
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0004d54c memsz 0x00067300 flags rwx
    LOAD off    0x0004f000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  0004f000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00046160  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000053bc  811463bc  811463bc  000473bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114b778  8114b778  0004c778  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00019db4  8114d56c  8114d56c  0004e56c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81167320  81167320  0004f000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  0004f000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0004f000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  0004f028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0006ecdf  00000000  00000000  00050d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0001643f  00000000  00000000  000bfa5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00021ce8  00000000  00000000  000d5e9e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009490  00000000  00000000  000f7b88  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c537  00000000  00000000  00101018  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0010d54f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013441c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  00134460  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00142635  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014263b  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00142647  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00142648  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00142649  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014264d  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00142651  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00142655  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00142660  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014266a  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00142674  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  00142685  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     002827ef  00000000  00000000  001426c4  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
811463bc l    d  .rodata	00000000 .rodata
8114b778 l    d  .rwdata	00000000 .rwdata
8114d56c l    d  .bss	00000000 .bss
81167320 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
00000000 l    df *ABS*	00000000 data_packet.c
81104d7c l     F .text	00000050 uliDpktReadReg
81104d28 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8114d588 l     O .bss	00000004 viCh1HoldContext
8114d58c l     O .bss	00000004 viCh2HoldContext
8114d590 l     O .bss	00000004 viCh3HoldContext
8114d594 l     O .bss	00000004 viCh4HoldContext
8114d598 l     O .bss	00000004 viCh5HoldContext
8114d59c l     O .bss	00000004 viCh6HoldContext
8114d5a0 l     O .bss	00000004 viCh7HoldContext
8114d5a4 l     O .bss	00000004 viCh8HoldContext
81105ebc l     F .text	00000054 vFeebWriteReg
81105f10 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8114d5a8 l     O .bss	00000004 viCh1HoldContext
8114d5ac l     O .bss	00000004 viCh2HoldContext
8114d5b0 l     O .bss	00000004 viCh3HoldContext
8114d5b4 l     O .bss	00000004 viCh4HoldContext
8114d5b8 l     O .bss	00000004 viCh5HoldContext
8114d5bc l     O .bss	00000004 viCh6HoldContext
8114d5c0 l     O .bss	00000004 viCh7HoldContext
8114d5c4 l     O .bss	00000004 viCh8HoldContext
81108c28 l     F .text	00000054 vRmapWriteReg
81108c7c l     F .text	00000050 uliRmapReadReg
81108ccc l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
81109600 l     F .text	00000050 uliSpwcReadReg
811095ac l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114d494 l     O .rwdata	00000001 ucIoValue
81109800 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110a0f0 l     F .text	0000013c msgdma_write_extended_descriptor
8110a22c l     F .text	00000164 msgdma_construct_extended_descriptor
8110a390 l     F .text	00000318 msgdma_descriptor_async_transfer
8110a6a8 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110b224 l     F .text	00000054 vRstcWriteReg
8110b278 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114d5cc l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8114d5d4 l     O .bss	00000004 pxNFee.5484
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8114d5d8 l     O .bss	00000004 xRAckLocal.5472
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114d5dc l     O .bss	00000004 bDmaBack.5474
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114d5e0 l     O .bss	00000004 xSAckLocal.5457
00000000 l    df *ABS*	00000000 parser_comm_task.c
8114d758 l     O .bss	0000004c PreParsedLocal.5546
8114d7a4 l     O .bss	00000054 xTcPusL.5545
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8114d7f8 l     O .bss	0000004c xPreParsedReader.5538
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8114d844 l     O .bss	00000054 xPusLocal.5731
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81149157 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114abb9 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114b778 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111d0fc l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114ad86 l     O .rodata	00000010 zeroes.4389
8114ad96 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114ada6 l     O .rodata	00000010 zeroes.4404
81121d74 l     F .text	000000c4 __sbprintf
8114adb6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114adce l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
81123a5c l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
811255ac l     F .text	00000008 __fp_unlock
811255c0 l     F .text	000001a4 __sinit.part.1
81125764 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114bfc4 l     O .rwdata	00000020 lc_ctype_charset
8114bfa4 l     O .rwdata	00000020 lc_message_charset
8114bfe4 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114ae0c l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
811285d4 l     F .text	0000006c sulp
8114af54 l     O .rodata	00000014 fpi.2737
8114af68 l     O .rodata	00000028 tinytens
8114af40 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114afa0 l     O .rodata	00000010 blanks.4332
8114af90 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112bc44 l     F .text	00000104 __sprint_r.part.0
8114afc0 l     O .rodata	00000010 blanks.4348
8114afb0 l     O .rodata	00000010 zeroes.4349
8112d1e0 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112d694 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
81131430 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81131574 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
811315a8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
8113182c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81131924 l       .text	00000000 tx_next_char
8113194c l       .text	00000000 end_tx
8113192c l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81132428 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
811326a4 l     F .text	00000044 alt_get_errno
811326e8 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81132910 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8114d4dc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81132eb0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114d4e8 l     O .rwdata	00000004 lockid
8114d6a0 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8114d4ec l     O .rwdata	00000004 lockid
8114d6a8 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8113493c l     F .text	00000050 OS_InitMisc
8113498c l     F .text	00000074 OS_InitRdyList
81134b10 l     F .text	000000ec OS_InitTCBList
81134854 l     F .text	000000e8 OS_InitEventList
81134a00 l     F .text	00000088 OS_InitTaskIdle
81134a88 l     F .text	00000088 OS_InitTaskStat
81134da0 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81136bb8 l     F .text	000000fc OS_FlagTaskRdy
81136968 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
811384a4 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113cd20 l     F .text	00000044 OSTmr_Lock
8113c7c0 l     F .text	00000074 OSTmr_Alloc
8113cd64 l     F .text	0000003c OSTmr_Unlock
8113cc24 l     F .text	000000fc OSTmr_Unlink
8113c834 l     F .text	000000a4 OSTmr_Free
8113cad4 l     F .text	00000150 OSTmr_Link
8113ca4c l     F .text	00000088 OSTmr_InitTask
8113cda0 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113ceb0 l     F .text	0000003c alt_dev_reg
8114c260 l     O .rwdata	0000106c jtag_uart_0
8114d2cc l     O .rwdata	000000d0 rs232_uart
8114d39c l     O .rwdata	00000064 dma_DDR_M1
8114d400 l     O .rwdata	00000064 dma_DDR_M2
8114d464 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81141740 l     F .text	000002bc altera_avalon_jtag_uart_irq
811419fc l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81142200 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
81142598 l     F .text	000000a4 altera_avalon_uart_irq
8114263c l     F .text	00000140 altera_avalon_uart_rxirq
8114277c l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81142984 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81142c38 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81142ebc l     F .text	00000044 alt_get_errno
81142f00 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81142f9c l     F .text	00000134 alt_msgdma_write_extended_descriptor
811430d0 l     F .text	0000018c alt_msgdma_irq
8114325c l     F .text	00000094 alt_msgdma_construct_standard_descriptor
811432f0 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8114344c l     F .text	00000340 alt_msgdma_descriptor_async_transfer
8114378c l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81143e94 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81143f40 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114510c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81145750 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8114d750 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8114d754 g     O .bss	00000004 alt_instruction_exception_handler
811062f8 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
8114ddc0 g     O .bss	00001000 vFeeTask0_stk
811171d0 g     F .text	0000004c vFailDeleteInitialization
8114d724 g     O .bss	00000004 aux_status_register
8114edc0 g     O .bss	00001000 vInAckHandlerTask_stk
81144ec8 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81106640 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110b8e8 g     F .text	0000004c vSyncInitIrq
81113284 g     F .text	00000284 vCheckRetransmission128
81127c58 g     F .text	0000007c _mprec_log10
8110baf0 g     F .text	00000040 bSyncSetMbt
81118794 g     F .text	00000054 vFailRequestDMAFromIRQ
811099e4 g     F .text	00000108 I2C_Read
8114d53a g     O .rwdata	00000002 OSTaskNameSize
8114d5e8 g     O .bss	00000004 xWaitSyncQFee
8114fdc0 g     O .bss	00000260 xBuffer64
81127d4c g     F .text	0000008c __any_on
81126720 g     F .text	0000005c _isatty_r
8114ae18 g     O .rodata	00000028 __mprec_tinytens
811065e8 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
81132548 g     F .text	0000015c alt_main
8111d020 g     F .text	000000c8 _puts_r
81105430 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
8114d6b0 g     O .bss	00000004 OSTmrFreeList
81167220 g     O .bss	00000100 alt_irq
81126890 g     F .text	00000068 _lseek_r
8111982c g     F .text	00000030 vChangeDefaultAutoResetSync
81137418 g     F .text	000000d4 OS_MemInit
81118740 g     F .text	00000054 vFailRequestDMA
81115cb4 g     F .text	000009d4 vLoadDefaultETHConf
8110e8bc g     F .text	0000014c bCheckInAck64
81150020 g     O .bss	00000150 xPus
8113bd00 g     F .text	00000068 OSTimeSet
81111f30 g     F .text	0000008c vPusType250run
81125964 g     F .text	000000ac __sflags
81118114 g     F .text	00000068 vCoudlNotCreateNFee2Task
81118500 g     F .text	0000004c vCouldNotGetMutexMebPus
81130590 g     F .text	00000088 .hidden __eqdf2
811125fc g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81119718 g     F .text	00000034 vLoadDefaultSyncSource
81116c68 g     F .text	0000004c vFailCreateMutexDMA
8113d3b0 g     F .text	000001ac Check_for_Master_Boot_Record
81160d94 g     O .bss	00000010 OSTmrWheelTbl
811066e0 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81143c54 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81150170 g     O .bss	00000010 xFeeQueueTBL3
811335a0 g     F .text	00000594 OSEventPendMulti
8114d5ec g     O .bss	00000004 xNfeeSchedule
81167320 g       *ABS*	00000000 __alt_heap_start
81145d88 g     F .text	0000002c OSTaskCreateHook
81141228 g     F .text	000001c4 alt_up_sd_card_fclose
8114d5f0 g     O .bss	00000004 xSemCountBuffer64
81106ae4 g     F .text	00000088 bRmapGetIrqControl
8111ce64 g     F .text	00000044 printf
8114d5c9 g     O .bss	00000001 SspdConfigControl
8110bf0c g     F .text	00000054 bSyncCtrReset
8114d512 g     O .rwdata	00000002 OSMboxEn
8111a350 g     F .text	000000a4 aatoh
81133b98 g     F .text	00000054 OSIntEnter
8112e300 g     F .text	000000a4 _wcrtomb_r
8110533c g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81117138 g     F .text	0000004c vFailReceiverCreate
8114d5f4 g     O .bss	00000004 xQMaskDataCtrl
81104e4c g     F .text	00000084 vFeebCh2HandleIrq
8111d588 g     F .text	00000064 __sseek
81125914 g     F .text	00000010 __sinit
8110ab64 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
811236dc g     F .text	00000148 __swbuf_r
81113a5c g     F .text	000004a4 bResourcesInitRTOS
8110914c g     F .text	000000f4 bSpwcGetLinkError
8114d522 g     O .rwdata	00000002 OSQEn
81106020 g     F .text	00000040 vRmapCh4HandleIrq
811267ac g     F .text	00000084 _setlocale_r
81150180 g     O .bss	00000010 SyncTBL2
8114d498 g     O .rwdata	00000004 LedsPainelControl
8114d8c0 g     O .bss	00000100 cDebugBuffer
8112576c g     F .text	00000070 __sfmoreglue
8112bc2c g     F .text	00000018 ungetc
8113325c g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
81145e08 g     F .text	00000028 OSTaskStatHook
81112458 g     F .text	00000088 vSendCmdQToNFeeCTRL
81119788 g     F .text	00000030 vChangeDefaultSyncSource
8114d6b4 g     O .bss	00000001 OSLockNesting
8114d6b8 g     O .bss	00000004 OSTmrSemSignal
81118b18 g     F .text	00000140 vNFeeStructureInit
8114d5f8 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
81128640 g     F .text	00001600 _strtod_r
8114d5fc g     O .bss	00000004 xSemCountSenderACK
8111a48c g     F .text	00000448 .hidden __divsf3
8114d748 g     O .bss	00000004 current_sector_modified
8114d560 g     O .rwdata	00000002 OSDataSize
8114d6bc g     O .bss	00000001 OSRunning
81109428 g     F .text	00000184 bSpwcInitCh
81132210 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81150190 g     O .bss	00001000 senderTask_stk
811075d8 g     F .text	00000094 bRmapGetMemConfigStat
8114d600 g     O .bss	00000004 fp
81151190 g     O .bss	00000030 xNfeeScheduleTBL
8110e774 g     F .text	00000148 bCheckInAck128
81126c20 g     F .text	0000015c memmove
81145e84 g     F .text	0000002c OSInitHookBegin
8110c3a8 g     F .text	00000074 bSyncCtrCh8OutEnable
8110d948 g     F .text	0000006c bEnableDbBuffer
8114d558 g     O .rwdata	00000002 OSTmrSize
811258fc g     F .text	00000018 _cleanup
81119c54 g     F .text	00000040 siCloseFile
81105d38 g     F .text	00000184 bFeebInitCh
81126d7c g     F .text	000000b0 _Balloc
811197b8 g     F .text	00000038 vLoadDefaultAutoResetSync
81106bf4 g     F .text	000000d8 bRmapSetCodecConfig
8113fe04 g     F .text	000000cc alt_up_sd_card_is_Present
81143b94 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114d574 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8113d0d8 g     F .text	00000054 Save_Modified_Sector
81105590 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
8114d6c0 g     O .bss	00000004 OSIdleCtr
8114d67c g     O .bss	00000001 alt_log_write_on_flag
81109650 g     F .text	0000003c bEnableIsoDrivers
81130618 g     F .text	000000dc .hidden __gtdf2
81145b18 g     F .text	0000002c altera_nios2_gen2_irq_init
81145c00 g       .text	00000000 OSStartTsk
8110bc64 g     F .text	00000070 bSyncSetNCycles
81135110 g     F .text	000002dc OS_TCBInit
8114d67f g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
811193a0 g     F .text	00000078 vInitSimucamBasicHW
811511c0 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110c2c0 g     F .text	00000074 bSyncCtrCh6OutEnable
81109d60 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8114d740 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8114d6c4 g     O .bss	00000002 OSTmrUsed
8114d604 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
81106a3c g     F .text	000000a8 bRmapSetIrqControl
811521c0 g     O .bss	00001000 vDataControlTask_stk
81104f54 g     F .text	00000084 vFeebCh4HandleIrq
8114d55e g     O .rwdata	00000002 OSTmrWheelTblSize
81119048 g     F .text	0000002c cFeeSpwChannelDisable
8114d4fe g     O .rwdata	00000002 OSEventSize
8114d6c6 g     O .bss	00000001 OSPrioHighRdy
8111c000 g     F .text	00000064 _fstat_r
81145db4 g     F .text	0000002c OSTaskDelHook
8114d658 g     O .bss	00000004 errno
8110c69c g     F .text	0000003c uliSyncGetCtr
8112366c g     F .text	0000001c __svfscanf
8111d4fc g     F .text	00000008 __seofread
81145be0 g       .text	00000000 OSStartHighRdy
81118a78 g     F .text	00000028 vEvtChangeFeeControllerMode
8110dabc g     F .text	00000968 vPrintConsoleNFee
8110f6b8 g     F .text	000000c8 bSendCmdQToNFeeInst
811060e0 g     F .text	00000040 vRmapCh7HandleIrq
8113a730 g     F .text	000001ec OSTaskCreateExt
81160d68 g     O .bss	00000011 alt_log_write_buf
811047b8 g     F .text	0000012c bDpktGetPacketConfig
81106870 g     F .text	00000050 uliRmapCh8WriteCmdAddress
811174f4 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112a770 g     F .text	00001244 ___svfiprintf_internal_r
8111118c g     F .text	00000364 bPreParserV2
81136498 g     F .text	00000068 OSFlagPendGetFlagsRdy
8114d53e g     O .rwdata	00000002 OSTaskStatStkSize
811355e4 g     F .text	00000310 OSFlagAccept
81138bc0 g     F .text	000000c0 OSQFlush
8113863c g     F .text	00000148 OSQAccept
8114d690 g     O .bss	00000004 alt_argv
81155490 g       *ABS*	00000000 _gp
81116e00 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81132d74 g     F .text	0000013c usleep
811403dc g     F .text	00000384 alt_up_sd_card_fopen
81119ac0 g     F .text	00000030 bSDcardIsPresent
811114f0 g     F .text	00000178 vSenderComTask
8113ff44 g     F .text	000000d8 alt_up_sd_card_find_first
81117694 g     F .text	00000068 vFailSendNack
8114d734 g     O .bss	00000004 command_argument_register
8113a238 g     F .text	000004f8 OSTaskChangePrio
81111af4 g     F .text	000000ac vPusMebInTaskConfigMode
81117e0c g     F .text	00000088 vCouldNotSendTMPusCommand
8114d6ac g     O .bss	00000004 alt_heapsem
81109ff8 g     F .text	00000080 bSetBoardLeds
811353ec g     F .text	000001f8 OSDebugInit
8113a91c g     F .text	0000034c OSTaskDel
811374ec g     F .text	000001ac OSMutexAccept
811531c0 g     O .bss	000002b4 xSimMeb
81119284 g     F .text	00000040 vSetTimeCode
8114473c g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8114d608 g     O .bss	00000004 xSemCountPreParsed
8114c044 g     O .rwdata	00000180 alt_fd_list
811054e0 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114c1e0 g     O .rwdata	0000001d alt_log_msg_alt_main
81160da4 g     O .bss	000006e0 OSFlagTbl
81106380 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81116f68 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
81106780 g     F .text	00000050 uliRmapCh5WriteCmdAddress
81119670 g     F .text	0000003c vLoadDefaultRTValue
8113461c g     F .text	000000c0 OS_EventTaskRemove
81153474 g     O .bss	00001000 vFeeTask5_stk
8114d67e g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
8113f658 g     F .text	00000134 find_first_empty_record_in_root_directory
811451fc g     F .text	00000098 alt_find_dev
8111cb4c g     F .text	00000150 memcpy
8112dfcc g     F .text	00000264 __hexnan
81104bb4 g     F .text	00000174 bDpktInitCh
81154474 g     O .bss	00000160 xBuffer32
8114d528 g     O .rwdata	00000002 OSRdyTblSize
81161484 g     O .bss	000001a0 OSTmrTbl
811255b4 g     F .text	0000000c _cleanup_r
8113116c g     F .text	000000e4 .hidden __floatsidf
811158dc g     F .text	000001a8 vSendPusTM64
8110ba60 g     F .text	0000004c ucSyncStatusErrorCode
81112568 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
81119144 g     F .text	00000034 cFeeRMAPLogDisable
8110fa78 g     F .text	00000df0 vParserCommTask
8114581c g     F .text	00000084 alt_io_redirect
811190d8 g     F .text	00000034 cFeeRMAPEchoingDisable
811306f4 g     F .text	000000f4 .hidden __ltdf2
8111844c g     F .text	0000004c vFailSendPUStoMebTask
81106590 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811057bc g     F .text	000000d4 bFeebSetIrqControl
81117c04 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
8114d60c g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
81144bc4 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81144f0c g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110bfb4 g     F .text	00000054 bSyncCtrErrInj
81144e6c g     F .text	0000005c alt_msgdma_register_callback
81116688 g     F .text	00000330 vShowEthConfig
81119418 g     F .text	00000030 bLogWriteSDCard
81117284 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
8111d0e8 g     F .text	00000014 puts
81119cd4 g     F .text	00000238 bInitSync
81145f2c g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110b770 g     F .text	0000014c vSyncHandleIrq
81133330 g     F .text	00000128 OSEventNameGet
811051a4 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8114d50c g     O .rwdata	00000002 OSFlagMax
811269ac g     F .text	000000e0 mbrtowc
8113f250 g     F .text	000001b4 find_first_empty_cluster
81112684 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110c24c g     F .text	00000074 bSyncCtrCh5OutEnable
8114d5d0 g     O .bss	00000001 vucN
811283ac g     F .text	00000074 __fpclassifyd
8110b9c0 g     F .text	00000054 bSyncStatusExtnIrq
81123688 g     F .text	00000054 _vfscanf_r
81137b6c g     F .text	000005a4 OSMutexPend
81127bac g     F .text	000000ac __ratio
8113fd40 g     F .text	000000c4 alt_up_sd_card_open_dev
81117e94 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81133bec g     F .text	00000100 OSIntExit
8110bb30 g     F .text	00000040 bSyncSetBt
8112d1c4 g     F .text	0000001c __vfiprintf_internal
8111854c g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
8114d546 g     O .rwdata	00000002 OSTCBSize
81105160 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
8114d6c7 g     O .bss	00000001 OSPrioCur
81141c70 g     F .text	000002c4 altera_avalon_jtag_uart_read
81144404 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111ce2c g     F .text	00000038 _printf_r
8112f134 g     F .text	00000064 .hidden __udivsi3
81131870 g     F .text	000000ac isatty
8114d5c8 g     O .bss	00000001 LedsBoardControl
8114d610 g     O .bss	00000004 xSemCountReceivedACK
8114d52c g     O .rwdata	00000002 OSStkWidth
8112677c g     F .text	00000030 iswspace
8114ae68 g     O .rodata	000000c8 __mprec_tens
8114d520 g     O .rwdata	00000002 OSPtrSize
811182b4 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
81126830 g     F .text	0000000c __locale_charset
8110c164 g     F .text	00000074 bSyncCtrCh3OutEnable
8112f324 g     F .text	000000c8 .hidden __lesf2
8114d500 g     O .rwdata	00000002 OSEventTblSize
8112e500 g     F .text	0000007c .hidden __fixunsdfsi
81145b44 g       .text	00000000 OSCtxSw
81109aec g     F .text	00000160 I2C_MultipleRead
811323b4 g     F .text	00000074 alt_log_system_clock
8114d664 g     O .bss	00000004 __malloc_top_pad
8114d6c8 g     O .bss	00000004 OSTCBList
8113c780 g     F .text	00000040 OSTmrSignal
8114d674 g     O .bss	00000004 alt_fd_list_lock
8112a29c g     F .text	0000001c strtoul
8114d4b0 g     O .rwdata	00000004 __mb_cur_max
81126860 g     F .text	0000000c _localeconv_r
8112a2b8 g     F .text	000002e0 _strtoull_r
8110b1b4 g     F .text	00000070 vRstcHoldDeviceReset
811271a0 g     F .text	00000044 __i2b
811260c4 g     F .text	000004c4 __sfvwrite_r
8113e530 g     F .text	000000c0 get_dir_divider_location
8110622c g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81161624 g     O .bss	00000c30 OSMemTbl
8114d6cc g     O .bss	00000001 OSTickStepState
81131fc4 g     F .text	00000060 alt_log_printf_proc
81104af0 g     F .text	000000c4 bDpktGetPixelDelay
811545d4 g     O .bss	00001800 vReceiverUartTask_stk
8111d2f4 g     F .text	0000005c _sbrk_r
8114d614 g     O .bss	00000004 xSemTimeoutChecker
8113e1f0 g     F .text	000000cc filename_to_upper_case
8114d680 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8114d524 g     O .rwdata	00000002 OSQMax
81140760 g     F .text	00000090 alt_up_sd_card_set_attributes
81137868 g     F .text	00000304 OSMutexDel
81162254 g     O .bss	00001000 OSTaskStatStk
81119af0 g     F .text	00000030 bSDcardFAT16Check
81137034 g     F .text	000000f8 OSMemNameGet
81116c08 g     F .text	00000060 vFailCreateMutexSResources
8113d55c g     F .text	00000284 Read_File_Record_At_Offset
81155dd4 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114d504 g     O .rwdata	00000002 OSFlagEn
81127dd8 g     F .text	00000068 _read_r
8114d54a g     O .rwdata	00000002 OSTimeTickHookEn
81136cb4 g     F .text	000000ac OS_FlagUnlink
81139088 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
8114d4cc g     O .rwdata	00000004 alt_max_fd
811179b0 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
81134c58 g     F .text	00000070 OS_MemCopy
81134cc8 g     F .text	000000d8 OS_Sched
8113edd4 g     F .text	0000047c find_file_in_directory
8112d370 g     F .text	000000f8 _fclose_r
81136f3c g     F .text	000000f8 OSMemGet
8113af60 g     F .text	000001bc OSTaskNameSet
8112557c g     F .text	00000030 fflush
8114d660 g     O .bss	00000004 __malloc_max_sbrked_mem
8114d6d0 g     O .bss	00000004 OSCtxSwCtr
81145e30 g     F .text	00000054 OSTimeTickHook
81155e14 g     O .bss	00001000 vOutAckHandlerTask_stk
811316a4 g     F .text	00000188 alt_irq_register
8114d50e g     O .rwdata	00000002 OSFlagNameSize
8111b61c g     F .text	00000118 .hidden __extendsfdf2
811346dc g     F .text	00000108 OS_EventTaskRemoveMulti
81117fd4 g     F .text	00000070 vFailCreateNFEESyncQueue
8113fed0 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110987c g     F .text	00000088 I2C_TestAdress
8112f3ec g     F .text	000008b4 .hidden __adddf3
81160d7c g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8112f1f0 g     F .text	00000078 .hidden __nesf2
811061e8 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811344c4 g     F .text	00000158 OS_EventTaskWaitMulti
81156e14 g     O .bss	00000010 SyncTBL4
81127944 g     F .text	00000114 __b2d
8114413c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114d526 g     O .rwdata	00000002 OSQSize
8112eafc g     F .text	00000540 .hidden __umoddi3
8113246c g     F .text	000000dc lseek
81139b78 g     F .text	00000214 OSSemPend
81118498 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81106d58 g     F .text	00000160 bRmapGetCodecStatus
81109240 g     F .text	000000d0 bSpwcGetLinkStatus
81105b18 g     F .text	00000088 bFeebGetWindowing
8114d4a0 g     O .rwdata	00000004 _global_impure_ptr
8110b724 g     F .text	0000004c bSSDisplayUpdate
8113e894 g     F .text	00000540 get_home_directory_cluster_for_file
81127e40 g     F .text	0000056c _realloc_r
8114d510 g     O .rwdata	00000002 OSLowestPrio
81167320 g       *ABS*	00000000 __bss_end
81145658 g     F .text	000000f8 alt_iic_isr_register
81145f00 g     F .text	0000002c OSTCBInitHook
8114d556 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81132c64 g     F .text	00000110 alt_tick
811068c0 g     F .text	0000017c vRmapInitIrq
81116f00 g     F .text	00000068 vFailGetMutexSenderTask
8110b0d4 g     F .text	0000006c vRstcSimucamReset
8110da18 g     F .text	000000a4 bSendRequestNFeeCtrl
8114afd0 g     O .rodata	00000100 __hexdig
81144cb8 g     F .text	000001b4 alt_msgdma_init
8112e57c g     F .text	00000580 .hidden __udivdi3
81110e74 g     F .text	0000017c setPreAckSenderFreePos
8112d5e8 g     F .text	00000024 _fputwc_r
8114d4f8 g     O .rwdata	00000002 OSEventEn
8114ae40 g     O .rodata	00000028 __mprec_bigtens
81126f7c g     F .text	0000010c __s2b
8114d552 g     O .rwdata	00000002 OSTmrCfgNameSize
81156e24 g     O .bss	00000010 xFeeQueueTBL4
8110bbf0 g     F .text	00000074 bSyncSetPolarity
81113508 g     F .text	0000028c vCheckRetransmission64
81131250 g     F .text	000000b0 .hidden __floatunsidf
8114d684 g     O .bss	00000004 alt_system_clock_in_sec
811321bc g     F .text	00000054 alt_log_jtag_uart_startup_info
8111748c g     F .text	00000068 vFailFoundBufferRetransmission
8112767c g     F .text	00000060 __mcmp
8114d74c g     O .bss	00000004 current_sector_index
81142430 g     F .text	00000168 altera_avalon_uart_init
81144f94 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
8110409c g     F .text	00000414 bSdmaDmaM2Transfer
811192c4 g     F .text	00000034 vResetTimeCode
8111901c g     F .text	0000002c cFeeSpwChannelEnable
81125934 g     F .text	00000018 __fp_lock_all
811188d4 g     F .text	0000004c vFailSendMsgDataCTRL
81145604 g     F .text	00000054 alt_ic_irq_enabled
81109904 g     F .text	000000e0 I2C_Write
81106430 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8114d6d4 g     O .bss	00000002 OSTmrFree
81136ad0 g     F .text	000000e8 OS_FlagInit
81132bc0 g     F .text	000000a4 alt_alarm_stop
8111d95c g     F .text	0000001c strtol
8114d67d g     O .bss	00000001 alt_log_sys_clk_on_flag
8113bf2c g     F .text	00000140 OSTmrDel
8113d2c8 g     F .text	000000e8 mark_cluster
8114d534 g     O .rwdata	00000002 OSTaskIdleStkSize
8114d678 g     O .bss	00000004 alt_irq_active
81139798 g     F .text	000000b8 OSSemAccept
8111bb98 g     F .text	0000044c _fseeko_r
81114394 g     F .text	00000260 vFillMemmoryPattern
8111d6d8 g     F .text	00000044 strnlen
81137248 g     F .text	000000e0 OSMemPut
81136d60 g     F .text	000001dc OSMemCreate
8114d6d8 g     O .bss	00000004 OSIdleCtrMax
81115a84 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81131a0c g     F .text	000005b8 alt_log_private_printf
8114c01c g     O .rwdata	00000028 alt_dev_null
81143d4c g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110bbb0 g     F .text	00000040 bSyncSetOst
8114d548 g     O .rwdata	00000002 OSTicksPerSec
8114c1c4 g     O .rwdata	00000019 alt_log_msg_bss
8113f78c g     F .text	00000194 convert_filename_to_name_extension
8110766c g     F .text	00000c4c bRmapSetRmapMemHKArea
81111668 g     F .text	00000330 vSimMebTask
81109c4c g     F .text	00000094 i2c_start
81145b44 g       .text	00000000 OSIntCtxSw
811187e8 g     F .text	00000054 vFailSendMsgSync
8110c1d8 g     F .text	00000074 bSyncCtrCh4OutEnable
81144b30 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
8113154c g     F .text	00000028 alt_dcache_flush_all
81127088 g     F .text	00000068 __hi0bits
81111fbc g     F .text	00000114 vPusType251run
811067d0 g     F .text	00000050 uliRmapCh6WriteCmdAddress
811196ac g     F .text	0000003c vChangeRTValue
8114d720 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81113100 g     F .text	00000184 vCheck
81118ac8 g     F .text	00000050 vNFeeNotInUse
811310ec g     F .text	00000080 .hidden __fixdfsi
81105c28 g     F .text	00000088 bFeebStopCh
8110f0d8 g     F .text	000003ec vNFeeControlTask
81156e34 g     O .bss	00001000 vInitialTask_stk
8114d618 g     O .bss	00000002 usiIdCMD
81157e34 g     O .bss	00000010 SyncTBL3
8110beb8 g     F .text	00000054 bSyncCtrStart
8113f404 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81129c40 g     F .text	00000018 strtod
81105cb0 g     F .text	00000088 bFeebClrCh
8114d6dc g     O .bss	00000004 OSTCBFreeList
81106538 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
81139d8c g     F .text	00000174 OSSemPendAbort
811170a0 g     F .text	0000004c vFailGetMacRTC
81106730 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
81117918 g     F .text	0000004c vFailCreateTimerRetransmisison
81117424 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
8111494c g     F .text	000002f0 bSendUART128v2
811194e0 g     F .text	000000ec vSimucamStructureInit
8114d4c4 g     O .rwdata	00000008 alt_dev_list
8111bac8 g     F .text	0000004c _fputc_r
81132ef4 g     F .text	0000010c write
8111cea8 g     F .text	000000a8 _putc_r
8114d744 g     O .bss	00000004 device_pointer
8114d54c g     O .rwdata	00000002 OSVersionNbr
8112f268 g     F .text	000000bc .hidden __gtsf2
811189b8 g     F .text	0000004c vFailFlushMEBQueue
81110868 g     F .text	00000118 getPreParsedPacket
8110d8e8 g     F .text	00000060 bEnableSPWChannel
811315ec g     F .text	000000b8 fstat
8111932c g     F .text	00000040 vChangeIdNFEEMaster
8111ba9c g     F .text	0000002c fprintf
8111910c g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105538 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81117a64 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111a030 g     F .text	00000058 _reg_write
8111936c g     F .text	00000034 vChangeDefaultIdNFEEMaster
811306f4 g     F .text	000000f4 .hidden __ledf2
81106060 g     F .text	00000040 vRmapCh5HandleIrq
8110d7ec g     F .text	0000004c bDisableRmapIRQ
81157e44 g     O .bss	00001000 vStackMonitor_stk
81117da4 g     F .text	00000068 vCouldNotSendLog
8113c1ac g     F .text	000001b8 OSTmrRemainGet
8114d4f4 g     O .rwdata	00000004 OSEndiannessTest
8110b2c8 g     F .text	00000058 v_spi_start
811273e4 g     F .text	00000148 __pow5mult
81106690 g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112bd60 g     F .text	00001464 ___vfiprintf_internal_r
8114d670 g     O .bss	00000004 __nlocale_changed
8112f198 g     F .text	00000058 .hidden __umodsi3
8110c008 g     F .text	00000074 bSyncCtrSyncOutEnable
81119b20 g     F .text	000000f8 bInitializeSDCard
81117834 g     F .text	0000004c vFailParserCommTaskCreate
81117d3c g     F .text	00000068 vCouldNotSendReset
8111d394 g     F .text	00000038 _scanf_r
811178cc g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114d506 g     O .rwdata	00000002 OSFlagGrpSize
81111ba0 g     F .text	0000008c vPusType250conf
81158e44 g     O .bss	00000058 xInUseRetrans
8110b970 g     F .text	00000050 bSyncIrqFlagSync
8114419c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113c364 g     F .text	000000ec OSTmrStateGet
81167320 g       *ABS*	00000000 end
8110505c g     F .text	00000084 vFeebCh6HandleIrq
811145f4 g     F .text	00000260 vPrintMemmoryPattern
811175c4 g     F .text	00000068 vNoContentInPreParsedBuffer
8111bfe4 g     F .text	0000001c fseeko
81110980 g     F .text	00000168 bSendMessagePUStoMebTask
81117f64 g     F .text	00000070 vFailCreateNFEEQueue
8111b94c g     F .text	0000000c _atoi_r
81142c7c g     F .text	00000240 altera_avalon_uart_write
81131950 g     F .text	00000054 alt_log_txchar
8111bb7c g     F .text	0000001c fseek
811148bc g     F .text	00000090 vCCDChangeValues
81141570 g     F .text	000001d0 altera_avalon_jtag_uart_init
81134f58 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81116d00 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81142284 g     F .text	00000084 alt_avalon_timer_sc_init
81105a70 g     F .text	000000a8 bFeebSetWindowing
81142370 g     F .text	00000068 altera_avalon_uart_write_fd
8111b8dc g     F .text	00000064 .hidden __clzsi2
811423d8 g     F .text	00000058 altera_avalon_uart_close_fd
81158e9c g     O .bss	00000020 xMebQTBL
81141f34 g     F .text	000002cc altera_avalon_jtag_uart_write
8113c8d8 g     F .text	00000174 OSTmr_Init
81158ebc g     O .bss	00000348 xBuffer128
81125924 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
81126b3c g     F .text	000000e4 memchr
81134bfc g     F .text	0000005c OS_MemClr
8111fb58 g     F .text	00002200 ___vfprintf_internal_r
81145c24 g     F .text	00000164 OSTaskStkInit
8111d3cc g     F .text	00000060 _sprintf_r
81107304 g     F .text	000002d4 bRmapGetMemConfigArea
8114d61a g     O .bss	00000001 SemCount32
81125dac g     F .text	00000318 _free_r
811458a0 g     F .text	00000234 alt_printf
8111588c g     F .text	00000050 vTimeoutCheck
8111a0e0 g     F .text	000001fc _print_codec_status
8112683c g     F .text	00000010 __locale_mb_cur_max
8113420c g     F .text	000001a0 OS_EventTaskRdy
81106b6c g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
81146178 g     F .text	00000188 __call_exitprocs
8110f58c g     F .text	0000012c vPerformActionNFCRunning
8114d6e0 g     O .bss	00000001 OSCPUUsage
811181e4 g     F .text	00000068 vCoudlNotCreateNFee4Task
8114d66c g     O .bss	00000004 __mlocale_changed
8110f4c4 g     F .text	000000c8 vPerformActionNFCConfig
8110bf60 g     F .text	00000054 bSyncCtrOneShot
8114d4a8 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110c6d8 g     F .text	0000003c uliSyncReadStatus
8114d698 g     O .bss	00000004 _alt_tick_rate
81138c80 g     F .text	00000294 OSQPend
81129d60 g     F .text	000002e8 _strtoll_r
81159204 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8113b850 g     F .text	0000010c OSTimeDly
81111e84 g     F .text	000000ac vPusMebInTaskRunningMode
8110b934 g     F .text	0000003c vSyncIrqFlagClrSync
8112752c g     F .text	00000150 __lshift
8110f780 g     F .text	000002f8 vOutAckHandlerTask
81143bf4 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8114d69c g     O .bss	00000004 _alt_nticks
81132954 g     F .text	00000104 read
8113cf2c g     F .text	000000f0 alt_sys_init
8111acd8 g     F .text	0000012c .hidden __floatsisf
811061a4 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112a598 g     F .text	000001d8 __ssprint_r
8111cdc4 g     F .text	00000068 _open_r
81119fa8 g     F .text	00000088 bTestSimucamCriticalHW
811059c4 g     F .text	000000ac bFeebGetBuffersStatus
811169b8 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
8114d6e1 g     O .bss	00000001 OSTaskCtr
8113191c g       .text	00000000 tx_log_str
81111998 g     F .text	0000015c vPusMebTask
8111583c g     F .text	00000050 siPosStr
811124e0 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8112e230 g     F .text	000000d0 strncmp
8110c714 g     F .text	0000005c bSyncWriteReg
811064e0 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113b95c g     F .text	00000164 OSTimeDlyHMSM
811271e4 g     F .text	00000200 __multiply
81141b08 g     F .text	00000070 altera_avalon_jtag_uart_close
8110b498 g     F .text	00000058 v_spi_end
81119c94 g     F .text	00000040 cGetNextChar
8114608c g     F .text	000000ec strncpy
8114d898 g     O .bss	00000028 __malloc_current_mallinfo
8114d4fa g     O .rwdata	00000002 OSEventMax
8112f1f0 g     F .text	00000078 .hidden __eqsf2
81127a58 g     F .text	00000154 __d2b
81139f00 g     F .text	00000118 OSSemPost
8110522c g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
811196e8 g     F .text	00000030 vChangeDefaultRTValue
81105120 g     F .text	00000040 vFeebCh8HandleIrq
8114d71c g     O .bss	00000004 initialized
811156ec g     F .text	00000100 vSendLog
81133d80 g     F .text	000000e4 OSSchedUnlock
8110b4f0 g     F .text	00000164 RTCC_SPI_R_MAC
8114d4d8 g     O .rwdata	00000004 alt_log_boot_on_flag
811413ec g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112a048 g     F .text	00000254 _strtoul_r
81159244 g     O .bss	00000010 xFeeQueueTBL5
811453a4 g     F .text	000000e4 alt_get_fd
8114d6e4 g     O .bss	00000004 OSMemFreeList
81133edc g     F .text	000000b8 OSStatInit
81119f74 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
81166cb8 g     O .bss	00000014 search_data
81108f34 g     F .text	00000134 bSpwcSetLink
81131300 g     F .text	00000130 alt_busy_sleep
8113689c g     F .text	000000cc OSFlagQuery
8110c07c g     F .text	00000074 bSyncCtrCh1OutEnable
8114d530 g     O .rwdata	00000002 OSTaskCreateExtEn
8111a2dc g     F .text	00000074 _split_codec_status
81123a00 g     F .text	0000005c _close_r
8111762c g     F .text	00000068 vCouldNotSendEthConfUART
8110eb54 g     F .text	00000584 vInitialTask
811320c4 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
811440dc g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81146010 g     F .text	0000007c memcmp
811341e4 g     F .text	00000028 OS_Dummy
811414bc g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81167320 g       *ABS*	00000000 __alt_stack_base
81141514 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105270 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111c064 g     F .text	000000d4 _fwrite_r
81112814 g     F .text	000000a4 vReleaseSyncMessages
811441fc g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105380 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
811238a4 g     F .text	0000015c __swsetup_r
81163254 g     O .bss	00000300 OSQTbl
8111861c g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81160d4c g     O .bss	0000001c xConfEth
8112fca0 g     F .text	000008f0 .hidden __divdf3
8111974c g     F .text	0000003c vChangeSyncSource
811257dc g     F .text	00000120 __sfp
81166ccc g     O .bss	00000054 boot_sector_data
811185b4 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
811093a0 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
81127cd4 g     F .text	00000078 __copybits
8114bb9c g     O .rwdata	00000408 __malloc_av_
81125930 g     F .text	00000004 __sinit_lock_release
8114d56c g     O .bss	00000004 uliInitialState
81109ce0 g     F .text	00000080 i2c_stop
8111a3f4 g     F .text	00000064 Verif_Error
8111a458 g     F .text	00000034 toInt
81116e4c g     F .text	0000004c vFailSendPreAckSenderSemaphore
8114d6e8 g     O .bss	00000004 OSTCBHighRdy
8111aefc g     F .text	00000720 .hidden __muldf3
8111d4a0 g     F .text	0000005c __sread
81125c44 g     F .text	0000003c fread
8114d6ec g     O .bss	00000004 OSQFreeList
81145294 g     F .text	00000110 alt_find_file
81145150 g     F .text	000000ac alt_dev_llist_insert
81133134 g     F .text	00000128 __malloc_lock
8111ba6c g     F .text	00000030 _fprintf_r
81132ac4 g     F .text	000000fc sbrk
81118f98 g     F .text	0000002c vFeeSpwRMAPLoadDefault
811173bc g     F .text	00000068 vFailGetCountSemaphorexBuffer64
8111d978 g     F .text	000021e0 ___svfprintf_internal_r
81115c2c g     F .text	00000088 vTMPusTestConnection
8114d61c g     O .bss	00000004 xMebQ
81133458 g     F .text	00000148 OSEventNameSet
81125518 g     F .text	00000064 _fflush_r
8112d2a4 g     F .text	000000cc _calloc_r
8114d6f0 g     O .bss	00000001 OSRdyGrp
81118888 g     F .text	0000004c vFailSendMsgFeeCTRL
8110baac g     F .text	00000044 ucSyncStatusCycleNumber
81106ccc g     F .text	0000008c bRmapGetCodecConfig
8113c450 g     F .text	00000148 OSTmrStart
81104fd8 g     F .text	00000084 vFeebCh5HandleIrq
8111ba54 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8114d56c g       *ABS*	00000000 __bss_start
8111cc9c g     F .text	00000128 memset
81110d38 g     F .text	0000013c setPreParsedFreePos
8110d4e8 g     F .text	00000174 vQCmdFEEinStandBy
81144c58 g     F .text	00000060 alt_msgdma_open
811198a4 g     F .text	0000021c pattern_createPattern
81114214 g     F .text	00000180 main
81116fd0 g     F .text	00000068 vFailGetMutexReceiverTask
81159254 g     O .bss	00001000 vNFeeControlTask_stk
8110633c g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
81119604 g     F .text	0000003c vChangeEPValue
81106488 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
8114d694 g     O .bss	00000004 alt_envp
81118920 g     F .text	0000004c vFailFlushQueue
8114d65c g     O .bss	00000004 __malloc_max_total_mem
811444fc g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
81116a5c g     F .text	0000005c ucCrc8wInit
81117964 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81141454 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
81109e98 g     F .text	00000160 i2c_read
8115a254 g     O .bss	00000010 SyncTBL5
81123824 g     F .text	00000018 __swbuf
8114b2d0 g     O .rodata	00000100 OSUnMapTbl
8112f324 g     F .text	000000c8 .hidden __ltsf2
811407f0 g     F .text	00000090 alt_up_sd_card_get_attributes
81125a10 g     F .text	00000234 _fread_r
81116e98 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110968c g     F .text	0000003c bDisableIsoDrivers
8114d52a g     O .rwdata	00000002 OSSemEn
8113d01c g     F .text	000000bc Write_Sector_Data
81140c00 g     F .text	00000628 alt_up_sd_card_write
8114d620 g     O .bss	00000004 xFeeQ
81136500 g     F .text	0000039c OSFlagPost
8111d5ec g     F .text	00000008 __sclose
81117c6c g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112d468 g     F .text	00000014 fclose
811343ac g     F .text	00000118 OS_EventTaskWait
81117b34 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111d71c g     F .text	00000240 _strtol_r
8111b734 g     F .text	000001a8 .hidden __truncdfsf2
8115a264 g     O .bss	00000010 xFeeQueueTBL2
8113503c g     F .text	000000d4 OS_TaskStatStkChk
8113ac68 g     F .text	00000158 OSTaskDelReq
811048e4 g     F .text	000000c4 bDpktGetPacketHeader
81105f60 g     F .text	00000040 vRmapCh1HandleIrq
81123c64 g     F .text	00001690 _dtoa_r
81144818 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111c338 g     F .text	00000814 _malloc_r
8112e46c g     F .text	00000030 __ascii_wctomb
81137698 g     F .text	000001d0 OSMutexCreate
81117acc g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
8110ea08 g     F .text	0000014c bCheckInAck32
8114d4d0 g     O .rwdata	00000004 alt_errno
81144344 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81133e64 g     F .text	00000078 OSStart
81109068 g     F .text	000000e4 bSpwcGetLink
8110abec g     F .text	000004e8 POWER_SPI_RW
8112b9b4 g     F .text	000000dc __submore
81132024 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
811330cc g     F .text	00000068 __env_unlock
811180ac g     F .text	00000068 vCoudlNotCreateNFee1Task
81126588 g     F .text	000000cc _fwalk
8113b11c g     F .text	000001dc OSTaskResume
81137328 g     F .text	000000f0 OSMemQuery
8114d53c g     O .rwdata	00000002 OSTaskStatEn
81167320 g       *ABS*	00000000 __alt_stack_limit
8114d584 g     O .bss	00000004 ECommSpwCh
811197f0 g     F .text	0000003c vChangeAutoResetSync
81126ad8 g     F .text	00000064 _mbtowc_r
8110e424 g     F .text	00000350 vInAckHandlerTaskV2
8114d516 g     O .rwdata	00000002 OSMemMax
811391f8 g     F .text	00000178 OSQPostFront
8111cf50 g     F .text	000000d0 putc
8112f03c g     F .text	00000084 .hidden __divsi3
8114d6f1 g     O .bss	00000006 OSRdyTbl
8114d4f0 g     O .rwdata	00000002 OSDebugEn
8114c234 g     O .rwdata	0000002a alt_log_msg_cache
81125c80 g     F .text	0000012c _malloc_trim_r
81108a84 g     F .text	000001a4 bRmapInitCh
8114d650 g     O .bss	00000008 xSdHandle
8111a8d4 g     F .text	00000404 .hidden __mulsf3
8114d508 g     O .rwdata	00000002 OSFlagNodeSize
8114d570 g     O .bss	00000004 pnt_memory
8111985c g     F .text	00000048 vSyncReset
8110bb70 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8114d728 g     O .bss	00000004 status_register
8114d550 g     O .rwdata	00000002 OSTmrCfgMax
8110c504 g     F .text	00000074 bSyncIrqFlagClrError
811176fc g     F .text	00000068 vFailSetPreAckSenderBuffer
811284f8 g     F .text	000000dc strcmp
8114d730 g     O .bss	00000004 command_register
81138784 g     F .text	000001b4 OSQCreate
8113adc0 g     F .text	000001a0 OSTaskNameGet
8115a274 g     O .bss	00001000 vFeeTask4_stk
8115b274 g     O .bss	00000018 xReceivedACK
81139370 g     F .text	00000214 OSQPostOpt
81133f94 g     F .text	00000228 OSTimeTick
8114d538 g     O .rwdata	00000002 OSTaskMax
81139850 g     F .text	000000e0 OSSemCreate
8114d55c g     O .rwdata	00000002 OSTmrWheelSize
81117efc g     F .text	00000068 vFailCreateScheduleQueue
8111a088 g     F .text	00000058 _reg_read
81138330 g     F .text	00000174 OSMutexQuery
81130590 g     F .text	00000088 .hidden __nedf2
8114d532 g     O .rwdata	00000002 OSTaskDelEn
811195cc g     F .text	00000038 vLoadDefaultEPValue
8115b28c g     O .bss	00001000 vFeeTask1_stk
8110c334 g     F .text	00000074 bSyncCtrCh7OutEnable
8113a018 g     F .text	00000118 OSSemQuery
81138938 g     F .text	00000288 OSQDel
81138f14 g     F .text	00000174 OSQPendAbort
8114d624 g     O .bss	00000004 xMutexPreParsed
8113ceec g     F .text	00000040 alt_irq_init
81132a58 g     F .text	0000006c alt_release_fd
8113d20c g     F .text	000000bc get_cluster_flag
8110c578 g     F .text	00000074 bSyncIrqFlagClrBlank
81144f50 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110b8bc g     F .text	0000002c vSyncClearCounter
8114c200 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111d42c g     F .text	00000074 sprintf
8114a9b8 g     O .rodata	00000100 .hidden __clz_tab
8113d7e0 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
81117038 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8114d668 g     O .bss	00000004 _PathLocale
8110c644 g     F .text	00000058 bSyncIrqFlagBlank
8110aaa4 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113c598 g     F .text	000001e8 OSTmrStop
811157ec g     F .text	00000050 usiGetIdCMD
8110c770 g     F .text	00000058 uliSyncReadReg
81129c58 g     F .text	00000108 strtof
81104ed0 g     F .text	00000084 vFeebCh3HandleIrq
8112f268 g     F .text	000000bc .hidden __gesf2
8111d5f4 g     F .text	0000004c strcspn
8112383c g     F .text	00000068 _write_r
8110b140 g     F .text	00000074 vRstcReleaseDeviceReset
81117880 g     F .text	0000004c vFailInAckHandlerTaskCreate
81133cec g     F .text	00000094 OSSchedLock
8111817c g     F .text	00000068 vCoudlNotCreateNFee3Task
8112686c g     F .text	00000018 setlocale
811442a4 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81163554 g     O .bss	00000800 OSTmrTaskStk
8111d350 g     F .text	00000044 scanf
811183ec g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
811358f4 g     F .text	00000110 OSFlagCreate
8113da74 g     F .text	00000688 Check_for_DOS_FAT
8111270c g     F .text	00000064 vMebInit
8113f920 g     F .text	000002d0 create_file
811284f0 g     F .text	00000008 nanf
8114d4a4 g     O .rwdata	00000004 _impure_ptr
8114d72c g     O .bss	00000004 CSD_register_w0
8114d68c g     O .bss	00000004 alt_argc
81117354 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
811252f4 g     F .text	00000224 __sflush_r
811268f8 g     F .text	000000b4 _mbrtowc_r
81109310 g     F .text	00000090 bSpwcGetTimecode
81126858 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
8114d57c g     O .bss	00000004 ESdmaBufferSide
8114d502 g     O .rwdata	00000002 OSEventMultiEn
8111bb78 g     F .text	00000004 _fseek_r
8115c28c g     O .bss	00001800 vParserCommTask_stk
81116b98 g     F .text	00000070 printErrorTask
81119640 g     F .text	00000030 vChangeDefaultEPValue
81113794 g     F .text	000002c8 vCheckRetransmission32
8113bd68 g     F .text	000001c4 OSTmrCreate
811128b8 g     F .text	000007dc vStackMonitor
8111d118 g     F .text	000001dc __srefill_r
811096c8 g     F .text	0000003c bEnableLvdsBoard
8114d628 g     O .bss	00000004 xMutexBuffer32
81105fa0 g     F .text	00000040 vRmapCh2HandleIrq
81135a04 g     F .text	00000250 OSFlagDel
8114d6f8 g     O .bss	00000004 OSEventFreeList
81109740 g     F .text	000000c0 bSetPreEmphasys
8110d378 g     F .text	00000170 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81126a8c g     F .text	0000004c __ascii_mbtowc
8110be40 g     F .text	00000078 bSyncCtrExtnIrq
811278e0 g     F .text	00000064 __ulp
81119178 g     F .text	0000010c vNFeeControlInit
81112770 g     F .text	000000a4 vSwapMemmory
81135ed8 g     F .text	000005c0 OSFlagPend
8114d54e g     O .rwdata	00000002 OSTmrEn
8112594c g     F .text	00000018 __fp_unlock_all
8115da8c g     O .bss	00000010 xDma
8111bb14 g     F .text	00000064 fputc
8110d838 g     F .text	00000050 bEnableRmapIRQ
81114f34 g     F .text	000002f8 bSendUART32v2
81110ff0 g     F .text	0000019c setPreAckReceiverFreePos
8110be00 g     F .text	00000040 bSyncErrInj
8114d4bc g     O .rwdata	00000008 alt_fs_list
8115da9c g     O .bss	00001000 vSimMebTask_stk
81118384 g     F .text	00000068 vCoudlNotCreateMebTask
8113e2bc g     F .text	00000274 check_file_name_for_FAT16_compliance
8115ea9c g     O .bss	00001000 vFeeTask3_stk
8113c06c g     F .text	00000140 OSTmrNameGet
8114d9c0 g     O .bss	00000400 xSZData
8110d65c g     F .text	00000190 vQCmdFEEinFullPattern
81134e1c g     F .text	0000007c OS_StrCopy
8114d738 g     O .bss	00000004 buffer_memory
8111755c g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
81119448 g     F .text	00000098 vLogWriteNUC
8114d518 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110c490 g     F .text	00000074 bSyncIrqEnableBlank
81145eb0 g     F .text	00000028 OSInitHookEnd
81118c58 g     F .text	00000340 vUpdateMemMapFEE
811177cc g     F .text	00000068 vFailSetPreAckReceiverBuffer
811055e8 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
8114d544 g     O .rwdata	00000002 OSTCBPrioTblMax
81126884 g     F .text	0000000c localeconv
8111831c g     F .text	00000068 vCoudlNotCreateDataControllerTask
8114d62c g     O .bss	00000004 xTimerRetransmission
81110ae8 g     F .text	00000250 vReceiverUartTask
8114d688 g     O .bss	00000004 alt_log_sys_clk_count
8114d540 g     O .rwdata	00000002 OSTaskStatStkChkEn
81132274 g     F .text	00000140 alt_log_write
8115fa9c g     O .bss	00001000 vFeeTask2_stk
8114d630 g     O .bss	00000004 xMutexBuffer128
81104dcc g     F .text	00000080 vFeebCh1HandleIrq
81119f0c g     F .text	00000038 bStartSync
811050e0 g     F .text	00000040 vFeebCh7HandleIrq
81119f44 g     F .text	00000030 bStopSync
81145488 g     F .text	00000058 alt_ic_isr_register
8114d514 g     O .rwdata	00000002 OSMemEn
81105fe0 g     F .text	00000040 vRmapCh3HandleIrq
8114d490 g     O .rwdata	00000004 alt_stack_limit_value
811120d0 g     F .text	00000388 vPusType252run
8111883c g     F .text	0000004c vFailSendMsgMasterSyncMeb
8111c138 g     F .text	0000003c fwrite
8114d73c g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8114d51e g     O .rwdata	00000002 OSMutexEn
81118684 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8114d56c g       *ABS*	00000000 _edata
81142308 g     F .text	00000068 altera_avalon_uart_read_fd
811192f8 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81167320 g       *ABS*	00000000 _end
81166d20 g     O .bss	00000500 active_files
8114d6fc g     O .bss	00000001 OSIntNesting
811170ec g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
81119074 g     F .text	0000002c cFeeRMAPDump
8114d634 g     O .bss	00000004 xSemCountBuffer32
8112d47c g     F .text	0000016c __fputwc
8114d638 g     O .bss	00000004 xQMaskFeeCtrl
81118fc4 g     F .text	0000002c vFeeSpwRMAPChangeConfig
811235fc g     F .text	00000070 vfscanf
8113fbf0 g     F .text	00000150 copy_file_record_name_to_string
81141b78 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113bac0 g     F .text	000001dc OSTimeDlyResume
8113e0fc g     F .text	000000f4 Look_for_FAT16
8110d888 g     F .text	00000060 bDisableSPWChannel
81135d84 g     F .text	00000154 OSFlagNameSet
8110d9b4 g     F .text	00000064 bDisAndClrDbBuffer
8114d63c g     O .bss	00000004 xMutexBuffer64
81106eb8 g     F .text	00000160 bRmapGetCodecError
8113b2f8 g     F .text	000001c8 OSTaskStkChk
81145570 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000040c bSdmaDmaM1Transfer
8114d51a g     O .rwdata	00000002 OSMemSize
81111c80 g     F .text	00000204 vPusType252conf
8111721c g     F .text	00000068 vFailSetCountSemaphorexBuffer32
8111d504 g     F .text	00000084 __swrite
8114d4ac g     O .rwdata	00000004 __malloc_trim_threshold
8112684c g     F .text	0000000c __locale_msgcharset
81160a9c g     O .bss	00000010 xFeeQueueTBL1
8114d700 g     O .bss	00000004 OSTCBCur
81117b9c g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110aba8 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81145fd0 g     F .text	00000040 exit
81138110 g     F .text	00000220 OSMutexPost
8110c5ec g     F .text	00000058 bSyncIrqFlagError
8114001c g     F .text	000003c0 alt_up_sd_card_find_next
8114d51c g     O .rwdata	00000002 OSMemTblSize
81126654 g     F .text	000000cc _fwalk_reent
8114469c g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111ae04 g     F .text	000000f8 .hidden __floatunsisf
811276dc g     F .text	00000204 __mdiff
81118044 g     F .text	00000068 vCoudlNotCreateNFee0Task
81105640 g     F .text	0000017c vFeebInitIrq
8110458c g     F .text	0000022c bDpktSetPacketConfig
81117184 g     F .text	0000004c vFailSenderCreate
8112f0c0 g     F .text	00000074 .hidden __modsi3
8111824c g     F .text	00000068 vCoudlNotCreateNFee5Task
8110bd4c g     F .text	0000003c uliSyncGetPer
811060a0 g     F .text	00000040 vRmapCh6HandleIrq
8114d640 g     O .bss	00000004 xMutexSenderACK
811179fc g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8114d49c g     O .rwdata	00000004 __ctype_ptr__
81117764 g     F .text	00000068 vFailSetPreParsedBuffer
8113d12c g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
81125928 g     F .text	00000004 __sfp_lock_release
81105890 g     F .text	000000ac bFeebGetIrqControl
81117cd4 g     F .text	00000068 vCouldNotSendTurnOff
81133b34 g     F .text	00000064 OSInit
8110a078 g     F .text	00000078 bSetPainelLeds
81143de4 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8114d704 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107018 g     F .text	000002ec bRmapSetMemConfigArea
8113b6ac g     F .text	0000012c OSTaskQuery
8110c41c g     F .text	00000074 bSyncIrqEnableError
8114d644 g     O .bss	00000004 xMutexPus
811396e8 g     F .text	000000b0 OS_QInit
81128420 g     F .text	000000d0 __sccl
8111b940 g     F .text	0000000c atoi
8110c868 g     F .text	00000b10 vFeeTask
81134e98 g     F .text	0000005c OS_StrLen
81118a04 g     F .text	0000004c vFailFlushNFEEQueue
811053d8 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
81116ab8 g     F .text	000000e0 vDataControllerInit
8113712c g     F .text	0000011c OSMemNameSet
8114aab8 g     O .rodata	00000101 _ctype_
8110bd10 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
811172ec g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114d536 g     O .rwdata	00000002 OSTaskProfileEn
81118a50 g     F .text	00000028 vEvtChangeMebMode
81143cb4 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8114d648 g     O .bss	00000004 xTxUARTMutex
8114d708 g     O .bss	00000004 OSTime
8114d4b4 g     O .rwdata	00000004 __mbtowc
81142928 g     F .text	0000005c altera_avalon_uart_close
8114d70c g     O .bss	00000004 OSTmrSem
81111c2c g     F .text	00000054 vPusType251conf
81163d54 g     O .bss	00001000 OSTaskIdleStk
8111b958 g     F .text	000000fc _fopen_r
8114d5e4 g     O .bss	00000004 pdata
81146300 g     F .text	000000bc _exit
81144fd8 g     F .text	00000134 alt_alarm_start
81135c54 g     F .text	00000130 OSFlagNameGet
8113bc9c g     F .text	00000064 OSTimeGet
8114d580 g     O .bss	00000004 ESdmaChBufferId
81140880 g     F .text	00000380 alt_up_sd_card_read
81106270 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111c174 g     F .text	000001c4 __smakebuf_r
8114d64c g     O .bss	00000001 SemCount64
81114c3c g     F .text	000002f8 bSendUART64v2
8111896c g     F .text	0000004c vFailFlushQueueData
81105488 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8114d564 g     O .rwdata	00000008 alt_msgdma_list
8111d640 g     F .text	00000098 strlen
8110b3e4 g     F .text	000000b4 uc_spi_get_byte
811062b4 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
811186ec g     F .text	00000054 vFailSendMsgAccessDMA
81145de0 g     F .text	00000028 OSTaskSwHook
811327b4 g     F .text	0000015c open
811082b8 g     F .text	000007cc bRmapGetRmapMemHKArea
81164d54 g     O .bss	00000d00 OSEventTbl
81118ff0 g     F .text	0000002c vFeeSpwRMAPChangeDefault
81130618 g     F .text	000000dc .hidden __gedf2
81160aac g     O .bss	00000020 xSenderACK
81145ad4 g     F .text	00000044 alt_putchar
81165a54 g     O .bss	000011b8 OSTCBTbl
8112d794 g     F .text	00000838 __gethex
8113a130 g     F .text	00000108 OSSemSet
81113094 g     F .text	0000006c vTimeoutCheckerTaskv2
811190a0 g     F .text	00000038 cFeeRMAPEchoingEnable
8114d4b8 g     O .rwdata	00000004 __wctomb
81113f00 g     F .text	00000314 vVariablesInitialization
8112bd48 g     F .text	00000018 __sprint_r
8110593c g     F .text	00000088 bFeebGetIrqFlags
8114d578 g     O .bss	00000004 pxDmaM2Dev
81116cb4 g     F .text	0000004c vFailCreateSemaphoreResources
8114d4d4 g     O .rwdata	00000004 alt_priority_mask
81109704 g     F .text	0000003c bDisableLvdsBoard
81139930 g     F .text	00000248 OSSemDel
8114d710 g     O .bss	00000004 OSFlagFreeList
8110b320 g     F .text	000000c4 v_spi_send_byte
8110b654 g     F .text	000000d0 bSSDisplayConfig
811454e0 g     F .text	00000090 alt_ic_irq_enable
8114d4fc g     O .rwdata	00000002 OSEventNameSize
81121d58 g     F .text	0000001c __vfprintf_internal
8114d714 g     O .bss	00000001 OSStatRdy
8110c0f0 g     F .text	00000074 bSyncCtrCh2OutEnable
81166c0c g     O .bss	000000ac OSTCBPrioTbl
811429c8 g     F .text	00000270 altera_avalon_uart_read
8112e49c g     F .text	00000064 _wctomb_r
81133000 g     F .text	000000cc __env_lock
8114d542 g     O .rwdata	00000002 OSTaskSwHookEn
811051e8 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
811307e8 g     F .text	00000904 .hidden __subdf3
81160acc g     O .bss	00000260 xPreParsed
8110bd88 g     F .text	0000003c uliSyncGetOst
8114d64d g     O .bss	00000001 SemCount128
81106120 g     F .text	00000040 vRmapCh8HandleIrq
811052b4 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
8111522c g     F .text	00000290 vSendEthConf
811044b0 g     F .text	000000dc bCommInitCh
811270f0 g     F .text	000000b0 __lo0bits
81121e38 g     F .text	000017c4 __svfscanf_r
8114d4e0 g     O .rwdata	00000008 alt_alarm_list
8112ba90 g     F .text	0000019c _ungetc_r
8114d50a g     O .rwdata	00000002 OSFlagWidth
81106160 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
8112e3a4 g     F .text	000000c8 wcrtomb
811049a8 g     F .text	00000148 bDpktSetPixelDelay
81114854 g     F .text	00000068 vCCDLoadDefaultValues
81131474 g     F .text	000000d8 close
8110bdc4 g     F .text	0000003c uliSyncGetGeneral
81118aa0 g     F .text	00000028 vEvtChangeDataControllerMode
8114d6a4 g     O .bss	00000004 alt_envsem
811319a4 g     F .text	00000068 alt_log_repchar
8114d718 g     O .bss	00000004 OSIdleCtrRun
811341bc g     F .text	00000028 OSVersion
8114d554 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113b7d8 g     F .text	00000078 OS_TaskStkClr
81119c18 g     F .text	0000003c siOpenFile
8110c7c8 g     F .text	000000a0 vDataControlTask
8114d52e g     O .rwdata	00000002 OSTaskCreateEn
811063d8 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81106820 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81105ba0 g     F .text	00000088 bFeebStartCh
811154bc g     F .text	00000118 vSendTurnOff
81116db4 g     F .text	0000004c vFailSendPreParsedSemaphore
8113e5f0 g     F .text	000002a4 match_file_record_to_name_ext
811347e4 g     F .text	00000070 OS_EventWaitListInit
8112d60c g     F .text	00000088 fputwc
81160d2c g     O .bss	00000010 xFeeQueueTBL0
81116d4c g     F .text	00000068 vFailSendxSemCommInit
81145ed8 g     F .text	00000028 OSTaskIdleHook
811155d4 g     F .text	00000118 vSendReset
8112592c g     F .text	00000004 __sinit_lock_acquire
81126e54 g     F .text	00000128 __multadd
81160d3c g     O .bss	00000010 SyncTBL1
811052f8 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110ba14 g     F .text	0000004c ucSyncStatusState
8113b4c0 g     F .text	000001ec OSTaskSuspend
81126e2c g     F .text	00000028 _Bfree
8110bcd4 g     F .text	0000003c uliSyncGetMbt
81134ef4 g     F .text	00000064 OS_TaskIdle
8114d55a g     O .rwdata	00000002 OSTmrTblSize
81139584 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1133b980 	call	81133b98 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	109c8804 	addi	r2,r2,29216
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	109c8804 	addi	r2,r2,29216
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1133bec0 	call	81133bec <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b117 	ldw	r2,-32060(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b117 	ldw	r2,-32060(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21353604 	addi	r4,r4,-11048
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	21308d04 	addi	r4,r4,-15820
81100274:	113191c0 	call	8113191c <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21353604 	addi	r4,r4,-11048
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	21308004 	addi	r4,r4,-15872
81100290:	113191c0 	call	8113191c <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6952414 	ori	gp,gp,21648
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21353604 	addi	r4,r4,-11048
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	21307104 	addi	r4,r4,-15932
811002bc:	113191c0 	call	8113191c <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10b55b14 	ori	r2,r2,54636

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18dcc814 	ori	r3,r3,29472

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21353604 	addi	r4,r4,-11048
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	21307804 	addi	r4,r4,-15904
811002fc:	113191c0 	call	8113191c <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11325480 	call	81132548 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18f63004 	addi	r3,r3,-10048
81100330:	00a04534 	movhi	r2,33044
81100334:	1098ef04 	addi	r2,r2,25532
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05c17 	ldw	r2,-32400(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29763004 	addi	r5,r5,-10048
8110035c:	1009883a 	mov	r4,r2
81100360:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18f63004 	addi	r3,r3,-10048
811003cc:	00a04534 	movhi	r2,33044
811003d0:	1098f804 	addi	r2,r2,25568
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a05c17 	ldw	r2,-32400(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	29763004 	addi	r5,r5,-10048
811003f8:	1009883a 	mov	r4,r2
811003fc:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18f63004 	addi	r3,r3,-10048
81100410:	00a04534 	movhi	r2,33044
81100414:	10990404 	addi	r2,r2,25616
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a05c17 	ldw	r2,-32400(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	29763004 	addi	r5,r5,-10048
8110043c:	1009883a 	mov	r4,r2
81100440:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1132d740 	call	81132d74 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	11099e40 	call	811099e4 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604534 	movhi	r5,33044
811004b0:	29590a04 	addi	r5,r5,25640
811004b4:	01204574 	movhi	r4,33045
811004b8:	21363004 	addi	r4,r4,-10048
811004bc:	111d42c0 	call	8111d42c <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a05c17 	ldw	r2,-32400(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	29763004 	addi	r5,r5,-10048
811004cc:	1009883a 	mov	r4,r2
811004d0:	111ba9c0 	call	8111ba9c <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18f63004 	addi	r3,r3,-10048
811004e0:	00a04534 	movhi	r2,33044
811004e4:	10990f04 	addi	r2,r2,25660
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	111cb4c0 	call	8111cb4c <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a05c17 	ldw	r2,-32400(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	29763004 	addi	r5,r5,-10048
8110050c:	1009883a 	mov	r4,r2
81100510:	111ba9c0 	call	8111ba9c <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18f63004 	addi	r3,r3,-10048
81100544:	00a04534 	movhi	r2,33044
81100548:	10991504 	addi	r2,r2,25684
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a05c17 	ldw	r2,-32400(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	29763004 	addi	r5,r5,-10048
81100570:	1009883a 	mov	r4,r2
81100574:	111ba9c0 	call	8111ba9c <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18f63004 	addi	r3,r3,-10048
81100584:	00a04534 	movhi	r2,33044
81100588:	10991e04 	addi	r2,r2,25720
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a05c17 	ldw	r2,-32400(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	29763004 	addi	r5,r5,-10048
811005b0:	1009883a 	mov	r4,r2
811005b4:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18f63004 	addi	r3,r3,-10048
811005c0:	00a04534 	movhi	r2,33044
811005c4:	10992604 	addi	r2,r2,25752
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a05c17 	ldw	r2,-32400(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	29763004 	addi	r5,r5,-10048
811005ec:	1009883a 	mov	r4,r2
811005f0:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1132d740 	call	81132d74 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	11099040 	call	81109904 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18f63004 	addi	r3,r3,-10048
81100650:	00a04534 	movhi	r2,33044
81100654:	10992c04 	addi	r2,r2,25776
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a05c17 	ldw	r2,-32400(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	29763004 	addi	r5,r5,-10048
8110067c:	1009883a 	mov	r4,r2
81100680:	111ba9c0 	call	8111ba9c <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	11099e40 	call	811099e4 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18f63004 	addi	r3,r3,-10048
811006cc:	00a04534 	movhi	r2,33044
811006d0:	10993204 	addi	r2,r2,25800
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	111cb4c0 	call	8111cb4c <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a05c17 	ldw	r2,-32400(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	29763004 	addi	r5,r5,-10048
811006f8:	1009883a 	mov	r4,r2
811006fc:	111ba9c0 	call	8111ba9c <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604534 	movhi	r5,33044
81100730:	29593b04 	addi	r5,r5,25836
81100734:	01204574 	movhi	r4,33045
81100738:	21363004 	addi	r4,r4,-10048
8110073c:	111d42c0 	call	8111d42c <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a05c17 	ldw	r2,-32400(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	29763004 	addi	r5,r5,-10048
8110074c:	1009883a 	mov	r4,r2
81100750:	111ba9c0 	call	8111ba9c <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18f63004 	addi	r3,r3,-10048
81100764:	00a04534 	movhi	r2,33044
81100768:	10994a04 	addi	r2,r2,25896
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a05c17 	ldw	r2,-32400(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	29763004 	addi	r5,r5,-10048
81100790:	1009883a 	mov	r4,r2
81100794:	111ba9c0 	call	8111ba9c <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18f63004 	addi	r3,r3,-10048
811007a4:	00a04534 	movhi	r2,33044
811007a8:	10995304 	addi	r2,r2,25932
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a05c17 	ldw	r2,-32400(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	29763004 	addi	r5,r5,-10048
811007d0:	1009883a 	mov	r4,r2
811007d4:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10b63004 	addi	r2,r2,-10048
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a05c17 	ldw	r2,-32400(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	29763004 	addi	r5,r5,-10048
811007f8:	1009883a 	mov	r4,r2
811007fc:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18f63004 	addi	r3,r3,-10048
81100840:	00a04534 	movhi	r2,33044
81100844:	10995b04 	addi	r2,r2,25964
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a05c17 	ldw	r2,-32400(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	29763004 	addi	r5,r5,-10048
8110086c:	1009883a 	mov	r4,r2
81100870:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18f63004 	addi	r3,r3,-10048
811008dc:	00a04534 	movhi	r2,33044
811008e0:	10996404 	addi	r2,r2,26000
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a05c17 	ldw	r2,-32400(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	29763004 	addi	r5,r5,-10048
81100908:	1009883a 	mov	r4,r2
8110090c:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	1109aec0 	call	81109aec <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604534 	movhi	r5,33044
81100984:	29597004 	addi	r5,r5,26048
81100988:	01204574 	movhi	r4,33045
8110098c:	21363004 	addi	r4,r4,-10048
81100990:	111d42c0 	call	8111d42c <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a05c17 	ldw	r2,-32400(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	29763004 	addi	r5,r5,-10048
811009a0:	1009883a 	mov	r4,r2
811009a4:	111ba9c0 	call	8111ba9c <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18f63004 	addi	r3,r3,-10048
811009c0:	00a04534 	movhi	r2,33044
811009c4:	10997c04 	addi	r2,r2,26096
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	111cb4c0 	call	8111cb4c <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a05c17 	ldw	r2,-32400(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	29763004 	addi	r5,r5,-10048
811009ec:	1009883a 	mov	r4,r2
811009f0:	111ba9c0 	call	8111ba9c <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18f63004 	addi	r3,r3,-10048
81100a0c:	00a04534 	movhi	r2,33044
81100a10:	10998804 	addi	r2,r2,26144
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a05c17 	ldw	r2,-32400(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	29763004 	addi	r5,r5,-10048
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111ba9c0 	call	8111ba9c <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18f63004 	addi	r3,r3,-10048
81100a58:	00a04534 	movhi	r2,33044
81100a5c:	10999004 	addi	r2,r2,26176
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	111cb4c0 	call	8111cb4c <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a05c17 	ldw	r2,-32400(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	29763004 	addi	r5,r5,-10048
81100a84:	1009883a 	mov	r4,r2
81100a88:	111ba9c0 	call	8111ba9c <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18f63004 	addi	r3,r3,-10048
81100aa4:	00a04534 	movhi	r2,33044
81100aa8:	10999a04 	addi	r2,r2,26216
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	111cb4c0 	call	8111cb4c <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a05c17 	ldw	r2,-32400(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	29763004 	addi	r5,r5,-10048
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111ba9c0 	call	8111ba9c <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18f63004 	addi	r3,r3,-10048
81100af0:	00a04534 	movhi	r2,33044
81100af4:	1099a504 	addi	r2,r2,26260
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	111cb4c0 	call	8111cb4c <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a05c17 	ldw	r2,-32400(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	29763004 	addi	r5,r5,-10048
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111ba9c0 	call	8111ba9c <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18f63004 	addi	r3,r3,-10048
81100b3c:	00a04534 	movhi	r2,33044
81100b40:	1099b104 	addi	r2,r2,26308
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a05c17 	ldw	r2,-32400(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	29763004 	addi	r5,r5,-10048
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111ba9c0 	call	8111ba9c <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18f63004 	addi	r3,r3,-10048
81100b88:	00a04534 	movhi	r2,33044
81100b8c:	1099b704 	addi	r2,r2,26332
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a05c17 	ldw	r2,-32400(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	29763004 	addi	r5,r5,-10048
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111ba9c0 	call	8111ba9c <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18f63004 	addi	r3,r3,-10048
81100bd4:	00a04534 	movhi	r2,33044
81100bd8:	1099bf04 	addi	r2,r2,26364
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	111cb4c0 	call	8111cb4c <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a05c17 	ldw	r2,-32400(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	29763004 	addi	r5,r5,-10048
81100c00:	1009883a 	mov	r4,r2
81100c04:	111ba9c0 	call	8111ba9c <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18f63004 	addi	r3,r3,-10048
81100c20:	00a04534 	movhi	r2,33044
81100c24:	1099cc04 	addi	r2,r2,26416
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a05c17 	ldw	r2,-32400(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	29763004 	addi	r5,r5,-10048
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111ba9c0 	call	8111ba9c <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18f63004 	addi	r3,r3,-10048
81100c6c:	00a04534 	movhi	r2,33044
81100c70:	1099d204 	addi	r2,r2,26440
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a05c17 	ldw	r2,-32400(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	29763004 	addi	r5,r5,-10048
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111ba9c0 	call	8111ba9c <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18f63004 	addi	r3,r3,-10048
81100cb8:	00a04534 	movhi	r2,33044
81100cbc:	1099d704 	addi	r2,r2,26460
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a05c17 	ldw	r2,-32400(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	29763004 	addi	r5,r5,-10048
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111ba9c0 	call	8111ba9c <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18f63004 	addi	r3,r3,-10048
81100d04:	00a04534 	movhi	r2,33044
81100d08:	1099de04 	addi	r2,r2,26488
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	111cb4c0 	call	8111cb4c <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a05c17 	ldw	r2,-32400(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	29763004 	addi	r5,r5,-10048
81100d30:	1009883a 	mov	r4,r2
81100d34:	111ba9c0 	call	8111ba9c <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18f63004 	addi	r3,r3,-10048
81100d50:	00a04534 	movhi	r2,33044
81100d54:	1099ec04 	addi	r2,r2,26544
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	111cb4c0 	call	8111cb4c <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a05c17 	ldw	r2,-32400(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	29763004 	addi	r5,r5,-10048
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111ba9c0 	call	8111ba9c <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18f63004 	addi	r3,r3,-10048
81100d9c:	00a04534 	movhi	r2,33044
81100da0:	1099fe04 	addi	r2,r2,26616
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a05c17 	ldw	r2,-32400(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	29763004 	addi	r5,r5,-10048
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111ba9c0 	call	8111ba9c <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18f63004 	addi	r3,r3,-10048
81100de8:	00a04534 	movhi	r2,33044
81100dec:	109a0604 	addi	r2,r2,26648
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a05c17 	ldw	r2,-32400(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	29763004 	addi	r5,r5,-10048
81100e14:	1009883a 	mov	r4,r2
81100e18:	111ba9c0 	call	8111ba9c <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18f63004 	addi	r3,r3,-10048
81100e34:	00a04534 	movhi	r2,33044
81100e38:	109a1004 	addi	r2,r2,26688
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a05c17 	ldw	r2,-32400(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	29763004 	addi	r5,r5,-10048
81100e60:	1009883a 	mov	r4,r2
81100e64:	111ba9c0 	call	8111ba9c <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18f63004 	addi	r3,r3,-10048
81100e80:	00a04534 	movhi	r2,33044
81100e84:	109a1d04 	addi	r2,r2,26740
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a05c17 	ldw	r2,-32400(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	29763004 	addi	r5,r5,-10048
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111ba9c0 	call	8111ba9c <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18f63004 	addi	r3,r3,-10048
81100ecc:	00a04534 	movhi	r2,33044
81100ed0:	109a2704 	addi	r2,r2,26780
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a05c17 	ldw	r2,-32400(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	29763004 	addi	r5,r5,-10048
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111ba9c0 	call	8111ba9c <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18f63004 	addi	r3,r3,-10048
81100f18:	00a04534 	movhi	r2,33044
81100f1c:	109a3204 	addi	r2,r2,26824
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	111cb4c0 	call	8111cb4c <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a05c17 	ldw	r2,-32400(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	29763004 	addi	r5,r5,-10048
81100f44:	1009883a 	mov	r4,r2
81100f48:	111ba9c0 	call	8111ba9c <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18f63004 	addi	r3,r3,-10048
81100f64:	00a04534 	movhi	r2,33044
81100f68:	109a4304 	addi	r2,r2,26892
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a05c17 	ldw	r2,-32400(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	29763004 	addi	r5,r5,-10048
81100f90:	1009883a 	mov	r4,r2
81100f94:	111ba9c0 	call	8111ba9c <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18f63004 	addi	r3,r3,-10048
81100fb0:	00a04534 	movhi	r2,33044
81100fb4:	109a4e04 	addi	r2,r2,26936
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	111cb4c0 	call	8111cb4c <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a05c17 	ldw	r2,-32400(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	29763004 	addi	r5,r5,-10048
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111ba9c0 	call	8111ba9c <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18f63004 	addi	r3,r3,-10048
81100ffc:	00a04534 	movhi	r2,33044
81101000:	109a5b04 	addi	r2,r2,26988
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	111cb4c0 	call	8111cb4c <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a05c17 	ldw	r2,-32400(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	29763004 	addi	r5,r5,-10048
81101028:	1009883a 	mov	r4,r2
8110102c:	111ba9c0 	call	8111ba9c <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18f63004 	addi	r3,r3,-10048
81101048:	00a04534 	movhi	r2,33044
8110104c:	109a6904 	addi	r2,r2,27044
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a05c17 	ldw	r2,-32400(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	29763004 	addi	r5,r5,-10048
81101074:	1009883a 	mov	r4,r2
81101078:	111ba9c0 	call	8111ba9c <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18f63004 	addi	r3,r3,-10048
81101094:	00a04534 	movhi	r2,33044
81101098:	109a7604 	addi	r2,r2,27096
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	111cb4c0 	call	8111cb4c <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a05c17 	ldw	r2,-32400(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	29763004 	addi	r5,r5,-10048
811010c0:	1009883a 	mov	r4,r2
811010c4:	111ba9c0 	call	8111ba9c <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18f63004 	addi	r3,r3,-10048
811010e0:	00a04534 	movhi	r2,33044
811010e4:	109a8304 	addi	r2,r2,27148
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a05c17 	ldw	r2,-32400(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	29763004 	addi	r5,r5,-10048
8110110c:	1009883a 	mov	r4,r2
81101110:	111ba9c0 	call	8111ba9c <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10b63004 	addi	r2,r2,-10048
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a05c17 	ldw	r2,-32400(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	29763004 	addi	r5,r5,-10048
81101194:	1009883a 	mov	r4,r2
81101198:	111ba9c0 	call	8111ba9c <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18f63004 	addi	r3,r3,-10048
811011b4:	00a04534 	movhi	r2,33044
811011b8:	109a8704 	addi	r2,r2,27164
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a05c17 	ldw	r2,-32400(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	29763004 	addi	r5,r5,-10048
811011e0:	1009883a 	mov	r4,r2
811011e4:	111ba9c0 	call	8111ba9c <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18f63004 	addi	r3,r3,-10048
81101200:	00a04534 	movhi	r2,33044
81101204:	109a8f04 	addi	r2,r2,27196
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	111cb4c0 	call	8111cb4c <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a05c17 	ldw	r2,-32400(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	29763004 	addi	r5,r5,-10048
8110122c:	1009883a 	mov	r4,r2
81101230:	111ba9c0 	call	8111ba9c <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18f63004 	addi	r3,r3,-10048
8110124c:	00a04534 	movhi	r2,33044
81101250:	109a9d04 	addi	r2,r2,27252
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a05c17 	ldw	r2,-32400(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	29763004 	addi	r5,r5,-10048
81101278:	1009883a 	mov	r4,r2
8110127c:	111ba9c0 	call	8111ba9c <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18f63004 	addi	r3,r3,-10048
81101298:	00a04534 	movhi	r2,33044
8110129c:	109aa504 	addi	r2,r2,27284
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a05c17 	ldw	r2,-32400(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	29763004 	addi	r5,r5,-10048
811012c4:	1009883a 	mov	r4,r2
811012c8:	111ba9c0 	call	8111ba9c <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18f63004 	addi	r3,r3,-10048
811012e4:	00a04534 	movhi	r2,33044
811012e8:	109aad04 	addi	r2,r2,27316
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	111cb4c0 	call	8111cb4c <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a05c17 	ldw	r2,-32400(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	29763004 	addi	r5,r5,-10048
81101310:	1009883a 	mov	r4,r2
81101314:	111ba9c0 	call	8111ba9c <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18f63004 	addi	r3,r3,-10048
81101330:	00a04534 	movhi	r2,33044
81101334:	109ab704 	addi	r2,r2,27356
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a05c17 	ldw	r2,-32400(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	29763004 	addi	r5,r5,-10048
8110135c:	1009883a 	mov	r4,r2
81101360:	111ba9c0 	call	8111ba9c <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18f63004 	addi	r3,r3,-10048
8110137c:	00a04534 	movhi	r2,33044
81101380:	109abe04 	addi	r2,r2,27384
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	111cb4c0 	call	8111cb4c <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a05c17 	ldw	r2,-32400(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	29763004 	addi	r5,r5,-10048
811013a8:	1009883a 	mov	r4,r2
811013ac:	111ba9c0 	call	8111ba9c <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18f63004 	addi	r3,r3,-10048
811013c8:	00a04534 	movhi	r2,33044
811013cc:	109ac804 	addi	r2,r2,27424
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a05c17 	ldw	r2,-32400(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	29763004 	addi	r5,r5,-10048
811013f4:	1009883a 	mov	r4,r2
811013f8:	111ba9c0 	call	8111ba9c <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10b63004 	addi	r2,r2,-10048
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a05c17 	ldw	r2,-32400(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	29763004 	addi	r5,r5,-10048
81101420:	1009883a 	mov	r4,r2
81101424:	111ba9c0 	call	8111ba9c <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18f63004 	addi	r3,r3,-10048
81101454:	00a04534 	movhi	r2,33044
81101458:	109ad204 	addi	r2,r2,27464
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a05c17 	ldw	r2,-32400(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	29763004 	addi	r5,r5,-10048
81101480:	1009883a 	mov	r4,r2
81101484:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10b63004 	addi	r2,r2,-10048
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a05c17 	ldw	r2,-32400(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	29763004 	addi	r5,r5,-10048
811014a8:	1009883a 	mov	r4,r2
811014ac:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18f63004 	addi	r3,r3,-10048
81101538:	00a04534 	movhi	r2,33044
8110153c:	109ad804 	addi	r2,r2,27488
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a05c17 	ldw	r2,-32400(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	29763004 	addi	r5,r5,-10048
81101564:	1009883a 	mov	r4,r2
81101568:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18f63004 	addi	r3,r3,-10048
811015b4:	00a04534 	movhi	r2,33044
811015b8:	109ae704 	addi	r2,r2,27548
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a05c17 	ldw	r2,-32400(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	29763004 	addi	r5,r5,-10048
811015e0:	1009883a 	mov	r4,r2
811015e4:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18f63004 	addi	r3,r3,-10048
81101648:	00a04534 	movhi	r2,33044
8110164c:	1098f804 	addi	r2,r2,25568
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a05c17 	ldw	r2,-32400(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	29763004 	addi	r5,r5,-10048
81101674:	1009883a 	mov	r4,r2
81101678:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604534 	movhi	r5,33044
81101694:	295af104 	addi	r5,r5,27588
81101698:	01204574 	movhi	r4,33045
8110169c:	21363004 	addi	r4,r4,-10048
811016a0:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a05c17 	ldw	r2,-32400(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	29763004 	addi	r5,r5,-10048
811016b0:	1009883a 	mov	r4,r2
811016b4:	111ba9c0 	call	8111ba9c <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08317 	ldw	r2,-32244(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10b67004 	addi	r2,r2,-9792
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10b67004 	addi	r2,r2,-9792
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10b67004 	addi	r2,r2,-9792
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10b67004 	addi	r2,r2,-9792
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10b67004 	addi	r2,r2,-9792
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10b67004 	addi	r2,r2,-9792
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10b67004 	addi	r2,r2,-9792
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18f63004 	addi	r3,r3,-10048
81101868:	00a04534 	movhi	r2,33044
8110186c:	109af704 	addi	r2,r2,27612
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a05c17 	ldw	r2,-32400(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	29763004 	addi	r5,r5,-10048
81101894:	1009883a 	mov	r4,r2
81101898:	111ba9c0 	call	8111ba9c <fprintf>
8110189c:	d0a08317 	ldw	r2,-32244(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29767004 	addi	r5,r5,-9792
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	111cb4c0 	call	8111cb4c <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604534 	movhi	r5,33044
81101990:	295afc04 	addi	r5,r5,27632
81101994:	01204574 	movhi	r4,33045
81101998:	21363004 	addi	r4,r4,-10048
8110199c:	111d42c0 	call	8111d42c <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a05c17 	ldw	r2,-32400(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	29763004 	addi	r5,r5,-10048
811019ac:	1009883a 	mov	r4,r2
811019b0:	111ba9c0 	call	8111ba9c <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	113154c0 	call	8113154c <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10b63004 	addi	r2,r2,-10048
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a05c17 	ldw	r2,-32400(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	29763004 	addi	r5,r5,-10048
811019e4:	1009883a 	mov	r4,r2
811019e8:	111ba9c0 	call	8111ba9c <fprintf>
811019ec:	d0e08317 	ldw	r3,-32244(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111acd80 	call	8111acd8 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08217 	ldw	r2,-32248(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111ae040 	call	8111ae04 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111a48c0 	call	8111a48c <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111b61c0 	call	8111b61c <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604534 	movhi	r5,33044
81101a54:	295afe04 	addi	r5,r5,27640
81101a58:	01204574 	movhi	r4,33045
81101a5c:	21363004 	addi	r4,r4,-10048
81101a60:	111d42c0 	call	8111d42c <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a05c17 	ldw	r2,-32400(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	29763004 	addi	r5,r5,-10048
81101a70:	1009883a 	mov	r4,r2
81101a74:	111ba9c0 	call	8111ba9c <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18f63004 	addi	r3,r3,-10048
81101a84:	00a04534 	movhi	r2,33044
81101a88:	109b0a04 	addi	r2,r2,27688
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a05c17 	ldw	r2,-32400(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	29763004 	addi	r5,r5,-10048
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10b63004 	addi	r2,r2,-10048
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a05c17 	ldw	r2,-32400(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	29763004 	addi	r5,r5,-10048
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18f63004 	addi	r3,r3,-10048
81101b30:	00a04534 	movhi	r2,33044
81101b34:	109b1004 	addi	r2,r2,27712
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a05c17 	ldw	r2,-32400(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	29763004 	addi	r5,r5,-10048
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18f63004 	addi	r3,r3,-10048
81101bc4:	00a04534 	movhi	r2,33044
81101bc8:	1098f804 	addi	r2,r2,25568
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a05c17 	ldw	r2,-32400(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	29763004 	addi	r5,r5,-10048
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604534 	movhi	r5,33044
81101c10:	295b1a04 	addi	r5,r5,27752
81101c14:	01204574 	movhi	r4,33045
81101c18:	21363004 	addi	r4,r4,-10048
81101c1c:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a05c17 	ldw	r2,-32400(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29763004 	addi	r5,r5,-10048
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18f63004 	addi	r3,r3,-10048
81101cd0:	00a04534 	movhi	r2,33044
81101cd4:	109b2004 	addi	r2,r2,27776
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a05c17 	ldw	r2,-32400(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	29763004 	addi	r5,r5,-10048
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111ba9c0 	call	8111ba9c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08317 	ldw	r2,-32244(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10b67004 	addi	r2,r2,-9792
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10b67004 	addi	r2,r2,-9792
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604534 	movhi	r5,33044
81101df4:	295b2704 	addi	r5,r5,27804
81101df8:	01204574 	movhi	r4,33045
81101dfc:	21363004 	addi	r4,r4,-10048
81101e00:	111d42c0 	call	8111d42c <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a05c17 	ldw	r2,-32400(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	29763004 	addi	r5,r5,-10048
81101e10:	1009883a 	mov	r4,r2
81101e14:	111ba9c0 	call	8111ba9c <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604534 	movhi	r5,33044
81101e98:	295afc04 	addi	r5,r5,27632
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	21363004 	addi	r4,r4,-10048
81101ea4:	111d42c0 	call	8111d42c <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a05c17 	ldw	r2,-32400(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	29763004 	addi	r5,r5,-10048
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111ba9c0 	call	8111ba9c <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10b63004 	addi	r2,r2,-10048
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a05c17 	ldw	r2,-32400(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29763004 	addi	r5,r5,-10048
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111ba9c0 	call	8111ba9c <fprintf>
81101ef8:	d0e08317 	ldw	r3,-32244(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111acd80 	call	8111acd8 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08217 	ldw	r2,-32248(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111ae040 	call	8111ae04 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111a48c0 	call	8111a48c <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111b61c0 	call	8111b61c <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604534 	movhi	r5,33044
81101f60:	295b3504 	addi	r5,r5,27860
81101f64:	01204574 	movhi	r4,33045
81101f68:	21363004 	addi	r4,r4,-10048
81101f6c:	111d42c0 	call	8111d42c <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a05c17 	ldw	r2,-32400(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	29763004 	addi	r5,r5,-10048
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111ba9c0 	call	8111ba9c <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18f63004 	addi	r3,r3,-10048
81101f90:	00a04534 	movhi	r2,33044
81101f94:	109b4104 	addi	r2,r2,27908
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a05c17 	ldw	r2,-32400(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	29763004 	addi	r5,r5,-10048
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10b63004 	addi	r2,r2,-10048
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a05c17 	ldw	r2,-32400(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	29763004 	addi	r5,r5,-10048
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18f63004 	addi	r3,r3,-10048
8110204c:	00a04534 	movhi	r2,33044
81102050:	109b4704 	addi	r2,r2,27932
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a05c17 	ldw	r2,-32400(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	29763004 	addi	r5,r5,-10048
81102078:	1009883a 	mov	r4,r2
8110207c:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18f63004 	addi	r3,r3,-10048
811020e0:	00a04534 	movhi	r2,33044
811020e4:	1098f804 	addi	r2,r2,25568
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a05c17 	ldw	r2,-32400(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	29763004 	addi	r5,r5,-10048
8110210c:	1009883a 	mov	r4,r2
81102110:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604534 	movhi	r5,33044
8110212c:	295af104 	addi	r5,r5,27588
81102130:	01204574 	movhi	r4,33045
81102134:	21363004 	addi	r4,r4,-10048
81102138:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a05c17 	ldw	r2,-32400(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	29763004 	addi	r5,r5,-10048
81102148:	1009883a 	mov	r4,r2
8110214c:	111ba9c0 	call	8111ba9c <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08317 	ldw	r2,-32244(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18f63004 	addi	r3,r3,-10048
811021ac:	00a04534 	movhi	r2,33044
811021b0:	109b5304 	addi	r2,r2,27980
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a05c17 	ldw	r2,-32400(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	29763004 	addi	r5,r5,-10048
811021d8:	1009883a 	mov	r4,r2
811021dc:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604534 	movhi	r5,33044
811021f0:	295b5904 	addi	r5,r5,28004
811021f4:	01204574 	movhi	r4,33045
811021f8:	21363004 	addi	r4,r4,-10048
811021fc:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a05c17 	ldw	r2,-32400(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	29763004 	addi	r5,r5,-10048
8110220c:	1009883a 	mov	r4,r2
81102210:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08317 	ldw	r2,-32244(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604534 	movhi	r5,33044
81102274:	295b5b04 	addi	r5,r5,28012
81102278:	01204574 	movhi	r4,33045
8110227c:	21363004 	addi	r4,r4,-10048
81102280:	111d42c0 	call	8111d42c <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a05c17 	ldw	r2,-32400(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	29763004 	addi	r5,r5,-10048
81102290:	1009883a 	mov	r4,r2
81102294:	111ba9c0 	call	8111ba9c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	113154c0 	call	8113154c <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604534 	movhi	r5,33044
811022fc:	295b5e04 	addi	r5,r5,28024
81102300:	01204574 	movhi	r4,33045
81102304:	21363004 	addi	r4,r4,-10048
81102308:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a05c17 	ldw	r2,-32400(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	29763004 	addi	r5,r5,-10048
81102318:	1009883a 	mov	r4,r2
8110231c:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08317 	ldw	r3,-32244(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111acd80 	call	8111acd8 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08217 	ldw	r2,-32248(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111ae040 	call	8111ae04 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111a48c0 	call	8111a48c <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111b61c0 	call	8111b61c <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604534 	movhi	r5,33044
81102394:	295b6104 	addi	r5,r5,28036
81102398:	01204574 	movhi	r4,33045
8110239c:	21363004 	addi	r4,r4,-10048
811023a0:	111d42c0 	call	8111d42c <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a05c17 	ldw	r2,-32400(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	29763004 	addi	r5,r5,-10048
811023b0:	1009883a 	mov	r4,r2
811023b4:	111ba9c0 	call	8111ba9c <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	295b6d04 	addi	r5,r5,28084
811023c8:	01204574 	movhi	r4,33045
811023cc:	21363004 	addi	r4,r4,-10048
811023d0:	111d42c0 	call	8111d42c <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a05c17 	ldw	r2,-32400(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	29763004 	addi	r5,r5,-10048
811023e0:	1009883a 	mov	r4,r2
811023e4:	111ba9c0 	call	8111ba9c <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18f63004 	addi	r3,r3,-10048
811023f4:	00a04534 	movhi	r2,33044
811023f8:	109b0a04 	addi	r2,r2,27688
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a05c17 	ldw	r2,-32400(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	29763004 	addi	r5,r5,-10048
81102420:	1009883a 	mov	r4,r2
81102424:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10b63004 	addi	r2,r2,-10048
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a05c17 	ldw	r2,-32400(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	29763004 	addi	r5,r5,-10048
81102448:	1009883a 	mov	r4,r2
8110244c:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18f63004 	addi	r3,r3,-10048
811024b8:	00a04534 	movhi	r2,33044
811024bc:	109b7704 	addi	r2,r2,28124
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a05c17 	ldw	r2,-32400(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	29763004 	addi	r5,r5,-10048
811024e4:	1009883a 	mov	r4,r2
811024e8:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18f63004 	addi	r3,r3,-10048
8110254c:	00a04534 	movhi	r2,33044
81102550:	1098f804 	addi	r2,r2,25568
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	111cb4c0 	call	8111cb4c <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a05c17 	ldw	r2,-32400(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	29763004 	addi	r5,r5,-10048
81102578:	1009883a 	mov	r4,r2
8110257c:	111ba9c0 	call	8111ba9c <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604534 	movhi	r5,33044
81102598:	295af104 	addi	r5,r5,27588
8110259c:	01204574 	movhi	r4,33045
811025a0:	21363004 	addi	r4,r4,-10048
811025a4:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a05c17 	ldw	r2,-32400(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	29763004 	addi	r5,r5,-10048
811025b4:	1009883a 	mov	r4,r2
811025b8:	111ba9c0 	call	8111ba9c <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18f63004 	addi	r3,r3,-10048
81102610:	00a04534 	movhi	r2,33044
81102614:	109b8304 	addi	r2,r2,28172
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a05c17 	ldw	r2,-32400(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	29763004 	addi	r5,r5,-10048
8110263c:	1009883a 	mov	r4,r2
81102640:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604534 	movhi	r5,33044
81102654:	295b5904 	addi	r5,r5,28004
81102658:	01204574 	movhi	r4,33045
8110265c:	21363004 	addi	r4,r4,-10048
81102660:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a05c17 	ldw	r2,-32400(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	29763004 	addi	r5,r5,-10048
81102670:	1009883a 	mov	r4,r2
81102674:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08317 	ldw	r2,-32244(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604534 	movhi	r5,33044
811026c8:	295b8904 	addi	r5,r5,28196
811026cc:	01204574 	movhi	r4,33045
811026d0:	21363004 	addi	r4,r4,-10048
811026d4:	111d42c0 	call	8111d42c <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a05c17 	ldw	r2,-32400(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	29763004 	addi	r5,r5,-10048
811026e4:	1009883a 	mov	r4,r2
811026e8:	111ba9c0 	call	8111ba9c <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604534 	movhi	r5,33044
81102710:	295b5b04 	addi	r5,r5,28012
81102714:	01204574 	movhi	r4,33045
81102718:	21363004 	addi	r4,r4,-10048
8110271c:	111d42c0 	call	8111d42c <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a05c17 	ldw	r2,-32400(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	29763004 	addi	r5,r5,-10048
8110272c:	1009883a 	mov	r4,r2
81102730:	111ba9c0 	call	8111ba9c <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604534 	movhi	r5,33044
81102794:	295b5e04 	addi	r5,r5,28024
81102798:	01204574 	movhi	r4,33045
8110279c:	21363004 	addi	r4,r4,-10048
811027a0:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a05c17 	ldw	r2,-32400(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	29763004 	addi	r5,r5,-10048
811027b0:	1009883a 	mov	r4,r2
811027b4:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08317 	ldw	r3,-32244(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111acd80 	call	8111acd8 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08217 	ldw	r2,-32248(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111ae040 	call	8111ae04 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111a48c0 	call	8111a48c <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111b61c0 	call	8111b61c <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604534 	movhi	r5,33044
8110282c:	295b9104 	addi	r5,r5,28228
81102830:	01204574 	movhi	r4,33045
81102834:	21363004 	addi	r4,r4,-10048
81102838:	111d42c0 	call	8111d42c <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a05c17 	ldw	r2,-32400(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	29763004 	addi	r5,r5,-10048
81102848:	1009883a 	mov	r4,r2
8110284c:	111ba9c0 	call	8111ba9c <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604534 	movhi	r5,33044
8110285c:	295b9d04 	addi	r5,r5,28276
81102860:	01204574 	movhi	r4,33045
81102864:	21363004 	addi	r4,r4,-10048
81102868:	111d42c0 	call	8111d42c <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a05c17 	ldw	r2,-32400(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	29763004 	addi	r5,r5,-10048
81102878:	1009883a 	mov	r4,r2
8110287c:	111ba9c0 	call	8111ba9c <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18f63004 	addi	r3,r3,-10048
8110288c:	00a04534 	movhi	r2,33044
81102890:	109b4104 	addi	r2,r2,27908
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	111cb4c0 	call	8111cb4c <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a05c17 	ldw	r2,-32400(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	29763004 	addi	r5,r5,-10048
811028b8:	1009883a 	mov	r4,r2
811028bc:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10b63004 	addi	r2,r2,-10048
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a05c17 	ldw	r2,-32400(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	29763004 	addi	r5,r5,-10048
811028e0:	1009883a 	mov	r4,r2
811028e4:	111ba9c0 	call	8111ba9c <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1144c580 	call	81144c58 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1132d740 	call	81132d74 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1132d740 	call	81132d74 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1132d740 	call	81132d74 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1132d740 	call	81132d74 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	1143c540 	call	81143c54 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	1144ec80 	call	81144ec8 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1132d740 	call	81132d74 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1132d740 	call	81132d74 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	1143c540 	call	81143c54 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	1144ec80 	call	81144ec8 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	1143c540 	call	81143c54 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	1144ec80 	call	81144ec8 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1132d740 	call	81132d74 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1132d740 	call	81132d74 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110abec0 	call	8110abec <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110abec0 	call	8110abec <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604534 	movhi	r5,33044
811030d0:	295ba704 	addi	r5,r5,28316
811030d4:	01204574 	movhi	r4,33045
811030d8:	21363004 	addi	r4,r4,-10048
811030dc:	111d42c0 	call	8111d42c <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a05c17 	ldw	r2,-32400(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	29763004 	addi	r5,r5,-10048
811030ec:	1009883a 	mov	r4,r2
811030f0:	111ba9c0 	call	8111ba9c <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604534 	movhi	r5,33044
8110311c:	295bad04 	addi	r5,r5,28340
81103120:	01204574 	movhi	r4,33045
81103124:	21363004 	addi	r4,r4,-10048
81103128:	111d42c0 	call	8111d42c <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a05c17 	ldw	r2,-32400(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	29763004 	addi	r5,r5,-10048
81103138:	1009883a 	mov	r4,r2
8110313c:	111ba9c0 	call	8111ba9c <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604534 	movhi	r5,33044
8110315c:	295bb904 	addi	r5,r5,28388
81103160:	01204574 	movhi	r4,33045
81103164:	21363004 	addi	r4,r4,-10048
81103168:	111d42c0 	call	8111d42c <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a05c17 	ldw	r2,-32400(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	29763004 	addi	r5,r5,-10048
81103178:	1009883a 	mov	r4,r2
8110317c:	111ba9c0 	call	8111ba9c <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18f63004 	addi	r3,r3,-10048
811031c0:	00a04534 	movhi	r2,33044
811031c4:	109bbf04 	addi	r2,r2,28412
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	111cb4c0 	call	8111cb4c <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a05c17 	ldw	r2,-32400(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	29763004 	addi	r5,r5,-10048
811031ec:	1009883a 	mov	r4,r2
811031f0:	111ba9c0 	call	8111ba9c <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	11099e40 	call	811099e4 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	11099e40 	call	811099e4 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04534 	movhi	r2,33044
811034f0:	109bf604 	addi	r2,r2,28632
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	111cb4c0 	call	8111cb4c <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111ae040 	call	8111ae04 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111a48c0 	call	8111a48c <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111a8d40 	call	8111a8d4 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	111b61c0 	call	8111b61c <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604534 	movhi	r5,33044
81103658:	295bc404 	addi	r5,r5,28432
8110365c:	01204574 	movhi	r4,33045
81103660:	21363004 	addi	r4,r4,-10048
81103664:	111d42c0 	call	8111d42c <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a05c17 	ldw	r2,-32400(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	29763004 	addi	r5,r5,-10048
81103674:	1009883a 	mov	r4,r2
81103678:	111ba9c0 	call	8111ba9c <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	111b61c0 	call	8111b61c <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111aefc0 	call	8111aefc <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	111b61c0 	call	8111b61c <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111aefc0 	call	8111aefc <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	111b7340 	call	8111b734 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111a48c0 	call	8111a48c <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111a8d40 	call	8111a8d4 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	111b61c0 	call	8111b61c <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	111b61c0 	call	8111b61c <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	111b61c0 	call	8111b61c <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604534 	movhi	r5,33044
811037f0:	295bcd04 	addi	r5,r5,28468
811037f4:	01204574 	movhi	r4,33045
811037f8:	21363004 	addi	r4,r4,-10048
811037fc:	111d42c0 	call	8111d42c <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a05c17 	ldw	r2,-32400(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	29763004 	addi	r5,r5,-10048
8110380c:	1009883a 	mov	r4,r2
81103810:	111ba9c0 	call	8111ba9c <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	111b61c0 	call	8111b61c <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111aefc0 	call	8111aefc <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	111b61c0 	call	8111b61c <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111aefc0 	call	8111aefc <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	111b7340 	call	8111b734 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111a48c0 	call	8111a48c <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111a8d40 	call	8111a8d4 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	111b61c0 	call	8111b61c <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	111b61c0 	call	8111b61c <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	111b61c0 	call	8111b61c <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604534 	movhi	r5,33044
81103988:	295bdd04 	addi	r5,r5,28532
8110398c:	01204574 	movhi	r4,33045
81103990:	21363004 	addi	r4,r4,-10048
81103994:	111d42c0 	call	8111d42c <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a05c17 	ldw	r2,-32400(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	29763004 	addi	r5,r5,-10048
811039a4:	1009883a 	mov	r4,r2
811039a8:	111ba9c0 	call	8111ba9c <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111a8d40 	call	8111a8d4 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	111b61c0 	call	8111b61c <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604534 	movhi	r5,33044
81103a30:	295bed04 	addi	r5,r5,28596
81103a34:	01204574 	movhi	r4,33045
81103a38:	21363004 	addi	r4,r4,-10048
81103a3c:	111d42c0 	call	8111d42c <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a05c17 	ldw	r2,-32400(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	29763004 	addi	r5,r5,-10048
81103a4c:	1009883a 	mov	r4,r2
81103a50:	111ba9c0 	call	8111ba9c <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10b63004 	addi	r2,r2,-10048
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a05c17 	ldw	r2,-32400(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	29763004 	addi	r5,r5,-10048
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	111ba9c0 	call	8111ba9c <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10b63004 	addi	r2,r2,-10048
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a05c17 	ldw	r2,-32400(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	29763004 	addi	r5,r5,-10048
81103af8:	1009883a 	mov	r4,r2
81103afc:	111ba9c0 	call	8111ba9c <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204534 	movhi	r4,33044
81103b58:	211cb604 	addi	r4,r4,29400
81103b5c:	1144c580 	call	81144c58 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	1132d740 	call	81132d74 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204534 	movhi	r4,33044
81103c08:	211cbb04 	addi	r4,r4,29420
81103c0c:	1144c580 	call	81144c58 <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	1132d740 	call	81132d74 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe904 	addi	sp,sp,-92
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01615 	stw	ra,88(sp)
81103ca0:	df001515 	stw	fp,84(sp)
81103ca4:	dc001415 	stw	r16,80(sp)
81103ca8:	df001504 	addi	fp,sp,84
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cfc:	e0bffe03 	ldbu	r2,-8(fp)
81103d00:	10c00228 	cmpgeui	r3,r2,8
81103d04:	18009c1e 	bne	r3,zero,81103f78 <bSdmaDmaM1Transfer+0x2e8>
81103d08:	100690ba 	slli	r3,r2,2
81103d0c:	00a04434 	movhi	r2,33040
81103d10:	108f4804 	addi	r2,r2,15648
81103d14:	1885883a 	add	r2,r3,r2
81103d18:	10800017 	ldw	r2,0(r2)
81103d1c:	1000683a 	jmp	r2
81103d20:	81103d40 	call	881103d4 <__reset+0x20f03d4>
81103d24:	81103d80 	call	881103d8 <__reset+0x20f03d8>
81103d28:	81103dc8 	cmpgei	r4,r16,16631
81103d2c:	81103e10 	cmplti	r4,r16,16632
81103d30:	81103e58 	cmpnei	r4,r16,16633
81103d34:	81103ea0 	cmpeqi	r4,r16,16634
81103d38:	81103ee8 	cmpgeui	r4,r16,16635
81103d3c:	81103f30 	cmpltui	r4,r16,16636
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d40:	e0bffd03 	ldbu	r2,-12(fp)
81103d44:	10000626 	beq	r2,zero,81103d60 <bSdmaDmaM1Transfer+0xd0>
81103d48:	10800060 	cmpeqi	r2,r2,1
81103d4c:	10000926 	beq	r2,zero,81103d74 <bSdmaDmaM1Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d50:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d54:	00800044 	movi	r2,1
81103d58:	e0bff715 	stw	r2,-36(fp)
			break;
81103d5c:	00000706 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d60:	00800074 	movhi	r2,1
81103d64:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d68:	00800044 	movi	r2,1
81103d6c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d70:	00000206 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		default:
			bStatus = FALSE;
81103d74:	e03ff415 	stw	zero,-48(fp)
			break;
81103d78:	0001883a 	nop
		}
		break;
81103d7c:	00008006 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d80:	e0bffd03 	ldbu	r2,-12(fp)
81103d84:	10000726 	beq	r2,zero,81103da4 <bSdmaDmaM1Transfer+0x114>
81103d88:	10800060 	cmpeqi	r2,r2,1
81103d8c:	10000b26 	beq	r2,zero,81103dbc <bSdmaDmaM1Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d90:	00880004 	movi	r2,8192
81103d94:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d98:	00800044 	movi	r2,1
81103d9c:	e0bff715 	stw	r2,-36(fp)
			break;
81103da0:	00000806 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103da4:	00800074 	movhi	r2,1
81103da8:	10880004 	addi	r2,r2,8192
81103dac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff715 	stw	r2,-36(fp)
			break;
81103db8:	00000206 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		default:
			bStatus = FALSE;
81103dbc:	e03ff415 	stw	zero,-48(fp)
			break;
81103dc0:	0001883a 	nop
		}
		break;
81103dc4:	00006e06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc8:	e0bffd03 	ldbu	r2,-12(fp)
81103dcc:	10000726 	beq	r2,zero,81103dec <bSdmaDmaM1Transfer+0x15c>
81103dd0:	10800060 	cmpeqi	r2,r2,1
81103dd4:	10000b26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd8:	00900004 	movi	r2,16384
81103ddc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103de0:	00800044 	movi	r2,1
81103de4:	e0bff715 	stw	r2,-36(fp)
			break;
81103de8:	00000806 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103dec:	00800074 	movhi	r2,1
81103df0:	10900004 	addi	r2,r2,16384
81103df4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df8:	00800044 	movi	r2,1
81103dfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103e00:	00000206 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		default:
			bStatus = FALSE;
81103e04:	e03ff415 	stw	zero,-48(fp)
			break;
81103e08:	0001883a 	nop
		}
		break;
81103e0c:	00005c06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e10:	e0bffd03 	ldbu	r2,-12(fp)
81103e14:	10000726 	beq	r2,zero,81103e34 <bSdmaDmaM1Transfer+0x1a4>
81103e18:	10800060 	cmpeqi	r2,r2,1
81103e1c:	10000b26 	beq	r2,zero,81103e4c <bSdmaDmaM1Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e20:	00980004 	movi	r2,24576
81103e24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e30:	00000806 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e34:	00800074 	movhi	r2,1
81103e38:	10980004 	addi	r2,r2,24576
81103e3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e40:	00800044 	movi	r2,1
81103e44:	e0bff715 	stw	r2,-36(fp)
			break;
81103e48:	00000206 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		default:
			bStatus = FALSE;
81103e4c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e50:	0001883a 	nop
		}
		break;
81103e54:	00004a06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e58:	e0bffd03 	ldbu	r2,-12(fp)
81103e5c:	10000726 	beq	r2,zero,81103e7c <bSdmaDmaM1Transfer+0x1ec>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	10000b26 	beq	r2,zero,81103e94 <bSdmaDmaM1Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e68:	00a00014 	movui	r2,32768
81103e6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e70:	00800044 	movi	r2,1
81103e74:	e0bff715 	stw	r2,-36(fp)
			break;
81103e78:	00000806 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e7c:	008000b4 	movhi	r2,2
81103e80:	10a00004 	addi	r2,r2,-32768
81103e84:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e88:	00800044 	movi	r2,1
81103e8c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e90:	00000206 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		default:
			bStatus = FALSE;
81103e94:	e03ff415 	stw	zero,-48(fp)
			break;
81103e98:	0001883a 	nop
		}
		break;
81103e9c:	00003806 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea0:	e0bffd03 	ldbu	r2,-12(fp)
81103ea4:	10000726 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea8:	10800060 	cmpeqi	r2,r2,1
81103eac:	10000b26 	beq	r2,zero,81103edc <bSdmaDmaM1Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103eb0:	00a80014 	movui	r2,40960
81103eb4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103eb8:	00800044 	movi	r2,1
81103ebc:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec0:	00000806 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a80004 	addi	r2,r2,-24576
81103ecc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ed8:	00000206 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		default:
			bStatus = FALSE;
81103edc:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee0:	0001883a 	nop
		}
		break;
81103ee4:	00002606 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ee8:	e0bffd03 	ldbu	r2,-12(fp)
81103eec:	10000726 	beq	r2,zero,81103f0c <bSdmaDmaM1Transfer+0x27c>
81103ef0:	10800060 	cmpeqi	r2,r2,1
81103ef4:	10000b26 	beq	r2,zero,81103f24 <bSdmaDmaM1Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103ef8:	00b00014 	movui	r2,49152
81103efc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f00:	00800044 	movi	r2,1
81103f04:	e0bff715 	stw	r2,-36(fp)
			break;
81103f08:	00000806 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f0c:	008000b4 	movhi	r2,2
81103f10:	10b00004 	addi	r2,r2,-16384
81103f14:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f18:	00800044 	movi	r2,1
81103f1c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f20:	00000206 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		default:
			bStatus = FALSE;
81103f24:	e03ff415 	stw	zero,-48(fp)
			break;
81103f28:	0001883a 	nop
		}
		break;
81103f2c:	00001406 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f30:	e0bffd03 	ldbu	r2,-12(fp)
81103f34:	10000726 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2c4>
81103f38:	10800060 	cmpeqi	r2,r2,1
81103f3c:	10000b26 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f40:	00b80014 	movui	r2,57344
81103f44:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f48:	00800044 	movi	r2,1
81103f4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f50:	00000806 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f54:	008000b4 	movhi	r2,2
81103f58:	10b80004 	addi	r2,r2,-8192
81103f5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f60:	00800044 	movi	r2,1
81103f64:	e0bff715 	stw	r2,-36(fp)
			break;
81103f68:	00000206 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		default:
			bStatus = FALSE;
81103f6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f70:	0001883a 	nop
		}
		break;
81103f74:	00000206 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	default:
		bStatus = FALSE;
81103f78:	e03ff415 	stw	zero,-48(fp)
		break;
81103f7c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f80:	e0bffb17 	ldw	r2,-20(fp)
81103f84:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f88:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f8c:	e0bff417 	ldw	r2,-48(fp)
81103f90:	10003b26 	beq	r2,zero,81104080 <bSdmaDmaM1Transfer+0x3f0>
		if (pxDmaM1Dev == NULL) {
81103f94:	d0a03917 	ldw	r2,-32540(gp)
81103f98:	1000021e 	bne	r2,zero,81103fa4 <bSdmaDmaM1Transfer+0x314>
			bStatus = FALSE;
81103f9c:	e03ff415 	stw	zero,-48(fp)
81103fa0:	00003706 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fa4:	e03ff50d 	sth	zero,-44(fp)
81103fa8:	00003206 	br	81104074 <bSdmaDmaM1Transfer+0x3e4>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fac:	01000044 	movi	r4,1
81103fb0:	11313000 	call	81131300 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fb4:	d0a03917 	ldw	r2,-32540(gp)
81103fb8:	10800317 	ldw	r2,12(r2)
81103fbc:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fc0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fc4:	103ff91e 	bne	r2,zero,81103fac <__reset+0xfb0e3fac>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fc8:	d2203917 	ldw	r8,-32540(gp)
81103fcc:	e17ff817 	ldw	r5,-32(fp)
81103fd0:	e1bff617 	ldw	r6,-40(fp)
81103fd4:	e0bff917 	ldw	r2,-28(fp)
81103fd8:	e0fff717 	ldw	r3,-36(fp)
81103fdc:	01000044 	movi	r4,1
81103fe0:	d9000815 	stw	r4,32(sp)
81103fe4:	01000044 	movi	r4,1
81103fe8:	d9000715 	stw	r4,28(sp)
81103fec:	01000044 	movi	r4,1
81103ff0:	d9000615 	stw	r4,24(sp)
81103ff4:	01000044 	movi	r4,1
81103ff8:	d9000515 	stw	r4,20(sp)
81103ffc:	01000044 	movi	r4,1
81104000:	d9000415 	stw	r4,16(sp)
81104004:	d8c00315 	stw	r3,12(sp)
81104008:	d8800215 	stw	r2,8(sp)
8110400c:	e0bffa17 	ldw	r2,-24(fp)
81104010:	d8800115 	stw	r2,4(sp)
81104014:	00802204 	movi	r2,136
81104018:	d8800015 	stw	r2,0(sp)
8110401c:	300f883a 	mov	r7,r6
81104020:	280d883a 	mov	r6,r5
81104024:	800b883a 	mov	r5,r16
81104028:	4009883a 	mov	r4,r8
8110402c:	110aaa40 	call	8110aaa4 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104030:	10000226 	beq	r2,zero,8110403c <bSdmaDmaM1Transfer+0x3ac>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104034:	e03ff415 	stw	zero,-48(fp)
					break;
81104038:	00001106 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	800b883a 	mov	r5,r16
81104044:	1009883a 	mov	r4,r2
81104048:	110aba80 	call	8110aba8 <iMsgdmaExtendedDescriptorSyncTransfer>
8110404c:	10000226 	beq	r2,zero,81104058 <bSdmaDmaM1Transfer+0x3c8>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104050:	e03ff415 	stw	zero,-48(fp)
						break;
81104054:	00000a06 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104058:	e0bff817 	ldw	r2,-32(fp)
8110405c:	10802204 	addi	r2,r2,136
81104060:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104064:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104068:	e0bff50b 	ldhu	r2,-44(fp)
8110406c:	10800044 	addi	r2,r2,1
81104070:	e0bff50d 	sth	r2,-44(fp)
81104074:	e0fff50b 	ldhu	r3,-44(fp)
81104078:	e0bffc0b 	ldhu	r2,-16(fp)
8110407c:	18bfcd36 	bltu	r3,r2,81103fb4 <__reset+0xfb0e3fb4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104080:	e0bff417 	ldw	r2,-48(fp)
}
81104084:	e6ffff04 	addi	sp,fp,-4
81104088:	dfc00217 	ldw	ra,8(sp)
8110408c:	df000117 	ldw	fp,4(sp)
81104090:	dc000017 	ldw	r16,0(sp)
81104094:	dec00304 	addi	sp,sp,12
81104098:	f800283a 	ret

8110409c <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
8110409c:	deffe904 	addi	sp,sp,-92
811040a0:	de00012e 	bgeu	sp,et,811040a8 <bSdmaDmaM2Transfer+0xc>
811040a4:	003b68fa 	trap	3
811040a8:	dfc01615 	stw	ra,88(sp)
811040ac:	df001515 	stw	fp,84(sp)
811040b0:	dc001415 	stw	r16,80(sp)
811040b4:	df001504 	addi	fp,sp,84
811040b8:	e13ffb15 	stw	r4,-20(fp)
811040bc:	2809883a 	mov	r4,r5
811040c0:	3007883a 	mov	r3,r6
811040c4:	3805883a 	mov	r2,r7
811040c8:	e13ffc0d 	sth	r4,-16(fp)
811040cc:	e0fffd05 	stb	r3,-12(fp)
811040d0:	e0bffe05 	stb	r2,-8(fp)
811040d4:	defff004 	addi	sp,sp,-64
811040d8:	d8800904 	addi	r2,sp,36
811040dc:	108007c4 	addi	r2,r2,31
811040e0:	1004d17a 	srli	r2,r2,5
811040e4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040e8:	00800044 	movi	r2,1
811040ec:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
811040f0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811040f4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
811040f8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
811040fc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104100:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104104:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104108:	e0bffe03 	ldbu	r2,-8(fp)
8110410c:	10c00228 	cmpgeui	r3,r2,8
81104110:	18009c1e 	bne	r3,zero,81104384 <bSdmaDmaM2Transfer+0x2e8>
81104114:	100690ba 	slli	r3,r2,2
81104118:	00a04434 	movhi	r2,33040
8110411c:	10904b04 	addi	r2,r2,16684
81104120:	1885883a 	add	r2,r3,r2
81104124:	10800017 	ldw	r2,0(r2)
81104128:	1000683a 	jmp	r2
8110412c:	8110414c 	andi	r4,r16,16645
81104130:	8110418c 	andi	r4,r16,16646
81104134:	811041d4 	ori	r4,r16,16647
81104138:	8110421c 	xori	r4,r16,16648
8110413c:	81104264 	muli	r4,r16,16649
81104140:	811042ac 	andhi	r4,r16,16650
81104144:	811042f4 	orhi	r4,r16,16651
81104148:	8110433c 	xorhi	r4,r16,16652
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110414c:	e0bffd03 	ldbu	r2,-12(fp)
81104150:	10000626 	beq	r2,zero,8110416c <bSdmaDmaM2Transfer+0xd0>
81104154:	10800060 	cmpeqi	r2,r2,1
81104158:	10000926 	beq	r2,zero,81104180 <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110415c:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104160:	00800044 	movi	r2,1
81104164:	e0bff715 	stw	r2,-36(fp)
			break;
81104168:	00000706 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
8110416c:	00800074 	movhi	r2,1
81104170:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104174:	00800044 	movi	r2,1
81104178:	e0bff715 	stw	r2,-36(fp)
			break;
8110417c:	00000206 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
81104180:	e03ff415 	stw	zero,-48(fp)
			break;
81104184:	0001883a 	nop
		}
		break;
81104188:	00008006 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110418c:	e0bffd03 	ldbu	r2,-12(fp)
81104190:	10000726 	beq	r2,zero,811041b0 <bSdmaDmaM2Transfer+0x114>
81104194:	10800060 	cmpeqi	r2,r2,1
81104198:	10000b26 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110419c:	00880004 	movi	r2,8192
811041a0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041a4:	00800044 	movi	r2,1
811041a8:	e0bff715 	stw	r2,-36(fp)
			break;
811041ac:	00000806 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041b0:	00800074 	movhi	r2,1
811041b4:	10880004 	addi	r2,r2,8192
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000206 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
811041c8:	e03ff415 	stw	zero,-48(fp)
			break;
811041cc:	0001883a 	nop
		}
		break;
811041d0:	00006e06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041d4:	e0bffd03 	ldbu	r2,-12(fp)
811041d8:	10000726 	beq	r2,zero,811041f8 <bSdmaDmaM2Transfer+0x15c>
811041dc:	10800060 	cmpeqi	r2,r2,1
811041e0:	10000b26 	beq	r2,zero,81104210 <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811041e4:	00900004 	movi	r2,16384
811041e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811041ec:	00800044 	movi	r2,1
811041f0:	e0bff715 	stw	r2,-36(fp)
			break;
811041f4:	00000806 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811041f8:	00800074 	movhi	r2,1
811041fc:	10900004 	addi	r2,r2,16384
81104200:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104204:	00800044 	movi	r2,1
81104208:	e0bff715 	stw	r2,-36(fp)
			break;
8110420c:	00000206 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
81104210:	e03ff415 	stw	zero,-48(fp)
			break;
81104214:	0001883a 	nop
		}
		break;
81104218:	00005c06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110421c:	e0bffd03 	ldbu	r2,-12(fp)
81104220:	10000726 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x1a4>
81104224:	10800060 	cmpeqi	r2,r2,1
81104228:	10000b26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110422c:	00980004 	movi	r2,24576
81104230:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104234:	00800044 	movi	r2,1
81104238:	e0bff715 	stw	r2,-36(fp)
			break;
8110423c:	00000806 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104240:	00800074 	movhi	r2,1
81104244:	10980004 	addi	r2,r2,24576
81104248:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8110424c:	00800044 	movi	r2,1
81104250:	e0bff715 	stw	r2,-36(fp)
			break;
81104254:	00000206 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
81104258:	e03ff415 	stw	zero,-48(fp)
			break;
8110425c:	0001883a 	nop
		}
		break;
81104260:	00004a06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104264:	e0bffd03 	ldbu	r2,-12(fp)
81104268:	10000726 	beq	r2,zero,81104288 <bSdmaDmaM2Transfer+0x1ec>
8110426c:	10800060 	cmpeqi	r2,r2,1
81104270:	10000b26 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104274:	00a00014 	movui	r2,32768
81104278:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110427c:	00800044 	movi	r2,1
81104280:	e0bff715 	stw	r2,-36(fp)
			break;
81104284:	00000806 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104288:	008000b4 	movhi	r2,2
8110428c:	10a00004 	addi	r2,r2,-32768
81104290:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104294:	00800044 	movi	r2,1
81104298:	e0bff715 	stw	r2,-36(fp)
			break;
8110429c:	00000206 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
811042a0:	e03ff415 	stw	zero,-48(fp)
			break;
811042a4:	0001883a 	nop
		}
		break;
811042a8:	00003806 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042ac:	e0bffd03 	ldbu	r2,-12(fp)
811042b0:	10000726 	beq	r2,zero,811042d0 <bSdmaDmaM2Transfer+0x234>
811042b4:	10800060 	cmpeqi	r2,r2,1
811042b8:	10000b26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042bc:	00a80014 	movui	r2,40960
811042c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042c4:	00800044 	movi	r2,1
811042c8:	e0bff715 	stw	r2,-36(fp)
			break;
811042cc:	00000806 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042d0:	008000b4 	movhi	r2,2
811042d4:	10a80004 	addi	r2,r2,-24576
811042d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811042dc:	00800044 	movi	r2,1
811042e0:	e0bff715 	stw	r2,-36(fp)
			break;
811042e4:	00000206 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
811042e8:	e03ff415 	stw	zero,-48(fp)
			break;
811042ec:	0001883a 	nop
		}
		break;
811042f0:	00002606 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811042f4:	e0bffd03 	ldbu	r2,-12(fp)
811042f8:	10000726 	beq	r2,zero,81104318 <bSdmaDmaM2Transfer+0x27c>
811042fc:	10800060 	cmpeqi	r2,r2,1
81104300:	10000b26 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104304:	00b00014 	movui	r2,49152
81104308:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
8110430c:	00800044 	movi	r2,1
81104310:	e0bff715 	stw	r2,-36(fp)
			break;
81104314:	00000806 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104318:	008000b4 	movhi	r2,2
8110431c:	10b00004 	addi	r2,r2,-16384
81104320:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104324:	00800044 	movi	r2,1
81104328:	e0bff715 	stw	r2,-36(fp)
			break;
8110432c:	00000206 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
81104330:	e03ff415 	stw	zero,-48(fp)
			break;
81104334:	0001883a 	nop
		}
		break;
81104338:	00001406 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110433c:	e0bffd03 	ldbu	r2,-12(fp)
81104340:	10000726 	beq	r2,zero,81104360 <bSdmaDmaM2Transfer+0x2c4>
81104344:	10800060 	cmpeqi	r2,r2,1
81104348:	10000b26 	beq	r2,zero,81104378 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110434c:	00b80014 	movui	r2,57344
81104350:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104354:	00800044 	movi	r2,1
81104358:	e0bff715 	stw	r2,-36(fp)
			break;
8110435c:	00000806 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104360:	008000b4 	movhi	r2,2
81104364:	10b80004 	addi	r2,r2,-8192
81104368:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
8110436c:	00800044 	movi	r2,1
81104370:	e0bff715 	stw	r2,-36(fp)
			break;
81104374:	00000206 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
81104378:	e03ff415 	stw	zero,-48(fp)
			break;
8110437c:	0001883a 	nop
		}
		break;
81104380:	00000206 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104384:	e03ff415 	stw	zero,-48(fp)
		break;
81104388:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
8110438c:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104390:	00a00034 	movhi	r2,32768
81104394:	1885883a 	add	r2,r3,r2
81104398:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110439c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043a0:	e0bff417 	ldw	r2,-48(fp)
811043a4:	10003b26 	beq	r2,zero,81104494 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
811043a8:	d0a03a17 	ldw	r2,-32536(gp)
811043ac:	1000021e 	bne	r2,zero,811043b8 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
811043b0:	e03ff415 	stw	zero,-48(fp)
811043b4:	00003706 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043b8:	e03ff50d 	sth	zero,-44(fp)
811043bc:	00003206 	br	81104488 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043c0:	01000044 	movi	r4,1
811043c4:	11313000 	call	81131300 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043c8:	d0a03a17 	ldw	r2,-32536(gp)
811043cc:	10800317 	ldw	r2,12(r2)
811043d0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811043d4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811043d8:	103ff91e 	bne	r2,zero,811043c0 <__reset+0xfb0e43c0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811043dc:	d2203a17 	ldw	r8,-32536(gp)
811043e0:	e17ff817 	ldw	r5,-32(fp)
811043e4:	e1bff617 	ldw	r6,-40(fp)
811043e8:	e0bff917 	ldw	r2,-28(fp)
811043ec:	e0fff717 	ldw	r3,-36(fp)
811043f0:	01000044 	movi	r4,1
811043f4:	d9000815 	stw	r4,32(sp)
811043f8:	01000044 	movi	r4,1
811043fc:	d9000715 	stw	r4,28(sp)
81104400:	01000044 	movi	r4,1
81104404:	d9000615 	stw	r4,24(sp)
81104408:	01000044 	movi	r4,1
8110440c:	d9000515 	stw	r4,20(sp)
81104410:	01000044 	movi	r4,1
81104414:	d9000415 	stw	r4,16(sp)
81104418:	d8c00315 	stw	r3,12(sp)
8110441c:	d8800215 	stw	r2,8(sp)
81104420:	e0bffa17 	ldw	r2,-24(fp)
81104424:	d8800115 	stw	r2,4(sp)
81104428:	00802204 	movi	r2,136
8110442c:	d8800015 	stw	r2,0(sp)
81104430:	300f883a 	mov	r7,r6
81104434:	280d883a 	mov	r6,r5
81104438:	800b883a 	mov	r5,r16
8110443c:	4009883a 	mov	r4,r8
81104440:	110aaa40 	call	8110aaa4 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104444:	10000226 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104448:	e03ff415 	stw	zero,-48(fp)
					break;
8110444c:	00001106 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104450:	d0a03a17 	ldw	r2,-32536(gp)
81104454:	800b883a 	mov	r5,r16
81104458:	1009883a 	mov	r4,r2
8110445c:	110aba80 	call	8110aba8 <iMsgdmaExtendedDescriptorSyncTransfer>
81104460:	10000226 	beq	r2,zero,8110446c <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104464:	e03ff415 	stw	zero,-48(fp)
						break;
81104468:	00000a06 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110446c:	e0bff817 	ldw	r2,-32(fp)
81104470:	10802204 	addi	r2,r2,136
81104474:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110447c:	e0bff50b 	ldhu	r2,-44(fp)
81104480:	10800044 	addi	r2,r2,1
81104484:	e0bff50d 	sth	r2,-44(fp)
81104488:	e0fff50b 	ldhu	r3,-44(fp)
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	18bfcd36 	bltu	r3,r2,811043c8 <__reset+0xfb0e43c8>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104494:	e0bff417 	ldw	r2,-48(fp)
}
81104498:	e6ffff04 	addi	sp,fp,-4
8110449c:	dfc00217 	ldw	ra,8(sp)
811044a0:	df000117 	ldw	fp,4(sp)
811044a4:	dc000017 	ldw	r16,0(sp)
811044a8:	dec00304 	addi	sp,sp,12
811044ac:	f800283a 	ret

811044b0 <bCommInitCh>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811044b0:	defffb04 	addi	sp,sp,-20
811044b4:	de00012e 	bgeu	sp,et,811044bc <bCommInitCh+0xc>
811044b8:	003b68fa 	trap	3
811044bc:	dfc00415 	stw	ra,16(sp)
811044c0:	df000315 	stw	fp,12(sp)
811044c4:	df000304 	addi	fp,sp,12
811044c8:	e13ffe15 	stw	r4,-8(fp)
811044cc:	2805883a 	mov	r2,r5
811044d0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811044d4:	00800044 	movi	r2,1
811044d8:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811044dc:	e0bffe17 	ldw	r2,-8(fp)
811044e0:	10805604 	addi	r2,r2,344
811044e4:	e0ffff03 	ldbu	r3,-4(fp)
811044e8:	180b883a 	mov	r5,r3
811044ec:	1009883a 	mov	r4,r2
811044f0:	11094280 	call	81109428 <bSpwcInitCh>
811044f4:	1000011e 	bne	r2,zero,811044fc <bCommInitCh+0x4c>
		bStatus = FALSE;
811044f8:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
811044fc:	e0bfff03 	ldbu	r2,-4(fp)
81104500:	1009883a 	mov	r4,r2
81104504:	11056400 	call	81105640 <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104508:	e0bffe17 	ldw	r2,-8(fp)
8110450c:	10800904 	addi	r2,r2,36
81104510:	e0ffff03 	ldbu	r3,-4(fp)
81104514:	180b883a 	mov	r5,r3
81104518:	1009883a 	mov	r4,r2
8110451c:	1105d380 	call	81105d38 <bFeebInitCh>
81104520:	1000011e 	bne	r2,zero,81104528 <bCommInitCh+0x78>
		bStatus = FALSE;
81104524:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104528:	e0bffe17 	ldw	r2,-8(fp)
8110452c:	10801004 	addi	r2,r2,64
81104530:	e0ffff03 	ldbu	r3,-4(fp)
81104534:	180b883a 	mov	r5,r3
81104538:	1009883a 	mov	r4,r2
8110453c:	1108a840 	call	81108a84 <bRmapInitCh>
81104540:	1000011e 	bne	r2,zero,81104548 <bCommInitCh+0x98>
		bStatus = FALSE;
81104544:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104548:	e0bfff03 	ldbu	r2,-4(fp)
8110454c:	1009883a 	mov	r4,r2
81104550:	11068c00 	call	811068c0 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104554:	e0bffe17 	ldw	r2,-8(fp)
81104558:	10800104 	addi	r2,r2,4
8110455c:	e0ffff03 	ldbu	r3,-4(fp)
81104560:	180b883a 	mov	r5,r3
81104564:	1009883a 	mov	r4,r2
81104568:	1104bb40 	call	81104bb4 <bDpktInitCh>
8110456c:	1000011e 	bne	r2,zero,81104574 <bCommInitCh+0xc4>
		bStatus = FALSE;
81104570:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81104574:	e0bffd17 	ldw	r2,-12(fp)
}
81104578:	e037883a 	mov	sp,fp
8110457c:	dfc00117 	ldw	ra,4(sp)
81104580:	df000017 	ldw	fp,0(sp)
81104584:	dec00204 	addi	sp,sp,8
81104588:	f800283a 	ret

8110458c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110458c:	defffb04 	addi	sp,sp,-20
81104590:	de00012e 	bgeu	sp,et,81104598 <bDpktSetPacketConfig+0xc>
81104594:	003b68fa 	trap	3
81104598:	dfc00415 	stw	ra,16(sp)
8110459c:	df000315 	stw	fp,12(sp)
811045a0:	df000304 	addi	fp,sp,12
811045a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811045a8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811045ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811045b0:	e0bfff17 	ldw	r2,-4(fp)
811045b4:	10007a26 	beq	r2,zero,811047a0 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811045b8:	e0bfff17 	ldw	r2,-4(fp)
811045bc:	10800017 	ldw	r2,0(r2)
811045c0:	01400204 	movi	r5,8
811045c4:	1009883a 	mov	r4,r2
811045c8:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811045cc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
811045d0:	e0bffe17 	ldw	r2,-8(fp)
811045d4:	10bfffec 	andhi	r2,r2,65535
811045d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
811045dc:	e0bfff17 	ldw	r2,-4(fp)
811045e0:	1080010b 	ldhu	r2,4(r2)
811045e4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
811045e8:	e0fffe17 	ldw	r3,-8(fp)
811045ec:	1884b03a 	or	r2,r3,r2
811045f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
811045f4:	e0bffe17 	ldw	r2,-8(fp)
811045f8:	10bfffcc 	andi	r2,r2,65535
811045fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104600:	e0bfff17 	ldw	r2,-4(fp)
81104604:	1080018b 	ldhu	r2,6(r2)
81104608:	10bfffcc 	andi	r2,r2,65535
8110460c:	1004943a 	slli	r2,r2,16
81104610:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104614:	e0bffe17 	ldw	r2,-8(fp)
81104618:	10c4b03a 	or	r2,r2,r3
8110461c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81104620:	e0bfff17 	ldw	r2,-4(fp)
81104624:	10800017 	ldw	r2,0(r2)
81104628:	e1bffe17 	ldw	r6,-8(fp)
8110462c:	01400204 	movi	r5,8
81104630:	1009883a 	mov	r4,r2
81104634:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104638:	e0bfff17 	ldw	r2,-4(fp)
8110463c:	10800017 	ldw	r2,0(r2)
81104640:	01400244 	movi	r5,9
81104644:	1009883a 	mov	r4,r2
81104648:	1104d7c0 	call	81104d7c <uliDpktReadReg>
8110464c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104650:	e0bffe17 	ldw	r2,-8(fp)
81104654:	10bfffec 	andhi	r2,r2,65535
81104658:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
8110465c:	e0bfff17 	ldw	r2,-4(fp)
81104660:	1080020b 	ldhu	r2,8(r2)
81104664:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104668:	e0fffe17 	ldw	r3,-8(fp)
8110466c:	1884b03a 	or	r2,r3,r2
81104670:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104674:	e0bffe17 	ldw	r2,-8(fp)
81104678:	10bfffcc 	andi	r2,r2,65535
8110467c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104680:	e0bfff17 	ldw	r2,-4(fp)
81104684:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104688:	10bfffcc 	andi	r2,r2,65535
8110468c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81104690:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104694:	e0bffe17 	ldw	r2,-8(fp)
81104698:	10c4b03a 	or	r2,r2,r3
8110469c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
811046a0:	e0bfff17 	ldw	r2,-4(fp)
811046a4:	10800017 	ldw	r2,0(r2)
811046a8:	e1bffe17 	ldw	r6,-8(fp)
811046ac:	01400244 	movi	r5,9
811046b0:	1009883a 	mov	r4,r2
811046b4:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811046b8:	e0bfff17 	ldw	r2,-4(fp)
811046bc:	10800017 	ldw	r2,0(r2)
811046c0:	01400284 	movi	r5,10
811046c4:	1009883a 	mov	r4,r2
811046c8:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811046cc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
811046d0:	e0bffe17 	ldw	r2,-8(fp)
811046d4:	10bfffec 	andhi	r2,r2,65535
811046d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
811046dc:	e0bfff17 	ldw	r2,-4(fp)
811046e0:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
811046e4:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
811046e8:	e0fffe17 	ldw	r3,-8(fp)
811046ec:	1884b03a 	or	r2,r3,r2
811046f0:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
811046f4:	e0bfff17 	ldw	r2,-4(fp)
811046f8:	10800017 	ldw	r2,0(r2)
811046fc:	e1bffe17 	ldw	r6,-8(fp)
81104700:	01400284 	movi	r5,10
81104704:	1009883a 	mov	r4,r2
81104708:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110470c:	e0bfff17 	ldw	r2,-4(fp)
81104710:	10800017 	ldw	r2,0(r2)
81104714:	014002c4 	movi	r5,11
81104718:	1009883a 	mov	r4,r2
8110471c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104720:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104724:	e0fffe17 	ldw	r3,-8(fp)
81104728:	00bfc004 	movi	r2,-256
8110472c:	1884703a 	and	r2,r3,r2
81104730:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104734:	e0bfff17 	ldw	r2,-4(fp)
81104738:	10800383 	ldbu	r2,14(r2)
8110473c:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104740:	e0fffe17 	ldw	r3,-8(fp)
81104744:	1884b03a 	or	r2,r3,r2
81104748:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
8110474c:	e0fffe17 	ldw	r3,-8(fp)
81104750:	00bffff4 	movhi	r2,65535
81104754:	10803fc4 	addi	r2,r2,255
81104758:	1884703a 	and	r2,r3,r2
8110475c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104760:	e0bfff17 	ldw	r2,-4(fp)
81104764:	108003c3 	ldbu	r2,15(r2)
81104768:	10803fcc 	andi	r2,r2,255
8110476c:	1004923a 	slli	r2,r2,8
81104770:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104774:	e0fffe17 	ldw	r3,-8(fp)
81104778:	1884b03a 	or	r2,r3,r2
8110477c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104780:	e0bfff17 	ldw	r2,-4(fp)
81104784:	10800017 	ldw	r2,0(r2)
81104788:	e1bffe17 	ldw	r6,-8(fp)
8110478c:	014002c4 	movi	r5,11
81104790:	1009883a 	mov	r4,r2
81104794:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104798:	00800044 	movi	r2,1
8110479c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811047a0:	e0bffd17 	ldw	r2,-12(fp)
}
811047a4:	e037883a 	mov	sp,fp
811047a8:	dfc00117 	ldw	ra,4(sp)
811047ac:	df000017 	ldw	fp,0(sp)
811047b0:	dec00204 	addi	sp,sp,8
811047b4:	f800283a 	ret

811047b8 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
811047b8:	defffb04 	addi	sp,sp,-20
811047bc:	de00012e 	bgeu	sp,et,811047c4 <bDpktGetPacketConfig+0xc>
811047c0:	003b68fa 	trap	3
811047c4:	dfc00415 	stw	ra,16(sp)
811047c8:	df000315 	stw	fp,12(sp)
811047cc:	df000304 	addi	fp,sp,12
811047d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811047d4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811047d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811047dc:	e0bfff17 	ldw	r2,-4(fp)
811047e0:	10003a26 	beq	r2,zero,811048cc <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811047e4:	e0bfff17 	ldw	r2,-4(fp)
811047e8:	10800017 	ldw	r2,0(r2)
811047ec:	01400204 	movi	r5,8
811047f0:	1009883a 	mov	r4,r2
811047f4:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811047f8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
811047fc:	e0bffe17 	ldw	r2,-8(fp)
81104800:	1007883a 	mov	r3,r2
81104804:	e0bfff17 	ldw	r2,-4(fp)
81104808:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
8110480c:	e0bffe17 	ldw	r2,-8(fp)
81104810:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104814:	1007883a 	mov	r3,r2
81104818:	e0bfff17 	ldw	r2,-4(fp)
8110481c:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104820:	e0bfff17 	ldw	r2,-4(fp)
81104824:	10800017 	ldw	r2,0(r2)
81104828:	01400244 	movi	r5,9
8110482c:	1009883a 	mov	r4,r2
81104830:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104834:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104838:	e0bffe17 	ldw	r2,-8(fp)
8110483c:	1007883a 	mov	r3,r2
81104840:	e0bfff17 	ldw	r2,-4(fp)
81104844:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104848:	e0bffe17 	ldw	r2,-8(fp)
8110484c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104850:	1007883a 	mov	r3,r2
81104854:	e0bfff17 	ldw	r2,-4(fp)
81104858:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110485c:	e0bfff17 	ldw	r2,-4(fp)
81104860:	10800017 	ldw	r2,0(r2)
81104864:	01400284 	movi	r5,10
81104868:	1009883a 	mov	r4,r2
8110486c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104870:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104874:	e0bffe17 	ldw	r2,-8(fp)
81104878:	1007883a 	mov	r3,r2
8110487c:	e0bfff17 	ldw	r2,-4(fp)
81104880:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104884:	e0bfff17 	ldw	r2,-4(fp)
81104888:	10800017 	ldw	r2,0(r2)
8110488c:	014002c4 	movi	r5,11
81104890:	1009883a 	mov	r4,r2
81104894:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104898:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
8110489c:	e0bffe17 	ldw	r2,-8(fp)
811048a0:	1007883a 	mov	r3,r2
811048a4:	e0bfff17 	ldw	r2,-4(fp)
811048a8:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
811048ac:	e0bffe17 	ldw	r2,-8(fp)
811048b0:	10bfc00c 	andi	r2,r2,65280
811048b4:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
811048b8:	1007883a 	mov	r3,r2
811048bc:	e0bfff17 	ldw	r2,-4(fp)
811048c0:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
811048c4:	00800044 	movi	r2,1
811048c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811048cc:	e0bffd17 	ldw	r2,-12(fp)
}
811048d0:	e037883a 	mov	sp,fp
811048d4:	dfc00117 	ldw	ra,4(sp)
811048d8:	df000017 	ldw	fp,0(sp)
811048dc:	dec00204 	addi	sp,sp,8
811048e0:	f800283a 	ret

811048e4 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
811048e4:	defffb04 	addi	sp,sp,-20
811048e8:	de00012e 	bgeu	sp,et,811048f0 <bDpktGetPacketHeader+0xc>
811048ec:	003b68fa 	trap	3
811048f0:	dfc00415 	stw	ra,16(sp)
811048f4:	df000315 	stw	fp,12(sp)
811048f8:	df000304 	addi	fp,sp,12
811048fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104900:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104904:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104908:	e0bfff17 	ldw	r2,-4(fp)
8110490c:	10002026 	beq	r2,zero,81104990 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104910:	e0bfff17 	ldw	r2,-4(fp)
81104914:	10800017 	ldw	r2,0(r2)
81104918:	01400304 	movi	r5,12
8110491c:	1009883a 	mov	r4,r2
81104920:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104924:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104928:	e0bffe17 	ldw	r2,-8(fp)
8110492c:	1007883a 	mov	r3,r2
81104930:	e0bfff17 	ldw	r2,-4(fp)
81104934:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104938:	e0bffe17 	ldw	r2,-8(fp)
8110493c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104940:	1007883a 	mov	r3,r2
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110494c:	e0bfff17 	ldw	r2,-4(fp)
81104950:	10800017 	ldw	r2,0(r2)
81104954:	01400344 	movi	r5,13
81104958:	1009883a 	mov	r4,r2
8110495c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104960:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104964:	e0bffe17 	ldw	r2,-8(fp)
81104968:	1007883a 	mov	r3,r2
8110496c:	e0bfff17 	ldw	r2,-4(fp)
81104970:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104974:	e0bffe17 	ldw	r2,-8(fp)
81104978:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
8110497c:	1007883a 	mov	r3,r2
81104980:	e0bfff17 	ldw	r2,-4(fp)
81104984:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104988:	00800044 	movi	r2,1
8110498c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104990:	e0bffd17 	ldw	r2,-12(fp)
}
81104994:	e037883a 	mov	sp,fp
81104998:	dfc00117 	ldw	ra,4(sp)
8110499c:	df000017 	ldw	fp,0(sp)
811049a0:	dec00204 	addi	sp,sp,8
811049a4:	f800283a 	ret

811049a8 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
811049a8:	defffb04 	addi	sp,sp,-20
811049ac:	de00012e 	bgeu	sp,et,811049b4 <bDpktSetPixelDelay+0xc>
811049b0:	003b68fa 	trap	3
811049b4:	dfc00415 	stw	ra,16(sp)
811049b8:	df000315 	stw	fp,12(sp)
811049bc:	df000304 	addi	fp,sp,12
811049c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811049c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811049cc:	e0bfff17 	ldw	r2,-4(fp)
811049d0:	10004126 	beq	r2,zero,81104ad8 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049d4:	e0bfff17 	ldw	r2,-4(fp)
811049d8:	10800017 	ldw	r2,0(r2)
811049dc:	01400384 	movi	r5,14
811049e0:	1009883a 	mov	r4,r2
811049e4:	1104d7c0 	call	81104d7c <uliDpktReadReg>
811049e8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
811049ec:	e0bffe17 	ldw	r2,-8(fp)
811049f0:	10bfffec 	andhi	r2,r2,65535
811049f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
811049f8:	e0bfff17 	ldw	r2,-4(fp)
811049fc:	1080060b 	ldhu	r2,24(r2)
81104a00:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104a04:	e0fffe17 	ldw	r3,-8(fp)
81104a08:	1884b03a 	or	r2,r3,r2
81104a0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104a10:	e0bfff17 	ldw	r2,-4(fp)
81104a14:	10800017 	ldw	r2,0(r2)
81104a18:	e1bffe17 	ldw	r6,-8(fp)
81104a1c:	01400384 	movi	r5,14
81104a20:	1009883a 	mov	r4,r2
81104a24:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a28:	e0bfff17 	ldw	r2,-4(fp)
81104a2c:	10800017 	ldw	r2,0(r2)
81104a30:	014003c4 	movi	r5,15
81104a34:	1009883a 	mov	r4,r2
81104a38:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104a3c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104a40:	e0bffe17 	ldw	r2,-8(fp)
81104a44:	10bfffec 	andhi	r2,r2,65535
81104a48:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104a4c:	e0bfff17 	ldw	r2,-4(fp)
81104a50:	1080068b 	ldhu	r2,26(r2)
81104a54:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104a58:	e0fffe17 	ldw	r3,-8(fp)
81104a5c:	1884b03a 	or	r2,r3,r2
81104a60:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104a64:	e0bfff17 	ldw	r2,-4(fp)
81104a68:	10800017 	ldw	r2,0(r2)
81104a6c:	e1bffe17 	ldw	r6,-8(fp)
81104a70:	014003c4 	movi	r5,15
81104a74:	1009883a 	mov	r4,r2
81104a78:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a7c:	e0bfff17 	ldw	r2,-4(fp)
81104a80:	10800017 	ldw	r2,0(r2)
81104a84:	01400404 	movi	r5,16
81104a88:	1009883a 	mov	r4,r2
81104a8c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104a90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104a94:	e0bffe17 	ldw	r2,-8(fp)
81104a98:	10bfffec 	andhi	r2,r2,65535
81104a9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104aa0:	e0bfff17 	ldw	r2,-4(fp)
81104aa4:	1080070b 	ldhu	r2,28(r2)
81104aa8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104aac:	e0fffe17 	ldw	r3,-8(fp)
81104ab0:	1884b03a 	or	r2,r3,r2
81104ab4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104ab8:	e0bfff17 	ldw	r2,-4(fp)
81104abc:	10800017 	ldw	r2,0(r2)
81104ac0:	e1bffe17 	ldw	r6,-8(fp)
81104ac4:	01400404 	movi	r5,16
81104ac8:	1009883a 	mov	r4,r2
81104acc:	1104d280 	call	81104d28 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104ad0:	00800044 	movi	r2,1
81104ad4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ad8:	e0bffd17 	ldw	r2,-12(fp)
}
81104adc:	e037883a 	mov	sp,fp
81104ae0:	dfc00117 	ldw	ra,4(sp)
81104ae4:	df000017 	ldw	fp,0(sp)
81104ae8:	dec00204 	addi	sp,sp,8
81104aec:	f800283a 	ret

81104af0 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104af0:	defffb04 	addi	sp,sp,-20
81104af4:	de00012e 	bgeu	sp,et,81104afc <bDpktGetPixelDelay+0xc>
81104af8:	003b68fa 	trap	3
81104afc:	dfc00415 	stw	ra,16(sp)
81104b00:	df000315 	stw	fp,12(sp)
81104b04:	df000304 	addi	fp,sp,12
81104b08:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b0c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b10:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b14:	e0bfff17 	ldw	r2,-4(fp)
81104b18:	10002026 	beq	r2,zero,81104b9c <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b1c:	e0bfff17 	ldw	r2,-4(fp)
81104b20:	10800017 	ldw	r2,0(r2)
81104b24:	01400384 	movi	r5,14
81104b28:	1009883a 	mov	r4,r2
81104b2c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104b30:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104b34:	e0bffe17 	ldw	r2,-8(fp)
81104b38:	1007883a 	mov	r3,r2
81104b3c:	e0bfff17 	ldw	r2,-4(fp)
81104b40:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b44:	e0bfff17 	ldw	r2,-4(fp)
81104b48:	10800017 	ldw	r2,0(r2)
81104b4c:	014003c4 	movi	r5,15
81104b50:	1009883a 	mov	r4,r2
81104b54:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104b58:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104b5c:	e0bffe17 	ldw	r2,-8(fp)
81104b60:	1007883a 	mov	r3,r2
81104b64:	e0bfff17 	ldw	r2,-4(fp)
81104b68:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b6c:	e0bfff17 	ldw	r2,-4(fp)
81104b70:	10800017 	ldw	r2,0(r2)
81104b74:	01400404 	movi	r5,16
81104b78:	1009883a 	mov	r4,r2
81104b7c:	1104d7c0 	call	81104d7c <uliDpktReadReg>
81104b80:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104b84:	e0bffe17 	ldw	r2,-8(fp)
81104b88:	1007883a 	mov	r3,r2
81104b8c:	e0bfff17 	ldw	r2,-4(fp)
81104b90:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104b94:	00800044 	movi	r2,1
81104b98:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b9c:	e0bffd17 	ldw	r2,-12(fp)
}
81104ba0:	e037883a 	mov	sp,fp
81104ba4:	dfc00117 	ldw	ra,4(sp)
81104ba8:	df000017 	ldw	fp,0(sp)
81104bac:	dec00204 	addi	sp,sp,8
81104bb0:	f800283a 	ret

81104bb4 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104bb4:	defffb04 	addi	sp,sp,-20
81104bb8:	de00012e 	bgeu	sp,et,81104bc0 <bDpktInitCh+0xc>
81104bbc:	003b68fa 	trap	3
81104bc0:	dfc00415 	stw	ra,16(sp)
81104bc4:	df000315 	stw	fp,12(sp)
81104bc8:	df000304 	addi	fp,sp,12
81104bcc:	e13ffe15 	stw	r4,-8(fp)
81104bd0:	2805883a 	mov	r2,r5
81104bd4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104bd8:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104bdc:	e0bffe17 	ldw	r2,-8(fp)
81104be0:	10004b26 	beq	r2,zero,81104d10 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104be4:	00800044 	movi	r2,1
81104be8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104bec:	e0bfff03 	ldbu	r2,-4(fp)
81104bf0:	10c00228 	cmpgeui	r3,r2,8
81104bf4:	1800361e 	bne	r3,zero,81104cd0 <bDpktInitCh+0x11c>
81104bf8:	100690ba 	slli	r3,r2,2
81104bfc:	00a04434 	movhi	r2,33040
81104c00:	10930404 	addi	r2,r2,19472
81104c04:	1885883a 	add	r2,r3,r2
81104c08:	10800017 	ldw	r2,0(r2)
81104c0c:	1000683a 	jmp	r2
81104c10:	81104c30 	cmpltui	r4,r16,16688
81104c14:	81104c44 	addi	r4,r16,16689
81104c18:	81104c58 	cmpnei	r4,r16,16689
81104c1c:	81104c6c 	andhi	r4,r16,16689
81104c20:	81104c80 	call	881104c8 <__reset+0x20f04c8>
81104c24:	81104c94 	ori	r4,r16,16690
81104c28:	81104ca8 	cmpgeui	r4,r16,16690
81104c2c:	81104cbc 	xorhi	r4,r16,16690
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104c30:	e0fffe17 	ldw	r3,-8(fp)
81104c34:	00a04834 	movhi	r2,33056
81104c38:	108b0004 	addi	r2,r2,11264
81104c3c:	18800015 	stw	r2,0(r3)
			break;
81104c40:	00002506 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104c44:	e0fffe17 	ldw	r3,-8(fp)
81104c48:	00a04834 	movhi	r2,33056
81104c4c:	108a0004 	addi	r2,r2,10240
81104c50:	18800015 	stw	r2,0(r3)
			break;
81104c54:	00002006 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104c58:	e0fffe17 	ldw	r3,-8(fp)
81104c5c:	00a04834 	movhi	r2,33056
81104c60:	10890004 	addi	r2,r2,9216
81104c64:	18800015 	stw	r2,0(r3)
			break;
81104c68:	00001b06 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104c6c:	e0fffe17 	ldw	r3,-8(fp)
81104c70:	00a04834 	movhi	r2,33056
81104c74:	10880004 	addi	r2,r2,8192
81104c78:	18800015 	stw	r2,0(r3)
			break;
81104c7c:	00001606 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104c80:	e0fffe17 	ldw	r3,-8(fp)
81104c84:	00a04834 	movhi	r2,33056
81104c88:	10870004 	addi	r2,r2,7168
81104c8c:	18800015 	stw	r2,0(r3)
			break;
81104c90:	00001106 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104c94:	e0fffe17 	ldw	r3,-8(fp)
81104c98:	00a04834 	movhi	r2,33056
81104c9c:	10860004 	addi	r2,r2,6144
81104ca0:	18800015 	stw	r2,0(r3)
			break;
81104ca4:	00000c06 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104ca8:	e0fffe17 	ldw	r3,-8(fp)
81104cac:	00a04834 	movhi	r2,33056
81104cb0:	10850004 	addi	r2,r2,5120
81104cb4:	18800015 	stw	r2,0(r3)
			break;
81104cb8:	00000706 	br	81104cd8 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104cbc:	e0fffe17 	ldw	r3,-8(fp)
81104cc0:	00a04834 	movhi	r2,33056
81104cc4:	10840004 	addi	r2,r2,4096
81104cc8:	18800015 	stw	r2,0(r3)
			break;
81104ccc:	00000206 	br	81104cd8 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104cd0:	e03ffd15 	stw	zero,-12(fp)
			break;
81104cd4:	0001883a 	nop
		}

		if (bStatus) {
81104cd8:	e0bffd17 	ldw	r2,-12(fp)
81104cdc:	10000c26 	beq	r2,zero,81104d10 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104ce0:	e13ffe17 	ldw	r4,-8(fp)
81104ce4:	11047b80 	call	811047b8 <bDpktGetPacketConfig>
81104ce8:	1000011e 	bne	r2,zero,81104cf0 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104cec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104cf0:	e13ffe17 	ldw	r4,-8(fp)
81104cf4:	11048e40 	call	811048e4 <bDpktGetPacketHeader>
81104cf8:	1000011e 	bne	r2,zero,81104d00 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104cfc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104d00:	e13ffe17 	ldw	r4,-8(fp)
81104d04:	1104af00 	call	81104af0 <bDpktGetPixelDelay>
81104d08:	1000011e 	bne	r2,zero,81104d10 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104d0c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104d10:	e0bffd17 	ldw	r2,-12(fp)
}
81104d14:	e037883a 	mov	sp,fp
81104d18:	dfc00117 	ldw	ra,4(sp)
81104d1c:	df000017 	ldw	fp,0(sp)
81104d20:	dec00204 	addi	sp,sp,8
81104d24:	f800283a 	ret

81104d28 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104d28:	defffc04 	addi	sp,sp,-16
81104d2c:	de00012e 	bgeu	sp,et,81104d34 <vDpktWriteReg+0xc>
81104d30:	003b68fa 	trap	3
81104d34:	df000315 	stw	fp,12(sp)
81104d38:	df000304 	addi	fp,sp,12
81104d3c:	e13ffd15 	stw	r4,-12(fp)
81104d40:	e17ffe15 	stw	r5,-8(fp)
81104d44:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104d48:	e0bffe17 	ldw	r2,-8(fp)
81104d4c:	1085883a 	add	r2,r2,r2
81104d50:	1085883a 	add	r2,r2,r2
81104d54:	1007883a 	mov	r3,r2
81104d58:	e0bffd17 	ldw	r2,-12(fp)
81104d5c:	10c5883a 	add	r2,r2,r3
81104d60:	e0ffff17 	ldw	r3,-4(fp)
81104d64:	10c00015 	stw	r3,0(r2)
}
81104d68:	0001883a 	nop
81104d6c:	e037883a 	mov	sp,fp
81104d70:	df000017 	ldw	fp,0(sp)
81104d74:	dec00104 	addi	sp,sp,4
81104d78:	f800283a 	ret

81104d7c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104d7c:	defffc04 	addi	sp,sp,-16
81104d80:	de00012e 	bgeu	sp,et,81104d88 <uliDpktReadReg+0xc>
81104d84:	003b68fa 	trap	3
81104d88:	df000315 	stw	fp,12(sp)
81104d8c:	df000304 	addi	fp,sp,12
81104d90:	e13ffe15 	stw	r4,-8(fp)
81104d94:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104d98:	e0bfff17 	ldw	r2,-4(fp)
81104d9c:	1085883a 	add	r2,r2,r2
81104da0:	1085883a 	add	r2,r2,r2
81104da4:	1007883a 	mov	r3,r2
81104da8:	e0bffe17 	ldw	r2,-8(fp)
81104dac:	10c5883a 	add	r2,r2,r3
81104db0:	10800017 	ldw	r2,0(r2)
81104db4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104db8:	e0bffd17 	ldw	r2,-12(fp)
}
81104dbc:	e037883a 	mov	sp,fp
81104dc0:	df000017 	ldw	fp,0(sp)
81104dc4:	dec00104 	addi	sp,sp,4
81104dc8:	f800283a 	ret

81104dcc <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104dcc:	defffa04 	addi	sp,sp,-24
81104dd0:	de00012e 	bgeu	sp,et,81104dd8 <vFeebCh1HandleIrq+0xc>
81104dd4:	003b68fa 	trap	3
81104dd8:	dfc00515 	stw	ra,20(sp)
81104ddc:	df000415 	stw	fp,16(sp)
81104de0:	df000404 	addi	fp,sp,16
81104de4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104de8:	e0bfff17 	ldw	r2,-4(fp)
81104dec:	e0bffc15 	stw	r2,-16(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81104df0:	00800404 	movi	r2,16
81104df4:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81104df8:	00bfe004 	movi	r2,-128
81104dfc:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81104e00:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 0;
81104e04:	e03ffe05 	stb	zero,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81104e08:	d0a05717 	ldw	r2,-32420(gp)
81104e0c:	e0fffe17 	ldw	r3,-8(fp)
81104e10:	180b883a 	mov	r5,r3
81104e14:	1009883a 	mov	r4,r2
81104e18:	11390880 	call	81139088 <OSQPost>
81104e1c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81104e20:	e0bffd03 	ldbu	r2,-12(fp)
81104e24:	10000226 	beq	r2,zero,81104e30 <vFeebCh1HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 0 );
81104e28:	0009883a 	mov	r4,zero
81104e2c:	11187940 	call	81118794 <vFailRequestDMAFromIRQ>

	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */


	vFeebCh1IrqFlagClrBufferEmpty();
81104e30:	11051600 	call	81105160 <vFeebCh1IrqFlagClrBufferEmpty>
}
81104e34:	0001883a 	nop
81104e38:	e037883a 	mov	sp,fp
81104e3c:	dfc00117 	ldw	ra,4(sp)
81104e40:	df000017 	ldw	fp,0(sp)
81104e44:	dec00204 	addi	sp,sp,8
81104e48:	f800283a 	ret

81104e4c <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81104e4c:	defffa04 	addi	sp,sp,-24
81104e50:	de00012e 	bgeu	sp,et,81104e58 <vFeebCh2HandleIrq+0xc>
81104e54:	003b68fa 	trap	3
81104e58:	dfc00515 	stw	ra,20(sp)
81104e5c:	df000415 	stw	fp,16(sp)
81104e60:	df000404 	addi	fp,sp,16
81104e64:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104e68:	e0bfff17 	ldw	r2,-4(fp)
81104e6c:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81104e70:	00800404 	movi	r2,16
81104e74:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81104e78:	00bfe004 	movi	r2,-128
81104e7c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81104e80:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
81104e84:	00800044 	movi	r2,1
81104e88:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81104e8c:	d0a05717 	ldw	r2,-32420(gp)
81104e90:	e0fffe17 	ldw	r3,-8(fp)
81104e94:	180b883a 	mov	r5,r3
81104e98:	1009883a 	mov	r4,r2
81104e9c:	11390880 	call	81139088 <OSQPost>
81104ea0:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81104ea4:	e0bffd03 	ldbu	r2,-12(fp)
81104ea8:	10000226 	beq	r2,zero,81104eb4 <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
81104eac:	01000044 	movi	r4,1
81104eb0:	11187940 	call	81118794 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
81104eb4:	11051a40 	call	811051a4 <vFeebCh2IrqFlagClrBufferEmpty>
}
81104eb8:	0001883a 	nop
81104ebc:	e037883a 	mov	sp,fp
81104ec0:	dfc00117 	ldw	ra,4(sp)
81104ec4:	df000017 	ldw	fp,0(sp)
81104ec8:	dec00204 	addi	sp,sp,8
81104ecc:	f800283a 	ret

81104ed0 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81104ed0:	defffa04 	addi	sp,sp,-24
81104ed4:	de00012e 	bgeu	sp,et,81104edc <vFeebCh3HandleIrq+0xc>
81104ed8:	003b68fa 	trap	3
81104edc:	dfc00515 	stw	ra,20(sp)
81104ee0:	df000415 	stw	fp,16(sp)
81104ee4:	df000404 	addi	fp,sp,16
81104ee8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104eec:	e0bfff17 	ldw	r2,-4(fp)
81104ef0:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81104ef4:	00800404 	movi	r2,16
81104ef8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81104efc:	00bfe004 	movi	r2,-128
81104f00:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81104f04:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81104f08:	00800084 	movi	r2,2
81104f0c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81104f10:	d0a05717 	ldw	r2,-32420(gp)
81104f14:	e0fffe17 	ldw	r3,-8(fp)
81104f18:	180b883a 	mov	r5,r3
81104f1c:	1009883a 	mov	r4,r2
81104f20:	11390880 	call	81139088 <OSQPost>
81104f24:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81104f28:	e0bffd03 	ldbu	r2,-12(fp)
81104f2c:	10000226 	beq	r2,zero,81104f38 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81104f30:	01000084 	movi	r4,2
81104f34:	11187940 	call	81118794 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81104f38:	11051e80 	call	811051e8 <vFeebCh3IrqFlagClrBufferEmpty>
}
81104f3c:	0001883a 	nop
81104f40:	e037883a 	mov	sp,fp
81104f44:	dfc00117 	ldw	ra,4(sp)
81104f48:	df000017 	ldw	fp,0(sp)
81104f4c:	dec00204 	addi	sp,sp,8
81104f50:	f800283a 	ret

81104f54 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81104f54:	defffa04 	addi	sp,sp,-24
81104f58:	de00012e 	bgeu	sp,et,81104f60 <vFeebCh4HandleIrq+0xc>
81104f5c:	003b68fa 	trap	3
81104f60:	dfc00515 	stw	ra,20(sp)
81104f64:	df000415 	stw	fp,16(sp)
81104f68:	df000404 	addi	fp,sp,16
81104f6c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104f70:	e0bfff17 	ldw	r2,-4(fp)
81104f74:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81104f78:	00800404 	movi	r2,16
81104f7c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81104f80:	00bfe004 	movi	r2,-128
81104f84:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81104f88:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
81104f8c:	008000c4 	movi	r2,3
81104f90:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81104f94:	d0a05717 	ldw	r2,-32420(gp)
81104f98:	e0fffe17 	ldw	r3,-8(fp)
81104f9c:	180b883a 	mov	r5,r3
81104fa0:	1009883a 	mov	r4,r2
81104fa4:	11390880 	call	81139088 <OSQPost>
81104fa8:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81104fac:	e0bffd03 	ldbu	r2,-12(fp)
81104fb0:	10000226 	beq	r2,zero,81104fbc <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
81104fb4:	010000c4 	movi	r4,3
81104fb8:	11187940 	call	81118794 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
81104fbc:	110522c0 	call	8110522c <vFeebCh4IrqFlagClrBufferEmpty>
}
81104fc0:	0001883a 	nop
81104fc4:	e037883a 	mov	sp,fp
81104fc8:	dfc00117 	ldw	ra,4(sp)
81104fcc:	df000017 	ldw	fp,0(sp)
81104fd0:	dec00204 	addi	sp,sp,8
81104fd4:	f800283a 	ret

81104fd8 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81104fd8:	defffa04 	addi	sp,sp,-24
81104fdc:	de00012e 	bgeu	sp,et,81104fe4 <vFeebCh5HandleIrq+0xc>
81104fe0:	003b68fa 	trap	3
81104fe4:	dfc00515 	stw	ra,20(sp)
81104fe8:	df000415 	stw	fp,16(sp)
81104fec:	df000404 	addi	fp,sp,16
81104ff0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ff4:	e0bfff17 	ldw	r2,-4(fp)
81104ff8:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81104ffc:	00800404 	movi	r2,16
81105000:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105004:	00bfe004 	movi	r2,-128
81105008:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110500c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81105010:	00800104 	movi	r2,4
81105014:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105018:	d0a05717 	ldw	r2,-32420(gp)
8110501c:	e0fffe17 	ldw	r3,-8(fp)
81105020:	180b883a 	mov	r5,r3
81105024:	1009883a 	mov	r4,r2
81105028:	11390880 	call	81139088 <OSQPost>
8110502c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105030:	e0bffd03 	ldbu	r2,-12(fp)
81105034:	10000226 	beq	r2,zero,81105040 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105038:	01000104 	movi	r4,4
8110503c:	11187940 	call	81118794 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105040:	11052700 	call	81105270 <vFeebCh5IrqFlagClrBufferEmpty>
}
81105044:	0001883a 	nop
81105048:	e037883a 	mov	sp,fp
8110504c:	dfc00117 	ldw	ra,4(sp)
81105050:	df000017 	ldw	fp,0(sp)
81105054:	dec00204 	addi	sp,sp,8
81105058:	f800283a 	ret

8110505c <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
8110505c:	defffa04 	addi	sp,sp,-24
81105060:	de00012e 	bgeu	sp,et,81105068 <vFeebCh6HandleIrq+0xc>
81105064:	003b68fa 	trap	3
81105068:	dfc00515 	stw	ra,20(sp)
8110506c:	df000415 	stw	fp,16(sp)
81105070:	df000404 	addi	fp,sp,16
81105074:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105078:	e0bfff17 	ldw	r2,-4(fp)
8110507c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105080:	00800404 	movi	r2,16
81105084:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105088:	00bfe004 	movi	r2,-128
8110508c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105090:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
81105094:	00800144 	movi	r2,5
81105098:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110509c:	d0a05717 	ldw	r2,-32420(gp)
811050a0:	e0fffe17 	ldw	r3,-8(fp)
811050a4:	180b883a 	mov	r5,r3
811050a8:	1009883a 	mov	r4,r2
811050ac:	11390880 	call	81139088 <OSQPost>
811050b0:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811050b4:	e0bffd03 	ldbu	r2,-12(fp)
811050b8:	10000226 	beq	r2,zero,811050c4 <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
811050bc:	01000144 	movi	r4,5
811050c0:	11187940 	call	81118794 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
811050c4:	11052b40 	call	811052b4 <vFeebCh6IrqFlagClrBufferEmpty>
}
811050c8:	0001883a 	nop
811050cc:	e037883a 	mov	sp,fp
811050d0:	dfc00117 	ldw	ra,4(sp)
811050d4:	df000017 	ldw	fp,0(sp)
811050d8:	dec00204 	addi	sp,sp,8
811050dc:	f800283a 	ret

811050e0 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811050e0:	defffc04 	addi	sp,sp,-16
811050e4:	de00012e 	bgeu	sp,et,811050ec <vFeebCh7HandleIrq+0xc>
811050e8:	003b68fa 	trap	3
811050ec:	dfc00315 	stw	ra,12(sp)
811050f0:	df000215 	stw	fp,8(sp)
811050f4:	df000204 	addi	fp,sp,8
811050f8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811050fc:	e0bfff17 	ldw	r2,-4(fp)
81105100:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
81105104:	11052f80 	call	811052f8 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105108:	0001883a 	nop
8110510c:	e037883a 	mov	sp,fp
81105110:	dfc00117 	ldw	ra,4(sp)
81105114:	df000017 	ldw	fp,0(sp)
81105118:	dec00204 	addi	sp,sp,8
8110511c:	f800283a 	ret

81105120 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105120:	defffc04 	addi	sp,sp,-16
81105124:	de00012e 	bgeu	sp,et,8110512c <vFeebCh8HandleIrq+0xc>
81105128:	003b68fa 	trap	3
8110512c:	dfc00315 	stw	ra,12(sp)
81105130:	df000215 	stw	fp,8(sp)
81105134:	df000204 	addi	fp,sp,8
81105138:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110513c:	e0bfff17 	ldw	r2,-4(fp)
81105140:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
81105144:	110533c0 	call	8110533c <vFeebCh8IrqFlagClrBufferEmpty>
}
81105148:	0001883a 	nop
8110514c:	e037883a 	mov	sp,fp
81105150:	dfc00117 	ldw	ra,4(sp)
81105154:	df000017 	ldw	fp,0(sp)
81105158:	dec00204 	addi	sp,sp,8
8110515c:	f800283a 	ret

81105160 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105160:	defffe04 	addi	sp,sp,-8
81105164:	de00012e 	bgeu	sp,et,8110516c <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105168:	003b68fa 	trap	3
8110516c:	dfc00115 	stw	ra,4(sp)
81105170:	df000015 	stw	fp,0(sp)
81105174:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105178:	01804004 	movi	r6,256
8110517c:	014004c4 	movi	r5,19
81105180:	01204834 	movhi	r4,33056
81105184:	210b0004 	addi	r4,r4,11264
81105188:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110518c:	0001883a 	nop
81105190:	e037883a 	mov	sp,fp
81105194:	dfc00117 	ldw	ra,4(sp)
81105198:	df000017 	ldw	fp,0(sp)
8110519c:	dec00204 	addi	sp,sp,8
811051a0:	f800283a 	ret

811051a4 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
811051a4:	defffe04 	addi	sp,sp,-8
811051a8:	de00012e 	bgeu	sp,et,811051b0 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811051ac:	003b68fa 	trap	3
811051b0:	dfc00115 	stw	ra,4(sp)
811051b4:	df000015 	stw	fp,0(sp)
811051b8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811051bc:	01804004 	movi	r6,256
811051c0:	014004c4 	movi	r5,19
811051c4:	01204834 	movhi	r4,33056
811051c8:	210a0004 	addi	r4,r4,10240
811051cc:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811051d0:	0001883a 	nop
811051d4:	e037883a 	mov	sp,fp
811051d8:	dfc00117 	ldw	ra,4(sp)
811051dc:	df000017 	ldw	fp,0(sp)
811051e0:	dec00204 	addi	sp,sp,8
811051e4:	f800283a 	ret

811051e8 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811051e8:	defffe04 	addi	sp,sp,-8
811051ec:	de00012e 	bgeu	sp,et,811051f4 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
811051f0:	003b68fa 	trap	3
811051f4:	dfc00115 	stw	ra,4(sp)
811051f8:	df000015 	stw	fp,0(sp)
811051fc:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105200:	01804004 	movi	r6,256
81105204:	014004c4 	movi	r5,19
81105208:	01204834 	movhi	r4,33056
8110520c:	21090004 	addi	r4,r4,9216
81105210:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105214:	0001883a 	nop
81105218:	e037883a 	mov	sp,fp
8110521c:	dfc00117 	ldw	ra,4(sp)
81105220:	df000017 	ldw	fp,0(sp)
81105224:	dec00204 	addi	sp,sp,8
81105228:	f800283a 	ret

8110522c <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
8110522c:	defffe04 	addi	sp,sp,-8
81105230:	de00012e 	bgeu	sp,et,81105238 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105234:	003b68fa 	trap	3
81105238:	dfc00115 	stw	ra,4(sp)
8110523c:	df000015 	stw	fp,0(sp)
81105240:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105244:	01804004 	movi	r6,256
81105248:	014004c4 	movi	r5,19
8110524c:	01204834 	movhi	r4,33056
81105250:	21080004 	addi	r4,r4,8192
81105254:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105258:	0001883a 	nop
8110525c:	e037883a 	mov	sp,fp
81105260:	dfc00117 	ldw	ra,4(sp)
81105264:	df000017 	ldw	fp,0(sp)
81105268:	dec00204 	addi	sp,sp,8
8110526c:	f800283a 	ret

81105270 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105270:	defffe04 	addi	sp,sp,-8
81105274:	de00012e 	bgeu	sp,et,8110527c <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105278:	003b68fa 	trap	3
8110527c:	dfc00115 	stw	ra,4(sp)
81105280:	df000015 	stw	fp,0(sp)
81105284:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105288:	01804004 	movi	r6,256
8110528c:	014004c4 	movi	r5,19
81105290:	01204834 	movhi	r4,33056
81105294:	21070004 	addi	r4,r4,7168
81105298:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110529c:	0001883a 	nop
811052a0:	e037883a 	mov	sp,fp
811052a4:	dfc00117 	ldw	ra,4(sp)
811052a8:	df000017 	ldw	fp,0(sp)
811052ac:	dec00204 	addi	sp,sp,8
811052b0:	f800283a 	ret

811052b4 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811052b4:	defffe04 	addi	sp,sp,-8
811052b8:	de00012e 	bgeu	sp,et,811052c0 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811052bc:	003b68fa 	trap	3
811052c0:	dfc00115 	stw	ra,4(sp)
811052c4:	df000015 	stw	fp,0(sp)
811052c8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811052cc:	01804004 	movi	r6,256
811052d0:	014004c4 	movi	r5,19
811052d4:	01204834 	movhi	r4,33056
811052d8:	21060004 	addi	r4,r4,6144
811052dc:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811052e0:	0001883a 	nop
811052e4:	e037883a 	mov	sp,fp
811052e8:	dfc00117 	ldw	ra,4(sp)
811052ec:	df000017 	ldw	fp,0(sp)
811052f0:	dec00204 	addi	sp,sp,8
811052f4:	f800283a 	ret

811052f8 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
811052f8:	defffe04 	addi	sp,sp,-8
811052fc:	de00012e 	bgeu	sp,et,81105304 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105300:	003b68fa 	trap	3
81105304:	dfc00115 	stw	ra,4(sp)
81105308:	df000015 	stw	fp,0(sp)
8110530c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105310:	01804004 	movi	r6,256
81105314:	014004c4 	movi	r5,19
81105318:	01204834 	movhi	r4,33056
8110531c:	21050004 	addi	r4,r4,5120
81105320:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105324:	0001883a 	nop
81105328:	e037883a 	mov	sp,fp
8110532c:	dfc00117 	ldw	ra,4(sp)
81105330:	df000017 	ldw	fp,0(sp)
81105334:	dec00204 	addi	sp,sp,8
81105338:	f800283a 	ret

8110533c <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
8110533c:	defffe04 	addi	sp,sp,-8
81105340:	de00012e 	bgeu	sp,et,81105348 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105344:	003b68fa 	trap	3
81105348:	dfc00115 	stw	ra,4(sp)
8110534c:	df000015 	stw	fp,0(sp)
81105350:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105354:	01804004 	movi	r6,256
81105358:	014004c4 	movi	r5,19
8110535c:	01204834 	movhi	r4,33056
81105360:	21040004 	addi	r4,r4,4096
81105364:	1105ebc0 	call	81105ebc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105368:	0001883a 	nop
8110536c:	e037883a 	mov	sp,fp
81105370:	dfc00117 	ldw	ra,4(sp)
81105374:	df000017 	ldw	fp,0(sp)
81105378:	dec00204 	addi	sp,sp,8
8110537c:	f800283a 	ret

81105380 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105380:	defffd04 	addi	sp,sp,-12
81105384:	de00012e 	bgeu	sp,et,8110538c <bFeebCh1IrqFlagBufferEmpty+0xc>
81105388:	003b68fa 	trap	3
8110538c:	dfc00215 	stw	ra,8(sp)
81105390:	df000115 	stw	fp,4(sp)
81105394:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105398:	01400484 	movi	r5,18
8110539c:	01204834 	movhi	r4,33056
811053a0:	210b0004 	addi	r4,r4,11264
811053a4:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811053a8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811053ac:	10000326 	beq	r2,zero,811053bc <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811053b0:	00800044 	movi	r2,1
811053b4:	e0bfff15 	stw	r2,-4(fp)
811053b8:	00000106 	br	811053c0 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811053bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811053c0:	e0bfff17 	ldw	r2,-4(fp)
}
811053c4:	e037883a 	mov	sp,fp
811053c8:	dfc00117 	ldw	ra,4(sp)
811053cc:	df000017 	ldw	fp,0(sp)
811053d0:	dec00204 	addi	sp,sp,8
811053d4:	f800283a 	ret

811053d8 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811053d8:	defffd04 	addi	sp,sp,-12
811053dc:	de00012e 	bgeu	sp,et,811053e4 <bFeebCh2IrqFlagBufferEmpty+0xc>
811053e0:	003b68fa 	trap	3
811053e4:	dfc00215 	stw	ra,8(sp)
811053e8:	df000115 	stw	fp,4(sp)
811053ec:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811053f0:	01400484 	movi	r5,18
811053f4:	01204834 	movhi	r4,33056
811053f8:	210a0004 	addi	r4,r4,10240
811053fc:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105400:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105404:	10000326 	beq	r2,zero,81105414 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105408:	00800044 	movi	r2,1
8110540c:	e0bfff15 	stw	r2,-4(fp)
81105410:	00000106 	br	81105418 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105414:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105418:	e0bfff17 	ldw	r2,-4(fp)
}
8110541c:	e037883a 	mov	sp,fp
81105420:	dfc00117 	ldw	ra,4(sp)
81105424:	df000017 	ldw	fp,0(sp)
81105428:	dec00204 	addi	sp,sp,8
8110542c:	f800283a 	ret

81105430 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105430:	defffd04 	addi	sp,sp,-12
81105434:	de00012e 	bgeu	sp,et,8110543c <bFeebCh3IrqFlagBufferEmpty+0xc>
81105438:	003b68fa 	trap	3
8110543c:	dfc00215 	stw	ra,8(sp)
81105440:	df000115 	stw	fp,4(sp)
81105444:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105448:	01400484 	movi	r5,18
8110544c:	01204834 	movhi	r4,33056
81105450:	21090004 	addi	r4,r4,9216
81105454:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105458:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110545c:	10000326 	beq	r2,zero,8110546c <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105460:	00800044 	movi	r2,1
81105464:	e0bfff15 	stw	r2,-4(fp)
81105468:	00000106 	br	81105470 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110546c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105470:	e0bfff17 	ldw	r2,-4(fp)
}
81105474:	e037883a 	mov	sp,fp
81105478:	dfc00117 	ldw	ra,4(sp)
8110547c:	df000017 	ldw	fp,0(sp)
81105480:	dec00204 	addi	sp,sp,8
81105484:	f800283a 	ret

81105488 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105488:	defffd04 	addi	sp,sp,-12
8110548c:	de00012e 	bgeu	sp,et,81105494 <bFeebCh4IrqFlagBufferEmpty+0xc>
81105490:	003b68fa 	trap	3
81105494:	dfc00215 	stw	ra,8(sp)
81105498:	df000115 	stw	fp,4(sp)
8110549c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811054a0:	01400484 	movi	r5,18
811054a4:	01204834 	movhi	r4,33056
811054a8:	21080004 	addi	r4,r4,8192
811054ac:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811054b0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811054b4:	10000326 	beq	r2,zero,811054c4 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811054b8:	00800044 	movi	r2,1
811054bc:	e0bfff15 	stw	r2,-4(fp)
811054c0:	00000106 	br	811054c8 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811054c4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811054c8:	e0bfff17 	ldw	r2,-4(fp)
}
811054cc:	e037883a 	mov	sp,fp
811054d0:	dfc00117 	ldw	ra,4(sp)
811054d4:	df000017 	ldw	fp,0(sp)
811054d8:	dec00204 	addi	sp,sp,8
811054dc:	f800283a 	ret

811054e0 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811054e0:	defffd04 	addi	sp,sp,-12
811054e4:	de00012e 	bgeu	sp,et,811054ec <bFeebCh5IrqFlagBufferEmpty+0xc>
811054e8:	003b68fa 	trap	3
811054ec:	dfc00215 	stw	ra,8(sp)
811054f0:	df000115 	stw	fp,4(sp)
811054f4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811054f8:	01400484 	movi	r5,18
811054fc:	01204834 	movhi	r4,33056
81105500:	21070004 	addi	r4,r4,7168
81105504:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105508:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110550c:	10000326 	beq	r2,zero,8110551c <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105510:	00800044 	movi	r2,1
81105514:	e0bfff15 	stw	r2,-4(fp)
81105518:	00000106 	br	81105520 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110551c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105520:	e0bfff17 	ldw	r2,-4(fp)
}
81105524:	e037883a 	mov	sp,fp
81105528:	dfc00117 	ldw	ra,4(sp)
8110552c:	df000017 	ldw	fp,0(sp)
81105530:	dec00204 	addi	sp,sp,8
81105534:	f800283a 	ret

81105538 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105538:	defffd04 	addi	sp,sp,-12
8110553c:	de00012e 	bgeu	sp,et,81105544 <bFeebCh6IrqFlagBufferEmpty+0xc>
81105540:	003b68fa 	trap	3
81105544:	dfc00215 	stw	ra,8(sp)
81105548:	df000115 	stw	fp,4(sp)
8110554c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105550:	01400484 	movi	r5,18
81105554:	01204834 	movhi	r4,33056
81105558:	21060004 	addi	r4,r4,6144
8110555c:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105560:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105564:	10000326 	beq	r2,zero,81105574 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105568:	00800044 	movi	r2,1
8110556c:	e0bfff15 	stw	r2,-4(fp)
81105570:	00000106 	br	81105578 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105574:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105578:	e0bfff17 	ldw	r2,-4(fp)
}
8110557c:	e037883a 	mov	sp,fp
81105580:	dfc00117 	ldw	ra,4(sp)
81105584:	df000017 	ldw	fp,0(sp)
81105588:	dec00204 	addi	sp,sp,8
8110558c:	f800283a 	ret

81105590 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105590:	defffd04 	addi	sp,sp,-12
81105594:	de00012e 	bgeu	sp,et,8110559c <bFeebCh7IrqFlagBufferEmpty+0xc>
81105598:	003b68fa 	trap	3
8110559c:	dfc00215 	stw	ra,8(sp)
811055a0:	df000115 	stw	fp,4(sp)
811055a4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811055a8:	01400484 	movi	r5,18
811055ac:	01204834 	movhi	r4,33056
811055b0:	21050004 	addi	r4,r4,5120
811055b4:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055b8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811055bc:	10000326 	beq	r2,zero,811055cc <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055c0:	00800044 	movi	r2,1
811055c4:	e0bfff15 	stw	r2,-4(fp)
811055c8:	00000106 	br	811055d0 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811055cc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055d0:	e0bfff17 	ldw	r2,-4(fp)
}
811055d4:	e037883a 	mov	sp,fp
811055d8:	dfc00117 	ldw	ra,4(sp)
811055dc:	df000017 	ldw	fp,0(sp)
811055e0:	dec00204 	addi	sp,sp,8
811055e4:	f800283a 	ret

811055e8 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811055e8:	defffd04 	addi	sp,sp,-12
811055ec:	de00012e 	bgeu	sp,et,811055f4 <bFeebCh8IrqFlagBufferEmpty+0xc>
811055f0:	003b68fa 	trap	3
811055f4:	dfc00215 	stw	ra,8(sp)
811055f8:	df000115 	stw	fp,4(sp)
811055fc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105600:	01400484 	movi	r5,18
81105604:	01204834 	movhi	r4,33056
81105608:	21040004 	addi	r4,r4,4096
8110560c:	1105f100 	call	81105f10 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105610:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105614:	10000326 	beq	r2,zero,81105624 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105618:	00800044 	movi	r2,1
8110561c:	e0bfff15 	stw	r2,-4(fp)
81105620:	00000106 	br	81105628 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105624:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105628:	e0bfff17 	ldw	r2,-4(fp)
}
8110562c:	e037883a 	mov	sp,fp
81105630:	dfc00117 	ldw	ra,4(sp)
81105634:	df000017 	ldw	fp,0(sp)
81105638:	dec00204 	addi	sp,sp,8
8110563c:	f800283a 	ret

81105640 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81105640:	defffc04 	addi	sp,sp,-16
81105644:	de00012e 	bgeu	sp,et,8110564c <vFeebInitIrq+0xc>
81105648:	003b68fa 	trap	3
8110564c:	dfc00315 	stw	ra,12(sp)
81105650:	df000215 	stw	fp,8(sp)
81105654:	df000204 	addi	fp,sp,8
81105658:	2005883a 	mov	r2,r4
8110565c:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105660:	e0bfff03 	ldbu	r2,-4(fp)
81105664:	10c00228 	cmpgeui	r3,r2,8
81105668:	18004e1e 	bne	r3,zero,811057a4 <vFeebInitIrq+0x164>
8110566c:	100690ba 	slli	r3,r2,2
81105670:	00a04434 	movhi	r2,33040
81105674:	1095a104 	addi	r2,r2,22148
81105678:	1885883a 	add	r2,r3,r2
8110567c:	10800017 	ldw	r2,0(r2)
81105680:	1000683a 	jmp	r2
81105684:	811056a4 	muli	r4,r16,16730
81105688:	811056c4 	addi	r4,r16,16731
8110568c:	811056e4 	muli	r4,r16,16731
81105690:	81105704 	addi	r4,r16,16732
81105694:	81105724 	muli	r4,r16,16732
81105698:	81105744 	addi	r4,r16,16733
8110569c:	81105764 	muli	r4,r16,16733
811056a0:	81105784 	addi	r4,r16,16734
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811056a4:	d0a03e04 	addi	r2,gp,-32520
811056a8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
811056ac:	01a04434 	movhi	r6,33040
811056b0:	31937304 	addi	r6,r6,19916
811056b4:	e17ffe17 	ldw	r5,-8(fp)
811056b8:	01000584 	movi	r4,22
811056bc:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
811056c0:	00003806 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811056c4:	d0a03f04 	addi	r2,gp,-32516
811056c8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811056cc:	01a04434 	movhi	r6,33040
811056d0:	31939304 	addi	r6,r6,20044
811056d4:	e17ffe17 	ldw	r5,-8(fp)
811056d8:	01000504 	movi	r4,20
811056dc:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
811056e0:	00003006 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811056e4:	d0a04004 	addi	r2,gp,-32512
811056e8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811056ec:	01a04434 	movhi	r6,33040
811056f0:	3193b404 	addi	r6,r6,20176
811056f4:	e17ffe17 	ldw	r5,-8(fp)
811056f8:	01000484 	movi	r4,18
811056fc:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105700:	00002806 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105704:	d0a04104 	addi	r2,gp,-32508
81105708:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
8110570c:	01a04434 	movhi	r6,33040
81105710:	3193d504 	addi	r6,r6,20308
81105714:	e17ffe17 	ldw	r5,-8(fp)
81105718:	01000404 	movi	r4,16
8110571c:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81105720:	00002006 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105724:	d0a04204 	addi	r2,gp,-32504
81105728:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
8110572c:	01a04434 	movhi	r6,33040
81105730:	3193f604 	addi	r6,r6,20440
81105734:	e17ffe17 	ldw	r5,-8(fp)
81105738:	01000204 	movi	r4,8
8110573c:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81105740:	00001806 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105744:	d0a04304 	addi	r2,gp,-32500
81105748:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
8110574c:	01a04434 	movhi	r6,33040
81105750:	31941704 	addi	r6,r6,20572
81105754:	e17ffe17 	ldw	r5,-8(fp)
81105758:	01000184 	movi	r4,6
8110575c:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81105760:	00001006 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105764:	d0a04404 	addi	r2,gp,-32496
81105768:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
8110576c:	01a04434 	movhi	r6,33040
81105770:	31943804 	addi	r6,r6,20704
81105774:	e17ffe17 	ldw	r5,-8(fp)
81105778:	01000144 	movi	r4,5
8110577c:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81105780:	00000806 	br	811057a4 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81105784:	d0a04504 	addi	r2,gp,-32492
81105788:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
8110578c:	01a04434 	movhi	r6,33040
81105790:	31944804 	addi	r6,r6,20768
81105794:	e17ffe17 	ldw	r5,-8(fp)
81105798:	01000084 	movi	r4,2
8110579c:	11316a40 	call	811316a4 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
811057a0:	0001883a 	nop
	}
}
811057a4:	0001883a 	nop
811057a8:	e037883a 	mov	sp,fp
811057ac:	dfc00117 	ldw	ra,4(sp)
811057b0:	df000017 	ldw	fp,0(sp)
811057b4:	dec00204 	addi	sp,sp,8
811057b8:	f800283a 	ret

811057bc <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811057bc:	defffb04 	addi	sp,sp,-20
811057c0:	de00012e 	bgeu	sp,et,811057c8 <bFeebSetIrqControl+0xc>
811057c4:	003b68fa 	trap	3
811057c8:	dfc00415 	stw	ra,16(sp)
811057cc:	df000315 	stw	fp,12(sp)
811057d0:	df000304 	addi	fp,sp,12
811057d4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811057d8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811057dc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811057e0:	e0bfff17 	ldw	r2,-4(fp)
811057e4:	10002426 	beq	r2,zero,81105878 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811057e8:	e0bfff17 	ldw	r2,-4(fp)
811057ec:	10800017 	ldw	r2,0(r2)
811057f0:	01400444 	movi	r5,17
811057f4:	1009883a 	mov	r4,r2
811057f8:	1105f100 	call	81105f10 <uliFeebReadReg>
811057fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81105800:	e0bfff17 	ldw	r2,-4(fp)
81105804:	10800217 	ldw	r2,8(r2)
81105808:	10000426 	beq	r2,zero,8110581c <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
8110580c:	e0bffe17 	ldw	r2,-8(fp)
81105810:	10808014 	ori	r2,r2,512
81105814:	e0bffe15 	stw	r2,-8(fp)
81105818:	00000406 	br	8110582c <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
8110581c:	e0fffe17 	ldw	r3,-8(fp)
81105820:	00bf7fc4 	movi	r2,-513
81105824:	1884703a 	and	r2,r3,r2
81105828:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
8110582c:	e0bfff17 	ldw	r2,-4(fp)
81105830:	10800317 	ldw	r2,12(r2)
81105834:	10000426 	beq	r2,zero,81105848 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81105838:	e0bffe17 	ldw	r2,-8(fp)
8110583c:	10804014 	ori	r2,r2,256
81105840:	e0bffe15 	stw	r2,-8(fp)
81105844:	00000406 	br	81105858 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81105848:	e0fffe17 	ldw	r3,-8(fp)
8110584c:	00bfbfc4 	movi	r2,-257
81105850:	1884703a 	and	r2,r3,r2
81105854:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81105858:	e0bfff17 	ldw	r2,-4(fp)
8110585c:	10800017 	ldw	r2,0(r2)
81105860:	e1bffe17 	ldw	r6,-8(fp)
81105864:	01400444 	movi	r5,17
81105868:	1009883a 	mov	r4,r2
8110586c:	1105ebc0 	call	81105ebc <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81105870:	00800044 	movi	r2,1
81105874:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105878:	e0bffd17 	ldw	r2,-12(fp)
}
8110587c:	e037883a 	mov	sp,fp
81105880:	dfc00117 	ldw	ra,4(sp)
81105884:	df000017 	ldw	fp,0(sp)
81105888:	dec00204 	addi	sp,sp,8
8110588c:	f800283a 	ret

81105890 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81105890:	defffb04 	addi	sp,sp,-20
81105894:	de00012e 	bgeu	sp,et,8110589c <bFeebGetIrqControl+0xc>
81105898:	003b68fa 	trap	3
8110589c:	dfc00415 	stw	ra,16(sp)
811058a0:	df000315 	stw	fp,12(sp)
811058a4:	df000304 	addi	fp,sp,12
811058a8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811058ac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811058b0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811058b4:	e0bfff17 	ldw	r2,-4(fp)
811058b8:	10001a26 	beq	r2,zero,81105924 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811058bc:	e0bfff17 	ldw	r2,-4(fp)
811058c0:	10800017 	ldw	r2,0(r2)
811058c4:	01400444 	movi	r5,17
811058c8:	1009883a 	mov	r4,r2
811058cc:	1105f100 	call	81105f10 <uliFeebReadReg>
811058d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811058d4:	e0bffe17 	ldw	r2,-8(fp)
811058d8:	1080800c 	andi	r2,r2,512
811058dc:	10000426 	beq	r2,zero,811058f0 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
811058e0:	e0bfff17 	ldw	r2,-4(fp)
811058e4:	00c00044 	movi	r3,1
811058e8:	10c00215 	stw	r3,8(r2)
811058ec:	00000206 	br	811058f8 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811058f0:	e0bfff17 	ldw	r2,-4(fp)
811058f4:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
811058f8:	e0bffe17 	ldw	r2,-8(fp)
811058fc:	1080400c 	andi	r2,r2,256
81105900:	10000426 	beq	r2,zero,81105914 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81105904:	e0bfff17 	ldw	r2,-4(fp)
81105908:	00c00044 	movi	r3,1
8110590c:	10c00315 	stw	r3,12(r2)
81105910:	00000206 	br	8110591c <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81105914:	e0bfff17 	ldw	r2,-4(fp)
81105918:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
8110591c:	00800044 	movi	r2,1
81105920:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105924:	e0bffd17 	ldw	r2,-12(fp)
}
81105928:	e037883a 	mov	sp,fp
8110592c:	dfc00117 	ldw	ra,4(sp)
81105930:	df000017 	ldw	fp,0(sp)
81105934:	dec00204 	addi	sp,sp,8
81105938:	f800283a 	ret

8110593c <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
8110593c:	defffb04 	addi	sp,sp,-20
81105940:	de00012e 	bgeu	sp,et,81105948 <bFeebGetIrqFlags+0xc>
81105944:	003b68fa 	trap	3
81105948:	dfc00415 	stw	ra,16(sp)
8110594c:	df000315 	stw	fp,12(sp)
81105950:	df000304 	addi	fp,sp,12
81105954:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105958:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110595c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105960:	e0bfff17 	ldw	r2,-4(fp)
81105964:	10001126 	beq	r2,zero,811059ac <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105968:	e0bfff17 	ldw	r2,-4(fp)
8110596c:	10800017 	ldw	r2,0(r2)
81105970:	01400484 	movi	r5,18
81105974:	1009883a 	mov	r4,r2
81105978:	1105f100 	call	81105f10 <uliFeebReadReg>
8110597c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105980:	e0bffe17 	ldw	r2,-8(fp)
81105984:	1080400c 	andi	r2,r2,256
81105988:	10000426 	beq	r2,zero,8110599c <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
8110598c:	e0bfff17 	ldw	r2,-4(fp)
81105990:	00c00044 	movi	r3,1
81105994:	10c00415 	stw	r3,16(r2)
81105998:	00000206 	br	811059a4 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
8110599c:	e0bfff17 	ldw	r2,-4(fp)
811059a0:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
811059a4:	00800044 	movi	r2,1
811059a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811059ac:	e0bffd17 	ldw	r2,-12(fp)
}
811059b0:	e037883a 	mov	sp,fp
811059b4:	dfc00117 	ldw	ra,4(sp)
811059b8:	df000017 	ldw	fp,0(sp)
811059bc:	dec00204 	addi	sp,sp,8
811059c0:	f800283a 	ret

811059c4 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
811059c4:	defffb04 	addi	sp,sp,-20
811059c8:	de00012e 	bgeu	sp,et,811059d0 <bFeebGetBuffersStatus+0xc>
811059cc:	003b68fa 	trap	3
811059d0:	dfc00415 	stw	ra,16(sp)
811059d4:	df000315 	stw	fp,12(sp)
811059d8:	df000304 	addi	fp,sp,12
811059dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811059e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811059e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811059e8:	e0bfff17 	ldw	r2,-4(fp)
811059ec:	10001a26 	beq	r2,zero,81105a58 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811059f0:	e0bfff17 	ldw	r2,-4(fp)
811059f4:	10800017 	ldw	r2,0(r2)
811059f8:	014000c4 	movi	r5,3
811059fc:	1009883a 	mov	r4,r2
81105a00:	1105f100 	call	81105f10 <uliFeebReadReg>
81105a04:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81105a08:	e0bffe17 	ldw	r2,-8(fp)
81105a0c:	1080008c 	andi	r2,r2,2
81105a10:	10000426 	beq	r2,zero,81105a24 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81105a14:	e0bfff17 	ldw	r2,-4(fp)
81105a18:	00c00044 	movi	r3,1
81105a1c:	10c00515 	stw	r3,20(r2)
81105a20:	00000206 	br	81105a2c <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81105a24:	e0bfff17 	ldw	r2,-4(fp)
81105a28:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81105a2c:	e0bffe17 	ldw	r2,-8(fp)
81105a30:	1080004c 	andi	r2,r2,1
81105a34:	10000426 	beq	r2,zero,81105a48 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81105a38:	e0bfff17 	ldw	r2,-4(fp)
81105a3c:	00c00044 	movi	r3,1
81105a40:	10c00615 	stw	r3,24(r2)
81105a44:	00000206 	br	81105a50 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81105a48:	e0bfff17 	ldw	r2,-4(fp)
81105a4c:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
81105a50:	00800044 	movi	r2,1
81105a54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105a58:	e0bffd17 	ldw	r2,-12(fp)
}
81105a5c:	e037883a 	mov	sp,fp
81105a60:	dfc00117 	ldw	ra,4(sp)
81105a64:	df000017 	ldw	fp,0(sp)
81105a68:	dec00204 	addi	sp,sp,8
81105a6c:	f800283a 	ret

81105a70 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81105a70:	defffb04 	addi	sp,sp,-20
81105a74:	de00012e 	bgeu	sp,et,81105a7c <bFeebSetWindowing+0xc>
81105a78:	003b68fa 	trap	3
81105a7c:	dfc00415 	stw	ra,16(sp)
81105a80:	df000315 	stw	fp,12(sp)
81105a84:	df000304 	addi	fp,sp,12
81105a88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105a8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105a90:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105a94:	e0bfff17 	ldw	r2,-4(fp)
81105a98:	10001926 	beq	r2,zero,81105b00 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105a9c:	e0bfff17 	ldw	r2,-4(fp)
81105aa0:	10800017 	ldw	r2,0(r2)
81105aa4:	01400084 	movi	r5,2
81105aa8:	1009883a 	mov	r4,r2
81105aac:	1105f100 	call	81105f10 <uliFeebReadReg>
81105ab0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81105ab4:	e0bfff17 	ldw	r2,-4(fp)
81105ab8:	10800117 	ldw	r2,4(r2)
81105abc:	10000426 	beq	r2,zero,81105ad0 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81105ac0:	e0bffe17 	ldw	r2,-8(fp)
81105ac4:	10800214 	ori	r2,r2,8
81105ac8:	e0bffe15 	stw	r2,-8(fp)
81105acc:	00000406 	br	81105ae0 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81105ad0:	e0fffe17 	ldw	r3,-8(fp)
81105ad4:	00bffdc4 	movi	r2,-9
81105ad8:	1884703a 	and	r2,r3,r2
81105adc:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105ae0:	e0bfff17 	ldw	r2,-4(fp)
81105ae4:	10800017 	ldw	r2,0(r2)
81105ae8:	e1bffe17 	ldw	r6,-8(fp)
81105aec:	01400084 	movi	r5,2
81105af0:	1009883a 	mov	r4,r2
81105af4:	1105ebc0 	call	81105ebc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105af8:	00800044 	movi	r2,1
81105afc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b00:	e0bffd17 	ldw	r2,-12(fp)
}
81105b04:	e037883a 	mov	sp,fp
81105b08:	dfc00117 	ldw	ra,4(sp)
81105b0c:	df000017 	ldw	fp,0(sp)
81105b10:	dec00204 	addi	sp,sp,8
81105b14:	f800283a 	ret

81105b18 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81105b18:	defffb04 	addi	sp,sp,-20
81105b1c:	de00012e 	bgeu	sp,et,81105b24 <bFeebGetWindowing+0xc>
81105b20:	003b68fa 	trap	3
81105b24:	dfc00415 	stw	ra,16(sp)
81105b28:	df000315 	stw	fp,12(sp)
81105b2c:	df000304 	addi	fp,sp,12
81105b30:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105b34:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105b38:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105b3c:	e0bfff17 	ldw	r2,-4(fp)
81105b40:	10001126 	beq	r2,zero,81105b88 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105b44:	e0bfff17 	ldw	r2,-4(fp)
81105b48:	10800017 	ldw	r2,0(r2)
81105b4c:	01400084 	movi	r5,2
81105b50:	1009883a 	mov	r4,r2
81105b54:	1105f100 	call	81105f10 <uliFeebReadReg>
81105b58:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81105b5c:	e0bffe17 	ldw	r2,-8(fp)
81105b60:	1080020c 	andi	r2,r2,8
81105b64:	10000426 	beq	r2,zero,81105b78 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81105b68:	e0bfff17 	ldw	r2,-4(fp)
81105b6c:	00c00044 	movi	r3,1
81105b70:	10c00115 	stw	r3,4(r2)
81105b74:	00000206 	br	81105b80 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105b78:	e0bfff17 	ldw	r2,-4(fp)
81105b7c:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81105b80:	00800044 	movi	r2,1
81105b84:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b88:	e0bffd17 	ldw	r2,-12(fp)
}
81105b8c:	e037883a 	mov	sp,fp
81105b90:	dfc00117 	ldw	ra,4(sp)
81105b94:	df000017 	ldw	fp,0(sp)
81105b98:	dec00204 	addi	sp,sp,8
81105b9c:	f800283a 	ret

81105ba0 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81105ba0:	defffb04 	addi	sp,sp,-20
81105ba4:	de00012e 	bgeu	sp,et,81105bac <bFeebStartCh+0xc>
81105ba8:	003b68fa 	trap	3
81105bac:	dfc00415 	stw	ra,16(sp)
81105bb0:	df000315 	stw	fp,12(sp)
81105bb4:	df000304 	addi	fp,sp,12
81105bb8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105bbc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105bc0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105bc4:	e0bfff17 	ldw	r2,-4(fp)
81105bc8:	10001126 	beq	r2,zero,81105c10 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105bcc:	e0bfff17 	ldw	r2,-4(fp)
81105bd0:	10800017 	ldw	r2,0(r2)
81105bd4:	01400084 	movi	r5,2
81105bd8:	1009883a 	mov	r4,r2
81105bdc:	1105f100 	call	81105f10 <uliFeebReadReg>
81105be0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81105be4:	e0bffe17 	ldw	r2,-8(fp)
81105be8:	10800114 	ori	r2,r2,4
81105bec:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105bf0:	e0bfff17 	ldw	r2,-4(fp)
81105bf4:	10800017 	ldw	r2,0(r2)
81105bf8:	e1bffe17 	ldw	r6,-8(fp)
81105bfc:	01400084 	movi	r5,2
81105c00:	1009883a 	mov	r4,r2
81105c04:	1105ebc0 	call	81105ebc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105c08:	00800044 	movi	r2,1
81105c0c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105c10:	e0bffd17 	ldw	r2,-12(fp)
}
81105c14:	e037883a 	mov	sp,fp
81105c18:	dfc00117 	ldw	ra,4(sp)
81105c1c:	df000017 	ldw	fp,0(sp)
81105c20:	dec00204 	addi	sp,sp,8
81105c24:	f800283a 	ret

81105c28 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81105c28:	defffb04 	addi	sp,sp,-20
81105c2c:	de00012e 	bgeu	sp,et,81105c34 <bFeebStopCh+0xc>
81105c30:	003b68fa 	trap	3
81105c34:	dfc00415 	stw	ra,16(sp)
81105c38:	df000315 	stw	fp,12(sp)
81105c3c:	df000304 	addi	fp,sp,12
81105c40:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105c44:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105c48:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105c4c:	e0bfff17 	ldw	r2,-4(fp)
81105c50:	10001126 	beq	r2,zero,81105c98 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105c54:	e0bfff17 	ldw	r2,-4(fp)
81105c58:	10800017 	ldw	r2,0(r2)
81105c5c:	01400084 	movi	r5,2
81105c60:	1009883a 	mov	r4,r2
81105c64:	1105f100 	call	81105f10 <uliFeebReadReg>
81105c68:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81105c6c:	e0bffe17 	ldw	r2,-8(fp)
81105c70:	10800094 	ori	r2,r2,2
81105c74:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105c78:	e0bfff17 	ldw	r2,-4(fp)
81105c7c:	10800017 	ldw	r2,0(r2)
81105c80:	e1bffe17 	ldw	r6,-8(fp)
81105c84:	01400084 	movi	r5,2
81105c88:	1009883a 	mov	r4,r2
81105c8c:	1105ebc0 	call	81105ebc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105c90:	00800044 	movi	r2,1
81105c94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105c98:	e0bffd17 	ldw	r2,-12(fp)
}
81105c9c:	e037883a 	mov	sp,fp
81105ca0:	dfc00117 	ldw	ra,4(sp)
81105ca4:	df000017 	ldw	fp,0(sp)
81105ca8:	dec00204 	addi	sp,sp,8
81105cac:	f800283a 	ret

81105cb0 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81105cb0:	defffb04 	addi	sp,sp,-20
81105cb4:	de00012e 	bgeu	sp,et,81105cbc <bFeebClrCh+0xc>
81105cb8:	003b68fa 	trap	3
81105cbc:	dfc00415 	stw	ra,16(sp)
81105cc0:	df000315 	stw	fp,12(sp)
81105cc4:	df000304 	addi	fp,sp,12
81105cc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105ccc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105cd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105cd4:	e0bfff17 	ldw	r2,-4(fp)
81105cd8:	10001126 	beq	r2,zero,81105d20 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105cdc:	e0bfff17 	ldw	r2,-4(fp)
81105ce0:	10800017 	ldw	r2,0(r2)
81105ce4:	01400084 	movi	r5,2
81105ce8:	1009883a 	mov	r4,r2
81105cec:	1105f100 	call	81105f10 <uliFeebReadReg>
81105cf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81105cf4:	e0bffe17 	ldw	r2,-8(fp)
81105cf8:	10800054 	ori	r2,r2,1
81105cfc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105d00:	e0bfff17 	ldw	r2,-4(fp)
81105d04:	10800017 	ldw	r2,0(r2)
81105d08:	e1bffe17 	ldw	r6,-8(fp)
81105d0c:	01400084 	movi	r5,2
81105d10:	1009883a 	mov	r4,r2
81105d14:	1105ebc0 	call	81105ebc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105d18:	00800044 	movi	r2,1
81105d1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105d20:	e0bffd17 	ldw	r2,-12(fp)
}
81105d24:	e037883a 	mov	sp,fp
81105d28:	dfc00117 	ldw	ra,4(sp)
81105d2c:	df000017 	ldw	fp,0(sp)
81105d30:	dec00204 	addi	sp,sp,8
81105d34:	f800283a 	ret

81105d38 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81105d38:	defffb04 	addi	sp,sp,-20
81105d3c:	de00012e 	bgeu	sp,et,81105d44 <bFeebInitCh+0xc>
81105d40:	003b68fa 	trap	3
81105d44:	dfc00415 	stw	ra,16(sp)
81105d48:	df000315 	stw	fp,12(sp)
81105d4c:	df000304 	addi	fp,sp,12
81105d50:	e13ffe15 	stw	r4,-8(fp)
81105d54:	2805883a 	mov	r2,r5
81105d58:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105d5c:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81105d60:	e0bffe17 	ldw	r2,-8(fp)
81105d64:	10004f26 	beq	r2,zero,81105ea4 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81105d68:	00800044 	movi	r2,1
81105d6c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105d70:	e0bfff03 	ldbu	r2,-4(fp)
81105d74:	10c00228 	cmpgeui	r3,r2,8
81105d78:	1800361e 	bne	r3,zero,81105e54 <bFeebInitCh+0x11c>
81105d7c:	100690ba 	slli	r3,r2,2
81105d80:	00a04434 	movhi	r2,33040
81105d84:	10976504 	addi	r2,r2,23956
81105d88:	1885883a 	add	r2,r3,r2
81105d8c:	10800017 	ldw	r2,0(r2)
81105d90:	1000683a 	jmp	r2
81105d94:	81105db4 	orhi	r4,r16,16758
81105d98:	81105dc8 	cmpgei	r4,r16,16759
81105d9c:	81105ddc 	xori	r4,r16,16759
81105da0:	81105df0 	cmpltui	r4,r16,16759
81105da4:	81105e04 	addi	r4,r16,16760
81105da8:	81105e18 	cmpnei	r4,r16,16760
81105dac:	81105e2c 	andhi	r4,r16,16760
81105db0:	81105e40 	call	881105e4 <__reset+0x20f05e4>
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105db4:	e0fffe17 	ldw	r3,-8(fp)
81105db8:	00a04834 	movhi	r2,33056
81105dbc:	108b0004 	addi	r2,r2,11264
81105dc0:	18800015 	stw	r2,0(r3)
			break;
81105dc4:	00002506 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105dc8:	e0fffe17 	ldw	r3,-8(fp)
81105dcc:	00a04834 	movhi	r2,33056
81105dd0:	108a0004 	addi	r2,r2,10240
81105dd4:	18800015 	stw	r2,0(r3)
			break;
81105dd8:	00002006 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105ddc:	e0fffe17 	ldw	r3,-8(fp)
81105de0:	00a04834 	movhi	r2,33056
81105de4:	10890004 	addi	r2,r2,9216
81105de8:	18800015 	stw	r2,0(r3)
			break;
81105dec:	00001b06 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81105df0:	e0fffe17 	ldw	r3,-8(fp)
81105df4:	00a04834 	movhi	r2,33056
81105df8:	10880004 	addi	r2,r2,8192
81105dfc:	18800015 	stw	r2,0(r3)
			break;
81105e00:	00001606 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81105e04:	e0fffe17 	ldw	r3,-8(fp)
81105e08:	00a04834 	movhi	r2,33056
81105e0c:	10870004 	addi	r2,r2,7168
81105e10:	18800015 	stw	r2,0(r3)
			break;
81105e14:	00001106 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81105e18:	e0fffe17 	ldw	r3,-8(fp)
81105e1c:	00a04834 	movhi	r2,33056
81105e20:	10860004 	addi	r2,r2,6144
81105e24:	18800015 	stw	r2,0(r3)
			break;
81105e28:	00000c06 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105e2c:	e0fffe17 	ldw	r3,-8(fp)
81105e30:	00a04834 	movhi	r2,33056
81105e34:	10850004 	addi	r2,r2,5120
81105e38:	18800015 	stw	r2,0(r3)
			break;
81105e3c:	00000706 	br	81105e5c <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81105e40:	e0fffe17 	ldw	r3,-8(fp)
81105e44:	00a04834 	movhi	r2,33056
81105e48:	10840004 	addi	r2,r2,4096
81105e4c:	18800015 	stw	r2,0(r3)
			break;
81105e50:	00000206 	br	81105e5c <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81105e54:	e03ffd15 	stw	zero,-12(fp)
			break;
81105e58:	0001883a 	nop
		}

		if (bStatus) {
81105e5c:	e0bffd17 	ldw	r2,-12(fp)
81105e60:	10001026 	beq	r2,zero,81105ea4 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81105e64:	e13ffe17 	ldw	r4,-8(fp)
81105e68:	11058900 	call	81105890 <bFeebGetIrqControl>
81105e6c:	1000011e 	bne	r2,zero,81105e74 <bFeebInitCh+0x13c>
				bStatus = FALSE;
81105e70:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81105e74:	e13ffe17 	ldw	r4,-8(fp)
81105e78:	110593c0 	call	8110593c <bFeebGetIrqFlags>
81105e7c:	1000011e 	bne	r2,zero,81105e84 <bFeebInitCh+0x14c>
				bStatus = FALSE;
81105e80:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81105e84:	e13ffe17 	ldw	r4,-8(fp)
81105e88:	11059c40 	call	811059c4 <bFeebGetBuffersStatus>
81105e8c:	1000011e 	bne	r2,zero,81105e94 <bFeebInitCh+0x15c>
				bStatus = FALSE;
81105e90:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81105e94:	e13ffe17 	ldw	r4,-8(fp)
81105e98:	1105b180 	call	81105b18 <bFeebGetWindowing>
81105e9c:	1000011e 	bne	r2,zero,81105ea4 <bFeebInitCh+0x16c>
				bStatus = FALSE;
81105ea0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81105ea4:	e0bffd17 	ldw	r2,-12(fp)
}
81105ea8:	e037883a 	mov	sp,fp
81105eac:	dfc00117 	ldw	ra,4(sp)
81105eb0:	df000017 	ldw	fp,0(sp)
81105eb4:	dec00204 	addi	sp,sp,8
81105eb8:	f800283a 	ret

81105ebc <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81105ebc:	defffc04 	addi	sp,sp,-16
81105ec0:	de00012e 	bgeu	sp,et,81105ec8 <vFeebWriteReg+0xc>
81105ec4:	003b68fa 	trap	3
81105ec8:	df000315 	stw	fp,12(sp)
81105ecc:	df000304 	addi	fp,sp,12
81105ed0:	e13ffd15 	stw	r4,-12(fp)
81105ed4:	e17ffe15 	stw	r5,-8(fp)
81105ed8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81105edc:	e0bffe17 	ldw	r2,-8(fp)
81105ee0:	1085883a 	add	r2,r2,r2
81105ee4:	1085883a 	add	r2,r2,r2
81105ee8:	1007883a 	mov	r3,r2
81105eec:	e0bffd17 	ldw	r2,-12(fp)
81105ef0:	10c5883a 	add	r2,r2,r3
81105ef4:	e0ffff17 	ldw	r3,-4(fp)
81105ef8:	10c00015 	stw	r3,0(r2)
}
81105efc:	0001883a 	nop
81105f00:	e037883a 	mov	sp,fp
81105f04:	df000017 	ldw	fp,0(sp)
81105f08:	dec00104 	addi	sp,sp,4
81105f0c:	f800283a 	ret

81105f10 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105f10:	defffc04 	addi	sp,sp,-16
81105f14:	de00012e 	bgeu	sp,et,81105f1c <uliFeebReadReg+0xc>
81105f18:	003b68fa 	trap	3
81105f1c:	df000315 	stw	fp,12(sp)
81105f20:	df000304 	addi	fp,sp,12
81105f24:	e13ffe15 	stw	r4,-8(fp)
81105f28:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105f2c:	e0bfff17 	ldw	r2,-4(fp)
81105f30:	1085883a 	add	r2,r2,r2
81105f34:	1085883a 	add	r2,r2,r2
81105f38:	1007883a 	mov	r3,r2
81105f3c:	e0bffe17 	ldw	r2,-8(fp)
81105f40:	10c5883a 	add	r2,r2,r3
81105f44:	10800017 	ldw	r2,0(r2)
81105f48:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105f4c:	e0bffd17 	ldw	r2,-12(fp)
}
81105f50:	e037883a 	mov	sp,fp
81105f54:	df000017 	ldw	fp,0(sp)
81105f58:	dec00104 	addi	sp,sp,4
81105f5c:	f800283a 	ret

81105f60 <vRmapCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRmapCh1HandleIrq(void* pvContext) {
81105f60:	defffc04 	addi	sp,sp,-16
81105f64:	de00012e 	bgeu	sp,et,81105f6c <vRmapCh1HandleIrq+0xc>
81105f68:	003b68fa 	trap	3
81105f6c:	dfc00315 	stw	ra,12(sp)
81105f70:	df000215 	stw	fp,8(sp)
81105f74:	df000204 	addi	fp,sp,8
81105f78:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105f7c:	e0bfff17 	ldw	r2,-4(fp)
81105f80:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh1IrqFlagClrWriteCmd();
81105f84:	11061600 	call	81106160 <vRmapCh1IrqFlagClrWriteCmd>
}
81105f88:	0001883a 	nop
81105f8c:	e037883a 	mov	sp,fp
81105f90:	dfc00117 	ldw	ra,4(sp)
81105f94:	df000017 	ldw	fp,0(sp)
81105f98:	dec00204 	addi	sp,sp,8
81105f9c:	f800283a 	ret

81105fa0 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81105fa0:	defffc04 	addi	sp,sp,-16
81105fa4:	de00012e 	bgeu	sp,et,81105fac <vRmapCh2HandleIrq+0xc>
81105fa8:	003b68fa 	trap	3
81105fac:	dfc00315 	stw	ra,12(sp)
81105fb0:	df000215 	stw	fp,8(sp)
81105fb4:	df000204 	addi	fp,sp,8
81105fb8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105fbc:	e0bfff17 	ldw	r2,-4(fp)
81105fc0:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81105fc4:	11061a40 	call	811061a4 <vRmapCh2IrqFlagClrWriteCmd>
}
81105fc8:	0001883a 	nop
81105fcc:	e037883a 	mov	sp,fp
81105fd0:	dfc00117 	ldw	ra,4(sp)
81105fd4:	df000017 	ldw	fp,0(sp)
81105fd8:	dec00204 	addi	sp,sp,8
81105fdc:	f800283a 	ret

81105fe0 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81105fe0:	defffc04 	addi	sp,sp,-16
81105fe4:	de00012e 	bgeu	sp,et,81105fec <vRmapCh3HandleIrq+0xc>
81105fe8:	003b68fa 	trap	3
81105fec:	dfc00315 	stw	ra,12(sp)
81105ff0:	df000215 	stw	fp,8(sp)
81105ff4:	df000204 	addi	fp,sp,8
81105ff8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105ffc:	e0bfff17 	ldw	r2,-4(fp)
81106000:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106004:	11061e80 	call	811061e8 <vRmapCh3IrqFlagClrWriteCmd>
}
81106008:	0001883a 	nop
8110600c:	e037883a 	mov	sp,fp
81106010:	dfc00117 	ldw	ra,4(sp)
81106014:	df000017 	ldw	fp,0(sp)
81106018:	dec00204 	addi	sp,sp,8
8110601c:	f800283a 	ret

81106020 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106020:	defffc04 	addi	sp,sp,-16
81106024:	de00012e 	bgeu	sp,et,8110602c <vRmapCh4HandleIrq+0xc>
81106028:	003b68fa 	trap	3
8110602c:	dfc00315 	stw	ra,12(sp)
81106030:	df000215 	stw	fp,8(sp)
81106034:	df000204 	addi	fp,sp,8
81106038:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110603c:	e0bfff17 	ldw	r2,-4(fp)
81106040:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106044:	110622c0 	call	8110622c <vRmapCh4IrqFlagClrWriteCmd>
}
81106048:	0001883a 	nop
8110604c:	e037883a 	mov	sp,fp
81106050:	dfc00117 	ldw	ra,4(sp)
81106054:	df000017 	ldw	fp,0(sp)
81106058:	dec00204 	addi	sp,sp,8
8110605c:	f800283a 	ret

81106060 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106060:	defffc04 	addi	sp,sp,-16
81106064:	de00012e 	bgeu	sp,et,8110606c <vRmapCh5HandleIrq+0xc>
81106068:	003b68fa 	trap	3
8110606c:	dfc00315 	stw	ra,12(sp)
81106070:	df000215 	stw	fp,8(sp)
81106074:	df000204 	addi	fp,sp,8
81106078:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110607c:	e0bfff17 	ldw	r2,-4(fp)
81106080:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106084:	11062700 	call	81106270 <vRmapCh5IrqFlagClrWriteCmd>
}
81106088:	0001883a 	nop
8110608c:	e037883a 	mov	sp,fp
81106090:	dfc00117 	ldw	ra,4(sp)
81106094:	df000017 	ldw	fp,0(sp)
81106098:	dec00204 	addi	sp,sp,8
8110609c:	f800283a 	ret

811060a0 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
811060a0:	defffc04 	addi	sp,sp,-16
811060a4:	de00012e 	bgeu	sp,et,811060ac <vRmapCh6HandleIrq+0xc>
811060a8:	003b68fa 	trap	3
811060ac:	dfc00315 	stw	ra,12(sp)
811060b0:	df000215 	stw	fp,8(sp)
811060b4:	df000204 	addi	fp,sp,8
811060b8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811060bc:	e0bfff17 	ldw	r2,-4(fp)
811060c0:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
811060c4:	11062b40 	call	811062b4 <vRmapCh6IrqFlagClrWriteCmd>
}
811060c8:	0001883a 	nop
811060cc:	e037883a 	mov	sp,fp
811060d0:	dfc00117 	ldw	ra,4(sp)
811060d4:	df000017 	ldw	fp,0(sp)
811060d8:	dec00204 	addi	sp,sp,8
811060dc:	f800283a 	ret

811060e0 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
811060e0:	defffc04 	addi	sp,sp,-16
811060e4:	de00012e 	bgeu	sp,et,811060ec <vRmapCh7HandleIrq+0xc>
811060e8:	003b68fa 	trap	3
811060ec:	dfc00315 	stw	ra,12(sp)
811060f0:	df000215 	stw	fp,8(sp)
811060f4:	df000204 	addi	fp,sp,8
811060f8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811060fc:	e0bfff17 	ldw	r2,-4(fp)
81106100:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106104:	11062f80 	call	811062f8 <vRmapCh7IrqFlagClrWriteCmd>
}
81106108:	0001883a 	nop
8110610c:	e037883a 	mov	sp,fp
81106110:	dfc00117 	ldw	ra,4(sp)
81106114:	df000017 	ldw	fp,0(sp)
81106118:	dec00204 	addi	sp,sp,8
8110611c:	f800283a 	ret

81106120 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106120:	defffc04 	addi	sp,sp,-16
81106124:	de00012e 	bgeu	sp,et,8110612c <vRmapCh8HandleIrq+0xc>
81106128:	003b68fa 	trap	3
8110612c:	dfc00315 	stw	ra,12(sp)
81106130:	df000215 	stw	fp,8(sp)
81106134:	df000204 	addi	fp,sp,8
81106138:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110613c:	e0bfff17 	ldw	r2,-4(fp)
81106140:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106144:	110633c0 	call	8110633c <vRmapCh8IrqFlagClrWriteCmd>
}
81106148:	0001883a 	nop
8110614c:	e037883a 	mov	sp,fp
81106150:	dfc00117 	ldw	ra,4(sp)
81106154:	df000017 	ldw	fp,0(sp)
81106158:	dec00204 	addi	sp,sp,8
8110615c:	f800283a 	ret

81106160 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106160:	defffe04 	addi	sp,sp,-8
81106164:	de00012e 	bgeu	sp,et,8110616c <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106168:	003b68fa 	trap	3
8110616c:	dfc00115 	stw	ra,4(sp)
81106170:	df000015 	stw	fp,0(sp)
81106174:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106178:	01800044 	movi	r6,1
8110617c:	014004c4 	movi	r5,19
81106180:	01204834 	movhi	r4,33056
81106184:	210b0004 	addi	r4,r4,11264
81106188:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110618c:	0001883a 	nop
81106190:	e037883a 	mov	sp,fp
81106194:	dfc00117 	ldw	ra,4(sp)
81106198:	df000017 	ldw	fp,0(sp)
8110619c:	dec00204 	addi	sp,sp,8
811061a0:	f800283a 	ret

811061a4 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
811061a4:	defffe04 	addi	sp,sp,-8
811061a8:	de00012e 	bgeu	sp,et,811061b0 <vRmapCh2IrqFlagClrWriteCmd+0xc>
811061ac:	003b68fa 	trap	3
811061b0:	dfc00115 	stw	ra,4(sp)
811061b4:	df000015 	stw	fp,0(sp)
811061b8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811061bc:	01800044 	movi	r6,1
811061c0:	014004c4 	movi	r5,19
811061c4:	01204834 	movhi	r4,33056
811061c8:	210a0004 	addi	r4,r4,10240
811061cc:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811061d0:	0001883a 	nop
811061d4:	e037883a 	mov	sp,fp
811061d8:	dfc00117 	ldw	ra,4(sp)
811061dc:	df000017 	ldw	fp,0(sp)
811061e0:	dec00204 	addi	sp,sp,8
811061e4:	f800283a 	ret

811061e8 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
811061e8:	defffe04 	addi	sp,sp,-8
811061ec:	de00012e 	bgeu	sp,et,811061f4 <vRmapCh3IrqFlagClrWriteCmd+0xc>
811061f0:	003b68fa 	trap	3
811061f4:	dfc00115 	stw	ra,4(sp)
811061f8:	df000015 	stw	fp,0(sp)
811061fc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106200:	01800044 	movi	r6,1
81106204:	014004c4 	movi	r5,19
81106208:	01204834 	movhi	r4,33056
8110620c:	21090004 	addi	r4,r4,9216
81106210:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106214:	0001883a 	nop
81106218:	e037883a 	mov	sp,fp
8110621c:	dfc00117 	ldw	ra,4(sp)
81106220:	df000017 	ldw	fp,0(sp)
81106224:	dec00204 	addi	sp,sp,8
81106228:	f800283a 	ret

8110622c <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
8110622c:	defffe04 	addi	sp,sp,-8
81106230:	de00012e 	bgeu	sp,et,81106238 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106234:	003b68fa 	trap	3
81106238:	dfc00115 	stw	ra,4(sp)
8110623c:	df000015 	stw	fp,0(sp)
81106240:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106244:	01800044 	movi	r6,1
81106248:	014004c4 	movi	r5,19
8110624c:	01204834 	movhi	r4,33056
81106250:	21080004 	addi	r4,r4,8192
81106254:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106258:	0001883a 	nop
8110625c:	e037883a 	mov	sp,fp
81106260:	dfc00117 	ldw	ra,4(sp)
81106264:	df000017 	ldw	fp,0(sp)
81106268:	dec00204 	addi	sp,sp,8
8110626c:	f800283a 	ret

81106270 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81106270:	defffe04 	addi	sp,sp,-8
81106274:	de00012e 	bgeu	sp,et,8110627c <vRmapCh5IrqFlagClrWriteCmd+0xc>
81106278:	003b68fa 	trap	3
8110627c:	dfc00115 	stw	ra,4(sp)
81106280:	df000015 	stw	fp,0(sp)
81106284:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106288:	01800044 	movi	r6,1
8110628c:	014004c4 	movi	r5,19
81106290:	01204834 	movhi	r4,33056
81106294:	21070004 	addi	r4,r4,7168
81106298:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110629c:	0001883a 	nop
811062a0:	e037883a 	mov	sp,fp
811062a4:	dfc00117 	ldw	ra,4(sp)
811062a8:	df000017 	ldw	fp,0(sp)
811062ac:	dec00204 	addi	sp,sp,8
811062b0:	f800283a 	ret

811062b4 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
811062b4:	defffe04 	addi	sp,sp,-8
811062b8:	de00012e 	bgeu	sp,et,811062c0 <vRmapCh6IrqFlagClrWriteCmd+0xc>
811062bc:	003b68fa 	trap	3
811062c0:	dfc00115 	stw	ra,4(sp)
811062c4:	df000015 	stw	fp,0(sp)
811062c8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811062cc:	01800044 	movi	r6,1
811062d0:	014004c4 	movi	r5,19
811062d4:	01204834 	movhi	r4,33056
811062d8:	21060004 	addi	r4,r4,6144
811062dc:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811062e0:	0001883a 	nop
811062e4:	e037883a 	mov	sp,fp
811062e8:	dfc00117 	ldw	ra,4(sp)
811062ec:	df000017 	ldw	fp,0(sp)
811062f0:	dec00204 	addi	sp,sp,8
811062f4:	f800283a 	ret

811062f8 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
811062f8:	defffe04 	addi	sp,sp,-8
811062fc:	de00012e 	bgeu	sp,et,81106304 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81106300:	003b68fa 	trap	3
81106304:	dfc00115 	stw	ra,4(sp)
81106308:	df000015 	stw	fp,0(sp)
8110630c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106310:	01800044 	movi	r6,1
81106314:	014004c4 	movi	r5,19
81106318:	01204834 	movhi	r4,33056
8110631c:	21050004 	addi	r4,r4,5120
81106320:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106324:	0001883a 	nop
81106328:	e037883a 	mov	sp,fp
8110632c:	dfc00117 	ldw	ra,4(sp)
81106330:	df000017 	ldw	fp,0(sp)
81106334:	dec00204 	addi	sp,sp,8
81106338:	f800283a 	ret

8110633c <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
8110633c:	defffe04 	addi	sp,sp,-8
81106340:	de00012e 	bgeu	sp,et,81106348 <vRmapCh8IrqFlagClrWriteCmd+0xc>
81106344:	003b68fa 	trap	3
81106348:	dfc00115 	stw	ra,4(sp)
8110634c:	df000015 	stw	fp,0(sp)
81106350:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106354:	01800044 	movi	r6,1
81106358:	014004c4 	movi	r5,19
8110635c:	01204834 	movhi	r4,33056
81106360:	21040004 	addi	r4,r4,4096
81106364:	1108c280 	call	81108c28 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106368:	0001883a 	nop
8110636c:	e037883a 	mov	sp,fp
81106370:	dfc00117 	ldw	ra,4(sp)
81106374:	df000017 	ldw	fp,0(sp)
81106378:	dec00204 	addi	sp,sp,8
8110637c:	f800283a 	ret

81106380 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
81106380:	defffd04 	addi	sp,sp,-12
81106384:	de00012e 	bgeu	sp,et,8110638c <bRmapCh1IrqFlagWriteCmd+0xc>
81106388:	003b68fa 	trap	3
8110638c:	dfc00215 	stw	ra,8(sp)
81106390:	df000115 	stw	fp,4(sp)
81106394:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106398:	01400484 	movi	r5,18
8110639c:	01204834 	movhi	r4,33056
811063a0:	210b0004 	addi	r4,r4,11264
811063a4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811063a8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811063ac:	10000326 	beq	r2,zero,811063bc <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811063b0:	00800044 	movi	r2,1
811063b4:	e0bfff15 	stw	r2,-4(fp)
811063b8:	00000106 	br	811063c0 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811063bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811063c0:	e0bfff17 	ldw	r2,-4(fp)
}
811063c4:	e037883a 	mov	sp,fp
811063c8:	dfc00117 	ldw	ra,4(sp)
811063cc:	df000017 	ldw	fp,0(sp)
811063d0:	dec00204 	addi	sp,sp,8
811063d4:	f800283a 	ret

811063d8 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
811063d8:	defffd04 	addi	sp,sp,-12
811063dc:	de00012e 	bgeu	sp,et,811063e4 <bRmapCh2IrqFlagWriteCmd+0xc>
811063e0:	003b68fa 	trap	3
811063e4:	dfc00215 	stw	ra,8(sp)
811063e8:	df000115 	stw	fp,4(sp)
811063ec:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811063f0:	01400484 	movi	r5,18
811063f4:	01204834 	movhi	r4,33056
811063f8:	210a0004 	addi	r4,r4,10240
811063fc:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106400:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106404:	10000326 	beq	r2,zero,81106414 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106408:	00800044 	movi	r2,1
8110640c:	e0bfff15 	stw	r2,-4(fp)
81106410:	00000106 	br	81106418 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106414:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106418:	e0bfff17 	ldw	r2,-4(fp)
}
8110641c:	e037883a 	mov	sp,fp
81106420:	dfc00117 	ldw	ra,4(sp)
81106424:	df000017 	ldw	fp,0(sp)
81106428:	dec00204 	addi	sp,sp,8
8110642c:	f800283a 	ret

81106430 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81106430:	defffd04 	addi	sp,sp,-12
81106434:	de00012e 	bgeu	sp,et,8110643c <bRmapCh3IrqFlagWriteCmd+0xc>
81106438:	003b68fa 	trap	3
8110643c:	dfc00215 	stw	ra,8(sp)
81106440:	df000115 	stw	fp,4(sp)
81106444:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106448:	01400484 	movi	r5,18
8110644c:	01204834 	movhi	r4,33056
81106450:	21090004 	addi	r4,r4,9216
81106454:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106458:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110645c:	10000326 	beq	r2,zero,8110646c <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106460:	00800044 	movi	r2,1
81106464:	e0bfff15 	stw	r2,-4(fp)
81106468:	00000106 	br	81106470 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110646c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106470:	e0bfff17 	ldw	r2,-4(fp)
}
81106474:	e037883a 	mov	sp,fp
81106478:	dfc00117 	ldw	ra,4(sp)
8110647c:	df000017 	ldw	fp,0(sp)
81106480:	dec00204 	addi	sp,sp,8
81106484:	f800283a 	ret

81106488 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81106488:	defffd04 	addi	sp,sp,-12
8110648c:	de00012e 	bgeu	sp,et,81106494 <bRmapCh4IrqFlagWriteCmd+0xc>
81106490:	003b68fa 	trap	3
81106494:	dfc00215 	stw	ra,8(sp)
81106498:	df000115 	stw	fp,4(sp)
8110649c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811064a0:	01400484 	movi	r5,18
811064a4:	01204834 	movhi	r4,33056
811064a8:	21080004 	addi	r4,r4,8192
811064ac:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811064b0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811064b4:	10000326 	beq	r2,zero,811064c4 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811064b8:	00800044 	movi	r2,1
811064bc:	e0bfff15 	stw	r2,-4(fp)
811064c0:	00000106 	br	811064c8 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811064c4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811064c8:	e0bfff17 	ldw	r2,-4(fp)
}
811064cc:	e037883a 	mov	sp,fp
811064d0:	dfc00117 	ldw	ra,4(sp)
811064d4:	df000017 	ldw	fp,0(sp)
811064d8:	dec00204 	addi	sp,sp,8
811064dc:	f800283a 	ret

811064e0 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
811064e0:	defffd04 	addi	sp,sp,-12
811064e4:	de00012e 	bgeu	sp,et,811064ec <bRmapCh5IrqFlagWriteCmd+0xc>
811064e8:	003b68fa 	trap	3
811064ec:	dfc00215 	stw	ra,8(sp)
811064f0:	df000115 	stw	fp,4(sp)
811064f4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811064f8:	01400484 	movi	r5,18
811064fc:	01204834 	movhi	r4,33056
81106500:	21070004 	addi	r4,r4,7168
81106504:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106508:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110650c:	10000326 	beq	r2,zero,8110651c <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106510:	00800044 	movi	r2,1
81106514:	e0bfff15 	stw	r2,-4(fp)
81106518:	00000106 	br	81106520 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110651c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106520:	e0bfff17 	ldw	r2,-4(fp)
}
81106524:	e037883a 	mov	sp,fp
81106528:	dfc00117 	ldw	ra,4(sp)
8110652c:	df000017 	ldw	fp,0(sp)
81106530:	dec00204 	addi	sp,sp,8
81106534:	f800283a 	ret

81106538 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81106538:	defffd04 	addi	sp,sp,-12
8110653c:	de00012e 	bgeu	sp,et,81106544 <bRmapCh6IrqFlagWriteCmd+0xc>
81106540:	003b68fa 	trap	3
81106544:	dfc00215 	stw	ra,8(sp)
81106548:	df000115 	stw	fp,4(sp)
8110654c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106550:	01400484 	movi	r5,18
81106554:	01204834 	movhi	r4,33056
81106558:	21060004 	addi	r4,r4,6144
8110655c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106560:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106564:	10000326 	beq	r2,zero,81106574 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106568:	00800044 	movi	r2,1
8110656c:	e0bfff15 	stw	r2,-4(fp)
81106570:	00000106 	br	81106578 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106574:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106578:	e0bfff17 	ldw	r2,-4(fp)
}
8110657c:	e037883a 	mov	sp,fp
81106580:	dfc00117 	ldw	ra,4(sp)
81106584:	df000017 	ldw	fp,0(sp)
81106588:	dec00204 	addi	sp,sp,8
8110658c:	f800283a 	ret

81106590 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81106590:	defffd04 	addi	sp,sp,-12
81106594:	de00012e 	bgeu	sp,et,8110659c <bRmapCh7IrqFlagWriteCmd+0xc>
81106598:	003b68fa 	trap	3
8110659c:	dfc00215 	stw	ra,8(sp)
811065a0:	df000115 	stw	fp,4(sp)
811065a4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811065a8:	01400484 	movi	r5,18
811065ac:	01204834 	movhi	r4,33056
811065b0:	21050004 	addi	r4,r4,5120
811065b4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811065b8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811065bc:	10000326 	beq	r2,zero,811065cc <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811065c0:	00800044 	movi	r2,1
811065c4:	e0bfff15 	stw	r2,-4(fp)
811065c8:	00000106 	br	811065d0 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811065cc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811065d0:	e0bfff17 	ldw	r2,-4(fp)
}
811065d4:	e037883a 	mov	sp,fp
811065d8:	dfc00117 	ldw	ra,4(sp)
811065dc:	df000017 	ldw	fp,0(sp)
811065e0:	dec00204 	addi	sp,sp,8
811065e4:	f800283a 	ret

811065e8 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
811065e8:	defffd04 	addi	sp,sp,-12
811065ec:	de00012e 	bgeu	sp,et,811065f4 <bRmapCh8IrqFlagWriteCmd+0xc>
811065f0:	003b68fa 	trap	3
811065f4:	dfc00215 	stw	ra,8(sp)
811065f8:	df000115 	stw	fp,4(sp)
811065fc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106600:	01400484 	movi	r5,18
81106604:	01204834 	movhi	r4,33056
81106608:	21040004 	addi	r4,r4,4096
8110660c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106610:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106614:	10000326 	beq	r2,zero,81106624 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106618:	00800044 	movi	r2,1
8110661c:	e0bfff15 	stw	r2,-4(fp)
81106620:	00000106 	br	81106628 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106624:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106628:	e0bfff17 	ldw	r2,-4(fp)
}
8110662c:	e037883a 	mov	sp,fp
81106630:	dfc00117 	ldw	ra,4(sp)
81106634:	df000017 	ldw	fp,0(sp)
81106638:	dec00204 	addi	sp,sp,8
8110663c:	f800283a 	ret

81106640 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81106640:	defffd04 	addi	sp,sp,-12
81106644:	de00012e 	bgeu	sp,et,8110664c <uliRmapCh1WriteCmdAddress+0xc>
81106648:	003b68fa 	trap	3
8110664c:	dfc00215 	stw	ra,8(sp)
81106650:	df000115 	stw	fp,4(sp)
81106654:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106658:	01400184 	movi	r5,6
8110665c:	01204834 	movhi	r4,33056
81106660:	210b0004 	addi	r4,r4,11264
81106664:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106668:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110666c:	e13fff17 	ldw	r4,-4(fp)
81106670:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
81106674:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106678:	e0bfff17 	ldw	r2,-4(fp)
}
8110667c:	e037883a 	mov	sp,fp
81106680:	dfc00117 	ldw	ra,4(sp)
81106684:	df000017 	ldw	fp,0(sp)
81106688:	dec00204 	addi	sp,sp,8
8110668c:	f800283a 	ret

81106690 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81106690:	defffd04 	addi	sp,sp,-12
81106694:	de00012e 	bgeu	sp,et,8110669c <uliRmapCh2WriteCmdAddress+0xc>
81106698:	003b68fa 	trap	3
8110669c:	dfc00215 	stw	ra,8(sp)
811066a0:	df000115 	stw	fp,4(sp)
811066a4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811066a8:	01400184 	movi	r5,6
811066ac:	01204834 	movhi	r4,33056
811066b0:	210a0004 	addi	r4,r4,10240
811066b4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811066b8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811066bc:	e13fff17 	ldw	r4,-4(fp)
811066c0:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
811066c4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811066c8:	e0bfff17 	ldw	r2,-4(fp)
}
811066cc:	e037883a 	mov	sp,fp
811066d0:	dfc00117 	ldw	ra,4(sp)
811066d4:	df000017 	ldw	fp,0(sp)
811066d8:	dec00204 	addi	sp,sp,8
811066dc:	f800283a 	ret

811066e0 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
811066e0:	defffd04 	addi	sp,sp,-12
811066e4:	de00012e 	bgeu	sp,et,811066ec <uliRmapCh3WriteCmdAddress+0xc>
811066e8:	003b68fa 	trap	3
811066ec:	dfc00215 	stw	ra,8(sp)
811066f0:	df000115 	stw	fp,4(sp)
811066f4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811066f8:	01400184 	movi	r5,6
811066fc:	01204834 	movhi	r4,33056
81106700:	21090004 	addi	r4,r4,9216
81106704:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106708:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110670c:	e13fff17 	ldw	r4,-4(fp)
81106710:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
81106714:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106718:	e0bfff17 	ldw	r2,-4(fp)
}
8110671c:	e037883a 	mov	sp,fp
81106720:	dfc00117 	ldw	ra,4(sp)
81106724:	df000017 	ldw	fp,0(sp)
81106728:	dec00204 	addi	sp,sp,8
8110672c:	f800283a 	ret

81106730 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
81106730:	defffd04 	addi	sp,sp,-12
81106734:	de00012e 	bgeu	sp,et,8110673c <uliRmapCh4WriteCmdAddress+0xc>
81106738:	003b68fa 	trap	3
8110673c:	dfc00215 	stw	ra,8(sp)
81106740:	df000115 	stw	fp,4(sp)
81106744:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106748:	01400184 	movi	r5,6
8110674c:	01204834 	movhi	r4,33056
81106750:	21080004 	addi	r4,r4,8192
81106754:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106758:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110675c:	e13fff17 	ldw	r4,-4(fp)
81106760:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
81106764:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106768:	e0bfff17 	ldw	r2,-4(fp)
}
8110676c:	e037883a 	mov	sp,fp
81106770:	dfc00117 	ldw	ra,4(sp)
81106774:	df000017 	ldw	fp,0(sp)
81106778:	dec00204 	addi	sp,sp,8
8110677c:	f800283a 	ret

81106780 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81106780:	defffd04 	addi	sp,sp,-12
81106784:	de00012e 	bgeu	sp,et,8110678c <uliRmapCh5WriteCmdAddress+0xc>
81106788:	003b68fa 	trap	3
8110678c:	dfc00215 	stw	ra,8(sp)
81106790:	df000115 	stw	fp,4(sp)
81106794:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106798:	01400184 	movi	r5,6
8110679c:	01204834 	movhi	r4,33056
811067a0:	21070004 	addi	r4,r4,7168
811067a4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811067a8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811067ac:	e13fff17 	ldw	r4,-4(fp)
811067b0:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
811067b4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811067b8:	e0bfff17 	ldw	r2,-4(fp)
}
811067bc:	e037883a 	mov	sp,fp
811067c0:	dfc00117 	ldw	ra,4(sp)
811067c4:	df000017 	ldw	fp,0(sp)
811067c8:	dec00204 	addi	sp,sp,8
811067cc:	f800283a 	ret

811067d0 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
811067d0:	defffd04 	addi	sp,sp,-12
811067d4:	de00012e 	bgeu	sp,et,811067dc <uliRmapCh6WriteCmdAddress+0xc>
811067d8:	003b68fa 	trap	3
811067dc:	dfc00215 	stw	ra,8(sp)
811067e0:	df000115 	stw	fp,4(sp)
811067e4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811067e8:	01400184 	movi	r5,6
811067ec:	01204834 	movhi	r4,33056
811067f0:	21060004 	addi	r4,r4,6144
811067f4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811067f8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811067fc:	e13fff17 	ldw	r4,-4(fp)
81106800:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
81106804:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106808:	e0bfff17 	ldw	r2,-4(fp)
}
8110680c:	e037883a 	mov	sp,fp
81106810:	dfc00117 	ldw	ra,4(sp)
81106814:	df000017 	ldw	fp,0(sp)
81106818:	dec00204 	addi	sp,sp,8
8110681c:	f800283a 	ret

81106820 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81106820:	defffd04 	addi	sp,sp,-12
81106824:	de00012e 	bgeu	sp,et,8110682c <uliRmapCh7WriteCmdAddress+0xc>
81106828:	003b68fa 	trap	3
8110682c:	dfc00215 	stw	ra,8(sp)
81106830:	df000115 	stw	fp,4(sp)
81106834:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106838:	01400184 	movi	r5,6
8110683c:	01204834 	movhi	r4,33056
81106840:	21050004 	addi	r4,r4,5120
81106844:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106848:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110684c:	e13fff17 	ldw	r4,-4(fp)
81106850:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
81106854:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106858:	e0bfff17 	ldw	r2,-4(fp)
}
8110685c:	e037883a 	mov	sp,fp
81106860:	dfc00117 	ldw	ra,4(sp)
81106864:	df000017 	ldw	fp,0(sp)
81106868:	dec00204 	addi	sp,sp,8
8110686c:	f800283a 	ret

81106870 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81106870:	defffd04 	addi	sp,sp,-12
81106874:	de00012e 	bgeu	sp,et,8110687c <uliRmapCh8WriteCmdAddress+0xc>
81106878:	003b68fa 	trap	3
8110687c:	dfc00215 	stw	ra,8(sp)
81106880:	df000115 	stw	fp,4(sp)
81106884:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106888:	01400184 	movi	r5,6
8110688c:	01204834 	movhi	r4,33056
81106890:	21040004 	addi	r4,r4,4096
81106894:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106898:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110689c:	e13fff17 	ldw	r4,-4(fp)
811068a0:	1108ccc0 	call	81108ccc <uliConvRmapCfgAddr>
811068a4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811068a8:	e0bfff17 	ldw	r2,-4(fp)
}
811068ac:	e037883a 	mov	sp,fp
811068b0:	dfc00117 	ldw	ra,4(sp)
811068b4:	df000017 	ldw	fp,0(sp)
811068b8:	dec00204 	addi	sp,sp,8
811068bc:	f800283a 	ret

811068c0 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
811068c0:	defffc04 	addi	sp,sp,-16
811068c4:	de00012e 	bgeu	sp,et,811068cc <vRmapInitIrq+0xc>
811068c8:	003b68fa 	trap	3
811068cc:	dfc00315 	stw	ra,12(sp)
811068d0:	df000215 	stw	fp,8(sp)
811068d4:	df000204 	addi	fp,sp,8
811068d8:	2005883a 	mov	r2,r4
811068dc:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
811068e0:	e0bfff03 	ldbu	r2,-4(fp)
811068e4:	10c00228 	cmpgeui	r3,r2,8
811068e8:	18004e1e 	bne	r3,zero,81106a24 <vRmapInitIrq+0x164>
811068ec:	100690ba 	slli	r3,r2,2
811068f0:	00a04434 	movhi	r2,33040
811068f4:	109a4104 	addi	r2,r2,26884
811068f8:	1885883a 	add	r2,r3,r2
811068fc:	10800017 	ldw	r2,0(r2)
81106900:	1000683a 	jmp	r2
81106904:	81106924 	muli	r4,r16,16804
81106908:	81106944 	addi	r4,r16,16805
8110690c:	81106964 	muli	r4,r16,16805
81106910:	81106984 	addi	r4,r16,16806
81106914:	811069a4 	muli	r4,r16,16806
81106918:	811069c4 	addi	r4,r16,16807
8110691c:	811069e4 	muli	r4,r16,16807
81106920:	81106a04 	addi	r4,r16,16808
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81106924:	d0a04604 	addi	r2,gp,-32488
81106928:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
8110692c:	01a04434 	movhi	r6,33040
81106930:	3197d804 	addi	r6,r6,24416
81106934:	e17ffe17 	ldw	r5,-8(fp)
81106938:	010005c4 	movi	r4,23
8110693c:	11316a40 	call	811316a4 <alt_irq_register>
		break;
81106940:	00003806 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81106944:	d0a04704 	addi	r2,gp,-32484
81106948:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
8110694c:	01a04434 	movhi	r6,33040
81106950:	3197e804 	addi	r6,r6,24480
81106954:	e17ffe17 	ldw	r5,-8(fp)
81106958:	01000544 	movi	r4,21
8110695c:	11316a40 	call	811316a4 <alt_irq_register>
		break;
81106960:	00003006 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81106964:	d0a04804 	addi	r2,gp,-32480
81106968:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
8110696c:	01a04434 	movhi	r6,33040
81106970:	3197f804 	addi	r6,r6,24544
81106974:	e17ffe17 	ldw	r5,-8(fp)
81106978:	010004c4 	movi	r4,19
8110697c:	11316a40 	call	811316a4 <alt_irq_register>
		break;
81106980:	00002806 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81106984:	d0a04904 	addi	r2,gp,-32476
81106988:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
8110698c:	01a04434 	movhi	r6,33040
81106990:	31980804 	addi	r6,r6,24608
81106994:	e17ffe17 	ldw	r5,-8(fp)
81106998:	01000444 	movi	r4,17
8110699c:	11316a40 	call	811316a4 <alt_irq_register>
		break;
811069a0:	00002006 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811069a4:	d0a04a04 	addi	r2,gp,-32472
811069a8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
811069ac:	01a04434 	movhi	r6,33040
811069b0:	31981804 	addi	r6,r6,24672
811069b4:	e17ffe17 	ldw	r5,-8(fp)
811069b8:	01000244 	movi	r4,9
811069bc:	11316a40 	call	811316a4 <alt_irq_register>
		break;
811069c0:	00001806 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
811069c4:	d0a04b04 	addi	r2,gp,-32468
811069c8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
811069cc:	01a04434 	movhi	r6,33040
811069d0:	31982804 	addi	r6,r6,24736
811069d4:	e17ffe17 	ldw	r5,-8(fp)
811069d8:	010001c4 	movi	r4,7
811069dc:	11316a40 	call	811316a4 <alt_irq_register>
		break;
811069e0:	00001006 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
811069e4:	d0a04c04 	addi	r2,gp,-32464
811069e8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
811069ec:	01a04434 	movhi	r6,33040
811069f0:	31983804 	addi	r6,r6,24800
811069f4:	e17ffe17 	ldw	r5,-8(fp)
811069f8:	01000104 	movi	r4,4
811069fc:	11316a40 	call	811316a4 <alt_irq_register>
		break;
81106a00:	00000806 	br	81106a24 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106a04:	d0a04d04 	addi	r2,gp,-32460
81106a08:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81106a0c:	01a04434 	movhi	r6,33040
81106a10:	31984804 	addi	r6,r6,24864
81106a14:	e17ffe17 	ldw	r5,-8(fp)
81106a18:	010000c4 	movi	r4,3
81106a1c:	11316a40 	call	811316a4 <alt_irq_register>
		break;
81106a20:	0001883a 	nop
	}
}
81106a24:	0001883a 	nop
81106a28:	e037883a 	mov	sp,fp
81106a2c:	dfc00117 	ldw	ra,4(sp)
81106a30:	df000017 	ldw	fp,0(sp)
81106a34:	dec00204 	addi	sp,sp,8
81106a38:	f800283a 	ret

81106a3c <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81106a3c:	defffb04 	addi	sp,sp,-20
81106a40:	de00012e 	bgeu	sp,et,81106a48 <bRmapSetIrqControl+0xc>
81106a44:	003b68fa 	trap	3
81106a48:	dfc00415 	stw	ra,16(sp)
81106a4c:	df000315 	stw	fp,12(sp)
81106a50:	df000304 	addi	fp,sp,12
81106a54:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a58:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a5c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106a60:	e0bfff17 	ldw	r2,-4(fp)
81106a64:	10001926 	beq	r2,zero,81106acc <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106a68:	e0bfff17 	ldw	r2,-4(fp)
81106a6c:	10800017 	ldw	r2,0(r2)
81106a70:	01400444 	movi	r5,17
81106a74:	1009883a 	mov	r4,r2
81106a78:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106a7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81106a80:	e0bfff17 	ldw	r2,-4(fp)
81106a84:	10801017 	ldw	r2,64(r2)
81106a88:	10000426 	beq	r2,zero,81106a9c <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81106a8c:	e0bffe17 	ldw	r2,-8(fp)
81106a90:	10800054 	ori	r2,r2,1
81106a94:	e0bffe15 	stw	r2,-8(fp)
81106a98:	00000406 	br	81106aac <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81106a9c:	e0fffe17 	ldw	r3,-8(fp)
81106aa0:	00bfff84 	movi	r2,-2
81106aa4:	1884703a 	and	r2,r3,r2
81106aa8:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106aac:	e0bfff17 	ldw	r2,-4(fp)
81106ab0:	10800017 	ldw	r2,0(r2)
81106ab4:	e1bffe17 	ldw	r6,-8(fp)
81106ab8:	01400444 	movi	r5,17
81106abc:	1009883a 	mov	r4,r2
81106ac0:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81106ac4:	00800044 	movi	r2,1
81106ac8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106acc:	e0bffd17 	ldw	r2,-12(fp)
}
81106ad0:	e037883a 	mov	sp,fp
81106ad4:	dfc00117 	ldw	ra,4(sp)
81106ad8:	df000017 	ldw	fp,0(sp)
81106adc:	dec00204 	addi	sp,sp,8
81106ae0:	f800283a 	ret

81106ae4 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81106ae4:	defffb04 	addi	sp,sp,-20
81106ae8:	de00012e 	bgeu	sp,et,81106af0 <bRmapGetIrqControl+0xc>
81106aec:	003b68fa 	trap	3
81106af0:	dfc00415 	stw	ra,16(sp)
81106af4:	df000315 	stw	fp,12(sp)
81106af8:	df000304 	addi	fp,sp,12
81106afc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b00:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106b04:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106b08:	e0bfff17 	ldw	r2,-4(fp)
81106b0c:	10001126 	beq	r2,zero,81106b54 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106b10:	e0bfff17 	ldw	r2,-4(fp)
81106b14:	10800017 	ldw	r2,0(r2)
81106b18:	01400444 	movi	r5,17
81106b1c:	1009883a 	mov	r4,r2
81106b20:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106b24:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81106b28:	e0bffe17 	ldw	r2,-8(fp)
81106b2c:	1080004c 	andi	r2,r2,1
81106b30:	10000426 	beq	r2,zero,81106b44 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81106b34:	e0bfff17 	ldw	r2,-4(fp)
81106b38:	00c00044 	movi	r3,1
81106b3c:	10c01015 	stw	r3,64(r2)
81106b40:	00000206 	br	81106b4c <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81106b44:	e0bfff17 	ldw	r2,-4(fp)
81106b48:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81106b4c:	00800044 	movi	r2,1
81106b50:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106b54:	e0bffd17 	ldw	r2,-12(fp)
}
81106b58:	e037883a 	mov	sp,fp
81106b5c:	dfc00117 	ldw	ra,4(sp)
81106b60:	df000017 	ldw	fp,0(sp)
81106b64:	dec00204 	addi	sp,sp,8
81106b68:	f800283a 	ret

81106b6c <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81106b6c:	defffb04 	addi	sp,sp,-20
81106b70:	de00012e 	bgeu	sp,et,81106b78 <bRmapGetIrqFlags+0xc>
81106b74:	003b68fa 	trap	3
81106b78:	dfc00415 	stw	ra,16(sp)
81106b7c:	df000315 	stw	fp,12(sp)
81106b80:	df000304 	addi	fp,sp,12
81106b84:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b88:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106b8c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106b90:	e0bfff17 	ldw	r2,-4(fp)
81106b94:	10001126 	beq	r2,zero,81106bdc <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106b98:	e0bfff17 	ldw	r2,-4(fp)
81106b9c:	10800017 	ldw	r2,0(r2)
81106ba0:	01400484 	movi	r5,18
81106ba4:	1009883a 	mov	r4,r2
81106ba8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106bac:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106bb0:	e0bffe17 	ldw	r2,-8(fp)
81106bb4:	1080004c 	andi	r2,r2,1
81106bb8:	10000426 	beq	r2,zero,81106bcc <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81106bbc:	e0bfff17 	ldw	r2,-4(fp)
81106bc0:	00c00044 	movi	r3,1
81106bc4:	10c01115 	stw	r3,68(r2)
81106bc8:	00000206 	br	81106bd4 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81106bcc:	e0bfff17 	ldw	r2,-4(fp)
81106bd0:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81106bd4:	00800044 	movi	r2,1
81106bd8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106bdc:	e0bffd17 	ldw	r2,-12(fp)
}
81106be0:	e037883a 	mov	sp,fp
81106be4:	dfc00117 	ldw	ra,4(sp)
81106be8:	df000017 	ldw	fp,0(sp)
81106bec:	dec00204 	addi	sp,sp,8
81106bf0:	f800283a 	ret

81106bf4 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81106bf4:	defffb04 	addi	sp,sp,-20
81106bf8:	de00012e 	bgeu	sp,et,81106c00 <bRmapSetCodecConfig+0xc>
81106bfc:	003b68fa 	trap	3
81106c00:	dfc00415 	stw	ra,16(sp)
81106c04:	df000315 	stw	fp,12(sp)
81106c08:	df000304 	addi	fp,sp,12
81106c0c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106c10:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106c14:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106c18:	e0bfff17 	ldw	r2,-4(fp)
81106c1c:	10002526 	beq	r2,zero,81106cb4 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106c20:	e0bfff17 	ldw	r2,-4(fp)
81106c24:	10800017 	ldw	r2,0(r2)
81106c28:	01400104 	movi	r5,4
81106c2c:	1009883a 	mov	r4,r2
81106c30:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106c34:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81106c38:	e0fffe17 	ldw	r3,-8(fp)
81106c3c:	00bfc004 	movi	r2,-256
81106c40:	1884703a 	and	r2,r3,r2
81106c44:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81106c48:	e0bfff17 	ldw	r2,-4(fp)
81106c4c:	10800143 	ldbu	r2,5(r2)
81106c50:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81106c54:	e0fffe17 	ldw	r3,-8(fp)
81106c58:	1884b03a 	or	r2,r3,r2
81106c5c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81106c60:	e0fffe17 	ldw	r3,-8(fp)
81106c64:	00bffff4 	movhi	r2,65535
81106c68:	10803fc4 	addi	r2,r2,255
81106c6c:	1884703a 	and	r2,r3,r2
81106c70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81106c74:	e0bfff17 	ldw	r2,-4(fp)
81106c78:	10800103 	ldbu	r2,4(r2)
81106c7c:	10803fcc 	andi	r2,r2,255
81106c80:	1004923a 	slli	r2,r2,8
81106c84:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81106c88:	e0fffe17 	ldw	r3,-8(fp)
81106c8c:	1884b03a 	or	r2,r3,r2
81106c90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81106c94:	e0bfff17 	ldw	r2,-4(fp)
81106c98:	10800017 	ldw	r2,0(r2)
81106c9c:	e1bffe17 	ldw	r6,-8(fp)
81106ca0:	01400104 	movi	r5,4
81106ca4:	1009883a 	mov	r4,r2
81106ca8:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81106cac:	00800044 	movi	r2,1
81106cb0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106cb4:	e0bffd17 	ldw	r2,-12(fp)
}
81106cb8:	e037883a 	mov	sp,fp
81106cbc:	dfc00117 	ldw	ra,4(sp)
81106cc0:	df000017 	ldw	fp,0(sp)
81106cc4:	dec00204 	addi	sp,sp,8
81106cc8:	f800283a 	ret

81106ccc <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81106ccc:	defffb04 	addi	sp,sp,-20
81106cd0:	de00012e 	bgeu	sp,et,81106cd8 <bRmapGetCodecConfig+0xc>
81106cd4:	003b68fa 	trap	3
81106cd8:	dfc00415 	stw	ra,16(sp)
81106cdc:	df000315 	stw	fp,12(sp)
81106ce0:	df000304 	addi	fp,sp,12
81106ce4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ce8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106cec:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106cf0:	e0bfff17 	ldw	r2,-4(fp)
81106cf4:	10001226 	beq	r2,zero,81106d40 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106cf8:	e0bfff17 	ldw	r2,-4(fp)
81106cfc:	10800017 	ldw	r2,0(r2)
81106d00:	01400104 	movi	r5,4
81106d04:	1009883a 	mov	r4,r2
81106d08:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106d0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81106d10:	e0bffe17 	ldw	r2,-8(fp)
81106d14:	1007883a 	mov	r3,r2
81106d18:	e0bfff17 	ldw	r2,-4(fp)
81106d1c:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81106d20:	e0bffe17 	ldw	r2,-8(fp)
81106d24:	10bfc00c 	andi	r2,r2,65280
81106d28:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81106d2c:	1007883a 	mov	r3,r2
81106d30:	e0bfff17 	ldw	r2,-4(fp)
81106d34:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81106d38:	00800044 	movi	r2,1
81106d3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106d40:	e0bffd17 	ldw	r2,-12(fp)
}
81106d44:	e037883a 	mov	sp,fp
81106d48:	dfc00117 	ldw	ra,4(sp)
81106d4c:	df000017 	ldw	fp,0(sp)
81106d50:	dec00204 	addi	sp,sp,8
81106d54:	f800283a 	ret

81106d58 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81106d58:	defffb04 	addi	sp,sp,-20
81106d5c:	de00012e 	bgeu	sp,et,81106d64 <bRmapGetCodecStatus+0xc>
81106d60:	003b68fa 	trap	3
81106d64:	dfc00415 	stw	ra,16(sp)
81106d68:	df000315 	stw	fp,12(sp)
81106d6c:	df000304 	addi	fp,sp,12
81106d70:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106d74:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106d78:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106d7c:	e0bfff17 	ldw	r2,-4(fp)
81106d80:	10004726 	beq	r2,zero,81106ea0 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106d84:	e0bfff17 	ldw	r2,-4(fp)
81106d88:	10800017 	ldw	r2,0(r2)
81106d8c:	01400144 	movi	r5,5
81106d90:	1009883a 	mov	r4,r2
81106d94:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106d98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81106d9c:	e0bffe17 	ldw	r2,-8(fp)
81106da0:	1080004c 	andi	r2,r2,1
81106da4:	10000426 	beq	r2,zero,81106db8 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81106da8:	e0bfff17 	ldw	r2,-4(fp)
81106dac:	00c00044 	movi	r3,1
81106db0:	10c00215 	stw	r3,8(r2)
81106db4:	00000206 	br	81106dc0 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106db8:	e0bfff17 	ldw	r2,-4(fp)
81106dbc:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81106dc0:	e0bffe17 	ldw	r2,-8(fp)
81106dc4:	1080008c 	andi	r2,r2,2
81106dc8:	10000426 	beq	r2,zero,81106ddc <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81106dcc:	e0bfff17 	ldw	r2,-4(fp)
81106dd0:	00c00044 	movi	r3,1
81106dd4:	10c00315 	stw	r3,12(r2)
81106dd8:	00000206 	br	81106de4 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81106ddc:	e0bfff17 	ldw	r2,-4(fp)
81106de0:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81106de4:	e0bffe17 	ldw	r2,-8(fp)
81106de8:	1080010c 	andi	r2,r2,4
81106dec:	10000426 	beq	r2,zero,81106e00 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81106df0:	e0bfff17 	ldw	r2,-4(fp)
81106df4:	00c00044 	movi	r3,1
81106df8:	10c00415 	stw	r3,16(r2)
81106dfc:	00000206 	br	81106e08 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81106e00:	e0bfff17 	ldw	r2,-4(fp)
81106e04:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81106e08:	e0bffe17 	ldw	r2,-8(fp)
81106e0c:	1080020c 	andi	r2,r2,8
81106e10:	10000426 	beq	r2,zero,81106e24 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81106e14:	e0bfff17 	ldw	r2,-4(fp)
81106e18:	00c00044 	movi	r3,1
81106e1c:	10c00515 	stw	r3,20(r2)
81106e20:	00000206 	br	81106e2c <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81106e24:	e0bfff17 	ldw	r2,-4(fp)
81106e28:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81106e2c:	e0bffe17 	ldw	r2,-8(fp)
81106e30:	1080040c 	andi	r2,r2,16
81106e34:	10000426 	beq	r2,zero,81106e48 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81106e38:	e0bfff17 	ldw	r2,-4(fp)
81106e3c:	00c00044 	movi	r3,1
81106e40:	10c00615 	stw	r3,24(r2)
81106e44:	00000206 	br	81106e50 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81106e48:	e0bfff17 	ldw	r2,-4(fp)
81106e4c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81106e50:	e0bffe17 	ldw	r2,-8(fp)
81106e54:	1080080c 	andi	r2,r2,32
81106e58:	10000426 	beq	r2,zero,81106e6c <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81106e5c:	e0bfff17 	ldw	r2,-4(fp)
81106e60:	00c00044 	movi	r3,1
81106e64:	10c00715 	stw	r3,28(r2)
81106e68:	00000206 	br	81106e74 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81106e6c:	e0bfff17 	ldw	r2,-4(fp)
81106e70:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81106e74:	e0bffe17 	ldw	r2,-8(fp)
81106e78:	1080100c 	andi	r2,r2,64
81106e7c:	10000426 	beq	r2,zero,81106e90 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81106e80:	e0bfff17 	ldw	r2,-4(fp)
81106e84:	00c00044 	movi	r3,1
81106e88:	10c00815 	stw	r3,32(r2)
81106e8c:	00000206 	br	81106e98 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106e90:	e0bfff17 	ldw	r2,-4(fp)
81106e94:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81106e98:	00800044 	movi	r2,1
81106e9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106ea0:	e0bffd17 	ldw	r2,-12(fp)
}
81106ea4:	e037883a 	mov	sp,fp
81106ea8:	dfc00117 	ldw	ra,4(sp)
81106eac:	df000017 	ldw	fp,0(sp)
81106eb0:	dec00204 	addi	sp,sp,8
81106eb4:	f800283a 	ret

81106eb8 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81106eb8:	defffb04 	addi	sp,sp,-20
81106ebc:	de00012e 	bgeu	sp,et,81106ec4 <bRmapGetCodecError+0xc>
81106ec0:	003b68fa 	trap	3
81106ec4:	dfc00415 	stw	ra,16(sp)
81106ec8:	df000315 	stw	fp,12(sp)
81106ecc:	df000304 	addi	fp,sp,12
81106ed0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ed4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106ed8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106edc:	e0bfff17 	ldw	r2,-4(fp)
81106ee0:	10004726 	beq	r2,zero,81107000 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106ee4:	e0bfff17 	ldw	r2,-4(fp)
81106ee8:	10800017 	ldw	r2,0(r2)
81106eec:	01400144 	movi	r5,5
81106ef0:	1009883a 	mov	r4,r2
81106ef4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81106ef8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81106efc:	e0bffe17 	ldw	r2,-8(fp)
81106f00:	1080006c 	andhi	r2,r2,1
81106f04:	10000426 	beq	r2,zero,81106f18 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81106f08:	e0bfff17 	ldw	r2,-4(fp)
81106f0c:	00c00044 	movi	r3,1
81106f10:	10c00915 	stw	r3,36(r2)
81106f14:	00000206 	br	81106f20 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81106f18:	e0bfff17 	ldw	r2,-4(fp)
81106f1c:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81106f20:	e0bffe17 	ldw	r2,-8(fp)
81106f24:	108000ac 	andhi	r2,r2,2
81106f28:	10000426 	beq	r2,zero,81106f3c <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81106f2c:	e0bfff17 	ldw	r2,-4(fp)
81106f30:	00c00044 	movi	r3,1
81106f34:	10c00a15 	stw	r3,40(r2)
81106f38:	00000206 	br	81106f44 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81106f3c:	e0bfff17 	ldw	r2,-4(fp)
81106f40:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81106f44:	e0bffe17 	ldw	r2,-8(fp)
81106f48:	1080012c 	andhi	r2,r2,4
81106f4c:	10000426 	beq	r2,zero,81106f60 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81106f50:	e0bfff17 	ldw	r2,-4(fp)
81106f54:	00c00044 	movi	r3,1
81106f58:	10c00b15 	stw	r3,44(r2)
81106f5c:	00000206 	br	81106f68 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81106f60:	e0bfff17 	ldw	r2,-4(fp)
81106f64:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81106f68:	e0bffe17 	ldw	r2,-8(fp)
81106f6c:	1080022c 	andhi	r2,r2,8
81106f70:	10000426 	beq	r2,zero,81106f84 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81106f74:	e0bfff17 	ldw	r2,-4(fp)
81106f78:	00c00044 	movi	r3,1
81106f7c:	10c00c15 	stw	r3,48(r2)
81106f80:	00000206 	br	81106f8c <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81106f84:	e0bfff17 	ldw	r2,-4(fp)
81106f88:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81106f8c:	e0bffe17 	ldw	r2,-8(fp)
81106f90:	1080042c 	andhi	r2,r2,16
81106f94:	10000426 	beq	r2,zero,81106fa8 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81106f98:	e0bfff17 	ldw	r2,-4(fp)
81106f9c:	00c00044 	movi	r3,1
81106fa0:	10c00d15 	stw	r3,52(r2)
81106fa4:	00000206 	br	81106fb0 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81106fa8:	e0bfff17 	ldw	r2,-4(fp)
81106fac:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81106fb0:	e0bffe17 	ldw	r2,-8(fp)
81106fb4:	1080082c 	andhi	r2,r2,32
81106fb8:	10000426 	beq	r2,zero,81106fcc <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81106fbc:	e0bfff17 	ldw	r2,-4(fp)
81106fc0:	00c00044 	movi	r3,1
81106fc4:	10c00e15 	stw	r3,56(r2)
81106fc8:	00000206 	br	81106fd4 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81106fcc:	e0bfff17 	ldw	r2,-4(fp)
81106fd0:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81106fd4:	e0bffe17 	ldw	r2,-8(fp)
81106fd8:	1080102c 	andhi	r2,r2,64
81106fdc:	10000426 	beq	r2,zero,81106ff0 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81106fe0:	e0bfff17 	ldw	r2,-4(fp)
81106fe4:	00c00044 	movi	r3,1
81106fe8:	10c00f15 	stw	r3,60(r2)
81106fec:	00000206 	br	81106ff8 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81106ff0:	e0bfff17 	ldw	r2,-4(fp)
81106ff4:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81106ff8:	00800044 	movi	r2,1
81106ffc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107000:	e0bffd17 	ldw	r2,-12(fp)
}
81107004:	e037883a 	mov	sp,fp
81107008:	dfc00117 	ldw	ra,4(sp)
8110700c:	df000017 	ldw	fp,0(sp)
81107010:	dec00204 	addi	sp,sp,8
81107014:	f800283a 	ret

81107018 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107018:	defffb04 	addi	sp,sp,-20
8110701c:	de00012e 	bgeu	sp,et,81107024 <bRmapSetMemConfigArea+0xc>
81107020:	003b68fa 	trap	3
81107024:	dfc00415 	stw	ra,16(sp)
81107028:	df000315 	stw	fp,12(sp)
8110702c:	df000304 	addi	fp,sp,12
81107030:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107034:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107038:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110703c:	e0bfff17 	ldw	r2,-4(fp)
81107040:	1000aa26 	beq	r2,zero,811072ec <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107044:	e0bfff17 	ldw	r2,-4(fp)
81107048:	10801217 	ldw	r2,72(r2)
8110704c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107050:	e0bfff17 	ldw	r2,-4(fp)
81107054:	10800017 	ldw	r2,0(r2)
81107058:	e1bffe17 	ldw	r6,-8(fp)
8110705c:	01401004 	movi	r5,64
81107060:	1009883a 	mov	r4,r2
81107064:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107068:	e0bfff17 	ldw	r2,-4(fp)
8110706c:	10801317 	ldw	r2,76(r2)
81107070:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107074:	e0bfff17 	ldw	r2,-4(fp)
81107078:	10800017 	ldw	r2,0(r2)
8110707c:	e1bffe17 	ldw	r6,-8(fp)
81107080:	01401044 	movi	r5,65
81107084:	1009883a 	mov	r4,r2
81107088:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
8110708c:	e0bfff17 	ldw	r2,-4(fp)
81107090:	10801417 	ldw	r2,80(r2)
81107094:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107098:	e0bfff17 	ldw	r2,-4(fp)
8110709c:	10800017 	ldw	r2,0(r2)
811070a0:	e1bffe17 	ldw	r6,-8(fp)
811070a4:	01401084 	movi	r5,66
811070a8:	1009883a 	mov	r4,r2
811070ac:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
811070b0:	e0bfff17 	ldw	r2,-4(fp)
811070b4:	10801517 	ldw	r2,84(r2)
811070b8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811070bc:	e0bfff17 	ldw	r2,-4(fp)
811070c0:	10800017 	ldw	r2,0(r2)
811070c4:	e1bffe17 	ldw	r6,-8(fp)
811070c8:	014010c4 	movi	r5,67
811070cc:	1009883a 	mov	r4,r2
811070d0:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811070d4:	e0bfff17 	ldw	r2,-4(fp)
811070d8:	10802217 	ldw	r2,136(r2)
811070dc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811070e0:	e0bfff17 	ldw	r2,-4(fp)
811070e4:	10800017 	ldw	r2,0(r2)
811070e8:	e1bffe17 	ldw	r6,-8(fp)
811070ec:	01401104 	movi	r5,68
811070f0:	1009883a 	mov	r4,r2
811070f4:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
811070f8:	e0bfff17 	ldw	r2,-4(fp)
811070fc:	10801717 	ldw	r2,92(r2)
81107100:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107104:	e0bfff17 	ldw	r2,-4(fp)
81107108:	10800017 	ldw	r2,0(r2)
8110710c:	e1bffe17 	ldw	r6,-8(fp)
81107110:	01401144 	movi	r5,69
81107114:	1009883a 	mov	r4,r2
81107118:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
8110711c:	e0bfff17 	ldw	r2,-4(fp)
81107120:	10801817 	ldw	r2,96(r2)
81107124:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107128:	e0bfff17 	ldw	r2,-4(fp)
8110712c:	10800017 	ldw	r2,0(r2)
81107130:	e1bffe17 	ldw	r6,-8(fp)
81107134:	01401184 	movi	r5,70
81107138:	1009883a 	mov	r4,r2
8110713c:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107140:	e0bfff17 	ldw	r2,-4(fp)
81107144:	10801917 	ldw	r2,100(r2)
81107148:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110714c:	e0bfff17 	ldw	r2,-4(fp)
81107150:	10800017 	ldw	r2,0(r2)
81107154:	e1bffe17 	ldw	r6,-8(fp)
81107158:	014011c4 	movi	r5,71
8110715c:	1009883a 	mov	r4,r2
81107160:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107164:	e0bfff17 	ldw	r2,-4(fp)
81107168:	10801a17 	ldw	r2,104(r2)
8110716c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107170:	e0bfff17 	ldw	r2,-4(fp)
81107174:	10800017 	ldw	r2,0(r2)
81107178:	e1bffe17 	ldw	r6,-8(fp)
8110717c:	01401204 	movi	r5,72
81107180:	1009883a 	mov	r4,r2
81107184:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107188:	e0bfff17 	ldw	r2,-4(fp)
8110718c:	10801b17 	ldw	r2,108(r2)
81107190:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107194:	e0bfff17 	ldw	r2,-4(fp)
81107198:	10800017 	ldw	r2,0(r2)
8110719c:	e1bffe17 	ldw	r6,-8(fp)
811071a0:	01401244 	movi	r5,73
811071a4:	1009883a 	mov	r4,r2
811071a8:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811071ac:	e0bfff17 	ldw	r2,-4(fp)
811071b0:	10800017 	ldw	r2,0(r2)
811071b4:	01401284 	movi	r5,74
811071b8:	1009883a 	mov	r4,r2
811071bc:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811071c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
811071c4:	e0bfff17 	ldw	r2,-4(fp)
811071c8:	10801c17 	ldw	r2,112(r2)
811071cc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811071d0:	e0bfff17 	ldw	r2,-4(fp)
811071d4:	10800017 	ldw	r2,0(r2)
811071d8:	e1bffe17 	ldw	r6,-8(fp)
811071dc:	01401284 	movi	r5,74
811071e0:	1009883a 	mov	r4,r2
811071e4:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
811071e8:	e0bfff17 	ldw	r2,-4(fp)
811071ec:	10801d17 	ldw	r2,116(r2)
811071f0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811071f4:	e0bfff17 	ldw	r2,-4(fp)
811071f8:	10800017 	ldw	r2,0(r2)
811071fc:	e1bffe17 	ldw	r6,-8(fp)
81107200:	014012c4 	movi	r5,75
81107204:	1009883a 	mov	r4,r2
81107208:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
8110720c:	e0bfff17 	ldw	r2,-4(fp)
81107210:	10801e17 	ldw	r2,120(r2)
81107214:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107218:	e0bfff17 	ldw	r2,-4(fp)
8110721c:	10800017 	ldw	r2,0(r2)
81107220:	e1bffe17 	ldw	r6,-8(fp)
81107224:	01401304 	movi	r5,76
81107228:	1009883a 	mov	r4,r2
8110722c:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81107230:	e0bfff17 	ldw	r2,-4(fp)
81107234:	10801f17 	ldw	r2,124(r2)
81107238:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
8110723c:	e0bfff17 	ldw	r2,-4(fp)
81107240:	10800017 	ldw	r2,0(r2)
81107244:	e1bffe17 	ldw	r6,-8(fp)
81107248:	01401344 	movi	r5,77
8110724c:	1009883a 	mov	r4,r2
81107250:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81107254:	e0bfff17 	ldw	r2,-4(fp)
81107258:	10802017 	ldw	r2,128(r2)
8110725c:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81107260:	e0bfff17 	ldw	r2,-4(fp)
81107264:	10800017 	ldw	r2,0(r2)
81107268:	e1bffe17 	ldw	r6,-8(fp)
8110726c:	01401384 	movi	r5,78
81107270:	1009883a 	mov	r4,r2
81107274:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107278:	e0bfff17 	ldw	r2,-4(fp)
8110727c:	10802217 	ldw	r2,136(r2)
81107280:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107284:	e0bfff17 	ldw	r2,-4(fp)
81107288:	10800017 	ldw	r2,0(r2)
8110728c:	e1bffe17 	ldw	r6,-8(fp)
81107290:	014013c4 	movi	r5,79
81107294:	1009883a 	mov	r4,r2
81107298:	1108c280 	call	81108c28 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
8110729c:	e0bfff17 	ldw	r2,-4(fp)
811072a0:	10802217 	ldw	r2,136(r2)
811072a4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
811072a8:	e0bfff17 	ldw	r2,-4(fp)
811072ac:	10800017 	ldw	r2,0(r2)
811072b0:	e1bffe17 	ldw	r6,-8(fp)
811072b4:	01401404 	movi	r5,80
811072b8:	1009883a 	mov	r4,r2
811072bc:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
811072c0:	e0bfff17 	ldw	r2,-4(fp)
811072c4:	10802317 	ldw	r2,140(r2)
811072c8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
811072cc:	e0bfff17 	ldw	r2,-4(fp)
811072d0:	10800017 	ldw	r2,0(r2)
811072d4:	e1bffe17 	ldw	r6,-8(fp)
811072d8:	01401444 	movi	r5,81
811072dc:	1009883a 	mov	r4,r2
811072e0:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811072e4:	00800044 	movi	r2,1
811072e8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811072ec:	e0bffd17 	ldw	r2,-12(fp)
}
811072f0:	e037883a 	mov	sp,fp
811072f4:	dfc00117 	ldw	ra,4(sp)
811072f8:	df000017 	ldw	fp,0(sp)
811072fc:	dec00204 	addi	sp,sp,8
81107300:	f800283a 	ret

81107304 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81107304:	defffb04 	addi	sp,sp,-20
81107308:	de00012e 	bgeu	sp,et,81107310 <bRmapGetMemConfigArea+0xc>
8110730c:	003b68fa 	trap	3
81107310:	dfc00415 	stw	ra,16(sp)
81107314:	df000315 	stw	fp,12(sp)
81107318:	df000304 	addi	fp,sp,12
8110731c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107320:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107324:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107328:	e0bfff17 	ldw	r2,-4(fp)
8110732c:	1000a426 	beq	r2,zero,811075c0 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107330:	e0bfff17 	ldw	r2,-4(fp)
81107334:	10800017 	ldw	r2,0(r2)
81107338:	01401004 	movi	r5,64
8110733c:	1009883a 	mov	r4,r2
81107340:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107344:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
81107348:	e0bfff17 	ldw	r2,-4(fp)
8110734c:	e0fffe17 	ldw	r3,-8(fp)
81107350:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107354:	e0bfff17 	ldw	r2,-4(fp)
81107358:	10800017 	ldw	r2,0(r2)
8110735c:	01401044 	movi	r5,65
81107360:	1009883a 	mov	r4,r2
81107364:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107368:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
8110736c:	e0bfff17 	ldw	r2,-4(fp)
81107370:	e0fffe17 	ldw	r3,-8(fp)
81107374:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107378:	e0bfff17 	ldw	r2,-4(fp)
8110737c:	10800017 	ldw	r2,0(r2)
81107380:	01401084 	movi	r5,66
81107384:	1009883a 	mov	r4,r2
81107388:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110738c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81107390:	e0bfff17 	ldw	r2,-4(fp)
81107394:	e0fffe17 	ldw	r3,-8(fp)
81107398:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110739c:	e0bfff17 	ldw	r2,-4(fp)
811073a0:	10800017 	ldw	r2,0(r2)
811073a4:	014010c4 	movi	r5,67
811073a8:	1009883a 	mov	r4,r2
811073ac:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811073b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
811073b4:	e0bfff17 	ldw	r2,-4(fp)
811073b8:	e0fffe17 	ldw	r3,-8(fp)
811073bc:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073c0:	e0bfff17 	ldw	r2,-4(fp)
811073c4:	10800017 	ldw	r2,0(r2)
811073c8:	01401104 	movi	r5,68
811073cc:	1009883a 	mov	r4,r2
811073d0:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811073d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811073d8:	e0bfff17 	ldw	r2,-4(fp)
811073dc:	e0fffe17 	ldw	r3,-8(fp)
811073e0:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073e4:	e0bfff17 	ldw	r2,-4(fp)
811073e8:	10800017 	ldw	r2,0(r2)
811073ec:	01401144 	movi	r5,69
811073f0:	1009883a 	mov	r4,r2
811073f4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811073f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
811073fc:	e0bfff17 	ldw	r2,-4(fp)
81107400:	e0fffe17 	ldw	r3,-8(fp)
81107404:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107408:	e0bfff17 	ldw	r2,-4(fp)
8110740c:	10800017 	ldw	r2,0(r2)
81107410:	01401184 	movi	r5,70
81107414:	1009883a 	mov	r4,r2
81107418:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110741c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81107420:	e0bfff17 	ldw	r2,-4(fp)
81107424:	e0fffe17 	ldw	r3,-8(fp)
81107428:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110742c:	e0bfff17 	ldw	r2,-4(fp)
81107430:	10800017 	ldw	r2,0(r2)
81107434:	014011c4 	movi	r5,71
81107438:	1009883a 	mov	r4,r2
8110743c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107440:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81107444:	e0bfff17 	ldw	r2,-4(fp)
81107448:	e0fffe17 	ldw	r3,-8(fp)
8110744c:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107450:	e0bfff17 	ldw	r2,-4(fp)
81107454:	10800017 	ldw	r2,0(r2)
81107458:	01401204 	movi	r5,72
8110745c:	1009883a 	mov	r4,r2
81107460:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107464:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
81107468:	e0bfff17 	ldw	r2,-4(fp)
8110746c:	e0fffe17 	ldw	r3,-8(fp)
81107470:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107474:	e0bfff17 	ldw	r2,-4(fp)
81107478:	10800017 	ldw	r2,0(r2)
8110747c:	01401244 	movi	r5,73
81107480:	1009883a 	mov	r4,r2
81107484:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107488:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
8110748c:	e0bfff17 	ldw	r2,-4(fp)
81107490:	e0fffe17 	ldw	r3,-8(fp)
81107494:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107498:	e0bfff17 	ldw	r2,-4(fp)
8110749c:	10800017 	ldw	r2,0(r2)
811074a0:	01401284 	movi	r5,74
811074a4:	1009883a 	mov	r4,r2
811074a8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811074ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
811074b0:	e0bfff17 	ldw	r2,-4(fp)
811074b4:	e0fffe17 	ldw	r3,-8(fp)
811074b8:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811074bc:	e0bfff17 	ldw	r2,-4(fp)
811074c0:	10800017 	ldw	r2,0(r2)
811074c4:	014012c4 	movi	r5,75
811074c8:	1009883a 	mov	r4,r2
811074cc:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811074d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
811074d4:	e0bfff17 	ldw	r2,-4(fp)
811074d8:	e0fffe17 	ldw	r3,-8(fp)
811074dc:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811074e0:	e0bfff17 	ldw	r2,-4(fp)
811074e4:	10800017 	ldw	r2,0(r2)
811074e8:	01401304 	movi	r5,76
811074ec:	1009883a 	mov	r4,r2
811074f0:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811074f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
811074f8:	e0bfff17 	ldw	r2,-4(fp)
811074fc:	e0fffe17 	ldw	r3,-8(fp)
81107500:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107504:	e0bfff17 	ldw	r2,-4(fp)
81107508:	10800017 	ldw	r2,0(r2)
8110750c:	01401344 	movi	r5,77
81107510:	1009883a 	mov	r4,r2
81107514:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107518:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
8110751c:	e0bfff17 	ldw	r2,-4(fp)
81107520:	e0fffe17 	ldw	r3,-8(fp)
81107524:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107528:	e0bfff17 	ldw	r2,-4(fp)
8110752c:	10800017 	ldw	r2,0(r2)
81107530:	01401384 	movi	r5,78
81107534:	1009883a 	mov	r4,r2
81107538:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110753c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81107540:	e0bfff17 	ldw	r2,-4(fp)
81107544:	e0fffe17 	ldw	r3,-8(fp)
81107548:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110754c:	e0bfff17 	ldw	r2,-4(fp)
81107550:	10800017 	ldw	r2,0(r2)
81107554:	014013c4 	movi	r5,79
81107558:	1009883a 	mov	r4,r2
8110755c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107560:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107564:	e0bfff17 	ldw	r2,-4(fp)
81107568:	e0fffe17 	ldw	r3,-8(fp)
8110756c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107570:	e0bfff17 	ldw	r2,-4(fp)
81107574:	10800017 	ldw	r2,0(r2)
81107578:	01401404 	movi	r5,80
8110757c:	1009883a 	mov	r4,r2
81107580:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107584:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107588:	e0bfff17 	ldw	r2,-4(fp)
8110758c:	e0fffe17 	ldw	r3,-8(fp)
81107590:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107594:	e0bfff17 	ldw	r2,-4(fp)
81107598:	10800017 	ldw	r2,0(r2)
8110759c:	01401444 	movi	r5,81
811075a0:	1009883a 	mov	r4,r2
811075a4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811075a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
811075ac:	e0bfff17 	ldw	r2,-4(fp)
811075b0:	e0fffe17 	ldw	r3,-8(fp)
811075b4:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
811075b8:	00800044 	movi	r2,1
811075bc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811075c0:	e0bffd17 	ldw	r2,-12(fp)
}
811075c4:	e037883a 	mov	sp,fp
811075c8:	dfc00117 	ldw	ra,4(sp)
811075cc:	df000017 	ldw	fp,0(sp)
811075d0:	dec00204 	addi	sp,sp,8
811075d4:	f800283a 	ret

811075d8 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
811075d8:	defffb04 	addi	sp,sp,-20
811075dc:	de00012e 	bgeu	sp,et,811075e4 <bRmapGetMemConfigStat+0xc>
811075e0:	003b68fa 	trap	3
811075e4:	dfc00415 	stw	ra,16(sp)
811075e8:	df000315 	stw	fp,12(sp)
811075ec:	df000304 	addi	fp,sp,12
811075f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811075f4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811075f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811075fc:	e0bfff17 	ldw	r2,-4(fp)
81107600:	10001426 	beq	r2,zero,81107654 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107604:	e0bfff17 	ldw	r2,-4(fp)
81107608:	10800017 	ldw	r2,0(r2)
8110760c:	014001c4 	movi	r5,7
81107610:	1009883a 	mov	r4,r2
81107614:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107618:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
8110761c:	e0bfff17 	ldw	r2,-4(fp)
81107620:	e0fffe17 	ldw	r3,-8(fp)
81107624:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107628:	e0bfff17 	ldw	r2,-4(fp)
8110762c:	10800017 	ldw	r2,0(r2)
81107630:	01400184 	movi	r5,6
81107634:	1009883a 	mov	r4,r2
81107638:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110763c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81107640:	e0bfff17 	ldw	r2,-4(fp)
81107644:	e0fffe17 	ldw	r3,-8(fp)
81107648:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
8110764c:	00800044 	movi	r2,1
81107650:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107654:	e0bffd17 	ldw	r2,-12(fp)
}
81107658:	e037883a 	mov	sp,fp
8110765c:	dfc00117 	ldw	ra,4(sp)
81107660:	df000017 	ldw	fp,0(sp)
81107664:	dec00204 	addi	sp,sp,8
81107668:	f800283a 	ret

8110766c <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
8110766c:	defffb04 	addi	sp,sp,-20
81107670:	de00012e 	bgeu	sp,et,81107678 <bRmapSetRmapMemHKArea+0xc>
81107674:	003b68fa 	trap	3
81107678:	dfc00415 	stw	ra,16(sp)
8110767c:	df000315 	stw	fp,12(sp)
81107680:	df000304 	addi	fp,sp,12
81107684:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107688:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110768c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107690:	e0bfff17 	ldw	r2,-4(fp)
81107694:	10030226 	beq	r2,zero,811082a0 <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107698:	e0bfff17 	ldw	r2,-4(fp)
8110769c:	10800017 	ldw	r2,0(r2)
811076a0:	01402804 	movi	r5,160
811076a4:	1009883a 	mov	r4,r2
811076a8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811076ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
811076b0:	e0bffe17 	ldw	r2,-8(fp)
811076b4:	10bfffec 	andhi	r2,r2,65535
811076b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
811076bc:	e0bfff17 	ldw	r2,-4(fp)
811076c0:	1080260b 	ldhu	r2,152(r2)
811076c4:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
811076c8:	e0fffe17 	ldw	r3,-8(fp)
811076cc:	1884b03a 	or	r2,r3,r2
811076d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
811076d4:	e0bffe17 	ldw	r2,-8(fp)
811076d8:	10bfffcc 	andi	r2,r2,65535
811076dc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
811076e0:	e0bfff17 	ldw	r2,-4(fp)
811076e4:	10800017 	ldw	r2,0(r2)
811076e8:	e1bffe17 	ldw	r6,-8(fp)
811076ec:	01402804 	movi	r5,160
811076f0:	1009883a 	mov	r4,r2
811076f4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076f8:	e0bfff17 	ldw	r2,-4(fp)
811076fc:	10800017 	ldw	r2,0(r2)
81107700:	01402844 	movi	r5,161
81107704:	1009883a 	mov	r4,r2
81107708:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110770c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81107710:	e0bffe17 	ldw	r2,-8(fp)
81107714:	10bfffec 	andhi	r2,r2,65535
81107718:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
8110771c:	e0bfff17 	ldw	r2,-4(fp)
81107720:	1080270b 	ldhu	r2,156(r2)
81107724:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81107728:	e0fffe17 	ldw	r3,-8(fp)
8110772c:	1884b03a 	or	r2,r3,r2
81107730:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81107734:	e0bffe17 	ldw	r2,-8(fp)
81107738:	10bfffcc 	andi	r2,r2,65535
8110773c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81107740:	e0bfff17 	ldw	r2,-4(fp)
81107744:	10800017 	ldw	r2,0(r2)
81107748:	e1bffe17 	ldw	r6,-8(fp)
8110774c:	01402844 	movi	r5,161
81107750:	1009883a 	mov	r4,r2
81107754:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107758:	e0bfff17 	ldw	r2,-4(fp)
8110775c:	10800017 	ldw	r2,0(r2)
81107760:	01402884 	movi	r5,162
81107764:	1009883a 	mov	r4,r2
81107768:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110776c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81107770:	e0bffe17 	ldw	r2,-8(fp)
81107774:	10bfffec 	andhi	r2,r2,65535
81107778:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
8110777c:	e0bfff17 	ldw	r2,-4(fp)
81107780:	1080280b 	ldhu	r2,160(r2)
81107784:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81107788:	e0fffe17 	ldw	r3,-8(fp)
8110778c:	1884b03a 	or	r2,r3,r2
81107790:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81107794:	e0bffe17 	ldw	r2,-8(fp)
81107798:	10bfffcc 	andi	r2,r2,65535
8110779c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
811077a0:	e0bfff17 	ldw	r2,-4(fp)
811077a4:	10800017 	ldw	r2,0(r2)
811077a8:	e1bffe17 	ldw	r6,-8(fp)
811077ac:	01402884 	movi	r5,162
811077b0:	1009883a 	mov	r4,r2
811077b4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077b8:	e0bfff17 	ldw	r2,-4(fp)
811077bc:	10800017 	ldw	r2,0(r2)
811077c0:	014028c4 	movi	r5,163
811077c4:	1009883a 	mov	r4,r2
811077c8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811077cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
811077d0:	e0bffe17 	ldw	r2,-8(fp)
811077d4:	10bfffec 	andhi	r2,r2,65535
811077d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
811077dc:	e0bfff17 	ldw	r2,-4(fp)
811077e0:	1080290b 	ldhu	r2,164(r2)
811077e4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811077e8:	e0fffe17 	ldw	r3,-8(fp)
811077ec:	1884b03a 	or	r2,r3,r2
811077f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811077f4:	e0bffe17 	ldw	r2,-8(fp)
811077f8:	10bfffcc 	andi	r2,r2,65535
811077fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81107800:	e0bfff17 	ldw	r2,-4(fp)
81107804:	10800017 	ldw	r2,0(r2)
81107808:	e1bffe17 	ldw	r6,-8(fp)
8110780c:	014028c4 	movi	r5,163
81107810:	1009883a 	mov	r4,r2
81107814:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107818:	e0bfff17 	ldw	r2,-4(fp)
8110781c:	10800017 	ldw	r2,0(r2)
81107820:	01402904 	movi	r5,164
81107824:	1009883a 	mov	r4,r2
81107828:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110782c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81107830:	e0bffe17 	ldw	r2,-8(fp)
81107834:	10bfffec 	andhi	r2,r2,65535
81107838:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
8110783c:	e0bfff17 	ldw	r2,-4(fp)
81107840:	10802a0b 	ldhu	r2,168(r2)
81107844:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81107848:	e0fffe17 	ldw	r3,-8(fp)
8110784c:	1884b03a 	or	r2,r3,r2
81107850:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81107854:	e0bffe17 	ldw	r2,-8(fp)
81107858:	10bfffcc 	andi	r2,r2,65535
8110785c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81107860:	e0bfff17 	ldw	r2,-4(fp)
81107864:	10800017 	ldw	r2,0(r2)
81107868:	e1bffe17 	ldw	r6,-8(fp)
8110786c:	01402904 	movi	r5,164
81107870:	1009883a 	mov	r4,r2
81107874:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107878:	e0bfff17 	ldw	r2,-4(fp)
8110787c:	10800017 	ldw	r2,0(r2)
81107880:	01402944 	movi	r5,165
81107884:	1009883a 	mov	r4,r2
81107888:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110788c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81107890:	e0bffe17 	ldw	r2,-8(fp)
81107894:	10bfffec 	andhi	r2,r2,65535
81107898:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
8110789c:	e0bfff17 	ldw	r2,-4(fp)
811078a0:	10802b0b 	ldhu	r2,172(r2)
811078a4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811078a8:	e0fffe17 	ldw	r3,-8(fp)
811078ac:	1884b03a 	or	r2,r3,r2
811078b0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811078b4:	e0bffe17 	ldw	r2,-8(fp)
811078b8:	10bfffcc 	andi	r2,r2,65535
811078bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
811078c0:	e0bfff17 	ldw	r2,-4(fp)
811078c4:	10800017 	ldw	r2,0(r2)
811078c8:	e1bffe17 	ldw	r6,-8(fp)
811078cc:	01402944 	movi	r5,165
811078d0:	1009883a 	mov	r4,r2
811078d4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078d8:	e0bfff17 	ldw	r2,-4(fp)
811078dc:	10800017 	ldw	r2,0(r2)
811078e0:	01402984 	movi	r5,166
811078e4:	1009883a 	mov	r4,r2
811078e8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811078ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
811078f0:	e0bffe17 	ldw	r2,-8(fp)
811078f4:	10bfffec 	andhi	r2,r2,65535
811078f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
811078fc:	e0bfff17 	ldw	r2,-4(fp)
81107900:	10802c0b 	ldhu	r2,176(r2)
81107904:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81107908:	e0fffe17 	ldw	r3,-8(fp)
8110790c:	1884b03a 	or	r2,r3,r2
81107910:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81107914:	e0bffe17 	ldw	r2,-8(fp)
81107918:	10bfffcc 	andi	r2,r2,65535
8110791c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81107920:	e0bfff17 	ldw	r2,-4(fp)
81107924:	10800017 	ldw	r2,0(r2)
81107928:	e1bffe17 	ldw	r6,-8(fp)
8110792c:	01402984 	movi	r5,166
81107930:	1009883a 	mov	r4,r2
81107934:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107938:	e0bfff17 	ldw	r2,-4(fp)
8110793c:	10800017 	ldw	r2,0(r2)
81107940:	014029c4 	movi	r5,167
81107944:	1009883a 	mov	r4,r2
81107948:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110794c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81107950:	e0bffe17 	ldw	r2,-8(fp)
81107954:	10bfffec 	andhi	r2,r2,65535
81107958:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
8110795c:	e0bfff17 	ldw	r2,-4(fp)
81107960:	10802d0b 	ldhu	r2,180(r2)
81107964:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81107968:	e0fffe17 	ldw	r3,-8(fp)
8110796c:	1884b03a 	or	r2,r3,r2
81107970:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81107974:	e0bffe17 	ldw	r2,-8(fp)
81107978:	10bfffcc 	andi	r2,r2,65535
8110797c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81107980:	e0bfff17 	ldw	r2,-4(fp)
81107984:	10800017 	ldw	r2,0(r2)
81107988:	e1bffe17 	ldw	r6,-8(fp)
8110798c:	014029c4 	movi	r5,167
81107990:	1009883a 	mov	r4,r2
81107994:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107998:	e0bfff17 	ldw	r2,-4(fp)
8110799c:	10800017 	ldw	r2,0(r2)
811079a0:	01402a04 	movi	r5,168
811079a4:	1009883a 	mov	r4,r2
811079a8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811079ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
811079b0:	e0bffe17 	ldw	r2,-8(fp)
811079b4:	10bfffec 	andhi	r2,r2,65535
811079b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
811079bc:	e0bfff17 	ldw	r2,-4(fp)
811079c0:	10802e0b 	ldhu	r2,184(r2)
811079c4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
811079c8:	e0fffe17 	ldw	r3,-8(fp)
811079cc:	1884b03a 	or	r2,r3,r2
811079d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
811079d4:	e0bffe17 	ldw	r2,-8(fp)
811079d8:	10bfffcc 	andi	r2,r2,65535
811079dc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
811079e0:	e0bfff17 	ldw	r2,-4(fp)
811079e4:	10800017 	ldw	r2,0(r2)
811079e8:	e1bffe17 	ldw	r6,-8(fp)
811079ec:	01402a04 	movi	r5,168
811079f0:	1009883a 	mov	r4,r2
811079f4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079f8:	e0bfff17 	ldw	r2,-4(fp)
811079fc:	10800017 	ldw	r2,0(r2)
81107a00:	01402a44 	movi	r5,169
81107a04:	1009883a 	mov	r4,r2
81107a08:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107a0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81107a10:	e0bffe17 	ldw	r2,-8(fp)
81107a14:	10bfffec 	andhi	r2,r2,65535
81107a18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81107a1c:	e0bfff17 	ldw	r2,-4(fp)
81107a20:	10802f0b 	ldhu	r2,188(r2)
81107a24:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81107a28:	e0fffe17 	ldw	r3,-8(fp)
81107a2c:	1884b03a 	or	r2,r3,r2
81107a30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81107a34:	e0bffe17 	ldw	r2,-8(fp)
81107a38:	10bfffcc 	andi	r2,r2,65535
81107a3c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81107a40:	e0bfff17 	ldw	r2,-4(fp)
81107a44:	10800017 	ldw	r2,0(r2)
81107a48:	e1bffe17 	ldw	r6,-8(fp)
81107a4c:	01402a44 	movi	r5,169
81107a50:	1009883a 	mov	r4,r2
81107a54:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a58:	e0bfff17 	ldw	r2,-4(fp)
81107a5c:	10800017 	ldw	r2,0(r2)
81107a60:	01402a84 	movi	r5,170
81107a64:	1009883a 	mov	r4,r2
81107a68:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107a6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81107a70:	e0bffe17 	ldw	r2,-8(fp)
81107a74:	10bfffec 	andhi	r2,r2,65535
81107a78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81107a7c:	e0bfff17 	ldw	r2,-4(fp)
81107a80:	1080300b 	ldhu	r2,192(r2)
81107a84:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81107a88:	e0fffe17 	ldw	r3,-8(fp)
81107a8c:	1884b03a 	or	r2,r3,r2
81107a90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81107a94:	e0bffe17 	ldw	r2,-8(fp)
81107a98:	10bfffcc 	andi	r2,r2,65535
81107a9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81107aa0:	e0bfff17 	ldw	r2,-4(fp)
81107aa4:	10800017 	ldw	r2,0(r2)
81107aa8:	e1bffe17 	ldw	r6,-8(fp)
81107aac:	01402a84 	movi	r5,170
81107ab0:	1009883a 	mov	r4,r2
81107ab4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ab8:	e0bfff17 	ldw	r2,-4(fp)
81107abc:	10800017 	ldw	r2,0(r2)
81107ac0:	01402ac4 	movi	r5,171
81107ac4:	1009883a 	mov	r4,r2
81107ac8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107acc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81107ad0:	e0bffe17 	ldw	r2,-8(fp)
81107ad4:	10bfffec 	andhi	r2,r2,65535
81107ad8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81107adc:	e0bfff17 	ldw	r2,-4(fp)
81107ae0:	1080310b 	ldhu	r2,196(r2)
81107ae4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81107ae8:	e0fffe17 	ldw	r3,-8(fp)
81107aec:	1884b03a 	or	r2,r3,r2
81107af0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81107af4:	e0bffe17 	ldw	r2,-8(fp)
81107af8:	10bfffcc 	andi	r2,r2,65535
81107afc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81107b00:	e0bfff17 	ldw	r2,-4(fp)
81107b04:	10800017 	ldw	r2,0(r2)
81107b08:	e1bffe17 	ldw	r6,-8(fp)
81107b0c:	01402ac4 	movi	r5,171
81107b10:	1009883a 	mov	r4,r2
81107b14:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b18:	e0bfff17 	ldw	r2,-4(fp)
81107b1c:	10800017 	ldw	r2,0(r2)
81107b20:	01402b04 	movi	r5,172
81107b24:	1009883a 	mov	r4,r2
81107b28:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107b2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81107b30:	e0bffe17 	ldw	r2,-8(fp)
81107b34:	10bfffec 	andhi	r2,r2,65535
81107b38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81107b3c:	e0bfff17 	ldw	r2,-4(fp)
81107b40:	1080320b 	ldhu	r2,200(r2)
81107b44:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81107b48:	e0fffe17 	ldw	r3,-8(fp)
81107b4c:	1884b03a 	or	r2,r3,r2
81107b50:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81107b54:	e0bffe17 	ldw	r2,-8(fp)
81107b58:	10bfffcc 	andi	r2,r2,65535
81107b5c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81107b60:	e0bfff17 	ldw	r2,-4(fp)
81107b64:	10800017 	ldw	r2,0(r2)
81107b68:	e1bffe17 	ldw	r6,-8(fp)
81107b6c:	01402b04 	movi	r5,172
81107b70:	1009883a 	mov	r4,r2
81107b74:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b78:	e0bfff17 	ldw	r2,-4(fp)
81107b7c:	10800017 	ldw	r2,0(r2)
81107b80:	01402b44 	movi	r5,173
81107b84:	1009883a 	mov	r4,r2
81107b88:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107b8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81107b90:	e0bffe17 	ldw	r2,-8(fp)
81107b94:	10bfffec 	andhi	r2,r2,65535
81107b98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81107b9c:	e0bfff17 	ldw	r2,-4(fp)
81107ba0:	1080330b 	ldhu	r2,204(r2)
81107ba4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81107ba8:	e0fffe17 	ldw	r3,-8(fp)
81107bac:	1884b03a 	or	r2,r3,r2
81107bb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81107bb4:	e0bffe17 	ldw	r2,-8(fp)
81107bb8:	10bfffcc 	andi	r2,r2,65535
81107bbc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81107bc0:	e0bfff17 	ldw	r2,-4(fp)
81107bc4:	10800017 	ldw	r2,0(r2)
81107bc8:	e1bffe17 	ldw	r6,-8(fp)
81107bcc:	01402b44 	movi	r5,173
81107bd0:	1009883a 	mov	r4,r2
81107bd4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bd8:	e0bfff17 	ldw	r2,-4(fp)
81107bdc:	10800017 	ldw	r2,0(r2)
81107be0:	01402b84 	movi	r5,174
81107be4:	1009883a 	mov	r4,r2
81107be8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107bec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81107bf0:	e0bffe17 	ldw	r2,-8(fp)
81107bf4:	10bfffec 	andhi	r2,r2,65535
81107bf8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81107bfc:	e0bfff17 	ldw	r2,-4(fp)
81107c00:	1080340b 	ldhu	r2,208(r2)
81107c04:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81107c08:	e0fffe17 	ldw	r3,-8(fp)
81107c0c:	1884b03a 	or	r2,r3,r2
81107c10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81107c14:	e0bffe17 	ldw	r2,-8(fp)
81107c18:	10bfffcc 	andi	r2,r2,65535
81107c1c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81107c20:	e0bfff17 	ldw	r2,-4(fp)
81107c24:	10800017 	ldw	r2,0(r2)
81107c28:	e1bffe17 	ldw	r6,-8(fp)
81107c2c:	01402b84 	movi	r5,174
81107c30:	1009883a 	mov	r4,r2
81107c34:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c38:	e0bfff17 	ldw	r2,-4(fp)
81107c3c:	10800017 	ldw	r2,0(r2)
81107c40:	01402bc4 	movi	r5,175
81107c44:	1009883a 	mov	r4,r2
81107c48:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107c4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81107c50:	e0bffe17 	ldw	r2,-8(fp)
81107c54:	10bfffec 	andhi	r2,r2,65535
81107c58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81107c5c:	e0bfff17 	ldw	r2,-4(fp)
81107c60:	1080350b 	ldhu	r2,212(r2)
81107c64:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81107c68:	e0fffe17 	ldw	r3,-8(fp)
81107c6c:	1884b03a 	or	r2,r3,r2
81107c70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81107c74:	e0bffe17 	ldw	r2,-8(fp)
81107c78:	10bfffcc 	andi	r2,r2,65535
81107c7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81107c80:	e0bfff17 	ldw	r2,-4(fp)
81107c84:	10800017 	ldw	r2,0(r2)
81107c88:	e1bffe17 	ldw	r6,-8(fp)
81107c8c:	01402bc4 	movi	r5,175
81107c90:	1009883a 	mov	r4,r2
81107c94:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c98:	e0bfff17 	ldw	r2,-4(fp)
81107c9c:	10800017 	ldw	r2,0(r2)
81107ca0:	01402c04 	movi	r5,176
81107ca4:	1009883a 	mov	r4,r2
81107ca8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107cac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81107cb0:	e0bffe17 	ldw	r2,-8(fp)
81107cb4:	10bfffec 	andhi	r2,r2,65535
81107cb8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81107cbc:	e0bfff17 	ldw	r2,-4(fp)
81107cc0:	1080360b 	ldhu	r2,216(r2)
81107cc4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81107cc8:	e0fffe17 	ldw	r3,-8(fp)
81107ccc:	1884b03a 	or	r2,r3,r2
81107cd0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81107cd4:	e0bffe17 	ldw	r2,-8(fp)
81107cd8:	10bfffcc 	andi	r2,r2,65535
81107cdc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81107ce0:	e0bfff17 	ldw	r2,-4(fp)
81107ce4:	10800017 	ldw	r2,0(r2)
81107ce8:	e1bffe17 	ldw	r6,-8(fp)
81107cec:	01402c04 	movi	r5,176
81107cf0:	1009883a 	mov	r4,r2
81107cf4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107cf8:	e0bfff17 	ldw	r2,-4(fp)
81107cfc:	10800017 	ldw	r2,0(r2)
81107d00:	01402c44 	movi	r5,177
81107d04:	1009883a 	mov	r4,r2
81107d08:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107d0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81107d10:	e0bffe17 	ldw	r2,-8(fp)
81107d14:	10bfffec 	andhi	r2,r2,65535
81107d18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81107d1c:	e0bfff17 	ldw	r2,-4(fp)
81107d20:	1080370b 	ldhu	r2,220(r2)
81107d24:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81107d28:	e0fffe17 	ldw	r3,-8(fp)
81107d2c:	1884b03a 	or	r2,r3,r2
81107d30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81107d34:	e0bffe17 	ldw	r2,-8(fp)
81107d38:	10bfffcc 	andi	r2,r2,65535
81107d3c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81107d40:	e0bfff17 	ldw	r2,-4(fp)
81107d44:	10800017 	ldw	r2,0(r2)
81107d48:	e1bffe17 	ldw	r6,-8(fp)
81107d4c:	01402c44 	movi	r5,177
81107d50:	1009883a 	mov	r4,r2
81107d54:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d58:	e0bfff17 	ldw	r2,-4(fp)
81107d5c:	10800017 	ldw	r2,0(r2)
81107d60:	01402c84 	movi	r5,178
81107d64:	1009883a 	mov	r4,r2
81107d68:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107d6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81107d70:	e0bffe17 	ldw	r2,-8(fp)
81107d74:	10bfffec 	andhi	r2,r2,65535
81107d78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81107d7c:	e0bfff17 	ldw	r2,-4(fp)
81107d80:	1080380b 	ldhu	r2,224(r2)
81107d84:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81107d88:	e0fffe17 	ldw	r3,-8(fp)
81107d8c:	1884b03a 	or	r2,r3,r2
81107d90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81107d94:	e0bffe17 	ldw	r2,-8(fp)
81107d98:	10bfffcc 	andi	r2,r2,65535
81107d9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81107da0:	e0bfff17 	ldw	r2,-4(fp)
81107da4:	10800017 	ldw	r2,0(r2)
81107da8:	e1bffe17 	ldw	r6,-8(fp)
81107dac:	01402c84 	movi	r5,178
81107db0:	1009883a 	mov	r4,r2
81107db4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107db8:	e0bfff17 	ldw	r2,-4(fp)
81107dbc:	10800017 	ldw	r2,0(r2)
81107dc0:	01402cc4 	movi	r5,179
81107dc4:	1009883a 	mov	r4,r2
81107dc8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107dcc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81107dd0:	e0bffe17 	ldw	r2,-8(fp)
81107dd4:	10bfffec 	andhi	r2,r2,65535
81107dd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81107ddc:	e0bfff17 	ldw	r2,-4(fp)
81107de0:	1080390b 	ldhu	r2,228(r2)
81107de4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81107de8:	e0fffe17 	ldw	r3,-8(fp)
81107dec:	1884b03a 	or	r2,r3,r2
81107df0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81107df4:	e0bffe17 	ldw	r2,-8(fp)
81107df8:	10bfffcc 	andi	r2,r2,65535
81107dfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81107e00:	e0bfff17 	ldw	r2,-4(fp)
81107e04:	10800017 	ldw	r2,0(r2)
81107e08:	e1bffe17 	ldw	r6,-8(fp)
81107e0c:	01402cc4 	movi	r5,179
81107e10:	1009883a 	mov	r4,r2
81107e14:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e18:	e0bfff17 	ldw	r2,-4(fp)
81107e1c:	10800017 	ldw	r2,0(r2)
81107e20:	01402d04 	movi	r5,180
81107e24:	1009883a 	mov	r4,r2
81107e28:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107e2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81107e30:	e0bffe17 	ldw	r2,-8(fp)
81107e34:	10bfffec 	andhi	r2,r2,65535
81107e38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81107e3c:	e0bfff17 	ldw	r2,-4(fp)
81107e40:	10803a0b 	ldhu	r2,232(r2)
81107e44:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81107e48:	e0fffe17 	ldw	r3,-8(fp)
81107e4c:	1884b03a 	or	r2,r3,r2
81107e50:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81107e54:	e0bffe17 	ldw	r2,-8(fp)
81107e58:	10bfffcc 	andi	r2,r2,65535
81107e5c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81107e60:	e0bfff17 	ldw	r2,-4(fp)
81107e64:	10800017 	ldw	r2,0(r2)
81107e68:	e1bffe17 	ldw	r6,-8(fp)
81107e6c:	01402d04 	movi	r5,180
81107e70:	1009883a 	mov	r4,r2
81107e74:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e78:	e0bfff17 	ldw	r2,-4(fp)
81107e7c:	10800017 	ldw	r2,0(r2)
81107e80:	01402d44 	movi	r5,181
81107e84:	1009883a 	mov	r4,r2
81107e88:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107e8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81107e90:	e0bffe17 	ldw	r2,-8(fp)
81107e94:	10bfffec 	andhi	r2,r2,65535
81107e98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81107e9c:	e0bfff17 	ldw	r2,-4(fp)
81107ea0:	10803b0b 	ldhu	r2,236(r2)
81107ea4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81107ea8:	e0fffe17 	ldw	r3,-8(fp)
81107eac:	1884b03a 	or	r2,r3,r2
81107eb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81107eb4:	e0bffe17 	ldw	r2,-8(fp)
81107eb8:	10bfffcc 	andi	r2,r2,65535
81107ebc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81107ec0:	e0bfff17 	ldw	r2,-4(fp)
81107ec4:	10800017 	ldw	r2,0(r2)
81107ec8:	e1bffe17 	ldw	r6,-8(fp)
81107ecc:	01402d44 	movi	r5,181
81107ed0:	1009883a 	mov	r4,r2
81107ed4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ed8:	e0bfff17 	ldw	r2,-4(fp)
81107edc:	10800017 	ldw	r2,0(r2)
81107ee0:	01402d84 	movi	r5,182
81107ee4:	1009883a 	mov	r4,r2
81107ee8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107eec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81107ef0:	e0bffe17 	ldw	r2,-8(fp)
81107ef4:	10bfffec 	andhi	r2,r2,65535
81107ef8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81107efc:	e0bfff17 	ldw	r2,-4(fp)
81107f00:	10803c0b 	ldhu	r2,240(r2)
81107f04:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81107f08:	e0fffe17 	ldw	r3,-8(fp)
81107f0c:	1884b03a 	or	r2,r3,r2
81107f10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81107f14:	e0bffe17 	ldw	r2,-8(fp)
81107f18:	10bfffcc 	andi	r2,r2,65535
81107f1c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81107f20:	e0bfff17 	ldw	r2,-4(fp)
81107f24:	10800017 	ldw	r2,0(r2)
81107f28:	e1bffe17 	ldw	r6,-8(fp)
81107f2c:	01402d84 	movi	r5,182
81107f30:	1009883a 	mov	r4,r2
81107f34:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f38:	e0bfff17 	ldw	r2,-4(fp)
81107f3c:	10800017 	ldw	r2,0(r2)
81107f40:	01402dc4 	movi	r5,183
81107f44:	1009883a 	mov	r4,r2
81107f48:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107f4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81107f50:	e0bffe17 	ldw	r2,-8(fp)
81107f54:	10bfffec 	andhi	r2,r2,65535
81107f58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81107f5c:	e0bfff17 	ldw	r2,-4(fp)
81107f60:	10803d0b 	ldhu	r2,244(r2)
81107f64:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81107f68:	e0fffe17 	ldw	r3,-8(fp)
81107f6c:	1884b03a 	or	r2,r3,r2
81107f70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81107f74:	e0bffe17 	ldw	r2,-8(fp)
81107f78:	10bfffcc 	andi	r2,r2,65535
81107f7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81107f80:	e0bfff17 	ldw	r2,-4(fp)
81107f84:	10800017 	ldw	r2,0(r2)
81107f88:	e1bffe17 	ldw	r6,-8(fp)
81107f8c:	01402dc4 	movi	r5,183
81107f90:	1009883a 	mov	r4,r2
81107f94:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f98:	e0bfff17 	ldw	r2,-4(fp)
81107f9c:	10800017 	ldw	r2,0(r2)
81107fa0:	01402e04 	movi	r5,184
81107fa4:	1009883a 	mov	r4,r2
81107fa8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81107fac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81107fb0:	e0bffe17 	ldw	r2,-8(fp)
81107fb4:	10bfffec 	andhi	r2,r2,65535
81107fb8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81107fbc:	e0bfff17 	ldw	r2,-4(fp)
81107fc0:	10803e0b 	ldhu	r2,248(r2)
81107fc4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81107fc8:	e0fffe17 	ldw	r3,-8(fp)
81107fcc:	1884b03a 	or	r2,r3,r2
81107fd0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81107fd4:	e0bffe17 	ldw	r2,-8(fp)
81107fd8:	10bfffcc 	andi	r2,r2,65535
81107fdc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81107fe0:	e0bfff17 	ldw	r2,-4(fp)
81107fe4:	10800017 	ldw	r2,0(r2)
81107fe8:	e1bffe17 	ldw	r6,-8(fp)
81107fec:	01402e04 	movi	r5,184
81107ff0:	1009883a 	mov	r4,r2
81107ff4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ff8:	e0bfff17 	ldw	r2,-4(fp)
81107ffc:	10800017 	ldw	r2,0(r2)
81108000:	01402e44 	movi	r5,185
81108004:	1009883a 	mov	r4,r2
81108008:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110800c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81108010:	e0bffe17 	ldw	r2,-8(fp)
81108014:	10bfffec 	andhi	r2,r2,65535
81108018:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
8110801c:	e0bfff17 	ldw	r2,-4(fp)
81108020:	10803f0b 	ldhu	r2,252(r2)
81108024:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81108028:	e0fffe17 	ldw	r3,-8(fp)
8110802c:	1884b03a 	or	r2,r3,r2
81108030:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81108034:	e0bffe17 	ldw	r2,-8(fp)
81108038:	10bfffcc 	andi	r2,r2,65535
8110803c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81108040:	e0bfff17 	ldw	r2,-4(fp)
81108044:	10800017 	ldw	r2,0(r2)
81108048:	e1bffe17 	ldw	r6,-8(fp)
8110804c:	01402e44 	movi	r5,185
81108050:	1009883a 	mov	r4,r2
81108054:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108058:	e0bfff17 	ldw	r2,-4(fp)
8110805c:	10800017 	ldw	r2,0(r2)
81108060:	01402e84 	movi	r5,186
81108064:	1009883a 	mov	r4,r2
81108068:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110806c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81108070:	e0bffe17 	ldw	r2,-8(fp)
81108074:	10bfffec 	andhi	r2,r2,65535
81108078:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
8110807c:	e0bfff17 	ldw	r2,-4(fp)
81108080:	1080400b 	ldhu	r2,256(r2)
81108084:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81108088:	e0fffe17 	ldw	r3,-8(fp)
8110808c:	1884b03a 	or	r2,r3,r2
81108090:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81108094:	e0bffe17 	ldw	r2,-8(fp)
81108098:	10bfffcc 	andi	r2,r2,65535
8110809c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
811080a0:	e0bfff17 	ldw	r2,-4(fp)
811080a4:	10800017 	ldw	r2,0(r2)
811080a8:	e1bffe17 	ldw	r6,-8(fp)
811080ac:	01402e84 	movi	r5,186
811080b0:	1009883a 	mov	r4,r2
811080b4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	10800017 	ldw	r2,0(r2)
811080c0:	01402ec4 	movi	r5,187
811080c4:	1009883a 	mov	r4,r2
811080c8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811080cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
811080d0:	e0bffe17 	ldw	r2,-8(fp)
811080d4:	10bfffec 	andhi	r2,r2,65535
811080d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
811080dc:	e0bfff17 	ldw	r2,-4(fp)
811080e0:	1080410b 	ldhu	r2,260(r2)
811080e4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811080e8:	e0fffe17 	ldw	r3,-8(fp)
811080ec:	1884b03a 	or	r2,r3,r2
811080f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811080f4:	e0bffe17 	ldw	r2,-8(fp)
811080f8:	10bfffcc 	andi	r2,r2,65535
811080fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81108100:	e0bfff17 	ldw	r2,-4(fp)
81108104:	10800017 	ldw	r2,0(r2)
81108108:	e1bffe17 	ldw	r6,-8(fp)
8110810c:	01402ec4 	movi	r5,187
81108110:	1009883a 	mov	r4,r2
81108114:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10800017 	ldw	r2,0(r2)
81108120:	01402f04 	movi	r5,188
81108124:	1009883a 	mov	r4,r2
81108128:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110812c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81108130:	e0bffe17 	ldw	r2,-8(fp)
81108134:	10bfffec 	andhi	r2,r2,65535
81108138:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
8110813c:	e0bfff17 	ldw	r2,-4(fp)
81108140:	1080420b 	ldhu	r2,264(r2)
81108144:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81108148:	e0fffe17 	ldw	r3,-8(fp)
8110814c:	1884b03a 	or	r2,r3,r2
81108150:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81108154:	e0bffe17 	ldw	r2,-8(fp)
81108158:	10bfffcc 	andi	r2,r2,65535
8110815c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81108160:	e0bfff17 	ldw	r2,-4(fp)
81108164:	10800017 	ldw	r2,0(r2)
81108168:	e1bffe17 	ldw	r6,-8(fp)
8110816c:	01402f04 	movi	r5,188
81108170:	1009883a 	mov	r4,r2
81108174:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108178:	e0bfff17 	ldw	r2,-4(fp)
8110817c:	10800017 	ldw	r2,0(r2)
81108180:	01402f44 	movi	r5,189
81108184:	1009883a 	mov	r4,r2
81108188:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110818c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81108190:	e0bffe17 	ldw	r2,-8(fp)
81108194:	10bfffec 	andhi	r2,r2,65535
81108198:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
8110819c:	e0bfff17 	ldw	r2,-4(fp)
811081a0:	1080430b 	ldhu	r2,268(r2)
811081a4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811081a8:	e0fffe17 	ldw	r3,-8(fp)
811081ac:	1884b03a 	or	r2,r3,r2
811081b0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811081b4:	e0bffe17 	ldw	r2,-8(fp)
811081b8:	10bfffcc 	andi	r2,r2,65535
811081bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
811081c0:	e0bfff17 	ldw	r2,-4(fp)
811081c4:	10800017 	ldw	r2,0(r2)
811081c8:	e1bffe17 	ldw	r6,-8(fp)
811081cc:	01402f44 	movi	r5,189
811081d0:	1009883a 	mov	r4,r2
811081d4:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081d8:	e0bfff17 	ldw	r2,-4(fp)
811081dc:	10800017 	ldw	r2,0(r2)
811081e0:	01402f84 	movi	r5,190
811081e4:	1009883a 	mov	r4,r2
811081e8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811081ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
811081f0:	e0bffe17 	ldw	r2,-8(fp)
811081f4:	10bfffec 	andhi	r2,r2,65535
811081f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
811081fc:	e0bfff17 	ldw	r2,-4(fp)
81108200:	1080440b 	ldhu	r2,272(r2)
81108204:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81108208:	e0fffe17 	ldw	r3,-8(fp)
8110820c:	1884b03a 	or	r2,r3,r2
81108210:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81108214:	e0bffe17 	ldw	r2,-8(fp)
81108218:	10bfffcc 	andi	r2,r2,65535
8110821c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81108220:	e0bfff17 	ldw	r2,-4(fp)
81108224:	10800017 	ldw	r2,0(r2)
81108228:	e1bffe17 	ldw	r6,-8(fp)
8110822c:	01402f84 	movi	r5,190
81108230:	1009883a 	mov	r4,r2
81108234:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108238:	e0bfff17 	ldw	r2,-4(fp)
8110823c:	10800017 	ldw	r2,0(r2)
81108240:	01402fc4 	movi	r5,191
81108244:	1009883a 	mov	r4,r2
81108248:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110824c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81108250:	e0bffe17 	ldw	r2,-8(fp)
81108254:	10bfffec 	andhi	r2,r2,65535
81108258:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
8110825c:	e0bfff17 	ldw	r2,-4(fp)
81108260:	1080450b 	ldhu	r2,276(r2)
81108264:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81108268:	e0fffe17 	ldw	r3,-8(fp)
8110826c:	1884b03a 	or	r2,r3,r2
81108270:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81108274:	e0bffe17 	ldw	r2,-8(fp)
81108278:	10bfffcc 	andi	r2,r2,65535
8110827c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81108280:	e0bfff17 	ldw	r2,-4(fp)
81108284:	10800017 	ldw	r2,0(r2)
81108288:	e1bffe17 	ldw	r6,-8(fp)
8110828c:	01402fc4 	movi	r5,191
81108290:	1009883a 	mov	r4,r2
81108294:	1108c280 	call	81108c28 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108298:	00800044 	movi	r2,1
8110829c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811082a0:	e0bffd17 	ldw	r2,-12(fp)
}
811082a4:	e037883a 	mov	sp,fp
811082a8:	dfc00117 	ldw	ra,4(sp)
811082ac:	df000017 	ldw	fp,0(sp)
811082b0:	dec00204 	addi	sp,sp,8
811082b4:	f800283a 	ret

811082b8 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811082b8:	defffb04 	addi	sp,sp,-20
811082bc:	de00012e 	bgeu	sp,et,811082c4 <bRmapGetRmapMemHKArea+0xc>
811082c0:	003b68fa 	trap	3
811082c4:	dfc00415 	stw	ra,16(sp)
811082c8:	df000315 	stw	fp,12(sp)
811082cc:	df000304 	addi	fp,sp,12
811082d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811082d4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811082d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811082dc:	e0bfff17 	ldw	r2,-4(fp)
811082e0:	1001e226 	beq	r2,zero,81108a6c <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082e4:	e0bfff17 	ldw	r2,-4(fp)
811082e8:	10800017 	ldw	r2,0(r2)
811082ec:	01402804 	movi	r5,160
811082f0:	1009883a 	mov	r4,r2
811082f4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811082f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
811082fc:	e0bffe17 	ldw	r2,-8(fp)
81108300:	1007883a 	mov	r3,r2
81108304:	e0bfff17 	ldw	r2,-4(fp)
81108308:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
8110830c:	e0bffe17 	ldw	r2,-8(fp)
81108310:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81108314:	1007883a 	mov	r3,r2
81108318:	e0bfff17 	ldw	r2,-4(fp)
8110831c:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108320:	e0bfff17 	ldw	r2,-4(fp)
81108324:	10800017 	ldw	r2,0(r2)
81108328:	01402844 	movi	r5,161
8110832c:	1009883a 	mov	r4,r2
81108330:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108334:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81108338:	e0bffe17 	ldw	r2,-8(fp)
8110833c:	1007883a 	mov	r3,r2
81108340:	e0bfff17 	ldw	r2,-4(fp)
81108344:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81108348:	e0bffe17 	ldw	r2,-8(fp)
8110834c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81108350:	1007883a 	mov	r3,r2
81108354:	e0bfff17 	ldw	r2,-4(fp)
81108358:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	10800017 	ldw	r2,0(r2)
81108364:	01402884 	movi	r5,162
81108368:	1009883a 	mov	r4,r2
8110836c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108370:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
81108374:	e0bffe17 	ldw	r2,-8(fp)
81108378:	1007883a 	mov	r3,r2
8110837c:	e0bfff17 	ldw	r2,-4(fp)
81108380:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
81108384:	e0bffe17 	ldw	r2,-8(fp)
81108388:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
8110838c:	1007883a 	mov	r3,r2
81108390:	e0bfff17 	ldw	r2,-4(fp)
81108394:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	10800017 	ldw	r2,0(r2)
811083a0:	014028c4 	movi	r5,163
811083a4:	1009883a 	mov	r4,r2
811083a8:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811083ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
811083b0:	e0bffe17 	ldw	r2,-8(fp)
811083b4:	1007883a 	mov	r3,r2
811083b8:	e0bfff17 	ldw	r2,-4(fp)
811083bc:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
811083c0:	e0bffe17 	ldw	r2,-8(fp)
811083c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
811083c8:	1007883a 	mov	r3,r2
811083cc:	e0bfff17 	ldw	r2,-4(fp)
811083d0:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083d4:	e0bfff17 	ldw	r2,-4(fp)
811083d8:	10800017 	ldw	r2,0(r2)
811083dc:	01402904 	movi	r5,164
811083e0:	1009883a 	mov	r4,r2
811083e4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811083e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
811083ec:	e0bffe17 	ldw	r2,-8(fp)
811083f0:	1007883a 	mov	r3,r2
811083f4:	e0bfff17 	ldw	r2,-4(fp)
811083f8:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
811083fc:	e0bffe17 	ldw	r2,-8(fp)
81108400:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81108404:	1007883a 	mov	r3,r2
81108408:	e0bfff17 	ldw	r2,-4(fp)
8110840c:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108410:	e0bfff17 	ldw	r2,-4(fp)
81108414:	10800017 	ldw	r2,0(r2)
81108418:	01402944 	movi	r5,165
8110841c:	1009883a 	mov	r4,r2
81108420:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108424:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81108428:	e0bffe17 	ldw	r2,-8(fp)
8110842c:	1007883a 	mov	r3,r2
81108430:	e0bfff17 	ldw	r2,-4(fp)
81108434:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81108438:	e0bffe17 	ldw	r2,-8(fp)
8110843c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81108440:	1007883a 	mov	r3,r2
81108444:	e0bfff17 	ldw	r2,-4(fp)
81108448:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110844c:	e0bfff17 	ldw	r2,-4(fp)
81108450:	10800017 	ldw	r2,0(r2)
81108454:	01402984 	movi	r5,166
81108458:	1009883a 	mov	r4,r2
8110845c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108460:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
81108464:	e0bffe17 	ldw	r2,-8(fp)
81108468:	1007883a 	mov	r3,r2
8110846c:	e0bfff17 	ldw	r2,-4(fp)
81108470:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
81108474:	e0bffe17 	ldw	r2,-8(fp)
81108478:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
8110847c:	1007883a 	mov	r3,r2
81108480:	e0bfff17 	ldw	r2,-4(fp)
81108484:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108488:	e0bfff17 	ldw	r2,-4(fp)
8110848c:	10800017 	ldw	r2,0(r2)
81108490:	014029c4 	movi	r5,167
81108494:	1009883a 	mov	r4,r2
81108498:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110849c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
811084a0:	e0bffe17 	ldw	r2,-8(fp)
811084a4:	1007883a 	mov	r3,r2
811084a8:	e0bfff17 	ldw	r2,-4(fp)
811084ac:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
811084b0:	e0bffe17 	ldw	r2,-8(fp)
811084b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
811084b8:	1007883a 	mov	r3,r2
811084bc:	e0bfff17 	ldw	r2,-4(fp)
811084c0:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084c4:	e0bfff17 	ldw	r2,-4(fp)
811084c8:	10800017 	ldw	r2,0(r2)
811084cc:	01402a04 	movi	r5,168
811084d0:	1009883a 	mov	r4,r2
811084d4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811084d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
811084dc:	e0bffe17 	ldw	r2,-8(fp)
811084e0:	1007883a 	mov	r3,r2
811084e4:	e0bfff17 	ldw	r2,-4(fp)
811084e8:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
811084ec:	e0bffe17 	ldw	r2,-8(fp)
811084f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
811084f4:	1007883a 	mov	r3,r2
811084f8:	e0bfff17 	ldw	r2,-4(fp)
811084fc:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108500:	e0bfff17 	ldw	r2,-4(fp)
81108504:	10800017 	ldw	r2,0(r2)
81108508:	01402a44 	movi	r5,169
8110850c:	1009883a 	mov	r4,r2
81108510:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108514:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81108518:	e0bffe17 	ldw	r2,-8(fp)
8110851c:	1007883a 	mov	r3,r2
81108520:	e0bfff17 	ldw	r2,-4(fp)
81108524:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81108528:	e0bffe17 	ldw	r2,-8(fp)
8110852c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81108530:	1007883a 	mov	r3,r2
81108534:	e0bfff17 	ldw	r2,-4(fp)
81108538:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110853c:	e0bfff17 	ldw	r2,-4(fp)
81108540:	10800017 	ldw	r2,0(r2)
81108544:	01402a84 	movi	r5,170
81108548:	1009883a 	mov	r4,r2
8110854c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108550:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81108554:	e0bffe17 	ldw	r2,-8(fp)
81108558:	1007883a 	mov	r3,r2
8110855c:	e0bfff17 	ldw	r2,-4(fp)
81108560:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
81108564:	e0bffe17 	ldw	r2,-8(fp)
81108568:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
8110856c:	1007883a 	mov	r3,r2
81108570:	e0bfff17 	ldw	r2,-4(fp)
81108574:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108578:	e0bfff17 	ldw	r2,-4(fp)
8110857c:	10800017 	ldw	r2,0(r2)
81108580:	01402ac4 	movi	r5,171
81108584:	1009883a 	mov	r4,r2
81108588:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110858c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81108590:	e0bffe17 	ldw	r2,-8(fp)
81108594:	1007883a 	mov	r3,r2
81108598:	e0bfff17 	ldw	r2,-4(fp)
8110859c:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
811085a0:	e0bffe17 	ldw	r2,-8(fp)
811085a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
811085a8:	1007883a 	mov	r3,r2
811085ac:	e0bfff17 	ldw	r2,-4(fp)
811085b0:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085b4:	e0bfff17 	ldw	r2,-4(fp)
811085b8:	10800017 	ldw	r2,0(r2)
811085bc:	01402b04 	movi	r5,172
811085c0:	1009883a 	mov	r4,r2
811085c4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811085c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
811085cc:	e0bffe17 	ldw	r2,-8(fp)
811085d0:	1007883a 	mov	r3,r2
811085d4:	e0bfff17 	ldw	r2,-4(fp)
811085d8:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
811085dc:	e0bffe17 	ldw	r2,-8(fp)
811085e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
811085e4:	1007883a 	mov	r3,r2
811085e8:	e0bfff17 	ldw	r2,-4(fp)
811085ec:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	10800017 	ldw	r2,0(r2)
811085f8:	01402b44 	movi	r5,173
811085fc:	1009883a 	mov	r4,r2
81108600:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81108608:	e0bffe17 	ldw	r2,-8(fp)
8110860c:	1007883a 	mov	r3,r2
81108610:	e0bfff17 	ldw	r2,-4(fp)
81108614:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81108618:	e0bffe17 	ldw	r2,-8(fp)
8110861c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81108620:	1007883a 	mov	r3,r2
81108624:	e0bfff17 	ldw	r2,-4(fp)
81108628:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110862c:	e0bfff17 	ldw	r2,-4(fp)
81108630:	10800017 	ldw	r2,0(r2)
81108634:	01402b84 	movi	r5,174
81108638:	1009883a 	mov	r4,r2
8110863c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108640:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81108644:	e0bffe17 	ldw	r2,-8(fp)
81108648:	1007883a 	mov	r3,r2
8110864c:	e0bfff17 	ldw	r2,-4(fp)
81108650:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
81108654:	e0bffe17 	ldw	r2,-8(fp)
81108658:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
8110865c:	1007883a 	mov	r3,r2
81108660:	e0bfff17 	ldw	r2,-4(fp)
81108664:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108668:	e0bfff17 	ldw	r2,-4(fp)
8110866c:	10800017 	ldw	r2,0(r2)
81108670:	01402bc4 	movi	r5,175
81108674:	1009883a 	mov	r4,r2
81108678:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110867c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81108680:	e0bffe17 	ldw	r2,-8(fp)
81108684:	1007883a 	mov	r3,r2
81108688:	e0bfff17 	ldw	r2,-4(fp)
8110868c:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81108690:	e0bffe17 	ldw	r2,-8(fp)
81108694:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81108698:	1007883a 	mov	r3,r2
8110869c:	e0bfff17 	ldw	r2,-4(fp)
811086a0:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086a4:	e0bfff17 	ldw	r2,-4(fp)
811086a8:	10800017 	ldw	r2,0(r2)
811086ac:	01402c04 	movi	r5,176
811086b0:	1009883a 	mov	r4,r2
811086b4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811086b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
811086bc:	e0bffe17 	ldw	r2,-8(fp)
811086c0:	1007883a 	mov	r3,r2
811086c4:	e0bfff17 	ldw	r2,-4(fp)
811086c8:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
811086cc:	e0bffe17 	ldw	r2,-8(fp)
811086d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
811086d4:	1007883a 	mov	r3,r2
811086d8:	e0bfff17 	ldw	r2,-4(fp)
811086dc:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086e0:	e0bfff17 	ldw	r2,-4(fp)
811086e4:	10800017 	ldw	r2,0(r2)
811086e8:	01402c44 	movi	r5,177
811086ec:	1009883a 	mov	r4,r2
811086f0:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811086f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
811086f8:	e0bffe17 	ldw	r2,-8(fp)
811086fc:	1007883a 	mov	r3,r2
81108700:	e0bfff17 	ldw	r2,-4(fp)
81108704:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81108708:	e0bffe17 	ldw	r2,-8(fp)
8110870c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
81108710:	1007883a 	mov	r3,r2
81108714:	e0bfff17 	ldw	r2,-4(fp)
81108718:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110871c:	e0bfff17 	ldw	r2,-4(fp)
81108720:	10800017 	ldw	r2,0(r2)
81108724:	01402c84 	movi	r5,178
81108728:	1009883a 	mov	r4,r2
8110872c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108730:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81108734:	e0bffe17 	ldw	r2,-8(fp)
81108738:	1007883a 	mov	r3,r2
8110873c:	e0bfff17 	ldw	r2,-4(fp)
81108740:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
81108744:	e0bffe17 	ldw	r2,-8(fp)
81108748:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
8110874c:	1007883a 	mov	r3,r2
81108750:	e0bfff17 	ldw	r2,-4(fp)
81108754:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108758:	e0bfff17 	ldw	r2,-4(fp)
8110875c:	10800017 	ldw	r2,0(r2)
81108760:	01402cc4 	movi	r5,179
81108764:	1009883a 	mov	r4,r2
81108768:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110876c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81108770:	e0bffe17 	ldw	r2,-8(fp)
81108774:	1007883a 	mov	r3,r2
81108778:	e0bfff17 	ldw	r2,-4(fp)
8110877c:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81108780:	e0bffe17 	ldw	r2,-8(fp)
81108784:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81108788:	1007883a 	mov	r3,r2
8110878c:	e0bfff17 	ldw	r2,-4(fp)
81108790:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	10800017 	ldw	r2,0(r2)
8110879c:	01402d04 	movi	r5,180
811087a0:	1009883a 	mov	r4,r2
811087a4:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811087a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
811087ac:	e0bffe17 	ldw	r2,-8(fp)
811087b0:	1007883a 	mov	r3,r2
811087b4:	e0bfff17 	ldw	r2,-4(fp)
811087b8:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
811087bc:	e0bffe17 	ldw	r2,-8(fp)
811087c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
811087c4:	1007883a 	mov	r3,r2
811087c8:	e0bfff17 	ldw	r2,-4(fp)
811087cc:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087d0:	e0bfff17 	ldw	r2,-4(fp)
811087d4:	10800017 	ldw	r2,0(r2)
811087d8:	01402d44 	movi	r5,181
811087dc:	1009883a 	mov	r4,r2
811087e0:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811087e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
811087e8:	e0bffe17 	ldw	r2,-8(fp)
811087ec:	1007883a 	mov	r3,r2
811087f0:	e0bfff17 	ldw	r2,-4(fp)
811087f4:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
811087f8:	e0bffe17 	ldw	r2,-8(fp)
811087fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81108800:	1007883a 	mov	r3,r2
81108804:	e0bfff17 	ldw	r2,-4(fp)
81108808:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110880c:	e0bfff17 	ldw	r2,-4(fp)
81108810:	10800017 	ldw	r2,0(r2)
81108814:	01402d84 	movi	r5,182
81108818:	1009883a 	mov	r4,r2
8110881c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108820:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81108824:	e0bffe17 	ldw	r2,-8(fp)
81108828:	1007883a 	mov	r3,r2
8110882c:	e0bfff17 	ldw	r2,-4(fp)
81108830:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81108834:	e0bffe17 	ldw	r2,-8(fp)
81108838:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
8110883c:	1007883a 	mov	r3,r2
81108840:	e0bfff17 	ldw	r2,-4(fp)
81108844:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108848:	e0bfff17 	ldw	r2,-4(fp)
8110884c:	10800017 	ldw	r2,0(r2)
81108850:	01402dc4 	movi	r5,183
81108854:	1009883a 	mov	r4,r2
81108858:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110885c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81108860:	e0bffe17 	ldw	r2,-8(fp)
81108864:	1007883a 	mov	r3,r2
81108868:	e0bfff17 	ldw	r2,-4(fp)
8110886c:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81108870:	e0bffe17 	ldw	r2,-8(fp)
81108874:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81108878:	1007883a 	mov	r3,r2
8110887c:	e0bfff17 	ldw	r2,-4(fp)
81108880:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108884:	e0bfff17 	ldw	r2,-4(fp)
81108888:	10800017 	ldw	r2,0(r2)
8110888c:	01402e04 	movi	r5,184
81108890:	1009883a 	mov	r4,r2
81108894:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108898:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
8110889c:	e0bffe17 	ldw	r2,-8(fp)
811088a0:	1007883a 	mov	r3,r2
811088a4:	e0bfff17 	ldw	r2,-4(fp)
811088a8:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
811088ac:	e0bffe17 	ldw	r2,-8(fp)
811088b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
811088b4:	1007883a 	mov	r3,r2
811088b8:	e0bfff17 	ldw	r2,-4(fp)
811088bc:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088c0:	e0bfff17 	ldw	r2,-4(fp)
811088c4:	10800017 	ldw	r2,0(r2)
811088c8:	01402e44 	movi	r5,185
811088cc:	1009883a 	mov	r4,r2
811088d0:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811088d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
811088d8:	e0bffe17 	ldw	r2,-8(fp)
811088dc:	1007883a 	mov	r3,r2
811088e0:	e0bfff17 	ldw	r2,-4(fp)
811088e4:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
811088e8:	e0bffe17 	ldw	r2,-8(fp)
811088ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
811088f0:	1007883a 	mov	r3,r2
811088f4:	e0bfff17 	ldw	r2,-4(fp)
811088f8:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088fc:	e0bfff17 	ldw	r2,-4(fp)
81108900:	10800017 	ldw	r2,0(r2)
81108904:	01402e84 	movi	r5,186
81108908:	1009883a 	mov	r4,r2
8110890c:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108910:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81108914:	e0bffe17 	ldw	r2,-8(fp)
81108918:	1007883a 	mov	r3,r2
8110891c:	e0bfff17 	ldw	r2,-4(fp)
81108920:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81108924:	e0bffe17 	ldw	r2,-8(fp)
81108928:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
8110892c:	1007883a 	mov	r3,r2
81108930:	e0bfff17 	ldw	r2,-4(fp)
81108934:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108938:	e0bfff17 	ldw	r2,-4(fp)
8110893c:	10800017 	ldw	r2,0(r2)
81108940:	01402ec4 	movi	r5,187
81108944:	1009883a 	mov	r4,r2
81108948:	1108c7c0 	call	81108c7c <uliRmapReadReg>
8110894c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81108950:	e0bffe17 	ldw	r2,-8(fp)
81108954:	1007883a 	mov	r3,r2
81108958:	e0bfff17 	ldw	r2,-4(fp)
8110895c:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81108960:	e0bffe17 	ldw	r2,-8(fp)
81108964:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81108968:	1007883a 	mov	r3,r2
8110896c:	e0bfff17 	ldw	r2,-4(fp)
81108970:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108974:	e0bfff17 	ldw	r2,-4(fp)
81108978:	10800017 	ldw	r2,0(r2)
8110897c:	01402f04 	movi	r5,188
81108980:	1009883a 	mov	r4,r2
81108984:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108988:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
8110898c:	e0bffe17 	ldw	r2,-8(fp)
81108990:	1007883a 	mov	r3,r2
81108994:	e0bfff17 	ldw	r2,-4(fp)
81108998:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
8110899c:	e0bffe17 	ldw	r2,-8(fp)
811089a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
811089a4:	1007883a 	mov	r3,r2
811089a8:	e0bfff17 	ldw	r2,-4(fp)
811089ac:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089b0:	e0bfff17 	ldw	r2,-4(fp)
811089b4:	10800017 	ldw	r2,0(r2)
811089b8:	01402f44 	movi	r5,189
811089bc:	1009883a 	mov	r4,r2
811089c0:	1108c7c0 	call	81108c7c <uliRmapReadReg>
811089c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
811089c8:	e0bffe17 	ldw	r2,-8(fp)
811089cc:	1007883a 	mov	r3,r2
811089d0:	e0bfff17 	ldw	r2,-4(fp)
811089d4:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
811089d8:	e0bffe17 	ldw	r2,-8(fp)
811089dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
811089e0:	1007883a 	mov	r3,r2
811089e4:	e0bfff17 	ldw	r2,-4(fp)
811089e8:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089ec:	e0bfff17 	ldw	r2,-4(fp)
811089f0:	10800017 	ldw	r2,0(r2)
811089f4:	01402f84 	movi	r5,190
811089f8:	1009883a 	mov	r4,r2
811089fc:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108a00:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81108a04:	e0bffe17 	ldw	r2,-8(fp)
81108a08:	1007883a 	mov	r3,r2
81108a0c:	e0bfff17 	ldw	r2,-4(fp)
81108a10:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81108a14:	e0bffe17 	ldw	r2,-8(fp)
81108a18:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81108a1c:	1007883a 	mov	r3,r2
81108a20:	e0bfff17 	ldw	r2,-4(fp)
81108a24:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a28:	e0bfff17 	ldw	r2,-4(fp)
81108a2c:	10800017 	ldw	r2,0(r2)
81108a30:	01402fc4 	movi	r5,191
81108a34:	1009883a 	mov	r4,r2
81108a38:	1108c7c0 	call	81108c7c <uliRmapReadReg>
81108a3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81108a40:	e0bffe17 	ldw	r2,-8(fp)
81108a44:	1007883a 	mov	r3,r2
81108a48:	e0bfff17 	ldw	r2,-4(fp)
81108a4c:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81108a50:	e0bffe17 	ldw	r2,-8(fp)
81108a54:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81108a58:	1007883a 	mov	r3,r2
81108a5c:	e0bfff17 	ldw	r2,-4(fp)
81108a60:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81108a64:	00800044 	movi	r2,1
81108a68:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108a6c:	e0bffd17 	ldw	r2,-12(fp)
}
81108a70:	e037883a 	mov	sp,fp
81108a74:	dfc00117 	ldw	ra,4(sp)
81108a78:	df000017 	ldw	fp,0(sp)
81108a7c:	dec00204 	addi	sp,sp,8
81108a80:	f800283a 	ret

81108a84 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81108a84:	defffb04 	addi	sp,sp,-20
81108a88:	de00012e 	bgeu	sp,et,81108a90 <bRmapInitCh+0xc>
81108a8c:	003b68fa 	trap	3
81108a90:	dfc00415 	stw	ra,16(sp)
81108a94:	df000315 	stw	fp,12(sp)
81108a98:	df000304 	addi	fp,sp,12
81108a9c:	e13ffe15 	stw	r4,-8(fp)
81108aa0:	2805883a 	mov	r2,r5
81108aa4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81108aa8:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81108aac:	e0bffe17 	ldw	r2,-8(fp)
81108ab0:	10005726 	beq	r2,zero,81108c10 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81108ab4:	00800044 	movi	r2,1
81108ab8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81108abc:	e0bfff03 	ldbu	r2,-4(fp)
81108ac0:	10c00228 	cmpgeui	r3,r2,8
81108ac4:	1800361e 	bne	r3,zero,81108ba0 <bRmapInitCh+0x11c>
81108ac8:	100690ba 	slli	r3,r2,2
81108acc:	00a04474 	movhi	r2,33041
81108ad0:	10a2b804 	addi	r2,r2,-29984
81108ad4:	1885883a 	add	r2,r3,r2
81108ad8:	10800017 	ldw	r2,0(r2)
81108adc:	1000683a 	jmp	r2
81108ae0:	81108b00 	call	881108b0 <__reset+0x20f08b0>
81108ae4:	81108b14 	ori	r4,r16,16940
81108ae8:	81108b28 	cmpgeui	r4,r16,16940
81108aec:	81108b3c 	xorhi	r4,r16,16940
81108af0:	81108b50 	cmplti	r4,r16,16941
81108af4:	81108b64 	muli	r4,r16,16941
81108af8:	81108b78 	rdprs	r4,r16,16941
81108afc:	81108b8c 	andi	r4,r16,16942
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81108b00:	e0fffe17 	ldw	r3,-8(fp)
81108b04:	00a04834 	movhi	r2,33056
81108b08:	108b0004 	addi	r2,r2,11264
81108b0c:	18800015 	stw	r2,0(r3)
			break;
81108b10:	00002506 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81108b14:	e0fffe17 	ldw	r3,-8(fp)
81108b18:	00a04834 	movhi	r2,33056
81108b1c:	108a0004 	addi	r2,r2,10240
81108b20:	18800015 	stw	r2,0(r3)
			break;
81108b24:	00002006 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81108b28:	e0fffe17 	ldw	r3,-8(fp)
81108b2c:	00a04834 	movhi	r2,33056
81108b30:	10890004 	addi	r2,r2,9216
81108b34:	18800015 	stw	r2,0(r3)
			break;
81108b38:	00001b06 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81108b3c:	e0fffe17 	ldw	r3,-8(fp)
81108b40:	00a04834 	movhi	r2,33056
81108b44:	10880004 	addi	r2,r2,8192
81108b48:	18800015 	stw	r2,0(r3)
			break;
81108b4c:	00001606 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81108b50:	e0fffe17 	ldw	r3,-8(fp)
81108b54:	00a04834 	movhi	r2,33056
81108b58:	10870004 	addi	r2,r2,7168
81108b5c:	18800015 	stw	r2,0(r3)
			break;
81108b60:	00001106 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81108b64:	e0fffe17 	ldw	r3,-8(fp)
81108b68:	00a04834 	movhi	r2,33056
81108b6c:	10860004 	addi	r2,r2,6144
81108b70:	18800015 	stw	r2,0(r3)
			break;
81108b74:	00000c06 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81108b78:	e0fffe17 	ldw	r3,-8(fp)
81108b7c:	00a04834 	movhi	r2,33056
81108b80:	10850004 	addi	r2,r2,5120
81108b84:	18800015 	stw	r2,0(r3)
			break;
81108b88:	00000706 	br	81108ba8 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81108b8c:	e0fffe17 	ldw	r3,-8(fp)
81108b90:	00a04834 	movhi	r2,33056
81108b94:	10840004 	addi	r2,r2,4096
81108b98:	18800015 	stw	r2,0(r3)
			break;
81108b9c:	00000206 	br	81108ba8 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81108ba0:	e03ffd15 	stw	zero,-12(fp)
			break;
81108ba4:	0001883a 	nop
		}

		if (bStatus) {
81108ba8:	e0bffd17 	ldw	r2,-12(fp)
81108bac:	10001826 	beq	r2,zero,81108c10 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81108bb0:	e13ffe17 	ldw	r4,-8(fp)
81108bb4:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
81108bb8:	1000011e 	bne	r2,zero,81108bc0 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81108bbc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81108bc0:	e13ffe17 	ldw	r4,-8(fp)
81108bc4:	1106ccc0 	call	81106ccc <bRmapGetCodecConfig>
81108bc8:	1000011e 	bne	r2,zero,81108bd0 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81108bcc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81108bd0:	e13ffe17 	ldw	r4,-8(fp)
81108bd4:	1106d580 	call	81106d58 <bRmapGetCodecStatus>
81108bd8:	1000011e 	bne	r2,zero,81108be0 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81108bdc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81108be0:	e13ffe17 	ldw	r4,-8(fp)
81108be4:	11073040 	call	81107304 <bRmapGetMemConfigArea>
81108be8:	1000011e 	bne	r2,zero,81108bf0 <bRmapInitCh+0x16c>
				bStatus = FALSE;
81108bec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81108bf0:	e13ffe17 	ldw	r4,-8(fp)
81108bf4:	11075d80 	call	811075d8 <bRmapGetMemConfigStat>
81108bf8:	1000011e 	bne	r2,zero,81108c00 <bRmapInitCh+0x17c>
				bStatus = FALSE;
81108bfc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81108c00:	e13ffe17 	ldw	r4,-8(fp)
81108c04:	11082b80 	call	811082b8 <bRmapGetRmapMemHKArea>
81108c08:	1000011e 	bne	r2,zero,81108c10 <bRmapInitCh+0x18c>
				bStatus = FALSE;
81108c0c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108c10:	e0bffd17 	ldw	r2,-12(fp)
}
81108c14:	e037883a 	mov	sp,fp
81108c18:	dfc00117 	ldw	ra,4(sp)
81108c1c:	df000017 	ldw	fp,0(sp)
81108c20:	dec00204 	addi	sp,sp,8
81108c24:	f800283a 	ret

81108c28 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108c28:	defffc04 	addi	sp,sp,-16
81108c2c:	de00012e 	bgeu	sp,et,81108c34 <vRmapWriteReg+0xc>
81108c30:	003b68fa 	trap	3
81108c34:	df000315 	stw	fp,12(sp)
81108c38:	df000304 	addi	fp,sp,12
81108c3c:	e13ffd15 	stw	r4,-12(fp)
81108c40:	e17ffe15 	stw	r5,-8(fp)
81108c44:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108c48:	e0bffe17 	ldw	r2,-8(fp)
81108c4c:	1085883a 	add	r2,r2,r2
81108c50:	1085883a 	add	r2,r2,r2
81108c54:	1007883a 	mov	r3,r2
81108c58:	e0bffd17 	ldw	r2,-12(fp)
81108c5c:	10c5883a 	add	r2,r2,r3
81108c60:	e0ffff17 	ldw	r3,-4(fp)
81108c64:	10c00015 	stw	r3,0(r2)
}
81108c68:	0001883a 	nop
81108c6c:	e037883a 	mov	sp,fp
81108c70:	df000017 	ldw	fp,0(sp)
81108c74:	dec00104 	addi	sp,sp,4
81108c78:	f800283a 	ret

81108c7c <uliRmapReadReg>:

static alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81108c7c:	defffc04 	addi	sp,sp,-16
81108c80:	de00012e 	bgeu	sp,et,81108c88 <uliRmapReadReg+0xc>
81108c84:	003b68fa 	trap	3
81108c88:	df000315 	stw	fp,12(sp)
81108c8c:	df000304 	addi	fp,sp,12
81108c90:	e13ffe15 	stw	r4,-8(fp)
81108c94:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81108c98:	e0bfff17 	ldw	r2,-4(fp)
81108c9c:	1085883a 	add	r2,r2,r2
81108ca0:	1085883a 	add	r2,r2,r2
81108ca4:	1007883a 	mov	r3,r2
81108ca8:	e0bffe17 	ldw	r2,-8(fp)
81108cac:	10c5883a 	add	r2,r2,r3
81108cb0:	10800017 	ldw	r2,0(r2)
81108cb4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81108cb8:	e0bffd17 	ldw	r2,-12(fp)
}
81108cbc:	e037883a 	mov	sp,fp
81108cc0:	df000017 	ldw	fp,0(sp)
81108cc4:	dec00104 	addi	sp,sp,4
81108cc8:	f800283a 	ret

81108ccc <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81108ccc:	defffd04 	addi	sp,sp,-12
81108cd0:	de00012e 	bgeu	sp,et,81108cd8 <uliConvRmapCfgAddr+0xc>
81108cd4:	003b68fa 	trap	3
81108cd8:	df000215 	stw	fp,8(sp)
81108cdc:	df000204 	addi	fp,sp,8
81108ce0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81108ce4:	e0bfff17 	ldw	r2,-4(fp)
81108ce8:	10801368 	cmpgeui	r2,r2,77
81108cec:	10008a1e 	bne	r2,zero,81108f18 <uliConvRmapCfgAddr+0x24c>
81108cf0:	e0bfff17 	ldw	r2,-4(fp)
81108cf4:	100690ba 	slli	r3,r2,2
81108cf8:	00a04474 	movhi	r2,33041
81108cfc:	10a34304 	addi	r2,r2,-29428
81108d00:	1885883a 	add	r2,r3,r2
81108d04:	10800017 	ldw	r2,0(r2)
81108d08:	1000683a 	jmp	r2
81108d0c:	81108e40 	call	881108e4 <__reset+0x20f08e4>
81108d10:	81108f18 	cmpnei	r4,r16,16956
81108d14:	81108f18 	cmpnei	r4,r16,16956
81108d18:	81108f18 	cmpnei	r4,r16,16956
81108d1c:	81108e4c 	andi	r4,r16,16953
81108d20:	81108f18 	cmpnei	r4,r16,16956
81108d24:	81108f18 	cmpnei	r4,r16,16956
81108d28:	81108f18 	cmpnei	r4,r16,16956
81108d2c:	81108e58 	cmpnei	r4,r16,16953
81108d30:	81108f18 	cmpnei	r4,r16,16956
81108d34:	81108f18 	cmpnei	r4,r16,16956
81108d38:	81108f18 	cmpnei	r4,r16,16956
81108d3c:	81108e64 	muli	r4,r16,16953
81108d40:	81108f18 	cmpnei	r4,r16,16956
81108d44:	81108f18 	cmpnei	r4,r16,16956
81108d48:	81108f18 	cmpnei	r4,r16,16956
81108d4c:	81108e70 	cmpltui	r4,r16,16953
81108d50:	81108f18 	cmpnei	r4,r16,16956
81108d54:	81108f18 	cmpnei	r4,r16,16956
81108d58:	81108f18 	cmpnei	r4,r16,16956
81108d5c:	81108e7c 	xorhi	r4,r16,16953
81108d60:	81108f18 	cmpnei	r4,r16,16956
81108d64:	81108f18 	cmpnei	r4,r16,16956
81108d68:	81108f18 	cmpnei	r4,r16,16956
81108d6c:	81108e88 	cmpgei	r4,r16,16954
81108d70:	81108f18 	cmpnei	r4,r16,16956
81108d74:	81108f18 	cmpnei	r4,r16,16956
81108d78:	81108f18 	cmpnei	r4,r16,16956
81108d7c:	81108e94 	ori	r4,r16,16954
81108d80:	81108f18 	cmpnei	r4,r16,16956
81108d84:	81108f18 	cmpnei	r4,r16,16956
81108d88:	81108f18 	cmpnei	r4,r16,16956
81108d8c:	81108ea0 	cmpeqi	r4,r16,16954
81108d90:	81108f18 	cmpnei	r4,r16,16956
81108d94:	81108f18 	cmpnei	r4,r16,16956
81108d98:	81108f18 	cmpnei	r4,r16,16956
81108d9c:	81108eac 	andhi	r4,r16,16954
81108da0:	81108f18 	cmpnei	r4,r16,16956
81108da4:	81108f18 	cmpnei	r4,r16,16956
81108da8:	81108f18 	cmpnei	r4,r16,16956
81108dac:	81108eb8 	rdprs	r4,r16,16954
81108db0:	81108f18 	cmpnei	r4,r16,16956
81108db4:	81108f18 	cmpnei	r4,r16,16956
81108db8:	81108f18 	cmpnei	r4,r16,16956
81108dbc:	81108ec4 	addi	r4,r16,16955
81108dc0:	81108f18 	cmpnei	r4,r16,16956
81108dc4:	81108f18 	cmpnei	r4,r16,16956
81108dc8:	81108f18 	cmpnei	r4,r16,16956
81108dcc:	81108f18 	cmpnei	r4,r16,16956
81108dd0:	81108f18 	cmpnei	r4,r16,16956
81108dd4:	81108f18 	cmpnei	r4,r16,16956
81108dd8:	81108f18 	cmpnei	r4,r16,16956
81108ddc:	81108f18 	cmpnei	r4,r16,16956
81108de0:	81108f18 	cmpnei	r4,r16,16956
81108de4:	81108f18 	cmpnei	r4,r16,16956
81108de8:	81108f18 	cmpnei	r4,r16,16956
81108dec:	81108ed0 	cmplti	r4,r16,16955
81108df0:	81108f18 	cmpnei	r4,r16,16956
81108df4:	81108f18 	cmpnei	r4,r16,16956
81108df8:	81108f18 	cmpnei	r4,r16,16956
81108dfc:	81108edc 	xori	r4,r16,16955
81108e00:	81108f18 	cmpnei	r4,r16,16956
81108e04:	81108f18 	cmpnei	r4,r16,16956
81108e08:	81108f18 	cmpnei	r4,r16,16956
81108e0c:	81108ee8 	cmpgeui	r4,r16,16955
81108e10:	81108f18 	cmpnei	r4,r16,16956
81108e14:	81108f18 	cmpnei	r4,r16,16956
81108e18:	81108f18 	cmpnei	r4,r16,16956
81108e1c:	81108ef4 	orhi	r4,r16,16955
81108e20:	81108f18 	cmpnei	r4,r16,16956
81108e24:	81108f18 	cmpnei	r4,r16,16956
81108e28:	81108f18 	cmpnei	r4,r16,16956
81108e2c:	81108f00 	call	881108f0 <__reset+0x20f08f0>
81108e30:	81108f18 	cmpnei	r4,r16,16956
81108e34:	81108f18 	cmpnei	r4,r16,16956
81108e38:	81108f18 	cmpnei	r4,r16,16956
81108e3c:	81108f0c 	andi	r4,r16,16956
	case 0x00000000:
		uliValue = 0x00000040;
81108e40:	00801004 	movi	r2,64
81108e44:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e48:	00003506 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81108e4c:	00801044 	movi	r2,65
81108e50:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e54:	00003206 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81108e58:	00801084 	movi	r2,66
81108e5c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e60:	00002f06 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81108e64:	008010c4 	movi	r2,67
81108e68:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e6c:	00002c06 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
81108e70:	00801104 	movi	r2,68
81108e74:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e78:	00002906 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
81108e7c:	00801144 	movi	r2,69
81108e80:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e84:	00002606 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
81108e88:	00801184 	movi	r2,70
81108e8c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e90:	00002306 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
81108e94:	008011c4 	movi	r2,71
81108e98:	e0bffe15 	stw	r2,-8(fp)
		break;
81108e9c:	00002006 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
81108ea0:	00801204 	movi	r2,72
81108ea4:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ea8:	00001d06 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81108eac:	00801244 	movi	r2,73
81108eb0:	e0bffe15 	stw	r2,-8(fp)
		break;
81108eb4:	00001a06 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
81108eb8:	00801284 	movi	r2,74
81108ebc:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ec0:	00001706 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
81108ec4:	008012c4 	movi	r2,75
81108ec8:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ecc:	00001406 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
81108ed0:	00801304 	movi	r2,76
81108ed4:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ed8:	00001106 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
81108edc:	00801344 	movi	r2,77
81108ee0:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ee4:	00000e06 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
81108ee8:	00801384 	movi	r2,78
81108eec:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ef0:	00000b06 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
81108ef4:	008013c4 	movi	r2,79
81108ef8:	e0bffe15 	stw	r2,-8(fp)
		break;
81108efc:	00000806 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
81108f00:	00801404 	movi	r2,80
81108f04:	e0bffe15 	stw	r2,-8(fp)
		break;
81108f08:	00000506 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
81108f0c:	00801444 	movi	r2,81
81108f10:	e0bffe15 	stw	r2,-8(fp)
		break;
81108f14:	00000206 	br	81108f20 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81108f18:	e03ffe15 	stw	zero,-8(fp)
		break;
81108f1c:	0001883a 	nop
	}

	return uliValue;
81108f20:	e0bffe17 	ldw	r2,-8(fp)
}
81108f24:	e037883a 	mov	sp,fp
81108f28:	df000017 	ldw	fp,0(sp)
81108f2c:	dec00104 	addi	sp,sp,4
81108f30:	f800283a 	ret

81108f34 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81108f34:	defffb04 	addi	sp,sp,-20
81108f38:	de00012e 	bgeu	sp,et,81108f40 <bSpwcSetLink+0xc>
81108f3c:	003b68fa 	trap	3
81108f40:	dfc00415 	stw	ra,16(sp)
81108f44:	df000315 	stw	fp,12(sp)
81108f48:	df000304 	addi	fp,sp,12
81108f4c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108f50:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108f54:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108f58:	e0bfff17 	ldw	r2,-4(fp)
81108f5c:	10003c26 	beq	r2,zero,81109050 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108f60:	e0bfff17 	ldw	r2,-4(fp)
81108f64:	10800017 	ldw	r2,0(r2)
81108f68:	000b883a 	mov	r5,zero
81108f6c:	1009883a 	mov	r4,r2
81108f70:	11096000 	call	81109600 <uliSpwcReadReg>
81108f74:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81108f78:	e0bfff17 	ldw	r2,-4(fp)
81108f7c:	10800117 	ldw	r2,4(r2)
81108f80:	10000426 	beq	r2,zero,81108f94 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
81108f84:	e0bffe17 	ldw	r2,-8(fp)
81108f88:	10800114 	ori	r2,r2,4
81108f8c:	e0bffe15 	stw	r2,-8(fp)
81108f90:	00000406 	br	81108fa4 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
81108f94:	e0fffe17 	ldw	r3,-8(fp)
81108f98:	00bffec4 	movi	r2,-5
81108f9c:	1884703a 	and	r2,r3,r2
81108fa0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
81108fa4:	e0bfff17 	ldw	r2,-4(fp)
81108fa8:	10800217 	ldw	r2,8(r2)
81108fac:	10000426 	beq	r2,zero,81108fc0 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
81108fb0:	e0bffe17 	ldw	r2,-8(fp)
81108fb4:	10800094 	ori	r2,r2,2
81108fb8:	e0bffe15 	stw	r2,-8(fp)
81108fbc:	00000406 	br	81108fd0 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
81108fc0:	e0fffe17 	ldw	r3,-8(fp)
81108fc4:	00bfff44 	movi	r2,-3
81108fc8:	1884703a 	and	r2,r3,r2
81108fcc:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81108fd0:	e0bfff17 	ldw	r2,-4(fp)
81108fd4:	10800317 	ldw	r2,12(r2)
81108fd8:	10000426 	beq	r2,zero,81108fec <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
81108fdc:	e0bffe17 	ldw	r2,-8(fp)
81108fe0:	10800054 	ori	r2,r2,1
81108fe4:	e0bffe15 	stw	r2,-8(fp)
81108fe8:	00000406 	br	81108ffc <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
81108fec:	e0fffe17 	ldw	r3,-8(fp)
81108ff0:	00bfff84 	movi	r2,-2
81108ff4:	1884703a 	and	r2,r3,r2
81108ff8:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
81108ffc:	e0fffe17 	ldw	r3,-8(fp)
81109000:	00804034 	movhi	r2,256
81109004:	10bfffc4 	addi	r2,r2,-1
81109008:	1884703a 	and	r2,r3,r2
8110900c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
81109010:	e0bfff17 	ldw	r2,-4(fp)
81109014:	10800403 	ldbu	r2,16(r2)
81109018:	10803fcc 	andi	r2,r2,255
8110901c:	1004963a 	slli	r2,r2,24
81109020:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81109024:	e0bffe17 	ldw	r2,-8(fp)
81109028:	10c4b03a 	or	r2,r2,r3
8110902c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
81109030:	e0bfff17 	ldw	r2,-4(fp)
81109034:	10800017 	ldw	r2,0(r2)
81109038:	e1bffe17 	ldw	r6,-8(fp)
8110903c:	000b883a 	mov	r5,zero
81109040:	1009883a 	mov	r4,r2
81109044:	11095ac0 	call	811095ac <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81109048:	00800044 	movi	r2,1
8110904c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109050:	e0bffd17 	ldw	r2,-12(fp)
}
81109054:	e037883a 	mov	sp,fp
81109058:	dfc00117 	ldw	ra,4(sp)
8110905c:	df000017 	ldw	fp,0(sp)
81109060:	dec00204 	addi	sp,sp,8
81109064:	f800283a 	ret

81109068 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81109068:	defffb04 	addi	sp,sp,-20
8110906c:	de00012e 	bgeu	sp,et,81109074 <bSpwcGetLink+0xc>
81109070:	003b68fa 	trap	3
81109074:	dfc00415 	stw	ra,16(sp)
81109078:	df000315 	stw	fp,12(sp)
8110907c:	df000304 	addi	fp,sp,12
81109080:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109084:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109088:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110908c:	e0bfff17 	ldw	r2,-4(fp)
81109090:	10002826 	beq	r2,zero,81109134 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109094:	e0bfff17 	ldw	r2,-4(fp)
81109098:	10800017 	ldw	r2,0(r2)
8110909c:	000b883a 	mov	r5,zero
811090a0:	1009883a 	mov	r4,r2
811090a4:	11096000 	call	81109600 <uliSpwcReadReg>
811090a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
811090ac:	e0bffe17 	ldw	r2,-8(fp)
811090b0:	1080010c 	andi	r2,r2,4
811090b4:	10000426 	beq	r2,zero,811090c8 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
811090b8:	e0bfff17 	ldw	r2,-4(fp)
811090bc:	00c00044 	movi	r3,1
811090c0:	10c00115 	stw	r3,4(r2)
811090c4:	00000206 	br	811090d0 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
811090c8:	e0bfff17 	ldw	r2,-4(fp)
811090cc:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
811090d0:	e0bffe17 	ldw	r2,-8(fp)
811090d4:	1080008c 	andi	r2,r2,2
811090d8:	10000426 	beq	r2,zero,811090ec <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
811090dc:	e0bfff17 	ldw	r2,-4(fp)
811090e0:	00c00044 	movi	r3,1
811090e4:	10c00215 	stw	r3,8(r2)
811090e8:	00000206 	br	811090f4 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
811090ec:	e0bfff17 	ldw	r2,-4(fp)
811090f0:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
811090f4:	e0bffe17 	ldw	r2,-8(fp)
811090f8:	1080004c 	andi	r2,r2,1
811090fc:	10000426 	beq	r2,zero,81109110 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81109100:	e0bfff17 	ldw	r2,-4(fp)
81109104:	00c00044 	movi	r3,1
81109108:	10c00315 	stw	r3,12(r2)
8110910c:	00000206 	br	81109118 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81109110:	e0bfff17 	ldw	r2,-4(fp)
81109114:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81109118:	e0bffe17 	ldw	r2,-8(fp)
8110911c:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
81109120:	1007883a 	mov	r3,r2
81109124:	e0bfff17 	ldw	r2,-4(fp)
81109128:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110912c:	00800044 	movi	r2,1
81109130:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109134:	e0bffd17 	ldw	r2,-12(fp)
}
81109138:	e037883a 	mov	sp,fp
8110913c:	dfc00117 	ldw	ra,4(sp)
81109140:	df000017 	ldw	fp,0(sp)
81109144:	dec00204 	addi	sp,sp,8
81109148:	f800283a 	ret

8110914c <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110914c:	defffb04 	addi	sp,sp,-20
81109150:	de00012e 	bgeu	sp,et,81109158 <bSpwcGetLinkError+0xc>
81109154:	003b68fa 	trap	3
81109158:	dfc00415 	stw	ra,16(sp)
8110915c:	df000315 	stw	fp,12(sp)
81109160:	df000304 	addi	fp,sp,12
81109164:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109168:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110916c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109170:	e0bfff17 	ldw	r2,-4(fp)
81109174:	10002c26 	beq	r2,zero,81109228 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109178:	e0bfff17 	ldw	r2,-4(fp)
8110917c:	10800017 	ldw	r2,0(r2)
81109180:	000b883a 	mov	r5,zero
81109184:	1009883a 	mov	r4,r2
81109188:	11096000 	call	81109600 <uliSpwcReadReg>
8110918c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
81109190:	e0bffe17 	ldw	r2,-8(fp)
81109194:	1080006c 	andhi	r2,r2,1
81109198:	10000426 	beq	r2,zero,811091ac <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110919c:	e0bfff17 	ldw	r2,-4(fp)
811091a0:	00c00044 	movi	r3,1
811091a4:	10c00515 	stw	r3,20(r2)
811091a8:	00000206 	br	811091b4 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
811091ac:	e0bfff17 	ldw	r2,-4(fp)
811091b0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
811091b4:	e0bffe17 	ldw	r2,-8(fp)
811091b8:	108000ac 	andhi	r2,r2,2
811091bc:	10000426 	beq	r2,zero,811091d0 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
811091c0:	e0bfff17 	ldw	r2,-4(fp)
811091c4:	00c00044 	movi	r3,1
811091c8:	10c00615 	stw	r3,24(r2)
811091cc:	00000206 	br	811091d8 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
811091d0:	e0bfff17 	ldw	r2,-4(fp)
811091d4:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
811091d8:	e0bffe17 	ldw	r2,-8(fp)
811091dc:	1080012c 	andhi	r2,r2,4
811091e0:	10000426 	beq	r2,zero,811091f4 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
811091e4:	e0bfff17 	ldw	r2,-4(fp)
811091e8:	00c00044 	movi	r3,1
811091ec:	10c00715 	stw	r3,28(r2)
811091f0:	00000206 	br	811091fc <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
811091f4:	e0bfff17 	ldw	r2,-4(fp)
811091f8:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
811091fc:	e0bffe17 	ldw	r2,-8(fp)
81109200:	1080022c 	andhi	r2,r2,8
81109204:	10000426 	beq	r2,zero,81109218 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81109208:	e0bfff17 	ldw	r2,-4(fp)
8110920c:	00c00044 	movi	r3,1
81109210:	10c00815 	stw	r3,32(r2)
81109214:	00000206 	br	81109220 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81109218:	e0bfff17 	ldw	r2,-4(fp)
8110921c:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
81109220:	00800044 	movi	r2,1
81109224:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109228:	e0bffd17 	ldw	r2,-12(fp)
}
8110922c:	e037883a 	mov	sp,fp
81109230:	dfc00117 	ldw	ra,4(sp)
81109234:	df000017 	ldw	fp,0(sp)
81109238:	dec00204 	addi	sp,sp,8
8110923c:	f800283a 	ret

81109240 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
81109240:	defffb04 	addi	sp,sp,-20
81109244:	de00012e 	bgeu	sp,et,8110924c <bSpwcGetLinkStatus+0xc>
81109248:	003b68fa 	trap	3
8110924c:	dfc00415 	stw	ra,16(sp)
81109250:	df000315 	stw	fp,12(sp)
81109254:	df000304 	addi	fp,sp,12
81109258:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110925c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109260:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109264:	e0bfff17 	ldw	r2,-4(fp)
81109268:	10002326 	beq	r2,zero,811092f8 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110926c:	e0bfff17 	ldw	r2,-4(fp)
81109270:	10800017 	ldw	r2,0(r2)
81109274:	000b883a 	mov	r5,zero
81109278:	1009883a 	mov	r4,r2
8110927c:	11096000 	call	81109600 <uliSpwcReadReg>
81109280:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
81109284:	e0bffe17 	ldw	r2,-8(fp)
81109288:	1081000c 	andi	r2,r2,1024
8110928c:	10000426 	beq	r2,zero,811092a0 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
81109290:	e0bfff17 	ldw	r2,-4(fp)
81109294:	00c00044 	movi	r3,1
81109298:	10c00915 	stw	r3,36(r2)
8110929c:	00000206 	br	811092a8 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
811092a0:	e0bfff17 	ldw	r2,-4(fp)
811092a4:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
811092a8:	e0bffe17 	ldw	r2,-8(fp)
811092ac:	1080800c 	andi	r2,r2,512
811092b0:	10000426 	beq	r2,zero,811092c4 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
811092b4:	e0bfff17 	ldw	r2,-4(fp)
811092b8:	00c00044 	movi	r3,1
811092bc:	10c00a15 	stw	r3,40(r2)
811092c0:	00000206 	br	811092cc <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
811092c4:	e0bfff17 	ldw	r2,-4(fp)
811092c8:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
811092cc:	e0bffe17 	ldw	r2,-8(fp)
811092d0:	1080400c 	andi	r2,r2,256
811092d4:	10000426 	beq	r2,zero,811092e8 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
811092d8:	e0bfff17 	ldw	r2,-4(fp)
811092dc:	00c00044 	movi	r3,1
811092e0:	10c00b15 	stw	r3,44(r2)
811092e4:	00000206 	br	811092f0 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
811092e8:	e0bfff17 	ldw	r2,-4(fp)
811092ec:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
811092f0:	00800044 	movi	r2,1
811092f4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811092f8:	e0bffd17 	ldw	r2,-12(fp)
}
811092fc:	e037883a 	mov	sp,fp
81109300:	dfc00117 	ldw	ra,4(sp)
81109304:	df000017 	ldw	fp,0(sp)
81109308:	dec00204 	addi	sp,sp,8
8110930c:	f800283a 	ret

81109310 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
81109310:	defffb04 	addi	sp,sp,-20
81109314:	de00012e 	bgeu	sp,et,8110931c <bSpwcGetTimecode+0xc>
81109318:	003b68fa 	trap	3
8110931c:	dfc00415 	stw	ra,16(sp)
81109320:	df000315 	stw	fp,12(sp)
81109324:	df000304 	addi	fp,sp,12
81109328:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110932c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109330:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109334:	e0bfff17 	ldw	r2,-4(fp)
81109338:	10001326 	beq	r2,zero,81109388 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110933c:	e0bfff17 	ldw	r2,-4(fp)
81109340:	10800017 	ldw	r2,0(r2)
81109344:	01400044 	movi	r5,1
81109348:	1009883a 	mov	r4,r2
8110934c:	11096000 	call	81109600 <uliSpwcReadReg>
81109350:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
81109354:	e0bffe17 	ldw	r2,-8(fp)
81109358:	1080300c 	andi	r2,r2,192
8110935c:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
81109360:	1007883a 	mov	r3,r2
81109364:	e0bfff17 	ldw	r2,-4(fp)
81109368:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110936c:	e0bffe17 	ldw	r2,-8(fp)
81109370:	10800fcc 	andi	r2,r2,63
81109374:	1007883a 	mov	r3,r2
81109378:	e0bfff17 	ldw	r2,-4(fp)
8110937c:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
81109380:	00800044 	movi	r2,1
81109384:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109388:	e0bffd17 	ldw	r2,-12(fp)
}
8110938c:	e037883a 	mov	sp,fp
81109390:	dfc00117 	ldw	ra,4(sp)
81109394:	df000017 	ldw	fp,0(sp)
81109398:	dec00204 	addi	sp,sp,8
8110939c:	f800283a 	ret

811093a0 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
811093a0:	defffb04 	addi	sp,sp,-20
811093a4:	de00012e 	bgeu	sp,et,811093ac <bSpwcClearTimecode+0xc>
811093a8:	003b68fa 	trap	3
811093ac:	dfc00415 	stw	ra,16(sp)
811093b0:	df000315 	stw	fp,12(sp)
811093b4:	df000304 	addi	fp,sp,12
811093b8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811093bc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811093c0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811093c4:	e0bfff17 	ldw	r2,-4(fp)
811093c8:	10001126 	beq	r2,zero,81109410 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811093cc:	e0bfff17 	ldw	r2,-4(fp)
811093d0:	10800017 	ldw	r2,0(r2)
811093d4:	01400044 	movi	r5,1
811093d8:	1009883a 	mov	r4,r2
811093dc:	11096000 	call	81109600 <uliSpwcReadReg>
811093e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
811093e4:	e0bffe17 	ldw	r2,-8(fp)
811093e8:	10804014 	ori	r2,r2,256
811093ec:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
811093f0:	e0bfff17 	ldw	r2,-4(fp)
811093f4:	10800017 	ldw	r2,0(r2)
811093f8:	e1bffe17 	ldw	r6,-8(fp)
811093fc:	01400044 	movi	r5,1
81109400:	1009883a 	mov	r4,r2
81109404:	11095ac0 	call	811095ac <vSpwcWriteReg>
		bStatus = TRUE;
81109408:	00800044 	movi	r2,1
8110940c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109410:	e0bffd17 	ldw	r2,-12(fp)
}
81109414:	e037883a 	mov	sp,fp
81109418:	dfc00117 	ldw	ra,4(sp)
8110941c:	df000017 	ldw	fp,0(sp)
81109420:	dec00204 	addi	sp,sp,8
81109424:	f800283a 	ret

81109428 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81109428:	defffb04 	addi	sp,sp,-20
8110942c:	de00012e 	bgeu	sp,et,81109434 <bSpwcInitCh+0xc>
81109430:	003b68fa 	trap	3
81109434:	dfc00415 	stw	ra,16(sp)
81109438:	df000315 	stw	fp,12(sp)
8110943c:	df000304 	addi	fp,sp,12
81109440:	e13ffe15 	stw	r4,-8(fp)
81109444:	2805883a 	mov	r2,r5
81109448:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110944c:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
81109450:	e0bffe17 	ldw	r2,-8(fp)
81109454:	10004f26 	beq	r2,zero,81109594 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
81109458:	00800044 	movi	r2,1
8110945c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109460:	e0bfff03 	ldbu	r2,-4(fp)
81109464:	10c00228 	cmpgeui	r3,r2,8
81109468:	1800361e 	bne	r3,zero,81109544 <bSpwcInitCh+0x11c>
8110946c:	100690ba 	slli	r3,r2,2
81109470:	00a04474 	movhi	r2,33041
81109474:	10a52104 	addi	r2,r2,-27516
81109478:	1885883a 	add	r2,r3,r2
8110947c:	10800017 	ldw	r2,0(r2)
81109480:	1000683a 	jmp	r2
81109484:	811094a4 	muli	r4,r16,16978
81109488:	811094b8 	rdprs	r4,r16,16978
8110948c:	811094cc 	andi	r4,r16,16979
81109490:	811094e0 	cmpeqi	r4,r16,16979
81109494:	811094f4 	orhi	r4,r16,16979
81109498:	81109508 	cmpgei	r4,r16,16980
8110949c:	8110951c 	xori	r4,r16,16980
811094a0:	81109530 	cmpltui	r4,r16,16980
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811094a4:	e0fffe17 	ldw	r3,-8(fp)
811094a8:	00a04834 	movhi	r2,33056
811094ac:	108b0004 	addi	r2,r2,11264
811094b0:	18800015 	stw	r2,0(r3)
			break;
811094b4:	00002506 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811094b8:	e0fffe17 	ldw	r3,-8(fp)
811094bc:	00a04834 	movhi	r2,33056
811094c0:	108a0004 	addi	r2,r2,10240
811094c4:	18800015 	stw	r2,0(r3)
			break;
811094c8:	00002006 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811094cc:	e0fffe17 	ldw	r3,-8(fp)
811094d0:	00a04834 	movhi	r2,33056
811094d4:	10890004 	addi	r2,r2,9216
811094d8:	18800015 	stw	r2,0(r3)
			break;
811094dc:	00001b06 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811094e0:	e0fffe17 	ldw	r3,-8(fp)
811094e4:	00a04834 	movhi	r2,33056
811094e8:	10880004 	addi	r2,r2,8192
811094ec:	18800015 	stw	r2,0(r3)
			break;
811094f0:	00001606 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811094f4:	e0fffe17 	ldw	r3,-8(fp)
811094f8:	00a04834 	movhi	r2,33056
811094fc:	10870004 	addi	r2,r2,7168
81109500:	18800015 	stw	r2,0(r3)
			break;
81109504:	00001106 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109508:	e0fffe17 	ldw	r3,-8(fp)
8110950c:	00a04834 	movhi	r2,33056
81109510:	10860004 	addi	r2,r2,6144
81109514:	18800015 	stw	r2,0(r3)
			break;
81109518:	00000c06 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110951c:	e0fffe17 	ldw	r3,-8(fp)
81109520:	00a04834 	movhi	r2,33056
81109524:	10850004 	addi	r2,r2,5120
81109528:	18800015 	stw	r2,0(r3)
			break;
8110952c:	00000706 	br	8110954c <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109530:	e0fffe17 	ldw	r3,-8(fp)
81109534:	00a04834 	movhi	r2,33056
81109538:	10840004 	addi	r2,r2,4096
8110953c:	18800015 	stw	r2,0(r3)
			break;
81109540:	00000206 	br	8110954c <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
81109544:	e03ffd15 	stw	zero,-12(fp)
			break;
81109548:	0001883a 	nop
		}

		if (bStatus) {
8110954c:	e0bffd17 	ldw	r2,-12(fp)
81109550:	10001026 	beq	r2,zero,81109594 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
81109554:	e13ffe17 	ldw	r4,-8(fp)
81109558:	11090680 	call	81109068 <bSpwcGetLink>
8110955c:	1000011e 	bne	r2,zero,81109564 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
81109560:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
81109564:	e13ffe17 	ldw	r4,-8(fp)
81109568:	110914c0 	call	8110914c <bSpwcGetLinkError>
8110956c:	1000011e 	bne	r2,zero,81109574 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
81109570:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
81109574:	e13ffe17 	ldw	r4,-8(fp)
81109578:	11092400 	call	81109240 <bSpwcGetLinkStatus>
8110957c:	1000011e 	bne	r2,zero,81109584 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
81109580:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
81109584:	e13ffe17 	ldw	r4,-8(fp)
81109588:	11093100 	call	81109310 <bSpwcGetTimecode>
8110958c:	1000011e 	bne	r2,zero,81109594 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
81109590:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109594:	e0bffd17 	ldw	r2,-12(fp)
}
81109598:	e037883a 	mov	sp,fp
8110959c:	dfc00117 	ldw	ra,4(sp)
811095a0:	df000017 	ldw	fp,0(sp)
811095a4:	dec00204 	addi	sp,sp,8
811095a8:	f800283a 	ret

811095ac <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811095ac:	defffc04 	addi	sp,sp,-16
811095b0:	de00012e 	bgeu	sp,et,811095b8 <vSpwcWriteReg+0xc>
811095b4:	003b68fa 	trap	3
811095b8:	df000315 	stw	fp,12(sp)
811095bc:	df000304 	addi	fp,sp,12
811095c0:	e13ffd15 	stw	r4,-12(fp)
811095c4:	e17ffe15 	stw	r5,-8(fp)
811095c8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811095cc:	e0bffe17 	ldw	r2,-8(fp)
811095d0:	1085883a 	add	r2,r2,r2
811095d4:	1085883a 	add	r2,r2,r2
811095d8:	1007883a 	mov	r3,r2
811095dc:	e0bffd17 	ldw	r2,-12(fp)
811095e0:	10c5883a 	add	r2,r2,r3
811095e4:	e0ffff17 	ldw	r3,-4(fp)
811095e8:	10c00015 	stw	r3,0(r2)
}
811095ec:	0001883a 	nop
811095f0:	e037883a 	mov	sp,fp
811095f4:	df000017 	ldw	fp,0(sp)
811095f8:	dec00104 	addi	sp,sp,4
811095fc:	f800283a 	ret

81109600 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109600:	defffc04 	addi	sp,sp,-16
81109604:	de00012e 	bgeu	sp,et,8110960c <uliSpwcReadReg+0xc>
81109608:	003b68fa 	trap	3
8110960c:	df000315 	stw	fp,12(sp)
81109610:	df000304 	addi	fp,sp,12
81109614:	e13ffe15 	stw	r4,-8(fp)
81109618:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110961c:	e0bfff17 	ldw	r2,-4(fp)
81109620:	1085883a 	add	r2,r2,r2
81109624:	1085883a 	add	r2,r2,r2
81109628:	1007883a 	mov	r3,r2
8110962c:	e0bffe17 	ldw	r2,-8(fp)
81109630:	10c5883a 	add	r2,r2,r3
81109634:	10800017 	ldw	r2,0(r2)
81109638:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110963c:	e0bffd17 	ldw	r2,-12(fp)
}
81109640:	e037883a 	mov	sp,fp
81109644:	df000017 	ldw	fp,0(sp)
81109648:	dec00104 	addi	sp,sp,4
8110964c:	f800283a 	ret

81109650 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
81109650:	defffe04 	addi	sp,sp,-8
81109654:	de00012e 	bgeu	sp,et,8110965c <bEnableIsoDrivers+0xc>
81109658:	003b68fa 	trap	3
8110965c:	dfc00115 	stw	ra,4(sp)
81109660:	df000015 	stw	fp,0(sp)
81109664:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
81109668:	01400204 	movi	r5,8
8110966c:	01000044 	movi	r4,1
81109670:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
  return  TRUE;
81109674:	00800044 	movi	r2,1
}
81109678:	e037883a 	mov	sp,fp
8110967c:	dfc00117 	ldw	ra,4(sp)
81109680:	df000017 	ldw	fp,0(sp)
81109684:	dec00204 	addi	sp,sp,8
81109688:	f800283a 	ret

8110968c <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110968c:	defffe04 	addi	sp,sp,-8
81109690:	de00012e 	bgeu	sp,et,81109698 <bDisableIsoDrivers+0xc>
81109694:	003b68fa 	trap	3
81109698:	dfc00115 	stw	ra,4(sp)
8110969c:	df000015 	stw	fp,0(sp)
811096a0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
811096a4:	01400204 	movi	r5,8
811096a8:	0009883a 	mov	r4,zero
811096ac:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
  return  TRUE;
811096b0:	00800044 	movi	r2,1
}
811096b4:	e037883a 	mov	sp,fp
811096b8:	dfc00117 	ldw	ra,4(sp)
811096bc:	df000017 	ldw	fp,0(sp)
811096c0:	dec00204 	addi	sp,sp,8
811096c4:	f800283a 	ret

811096c8 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
811096c8:	defffe04 	addi	sp,sp,-8
811096cc:	de00012e 	bgeu	sp,et,811096d4 <bEnableLvdsBoard+0xc>
811096d0:	003b68fa 	trap	3
811096d4:	dfc00115 	stw	ra,4(sp)
811096d8:	df000015 	stw	fp,0(sp)
811096dc:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
811096e0:	01400104 	movi	r5,4
811096e4:	01000044 	movi	r4,1
811096e8:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
  return  TRUE;
811096ec:	00800044 	movi	r2,1
}
811096f0:	e037883a 	mov	sp,fp
811096f4:	dfc00117 	ldw	ra,4(sp)
811096f8:	df000017 	ldw	fp,0(sp)
811096fc:	dec00204 	addi	sp,sp,8
81109700:	f800283a 	ret

81109704 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
81109704:	defffe04 	addi	sp,sp,-8
81109708:	de00012e 	bgeu	sp,et,81109710 <bDisableLvdsBoard+0xc>
8110970c:	003b68fa 	trap	3
81109710:	dfc00115 	stw	ra,4(sp)
81109714:	df000015 	stw	fp,0(sp)
81109718:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110971c:	01400104 	movi	r5,4
81109720:	0009883a 	mov	r4,zero
81109724:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
  return  TRUE;
81109728:	00800044 	movi	r2,1
}
8110972c:	e037883a 	mov	sp,fp
81109730:	dfc00117 	ldw	ra,4(sp)
81109734:	df000017 	ldw	fp,0(sp)
81109738:	dec00204 	addi	sp,sp,8
8110973c:	f800283a 	ret

81109740 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
81109740:	defffd04 	addi	sp,sp,-12
81109744:	de00012e 	bgeu	sp,et,8110974c <bSetPreEmphasys+0xc>
81109748:	003b68fa 	trap	3
8110974c:	dfc00215 	stw	ra,8(sp)
81109750:	df000115 	stw	fp,4(sp)
81109754:	df000104 	addi	fp,sp,4
81109758:	2005883a 	mov	r2,r4
8110975c:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
81109760:	e0bfff03 	ldbu	r2,-4(fp)
81109764:	10c00060 	cmpeqi	r3,r2,1
81109768:	18000d1e 	bne	r3,zero,811097a0 <bSetPreEmphasys+0x60>
8110976c:	10c00088 	cmpgei	r3,r2,2
81109770:	1800021e 	bne	r3,zero,8110977c <bSetPreEmphasys+0x3c>
81109774:	10000626 	beq	r2,zero,81109790 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81109778:	00001b06 	br	811097e8 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110977c:	10c000a0 	cmpeqi	r3,r2,2
81109780:	18000e1e 	bne	r3,zero,811097bc <bSetPreEmphasys+0x7c>
81109784:	108000e0 	cmpeqi	r2,r2,3
81109788:	1000131e 	bne	r2,zero,811097d8 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110978c:	00001606 	br	811097e8 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81109790:	014000c4 	movi	r5,3
81109794:	0009883a 	mov	r4,zero
81109798:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
      break;
8110979c:	00001206 	br	811097e8 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
811097a0:	01400084 	movi	r5,2
811097a4:	0009883a 	mov	r4,zero
811097a8:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
811097ac:	01400044 	movi	r5,1
811097b0:	01000044 	movi	r4,1
811097b4:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
      break;
811097b8:	00000b06 	br	811097e8 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
811097bc:	01400044 	movi	r5,1
811097c0:	0009883a 	mov	r4,zero
811097c4:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
811097c8:	01400084 	movi	r5,2
811097cc:	01000044 	movi	r4,1
811097d0:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
      break;
811097d4:	00000406 	br	811097e8 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811097d8:	014000c4 	movi	r5,3
811097dc:	01000044 	movi	r4,1
811097e0:	11098000 	call	81109800 <bCtrlIoLvdsDrive>
      break;
811097e4:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
811097e8:	00800044 	movi	r2,1
}
811097ec:	e037883a 	mov	sp,fp
811097f0:	dfc00117 	ldw	ra,4(sp)
811097f4:	df000017 	ldw	fp,0(sp)
811097f8:	dec00204 	addi	sp,sp,8
811097fc:	f800283a 	ret

81109800 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
81109800:	defffd04 	addi	sp,sp,-12
81109804:	de00012e 	bgeu	sp,et,8110980c <bCtrlIoLvdsDrive+0xc>
81109808:	003b68fa 	trap	3
8110980c:	df000215 	stw	fp,8(sp)
81109810:	df000204 	addi	fp,sp,8
81109814:	e13ffe15 	stw	r4,-8(fp)
81109818:	2805883a 	mov	r2,r5
8110981c:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
81109820:	e0bffe17 	ldw	r2,-8(fp)
81109824:	1000071e 	bne	r2,zero,81109844 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81109828:	e0bfff03 	ldbu	r2,-4(fp)
8110982c:	0084303a 	nor	r2,zero,r2
81109830:	1007883a 	mov	r3,r2
81109834:	d0a00103 	ldbu	r2,-32764(gp)
81109838:	1884703a 	and	r2,r3,r2
8110983c:	d0a00105 	stb	r2,-32764(gp)
81109840:	00000406 	br	81109854 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
81109844:	d0e00103 	ldbu	r3,-32764(gp)
81109848:	e0bfff03 	ldbu	r2,-4(fp)
8110984c:	1884b03a 	or	r2,r3,r2
81109850:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
81109854:	d0a00103 	ldbu	r2,-32764(gp)
81109858:	10c03fcc 	andi	r3,r2,255
8110985c:	00a00034 	movhi	r2,32768
81109860:	10822804 	addi	r2,r2,2208
81109864:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81109868:	00800044 	movi	r2,1
}
8110986c:	e037883a 	mov	sp,fp
81109870:	df000017 	ldw	fp,0(sp)
81109874:	dec00104 	addi	sp,sp,4
81109878:	f800283a 	ret

8110987c <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110987c:	defffa04 	addi	sp,sp,-24
81109880:	de00012e 	bgeu	sp,et,81109888 <I2C_TestAdress+0xc>
81109884:	003b68fa 	trap	3
81109888:	dfc00515 	stw	ra,20(sp)
8110988c:	df000415 	stw	fp,16(sp)
81109890:	df000404 	addi	fp,sp,16
81109894:	e13ffd15 	stw	r4,-12(fp)
81109898:	e17ffe15 	stw	r5,-8(fp)
8110989c:	3005883a 	mov	r2,r6
811098a0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
811098a4:	00800044 	movi	r2,1
811098a8:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811098ac:	e17ffe17 	ldw	r5,-8(fp)
811098b0:	e13ffd17 	ldw	r4,-12(fp)
811098b4:	1109c4c0 	call	81109c4c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811098b8:	e0bfff03 	ldbu	r2,-4(fp)
811098bc:	10803fcc 	andi	r2,r2,255
811098c0:	100d883a 	mov	r6,r2
811098c4:	e17ffe17 	ldw	r5,-8(fp)
811098c8:	e13ffd17 	ldw	r4,-12(fp)
811098cc:	1109d600 	call	81109d60 <i2c_write>
811098d0:	1000011e 	bne	r2,zero,811098d8 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
811098d4:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
811098d8:	e17ffe17 	ldw	r5,-8(fp)
811098dc:	e13ffd17 	ldw	r4,-12(fp)
811098e0:	1109ce00 	call	81109ce0 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
811098e4:	0106d604 	movi	r4,7000
811098e8:	1132d740 	call	81132d74 <usleep>
    
    return bSuccess;
811098ec:	e0bffc17 	ldw	r2,-16(fp)

}
811098f0:	e037883a 	mov	sp,fp
811098f4:	dfc00117 	ldw	ra,4(sp)
811098f8:	df000017 	ldw	fp,0(sp)
811098fc:	dec00204 	addi	sp,sp,8
81109900:	f800283a 	ret

81109904 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81109904:	defff804 	addi	sp,sp,-32
81109908:	de00012e 	bgeu	sp,et,81109910 <I2C_Write+0xc>
8110990c:	003b68fa 	trap	3
81109910:	dfc00715 	stw	ra,28(sp)
81109914:	df000615 	stw	fp,24(sp)
81109918:	df000604 	addi	fp,sp,24
8110991c:	e13ffb15 	stw	r4,-20(fp)
81109920:	e17ffc15 	stw	r5,-16(fp)
81109924:	3009883a 	mov	r4,r6
81109928:	3807883a 	mov	r3,r7
8110992c:	e0800217 	ldw	r2,8(fp)
81109930:	e13ffd05 	stb	r4,-12(fp)
81109934:	e0fffe05 	stb	r3,-8(fp)
81109938:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110993c:	00800044 	movi	r2,1
81109940:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109944:	e17ffc17 	ldw	r5,-16(fp)
81109948:	e13ffb17 	ldw	r4,-20(fp)
8110994c:	1109c4c0 	call	81109c4c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109950:	e0bffd03 	ldbu	r2,-12(fp)
81109954:	10803fcc 	andi	r2,r2,255
81109958:	100d883a 	mov	r6,r2
8110995c:	e17ffc17 	ldw	r5,-16(fp)
81109960:	e13ffb17 	ldw	r4,-20(fp)
81109964:	1109d600 	call	81109d60 <i2c_write>
81109968:	1000011e 	bne	r2,zero,81109970 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110996c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109970:	e0bffa17 	ldw	r2,-24(fp)
81109974:	10000726 	beq	r2,zero,81109994 <I2C_Write+0x90>
81109978:	e0bffe03 	ldbu	r2,-8(fp)
8110997c:	100d883a 	mov	r6,r2
81109980:	e17ffc17 	ldw	r5,-16(fp)
81109984:	e13ffb17 	ldw	r4,-20(fp)
81109988:	1109d600 	call	81109d60 <i2c_write>
8110998c:	1000011e 	bne	r2,zero,81109994 <I2C_Write+0x90>
        bSuccess = FALSE;
81109990:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81109994:	e0bffa17 	ldw	r2,-24(fp)
81109998:	10000726 	beq	r2,zero,811099b8 <I2C_Write+0xb4>
8110999c:	e0bfff03 	ldbu	r2,-4(fp)
811099a0:	100d883a 	mov	r6,r2
811099a4:	e17ffc17 	ldw	r5,-16(fp)
811099a8:	e13ffb17 	ldw	r4,-20(fp)
811099ac:	1109d600 	call	81109d60 <i2c_write>
811099b0:	1000011e 	bne	r2,zero,811099b8 <I2C_Write+0xb4>
        bSuccess = FALSE;
811099b4:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
811099b8:	e17ffc17 	ldw	r5,-16(fp)
811099bc:	e13ffb17 	ldw	r4,-20(fp)
811099c0:	1109ce00 	call	81109ce0 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
811099c4:	0106d604 	movi	r4,7000
811099c8:	1132d740 	call	81132d74 <usleep>
    
    return bSuccess;
811099cc:	e0bffa17 	ldw	r2,-24(fp)

}
811099d0:	e037883a 	mov	sp,fp
811099d4:	dfc00117 	ldw	ra,4(sp)
811099d8:	df000017 	ldw	fp,0(sp)
811099dc:	dec00204 	addi	sp,sp,8
811099e0:	f800283a 	ret

811099e4 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
811099e4:	defff904 	addi	sp,sp,-28
811099e8:	de00012e 	bgeu	sp,et,811099f0 <I2C_Read+0xc>
811099ec:	003b68fa 	trap	3
811099f0:	dfc00615 	stw	ra,24(sp)
811099f4:	df000515 	stw	fp,20(sp)
811099f8:	df000504 	addi	fp,sp,20
811099fc:	e13ffc15 	stw	r4,-16(fp)
81109a00:	e17ffd15 	stw	r5,-12(fp)
81109a04:	3007883a 	mov	r3,r6
81109a08:	3805883a 	mov	r2,r7
81109a0c:	e0fffe05 	stb	r3,-8(fp)
81109a10:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109a14:	00800044 	movi	r2,1
81109a18:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109a1c:	e17ffd17 	ldw	r5,-12(fp)
81109a20:	e13ffc17 	ldw	r4,-16(fp)
81109a24:	1109c4c0 	call	81109c4c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109a28:	e0bffe03 	ldbu	r2,-8(fp)
81109a2c:	10803fcc 	andi	r2,r2,255
81109a30:	100d883a 	mov	r6,r2
81109a34:	e17ffd17 	ldw	r5,-12(fp)
81109a38:	e13ffc17 	ldw	r4,-16(fp)
81109a3c:	1109d600 	call	81109d60 <i2c_write>
81109a40:	1000011e 	bne	r2,zero,81109a48 <I2C_Read+0x64>
        bSuccess = FALSE;
81109a44:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109a48:	e0bffb17 	ldw	r2,-20(fp)
81109a4c:	10000726 	beq	r2,zero,81109a6c <I2C_Read+0x88>
81109a50:	e0bfff03 	ldbu	r2,-4(fp)
81109a54:	100d883a 	mov	r6,r2
81109a58:	e17ffd17 	ldw	r5,-12(fp)
81109a5c:	e13ffc17 	ldw	r4,-16(fp)
81109a60:	1109d600 	call	81109d60 <i2c_write>
81109a64:	1000011e 	bne	r2,zero,81109a6c <I2C_Read+0x88>
        bSuccess = FALSE;
81109a68:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81109a6c:	e17ffd17 	ldw	r5,-12(fp)
81109a70:	e13ffc17 	ldw	r4,-16(fp)
81109a74:	1109c4c0 	call	81109c4c <i2c_start>
    DeviceAddr |= 1; // Read
81109a78:	e0bffe03 	ldbu	r2,-8(fp)
81109a7c:	10800054 	ori	r2,r2,1
81109a80:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109a84:	e0bffb17 	ldw	r2,-20(fp)
81109a88:	10000826 	beq	r2,zero,81109aac <I2C_Read+0xc8>
81109a8c:	e0bffe03 	ldbu	r2,-8(fp)
81109a90:	10803fcc 	andi	r2,r2,255
81109a94:	100d883a 	mov	r6,r2
81109a98:	e17ffd17 	ldw	r5,-12(fp)
81109a9c:	e13ffc17 	ldw	r4,-16(fp)
81109aa0:	1109d600 	call	81109d60 <i2c_write>
81109aa4:	1000011e 	bne	r2,zero,81109aac <I2C_Read+0xc8>
        bSuccess = FALSE;
81109aa8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109aac:	e0bffb17 	ldw	r2,-20(fp)
81109ab0:	10000526 	beq	r2,zero,81109ac8 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81109ab4:	000f883a 	mov	r7,zero
81109ab8:	e1800217 	ldw	r6,8(fp)
81109abc:	e17ffd17 	ldw	r5,-12(fp)
81109ac0:	e13ffc17 	ldw	r4,-16(fp)
81109ac4:	1109e980 	call	81109e98 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81109ac8:	e17ffd17 	ldw	r5,-12(fp)
81109acc:	e13ffc17 	ldw	r4,-16(fp)
81109ad0:	1109ce00 	call	81109ce0 <i2c_stop>
    
    return bSuccess;
81109ad4:	e0bffb17 	ldw	r2,-20(fp)
}
81109ad8:	e037883a 	mov	sp,fp
81109adc:	dfc00117 	ldw	ra,4(sp)
81109ae0:	df000017 	ldw	fp,0(sp)
81109ae4:	dec00204 	addi	sp,sp,8
81109ae8:	f800283a 	ret

81109aec <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81109aec:	defff604 	addi	sp,sp,-40
81109af0:	de00012e 	bgeu	sp,et,81109af8 <I2C_MultipleRead+0xc>
81109af4:	003b68fa 	trap	3
81109af8:	dfc00915 	stw	ra,36(sp)
81109afc:	df000815 	stw	fp,32(sp)
81109b00:	df000804 	addi	fp,sp,32
81109b04:	e13ffb15 	stw	r4,-20(fp)
81109b08:	e17ffc15 	stw	r5,-16(fp)
81109b0c:	3007883a 	mov	r3,r6
81109b10:	e1fffe15 	stw	r7,-8(fp)
81109b14:	e0800217 	ldw	r2,8(fp)
81109b18:	e0fffd05 	stb	r3,-12(fp)
81109b1c:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81109b20:	00800044 	movi	r2,1
81109b24:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81109b28:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109b2c:	e17ffc17 	ldw	r5,-16(fp)
81109b30:	e13ffb17 	ldw	r4,-20(fp)
81109b34:	1109c4c0 	call	81109c4c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109b38:	e0bffd03 	ldbu	r2,-12(fp)
81109b3c:	10803fcc 	andi	r2,r2,255
81109b40:	100d883a 	mov	r6,r2
81109b44:	e17ffc17 	ldw	r5,-16(fp)
81109b48:	e13ffb17 	ldw	r4,-20(fp)
81109b4c:	1109d600 	call	81109d60 <i2c_write>
81109b50:	1000011e 	bne	r2,zero,81109b58 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81109b54:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109b58:	e0bff917 	ldw	r2,-28(fp)
81109b5c:	10000726 	beq	r2,zero,81109b7c <I2C_MultipleRead+0x90>
81109b60:	e0bffa03 	ldbu	r2,-24(fp)
81109b64:	100d883a 	mov	r6,r2
81109b68:	e17ffc17 	ldw	r5,-16(fp)
81109b6c:	e13ffb17 	ldw	r4,-20(fp)
81109b70:	1109d600 	call	81109d60 <i2c_write>
81109b74:	1000011e 	bne	r2,zero,81109b7c <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81109b78:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81109b7c:	e0bff917 	ldw	r2,-28(fp)
81109b80:	10000326 	beq	r2,zero,81109b90 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81109b84:	e17ffc17 	ldw	r5,-16(fp)
81109b88:	e13ffb17 	ldw	r4,-20(fp)
81109b8c:	1109c4c0 	call	81109c4c <i2c_start>
    DeviceAddr |= 1; // Read
81109b90:	e0bffd03 	ldbu	r2,-12(fp)
81109b94:	10800054 	ori	r2,r2,1
81109b98:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109b9c:	e0bff917 	ldw	r2,-28(fp)
81109ba0:	10000826 	beq	r2,zero,81109bc4 <I2C_MultipleRead+0xd8>
81109ba4:	e0bffd03 	ldbu	r2,-12(fp)
81109ba8:	10803fcc 	andi	r2,r2,255
81109bac:	100d883a 	mov	r6,r2
81109bb0:	e17ffc17 	ldw	r5,-16(fp)
81109bb4:	e13ffb17 	ldw	r4,-20(fp)
81109bb8:	1109d600 	call	81109d60 <i2c_write>
81109bbc:	1000011e 	bne	r2,zero,81109bc4 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81109bc0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109bc4:	e0bff917 	ldw	r2,-28(fp)
81109bc8:	10001726 	beq	r2,zero,81109c28 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81109bcc:	e03ff815 	stw	zero,-32(fp)
81109bd0:	00001006 	br	81109c14 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81109bd4:	e0bff817 	ldw	r2,-32(fp)
81109bd8:	e0fffe17 	ldw	r3,-8(fp)
81109bdc:	1889883a 	add	r4,r3,r2
81109be0:	e0bfff0b 	ldhu	r2,-4(fp)
81109be4:	10ffffc4 	addi	r3,r2,-1
81109be8:	e0bff817 	ldw	r2,-32(fp)
81109bec:	1884c03a 	cmpne	r2,r3,r2
81109bf0:	10803fcc 	andi	r2,r2,255
81109bf4:	100f883a 	mov	r7,r2
81109bf8:	200d883a 	mov	r6,r4
81109bfc:	e17ffc17 	ldw	r5,-16(fp)
81109c00:	e13ffb17 	ldw	r4,-20(fp)
81109c04:	1109e980 	call	81109e98 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81109c08:	e0bff817 	ldw	r2,-32(fp)
81109c0c:	10800044 	addi	r2,r2,1
81109c10:	e0bff815 	stw	r2,-32(fp)
81109c14:	e0bfff0b 	ldhu	r2,-4(fp)
81109c18:	e0fff817 	ldw	r3,-32(fp)
81109c1c:	1880020e 	bge	r3,r2,81109c28 <I2C_MultipleRead+0x13c>
81109c20:	e0bff917 	ldw	r2,-28(fp)
81109c24:	103feb1e 	bne	r2,zero,81109bd4 <__reset+0xfb0e9bd4>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81109c28:	e17ffc17 	ldw	r5,-16(fp)
81109c2c:	e13ffb17 	ldw	r4,-20(fp)
81109c30:	1109ce00 	call	81109ce0 <i2c_stop>
    
    return bSuccess;    
81109c34:	e0bff917 	ldw	r2,-28(fp)
    
}
81109c38:	e037883a 	mov	sp,fp
81109c3c:	dfc00117 	ldw	ra,4(sp)
81109c40:	df000017 	ldw	fp,0(sp)
81109c44:	dec00204 	addi	sp,sp,8
81109c48:	f800283a 	ret

81109c4c <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81109c4c:	defffc04 	addi	sp,sp,-16
81109c50:	de00012e 	bgeu	sp,et,81109c58 <i2c_start+0xc>
81109c54:	003b68fa 	trap	3
81109c58:	dfc00315 	stw	ra,12(sp)
81109c5c:	df000215 	stw	fp,8(sp)
81109c60:	df000204 	addi	fp,sp,8
81109c64:	e13ffe15 	stw	r4,-8(fp)
81109c68:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81109c6c:	e0bfff17 	ldw	r2,-4(fp)
81109c70:	10800104 	addi	r2,r2,4
81109c74:	1007883a 	mov	r3,r2
81109c78:	00800044 	movi	r2,1
81109c7c:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81109c80:	e0bfff17 	ldw	r2,-4(fp)
81109c84:	00c00044 	movi	r3,1
81109c88:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81109c8c:	e0bffe17 	ldw	r2,-8(fp)
81109c90:	00c00044 	movi	r3,1
81109c94:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109c98:	01000044 	movi	r4,1
81109c9c:	1132d740 	call	81132d74 <usleep>
     
    SDA_LOW(data_base); // data low
81109ca0:	e0bfff17 	ldw	r2,-4(fp)
81109ca4:	0007883a 	mov	r3,zero
81109ca8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81109cac:	01000044 	movi	r4,1
81109cb0:	1132d740 	call	81132d74 <usleep>
    SCL_LOW(clk_base); // clock low
81109cb4:	e0bffe17 	ldw	r2,-8(fp)
81109cb8:	0007883a 	mov	r3,zero
81109cbc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109cc0:	01000044 	movi	r4,1
81109cc4:	1132d740 	call	81132d74 <usleep>
}
81109cc8:	0001883a 	nop
81109ccc:	e037883a 	mov	sp,fp
81109cd0:	dfc00117 	ldw	ra,4(sp)
81109cd4:	df000017 	ldw	fp,0(sp)
81109cd8:	dec00204 	addi	sp,sp,8
81109cdc:	f800283a 	ret

81109ce0 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81109ce0:	defffc04 	addi	sp,sp,-16
81109ce4:	de00012e 	bgeu	sp,et,81109cec <i2c_stop+0xc>
81109ce8:	003b68fa 	trap	3
81109cec:	dfc00315 	stw	ra,12(sp)
81109cf0:	df000215 	stw	fp,8(sp)
81109cf4:	df000204 	addi	fp,sp,8
81109cf8:	e13ffe15 	stw	r4,-8(fp)
81109cfc:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81109d00:	e0bfff17 	ldw	r2,-4(fp)
81109d04:	10800104 	addi	r2,r2,4
81109d08:	1007883a 	mov	r3,r2
81109d0c:	00800044 	movi	r2,1
81109d10:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81109d14:	e0bfff17 	ldw	r2,-4(fp)
81109d18:	0007883a 	mov	r3,zero
81109d1c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81109d20:	e0bffe17 	ldw	r2,-8(fp)
81109d24:	00c00044 	movi	r3,1
81109d28:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81109d2c:	01000044 	movi	r4,1
81109d30:	1132d740 	call	81132d74 <usleep>
    SDA_HIGH(data_base); // data high
81109d34:	e0bfff17 	ldw	r2,-4(fp)
81109d38:	00c00044 	movi	r3,1
81109d3c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81109d40:	01000044 	movi	r4,1
81109d44:	1132d740 	call	81132d74 <usleep>
    

    
}
81109d48:	0001883a 	nop
81109d4c:	e037883a 	mov	sp,fp
81109d50:	dfc00117 	ldw	ra,4(sp)
81109d54:	df000017 	ldw	fp,0(sp)
81109d58:	dec00204 	addi	sp,sp,8
81109d5c:	f800283a 	ret

81109d60 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81109d60:	defff804 	addi	sp,sp,-32
81109d64:	de00012e 	bgeu	sp,et,81109d6c <i2c_write+0xc>
81109d68:	003b68fa 	trap	3
81109d6c:	dfc00715 	stw	ra,28(sp)
81109d70:	df000615 	stw	fp,24(sp)
81109d74:	df000604 	addi	fp,sp,24
81109d78:	e13ffd15 	stw	r4,-12(fp)
81109d7c:	e17ffe15 	stw	r5,-8(fp)
81109d80:	3005883a 	mov	r2,r6
81109d84:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81109d88:	00bfe004 	movi	r2,-128
81109d8c:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81109d90:	e0bffe17 	ldw	r2,-8(fp)
81109d94:	10800104 	addi	r2,r2,4
81109d98:	1007883a 	mov	r3,r2
81109d9c:	00800044 	movi	r2,1
81109da0:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81109da4:	e03ffb15 	stw	zero,-20(fp)
81109da8:	00001f06 	br	81109e28 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81109dac:	e0bffd17 	ldw	r2,-12(fp)
81109db0:	0007883a 	mov	r3,zero
81109db4:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81109db8:	e0ffff03 	ldbu	r3,-4(fp)
81109dbc:	e0bffa03 	ldbu	r2,-24(fp)
81109dc0:	1884703a 	and	r2,r3,r2
81109dc4:	10803fcc 	andi	r2,r2,255
81109dc8:	10000426 	beq	r2,zero,81109ddc <i2c_write+0x7c>
            SDA_HIGH(data_base);
81109dcc:	e0bffe17 	ldw	r2,-8(fp)
81109dd0:	00c00044 	movi	r3,1
81109dd4:	10c00035 	stwio	r3,0(r2)
81109dd8:	00000306 	br	81109de8 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81109ddc:	e0bffe17 	ldw	r2,-8(fp)
81109de0:	0007883a 	mov	r3,zero
81109de4:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81109de8:	e0bffa03 	ldbu	r2,-24(fp)
81109dec:	1004d07a 	srli	r2,r2,1
81109df0:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81109df4:	e0bffd17 	ldw	r2,-12(fp)
81109df8:	00c00044 	movi	r3,1
81109dfc:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109e00:	01000044 	movi	r4,1
81109e04:	1132d740 	call	81132d74 <usleep>
        SCL_LOW(clk_base);
81109e08:	e0bffd17 	ldw	r2,-12(fp)
81109e0c:	0007883a 	mov	r3,zero
81109e10:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109e14:	01000044 	movi	r4,1
81109e18:	1132d740 	call	81132d74 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
81109e1c:	e0bffb17 	ldw	r2,-20(fp)
81109e20:	10800044 	addi	r2,r2,1
81109e24:	e0bffb15 	stw	r2,-20(fp)
81109e28:	e0bffb17 	ldw	r2,-20(fp)
81109e2c:	10800210 	cmplti	r2,r2,8
81109e30:	103fde1e 	bne	r2,zero,81109dac <__reset+0xfb0e9dac>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81109e34:	e0bffe17 	ldw	r2,-8(fp)
81109e38:	10800104 	addi	r2,r2,4
81109e3c:	0007883a 	mov	r3,zero
81109e40:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81109e44:	e0bffd17 	ldw	r2,-12(fp)
81109e48:	00c00044 	movi	r3,1
81109e4c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81109e50:	01000044 	movi	r4,1
81109e54:	1132d740 	call	81132d74 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81109e58:	e0bffe17 	ldw	r2,-8(fp)
81109e5c:	10800037 	ldwio	r2,0(r2)
81109e60:	1005003a 	cmpeq	r2,r2,zero
81109e64:	10803fcc 	andi	r2,r2,255
81109e68:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
81109e6c:	e0bffd17 	ldw	r2,-12(fp)
81109e70:	0007883a 	mov	r3,zero
81109e74:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109e78:	01000044 	movi	r4,1
81109e7c:	1132d740 	call	81132d74 <usleep>
    return bAck;
81109e80:	e0bffc17 	ldw	r2,-16(fp)
}    
81109e84:	e037883a 	mov	sp,fp
81109e88:	dfc00117 	ldw	ra,4(sp)
81109e8c:	df000017 	ldw	fp,0(sp)
81109e90:	dec00204 	addi	sp,sp,8
81109e94:	f800283a 	ret

81109e98 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
81109e98:	defff804 	addi	sp,sp,-32
81109e9c:	de00012e 	bgeu	sp,et,81109ea4 <i2c_read+0xc>
81109ea0:	003b68fa 	trap	3
81109ea4:	dfc00715 	stw	ra,28(sp)
81109ea8:	df000615 	stw	fp,24(sp)
81109eac:	df000604 	addi	fp,sp,24
81109eb0:	e13ffc15 	stw	r4,-16(fp)
81109eb4:	e17ffd15 	stw	r5,-12(fp)
81109eb8:	e1bffe15 	stw	r6,-8(fp)
81109ebc:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
81109ec0:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
81109ec4:	e0bffd17 	ldw	r2,-12(fp)
81109ec8:	10800104 	addi	r2,r2,4
81109ecc:	0007883a 	mov	r3,zero
81109ed0:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81109ed4:	e0bffc17 	ldw	r2,-16(fp)
81109ed8:	0007883a 	mov	r3,zero
81109edc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109ee0:	01000044 	movi	r4,1
81109ee4:	1132d740 	call	81132d74 <usleep>

    for(i=0;i<8;i++){
81109ee8:	e03ffb15 	stw	zero,-20(fp)
81109eec:	00001606 	br	81109f48 <i2c_read+0xb0>
        Data <<= 1;
81109ef0:	e0bffa03 	ldbu	r2,-24(fp)
81109ef4:	1085883a 	add	r2,r2,r2
81109ef8:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
81109efc:	e0bffc17 	ldw	r2,-16(fp)
81109f00:	00c00044 	movi	r3,1
81109f04:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109f08:	01000044 	movi	r4,1
81109f0c:	1132d740 	call	81132d74 <usleep>
        if (SDA_READ(data_base))  // read data   
81109f10:	e0bffd17 	ldw	r2,-12(fp)
81109f14:	10800037 	ldwio	r2,0(r2)
81109f18:	10000326 	beq	r2,zero,81109f28 <i2c_read+0x90>
            Data |= 0x01;
81109f1c:	e0bffa03 	ldbu	r2,-24(fp)
81109f20:	10800054 	ori	r2,r2,1
81109f24:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81109f28:	e0bffc17 	ldw	r2,-16(fp)
81109f2c:	0007883a 	mov	r3,zero
81109f30:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109f34:	01000044 	movi	r4,1
81109f38:	1132d740 	call	81132d74 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
81109f3c:	e0bffb17 	ldw	r2,-20(fp)
81109f40:	10800044 	addi	r2,r2,1
81109f44:	e0bffb15 	stw	r2,-20(fp)
81109f48:	e0bffb17 	ldw	r2,-20(fp)
81109f4c:	10800210 	cmplti	r2,r2,8
81109f50:	103fe71e 	bne	r2,zero,81109ef0 <__reset+0xfb0e9ef0>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
81109f54:	e0bffc17 	ldw	r2,-16(fp)
81109f58:	0007883a 	mov	r3,zero
81109f5c:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
81109f60:	e0bffd17 	ldw	r2,-12(fp)
81109f64:	10800104 	addi	r2,r2,4
81109f68:	1007883a 	mov	r3,r2
81109f6c:	00800044 	movi	r2,1
81109f70:	18800035 	stwio	r2,0(r3)
    if (bAck)
81109f74:	e0bfff17 	ldw	r2,-4(fp)
81109f78:	10000426 	beq	r2,zero,81109f8c <i2c_read+0xf4>
        SDA_LOW(data_base);
81109f7c:	e0bffd17 	ldw	r2,-12(fp)
81109f80:	0007883a 	mov	r3,zero
81109f84:	10c00035 	stwio	r3,0(r2)
81109f88:	00000306 	br	81109f98 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
81109f8c:	e0bffd17 	ldw	r2,-12(fp)
81109f90:	00c00044 	movi	r3,1
81109f94:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
81109f98:	e0bffc17 	ldw	r2,-16(fp)
81109f9c:	00c00044 	movi	r3,1
81109fa0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
81109fa4:	01000044 	movi	r4,1
81109fa8:	1132d740 	call	81132d74 <usleep>
    SCL_LOW(clk_base); // clock low
81109fac:	e0bffc17 	ldw	r2,-16(fp)
81109fb0:	0007883a 	mov	r3,zero
81109fb4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109fb8:	01000044 	movi	r4,1
81109fbc:	1132d740 	call	81132d74 <usleep>
    SDA_LOW(data_base);  // data low
81109fc0:	e0bffd17 	ldw	r2,-12(fp)
81109fc4:	0007883a 	mov	r3,zero
81109fc8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
81109fcc:	01000044 	movi	r4,1
81109fd0:	1132d740 	call	81132d74 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
81109fd4:	e0bffe17 	ldw	r2,-8(fp)
81109fd8:	e0fffa03 	ldbu	r3,-24(fp)
81109fdc:	10c00005 	stb	r3,0(r2)
}
81109fe0:	0001883a 	nop
81109fe4:	e037883a 	mov	sp,fp
81109fe8:	dfc00117 	ldw	ra,4(sp)
81109fec:	df000017 	ldw	fp,0(sp)
81109ff0:	dec00204 	addi	sp,sp,8
81109ff4:	f800283a 	ret

81109ff8 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
81109ff8:	defffd04 	addi	sp,sp,-12
81109ffc:	de00012e 	bgeu	sp,et,8110a004 <bSetBoardLeds+0xc>
8110a000:	003b68fa 	trap	3
8110a004:	df000215 	stw	fp,8(sp)
8110a008:	df000204 	addi	fp,sp,8
8110a00c:	e13ffe15 	stw	r4,-8(fp)
8110a010:	2805883a 	mov	r2,r5
8110a014:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110a018:	e0bffe17 	ldw	r2,-8(fp)
8110a01c:	10800058 	cmpnei	r2,r2,1
8110a020:	1000071e 	bne	r2,zero,8110a040 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110a024:	e0bfff03 	ldbu	r2,-4(fp)
8110a028:	0084303a 	nor	r2,zero,r2
8110a02c:	1007883a 	mov	r3,r2
8110a030:	d0a04e03 	ldbu	r2,-32456(gp)
8110a034:	1884703a 	and	r2,r3,r2
8110a038:	d0a04e05 	stb	r2,-32456(gp)
8110a03c:	00000406 	br	8110a050 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110a040:	d0e04e03 	ldbu	r3,-32456(gp)
8110a044:	e0bfff03 	ldbu	r2,-4(fp)
8110a048:	1884b03a 	or	r2,r3,r2
8110a04c:	d0a04e05 	stb	r2,-32456(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110a050:	d0a04e03 	ldbu	r2,-32456(gp)
8110a054:	10c03fcc 	andi	r3,r2,255
8110a058:	00a00034 	movhi	r2,32768
8110a05c:	10827404 	addi	r2,r2,2512
8110a060:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110a064:	00800044 	movi	r2,1
}
8110a068:	e037883a 	mov	sp,fp
8110a06c:	df000017 	ldw	fp,0(sp)
8110a070:	dec00104 	addi	sp,sp,4
8110a074:	f800283a 	ret

8110a078 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110a078:	defffd04 	addi	sp,sp,-12
8110a07c:	de00012e 	bgeu	sp,et,8110a084 <bSetPainelLeds+0xc>
8110a080:	003b68fa 	trap	3
8110a084:	df000215 	stw	fp,8(sp)
8110a088:	df000204 	addi	fp,sp,8
8110a08c:	e13ffe15 	stw	r4,-8(fp)
8110a090:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110a094:	e0bffe17 	ldw	r2,-8(fp)
8110a098:	10800058 	cmpnei	r2,r2,1
8110a09c:	1000051e 	bne	r2,zero,8110a0b4 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110a0a0:	d0e00217 	ldw	r3,-32760(gp)
8110a0a4:	e0bfff17 	ldw	r2,-4(fp)
8110a0a8:	1884b03a 	or	r2,r3,r2
8110a0ac:	d0a00215 	stw	r2,-32760(gp)
8110a0b0:	00000506 	br	8110a0c8 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110a0b4:	e0bfff17 	ldw	r2,-4(fp)
8110a0b8:	0086303a 	nor	r3,zero,r2
8110a0bc:	d0a00217 	ldw	r2,-32760(gp)
8110a0c0:	1884703a 	and	r2,r3,r2
8110a0c4:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110a0c8:	d0a00217 	ldw	r2,-32760(gp)
8110a0cc:	1007883a 	mov	r3,r2
8110a0d0:	00a00034 	movhi	r2,32768
8110a0d4:	10824004 	addi	r2,r2,2304
8110a0d8:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110a0dc:	00800044 	movi	r2,1
}
8110a0e0:	e037883a 	mov	sp,fp
8110a0e4:	df000017 	ldw	fp,0(sp)
8110a0e8:	dec00104 	addi	sp,sp,4
8110a0ec:	f800283a 	ret

8110a0f0 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110a0f0:	defffc04 	addi	sp,sp,-16
8110a0f4:	de00012e 	bgeu	sp,et,8110a0fc <msgdma_write_extended_descriptor+0xc>
8110a0f8:	003b68fa 	trap	3
8110a0fc:	df000315 	stw	fp,12(sp)
8110a100:	df000304 	addi	fp,sp,12
8110a104:	e13ffd15 	stw	r4,-12(fp)
8110a108:	e17ffe15 	stw	r5,-8(fp)
8110a10c:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110a110:	e0bffd17 	ldw	r2,-12(fp)
8110a114:	10800037 	ldwio	r2,0(r2)
8110a118:	1080010c 	andi	r2,r2,4
8110a11c:	10000226 	beq	r2,zero,8110a128 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110a120:	00bff904 	movi	r2,-28
8110a124:	00003d06 	br	8110a21c <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110a128:	e0bfff17 	ldw	r2,-4(fp)
8110a12c:	10800017 	ldw	r2,0(r2)
8110a130:	1007883a 	mov	r3,r2
8110a134:	e0bffe17 	ldw	r2,-8(fp)
8110a138:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110a13c:	e0bffe17 	ldw	r2,-8(fp)
8110a140:	10800104 	addi	r2,r2,4
8110a144:	e0ffff17 	ldw	r3,-4(fp)
8110a148:	18c00117 	ldw	r3,4(r3)
8110a14c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110a150:	e0bffe17 	ldw	r2,-8(fp)
8110a154:	10800204 	addi	r2,r2,8
8110a158:	e0ffff17 	ldw	r3,-4(fp)
8110a15c:	18c00217 	ldw	r3,8(r3)
8110a160:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110a164:	e0bffe17 	ldw	r2,-8(fp)
8110a168:	10800304 	addi	r2,r2,12
8110a16c:	e0ffff17 	ldw	r3,-4(fp)
8110a170:	18c0030b 	ldhu	r3,12(r3)
8110a174:	18ffffcc 	andi	r3,r3,65535
8110a178:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110a17c:	e0bffe17 	ldw	r2,-8(fp)
8110a180:	10800384 	addi	r2,r2,14
8110a184:	e0ffff17 	ldw	r3,-4(fp)
8110a188:	18c00383 	ldbu	r3,14(r3)
8110a18c:	18c03fcc 	andi	r3,r3,255
8110a190:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110a194:	e0bffe17 	ldw	r2,-8(fp)
8110a198:	108003c4 	addi	r2,r2,15
8110a19c:	e0ffff17 	ldw	r3,-4(fp)
8110a1a0:	18c003c3 	ldbu	r3,15(r3)
8110a1a4:	18c03fcc 	andi	r3,r3,255
8110a1a8:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110a1ac:	e0bffe17 	ldw	r2,-8(fp)
8110a1b0:	10800404 	addi	r2,r2,16
8110a1b4:	e0ffff17 	ldw	r3,-4(fp)
8110a1b8:	18c0040b 	ldhu	r3,16(r3)
8110a1bc:	18ffffcc 	andi	r3,r3,65535
8110a1c0:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110a1c4:	e0bffe17 	ldw	r2,-8(fp)
8110a1c8:	10800484 	addi	r2,r2,18
8110a1cc:	e0ffff17 	ldw	r3,-4(fp)
8110a1d0:	18c0048b 	ldhu	r3,18(r3)
8110a1d4:	18ffffcc 	andi	r3,r3,65535
8110a1d8:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110a1dc:	e0bffe17 	ldw	r2,-8(fp)
8110a1e0:	10800504 	addi	r2,r2,20
8110a1e4:	e0ffff17 	ldw	r3,-4(fp)
8110a1e8:	18c00517 	ldw	r3,20(r3)
8110a1ec:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110a1f0:	e0bffe17 	ldw	r2,-8(fp)
8110a1f4:	10800604 	addi	r2,r2,24
8110a1f8:	e0ffff17 	ldw	r3,-4(fp)
8110a1fc:	18c00617 	ldw	r3,24(r3)
8110a200:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110a204:	e0bffe17 	ldw	r2,-8(fp)
8110a208:	10800704 	addi	r2,r2,28
8110a20c:	e0ffff17 	ldw	r3,-4(fp)
8110a210:	18c00717 	ldw	r3,28(r3)
8110a214:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110a218:	0005883a 	mov	r2,zero
}
8110a21c:	e037883a 	mov	sp,fp
8110a220:	df000017 	ldw	fp,0(sp)
8110a224:	dec00104 	addi	sp,sp,4
8110a228:	f800283a 	ret

8110a22c <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110a22c:	defff604 	addi	sp,sp,-40
8110a230:	de00012e 	bgeu	sp,et,8110a238 <msgdma_construct_extended_descriptor+0xc>
8110a234:	003b68fa 	trap	3
8110a238:	df000915 	stw	fp,36(sp)
8110a23c:	df000904 	addi	fp,sp,36
8110a240:	e13ff715 	stw	r4,-36(fp)
8110a244:	e17ff815 	stw	r5,-32(fp)
8110a248:	e1bff915 	stw	r6,-28(fp)
8110a24c:	e1fffa15 	stw	r7,-24(fp)
8110a250:	e1800517 	ldw	r6,20(fp)
8110a254:	e1400617 	ldw	r5,24(fp)
8110a258:	e1000717 	ldw	r4,28(fp)
8110a25c:	e0c00817 	ldw	r3,32(fp)
8110a260:	e0800917 	ldw	r2,36(fp)
8110a264:	e1bffb0d 	sth	r6,-20(fp)
8110a268:	e17ffc05 	stb	r5,-16(fp)
8110a26c:	e13ffd05 	stb	r4,-12(fp)
8110a270:	e0fffe0d 	sth	r3,-8(fp)
8110a274:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110a278:	e0bff717 	ldw	r2,-36(fp)
8110a27c:	10c01217 	ldw	r3,72(r2)
8110a280:	e0800117 	ldw	r2,4(fp)
8110a284:	18801936 	bltu	r3,r2,8110a2ec <msgdma_construct_extended_descriptor+0xc0>
8110a288:	e13ff717 	ldw	r4,-36(fp)
8110a28c:	20801317 	ldw	r2,76(r4)
8110a290:	20c01417 	ldw	r3,80(r4)
8110a294:	e13ffe0b 	ldhu	r4,-8(fp)
8110a298:	213fffcc 	andi	r4,r4,65535
8110a29c:	2015883a 	mov	r10,r4
8110a2a0:	0017883a 	mov	r11,zero
8110a2a4:	1ac01136 	bltu	r3,r11,8110a2ec <msgdma_construct_extended_descriptor+0xc0>
8110a2a8:	58c0011e 	bne	r11,r3,8110a2b0 <msgdma_construct_extended_descriptor+0x84>
8110a2ac:	12800f36 	bltu	r2,r10,8110a2ec <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110a2b0:	e13ff717 	ldw	r4,-36(fp)
8110a2b4:	20801317 	ldw	r2,76(r4)
8110a2b8:	20c01417 	ldw	r3,80(r4)
8110a2bc:	e13fff0b 	ldhu	r4,-4(fp)
8110a2c0:	213fffcc 	andi	r4,r4,65535
8110a2c4:	2011883a 	mov	r8,r4
8110a2c8:	0013883a 	mov	r9,zero
8110a2cc:	1a400736 	bltu	r3,r9,8110a2ec <msgdma_construct_extended_descriptor+0xc0>
8110a2d0:	48c0011e 	bne	r9,r3,8110a2d8 <msgdma_construct_extended_descriptor+0xac>
8110a2d4:	12000536 	bltu	r2,r8,8110a2ec <msgdma_construct_extended_descriptor+0xc0>
8110a2d8:	e0bff717 	ldw	r2,-36(fp)
8110a2dc:	10801703 	ldbu	r2,92(r2)
8110a2e0:	10803fcc 	andi	r2,r2,255
8110a2e4:	10800060 	cmpeqi	r2,r2,1
8110a2e8:	1000021e 	bne	r2,zero,8110a2f4 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110a2ec:	00bffa84 	movi	r2,-22
8110a2f0:	00002306 	br	8110a380 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110a2f4:	e0bff817 	ldw	r2,-32(fp)
8110a2f8:	e0fff917 	ldw	r3,-28(fp)
8110a2fc:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110a300:	e0bff817 	ldw	r2,-32(fp)
8110a304:	e0fffa17 	ldw	r3,-24(fp)
8110a308:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110a30c:	e0bff817 	ldw	r2,-32(fp)
8110a310:	e0c00117 	ldw	r3,4(fp)
8110a314:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110a318:	e0bff817 	ldw	r2,-32(fp)
8110a31c:	e0fffb0b 	ldhu	r3,-20(fp)
8110a320:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110a324:	e0bff817 	ldw	r2,-32(fp)
8110a328:	e0fffc03 	ldbu	r3,-16(fp)
8110a32c:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110a330:	e0bff817 	ldw	r2,-32(fp)
8110a334:	e0fffd03 	ldbu	r3,-12(fp)
8110a338:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110a33c:	e0bff817 	ldw	r2,-32(fp)
8110a340:	e0fffe0b 	ldhu	r3,-8(fp)
8110a344:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110a348:	e0bff817 	ldw	r2,-32(fp)
8110a34c:	e0ffff0b 	ldhu	r3,-4(fp)
8110a350:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110a354:	e0bff817 	ldw	r2,-32(fp)
8110a358:	e0c00317 	ldw	r3,12(fp)
8110a35c:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110a360:	e0bff817 	ldw	r2,-32(fp)
8110a364:	e0c00417 	ldw	r3,16(fp)
8110a368:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110a36c:	e0800217 	ldw	r2,8(fp)
8110a370:	10e00034 	orhi	r3,r2,32768
8110a374:	e0bff817 	ldw	r2,-32(fp)
8110a378:	10c00715 	stw	r3,28(r2)

	return 0;
8110a37c:	0005883a 	mov	r2,zero

}
8110a380:	e037883a 	mov	sp,fp
8110a384:	df000017 	ldw	fp,0(sp)
8110a388:	dec00104 	addi	sp,sp,4
8110a38c:	f800283a 	ret

8110a390 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a390:	deffee04 	addi	sp,sp,-72
8110a394:	de00012e 	bgeu	sp,et,8110a39c <msgdma_descriptor_async_transfer+0xc>
8110a398:	003b68fa 	trap	3
8110a39c:	dfc01115 	stw	ra,68(sp)
8110a3a0:	df001015 	stw	fp,64(sp)
8110a3a4:	df001004 	addi	fp,sp,64
8110a3a8:	e13ffd15 	stw	r4,-12(fp)
8110a3ac:	e17ffe15 	stw	r5,-8(fp)
8110a3b0:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a3b4:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110a3b8:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110a3bc:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a3c0:	e0bffd17 	ldw	r2,-12(fp)
8110a3c4:	10800317 	ldw	r2,12(r2)
8110a3c8:	10800204 	addi	r2,r2,8
8110a3cc:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a3d0:	10bfffcc 	andi	r2,r2,65535
8110a3d4:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a3d8:	e0bffd17 	ldw	r2,-12(fp)
8110a3dc:	10800317 	ldw	r2,12(r2)
8110a3e0:	10800204 	addi	r2,r2,8
8110a3e4:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a3e8:	1004d43a 	srli	r2,r2,16
8110a3ec:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a3f0:	e0bffd17 	ldw	r2,-12(fp)
8110a3f4:	10800917 	ldw	r2,36(r2)
8110a3f8:	e0fff417 	ldw	r3,-48(fp)
8110a3fc:	1880042e 	bgeu	r3,r2,8110a410 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a400:	e0bffd17 	ldw	r2,-12(fp)
8110a404:	10800917 	ldw	r2,36(r2)
8110a408:	e0fff317 	ldw	r3,-52(fp)
8110a40c:	18800236 	bltu	r3,r2,8110a418 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110a410:	00bff904 	movi	r2,-28
8110a414:	00009f06 	br	8110a694 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a418:	e0bffd17 	ldw	r2,-12(fp)
8110a41c:	10801817 	ldw	r2,96(r2)
8110a420:	e0bff615 	stw	r2,-40(fp)
8110a424:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110a428:	e0bffc0b 	ldhu	r2,-16(fp)
8110a42c:	e0fffc84 	addi	r3,fp,-14
8110a430:	180d883a 	mov	r6,r3
8110a434:	100b883a 	mov	r5,r2
8110a438:	e13ff617 	ldw	r4,-40(fp)
8110a43c:	1139b780 	call	81139b78 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110a440:	00800804 	movi	r2,32
8110a444:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a448:	0005303a 	rdctl	r2,status
8110a44c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a450:	e0fff717 	ldw	r3,-36(fp)
8110a454:	00bfff84 	movi	r2,-2
8110a458:	1884703a 	and	r2,r3,r2
8110a45c:	1001703a 	wrctl	status,r2
  
  return context;
8110a460:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a464:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a468:	e0bffd17 	ldw	r2,-12(fp)
8110a46c:	10800317 	ldw	r2,12(r2)
8110a470:	10800104 	addi	r2,r2,4
8110a474:	e0fff117 	ldw	r3,-60(fp)
8110a478:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a47c:	e0bffd17 	ldw	r2,-12(fp)
8110a480:	10800317 	ldw	r2,12(r2)
8110a484:	e0fffd17 	ldw	r3,-12(fp)
8110a488:	18c00317 	ldw	r3,12(r3)
8110a48c:	18c00037 	ldwio	r3,0(r3)
8110a490:	10c00035 	stwio	r3,0(r2)
8110a494:	e0bff217 	ldw	r2,-56(fp)
8110a498:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a49c:	e0bffb17 	ldw	r2,-20(fp)
8110a4a0:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110a4a4:	e0bffe17 	ldw	r2,-8(fp)
8110a4a8:	10001026 	beq	r2,zero,8110a4ec <msgdma_descriptor_async_transfer+0x15c>
8110a4ac:	e0bfff17 	ldw	r2,-4(fp)
8110a4b0:	10000e1e 	bne	r2,zero,8110a4ec <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110a4b4:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a4b8:	d0a05c17 	ldw	r2,-32400(gp)
8110a4bc:	100f883a 	mov	r7,r2
8110a4c0:	01800784 	movi	r6,30
8110a4c4:	01400044 	movi	r5,1
8110a4c8:	01204534 	movhi	r4,33044
8110a4cc:	211cc004 	addi	r4,r4,29440
8110a4d0:	111c1380 	call	8111c138 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a4d4:	e0bffd17 	ldw	r2,-12(fp)
8110a4d8:	10801817 	ldw	r2,96(r2)
8110a4dc:	1009883a 	mov	r4,r2
8110a4e0:	1139f000 	call	81139f00 <OSSemPost>

		return -ETIME;
8110a4e4:	00bff084 	movi	r2,-62
8110a4e8:	00006a06 	br	8110a694 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a4ec:	e0bffe17 	ldw	r2,-8(fp)
8110a4f0:	1000231e 	bne	r2,zero,8110a580 <msgdma_descriptor_async_transfer+0x1f0>
8110a4f4:	e0bfff17 	ldw	r2,-4(fp)
8110a4f8:	10002126 	beq	r2,zero,8110a580 <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110a4fc:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a500:	00001506 	br	8110a558 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a504:	01000044 	movi	r4,1
8110a508:	11313000 	call	81131300 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a50c:	e0bff00b 	ldhu	r2,-64(fp)
8110a510:	1084e230 	cmpltui	r2,r2,5000
8110a514:	10000d1e 	bne	r2,zero,8110a54c <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a518:	d0a05c17 	ldw	r2,-32400(gp)
8110a51c:	100f883a 	mov	r7,r2
8110a520:	01801544 	movi	r6,85
8110a524:	01400044 	movi	r5,1
8110a528:	01204534 	movhi	r4,33044
8110a52c:	211cc804 	addi	r4,r4,29472
8110a530:	111c1380 	call	8111c138 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a534:	e0bffd17 	ldw	r2,-12(fp)
8110a538:	10801817 	ldw	r2,96(r2)
8110a53c:	1009883a 	mov	r4,r2
8110a540:	1139f000 	call	81139f00 <OSSemPost>

				return -ETIME;
8110a544:	00bff084 	movi	r2,-62
8110a548:	00005206 	br	8110a694 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110a54c:	e0bff00b 	ldhu	r2,-64(fp)
8110a550:	10800044 	addi	r2,r2,1
8110a554:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a558:	e0bffd17 	ldw	r2,-12(fp)
8110a55c:	10c00317 	ldw	r3,12(r2)
8110a560:	e0bffd17 	ldw	r2,-12(fp)
8110a564:	10800417 	ldw	r2,16(r2)
8110a568:	e1bfff17 	ldw	r6,-4(fp)
8110a56c:	100b883a 	mov	r5,r2
8110a570:	1809883a 	mov	r4,r3
8110a574:	110a0f00 	call	8110a0f0 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a578:	103fe21e 	bne	r2,zero,8110a504 <__reset+0xfb0ea504>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a57c:	00000606 	br	8110a598 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a580:	e0bffd17 	ldw	r2,-12(fp)
8110a584:	10801817 	ldw	r2,96(r2)
8110a588:	1009883a 	mov	r4,r2
8110a58c:	1139f000 	call	81139f00 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a590:	00bfffc4 	movi	r2,-1
8110a594:	00003f06 	br	8110a694 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110a598:	e0bffd17 	ldw	r2,-12(fp)
8110a59c:	10800b17 	ldw	r2,44(r2)
8110a5a0:	10001c26 	beq	r2,zero,8110a614 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110a5a4:	e0bffd17 	ldw	r2,-12(fp)
8110a5a8:	10c00d17 	ldw	r3,52(r2)
8110a5ac:	e0bff117 	ldw	r2,-60(fp)
8110a5b0:	1884b03a 	or	r2,r3,r2
8110a5b4:	10800514 	ori	r2,r2,20
8110a5b8:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110a5bc:	e0fff117 	ldw	r3,-60(fp)
8110a5c0:	00bff7c4 	movi	r2,-33
8110a5c4:	1884703a 	and	r2,r3,r2
8110a5c8:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a5cc:	0005303a 	rdctl	r2,status
8110a5d0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a5d4:	e0fff917 	ldw	r3,-28(fp)
8110a5d8:	00bfff84 	movi	r2,-2
8110a5dc:	1884703a 	and	r2,r3,r2
8110a5e0:	1001703a 	wrctl	status,r2
  
  return context;
8110a5e4:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a5e8:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a5ec:	e0bffd17 	ldw	r2,-12(fp)
8110a5f0:	10800317 	ldw	r2,12(r2)
8110a5f4:	10800104 	addi	r2,r2,4
8110a5f8:	e0fff117 	ldw	r3,-60(fp)
8110a5fc:	10c00035 	stwio	r3,0(r2)
8110a600:	e0bff217 	ldw	r2,-56(fp)
8110a604:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a608:	e0bff517 	ldw	r2,-44(fp)
8110a60c:	1001703a 	wrctl	status,r2
8110a610:	00001b06 	br	8110a680 <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110a614:	e0bffd17 	ldw	r2,-12(fp)
8110a618:	10c00d17 	ldw	r3,52(r2)
8110a61c:	e0bff117 	ldw	r2,-60(fp)
8110a620:	1884b03a 	or	r2,r3,r2
8110a624:	10800114 	ori	r2,r2,4
8110a628:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110a62c:	e0fff117 	ldw	r3,-60(fp)
8110a630:	00bff3c4 	movi	r2,-49
8110a634:	1884703a 	and	r2,r3,r2
8110a638:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a63c:	0005303a 	rdctl	r2,status
8110a640:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a644:	e0fffa17 	ldw	r3,-24(fp)
8110a648:	00bfff84 	movi	r2,-2
8110a64c:	1884703a 	and	r2,r3,r2
8110a650:	1001703a 	wrctl	status,r2
  
  return context;
8110a654:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a658:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a65c:	e0bffd17 	ldw	r2,-12(fp)
8110a660:	10800317 	ldw	r2,12(r2)
8110a664:	10800104 	addi	r2,r2,4
8110a668:	e0fff117 	ldw	r3,-60(fp)
8110a66c:	10c00035 	stwio	r3,0(r2)
8110a670:	e0bff217 	ldw	r2,-56(fp)
8110a674:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a678:	e0bff817 	ldw	r2,-32(fp)
8110a67c:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a680:	e0bffd17 	ldw	r2,-12(fp)
8110a684:	10801817 	ldw	r2,96(r2)
8110a688:	1009883a 	mov	r4,r2
8110a68c:	1139f000 	call	81139f00 <OSSemPost>

	return 0;
8110a690:	0005883a 	mov	r2,zero
}
8110a694:	e037883a 	mov	sp,fp
8110a698:	dfc00117 	ldw	ra,4(sp)
8110a69c:	df000017 	ldw	fp,0(sp)
8110a6a0:	dec00204 	addi	sp,sp,8
8110a6a4:	f800283a 	ret

8110a6a8 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a6a8:	deffee04 	addi	sp,sp,-72
8110a6ac:	de00012e 	bgeu	sp,et,8110a6b4 <msgdma_descriptor_sync_transfer+0xc>
8110a6b0:	003b68fa 	trap	3
8110a6b4:	dfc01115 	stw	ra,68(sp)
8110a6b8:	df001015 	stw	fp,64(sp)
8110a6bc:	df001004 	addi	fp,sp,64
8110a6c0:	e13ffd15 	stw	r4,-12(fp)
8110a6c4:	e17ffe15 	stw	r5,-8(fp)
8110a6c8:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a6cc:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110a6d0:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110a6d4:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110a6d8:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a6dc:	e0bffd17 	ldw	r2,-12(fp)
8110a6e0:	10800317 	ldw	r2,12(r2)
8110a6e4:	10800204 	addi	r2,r2,8
8110a6e8:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a6ec:	10bfffcc 	andi	r2,r2,65535
8110a6f0:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a6f4:	e0bffd17 	ldw	r2,-12(fp)
8110a6f8:	10800317 	ldw	r2,12(r2)
8110a6fc:	10800204 	addi	r2,r2,8
8110a700:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a704:	1004d43a 	srli	r2,r2,16
8110a708:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110a70c:	00807804 	movi	r2,480
8110a710:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a714:	00001d06 	br	8110a78c <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110a718:	01000044 	movi	r4,1
8110a71c:	11313000 	call	81131300 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a720:	e0bff10b 	ldhu	r2,-60(fp)
8110a724:	1084e230 	cmpltui	r2,r2,5000
8110a728:	1000091e 	bne	r2,zero,8110a750 <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a72c:	d0a05c17 	ldw	r2,-32400(gp)
8110a730:	100f883a 	mov	r7,r2
8110a734:	01801304 	movi	r6,76
8110a738:	01400044 	movi	r5,1
8110a73c:	01204534 	movhi	r4,33044
8110a740:	211cde04 	addi	r4,r4,29560
8110a744:	111c1380 	call	8111c138 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110a748:	00bff084 	movi	r2,-62
8110a74c:	0000d006 	br	8110aa90 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a750:	e0bff10b 	ldhu	r2,-60(fp)
8110a754:	10800044 	addi	r2,r2,1
8110a758:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a75c:	e0bffd17 	ldw	r2,-12(fp)
8110a760:	10800317 	ldw	r2,12(r2)
8110a764:	10800204 	addi	r2,r2,8
8110a768:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110a76c:	10bfffcc 	andi	r2,r2,65535
8110a770:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a774:	e0bffd17 	ldw	r2,-12(fp)
8110a778:	10800317 	ldw	r2,12(r2)
8110a77c:	10800204 	addi	r2,r2,8
8110a780:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110a784:	1004d43a 	srli	r2,r2,16
8110a788:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a78c:	e0bffd17 	ldw	r2,-12(fp)
8110a790:	10800917 	ldw	r2,36(r2)
8110a794:	e0fff317 	ldw	r3,-52(fp)
8110a798:	18bfdf2e 	bgeu	r3,r2,8110a718 <__reset+0xfb0ea718>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a79c:	e0bffd17 	ldw	r2,-12(fp)
8110a7a0:	10800917 	ldw	r2,36(r2)
8110a7a4:	e0fff217 	ldw	r3,-56(fp)
8110a7a8:	18bfdb2e 	bgeu	r3,r2,8110a718 <__reset+0xfb0ea718>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a7ac:	e0bffd17 	ldw	r2,-12(fp)
8110a7b0:	10801817 	ldw	r2,96(r2)
8110a7b4:	e0bff815 	stw	r2,-32(fp)
8110a7b8:	e03ffc0d 	sth	zero,-16(fp)
8110a7bc:	e0bffc0b 	ldhu	r2,-16(fp)
8110a7c0:	e0fffc84 	addi	r3,fp,-14
8110a7c4:	180d883a 	mov	r6,r3
8110a7c8:	100b883a 	mov	r5,r2
8110a7cc:	e13ff817 	ldw	r4,-32(fp)
8110a7d0:	1139b780 	call	81139b78 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a7d4:	0005303a 	rdctl	r2,status
8110a7d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a7dc:	e0fffb17 	ldw	r3,-20(fp)
8110a7e0:	00bfff84 	movi	r2,-2
8110a7e4:	1884703a 	and	r2,r3,r2
8110a7e8:	1001703a 	wrctl	status,r2
  
  return context;
8110a7ec:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a7f0:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a7f4:	e0bffd17 	ldw	r2,-12(fp)
8110a7f8:	10800317 	ldw	r2,12(r2)
8110a7fc:	10800104 	addi	r2,r2,4
8110a800:	00c00804 	movi	r3,32
8110a804:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a808:	e0bffd17 	ldw	r2,-12(fp)
8110a80c:	10800317 	ldw	r2,12(r2)
8110a810:	e0fffd17 	ldw	r3,-12(fp)
8110a814:	18c00317 	ldw	r3,12(r3)
8110a818:	18c00037 	ldwio	r3,0(r3)
8110a81c:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110a820:	e0bffe17 	ldw	r2,-8(fp)
8110a824:	10001026 	beq	r2,zero,8110a868 <msgdma_descriptor_sync_transfer+0x1c0>
8110a828:	e0bfff17 	ldw	r2,-4(fp)
8110a82c:	10000e1e 	bne	r2,zero,8110a868 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110a830:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a834:	d0a05c17 	ldw	r2,-32400(gp)
8110a838:	100f883a 	mov	r7,r2
8110a83c:	01800784 	movi	r6,30
8110a840:	01400044 	movi	r5,1
8110a844:	01204534 	movhi	r4,33044
8110a848:	211cc004 	addi	r4,r4,29440
8110a84c:	111c1380 	call	8111c138 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a850:	e0bffd17 	ldw	r2,-12(fp)
8110a854:	10801817 	ldw	r2,96(r2)
8110a858:	1009883a 	mov	r4,r2
8110a85c:	1139f000 	call	81139f00 <OSSemPost>

		return -ETIME;
8110a860:	00bff084 	movi	r2,-62
8110a864:	00008a06 	br	8110aa90 <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a868:	e0bffe17 	ldw	r2,-8(fp)
8110a86c:	1000231e 	bne	r2,zero,8110a8fc <msgdma_descriptor_sync_transfer+0x254>
8110a870:	e0bfff17 	ldw	r2,-4(fp)
8110a874:	10002126 	beq	r2,zero,8110a8fc <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110a878:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a87c:	00001506 	br	8110a8d4 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a880:	01000044 	movi	r4,1
8110a884:	11313000 	call	81131300 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a888:	e0bff10b 	ldhu	r2,-60(fp)
8110a88c:	1084e230 	cmpltui	r2,r2,5000
8110a890:	10000d1e 	bne	r2,zero,8110a8c8 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a894:	d0a05c17 	ldw	r2,-32400(gp)
8110a898:	100f883a 	mov	r7,r2
8110a89c:	01801004 	movi	r6,64
8110a8a0:	01400044 	movi	r5,1
8110a8a4:	01204534 	movhi	r4,33044
8110a8a8:	211cf204 	addi	r4,r4,29640
8110a8ac:	111c1380 	call	8111c138 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a8b0:	e0bffd17 	ldw	r2,-12(fp)
8110a8b4:	10801817 	ldw	r2,96(r2)
8110a8b8:	1009883a 	mov	r4,r2
8110a8bc:	1139f000 	call	81139f00 <OSSemPost>

				return -ETIME;
8110a8c0:	00bff084 	movi	r2,-62
8110a8c4:	00007206 	br	8110aa90 <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110a8c8:	e0bff10b 	ldhu	r2,-60(fp)
8110a8cc:	10800044 	addi	r2,r2,1
8110a8d0:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a8d4:	e0bffd17 	ldw	r2,-12(fp)
8110a8d8:	10c00317 	ldw	r3,12(r2)
8110a8dc:	e0bffd17 	ldw	r2,-12(fp)
8110a8e0:	10800417 	ldw	r2,16(r2)
8110a8e4:	e1bfff17 	ldw	r6,-4(fp)
8110a8e8:	100b883a 	mov	r5,r2
8110a8ec:	1809883a 	mov	r4,r3
8110a8f0:	110a0f00 	call	8110a0f0 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a8f4:	103fe21e 	bne	r2,zero,8110a880 <__reset+0xfb0ea880>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a8f8:	00000606 	br	8110a914 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a8fc:	e0bffd17 	ldw	r2,-12(fp)
8110a900:	10801817 	ldw	r2,96(r2)
8110a904:	1009883a 	mov	r4,r2
8110a908:	1139f000 	call	81139f00 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a90c:	00bfffc4 	movi	r2,-1
8110a910:	00005f06 	br	8110aa90 <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a914:	e0bffd17 	ldw	r2,-12(fp)
8110a918:	10800317 	ldw	r2,12(r2)
8110a91c:	10800104 	addi	r2,r2,4
8110a920:	e0fffd17 	ldw	r3,-12(fp)
8110a924:	19000d17 	ldw	r4,52(r3)
8110a928:	00fff2c4 	movi	r3,-53
8110a92c:	20c6703a 	and	r3,r4,r3
8110a930:	18c00114 	ori	r3,r3,4
8110a934:	10c00035 	stwio	r3,0(r2)
8110a938:	e0bff517 	ldw	r2,-44(fp)
8110a93c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a940:	e0bff717 	ldw	r2,-36(fp)
8110a944:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110a948:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110a94c:	e0bffd17 	ldw	r2,-12(fp)
8110a950:	10800317 	ldw	r2,12(r2)
8110a954:	10800037 	ldwio	r2,0(r2)
8110a958:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110a95c:	00001906 	br	8110a9c4 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110a960:	01000044 	movi	r4,1
8110a964:	11313000 	call	81131300 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a968:	e0bff10b 	ldhu	r2,-60(fp)
8110a96c:	1084e230 	cmpltui	r2,r2,5000
8110a970:	10000d1e 	bne	r2,zero,8110a9a8 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a974:	d0a05c17 	ldw	r2,-32400(gp)
8110a978:	100f883a 	mov	r7,r2
8110a97c:	01801184 	movi	r6,70
8110a980:	01400044 	movi	r5,1
8110a984:	01204534 	movhi	r4,33044
8110a988:	211d0304 	addi	r4,r4,29708
8110a98c:	111c1380 	call	8111c138 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110a990:	e0bffd17 	ldw	r2,-12(fp)
8110a994:	10801817 	ldw	r2,96(r2)
8110a998:	1009883a 	mov	r4,r2
8110a99c:	1139f000 	call	81139f00 <OSSemPost>

			return -ETIME;
8110a9a0:	00bff084 	movi	r2,-62
8110a9a4:	00003a06 	br	8110aa90 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a9a8:	e0bff10b 	ldhu	r2,-60(fp)
8110a9ac:	10800044 	addi	r2,r2,1
8110a9b0:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110a9b4:	e0bffd17 	ldw	r2,-12(fp)
8110a9b8:	10800317 	ldw	r2,12(r2)
8110a9bc:	10800037 	ldwio	r2,0(r2)
8110a9c0:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110a9c4:	e0fff017 	ldw	r3,-64(fp)
8110a9c8:	e0bff617 	ldw	r2,-40(fp)
8110a9cc:	1884703a 	and	r2,r3,r2
8110a9d0:	1000031e 	bne	r2,zero,8110a9e0 <msgdma_descriptor_sync_transfer+0x338>
8110a9d4:	e0bff017 	ldw	r2,-64(fp)
8110a9d8:	1080004c 	andi	r2,r2,1
8110a9dc:	103fe01e 	bne	r2,zero,8110a960 <__reset+0xfb0ea960>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110a9e0:	e0fff017 	ldw	r3,-64(fp)
8110a9e4:	e0bff617 	ldw	r2,-40(fp)
8110a9e8:	1884703a 	and	r2,r3,r2
8110a9ec:	10000626 	beq	r2,zero,8110aa08 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a9f0:	e0bffd17 	ldw	r2,-12(fp)
8110a9f4:	10801817 	ldw	r2,96(r2)
8110a9f8:	1009883a 	mov	r4,r2
8110a9fc:	1139f000 	call	81139f00 <OSSemPost>

		return error;
8110aa00:	e0bff617 	ldw	r2,-40(fp)
8110aa04:	00002206 	br	8110aa90 <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110aa08:	e0bffd17 	ldw	r2,-12(fp)
8110aa0c:	10800317 	ldw	r2,12(r2)
8110aa10:	10800104 	addi	r2,r2,4
8110aa14:	10800037 	ldwio	r2,0(r2)
8110aa18:	10800814 	ori	r2,r2,32
8110aa1c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110aa20:	0005303a 	rdctl	r2,status
8110aa24:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110aa28:	e0fffa17 	ldw	r3,-24(fp)
8110aa2c:	00bfff84 	movi	r2,-2
8110aa30:	1884703a 	and	r2,r3,r2
8110aa34:	1001703a 	wrctl	status,r2
  
  return context;
8110aa38:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110aa3c:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110aa40:	e0bffd17 	ldw	r2,-12(fp)
8110aa44:	10800317 	ldw	r2,12(r2)
8110aa48:	10800104 	addi	r2,r2,4
8110aa4c:	e0fff417 	ldw	r3,-48(fp)
8110aa50:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110aa54:	e0bffd17 	ldw	r2,-12(fp)
8110aa58:	10800317 	ldw	r2,12(r2)
8110aa5c:	e0fffd17 	ldw	r3,-12(fp)
8110aa60:	18c00317 	ldw	r3,12(r3)
8110aa64:	18c00037 	ldwio	r3,0(r3)
8110aa68:	10c00035 	stwio	r3,0(r2)
8110aa6c:	e0bff517 	ldw	r2,-44(fp)
8110aa70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110aa74:	e0bff917 	ldw	r2,-28(fp)
8110aa78:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110aa7c:	e0bffd17 	ldw	r2,-12(fp)
8110aa80:	10801817 	ldw	r2,96(r2)
8110aa84:	1009883a 	mov	r4,r2
8110aa88:	1139f000 	call	81139f00 <OSSemPost>

	return 0;
8110aa8c:	0005883a 	mov	r2,zero

}
8110aa90:	e037883a 	mov	sp,fp
8110aa94:	dfc00117 	ldw	ra,4(sp)
8110aa98:	df000017 	ldw	fp,0(sp)
8110aa9c:	dec00204 	addi	sp,sp,8
8110aaa0:	f800283a 	ret

8110aaa4 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110aaa4:	deffec04 	addi	sp,sp,-80
8110aaa8:	de00012e 	bgeu	sp,et,8110aab0 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110aaac:	003b68fa 	trap	3
8110aab0:	dfc01315 	stw	ra,76(sp)
8110aab4:	df001215 	stw	fp,72(sp)
8110aab8:	df001204 	addi	fp,sp,72
8110aabc:	e13ff715 	stw	r4,-36(fp)
8110aac0:	e17ff815 	stw	r5,-32(fp)
8110aac4:	e1bff915 	stw	r6,-28(fp)
8110aac8:	e1fffa15 	stw	r7,-24(fp)
8110aacc:	e1800617 	ldw	r6,24(fp)
8110aad0:	e1400717 	ldw	r5,28(fp)
8110aad4:	e1000817 	ldw	r4,32(fp)
8110aad8:	e0c00917 	ldw	r3,36(fp)
8110aadc:	e0800a17 	ldw	r2,40(fp)
8110aae0:	e1bffb0d 	sth	r6,-20(fp)
8110aae4:	e17ffc05 	stb	r5,-16(fp)
8110aae8:	e13ffd05 	stb	r4,-12(fp)
8110aaec:	e0fffe0d 	sth	r3,-8(fp)
8110aaf0:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110aaf4:	e0bffb0b 	ldhu	r2,-20(fp)
8110aaf8:	e0fffc03 	ldbu	r3,-16(fp)
8110aafc:	e13ffd03 	ldbu	r4,-12(fp)
8110ab00:	e17ffe0b 	ldhu	r5,-8(fp)
8110ab04:	e1bfff0b 	ldhu	r6,-4(fp)
8110ab08:	d9800815 	stw	r6,32(sp)
8110ab0c:	d9400715 	stw	r5,28(sp)
8110ab10:	d9000615 	stw	r4,24(sp)
8110ab14:	d8c00515 	stw	r3,20(sp)
8110ab18:	d8800415 	stw	r2,16(sp)
8110ab1c:	e0800517 	ldw	r2,20(fp)
8110ab20:	d8800315 	stw	r2,12(sp)
8110ab24:	e0800417 	ldw	r2,16(fp)
8110ab28:	d8800215 	stw	r2,8(sp)
8110ab2c:	e0800317 	ldw	r2,12(fp)
8110ab30:	d8800115 	stw	r2,4(sp)
8110ab34:	e0800217 	ldw	r2,8(fp)
8110ab38:	d8800015 	stw	r2,0(sp)
8110ab3c:	e1fffa17 	ldw	r7,-24(fp)
8110ab40:	e1bff917 	ldw	r6,-28(fp)
8110ab44:	e17ff817 	ldw	r5,-32(fp)
8110ab48:	e13ff717 	ldw	r4,-36(fp)
8110ab4c:	110a22c0 	call	8110a22c <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110ab50:	e037883a 	mov	sp,fp
8110ab54:	dfc00117 	ldw	ra,4(sp)
8110ab58:	df000017 	ldw	fp,0(sp)
8110ab5c:	dec00204 	addi	sp,sp,8
8110ab60:	f800283a 	ret

8110ab64 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110ab64:	defffc04 	addi	sp,sp,-16
8110ab68:	de00012e 	bgeu	sp,et,8110ab70 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110ab6c:	003b68fa 	trap	3
8110ab70:	dfc00315 	stw	ra,12(sp)
8110ab74:	df000215 	stw	fp,8(sp)
8110ab78:	df000204 	addi	fp,sp,8
8110ab7c:	e13ffe15 	stw	r4,-8(fp)
8110ab80:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110ab84:	e1bfff17 	ldw	r6,-4(fp)
8110ab88:	000b883a 	mov	r5,zero
8110ab8c:	e13ffe17 	ldw	r4,-8(fp)
8110ab90:	110a3900 	call	8110a390 <msgdma_descriptor_async_transfer>
}
8110ab94:	e037883a 	mov	sp,fp
8110ab98:	dfc00117 	ldw	ra,4(sp)
8110ab9c:	df000017 	ldw	fp,0(sp)
8110aba0:	dec00204 	addi	sp,sp,8
8110aba4:	f800283a 	ret

8110aba8 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110aba8:	defffc04 	addi	sp,sp,-16
8110abac:	de00012e 	bgeu	sp,et,8110abb4 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110abb0:	003b68fa 	trap	3
8110abb4:	dfc00315 	stw	ra,12(sp)
8110abb8:	df000215 	stw	fp,8(sp)
8110abbc:	df000204 	addi	fp,sp,8
8110abc0:	e13ffe15 	stw	r4,-8(fp)
8110abc4:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110abc8:	e1bfff17 	ldw	r6,-4(fp)
8110abcc:	000b883a 	mov	r5,zero
8110abd0:	e13ffe17 	ldw	r4,-8(fp)
8110abd4:	110a6a80 	call	8110a6a8 <msgdma_descriptor_sync_transfer>
}
8110abd8:	e037883a 	mov	sp,fp
8110abdc:	dfc00117 	ldw	ra,4(sp)
8110abe0:	df000017 	ldw	fp,0(sp)
8110abe4:	dec00204 	addi	sp,sp,8
8110abe8:	f800283a 	ret

8110abec <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110abec:	defff204 	addi	sp,sp,-56
8110abf0:	de00012e 	bgeu	sp,et,8110abf8 <POWER_SPI_RW+0xc>
8110abf4:	003b68fa 	trap	3
8110abf8:	dfc00d15 	stw	ra,52(sp)
8110abfc:	df000c15 	stw	fp,48(sp)
8110ac00:	df000c04 	addi	fp,sp,48
8110ac04:	2007883a 	mov	r3,r4
8110ac08:	2805883a 	mov	r2,r5
8110ac0c:	e1bffe15 	stw	r6,-8(fp)
8110ac10:	e1ffff15 	stw	r7,-4(fp)
8110ac14:	e0fffc05 	stb	r3,-16(fp)
8110ac18:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110ac1c:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110ac20:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110ac24:	008003f4 	movhi	r2,15
8110ac28:	10909004 	addi	r2,r2,16960
8110ac2c:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110ac30:	00bfe004 	movi	r2,-128
8110ac34:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110ac38:	e0bffe17 	ldw	r2,-8(fp)
8110ac3c:	10000226 	beq	r2,zero,8110ac48 <POWER_SPI_RW+0x5c>
8110ac40:	00800804 	movi	r2,32
8110ac44:	00000106 	br	8110ac4c <POWER_SPI_RW+0x60>
8110ac48:	0005883a 	mov	r2,zero
8110ac4c:	e0fff403 	ldbu	r3,-48(fp)
8110ac50:	10c4b03a 	or	r2,r2,r3
8110ac54:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110ac58:	e0800217 	ldw	r2,8(fp)
8110ac5c:	10000226 	beq	r2,zero,8110ac68 <POWER_SPI_RW+0x7c>
8110ac60:	00800404 	movi	r2,16
8110ac64:	00000106 	br	8110ac6c <POWER_SPI_RW+0x80>
8110ac68:	0005883a 	mov	r2,zero
8110ac6c:	e0fff403 	ldbu	r3,-48(fp)
8110ac70:	10c4b03a 	or	r2,r2,r3
8110ac74:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110ac78:	e0bfff17 	ldw	r2,-4(fp)
8110ac7c:	10000226 	beq	r2,zero,8110ac88 <POWER_SPI_RW+0x9c>
8110ac80:	00800204 	movi	r2,8
8110ac84:	00000106 	br	8110ac8c <POWER_SPI_RW+0xa0>
8110ac88:	0005883a 	mov	r2,zero
8110ac8c:	e0fff403 	ldbu	r3,-48(fp)
8110ac90:	10c4b03a 	or	r2,r2,r3
8110ac94:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110ac98:	e0bffd03 	ldbu	r2,-12(fp)
8110ac9c:	108001cc 	andi	r2,r2,7
8110aca0:	1007883a 	mov	r3,r2
8110aca4:	e0bff403 	ldbu	r2,-48(fp)
8110aca8:	1884b03a 	or	r2,r3,r2
8110acac:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110acb0:	0007883a 	mov	r3,zero
8110acb4:	00a00034 	movhi	r2,32768
8110acb8:	10824404 	addi	r2,r2,2320
8110acbc:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110acc0:	0007883a 	mov	r3,zero
8110acc4:	00a00034 	movhi	r2,32768
8110acc8:	10824c04 	addi	r2,r2,2352
8110accc:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110acd0:	e0bffc03 	ldbu	r2,-16(fp)
8110acd4:	1000021e 	bne	r2,zero,8110ace0 <POWER_SPI_RW+0xf4>
8110acd8:	00c00084 	movi	r3,2
8110acdc:	00000106 	br	8110ace4 <POWER_SPI_RW+0xf8>
8110ace0:	00c00044 	movi	r3,1
8110ace4:	00a00034 	movhi	r2,32768
8110ace8:	10824804 	addi	r2,r2,2336
8110acec:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110acf0:	010003c4 	movi	r4,15
8110acf4:	1132d740 	call	81132d74 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110acf8:	00000306 	br	8110ad08 <POWER_SPI_RW+0x11c>
		nWait++;
8110acfc:	e0bff817 	ldw	r2,-32(fp)
8110ad00:	10800044 	addi	r2,r2,1
8110ad04:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ad08:	00a00034 	movhi	r2,32768
8110ad0c:	10825404 	addi	r2,r2,2384
8110ad10:	10800037 	ldwio	r2,0(r2)
8110ad14:	1080004c 	andi	r2,r2,1
8110ad18:	10000326 	beq	r2,zero,8110ad28 <POWER_SPI_RW+0x13c>
8110ad1c:	e0fff817 	ldw	r3,-32(fp)
8110ad20:	e0bffa17 	ldw	r2,-24(fp)
8110ad24:	18bff516 	blt	r3,r2,8110acfc <__reset+0xfb0eacfc>
		nWait++;
	}

	if (SPI_SDO) {
8110ad28:	00a00034 	movhi	r2,32768
8110ad2c:	10825404 	addi	r2,r2,2384
8110ad30:	10800037 	ldwio	r2,0(r2)
8110ad34:	1080004c 	andi	r2,r2,1
8110ad38:	10000626 	beq	r2,zero,8110ad54 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110ad3c:	00c000c4 	movi	r3,3
8110ad40:	00a00034 	movhi	r2,32768
8110ad44:	10824804 	addi	r2,r2,2336
8110ad48:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110ad4c:	0005883a 	mov	r2,zero
8110ad50:	0000db06 	br	8110b0c0 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110ad54:	e03ff715 	stw	zero,-36(fp)
8110ad58:	00002406 	br	8110adec <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110ad5c:	e0bff403 	ldbu	r2,-48(fp)
8110ad60:	10803fcc 	andi	r2,r2,255
8110ad64:	1004d1fa 	srli	r2,r2,7
8110ad68:	10c03fcc 	andi	r3,r2,255
8110ad6c:	00a00034 	movhi	r2,32768
8110ad70:	10825004 	addi	r2,r2,2368
8110ad74:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110ad78:	e0bff403 	ldbu	r2,-48(fp)
8110ad7c:	1085883a 	add	r2,r2,r2
8110ad80:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110ad84:	e0bff517 	ldw	r2,-44(fp)
8110ad88:	1085883a 	add	r2,r2,r2
8110ad8c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110ad90:	00a00034 	movhi	r2,32768
8110ad94:	10825404 	addi	r2,r2,2384
8110ad98:	10800037 	ldwio	r2,0(r2)
8110ad9c:	1080004c 	andi	r2,r2,1
8110ada0:	1007883a 	mov	r3,r2
8110ada4:	e0bff517 	ldw	r2,-44(fp)
8110ada8:	10c4b03a 	or	r2,r2,r3
8110adac:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110adb0:	00c00044 	movi	r3,1
8110adb4:	00a00034 	movhi	r2,32768
8110adb8:	10824c04 	addi	r2,r2,2352
8110adbc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110adc0:	010003c4 	movi	r4,15
8110adc4:	1132d740 	call	81132d74 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110adc8:	0007883a 	mov	r3,zero
8110adcc:	00a00034 	movhi	r2,32768
8110add0:	10824c04 	addi	r2,r2,2352
8110add4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110add8:	010003c4 	movi	r4,15
8110addc:	1132d740 	call	81132d74 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110ade0:	e0bff717 	ldw	r2,-36(fp)
8110ade4:	10800044 	addi	r2,r2,1
8110ade8:	e0bff715 	stw	r2,-36(fp)
8110adec:	e0bff717 	ldw	r2,-36(fp)
8110adf0:	10800090 	cmplti	r2,r2,2
8110adf4:	103fd91e 	bne	r2,zero,8110ad5c <__reset+0xfb0ead5c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110adf8:	e03ff715 	stw	zero,-36(fp)
8110adfc:	00002406 	br	8110ae90 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110ae00:	e0bff403 	ldbu	r2,-48(fp)
8110ae04:	10803fcc 	andi	r2,r2,255
8110ae08:	1004d1fa 	srli	r2,r2,7
8110ae0c:	10c03fcc 	andi	r3,r2,255
8110ae10:	00a00034 	movhi	r2,32768
8110ae14:	10825004 	addi	r2,r2,2368
8110ae18:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110ae1c:	e0bff403 	ldbu	r2,-48(fp)
8110ae20:	1085883a 	add	r2,r2,r2
8110ae24:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110ae28:	e0bff517 	ldw	r2,-44(fp)
8110ae2c:	1085883a 	add	r2,r2,r2
8110ae30:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110ae34:	00a00034 	movhi	r2,32768
8110ae38:	10825404 	addi	r2,r2,2384
8110ae3c:	10800037 	ldwio	r2,0(r2)
8110ae40:	1080004c 	andi	r2,r2,1
8110ae44:	1007883a 	mov	r3,r2
8110ae48:	e0bff517 	ldw	r2,-44(fp)
8110ae4c:	10c4b03a 	or	r2,r2,r3
8110ae50:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ae54:	00c00044 	movi	r3,1
8110ae58:	00a00034 	movhi	r2,32768
8110ae5c:	10824c04 	addi	r2,r2,2352
8110ae60:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae64:	010003c4 	movi	r4,15
8110ae68:	1132d740 	call	81132d74 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ae6c:	0007883a 	mov	r3,zero
8110ae70:	00a00034 	movhi	r2,32768
8110ae74:	10824c04 	addi	r2,r2,2352
8110ae78:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae7c:	010003c4 	movi	r4,15
8110ae80:	1132d740 	call	81132d74 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110ae84:	e0bff717 	ldw	r2,-36(fp)
8110ae88:	10800044 	addi	r2,r2,1
8110ae8c:	e0bff715 	stw	r2,-36(fp)
8110ae90:	e0bff717 	ldw	r2,-36(fp)
8110ae94:	10800210 	cmplti	r2,r2,8
8110ae98:	103fd91e 	bne	r2,zero,8110ae00 <__reset+0xfb0eae00>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110ae9c:	e03ff715 	stw	zero,-36(fp)
8110aea0:	00001a06 	br	8110af0c <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110aea4:	e0bff517 	ldw	r2,-44(fp)
8110aea8:	1085883a 	add	r2,r2,r2
8110aeac:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110aeb0:	00a00034 	movhi	r2,32768
8110aeb4:	10825404 	addi	r2,r2,2384
8110aeb8:	10800037 	ldwio	r2,0(r2)
8110aebc:	1080004c 	andi	r2,r2,1
8110aec0:	1007883a 	mov	r3,r2
8110aec4:	e0bff517 	ldw	r2,-44(fp)
8110aec8:	10c4b03a 	or	r2,r2,r3
8110aecc:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110aed0:	00c00044 	movi	r3,1
8110aed4:	00a00034 	movhi	r2,32768
8110aed8:	10824c04 	addi	r2,r2,2352
8110aedc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110aee0:	010003c4 	movi	r4,15
8110aee4:	1132d740 	call	81132d74 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110aee8:	0007883a 	mov	r3,zero
8110aeec:	00a00034 	movhi	r2,32768
8110aef0:	10824c04 	addi	r2,r2,2352
8110aef4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110aef8:	010003c4 	movi	r4,15
8110aefc:	1132d740 	call	81132d74 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110af00:	e0bff717 	ldw	r2,-36(fp)
8110af04:	10800044 	addi	r2,r2,1
8110af08:	e0bff715 	stw	r2,-36(fp)
8110af0c:	e0bff717 	ldw	r2,-36(fp)
8110af10:	10800210 	cmplti	r2,r2,8
8110af14:	103fe31e 	bne	r2,zero,8110aea4 <__reset+0xfb0eaea4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110af18:	e03ff715 	stw	zero,-36(fp)
8110af1c:	00001a06 	br	8110af88 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110af20:	e0bff517 	ldw	r2,-44(fp)
8110af24:	1085883a 	add	r2,r2,r2
8110af28:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110af2c:	00a00034 	movhi	r2,32768
8110af30:	10825404 	addi	r2,r2,2384
8110af34:	10800037 	ldwio	r2,0(r2)
8110af38:	1080004c 	andi	r2,r2,1
8110af3c:	1007883a 	mov	r3,r2
8110af40:	e0bff517 	ldw	r2,-44(fp)
8110af44:	10c4b03a 	or	r2,r2,r3
8110af48:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110af4c:	00c00044 	movi	r3,1
8110af50:	00a00034 	movhi	r2,32768
8110af54:	10824c04 	addi	r2,r2,2352
8110af58:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110af5c:	010003c4 	movi	r4,15
8110af60:	1132d740 	call	81132d74 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110af64:	0007883a 	mov	r3,zero
8110af68:	00a00034 	movhi	r2,32768
8110af6c:	10824c04 	addi	r2,r2,2352
8110af70:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110af74:	010003c4 	movi	r4,15
8110af78:	1132d740 	call	81132d74 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110af7c:	e0bff717 	ldw	r2,-36(fp)
8110af80:	10800044 	addi	r2,r2,1
8110af84:	e0bff715 	stw	r2,-36(fp)
8110af88:	e0bff717 	ldw	r2,-36(fp)
8110af8c:	10800210 	cmplti	r2,r2,8
8110af90:	103fe31e 	bne	r2,zero,8110af20 <__reset+0xfb0eaf20>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110af94:	e03ff715 	stw	zero,-36(fp)
8110af98:	00001a06 	br	8110b004 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110af9c:	e0bff517 	ldw	r2,-44(fp)
8110afa0:	1085883a 	add	r2,r2,r2
8110afa4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110afa8:	00a00034 	movhi	r2,32768
8110afac:	10825404 	addi	r2,r2,2384
8110afb0:	10800037 	ldwio	r2,0(r2)
8110afb4:	1080004c 	andi	r2,r2,1
8110afb8:	1007883a 	mov	r3,r2
8110afbc:	e0bff517 	ldw	r2,-44(fp)
8110afc0:	10c4b03a 	or	r2,r2,r3
8110afc4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110afc8:	00c00044 	movi	r3,1
8110afcc:	00a00034 	movhi	r2,32768
8110afd0:	10824c04 	addi	r2,r2,2352
8110afd4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110afd8:	010003c4 	movi	r4,15
8110afdc:	1132d740 	call	81132d74 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110afe0:	0007883a 	mov	r3,zero
8110afe4:	00a00034 	movhi	r2,32768
8110afe8:	10824c04 	addi	r2,r2,2352
8110afec:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110aff0:	010003c4 	movi	r4,15
8110aff4:	1132d740 	call	81132d74 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110aff8:	e0bff717 	ldw	r2,-36(fp)
8110affc:	10800044 	addi	r2,r2,1
8110b000:	e0bff715 	stw	r2,-36(fp)
8110b004:	e0bff717 	ldw	r2,-36(fp)
8110b008:	10800190 	cmplti	r2,r2,6
8110b00c:	103fe31e 	bne	r2,zero,8110af9c <__reset+0xfb0eaf9c>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110b010:	00c00044 	movi	r3,1
8110b014:	00a00034 	movhi	r2,32768
8110b018:	10824c04 	addi	r2,r2,2352
8110b01c:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110b020:	010003c4 	movi	r4,15
8110b024:	1132d740 	call	81132d74 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110b028:	00c000c4 	movi	r3,3
8110b02c:	00a00034 	movhi	r2,32768
8110b030:	10824804 	addi	r2,r2,2336
8110b034:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110b038:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110b03c:	00800044 	movi	r2,1
8110b040:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110b044:	e03ff715 	stw	zero,-36(fp)
8110b048:	00000d06 	br	8110b080 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110b04c:	e0fff517 	ldw	r3,-44(fp)
8110b050:	e0bff617 	ldw	r2,-40(fp)
8110b054:	1884703a 	and	r2,r3,r2
8110b058:	1000031e 	bne	r2,zero,8110b068 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110b05c:	e0bff917 	ldw	r2,-28(fp)
8110b060:	10800044 	addi	r2,r2,1
8110b064:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110b068:	e0bff617 	ldw	r2,-40(fp)
8110b06c:	1085883a 	add	r2,r2,r2
8110b070:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110b074:	e0bff717 	ldw	r2,-36(fp)
8110b078:	10800044 	addi	r2,r2,1
8110b07c:	e0bff715 	stw	r2,-36(fp)
8110b080:	e0bff717 	ldw	r2,-36(fp)
8110b084:	10800810 	cmplti	r2,r2,32
8110b088:	103ff01e 	bne	r2,zero,8110b04c <__reset+0xfb0eb04c>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110b08c:	e0bff917 	ldw	r2,-28(fp)
8110b090:	1080004c 	andi	r2,r2,1
8110b094:	1005003a 	cmpeq	r2,r2,zero
8110b098:	10803fcc 	andi	r2,r2,255
8110b09c:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110b0a0:	e0bffb17 	ldw	r2,-20(fp)
8110b0a4:	1000021e 	bne	r2,zero,8110b0b0 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110b0a8:	0005883a 	mov	r2,zero
8110b0ac:	00000406 	br	8110b0c0 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110b0b0:	e0800317 	ldw	r2,12(fp)
8110b0b4:	e0fff517 	ldw	r3,-44(fp)
8110b0b8:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110b0bc:	e0bffb17 	ldw	r2,-20(fp)
}
8110b0c0:	e037883a 	mov	sp,fp
8110b0c4:	dfc00117 	ldw	ra,4(sp)
8110b0c8:	df000017 	ldw	fp,0(sp)
8110b0cc:	dec00204 	addi	sp,sp,8
8110b0d0:	f800283a 	ret

8110b0d4 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110b0d4:	defffc04 	addi	sp,sp,-16
8110b0d8:	de00012e 	bgeu	sp,et,8110b0e0 <vRstcSimucamReset+0xc>
8110b0dc:	003b68fa 	trap	3
8110b0e0:	dfc00315 	stw	ra,12(sp)
8110b0e4:	df000215 	stw	fp,8(sp)
8110b0e8:	df000204 	addi	fp,sp,8
8110b0ec:	2005883a 	mov	r2,r4
8110b0f0:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110b0f4:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110b0f8:	e0bfff0b 	ldhu	r2,-4(fp)
8110b0fc:	e0fffe17 	ldw	r3,-8(fp)
8110b100:	1884b03a 	or	r2,r3,r2
8110b104:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110b108:	e0bffe17 	ldw	r2,-8(fp)
8110b10c:	10800074 	orhi	r2,r2,1
8110b110:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b114:	e1bffe17 	ldw	r6,-8(fp)
8110b118:	000b883a 	mov	r5,zero
8110b11c:	01200034 	movhi	r4,32768
8110b120:	21020004 	addi	r4,r4,2048
8110b124:	110b2240 	call	8110b224 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110b128:	0001883a 	nop
8110b12c:	e037883a 	mov	sp,fp
8110b130:	dfc00117 	ldw	ra,4(sp)
8110b134:	df000017 	ldw	fp,0(sp)
8110b138:	dec00204 	addi	sp,sp,8
8110b13c:	f800283a 	ret

8110b140 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110b140:	defffc04 	addi	sp,sp,-16
8110b144:	de00012e 	bgeu	sp,et,8110b14c <vRstcReleaseDeviceReset+0xc>
8110b148:	003b68fa 	trap	3
8110b14c:	dfc00315 	stw	ra,12(sp)
8110b150:	df000215 	stw	fp,8(sp)
8110b154:	df000204 	addi	fp,sp,8
8110b158:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b15c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b160:	01400044 	movi	r5,1
8110b164:	01200034 	movhi	r4,32768
8110b168:	21020004 	addi	r4,r4,2048
8110b16c:	110b2780 	call	8110b278 <uliRstReadReg>
8110b170:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110b174:	e0bfff17 	ldw	r2,-4(fp)
8110b178:	0084303a 	nor	r2,zero,r2
8110b17c:	e0fffe17 	ldw	r3,-8(fp)
8110b180:	1884703a 	and	r2,r3,r2
8110b184:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b188:	e1bffe17 	ldw	r6,-8(fp)
8110b18c:	01400044 	movi	r5,1
8110b190:	01200034 	movhi	r4,32768
8110b194:	21020004 	addi	r4,r4,2048
8110b198:	110b2240 	call	8110b224 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b19c:	0001883a 	nop
8110b1a0:	e037883a 	mov	sp,fp
8110b1a4:	dfc00117 	ldw	ra,4(sp)
8110b1a8:	df000017 	ldw	fp,0(sp)
8110b1ac:	dec00204 	addi	sp,sp,8
8110b1b0:	f800283a 	ret

8110b1b4 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110b1b4:	defffc04 	addi	sp,sp,-16
8110b1b8:	de00012e 	bgeu	sp,et,8110b1c0 <vRstcHoldDeviceReset+0xc>
8110b1bc:	003b68fa 	trap	3
8110b1c0:	dfc00315 	stw	ra,12(sp)
8110b1c4:	df000215 	stw	fp,8(sp)
8110b1c8:	df000204 	addi	fp,sp,8
8110b1cc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b1d0:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b1d4:	01400044 	movi	r5,1
8110b1d8:	01200034 	movhi	r4,32768
8110b1dc:	21020004 	addi	r4,r4,2048
8110b1e0:	110b2780 	call	8110b278 <uliRstReadReg>
8110b1e4:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110b1e8:	e0fffe17 	ldw	r3,-8(fp)
8110b1ec:	e0bfff17 	ldw	r2,-4(fp)
8110b1f0:	1884b03a 	or	r2,r3,r2
8110b1f4:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b1f8:	e1bffe17 	ldw	r6,-8(fp)
8110b1fc:	01400044 	movi	r5,1
8110b200:	01200034 	movhi	r4,32768
8110b204:	21020004 	addi	r4,r4,2048
8110b208:	110b2240 	call	8110b224 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b20c:	0001883a 	nop
8110b210:	e037883a 	mov	sp,fp
8110b214:	dfc00117 	ldw	ra,4(sp)
8110b218:	df000017 	ldw	fp,0(sp)
8110b21c:	dec00204 	addi	sp,sp,8
8110b220:	f800283a 	ret

8110b224 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110b224:	defffc04 	addi	sp,sp,-16
8110b228:	de00012e 	bgeu	sp,et,8110b230 <vRstcWriteReg+0xc>
8110b22c:	003b68fa 	trap	3
8110b230:	df000315 	stw	fp,12(sp)
8110b234:	df000304 	addi	fp,sp,12
8110b238:	e13ffd15 	stw	r4,-12(fp)
8110b23c:	e17ffe15 	stw	r5,-8(fp)
8110b240:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110b244:	e0bffe17 	ldw	r2,-8(fp)
8110b248:	1085883a 	add	r2,r2,r2
8110b24c:	1085883a 	add	r2,r2,r2
8110b250:	1007883a 	mov	r3,r2
8110b254:	e0bffd17 	ldw	r2,-12(fp)
8110b258:	10c5883a 	add	r2,r2,r3
8110b25c:	e0ffff17 	ldw	r3,-4(fp)
8110b260:	10c00015 	stw	r3,0(r2)
}
8110b264:	0001883a 	nop
8110b268:	e037883a 	mov	sp,fp
8110b26c:	df000017 	ldw	fp,0(sp)
8110b270:	dec00104 	addi	sp,sp,4
8110b274:	f800283a 	ret

8110b278 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110b278:	defffc04 	addi	sp,sp,-16
8110b27c:	de00012e 	bgeu	sp,et,8110b284 <uliRstReadReg+0xc>
8110b280:	003b68fa 	trap	3
8110b284:	df000315 	stw	fp,12(sp)
8110b288:	df000304 	addi	fp,sp,12
8110b28c:	e13ffe15 	stw	r4,-8(fp)
8110b290:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110b294:	e0bfff17 	ldw	r2,-4(fp)
8110b298:	1085883a 	add	r2,r2,r2
8110b29c:	1085883a 	add	r2,r2,r2
8110b2a0:	1007883a 	mov	r3,r2
8110b2a4:	e0bffe17 	ldw	r2,-8(fp)
8110b2a8:	10c5883a 	add	r2,r2,r3
8110b2ac:	10800017 	ldw	r2,0(r2)
8110b2b0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110b2b4:	e0bffd17 	ldw	r2,-12(fp)
}
8110b2b8:	e037883a 	mov	sp,fp
8110b2bc:	df000017 	ldw	fp,0(sp)
8110b2c0:	dec00104 	addi	sp,sp,4
8110b2c4:	f800283a 	ret

8110b2c8 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110b2c8:	defffe04 	addi	sp,sp,-8
8110b2cc:	de00012e 	bgeu	sp,et,8110b2d4 <v_spi_start+0xc>
8110b2d0:	003b68fa 	trap	3
8110b2d4:	dfc00115 	stw	ra,4(sp)
8110b2d8:	df000015 	stw	fp,0(sp)
8110b2dc:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110b2e0:	0007883a 	mov	r3,zero
8110b2e4:	00a00034 	movhi	r2,32768
8110b2e8:	10823004 	addi	r2,r2,2240
8110b2ec:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110b2f0:	0007883a 	mov	r3,zero
8110b2f4:	00a00034 	movhi	r2,32768
8110b2f8:	10822c04 	addi	r2,r2,2224
8110b2fc:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b300:	01002584 	movi	r4,150
8110b304:	1132d740 	call	81132d74 <usleep>
}
8110b308:	0001883a 	nop
8110b30c:	e037883a 	mov	sp,fp
8110b310:	dfc00117 	ldw	ra,4(sp)
8110b314:	df000017 	ldw	fp,0(sp)
8110b318:	dec00204 	addi	sp,sp,8
8110b31c:	f800283a 	ret

8110b320 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110b320:	defffc04 	addi	sp,sp,-16
8110b324:	de00012e 	bgeu	sp,et,8110b32c <v_spi_send_byte+0xc>
8110b328:	003b68fa 	trap	3
8110b32c:	dfc00315 	stw	ra,12(sp)
8110b330:	df000215 	stw	fp,8(sp)
8110b334:	df000204 	addi	fp,sp,8
8110b338:	2005883a 	mov	r2,r4
8110b33c:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110b340:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110b344:	00bfe004 	movi	r2,-128
8110b348:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110b34c:	e03ffe05 	stb	zero,-8(fp)
8110b350:	00001b06 	br	8110b3c0 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110b354:	e0ffff03 	ldbu	r3,-4(fp)
8110b358:	e0bffe43 	ldbu	r2,-7(fp)
8110b35c:	1884703a 	and	r2,r3,r2
8110b360:	10803fcc 	andi	r2,r2,255
8110b364:	1004c03a 	cmpne	r2,r2,zero
8110b368:	10c03fcc 	andi	r3,r2,255
8110b36c:	00a00034 	movhi	r2,32768
8110b370:	10823404 	addi	r2,r2,2256
8110b374:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110b378:	e0bffe43 	ldbu	r2,-7(fp)
8110b37c:	1004d07a 	srli	r2,r2,1
8110b380:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b384:	00c00044 	movi	r3,1
8110b388:	00a00034 	movhi	r2,32768
8110b38c:	10823004 	addi	r2,r2,2240
8110b390:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b394:	01002584 	movi	r4,150
8110b398:	1132d740 	call	81132d74 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b39c:	0007883a 	mov	r3,zero
8110b3a0:	00a00034 	movhi	r2,32768
8110b3a4:	10823004 	addi	r2,r2,2240
8110b3a8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b3ac:	01002584 	movi	r4,150
8110b3b0:	1132d740 	call	81132d74 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110b3b4:	e0bffe03 	ldbu	r2,-8(fp)
8110b3b8:	10800044 	addi	r2,r2,1
8110b3bc:	e0bffe05 	stb	r2,-8(fp)
8110b3c0:	e0bffe03 	ldbu	r2,-8(fp)
8110b3c4:	10800230 	cmpltui	r2,r2,8
8110b3c8:	103fe21e 	bne	r2,zero,8110b354 <__reset+0xfb0eb354>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110b3cc:	0001883a 	nop
8110b3d0:	e037883a 	mov	sp,fp
8110b3d4:	dfc00117 	ldw	ra,4(sp)
8110b3d8:	df000017 	ldw	fp,0(sp)
8110b3dc:	dec00204 	addi	sp,sp,8
8110b3e0:	f800283a 	ret

8110b3e4 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110b3e4:	defffd04 	addi	sp,sp,-12
8110b3e8:	de00012e 	bgeu	sp,et,8110b3f0 <uc_spi_get_byte+0xc>
8110b3ec:	003b68fa 	trap	3
8110b3f0:	dfc00215 	stw	ra,8(sp)
8110b3f4:	df000115 	stw	fp,4(sp)
8110b3f8:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110b3fc:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110b400:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110b404:	e03fff05 	stb	zero,-4(fp)
8110b408:	00001a06 	br	8110b474 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110b40c:	e0bfff43 	ldbu	r2,-3(fp)
8110b410:	1085883a 	add	r2,r2,r2
8110b414:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110b418:	00a00034 	movhi	r2,32768
8110b41c:	10823804 	addi	r2,r2,2272
8110b420:	10800037 	ldwio	r2,0(r2)
8110b424:	1080004c 	andi	r2,r2,1
8110b428:	1007883a 	mov	r3,r2
8110b42c:	e0bfff43 	ldbu	r2,-3(fp)
8110b430:	1884b03a 	or	r2,r3,r2
8110b434:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b438:	00c00044 	movi	r3,1
8110b43c:	00a00034 	movhi	r2,32768
8110b440:	10823004 	addi	r2,r2,2240
8110b444:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b448:	01002584 	movi	r4,150
8110b44c:	1132d740 	call	81132d74 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b450:	0007883a 	mov	r3,zero
8110b454:	00a00034 	movhi	r2,32768
8110b458:	10823004 	addi	r2,r2,2240
8110b45c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b460:	01002584 	movi	r4,150
8110b464:	1132d740 	call	81132d74 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110b468:	e0bfff03 	ldbu	r2,-4(fp)
8110b46c:	10800044 	addi	r2,r2,1
8110b470:	e0bfff05 	stb	r2,-4(fp)
8110b474:	e0bfff03 	ldbu	r2,-4(fp)
8110b478:	10800230 	cmpltui	r2,r2,8
8110b47c:	103fe31e 	bne	r2,zero,8110b40c <__reset+0xfb0eb40c>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110b480:	e0bfff43 	ldbu	r2,-3(fp)
}
8110b484:	e037883a 	mov	sp,fp
8110b488:	dfc00117 	ldw	ra,4(sp)
8110b48c:	df000017 	ldw	fp,0(sp)
8110b490:	dec00204 	addi	sp,sp,8
8110b494:	f800283a 	ret

8110b498 <v_spi_end>:

void v_spi_end(void){
8110b498:	defffe04 	addi	sp,sp,-8
8110b49c:	de00012e 	bgeu	sp,et,8110b4a4 <v_spi_end+0xc>
8110b4a0:	003b68fa 	trap	3
8110b4a4:	dfc00115 	stw	ra,4(sp)
8110b4a8:	df000015 	stw	fp,0(sp)
8110b4ac:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110b4b0:	0007883a 	mov	r3,zero
8110b4b4:	00a00034 	movhi	r2,32768
8110b4b8:	10823004 	addi	r2,r2,2240
8110b4bc:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b4c0:	01002584 	movi	r4,150
8110b4c4:	1132d740 	call	81132d74 <usleep>
    SPI_CS_N(1);
8110b4c8:	00c00044 	movi	r3,1
8110b4cc:	00a00034 	movhi	r2,32768
8110b4d0:	10822c04 	addi	r2,r2,2224
8110b4d4:	10c00035 	stwio	r3,0(r2)
}
8110b4d8:	0001883a 	nop
8110b4dc:	e037883a 	mov	sp,fp
8110b4e0:	dfc00117 	ldw	ra,4(sp)
8110b4e4:	df000017 	ldw	fp,0(sp)
8110b4e8:	dec00204 	addi	sp,sp,8
8110b4ec:	f800283a 	ret

8110b4f0 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110b4f0:	defff604 	addi	sp,sp,-40
8110b4f4:	de00012e 	bgeu	sp,et,8110b4fc <RTCC_SPI_R_MAC+0xc>
8110b4f8:	003b68fa 	trap	3
8110b4fc:	dfc00915 	stw	ra,36(sp)
8110b500:	df000815 	stw	fp,32(sp)
8110b504:	df000804 	addi	fp,sp,32
8110b508:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b50c:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110b510:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110b514:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110b518:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110b51c:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110b520:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110b524:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110b528:	00800084 	movi	r2,2
8110b52c:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110b530:	00800cc4 	movi	r2,51
8110b534:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110b538:	110b2c80 	call	8110b2c8 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110b53c:	e0bffec3 	ldbu	r2,-5(fp)
8110b540:	1009883a 	mov	r4,r2
8110b544:	110b3200 	call	8110b320 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110b548:	e0bffe83 	ldbu	r2,-6(fp)
8110b54c:	1009883a 	mov	r4,r2
8110b550:	110b3200 	call	8110b320 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110b554:	110b3e40 	call	8110b3e4 <uc_spi_get_byte>
8110b558:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110b55c:	110b3e40 	call	8110b3e4 <uc_spi_get_byte>
8110b560:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110b564:	110b3e40 	call	8110b3e4 <uc_spi_get_byte>
8110b568:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110b56c:	110b3e40 	call	8110b3e4 <uc_spi_get_byte>
8110b570:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110b574:	110b3e40 	call	8110b3e4 <uc_spi_get_byte>
8110b578:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110b57c:	110b3e40 	call	8110b3e4 <uc_spi_get_byte>
8110b580:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110b584:	110b4980 	call	8110b498 <v_spi_end>

    bSuccess = TRUE;
8110b588:	00800044 	movi	r2,1
8110b58c:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110b590:	e0bfff17 	ldw	r2,-4(fp)
8110b594:	e0fffd03 	ldbu	r3,-12(fp)
8110b598:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110b59c:	e0bfff17 	ldw	r2,-4(fp)
8110b5a0:	10800044 	addi	r2,r2,1
8110b5a4:	e0fffd43 	ldbu	r3,-11(fp)
8110b5a8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110b5ac:	e0bfff17 	ldw	r2,-4(fp)
8110b5b0:	10800084 	addi	r2,r2,2
8110b5b4:	e0fffd83 	ldbu	r3,-10(fp)
8110b5b8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110b5bc:	e0bfff17 	ldw	r2,-4(fp)
8110b5c0:	108000c4 	addi	r2,r2,3
8110b5c4:	e0fffdc3 	ldbu	r3,-9(fp)
8110b5c8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110b5cc:	e0bfff17 	ldw	r2,-4(fp)
8110b5d0:	10800104 	addi	r2,r2,4
8110b5d4:	e0fffe03 	ldbu	r3,-8(fp)
8110b5d8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110b5dc:	e0bfff17 	ldw	r2,-4(fp)
8110b5e0:	10800144 	addi	r2,r2,5
8110b5e4:	e0fffe43 	ldbu	r3,-7(fp)
8110b5e8:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110b5ec:	e1bffd03 	ldbu	r6,-12(fp)
8110b5f0:	e1fffd43 	ldbu	r7,-11(fp)
8110b5f4:	e0bffd83 	ldbu	r2,-10(fp)
8110b5f8:	e0fffdc3 	ldbu	r3,-9(fp)
8110b5fc:	e13ffe03 	ldbu	r4,-8(fp)
8110b600:	e17ffe43 	ldbu	r5,-7(fp)
8110b604:	d9400315 	stw	r5,12(sp)
8110b608:	d9000215 	stw	r4,8(sp)
8110b60c:	d8c00115 	stw	r3,4(sp)
8110b610:	d8800015 	stw	r2,0(sp)
8110b614:	01604534 	movhi	r5,33044
8110b618:	295d1504 	addi	r5,r5,29780
8110b61c:	01204574 	movhi	r4,33045
8110b620:	21363004 	addi	r4,r4,-10048
8110b624:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
8110b628:	d0a05c17 	ldw	r2,-32400(gp)
8110b62c:	01604574 	movhi	r5,33045
8110b630:	29763004 	addi	r5,r5,-10048
8110b634:	1009883a 	mov	r4,r2
8110b638:	111ba9c0 	call	8111ba9c <fprintf>
#endif

    return bSuccess;
8110b63c:	e0bffc17 	ldw	r2,-16(fp)
}
8110b640:	e037883a 	mov	sp,fp
8110b644:	dfc00117 	ldw	ra,4(sp)
8110b648:	df000017 	ldw	fp,0(sp)
8110b64c:	dec00204 	addi	sp,sp,8
8110b650:	f800283a 	ret

8110b654 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110b654:	defffd04 	addi	sp,sp,-12
8110b658:	de00012e 	bgeu	sp,et,8110b660 <bSSDisplayConfig+0xc>
8110b65c:	003b68fa 	trap	3
8110b660:	df000215 	stw	fp,8(sp)
8110b664:	df000204 	addi	fp,sp,8
8110b668:	2005883a 	mov	r2,r4
8110b66c:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110b670:	e0bfff03 	ldbu	r2,-4(fp)
8110b674:	10c00168 	cmpgeui	r3,r2,5
8110b678:	18001c1e 	bne	r3,zero,8110b6ec <bSSDisplayConfig+0x98>
8110b67c:	100690ba 	slli	r3,r2,2
8110b680:	00a04474 	movhi	r2,33041
8110b684:	10ada504 	addi	r2,r2,-18796
8110b688:	1885883a 	add	r2,r3,r2
8110b68c:	10800017 	ldw	r2,0(r2)
8110b690:	1000683a 	jmp	r2
8110b694:	8110b6a8 	cmpgeui	r4,r16,17114
8110b698:	8110b6b4 	orhi	r4,r16,17114
8110b69c:	8110b6c0 	call	88110b6c <__reset+0x20f0b6c>
8110b6a0:	8110b6d4 	ori	r4,r16,17115
8110b6a4:	8110b6e4 	muli	r4,r16,17115
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110b6a8:	00800cc4 	movi	r2,51
8110b6ac:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b6b0:	00001006 	br	8110b6f4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110b6b4:	00801544 	movi	r2,85
8110b6b8:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b6bc:	00000d06 	br	8110b6f4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110b6c0:	d0e04e43 	ldbu	r3,-32455(gp)
8110b6c4:	00bff744 	movi	r2,-35
8110b6c8:	1884703a 	and	r2,r3,r2
8110b6cc:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b6d0:	00000806 	br	8110b6f4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110b6d4:	d0a04e43 	ldbu	r2,-32455(gp)
8110b6d8:	10800894 	ori	r2,r2,34
8110b6dc:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b6e0:	00000406 	br	8110b6f4 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110b6e4:	d0204e45 	stb	zero,-32455(gp)
	    break;
8110b6e8:	00000206 	br	8110b6f4 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110b6ec:	0005883a 	mov	r2,zero
8110b6f0:	00000806 	br	8110b714 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b6f4:	00a00034 	movhi	r2,32768
8110b6f8:	10828404 	addi	r2,r2,2576
8110b6fc:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110b700:	d0a04e43 	ldbu	r2,-32455(gp)
8110b704:	10c03fcc 	andi	r3,r2,255
8110b708:	e0bffe17 	ldw	r2,-8(fp)
8110b70c:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b710:	00800044 	movi	r2,1
}
8110b714:	e037883a 	mov	sp,fp
8110b718:	df000017 	ldw	fp,0(sp)
8110b71c:	dec00104 	addi	sp,sp,4
8110b720:	f800283a 	ret

8110b724 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110b724:	defffd04 	addi	sp,sp,-12
8110b728:	de00012e 	bgeu	sp,et,8110b730 <bSSDisplayUpdate+0xc>
8110b72c:	003b68fa 	trap	3
8110b730:	df000215 	stw	fp,8(sp)
8110b734:	df000204 	addi	fp,sp,8
8110b738:	2005883a 	mov	r2,r4
8110b73c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b740:	00a00034 	movhi	r2,32768
8110b744:	10828404 	addi	r2,r2,2576
8110b748:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110b74c:	e0bffe17 	ldw	r2,-8(fp)
8110b750:	10800104 	addi	r2,r2,4
8110b754:	e0ffff03 	ldbu	r3,-4(fp)
8110b758:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b75c:	00800044 	movi	r2,1
}
8110b760:	e037883a 	mov	sp,fp
8110b764:	df000017 	ldw	fp,0(sp)
8110b768:	dec00104 	addi	sp,sp,4
8110b76c:	f800283a 	ret

8110b770 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110b770:	defff904 	addi	sp,sp,-28
8110b774:	de00012e 	bgeu	sp,et,8110b77c <vSyncHandleIrq+0xc>
8110b778:	003b68fa 	trap	3
8110b77c:	dfc00615 	stw	ra,24(sp)
8110b780:	df000515 	stw	fp,20(sp)
8110b784:	df000504 	addi	fp,sp,20
8110b788:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110b78c:	e0bfff17 	ldw	r2,-4(fp)
8110b790:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110b794:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110b798:	d0a05003 	ldbu	r2,-32448(gp)
8110b79c:	108000cc 	andi	r2,r2,3
8110b7a0:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 ) {
8110b7a4:	e0bffd03 	ldbu	r2,-12(fp)
8110b7a8:	10000e1e 	bne	r2,zero,8110b7e4 <vSyncHandleIrq+0x74>

		uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110b7ac:	00800044 	movi	r2,1
8110b7b0:	e0bffec5 	stb	r2,-5(fp)
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110b7b4:	00bff804 	movi	r2,-32
8110b7b8:	e0bffe85 	stb	r2,-6(fp)

		/* Send Priority message to the Meb Task to indicate the Master Sync */
		error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110b7bc:	d0a06317 	ldw	r2,-32372(gp)
8110b7c0:	e0fffe17 	ldw	r3,-8(fp)
8110b7c4:	180b883a 	mov	r5,r3
8110b7c8:	1009883a 	mov	r4,r2
8110b7cc:	11391f80 	call	811391f8 <OSQPostFront>
8110b7d0:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110b7d4:	e0bffd43 	ldbu	r2,-11(fp)
8110b7d8:	10000426 	beq	r2,zero,8110b7ec <vSyncHandleIrq+0x7c>
			vFailSendMsgMasterSyncMeb( );
8110b7dc:	111883c0 	call	8111883c <vFailSendMsgMasterSyncMeb>
8110b7e0:	00000206 	br	8110b7ec <vSyncHandleIrq+0x7c>
		}

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110b7e4:	00bff844 	movi	r2,-31
8110b7e8:	e0bffe85 	stb	r2,-6(fp)


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b7ec:	e03ffb05 	stb	zero,-20(fp)
8110b7f0:	00001f06 	br	8110b870 <vSyncHandleIrq+0x100>

		if ( xSimMeb.xFeeControl.xNfee[ucIL].xControl.bWatingSync == TRUE ) {
8110b7f4:	e0fffb03 	ldbu	r3,-20(fp)
8110b7f8:	00a04574 	movhi	r2,33045
8110b7fc:	108c7004 	addi	r2,r2,12736
8110b800:	18c09524 	muli	r3,r3,596
8110b804:	10c5883a 	add	r2,r2,r3
8110b808:	10803a04 	addi	r2,r2,232
8110b80c:	10800017 	ldw	r2,0(r2)
8110b810:	10800058 	cmpnei	r2,r2,1
8110b814:	1000131e 	bne	r2,zero,8110b864 <vSyncHandleIrq+0xf4>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110b818:	e0bffb03 	ldbu	r2,-20(fp)
8110b81c:	10800444 	addi	r2,r2,17
8110b820:	e0bffec5 	stb	r2,-5(fp)
			error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110b824:	e0bffb03 	ldbu	r2,-20(fp)
8110b828:	1085883a 	add	r2,r2,r2
8110b82c:	1087883a 	add	r3,r2,r2
8110b830:	d0a05604 	addi	r2,gp,-32424
8110b834:	1885883a 	add	r2,r3,r2
8110b838:	10800017 	ldw	r2,0(r2)
8110b83c:	e0fffe17 	ldw	r3,-8(fp)
8110b840:	180b883a 	mov	r5,r3
8110b844:	1009883a 	mov	r4,r2
8110b848:	11390880 	call	81139088 <OSQPost>
8110b84c:	e0bffd45 	stb	r2,-11(fp)
			if ( error_codel != OS_ERR_NONE ) {
8110b850:	e0bffd43 	ldbu	r2,-11(fp)
8110b854:	10000326 	beq	r2,zero,8110b864 <vSyncHandleIrq+0xf4>
				vFailSendMsgSync( ucIL );
8110b858:	e0bffb03 	ldbu	r2,-20(fp)
8110b85c:	1009883a 	mov	r4,r2
8110b860:	11187e80 	call	811187e8 <vFailSendMsgSync>

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b864:	e0bffb03 	ldbu	r2,-20(fp)
8110b868:	10800044 	addi	r2,r2,1
8110b86c:	e0bffb05 	stb	r2,-20(fp)
8110b870:	e0bffb03 	ldbu	r2,-20(fp)
8110b874:	103fdf26 	beq	r2,zero,8110b7f4 <__reset+0xfb0eb7f4>
				vFailSendMsgSync( ucIL );
			}
		}
	}

	vucN += 1;
8110b878:	d0a05003 	ldbu	r2,-32448(gp)
8110b87c:	10800044 	addi	r2,r2,1
8110b880:	d0a05005 	stb	r2,-32448(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110b884:	d0a05c17 	ldw	r2,-32400(gp)
8110b888:	e0fffd03 	ldbu	r3,-12(fp)
8110b88c:	180d883a 	mov	r6,r3
8110b890:	01604534 	movhi	r5,33044
8110b894:	295d2404 	addi	r5,r5,29840
8110b898:	1009883a 	mov	r4,r2
8110b89c:	111ba9c0 	call	8111ba9c <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110b8a0:	110b9340 	call	8110b934 <vSyncIrqFlagClrSync>
}
8110b8a4:	0001883a 	nop
8110b8a8:	e037883a 	mov	sp,fp
8110b8ac:	dfc00117 	ldw	ra,4(sp)
8110b8b0:	df000017 	ldw	fp,0(sp)
8110b8b4:	dec00204 	addi	sp,sp,8
8110b8b8:	f800283a 	ret

8110b8bc <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110b8bc:	deffff04 	addi	sp,sp,-4
8110b8c0:	de00012e 	bgeu	sp,et,8110b8c8 <vSyncClearCounter+0xc>
8110b8c4:	003b68fa 	trap	3
8110b8c8:	df000015 	stw	fp,0(sp)
8110b8cc:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110b8d0:	d0205005 	stb	zero,-32448(gp)
}
8110b8d4:	0001883a 	nop
8110b8d8:	e037883a 	mov	sp,fp
8110b8dc:	df000017 	ldw	fp,0(sp)
8110b8e0:	dec00104 	addi	sp,sp,4
8110b8e4:	f800283a 	ret

8110b8e8 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110b8e8:	defffd04 	addi	sp,sp,-12
8110b8ec:	de00012e 	bgeu	sp,et,8110b8f4 <vSyncInitIrq+0xc>
8110b8f0:	003b68fa 	trap	3
8110b8f4:	dfc00215 	stw	ra,8(sp)
8110b8f8:	df000115 	stw	fp,4(sp)
8110b8fc:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110b900:	d0a04f04 	addi	r2,gp,-32452
8110b904:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110b908:	01a04474 	movhi	r6,33041
8110b90c:	31addc04 	addi	r6,r6,-18576
8110b910:	e17fff17 	ldw	r5,-4(fp)
8110b914:	01000284 	movi	r4,10
8110b918:	11316a40 	call	811316a4 <alt_irq_register>
}
8110b91c:	0001883a 	nop
8110b920:	e037883a 	mov	sp,fp
8110b924:	dfc00117 	ldw	ra,4(sp)
8110b928:	df000017 	ldw	fp,0(sp)
8110b92c:	dec00204 	addi	sp,sp,8
8110b930:	f800283a 	ret

8110b934 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110b934:	defffe04 	addi	sp,sp,-8
8110b938:	de00012e 	bgeu	sp,et,8110b940 <vSyncIrqFlagClrSync+0xc>
8110b93c:	003b68fa 	trap	3
8110b940:	dfc00115 	stw	ra,4(sp)
8110b944:	df000015 	stw	fp,0(sp)
8110b948:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110b94c:	01400044 	movi	r5,1
8110b950:	010002c4 	movi	r4,11
8110b954:	110c7140 	call	8110c714 <bSyncWriteReg>
}
8110b958:	0001883a 	nop
8110b95c:	e037883a 	mov	sp,fp
8110b960:	dfc00117 	ldw	ra,4(sp)
8110b964:	df000017 	ldw	fp,0(sp)
8110b968:	dec00204 	addi	sp,sp,8
8110b96c:	f800283a 	ret

8110b970 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110b970:	defffd04 	addi	sp,sp,-12
8110b974:	de00012e 	bgeu	sp,et,8110b97c <bSyncIrqFlagSync+0xc>
8110b978:	003b68fa 	trap	3
8110b97c:	dfc00215 	stw	ra,8(sp)
8110b980:	df000115 	stw	fp,4(sp)
8110b984:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110b988:	01000304 	movi	r4,12
8110b98c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110b990:	1080004c 	andi	r2,r2,1
8110b994:	10000326 	beq	r2,zero,8110b9a4 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110b998:	00800044 	movi	r2,1
8110b99c:	e0bfff15 	stw	r2,-4(fp)
8110b9a0:	00000106 	br	8110b9a8 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110b9a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110b9a8:	e0bfff17 	ldw	r2,-4(fp)
}
8110b9ac:	e037883a 	mov	sp,fp
8110b9b0:	dfc00117 	ldw	ra,4(sp)
8110b9b4:	df000017 	ldw	fp,0(sp)
8110b9b8:	dec00204 	addi	sp,sp,8
8110b9bc:	f800283a 	ret

8110b9c0 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110b9c0:	defffc04 	addi	sp,sp,-16
8110b9c4:	de00012e 	bgeu	sp,et,8110b9cc <bSyncStatusExtnIrq+0xc>
8110b9c8:	003b68fa 	trap	3
8110b9cc:	dfc00315 	stw	ra,12(sp)
8110b9d0:	df000215 	stw	fp,8(sp)
8110b9d4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b9d8:	0009883a 	mov	r4,zero
8110b9dc:	110c7700 	call	8110c770 <uliSyncReadReg>
8110b9e0:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110b9e4:	e0bfff17 	ldw	r2,-4(fp)
8110b9e8:	1000030e 	bge	r2,zero,8110b9f8 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110b9ec:	00800044 	movi	r2,1
8110b9f0:	e0bffe15 	stw	r2,-8(fp)
8110b9f4:	00000106 	br	8110b9fc <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110b9f8:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110b9fc:	e0bffe17 	ldw	r2,-8(fp)
}
8110ba00:	e037883a 	mov	sp,fp
8110ba04:	dfc00117 	ldw	ra,4(sp)
8110ba08:	df000017 	ldw	fp,0(sp)
8110ba0c:	dec00204 	addi	sp,sp,8
8110ba10:	f800283a 	ret

8110ba14 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110ba14:	defffc04 	addi	sp,sp,-16
8110ba18:	de00012e 	bgeu	sp,et,8110ba20 <ucSyncStatusState+0xc>
8110ba1c:	003b68fa 	trap	3
8110ba20:	dfc00315 	stw	ra,12(sp)
8110ba24:	df000215 	stw	fp,8(sp)
8110ba28:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ba2c:	0009883a 	mov	r4,zero
8110ba30:	110c7700 	call	8110c770 <uliSyncReadReg>
8110ba34:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110ba38:	e0bffe17 	ldw	r2,-8(fp)
8110ba3c:	10803fec 	andhi	r2,r2,255
8110ba40:	1004d43a 	srli	r2,r2,16
8110ba44:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ba48:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ba4c:	e037883a 	mov	sp,fp
8110ba50:	dfc00117 	ldw	ra,4(sp)
8110ba54:	df000017 	ldw	fp,0(sp)
8110ba58:	dec00204 	addi	sp,sp,8
8110ba5c:	f800283a 	ret

8110ba60 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110ba60:	defffc04 	addi	sp,sp,-16
8110ba64:	de00012e 	bgeu	sp,et,8110ba6c <ucSyncStatusErrorCode+0xc>
8110ba68:	003b68fa 	trap	3
8110ba6c:	dfc00315 	stw	ra,12(sp)
8110ba70:	df000215 	stw	fp,8(sp)
8110ba74:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ba78:	0009883a 	mov	r4,zero
8110ba7c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110ba80:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110ba84:	e0bffe17 	ldw	r2,-8(fp)
8110ba88:	10bfc00c 	andi	r2,r2,65280
8110ba8c:	1004d23a 	srli	r2,r2,8
8110ba90:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ba94:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ba98:	e037883a 	mov	sp,fp
8110ba9c:	dfc00117 	ldw	ra,4(sp)
8110baa0:	df000017 	ldw	fp,0(sp)
8110baa4:	dec00204 	addi	sp,sp,8
8110baa8:	f800283a 	ret

8110baac <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110baac:	defffc04 	addi	sp,sp,-16
8110bab0:	de00012e 	bgeu	sp,et,8110bab8 <ucSyncStatusCycleNumber+0xc>
8110bab4:	003b68fa 	trap	3
8110bab8:	dfc00315 	stw	ra,12(sp)
8110babc:	df000215 	stw	fp,8(sp)
8110bac0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bac4:	0009883a 	mov	r4,zero
8110bac8:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bacc:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110bad0:	e0bffe17 	ldw	r2,-8(fp)
8110bad4:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bad8:	e0bfff03 	ldbu	r2,-4(fp)
}
8110badc:	e037883a 	mov	sp,fp
8110bae0:	dfc00117 	ldw	ra,4(sp)
8110bae4:	df000017 	ldw	fp,0(sp)
8110bae8:	dec00204 	addi	sp,sp,8
8110baec:	f800283a 	ret

8110baf0 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110baf0:	defffd04 	addi	sp,sp,-12
8110baf4:	de00012e 	bgeu	sp,et,8110bafc <bSyncSetMbt+0xc>
8110baf8:	003b68fa 	trap	3
8110bafc:	dfc00215 	stw	ra,8(sp)
8110bb00:	df000115 	stw	fp,4(sp)
8110bb04:	df000104 	addi	fp,sp,4
8110bb08:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110bb0c:	e17fff17 	ldw	r5,-4(fp)
8110bb10:	01000104 	movi	r4,4
8110bb14:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bb18:	00800044 	movi	r2,1
}
8110bb1c:	e037883a 	mov	sp,fp
8110bb20:	dfc00117 	ldw	ra,4(sp)
8110bb24:	df000017 	ldw	fp,0(sp)
8110bb28:	dec00204 	addi	sp,sp,8
8110bb2c:	f800283a 	ret

8110bb30 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110bb30:	defffd04 	addi	sp,sp,-12
8110bb34:	de00012e 	bgeu	sp,et,8110bb3c <bSyncSetBt+0xc>
8110bb38:	003b68fa 	trap	3
8110bb3c:	dfc00215 	stw	ra,8(sp)
8110bb40:	df000115 	stw	fp,4(sp)
8110bb44:	df000104 	addi	fp,sp,4
8110bb48:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110bb4c:	e17fff17 	ldw	r5,-4(fp)
8110bb50:	01000144 	movi	r4,5
8110bb54:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bb58:	00800044 	movi	r2,1
}
8110bb5c:	e037883a 	mov	sp,fp
8110bb60:	dfc00117 	ldw	ra,4(sp)
8110bb64:	df000017 	ldw	fp,0(sp)
8110bb68:	dec00204 	addi	sp,sp,8
8110bb6c:	f800283a 	ret

8110bb70 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110bb70:	defffd04 	addi	sp,sp,-12
8110bb74:	de00012e 	bgeu	sp,et,8110bb7c <bSyncSetPer+0xc>
8110bb78:	003b68fa 	trap	3
8110bb7c:	dfc00215 	stw	ra,8(sp)
8110bb80:	df000115 	stw	fp,4(sp)
8110bb84:	df000104 	addi	fp,sp,4
8110bb88:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110bb8c:	e17fff17 	ldw	r5,-4(fp)
8110bb90:	01000184 	movi	r4,6
8110bb94:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bb98:	00800044 	movi	r2,1
}
8110bb9c:	e037883a 	mov	sp,fp
8110bba0:	dfc00117 	ldw	ra,4(sp)
8110bba4:	df000017 	ldw	fp,0(sp)
8110bba8:	dec00204 	addi	sp,sp,8
8110bbac:	f800283a 	ret

8110bbb0 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110bbb0:	defffd04 	addi	sp,sp,-12
8110bbb4:	de00012e 	bgeu	sp,et,8110bbbc <bSyncSetOst+0xc>
8110bbb8:	003b68fa 	trap	3
8110bbbc:	dfc00215 	stw	ra,8(sp)
8110bbc0:	df000115 	stw	fp,4(sp)
8110bbc4:	df000104 	addi	fp,sp,4
8110bbc8:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110bbcc:	e17fff17 	ldw	r5,-4(fp)
8110bbd0:	010001c4 	movi	r4,7
8110bbd4:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bbd8:	00800044 	movi	r2,1
}
8110bbdc:	e037883a 	mov	sp,fp
8110bbe0:	dfc00117 	ldw	ra,4(sp)
8110bbe4:	df000017 	ldw	fp,0(sp)
8110bbe8:	dec00204 	addi	sp,sp,8
8110bbec:	f800283a 	ret

8110bbf0 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110bbf0:	defffc04 	addi	sp,sp,-16
8110bbf4:	de00012e 	bgeu	sp,et,8110bbfc <bSyncSetPolarity+0xc>
8110bbf8:	003b68fa 	trap	3
8110bbfc:	dfc00315 	stw	ra,12(sp)
8110bc00:	df000215 	stw	fp,8(sp)
8110bc04:	df000204 	addi	fp,sp,8
8110bc08:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bc0c:	01000204 	movi	r4,8
8110bc10:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bc14:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bc18:	e0bfff17 	ldw	r2,-4(fp)
8110bc1c:	1000051e 	bne	r2,zero,8110bc34 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110bc20:	e0fffe17 	ldw	r3,-8(fp)
8110bc24:	00bfbfc4 	movi	r2,-257
8110bc28:	1884703a 	and	r2,r3,r2
8110bc2c:	e0bffe15 	stw	r2,-8(fp)
8110bc30:	00000306 	br	8110bc40 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110bc34:	e0bffe17 	ldw	r2,-8(fp)
8110bc38:	10804014 	ori	r2,r2,256
8110bc3c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110bc40:	e17ffe17 	ldw	r5,-8(fp)
8110bc44:	01000204 	movi	r4,8
8110bc48:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bc4c:	00800044 	movi	r2,1
}
8110bc50:	e037883a 	mov	sp,fp
8110bc54:	dfc00117 	ldw	ra,4(sp)
8110bc58:	df000017 	ldw	fp,0(sp)
8110bc5c:	dec00204 	addi	sp,sp,8
8110bc60:	f800283a 	ret

8110bc64 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110bc64:	defffc04 	addi	sp,sp,-16
8110bc68:	de00012e 	bgeu	sp,et,8110bc70 <bSyncSetNCycles+0xc>
8110bc6c:	003b68fa 	trap	3
8110bc70:	dfc00315 	stw	ra,12(sp)
8110bc74:	df000215 	stw	fp,8(sp)
8110bc78:	df000204 	addi	fp,sp,8
8110bc7c:	2005883a 	mov	r2,r4
8110bc80:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bc84:	01000204 	movi	r4,8
8110bc88:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bc8c:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110bc90:	e0fffe17 	ldw	r3,-8(fp)
8110bc94:	00bfc004 	movi	r2,-256
8110bc98:	1884703a 	and	r2,r3,r2
8110bc9c:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110bca0:	e0bfff03 	ldbu	r2,-4(fp)
8110bca4:	e0fffe17 	ldw	r3,-8(fp)
8110bca8:	1884b03a 	or	r2,r3,r2
8110bcac:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110bcb0:	e17ffe17 	ldw	r5,-8(fp)
8110bcb4:	01000204 	movi	r4,8
8110bcb8:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bcbc:	00800044 	movi	r2,1
}
8110bcc0:	e037883a 	mov	sp,fp
8110bcc4:	dfc00117 	ldw	ra,4(sp)
8110bcc8:	df000017 	ldw	fp,0(sp)
8110bccc:	dec00204 	addi	sp,sp,8
8110bcd0:	f800283a 	ret

8110bcd4 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110bcd4:	defffd04 	addi	sp,sp,-12
8110bcd8:	de00012e 	bgeu	sp,et,8110bce0 <uliSyncGetMbt+0xc>
8110bcdc:	003b68fa 	trap	3
8110bce0:	dfc00215 	stw	ra,8(sp)
8110bce4:	df000115 	stw	fp,4(sp)
8110bce8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110bcec:	01000104 	movi	r4,4
8110bcf0:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bcf4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bcf8:	e0bfff17 	ldw	r2,-4(fp)
}
8110bcfc:	e037883a 	mov	sp,fp
8110bd00:	dfc00117 	ldw	ra,4(sp)
8110bd04:	df000017 	ldw	fp,0(sp)
8110bd08:	dec00204 	addi	sp,sp,8
8110bd0c:	f800283a 	ret

8110bd10 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110bd10:	defffd04 	addi	sp,sp,-12
8110bd14:	de00012e 	bgeu	sp,et,8110bd1c <uliSyncGetBt+0xc>
8110bd18:	003b68fa 	trap	3
8110bd1c:	dfc00215 	stw	ra,8(sp)
8110bd20:	df000115 	stw	fp,4(sp)
8110bd24:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110bd28:	01000144 	movi	r4,5
8110bd2c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bd30:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bd34:	e0bfff17 	ldw	r2,-4(fp)
}
8110bd38:	e037883a 	mov	sp,fp
8110bd3c:	dfc00117 	ldw	ra,4(sp)
8110bd40:	df000017 	ldw	fp,0(sp)
8110bd44:	dec00204 	addi	sp,sp,8
8110bd48:	f800283a 	ret

8110bd4c <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110bd4c:	defffd04 	addi	sp,sp,-12
8110bd50:	de00012e 	bgeu	sp,et,8110bd58 <uliSyncGetPer+0xc>
8110bd54:	003b68fa 	trap	3
8110bd58:	dfc00215 	stw	ra,8(sp)
8110bd5c:	df000115 	stw	fp,4(sp)
8110bd60:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110bd64:	01000184 	movi	r4,6
8110bd68:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bd6c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bd70:	e0bfff17 	ldw	r2,-4(fp)
}
8110bd74:	e037883a 	mov	sp,fp
8110bd78:	dfc00117 	ldw	ra,4(sp)
8110bd7c:	df000017 	ldw	fp,0(sp)
8110bd80:	dec00204 	addi	sp,sp,8
8110bd84:	f800283a 	ret

8110bd88 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110bd88:	defffd04 	addi	sp,sp,-12
8110bd8c:	de00012e 	bgeu	sp,et,8110bd94 <uliSyncGetOst+0xc>
8110bd90:	003b68fa 	trap	3
8110bd94:	dfc00215 	stw	ra,8(sp)
8110bd98:	df000115 	stw	fp,4(sp)
8110bd9c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110bda0:	010001c4 	movi	r4,7
8110bda4:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bda8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bdac:	e0bfff17 	ldw	r2,-4(fp)
}
8110bdb0:	e037883a 	mov	sp,fp
8110bdb4:	dfc00117 	ldw	ra,4(sp)
8110bdb8:	df000017 	ldw	fp,0(sp)
8110bdbc:	dec00204 	addi	sp,sp,8
8110bdc0:	f800283a 	ret

8110bdc4 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110bdc4:	defffd04 	addi	sp,sp,-12
8110bdc8:	de00012e 	bgeu	sp,et,8110bdd0 <uliSyncGetGeneral+0xc>
8110bdcc:	003b68fa 	trap	3
8110bdd0:	dfc00215 	stw	ra,8(sp)
8110bdd4:	df000115 	stw	fp,4(sp)
8110bdd8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bddc:	01000204 	movi	r4,8
8110bde0:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bde4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bde8:	e0bfff17 	ldw	r2,-4(fp)
}
8110bdec:	e037883a 	mov	sp,fp
8110bdf0:	dfc00117 	ldw	ra,4(sp)
8110bdf4:	df000017 	ldw	fp,0(sp)
8110bdf8:	dec00204 	addi	sp,sp,8
8110bdfc:	f800283a 	ret

8110be00 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110be00:	defffd04 	addi	sp,sp,-12
8110be04:	de00012e 	bgeu	sp,et,8110be0c <bSyncErrInj+0xc>
8110be08:	003b68fa 	trap	3
8110be0c:	dfc00215 	stw	ra,8(sp)
8110be10:	df000115 	stw	fp,4(sp)
8110be14:	df000104 	addi	fp,sp,4
8110be18:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110be1c:	e17fff17 	ldw	r5,-4(fp)
8110be20:	01000244 	movi	r4,9
8110be24:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110be28:	00800044 	movi	r2,1
}
8110be2c:	e037883a 	mov	sp,fp
8110be30:	dfc00117 	ldw	ra,4(sp)
8110be34:	df000017 	ldw	fp,0(sp)
8110be38:	dec00204 	addi	sp,sp,8
8110be3c:	f800283a 	ret

8110be40 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110be40:	defffc04 	addi	sp,sp,-16
8110be44:	de00012e 	bgeu	sp,et,8110be4c <bSyncCtrExtnIrq+0xc>
8110be48:	003b68fa 	trap	3
8110be4c:	dfc00315 	stw	ra,12(sp)
8110be50:	df000215 	stw	fp,8(sp)
8110be54:	df000204 	addi	fp,sp,8
8110be58:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110be5c:	01000284 	movi	r4,10
8110be60:	110c7700 	call	8110c770 <uliSyncReadReg>
8110be64:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110be68:	e0bfff17 	ldw	r2,-4(fp)
8110be6c:	1000061e 	bne	r2,zero,8110be88 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110be70:	e0fffe17 	ldw	r3,-8(fp)
8110be74:	00a00034 	movhi	r2,32768
8110be78:	10bfffc4 	addi	r2,r2,-1
8110be7c:	1884703a 	and	r2,r3,r2
8110be80:	e0bffe15 	stw	r2,-8(fp)
8110be84:	00000306 	br	8110be94 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110be88:	e0bffe17 	ldw	r2,-8(fp)
8110be8c:	10a00034 	orhi	r2,r2,32768
8110be90:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110be94:	e17ffe17 	ldw	r5,-8(fp)
8110be98:	01000284 	movi	r4,10
8110be9c:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bea0:	00800044 	movi	r2,1
}
8110bea4:	e037883a 	mov	sp,fp
8110bea8:	dfc00117 	ldw	ra,4(sp)
8110beac:	df000017 	ldw	fp,0(sp)
8110beb0:	dec00204 	addi	sp,sp,8
8110beb4:	f800283a 	ret

8110beb8 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110beb8:	defffd04 	addi	sp,sp,-12
8110bebc:	de00012e 	bgeu	sp,et,8110bec4 <bSyncCtrStart+0xc>
8110bec0:	003b68fa 	trap	3
8110bec4:	dfc00215 	stw	ra,8(sp)
8110bec8:	df000115 	stw	fp,4(sp)
8110becc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bed0:	01000284 	movi	r4,10
8110bed4:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bed8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110bedc:	e0bfff17 	ldw	r2,-4(fp)
8110bee0:	10800234 	orhi	r2,r2,8
8110bee4:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bee8:	e17fff17 	ldw	r5,-4(fp)
8110beec:	01000284 	movi	r4,10
8110bef0:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bef4:	00800044 	movi	r2,1
}
8110bef8:	e037883a 	mov	sp,fp
8110befc:	dfc00117 	ldw	ra,4(sp)
8110bf00:	df000017 	ldw	fp,0(sp)
8110bf04:	dec00204 	addi	sp,sp,8
8110bf08:	f800283a 	ret

8110bf0c <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110bf0c:	defffd04 	addi	sp,sp,-12
8110bf10:	de00012e 	bgeu	sp,et,8110bf18 <bSyncCtrReset+0xc>
8110bf14:	003b68fa 	trap	3
8110bf18:	dfc00215 	stw	ra,8(sp)
8110bf1c:	df000115 	stw	fp,4(sp)
8110bf20:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bf24:	01000284 	movi	r4,10
8110bf28:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bf2c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110bf30:	e0bfff17 	ldw	r2,-4(fp)
8110bf34:	10800134 	orhi	r2,r2,4
8110bf38:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bf3c:	e17fff17 	ldw	r5,-4(fp)
8110bf40:	01000284 	movi	r4,10
8110bf44:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bf48:	00800044 	movi	r2,1
}
8110bf4c:	e037883a 	mov	sp,fp
8110bf50:	dfc00117 	ldw	ra,4(sp)
8110bf54:	df000017 	ldw	fp,0(sp)
8110bf58:	dec00204 	addi	sp,sp,8
8110bf5c:	f800283a 	ret

8110bf60 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110bf60:	defffd04 	addi	sp,sp,-12
8110bf64:	de00012e 	bgeu	sp,et,8110bf6c <bSyncCtrOneShot+0xc>
8110bf68:	003b68fa 	trap	3
8110bf6c:	dfc00215 	stw	ra,8(sp)
8110bf70:	df000115 	stw	fp,4(sp)
8110bf74:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bf78:	01000284 	movi	r4,10
8110bf7c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bf80:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110bf84:	e0bfff17 	ldw	r2,-4(fp)
8110bf88:	108000b4 	orhi	r2,r2,2
8110bf8c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bf90:	e17fff17 	ldw	r5,-4(fp)
8110bf94:	01000284 	movi	r4,10
8110bf98:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bf9c:	00800044 	movi	r2,1
}
8110bfa0:	e037883a 	mov	sp,fp
8110bfa4:	dfc00117 	ldw	ra,4(sp)
8110bfa8:	df000017 	ldw	fp,0(sp)
8110bfac:	dec00204 	addi	sp,sp,8
8110bfb0:	f800283a 	ret

8110bfb4 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110bfb4:	defffd04 	addi	sp,sp,-12
8110bfb8:	de00012e 	bgeu	sp,et,8110bfc0 <bSyncCtrErrInj+0xc>
8110bfbc:	003b68fa 	trap	3
8110bfc0:	dfc00215 	stw	ra,8(sp)
8110bfc4:	df000115 	stw	fp,4(sp)
8110bfc8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bfcc:	01000284 	movi	r4,10
8110bfd0:	110c7700 	call	8110c770 <uliSyncReadReg>
8110bfd4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110bfd8:	e0bfff17 	ldw	r2,-4(fp)
8110bfdc:	10800074 	orhi	r2,r2,1
8110bfe0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bfe4:	e17fff17 	ldw	r5,-4(fp)
8110bfe8:	01000284 	movi	r4,10
8110bfec:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110bff0:	00800044 	movi	r2,1
}
8110bff4:	e037883a 	mov	sp,fp
8110bff8:	dfc00117 	ldw	ra,4(sp)
8110bffc:	df000017 	ldw	fp,0(sp)
8110c000:	dec00204 	addi	sp,sp,8
8110c004:	f800283a 	ret

8110c008 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110c008:	defffc04 	addi	sp,sp,-16
8110c00c:	de00012e 	bgeu	sp,et,8110c014 <bSyncCtrSyncOutEnable+0xc>
8110c010:	003b68fa 	trap	3
8110c014:	dfc00315 	stw	ra,12(sp)
8110c018:	df000215 	stw	fp,8(sp)
8110c01c:	df000204 	addi	fp,sp,8
8110c020:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c024:	01000284 	movi	r4,10
8110c028:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c02c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c030:	e0bfff17 	ldw	r2,-4(fp)
8110c034:	1000051e 	bne	r2,zero,8110c04c <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110c038:	e0fffe17 	ldw	r3,-8(fp)
8110c03c:	00bfbfc4 	movi	r2,-257
8110c040:	1884703a 	and	r2,r3,r2
8110c044:	e0bffe15 	stw	r2,-8(fp)
8110c048:	00000306 	br	8110c058 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110c04c:	e0bffe17 	ldw	r2,-8(fp)
8110c050:	10804014 	ori	r2,r2,256
8110c054:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c058:	e17ffe17 	ldw	r5,-8(fp)
8110c05c:	01000284 	movi	r4,10
8110c060:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c064:	00800044 	movi	r2,1
}
8110c068:	e037883a 	mov	sp,fp
8110c06c:	dfc00117 	ldw	ra,4(sp)
8110c070:	df000017 	ldw	fp,0(sp)
8110c074:	dec00204 	addi	sp,sp,8
8110c078:	f800283a 	ret

8110c07c <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110c07c:	defffc04 	addi	sp,sp,-16
8110c080:	de00012e 	bgeu	sp,et,8110c088 <bSyncCtrCh1OutEnable+0xc>
8110c084:	003b68fa 	trap	3
8110c088:	dfc00315 	stw	ra,12(sp)
8110c08c:	df000215 	stw	fp,8(sp)
8110c090:	df000204 	addi	fp,sp,8
8110c094:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c098:	01000284 	movi	r4,10
8110c09c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c0a0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c0a4:	e0bfff17 	ldw	r2,-4(fp)
8110c0a8:	1000051e 	bne	r2,zero,8110c0c0 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110c0ac:	e0fffe17 	ldw	r3,-8(fp)
8110c0b0:	00bfff84 	movi	r2,-2
8110c0b4:	1884703a 	and	r2,r3,r2
8110c0b8:	e0bffe15 	stw	r2,-8(fp)
8110c0bc:	00000306 	br	8110c0cc <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110c0c0:	e0bffe17 	ldw	r2,-8(fp)
8110c0c4:	10800054 	ori	r2,r2,1
8110c0c8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c0cc:	e17ffe17 	ldw	r5,-8(fp)
8110c0d0:	01000284 	movi	r4,10
8110c0d4:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c0d8:	00800044 	movi	r2,1
}
8110c0dc:	e037883a 	mov	sp,fp
8110c0e0:	dfc00117 	ldw	ra,4(sp)
8110c0e4:	df000017 	ldw	fp,0(sp)
8110c0e8:	dec00204 	addi	sp,sp,8
8110c0ec:	f800283a 	ret

8110c0f0 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110c0f0:	defffc04 	addi	sp,sp,-16
8110c0f4:	de00012e 	bgeu	sp,et,8110c0fc <bSyncCtrCh2OutEnable+0xc>
8110c0f8:	003b68fa 	trap	3
8110c0fc:	dfc00315 	stw	ra,12(sp)
8110c100:	df000215 	stw	fp,8(sp)
8110c104:	df000204 	addi	fp,sp,8
8110c108:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c10c:	01000284 	movi	r4,10
8110c110:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c114:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c118:	e0bfff17 	ldw	r2,-4(fp)
8110c11c:	1000051e 	bne	r2,zero,8110c134 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110c120:	e0fffe17 	ldw	r3,-8(fp)
8110c124:	00bfff44 	movi	r2,-3
8110c128:	1884703a 	and	r2,r3,r2
8110c12c:	e0bffe15 	stw	r2,-8(fp)
8110c130:	00000306 	br	8110c140 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110c134:	e0bffe17 	ldw	r2,-8(fp)
8110c138:	10800094 	ori	r2,r2,2
8110c13c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c140:	e17ffe17 	ldw	r5,-8(fp)
8110c144:	01000284 	movi	r4,10
8110c148:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c14c:	00800044 	movi	r2,1
}
8110c150:	e037883a 	mov	sp,fp
8110c154:	dfc00117 	ldw	ra,4(sp)
8110c158:	df000017 	ldw	fp,0(sp)
8110c15c:	dec00204 	addi	sp,sp,8
8110c160:	f800283a 	ret

8110c164 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110c164:	defffc04 	addi	sp,sp,-16
8110c168:	de00012e 	bgeu	sp,et,8110c170 <bSyncCtrCh3OutEnable+0xc>
8110c16c:	003b68fa 	trap	3
8110c170:	dfc00315 	stw	ra,12(sp)
8110c174:	df000215 	stw	fp,8(sp)
8110c178:	df000204 	addi	fp,sp,8
8110c17c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c180:	01000284 	movi	r4,10
8110c184:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c188:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c18c:	e0bfff17 	ldw	r2,-4(fp)
8110c190:	1000051e 	bne	r2,zero,8110c1a8 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110c194:	e0fffe17 	ldw	r3,-8(fp)
8110c198:	00bffec4 	movi	r2,-5
8110c19c:	1884703a 	and	r2,r3,r2
8110c1a0:	e0bffe15 	stw	r2,-8(fp)
8110c1a4:	00000306 	br	8110c1b4 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110c1a8:	e0bffe17 	ldw	r2,-8(fp)
8110c1ac:	10800114 	ori	r2,r2,4
8110c1b0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c1b4:	e17ffe17 	ldw	r5,-8(fp)
8110c1b8:	01000284 	movi	r4,10
8110c1bc:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c1c0:	00800044 	movi	r2,1
}
8110c1c4:	e037883a 	mov	sp,fp
8110c1c8:	dfc00117 	ldw	ra,4(sp)
8110c1cc:	df000017 	ldw	fp,0(sp)
8110c1d0:	dec00204 	addi	sp,sp,8
8110c1d4:	f800283a 	ret

8110c1d8 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110c1d8:	defffc04 	addi	sp,sp,-16
8110c1dc:	de00012e 	bgeu	sp,et,8110c1e4 <bSyncCtrCh4OutEnable+0xc>
8110c1e0:	003b68fa 	trap	3
8110c1e4:	dfc00315 	stw	ra,12(sp)
8110c1e8:	df000215 	stw	fp,8(sp)
8110c1ec:	df000204 	addi	fp,sp,8
8110c1f0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c1f4:	01000284 	movi	r4,10
8110c1f8:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c1fc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c200:	e0bfff17 	ldw	r2,-4(fp)
8110c204:	1000051e 	bne	r2,zero,8110c21c <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110c208:	e0fffe17 	ldw	r3,-8(fp)
8110c20c:	00bffdc4 	movi	r2,-9
8110c210:	1884703a 	and	r2,r3,r2
8110c214:	e0bffe15 	stw	r2,-8(fp)
8110c218:	00000306 	br	8110c228 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110c21c:	e0bffe17 	ldw	r2,-8(fp)
8110c220:	10800214 	ori	r2,r2,8
8110c224:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c228:	e17ffe17 	ldw	r5,-8(fp)
8110c22c:	01000284 	movi	r4,10
8110c230:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c234:	00800044 	movi	r2,1
}
8110c238:	e037883a 	mov	sp,fp
8110c23c:	dfc00117 	ldw	ra,4(sp)
8110c240:	df000017 	ldw	fp,0(sp)
8110c244:	dec00204 	addi	sp,sp,8
8110c248:	f800283a 	ret

8110c24c <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110c24c:	defffc04 	addi	sp,sp,-16
8110c250:	de00012e 	bgeu	sp,et,8110c258 <bSyncCtrCh5OutEnable+0xc>
8110c254:	003b68fa 	trap	3
8110c258:	dfc00315 	stw	ra,12(sp)
8110c25c:	df000215 	stw	fp,8(sp)
8110c260:	df000204 	addi	fp,sp,8
8110c264:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c268:	01000284 	movi	r4,10
8110c26c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c270:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c274:	e0bfff17 	ldw	r2,-4(fp)
8110c278:	1000051e 	bne	r2,zero,8110c290 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110c27c:	e0fffe17 	ldw	r3,-8(fp)
8110c280:	00bffbc4 	movi	r2,-17
8110c284:	1884703a 	and	r2,r3,r2
8110c288:	e0bffe15 	stw	r2,-8(fp)
8110c28c:	00000306 	br	8110c29c <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110c290:	e0bffe17 	ldw	r2,-8(fp)
8110c294:	10800414 	ori	r2,r2,16
8110c298:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c29c:	e17ffe17 	ldw	r5,-8(fp)
8110c2a0:	01000284 	movi	r4,10
8110c2a4:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c2a8:	00800044 	movi	r2,1
}
8110c2ac:	e037883a 	mov	sp,fp
8110c2b0:	dfc00117 	ldw	ra,4(sp)
8110c2b4:	df000017 	ldw	fp,0(sp)
8110c2b8:	dec00204 	addi	sp,sp,8
8110c2bc:	f800283a 	ret

8110c2c0 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110c2c0:	defffc04 	addi	sp,sp,-16
8110c2c4:	de00012e 	bgeu	sp,et,8110c2cc <bSyncCtrCh6OutEnable+0xc>
8110c2c8:	003b68fa 	trap	3
8110c2cc:	dfc00315 	stw	ra,12(sp)
8110c2d0:	df000215 	stw	fp,8(sp)
8110c2d4:	df000204 	addi	fp,sp,8
8110c2d8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c2dc:	01000284 	movi	r4,10
8110c2e0:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c2e4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c2e8:	e0bfff17 	ldw	r2,-4(fp)
8110c2ec:	1000051e 	bne	r2,zero,8110c304 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110c2f0:	e0fffe17 	ldw	r3,-8(fp)
8110c2f4:	00bff7c4 	movi	r2,-33
8110c2f8:	1884703a 	and	r2,r3,r2
8110c2fc:	e0bffe15 	stw	r2,-8(fp)
8110c300:	00000306 	br	8110c310 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110c304:	e0bffe17 	ldw	r2,-8(fp)
8110c308:	10800814 	ori	r2,r2,32
8110c30c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c310:	e17ffe17 	ldw	r5,-8(fp)
8110c314:	01000284 	movi	r4,10
8110c318:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c31c:	00800044 	movi	r2,1
}
8110c320:	e037883a 	mov	sp,fp
8110c324:	dfc00117 	ldw	ra,4(sp)
8110c328:	df000017 	ldw	fp,0(sp)
8110c32c:	dec00204 	addi	sp,sp,8
8110c330:	f800283a 	ret

8110c334 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110c334:	defffc04 	addi	sp,sp,-16
8110c338:	de00012e 	bgeu	sp,et,8110c340 <bSyncCtrCh7OutEnable+0xc>
8110c33c:	003b68fa 	trap	3
8110c340:	dfc00315 	stw	ra,12(sp)
8110c344:	df000215 	stw	fp,8(sp)
8110c348:	df000204 	addi	fp,sp,8
8110c34c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c350:	01000284 	movi	r4,10
8110c354:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c358:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c35c:	e0bfff17 	ldw	r2,-4(fp)
8110c360:	1000051e 	bne	r2,zero,8110c378 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110c364:	e0fffe17 	ldw	r3,-8(fp)
8110c368:	00bfefc4 	movi	r2,-65
8110c36c:	1884703a 	and	r2,r3,r2
8110c370:	e0bffe15 	stw	r2,-8(fp)
8110c374:	00000306 	br	8110c384 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110c378:	e0bffe17 	ldw	r2,-8(fp)
8110c37c:	10801014 	ori	r2,r2,64
8110c380:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c384:	e17ffe17 	ldw	r5,-8(fp)
8110c388:	01000284 	movi	r4,10
8110c38c:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c390:	00800044 	movi	r2,1
}
8110c394:	e037883a 	mov	sp,fp
8110c398:	dfc00117 	ldw	ra,4(sp)
8110c39c:	df000017 	ldw	fp,0(sp)
8110c3a0:	dec00204 	addi	sp,sp,8
8110c3a4:	f800283a 	ret

8110c3a8 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110c3a8:	defffc04 	addi	sp,sp,-16
8110c3ac:	de00012e 	bgeu	sp,et,8110c3b4 <bSyncCtrCh8OutEnable+0xc>
8110c3b0:	003b68fa 	trap	3
8110c3b4:	dfc00315 	stw	ra,12(sp)
8110c3b8:	df000215 	stw	fp,8(sp)
8110c3bc:	df000204 	addi	fp,sp,8
8110c3c0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c3c4:	01000284 	movi	r4,10
8110c3c8:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c3cc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c3d0:	e0bfff17 	ldw	r2,-4(fp)
8110c3d4:	1000051e 	bne	r2,zero,8110c3ec <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110c3d8:	e0fffe17 	ldw	r3,-8(fp)
8110c3dc:	00bfdfc4 	movi	r2,-129
8110c3e0:	1884703a 	and	r2,r3,r2
8110c3e4:	e0bffe15 	stw	r2,-8(fp)
8110c3e8:	00000306 	br	8110c3f8 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110c3ec:	e0bffe17 	ldw	r2,-8(fp)
8110c3f0:	10802014 	ori	r2,r2,128
8110c3f4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c3f8:	e17ffe17 	ldw	r5,-8(fp)
8110c3fc:	01000284 	movi	r4,10
8110c400:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c404:	00800044 	movi	r2,1
}
8110c408:	e037883a 	mov	sp,fp
8110c40c:	dfc00117 	ldw	ra,4(sp)
8110c410:	df000017 	ldw	fp,0(sp)
8110c414:	dec00204 	addi	sp,sp,8
8110c418:	f800283a 	ret

8110c41c <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110c41c:	defffc04 	addi	sp,sp,-16
8110c420:	de00012e 	bgeu	sp,et,8110c428 <bSyncIrqEnableError+0xc>
8110c424:	003b68fa 	trap	3
8110c428:	dfc00315 	stw	ra,12(sp)
8110c42c:	df000215 	stw	fp,8(sp)
8110c430:	df000204 	addi	fp,sp,8
8110c434:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c438:	01000044 	movi	r4,1
8110c43c:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c440:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c444:	e0bfff17 	ldw	r2,-4(fp)
8110c448:	1000051e 	bne	r2,zero,8110c460 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110c44c:	e0fffe17 	ldw	r3,-8(fp)
8110c450:	00bfff44 	movi	r2,-3
8110c454:	1884703a 	and	r2,r3,r2
8110c458:	e0bffe15 	stw	r2,-8(fp)
8110c45c:	00000306 	br	8110c46c <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110c460:	e0bffe17 	ldw	r2,-8(fp)
8110c464:	10800094 	ori	r2,r2,2
8110c468:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c46c:	e17ffe17 	ldw	r5,-8(fp)
8110c470:	01000044 	movi	r4,1
8110c474:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c478:	00800044 	movi	r2,1
}
8110c47c:	e037883a 	mov	sp,fp
8110c480:	dfc00117 	ldw	ra,4(sp)
8110c484:	df000017 	ldw	fp,0(sp)
8110c488:	dec00204 	addi	sp,sp,8
8110c48c:	f800283a 	ret

8110c490 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110c490:	defffc04 	addi	sp,sp,-16
8110c494:	de00012e 	bgeu	sp,et,8110c49c <bSyncIrqEnableBlank+0xc>
8110c498:	003b68fa 	trap	3
8110c49c:	dfc00315 	stw	ra,12(sp)
8110c4a0:	df000215 	stw	fp,8(sp)
8110c4a4:	df000204 	addi	fp,sp,8
8110c4a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c4ac:	01000044 	movi	r4,1
8110c4b0:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c4b4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c4b8:	e0bfff17 	ldw	r2,-4(fp)
8110c4bc:	1000051e 	bne	r2,zero,8110c4d4 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110c4c0:	e0fffe17 	ldw	r3,-8(fp)
8110c4c4:	00bfff84 	movi	r2,-2
8110c4c8:	1884703a 	and	r2,r3,r2
8110c4cc:	e0bffe15 	stw	r2,-8(fp)
8110c4d0:	00000306 	br	8110c4e0 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110c4d4:	e0bffe17 	ldw	r2,-8(fp)
8110c4d8:	10800054 	ori	r2,r2,1
8110c4dc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c4e0:	e17ffe17 	ldw	r5,-8(fp)
8110c4e4:	01000044 	movi	r4,1
8110c4e8:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c4ec:	00800044 	movi	r2,1
}
8110c4f0:	e037883a 	mov	sp,fp
8110c4f4:	dfc00117 	ldw	ra,4(sp)
8110c4f8:	df000017 	ldw	fp,0(sp)
8110c4fc:	dec00204 	addi	sp,sp,8
8110c500:	f800283a 	ret

8110c504 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110c504:	defffc04 	addi	sp,sp,-16
8110c508:	de00012e 	bgeu	sp,et,8110c510 <bSyncIrqFlagClrError+0xc>
8110c50c:	003b68fa 	trap	3
8110c510:	dfc00315 	stw	ra,12(sp)
8110c514:	df000215 	stw	fp,8(sp)
8110c518:	df000204 	addi	fp,sp,8
8110c51c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c520:	01000084 	movi	r4,2
8110c524:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c528:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c52c:	e0bfff17 	ldw	r2,-4(fp)
8110c530:	1000051e 	bne	r2,zero,8110c548 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c534:	e0fffe17 	ldw	r3,-8(fp)
8110c538:	00bfff44 	movi	r2,-3
8110c53c:	1884703a 	and	r2,r3,r2
8110c540:	e0bffe15 	stw	r2,-8(fp)
8110c544:	00000306 	br	8110c554 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c548:	e0bffe17 	ldw	r2,-8(fp)
8110c54c:	10800094 	ori	r2,r2,2
8110c550:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c554:	e17ffe17 	ldw	r5,-8(fp)
8110c558:	01000084 	movi	r4,2
8110c55c:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c560:	00800044 	movi	r2,1
}
8110c564:	e037883a 	mov	sp,fp
8110c568:	dfc00117 	ldw	ra,4(sp)
8110c56c:	df000017 	ldw	fp,0(sp)
8110c570:	dec00204 	addi	sp,sp,8
8110c574:	f800283a 	ret

8110c578 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110c578:	defffc04 	addi	sp,sp,-16
8110c57c:	de00012e 	bgeu	sp,et,8110c584 <bSyncIrqFlagClrBlank+0xc>
8110c580:	003b68fa 	trap	3
8110c584:	dfc00315 	stw	ra,12(sp)
8110c588:	df000215 	stw	fp,8(sp)
8110c58c:	df000204 	addi	fp,sp,8
8110c590:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c594:	01000084 	movi	r4,2
8110c598:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c59c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c5a0:	e0bfff17 	ldw	r2,-4(fp)
8110c5a4:	1000051e 	bne	r2,zero,8110c5bc <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c5a8:	e0fffe17 	ldw	r3,-8(fp)
8110c5ac:	00bfff84 	movi	r2,-2
8110c5b0:	1884703a 	and	r2,r3,r2
8110c5b4:	e0bffe15 	stw	r2,-8(fp)
8110c5b8:	00000306 	br	8110c5c8 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c5bc:	e0bffe17 	ldw	r2,-8(fp)
8110c5c0:	10800054 	ori	r2,r2,1
8110c5c4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c5c8:	e17ffe17 	ldw	r5,-8(fp)
8110c5cc:	01000084 	movi	r4,2
8110c5d0:	110c7140 	call	8110c714 <bSyncWriteReg>
	return TRUE;
8110c5d4:	00800044 	movi	r2,1
}
8110c5d8:	e037883a 	mov	sp,fp
8110c5dc:	dfc00117 	ldw	ra,4(sp)
8110c5e0:	df000017 	ldw	fp,0(sp)
8110c5e4:	dec00204 	addi	sp,sp,8
8110c5e8:	f800283a 	ret

8110c5ec <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110c5ec:	defffc04 	addi	sp,sp,-16
8110c5f0:	de00012e 	bgeu	sp,et,8110c5f8 <bSyncIrqFlagError+0xc>
8110c5f4:	003b68fa 	trap	3
8110c5f8:	dfc00315 	stw	ra,12(sp)
8110c5fc:	df000215 	stw	fp,8(sp)
8110c600:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c604:	010000c4 	movi	r4,3
8110c608:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c60c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110c610:	e0bfff17 	ldw	r2,-4(fp)
8110c614:	1080008c 	andi	r2,r2,2
8110c618:	10000326 	beq	r2,zero,8110c628 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110c61c:	00800044 	movi	r2,1
8110c620:	e0bffe15 	stw	r2,-8(fp)
8110c624:	00000106 	br	8110c62c <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110c628:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c62c:	e0bffe17 	ldw	r2,-8(fp)
}
8110c630:	e037883a 	mov	sp,fp
8110c634:	dfc00117 	ldw	ra,4(sp)
8110c638:	df000017 	ldw	fp,0(sp)
8110c63c:	dec00204 	addi	sp,sp,8
8110c640:	f800283a 	ret

8110c644 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110c644:	defffc04 	addi	sp,sp,-16
8110c648:	de00012e 	bgeu	sp,et,8110c650 <bSyncIrqFlagBlank+0xc>
8110c64c:	003b68fa 	trap	3
8110c650:	dfc00315 	stw	ra,12(sp)
8110c654:	df000215 	stw	fp,8(sp)
8110c658:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c65c:	010000c4 	movi	r4,3
8110c660:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c664:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110c668:	e0bfff17 	ldw	r2,-4(fp)
8110c66c:	1080004c 	andi	r2,r2,1
8110c670:	10000326 	beq	r2,zero,8110c680 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110c674:	00800044 	movi	r2,1
8110c678:	e0bffe15 	stw	r2,-8(fp)
8110c67c:	00000106 	br	8110c684 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110c680:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c684:	e0bffe17 	ldw	r2,-8(fp)
}
8110c688:	e037883a 	mov	sp,fp
8110c68c:	dfc00117 	ldw	ra,4(sp)
8110c690:	df000017 	ldw	fp,0(sp)
8110c694:	dec00204 	addi	sp,sp,8
8110c698:	f800283a 	ret

8110c69c <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110c69c:	defffd04 	addi	sp,sp,-12
8110c6a0:	de00012e 	bgeu	sp,et,8110c6a8 <uliSyncGetCtr+0xc>
8110c6a4:	003b68fa 	trap	3
8110c6a8:	dfc00215 	stw	ra,8(sp)
8110c6ac:	df000115 	stw	fp,4(sp)
8110c6b0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c6b4:	01000284 	movi	r4,10
8110c6b8:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c6bc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c6c0:	e0bfff17 	ldw	r2,-4(fp)
}
8110c6c4:	e037883a 	mov	sp,fp
8110c6c8:	dfc00117 	ldw	ra,4(sp)
8110c6cc:	df000017 	ldw	fp,0(sp)
8110c6d0:	dec00204 	addi	sp,sp,8
8110c6d4:	f800283a 	ret

8110c6d8 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110c6d8:	defffd04 	addi	sp,sp,-12
8110c6dc:	de00012e 	bgeu	sp,et,8110c6e4 <uliSyncReadStatus+0xc>
8110c6e0:	003b68fa 	trap	3
8110c6e4:	dfc00215 	stw	ra,8(sp)
8110c6e8:	df000115 	stw	fp,4(sp)
8110c6ec:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c6f0:	0009883a 	mov	r4,zero
8110c6f4:	110c7700 	call	8110c770 <uliSyncReadReg>
8110c6f8:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110c6fc:	e0bfff17 	ldw	r2,-4(fp)
}
8110c700:	e037883a 	mov	sp,fp
8110c704:	dfc00117 	ldw	ra,4(sp)
8110c708:	df000017 	ldw	fp,0(sp)
8110c70c:	dec00204 	addi	sp,sp,8
8110c710:	f800283a 	ret

8110c714 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110c714:	defffc04 	addi	sp,sp,-16
8110c718:	de00012e 	bgeu	sp,et,8110c720 <bSyncWriteReg+0xc>
8110c71c:	003b68fa 	trap	3
8110c720:	df000315 	stw	fp,12(sp)
8110c724:	df000304 	addi	fp,sp,12
8110c728:	e13ffe15 	stw	r4,-8(fp)
8110c72c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c730:	00a00034 	movhi	r2,32768
8110c734:	10810004 	addi	r2,r2,1024
8110c738:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110c73c:	e0bffe17 	ldw	r2,-8(fp)
8110c740:	1085883a 	add	r2,r2,r2
8110c744:	1085883a 	add	r2,r2,r2
8110c748:	1007883a 	mov	r3,r2
8110c74c:	e0bffd17 	ldw	r2,-12(fp)
8110c750:	10c5883a 	add	r2,r2,r3
8110c754:	e0ffff17 	ldw	r3,-4(fp)
8110c758:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110c75c:	00800044 	movi	r2,1
}
8110c760:	e037883a 	mov	sp,fp
8110c764:	df000017 	ldw	fp,0(sp)
8110c768:	dec00104 	addi	sp,sp,4
8110c76c:	f800283a 	ret

8110c770 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110c770:	defffc04 	addi	sp,sp,-16
8110c774:	de00012e 	bgeu	sp,et,8110c77c <uliSyncReadReg+0xc>
8110c778:	003b68fa 	trap	3
8110c77c:	df000315 	stw	fp,12(sp)
8110c780:	df000304 	addi	fp,sp,12
8110c784:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c788:	00a00034 	movhi	r2,32768
8110c78c:	10810004 	addi	r2,r2,1024
8110c790:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110c794:	e0bfff17 	ldw	r2,-4(fp)
8110c798:	1085883a 	add	r2,r2,r2
8110c79c:	1085883a 	add	r2,r2,r2
8110c7a0:	1007883a 	mov	r3,r2
8110c7a4:	e0bffd17 	ldw	r2,-12(fp)
8110c7a8:	10c5883a 	add	r2,r2,r3
8110c7ac:	10800017 	ldw	r2,0(r2)
8110c7b0:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110c7b4:	e0bffe17 	ldw	r2,-8(fp)
}
8110c7b8:	e037883a 	mov	sp,fp
8110c7bc:	df000017 	ldw	fp,0(sp)
8110c7c0:	dec00104 	addi	sp,sp,4
8110c7c4:	f800283a 	ret

8110c7c8 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110c7c8:	defff804 	addi	sp,sp,-32
8110c7cc:	de00012e 	bgeu	sp,et,8110c7d4 <vDataControlTask+0xc>
8110c7d0:	003b68fa 	trap	3
8110c7d4:	dfc00715 	stw	ra,28(sp)
8110c7d8:	df000615 	stw	fp,24(sp)
8110c7dc:	df000604 	addi	fp,sp,24
8110c7e0:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110c7e4:	e0bffd17 	ldw	r2,-12(fp)
8110c7e8:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110c7ec:	d0a05c17 	ldw	r2,-32400(gp)
8110c7f0:	100f883a 	mov	r7,r2
8110c7f4:	01800804 	movi	r6,32
8110c7f8:	01400044 	movi	r5,1
8110c7fc:	01204534 	movhi	r4,33044
8110c800:	211d2704 	addi	r4,r4,29852
8110c804:	111c1380 	call	8111c138 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110c808:	e0bffa17 	ldw	r2,-24(fp)
8110c80c:	00c00044 	movi	r3,1
8110c810:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110c814:	d0a05917 	ldw	r2,-32412(gp)
8110c818:	1009883a 	mov	r4,r2
8110c81c:	1138bc00 	call	81138bc0 <OSQFlush>
8110c820:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110c824:	e0bffc03 	ldbu	r2,-16(fp)
8110c828:	10803fcc 	andi	r2,r2,255
8110c82c:	10000126 	beq	r2,zero,8110c834 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110c830:	111896c0 	call	8111896c <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110c834:	e0bffc04 	addi	r2,fp,-16
8110c838:	100d883a 	mov	r6,r2
8110c83c:	000b883a 	mov	r5,zero
8110c840:	01204574 	movhi	r4,33045
8110c844:	21177504 	addi	r4,r4,24020
8110c848:	1138c800 	call	81138c80 <OSQPend>
8110c84c:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110c850:	000f883a 	mov	r7,zero
8110c854:	01800144 	movi	r6,5
8110c858:	000b883a 	mov	r5,zero
8110c85c:	0009883a 	mov	r4,zero
8110c860:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
	}
8110c864:	003ff306 	br	8110c834 <__reset+0xfb0ec834>

8110c868 <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
8110c868:	defff604 	addi	sp,sp,-40
8110c86c:	de00012e 	bgeu	sp,et,8110c874 <vFeeTask+0xc>
8110c870:	003b68fa 	trap	3
8110c874:	dfc00915 	stw	ra,36(sp)
8110c878:	df000815 	stw	fp,32(sp)
8110c87c:	df000804 	addi	fp,sp,32
8110c880:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110c884:	e03ffa15 	stw	zero,-24(fp)
	TCcdMemMap *xCcdMapLocal;
	unsigned char ucReadout;
	alt_u16 usiLengthBlocks;


	pxNFee = ( TNFee * ) task_data;
8110c888:	e0bfff17 	ldw	r2,-4(fp)
8110c88c:	d0a05115 	stw	r2,-32444(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110c890:	d0e05c17 	ldw	r3,-32400(gp)
8110c894:	d0a05117 	ldw	r2,-32444(gp)
8110c898:	10800003 	ldbu	r2,0(r2)
8110c89c:	10803fcc 	andi	r2,r2,255
8110c8a0:	100d883a 	mov	r6,r2
8110c8a4:	01604534 	movhi	r5,33044
8110c8a8:	295d3004 	addi	r5,r5,29888
8110c8ac:	1809883a 	mov	r4,r3
8110c8b0:	111ba9c0 	call	8111ba9c <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110c8b4:	d0a05117 	ldw	r2,-32444(gp)
8110c8b8:	1009883a 	mov	r4,r2
8110c8bc:	110dabc0 	call	8110dabc <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110c8c0:	d0a05117 	ldw	r2,-32444(gp)
8110c8c4:	10802c17 	ldw	r2,176(r2)
8110c8c8:	10c00328 	cmpgeui	r3,r2,12
8110c8cc:	1802991e 	bne	r3,zero,8110d334 <vFeeTask+0xacc>
8110c8d0:	100690ba 	slli	r3,r2,2
8110c8d4:	00a04474 	movhi	r2,33041
8110c8d8:	10b23a04 	addi	r2,r2,-14104
8110c8dc:	1885883a 	add	r2,r3,r2
8110c8e0:	10800017 	ldw	r2,0(r2)
8110c8e4:	1000683a 	jmp	r2
8110c8e8:	8110c918 	cmpnei	r4,r16,17188
8110c8ec:	8110caf8 	rdprs	r4,r16,17195
8110c8f0:	8110cb7c 	xorhi	r4,r16,17197
8110c8f4:	8110cc10 	cmplti	r4,r16,17200
8110c8f8:	8110d028 	cmpgeui	r4,r16,17216
8110c8fc:	8110c9a0 	cmpeqi	r4,r16,17190
8110c900:	8110cb8c 	andi	r4,r16,17198
8110c904:	8110cfe8 	cmpgeui	r4,r16,17215
8110c908:	8110d334 	orhi	r4,r16,17228
8110c90c:	8110d368 	cmpgeui	r4,r16,17229
8110c910:	8110cc94 	ori	r4,r16,17202
8110c914:	8110d208 	cmpgei	r4,r16,17224
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110c918:	d0a05117 	ldw	r2,-32444(gp)
8110c91c:	10800003 	ldbu	r2,0(r2)
8110c920:	10803fcc 	andi	r2,r2,255
8110c924:	1085883a 	add	r2,r2,r2
8110c928:	1087883a 	add	r3,r2,r2
8110c92c:	d0a06404 	addi	r2,gp,-32368
8110c930:	1885883a 	add	r2,r3,r2
8110c934:	10800017 	ldw	r2,0(r2)
8110c938:	1009883a 	mov	r4,r2
8110c93c:	1138bc00 	call	81138bc0 <OSQFlush>
8110c940:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110c944:	e0bffd03 	ldbu	r2,-12(fp)
8110c948:	10803fcc 	andi	r2,r2,255
8110c94c:	10000126 	beq	r2,zero,8110c954 <vFeeTask+0xec>
					vFailFlushNFEEQueue();
8110c950:	1118a040 	call	81118a04 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110c954:	d0a05117 	ldw	r2,-32444(gp)
8110c958:	10800003 	ldbu	r2,0(r2)
8110c95c:	10803fcc 	andi	r2,r2,255
8110c960:	1085883a 	add	r2,r2,r2
8110c964:	1087883a 	add	r3,r2,r2
8110c968:	d0a05604 	addi	r2,gp,-32424
8110c96c:	1885883a 	add	r2,r3,r2
8110c970:	10800017 	ldw	r2,0(r2)
8110c974:	1009883a 	mov	r4,r2
8110c978:	1138bc00 	call	81138bc0 <OSQFlush>
8110c97c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110c980:	e0bffd03 	ldbu	r2,-12(fp)
8110c984:	10803fcc 	andi	r2,r2,255
8110c988:	10000126 	beq	r2,zero,8110c990 <vFeeTask+0x128>
					vFailFlushNFEEQueue();
8110c98c:	1118a040 	call	81118a04 <vFailFlushNFEEQueue>
				}				

				pxNFee->xControl.eMode = sToFeeConfig;
8110c990:	d0a05117 	ldw	r2,-32444(gp)
8110c994:	00c00144 	movi	r3,5
8110c998:	10c02c15 	stw	r3,176(r2)

				break;
8110c99c:	00027506 	br	8110d374 <vFeeTask+0xb0c>
			case sToFeeConfig: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110c9a0:	d0e05c17 	ldw	r3,-32400(gp)
8110c9a4:	d0a05117 	ldw	r2,-32444(gp)
8110c9a8:	10800003 	ldbu	r2,0(r2)
8110c9ac:	10803fcc 	andi	r2,r2,255
8110c9b0:	100d883a 	mov	r6,r2
8110c9b4:	01604534 	movhi	r5,33044
8110c9b8:	295d3704 	addi	r5,r5,29916
8110c9bc:	1809883a 	mov	r4,r3
8110c9c0:	111ba9c0 	call	8111ba9c <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110c9c4:	d0a05117 	ldw	r2,-32444(gp)
8110c9c8:	10802217 	ldw	r2,136(r2)
8110c9cc:	10800058 	cmpnei	r2,r2,1
8110c9d0:	10000a1e 	bne	r2,zero,8110c9fc <vFeeTask+0x194>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110c9d4:	e0fff803 	ldbu	r3,-32(fp)
8110c9d8:	00a045b4 	movhi	r2,33046
8110c9dc:	10b6a304 	addi	r2,r2,-9588
8110c9e0:	180690fa 	slli	r3,r3,3
8110c9e4:	10c5883a 	add	r2,r2,r3
8110c9e8:	10800017 	ldw	r2,0(r2)
8110c9ec:	1009883a 	mov	r4,r2
8110c9f0:	11381100 	call	81138110 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110c9f4:	d0a05117 	ldw	r2,-32444(gp)
8110c9f8:	10002215 	stw	zero,136(r2)
				}

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110c9fc:	d0a05117 	ldw	r2,-32444(gp)
8110ca00:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110ca04:	d0a05117 	ldw	r2,-32444(gp)
8110ca08:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110ca0c:	d0a05117 	ldw	r2,-32444(gp)
8110ca10:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110ca14:	d0a05117 	ldw	r2,-32444(gp)
8110ca18:	00c00044 	movi	r3,1
8110ca1c:	10c02115 	stw	r3,132(r2)
				pxNFee->xControl.ucTimeCode = 0;
8110ca20:	d0a05117 	ldw	r2,-32444(gp)
8110ca24:	10002a05 	stb	zero,168(r2)

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110ca28:	d0a05117 	ldw	r2,-32444(gp)
8110ca2c:	10800003 	ldbu	r2,0(r2)
8110ca30:	10803fcc 	andi	r2,r2,255
8110ca34:	1085883a 	add	r2,r2,r2
8110ca38:	1087883a 	add	r3,r2,r2
8110ca3c:	d0a06404 	addi	r2,gp,-32368
8110ca40:	1885883a 	add	r2,r3,r2
8110ca44:	10800017 	ldw	r2,0(r2)
8110ca48:	1009883a 	mov	r4,r2
8110ca4c:	1138bc00 	call	81138bc0 <OSQFlush>
8110ca50:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110ca54:	e0bffd03 	ldbu	r2,-12(fp)
8110ca58:	10803fcc 	andi	r2,r2,255
8110ca5c:	10000126 	beq	r2,zero,8110ca64 <vFeeTask+0x1fc>
					vFailFlushNFEEQueue();
8110ca60:	1118a040 	call	81118a04 <vFailFlushNFEEQueue>
				}

				/* Clear the Queue that indicates when Sync Signals occours */
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110ca64:	d0a05117 	ldw	r2,-32444(gp)
8110ca68:	10800003 	ldbu	r2,0(r2)
8110ca6c:	10803fcc 	andi	r2,r2,255
8110ca70:	1085883a 	add	r2,r2,r2
8110ca74:	1087883a 	add	r3,r2,r2
8110ca78:	d0a05604 	addi	r2,gp,-32424
8110ca7c:	1885883a 	add	r2,r3,r2
8110ca80:	10800017 	ldw	r2,0(r2)
8110ca84:	1009883a 	mov	r4,r2
8110ca88:	1138bc00 	call	81138bc0 <OSQFlush>
8110ca8c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110ca90:	e0bffd03 	ldbu	r2,-12(fp)
8110ca94:	10803fcc 	andi	r2,r2,255
8110ca98:	10000126 	beq	r2,zero,8110caa0 <vFeeTask+0x238>
					vFailFlushNFEEQueue();
8110ca9c:	1118a040 	call	81118a04 <vFailFlushNFEEQueue>
				}

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110caa0:	d0a05117 	ldw	r2,-32444(gp)
8110caa4:	10808804 	addi	r2,r2,544
8110caa8:	1009883a 	mov	r4,r2
8110caac:	110d8880 	call	8110d888 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110cab0:	d0a05117 	ldw	r2,-32444(gp)
8110cab4:	10002615 	stw	zero,152(r2)


				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap);
8110cab8:	d0a05117 	ldw	r2,-32444(gp)
8110cabc:	10804204 	addi	r2,r2,264
8110cac0:	1009883a 	mov	r4,r2
8110cac4:	110d7ec0 	call	8110d7ec <bDisableRmapIRQ>


				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110cac8:	d0a05117 	ldw	r2,-32444(gp)
8110cacc:	10803b04 	addi	r2,r2,236
8110cad0:	1009883a 	mov	r4,r2
8110cad4:	110d9b40 	call	8110d9b4 <bDisAndClrDbBuffer>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);
8110cad8:	d0a05117 	ldw	r2,-32444(gp)
8110cadc:	10808804 	addi	r2,r2,544
8110cae0:	1009883a 	mov	r4,r2
8110cae4:	11093a00 	call	811093a0 <bSpwcClearTimecode>

				pxNFee->xControl.eMode = sFeeConfig;
8110cae8:	d0a05117 	ldw	r2,-32444(gp)
8110caec:	00c00044 	movi	r3,1
8110caf0:	10c02c15 	stw	r3,176(r2)
				break;
8110caf4:	00021f06 	br	8110d374 <vFeeTask+0xb0c>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110caf8:	d0a05117 	ldw	r2,-32444(gp)
8110cafc:	10800003 	ldbu	r2,0(r2)
8110cb00:	10803fcc 	andi	r2,r2,255
8110cb04:	1085883a 	add	r2,r2,r2
8110cb08:	1087883a 	add	r3,r2,r2
8110cb0c:	d0a06404 	addi	r2,gp,-32368
8110cb10:	1885883a 	add	r2,r3,r2
8110cb14:	10800017 	ldw	r2,0(r2)
8110cb18:	e0fffd04 	addi	r3,fp,-12
8110cb1c:	180d883a 	mov	r6,r3
8110cb20:	000b883a 	mov	r5,zero
8110cb24:	1009883a 	mov	r4,r2
8110cb28:	1138c800 	call	81138c80 <OSQPend>
8110cb2c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cb30:	e0bffd03 	ldbu	r2,-12(fp)
8110cb34:	10803fcc 	andi	r2,r2,255
8110cb38:	1000061e 	bne	r2,zero,8110cb54 <vFeeTask+0x2ec>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110cb3c:	d0a05117 	ldw	r2,-32444(gp)
8110cb40:	e0fffe17 	ldw	r3,-8(fp)
8110cb44:	180b883a 	mov	r5,r3
8110cb48:	1009883a 	mov	r4,r2
8110cb4c:	110d3780 	call	8110d378 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cb50:	00020806 	br	8110d374 <vFeeTask+0xb0c>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110cb54:	d0e05c17 	ldw	r3,-32400(gp)
8110cb58:	d0a05117 	ldw	r2,-32444(gp)
8110cb5c:	10800003 	ldbu	r2,0(r2)
8110cb60:	10803fcc 	andi	r2,r2,255
8110cb64:	100d883a 	mov	r6,r2
8110cb68:	01604534 	movhi	r5,33044
8110cb6c:	295d3e04 	addi	r5,r5,29944
8110cb70:	1809883a 	mov	r4,r3
8110cb74:	111ba9c0 	call	8111ba9c <fprintf>
					#endif
				}

				break;
8110cb78:	0001fe06 	br	8110d374 <vFeeTask+0xb0c>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110cb7c:	d0a05117 	ldw	r2,-32444(gp)
8110cb80:	00c00184 	movi	r3,6
8110cb84:	10c02c15 	stw	r3,176(r2)
				break;
8110cb88:	0001fa06 	br	8110d374 <vFeeTask+0xb0c>
				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
			case sToFeeStandBy: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110cb8c:	d0e05c17 	ldw	r3,-32400(gp)
8110cb90:	d0a05117 	ldw	r2,-32444(gp)
8110cb94:	10800003 	ldbu	r2,0(r2)
8110cb98:	10803fcc 	andi	r2,r2,255
8110cb9c:	100d883a 	mov	r6,r2
8110cba0:	01604534 	movhi	r5,33044
8110cba4:	295d4a04 	addi	r5,r5,29992
8110cba8:	1809883a 	mov	r4,r3
8110cbac:	111ba9c0 	call	8111ba9c <fprintf>
				#endif

				pxNFee->xControl.bSimulating = TRUE;
8110cbb0:	d0a05117 	ldw	r2,-32444(gp)
8110cbb4:	00c00044 	movi	r3,1
8110cbb8:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110cbbc:	d0a05117 	ldw	r2,-32444(gp)
8110cbc0:	10002315 	stw	zero,140(r2)

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110cbc4:	d0a05117 	ldw	r2,-32444(gp)
8110cbc8:	10803b04 	addi	r2,r2,236
8110cbcc:	1009883a 	mov	r4,r2
8110cbd0:	110d9b40 	call	8110d9b4 <bDisAndClrDbBuffer>


				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap);
8110cbd4:	d0a05117 	ldw	r2,-32444(gp)
8110cbd8:	10804204 	addi	r2,r2,264
8110cbdc:	1009883a 	mov	r4,r2
8110cbe0:	110d8380 	call	8110d838 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110cbe4:	d0a05117 	ldw	r2,-32444(gp)
8110cbe8:	10808804 	addi	r2,r2,544
8110cbec:	1009883a 	mov	r4,r2
8110cbf0:	110d8e80 	call	8110d8e8 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110cbf4:	d0a05117 	ldw	r2,-32444(gp)
8110cbf8:	00c00044 	movi	r3,1
8110cbfc:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.eMode = sFeeStandBy;
8110cc00:	d0a05117 	ldw	r2,-32444(gp)
8110cc04:	00c000c4 	movi	r3,3
8110cc08:	10c02c15 	stw	r3,176(r2)
				break;
8110cc0c:	0001d906 	br	8110d374 <vFeeTask+0xb0c>

			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cc10:	d0a05117 	ldw	r2,-32444(gp)
8110cc14:	10800003 	ldbu	r2,0(r2)
8110cc18:	10803fcc 	andi	r2,r2,255
8110cc1c:	1085883a 	add	r2,r2,r2
8110cc20:	1087883a 	add	r3,r2,r2
8110cc24:	d0a06404 	addi	r2,gp,-32368
8110cc28:	1885883a 	add	r2,r3,r2
8110cc2c:	10800017 	ldw	r2,0(r2)
8110cc30:	e0fffd04 	addi	r3,fp,-12
8110cc34:	180d883a 	mov	r6,r3
8110cc38:	000b883a 	mov	r5,zero
8110cc3c:	1009883a 	mov	r4,r2
8110cc40:	1138c800 	call	81138c80 <OSQPend>
8110cc44:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cc48:	e0bffd03 	ldbu	r2,-12(fp)
8110cc4c:	10803fcc 	andi	r2,r2,255
8110cc50:	1000061e 	bne	r2,zero,8110cc6c <vFeeTask+0x404>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110cc54:	d0a05117 	ldw	r2,-32444(gp)
8110cc58:	e0fffe17 	ldw	r3,-8(fp)
8110cc5c:	180b883a 	mov	r5,r3
8110cc60:	1009883a 	mov	r4,r2
8110cc64:	110d4e80 	call	8110d4e8 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cc68:	0001c206 	br	8110d374 <vFeeTask+0xb0c>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110cc6c:	d0e05c17 	ldw	r3,-32400(gp)
8110cc70:	d0a05117 	ldw	r2,-32444(gp)
8110cc74:	10800003 	ldbu	r2,0(r2)
8110cc78:	10803fcc 	andi	r2,r2,255
8110cc7c:	100d883a 	mov	r6,r2
8110cc80:	01604534 	movhi	r5,33044
8110cc84:	295d3e04 	addi	r5,r5,29944
8110cc88:	1809883a 	mov	r4,r3
8110cc8c:	111ba9c0 	call	8111ba9c <fprintf>
					#endif
				}

				break;
8110cc90:	0001b806 	br	8110d374 <vFeeTask+0xb0c>
			case sSIMTestFullPattern:

				pxNFee->xControl.bUsingDMA = TRUE;
8110cc94:	d0a05117 	ldw	r2,-32444(gp)
8110cc98:	00c00044 	movi	r3,1
8110cc9c:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110cca0:	d0a05117 	ldw	r2,-32444(gp)
8110cca4:	00c00044 	movi	r3,1
8110cca8:	10c02715 	stw	r3,156(r2)

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110ccac:	d0a05117 	ldw	r2,-32444(gp)
8110ccb0:	10803b04 	addi	r2,r2,236
8110ccb4:	1009883a 	mov	r4,r2
8110ccb8:	110d9480 	call	8110d948 <bEnableDbBuffer>

				/* Configurar o tamanho normal do double buffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  */

				tCodeNext = (bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire) + 1) % 4;
8110ccbc:	d0a05117 	ldw	r2,-32444(gp)
8110ccc0:	10808804 	addi	r2,r2,544
8110ccc4:	1009883a 	mov	r4,r2
8110ccc8:	11093100 	call	81109310 <bSpwcGetTimecode>
8110cccc:	10800044 	addi	r2,r2,1
8110ccd0:	108000cc 	andi	r2,r2,3
8110ccd4:	e0bffb15 	stw	r2,-20(fp)
				if ( tCodeNext == 0 ) {
8110ccd8:	e0bffb17 	ldw	r2,-20(fp)
8110ccdc:	10000f1e 	bne	r2,zero,8110cd1c <vFeeTask+0x4b4>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110cce0:	d0a05117 	ldw	r2,-32444(gp)
8110cce4:	10802917 	ldw	r2,164(r2)
8110cce8:	10800003 	ldbu	r2,0(r2)
8110ccec:	10803fcc 	andi	r2,r2,255
8110ccf0:	10c00044 	addi	r3,r2,1
8110ccf4:	00a00034 	movhi	r2,32768
8110ccf8:	10800044 	addi	r2,r2,1
8110ccfc:	1884703a 	and	r2,r3,r2
8110cd00:	1000040e 	bge	r2,zero,8110cd14 <vFeeTask+0x4ac>
8110cd04:	10bfffc4 	addi	r2,r2,-1
8110cd08:	00ffff84 	movi	r3,-2
8110cd0c:	10c4b03a 	or	r2,r2,r3
8110cd10:	10800044 	addi	r2,r2,1
8110cd14:	e0bff805 	stb	r2,-32(fp)
8110cd18:	00000406 	br	8110cd2c <vFeeTask+0x4c4>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110cd1c:	d0a05117 	ldw	r2,-32444(gp)
8110cd20:	10802917 	ldw	r2,164(r2)
8110cd24:	10800003 	ldbu	r2,0(r2)
8110cd28:	e0bff805 	stb	r2,-32(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110cd2c:	d0e05117 	ldw	r3,-32444(gp)
8110cd30:	e0bffb17 	ldw	r2,-20(fp)
8110cd34:	1885883a 	add	r2,r3,r2
8110cd38:	10802a44 	addi	r2,r2,169
8110cd3c:	10800003 	ldbu	r2,0(r2)
8110cd40:	e0bffc05 	stb	r2,-16(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110cd44:	d0a05117 	ldw	r2,-32444(gp)
8110cd48:	10802e17 	ldw	r2,184(r2)
8110cd4c:	1000071e 	bne	r2,zero,8110cd6c <vFeeTask+0x504>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110cd50:	d0e05117 	ldw	r3,-32444(gp)
8110cd54:	e0bffc03 	ldbu	r2,-16(fp)
8110cd58:	10800624 	muli	r2,r2,24
8110cd5c:	10800904 	addi	r2,r2,36
8110cd60:	1885883a 	add	r2,r3,r2
8110cd64:	e0bff915 	stw	r2,-28(fp)
8110cd68:	00000606 	br	8110cd84 <vFeeTask+0x51c>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110cd6c:	d0e05117 	ldw	r3,-32444(gp)
8110cd70:	e0bffc03 	ldbu	r2,-16(fp)
8110cd74:	10800624 	muli	r2,r2,24
8110cd78:	10800c04 	addi	r2,r2,48
8110cd7c:	1885883a 	add	r2,r3,r2
8110cd80:	e0bff915 	stw	r2,-28(fp)


				/* todo: resetar o tamanho do buffer size para o maximo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110cd84:	d0a05117 	ldw	r2,-32444(gp)
8110cd88:	10800003 	ldbu	r2,0(r2)
8110cd8c:	10803fcc 	andi	r2,r2,255
8110cd90:	100d883a 	mov	r6,r2
8110cd94:	000b883a 	mov	r5,zero
8110cd98:	01002004 	movi	r4,128
8110cd9c:	110da180 	call	8110da18 <bSendRequestNFeeCtrl>

				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cda0:	d0a05117 	ldw	r2,-32444(gp)
8110cda4:	10800003 	ldbu	r2,0(r2)
8110cda8:	10803fcc 	andi	r2,r2,255
8110cdac:	1085883a 	add	r2,r2,r2
8110cdb0:	1087883a 	add	r3,r2,r2
8110cdb4:	d0a06404 	addi	r2,gp,-32368
8110cdb8:	1885883a 	add	r2,r3,r2
8110cdbc:	10800017 	ldw	r2,0(r2)
8110cdc0:	e0fffd04 	addi	r3,fp,-12
8110cdc4:	180d883a 	mov	r6,r3
8110cdc8:	000b883a 	mov	r5,zero
8110cdcc:	1009883a 	mov	r4,r2
8110cdd0:	1138c800 	call	81138c80 <OSQPend>
8110cdd4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cdd8:	e0bffd03 	ldbu	r2,-12(fp)
8110cddc:	10803fcc 	andi	r2,r2,255
8110cde0:	1000661e 	bne	r2,zero,8110cf7c <vFeeTask+0x714>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110cde4:	e0bffe83 	ldbu	r2,-6(fp)
8110cde8:	10803fcc 	andi	r2,r2,255
8110cdec:	108023d8 	cmpnei	r2,r2,143
8110cdf0:	10005c1e 	bne	r2,zero,8110cf64 <vFeeTask+0x6fc>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110cdf4:	e0fff803 	ldbu	r3,-32(fp)
8110cdf8:	00a045b4 	movhi	r2,33046
8110cdfc:	10b6a304 	addi	r2,r2,-9588
8110ce00:	180690fa 	slli	r3,r3,3
8110ce04:	10c5883a 	add	r2,r2,r3
8110ce08:	10800017 	ldw	r2,0(r2)
8110ce0c:	e0fffd04 	addi	r3,fp,-12
8110ce10:	180d883a 	mov	r6,r3
8110ce14:	000b883a 	mov	r5,zero
8110ce18:	1009883a 	mov	r4,r2
8110ce1c:	1137b6c0 	call	81137b6c <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110ce20:	e0bffd03 	ldbu	r2,-12(fp)
8110ce24:	10803fcc 	andi	r2,r2,255
8110ce28:	10005d1e 	bne	r2,zero,8110cfa0 <vFeeTask+0x738>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110ce2c:	d0a05117 	ldw	r2,-32444(gp)
8110ce30:	00c00044 	movi	r3,1
8110ce34:	10c02215 	stw	r3,136(r2)

							/* Initializing the addr */
	                    	xCcdMapLocal->ulBlockI = 0;
8110ce38:	e0bff917 	ldw	r2,-28(fp)
8110ce3c:	10000115 	stw	zero,4(r2)
							xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110ce40:	e0bff917 	ldw	r2,-28(fp)
8110ce44:	10c00017 	ldw	r3,0(r2)
8110ce48:	e0bff917 	ldw	r2,-28(fp)
8110ce4c:	10c00215 	stw	r3,8(r2)
							(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
8110ce50:	e0fff803 	ldbu	r3,-32(fp)
8110ce54:	00a045b4 	movhi	r2,33046
8110ce58:	10b6a304 	addi	r2,r2,-9588
8110ce5c:	180690fa 	slli	r3,r3,3
8110ce60:	10c5883a 	add	r2,r2,r3
8110ce64:	10800104 	addi	r2,r2,4
8110ce68:	10800017 	ldw	r2,0(r2)
8110ce6c:	e0fff917 	ldw	r3,-28(fp)
8110ce70:	19000217 	ldw	r4,8(r3)
8110ce74:	d0e05117 	ldw	r3,-32444(gp)
8110ce78:	18c02e17 	ldw	r3,184(r3)
8110ce7c:	19403fcc 	andi	r5,r3,255
8110ce80:	d0e05117 	ldw	r3,-32444(gp)
8110ce84:	18c00003 	ldbu	r3,0(r3)
8110ce88:	18c03fcc 	andi	r3,r3,255
8110ce8c:	180f883a 	mov	r7,r3
8110ce90:	280d883a 	mov	r6,r5
8110ce94:	01400404 	movi	r5,16
8110ce98:	103ee83a 	callr	r2
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110ce9c:	e0bff917 	ldw	r2,-28(fp)
8110cea0:	10800217 	ldw	r2,8(r2)
8110cea4:	10c22004 	addi	r3,r2,2176
8110cea8:	e0bff917 	ldw	r2,-28(fp)
8110ceac:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110ceb0:	e0bff917 	ldw	r2,-28(fp)
8110ceb4:	10800117 	ldw	r2,4(r2)
8110ceb8:	10c00404 	addi	r3,r2,16
8110cebc:	e0bff917 	ldw	r2,-28(fp)
8110cec0:	10c00115 	stw	r3,4(r2)
							(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
8110cec4:	e0fff803 	ldbu	r3,-32(fp)
8110cec8:	00a045b4 	movhi	r2,33046
8110cecc:	10b6a304 	addi	r2,r2,-9588
8110ced0:	180690fa 	slli	r3,r3,3
8110ced4:	10c5883a 	add	r2,r2,r3
8110ced8:	10800104 	addi	r2,r2,4
8110cedc:	10800017 	ldw	r2,0(r2)
8110cee0:	e0fff917 	ldw	r3,-28(fp)
8110cee4:	19000217 	ldw	r4,8(r3)
8110cee8:	d0e05117 	ldw	r3,-32444(gp)
8110ceec:	18c02e17 	ldw	r3,184(r3)
8110cef0:	19403fcc 	andi	r5,r3,255
8110cef4:	d0e05117 	ldw	r3,-32444(gp)
8110cef8:	18c00003 	ldbu	r3,0(r3)
8110cefc:	18c03fcc 	andi	r3,r3,255
8110cf00:	180f883a 	mov	r7,r3
8110cf04:	280d883a 	mov	r6,r5
8110cf08:	01400404 	movi	r5,16
8110cf0c:	103ee83a 	callr	r2
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110cf10:	e0bff917 	ldw	r2,-28(fp)
8110cf14:	10800217 	ldw	r2,8(r2)
8110cf18:	10c22004 	addi	r3,r2,2176
8110cf1c:	e0bff917 	ldw	r2,-28(fp)
8110cf20:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110cf24:	e0bff917 	ldw	r2,-28(fp)
8110cf28:	10800117 	ldw	r2,4(r2)
8110cf2c:	10c00404 	addi	r3,r2,16
8110cf30:	e0bff917 	ldw	r2,-28(fp)
8110cf34:	10c00115 	stw	r3,4(r2)
	                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110cf38:	e0fff803 	ldbu	r3,-32(fp)
8110cf3c:	00a045b4 	movhi	r2,33046
8110cf40:	10b6a304 	addi	r2,r2,-9588
8110cf44:	180690fa 	slli	r3,r3,3
8110cf48:	10c5883a 	add	r2,r2,r3
8110cf4c:	10800017 	ldw	r2,0(r2)
8110cf50:	1009883a 	mov	r4,r2
8110cf54:	11381100 	call	81138110 <OSMutexPost>
	                        pxNFee->xControl.bDMALocked = FALSE;
8110cf58:	d0a05117 	ldw	r2,-32444(gp)
8110cf5c:	10002215 	stw	zero,136(r2)
8110cf60:	00000f06 	br	8110cfa0 <vFeeTask+0x738>
	                    }
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110cf64:	d0a05117 	ldw	r2,-32444(gp)
8110cf68:	e0fffe17 	ldw	r3,-8(fp)
8110cf6c:	180b883a 	mov	r5,r3
8110cf70:	1009883a 	mov	r4,r2
8110cf74:	110d65c0 	call	8110d65c <vQCmdFEEinFullPattern>
8110cf78:	00000906 	br	8110cfa0 <vFeeTask+0x738>
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110cf7c:	d0e05c17 	ldw	r3,-32400(gp)
8110cf80:	d0a05117 	ldw	r2,-32444(gp)
8110cf84:	10800003 	ldbu	r2,0(r2)
8110cf88:	10803fcc 	andi	r2,r2,255
8110cf8c:	100d883a 	mov	r6,r2
8110cf90:	01604534 	movhi	r5,33044
8110cf94:	295d3e04 	addi	r5,r5,29944
8110cf98:	1809883a 	mov	r4,r3
8110cf9c:	111ba9c0 	call	8111ba9c <fprintf>
					#endif
				}

				if (pxNFee->xControl.bWatingSync==TRUE) {
8110cfa0:	d0a05117 	ldw	r2,-32444(gp)
8110cfa4:	10802817 	ldw	r2,160(r2)
8110cfa8:	10800058 	cmpnei	r2,r2,1
8110cfac:	1000071e 	bne	r2,zero,8110cfcc <vFeeTask+0x764>
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110cfb0:	d0a05117 	ldw	r2,-32444(gp)
8110cfb4:	00c001c4 	movi	r3,7
8110cfb8:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sFeeWaitingSync;
8110cfbc:	d0a05117 	ldw	r2,-32444(gp)
8110cfc0:	00c002c4 	movi	r3,11
8110cfc4:	10c02c15 	stw	r3,176(r2)
				} else {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
					pxNFee->xControl.eMode = sToTestFullPattern;
				}

				break;
8110cfc8:	0000ea06 	br	8110d374 <vFeeTask+0xb0c>

				if (pxNFee->xControl.bWatingSync==TRUE) {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
					pxNFee->xControl.eMode = sFeeWaitingSync;
				} else {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110cfcc:	d0a05117 	ldw	r2,-32444(gp)
8110cfd0:	00c001c4 	movi	r3,7
8110cfd4:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sToTestFullPattern;
8110cfd8:	d0a05117 	ldw	r2,-32444(gp)
8110cfdc:	00c001c4 	movi	r3,7
8110cfe0:	10c02c15 	stw	r3,176(r2)
				}

				break;
8110cfe4:	0000e306 	br	8110d374 <vFeeTask+0xb0c>
			case sToTestFullPattern: /* Transition */
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110cfe8:	d0e05c17 	ldw	r3,-32400(gp)
8110cfec:	d0a05117 	ldw	r2,-32444(gp)
8110cff0:	10800003 	ldbu	r2,0(r2)
8110cff4:	10803fcc 	andi	r2,r2,255
8110cff8:	100d883a 	mov	r6,r2
8110cffc:	01604534 	movhi	r5,33044
8110d000:	295d5204 	addi	r5,r5,30024
8110d004:	1809883a 	mov	r4,r3
8110d008:	111ba9c0 	call	8111ba9c <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110d00c:	d0a05117 	ldw	r2,-32444(gp)
8110d010:	00c00044 	movi	r3,1
8110d014:	10c02315 	stw	r3,140(r2)

				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110d018:	d0a05117 	ldw	r2,-32444(gp)
8110d01c:	00c00104 	movi	r3,4
8110d020:	10c02c15 	stw	r3,176(r2)
				break;
8110d024:	0000d306 	br	8110d374 <vFeeTask+0xb0c>
			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d028:	d0a05117 	ldw	r2,-32444(gp)
8110d02c:	10800003 	ldbu	r2,0(r2)
8110d030:	10803fcc 	andi	r2,r2,255
8110d034:	1085883a 	add	r2,r2,r2
8110d038:	1087883a 	add	r3,r2,r2
8110d03c:	d0a06404 	addi	r2,gp,-32368
8110d040:	1885883a 	add	r2,r3,r2
8110d044:	10800017 	ldw	r2,0(r2)
8110d048:	e0fffd04 	addi	r3,fp,-12
8110d04c:	180d883a 	mov	r6,r3
8110d050:	000b883a 	mov	r5,zero
8110d054:	1009883a 	mov	r4,r2
8110d058:	1138c800 	call	81138c80 <OSQPend>
8110d05c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d060:	e0bffd03 	ldbu	r2,-12(fp)
8110d064:	10803fcc 	andi	r2,r2,255
8110d068:	10005d1e 	bne	r2,zero,8110d1e0 <vFeeTask+0x978>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110d06c:	e0bffe83 	ldbu	r2,-6(fp)
8110d070:	10803fcc 	andi	r2,r2,255
8110d074:	108023d8 	cmpnei	r2,r2,143
8110d078:	1000531e 	bne	r2,zero,8110d1c8 <vFeeTask+0x960>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110d07c:	e0fff803 	ldbu	r3,-32(fp)
8110d080:	00a045b4 	movhi	r2,33046
8110d084:	10b6a304 	addi	r2,r2,-9588
8110d088:	180690fa 	slli	r3,r3,3
8110d08c:	10c5883a 	add	r2,r2,r3
8110d090:	10800017 	ldw	r2,0(r2)
8110d094:	e0fffd04 	addi	r3,fp,-12
8110d098:	180d883a 	mov	r6,r3
8110d09c:	000b883a 	mov	r5,zero
8110d0a0:	1009883a 	mov	r4,r2
8110d0a4:	1137b6c0 	call	81137b6c <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110d0a8:	e0bffd03 	ldbu	r2,-12(fp)
8110d0ac:	10803fcc 	andi	r2,r2,255
8110d0b0:	1000af1e 	bne	r2,zero,8110d370 <vFeeTask+0xb08>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110d0b4:	d0a05117 	ldw	r2,-32444(gp)
8110d0b8:	00c00044 	movi	r3,1
8110d0bc:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI+SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110d0c0:	e0bff917 	ldw	r2,-28(fp)
8110d0c4:	10800117 	ldw	r2,4(r2)
8110d0c8:	10c00404 	addi	r3,r2,16
8110d0cc:	d0a05117 	ldw	r2,-32444(gp)
8110d0d0:	10800417 	ldw	r2,16(r2)
8110d0d4:	18801336 	bltu	r3,r2,8110d124 <vFeeTask+0x8bc>

		                    		/* todo: Configurar o tamanho do buffer para um numero menor = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI */
		                    		/* todo: Nao esquece porra !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		                    		usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110d0d8:	d0a05117 	ldw	r2,-32444(gp)
8110d0dc:	10800417 	ldw	r2,16(r2)
8110d0e0:	1007883a 	mov	r3,r2
8110d0e4:	e0bff917 	ldw	r2,-28(fp)
8110d0e8:	10800117 	ldw	r2,4(r2)
8110d0ec:	1885c83a 	sub	r2,r3,r2
8110d0f0:	e0bffc8d 	sth	r2,-14(fp)
		                    		pxNFee->xControl.bWatingSync = TRUE;
8110d0f4:	d0a05117 	ldw	r2,-32444(gp)
8110d0f8:	00c00044 	movi	r3,1
8110d0fc:	10c02815 	stw	r3,160(r2)
		                    		pxNFee->xControl.eMode = sSIMTestFullPattern;
8110d100:	d0a05117 	ldw	r2,-32444(gp)
8110d104:	00c00284 	movi	r3,10
8110d108:	10c02c15 	stw	r3,176(r2)
		                    		pxNFee->xControl.eNextMode = sSIMTestFullPattern;
8110d10c:	d0a05117 	ldw	r2,-32444(gp)
8110d110:	00c00284 	movi	r3,10
8110d114:	10c02d15 	stw	r3,180(r2)
		                    		pxNFee->xControl.bUsingDMA = FALSE;
8110d118:	d0a05117 	ldw	r2,-32444(gp)
8110d11c:	10002315 	stw	zero,140(r2)
8110d120:	00000206 	br	8110d12c <vFeeTask+0x8c4>
		                    	} else {
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110d124:	00800404 	movi	r2,16
8110d128:	e0bffc8d 	sth	r2,-14(fp)
		                    	}

								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
								(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
8110d12c:	e0fff803 	ldbu	r3,-32(fp)
8110d130:	00a045b4 	movhi	r2,33046
8110d134:	10b6a304 	addi	r2,r2,-9588
8110d138:	180690fa 	slli	r3,r3,3
8110d13c:	10c5883a 	add	r2,r2,r3
8110d140:	10800104 	addi	r2,r2,4
8110d144:	10800017 	ldw	r2,0(r2)
8110d148:	e0fff917 	ldw	r3,-28(fp)
8110d14c:	19000217 	ldw	r4,8(r3)
8110d150:	d0e05117 	ldw	r3,-32444(gp)
8110d154:	18c02e17 	ldw	r3,184(r3)
8110d158:	19403fcc 	andi	r5,r3,255
8110d15c:	d0e05117 	ldw	r3,-32444(gp)
8110d160:	18c00003 	ldbu	r3,0(r3)
8110d164:	18c03fcc 	andi	r3,r3,255
8110d168:	180f883a 	mov	r7,r3
8110d16c:	280d883a 	mov	r6,r5
8110d170:	01400404 	movi	r5,16
8110d174:	103ee83a 	callr	r2
								xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d178:	e0bff917 	ldw	r2,-28(fp)
8110d17c:	10800217 	ldw	r2,8(r2)
8110d180:	10c22004 	addi	r3,r2,2176
8110d184:	e0bff917 	ldw	r2,-28(fp)
8110d188:	10c00215 	stw	r3,8(r2)
		                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d18c:	e0fff803 	ldbu	r3,-32(fp)
8110d190:	00a045b4 	movhi	r2,33046
8110d194:	10b6a304 	addi	r2,r2,-9588
8110d198:	180690fa 	slli	r3,r3,3
8110d19c:	10c5883a 	add	r2,r2,r3
8110d1a0:	10800017 	ldw	r2,0(r2)
8110d1a4:	1009883a 	mov	r4,r2
8110d1a8:	11381100 	call	81138110 <OSMutexPost>
		                        pxNFee->xControl.bDMALocked = FALSE;
8110d1ac:	d0a05117 	ldw	r2,-32444(gp)
8110d1b0:	10002215 	stw	zero,136(r2)
		                        bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110d1b4:	d0a05117 	ldw	r2,-32444(gp)
8110d1b8:	10803b04 	addi	r2,r2,236
8110d1bc:	1009883a 	mov	r4,r2
8110d1c0:	110d9b40 	call	8110d9b4 <bDisAndClrDbBuffer>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d1c4:	00006a06 	br	8110d370 <vFeeTask+0xb08>
		                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
		                        pxNFee->xControl.bDMALocked = FALSE;
		                        bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110d1c8:	d0a05117 	ldw	r2,-32444(gp)
8110d1cc:	e0fffe17 	ldw	r3,-8(fp)
8110d1d0:	180b883a 	mov	r5,r3
8110d1d4:	1009883a 	mov	r4,r2
8110d1d8:	110d65c0 	call	8110d65c <vQCmdFEEinFullPattern>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d1dc:	00006406 	br	8110d370 <vFeeTask+0xb08>
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d1e0:	d0e05c17 	ldw	r3,-32400(gp)
8110d1e4:	d0a05117 	ldw	r2,-32444(gp)
8110d1e8:	10800003 	ldbu	r2,0(r2)
8110d1ec:	10803fcc 	andi	r2,r2,255
8110d1f0:	100d883a 	mov	r6,r2
8110d1f4:	01604534 	movhi	r5,33044
8110d1f8:	295d3e04 	addi	r5,r5,29944
8110d1fc:	1809883a 	mov	r4,r3
8110d200:	111ba9c0 	call	8111ba9c <fprintf>
					#endif
				}

				break;
8110d204:	00005a06 	br	8110d370 <vFeeTask+0xb08>

			case sFeeWaitingSync:

				pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110d208:	d0a05117 	ldw	r2,-32444(gp)
8110d20c:	d0e05117 	ldw	r3,-32444(gp)
8110d210:	18c02d17 	ldw	r3,180(r3)
8110d214:	10c02c15 	stw	r3,176(r2)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xWaitSyncQFee[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d218:	d0a05117 	ldw	r2,-32444(gp)
8110d21c:	10800003 	ldbu	r2,0(r2)
8110d220:	10803fcc 	andi	r2,r2,255
8110d224:	1085883a 	add	r2,r2,r2
8110d228:	1087883a 	add	r3,r2,r2
8110d22c:	d0a05604 	addi	r2,gp,-32424
8110d230:	1885883a 	add	r2,r3,r2
8110d234:	10800017 	ldw	r2,0(r2)
8110d238:	e0fffd04 	addi	r3,fp,-12
8110d23c:	180d883a 	mov	r6,r3
8110d240:	000b883a 	mov	r5,zero
8110d244:	1009883a 	mov	r4,r2
8110d248:	1138c800 	call	81138c80 <OSQPend>
8110d24c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d250:	e0bffd03 	ldbu	r2,-12(fp)
8110d254:	10803fcc 	andi	r2,r2,255
8110d258:	10002a1e 	bne	r2,zero,8110d304 <vFeeTask+0xa9c>

					/* Write in the RMAP */
					bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d25c:	d0a05117 	ldw	r2,-32444(gp)
8110d260:	10804204 	addi	r2,r2,264
8110d264:	1009883a 	mov	r4,r2
8110d268:	11073040 	call	81107304 <bRmapGetMemConfigArea>

					/* UCL- NFEE ICD p. 49 */
					switch ( pxNFee->xControl.eNextMode ) {
8110d26c:	d0a05117 	ldw	r2,-32444(gp)
8110d270:	10802d17 	ldw	r2,180(r2)
8110d274:	10c002e8 	cmpgeui	r3,r2,11
8110d278:	18001c1e 	bne	r3,zero,8110d2ec <vFeeTask+0xa84>
8110d27c:	100690ba 	slli	r3,r2,2
8110d280:	00a04474 	movhi	r2,33041
8110d284:	10b4a504 	addi	r2,r2,-11628
8110d288:	1885883a 	add	r2,r3,r2
8110d28c:	10800017 	ldw	r2,0(r2)
8110d290:	1000683a 	jmp	r2
8110d294:	8110d2ec 	andhi	r4,r16,17227
8110d298:	8110d2c0 	call	88110d2c <__reset+0x20f0d2c>
8110d29c:	8110d2ec 	andhi	r4,r16,17227
8110d2a0:	8110d2d0 	cmplti	r4,r16,17227
8110d2a4:	8110d2dc 	xori	r4,r16,17227
8110d2a8:	8110d2c0 	call	88110d2c <__reset+0x20f0d2c>
8110d2ac:	8110d2d0 	cmplti	r4,r16,17227
8110d2b0:	8110d2dc 	xori	r4,r16,17227
8110d2b4:	8110d2ec 	andhi	r4,r16,17227
8110d2b8:	8110d2ec 	andhi	r4,r16,17227
8110d2bc:	8110d2dc 	xori	r4,r16,17227
						case sToFeeConfig:
						case sFeeConfig:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /* Off-Mode */
8110d2c0:	d0a05117 	ldw	r2,-32444(gp)
8110d2c4:	00c00184 	movi	r3,6
8110d2c8:	10c06515 	stw	r3,404(r2)
							break;
8110d2cc:	00000806 	br	8110d2f0 <vFeeTask+0xa88>
						case sFeeStandBy:
						case sToFeeStandBy:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00;
8110d2d0:	d0a05117 	ldw	r2,-32444(gp)
8110d2d4:	10006515 	stw	zero,404(r2)
							break;
8110d2d8:	00000506 	br	8110d2f0 <vFeeTask+0xa88>
						case sSIMTestFullPattern:
						case sToTestFullPattern:
						case sFeeTestFullPattern:
							pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02;
8110d2dc:	d0a05117 	ldw	r2,-32444(gp)
8110d2e0:	00c00084 	movi	r3,2
8110d2e4:	10c06515 	stw	r3,404(r2)
							break;
8110d2e8:	00000106 	br	8110d2f0 <vFeeTask+0xa88>
						default:
							break;
8110d2ec:	0001883a 	nop
					}

					bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d2f0:	d0a05117 	ldw	r2,-32444(gp)
8110d2f4:	10804204 	addi	r2,r2,264
8110d2f8:	1009883a 	mov	r4,r2
8110d2fc:	11070180 	call	81107018 <bRmapSetMemConfigArea>
8110d300:	00000906 	br	8110d328 <vFeeTask+0xac0>

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xWaitSyncQFee\n", pxNFee->ucId);
8110d304:	d0e05c17 	ldw	r3,-32400(gp)
8110d308:	d0a05117 	ldw	r2,-32444(gp)
8110d30c:	10800003 	ldbu	r2,0(r2)
8110d310:	10803fcc 	andi	r2,r2,255
8110d314:	100d883a 	mov	r6,r2
8110d318:	01604534 	movhi	r5,33044
8110d31c:	295d5c04 	addi	r5,r5,30064
8110d320:	1809883a 	mov	r4,r3
8110d324:	111ba9c0 	call	8111ba9c <fprintf>
					#endif
				}

				pxNFee->xControl.bWatingSync = FALSE;
8110d328:	d0a05117 	ldw	r2,-32444(gp)
8110d32c:	10002815 	stw	zero,160(r2)
				break;
8110d330:	00001006 	br	8110d374 <vFeeTask+0xb0c>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110d334:	d0a05117 	ldw	r2,-32444(gp)
8110d338:	00c00144 	movi	r3,5
8110d33c:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110d340:	d0e05c17 	ldw	r3,-32400(gp)
8110d344:	d0a05117 	ldw	r2,-32444(gp)
8110d348:	10800003 	ldbu	r2,0(r2)
8110d34c:	10803fcc 	andi	r2,r2,255
8110d350:	100d883a 	mov	r6,r2
8110d354:	01604534 	movhi	r5,33044
8110d358:	295d6a04 	addi	r5,r5,30120
8110d35c:	1809883a 	mov	r4,r3
8110d360:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d364:	00000306 	br	8110d374 <vFeeTask+0xb0c>
				break;
			case sSIMFeeStandBy:

				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
8110d368:	0001883a 	nop
8110d36c:	003d5406 	br	8110c8c0 <__reset+0xfb0ec8c0>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d370:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110d374:	003d5206 	br	8110c8c0 <__reset+0xfb0ec8c0>

8110d378 <vQCmdFEEinConfig>:

}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110d378:	defffb04 	addi	sp,sp,-20
8110d37c:	de00012e 	bgeu	sp,et,8110d384 <vQCmdFEEinConfig+0xc>
8110d380:	003b68fa 	trap	3
8110d384:	dfc00415 	stw	ra,16(sp)
8110d388:	df000315 	stw	fp,12(sp)
8110d38c:	df000304 	addi	fp,sp,12
8110d390:	e13ffe15 	stw	r4,-8(fp)
8110d394:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d398:	e0bfff17 	ldw	r2,-4(fp)
8110d39c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d3a0:	e0bffdc3 	ldbu	r2,-9(fp)
8110d3a4:	10c03fcc 	andi	r3,r2,255
8110d3a8:	e0bffe17 	ldw	r2,-8(fp)
8110d3ac:	10800003 	ldbu	r2,0(r2)
8110d3b0:	10803fcc 	andi	r2,r2,255
8110d3b4:	10800444 	addi	r2,r2,17
8110d3b8:	1880451e 	bne	r3,r2,8110d4d0 <vQCmdFEEinConfig+0x158>

		switch (uiCmdFEEL.ucByte[2]) {
8110d3bc:	e0bffd83 	ldbu	r2,-10(fp)
8110d3c0:	10803fcc 	andi	r2,r2,255
8110d3c4:	10c00220 	cmpeqi	r3,r2,8
8110d3c8:	18002c1e 	bne	r3,zero,8110d47c <vQCmdFEEinConfig+0x104>
8110d3cc:	10c00248 	cmpgei	r3,r2,9
8110d3d0:	1800071e 	bne	r3,zero,8110d3f0 <vQCmdFEEinConfig+0x78>
8110d3d4:	10c000a0 	cmpeqi	r3,r2,2
8110d3d8:	18003c1e 	bne	r3,zero,8110d4cc <vQCmdFEEinConfig+0x154>
8110d3dc:	10c00120 	cmpeqi	r3,r2,4
8110d3e0:	1800131e 	bne	r3,zero,8110d430 <vQCmdFEEinConfig+0xb8>
8110d3e4:	10800060 	cmpeqi	r2,r2,1
8110d3e8:	1000071e 	bne	r2,zero,8110d408 <vQCmdFEEinConfig+0x90>
8110d3ec:	00002d06 	br	8110d4a4 <vQCmdFEEinConfig+0x12c>
8110d3f0:	10c02920 	cmpeqi	r3,r2,164
8110d3f4:	1800181e 	bne	r3,zero,8110d458 <vQCmdFEEinConfig+0xe0>
8110d3f8:	10c02a20 	cmpeqi	r3,r2,168
8110d3fc:	18001f1e 	bne	r3,zero,8110d47c <vQCmdFEEinConfig+0x104>
8110d400:	10802860 	cmpeqi	r2,r2,161
8110d404:	10002726 	beq	r2,zero,8110d4a4 <vQCmdFEEinConfig+0x12c>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110d408:	d0e05c17 	ldw	r3,-32400(gp)
8110d40c:	e0bffe17 	ldw	r2,-8(fp)
8110d410:	10800003 	ldbu	r2,0(r2)
8110d414:	10803fcc 	andi	r2,r2,255
8110d418:	100d883a 	mov	r6,r2
8110d41c:	01604534 	movhi	r5,33044
8110d420:	295d7504 	addi	r5,r5,30164
8110d424:	1809883a 	mov	r4,r3
8110d428:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d42c:	00002806 	br	8110d4d0 <vQCmdFEEinConfig+0x158>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d430:	e0bffe17 	ldw	r2,-8(fp)
8110d434:	00c00044 	movi	r3,1
8110d438:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d43c:	e0bffe17 	ldw	r2,-8(fp)
8110d440:	00c002c4 	movi	r3,11
8110d444:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d448:	e0bffe17 	ldw	r2,-8(fp)
8110d44c:	00c00184 	movi	r3,6
8110d450:	10c02d15 	stw	r3,180(r2)
				break;
8110d454:	00001e06 	br	8110d4d0 <vQCmdFEEinConfig+0x158>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d458:	e0bffe17 	ldw	r2,-8(fp)
8110d45c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110d460:	e0bffe17 	ldw	r2,-8(fp)
8110d464:	00c00184 	movi	r3,6
8110d468:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d46c:	e0bffe17 	ldw	r2,-8(fp)
8110d470:	00c00184 	movi	r3,6
8110d474:	10c02d15 	stw	r3,180(r2)
				break;				
8110d478:	00001506 	br	8110d4d0 <vQCmdFEEinConfig+0x158>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110d47c:	d0e05c17 	ldw	r3,-32400(gp)
8110d480:	e0bffe17 	ldw	r2,-8(fp)
8110d484:	10800003 	ldbu	r2,0(r2)
8110d488:	10803fcc 	andi	r2,r2,255
8110d48c:	100d883a 	mov	r6,r2
8110d490:	01604534 	movhi	r5,33044
8110d494:	295d8004 	addi	r5,r5,30208
8110d498:	1809883a 	mov	r4,r3
8110d49c:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;											
8110d4a0:	00000b06 	br	8110d4d0 <vQCmdFEEinConfig+0x158>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110d4a4:	d0e05c17 	ldw	r3,-32400(gp)
8110d4a8:	e0bffe17 	ldw	r2,-8(fp)
8110d4ac:	10800003 	ldbu	r2,0(r2)
8110d4b0:	10803fcc 	andi	r2,r2,255
8110d4b4:	100d883a 	mov	r6,r2
8110d4b8:	01604534 	movhi	r5,33044
8110d4bc:	295d9104 	addi	r5,r5,30276
8110d4c0:	1809883a 	mov	r4,r3
8110d4c4:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d4c8:	00000106 	br	8110d4d0 <vQCmdFEEinConfig+0x158>
				break;
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d4cc:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d4d0:	0001883a 	nop
8110d4d4:	e037883a 	mov	sp,fp
8110d4d8:	dfc00117 	ldw	ra,4(sp)
8110d4dc:	df000017 	ldw	fp,0(sp)
8110d4e0:	dec00204 	addi	sp,sp,8
8110d4e4:	f800283a 	ret

8110d4e8 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110d4e8:	defffb04 	addi	sp,sp,-20
8110d4ec:	de00012e 	bgeu	sp,et,8110d4f4 <vQCmdFEEinStandBy+0xc>
8110d4f0:	003b68fa 	trap	3
8110d4f4:	dfc00415 	stw	ra,16(sp)
8110d4f8:	df000315 	stw	fp,12(sp)
8110d4fc:	df000304 	addi	fp,sp,12
8110d500:	e13ffe15 	stw	r4,-8(fp)
8110d504:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d508:	e0bfff17 	ldw	r2,-4(fp)
8110d50c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d510:	e0bffdc3 	ldbu	r2,-9(fp)
8110d514:	10c03fcc 	andi	r3,r2,255
8110d518:	e0bffe17 	ldw	r2,-8(fp)
8110d51c:	10800003 	ldbu	r2,0(r2)
8110d520:	10803fcc 	andi	r2,r2,255
8110d524:	10800444 	addi	r2,r2,17
8110d528:	1880461e 	bne	r3,r2,8110d644 <vQCmdFEEinStandBy+0x15c>

		switch (uiCmdFEEL.ucByte[2]) {
8110d52c:	e0bffd83 	ldbu	r2,-10(fp)
8110d530:	10803fcc 	andi	r2,r2,255
8110d534:	10c00220 	cmpeqi	r3,r2,8
8110d538:	18002d1e 	bne	r3,zero,8110d5f0 <vQCmdFEEinStandBy+0x108>
8110d53c:	10c00248 	cmpgei	r3,r2,9
8110d540:	1800071e 	bne	r3,zero,8110d560 <vQCmdFEEinStandBy+0x78>
8110d544:	10c000a0 	cmpeqi	r3,r2,2
8110d548:	18003d1e 	bne	r3,zero,8110d640 <vQCmdFEEinStandBy+0x158>
8110d54c:	10c00120 	cmpeqi	r3,r2,4
8110d550:	18001d1e 	bne	r3,zero,8110d5c8 <vQCmdFEEinStandBy+0xe0>
8110d554:	10800060 	cmpeqi	r2,r2,1
8110d558:	1000081e 	bne	r2,zero,8110d57c <vQCmdFEEinStandBy+0x94>
8110d55c:	00002e06 	br	8110d618 <vQCmdFEEinStandBy+0x130>
8110d560:	10c02920 	cmpeqi	r3,r2,164
8110d564:	1800181e 	bne	r3,zero,8110d5c8 <vQCmdFEEinStandBy+0xe0>
8110d568:	10c02a20 	cmpeqi	r3,r2,168
8110d56c:	1800201e 	bne	r3,zero,8110d5f0 <vQCmdFEEinStandBy+0x108>
8110d570:	10802860 	cmpeqi	r2,r2,161
8110d574:	10000b1e 	bne	r2,zero,8110d5a4 <vQCmdFEEinStandBy+0xbc>
8110d578:	00002706 	br	8110d618 <vQCmdFEEinStandBy+0x130>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d57c:	e0bffe17 	ldw	r2,-8(fp)
8110d580:	00c00044 	movi	r3,1
8110d584:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d588:	e0bffe17 	ldw	r2,-8(fp)
8110d58c:	00c002c4 	movi	r3,11
8110d590:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110d594:	e0bffe17 	ldw	r2,-8(fp)
8110d598:	00c00144 	movi	r3,5
8110d59c:	10c02d15 	stw	r3,180(r2)
				break;
8110d5a0:	00002806 	br	8110d644 <vQCmdFEEinStandBy+0x15c>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d5a4:	e0bffe17 	ldw	r2,-8(fp)
8110d5a8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110d5ac:	e0bffe17 	ldw	r2,-8(fp)
8110d5b0:	00c00144 	movi	r3,5
8110d5b4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110d5b8:	e0bffe17 	ldw	r2,-8(fp)
8110d5bc:	00c00144 	movi	r3,5
8110d5c0:	10c02d15 	stw	r3,180(r2)
				break;				
8110d5c4:	00001f06 	br	8110d644 <vQCmdFEEinStandBy+0x15c>
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110d5c8:	d0e05c17 	ldw	r3,-32400(gp)
8110d5cc:	e0bffe17 	ldw	r2,-8(fp)
8110d5d0:	10800003 	ldbu	r2,0(r2)
8110d5d4:	10803fcc 	andi	r2,r2,255
8110d5d8:	100d883a 	mov	r6,r2
8110d5dc:	01604534 	movhi	r5,33044
8110d5e0:	295da204 	addi	r5,r5,30344
8110d5e4:	1809883a 	mov	r4,r3
8110d5e8:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d5ec:	00001506 	br	8110d644 <vQCmdFEEinStandBy+0x15c>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d5f0:	e0bffe17 	ldw	r2,-8(fp)
8110d5f4:	00c00044 	movi	r3,1
8110d5f8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sSIMTestFullPattern; /*sSIMTestFullPattern*/
8110d5fc:	e0bffe17 	ldw	r2,-8(fp)
8110d600:	00c00284 	movi	r3,10
8110d604:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110d608:	e0bffe17 	ldw	r2,-8(fp)
8110d60c:	00c00284 	movi	r3,10
8110d610:	10c02d15 	stw	r3,180(r2)
				break;				
8110d614:	00000b06 	br	8110d644 <vQCmdFEEinStandBy+0x15c>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110d618:	d0e05c17 	ldw	r3,-32400(gp)
8110d61c:	e0bffe17 	ldw	r2,-8(fp)
8110d620:	10800003 	ldbu	r2,0(r2)
8110d624:	10803fcc 	andi	r2,r2,255
8110d628:	100d883a 	mov	r6,r2
8110d62c:	01604534 	movhi	r5,33044
8110d630:	295dad04 	addi	r5,r5,30388
8110d634:	1809883a 	mov	r4,r3
8110d638:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d63c:	00000106 	br	8110d644 <vQCmdFEEinStandBy+0x15c>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d640:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d644:	0001883a 	nop
8110d648:	e037883a 	mov	sp,fp
8110d64c:	dfc00117 	ldw	ra,4(sp)
8110d650:	df000017 	ldw	fp,0(sp)
8110d654:	dec00204 	addi	sp,sp,8
8110d658:	f800283a 	ret

8110d65c <vQCmdFEEinFullPattern>:

void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110d65c:	defffb04 	addi	sp,sp,-20
8110d660:	de00012e 	bgeu	sp,et,8110d668 <vQCmdFEEinFullPattern+0xc>
8110d664:	003b68fa 	trap	3
8110d668:	dfc00415 	stw	ra,16(sp)
8110d66c:	df000315 	stw	fp,12(sp)
8110d670:	df000304 	addi	fp,sp,12
8110d674:	e13ffe15 	stw	r4,-8(fp)
8110d678:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d67c:	e0bfff17 	ldw	r2,-4(fp)
8110d680:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d684:	e0bffdc3 	ldbu	r2,-9(fp)
8110d688:	10c03fcc 	andi	r3,r2,255
8110d68c:	e0bffe17 	ldw	r2,-8(fp)
8110d690:	10800003 	ldbu	r2,0(r2)
8110d694:	10803fcc 	andi	r2,r2,255
8110d698:	10800444 	addi	r2,r2,17
8110d69c:	18804d1e 	bne	r3,r2,8110d7d4 <vQCmdFEEinFullPattern+0x178>

		switch (uiCmdFEEL.ucByte[2]) {
8110d6a0:	e0bffd83 	ldbu	r2,-10(fp)
8110d6a4:	10803fcc 	andi	r2,r2,255
8110d6a8:	10c00120 	cmpeqi	r3,r2,4
8110d6ac:	1800211e 	bne	r3,zero,8110d734 <vQCmdFEEinFullPattern+0xd8>
8110d6b0:	10c00148 	cmpgei	r3,r2,5
8110d6b4:	1800051e 	bne	r3,zero,8110d6cc <vQCmdFEEinFullPattern+0x70>
8110d6b8:	10c00060 	cmpeqi	r3,r2,1
8110d6bc:	18000a1e 	bne	r3,zero,8110d6e8 <vQCmdFEEinFullPattern+0x8c>
8110d6c0:	108000a0 	cmpeqi	r2,r2,2
8110d6c4:	1000421e 	bne	r2,zero,8110d7d0 <vQCmdFEEinFullPattern+0x174>
8110d6c8:	00003706 	br	8110d7a8 <vQCmdFEEinFullPattern+0x14c>
8110d6cc:	10c02860 	cmpeqi	r3,r2,161
8110d6d0:	18000f1e 	bne	r3,zero,8110d710 <vQCmdFEEinFullPattern+0xb4>
8110d6d4:	10c02920 	cmpeqi	r3,r2,164
8110d6d8:	1800201e 	bne	r3,zero,8110d75c <vQCmdFEEinFullPattern+0x100>
8110d6dc:	10800220 	cmpeqi	r2,r2,8
8110d6e0:	1000271e 	bne	r2,zero,8110d780 <vQCmdFEEinFullPattern+0x124>
8110d6e4:	00003006 	br	8110d7a8 <vQCmdFEEinFullPattern+0x14c>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d6e8:	e0bffe17 	ldw	r2,-8(fp)
8110d6ec:	00c00044 	movi	r3,1
8110d6f0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d6f4:	e0bffe17 	ldw	r2,-8(fp)
8110d6f8:	00c002c4 	movi	r3,11
8110d6fc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110d700:	e0bffe17 	ldw	r2,-8(fp)
8110d704:	00c00144 	movi	r3,5
8110d708:	10c02d15 	stw	r3,180(r2)
				break;
8110d70c:	00003106 	br	8110d7d4 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d710:	e0bffe17 	ldw	r2,-8(fp)
8110d714:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110d718:	e0bffe17 	ldw	r2,-8(fp)
8110d71c:	00c00144 	movi	r3,5
8110d720:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110d724:	e0bffe17 	ldw	r2,-8(fp)
8110d728:	00c00144 	movi	r3,5
8110d72c:	10c02d15 	stw	r3,180(r2)
				break;				
8110d730:	00002806 	br	8110d7d4 <vQCmdFEEinFullPattern+0x178>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d734:	e0bffe17 	ldw	r2,-8(fp)
8110d738:	00c00044 	movi	r3,1
8110d73c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d740:	e0bffe17 	ldw	r2,-8(fp)
8110d744:	00c002c4 	movi	r3,11
8110d748:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110d74c:	e0bffe17 	ldw	r2,-8(fp)
8110d750:	00c00184 	movi	r3,6
8110d754:	10c02d15 	stw	r3,180(r2)
				break;
8110d758:	00001e06 	br	8110d7d4 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d75c:	e0bffe17 	ldw	r2,-8(fp)
8110d760:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110d764:	e0bffe17 	ldw	r2,-8(fp)
8110d768:	00c00184 	movi	r3,6
8110d76c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110d770:	e0bffe17 	ldw	r2,-8(fp)
8110d774:	00c00184 	movi	r3,6
8110d778:	10c02d15 	stw	r3,180(r2)
				break;				
8110d77c:	00001506 	br	8110d7d4 <vQCmdFEEinFullPattern+0x178>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110d780:	d0e05c17 	ldw	r3,-32400(gp)
8110d784:	e0bffe17 	ldw	r2,-8(fp)
8110d788:	10800003 	ldbu	r2,0(r2)
8110d78c:	10803fcc 	andi	r2,r2,255
8110d790:	100d883a 	mov	r6,r2
8110d794:	01604534 	movhi	r5,33044
8110d798:	295dbe04 	addi	r5,r5,30456
8110d79c:	1809883a 	mov	r4,r3
8110d7a0:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d7a4:	00000b06 	br	8110d7d4 <vQCmdFEEinFullPattern+0x178>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110d7a8:	d0e05c17 	ldw	r3,-32400(gp)
8110d7ac:	e0bffe17 	ldw	r2,-8(fp)
8110d7b0:	10800003 	ldbu	r2,0(r2)
8110d7b4:	10803fcc 	andi	r2,r2,255
8110d7b8:	100d883a 	mov	r6,r2
8110d7bc:	01604534 	movhi	r5,33044
8110d7c0:	295d9104 	addi	r5,r5,30276
8110d7c4:	1809883a 	mov	r4,r3
8110d7c8:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
				break;
8110d7cc:	00000106 	br	8110d7d4 <vQCmdFEEinFullPattern+0x178>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d7d0:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d7d4:	0001883a 	nop
8110d7d8:	e037883a 	mov	sp,fp
8110d7dc:	dfc00117 	ldw	ra,4(sp)
8110d7e0:	df000017 	ldw	fp,0(sp)
8110d7e4:	dec00204 	addi	sp,sp,8
8110d7e8:	f800283a 	ret

8110d7ec <bDisableRmapIRQ>:

bool bDisableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110d7ec:	defffd04 	addi	sp,sp,-12
8110d7f0:	de00012e 	bgeu	sp,et,8110d7f8 <bDisableRmapIRQ+0xc>
8110d7f4:	003b68fa 	trap	3
8110d7f8:	dfc00215 	stw	ra,8(sp)
8110d7fc:	df000115 	stw	fp,4(sp)
8110d800:	df000104 	addi	fp,sp,4
8110d804:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bRmapGetIrqControl(pxRmapCh);
8110d808:	e13fff17 	ldw	r4,-4(fp)
8110d80c:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110d810:	e0bfff17 	ldw	r2,-4(fp)
8110d814:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110d818:	e13fff17 	ldw	r4,-4(fp)
8110d81c:	1106a3c0 	call	81106a3c <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110d820:	00800044 	movi	r2,1
}
8110d824:	e037883a 	mov	sp,fp
8110d828:	dfc00117 	ldw	ra,4(sp)
8110d82c:	df000017 	ldw	fp,0(sp)
8110d830:	dec00204 	addi	sp,sp,8
8110d834:	f800283a 	ret

8110d838 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110d838:	defffd04 	addi	sp,sp,-12
8110d83c:	de00012e 	bgeu	sp,et,8110d844 <bEnableRmapIRQ+0xc>
8110d840:	003b68fa 	trap	3
8110d844:	dfc00215 	stw	ra,8(sp)
8110d848:	df000115 	stw	fp,4(sp)
8110d84c:	df000104 	addi	fp,sp,4
8110d850:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bRmapGetIrqControl(pxRmapCh);
8110d854:	e13fff17 	ldw	r4,-4(fp)
8110d858:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110d85c:	e0bfff17 	ldw	r2,-4(fp)
8110d860:	00c00044 	movi	r3,1
8110d864:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110d868:	e13fff17 	ldw	r4,-4(fp)
8110d86c:	1106a3c0 	call	81106a3c <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110d870:	00800044 	movi	r2,1
}
8110d874:	e037883a 	mov	sp,fp
8110d878:	dfc00117 	ldw	ra,4(sp)
8110d87c:	df000017 	ldw	fp,0(sp)
8110d880:	dec00204 	addi	sp,sp,8
8110d884:	f800283a 	ret

8110d888 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110d888:	defffd04 	addi	sp,sp,-12
8110d88c:	de00012e 	bgeu	sp,et,8110d894 <bDisableSPWChannel+0xc>
8110d890:	003b68fa 	trap	3
8110d894:	dfc00215 	stw	ra,8(sp)
8110d898:	df000115 	stw	fp,4(sp)
8110d89c:	df000104 	addi	fp,sp,4
8110d8a0:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110d8a4:	e13fff17 	ldw	r4,-4(fp)
8110d8a8:	11090680 	call	81109068 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110d8ac:	e0bfff17 	ldw	r2,-4(fp)
8110d8b0:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110d8b4:	e0bfff17 	ldw	r2,-4(fp)
8110d8b8:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110d8bc:	e0bfff17 	ldw	r2,-4(fp)
8110d8c0:	00c00044 	movi	r3,1
8110d8c4:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110d8c8:	e13fff17 	ldw	r4,-4(fp)
8110d8cc:	1108f340 	call	81108f34 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110d8d0:	00800044 	movi	r2,1
}
8110d8d4:	e037883a 	mov	sp,fp
8110d8d8:	dfc00117 	ldw	ra,4(sp)
8110d8dc:	df000017 	ldw	fp,0(sp)
8110d8e0:	dec00204 	addi	sp,sp,8
8110d8e4:	f800283a 	ret

8110d8e8 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110d8e8:	defffd04 	addi	sp,sp,-12
8110d8ec:	de00012e 	bgeu	sp,et,8110d8f4 <bEnableSPWChannel+0xc>
8110d8f0:	003b68fa 	trap	3
8110d8f4:	dfc00215 	stw	ra,8(sp)
8110d8f8:	df000115 	stw	fp,4(sp)
8110d8fc:	df000104 	addi	fp,sp,4
8110d900:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110d904:	e13fff17 	ldw	r4,-4(fp)
8110d908:	11090680 	call	81109068 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110d90c:	e0bfff17 	ldw	r2,-4(fp)
8110d910:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110d914:	e0bfff17 	ldw	r2,-4(fp)
8110d918:	00c00044 	movi	r3,1
8110d91c:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110d920:	e0bfff17 	ldw	r2,-4(fp)
8110d924:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110d928:	e13fff17 	ldw	r4,-4(fp)
8110d92c:	1108f340 	call	81108f34 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110d930:	00800044 	movi	r2,1
}
8110d934:	e037883a 	mov	sp,fp
8110d938:	dfc00117 	ldw	ra,4(sp)
8110d93c:	df000017 	ldw	fp,0(sp)
8110d940:	dec00204 	addi	sp,sp,8
8110d944:	f800283a 	ret

8110d948 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110d948:	defffd04 	addi	sp,sp,-12
8110d94c:	de00012e 	bgeu	sp,et,8110d954 <bEnableDbBuffer+0xc>
8110d950:	003b68fa 	trap	3
8110d954:	dfc00215 	stw	ra,8(sp)
8110d958:	df000115 	stw	fp,4(sp)
8110d95c:	df000104 	addi	fp,sp,4
8110d960:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110d964:	e13fff17 	ldw	r4,-4(fp)
8110d968:	1105cb00 	call	81105cb0 <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110d96c:	e13fff17 	ldw	r4,-4(fp)
8110d970:	1105ba00 	call	81105ba0 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110d974:	e13fff17 	ldw	r4,-4(fp)
8110d978:	11058900 	call	81105890 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110d97c:	e0bfff17 	ldw	r2,-4(fp)
8110d980:	00c00044 	movi	r3,1
8110d984:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110d988:	e0bfff17 	ldw	r2,-4(fp)
8110d98c:	00c00044 	movi	r3,1
8110d990:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110d994:	e13fff17 	ldw	r4,-4(fp)
8110d998:	11057bc0 	call	811057bc <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110d99c:	00800044 	movi	r2,1
}
8110d9a0:	e037883a 	mov	sp,fp
8110d9a4:	dfc00117 	ldw	ra,4(sp)
8110d9a8:	df000017 	ldw	fp,0(sp)
8110d9ac:	dec00204 	addi	sp,sp,8
8110d9b0:	f800283a 	ret

8110d9b4 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110d9b4:	defffd04 	addi	sp,sp,-12
8110d9b8:	de00012e 	bgeu	sp,et,8110d9c0 <bDisAndClrDbBuffer+0xc>
8110d9bc:	003b68fa 	trap	3
8110d9c0:	dfc00215 	stw	ra,8(sp)
8110d9c4:	df000115 	stw	fp,4(sp)
8110d9c8:	df000104 	addi	fp,sp,4
8110d9cc:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110d9d0:	e13fff17 	ldw	r4,-4(fp)
8110d9d4:	11058900 	call	81105890 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110d9d8:	e0bfff17 	ldw	r2,-4(fp)
8110d9dc:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110d9e0:	e0bfff17 	ldw	r2,-4(fp)
8110d9e4:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110d9e8:	e13fff17 	ldw	r4,-4(fp)
8110d9ec:	11057bc0 	call	811057bc <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110d9f0:	e13fff17 	ldw	r4,-4(fp)
8110d9f4:	1105c280 	call	81105c28 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110d9f8:	e13fff17 	ldw	r4,-4(fp)
8110d9fc:	1105cb00 	call	81105cb0 <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
8110da00:	00800044 	movi	r2,1
}
8110da04:	e037883a 	mov	sp,fp
8110da08:	dfc00117 	ldw	ra,4(sp)
8110da0c:	df000017 	ldw	fp,0(sp)
8110da10:	dec00204 	addi	sp,sp,8
8110da14:	f800283a 	ret

8110da18 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110da18:	defff804 	addi	sp,sp,-32
8110da1c:	de00012e 	bgeu	sp,et,8110da24 <bSendRequestNFeeCtrl+0xc>
8110da20:	003b68fa 	trap	3
8110da24:	dfc00715 	stw	ra,28(sp)
8110da28:	df000615 	stw	fp,24(sp)
8110da2c:	df000604 	addi	fp,sp,24
8110da30:	2807883a 	mov	r3,r5
8110da34:	3005883a 	mov	r2,r6
8110da38:	e13ffd05 	stb	r4,-12(fp)
8110da3c:	e0fffe05 	stb	r3,-8(fp)
8110da40:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110da44:	00800404 	movi	r2,16
8110da48:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110da4c:	e0bffd03 	ldbu	r2,-12(fp)
8110da50:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110da54:	e0bffe03 	ldbu	r2,-8(fp)
8110da58:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110da5c:	e0bfff03 	ldbu	r2,-4(fp)
8110da60:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110da64:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110da68:	d0a05717 	ldw	r2,-32420(gp)
8110da6c:	e0fffc17 	ldw	r3,-16(fp)
8110da70:	180b883a 	mov	r5,r3
8110da74:	1009883a 	mov	r4,r2
8110da78:	11390880 	call	81139088 <OSQPost>
8110da7c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110da80:	e0bffb03 	ldbu	r2,-20(fp)
8110da84:	10000526 	beq	r2,zero,8110da9c <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110da88:	e0bfff03 	ldbu	r2,-4(fp)
8110da8c:	1009883a 	mov	r4,r2
8110da90:	11187400 	call	81118740 <vFailRequestDMA>
		bSuccesL = FALSE;
8110da94:	e03ffa15 	stw	zero,-24(fp)
8110da98:	00000206 	br	8110daa4 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110da9c:	00800044 	movi	r2,1
8110daa0:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110daa4:	e0bffa17 	ldw	r2,-24(fp)
}
8110daa8:	e037883a 	mov	sp,fp
8110daac:	dfc00117 	ldw	ra,4(sp)
8110dab0:	df000017 	ldw	fp,0(sp)
8110dab4:	dec00204 	addi	sp,sp,8
8110dab8:	f800283a 	ret

8110dabc <vPrintConsoleNFee>:


#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110dabc:	defffa04 	addi	sp,sp,-24
8110dac0:	de00012e 	bgeu	sp,et,8110dac8 <vPrintConsoleNFee+0xc>
8110dac4:	003b68fa 	trap	3
8110dac8:	dfc00515 	stw	ra,20(sp)
8110dacc:	df000415 	stw	fp,16(sp)
8110dad0:	df000404 	addi	fp,sp,16
8110dad4:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110dad8:	e0bfff17 	ldw	r2,-4(fp)
8110dadc:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110dae0:	d0e05c17 	ldw	r3,-32400(gp)
8110dae4:	e0bffe17 	ldw	r2,-8(fp)
8110dae8:	10800003 	ldbu	r2,0(r2)
8110daec:	10803fcc 	andi	r2,r2,255
8110daf0:	100d883a 	mov	r6,r2
8110daf4:	01604534 	movhi	r5,33044
8110daf8:	295dcc04 	addi	r5,r5,30512
8110dafc:	1809883a 	mov	r4,r3
8110db00:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110db04:	d0a05c17 	ldw	r2,-32400(gp)
8110db08:	100b883a 	mov	r5,r2
8110db0c:	01000284 	movi	r4,10
8110db10:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110db14:	d0e05c17 	ldw	r3,-32400(gp)
8110db18:	e0bffe17 	ldw	r2,-8(fp)
8110db1c:	10800003 	ldbu	r2,0(r2)
8110db20:	10803fcc 	andi	r2,r2,255
8110db24:	100d883a 	mov	r6,r2
8110db28:	01604534 	movhi	r5,33044
8110db2c:	295de104 	addi	r5,r5,30596
8110db30:	1809883a 	mov	r4,r3
8110db34:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110db38:	d0e05c17 	ldw	r3,-32400(gp)
8110db3c:	e0bffe17 	ldw	r2,-8(fp)
8110db40:	10802f0b 	ldhu	r2,188(r2)
8110db44:	10bfffcc 	andi	r2,r2,65535
8110db48:	100d883a 	mov	r6,r2
8110db4c:	01604534 	movhi	r5,33044
8110db50:	295de704 	addi	r5,r5,30620
8110db54:	1809883a 	mov	r4,r3
8110db58:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110db5c:	d0e05c17 	ldw	r3,-32400(gp)
8110db60:	e0bffe17 	ldw	r2,-8(fp)
8110db64:	10802f8b 	ldhu	r2,190(r2)
8110db68:	10bfffcc 	andi	r2,r2,65535
8110db6c:	100d883a 	mov	r6,r2
8110db70:	01604534 	movhi	r5,33044
8110db74:	295dec04 	addi	r5,r5,30640
8110db78:	1809883a 	mov	r4,r3
8110db7c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110db80:	d0e05c17 	ldw	r3,-32400(gp)
8110db84:	e0bffe17 	ldw	r2,-8(fp)
8110db88:	1080300b 	ldhu	r2,192(r2)
8110db8c:	10bfffcc 	andi	r2,r2,65535
8110db90:	100d883a 	mov	r6,r2
8110db94:	01604534 	movhi	r5,33044
8110db98:	295df204 	addi	r5,r5,30664
8110db9c:	1809883a 	mov	r4,r3
8110dba0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110dba4:	d0e05c17 	ldw	r3,-32400(gp)
8110dba8:	e0bffe17 	ldw	r2,-8(fp)
8110dbac:	1080308b 	ldhu	r2,194(r2)
8110dbb0:	10bfffcc 	andi	r2,r2,65535
8110dbb4:	100d883a 	mov	r6,r2
8110dbb8:	01604534 	movhi	r5,33044
8110dbbc:	295df604 	addi	r5,r5,30680
8110dbc0:	1809883a 	mov	r4,r3
8110dbc4:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110dbc8:	d0e05c17 	ldw	r3,-32400(gp)
8110dbcc:	e0bffe17 	ldw	r2,-8(fp)
8110dbd0:	1080310b 	ldhu	r2,196(r2)
8110dbd4:	10bfffcc 	andi	r2,r2,65535
8110dbd8:	100d883a 	mov	r6,r2
8110dbdc:	01604534 	movhi	r5,33044
8110dbe0:	295dfc04 	addi	r5,r5,30704
8110dbe4:	1809883a 	mov	r4,r3
8110dbe8:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110dbec:	d0a05c17 	ldw	r2,-32400(gp)
8110dbf0:	100b883a 	mov	r5,r2
8110dbf4:	01000284 	movi	r4,10
8110dbf8:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110dbfc:	d0e05c17 	ldw	r3,-32400(gp)
8110dc00:	e0bffe17 	ldw	r2,-8(fp)
8110dc04:	10800003 	ldbu	r2,0(r2)
8110dc08:	10803fcc 	andi	r2,r2,255
8110dc0c:	100d883a 	mov	r6,r2
8110dc10:	01604534 	movhi	r5,33044
8110dc14:	295e0104 	addi	r5,r5,30724
8110dc18:	1809883a 	mov	r4,r3
8110dc1c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110dc20:	d0e05c17 	ldw	r3,-32400(gp)
8110dc24:	e0bffe17 	ldw	r2,-8(fp)
8110dc28:	10802c17 	ldw	r2,176(r2)
8110dc2c:	100d883a 	mov	r6,r2
8110dc30:	01604534 	movhi	r5,33044
8110dc34:	295e0704 	addi	r5,r5,30748
8110dc38:	1809883a 	mov	r4,r3
8110dc3c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110dc40:	d0e05c17 	ldw	r3,-32400(gp)
8110dc44:	e0bffe17 	ldw	r2,-8(fp)
8110dc48:	10802117 	ldw	r2,132(r2)
8110dc4c:	100d883a 	mov	r6,r2
8110dc50:	01604534 	movhi	r5,33044
8110dc54:	295e0d04 	addi	r5,r5,30772
8110dc58:	1809883a 	mov	r4,r3
8110dc5c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110dc60:	d0e05c17 	ldw	r3,-32400(gp)
8110dc64:	e0bffe17 	ldw	r2,-8(fp)
8110dc68:	10802317 	ldw	r2,140(r2)
8110dc6c:	100d883a 	mov	r6,r2
8110dc70:	01604534 	movhi	r5,33044
8110dc74:	295e1404 	addi	r5,r5,30800
8110dc78:	1809883a 	mov	r4,r3
8110dc7c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110dc80:	d0e05c17 	ldw	r3,-32400(gp)
8110dc84:	e0bffe17 	ldw	r2,-8(fp)
8110dc88:	10802417 	ldw	r2,144(r2)
8110dc8c:	100d883a 	mov	r6,r2
8110dc90:	01604534 	movhi	r5,33044
8110dc94:	295e1b04 	addi	r5,r5,30828
8110dc98:	1809883a 	mov	r4,r3
8110dc9c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110dca0:	d0e05c17 	ldw	r3,-32400(gp)
8110dca4:	e0bffe17 	ldw	r2,-8(fp)
8110dca8:	10802517 	ldw	r2,148(r2)
8110dcac:	100d883a 	mov	r6,r2
8110dcb0:	01604534 	movhi	r5,33044
8110dcb4:	295e2204 	addi	r5,r5,30856
8110dcb8:	1809883a 	mov	r4,r3
8110dcbc:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110dcc0:	d0e05c17 	ldw	r3,-32400(gp)
8110dcc4:	e0bffe17 	ldw	r2,-8(fp)
8110dcc8:	10802617 	ldw	r2,152(r2)
8110dccc:	100d883a 	mov	r6,r2
8110dcd0:	01604534 	movhi	r5,33044
8110dcd4:	295e2904 	addi	r5,r5,30884
8110dcd8:	1809883a 	mov	r4,r3
8110dcdc:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110dce0:	d1205c17 	ldw	r4,-32400(gp)
8110dce4:	e0bffe17 	ldw	r2,-8(fp)
8110dce8:	10802a43 	ldbu	r2,169(r2)
8110dcec:	11403fcc 	andi	r5,r2,255
8110dcf0:	e0bffe17 	ldw	r2,-8(fp)
8110dcf4:	10802a83 	ldbu	r2,170(r2)
8110dcf8:	11803fcc 	andi	r6,r2,255
8110dcfc:	e0bffe17 	ldw	r2,-8(fp)
8110dd00:	10802ac3 	ldbu	r2,171(r2)
8110dd04:	10803fcc 	andi	r2,r2,255
8110dd08:	e0fffe17 	ldw	r3,-8(fp)
8110dd0c:	18c02b03 	ldbu	r3,172(r3)
8110dd10:	18c03fcc 	andi	r3,r3,255
8110dd14:	d8c00115 	stw	r3,4(sp)
8110dd18:	d8800015 	stw	r2,0(sp)
8110dd1c:	300f883a 	mov	r7,r6
8110dd20:	280d883a 	mov	r6,r5
8110dd24:	01604534 	movhi	r5,33044
8110dd28:	295e3004 	addi	r5,r5,30912
8110dd2c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110dd30:	d0e05c17 	ldw	r3,-32400(gp)
8110dd34:	e0bffe17 	ldw	r2,-8(fp)
8110dd38:	10802e17 	ldw	r2,184(r2)
8110dd3c:	100d883a 	mov	r6,r2
8110dd40:	01604534 	movhi	r5,33044
8110dd44:	295e3d04 	addi	r5,r5,30964
8110dd48:	1809883a 	mov	r4,r3
8110dd4c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n\n");
8110dd50:	d0a05c17 	ldw	r2,-32400(gp)
8110dd54:	100f883a 	mov	r7,r2
8110dd58:	01800084 	movi	r6,2
8110dd5c:	01400044 	movi	r5,1
8110dd60:	01204534 	movhi	r4,33044
8110dd64:	211e4304 	addi	r4,r4,30988
8110dd68:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110dd6c:	d0e05c17 	ldw	r3,-32400(gp)
8110dd70:	e0bffe17 	ldw	r2,-8(fp)
8110dd74:	10800003 	ldbu	r2,0(r2)
8110dd78:	10803fcc 	andi	r2,r2,255
8110dd7c:	100d883a 	mov	r6,r2
8110dd80:	01604534 	movhi	r5,33044
8110dd84:	295e4404 	addi	r5,r5,30992
8110dd88:	1809883a 	mov	r4,r3
8110dd8c:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    General Info: \n");
8110dd90:	d0a05c17 	ldw	r2,-32400(gp)
8110dd94:	100f883a 	mov	r7,r2
8110dd98:	018004c4 	movi	r6,19
8110dd9c:	01400044 	movi	r5,1
8110dda0:	01204534 	movhi	r4,33044
8110dda4:	211e4a04 	addi	r4,r4,31016
8110dda8:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110ddac:	d0e05c17 	ldw	r3,-32400(gp)
8110ddb0:	e0bffe17 	ldw	r2,-8(fp)
8110ddb4:	10800117 	ldw	r2,4(r2)
8110ddb8:	100d883a 	mov	r6,r2
8110ddbc:	01604534 	movhi	r5,33044
8110ddc0:	295e4f04 	addi	r5,r5,31036
8110ddc4:	1809883a 	mov	r4,r3
8110ddc8:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110ddcc:	d0e05c17 	ldw	r3,-32400(gp)
8110ddd0:	e0bffe17 	ldw	r2,-8(fp)
8110ddd4:	10800217 	ldw	r2,8(r2)
8110ddd8:	100d883a 	mov	r6,r2
8110dddc:	01604534 	movhi	r5,33044
8110dde0:	295e5704 	addi	r5,r5,31068
8110dde4:	1809883a 	mov	r4,r3
8110dde8:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110ddec:	d0e05c17 	ldw	r3,-32400(gp)
8110ddf0:	e0bffe17 	ldw	r2,-8(fp)
8110ddf4:	10800317 	ldw	r2,12(r2)
8110ddf8:	100d883a 	mov	r6,r2
8110ddfc:	01604534 	movhi	r5,33044
8110de00:	295e5f04 	addi	r5,r5,31100
8110de04:	1809883a 	mov	r4,r3
8110de08:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110de0c:	d0a05c17 	ldw	r2,-32400(gp)
8110de10:	100f883a 	mov	r7,r2
8110de14:	01800644 	movi	r6,25
8110de18:	01400044 	movi	r5,1
8110de1c:	01204534 	movhi	r4,33044
8110de20:	211e6604 	addi	r4,r4,31128
8110de24:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110de28:	d0e05c17 	ldw	r3,-32400(gp)
8110de2c:	e0bffe17 	ldw	r2,-8(fp)
8110de30:	10800517 	ldw	r2,20(r2)
8110de34:	100d883a 	mov	r6,r2
8110de38:	01604534 	movhi	r5,33044
8110de3c:	295e6d04 	addi	r5,r5,31156
8110de40:	1809883a 	mov	r4,r3
8110de44:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110de48:	d0e05c17 	ldw	r3,-32400(gp)
8110de4c:	e0bffe17 	ldw	r2,-8(fp)
8110de50:	10800417 	ldw	r2,16(r2)
8110de54:	100d883a 	mov	r6,r2
8110de58:	01604534 	movhi	r5,33044
8110de5c:	295e7504 	addi	r5,r5,31188
8110de60:	1809883a 	mov	r4,r3
8110de64:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110de68:	d0e05c17 	ldw	r3,-32400(gp)
8110de6c:	e0bffe17 	ldw	r2,-8(fp)
8110de70:	10800603 	ldbu	r2,24(r2)
8110de74:	10803fcc 	andi	r2,r2,255
8110de78:	100d883a 	mov	r6,r2
8110de7c:	01604534 	movhi	r5,33044
8110de80:	295e7d04 	addi	r5,r5,31220
8110de84:	1809883a 	mov	r4,r3
8110de88:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110de8c:	d2205c17 	ldw	r8,-32400(gp)
8110de90:	e13ffe17 	ldw	r4,-8(fp)
8110de94:	20800717 	ldw	r2,28(r4)
8110de98:	20c00817 	ldw	r3,32(r4)
8110de9c:	100d883a 	mov	r6,r2
8110dea0:	180f883a 	mov	r7,r3
8110dea4:	01604534 	movhi	r5,33044
8110dea8:	295e8504 	addi	r5,r5,31252
8110deac:	4009883a 	mov	r4,r8
8110deb0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110deb4:	d0a05c17 	ldw	r2,-32400(gp)
8110deb8:	100b883a 	mov	r5,r2
8110debc:	01000284 	movi	r4,10
8110dec0:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8110dec4:	d0e05c17 	ldw	r3,-32400(gp)
8110dec8:	e0bffe17 	ldw	r2,-8(fp)
8110decc:	10800003 	ldbu	r2,0(r2)
8110ded0:	10803fcc 	andi	r2,r2,255
8110ded4:	100f883a 	mov	r7,r2
8110ded8:	000d883a 	mov	r6,zero
8110dedc:	01604534 	movhi	r5,33044
8110dee0:	295e8d04 	addi	r5,r5,31284
8110dee4:	1809883a 	mov	r4,r3
8110dee8:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Left side \n");
8110deec:	d0a05c17 	ldw	r2,-32400(gp)
8110def0:	100f883a 	mov	r7,r2
8110def4:	018004c4 	movi	r6,19
8110def8:	01400044 	movi	r5,1
8110defc:	01204534 	movhi	r4,33044
8110df00:	211e9704 	addi	r4,r4,31324
8110df04:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
8110df08:	d0e05c17 	ldw	r3,-32400(gp)
8110df0c:	e0bffe17 	ldw	r2,-8(fp)
8110df10:	10800917 	ldw	r2,36(r2)
8110df14:	100d883a 	mov	r6,r2
8110df18:	01604534 	movhi	r5,33044
8110df1c:	295e9c04 	addi	r5,r5,31344
8110df20:	1809883a 	mov	r4,r3
8110df24:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
8110df28:	d0e05c17 	ldw	r3,-32400(gp)
8110df2c:	e0bffe17 	ldw	r2,-8(fp)
8110df30:	10800a17 	ldw	r2,40(r2)
8110df34:	100d883a 	mov	r6,r2
8110df38:	01604534 	movhi	r5,33044
8110df3c:	295ea504 	addi	r5,r5,31380
8110df40:	1809883a 	mov	r4,r3
8110df44:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
8110df48:	d0e05c17 	ldw	r3,-32400(gp)
8110df4c:	e0bffe17 	ldw	r2,-8(fp)
8110df50:	10800b17 	ldw	r2,44(r2)
8110df54:	100d883a 	mov	r6,r2
8110df58:	01604534 	movhi	r5,33044
8110df5c:	295eb004 	addi	r5,r5,31424
8110df60:	1809883a 	mov	r4,r3
8110df64:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Right side \n");
8110df68:	d0a05c17 	ldw	r2,-32400(gp)
8110df6c:	100f883a 	mov	r7,r2
8110df70:	01800504 	movi	r6,20
8110df74:	01400044 	movi	r5,1
8110df78:	01204534 	movhi	r4,33044
8110df7c:	211ebc04 	addi	r4,r4,31472
8110df80:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8110df84:	d0e05c17 	ldw	r3,-32400(gp)
8110df88:	e0bffe17 	ldw	r2,-8(fp)
8110df8c:	10800c17 	ldw	r2,48(r2)
8110df90:	100d883a 	mov	r6,r2
8110df94:	01604534 	movhi	r5,33044
8110df98:	295e9c04 	addi	r5,r5,31344
8110df9c:	1809883a 	mov	r4,r3
8110dfa0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8110dfa4:	d0e05c17 	ldw	r3,-32400(gp)
8110dfa8:	e0bffe17 	ldw	r2,-8(fp)
8110dfac:	10800d17 	ldw	r2,52(r2)
8110dfb0:	100d883a 	mov	r6,r2
8110dfb4:	01604534 	movhi	r5,33044
8110dfb8:	295ea504 	addi	r5,r5,31380
8110dfbc:	1809883a 	mov	r4,r3
8110dfc0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8110dfc4:	d0e05c17 	ldw	r3,-32400(gp)
8110dfc8:	e0bffe17 	ldw	r2,-8(fp)
8110dfcc:	10800e17 	ldw	r2,56(r2)
8110dfd0:	100d883a 	mov	r6,r2
8110dfd4:	01604534 	movhi	r5,33044
8110dfd8:	295eb004 	addi	r5,r5,31424
8110dfdc:	1809883a 	mov	r4,r3
8110dfe0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110dfe4:	d0a05c17 	ldw	r2,-32400(gp)
8110dfe8:	100b883a 	mov	r5,r2
8110dfec:	01000284 	movi	r4,10
8110dff0:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8110dff4:	d0e05c17 	ldw	r3,-32400(gp)
8110dff8:	e0bffe17 	ldw	r2,-8(fp)
8110dffc:	10800003 	ldbu	r2,0(r2)
8110e000:	10803fcc 	andi	r2,r2,255
8110e004:	100f883a 	mov	r7,r2
8110e008:	01800044 	movi	r6,1
8110e00c:	01604534 	movhi	r5,33044
8110e010:	295e8d04 	addi	r5,r5,31284
8110e014:	1809883a 	mov	r4,r3
8110e018:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Left side \n");
8110e01c:	d0a05c17 	ldw	r2,-32400(gp)
8110e020:	100f883a 	mov	r7,r2
8110e024:	018004c4 	movi	r6,19
8110e028:	01400044 	movi	r5,1
8110e02c:	01204534 	movhi	r4,33044
8110e030:	211e9704 	addi	r4,r4,31324
8110e034:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
8110e038:	d0e05c17 	ldw	r3,-32400(gp)
8110e03c:	e0bffe17 	ldw	r2,-8(fp)
8110e040:	10800f17 	ldw	r2,60(r2)
8110e044:	100d883a 	mov	r6,r2
8110e048:	01604534 	movhi	r5,33044
8110e04c:	295e9c04 	addi	r5,r5,31344
8110e050:	1809883a 	mov	r4,r3
8110e054:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
8110e058:	d0e05c17 	ldw	r3,-32400(gp)
8110e05c:	e0bffe17 	ldw	r2,-8(fp)
8110e060:	10801017 	ldw	r2,64(r2)
8110e064:	100d883a 	mov	r6,r2
8110e068:	01604534 	movhi	r5,33044
8110e06c:	295ea504 	addi	r5,r5,31380
8110e070:	1809883a 	mov	r4,r3
8110e074:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
8110e078:	d0e05c17 	ldw	r3,-32400(gp)
8110e07c:	e0bffe17 	ldw	r2,-8(fp)
8110e080:	10801117 	ldw	r2,68(r2)
8110e084:	100d883a 	mov	r6,r2
8110e088:	01604534 	movhi	r5,33044
8110e08c:	295eb004 	addi	r5,r5,31424
8110e090:	1809883a 	mov	r4,r3
8110e094:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Right side \n");
8110e098:	d0a05c17 	ldw	r2,-32400(gp)
8110e09c:	100f883a 	mov	r7,r2
8110e0a0:	01800504 	movi	r6,20
8110e0a4:	01400044 	movi	r5,1
8110e0a8:	01204534 	movhi	r4,33044
8110e0ac:	211ebc04 	addi	r4,r4,31472
8110e0b0:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8110e0b4:	d0e05c17 	ldw	r3,-32400(gp)
8110e0b8:	e0bffe17 	ldw	r2,-8(fp)
8110e0bc:	10801217 	ldw	r2,72(r2)
8110e0c0:	100d883a 	mov	r6,r2
8110e0c4:	01604534 	movhi	r5,33044
8110e0c8:	295e9c04 	addi	r5,r5,31344
8110e0cc:	1809883a 	mov	r4,r3
8110e0d0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8110e0d4:	d0e05c17 	ldw	r3,-32400(gp)
8110e0d8:	e0bffe17 	ldw	r2,-8(fp)
8110e0dc:	10801317 	ldw	r2,76(r2)
8110e0e0:	100d883a 	mov	r6,r2
8110e0e4:	01604534 	movhi	r5,33044
8110e0e8:	295ea504 	addi	r5,r5,31380
8110e0ec:	1809883a 	mov	r4,r3
8110e0f0:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8110e0f4:	d0e05c17 	ldw	r3,-32400(gp)
8110e0f8:	e0bffe17 	ldw	r2,-8(fp)
8110e0fc:	10801417 	ldw	r2,80(r2)
8110e100:	100d883a 	mov	r6,r2
8110e104:	01604534 	movhi	r5,33044
8110e108:	295eb004 	addi	r5,r5,31424
8110e10c:	1809883a 	mov	r4,r3
8110e110:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110e114:	d0a05c17 	ldw	r2,-32400(gp)
8110e118:	100b883a 	mov	r5,r2
8110e11c:	01000284 	movi	r4,10
8110e120:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8110e124:	d0e05c17 	ldw	r3,-32400(gp)
8110e128:	e0bffe17 	ldw	r2,-8(fp)
8110e12c:	10800003 	ldbu	r2,0(r2)
8110e130:	10803fcc 	andi	r2,r2,255
8110e134:	100f883a 	mov	r7,r2
8110e138:	01800084 	movi	r6,2
8110e13c:	01604534 	movhi	r5,33044
8110e140:	295e8d04 	addi	r5,r5,31284
8110e144:	1809883a 	mov	r4,r3
8110e148:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Left side \n");
8110e14c:	d0a05c17 	ldw	r2,-32400(gp)
8110e150:	100f883a 	mov	r7,r2
8110e154:	018004c4 	movi	r6,19
8110e158:	01400044 	movi	r5,1
8110e15c:	01204534 	movhi	r4,33044
8110e160:	211e9704 	addi	r4,r4,31324
8110e164:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
8110e168:	d0e05c17 	ldw	r3,-32400(gp)
8110e16c:	e0bffe17 	ldw	r2,-8(fp)
8110e170:	10801517 	ldw	r2,84(r2)
8110e174:	100d883a 	mov	r6,r2
8110e178:	01604534 	movhi	r5,33044
8110e17c:	295e9c04 	addi	r5,r5,31344
8110e180:	1809883a 	mov	r4,r3
8110e184:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
8110e188:	d0e05c17 	ldw	r3,-32400(gp)
8110e18c:	e0bffe17 	ldw	r2,-8(fp)
8110e190:	10801617 	ldw	r2,88(r2)
8110e194:	100d883a 	mov	r6,r2
8110e198:	01604534 	movhi	r5,33044
8110e19c:	295ea504 	addi	r5,r5,31380
8110e1a0:	1809883a 	mov	r4,r3
8110e1a4:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
8110e1a8:	d0e05c17 	ldw	r3,-32400(gp)
8110e1ac:	e0bffe17 	ldw	r2,-8(fp)
8110e1b0:	10801717 	ldw	r2,92(r2)
8110e1b4:	100d883a 	mov	r6,r2
8110e1b8:	01604534 	movhi	r5,33044
8110e1bc:	295eb004 	addi	r5,r5,31424
8110e1c0:	1809883a 	mov	r4,r3
8110e1c4:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Right side \n");
8110e1c8:	d0a05c17 	ldw	r2,-32400(gp)
8110e1cc:	100f883a 	mov	r7,r2
8110e1d0:	01800504 	movi	r6,20
8110e1d4:	01400044 	movi	r5,1
8110e1d8:	01204534 	movhi	r4,33044
8110e1dc:	211ebc04 	addi	r4,r4,31472
8110e1e0:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8110e1e4:	d0e05c17 	ldw	r3,-32400(gp)
8110e1e8:	e0bffe17 	ldw	r2,-8(fp)
8110e1ec:	10801817 	ldw	r2,96(r2)
8110e1f0:	100d883a 	mov	r6,r2
8110e1f4:	01604534 	movhi	r5,33044
8110e1f8:	295e9c04 	addi	r5,r5,31344
8110e1fc:	1809883a 	mov	r4,r3
8110e200:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8110e204:	d0e05c17 	ldw	r3,-32400(gp)
8110e208:	e0bffe17 	ldw	r2,-8(fp)
8110e20c:	10801917 	ldw	r2,100(r2)
8110e210:	100d883a 	mov	r6,r2
8110e214:	01604534 	movhi	r5,33044
8110e218:	295ea504 	addi	r5,r5,31380
8110e21c:	1809883a 	mov	r4,r3
8110e220:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8110e224:	d0e05c17 	ldw	r3,-32400(gp)
8110e228:	e0bffe17 	ldw	r2,-8(fp)
8110e22c:	10801a17 	ldw	r2,104(r2)
8110e230:	100d883a 	mov	r6,r2
8110e234:	01604534 	movhi	r5,33044
8110e238:	295eb004 	addi	r5,r5,31424
8110e23c:	1809883a 	mov	r4,r3
8110e240:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110e244:	d0a05c17 	ldw	r2,-32400(gp)
8110e248:	100b883a 	mov	r5,r2
8110e24c:	01000284 	movi	r4,10
8110e250:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8110e254:	d0e05c17 	ldw	r3,-32400(gp)
8110e258:	e0bffe17 	ldw	r2,-8(fp)
8110e25c:	10800003 	ldbu	r2,0(r2)
8110e260:	10803fcc 	andi	r2,r2,255
8110e264:	100f883a 	mov	r7,r2
8110e268:	018000c4 	movi	r6,3
8110e26c:	01604534 	movhi	r5,33044
8110e270:	295e8d04 	addi	r5,r5,31284
8110e274:	1809883a 	mov	r4,r3
8110e278:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Left side \n");
8110e27c:	d0a05c17 	ldw	r2,-32400(gp)
8110e280:	100f883a 	mov	r7,r2
8110e284:	018004c4 	movi	r6,19
8110e288:	01400044 	movi	r5,1
8110e28c:	01204534 	movhi	r4,33044
8110e290:	211e9704 	addi	r4,r4,31324
8110e294:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
8110e298:	d0e05c17 	ldw	r3,-32400(gp)
8110e29c:	e0bffe17 	ldw	r2,-8(fp)
8110e2a0:	10801b17 	ldw	r2,108(r2)
8110e2a4:	100d883a 	mov	r6,r2
8110e2a8:	01604534 	movhi	r5,33044
8110e2ac:	295e9c04 	addi	r5,r5,31344
8110e2b0:	1809883a 	mov	r4,r3
8110e2b4:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
8110e2b8:	d0e05c17 	ldw	r3,-32400(gp)
8110e2bc:	e0bffe17 	ldw	r2,-8(fp)
8110e2c0:	10801c17 	ldw	r2,112(r2)
8110e2c4:	100d883a 	mov	r6,r2
8110e2c8:	01604534 	movhi	r5,33044
8110e2cc:	295ea504 	addi	r5,r5,31380
8110e2d0:	1809883a 	mov	r4,r3
8110e2d4:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
8110e2d8:	d0e05c17 	ldw	r3,-32400(gp)
8110e2dc:	e0bffe17 	ldw	r2,-8(fp)
8110e2e0:	10801d17 	ldw	r2,116(r2)
8110e2e4:	100d883a 	mov	r6,r2
8110e2e8:	01604534 	movhi	r5,33044
8110e2ec:	295eb004 	addi	r5,r5,31424
8110e2f0:	1809883a 	mov	r4,r3
8110e2f4:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"        Right side \n");
8110e2f8:	d0a05c17 	ldw	r2,-32400(gp)
8110e2fc:	100f883a 	mov	r7,r2
8110e300:	01800504 	movi	r6,20
8110e304:	01400044 	movi	r5,1
8110e308:	01204534 	movhi	r4,33044
8110e30c:	211ebc04 	addi	r4,r4,31472
8110e310:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8110e314:	d0e05c17 	ldw	r3,-32400(gp)
8110e318:	e0bffe17 	ldw	r2,-8(fp)
8110e31c:	10801e17 	ldw	r2,120(r2)
8110e320:	100d883a 	mov	r6,r2
8110e324:	01604534 	movhi	r5,33044
8110e328:	295e9c04 	addi	r5,r5,31344
8110e32c:	1809883a 	mov	r4,r3
8110e330:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8110e334:	d0e05c17 	ldw	r3,-32400(gp)
8110e338:	e0bffe17 	ldw	r2,-8(fp)
8110e33c:	10801f17 	ldw	r2,124(r2)
8110e340:	100d883a 	mov	r6,r2
8110e344:	01604534 	movhi	r5,33044
8110e348:	295ea504 	addi	r5,r5,31380
8110e34c:	1809883a 	mov	r4,r3
8110e350:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8110e354:	d0e05c17 	ldw	r3,-32400(gp)
8110e358:	e0bffe17 	ldw	r2,-8(fp)
8110e35c:	10802017 	ldw	r2,128(r2)
8110e360:	100d883a 	mov	r6,r2
8110e364:	01604534 	movhi	r5,33044
8110e368:	295eb004 	addi	r5,r5,31424
8110e36c:	1809883a 	mov	r4,r3
8110e370:	111ba9c0 	call	8111ba9c <fprintf>
		fprintf(fp,"\n");
8110e374:	d0a05c17 	ldw	r2,-32400(gp)
8110e378:	100b883a 	mov	r5,r2
8110e37c:	01000284 	movi	r4,10
8110e380:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"==============================================================================\n");
8110e384:	d0a05c17 	ldw	r2,-32400(gp)
8110e388:	100f883a 	mov	r7,r2
8110e38c:	018013c4 	movi	r6,79
8110e390:	01400044 	movi	r5,1
8110e394:	01204534 	movhi	r4,33044
8110e398:	211ec204 	addi	r4,r4,31496
8110e39c:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"==============================================================================\n");
8110e3a0:	d0a05c17 	ldw	r2,-32400(gp)
8110e3a4:	100f883a 	mov	r7,r2
8110e3a8:	018013c4 	movi	r6,79
8110e3ac:	01400044 	movi	r5,1
8110e3b0:	01204534 	movhi	r4,33044
8110e3b4:	211ec204 	addi	r4,r4,31496
8110e3b8:	111c1380 	call	8111c138 <fwrite>
		fprintf(fp,"\n");
8110e3bc:	d0a05c17 	ldw	r2,-32400(gp)
8110e3c0:	100b883a 	mov	r5,r2
8110e3c4:	01000284 	movi	r4,10
8110e3c8:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"\n");
8110e3cc:	d0a05c17 	ldw	r2,-32400(gp)
8110e3d0:	100b883a 	mov	r5,r2
8110e3d4:	01000284 	movi	r4,10
8110e3d8:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"\n");
8110e3dc:	d0a05c17 	ldw	r2,-32400(gp)
8110e3e0:	100b883a 	mov	r5,r2
8110e3e4:	01000284 	movi	r4,10
8110e3e8:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"\n");
8110e3ec:	d0a05c17 	ldw	r2,-32400(gp)
8110e3f0:	100b883a 	mov	r5,r2
8110e3f4:	01000284 	movi	r4,10
8110e3f8:	111bb140 	call	8111bb14 <fputc>
		fprintf(fp,"\n");
8110e3fc:	d0a05c17 	ldw	r2,-32400(gp)
8110e400:	100b883a 	mov	r5,r2
8110e404:	01000284 	movi	r4,10
8110e408:	111bb140 	call	8111bb14 <fputc>
	}
8110e40c:	0001883a 	nop
8110e410:	e037883a 	mov	sp,fp
8110e414:	dfc00117 	ldw	ra,4(sp)
8110e418:	df000017 	ldw	fp,0(sp)
8110e41c:	dec00204 	addi	sp,sp,8
8110e420:	f800283a 	ret

8110e424 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110e424:	defff604 	addi	sp,sp,-40
8110e428:	de00012e 	bgeu	sp,et,8110e430 <vInAckHandlerTaskV2+0xc>
8110e42c:	003b68fa 	trap	3
8110e430:	dfc00915 	stw	ra,36(sp)
8110e434:	df000815 	stw	fp,32(sp)
8110e438:	df000804 	addi	fp,sp,32
8110e43c:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110e440:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110e444:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110e448:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110e44c:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110e450:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110e454:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110e458:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
8110e45c:	d0a05c17 	ldw	r2,-32400(gp)
8110e460:	100f883a 	mov	r7,r2
8110e464:	018007c4 	movi	r6,31
8110e468:	01400044 	movi	r5,1
8110e46c:	01204534 	movhi	r4,33044
8110e470:	211ed604 	addi	r4,r4,31576
8110e474:	111c1380 	call	8111c138 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8110e478:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110e47c:	e0bff917 	ldw	r2,-28(fp)
8110e480:	10c00060 	cmpeqi	r3,r2,1
8110e484:	1800071e 	bne	r3,zero,8110e4a4 <vInAckHandlerTaskV2+0x80>
8110e488:	0080032e 	bgeu	zero,r2,8110e498 <vInAckHandlerTaskV2+0x74>
8110e48c:	108000a0 	cmpeqi	r2,r2,2
8110e490:	10004a1e 	bne	r2,zero,8110e5bc <vInAckHandlerTaskV2+0x198>
8110e494:	0000ac06 	br	8110e748 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110e498:	00800044 	movi	r2,1
8110e49c:	e0bff915 	stw	r2,-28(fp)
				break;
8110e4a0:	0000b306 	br	8110e770 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110e4a4:	00800044 	movi	r2,1
8110e4a8:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110e4ac:	d0a06017 	ldw	r2,-32384(gp)
8110e4b0:	e0fffe04 	addi	r3,fp,-8
8110e4b4:	180d883a 	mov	r6,r3
8110e4b8:	000b883a 	mov	r5,zero
8110e4bc:	1009883a 	mov	r4,r2
8110e4c0:	1139b780 	call	81139b78 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110e4c4:	e0bffe03 	ldbu	r2,-8(fp)
8110e4c8:	10803fcc 	andi	r2,r2,255
8110e4cc:	1000391e 	bne	r2,zero,8110e5b4 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110e4d0:	d0a05f17 	ldw	r2,-32388(gp)
8110e4d4:	e0fffe04 	addi	r3,fp,-8
8110e4d8:	180d883a 	mov	r6,r3
8110e4dc:	000b883a 	mov	r5,zero
8110e4e0:	1009883a 	mov	r4,r2
8110e4e4:	1137b6c0 	call	81137b6c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110e4e8:	e0bffe03 	ldbu	r2,-8(fp)
8110e4ec:	10803fcc 	andi	r2,r2,255
8110e4f0:	10002b1e 	bne	r2,zero,8110e5a0 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110e4f4:	e03ffa45 	stb	zero,-23(fp)
8110e4f8:	00002206 	br	8110e584 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110e4fc:	e0fffa43 	ldbu	r3,-23(fp)
8110e500:	00a045b4 	movhi	r2,33046
8110e504:	10ac9d04 	addi	r2,r2,-19852
8110e508:	18c7883a 	add	r3,r3,r3
8110e50c:	18c7883a 	add	r3,r3,r3
8110e510:	10c5883a 	add	r2,r2,r3
8110e514:	10800003 	ldbu	r2,0(r2)
8110e518:	10803fcc 	andi	r2,r2,255
8110e51c:	1080201c 	xori	r2,r2,128
8110e520:	10bfe004 	addi	r2,r2,-128
8110e524:	10001426 	beq	r2,zero,8110e578 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110e528:	e0fffa43 	ldbu	r3,-23(fp)
8110e52c:	00a045b4 	movhi	r2,33046
8110e530:	10ac9d04 	addi	r2,r2,-19852
8110e534:	18c7883a 	add	r3,r3,r3
8110e538:	18c7883a 	add	r3,r3,r3
8110e53c:	10c5883a 	add	r2,r2,r3
8110e540:	10c0000b 	ldhu	r3,0(r2)
8110e544:	d0e0520d 	sth	r3,-32440(gp)
8110e548:	1080008b 	ldhu	r2,2(r2)
8110e54c:	d0a0528d 	sth	r2,-32438(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110e550:	e0fffa43 	ldbu	r3,-23(fp)
8110e554:	00a045b4 	movhi	r2,33046
8110e558:	10ac9d04 	addi	r2,r2,-19852
8110e55c:	18c7883a 	add	r3,r3,r3
8110e560:	18c7883a 	add	r3,r3,r3
8110e564:	10c5883a 	add	r2,r2,r3
8110e568:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110e56c:	00800084 	movi	r2,2
8110e570:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110e574:	00000606 	br	8110e590 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110e578:	e0bffa43 	ldbu	r2,-23(fp)
8110e57c:	10800044 	addi	r2,r2,1
8110e580:	e0bffa45 	stb	r2,-23(fp)
8110e584:	e0bffa43 	ldbu	r2,-23(fp)
8110e588:	108001b0 	cmpltui	r2,r2,6
8110e58c:	103fdb1e 	bne	r2,zero,8110e4fc <__reset+0xfb0ee4fc>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110e590:	d0a05f17 	ldw	r2,-32388(gp)
8110e594:	1009883a 	mov	r4,r2
8110e598:	11381100 	call	81138110 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110e59c:	00007406 	br	8110e770 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110e5a0:	d0a06017 	ldw	r2,-32384(gp)
8110e5a4:	1009883a 	mov	r4,r2
8110e5a8:	1139f000 	call	81139f00 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110e5ac:	1116fd00 	call	81116fd0 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110e5b0:	00006f06 	br	8110e770 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110e5b4:	1116f680 	call	81116f68 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110e5b8:	00006d06 	br	8110e770 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110e5bc:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110e5c0:	d0a06283 	ldbu	r2,-32374(gp)
8110e5c4:	10803fcc 	andi	r2,r2,255
8110e5c8:	10800218 	cmpnei	r2,r2,8
8110e5cc:	1000021e 	bne	r2,zero,8110e5d8 <vInAckHandlerTaskV2+0x1b4>
8110e5d0:	00c00104 	movi	r3,4
8110e5d4:	00000106 	br	8110e5dc <vInAckHandlerTaskV2+0x1b8>
8110e5d8:	0007883a 	mov	r3,zero
8110e5dc:	d0a06f03 	ldbu	r2,-32324(gp)
8110e5e0:	10803fcc 	andi	r2,r2,255
8110e5e4:	10800218 	cmpnei	r2,r2,8
8110e5e8:	1000021e 	bne	r2,zero,8110e5f4 <vInAckHandlerTaskV2+0x1d0>
8110e5ec:	00800084 	movi	r2,2
8110e5f0:	00000106 	br	8110e5f8 <vInAckHandlerTaskV2+0x1d4>
8110e5f4:	0005883a 	mov	r2,zero
8110e5f8:	1884b03a 	or	r2,r3,r2
8110e5fc:	1007883a 	mov	r3,r2
8110e600:	d0a06f43 	ldbu	r2,-32323(gp)
8110e604:	10803fcc 	andi	r2,r2,255
8110e608:	108001a0 	cmpeqi	r2,r2,6
8110e60c:	1884b03a 	or	r2,r3,r2
8110e610:	1007883a 	mov	r3,r2
8110e614:	e0bffa83 	ldbu	r2,-22(fp)
8110e618:	1884b03a 	or	r2,r3,r2
8110e61c:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110e620:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110e624:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110e628:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110e62c:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110e630:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110e634:	e0bffa03 	ldbu	r2,-24(fp)
8110e638:	10800044 	addi	r2,r2,1
8110e63c:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110e640:	e0bffa83 	ldbu	r2,-22(fp)
8110e644:	1080004c 	andi	r2,r2,1
8110e648:	10803fcc 	andi	r2,r2,255
8110e64c:	1000061e 	bne	r2,zero,8110e668 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110e650:	e0bffd04 	addi	r2,fp,-12
8110e654:	100b883a 	mov	r5,r2
8110e658:	d1205204 	addi	r4,gp,-32440
8110e65c:	110e7740 	call	8110e774 <bCheckInAck128>
8110e660:	e0bff815 	stw	r2,-32(fp)
8110e664:	00000206 	br	8110e670 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8110e668:	00800044 	movi	r2,1
8110e66c:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110e670:	e0bffa83 	ldbu	r2,-22(fp)
8110e674:	1080008c 	andi	r2,r2,2
8110e678:	10803fcc 	andi	r2,r2,255
8110e67c:	1000081e 	bne	r2,zero,8110e6a0 <vInAckHandlerTaskV2+0x27c>
8110e680:	e0bff817 	ldw	r2,-32(fp)
8110e684:	1000061e 	bne	r2,zero,8110e6a0 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110e688:	e0bffc04 	addi	r2,fp,-16
8110e68c:	100b883a 	mov	r5,r2
8110e690:	d1205204 	addi	r4,gp,-32440
8110e694:	110e8bc0 	call	8110e8bc <bCheckInAck64>
8110e698:	e0bff815 	stw	r2,-32(fp)
8110e69c:	00000206 	br	8110e6a8 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
8110e6a0:	00800044 	movi	r2,1
8110e6a4:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110e6a8:	e0bffa83 	ldbu	r2,-22(fp)
8110e6ac:	1080010c 	andi	r2,r2,4
8110e6b0:	10803fcc 	andi	r2,r2,255
8110e6b4:	1000081e 	bne	r2,zero,8110e6d8 <vInAckHandlerTaskV2+0x2b4>
8110e6b8:	e0bff817 	ldw	r2,-32(fp)
8110e6bc:	1000061e 	bne	r2,zero,8110e6d8 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110e6c0:	e0bffb04 	addi	r2,fp,-20
8110e6c4:	100b883a 	mov	r5,r2
8110e6c8:	d1205204 	addi	r4,gp,-32440
8110e6cc:	110ea080 	call	8110ea08 <bCheckInAck32>
8110e6d0:	e0bff815 	stw	r2,-32(fp)
8110e6d4:	00000206 	br	8110e6e0 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8110e6d8:	00800044 	movi	r2,1
8110e6dc:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110e6e0:	e0bffa03 	ldbu	r2,-24(fp)
8110e6e4:	10c00044 	addi	r3,r2,1
8110e6e8:	e0fffa05 	stb	r3,-24(fp)
8110e6ec:	10803fcc 	andi	r2,r2,255
8110e6f0:	10800ca8 	cmpgeui	r2,r2,50
8110e6f4:	10000e1e 	bne	r2,zero,8110e730 <vInAckHandlerTaskV2+0x30c>
8110e6f8:	e0bff817 	ldw	r2,-32(fp)
8110e6fc:	10000c1e 	bne	r2,zero,8110e730 <vInAckHandlerTaskV2+0x30c>
8110e700:	e0bffb17 	ldw	r2,-20(fp)
8110e704:	1005003a 	cmpeq	r2,r2,zero
8110e708:	1007883a 	mov	r3,r2
8110e70c:	e0bffc17 	ldw	r2,-16(fp)
8110e710:	1005003a 	cmpeq	r2,r2,zero
8110e714:	1884b03a 	or	r2,r3,r2
8110e718:	10c03fcc 	andi	r3,r2,255
8110e71c:	e0bffd17 	ldw	r2,-12(fp)
8110e720:	1005003a 	cmpeq	r2,r2,zero
8110e724:	10803fcc 	andi	r2,r2,255
8110e728:	1884b03a 	or	r2,r3,r2
8110e72c:	103fc11e 	bne	r2,zero,8110e634 <__reset+0xfb0ee634>
                
                if (bFound == FALSE) {
8110e730:	e0bff817 	ldw	r2,-32(fp)
8110e734:	1000011e 	bne	r2,zero,8110e73c <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110e738:	111748c0 	call	8111748c <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110e73c:	00800044 	movi	r2,1
8110e740:	e0bff915 	stw	r2,-28(fp)
				break;
8110e744:	00000a06 	br	8110e770 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
8110e748:	d0a05c17 	ldw	r2,-32400(gp)
8110e74c:	100f883a 	mov	r7,r2
8110e750:	01801144 	movi	r6,69
8110e754:	01400044 	movi	r5,1
8110e758:	01204534 	movhi	r4,33044
8110e75c:	211ede04 	addi	r4,r4,31608
8110e760:	111c1380 	call	8111c138 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
8110e764:	00800044 	movi	r2,1
8110e768:	e0bff915 	stw	r2,-28(fp)
				break;
8110e76c:	0001883a 	nop
		}
	}
8110e770:	003f4206 	br	8110e47c <__reset+0xfb0ee47c>

8110e774 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
8110e774:	defffa04 	addi	sp,sp,-24
8110e778:	de00012e 	bgeu	sp,et,8110e780 <bCheckInAck128+0xc>
8110e77c:	003b68fa 	trap	3
8110e780:	dfc00515 	stw	ra,20(sp)
8110e784:	df000415 	stw	fp,16(sp)
8110e788:	df000404 	addi	fp,sp,16
8110e78c:	e13ffe15 	stw	r4,-8(fp)
8110e790:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110e794:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110e798:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110e79c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110e7a0:	e0bfff17 	ldw	r2,-4(fp)
8110e7a4:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8110e7a8:	d0a06817 	ldw	r2,-32352(gp)
8110e7ac:	e0fffd44 	addi	r3,fp,-11
8110e7b0:	180d883a 	mov	r6,r3
8110e7b4:	01400144 	movi	r5,5
8110e7b8:	1009883a 	mov	r4,r2
8110e7bc:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110e7c0:	e0bffd43 	ldbu	r2,-11(fp)
8110e7c4:	10803fcc 	andi	r2,r2,255
8110e7c8:	10000226 	beq	r2,zero,8110e7d4 <bCheckInAck128+0x60>
        return bFound;
8110e7cc:	e0bffc17 	ldw	r2,-16(fp)
8110e7d0:	00003506 	br	8110e8a8 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110e7d4:	e03ffd05 	stb	zero,-12(fp)
8110e7d8:	00002706 	br	8110e878 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110e7dc:	e0fffd03 	ldbu	r3,-12(fp)
8110e7e0:	00a045b4 	movhi	r2,33046
8110e7e4:	10a3af04 	addi	r2,r2,-28996
8110e7e8:	18c02324 	muli	r3,r3,140
8110e7ec:	10c5883a 	add	r2,r2,r3
8110e7f0:	10802104 	addi	r2,r2,132
8110e7f4:	10c0000b 	ldhu	r3,0(r2)
8110e7f8:	e0bffe17 	ldw	r2,-8(fp)
8110e7fc:	1080008b 	ldhu	r2,2(r2)
8110e800:	18ffffcc 	andi	r3,r3,65535
8110e804:	10bfffcc 	andi	r2,r2,65535
8110e808:	1880181e 	bne	r3,r2,8110e86c <bCheckInAck128+0xf8>
            bFound = TRUE;
8110e80c:	00800044 	movi	r2,1
8110e810:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8110e814:	e0fffd03 	ldbu	r3,-12(fp)
8110e818:	00a045b4 	movhi	r2,33046
8110e81c:	10a39104 	addi	r2,r2,-29116
8110e820:	18c7883a 	add	r3,r3,r3
8110e824:	18c7883a 	add	r3,r3,r3
8110e828:	10c5883a 	add	r2,r2,r3
8110e82c:	10000015 	stw	zero,0(r2)
            SemCount128++;
8110e830:	d0a06f43 	ldbu	r2,-32323(gp)
8110e834:	10800044 	addi	r2,r2,1
8110e838:	d0a06f45 	stb	r2,-32323(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110e83c:	d0a05d17 	ldw	r2,-32396(gp)
8110e840:	1009883a 	mov	r4,r2
8110e844:	1139f000 	call	81139f00 <OSSemPost>
8110e848:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110e84c:	e0bffd43 	ldbu	r2,-11(fp)
8110e850:	10803fcc 	andi	r2,r2,255
8110e854:	10000c26 	beq	r2,zero,8110e888 <bCheckInAck128+0x114>
                SemCount128--;
8110e858:	d0a06f43 	ldbu	r2,-32323(gp)
8110e85c:	10bfffc4 	addi	r2,r2,-1
8110e860:	d0a06f45 	stb	r2,-32323(gp)
                vFailSetCountSemaphorexBuffer128();
8110e864:	11172ec0 	call	811172ec <vFailSetCountSemaphorexBuffer128>
            }
            break;
8110e868:	00000706 	br	8110e888 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110e86c:	e0bffd03 	ldbu	r2,-12(fp)
8110e870:	10800044 	addi	r2,r2,1
8110e874:	e0bffd05 	stb	r2,-12(fp)
8110e878:	e0bffd03 	ldbu	r2,-12(fp)
8110e87c:	108001b0 	cmpltui	r2,r2,6
8110e880:	103fd61e 	bne	r2,zero,8110e7dc <__reset+0xfb0ee7dc>
8110e884:	00000106 	br	8110e88c <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8110e888:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110e88c:	d0a06817 	ldw	r2,-32352(gp)
8110e890:	1009883a 	mov	r4,r2
8110e894:	11381100 	call	81138110 <OSMutexPost>
    (*bFinished) = TRUE;
8110e898:	e0bfff17 	ldw	r2,-4(fp)
8110e89c:	00c00044 	movi	r3,1
8110e8a0:	10c00015 	stw	r3,0(r2)

    return bFound;
8110e8a4:	e0bffc17 	ldw	r2,-16(fp)
}
8110e8a8:	e037883a 	mov	sp,fp
8110e8ac:	dfc00117 	ldw	ra,4(sp)
8110e8b0:	df000017 	ldw	fp,0(sp)
8110e8b4:	dec00204 	addi	sp,sp,8
8110e8b8:	f800283a 	ret

8110e8bc <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110e8bc:	defffa04 	addi	sp,sp,-24
8110e8c0:	de00012e 	bgeu	sp,et,8110e8c8 <bCheckInAck64+0xc>
8110e8c4:	003b68fa 	trap	3
8110e8c8:	dfc00515 	stw	ra,20(sp)
8110e8cc:	df000415 	stw	fp,16(sp)
8110e8d0:	df000404 	addi	fp,sp,16
8110e8d4:	e13ffe15 	stw	r4,-8(fp)
8110e8d8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110e8dc:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110e8e0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110e8e4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110e8e8:	e0bfff17 	ldw	r2,-4(fp)
8110e8ec:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110e8f0:	d0a06b17 	ldw	r2,-32340(gp)
8110e8f4:	e0fffd44 	addi	r3,fp,-11
8110e8f8:	180d883a 	mov	r6,r3
8110e8fc:	01400044 	movi	r5,1
8110e900:	1009883a 	mov	r4,r2
8110e904:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110e908:	e0bffd43 	ldbu	r2,-11(fp)
8110e90c:	10803fcc 	andi	r2,r2,255
8110e910:	10000226 	beq	r2,zero,8110e91c <bCheckInAck64+0x60>
        return bFound;
8110e914:	e0bffc17 	ldw	r2,-16(fp)
8110e918:	00003606 	br	8110e9f4 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110e91c:	e03ffd05 	stb	zero,-12(fp)
8110e920:	00002806 	br	8110e9c4 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110e924:	e0fffd03 	ldbu	r3,-12(fp)
8110e928:	00a04574 	movhi	r2,33045
8110e92c:	10bf7004 	addi	r2,r2,-576
8110e930:	18c01324 	muli	r3,r3,76
8110e934:	10c5883a 	add	r2,r2,r3
8110e938:	10801104 	addi	r2,r2,68
8110e93c:	10c0000b 	ldhu	r3,0(r2)
8110e940:	e0bffe17 	ldw	r2,-8(fp)
8110e944:	1080008b 	ldhu	r2,2(r2)
8110e948:	18ffffcc 	andi	r3,r3,65535
8110e94c:	10bfffcc 	andi	r2,r2,65535
8110e950:	1880191e 	bne	r3,r2,8110e9b8 <bCheckInAck64+0xfc>
            bFound = TRUE;
8110e954:	00800044 	movi	r2,1
8110e958:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110e95c:	e0fffd03 	ldbu	r3,-12(fp)
8110e960:	00a045b4 	movhi	r2,33046
8110e964:	10a39104 	addi	r2,r2,-29116
8110e968:	18c00184 	addi	r3,r3,6
8110e96c:	18c7883a 	add	r3,r3,r3
8110e970:	18c7883a 	add	r3,r3,r3
8110e974:	10c5883a 	add	r2,r2,r3
8110e978:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110e97c:	d0a06f03 	ldbu	r2,-32324(gp)
8110e980:	10800044 	addi	r2,r2,1
8110e984:	d0a06f05 	stb	r2,-32324(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110e988:	d0a05817 	ldw	r2,-32416(gp)
8110e98c:	1009883a 	mov	r4,r2
8110e990:	1139f000 	call	81139f00 <OSSemPost>
8110e994:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110e998:	e0bffd43 	ldbu	r2,-11(fp)
8110e99c:	10803fcc 	andi	r2,r2,255
8110e9a0:	10000c26 	beq	r2,zero,8110e9d4 <bCheckInAck64+0x118>
                SemCount64--;
8110e9a4:	d0a06f03 	ldbu	r2,-32324(gp)
8110e9a8:	10bfffc4 	addi	r2,r2,-1
8110e9ac:	d0a06f05 	stb	r2,-32324(gp)
                vFailSetCountSemaphorexBuffer64();
8110e9b0:	11172840 	call	81117284 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110e9b4:	00000706 	br	8110e9d4 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110e9b8:	e0bffd03 	ldbu	r2,-12(fp)
8110e9bc:	10800044 	addi	r2,r2,1
8110e9c0:	e0bffd05 	stb	r2,-12(fp)
8110e9c4:	e0bffd03 	ldbu	r2,-12(fp)
8110e9c8:	10800230 	cmpltui	r2,r2,8
8110e9cc:	103fd51e 	bne	r2,zero,8110e924 <__reset+0xfb0ee924>
8110e9d0:	00000106 	br	8110e9d8 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110e9d4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110e9d8:	d0a06b17 	ldw	r2,-32340(gp)
8110e9dc:	1009883a 	mov	r4,r2
8110e9e0:	11381100 	call	81138110 <OSMutexPost>
    (*bFinished) = TRUE;
8110e9e4:	e0bfff17 	ldw	r2,-4(fp)
8110e9e8:	00c00044 	movi	r3,1
8110e9ec:	10c00015 	stw	r3,0(r2)

    return bFound;
8110e9f0:	e0bffc17 	ldw	r2,-16(fp)
}
8110e9f4:	e037883a 	mov	sp,fp
8110e9f8:	dfc00117 	ldw	ra,4(sp)
8110e9fc:	df000017 	ldw	fp,0(sp)
8110ea00:	dec00204 	addi	sp,sp,8
8110ea04:	f800283a 	ret

8110ea08 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110ea08:	defffa04 	addi	sp,sp,-24
8110ea0c:	de00012e 	bgeu	sp,et,8110ea14 <bCheckInAck32+0xc>
8110ea10:	003b68fa 	trap	3
8110ea14:	dfc00515 	stw	ra,20(sp)
8110ea18:	df000415 	stw	fp,16(sp)
8110ea1c:	df000404 	addi	fp,sp,16
8110ea20:	e13ffe15 	stw	r4,-8(fp)
8110ea24:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110ea28:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110ea2c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110ea30:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110ea34:	e0bfff17 	ldw	r2,-4(fp)
8110ea38:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110ea3c:	d0a06617 	ldw	r2,-32360(gp)
8110ea40:	e0fffd44 	addi	r3,fp,-11
8110ea44:	180d883a 	mov	r6,r3
8110ea48:	01400044 	movi	r5,1
8110ea4c:	1009883a 	mov	r4,r2
8110ea50:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110ea54:	e0bffd43 	ldbu	r2,-11(fp)
8110ea58:	10803fcc 	andi	r2,r2,255
8110ea5c:	10000226 	beq	r2,zero,8110ea68 <bCheckInAck32+0x60>
        return bFound;
8110ea60:	e0bffc17 	ldw	r2,-16(fp)
8110ea64:	00003606 	br	8110eb40 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110ea68:	e03ffd05 	stb	zero,-12(fp)
8110ea6c:	00002806 	br	8110eb10 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110ea70:	e0fffd03 	ldbu	r3,-12(fp)
8110ea74:	00a04574 	movhi	r2,33045
8110ea78:	10911d04 	addi	r2,r2,17524
8110ea7c:	18c00b24 	muli	r3,r3,44
8110ea80:	10c5883a 	add	r2,r2,r3
8110ea84:	10800904 	addi	r2,r2,36
8110ea88:	10c0000b 	ldhu	r3,0(r2)
8110ea8c:	e0bffe17 	ldw	r2,-8(fp)
8110ea90:	1080008b 	ldhu	r2,2(r2)
8110ea94:	18ffffcc 	andi	r3,r3,65535
8110ea98:	10bfffcc 	andi	r2,r2,65535
8110ea9c:	1880191e 	bne	r3,r2,8110eb04 <bCheckInAck32+0xfc>
            bFound = TRUE;
8110eaa0:	00800044 	movi	r2,1
8110eaa4:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110eaa8:	e0fffd03 	ldbu	r3,-12(fp)
8110eaac:	00a045b4 	movhi	r2,33046
8110eab0:	10a39104 	addi	r2,r2,-29116
8110eab4:	18c00384 	addi	r3,r3,14
8110eab8:	18c7883a 	add	r3,r3,r3
8110eabc:	18c7883a 	add	r3,r3,r3
8110eac0:	10c5883a 	add	r2,r2,r3
8110eac4:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110eac8:	d0a06283 	ldbu	r2,-32374(gp)
8110eacc:	10800044 	addi	r2,r2,1
8110ead0:	d0a06285 	stb	r2,-32374(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110ead4:	d0a06917 	ldw	r2,-32348(gp)
8110ead8:	1009883a 	mov	r4,r2
8110eadc:	1139f000 	call	81139f00 <OSSemPost>
8110eae0:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110eae4:	e0bffd43 	ldbu	r2,-11(fp)
8110eae8:	10803fcc 	andi	r2,r2,255
8110eaec:	10000c26 	beq	r2,zero,8110eb20 <bCheckInAck32+0x118>
                SemCount32--;
8110eaf0:	d0a06283 	ldbu	r2,-32374(gp)
8110eaf4:	10bfffc4 	addi	r2,r2,-1
8110eaf8:	d0a06285 	stb	r2,-32374(gp)
                vFailSetCountSemaphorexBuffer32();
8110eafc:	111721c0 	call	8111721c <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110eb00:	00000706 	br	8110eb20 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110eb04:	e0bffd03 	ldbu	r2,-12(fp)
8110eb08:	10800044 	addi	r2,r2,1
8110eb0c:	e0bffd05 	stb	r2,-12(fp)
8110eb10:	e0bffd03 	ldbu	r2,-12(fp)
8110eb14:	10800230 	cmpltui	r2,r2,8
8110eb18:	103fd51e 	bne	r2,zero,8110ea70 <__reset+0xfb0eea70>
8110eb1c:	00000106 	br	8110eb24 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110eb20:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110eb24:	d0a06617 	ldw	r2,-32360(gp)
8110eb28:	1009883a 	mov	r4,r2
8110eb2c:	11381100 	call	81138110 <OSMutexPost>
    (*bFinished) = TRUE;
8110eb30:	e0bfff17 	ldw	r2,-4(fp)
8110eb34:	00c00044 	movi	r3,1
8110eb38:	10c00015 	stw	r3,0(r2)

    return bFound;
8110eb3c:	e0bffc17 	ldw	r2,-16(fp)
}
8110eb40:	e037883a 	mov	sp,fp
8110eb44:	dfc00117 	ldw	ra,4(sp)
8110eb48:	df000017 	ldw	fp,0(sp)
8110eb4c:	dec00204 	addi	sp,sp,8
8110eb50:	f800283a 	ret

8110eb54 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110eb54:	defff704 	addi	sp,sp,-36
8110eb58:	de00012e 	bgeu	sp,et,8110eb60 <vInitialTask+0xc>
8110eb5c:	003b68fa 	trap	3
8110eb60:	dfc00815 	stw	ra,32(sp)
8110eb64:	df000715 	stw	fp,28(sp)
8110eb68:	df000704 	addi	fp,sp,28
8110eb6c:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110eb70:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110eb74:	d8000415 	stw	zero,16(sp)
8110eb78:	d8000315 	stw	zero,12(sp)
8110eb7c:	00810004 	movi	r2,1024
8110eb80:	d8800215 	stw	r2,8(sp)
8110eb84:	00a04574 	movhi	r2,33045
8110eb88:	10b77004 	addi	r2,r2,-8768
8110eb8c:	d8800115 	stw	r2,4(sp)
8110eb90:	00800244 	movi	r2,9
8110eb94:	d8800015 	stw	r2,0(sp)
8110eb98:	01c00244 	movi	r7,9
8110eb9c:	01a04574 	movhi	r6,33045
8110eba0:	31bb6f04 	addi	r6,r6,-4676
8110eba4:	01604574 	movhi	r5,33045
8110eba8:	294c8204 	addi	r5,r5,12808
8110ebac:	01204474 	movhi	r4,33041
8110ebb0:	21321a04 	addi	r4,r4,-14232
8110ebb4:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ebb8:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ebbc:	e0bffe03 	ldbu	r2,-8(fp)
8110ebc0:	10803fcc 	andi	r2,r2,255
8110ebc4:	10000526 	beq	r2,zero,8110ebdc <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110ebc8:	e0bffe03 	ldbu	r2,-8(fp)
8110ebcc:	10803fcc 	andi	r2,r2,255
8110ebd0:	1009883a 	mov	r4,r2
8110ebd4:	1116b980 	call	81116b98 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
8110ebd8:	11180440 	call	81118044 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110ebdc:	01c17704 	movi	r7,1500
8110ebe0:	000d883a 	mov	r6,zero
8110ebe4:	000b883a 	mov	r5,zero
8110ebe8:	0009883a 	mov	r4,zero
8110ebec:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110ebf0:	d8000415 	stw	zero,16(sp)
8110ebf4:	d8000315 	stw	zero,12(sp)
8110ebf8:	00810004 	movi	r2,1024
8110ebfc:	d8800215 	stw	r2,8(sp)
8110ec00:	00a04574 	movhi	r2,33045
8110ec04:	10887004 	addi	r2,r2,8640
8110ec08:	d8800115 	stw	r2,4(sp)
8110ec0c:	00800204 	movi	r2,8
8110ec10:	d8800015 	stw	r2,0(sp)
8110ec14:	01c00204 	movi	r7,8
8110ec18:	01a04574 	movhi	r6,33045
8110ec1c:	318c6f04 	addi	r6,r6,12732
8110ec20:	01604574 	movhi	r5,33045
8110ec24:	294c7a04 	addi	r5,r5,12776
8110ec28:	01204474 	movhi	r4,33041
8110ec2c:	2131f204 	addi	r4,r4,-14392
8110ec30:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ec34:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ec38:	e0bffe03 	ldbu	r2,-8(fp)
8110ec3c:	10803fcc 	andi	r2,r2,255
8110ec40:	10000526 	beq	r2,zero,8110ec58 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110ec44:	e0bffe03 	ldbu	r2,-8(fp)
8110ec48:	10803fcc 	andi	r2,r2,255
8110ec4c:	1009883a 	mov	r4,r2
8110ec50:	1116b980 	call	81116b98 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
8110ec54:	111831c0 	call	8111831c <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110ec58:	01c17704 	movi	r7,1500
8110ec5c:	000d883a 	mov	r6,zero
8110ec60:	000b883a 	mov	r5,zero
8110ec64:	0009883a 	mov	r4,zero
8110ec68:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110ec6c:	d8000415 	stw	zero,16(sp)
8110ec70:	d8000315 	stw	zero,12(sp)
8110ec74:	00810004 	movi	r2,1024
8110ec78:	d8800215 	stw	r2,8(sp)
8110ec7c:	00a045b4 	movhi	r2,33046
8110ec80:	10a49504 	addi	r2,r2,-28076
8110ec84:	d8800115 	stw	r2,4(sp)
8110ec88:	008001c4 	movi	r2,7
8110ec8c:	d8800015 	stw	r2,0(sp)
8110ec90:	01c001c4 	movi	r7,7
8110ec94:	01a045b4 	movhi	r6,33046
8110ec98:	31a89404 	addi	r6,r6,-23984
8110ec9c:	01604574 	movhi	r5,33045
8110eca0:	294c8204 	addi	r5,r5,12808
8110eca4:	01204474 	movhi	r4,33041
8110eca8:	213c3604 	addi	r4,r4,-3880
8110ecac:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ecb0:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ecb4:	e0bffe03 	ldbu	r2,-8(fp)
8110ecb8:	10803fcc 	andi	r2,r2,255
8110ecbc:	10000526 	beq	r2,zero,8110ecd4 <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110ecc0:	e0bffe03 	ldbu	r2,-8(fp)
8110ecc4:	10803fcc 	andi	r2,r2,255
8110ecc8:	1009883a 	mov	r4,r2
8110eccc:	1116b980 	call	81116b98 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110ecd0:	11182b40 	call	811182b4 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110ecd4:	01c17704 	movi	r7,1500
8110ecd8:	000d883a 	mov	r6,zero
8110ecdc:	000b883a 	mov	r5,zero
8110ece0:	0009883a 	mov	r4,zero
8110ece4:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110ece8:	d8000415 	stw	zero,16(sp)
8110ecec:	d8000315 	stw	zero,12(sp)
8110ecf0:	00810004 	movi	r2,1024
8110ecf4:	d8800215 	stw	r2,8(sp)
8110ecf8:	00a045b4 	movhi	r2,33046
8110ecfc:	10b6a704 	addi	r2,r2,-9572
8110ed00:	d8800115 	stw	r2,4(sp)
8110ed04:	00800184 	movi	r2,6
8110ed08:	d8800015 	stw	r2,0(sp)
8110ed0c:	01c00184 	movi	r7,6
8110ed10:	01a045b4 	movhi	r6,33046
8110ed14:	31baa604 	addi	r6,r6,-5480
8110ed18:	01604574 	movhi	r5,33045
8110ed1c:	294c7004 	addi	r5,r5,12736
8110ed20:	01204474 	movhi	r4,33041
8110ed24:	21059a04 	addi	r4,r4,5736
8110ed28:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ed2c:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ed30:	e0bffe03 	ldbu	r2,-8(fp)
8110ed34:	10803fcc 	andi	r2,r2,255
8110ed38:	10000526 	beq	r2,zero,8110ed50 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110ed3c:	e0bffe03 	ldbu	r2,-8(fp)
8110ed40:	10803fcc 	andi	r2,r2,255
8110ed44:	1009883a 	mov	r4,r2
8110ed48:	1116b980 	call	81116b98 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8110ed4c:	11183840 	call	81118384 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110ed50:	01c17704 	movi	r7,1500
8110ed54:	000d883a 	mov	r6,zero
8110ed58:	000b883a 	mov	r5,zero
8110ed5c:	0009883a 	mov	r4,zero
8110ed60:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110ed64:	d8000415 	stw	zero,16(sp)
8110ed68:	d8000315 	stw	zero,12(sp)
8110ed6c:	00810004 	movi	r2,1024
8110ed70:	d8800215 	stw	r2,8(sp)
8110ed74:	00a04574 	movhi	r2,33045
8110ed78:	10847004 	addi	r2,r2,4544
8110ed7c:	d8800115 	stw	r2,4(sp)
8110ed80:	00800784 	movi	r2,30
8110ed84:	d8800015 	stw	r2,0(sp)
8110ed88:	01c00784 	movi	r7,30
8110ed8c:	01a04574 	movhi	r6,33045
8110ed90:	31886f04 	addi	r6,r6,8636
8110ed94:	000b883a 	mov	r5,zero
8110ed98:	01204474 	movhi	r4,33041
8110ed9c:	210c2504 	addi	r4,r4,12436
8110eda0:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110eda4:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110eda8:	e0bffe03 	ldbu	r2,-8(fp)
8110edac:	10803fcc 	andi	r2,r2,255
8110edb0:	10000526 	beq	r2,zero,8110edc8 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110edb4:	e0bffe03 	ldbu	r2,-8(fp)
8110edb8:	10803fcc 	andi	r2,r2,255
8110edbc:	1009883a 	mov	r4,r2
8110edc0:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8110edc4:	11179b00 	call	811179b0 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110edc8:	01c03204 	movi	r7,200
8110edcc:	000d883a 	mov	r6,zero
8110edd0:	000b883a 	mov	r5,zero
8110edd4:	0009883a 	mov	r4,zero
8110edd8:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110eddc:	d8000415 	stw	zero,16(sp)
8110ede0:	d8000315 	stw	zero,12(sp)
8110ede4:	00810004 	movi	r2,1024
8110ede8:	d8800215 	stw	r2,8(sp)
8110edec:	00a04574 	movhi	r2,33045
8110edf0:	10978504 	addi	r2,r2,24084
8110edf4:	d8800115 	stw	r2,4(sp)
8110edf8:	008006c4 	movi	r2,27
8110edfc:	d8800015 	stw	r2,0(sp)
8110ee00:	01c006c4 	movi	r7,27
8110ee04:	01a04574 	movhi	r6,33045
8110ee08:	319b8404 	addi	r6,r6,28176
8110ee0c:	000b883a 	mov	r5,zero
8110ee10:	01204474 	movhi	r4,33041
8110ee14:	213de004 	addi	r4,r4,-2176
8110ee18:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ee1c:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ee20:	e0bffe03 	ldbu	r2,-8(fp)
8110ee24:	10803fcc 	andi	r2,r2,255
8110ee28:	10000526 	beq	r2,zero,8110ee40 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110ee2c:	e0bffe03 	ldbu	r2,-8(fp)
8110ee30:	10803fcc 	andi	r2,r2,255
8110ee34:	1009883a 	mov	r4,r2
8110ee38:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
8110ee3c:	11178cc0 	call	811178cc <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110ee40:	01c03204 	movi	r7,200
8110ee44:	000d883a 	mov	r6,zero
8110ee48:	000b883a 	mov	r5,zero
8110ee4c:	0009883a 	mov	r4,zero
8110ee50:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110ee54:	d8000415 	stw	zero,16(sp)
8110ee58:	d8000315 	stw	zero,12(sp)
8110ee5c:	00810004 	movi	r2,1024
8110ee60:	d8800215 	stw	r2,8(sp)
8110ee64:	00a04574 	movhi	r2,33045
8110ee68:	10bb7004 	addi	r2,r2,-4672
8110ee6c:	d8800115 	stw	r2,4(sp)
8110ee70:	00800644 	movi	r2,25
8110ee74:	d8800015 	stw	r2,0(sp)
8110ee78:	01c00644 	movi	r7,25
8110ee7c:	01a04574 	movhi	r6,33045
8110ee80:	31bf6f04 	addi	r6,r6,-580
8110ee84:	000b883a 	mov	r5,zero
8110ee88:	01204474 	movhi	r4,33041
8110ee8c:	21390904 	addi	r4,r4,-7132
8110ee90:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ee94:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ee98:	e0bffe03 	ldbu	r2,-8(fp)
8110ee9c:	10803fcc 	andi	r2,r2,255
8110eea0:	10000526 	beq	r2,zero,8110eeb8 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110eea4:	e0bffe03 	ldbu	r2,-8(fp)
8110eea8:	10803fcc 	andi	r2,r2,255
8110eeac:	1009883a 	mov	r4,r2
8110eeb0:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8110eeb4:	11178800 	call	81117880 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110eeb8:	01c03204 	movi	r7,200
8110eebc:	000d883a 	mov	r6,zero
8110eec0:	000b883a 	mov	r5,zero
8110eec4:	0009883a 	mov	r4,zero
8110eec8:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110eecc:	d8000415 	stw	zero,16(sp)
8110eed0:	d8000315 	stw	zero,12(sp)
8110eed4:	00818004 	movi	r2,1536
8110eed8:	d8800215 	stw	r2,8(sp)
8110eedc:	00a045b4 	movhi	r2,33046
8110eee0:	10b0a304 	addi	r2,r2,-15732
8110eee4:	d8800115 	stw	r2,4(sp)
8110eee8:	00800704 	movi	r2,28
8110eeec:	d8800015 	stw	r2,0(sp)
8110eef0:	01c00704 	movi	r7,28
8110eef4:	01a045b4 	movhi	r6,33046
8110eef8:	31b6a204 	addi	r6,r6,-9592
8110eefc:	000b883a 	mov	r5,zero
8110ef00:	01204474 	movhi	r4,33041
8110ef04:	213e9e04 	addi	r4,r4,-1416
8110ef08:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ef0c:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ef10:	e0bffe03 	ldbu	r2,-8(fp)
8110ef14:	10803fcc 	andi	r2,r2,255
8110ef18:	10000526 	beq	r2,zero,8110ef30 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110ef1c:	e0bffe03 	ldbu	r2,-8(fp)
8110ef20:	10803fcc 	andi	r2,r2,255
8110ef24:	1009883a 	mov	r4,r2
8110ef28:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
8110ef2c:	11178340 	call	81117834 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110ef30:	01c03204 	movi	r7,200
8110ef34:	000d883a 	mov	r6,zero
8110ef38:	000b883a 	mov	r5,zero
8110ef3c:	0009883a 	mov	r4,zero
8110ef40:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110ef44:	d8000415 	stw	zero,16(sp)
8110ef48:	d8000315 	stw	zero,12(sp)
8110ef4c:	00818004 	movi	r2,1536
8110ef50:	d8800215 	stw	r2,8(sp)
8110ef54:	00a04574 	movhi	r2,33045
8110ef58:	10917504 	addi	r2,r2,17876
8110ef5c:	d8800115 	stw	r2,4(sp)
8110ef60:	00800804 	movi	r2,32
8110ef64:	d8800015 	stw	r2,0(sp)
8110ef68:	01c00804 	movi	r7,32
8110ef6c:	01a04574 	movhi	r6,33045
8110ef70:	31977404 	addi	r6,r6,24016
8110ef74:	000b883a 	mov	r5,zero
8110ef78:	01204474 	movhi	r4,33041
8110ef7c:	2102ba04 	addi	r4,r4,2792
8110ef80:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110ef84:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110ef88:	e0bffe03 	ldbu	r2,-8(fp)
8110ef8c:	10803fcc 	andi	r2,r2,255
8110ef90:	10000526 	beq	r2,zero,8110efa8 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110ef94:	e0bffe03 	ldbu	r2,-8(fp)
8110ef98:	10803fcc 	andi	r2,r2,255
8110ef9c:	1009883a 	mov	r4,r2
8110efa0:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailReceiverCreate();
8110efa4:	11171380 	call	81117138 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110efa8:	01c03204 	movi	r7,200
8110efac:	000d883a 	mov	r6,zero
8110efb0:	000b883a 	mov	r5,zero
8110efb4:	0009883a 	mov	r4,zero
8110efb8:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110efbc:	d8000415 	stw	zero,16(sp)
8110efc0:	d8000315 	stw	zero,12(sp)
8110efc4:	00810004 	movi	r2,1024
8110efc8:	d8800215 	stw	r2,8(sp)
8110efcc:	00a04574 	movhi	r2,33045
8110efd0:	10806404 	addi	r2,r2,400
8110efd4:	d8800115 	stw	r2,4(sp)
8110efd8:	00800684 	movi	r2,26
8110efdc:	d8800015 	stw	r2,0(sp)
8110efe0:	01c00684 	movi	r7,26
8110efe4:	01a04574 	movhi	r6,33045
8110efe8:	31846304 	addi	r6,r6,4492
8110efec:	000b883a 	mov	r5,zero
8110eff0:	01204474 	movhi	r4,33041
8110eff4:	21053c04 	addi	r4,r4,5360
8110eff8:	113a7300 	call	8113a730 <OSTaskCreateExt>
8110effc:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110f000:	01c03204 	movi	r7,200
8110f004:	000d883a 	mov	r6,zero
8110f008:	000b883a 	mov	r5,zero
8110f00c:	0009883a 	mov	r4,zero
8110f010:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110f014:	e0bffe03 	ldbu	r2,-8(fp)
8110f018:	10803fcc 	andi	r2,r2,255
8110f01c:	10000526 	beq	r2,zero,8110f034 <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110f020:	e0bffe03 	ldbu	r2,-8(fp)
8110f024:	10803fcc 	andi	r2,r2,255
8110f028:	1009883a 	mov	r4,r2
8110f02c:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailSenderCreate();
8110f030:	11171840 	call	81117184 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110f034:	d0a06717 	ldw	r2,-32356(gp)
8110f038:	e17ffe04 	addi	r5,fp,-8
8110f03c:	1009883a 	mov	r4,r2
8110f040:	113c4500 	call	8113c450 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110f044:	e0bffe03 	ldbu	r2,-8(fp)
8110f048:	10803fcc 	andi	r2,r2,255
8110f04c:	10000126 	beq	r2,zero,8110f054 <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110f050:	1117c6c0 	call	81117c6c <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110f054:	01c00084 	movi	r7,2
8110f058:	01800784 	movi	r6,30
8110f05c:	000b883a 	mov	r5,zero
8110f060:	0009883a 	mov	r4,zero
8110f064:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110f068:	01003fc4 	movi	r4,255
8110f06c:	113a91c0 	call	8113a91c <OSTaskDel>
8110f070:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110f074:	e0bffe03 	ldbu	r2,-8(fp)
8110f078:	10803fcc 	andi	r2,r2,255
8110f07c:	10001026 	beq	r2,zero,8110f0c0 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110f080:	e0bffe03 	ldbu	r2,-8(fp)
8110f084:	10803fcc 	andi	r2,r2,255
8110f088:	1009883a 	mov	r4,r2
8110f08c:	1116b980 	call	81116b98 <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110f090:	11171d00 	call	811171d0 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110f094:	014009c4 	movi	r5,39
8110f098:	01000044 	movi	r4,1
8110f09c:	113a2380 	call	8113a238 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110f0a0:	01003fc4 	movi	r4,255
8110f0a4:	113a91c0 	call	8113a91c <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110f0a8:	000f883a 	mov	r7,zero
8110f0ac:	01800284 	movi	r6,10
8110f0b0:	000b883a 	mov	r5,zero
8110f0b4:	0009883a 	mov	r4,zero
8110f0b8:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
		}
8110f0bc:	003ff806 	br	8110f0a0 <__reset+0xfb0ef0a0>
	}

}
8110f0c0:	0001883a 	nop
8110f0c4:	e037883a 	mov	sp,fp
8110f0c8:	dfc00117 	ldw	ra,4(sp)
8110f0cc:	df000017 	ldw	fp,0(sp)
8110f0d0:	dec00204 	addi	sp,sp,8
8110f0d4:	f800283a 	ret

8110f0d8 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110f0d8:	defff704 	addi	sp,sp,-36
8110f0dc:	de00012e 	bgeu	sp,et,8110f0e4 <vNFeeControlTask+0xc>
8110f0e0:	003b68fa 	trap	3
8110f0e4:	dfc00815 	stw	ra,32(sp)
8110f0e8:	df000715 	stw	fp,28(sp)
8110f0ec:	df000704 	addi	fp,sp,28
8110f0f0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8110f0f4:	e0bfff17 	ldw	r2,-4(fp)
8110f0f8:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110f0fc:	d0a05c17 	ldw	r2,-32400(gp)
8110f100:	100f883a 	mov	r7,r2
8110f104:	01800804 	movi	r6,32
8110f108:	01400044 	movi	r5,1
8110f10c:	01204534 	movhi	r4,33044
8110f110:	211ef004 	addi	r4,r4,31680
8110f114:	111c1380 	call	8111c138 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
8110f118:	e0bffa17 	ldw	r2,-24(fp)
8110f11c:	10809917 	ldw	r2,612(r2)
8110f120:	10c00168 	cmpgeui	r3,r2,5
8110f124:	1800da1e 	bne	r3,zero,8110f490 <vNFeeControlTask+0x3b8>
8110f128:	100690ba 	slli	r3,r2,2
8110f12c:	00a04474 	movhi	r2,33041
8110f130:	10bc5004 	addi	r2,r2,-3776
8110f134:	1885883a 	add	r2,r3,r2
8110f138:	10800017 	ldw	r2,0(r2)
8110f13c:	1000683a 	jmp	r2
8110f140:	8110f154 	ori	r4,r16,17349
8110f144:	8110f190 	cmplti	r4,r16,17350
8110f148:	8110f1e4 	muli	r4,r16,17351
8110f14c:	8110f298 	cmpnei	r4,r16,17354
8110f150:	8110f314 	ori	r4,r16,17356
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
8110f154:	d0a06a17 	ldw	r2,-32344(gp)
8110f158:	1009883a 	mov	r4,r2
8110f15c:	1138bc00 	call	81138bc0 <OSQFlush>
8110f160:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f164:	e0bffe03 	ldbu	r2,-8(fp)
8110f168:	10803fcc 	andi	r2,r2,255
8110f16c:	10000126 	beq	r2,zero,8110f174 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
8110f170:	11189200 	call	81118920 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
8110f174:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110f178:	00800044 	movi	r2,1
8110f17c:	d0a05315 	stw	r2,-32436(gp)
				pxFeeC->sMode = sMebToConfig;
8110f180:	e0bffa17 	ldw	r2,-24(fp)
8110f184:	00c00044 	movi	r3,1
8110f188:	10c09915 	stw	r3,612(r2)
				break;
8110f18c:	0000cc06 	br	8110f4c0 <vNFeeControlTask+0x3e8>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
8110f190:	d0a05c17 	ldw	r2,-32400(gp)
8110f194:	100f883a 	mov	r7,r2
8110f198:	018008c4 	movi	r6,35
8110f19c:	01400044 	movi	r5,1
8110f1a0:	01204534 	movhi	r4,33044
8110f1a4:	211ef904 	addi	r4,r4,31716
8110f1a8:	111c1380 	call	8111c138 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110f1ac:	d0a05717 	ldw	r2,-32420(gp)
8110f1b0:	1009883a 	mov	r4,r2
8110f1b4:	1138bc00 	call	81138bc0 <OSQFlush>
8110f1b8:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f1bc:	e0bffe03 	ldbu	r2,-8(fp)
8110f1c0:	10803fcc 	andi	r2,r2,255
8110f1c4:	10000126 	beq	r2,zero,8110f1cc <vNFeeControlTask+0xf4>
					vFailFlushQueue();
8110f1c8:	11189200 	call	81118920 <vFailFlushQueue>
				}

				pxFeeC->ucTimeCode = 0;
8110f1cc:	e0bffa17 	ldw	r2,-24(fp)
8110f1d0:	10009805 	stb	zero,608(r2)
				pxFeeC->sMode = sMebConfig;
8110f1d4:	e0bffa17 	ldw	r2,-24(fp)
8110f1d8:	00c000c4 	movi	r3,3
8110f1dc:	10c09915 	stw	r3,612(r2)
				break;
8110f1e0:	0000b706 	br	8110f4c0 <vNFeeControlTask+0x3e8>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8110f1e4:	1118a780 	call	81118a78 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
8110f1e8:	d0a05c17 	ldw	r2,-32400(gp)
8110f1ec:	100f883a 	mov	r7,r2
8110f1f0:	01800804 	movi	r6,32
8110f1f4:	01400044 	movi	r5,1
8110f1f8:	01204534 	movhi	r4,33044
8110f1fc:	211f0204 	addi	r4,r4,31752
8110f200:	111c1380 	call	8111c138 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110f204:	d0a05717 	ldw	r2,-32420(gp)
8110f208:	1009883a 	mov	r4,r2
8110f20c:	1138bc00 	call	81138bc0 <OSQFlush>
8110f210:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f214:	e0bffe03 	ldbu	r2,-8(fp)
8110f218:	10803fcc 	andi	r2,r2,255
8110f21c:	10000126 	beq	r2,zero,8110f224 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
8110f220:	11189200 	call	81118920 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110f224:	e03ff905 	stb	zero,-28(fp)
8110f228:	00001006 	br	8110f26c <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
8110f22c:	e0bff903 	ldbu	r2,-28(fp)
8110f230:	1085883a 	add	r2,r2,r2
8110f234:	1087883a 	add	r3,r2,r2
8110f238:	d0a06404 	addi	r2,gp,-32368
8110f23c:	1885883a 	add	r2,r3,r2
8110f240:	10800017 	ldw	r2,0(r2)
8110f244:	1009883a 	mov	r4,r2
8110f248:	1138bc00 	call	81138bc0 <OSQFlush>
8110f24c:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
8110f250:	e0bffe03 	ldbu	r2,-8(fp)
8110f254:	10803fcc 	andi	r2,r2,255
8110f258:	10000126 	beq	r2,zero,8110f260 <vNFeeControlTask+0x188>
						vFailFlushQueue();
8110f25c:	11189200 	call	81118920 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110f260:	e0bff903 	ldbu	r2,-28(fp)
8110f264:	10800044 	addi	r2,r2,1
8110f268:	e0bff905 	stb	r2,-28(fp)
8110f26c:	e0bff903 	ldbu	r2,-28(fp)
8110f270:	103fee26 	beq	r2,zero,8110f22c <__reset+0xfb0ef22c>
						vFailFlushQueue();
					}
				}


				pxFeeC->ucTimeCode = 0;
8110f274:	e0bffa17 	ldw	r2,-24(fp)
8110f278:	10009805 	stb	zero,608(r2)

				bCmdSent = FALSE;
8110f27c:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110f280:	00800044 	movi	r2,1
8110f284:	d0a05315 	stw	r2,-32436(gp)
				pxFeeC->sMode = sMebRun;
8110f288:	e0bffa17 	ldw	r2,-24(fp)
8110f28c:	00c00104 	movi	r3,4
8110f290:	10c09915 	stw	r3,612(r2)
				break;
8110f294:	00008a06 	br	8110f4c0 <vNFeeControlTask+0x3e8>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
8110f298:	d0a06a17 	ldw	r2,-32344(gp)
8110f29c:	e0fffe04 	addi	r3,fp,-8
8110f2a0:	180d883a 	mov	r6,r3
8110f2a4:	000b883a 	mov	r5,zero
8110f2a8:	1009883a 	mov	r4,r2
8110f2ac:	1138c800 	call	81138c80 <OSQPend>
8110f2b0:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
8110f2b4:	e0bffe03 	ldbu	r2,-8(fp)
8110f2b8:	10803fcc 	andi	r2,r2,255
8110f2bc:	1000131e 	bne	r2,zero,8110f30c <vNFeeControlTask+0x234>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110f2c0:	e0bffdc3 	ldbu	r2,-9(fp)
8110f2c4:	10803fcc 	andi	r2,r2,255
8110f2c8:	10800418 	cmpnei	r2,r2,16
8110f2cc:	1000051e 	bne	r2,zero,8110f2e4 <vNFeeControlTask+0x20c>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110f2d0:	e0bffd17 	ldw	r2,-12(fp)
8110f2d4:	e17ffa17 	ldw	r5,-24(fp)
8110f2d8:	1009883a 	mov	r4,r2
8110f2dc:	110f4c40 	call	8110f4c4 <vPerformActionNFCConfig>
8110f2e0:	00000706 	br	8110f300 <vNFeeControlTask+0x228>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
8110f2e4:	d0a05c17 	ldw	r2,-32400(gp)
8110f2e8:	100f883a 	mov	r7,r2
8110f2ec:	01800704 	movi	r6,28
8110f2f0:	01400044 	movi	r5,1
8110f2f4:	01204534 	movhi	r4,33044
8110f2f8:	211f0b04 	addi	r4,r4,31788
8110f2fc:	111c1380 	call	8111c138 <fwrite>
						#endif
					}

					bDmaBack = TRUE;
8110f300:	00800044 	movi	r2,1
8110f304:	d0a05315 	stw	r2,-32436(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110f308:	00006d06 	br	8110f4c0 <vNFeeControlTask+0x3e8>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110f30c:	111861c0 	call	8111861c <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110f310:	00006b06 	br	8110f4c0 <vNFeeControlTask+0x3e8>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110f314:	d0a05317 	ldw	r2,-32436(gp)
8110f318:	10800058 	cmpnei	r2,r2,1
8110f31c:	1000201e 	bne	r2,zero,8110f3a0 <vNFeeControlTask+0x2c8>
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 2, &error_codeCtrl);
8110f320:	d0a05717 	ldw	r2,-32420(gp)
8110f324:	e0fffe04 	addi	r3,fp,-8
8110f328:	180d883a 	mov	r6,r3
8110f32c:	01400084 	movi	r5,2
8110f330:	1009883a 	mov	r4,r2
8110f334:	1138c800 	call	81138c80 <OSQPend>
8110f338:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8110f33c:	e0bffe03 	ldbu	r2,-8(fp)
8110f340:	10803fcc 	andi	r2,r2,255
8110f344:	1000161e 	bne	r2,zero,8110f3a0 <vNFeeControlTask+0x2c8>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110f348:	e0bffd03 	ldbu	r2,-12(fp)
8110f34c:	e0bffc05 	stb	r2,-16(fp)
						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8110f350:	e0bffc03 	ldbu	r2,-16(fp)
8110f354:	e0fffa17 	ldw	r3,-24(fp)
8110f358:	10809524 	muli	r2,r2,596
8110f35c:	1885883a 	add	r2,r3,r2
8110f360:	10802304 	addi	r2,r2,140
8110f364:	10800017 	ldw	r2,0(r2)
8110f368:	10800058 	cmpnei	r2,r2,1
8110f36c:	10000c1e 	bne	r2,zero,8110f3a0 <vNFeeControlTask+0x2c8>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110f370:	e0bffc03 	ldbu	r2,-16(fp)
8110f374:	e0fffc03 	ldbu	r3,-16(fp)
8110f378:	180f883a 	mov	r7,r3
8110f37c:	000d883a 	mov	r6,zero
8110f380:	014023c4 	movi	r5,143
8110f384:	1009883a 	mov	r4,r2
8110f388:	110f6b80 	call	8110f6b8 <bSendCmdQToNFeeInst>
8110f38c:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE )
8110f390:	e0bffb17 	ldw	r2,-20(fp)
8110f394:	10800058 	cmpnei	r2,r2,1
8110f398:	1000011e 	bne	r2,zero,8110f3a0 <vNFeeControlTask+0x2c8>
								bDmaBack = FALSE;
8110f39c:	d0205315 	stw	zero,-32436(gp)
						}
					}
				} 

				if ( bDmaBack == FALSE )
8110f3a0:	d0a05317 	ldw	r2,-32436(gp)
8110f3a4:	1000081e 	bne	r2,zero,8110f3c8 <vNFeeControlTask+0x2f0>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110f3a8:	d0a06a17 	ldw	r2,-32344(gp)
8110f3ac:	e0fffe04 	addi	r3,fp,-8
8110f3b0:	180d883a 	mov	r6,r3
8110f3b4:	000b883a 	mov	r5,zero
8110f3b8:	1009883a 	mov	r4,r2
8110f3bc:	1138c800 	call	81138c80 <OSQPend>
8110f3c0:	e0bffd15 	stw	r2,-12(fp)
8110f3c4:	00000706 	br	8110f3e4 <vNFeeControlTask+0x30c>
				else
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 2, &error_codeCtrl);
8110f3c8:	d0a06a17 	ldw	r2,-32344(gp)
8110f3cc:	e0fffe04 	addi	r3,fp,-8
8110f3d0:	180d883a 	mov	r6,r3
8110f3d4:	01400084 	movi	r5,2
8110f3d8:	1009883a 	mov	r4,r2
8110f3dc:	1138c800 	call	81138c80 <OSQPend>
8110f3e0:	e0bffd15 	stw	r2,-12(fp)

				if ( error_codeCtrl == OS_ERR_NONE ){
8110f3e4:	e0bffe03 	ldbu	r2,-8(fp)
8110f3e8:	10803fcc 	andi	r2,r2,255
8110f3ec:	1000331e 	bne	r2,zero,8110f4bc <vNFeeControlTask+0x3e4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110f3f0:	e0bffd83 	ldbu	r2,-10(fp)
8110f3f4:	10803fcc 	andi	r2,r2,255
8110f3f8:	10802058 	cmpnei	r2,r2,129
8110f3fc:	1000031e 	bne	r2,zero,8110f40c <vNFeeControlTask+0x334>
						bDmaBack = TRUE;
8110f400:	00800044 	movi	r2,1
8110f404:	d0a05315 	stw	r2,-32436(gp)
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110f408:	00002c06 	br	8110f4bc <vNFeeControlTask+0x3e4>
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
						bDmaBack = TRUE;
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110f40c:	e0bffdc3 	ldbu	r2,-9(fp)
8110f410:	10803fcc 	andi	r2,r2,255
8110f414:	10800418 	cmpnei	r2,r2,16
8110f418:	1000051e 	bne	r2,zero,8110f430 <vNFeeControlTask+0x358>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110f41c:	e0bffd17 	ldw	r2,-12(fp)
8110f420:	e17ffa17 	ldw	r5,-24(fp)
8110f424:	1009883a 	mov	r4,r2
8110f428:	110f58c0 	call	8110f58c <vPerformActionNFCRunning>
8110f42c:	00001606 	br	8110f488 <vNFeeControlTask+0x3b0>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8110f430:	e0bffdc3 	ldbu	r2,-9(fp)
8110f434:	10803fcc 	andi	r2,r2,255
8110f438:	10800470 	cmpltui	r2,r2,17
8110f43c:	1000121e 	bne	r2,zero,8110f488 <vNFeeControlTask+0x3b0>
8110f440:	e0bffdc3 	ldbu	r2,-9(fp)
8110f444:	10803fcc 	andi	r2,r2,255
8110f448:	108004e8 	cmpgeui	r2,r2,19
8110f44c:	10000e1e 	bne	r2,zero,8110f488 <vNFeeControlTask+0x3b0>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8110f450:	e0bffdc3 	ldbu	r2,-9(fp)
8110f454:	10bffbc4 	addi	r2,r2,-17
8110f458:	10803fcc 	andi	r2,r2,255
8110f45c:	e0fffd83 	ldbu	r3,-10(fp)
8110f460:	18c03fcc 	andi	r3,r3,255
8110f464:	e13ffd43 	ldbu	r4,-11(fp)
8110f468:	21003fcc 	andi	r4,r4,255
8110f46c:	e17ffd03 	ldbu	r5,-12(fp)
8110f470:	29403fcc 	andi	r5,r5,255
8110f474:	280f883a 	mov	r7,r5
8110f478:	200d883a 	mov	r6,r4
8110f47c:	180b883a 	mov	r5,r3
8110f480:	1009883a 	mov	r4,r2
8110f484:	110f6b80 	call	8110f6b8 <bSendCmdQToNFeeInst>

							}
						}
						bDmaBack = FALSE;
8110f488:	d0205315 	stw	zero,-32436(gp)
					}
				}
				
				break;		
8110f48c:	00000b06 	br	8110f4bc <vNFeeControlTask+0x3e4>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
8110f490:	d0a05c17 	ldw	r2,-32400(gp)
8110f494:	100f883a 	mov	r7,r2
8110f498:	01800f44 	movi	r6,61
8110f49c:	01400044 	movi	r5,1
8110f4a0:	01204534 	movhi	r4,33044
8110f4a4:	211f1304 	addi	r4,r4,31820
8110f4a8:	111c1380 	call	8111c138 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110f4ac:	e0bffa17 	ldw	r2,-24(fp)
8110f4b0:	00c000c4 	movi	r3,3
8110f4b4:	10c09915 	stw	r3,612(r2)
				break;
8110f4b8:	00000106 	br	8110f4c0 <vNFeeControlTask+0x3e8>
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110f4bc:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8110f4c0:	003f1506 	br	8110f118 <__reset+0xfb0ef118>

8110f4c4 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110f4c4:	defffb04 	addi	sp,sp,-20
8110f4c8:	de00012e 	bgeu	sp,et,8110f4d0 <vPerformActionNFCConfig+0xc>
8110f4cc:	003b68fa 	trap	3
8110f4d0:	dfc00415 	stw	ra,16(sp)
8110f4d4:	df000315 	stw	fp,12(sp)
8110f4d8:	df000304 	addi	fp,sp,12
8110f4dc:	e13ffe15 	stw	r4,-8(fp)
8110f4e0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110f4e4:	e0bffe17 	ldw	r2,-8(fp)
8110f4e8:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110f4ec:	e0bffd83 	ldbu	r2,-10(fp)
8110f4f0:	10803fcc 	andi	r2,r2,255
8110f4f4:	10c000a0 	cmpeqi	r3,r2,2
8110f4f8:	1800121e 	bne	r3,zero,8110f544 <vPerformActionNFCConfig+0x80>
8110f4fc:	10c000c8 	cmpgei	r3,r2,3
8110f500:	1800031e 	bne	r3,zero,8110f510 <vPerformActionNFCConfig+0x4c>
8110f504:	10800060 	cmpeqi	r2,r2,1
8110f508:	1000061e 	bne	r2,zero,8110f524 <vPerformActionNFCConfig+0x60>
8110f50c:	00001106 	br	8110f554 <vPerformActionNFCConfig+0x90>
8110f510:	10c02860 	cmpeqi	r3,r2,161
8110f514:	1800031e 	bne	r3,zero,8110f524 <vPerformActionNFCConfig+0x60>
8110f518:	108028a0 	cmpeqi	r2,r2,162
8110f51c:	1000091e 	bne	r2,zero,8110f544 <vPerformActionNFCConfig+0x80>
8110f520:	00000c06 	br	8110f554 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
8110f524:	d0a05c17 	ldw	r2,-32400(gp)
8110f528:	100f883a 	mov	r7,r2
8110f52c:	01800d44 	movi	r6,53
8110f530:	01400044 	movi	r5,1
8110f534:	01204534 	movhi	r4,33044
8110f538:	211f2304 	addi	r4,r4,31884
8110f53c:	111c1380 	call	8111c138 <fwrite>
			#endif
			/* Do nothing for now */
			break;
8110f540:	00000c06 	br	8110f574 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
8110f544:	e0bfff17 	ldw	r2,-4(fp)
8110f548:	00c00084 	movi	r3,2
8110f54c:	10c09915 	stw	r3,612(r2)
			break;
8110f550:	00000806 	br	8110f574 <vPerformActionNFCConfig+0xb0>

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
8110f554:	d0a05c17 	ldw	r2,-32400(gp)
8110f558:	100f883a 	mov	r7,r2
8110f55c:	018009c4 	movi	r6,39
8110f560:	01400044 	movi	r5,1
8110f564:	01204534 	movhi	r4,33044
8110f568:	211f3104 	addi	r4,r4,31940
8110f56c:	111c1380 	call	8111c138 <fwrite>
			#endif	
			break;
8110f570:	0001883a 	nop
	}

}
8110f574:	0001883a 	nop
8110f578:	e037883a 	mov	sp,fp
8110f57c:	dfc00117 	ldw	ra,4(sp)
8110f580:	df000017 	ldw	fp,0(sp)
8110f584:	dec00204 	addi	sp,sp,8
8110f588:	f800283a 	ret

8110f58c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110f58c:	defffa04 	addi	sp,sp,-24
8110f590:	de00012e 	bgeu	sp,et,8110f598 <vPerformActionNFCRunning+0xc>
8110f594:	003b68fa 	trap	3
8110f598:	dfc00515 	stw	ra,20(sp)
8110f59c:	df000415 	stw	fp,16(sp)
8110f5a0:	df000404 	addi	fp,sp,16
8110f5a4:	e13ffe15 	stw	r4,-8(fp)
8110f5a8:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
8110f5ac:	e0bffe17 	ldw	r2,-8(fp)
8110f5b0:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110f5b4:	e0bffd83 	ldbu	r2,-10(fp)
8110f5b8:	10803fcc 	andi	r2,r2,255
8110f5bc:	10c000a0 	cmpeqi	r3,r2,2
8110f5c0:	1800271e 	bne	r3,zero,8110f660 <vPerformActionNFCRunning+0xd4>
8110f5c4:	10c02860 	cmpeqi	r3,r2,161
8110f5c8:	1800021e 	bne	r3,zero,8110f5d4 <vPerformActionNFCRunning+0x48>
8110f5cc:	10800060 	cmpeqi	r2,r2,1
8110f5d0:	10002b26 	beq	r2,zero,8110f680 <vPerformActionNFCRunning+0xf4>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
8110f5d4:	d0a05c17 	ldw	r2,-32400(gp)
8110f5d8:	100f883a 	mov	r7,r2
8110f5dc:	01800b84 	movi	r6,46
8110f5e0:	01400044 	movi	r5,1
8110f5e4:	01204534 	movhi	r4,33044
8110f5e8:	211f3b04 	addi	r4,r4,31980
8110f5ec:	111c1380 	call	8111c138 <fwrite>
			#endif

			pxFeeCP->sMode = sMebToConfig;
8110f5f0:	e0bfff17 	ldw	r2,-4(fp)
8110f5f4:	00c00044 	movi	r3,1
8110f5f8:	10c09915 	stw	r3,612(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110f5fc:	e03ffc05 	stb	zero,-16(fp)
8110f600:	00001406 	br	8110f654 <vPerformActionNFCRunning+0xc8>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110f604:	e0bffc03 	ldbu	r2,-16(fp)
8110f608:	e0ffff17 	ldw	r3,-4(fp)
8110f60c:	10802584 	addi	r2,r2,150
8110f610:	1085883a 	add	r2,r2,r2
8110f614:	1085883a 	add	r2,r2,r2
8110f618:	1885883a 	add	r2,r3,r2
8110f61c:	10800017 	ldw	r2,0(r2)
8110f620:	10800017 	ldw	r2,0(r2)
8110f624:	10800058 	cmpnei	r2,r2,1
8110f628:	1000071e 	bne	r2,zero,8110f648 <vPerformActionNFCRunning+0xbc>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
8110f62c:	e0bffc03 	ldbu	r2,-16(fp)
8110f630:	e0fffc03 	ldbu	r3,-16(fp)
8110f634:	180f883a 	mov	r7,r3
8110f638:	000d883a 	mov	r6,zero
8110f63c:	01402844 	movi	r5,161
8110f640:	1009883a 	mov	r4,r2
8110f644:	110f6b80 	call	8110f6b8 <bSendCmdQToNFeeInst>
			#endif

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110f648:	e0bffc03 	ldbu	r2,-16(fp)
8110f64c:	10800044 	addi	r2,r2,1
8110f650:	e0bffc05 	stb	r2,-16(fp)
8110f654:	e0bffc03 	ldbu	r2,-16(fp)
8110f658:	103fea26 	beq	r2,zero,8110f604 <__reset+0xfb0ef604>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
8110f65c:	00001006 	br	8110f6a0 <vPerformActionNFCRunning+0x114>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8110f660:	d0a05c17 	ldw	r2,-32400(gp)
8110f664:	100f883a 	mov	r7,r2
8110f668:	01800d84 	movi	r6,54
8110f66c:	01400044 	movi	r5,1
8110f670:	01204534 	movhi	r4,33044
8110f674:	211f4704 	addi	r4,r4,32028
8110f678:	111c1380 	call	8111c138 <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
8110f67c:	00000806 	br	8110f6a0 <vPerformActionNFCRunning+0x114>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110f680:	d0a05c17 	ldw	r2,-32400(gp)
8110f684:	100f883a 	mov	r7,r2
8110f688:	01800984 	movi	r6,38
8110f68c:	01400044 	movi	r5,1
8110f690:	01204534 	movhi	r4,33044
8110f694:	211f5504 	addi	r4,r4,32084
8110f698:	111c1380 	call	8111c138 <fwrite>
			#endif	
			break;
8110f69c:	0001883a 	nop
	}
}
8110f6a0:	0001883a 	nop
8110f6a4:	e037883a 	mov	sp,fp
8110f6a8:	dfc00117 	ldw	ra,4(sp)
8110f6ac:	df000017 	ldw	fp,0(sp)
8110f6b0:	dec00204 	addi	sp,sp,8
8110f6b4:	f800283a 	ret

8110f6b8 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110f6b8:	defff704 	addi	sp,sp,-36
8110f6bc:	de00012e 	bgeu	sp,et,8110f6c4 <bSendCmdQToNFeeInst+0xc>
8110f6c0:	003b68fa 	trap	3
8110f6c4:	dfc00815 	stw	ra,32(sp)
8110f6c8:	df000715 	stw	fp,28(sp)
8110f6cc:	df000704 	addi	fp,sp,28
8110f6d0:	2011883a 	mov	r8,r4
8110f6d4:	2809883a 	mov	r4,r5
8110f6d8:	3007883a 	mov	r3,r6
8110f6dc:	3805883a 	mov	r2,r7
8110f6e0:	e23ffc05 	stb	r8,-16(fp)
8110f6e4:	e13ffd05 	stb	r4,-12(fp)
8110f6e8:	e0fffe05 	stb	r3,-8(fp)
8110f6ec:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110f6f0:	e0bffc03 	ldbu	r2,-16(fp)
8110f6f4:	10800444 	addi	r2,r2,17
8110f6f8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110f6fc:	e0bffd03 	ldbu	r2,-12(fp)
8110f700:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110f704:	e0bffe03 	ldbu	r2,-8(fp)
8110f708:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110f70c:	e0bfff03 	ldbu	r2,-4(fp)
8110f710:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110f714:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110f718:	e0bffc03 	ldbu	r2,-16(fp)
8110f71c:	1085883a 	add	r2,r2,r2
8110f720:	1087883a 	add	r3,r2,r2
8110f724:	d0a06404 	addi	r2,gp,-32368
8110f728:	1885883a 	add	r2,r3,r2
8110f72c:	10800017 	ldw	r2,0(r2)
8110f730:	e0fffb17 	ldw	r3,-20(fp)
8110f734:	180b883a 	mov	r5,r3
8110f738:	1009883a 	mov	r4,r2
8110f73c:	11390880 	call	81139088 <OSQPost>
8110f740:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110f744:	e0bffa03 	ldbu	r2,-24(fp)
8110f748:	10000526 	beq	r2,zero,8110f760 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110f74c:	e0bffc03 	ldbu	r2,-16(fp)
8110f750:	1009883a 	mov	r4,r2
8110f754:	11186ec0 	call	811186ec <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110f758:	e03ff915 	stw	zero,-28(fp)
8110f75c:	00000206 	br	8110f768 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
8110f760:	00800044 	movi	r2,1
8110f764:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110f768:	e0bff917 	ldw	r2,-28(fp)
}
8110f76c:	e037883a 	mov	sp,fp
8110f770:	dfc00117 	ldw	ra,4(sp)
8110f774:	df000017 	ldw	fp,0(sp)
8110f778:	dec00204 	addi	sp,sp,8
8110f77c:	f800283a 	ret

8110f780 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110f780:	defff704 	addi	sp,sp,-36
8110f784:	de00012e 	bgeu	sp,et,8110f78c <vOutAckHandlerTask+0xc>
8110f788:	003b68fa 	trap	3
8110f78c:	dfc00815 	stw	ra,32(sp)
8110f790:	df000715 	stw	fp,28(sp)
8110f794:	df000704 	addi	fp,sp,28
8110f798:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110f79c:	e03ffac5 	stb	zero,-21(fp)
8110f7a0:	e03ffb05 	stb	zero,-20(fp)
8110f7a4:	e03ffb45 	stb	zero,-19(fp)
8110f7a8:	e03ffb85 	stb	zero,-18(fp)
8110f7ac:	e03ffbc5 	stb	zero,-17(fp)
8110f7b0:	e03ffc05 	stb	zero,-16(fp)
8110f7b4:	e03ffc45 	stb	zero,-15(fp)
8110f7b8:	e03ffc85 	stb	zero,-14(fp)
8110f7bc:	e03ffcc5 	stb	zero,-13(fp)
8110f7c0:	e03ffd05 	stb	zero,-12(fp)
8110f7c4:	e03ffd45 	stb	zero,-11(fp)
8110f7c8:	e03ffd85 	stb	zero,-10(fp)
8110f7cc:	e03ffdc5 	stb	zero,-9(fp)
8110f7d0:	e03ffe05 	stb	zero,-8(fp)
8110f7d4:	e03ffe45 	stb	zero,-7(fp)
8110f7d8:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110f7dc:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
8110f7e0:	d0a05c17 	ldw	r2,-32400(gp)
8110f7e4:	100f883a 	mov	r7,r2
8110f7e8:	01800804 	movi	r6,32
8110f7ec:	01400044 	movi	r5,1
8110f7f0:	01204534 	movhi	r4,33044
8110f7f4:	211f5f04 	addi	r4,r4,32124
8110f7f8:	111c1380 	call	8111c138 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8110f7fc:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110f800:	e0bff917 	ldw	r2,-28(fp)
8110f804:	10c00060 	cmpeqi	r3,r2,1
8110f808:	1800071e 	bne	r3,zero,8110f828 <vOutAckHandlerTask+0xa8>
8110f80c:	0080032e 	bgeu	zero,r2,8110f81c <vOutAckHandlerTask+0x9c>
8110f810:	108000a0 	cmpeqi	r2,r2,2
8110f814:	1000471e 	bne	r2,zero,8110f934 <vOutAckHandlerTask+0x1b4>
8110f818:	00008c06 	br	8110fa4c <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110f81c:	00800044 	movi	r2,1
8110f820:	e0bff915 	stw	r2,-28(fp)
				break;
8110f824:	00009306 	br	8110fa74 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110f828:	00800044 	movi	r2,1
8110f82c:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110f830:	d0a05b17 	ldw	r2,-32404(gp)
8110f834:	e0fffa84 	addi	r3,fp,-22
8110f838:	180d883a 	mov	r6,r3
8110f83c:	000b883a 	mov	r5,zero
8110f840:	1009883a 	mov	r4,r2
8110f844:	1139b780 	call	81139b78 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110f848:	e0bffa83 	ldbu	r2,-22(fp)
8110f84c:	10803fcc 	andi	r2,r2,255
8110f850:	1000361e 	bne	r2,zero,8110f92c <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110f854:	d0a06c17 	ldw	r2,-32336(gp)
8110f858:	e0fffa84 	addi	r3,fp,-22
8110f85c:	180d883a 	mov	r6,r3
8110f860:	000b883a 	mov	r5,zero
8110f864:	1009883a 	mov	r4,r2
8110f868:	1137b6c0 	call	81137b6c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110f86c:	e0bffa83 	ldbu	r2,-22(fp)
8110f870:	10803fcc 	andi	r2,r2,255
8110f874:	10002b1e 	bne	r2,zero,8110f924 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110f878:	e03ffa05 	stb	zero,-24(fp)
8110f87c:	00002206 	br	8110f908 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110f880:	e0fffa03 	ldbu	r3,-24(fp)
8110f884:	00a045b4 	movhi	r2,33046
8110f888:	1082ab04 	addi	r2,r2,2732
8110f88c:	18c7883a 	add	r3,r3,r3
8110f890:	18c7883a 	add	r3,r3,r3
8110f894:	10c5883a 	add	r2,r2,r3
8110f898:	10800003 	ldbu	r2,0(r2)
8110f89c:	10803fcc 	andi	r2,r2,255
8110f8a0:	1080201c 	xori	r2,r2,128
8110f8a4:	10bfe004 	addi	r2,r2,-128
8110f8a8:	10001426 	beq	r2,zero,8110f8fc <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110f8ac:	e0fffa03 	ldbu	r3,-24(fp)
8110f8b0:	00a045b4 	movhi	r2,33046
8110f8b4:	1082ab04 	addi	r2,r2,2732
8110f8b8:	18c7883a 	add	r3,r3,r3
8110f8bc:	18c7883a 	add	r3,r3,r3
8110f8c0:	10c5883a 	add	r2,r2,r3
8110f8c4:	10c0000b 	ldhu	r3,0(r2)
8110f8c8:	d0e0540d 	sth	r3,-32432(gp)
8110f8cc:	1080008b 	ldhu	r2,2(r2)
8110f8d0:	d0a0548d 	sth	r2,-32430(gp)
                                eSenderAckState = sSASending;
8110f8d4:	00800084 	movi	r2,2
8110f8d8:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110f8dc:	e0fffa03 	ldbu	r3,-24(fp)
8110f8e0:	00a045b4 	movhi	r2,33046
8110f8e4:	1082ab04 	addi	r2,r2,2732
8110f8e8:	18c7883a 	add	r3,r3,r3
8110f8ec:	18c7883a 	add	r3,r3,r3
8110f8f0:	10c5883a 	add	r2,r2,r3
8110f8f4:	10000005 	stb	zero,0(r2)
                                break;
8110f8f8:	00000606 	br	8110f914 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110f8fc:	e0bffa03 	ldbu	r2,-24(fp)
8110f900:	10800044 	addi	r2,r2,1
8110f904:	e0bffa05 	stb	r2,-24(fp)
8110f908:	e0bffa03 	ldbu	r2,-24(fp)
8110f90c:	10800230 	cmpltui	r2,r2,8
8110f910:	103fdb1e 	bne	r2,zero,8110f880 <__reset+0xfb0ef880>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110f914:	d0a06c17 	ldw	r2,-32336(gp)
8110f918:	1009883a 	mov	r4,r2
8110f91c:	11381100 	call	81138110 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110f920:	00005406 	br	8110fa74 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110f924:	1116f000 	call	81116f00 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110f928:	00005206 	br	8110fa74 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110f92c:	1116e980 	call	81116e98 <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110f930:	00005006 	br	8110fa74 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110f934:	d0a05403 	ldbu	r2,-32432(gp)
8110f938:	10803fcc 	andi	r2,r2,255
8110f93c:	1080201c 	xori	r2,r2,128
8110f940:	10bfe004 	addi	r2,r2,-128
8110f944:	108008e0 	cmpeqi	r2,r2,35
8110f948:	1000201e 	bne	r2,zero,8110f9cc <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110f94c:	d0a05443 	ldbu	r2,-32431(gp)
8110f950:	10c03fcc 	andi	r3,r2,255
8110f954:	18c0201c 	xori	r3,r3,128
8110f958:	18ffe004 	addi	r3,r3,-128
8110f95c:	d0a0548b 	ldhu	r2,-32430(gp)
8110f960:	113fffcc 	andi	r4,r2,65535
8110f964:	e0bffac4 	addi	r2,fp,-21
8110f968:	200f883a 	mov	r7,r4
8110f96c:	180d883a 	mov	r6,r3
8110f970:	01604534 	movhi	r5,33044
8110f974:	295f6804 	addi	r5,r5,32160
8110f978:	1009883a 	mov	r4,r2
8110f97c:	111d42c0 	call	8111d42c <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110f980:	e0bffac4 	addi	r2,fp,-21
8110f984:	1009883a 	mov	r4,r2
8110f988:	111d6400 	call	8111d640 <strlen>
8110f98c:	1007883a 	mov	r3,r2
8110f990:	e0bffac4 	addi	r2,fp,-21
8110f994:	180b883a 	mov	r5,r3
8110f998:	1009883a 	mov	r4,r2
8110f99c:	1116a5c0 	call	81116a5c <ucCrc8wInit>
8110f9a0:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110f9a4:	e13ffa43 	ldbu	r4,-23(fp)
8110f9a8:	e0fffac4 	addi	r3,fp,-21
8110f9ac:	e0bffac4 	addi	r2,fp,-21
8110f9b0:	200f883a 	mov	r7,r4
8110f9b4:	180d883a 	mov	r6,r3
8110f9b8:	01604534 	movhi	r5,33044
8110f9bc:	295f6a04 	addi	r5,r5,32168
8110f9c0:	1009883a 	mov	r4,r2
8110f9c4:	111d42c0 	call	8111d42c <sprintf>
8110f9c8:	00000c06 	br	8110f9fc <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110f9cc:	e0bffac4 	addi	r2,fp,-21
8110f9d0:	00c008c4 	movi	r3,35
8110f9d4:	10c00005 	stb	r3,0(r2)
8110f9d8:	00c01f04 	movi	r3,124
8110f9dc:	10c00045 	stb	r3,1(r2)
8110f9e0:	00c00d44 	movi	r3,53
8110f9e4:	10c00085 	stb	r3,2(r2)
8110f9e8:	00c00d04 	movi	r3,52
8110f9ec:	10c000c5 	stb	r3,3(r2)
8110f9f0:	00c00ec4 	movi	r3,59
8110f9f4:	10c00105 	stb	r3,4(r2)
8110f9f8:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110f9fc:	d0a06e17 	ldw	r2,-32328(gp)
8110fa00:	e0fffa84 	addi	r3,fp,-22
8110fa04:	180d883a 	mov	r6,r3
8110fa08:	01401904 	movi	r5,100
8110fa0c:	1009883a 	mov	r4,r2
8110fa10:	1137b6c0 	call	81137b6c <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110fa14:	e0bffa83 	ldbu	r2,-22(fp)
8110fa18:	10803fcc 	andi	r2,r2,255
8110fa1c:	1000071e 	bne	r2,zero,8110fa3c <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
8110fa20:	e0bffac4 	addi	r2,fp,-21
8110fa24:	1009883a 	mov	r4,r2
8110fa28:	111d0e80 	call	8111d0e8 <puts>
                    OSMutexPost(xTxUARTMutex);
8110fa2c:	d0a06e17 	ldw	r2,-32328(gp)
8110fa30:	1009883a 	mov	r4,r2
8110fa34:	11381100 	call	81138110 <OSMutexPost>
8110fa38:	00000106 	br	8110fa40 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8110fa3c:	11170380 	call	81117038 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
8110fa40:	00800044 	movi	r2,1
8110fa44:	e0bff915 	stw	r2,-28(fp)
                
				break;
8110fa48:	00000a06 	br	8110fa74 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8110fa4c:	d0a05c17 	ldw	r2,-32400(gp)
8110fa50:	100f883a 	mov	r7,r2
8110fa54:	01801104 	movi	r6,68
8110fa58:	01400044 	movi	r5,1
8110fa5c:	01204534 	movhi	r4,33044
8110fa60:	211f6d04 	addi	r4,r4,32180
8110fa64:	111c1380 	call	8111c138 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
8110fa68:	00800044 	movi	r2,1
8110fa6c:	e0bff915 	stw	r2,-28(fp)
				break;
8110fa70:	0001883a 	nop
		}
	}
8110fa74:	003f6206 	br	8110f800 <__reset+0xfb0ef800>

8110fa78 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110fa78:	deffd704 	addi	sp,sp,-164
8110fa7c:	de00012e 	bgeu	sp,et,8110fa84 <vParserCommTask+0xc>
8110fa80:	003b68fa 	trap	3
8110fa84:	dfc02815 	stw	ra,160(sp)
8110fa88:	df002715 	stw	fp,156(sp)
8110fa8c:	df002704 	addi	fp,sp,156
8110fa90:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8110fa94:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
8110fa98:	d0a05c17 	ldw	r2,-32400(gp)
8110fa9c:	100f883a 	mov	r7,r2
8110faa0:	01800704 	movi	r6,28
8110faa4:	01400044 	movi	r5,1
8110faa8:	01204534 	movhi	r4,33044
8110faac:	211f7f04 	addi	r4,r4,32252
8110fab0:	111c1380 	call	8111c138 <fwrite>
    #endif

	eParserMode = sConfiguring;
8110fab4:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
8110fab8:	e0bfdc17 	ldw	r2,-144(fp)
8110fabc:	10800168 	cmpgeui	r2,r2,5
8110fac0:	1003651e 	bne	r2,zero,81110858 <vParserCommTask+0xde0>
8110fac4:	e0bfdc17 	ldw	r2,-144(fp)
8110fac8:	100690ba 	slli	r3,r2,2
8110facc:	00a04474 	movhi	r2,33041
8110fad0:	10beb804 	addi	r2,r2,-1312
8110fad4:	1885883a 	add	r2,r3,r2
8110fad8:	10800017 	ldw	r2,0(r2)
8110fadc:	1000683a 	jmp	r2
8110fae0:	8110faf4 	orhi	r4,r16,17387
8110fae4:	8110fb00 	call	88110fb0 <__reset+0x20f0fb0>
8110fae8:	8110fb94 	ori	r4,r16,17390
8110faec:	8110fcf8 	rdprs	r4,r16,17395
8110faf0:	8110fd3c 	xorhi	r4,r16,17396
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8110faf4:	00800044 	movi	r2,1
8110faf8:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110fafc:	00035906 	br	81110864 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
8110fb00:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
8110fb04:	00800044 	movi	r2,1
8110fb08:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8110fb0c:	d0a05e17 	ldw	r2,-32392(gp)
8110fb10:	e0ffde84 	addi	r3,fp,-134
8110fb14:	180d883a 	mov	r6,r3
8110fb18:	000b883a 	mov	r5,zero
8110fb1c:	1009883a 	mov	r4,r2
8110fb20:	1139b780 	call	81139b78 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8110fb24:	e0bfde83 	ldbu	r2,-134(fp)
8110fb28:	10803fcc 	andi	r2,r2,255
8110fb2c:	1000171e 	bne	r2,zero,8110fb8c <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
8110fb30:	01204574 	movhi	r4,33045
8110fb34:	2135d604 	addi	r4,r4,-10408
8110fb38:	11108680 	call	81110868 <getPreParsedPacket>
8110fb3c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
8110fb40:	e0bfdd17 	ldw	r2,-140(fp)
8110fb44:	10800058 	cmpnei	r2,r2,1
8110fb48:	10000e1e 	bne	r2,zero,8110fb84 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8110fb4c:	00a04574 	movhi	r2,33045
8110fb50:	10b5d604 	addi	r2,r2,-10408
8110fb54:	10800103 	ldbu	r2,4(r2)
8110fb58:	10803fcc 	andi	r2,r2,255
8110fb5c:	1080201c 	xori	r2,r2,128
8110fb60:	10bfe004 	addi	r2,r2,-128
8110fb64:	10800858 	cmpnei	r2,r2,33
8110fb68:	1000031e 	bne	r2,zero,8110fb78 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8110fb6c:	008000c4 	movi	r2,3
8110fb70:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110fb74:	00033b06 	br	81110864 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8110fb78:	00800084 	movi	r2,2
8110fb7c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110fb80:	00033806 	br	81110864 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8110fb84:	11175c40 	call	811175c4 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110fb88:	00033606 	br	81110864 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110fb8c:	11174f40 	call	811174f4 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
8110fb90:	00033406 	br	81110864 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8110fb94:	00a04574 	movhi	r2,33045
8110fb98:	10b5d604 	addi	r2,r2,-10408
8110fb9c:	10800143 	ldbu	r2,5(r2)
8110fba0:	10803fcc 	andi	r2,r2,255
8110fba4:	1080201c 	xori	r2,r2,128
8110fba8:	10bfe004 	addi	r2,r2,-128
8110fbac:	10c010e0 	cmpeqi	r3,r2,67
8110fbb0:	1800031e 	bne	r3,zero,8110fbc0 <vParserCommTask+0x148>
8110fbb4:	10801420 	cmpeqi	r2,r2,80
8110fbb8:	1000051e 	bne	r2,zero,8110fbd0 <vParserCommTask+0x158>
8110fbbc:	00004a06 	br	8110fce8 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
8110fbc0:	111522c0 	call	8111522c <vSendEthConf>
						eParserMode = sWaitingMessage;
8110fbc4:	00800044 	movi	r2,1
8110fbc8:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110fbcc:	00004906 	br	8110fcf4 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
8110fbd0:	e0bfdec4 	addi	r2,fp,-133
8110fbd4:	01802004 	movi	r6,128
8110fbd8:	000b883a 	mov	r5,zero
8110fbdc:	1009883a 	mov	r4,r2
8110fbe0:	111cc9c0 	call	8111cc9c <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
8110fbe4:	00a04574 	movhi	r2,33045
8110fbe8:	10b5d604 	addi	r2,r2,-10408
8110fbec:	1080028b 	ldhu	r2,10(r2)
8110fbf0:	117fffcc 	andi	r5,r2,65535
8110fbf4:	00a04574 	movhi	r2,33045
8110fbf8:	10b5d604 	addi	r2,r2,-10408
8110fbfc:	1080030b 	ldhu	r2,12(r2)
8110fc00:	11bfffcc 	andi	r6,r2,65535
8110fc04:	00a04574 	movhi	r2,33045
8110fc08:	10b5d604 	addi	r2,r2,-10408
8110fc0c:	1080038b 	ldhu	r2,14(r2)
8110fc10:	10ffffcc 	andi	r3,r2,65535
8110fc14:	00a04574 	movhi	r2,33045
8110fc18:	10b5d604 	addi	r2,r2,-10408
8110fc1c:	1080040b 	ldhu	r2,16(r2)
8110fc20:	113fffcc 	andi	r4,r2,65535
8110fc24:	00a04574 	movhi	r2,33045
8110fc28:	10b5d604 	addi	r2,r2,-10408
8110fc2c:	1080048b 	ldhu	r2,18(r2)
8110fc30:	10bfffcc 	andi	r2,r2,65535
8110fc34:	e23fdec4 	addi	r8,fp,-133
8110fc38:	d8800215 	stw	r2,8(sp)
8110fc3c:	d9000115 	stw	r4,4(sp)
8110fc40:	d8c00015 	stw	r3,0(sp)
8110fc44:	300f883a 	mov	r7,r6
8110fc48:	280d883a 	mov	r6,r5
8110fc4c:	01604534 	movhi	r5,33044
8110fc50:	295f8704 	addi	r5,r5,32284
8110fc54:	4009883a 	mov	r4,r8
8110fc58:	111d42c0 	call	8111d42c <sprintf>
							debug(fp, cPUSDebug );
8110fc5c:	d0a05c17 	ldw	r2,-32400(gp)
8110fc60:	e0ffdec4 	addi	r3,fp,-133
8110fc64:	180b883a 	mov	r5,r3
8110fc68:	1009883a 	mov	r4,r2
8110fc6c:	111ba9c0 	call	8111ba9c <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
8110fc70:	00a04574 	movhi	r2,33045
8110fc74:	10b5d604 	addi	r2,r2,-10408
8110fc78:	10c0030b 	ldhu	r3,12(r2)
8110fc7c:	00a04574 	movhi	r2,33045
8110fc80:	10b5e904 	addi	r2,r2,-10332
8110fc84:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
8110fc88:	00a04574 	movhi	r2,33045
8110fc8c:	10b5d604 	addi	r2,r2,-10408
8110fc90:	10c0038b 	ldhu	r3,14(r2)
8110fc94:	00a04574 	movhi	r2,33045
8110fc98:	10b5e904 	addi	r2,r2,-10332
8110fc9c:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
8110fca0:	00a04574 	movhi	r2,33045
8110fca4:	10b5d604 	addi	r2,r2,-10408
8110fca8:	10c0040b 	ldhu	r3,16(r2)
8110fcac:	00a04574 	movhi	r2,33045
8110fcb0:	10b5e904 	addi	r2,r2,-10332
8110fcb4:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
8110fcb8:	00a04574 	movhi	r2,33045
8110fcbc:	10b5d604 	addi	r2,r2,-10408
8110fcc0:	10c0048b 	ldhu	r3,18(r2)
8110fcc4:	00a04574 	movhi	r2,33045
8110fcc8:	10b5e904 	addi	r2,r2,-10332
8110fccc:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
8110fcd0:	00a04574 	movhi	r2,33045
8110fcd4:	10b5e904 	addi	r2,r2,-10332
8110fcd8:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8110fcdc:	00800104 	movi	r2,4
8110fce0:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
8110fce4:	00000306 	br	8110fcf4 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
8110fce8:	00800044 	movi	r2,1
8110fcec:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110fcf0:	0001883a 	nop
				}
				break;
8110fcf4:	0002db06 	br	81110864 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
8110fcf8:	00800044 	movi	r2,1
8110fcfc:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
8110fd00:	00a04574 	movhi	r2,33045
8110fd04:	10b5e904 	addi	r2,r2,-10332
8110fd08:	1080030b 	ldhu	r2,12(r2)
8110fd0c:	10bfffcc 	andi	r2,r2,65535
8110fd10:	10c01220 	cmpeqi	r3,r2,72
8110fd14:	1800051e 	bne	r3,zero,8110fd2c <vParserCommTask+0x2b4>
8110fd18:	108014e0 	cmpeqi	r2,r2,83
8110fd1c:	1000051e 	bne	r2,zero,8110fd34 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
8110fd20:	00800044 	movi	r2,1
8110fd24:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110fd28:	00000306 	br	8110fd38 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8110fd2c:	0001883a 	nop
8110fd30:	0002cc06 	br	81110864 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8110fd34:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
8110fd38:	0002ca06 	br	81110864 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8110fd3c:	00800044 	movi	r2,1
8110fd40:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8110fd44:	00a04574 	movhi	r2,33045
8110fd48:	10b5e904 	addi	r2,r2,-10332
8110fd4c:	1080030b 	ldhu	r2,12(r2)
8110fd50:	10bfffcc 	andi	r2,r2,65535
8110fd54:	10c03ea0 	cmpeqi	r3,r2,250
8110fd58:	1800401e 	bne	r3,zero,8110fe5c <vParserCommTask+0x3e4>
8110fd5c:	10c03ec8 	cmpgei	r3,r2,251
8110fd60:	1800031e 	bne	r3,zero,8110fd70 <vParserCommTask+0x2f8>
8110fd64:	10800460 	cmpeqi	r2,r2,17
8110fd68:	1000061e 	bne	r2,zero,8110fd84 <vParserCommTask+0x30c>
8110fd6c:	0002b606 	br	81110848 <vParserCommTask+0xdd0>
8110fd70:	10c03ee0 	cmpeqi	r3,r2,251
8110fd74:	18009d1e 	bne	r3,zero,8110ffec <vParserCommTask+0x574>
8110fd78:	10803f20 	cmpeqi	r2,r2,252
8110fd7c:	1001321e 	bne	r2,zero,81110248 <vParserCommTask+0x7d0>
8110fd80:	0002b106 	br	81110848 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8110fd84:	00a04574 	movhi	r2,33045
8110fd88:	10b5e904 	addi	r2,r2,-10332
8110fd8c:	1080038b 	ldhu	r2,14(r2)
8110fd90:	10bfffcc 	andi	r2,r2,65535
8110fd94:	10800060 	cmpeqi	r2,r2,1
8110fd98:	10000e26 	beq	r2,zero,8110fdd4 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
8110fd9c:	d0a05c17 	ldw	r2,-32400(gp)
8110fda0:	100f883a 	mov	r7,r2
8110fda4:	01800944 	movi	r6,37
8110fda8:	01400044 	movi	r5,1
8110fdac:	01204534 	movhi	r4,33044
8110fdb0:	211f9d04 	addi	r4,r4,32372
8110fdb4:	111c1380 	call	8111c138 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
8110fdb8:	00a04574 	movhi	r2,33045
8110fdbc:	10b5e904 	addi	r2,r2,-10332
8110fdc0:	1080040b 	ldhu	r2,16(r2)
8110fdc4:	10bfffcc 	andi	r2,r2,65535
8110fdc8:	1009883a 	mov	r4,r2
8110fdcc:	1115c2c0 	call	81115c2c <vTMPusTestConnection>

								break;
8110fdd0:	00002106 	br	8110fe58 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110fdd4:	e0bfdec4 	addi	r2,fp,-133
8110fdd8:	01802004 	movi	r6,128
8110fddc:	000b883a 	mov	r5,zero
8110fde0:	1009883a 	mov	r4,r2
8110fde4:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110fde8:	00a04574 	movhi	r2,33045
8110fdec:	10b5e904 	addi	r2,r2,-10332
8110fdf0:	1080030b 	ldhu	r2,12(r2)
8110fdf4:	113fffcc 	andi	r4,r2,65535
8110fdf8:	00a04574 	movhi	r2,33045
8110fdfc:	10b5e904 	addi	r2,r2,-10332
8110fe00:	1080038b 	ldhu	r2,14(r2)
8110fe04:	117fffcc 	andi	r5,r2,65535
8110fe08:	00a04574 	movhi	r2,33045
8110fe0c:	10b5e904 	addi	r2,r2,-10332
8110fe10:	1080040b 	ldhu	r2,16(r2)
8110fe14:	10bfffcc 	andi	r2,r2,65535
8110fe18:	e0ffdec4 	addi	r3,fp,-133
8110fe1c:	d8800015 	stw	r2,0(sp)
8110fe20:	280f883a 	mov	r7,r5
8110fe24:	200d883a 	mov	r6,r4
8110fe28:	01604534 	movhi	r5,33044
8110fe2c:	295fa704 	addi	r5,r5,32412
8110fe30:	1809883a 	mov	r4,r3
8110fe34:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
8110fe38:	d0a05c17 	ldw	r2,-32400(gp)
8110fe3c:	e0ffdec4 	addi	r3,fp,-133
8110fe40:	180b883a 	mov	r5,r3
8110fe44:	1009883a 	mov	r4,r2
8110fe48:	111ba9c0 	call	8111ba9c <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8110fe4c:	00800044 	movi	r2,1
8110fe50:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110fe54:	0001883a 	nop
						}
                        break;
8110fe58:	00027e06 	br	81110854 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8110fe5c:	00a04574 	movhi	r2,33045
8110fe60:	10b5e904 	addi	r2,r2,-10332
8110fe64:	1080038b 	ldhu	r2,14(r2)
8110fe68:	10bfffcc 	andi	r2,r2,65535
8110fe6c:	10c00f20 	cmpeqi	r3,r2,60
8110fe70:	18001a1e 	bne	r3,zero,8110fedc <vParserCommTask+0x464>
8110fe74:	10c00f48 	cmpgei	r3,r2,61
8110fe78:	1800031e 	bne	r3,zero,8110fe88 <vParserCommTask+0x410>
8110fe7c:	10800ee0 	cmpeqi	r2,r2,59
8110fe80:	1000061e 	bne	r2,zero,8110fe9c <vParserCommTask+0x424>
8110fe84:	00003706 	br	8110ff64 <vParserCommTask+0x4ec>
8110fe88:	10c00f60 	cmpeqi	r3,r2,61
8110fe8c:	18001e1e 	bne	r3,zero,8110ff08 <vParserCommTask+0x490>
8110fe90:	10800fa0 	cmpeqi	r2,r2,62
8110fe94:	1000271e 	bne	r2,zero,8110ff34 <vParserCommTask+0x4bc>
8110fe98:	00003206 	br	8110ff64 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
8110fe9c:	d0a05c17 	ldw	r2,-32400(gp)
8110fea0:	100f883a 	mov	r7,r2
8110fea4:	018006c4 	movi	r6,27
8110fea8:	01400044 	movi	r5,1
8110feac:	01204534 	movhi	r4,33044
8110feb0:	211fba04 	addi	r4,r4,32488
8110feb4:	111c1380 	call	8111c138 <fwrite>
								#endif
								vSendReset();
8110feb8:	11155d40 	call	811155d4 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8110febc:	000f883a 	mov	r7,zero
8110fec0:	018000c4 	movi	r6,3
8110fec4:	000b883a 	mov	r5,zero
8110fec8:	0009883a 	mov	r4,zero
8110fecc:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
8110fed0:	0104e204 	movi	r4,5000
8110fed4:	110b0d40 	call	8110b0d4 <vRstcSimucamReset>

								break;
8110fed8:	00004306 	br	8110ffe8 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
8110fedc:	d0a05c17 	ldw	r2,-32400(gp)
8110fee0:	100f883a 	mov	r7,r2
8110fee4:	01800704 	movi	r6,28
8110fee8:	01400044 	movi	r5,1
8110feec:	01204534 	movhi	r4,33044
8110fef0:	211fc104 	addi	r4,r4,32516
8110fef4:	111c1380 	call	8111c138 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110fef8:	01204574 	movhi	r4,33045
8110fefc:	2135e904 	addi	r4,r4,-10332
8110ff00:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

								break;
8110ff04:	00003806 	br	8110ffe8 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
8110ff08:	d0a05c17 	ldw	r2,-32400(gp)
8110ff0c:	100f883a 	mov	r7,r2
8110ff10:	01800644 	movi	r6,25
8110ff14:	01400044 	movi	r5,1
8110ff18:	01204534 	movhi	r4,33044
8110ff1c:	211fc904 	addi	r4,r4,32548
8110ff20:	111c1380 	call	8111c138 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110ff24:	01204574 	movhi	r4,33045
8110ff28:	2135e904 	addi	r4,r4,-10332
8110ff2c:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

								break;
8110ff30:	00002d06 	br	8110ffe8 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
8110ff34:	d0a05c17 	ldw	r2,-32400(gp)
8110ff38:	100f883a 	mov	r7,r2
8110ff3c:	01800744 	movi	r6,29
8110ff40:	01400044 	movi	r5,1
8110ff44:	01204534 	movhi	r4,33044
8110ff48:	211fd004 	addi	r4,r4,32576
8110ff4c:	111c1380 	call	8111c138 <fwrite>
								#endif
								vSendTurnOff();
8110ff50:	11154bc0 	call	811154bc <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
8110ff54:	01204574 	movhi	r4,33045
8110ff58:	2135e904 	addi	r4,r4,-10332
8110ff5c:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

								break;
8110ff60:	00002106 	br	8110ffe8 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110ff64:	e0bfdec4 	addi	r2,fp,-133
8110ff68:	01802004 	movi	r6,128
8110ff6c:	000b883a 	mov	r5,zero
8110ff70:	1009883a 	mov	r4,r2
8110ff74:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110ff78:	00a04574 	movhi	r2,33045
8110ff7c:	10b5e904 	addi	r2,r2,-10332
8110ff80:	1080030b 	ldhu	r2,12(r2)
8110ff84:	113fffcc 	andi	r4,r2,65535
8110ff88:	00a04574 	movhi	r2,33045
8110ff8c:	10b5e904 	addi	r2,r2,-10332
8110ff90:	1080038b 	ldhu	r2,14(r2)
8110ff94:	117fffcc 	andi	r5,r2,65535
8110ff98:	00a04574 	movhi	r2,33045
8110ff9c:	10b5e904 	addi	r2,r2,-10332
8110ffa0:	1080040b 	ldhu	r2,16(r2)
8110ffa4:	10bfffcc 	andi	r2,r2,65535
8110ffa8:	e0ffdec4 	addi	r3,fp,-133
8110ffac:	d8800015 	stw	r2,0(sp)
8110ffb0:	280f883a 	mov	r7,r5
8110ffb4:	200d883a 	mov	r6,r4
8110ffb8:	01604534 	movhi	r5,33044
8110ffbc:	295fa704 	addi	r5,r5,32412
8110ffc0:	1809883a 	mov	r4,r3
8110ffc4:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
8110ffc8:	d0a05c17 	ldw	r2,-32400(gp)
8110ffcc:	e0ffdec4 	addi	r3,fp,-133
8110ffd0:	180b883a 	mov	r5,r3
8110ffd4:	1009883a 	mov	r4,r2
8110ffd8:	111ba9c0 	call	8111ba9c <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110ffdc:	00800044 	movi	r2,1
8110ffe0:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110ffe4:	0001883a 	nop
						}
                        break;
8110ffe8:	00021a06 	br	81110854 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110ffec:	00a04574 	movhi	r2,33045
8110fff0:	10b5d604 	addi	r2,r2,-10408
8110fff4:	1080050b 	ldhu	r2,20(r2)
8110fff8:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8110fffc:	e0bfde0b 	ldhu	r2,-136(fp)
81110000:	108000b0 	cmpltui	r2,r2,2
81110004:	1000121e 	bne	r2,zero,81110050 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
81110008:	e0bfdec4 	addi	r2,fp,-133
8111000c:	01802004 	movi	r6,128
81110010:	000b883a 	mov	r5,zero
81110014:	1009883a 	mov	r4,r2
81110018:	111cc9c0 	call	8111cc9c <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8111001c:	e0ffde0b 	ldhu	r3,-136(fp)
81110020:	e0bfdec4 	addi	r2,fp,-133
81110024:	180d883a 	mov	r6,r3
81110028:	01604534 	movhi	r5,33044
8111002c:	295fd804 	addi	r5,r5,32608
81110030:	1009883a 	mov	r4,r2
81110034:	111d42c0 	call	8111d42c <sprintf>
								debug(fp, cPUSDebug );
81110038:	d0a05c17 	ldw	r2,-32400(gp)
8111003c:	e0ffdec4 	addi	r3,fp,-133
81110040:	180b883a 	mov	r5,r3
81110044:	1009883a 	mov	r4,r2
81110048:	111ba9c0 	call	8111ba9c <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
8111004c:	00020106 	br	81110854 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81110050:	00a04574 	movhi	r2,33045
81110054:	10b5e904 	addi	r2,r2,-10332
81110058:	10800483 	ldbu	r2,18(r2)
8111005c:	10c03fcc 	andi	r3,r2,255
81110060:	00a04574 	movhi	r2,33045
81110064:	10b5e904 	addi	r2,r2,-10332
81110068:	18c00284 	addi	r3,r3,10
8111006c:	18c7883a 	add	r3,r3,r3
81110070:	10c5883a 	add	r2,r2,r3
81110074:	e0ffde0b 	ldhu	r3,-136(fp)
81110078:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8111007c:	00a04574 	movhi	r2,33045
81110080:	10b5e904 	addi	r2,r2,-10332
81110084:	10800483 	ldbu	r2,18(r2)
81110088:	10800044 	addi	r2,r2,1
8111008c:	1007883a 	mov	r3,r2
81110090:	00a04574 	movhi	r2,33045
81110094:	10b5e904 	addi	r2,r2,-10332
81110098:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8111009c:	00a04574 	movhi	r2,33045
811100a0:	10b5e904 	addi	r2,r2,-10332
811100a4:	1080038b 	ldhu	r2,14(r2)
811100a8:	10bfffcc 	andi	r2,r2,65535
811100ac:	10c000a0 	cmpeqi	r3,r2,2
811100b0:	1800191e 	bne	r3,zero,81110118 <vParserCommTask+0x6a0>
811100b4:	10c00160 	cmpeqi	r3,r2,5
811100b8:	18002c1e 	bne	r3,zero,8111016c <vParserCommTask+0x6f4>
811100bc:	10800060 	cmpeqi	r2,r2,1
811100c0:	10003f26 	beq	r2,zero,811101c0 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811100c4:	e0bfdec4 	addi	r2,fp,-133
811100c8:	01802004 	movi	r6,128
811100cc:	000b883a 	mov	r5,zero
811100d0:	1009883a 	mov	r4,r2
811100d4:	111cc9c0 	call	8111cc9c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811100d8:	e0ffde0b 	ldhu	r3,-136(fp)
811100dc:	e0bfdec4 	addi	r2,fp,-133
811100e0:	180d883a 	mov	r6,r3
811100e4:	01604534 	movhi	r5,33044
811100e8:	295fe704 	addi	r5,r5,32668
811100ec:	1009883a 	mov	r4,r2
811100f0:	111d42c0 	call	8111d42c <sprintf>
										debug(fp, cPUSDebug );
811100f4:	d0a05c17 	ldw	r2,-32400(gp)
811100f8:	e0ffdec4 	addi	r3,fp,-133
811100fc:	180b883a 	mov	r5,r3
81110100:	1009883a 	mov	r4,r2
81110104:	111ba9c0 	call	8111ba9c <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81110108:	01204574 	movhi	r4,33045
8111010c:	2135e904 	addi	r4,r4,-10332
81110110:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

									break;
81110114:	00004b06 	br	81110244 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110118:	e0bfdec4 	addi	r2,fp,-133
8111011c:	01802004 	movi	r6,128
81110120:	000b883a 	mov	r5,zero
81110124:	1009883a 	mov	r4,r2
81110128:	111cc9c0 	call	8111cc9c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111012c:	e0ffde0b 	ldhu	r3,-136(fp)
81110130:	e0bfdec4 	addi	r2,fp,-133
81110134:	180d883a 	mov	r6,r3
81110138:	01604534 	movhi	r5,33044
8111013c:	295ff704 	addi	r5,r5,32732
81110140:	1009883a 	mov	r4,r2
81110144:	111d42c0 	call	8111d42c <sprintf>
										debug(fp, cPUSDebug );
81110148:	d0a05c17 	ldw	r2,-32400(gp)
8111014c:	e0ffdec4 	addi	r3,fp,-133
81110150:	180b883a 	mov	r5,r3
81110154:	1009883a 	mov	r4,r2
81110158:	111ba9c0 	call	8111ba9c <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8111015c:	01204574 	movhi	r4,33045
81110160:	2135e904 	addi	r4,r4,-10332
81110164:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

									break;
81110168:	00003606 	br	81110244 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8111016c:	e0bfdec4 	addi	r2,fp,-133
81110170:	01802004 	movi	r6,128
81110174:	000b883a 	mov	r5,zero
81110178:	1009883a 	mov	r4,r2
8111017c:	111cc9c0 	call	8111cc9c <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81110180:	e0ffde0b 	ldhu	r3,-136(fp)
81110184:	e0bfdec4 	addi	r2,fp,-133
81110188:	180d883a 	mov	r6,r3
8111018c:	01604574 	movhi	r5,33045
81110190:	29600704 	addi	r5,r5,-32740
81110194:	1009883a 	mov	r4,r2
81110198:	111d42c0 	call	8111d42c <sprintf>
										debug(fp, cPUSDebug );
8111019c:	d0a05c17 	ldw	r2,-32400(gp)
811101a0:	e0ffdec4 	addi	r3,fp,-133
811101a4:	180b883a 	mov	r5,r3
811101a8:	1009883a 	mov	r4,r2
811101ac:	111ba9c0 	call	8111ba9c <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811101b0:	01204574 	movhi	r4,33045
811101b4:	2135e904 	addi	r4,r4,-10332
811101b8:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

									break;
811101bc:	00002106 	br	81110244 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811101c0:	e0bfdec4 	addi	r2,fp,-133
811101c4:	01802004 	movi	r6,128
811101c8:	000b883a 	mov	r5,zero
811101cc:	1009883a 	mov	r4,r2
811101d0:	111cc9c0 	call	8111cc9c <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811101d4:	00a04574 	movhi	r2,33045
811101d8:	10b5e904 	addi	r2,r2,-10332
811101dc:	1080030b 	ldhu	r2,12(r2)
811101e0:	113fffcc 	andi	r4,r2,65535
811101e4:	00a04574 	movhi	r2,33045
811101e8:	10b5e904 	addi	r2,r2,-10332
811101ec:	1080038b 	ldhu	r2,14(r2)
811101f0:	117fffcc 	andi	r5,r2,65535
811101f4:	00a04574 	movhi	r2,33045
811101f8:	10b5e904 	addi	r2,r2,-10332
811101fc:	1080040b 	ldhu	r2,16(r2)
81110200:	10bfffcc 	andi	r2,r2,65535
81110204:	e0ffdec4 	addi	r3,fp,-133
81110208:	d8800015 	stw	r2,0(sp)
8111020c:	280f883a 	mov	r7,r5
81110210:	200d883a 	mov	r6,r4
81110214:	01604534 	movhi	r5,33044
81110218:	295fa704 	addi	r5,r5,32412
8111021c:	1809883a 	mov	r4,r3
81110220:	111d42c0 	call	8111d42c <sprintf>
										debug(fp, cPUSDebug );
81110224:	d0a05c17 	ldw	r2,-32400(gp)
81110228:	e0ffdec4 	addi	r3,fp,-133
8111022c:	180b883a 	mov	r5,r3
81110230:	1009883a 	mov	r4,r2
81110234:	111ba9c0 	call	8111ba9c <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
81110238:	00800044 	movi	r2,1
8111023c:	e0bfdc15 	stw	r2,-144(fp)
									break;
81110240:	0001883a 	nop
							}
						}
                        break;
81110244:	00018306 	br	81110854 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81110248:	00a04574 	movhi	r2,33045
8111024c:	10b5d604 	addi	r2,r2,-10408
81110250:	1080050b 	ldhu	r2,20(r2)
81110254:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81110258:	00a04574 	movhi	r2,33045
8111025c:	10b5e904 	addi	r2,r2,-10332
81110260:	10800483 	ldbu	r2,18(r2)
81110264:	10c03fcc 	andi	r3,r2,255
81110268:	00a04574 	movhi	r2,33045
8111026c:	10b5e904 	addi	r2,r2,-10332
81110270:	18c00284 	addi	r3,r3,10
81110274:	18c7883a 	add	r3,r3,r3
81110278:	10c5883a 	add	r2,r2,r3
8111027c:	e0ffde0b 	ldhu	r3,-136(fp)
81110280:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81110284:	00a04574 	movhi	r2,33045
81110288:	10b5e904 	addi	r2,r2,-10332
8111028c:	10800483 	ldbu	r2,18(r2)
81110290:	10800044 	addi	r2,r2,1
81110294:	1007883a 	mov	r3,r2
81110298:	00a04574 	movhi	r2,33045
8111029c:	10b5e904 	addi	r2,r2,-10332
811102a0:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811102a4:	00a04574 	movhi	r2,33045
811102a8:	10b5e904 	addi	r2,r2,-10332
811102ac:	1080038b 	ldhu	r2,14(r2)
811102b0:	10bfffcc 	andi	r2,r2,65535
811102b4:	10c000e0 	cmpeqi	r3,r2,3
811102b8:	18000a1e 	bne	r3,zero,811102e4 <vParserCommTask+0x86c>
811102bc:	10c00108 	cmpgei	r3,r2,4
811102c0:	1800031e 	bne	r3,zero,811102d0 <vParserCommTask+0x858>
811102c4:	108000a0 	cmpeqi	r2,r2,2
811102c8:	1000451e 	bne	r2,zero,811103e0 <vParserCommTask+0x968>
811102cc:	00013c06 	br	811107c0 <vParserCommTask+0xd48>
811102d0:	10c00120 	cmpeqi	r3,r2,4
811102d4:	1800181e 	bne	r3,zero,81110338 <vParserCommTask+0x8c0>
811102d8:	10800160 	cmpeqi	r2,r2,5
811102dc:	10002b1e 	bne	r2,zero,8111038c <vParserCommTask+0x914>
811102e0:	00013706 	br	811107c0 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811102e4:	e0bfdec4 	addi	r2,fp,-133
811102e8:	01802004 	movi	r6,128
811102ec:	000b883a 	mov	r5,zero
811102f0:	1009883a 	mov	r4,r2
811102f4:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811102f8:	e0ffde0b 	ldhu	r3,-136(fp)
811102fc:	e0bfdec4 	addi	r2,fp,-133
81110300:	180d883a 	mov	r6,r3
81110304:	01604574 	movhi	r5,33045
81110308:	29601904 	addi	r5,r5,-32668
8111030c:	1009883a 	mov	r4,r2
81110310:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
81110314:	d0a05c17 	ldw	r2,-32400(gp)
81110318:	e0ffdec4 	addi	r3,fp,-133
8111031c:	180b883a 	mov	r5,r3
81110320:	1009883a 	mov	r4,r2
81110324:	111ba9c0 	call	8111ba9c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81110328:	01204574 	movhi	r4,33045
8111032c:	2135e904 	addi	r4,r4,-10332
81110330:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

								break;
81110334:	00014306 	br	81110844 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110338:	e0bfdec4 	addi	r2,fp,-133
8111033c:	01802004 	movi	r6,128
81110340:	000b883a 	mov	r5,zero
81110344:	1009883a 	mov	r4,r2
81110348:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111034c:	e0ffde0b 	ldhu	r3,-136(fp)
81110350:	e0bfdec4 	addi	r2,fp,-133
81110354:	180d883a 	mov	r6,r3
81110358:	01604574 	movhi	r5,33045
8111035c:	29602904 	addi	r5,r5,-32604
81110360:	1009883a 	mov	r4,r2
81110364:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
81110368:	d0a05c17 	ldw	r2,-32400(gp)
8111036c:	e0ffdec4 	addi	r3,fp,-133
81110370:	180b883a 	mov	r5,r3
81110374:	1009883a 	mov	r4,r2
81110378:	111ba9c0 	call	8111ba9c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111037c:	01204574 	movhi	r4,33045
81110380:	2135e904 	addi	r4,r4,-10332
81110384:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

								break;
81110388:	00012e06 	br	81110844 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8111038c:	e0bfdec4 	addi	r2,fp,-133
81110390:	01802004 	movi	r6,128
81110394:	000b883a 	mov	r5,zero
81110398:	1009883a 	mov	r4,r2
8111039c:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811103a0:	e0ffde0b 	ldhu	r3,-136(fp)
811103a4:	e0bfdec4 	addi	r2,fp,-133
811103a8:	180d883a 	mov	r6,r3
811103ac:	01604574 	movhi	r5,33045
811103b0:	29603904 	addi	r5,r5,-32540
811103b4:	1009883a 	mov	r4,r2
811103b8:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
811103bc:	d0a05c17 	ldw	r2,-32400(gp)
811103c0:	e0ffdec4 	addi	r3,fp,-133
811103c4:	180b883a 	mov	r5,r3
811103c8:	1009883a 	mov	r4,r2
811103cc:	111ba9c0 	call	8111ba9c <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811103d0:	01204574 	movhi	r4,33045
811103d4:	2135e904 	addi	r4,r4,-10332
811103d8:	11109800 	call	81110980 <bSendMessagePUStoMebTask>

								break;
811103dc:	00011906 	br	81110844 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
811103e0:	00a04574 	movhi	r2,33045
811103e4:	10b5e904 	addi	r2,r2,-10332
811103e8:	10800483 	ldbu	r2,18(r2)
811103ec:	10c03fcc 	andi	r3,r2,255
811103f0:	00a04574 	movhi	r2,33045
811103f4:	10b5d604 	addi	r2,r2,-10408
811103f8:	1100058b 	ldhu	r4,22(r2)
811103fc:	00a04574 	movhi	r2,33045
81110400:	10b5e904 	addi	r2,r2,-10332
81110404:	18c00284 	addi	r3,r3,10
81110408:	18c7883a 	add	r3,r3,r3
8111040c:	10c5883a 	add	r2,r2,r3
81110410:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110414:	00a04574 	movhi	r2,33045
81110418:	10b5e904 	addi	r2,r2,-10332
8111041c:	10800483 	ldbu	r2,18(r2)
81110420:	10800044 	addi	r2,r2,1
81110424:	1007883a 	mov	r3,r2
81110428:	00a04574 	movhi	r2,33045
8111042c:	10b5e904 	addi	r2,r2,-10332
81110430:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81110434:	00a04574 	movhi	r2,33045
81110438:	10b5e904 	addi	r2,r2,-10332
8111043c:	10800483 	ldbu	r2,18(r2)
81110440:	10c03fcc 	andi	r3,r2,255
81110444:	00a04574 	movhi	r2,33045
81110448:	10b5d604 	addi	r2,r2,-10408
8111044c:	1100060b 	ldhu	r4,24(r2)
81110450:	00a04574 	movhi	r2,33045
81110454:	10b5e904 	addi	r2,r2,-10332
81110458:	18c00284 	addi	r3,r3,10
8111045c:	18c7883a 	add	r3,r3,r3
81110460:	10c5883a 	add	r2,r2,r3
81110464:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110468:	00a04574 	movhi	r2,33045
8111046c:	10b5e904 	addi	r2,r2,-10332
81110470:	10800483 	ldbu	r2,18(r2)
81110474:	10800044 	addi	r2,r2,1
81110478:	1007883a 	mov	r3,r2
8111047c:	00a04574 	movhi	r2,33045
81110480:	10b5e904 	addi	r2,r2,-10332
81110484:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81110488:	00a04574 	movhi	r2,33045
8111048c:	10b5e904 	addi	r2,r2,-10332
81110490:	10800483 	ldbu	r2,18(r2)
81110494:	10c03fcc 	andi	r3,r2,255
81110498:	00a04574 	movhi	r2,33045
8111049c:	10b5d604 	addi	r2,r2,-10408
811104a0:	1100068b 	ldhu	r4,26(r2)
811104a4:	00a04574 	movhi	r2,33045
811104a8:	10b5e904 	addi	r2,r2,-10332
811104ac:	18c00284 	addi	r3,r3,10
811104b0:	18c7883a 	add	r3,r3,r3
811104b4:	10c5883a 	add	r2,r2,r3
811104b8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811104bc:	00a04574 	movhi	r2,33045
811104c0:	10b5e904 	addi	r2,r2,-10332
811104c4:	10800483 	ldbu	r2,18(r2)
811104c8:	10800044 	addi	r2,r2,1
811104cc:	1007883a 	mov	r3,r2
811104d0:	00a04574 	movhi	r2,33045
811104d4:	10b5e904 	addi	r2,r2,-10332
811104d8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
811104dc:	00a04574 	movhi	r2,33045
811104e0:	10b5e904 	addi	r2,r2,-10332
811104e4:	10800483 	ldbu	r2,18(r2)
811104e8:	10c03fcc 	andi	r3,r2,255
811104ec:	00a04574 	movhi	r2,33045
811104f0:	10b5d604 	addi	r2,r2,-10408
811104f4:	1100070b 	ldhu	r4,28(r2)
811104f8:	00a04574 	movhi	r2,33045
811104fc:	10b5e904 	addi	r2,r2,-10332
81110500:	18c00284 	addi	r3,r3,10
81110504:	18c7883a 	add	r3,r3,r3
81110508:	10c5883a 	add	r2,r2,r3
8111050c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110510:	00a04574 	movhi	r2,33045
81110514:	10b5e904 	addi	r2,r2,-10332
81110518:	10800483 	ldbu	r2,18(r2)
8111051c:	10800044 	addi	r2,r2,1
81110520:	1007883a 	mov	r3,r2
81110524:	00a04574 	movhi	r2,33045
81110528:	10b5e904 	addi	r2,r2,-10332
8111052c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81110530:	00a04574 	movhi	r2,33045
81110534:	10b5e904 	addi	r2,r2,-10332
81110538:	10800483 	ldbu	r2,18(r2)
8111053c:	10c03fcc 	andi	r3,r2,255
81110540:	00a04574 	movhi	r2,33045
81110544:	10b5d604 	addi	r2,r2,-10408
81110548:	1100078b 	ldhu	r4,30(r2)
8111054c:	00a04574 	movhi	r2,33045
81110550:	10b5e904 	addi	r2,r2,-10332
81110554:	18c00284 	addi	r3,r3,10
81110558:	18c7883a 	add	r3,r3,r3
8111055c:	10c5883a 	add	r2,r2,r3
81110560:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110564:	00a04574 	movhi	r2,33045
81110568:	10b5e904 	addi	r2,r2,-10332
8111056c:	10800483 	ldbu	r2,18(r2)
81110570:	10800044 	addi	r2,r2,1
81110574:	1007883a 	mov	r3,r2
81110578:	00a04574 	movhi	r2,33045
8111057c:	10b5e904 	addi	r2,r2,-10332
81110580:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81110584:	00a04574 	movhi	r2,33045
81110588:	10b5e904 	addi	r2,r2,-10332
8111058c:	10800483 	ldbu	r2,18(r2)
81110590:	10c03fcc 	andi	r3,r2,255
81110594:	00a04574 	movhi	r2,33045
81110598:	10b5d604 	addi	r2,r2,-10408
8111059c:	1100080b 	ldhu	r4,32(r2)
811105a0:	00a04574 	movhi	r2,33045
811105a4:	10b5e904 	addi	r2,r2,-10332
811105a8:	18c00284 	addi	r3,r3,10
811105ac:	18c7883a 	add	r3,r3,r3
811105b0:	10c5883a 	add	r2,r2,r3
811105b4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811105b8:	00a04574 	movhi	r2,33045
811105bc:	10b5e904 	addi	r2,r2,-10332
811105c0:	10800483 	ldbu	r2,18(r2)
811105c4:	10800044 	addi	r2,r2,1
811105c8:	1007883a 	mov	r3,r2
811105cc:	00a04574 	movhi	r2,33045
811105d0:	10b5e904 	addi	r2,r2,-10332
811105d4:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811105d8:	e0bfdec4 	addi	r2,fp,-133
811105dc:	01802004 	movi	r6,128
811105e0:	000b883a 	mov	r5,zero
811105e4:	1009883a 	mov	r4,r2
811105e8:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
811105ec:	e0ffdec4 	addi	r3,fp,-133
811105f0:	00a04574 	movhi	r2,33045
811105f4:	10a04804 	addi	r2,r2,-32480
811105f8:	1009883a 	mov	r4,r2
811105fc:	00800b84 	movi	r2,46
81110600:	100d883a 	mov	r6,r2
81110604:	200b883a 	mov	r5,r4
81110608:	1809883a 	mov	r4,r3
8111060c:	111cb4c0 	call	8111cb4c <memcpy>
									debug(fp, cPUSDebug );
81110610:	d0a05c17 	ldw	r2,-32400(gp)
81110614:	e0ffdec4 	addi	r3,fp,-133
81110618:	180b883a 	mov	r5,r3
8111061c:	1009883a 	mov	r4,r2
81110620:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81110624:	e0ffde0b 	ldhu	r3,-136(fp)
81110628:	e0bfdec4 	addi	r2,fp,-133
8111062c:	180d883a 	mov	r6,r3
81110630:	01604574 	movhi	r5,33045
81110634:	29605404 	addi	r5,r5,-32432
81110638:	1009883a 	mov	r4,r2
8111063c:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
81110640:	d0a05c17 	ldw	r2,-32400(gp)
81110644:	e0ffdec4 	addi	r3,fp,-133
81110648:	180b883a 	mov	r5,r3
8111064c:	1009883a 	mov	r4,r2
81110650:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81110654:	00a04574 	movhi	r2,33045
81110658:	10b5d604 	addi	r2,r2,-10408
8111065c:	1080058b 	ldhu	r2,22(r2)
81110660:	10ffffcc 	andi	r3,r2,65535
81110664:	e0bfdec4 	addi	r2,fp,-133
81110668:	180d883a 	mov	r6,r3
8111066c:	01604574 	movhi	r5,33045
81110670:	29605b04 	addi	r5,r5,-32404
81110674:	1009883a 	mov	r4,r2
81110678:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
8111067c:	d0a05c17 	ldw	r2,-32400(gp)
81110680:	e0ffdec4 	addi	r3,fp,-133
81110684:	180b883a 	mov	r5,r3
81110688:	1009883a 	mov	r4,r2
8111068c:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81110690:	00a04574 	movhi	r2,33045
81110694:	10b5d604 	addi	r2,r2,-10408
81110698:	1080060b 	ldhu	r2,24(r2)
8111069c:	10ffffcc 	andi	r3,r2,65535
811106a0:	e0bfdec4 	addi	r2,fp,-133
811106a4:	180d883a 	mov	r6,r3
811106a8:	01604574 	movhi	r5,33045
811106ac:	29605f04 	addi	r5,r5,-32388
811106b0:	1009883a 	mov	r4,r2
811106b4:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
811106b8:	d0a05c17 	ldw	r2,-32400(gp)
811106bc:	e0ffdec4 	addi	r3,fp,-133
811106c0:	180b883a 	mov	r5,r3
811106c4:	1009883a 	mov	r4,r2
811106c8:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
811106cc:	00a04574 	movhi	r2,33045
811106d0:	10b5d604 	addi	r2,r2,-10408
811106d4:	1080068b 	ldhu	r2,26(r2)
811106d8:	10ffffcc 	andi	r3,r2,65535
811106dc:	e0bfdec4 	addi	r2,fp,-133
811106e0:	180d883a 	mov	r6,r3
811106e4:	01604574 	movhi	r5,33045
811106e8:	29606404 	addi	r5,r5,-32368
811106ec:	1009883a 	mov	r4,r2
811106f0:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
811106f4:	d0a05c17 	ldw	r2,-32400(gp)
811106f8:	e0ffdec4 	addi	r3,fp,-133
811106fc:	180b883a 	mov	r5,r3
81110700:	1009883a 	mov	r4,r2
81110704:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
81110708:	00a04574 	movhi	r2,33045
8111070c:	10b5d604 	addi	r2,r2,-10408
81110710:	1080070b 	ldhu	r2,28(r2)
81110714:	10ffffcc 	andi	r3,r2,65535
81110718:	e0bfdec4 	addi	r2,fp,-133
8111071c:	180d883a 	mov	r6,r3
81110720:	01604574 	movhi	r5,33045
81110724:	29606b04 	addi	r5,r5,-32340
81110728:	1009883a 	mov	r4,r2
8111072c:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
81110730:	d0a05c17 	ldw	r2,-32400(gp)
81110734:	e0ffdec4 	addi	r3,fp,-133
81110738:	180b883a 	mov	r5,r3
8111073c:	1009883a 	mov	r4,r2
81110740:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81110744:	00a04574 	movhi	r2,33045
81110748:	10b5d604 	addi	r2,r2,-10408
8111074c:	1080078b 	ldhu	r2,30(r2)
81110750:	10ffffcc 	andi	r3,r2,65535
81110754:	e0bfdec4 	addi	r2,fp,-133
81110758:	180d883a 	mov	r6,r3
8111075c:	01604574 	movhi	r5,33045
81110760:	29607204 	addi	r5,r5,-32312
81110764:	1009883a 	mov	r4,r2
81110768:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
8111076c:	d0a05c17 	ldw	r2,-32400(gp)
81110770:	e0ffdec4 	addi	r3,fp,-133
81110774:	180b883a 	mov	r5,r3
81110778:	1009883a 	mov	r4,r2
8111077c:	111ba9c0 	call	8111ba9c <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81110780:	00a04574 	movhi	r2,33045
81110784:	10b5d604 	addi	r2,r2,-10408
81110788:	1080080b 	ldhu	r2,32(r2)
8111078c:	10ffffcc 	andi	r3,r2,65535
81110790:	e0bfdec4 	addi	r2,fp,-133
81110794:	180d883a 	mov	r6,r3
81110798:	01604574 	movhi	r5,33045
8111079c:	29607804 	addi	r5,r5,-32288
811107a0:	1009883a 	mov	r4,r2
811107a4:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
811107a8:	d0a05c17 	ldw	r2,-32400(gp)
811107ac:	e0ffdec4 	addi	r3,fp,-133
811107b0:	180b883a 	mov	r5,r3
811107b4:	1009883a 	mov	r4,r2
811107b8:	111ba9c0 	call	8111ba9c <fprintf>
								#endif

								break;
811107bc:	00002106 	br	81110844 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811107c0:	e0bfdec4 	addi	r2,fp,-133
811107c4:	01802004 	movi	r6,128
811107c8:	000b883a 	mov	r5,zero
811107cc:	1009883a 	mov	r4,r2
811107d0:	111cc9c0 	call	8111cc9c <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811107d4:	00a04574 	movhi	r2,33045
811107d8:	10b5e904 	addi	r2,r2,-10332
811107dc:	1080030b 	ldhu	r2,12(r2)
811107e0:	113fffcc 	andi	r4,r2,65535
811107e4:	00a04574 	movhi	r2,33045
811107e8:	10b5e904 	addi	r2,r2,-10332
811107ec:	1080038b 	ldhu	r2,14(r2)
811107f0:	117fffcc 	andi	r5,r2,65535
811107f4:	00a04574 	movhi	r2,33045
811107f8:	10b5e904 	addi	r2,r2,-10332
811107fc:	1080040b 	ldhu	r2,16(r2)
81110800:	10bfffcc 	andi	r2,r2,65535
81110804:	e0ffdec4 	addi	r3,fp,-133
81110808:	d8800015 	stw	r2,0(sp)
8111080c:	280f883a 	mov	r7,r5
81110810:	200d883a 	mov	r6,r4
81110814:	01604534 	movhi	r5,33044
81110818:	295fa704 	addi	r5,r5,32412
8111081c:	1809883a 	mov	r4,r3
81110820:	111d42c0 	call	8111d42c <sprintf>
									debug(fp, cPUSDebug );
81110824:	d0a05c17 	ldw	r2,-32400(gp)
81110828:	e0ffdec4 	addi	r3,fp,-133
8111082c:	180b883a 	mov	r5,r3
81110830:	1009883a 	mov	r4,r2
81110834:	111ba9c0 	call	8111ba9c <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81110838:	00800044 	movi	r2,1
8111083c:	e0bfdc15 	stw	r2,-144(fp)
								break;
81110840:	0001883a 	nop
						}
                        break;
81110844:	00000306 	br	81110854 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
81110848:	00800044 	movi	r2,1
8111084c:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81110850:	0001883a 	nop
                }
				break;				
81110854:	00000306 	br	81110864 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
81110858:	00800044 	movi	r2,1
8111085c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81110860:	0001883a 	nop
		}
	}
81110864:	003c9406 	br	8110fab8 <__reset+0xfb0efab8>

81110868 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81110868:	defffb04 	addi	sp,sp,-20
8111086c:	de00012e 	bgeu	sp,et,81110874 <getPreParsedPacket+0xc>
81110870:	003b68fa 	trap	3
81110874:	dfc00415 	stw	ra,16(sp)
81110878:	df000315 	stw	fp,12(sp)
8111087c:	df000304 	addi	fp,sp,12
81110880:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110884:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81110888:	d0a06517 	ldw	r2,-32364(gp)
8111088c:	e0fffe44 	addi	r3,fp,-7
81110890:	180d883a 	mov	r6,r3
81110894:	000b883a 	mov	r5,zero
81110898:	1009883a 	mov	r4,r2
8111089c:	1137b6c0 	call	81137b6c <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
811108a0:	e0bffe43 	ldbu	r2,-7(fp)
811108a4:	10803fcc 	andi	r2,r2,255
811108a8:	10002e1e 	bne	r2,zero,81110964 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811108ac:	e03ffe05 	stb	zero,-8(fp)
811108b0:	00002506 	br	81110948 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811108b4:	e0fffe03 	ldbu	r3,-8(fp)
811108b8:	00a045b4 	movhi	r2,33046
811108bc:	1082b304 	addi	r2,r2,2764
811108c0:	18c01324 	muli	r3,r3,76
811108c4:	10c5883a 	add	r2,r2,r3
811108c8:	10800104 	addi	r2,r2,4
811108cc:	10800003 	ldbu	r2,0(r2)
811108d0:	10803fcc 	andi	r2,r2,255
811108d4:	1080201c 	xori	r2,r2,128
811108d8:	10bfe004 	addi	r2,r2,-128
811108dc:	10001726 	beq	r2,zero,8111093c <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
811108e0:	e0fffe03 	ldbu	r3,-8(fp)
811108e4:	e13fff17 	ldw	r4,-4(fp)
811108e8:	00a045b4 	movhi	r2,33046
811108ec:	1082b304 	addi	r2,r2,2764
811108f0:	18c01324 	muli	r3,r3,76
811108f4:	10c5883a 	add	r2,r2,r3
811108f8:	2007883a 	mov	r3,r4
811108fc:	1009883a 	mov	r4,r2
81110900:	00801304 	movi	r2,76
81110904:	100d883a 	mov	r6,r2
81110908:	200b883a 	mov	r5,r4
8111090c:	1809883a 	mov	r4,r3
81110910:	111cb4c0 	call	8111cb4c <memcpy>
                bSuccess = TRUE;
81110914:	00800044 	movi	r2,1
81110918:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8111091c:	e0fffe03 	ldbu	r3,-8(fp)
81110920:	00a045b4 	movhi	r2,33046
81110924:	1082b304 	addi	r2,r2,2764
81110928:	18c01324 	muli	r3,r3,76
8111092c:	10c5883a 	add	r2,r2,r3
81110930:	10800104 	addi	r2,r2,4
81110934:	10000005 	stb	zero,0(r2)
                break;
81110938:	00000606 	br	81110954 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111093c:	e0bffe03 	ldbu	r2,-8(fp)
81110940:	10800044 	addi	r2,r2,1
81110944:	e0bffe05 	stb	r2,-8(fp)
81110948:	e0bffe03 	ldbu	r2,-8(fp)
8111094c:	10800230 	cmpltui	r2,r2,8
81110950:	103fd81e 	bne	r2,zero,811108b4 <__reset+0xfb0f08b4>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81110954:	d0a06517 	ldw	r2,-32364(gp)
81110958:	1009883a 	mov	r4,r2
8111095c:	11381100 	call	81138110 <OSMutexPost>
81110960:	00000106 	br	81110968 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81110964:	111755c0 	call	8111755c <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81110968:	e0bffd17 	ldw	r2,-12(fp)
}
8111096c:	e037883a 	mov	sp,fp
81110970:	dfc00117 	ldw	ra,4(sp)
81110974:	df000017 	ldw	fp,0(sp)
81110978:	dec00204 	addi	sp,sp,8
8111097c:	f800283a 	ret

81110980 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81110980:	defffa04 	addi	sp,sp,-24
81110984:	de00012e 	bgeu	sp,et,8111098c <bSendMessagePUStoMebTask+0xc>
81110988:	003b68fa 	trap	3
8111098c:	dfc00515 	stw	ra,20(sp)
81110990:	df000415 	stw	fp,16(sp)
81110994:	df000404 	addi	fp,sp,16
81110998:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111099c:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
811109a0:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
811109a4:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
811109a8:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
811109ac:	d0a06d17 	ldw	r2,-32332(gp)
811109b0:	e0fffd44 	addi	r3,fp,-11
811109b4:	180d883a 	mov	r6,r3
811109b8:	01400284 	movi	r5,10
811109bc:	1009883a 	mov	r4,r2
811109c0:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811109c4:	e0bffd43 	ldbu	r2,-11(fp)
811109c8:	10803fcc 	andi	r2,r2,255
811109cc:	1000401e 	bne	r2,zero,81110ad0 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
811109d0:	e03ffd05 	stb	zero,-12(fp)
811109d4:	00003806 	br	81110ab8 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811109d8:	e0fffd03 	ldbu	r3,-12(fp)
811109dc:	00a04574 	movhi	r2,33045
811109e0:	10800804 	addi	r2,r2,32
811109e4:	18c01524 	muli	r3,r3,84
811109e8:	10c5883a 	add	r2,r2,r3
811109ec:	10800104 	addi	r2,r2,4
811109f0:	10800017 	ldw	r2,0(r2)
811109f4:	10002d1e 	bne	r2,zero,81110aac <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
811109f8:	e0fffd03 	ldbu	r3,-12(fp)
811109fc:	00a04574 	movhi	r2,33045
81110a00:	10800804 	addi	r2,r2,32
81110a04:	18c01524 	muli	r3,r3,84
81110a08:	10c7883a 	add	r3,r2,r3
81110a0c:	e0bfff17 	ldw	r2,-4(fp)
81110a10:	1009883a 	mov	r4,r2
81110a14:	00801504 	movi	r2,84
81110a18:	100d883a 	mov	r6,r2
81110a1c:	200b883a 	mov	r5,r4
81110a20:	1809883a 	mov	r4,r3
81110a24:	111cb4c0 	call	8111cb4c <memcpy>
            	xPus[i].bInUse = TRUE;
81110a28:	e0fffd03 	ldbu	r3,-12(fp)
81110a2c:	00a04574 	movhi	r2,33045
81110a30:	10800804 	addi	r2,r2,32
81110a34:	18c01524 	muli	r3,r3,84
81110a38:	10c5883a 	add	r2,r2,r3
81110a3c:	10800104 	addi	r2,r2,4
81110a40:	00c00044 	movi	r3,1
81110a44:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81110a48:	00800044 	movi	r2,1
81110a4c:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81110a50:	00800044 	movi	r2,1
81110a54:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81110a58:	d0a06317 	ldw	r2,-32372(gp)
81110a5c:	e0fffe17 	ldw	r3,-8(fp)
81110a60:	180b883a 	mov	r5,r3
81110a64:	1009883a 	mov	r4,r2
81110a68:	11390880 	call	81139088 <OSQPost>
81110a6c:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81110a70:	e0bffd43 	ldbu	r2,-11(fp)
81110a74:	10803fcc 	andi	r2,r2,255
81110a78:	10000926 	beq	r2,zero,81110aa0 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81110a7c:	111844c0 	call	8111844c <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81110a80:	e0fffd03 	ldbu	r3,-12(fp)
81110a84:	00a04574 	movhi	r2,33045
81110a88:	10800804 	addi	r2,r2,32
81110a8c:	18c01524 	muli	r3,r3,84
81110a90:	10c5883a 	add	r2,r2,r3
81110a94:	10800104 	addi	r2,r2,4
81110a98:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81110a9c:	00000906 	br	81110ac4 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81110aa0:	00800044 	movi	r2,1
81110aa4:	e0bffc15 	stw	r2,-16(fp)
                break;
81110aa8:	00000606 	br	81110ac4 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81110aac:	e0bffd03 	ldbu	r2,-12(fp)
81110ab0:	10800044 	addi	r2,r2,1
81110ab4:	e0bffd05 	stb	r2,-12(fp)
81110ab8:	e0bffd03 	ldbu	r2,-12(fp)
81110abc:	10800130 	cmpltui	r2,r2,4
81110ac0:	103fc51e 	bne	r2,zero,811109d8 <__reset+0xfb0f09d8>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81110ac4:	d0a06d17 	ldw	r2,-32332(gp)
81110ac8:	1009883a 	mov	r4,r2
81110acc:	11381100 	call	81138110 <OSMutexPost>
    }

    return bSuccess;
81110ad0:	e0bffc17 	ldw	r2,-16(fp)
}
81110ad4:	e037883a 	mov	sp,fp
81110ad8:	dfc00117 	ldw	ra,4(sp)
81110adc:	df000017 	ldw	fp,0(sp)
81110ae0:	dec00204 	addi	sp,sp,8
81110ae4:	f800283a 	ret

81110ae8 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81110ae8:	deffab04 	addi	sp,sp,-340
81110aec:	de00012e 	bgeu	sp,et,81110af4 <vReceiverUartTask+0xc>
81110af0:	003b68fa 	trap	3
81110af4:	dfc05415 	stw	ra,336(sp)
81110af8:	df005315 	stw	fp,332(sp)
81110afc:	df005304 	addi	fp,sp,332
81110b00:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110b04:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
81110b08:	d0a05c17 	ldw	r2,-32400(gp)
81110b0c:	100f883a 	mov	r7,r2
81110b10:	01800784 	movi	r6,30
81110b14:	01400044 	movi	r5,1
81110b18:	01204574 	movhi	r4,33045
81110b1c:	21207e04 	addi	r4,r4,-32264
81110b20:	111c1380 	call	8111c138 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81110b24:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81110b28:	e0bfad17 	ldw	r2,-332(fp)
81110b2c:	10c00060 	cmpeqi	r3,r2,1
81110b30:	1800091e 	bne	r3,zero,81110b58 <vReceiverUartTask+0x70>
81110b34:	0080052e 	bgeu	zero,r2,81110b4c <vReceiverUartTask+0x64>
81110b38:	10c000a0 	cmpeqi	r3,r2,2
81110b3c:	18005d1e 	bne	r3,zero,81110cb4 <vReceiverUartTask+0x1cc>
81110b40:	108000e0 	cmpeqi	r2,r2,3
81110b44:	10006e1e 	bne	r2,zero,81110d00 <vReceiverUartTask+0x218>
81110b48:	00007706 	br	81110d28 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81110b4c:	00800044 	movi	r2,1
81110b50:	e0bfad15 	stw	r2,-332(fp)
                break;
81110b54:	00007706 	br	81110d34 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81110b58:	e0bfaf04 	addi	r2,fp,-324
81110b5c:	01802004 	movi	r6,128
81110b60:	000b883a 	mov	r5,zero
81110b64:	1009883a 	mov	r4,r2
81110b68:	111cc9c0 	call	8111cc9c <memset>
                scanf("%s", cReceive);
81110b6c:	e0bfcf04 	addi	r2,fp,-196
81110b70:	100b883a 	mov	r5,r2
81110b74:	01204574 	movhi	r4,33045
81110b78:	21208604 	addi	r4,r4,-32232
81110b7c:	111d3500 	call	8111d350 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81110b80:	e0ffcf04 	addi	r3,fp,-196
81110b84:	e0bfaf04 	addi	r2,fp,-324
81110b88:	01801fc4 	movi	r6,127
81110b8c:	180b883a 	mov	r5,r3
81110b90:	1009883a 	mov	r4,r2
81110b94:	111cb4c0 	call	8111cb4c <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81110b98:	e0bfaf04 	addi	r2,fp,-324
81110b9c:	01604574 	movhi	r5,33045
81110ba0:	2975fe04 	addi	r5,r5,-10248
81110ba4:	1009883a 	mov	r4,r2
81110ba8:	111118c0 	call	8111118c <bPreParserV2>
81110bac:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81110bb0:	e0bfae17 	ldw	r2,-328(fp)
81110bb4:	10800058 	cmpnei	r2,r2,1
81110bb8:	1000281e 	bne	r2,zero,81110c5c <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
81110bbc:	00a04574 	movhi	r2,33045
81110bc0:	10b5fe04 	addi	r2,r2,-10248
81110bc4:	10800103 	ldbu	r2,4(r2)
81110bc8:	10803fcc 	andi	r2,r2,255
81110bcc:	1080201c 	xori	r2,r2,128
81110bd0:	10bfe004 	addi	r2,r2,-128
81110bd4:	10800fe0 	cmpeqi	r2,r2,63
81110bd8:	1000081e 	bne	r2,zero,81110bfc <vReceiverUartTask+0x114>
81110bdc:	00a04574 	movhi	r2,33045
81110be0:	10b5fe04 	addi	r2,r2,-10248
81110be4:	10800103 	ldbu	r2,4(r2)
81110be8:	10803fcc 	andi	r2,r2,255
81110bec:	1080201c 	xori	r2,r2,128
81110bf0:	10bfe004 	addi	r2,r2,-128
81110bf4:	10800858 	cmpnei	r2,r2,33
81110bf8:	1000031e 	bne	r2,zero,81110c08 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81110bfc:	00800084 	movi	r2,2
81110c00:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110c04:	00004b06 	br	81110d34 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81110c08:	00a04574 	movhi	r2,33045
81110c0c:	10b5fe04 	addi	r2,r2,-10248
81110c10:	10800103 	ldbu	r2,4(r2)
81110c14:	10803fcc 	andi	r2,r2,255
81110c18:	1080201c 	xori	r2,r2,128
81110c1c:	10bfe004 	addi	r2,r2,-128
81110c20:	108008d8 	cmpnei	r2,r2,35
81110c24:	10000a1e 	bne	r2,zero,81110c50 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81110c28:	00800044 	movi	r2,1
81110c2c:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81110c30:	d0a05c17 	ldw	r2,-32400(gp)
81110c34:	100f883a 	mov	r7,r2
81110c38:	018006c4 	movi	r6,27
81110c3c:	01400044 	movi	r5,1
81110c40:	01204574 	movhi	r4,33045
81110c44:	21208704 	addi	r4,r4,-32228
81110c48:	111c1380 	call	8111c138 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110c4c:	00003906 	br	81110d34 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81110c50:	008000c4 	movi	r2,3
81110c54:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110c58:	00003606 	br	81110d34 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81110c5c:	00a04574 	movhi	r2,33045
81110c60:	10b5fe04 	addi	r2,r2,-10248
81110c64:	00c008c4 	movi	r3,35
81110c68:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81110c6c:	00a04574 	movhi	r2,33045
81110c70:	10b5fe04 	addi	r2,r2,-10248
81110c74:	00c00b84 	movi	r3,46
81110c78:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81110c7c:	00a04574 	movhi	r2,33045
81110c80:	10b5fe04 	addi	r2,r2,-10248
81110c84:	00c00044 	movi	r3,1
81110c88:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81110c8c:	01204574 	movhi	r4,33045
81110c90:	2135fe04 	addi	r4,r4,-10248
81110c94:	1110e740 	call	81110e74 <setPreAckSenderFreePos>
81110c98:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81110c9c:	e0bfae17 	ldw	r2,-328(fp)
81110ca0:	1000011e 	bne	r2,zero,81110ca8 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81110ca4:	11176940 	call	81117694 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81110ca8:	00800044 	movi	r2,1
81110cac:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81110cb0:	00002006 	br	81110d34 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81110cb4:	01204574 	movhi	r4,33045
81110cb8:	2135fe04 	addi	r4,r4,-10248
81110cbc:	1110e740 	call	81110e74 <setPreAckSenderFreePos>
81110cc0:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81110cc4:	e0bfae17 	ldw	r2,-328(fp)
81110cc8:	10800058 	cmpnei	r2,r2,1
81110ccc:	1000081e 	bne	r2,zero,81110cf0 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81110cd0:	01204574 	movhi	r4,33045
81110cd4:	2135fe04 	addi	r4,r4,-10248
81110cd8:	1110d380 	call	81110d38 <setPreParsedFreePos>
81110cdc:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81110ce0:	e0bfae17 	ldw	r2,-328(fp)
81110ce4:	1000031e 	bne	r2,zero,81110cf4 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81110ce8:	11177640 	call	81117764 <vFailSetPreParsedBuffer>
81110cec:	00000106 	br	81110cf4 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81110cf0:	11176fc0 	call	811176fc <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81110cf4:	00800044 	movi	r2,1
81110cf8:	e0bfad15 	stw	r2,-332(fp)
                break;
81110cfc:	00000d06 	br	81110d34 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81110d00:	01204574 	movhi	r4,33045
81110d04:	2135fe04 	addi	r4,r4,-10248
81110d08:	1110ff00 	call	81110ff0 <setPreAckReceiverFreePos>
81110d0c:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81110d10:	e0bfae17 	ldw	r2,-328(fp)
81110d14:	1000011e 	bne	r2,zero,81110d1c <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81110d18:	11177cc0 	call	811177cc <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81110d1c:	00800044 	movi	r2,1
81110d20:	e0bfad15 	stw	r2,-332(fp)
                break;
81110d24:	00000306 	br	81110d34 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81110d28:	00800044 	movi	r2,1
81110d2c:	e0bfad15 	stw	r2,-332(fp)
                break;
81110d30:	0001883a 	nop
        }

    }
81110d34:	003f7c06 	br	81110b28 <__reset+0xfb0f0b28>

81110d38 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81110d38:	defffb04 	addi	sp,sp,-20
81110d3c:	de00012e 	bgeu	sp,et,81110d44 <setPreParsedFreePos+0xc>
81110d40:	003b68fa 	trap	3
81110d44:	dfc00415 	stw	ra,16(sp)
81110d48:	df000315 	stw	fp,12(sp)
81110d4c:	df000304 	addi	fp,sp,12
81110d50:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110d54:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110d58:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110d5c:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81110d60:	d0a06517 	ldw	r2,-32364(gp)
81110d64:	e0fffe44 	addi	r3,fp,-7
81110d68:	180d883a 	mov	r6,r3
81110d6c:	01400284 	movi	r5,10
81110d70:	1009883a 	mov	r4,r2
81110d74:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110d78:	e0bffe43 	ldbu	r2,-7(fp)
81110d7c:	10803fcc 	andi	r2,r2,255
81110d80:	1000361e 	bne	r2,zero,81110e5c <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81110d84:	e03ffe05 	stb	zero,-8(fp)
81110d88:	00002e06 	br	81110e44 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81110d8c:	e0fffe03 	ldbu	r3,-8(fp)
81110d90:	00a045b4 	movhi	r2,33046
81110d94:	1082b304 	addi	r2,r2,2764
81110d98:	18c01324 	muli	r3,r3,76
81110d9c:	10c5883a 	add	r2,r2,r3
81110da0:	10800104 	addi	r2,r2,4
81110da4:	10800003 	ldbu	r2,0(r2)
81110da8:	10803fcc 	andi	r2,r2,255
81110dac:	1080201c 	xori	r2,r2,128
81110db0:	10bfe004 	addi	r2,r2,-128
81110db4:	1000201e 	bne	r2,zero,81110e38 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81110db8:	e0fffe03 	ldbu	r3,-8(fp)
81110dbc:	00a045b4 	movhi	r2,33046
81110dc0:	1082b304 	addi	r2,r2,2764
81110dc4:	18c01324 	muli	r3,r3,76
81110dc8:	10c7883a 	add	r3,r2,r3
81110dcc:	e0bfff17 	ldw	r2,-4(fp)
81110dd0:	1009883a 	mov	r4,r2
81110dd4:	00801304 	movi	r2,76
81110dd8:	100d883a 	mov	r6,r2
81110ddc:	200b883a 	mov	r5,r4
81110de0:	1809883a 	mov	r4,r3
81110de4:	111cb4c0 	call	8111cb4c <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81110de8:	d0a05e17 	ldw	r2,-32392(gp)
81110dec:	1009883a 	mov	r4,r2
81110df0:	1139f000 	call	81139f00 <OSSemPost>
81110df4:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81110df8:	e0bffe43 	ldbu	r2,-7(fp)
81110dfc:	10803fcc 	andi	r2,r2,255
81110e00:	1000031e 	bne	r2,zero,81110e10 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81110e04:	00800044 	movi	r2,1
81110e08:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81110e0c:	00001006 	br	81110e50 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81110e10:	1116db40 	call	81116db4 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81110e14:	e0fffe03 	ldbu	r3,-8(fp)
81110e18:	00a045b4 	movhi	r2,33046
81110e1c:	1082b304 	addi	r2,r2,2764
81110e20:	18c01324 	muli	r3,r3,76
81110e24:	10c5883a 	add	r2,r2,r3
81110e28:	10800104 	addi	r2,r2,4
81110e2c:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81110e30:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81110e34:	00000606 	br	81110e50 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81110e38:	e0bffe03 	ldbu	r2,-8(fp)
81110e3c:	10800044 	addi	r2,r2,1
81110e40:	e0bffe05 	stb	r2,-8(fp)
81110e44:	e0bffe03 	ldbu	r2,-8(fp)
81110e48:	10800230 	cmpltui	r2,r2,8
81110e4c:	103fcf1e 	bne	r2,zero,81110d8c <__reset+0xfb0f0d8c>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81110e50:	d0a06517 	ldw	r2,-32364(gp)
81110e54:	1009883a 	mov	r4,r2
81110e58:	11381100 	call	81138110 <OSMutexPost>
    }
    return bSuccess;
81110e5c:	e0bffd17 	ldw	r2,-12(fp)
}
81110e60:	e037883a 	mov	sp,fp
81110e64:	dfc00117 	ldw	ra,4(sp)
81110e68:	df000017 	ldw	fp,0(sp)
81110e6c:	dec00204 	addi	sp,sp,8
81110e70:	f800283a 	ret

81110e74 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81110e74:	defffb04 	addi	sp,sp,-20
81110e78:	de00012e 	bgeu	sp,et,81110e80 <setPreAckSenderFreePos+0xc>
81110e7c:	003b68fa 	trap	3
81110e80:	dfc00415 	stw	ra,16(sp)
81110e84:	df000315 	stw	fp,12(sp)
81110e88:	df000304 	addi	fp,sp,12
81110e8c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110e90:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110e94:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110e98:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81110e9c:	d0a06c17 	ldw	r2,-32336(gp)
81110ea0:	e0fffe44 	addi	r3,fp,-7
81110ea4:	180d883a 	mov	r6,r3
81110ea8:	01400284 	movi	r5,10
81110eac:	1009883a 	mov	r4,r2
81110eb0:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110eb4:	e0bffe43 	ldbu	r2,-7(fp)
81110eb8:	10803fcc 	andi	r2,r2,255
81110ebc:	1000461e 	bne	r2,zero,81110fd8 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81110ec0:	e03ffe05 	stb	zero,-8(fp)
81110ec4:	00003e06 	br	81110fc0 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81110ec8:	e0fffe03 	ldbu	r3,-8(fp)
81110ecc:	00a045b4 	movhi	r2,33046
81110ed0:	1082ab04 	addi	r2,r2,2732
81110ed4:	18c7883a 	add	r3,r3,r3
81110ed8:	18c7883a 	add	r3,r3,r3
81110edc:	10c5883a 	add	r2,r2,r3
81110ee0:	10800003 	ldbu	r2,0(r2)
81110ee4:	10803fcc 	andi	r2,r2,255
81110ee8:	1080201c 	xori	r2,r2,128
81110eec:	10bfe004 	addi	r2,r2,-128
81110ef0:	1000301e 	bne	r2,zero,81110fb4 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81110ef4:	e0fffe03 	ldbu	r3,-8(fp)
81110ef8:	e0bfff17 	ldw	r2,-4(fp)
81110efc:	11000103 	ldbu	r4,4(r2)
81110f00:	00a045b4 	movhi	r2,33046
81110f04:	1082ab04 	addi	r2,r2,2732
81110f08:	18c7883a 	add	r3,r3,r3
81110f0c:	18c7883a 	add	r3,r3,r3
81110f10:	10c5883a 	add	r2,r2,r3
81110f14:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81110f18:	e0fffe03 	ldbu	r3,-8(fp)
81110f1c:	e0bfff17 	ldw	r2,-4(fp)
81110f20:	11000143 	ldbu	r4,5(r2)
81110f24:	00a045b4 	movhi	r2,33046
81110f28:	1082ab04 	addi	r2,r2,2732
81110f2c:	18c7883a 	add	r3,r3,r3
81110f30:	18c7883a 	add	r3,r3,r3
81110f34:	10c5883a 	add	r2,r2,r3
81110f38:	10800044 	addi	r2,r2,1
81110f3c:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81110f40:	e0fffe03 	ldbu	r3,-8(fp)
81110f44:	e0bfff17 	ldw	r2,-4(fp)
81110f48:	1100020b 	ldhu	r4,8(r2)
81110f4c:	00a045b4 	movhi	r2,33046
81110f50:	1082ab04 	addi	r2,r2,2732
81110f54:	18c7883a 	add	r3,r3,r3
81110f58:	18c7883a 	add	r3,r3,r3
81110f5c:	10c5883a 	add	r2,r2,r3
81110f60:	10800084 	addi	r2,r2,2
81110f64:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81110f68:	d0a05b17 	ldw	r2,-32404(gp)
81110f6c:	1009883a 	mov	r4,r2
81110f70:	1139f000 	call	81139f00 <OSSemPost>
81110f74:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81110f78:	e0bffe43 	ldbu	r2,-7(fp)
81110f7c:	10803fcc 	andi	r2,r2,255
81110f80:	10000926 	beq	r2,zero,81110fa8 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81110f84:	1116e4c0 	call	81116e4c <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81110f88:	e0fffe03 	ldbu	r3,-8(fp)
81110f8c:	00a045b4 	movhi	r2,33046
81110f90:	1082ab04 	addi	r2,r2,2732
81110f94:	18c7883a 	add	r3,r3,r3
81110f98:	18c7883a 	add	r3,r3,r3
81110f9c:	10c5883a 	add	r2,r2,r3
81110fa0:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81110fa4:	00000906 	br	81110fcc <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81110fa8:	00800044 	movi	r2,1
81110fac:	e0bffd15 	stw	r2,-12(fp)
                break;
81110fb0:	00000606 	br	81110fcc <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81110fb4:	e0bffe03 	ldbu	r2,-8(fp)
81110fb8:	10800044 	addi	r2,r2,1
81110fbc:	e0bffe05 	stb	r2,-8(fp)
81110fc0:	e0bffe03 	ldbu	r2,-8(fp)
81110fc4:	10800230 	cmpltui	r2,r2,8
81110fc8:	103fbf1e 	bne	r2,zero,81110ec8 <__reset+0xfb0f0ec8>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81110fcc:	d0a06c17 	ldw	r2,-32336(gp)
81110fd0:	1009883a 	mov	r4,r2
81110fd4:	11381100 	call	81138110 <OSMutexPost>
    }

    return bSuccess;
81110fd8:	e0bffd17 	ldw	r2,-12(fp)
}
81110fdc:	e037883a 	mov	sp,fp
81110fe0:	dfc00117 	ldw	ra,4(sp)
81110fe4:	df000017 	ldw	fp,0(sp)
81110fe8:	dec00204 	addi	sp,sp,8
81110fec:	f800283a 	ret

81110ff0 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81110ff0:	defffb04 	addi	sp,sp,-20
81110ff4:	de00012e 	bgeu	sp,et,81110ffc <setPreAckReceiverFreePos+0xc>
81110ff8:	003b68fa 	trap	3
81110ffc:	dfc00415 	stw	ra,16(sp)
81111000:	df000315 	stw	fp,12(sp)
81111004:	df000304 	addi	fp,sp,12
81111008:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111100c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81111010:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81111014:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81111018:	d0a05f17 	ldw	r2,-32388(gp)
8111101c:	e0fffe44 	addi	r3,fp,-7
81111020:	180d883a 	mov	r6,r3
81111024:	01400504 	movi	r5,20
81111028:	1009883a 	mov	r4,r2
8111102c:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111030:	e0bffe43 	ldbu	r2,-7(fp)
81111034:	10803fcc 	andi	r2,r2,255
81111038:	1000471e 	bne	r2,zero,81111158 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
8111103c:	e03ffe05 	stb	zero,-8(fp)
81111040:	00003e06 	br	8111113c <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81111044:	e0fffe03 	ldbu	r3,-8(fp)
81111048:	00a045b4 	movhi	r2,33046
8111104c:	10ac9d04 	addi	r2,r2,-19852
81111050:	18c7883a 	add	r3,r3,r3
81111054:	18c7883a 	add	r3,r3,r3
81111058:	10c5883a 	add	r2,r2,r3
8111105c:	10800003 	ldbu	r2,0(r2)
81111060:	10803fcc 	andi	r2,r2,255
81111064:	1080201c 	xori	r2,r2,128
81111068:	10bfe004 	addi	r2,r2,-128
8111106c:	1000301e 	bne	r2,zero,81111130 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81111070:	e0fffe03 	ldbu	r3,-8(fp)
81111074:	e0bfff17 	ldw	r2,-4(fp)
81111078:	11000103 	ldbu	r4,4(r2)
8111107c:	00a045b4 	movhi	r2,33046
81111080:	10ac9d04 	addi	r2,r2,-19852
81111084:	18c7883a 	add	r3,r3,r3
81111088:	18c7883a 	add	r3,r3,r3
8111108c:	10c5883a 	add	r2,r2,r3
81111090:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81111094:	e0fffe03 	ldbu	r3,-8(fp)
81111098:	e0bfff17 	ldw	r2,-4(fp)
8111109c:	11000143 	ldbu	r4,5(r2)
811110a0:	00a045b4 	movhi	r2,33046
811110a4:	10ac9d04 	addi	r2,r2,-19852
811110a8:	18c7883a 	add	r3,r3,r3
811110ac:	18c7883a 	add	r3,r3,r3
811110b0:	10c5883a 	add	r2,r2,r3
811110b4:	10800044 	addi	r2,r2,1
811110b8:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
811110bc:	e0fffe03 	ldbu	r3,-8(fp)
811110c0:	e0bfff17 	ldw	r2,-4(fp)
811110c4:	1100020b 	ldhu	r4,8(r2)
811110c8:	00a045b4 	movhi	r2,33046
811110cc:	10ac9d04 	addi	r2,r2,-19852
811110d0:	18c7883a 	add	r3,r3,r3
811110d4:	18c7883a 	add	r3,r3,r3
811110d8:	10c5883a 	add	r2,r2,r3
811110dc:	10800084 	addi	r2,r2,2
811110e0:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
811110e4:	d0a06017 	ldw	r2,-32384(gp)
811110e8:	1009883a 	mov	r4,r2
811110ec:	1139f000 	call	81139f00 <OSSemPost>
811110f0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
811110f4:	e0bffe43 	ldbu	r2,-7(fp)
811110f8:	10803fcc 	andi	r2,r2,255
811110fc:	1000031e 	bne	r2,zero,8111110c <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81111100:	00800044 	movi	r2,1
81111104:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81111108:	00000f06 	br	81111148 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
8111110c:	1116e000 	call	81116e00 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81111110:	e0fffe03 	ldbu	r3,-8(fp)
81111114:	00a045b4 	movhi	r2,33046
81111118:	10ac9d04 	addi	r2,r2,-19852
8111111c:	18c7883a 	add	r3,r3,r3
81111120:	18c7883a 	add	r3,r3,r3
81111124:	10c5883a 	add	r2,r2,r3
81111128:	10000005 	stb	zero,0(r2)
                }
                break;
8111112c:	00000606 	br	81111148 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81111130:	e0bffe03 	ldbu	r2,-8(fp)
81111134:	10800044 	addi	r2,r2,1
81111138:	e0bffe05 	stb	r2,-8(fp)
8111113c:	e0bffe03 	ldbu	r2,-8(fp)
81111140:	108001b0 	cmpltui	r2,r2,6
81111144:	103fbf1e 	bne	r2,zero,81111044 <__reset+0xfb0f1044>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81111148:	d0a05f17 	ldw	r2,-32388(gp)
8111114c:	1009883a 	mov	r4,r2
81111150:	11381100 	call	81138110 <OSMutexPost>
81111154:	00000706 	br	81111174 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81111158:	d0a05c17 	ldw	r2,-32400(gp)
8111115c:	100f883a 	mov	r7,r2
81111160:	01801404 	movi	r6,80
81111164:	01400044 	movi	r5,1
81111168:	01204574 	movhi	r4,33045
8111116c:	21208e04 	addi	r4,r4,-32200
81111170:	111c1380 	call	8111c138 <fwrite>
        #endif
    }

    return bSuccess;
81111174:	e0bffd17 	ldw	r2,-12(fp)
}
81111178:	e037883a 	mov	sp,fp
8111117c:	dfc00117 	ldw	ra,4(sp)
81111180:	df000017 	ldw	fp,0(sp)
81111184:	dec00204 	addi	sp,sp,8
81111188:	f800283a 	ret

8111118c <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
8111118c:	defff404 	addi	sp,sp,-48
81111190:	de00012e 	bgeu	sp,et,81111198 <bPreParserV2+0xc>
81111194:	003b68fa 	trap	3
81111198:	dfc00b15 	stw	ra,44(sp)
8111119c:	df000a15 	stw	fp,40(sp)
811111a0:	dc000915 	stw	r16,36(sp)
811111a4:	df000a04 	addi	fp,sp,40
811111a8:	e13ffd15 	stw	r4,-12(fp)
811111ac:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
811111b0:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
811111b4:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
811111b8:	01402004 	movi	r5,128
811111bc:	e13ffd17 	ldw	r4,-12(fp)
811111c0:	111d6d80 	call	8111d6d8 <strnlen>
811111c4:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
811111c8:	01400ec4 	movi	r5,59
811111cc:	e13ffd17 	ldw	r4,-12(fp)
811111d0:	111583c0 	call	8111583c <siPosStr>
811111d4:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
811111d8:	e0fff98f 	ldh	r3,-26(fp)
811111dc:	e0bff90f 	ldh	r2,-28(fp)
811111e0:	10bfffc4 	addi	r2,r2,-1
811111e4:	18800226 	beq	r3,r2,811111f0 <bPreParserV2+0x64>
        return bSuccess;
811111e8:	e0bff617 	ldw	r2,-40(fp)
811111ec:	0000ba06 	br	811114d8 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
811111f0:	01401f04 	movi	r5,124
811111f4:	e13ffd17 	ldw	r4,-12(fp)
811111f8:	111583c0 	call	8111583c <siPosStr>
811111fc:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81111200:	e0bffa0f 	ldh	r2,-24(fp)
81111204:	e0fff98f 	ldh	r3,-26(fp)
81111208:	1880020e 	bge	r3,r2,81111214 <bPreParserV2+0x88>
        return bSuccess;
8111120c:	e0bff617 	ldw	r2,-40(fp)
81111210:	0000b106 	br	811114d8 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81111214:	01604574 	movhi	r5,33045
81111218:	2960a304 	addi	r5,r5,-32116
8111121c:	e13ffd17 	ldw	r4,-12(fp)
81111220:	111d5f40 	call	8111d5f4 <strcspn>
81111224:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81111228:	e0bffa8f 	ldh	r2,-22(fp)
8111122c:	e0fffa0f 	ldh	r3,-24(fp)
81111230:	1880020e 	bge	r3,r2,8111123c <bPreParserV2+0xb0>
        return bSuccess;
81111234:	e0bff617 	ldw	r2,-40(fp)
81111238:	0000a706 	br	811114d8 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
8111123c:	e0bffa8f 	ldh	r2,-22(fp)
81111240:	e0fffd17 	ldw	r3,-12(fp)
81111244:	1885883a 	add	r2,r3,r2
81111248:	10c00003 	ldbu	r3,0(r2)
8111124c:	e0bffe17 	ldw	r2,-8(fp)
81111250:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81111254:	e0bffe17 	ldw	r2,-8(fp)
81111258:	10800103 	ldbu	r2,4(r2)
8111125c:	10803fcc 	andi	r2,r2,255
81111260:	1080201c 	xori	r2,r2,128
81111264:	10bfe004 	addi	r2,r2,-128
81111268:	108008d8 	cmpnei	r2,r2,35
8111126c:	1000041e 	bne	r2,zero,81111280 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81111270:	00800044 	movi	r2,1
81111274:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81111278:	e0bff617 	ldw	r2,-40(fp)
8111127c:	00009606 	br	811114d8 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81111280:	e0bffa8f 	ldh	r2,-22(fp)
81111284:	e0fffd17 	ldw	r3,-12(fp)
81111288:	1889883a 	add	r4,r3,r2
8111128c:	e0fffa0f 	ldh	r3,-24(fp)
81111290:	e0bffa8f 	ldh	r2,-22(fp)
81111294:	1885c83a 	sub	r2,r3,r2
81111298:	100b883a 	mov	r5,r2
8111129c:	1116a5c0 	call	81116a5c <ucCrc8wInit>
811112a0:	1007883a 	mov	r3,r2
811112a4:	e0bffe17 	ldw	r2,-8(fp)
811112a8:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
811112ac:	e0bffa8f 	ldh	r2,-22(fp)
811112b0:	10800044 	addi	r2,r2,1
811112b4:	e0fffd17 	ldw	r3,-12(fp)
811112b8:	1885883a 	add	r2,r3,r2
811112bc:	10c00003 	ldbu	r3,0(r2)
811112c0:	e0bffe17 	ldw	r2,-8(fp)
811112c4:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
811112c8:	e0bffe17 	ldw	r2,-8(fp)
811112cc:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
811112d0:	e0bffe17 	ldw	r2,-8(fp)
811112d4:	10800204 	addi	r2,r2,8
811112d8:	01801004 	movi	r6,64
811112dc:	000b883a 	mov	r5,zero
811112e0:	1009883a 	mov	r4,r2
811112e4:	111cc9c0 	call	8111cc9c <memset>

    i = siIni + 3; /* "?C:i..." */
811112e8:	e0bffa8b 	ldhu	r2,-22(fp)
811112ec:	108000c4 	addi	r2,r2,3
811112f0:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
811112f4:	e0bffb44 	addi	r2,fp,-19
811112f8:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
811112fc:	e0bffb44 	addi	r2,fp,-19
81111300:	01800184 	movi	r6,6
81111304:	000b883a 	mov	r5,zero
81111308:	1009883a 	mov	r4,r2
8111130c:	111cc9c0 	call	8111cc9c <memset>
        do {
            c = buffer[i];
81111310:	e0bff703 	ldbu	r2,-36(fp)
81111314:	e0fffd17 	ldw	r3,-12(fp)
81111318:	1885883a 	add	r2,r3,r2
8111131c:	10800003 	ldbu	r2,0(r2)
81111320:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81111324:	d0e00317 	ldw	r3,-32756(gp)
81111328:	e0bffb07 	ldb	r2,-20(fp)
8111132c:	10800044 	addi	r2,r2,1
81111330:	1885883a 	add	r2,r3,r2
81111334:	10800003 	ldbu	r2,0(r2)
81111338:	10803fcc 	andi	r2,r2,255
8111133c:	1080010c 	andi	r2,r2,4
81111340:	10000626 	beq	r2,zero,8111135c <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81111344:	e0bff817 	ldw	r2,-32(fp)
81111348:	e0fffb03 	ldbu	r3,-20(fp)
8111134c:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81111350:	e0bff817 	ldw	r2,-32(fp)
81111354:	10800044 	addi	r2,r2,1
81111358:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
8111135c:	e0bff703 	ldbu	r2,-36(fp)
81111360:	10800044 	addi	r2,r2,1
81111364:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81111368:	e0bff90f 	ldh	r2,-28(fp)
8111136c:	e0fff703 	ldbu	r3,-36(fp)
81111370:	1880090e 	bge	r3,r2,81111398 <bPreParserV2+0x20c>
81111374:	e0bffb07 	ldb	r2,-20(fp)
81111378:	10800ea0 	cmpeqi	r2,r2,58
8111137c:	1000061e 	bne	r2,zero,81111398 <bPreParserV2+0x20c>
81111380:	e0bffb07 	ldb	r2,-20(fp)
81111384:	10800ee0 	cmpeqi	r2,r2,59
81111388:	1000031e 	bne	r2,zero,81111398 <bPreParserV2+0x20c>
8111138c:	e0bffb07 	ldb	r2,-20(fp)
81111390:	10801f18 	cmpnei	r2,r2,124
81111394:	103fde1e 	bne	r2,zero,81111310 <__reset+0xfb0f1310>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111398:	e0bff817 	ldw	r2,-32(fp)
8111139c:	00c00284 	movi	r3,10
811113a0:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
811113a4:	e0bffb07 	ldb	r2,-20(fp)
811113a8:	10800ea0 	cmpeqi	r2,r2,58
811113ac:	1000031e 	bne	r2,zero,811113bc <bPreParserV2+0x230>
811113b0:	e0bffb07 	ldb	r2,-20(fp)
811113b4:	10801f18 	cmpnei	r2,r2,124
811113b8:	10001a1e 	bne	r2,zero,81111424 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
811113bc:	e0bffe17 	ldw	r2,-8(fp)
811113c0:	10800183 	ldbu	r2,6(r2)
811113c4:	10803fcc 	andi	r2,r2,255
811113c8:	10800828 	cmpgeui	r2,r2,32
811113cc:	1000041e 	bne	r2,zero,811113e0 <bPreParserV2+0x254>
811113d0:	e0bffe17 	ldw	r2,-8(fp)
811113d4:	10800183 	ldbu	r2,6(r2)
811113d8:	14003fcc 	andi	r16,r2,255
811113dc:	00000106 	br	811113e4 <bPreParserV2+0x258>
811113e0:	04000804 	movi	r16,32
811113e4:	e0bffb44 	addi	r2,fp,-19
811113e8:	1009883a 	mov	r4,r2
811113ec:	111b9400 	call	8111b940 <atoi>
811113f0:	1009883a 	mov	r4,r2
811113f4:	e0fffe17 	ldw	r3,-8(fp)
811113f8:	80800104 	addi	r2,r16,4
811113fc:	1085883a 	add	r2,r2,r2
81111400:	1885883a 	add	r2,r3,r2
81111404:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81111408:	e0bffe17 	ldw	r2,-8(fp)
8111140c:	10800183 	ldbu	r2,6(r2)
81111410:	10800044 	addi	r2,r2,1
81111414:	1007883a 	mov	r3,r2
81111418:	e0bffe17 	ldw	r2,-8(fp)
8111141c:	10c00185 	stb	r3,6(r2)
81111420:	00000906 	br	81111448 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81111424:	e0bffb07 	ldb	r2,-20(fp)
81111428:	10800ed8 	cmpnei	r2,r2,59
8111142c:	1000061e 	bne	r2,zero,81111448 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81111430:	e0bffb44 	addi	r2,fp,-19
81111434:	1009883a 	mov	r4,r2
81111438:	111b9400 	call	8111b940 <atoi>
8111143c:	1007883a 	mov	r3,r2
81111440:	e0bffe17 	ldw	r2,-8(fp)
81111444:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81111448:	e0bffb07 	ldb	r2,-20(fp)
8111144c:	10800ee0 	cmpeqi	r2,r2,59
81111450:	1000031e 	bne	r2,zero,81111460 <bPreParserV2+0x2d4>
81111454:	e0bff90f 	ldh	r2,-28(fp)
81111458:	e0fff703 	ldbu	r3,-36(fp)
8111145c:	18bfa516 	blt	r3,r2,811112f4 <__reset+0xfb0f12f4>


    if ( c == FINAL_CHAR )
81111460:	e0bffb07 	ldb	r2,-20(fp)
81111464:	10800ed8 	cmpnei	r2,r2,59
81111468:	1000191e 	bne	r2,zero,811114d0 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
8111146c:	e0bffe17 	ldw	r2,-8(fp)
81111470:	10c01243 	ldbu	r3,73(r2)
81111474:	e0bffe17 	ldw	r2,-8(fp)
81111478:	10801203 	ldbu	r2,72(r2)
8111147c:	18c03fcc 	andi	r3,r3,255
81111480:	10803fcc 	andi	r2,r2,255
81111484:	1880031e 	bne	r3,r2,81111494 <bPreParserV2+0x308>
            bSuccess = TRUE;
81111488:	00800044 	movi	r2,1
8111148c:	e0bff615 	stw	r2,-40(fp)
81111490:	00001006 	br	811114d4 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81111494:	d0e05c17 	ldw	r3,-32400(gp)
81111498:	e0bffe17 	ldw	r2,-8(fp)
8111149c:	10801203 	ldbu	r2,72(r2)
811114a0:	11003fcc 	andi	r4,r2,255
811114a4:	e0bffe17 	ldw	r2,-8(fp)
811114a8:	10801243 	ldbu	r2,73(r2)
811114ac:	10803fcc 	andi	r2,r2,255
811114b0:	100f883a 	mov	r7,r2
811114b4:	200d883a 	mov	r6,r4
811114b8:	01604574 	movhi	r5,33045
811114bc:	2960a504 	addi	r5,r5,-32108
811114c0:	1809883a 	mov	r4,r3
811114c4:	111ba9c0 	call	8111ba9c <fprintf>
            #endif
            bSuccess = FALSE;
811114c8:	e03ff615 	stw	zero,-40(fp)
811114cc:	00000106 	br	811114d4 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
811114d0:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
811114d4:	e0bff617 	ldw	r2,-40(fp)
}
811114d8:	e6ffff04 	addi	sp,fp,-4
811114dc:	dfc00217 	ldw	ra,8(sp)
811114e0:	df000117 	ldw	fp,4(sp)
811114e4:	dc000017 	ldw	r16,0(sp)
811114e8:	dec00304 	addi	sp,sp,12
811114ec:	f800283a 	ret

811114f0 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
811114f0:	defffb04 	addi	sp,sp,-20
811114f4:	de00012e 	bgeu	sp,et,811114fc <vSenderComTask+0xc>
811114f8:	003b68fa 	trap	3
811114fc:	dfc00415 	stw	ra,16(sp)
81111500:	df000315 	stw	fp,12(sp)
81111504:	df000304 	addi	fp,sp,12
81111508:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
8111150c:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81111510:	d0a05c17 	ldw	r2,-32400(gp)
81111514:	100f883a 	mov	r7,r2
81111518:	01800704 	movi	r6,28
8111151c:	01400044 	movi	r5,1
81111520:	01204574 	movhi	r4,33045
81111524:	2120b104 	addi	r4,r4,-32060
81111528:	111c1380 	call	8111c138 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
8111152c:	e0bffd17 	ldw	r2,-12(fp)
81111530:	10c00060 	cmpeqi	r3,r2,1
81111534:	1800091e 	bne	r3,zero,8111155c <vSenderComTask+0x6c>
81111538:	0080052e 	bgeu	zero,r2,81111550 <vSenderComTask+0x60>
8111153c:	10c000a0 	cmpeqi	r3,r2,2
81111540:	1800471e 	bne	r3,zero,81111660 <vSenderComTask+0x170>
81111544:	10800160 	cmpeqi	r2,r2,5
81111548:	10002c1e 	bne	r2,zero,811115fc <vSenderComTask+0x10c>
8111154c:	00003a06 	br	81111638 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81111550:	00800044 	movi	r2,1
81111554:	e0bffd15 	stw	r2,-12(fp)
                break;
81111558:	00004206 	br	81111664 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
8111155c:	d0a05c17 	ldw	r2,-32400(gp)
81111560:	100f883a 	mov	r7,r2
81111564:	01800784 	movi	r6,30
81111568:	01400044 	movi	r5,1
8111156c:	01204574 	movhi	r4,33045
81111570:	2120b904 	addi	r4,r4,-32028
81111574:	111c1380 	call	8111c138 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81111578:	01400044 	movi	r5,1
8111157c:	01204574 	movhi	r4,33045
81111580:	2120c104 	addi	r4,r4,-31996
81111584:	1114f340 	call	81114f34 <bSendUART32v2>
81111588:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
8111158c:	e0bffe17 	ldw	r2,-8(fp)
81111590:	10800058 	cmpnei	r2,r2,1
81111594:	10000a1e 	bne	r2,zero,811115c0 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81111598:	00800144 	movi	r2,5
8111159c:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
811115a0:	d0a05c17 	ldw	r2,-32400(gp)
811115a4:	100f883a 	mov	r7,r2
811115a8:	01800d44 	movi	r6,53
811115ac:	01400044 	movi	r5,1
811115b0:	01204574 	movhi	r4,33045
811115b4:	2120c404 	addi	r4,r4,-31984
811115b8:	111c1380 	call	8111c138 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
811115bc:	00002906 	br	81111664 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
811115c0:	d0a05c17 	ldw	r2,-32400(gp)
811115c4:	100f883a 	mov	r7,r2
811115c8:	01800784 	movi	r6,30
811115cc:	01400044 	movi	r5,1
811115d0:	01204574 	movhi	r4,33045
811115d4:	2120d204 	addi	r4,r4,-31928
811115d8:	111c1380 	call	8111c138 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
811115dc:	00800044 	movi	r2,1
811115e0:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
811115e4:	000f883a 	mov	r7,zero
811115e8:	01800144 	movi	r6,5
811115ec:	000b883a 	mov	r5,zero
811115f0:	0009883a 	mov	r4,zero
811115f4:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
                }
                break;
811115f8:	00001a06 	br	81111664 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
811115fc:	00800144 	movi	r2,5
81111600:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81111604:	d0a05c17 	ldw	r2,-32400(gp)
81111608:	100f883a 	mov	r7,r2
8111160c:	018002c4 	movi	r6,11
81111610:	01400044 	movi	r5,1
81111614:	01204574 	movhi	r4,33045
81111618:	2120da04 	addi	r4,r4,-31896
8111161c:	111c1380 	call	8111c138 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81111620:	000f883a 	mov	r7,zero
81111624:	01800644 	movi	r6,25
81111628:	000b883a 	mov	r5,zero
8111162c:	0009883a 	mov	r4,zero
81111630:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>

                break;
81111634:	00000b06 	br	81111664 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
81111638:	d0a05c17 	ldw	r2,-32400(gp)
8111163c:	100f883a 	mov	r7,r2
81111640:	018003c4 	movi	r6,15
81111644:	01400044 	movi	r5,1
81111648:	01204574 	movhi	r4,33045
8111164c:	2120dd04 	addi	r4,r4,-31884
81111650:	111c1380 	call	8111c138 <fwrite>
                #endif
                eSenderMode = sDummySender;
81111654:	00800144 	movi	r2,5
81111658:	e0bffd15 	stw	r2,-12(fp)
                break;
8111165c:	00000106 	br	81111664 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81111660:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81111664:	003fb106 	br	8111152c <__reset+0xfb0f152c>

81111668 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81111668:	defffa04 	addi	sp,sp,-24
8111166c:	de00012e 	bgeu	sp,et,81111674 <vSimMebTask+0xc>
81111670:	003b68fa 	trap	3
81111674:	dfc00515 	stw	ra,20(sp)
81111678:	df000415 	stw	fp,16(sp)
8111167c:	df000404 	addi	fp,sp,16
81111680:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
81111684:	e0bfff17 	ldw	r2,-4(fp)
81111688:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
8111168c:	d0a05c17 	ldw	r2,-32400(gp)
81111690:	100f883a 	mov	r7,r2
81111694:	018008c4 	movi	r6,35
81111698:	01400044 	movi	r5,1
8111169c:	01204574 	movhi	r4,33045
811116a0:	2120e104 	addi	r4,r4,-31868
811116a4:	111c1380 	call	8111c138 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
811116a8:	e0bffc17 	ldw	r2,-16(fp)
811116ac:	10800117 	ldw	r2,4(r2)
811116b0:	10c00168 	cmpgeui	r3,r2,5
811116b4:	1800ac1e 	bne	r3,zero,81111968 <vSimMebTask+0x300>
811116b8:	100690ba 	slli	r3,r2,2
811116bc:	00a04474 	movhi	r2,33041
811116c0:	1085b404 	addi	r2,r2,5840
811116c4:	1885883a 	add	r2,r3,r2
811116c8:	10800017 	ldw	r2,0(r2)
811116cc:	1000683a 	jmp	r2
811116d0:	811116e4 	muli	r4,r16,17499
811116d4:	811116fc 	xorhi	r4,r16,17499
811116d8:	8111177c 	xorhi	r4,r16,17501
811116dc:	811117f4 	orhi	r4,r16,17503
811116e0:	811118cc 	andi	r4,r16,17507
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
811116e4:	e13ffc17 	ldw	r4,-16(fp)
811116e8:	111270c0 	call	8111270c <vMebInit>
				pxMebC->eMode = sMebToConfig;
811116ec:	e0bffc17 	ldw	r2,-16(fp)
811116f0:	00c00044 	movi	r3,1
811116f4:	10c00115 	stw	r3,4(r2)
				break;
811116f8:	0000a606 	br	81111994 <vSimMebTask+0x32c>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
811116fc:	d0a05c17 	ldw	r2,-32400(gp)
81111700:	100f883a 	mov	r7,r2
81111704:	01800584 	movi	r6,22
81111708:	01400044 	movi	r5,1
8111170c:	01204574 	movhi	r4,33045
81111710:	2120ea04 	addi	r4,r4,-31832
81111714:	111c1380 	call	8111c138 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
81111718:	1119f440 	call	81119f44 <bStopSync>
				vSyncClearCounter();
8111171c:	110b8bc0 	call	8110b8bc <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81111720:	11128140 	call	81112814 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81111724:	01c00284 	movi	r7,10
81111728:	000d883a 	mov	r6,zero
8111172c:	000b883a 	mov	r5,zero
81111730:	0009883a 	mov	r4,zero
81111734:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
81111738:	000d883a 	mov	r6,zero
8111173c:	000b883a 	mov	r5,zero
81111740:	01002844 	movi	r4,161
81111744:	11124e00 	call	811124e0 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81111748:	000d883a 	mov	r6,zero
8111174c:	000b883a 	mov	r5,zero
81111750:	01002844 	movi	r4,161
81111754:	11126840 	call	81112684 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81111758:	01c03e84 	movi	r7,250
8111175c:	000d883a 	mov	r6,zero
81111760:	000b883a 	mov	r5,zero
81111764:	0009883a 	mov	r4,zero
81111768:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
8111176c:	e0bffc17 	ldw	r2,-16(fp)
81111770:	00c000c4 	movi	r3,3
81111774:	10c00115 	stw	r3,4(r2)
				break;
81111778:	00008606 	br	81111994 <vSimMebTask+0x32c>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
8111177c:	d0a05c17 	ldw	r2,-32400(gp)
81111780:	100f883a 	mov	r7,r2
81111784:	018004c4 	movi	r6,19
81111788:	01400044 	movi	r5,1
8111178c:	01204574 	movhi	r4,33045
81111790:	2120f004 	addi	r4,r4,-31808
81111794:	111c1380 	call	8111c138 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81111798:	000d883a 	mov	r6,zero
8111179c:	000b883a 	mov	r5,zero
811117a0:	01002884 	movi	r4,162
811117a4:	11124e00 	call	811124e0 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
811117a8:	000d883a 	mov	r6,zero
811117ac:	000b883a 	mov	r5,zero
811117b0:	01002884 	movi	r4,162
811117b4:	11126840 	call	81112684 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811117b8:	e0bffc17 	ldw	r2,-16(fp)
811117bc:	1080050b 	ldhu	r2,20(r2)
811117c0:	10bfffcc 	andi	r2,r2,65535
811117c4:	100f883a 	mov	r7,r2
811117c8:	000d883a 	mov	r6,zero
811117cc:	000b883a 	mov	r5,zero
811117d0:	0009883a 	mov	r4,zero
811117d4:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
				vSyncClearCounter();
811117d8:	110b8bc0 	call	8110b8bc <vSyncClearCounter>
				bStartSync();
811117dc:	1119f0c0 	call	81119f0c <bStartSync>

				vEvtChangeMebMode();
811117e0:	1118a500 	call	81118a50 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
811117e4:	e0bffc17 	ldw	r2,-16(fp)
811117e8:	00c00104 	movi	r3,4
811117ec:	10c00115 	stw	r3,4(r2)
				break;
811117f0:	00006806 	br	81111994 <vSimMebTask+0x32c>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811117f4:	d0a06317 	ldw	r2,-32372(gp)
811117f8:	e0fffe04 	addi	r3,fp,-8
811117fc:	180d883a 	mov	r6,r3
81111800:	000b883a 	mov	r5,zero
81111804:	1009883a 	mov	r4,r2
81111808:	1138c800 	call	81138c80 <OSQPend>
8111180c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81111810:	e0bffe03 	ldbu	r2,-8(fp)
81111814:	10803fcc 	andi	r2,r2,255
81111818:	1000291e 	bne	r2,zero,811118c0 <vSimMebTask+0x258>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8111181c:	e0bffdc3 	ldbu	r2,-9(fp)
81111820:	10803fcc 	andi	r2,r2,255
81111824:	10800058 	cmpnei	r2,r2,1
81111828:	10001c1e 	bne	r2,zero,8111189c <vSimMebTask+0x234>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
8111182c:	e0bffd83 	ldbu	r2,-10(fp)
81111830:	10803fcc 	andi	r2,r2,255
81111834:	10c00060 	cmpeqi	r3,r2,1
81111838:	1800031e 	bne	r3,zero,81111848 <vSimMebTask+0x1e0>
8111183c:	10803820 	cmpeqi	r2,r2,224
81111840:	1000041e 	bne	r2,zero,81111854 <vSimMebTask+0x1ec>
81111844:	00000b06 	br	81111874 <vSimMebTask+0x20c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81111848:	e13ffc17 	ldw	r4,-16(fp)
8111184c:	11119980 	call	81111998 <vPusMebTask>
								break;
81111850:	00001d06 	br	811118c8 <vSimMebTask+0x260>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81111854:	d0a05c17 	ldw	r2,-32400(gp)
81111858:	100f883a 	mov	r7,r2
8111185c:	018012c4 	movi	r6,75
81111860:	01400044 	movi	r5,1
81111864:	01204574 	movhi	r4,33045
81111868:	2120f504 	addi	r4,r4,-31788
8111186c:	111c1380 	call	8111c138 <fwrite>
								#endif
								break;
81111870:	00001506 	br	811118c8 <vSimMebTask+0x260>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81111874:	d0a05c17 	ldw	r2,-32400(gp)
81111878:	e0fffd83 	ldbu	r3,-10(fp)
8111187c:	18c03fcc 	andi	r3,r3,255
81111880:	180d883a 	mov	r6,r3
81111884:	01604574 	movhi	r5,33045
81111888:	29610804 	addi	r5,r5,-31712
8111188c:	1009883a 	mov	r4,r2
81111890:	111ba9c0 	call	8111ba9c <fprintf>
								#endif
								break;
81111894:	0001883a 	nop
81111898:	00000b06 	br	811118c8 <vSimMebTask+0x260>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
8111189c:	d0a05c17 	ldw	r2,-32400(gp)
811118a0:	e0fffdc3 	ldbu	r3,-9(fp)
811118a4:	18c03fcc 	andi	r3,r3,255
811118a8:	180d883a 	mov	r6,r3
811118ac:	01604574 	movhi	r5,33045
811118b0:	29611a04 	addi	r5,r5,-31640
811118b4:	1009883a 	mov	r4,r2
811118b8:	111ba9c0 	call	8111ba9c <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811118bc:	00003506 	br	81111994 <vSimMebTask+0x32c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811118c0:	11184980 	call	81118498 <vCouldNotGetCmdQueueMeb>
				}

				break;
811118c4:	00003306 	br	81111994 <vSimMebTask+0x32c>
811118c8:	00003206 	br	81111994 <vSimMebTask+0x32c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811118cc:	d0a06317 	ldw	r2,-32372(gp)
811118d0:	e0fffe04 	addi	r3,fp,-8
811118d4:	180d883a 	mov	r6,r3
811118d8:	000b883a 	mov	r5,zero
811118dc:	1009883a 	mov	r4,r2
811118e0:	1138c800 	call	81138c80 <OSQPend>
811118e4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811118e8:	e0bffe03 	ldbu	r2,-8(fp)
811118ec:	10803fcc 	andi	r2,r2,255
811118f0:	10001a1e 	bne	r2,zero,8111195c <vSimMebTask+0x2f4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811118f4:	e0bffdc3 	ldbu	r2,-9(fp)
811118f8:	10803fcc 	andi	r2,r2,255
811118fc:	10800058 	cmpnei	r2,r2,1
81111900:	10000d1e 	bne	r2,zero,81111938 <vSimMebTask+0x2d0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81111904:	e0bffd83 	ldbu	r2,-10(fp)
81111908:	10803fcc 	andi	r2,r2,255
8111190c:	10c00060 	cmpeqi	r3,r2,1
81111910:	1800031e 	bne	r3,zero,81111920 <vSimMebTask+0x2b8>
81111914:	10803820 	cmpeqi	r2,r2,224
81111918:	1000041e 	bne	r2,zero,8111192c <vSimMebTask+0x2c4>
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);

								break;
							default:
								break;
8111191c:	00001106 	br	81111964 <vSimMebTask+0x2fc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81111920:	e13ffc17 	ldw	r4,-16(fp)
81111924:	11119980 	call	81111998 <vPusMebTask>
								break;
81111928:	00000e06 	br	81111964 <vSimMebTask+0x2fc>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
8111192c:	e13ffc17 	ldw	r4,-16(fp)
81111930:	11127700 	call	81112770 <vSwapMemmory>

								break;
81111934:	00000b06 	br	81111964 <vSimMebTask+0x2fc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81111938:	d0a05c17 	ldw	r2,-32400(gp)
8111193c:	e0fffdc3 	ldbu	r3,-9(fp)
81111940:	18c03fcc 	andi	r3,r3,255
81111944:	180d883a 	mov	r6,r3
81111948:	01604574 	movhi	r5,33045
8111194c:	29611a04 	addi	r5,r5,-31640
81111950:	1009883a 	mov	r4,r2
81111954:	111ba9c0 	call	8111ba9c <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81111958:	00000e06 	br	81111994 <vSimMebTask+0x32c>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
8111195c:	11184980 	call	81118498 <vCouldNotGetCmdQueueMeb>
				}			
				break;
81111960:	00000c06 	br	81111994 <vSimMebTask+0x32c>
81111964:	00000b06 	br	81111994 <vSimMebTask+0x32c>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
81111968:	d0a05c17 	ldw	r2,-32400(gp)
8111196c:	100f883a 	mov	r7,r2
81111970:	01800bc4 	movi	r6,47
81111974:	01400044 	movi	r5,1
81111978:	01204574 	movhi	r4,33045
8111197c:	21212804 	addi	r4,r4,-31584
81111980:	111c1380 	call	8111c138 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81111984:	e0bffc17 	ldw	r2,-16(fp)
81111988:	00c00044 	movi	r3,1
8111198c:	10c00115 	stw	r3,4(r2)
				break;
81111990:	0001883a 	nop
		}
	}
81111994:	003f4406 	br	811116a8 <__reset+0xfb0f16a8>

81111998 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81111998:	defffb04 	addi	sp,sp,-20
8111199c:	de00012e 	bgeu	sp,et,811119a4 <vPusMebTask+0xc>
811119a0:	003b68fa 	trap	3
811119a4:	dfc00415 	stw	ra,16(sp)
811119a8:	df000315 	stw	fp,12(sp)
811119ac:	df000304 	addi	fp,sp,12
811119b0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
811119b4:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
811119b8:	d0a06d17 	ldw	r2,-32332(gp)
811119bc:	e0fffe44 	addi	r3,fp,-7
811119c0:	180d883a 	mov	r6,r3
811119c4:	01400084 	movi	r5,2
811119c8:	1009883a 	mov	r4,r2
811119cc:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
811119d0:	e0bffe43 	ldbu	r2,-7(fp)
811119d4:	10803fcc 	andi	r2,r2,255
811119d8:	10002c1e 	bne	r2,zero,81111a8c <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811119dc:	e03ffe05 	stb	zero,-8(fp)
811119e0:	00002306 	br	81111a70 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
811119e4:	e0fffe03 	ldbu	r3,-8(fp)
811119e8:	00a04574 	movhi	r2,33045
811119ec:	10800804 	addi	r2,r2,32
811119f0:	18c01524 	muli	r3,r3,84
811119f4:	10c5883a 	add	r2,r2,r3
811119f8:	10800104 	addi	r2,r2,4
811119fc:	10800017 	ldw	r2,0(r2)
81111a00:	10800058 	cmpnei	r2,r2,1
81111a04:	1000171e 	bne	r2,zero,81111a64 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81111a08:	e13ffe03 	ldbu	r4,-8(fp)
81111a0c:	00e04574 	movhi	r3,33045
81111a10:	18f61104 	addi	r3,r3,-10172
81111a14:	00a04574 	movhi	r2,33045
81111a18:	10800804 	addi	r2,r2,32
81111a1c:	21001524 	muli	r4,r4,84
81111a20:	1105883a 	add	r2,r2,r4
81111a24:	1009883a 	mov	r4,r2
81111a28:	00801504 	movi	r2,84
81111a2c:	100d883a 	mov	r6,r2
81111a30:	200b883a 	mov	r5,r4
81111a34:	1809883a 	mov	r4,r3
81111a38:	111cb4c0 	call	8111cb4c <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81111a3c:	e0fffe03 	ldbu	r3,-8(fp)
81111a40:	00a04574 	movhi	r2,33045
81111a44:	10800804 	addi	r2,r2,32
81111a48:	18c01524 	muli	r3,r3,84
81111a4c:	10c5883a 	add	r2,r2,r3
81111a50:	10800104 	addi	r2,r2,4
81111a54:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81111a58:	00800044 	movi	r2,1
81111a5c:	e0bffd15 	stw	r2,-12(fp)
                break;
81111a60:	00000606 	br	81111a7c <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81111a64:	e0bffe03 	ldbu	r2,-8(fp)
81111a68:	10800044 	addi	r2,r2,1
81111a6c:	e0bffe05 	stb	r2,-8(fp)
81111a70:	e0bffe03 	ldbu	r2,-8(fp)
81111a74:	10800130 	cmpltui	r2,r2,4
81111a78:	103fda1e 	bne	r2,zero,811119e4 <__reset+0xfb0f19e4>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81111a7c:	d0a06d17 	ldw	r2,-32332(gp)
81111a80:	1009883a 	mov	r4,r2
81111a84:	11381100 	call	81138110 <OSMutexPost>
81111a88:	00000106 	br	81111a90 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81111a8c:	11185000 	call	81118500 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81111a90:	e0bffd17 	ldw	r2,-12(fp)
81111a94:	10001126 	beq	r2,zero,81111adc <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81111a98:	e0bfff17 	ldw	r2,-4(fp)
81111a9c:	10800117 	ldw	r2,4(r2)
81111aa0:	10c000e0 	cmpeqi	r3,r2,3
81111aa4:	1800031e 	bne	r3,zero,81111ab4 <vPusMebTask+0x11c>
81111aa8:	10800120 	cmpeqi	r2,r2,4
81111aac:	1000061e 	bne	r2,zero,81111ac8 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81111ab0:	00000a06 	br	81111adc <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81111ab4:	01604574 	movhi	r5,33045
81111ab8:	29761104 	addi	r5,r5,-10172
81111abc:	e13fff17 	ldw	r4,-4(fp)
81111ac0:	1111af40 	call	81111af4 <vPusMebInTaskConfigMode>
				break;
81111ac4:	00000506 	br	81111adc <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81111ac8:	01604574 	movhi	r5,33045
81111acc:	29761104 	addi	r5,r5,-10172
81111ad0:	e13fff17 	ldw	r4,-4(fp)
81111ad4:	1111e840 	call	81111e84 <vPusMebInTaskRunningMode>
				break;
81111ad8:	0001883a 	nop
			default:
				break;
		}
	}
}
81111adc:	0001883a 	nop
81111ae0:	e037883a 	mov	sp,fp
81111ae4:	dfc00117 	ldw	ra,4(sp)
81111ae8:	df000017 	ldw	fp,0(sp)
81111aec:	dec00204 	addi	sp,sp,8
81111af0:	f800283a 	ret

81111af4 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111af4:	defffc04 	addi	sp,sp,-16
81111af8:	de00012e 	bgeu	sp,et,81111b00 <vPusMebInTaskConfigMode+0xc>
81111afc:	003b68fa 	trap	3
81111b00:	dfc00315 	stw	ra,12(sp)
81111b04:	df000215 	stw	fp,8(sp)
81111b08:	df000204 	addi	fp,sp,8
81111b0c:	e13ffe15 	stw	r4,-8(fp)
81111b10:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81111b14:	e0bfff17 	ldw	r2,-4(fp)
81111b18:	1080030b 	ldhu	r2,12(r2)
81111b1c:	10bfffcc 	andi	r2,r2,65535
81111b20:	10c03ee0 	cmpeqi	r3,r2,251
81111b24:	1800081e 	bne	r3,zero,81111b48 <vPusMebInTaskConfigMode+0x54>
81111b28:	10c03f20 	cmpeqi	r3,r2,252
81111b2c:	18000a1e 	bne	r3,zero,81111b58 <vPusMebInTaskConfigMode+0x64>
81111b30:	10803ea0 	cmpeqi	r2,r2,250
81111b34:	10000c26 	beq	r2,zero,81111b68 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81111b38:	e17fff17 	ldw	r5,-4(fp)
81111b3c:	e13ffe17 	ldw	r4,-8(fp)
81111b40:	1111ba00 	call	81111ba0 <vPusType250conf>
			break;
81111b44:	00001006 	br	81111b88 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81111b48:	e17fff17 	ldw	r5,-4(fp)
81111b4c:	e13ffe17 	ldw	r4,-8(fp)
81111b50:	1111c2c0 	call	81111c2c <vPusType251conf>
			break;
81111b54:	00000c06 	br	81111b88 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81111b58:	e17fff17 	ldw	r5,-4(fp)
81111b5c:	e13ffe17 	ldw	r4,-8(fp)
81111b60:	1111c800 	call	81111c80 <vPusType252conf>
			break;
81111b64:	00000806 	br	81111b88 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81111b68:	d0a05c17 	ldw	r2,-32400(gp)
81111b6c:	100f883a 	mov	r7,r2
81111b70:	01800d84 	movi	r6,54
81111b74:	01400044 	movi	r5,1
81111b78:	01204574 	movhi	r4,33045
81111b7c:	21213404 	addi	r4,r4,-31536
81111b80:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81111b84:	0001883a 	nop
	}
}
81111b88:	0001883a 	nop
81111b8c:	e037883a 	mov	sp,fp
81111b90:	dfc00117 	ldw	ra,4(sp)
81111b94:	df000017 	ldw	fp,0(sp)
81111b98:	dec00204 	addi	sp,sp,8
81111b9c:	f800283a 	ret

81111ba0 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111ba0:	defffc04 	addi	sp,sp,-16
81111ba4:	de00012e 	bgeu	sp,et,81111bac <vPusType250conf+0xc>
81111ba8:	003b68fa 	trap	3
81111bac:	dfc00315 	stw	ra,12(sp)
81111bb0:	df000215 	stw	fp,8(sp)
81111bb4:	df000204 	addi	fp,sp,8
81111bb8:	e13ffe15 	stw	r4,-8(fp)
81111bbc:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81111bc0:	e0bfff17 	ldw	r2,-4(fp)
81111bc4:	1080038b 	ldhu	r2,14(r2)
81111bc8:	10bfffcc 	andi	r2,r2,65535
81111bcc:	10c00f60 	cmpeqi	r3,r2,61
81111bd0:	1800031e 	bne	r3,zero,81111be0 <vPusType250conf+0x40>
81111bd4:	10800fa0 	cmpeqi	r2,r2,62
81111bd8:	10000d1e 	bne	r2,zero,81111c10 <vPusType250conf+0x70>
81111bdc:	00000406 	br	81111bf0 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81111be0:	e0bffe17 	ldw	r2,-8(fp)
81111be4:	00c00084 	movi	r3,2
81111be8:	10c00115 	stw	r3,4(r2)
			break;
81111bec:	00000906 	br	81111c14 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81111bf0:	d0a05c17 	ldw	r2,-32400(gp)
81111bf4:	100f883a 	mov	r7,r2
81111bf8:	01800b04 	movi	r6,44
81111bfc:	01400044 	movi	r5,1
81111c00:	01204574 	movhi	r4,33045
81111c04:	21214204 	addi	r4,r4,-31480
81111c08:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81111c0c:	00000106 	br	81111c14 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81111c10:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81111c14:	0001883a 	nop
81111c18:	e037883a 	mov	sp,fp
81111c1c:	dfc00117 	ldw	ra,4(sp)
81111c20:	df000017 	ldw	fp,0(sp)
81111c24:	dec00204 	addi	sp,sp,8
81111c28:	f800283a 	ret

81111c2c <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111c2c:	defffc04 	addi	sp,sp,-16
81111c30:	de00012e 	bgeu	sp,et,81111c38 <vPusType251conf+0xc>
81111c34:	003b68fa 	trap	3
81111c38:	dfc00315 	stw	ra,12(sp)
81111c3c:	df000215 	stw	fp,8(sp)
81111c40:	df000204 	addi	fp,sp,8
81111c44:	e13ffe15 	stw	r4,-8(fp)
81111c48:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81111c4c:	d0a05c17 	ldw	r2,-32400(gp)
81111c50:	100f883a 	mov	r7,r2
81111c54:	01801184 	movi	r6,70
81111c58:	01400044 	movi	r5,1
81111c5c:	01204574 	movhi	r4,33045
81111c60:	21214e04 	addi	r4,r4,-31432
81111c64:	111c1380 	call	8111c138 <fwrite>
	#endif
}
81111c68:	0001883a 	nop
81111c6c:	e037883a 	mov	sp,fp
81111c70:	dfc00117 	ldw	ra,4(sp)
81111c74:	df000017 	ldw	fp,0(sp)
81111c78:	dec00204 	addi	sp,sp,8
81111c7c:	f800283a 	ret

81111c80 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111c80:	defffb04 	addi	sp,sp,-20
81111c84:	de00012e 	bgeu	sp,et,81111c8c <vPusType252conf+0xc>
81111c88:	003b68fa 	trap	3
81111c8c:	dfc00415 	stw	ra,16(sp)
81111c90:	df000315 	stw	fp,12(sp)
81111c94:	df000304 	addi	fp,sp,12
81111c98:	e13ffe15 	stw	r4,-8(fp)
81111c9c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81111ca0:	e0bfff17 	ldw	r2,-4(fp)
81111ca4:	1080050b 	ldhu	r2,20(r2)
81111ca8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81111cac:	e0bfff17 	ldw	r2,-4(fp)
81111cb0:	1080038b 	ldhu	r2,14(r2)
81111cb4:	10bfffcc 	andi	r2,r2,65535
81111cb8:	10c000a0 	cmpeqi	r3,r2,2
81111cbc:	18000c1e 	bne	r3,zero,81111cf0 <vPusType252conf+0x70>
81111cc0:	10c00090 	cmplti	r3,r2,2
81111cc4:	1800611e 	bne	r3,zero,81111e4c <vPusType252conf+0x1cc>
81111cc8:	10800188 	cmpgei	r2,r2,6
81111ccc:	10005f1e 	bne	r2,zero,81111e4c <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81111cd0:	d0a05c17 	ldw	r2,-32400(gp)
81111cd4:	100f883a 	mov	r7,r2
81111cd8:	01801384 	movi	r6,78
81111cdc:	01400044 	movi	r5,1
81111ce0:	01204574 	movhi	r4,33045
81111ce4:	21216004 	addi	r4,r4,-31360
81111ce8:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81111cec:	00005f06 	br	81111e6c <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111cf0:	e0bffd0b 	ldhu	r2,-12(fp)
81111cf4:	10809524 	muli	r2,r2,596
81111cf8:	10805404 	addi	r2,r2,336
81111cfc:	e0fffe17 	ldw	r3,-8(fp)
81111d00:	1885883a 	add	r2,r3,r2
81111d04:	1009883a 	mov	r4,r2
81111d08:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81111d0c:	e0bffd0b 	ldhu	r2,-12(fp)
81111d10:	e0fffe17 	ldw	r3,-8(fp)
81111d14:	10809524 	muli	r2,r2,596
81111d18:	1885883a 	add	r2,r3,r2
81111d1c:	10806404 	addi	r2,r2,400
81111d20:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111d24:	e0bffd0b 	ldhu	r2,-12(fp)
81111d28:	10809524 	muli	r2,r2,596
81111d2c:	10805404 	addi	r2,r2,336
81111d30:	e0fffe17 	ldw	r3,-8(fp)
81111d34:	1885883a 	add	r2,r3,r2
81111d38:	1009883a 	mov	r4,r2
81111d3c:	1106a3c0 	call	81106a3c <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111d40:	e0bffd0b 	ldhu	r2,-12(fp)
81111d44:	10809524 	muli	r2,r2,596
81111d48:	10805404 	addi	r2,r2,336
81111d4c:	e0fffe17 	ldw	r3,-8(fp)
81111d50:	1885883a 	add	r2,r3,r2
81111d54:	1009883a 	mov	r4,r2
81111d58:	1106ccc0 	call	81106ccc <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81111d5c:	e0bffd0b 	ldhu	r2,-12(fp)
81111d60:	e0ffff17 	ldw	r3,-4(fp)
81111d64:	18c00b0b 	ldhu	r3,44(r3)
81111d68:	1809883a 	mov	r4,r3
81111d6c:	e0fffe17 	ldw	r3,-8(fp)
81111d70:	10809524 	muli	r2,r2,596
81111d74:	1885883a 	add	r2,r3,r2
81111d78:	10805504 	addi	r2,r2,340
81111d7c:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81111d80:	e0bffd0b 	ldhu	r2,-12(fp)
81111d84:	e0ffff17 	ldw	r3,-4(fp)
81111d88:	18c0098b 	ldhu	r3,38(r3)
81111d8c:	1809883a 	mov	r4,r3
81111d90:	e0fffe17 	ldw	r3,-8(fp)
81111d94:	10809524 	muli	r2,r2,596
81111d98:	1885883a 	add	r2,r3,r2
81111d9c:	10805544 	addi	r2,r2,341
81111da0:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111da4:	e0bffd0b 	ldhu	r2,-12(fp)
81111da8:	10809524 	muli	r2,r2,596
81111dac:	10805404 	addi	r2,r2,336
81111db0:	e0fffe17 	ldw	r3,-8(fp)
81111db4:	1885883a 	add	r2,r3,r2
81111db8:	1009883a 	mov	r4,r2
81111dbc:	1106bf40 	call	81106bf4 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111dc0:	e0bffd0b 	ldhu	r2,-12(fp)
81111dc4:	10809524 	muli	r2,r2,596
81111dc8:	10805404 	addi	r2,r2,336
81111dcc:	e0fffe17 	ldw	r3,-8(fp)
81111dd0:	1885883a 	add	r2,r3,r2
81111dd4:	1009883a 	mov	r4,r2
81111dd8:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81111ddc:	e0bffd0b 	ldhu	r2,-12(fp)
81111de0:	e0fffe17 	ldw	r3,-8(fp)
81111de4:	10809524 	muli	r2,r2,596
81111de8:	1885883a 	add	r2,r3,r2
81111dec:	10806404 	addi	r2,r2,400
81111df0:	00c00044 	movi	r3,1
81111df4:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111df8:	e0bffd0b 	ldhu	r2,-12(fp)
81111dfc:	10809524 	muli	r2,r2,596
81111e00:	10805404 	addi	r2,r2,336
81111e04:	e0fffe17 	ldw	r3,-8(fp)
81111e08:	1885883a 	add	r2,r3,r2
81111e0c:	1009883a 	mov	r4,r2
81111e10:	1106a3c0 	call	81106a3c <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81111e14:	d0e05c17 	ldw	r3,-32400(gp)
81111e18:	e0bfff17 	ldw	r2,-4(fp)
81111e1c:	10800b0b 	ldhu	r2,44(r2)
81111e20:	113fffcc 	andi	r4,r2,65535
81111e24:	e0bfff17 	ldw	r2,-4(fp)
81111e28:	1080098b 	ldhu	r2,38(r2)
81111e2c:	10bfffcc 	andi	r2,r2,65535
81111e30:	100f883a 	mov	r7,r2
81111e34:	200d883a 	mov	r6,r4
81111e38:	01604574 	movhi	r5,33045
81111e3c:	29617404 	addi	r5,r5,-31280
81111e40:	1809883a 	mov	r4,r3
81111e44:	111ba9c0 	call	8111ba9c <fprintf>
			#endif

			break;
81111e48:	00000806 	br	81111e6c <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81111e4c:	d0a05c17 	ldw	r2,-32400(gp)
81111e50:	100f883a 	mov	r7,r2
81111e54:	01800b04 	movi	r6,44
81111e58:	01400044 	movi	r5,1
81111e5c:	01204574 	movhi	r4,33045
81111e60:	21214204 	addi	r4,r4,-31480
81111e64:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81111e68:	0001883a 	nop
	}
}
81111e6c:	0001883a 	nop
81111e70:	e037883a 	mov	sp,fp
81111e74:	dfc00117 	ldw	ra,4(sp)
81111e78:	df000017 	ldw	fp,0(sp)
81111e7c:	dec00204 	addi	sp,sp,8
81111e80:	f800283a 	ret

81111e84 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111e84:	defffc04 	addi	sp,sp,-16
81111e88:	de00012e 	bgeu	sp,et,81111e90 <vPusMebInTaskRunningMode+0xc>
81111e8c:	003b68fa 	trap	3
81111e90:	dfc00315 	stw	ra,12(sp)
81111e94:	df000215 	stw	fp,8(sp)
81111e98:	df000204 	addi	fp,sp,8
81111e9c:	e13ffe15 	stw	r4,-8(fp)
81111ea0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81111ea4:	e0bfff17 	ldw	r2,-4(fp)
81111ea8:	1080030b 	ldhu	r2,12(r2)
81111eac:	10bfffcc 	andi	r2,r2,65535
81111eb0:	10c03ee0 	cmpeqi	r3,r2,251
81111eb4:	1800081e 	bne	r3,zero,81111ed8 <vPusMebInTaskRunningMode+0x54>
81111eb8:	10c03f20 	cmpeqi	r3,r2,252
81111ebc:	18000a1e 	bne	r3,zero,81111ee8 <vPusMebInTaskRunningMode+0x64>
81111ec0:	10803ea0 	cmpeqi	r2,r2,250
81111ec4:	10000c26 	beq	r2,zero,81111ef8 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81111ec8:	e17fff17 	ldw	r5,-4(fp)
81111ecc:	e13ffe17 	ldw	r4,-8(fp)
81111ed0:	1111f300 	call	81111f30 <vPusType250run>
			break;
81111ed4:	00001006 	br	81111f18 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81111ed8:	e17fff17 	ldw	r5,-4(fp)
81111edc:	e13ffe17 	ldw	r4,-8(fp)
81111ee0:	1111fbc0 	call	81111fbc <vPusType251run>
			break;
81111ee4:	00000c06 	br	81111f18 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81111ee8:	e17fff17 	ldw	r5,-4(fp)
81111eec:	e13ffe17 	ldw	r4,-8(fp)
81111ef0:	11120d00 	call	811120d0 <vPusType252run>
			break;
81111ef4:	00000806 	br	81111f18 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81111ef8:	d0a05c17 	ldw	r2,-32400(gp)
81111efc:	100f883a 	mov	r7,r2
81111f00:	01800cc4 	movi	r6,51
81111f04:	01400044 	movi	r5,1
81111f08:	01204574 	movhi	r4,33045
81111f0c:	21218404 	addi	r4,r4,-31216
81111f10:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81111f14:	0001883a 	nop
	}
}
81111f18:	0001883a 	nop
81111f1c:	e037883a 	mov	sp,fp
81111f20:	dfc00117 	ldw	ra,4(sp)
81111f24:	df000017 	ldw	fp,0(sp)
81111f28:	dec00204 	addi	sp,sp,8
81111f2c:	f800283a 	ret

81111f30 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111f30:	defffc04 	addi	sp,sp,-16
81111f34:	de00012e 	bgeu	sp,et,81111f3c <vPusType250run+0xc>
81111f38:	003b68fa 	trap	3
81111f3c:	dfc00315 	stw	ra,12(sp)
81111f40:	df000215 	stw	fp,8(sp)
81111f44:	df000204 	addi	fp,sp,8
81111f48:	e13ffe15 	stw	r4,-8(fp)
81111f4c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81111f50:	e0bfff17 	ldw	r2,-4(fp)
81111f54:	1080038b 	ldhu	r2,14(r2)
81111f58:	10bfffcc 	andi	r2,r2,65535
81111f5c:	10c00f20 	cmpeqi	r3,r2,60
81111f60:	1800031e 	bne	r3,zero,81111f70 <vPusType250run+0x40>
81111f64:	10800fa0 	cmpeqi	r2,r2,62
81111f68:	10000d1e 	bne	r2,zero,81111fa0 <vPusType250run+0x70>
81111f6c:	00000406 	br	81111f80 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81111f70:	e0bffe17 	ldw	r2,-8(fp)
81111f74:	00c00044 	movi	r3,1
81111f78:	10c00115 	stw	r3,4(r2)
			break;
81111f7c:	00000906 	br	81111fa4 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81111f80:	d0a05c17 	ldw	r2,-32400(gp)
81111f84:	100f883a 	mov	r7,r2
81111f88:	01800c84 	movi	r6,50
81111f8c:	01400044 	movi	r5,1
81111f90:	01204574 	movhi	r4,33045
81111f94:	21219104 	addi	r4,r4,-31164
81111f98:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81111f9c:	00000106 	br	81111fa4 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81111fa0:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81111fa4:	0001883a 	nop
81111fa8:	e037883a 	mov	sp,fp
81111fac:	dfc00117 	ldw	ra,4(sp)
81111fb0:	df000017 	ldw	fp,0(sp)
81111fb4:	dec00204 	addi	sp,sp,8
81111fb8:	f800283a 	ret

81111fbc <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111fbc:	defffb04 	addi	sp,sp,-20
81111fc0:	de00012e 	bgeu	sp,et,81111fc8 <vPusType251run+0xc>
81111fc4:	003b68fa 	trap	3
81111fc8:	dfc00415 	stw	ra,16(sp)
81111fcc:	df000315 	stw	fp,12(sp)
81111fd0:	df000304 	addi	fp,sp,12
81111fd4:	e13ffe15 	stw	r4,-8(fp)
81111fd8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81111fdc:	e0bfff17 	ldw	r2,-4(fp)
81111fe0:	1080050b 	ldhu	r2,20(r2)
81111fe4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81111fe8:	e0bfff17 	ldw	r2,-4(fp)
81111fec:	1080038b 	ldhu	r2,14(r2)
81111ff0:	10bfffcc 	andi	r2,r2,65535
81111ff4:	10c000a0 	cmpeqi	r3,r2,2
81111ff8:	18000f1e 	bne	r3,zero,81112038 <vPusType251run+0x7c>
81111ffc:	10c00160 	cmpeqi	r3,r2,5
81112000:	1800181e 	bne	r3,zero,81112064 <vPusType251run+0xa8>
81112004:	10800060 	cmpeqi	r2,r2,1
81112008:	10002126 	beq	r2,zero,81112090 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
8111200c:	e0bffd0b 	ldhu	r2,-12(fp)
81112010:	10800444 	addi	r2,r2,17
81112014:	10803fcc 	andi	r2,r2,255
81112018:	e0fffd0b 	ldhu	r3,-12(fp)
8111201c:	18c03fcc 	andi	r3,r3,255
81112020:	180f883a 	mov	r7,r3
81112024:	000d883a 	mov	r6,zero
81112028:	01400044 	movi	r5,1
8111202c:	1009883a 	mov	r4,r2
81112030:	11125680 	call	81112568 <vSendCmdQToNFeeCTRL_GEN>
			break;
81112034:	00002006 	br	811120b8 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81112038:	e0bffd0b 	ldhu	r2,-12(fp)
8111203c:	10800444 	addi	r2,r2,17
81112040:	10803fcc 	andi	r2,r2,255
81112044:	e0fffd0b 	ldhu	r3,-12(fp)
81112048:	18c03fcc 	andi	r3,r3,255
8111204c:	180f883a 	mov	r7,r3
81112050:	000d883a 	mov	r6,zero
81112054:	01400104 	movi	r5,4
81112058:	1009883a 	mov	r4,r2
8111205c:	11125680 	call	81112568 <vSendCmdQToNFeeCTRL_GEN>
			break;
81112060:	00001506 	br	811120b8 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81112064:	e0bffd0b 	ldhu	r2,-12(fp)
81112068:	10800444 	addi	r2,r2,17
8111206c:	10803fcc 	andi	r2,r2,255
81112070:	e0fffd0b 	ldhu	r3,-12(fp)
81112074:	18c03fcc 	andi	r3,r3,255
81112078:	180f883a 	mov	r7,r3
8111207c:	000d883a 	mov	r6,zero
81112080:	01400204 	movi	r5,8
81112084:	1009883a 	mov	r4,r2
81112088:	11125680 	call	81112568 <vSendCmdQToNFeeCTRL_GEN>
			break;
8111208c:	00000a06 	br	811120b8 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81112090:	d0e05c17 	ldw	r3,-32400(gp)
81112094:	e0bfff17 	ldw	r2,-4(fp)
81112098:	1080038b 	ldhu	r2,14(r2)
8111209c:	10bfffcc 	andi	r2,r2,65535
811120a0:	100d883a 	mov	r6,r2
811120a4:	01604574 	movhi	r5,33045
811120a8:	29619e04 	addi	r5,r5,-31112
811120ac:	1809883a 	mov	r4,r3
811120b0:	111ba9c0 	call	8111ba9c <fprintf>
			#endif
			break;
811120b4:	0001883a 	nop
	}
}
811120b8:	0001883a 	nop
811120bc:	e037883a 	mov	sp,fp
811120c0:	dfc00117 	ldw	ra,4(sp)
811120c4:	df000017 	ldw	fp,0(sp)
811120c8:	dec00204 	addi	sp,sp,8
811120cc:	f800283a 	ret

811120d0 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811120d0:	defffb04 	addi	sp,sp,-20
811120d4:	de00012e 	bgeu	sp,et,811120dc <vPusType252run+0xc>
811120d8:	003b68fa 	trap	3
811120dc:	dfc00415 	stw	ra,16(sp)
811120e0:	df000315 	stw	fp,12(sp)
811120e4:	df000304 	addi	fp,sp,12
811120e8:	e13ffe15 	stw	r4,-8(fp)
811120ec:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811120f0:	e0bfff17 	ldw	r2,-4(fp)
811120f4:	1080050b 	ldhu	r2,20(r2)
811120f8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811120fc:	e0bfff17 	ldw	r2,-4(fp)
81112100:	1080038b 	ldhu	r2,14(r2)
81112104:	10bfffcc 	andi	r2,r2,65535
81112108:	10c000e0 	cmpeqi	r3,r2,3
8111210c:	18000a1e 	bne	r3,zero,81112138 <vPusType252run+0x68>
81112110:	10c00108 	cmpgei	r3,r2,4
81112114:	1800031e 	bne	r3,zero,81112124 <vPusType252run+0x54>
81112118:	108000a0 	cmpeqi	r2,r2,2
8111211c:	1000581e 	bne	r2,zero,81112280 <vPusType252run+0x1b0>
81112120:	0000be06 	br	8111241c <vPusType252run+0x34c>
81112124:	10c00120 	cmpeqi	r3,r2,4
81112128:	18002c1e 	bne	r3,zero,811121dc <vPusType252run+0x10c>
8111212c:	10800160 	cmpeqi	r2,r2,5
81112130:	1000c21e 	bne	r2,zero,8111243c <vPusType252run+0x36c>
81112134:	0000b906 	br	8111241c <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112138:	e0bffd0b 	ldhu	r2,-12(fp)
8111213c:	10809524 	muli	r2,r2,596
81112140:	10809a04 	addi	r2,r2,616
81112144:	e0fffe17 	ldw	r3,-8(fp)
81112148:	1885883a 	add	r2,r3,r2
8111214c:	1009883a 	mov	r4,r2
81112150:	11090680 	call	81109068 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81112154:	e0bffd0b 	ldhu	r2,-12(fp)
81112158:	e0fffe17 	ldw	r3,-8(fp)
8111215c:	10809524 	muli	r2,r2,596
81112160:	1885883a 	add	r2,r3,r2
81112164:	10809c04 	addi	r2,r2,624
81112168:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
8111216c:	e0bffd0b 	ldhu	r2,-12(fp)
81112170:	e0fffe17 	ldw	r3,-8(fp)
81112174:	10809524 	muli	r2,r2,596
81112178:	1885883a 	add	r2,r3,r2
8111217c:	10809b04 	addi	r2,r2,620
81112180:	00c00044 	movi	r3,1
81112184:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81112188:	e0bffd0b 	ldhu	r2,-12(fp)
8111218c:	e0fffe17 	ldw	r3,-8(fp)
81112190:	10809524 	muli	r2,r2,596
81112194:	1885883a 	add	r2,r3,r2
81112198:	10809d04 	addi	r2,r2,628
8111219c:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811121a0:	e0bffd0b 	ldhu	r2,-12(fp)
811121a4:	10809524 	muli	r2,r2,596
811121a8:	10809a04 	addi	r2,r2,616
811121ac:	e0fffe17 	ldw	r3,-8(fp)
811121b0:	1885883a 	add	r2,r3,r2
811121b4:	1009883a 	mov	r4,r2
811121b8:	1108f340 	call	81108f34 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
811121bc:	d0a05c17 	ldw	r2,-32400(gp)
811121c0:	e0fffd0b 	ldhu	r3,-12(fp)
811121c4:	180d883a 	mov	r6,r3
811121c8:	01604574 	movhi	r5,33045
811121cc:	2961ac04 	addi	r5,r5,-31056
811121d0:	1009883a 	mov	r4,r2
811121d4:	111ba9c0 	call	8111ba9c <fprintf>
			#endif

			break;
811121d8:	00009906 	br	81112440 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811121dc:	e0bffd0b 	ldhu	r2,-12(fp)
811121e0:	10809524 	muli	r2,r2,596
811121e4:	10809a04 	addi	r2,r2,616
811121e8:	e0fffe17 	ldw	r3,-8(fp)
811121ec:	1885883a 	add	r2,r3,r2
811121f0:	1009883a 	mov	r4,r2
811121f4:	11090680 	call	81109068 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
811121f8:	e0bffd0b 	ldhu	r2,-12(fp)
811121fc:	e0fffe17 	ldw	r3,-8(fp)
81112200:	10809524 	muli	r2,r2,596
81112204:	1885883a 	add	r2,r3,r2
81112208:	10809c04 	addi	r2,r2,624
8111220c:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81112210:	e0bffd0b 	ldhu	r2,-12(fp)
81112214:	e0fffe17 	ldw	r3,-8(fp)
81112218:	10809524 	muli	r2,r2,596
8111221c:	1885883a 	add	r2,r3,r2
81112220:	10809b04 	addi	r2,r2,620
81112224:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81112228:	e0bffd0b 	ldhu	r2,-12(fp)
8111222c:	e0fffe17 	ldw	r3,-8(fp)
81112230:	10809524 	muli	r2,r2,596
81112234:	1885883a 	add	r2,r3,r2
81112238:	10809d04 	addi	r2,r2,628
8111223c:	00c00044 	movi	r3,1
81112240:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112244:	e0bffd0b 	ldhu	r2,-12(fp)
81112248:	10809524 	muli	r2,r2,596
8111224c:	10809a04 	addi	r2,r2,616
81112250:	e0fffe17 	ldw	r3,-8(fp)
81112254:	1885883a 	add	r2,r3,r2
81112258:	1009883a 	mov	r4,r2
8111225c:	1108f340 	call	81108f34 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81112260:	d0a05c17 	ldw	r2,-32400(gp)
81112264:	e0fffd0b 	ldhu	r3,-12(fp)
81112268:	180d883a 	mov	r6,r3
8111226c:	01604574 	movhi	r5,33045
81112270:	2961b504 	addi	r5,r5,-31020
81112274:	1009883a 	mov	r4,r2
81112278:	111ba9c0 	call	8111ba9c <fprintf>
			#endif

			break;
8111227c:	00007006 	br	81112440 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81112280:	e0bffd0b 	ldhu	r2,-12(fp)
81112284:	e0fffe17 	ldw	r3,-8(fp)
81112288:	10809524 	muli	r2,r2,596
8111228c:	1885883a 	add	r2,r3,r2
81112290:	10803e04 	addi	r2,r2,248
81112294:	10800017 	ldw	r2,0(r2)
81112298:	10800058 	cmpnei	r2,r2,1
8111229c:	10004a1e 	bne	r2,zero,811123c8 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811122a0:	e0bffd0b 	ldhu	r2,-12(fp)
811122a4:	10809524 	muli	r2,r2,596
811122a8:	10805404 	addi	r2,r2,336
811122ac:	e0fffe17 	ldw	r3,-8(fp)
811122b0:	1885883a 	add	r2,r3,r2
811122b4:	1009883a 	mov	r4,r2
811122b8:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
811122bc:	e0bffd0b 	ldhu	r2,-12(fp)
811122c0:	e0fffe17 	ldw	r3,-8(fp)
811122c4:	10809524 	muli	r2,r2,596
811122c8:	1885883a 	add	r2,r3,r2
811122cc:	10806404 	addi	r2,r2,400
811122d0:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811122d4:	e0bffd0b 	ldhu	r2,-12(fp)
811122d8:	10809524 	muli	r2,r2,596
811122dc:	10805404 	addi	r2,r2,336
811122e0:	e0fffe17 	ldw	r3,-8(fp)
811122e4:	1885883a 	add	r2,r3,r2
811122e8:	1009883a 	mov	r4,r2
811122ec:	1106a3c0 	call	81106a3c <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811122f0:	e0bffd0b 	ldhu	r2,-12(fp)
811122f4:	10809524 	muli	r2,r2,596
811122f8:	10805404 	addi	r2,r2,336
811122fc:	e0fffe17 	ldw	r3,-8(fp)
81112300:	1885883a 	add	r2,r3,r2
81112304:	1009883a 	mov	r4,r2
81112308:	1106ccc0 	call	81106ccc <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
8111230c:	e0bffd0b 	ldhu	r2,-12(fp)
81112310:	e0ffff17 	ldw	r3,-4(fp)
81112314:	18c00b0b 	ldhu	r3,44(r3)
81112318:	1809883a 	mov	r4,r3
8111231c:	e0fffe17 	ldw	r3,-8(fp)
81112320:	10809524 	muli	r2,r2,596
81112324:	1885883a 	add	r2,r3,r2
81112328:	10805504 	addi	r2,r2,340
8111232c:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81112330:	e0bffd0b 	ldhu	r2,-12(fp)
81112334:	e0ffff17 	ldw	r3,-4(fp)
81112338:	18c0098b 	ldhu	r3,38(r3)
8111233c:	1809883a 	mov	r4,r3
81112340:	e0fffe17 	ldw	r3,-8(fp)
81112344:	10809524 	muli	r2,r2,596
81112348:	1885883a 	add	r2,r3,r2
8111234c:	10805544 	addi	r2,r2,341
81112350:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81112354:	e0bffd0b 	ldhu	r2,-12(fp)
81112358:	10809524 	muli	r2,r2,596
8111235c:	10805404 	addi	r2,r2,336
81112360:	e0fffe17 	ldw	r3,-8(fp)
81112364:	1885883a 	add	r2,r3,r2
81112368:	1009883a 	mov	r4,r2
8111236c:	1106bf40 	call	81106bf4 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112370:	e0bffd0b 	ldhu	r2,-12(fp)
81112374:	10809524 	muli	r2,r2,596
81112378:	10805404 	addi	r2,r2,336
8111237c:	e0fffe17 	ldw	r3,-8(fp)
81112380:	1885883a 	add	r2,r3,r2
81112384:	1009883a 	mov	r4,r2
81112388:	1106ae40 	call	81106ae4 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
8111238c:	e0bffd0b 	ldhu	r2,-12(fp)
81112390:	e0fffe17 	ldw	r3,-8(fp)
81112394:	10809524 	muli	r2,r2,596
81112398:	1885883a 	add	r2,r3,r2
8111239c:	10806404 	addi	r2,r2,400
811123a0:	00c00044 	movi	r3,1
811123a4:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811123a8:	e0bffd0b 	ldhu	r2,-12(fp)
811123ac:	10809524 	muli	r2,r2,596
811123b0:	10805404 	addi	r2,r2,336
811123b4:	e0fffe17 	ldw	r3,-8(fp)
811123b8:	1885883a 	add	r2,r3,r2
811123bc:	1009883a 	mov	r4,r2
811123c0:	1106a3c0 	call	81106a3c <bRmapSetIrqControl>
811123c4:	00000706 	br	811123e4 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
811123c8:	d0a05c17 	ldw	r2,-32400(gp)
811123cc:	e0fffd0b 	ldhu	r3,-12(fp)
811123d0:	180d883a 	mov	r6,r3
811123d4:	01604574 	movhi	r5,33045
811123d8:	2961be04 	addi	r5,r5,-30984
811123dc:	1009883a 	mov	r4,r2
811123e0:	111ba9c0 	call	8111ba9c <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811123e4:	d0e05c17 	ldw	r3,-32400(gp)
811123e8:	e0bfff17 	ldw	r2,-4(fp)
811123ec:	10800b0b 	ldhu	r2,44(r2)
811123f0:	113fffcc 	andi	r4,r2,65535
811123f4:	e0bfff17 	ldw	r2,-4(fp)
811123f8:	1080098b 	ldhu	r2,38(r2)
811123fc:	10bfffcc 	andi	r2,r2,65535
81112400:	100f883a 	mov	r7,r2
81112404:	200d883a 	mov	r6,r4
81112408:	01604574 	movhi	r5,33045
8111240c:	29617404 	addi	r5,r5,-31280
81112410:	1809883a 	mov	r4,r3
81112414:	111ba9c0 	call	8111ba9c <fprintf>
			#endif
			break;
81112418:	00000906 	br	81112440 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
8111241c:	d0a05c17 	ldw	r2,-32400(gp)
81112420:	100f883a 	mov	r7,r2
81112424:	01800c84 	movi	r6,50
81112428:	01400044 	movi	r5,1
8111242c:	01204574 	movhi	r4,33045
81112430:	21219104 	addi	r4,r4,-31164
81112434:	111c1380 	call	8111c138 <fwrite>
			#endif
			break;
81112438:	00000106 	br	81112440 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
8111243c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81112440:	0001883a 	nop
81112444:	e037883a 	mov	sp,fp
81112448:	dfc00117 	ldw	ra,4(sp)
8111244c:	df000017 	ldw	fp,0(sp)
81112450:	dec00204 	addi	sp,sp,8
81112454:	f800283a 	ret

81112458 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112458:	defff904 	addi	sp,sp,-28
8111245c:	de00012e 	bgeu	sp,et,81112464 <vSendCmdQToNFeeCTRL+0xc>
81112460:	003b68fa 	trap	3
81112464:	dfc00615 	stw	ra,24(sp)
81112468:	df000515 	stw	fp,20(sp)
8111246c:	df000504 	addi	fp,sp,20
81112470:	2807883a 	mov	r3,r5
81112474:	3005883a 	mov	r2,r6
81112478:	e13ffd05 	stb	r4,-12(fp)
8111247c:	e0fffe05 	stb	r3,-8(fp)
81112480:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81112484:	00800404 	movi	r2,16
81112488:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111248c:	e0bffd03 	ldbu	r2,-12(fp)
81112490:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112494:	e0bffe03 	ldbu	r2,-8(fp)
81112498:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111249c:	e0bfff03 	ldbu	r2,-4(fp)
811124a0:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811124a4:	d0a06a17 	ldw	r2,-32344(gp)
811124a8:	e0fffc17 	ldw	r3,-16(fp)
811124ac:	180b883a 	mov	r5,r3
811124b0:	1009883a 	mov	r4,r2
811124b4:	11390880 	call	81139088 <OSQPost>
811124b8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811124bc:	e0bffb03 	ldbu	r2,-20(fp)
811124c0:	10000126 	beq	r2,zero,811124c8 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
811124c4:	11188880 	call	81118888 <vFailSendMsgFeeCTRL>
	}
}
811124c8:	0001883a 	nop
811124cc:	e037883a 	mov	sp,fp
811124d0:	dfc00117 	ldw	ra,4(sp)
811124d4:	df000017 	ldw	fp,0(sp)
811124d8:	dec00204 	addi	sp,sp,8
811124dc:	f800283a 	ret

811124e0 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811124e0:	defff904 	addi	sp,sp,-28
811124e4:	de00012e 	bgeu	sp,et,811124ec <vSendCmdQToNFeeCTRL_PRIO+0xc>
811124e8:	003b68fa 	trap	3
811124ec:	dfc00615 	stw	ra,24(sp)
811124f0:	df000515 	stw	fp,20(sp)
811124f4:	df000504 	addi	fp,sp,20
811124f8:	2807883a 	mov	r3,r5
811124fc:	3005883a 	mov	r2,r6
81112500:	e13ffd05 	stb	r4,-12(fp)
81112504:	e0fffe05 	stb	r3,-8(fp)
81112508:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111250c:	00800404 	movi	r2,16
81112510:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112514:	e0bffd03 	ldbu	r2,-12(fp)
81112518:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111251c:	e0bffe03 	ldbu	r2,-8(fp)
81112520:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112524:	e0bfff03 	ldbu	r2,-4(fp)
81112528:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8111252c:	d0a06a17 	ldw	r2,-32344(gp)
81112530:	e0fffc17 	ldw	r3,-16(fp)
81112534:	180b883a 	mov	r5,r3
81112538:	1009883a 	mov	r4,r2
8111253c:	11391f80 	call	811391f8 <OSQPostFront>
81112540:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112544:	e0bffb03 	ldbu	r2,-20(fp)
81112548:	10000126 	beq	r2,zero,81112550 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
8111254c:	11188880 	call	81118888 <vFailSendMsgFeeCTRL>
	}
}
81112550:	0001883a 	nop
81112554:	e037883a 	mov	sp,fp
81112558:	dfc00117 	ldw	ra,4(sp)
8111255c:	df000017 	ldw	fp,0(sp)
81112560:	dec00204 	addi	sp,sp,8
81112564:	f800283a 	ret

81112568 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112568:	defff804 	addi	sp,sp,-32
8111256c:	de00012e 	bgeu	sp,et,81112574 <vSendCmdQToNFeeCTRL_GEN+0xc>
81112570:	003b68fa 	trap	3
81112574:	dfc00715 	stw	ra,28(sp)
81112578:	df000615 	stw	fp,24(sp)
8111257c:	df000604 	addi	fp,sp,24
81112580:	2011883a 	mov	r8,r4
81112584:	2809883a 	mov	r4,r5
81112588:	3007883a 	mov	r3,r6
8111258c:	3805883a 	mov	r2,r7
81112590:	e23ffc05 	stb	r8,-16(fp)
81112594:	e13ffd05 	stb	r4,-12(fp)
81112598:	e0fffe05 	stb	r3,-8(fp)
8111259c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
811125a0:	e0bffc03 	ldbu	r2,-16(fp)
811125a4:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811125a8:	e0bffd03 	ldbu	r2,-12(fp)
811125ac:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811125b0:	e0bffe03 	ldbu	r2,-8(fp)
811125b4:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811125b8:	e0bfff03 	ldbu	r2,-4(fp)
811125bc:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811125c0:	d0a06a17 	ldw	r2,-32344(gp)
811125c4:	e0fffb17 	ldw	r3,-20(fp)
811125c8:	180b883a 	mov	r5,r3
811125cc:	1009883a 	mov	r4,r2
811125d0:	11390880 	call	81139088 <OSQPost>
811125d4:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811125d8:	e0bffa03 	ldbu	r2,-24(fp)
811125dc:	10000126 	beq	r2,zero,811125e4 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
811125e0:	11188880 	call	81118888 <vFailSendMsgFeeCTRL>
	}
}
811125e4:	0001883a 	nop
811125e8:	e037883a 	mov	sp,fp
811125ec:	dfc00117 	ldw	ra,4(sp)
811125f0:	df000017 	ldw	fp,0(sp)
811125f4:	dec00204 	addi	sp,sp,8
811125f8:	f800283a 	ret

811125fc <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811125fc:	defff904 	addi	sp,sp,-28
81112600:	de00012e 	bgeu	sp,et,81112608 <vSendCmdQToDataCTRL+0xc>
81112604:	003b68fa 	trap	3
81112608:	dfc00615 	stw	ra,24(sp)
8111260c:	df000515 	stw	fp,20(sp)
81112610:	df000504 	addi	fp,sp,20
81112614:	2807883a 	mov	r3,r5
81112618:	3005883a 	mov	r2,r6
8111261c:	e13ffd05 	stb	r4,-12(fp)
81112620:	e0fffe05 	stb	r3,-8(fp)
81112624:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81112628:	00800804 	movi	r2,32
8111262c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112630:	e0bffd03 	ldbu	r2,-12(fp)
81112634:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81112638:	e0bffe03 	ldbu	r2,-8(fp)
8111263c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112640:	e0bfff03 	ldbu	r2,-4(fp)
81112644:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81112648:	d0a05917 	ldw	r2,-32412(gp)
8111264c:	e0fffc17 	ldw	r3,-16(fp)
81112650:	180b883a 	mov	r5,r3
81112654:	1009883a 	mov	r4,r2
81112658:	11390880 	call	81139088 <OSQPost>
8111265c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112660:	e0bffb03 	ldbu	r2,-20(fp)
81112664:	10000126 	beq	r2,zero,8111266c <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81112668:	11188d40 	call	811188d4 <vFailSendMsgDataCTRL>
	}
}
8111266c:	0001883a 	nop
81112670:	e037883a 	mov	sp,fp
81112674:	dfc00117 	ldw	ra,4(sp)
81112678:	df000017 	ldw	fp,0(sp)
8111267c:	dec00204 	addi	sp,sp,8
81112680:	f800283a 	ret

81112684 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112684:	defff904 	addi	sp,sp,-28
81112688:	de00012e 	bgeu	sp,et,81112690 <vSendCmdQToDataCTRL_PRIO+0xc>
8111268c:	003b68fa 	trap	3
81112690:	dfc00615 	stw	ra,24(sp)
81112694:	df000515 	stw	fp,20(sp)
81112698:	df000504 	addi	fp,sp,20
8111269c:	2807883a 	mov	r3,r5
811126a0:	3005883a 	mov	r2,r6
811126a4:	e13ffd05 	stb	r4,-12(fp)
811126a8:	e0fffe05 	stb	r3,-8(fp)
811126ac:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811126b0:	00800404 	movi	r2,16
811126b4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811126b8:	e0bffd03 	ldbu	r2,-12(fp)
811126bc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811126c0:	e0bffe03 	ldbu	r2,-8(fp)
811126c4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811126c8:	e0bfff03 	ldbu	r2,-4(fp)
811126cc:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811126d0:	d0a05917 	ldw	r2,-32412(gp)
811126d4:	e0fffc17 	ldw	r3,-16(fp)
811126d8:	180b883a 	mov	r5,r3
811126dc:	1009883a 	mov	r4,r2
811126e0:	11391f80 	call	811391f8 <OSQPostFront>
811126e4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811126e8:	e0bffb03 	ldbu	r2,-20(fp)
811126ec:	10000126 	beq	r2,zero,811126f4 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811126f0:	11188880 	call	81118888 <vFailSendMsgFeeCTRL>
	}
}
811126f4:	0001883a 	nop
811126f8:	e037883a 	mov	sp,fp
811126fc:	dfc00117 	ldw	ra,4(sp)
81112700:	df000017 	ldw	fp,0(sp)
81112704:	dec00204 	addi	sp,sp,8
81112708:	f800283a 	ret

8111270c <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
8111270c:	defffc04 	addi	sp,sp,-16
81112710:	de00012e 	bgeu	sp,et,81112718 <vMebInit+0xc>
81112714:	003b68fa 	trap	3
81112718:	dfc00315 	stw	ra,12(sp)
8111271c:	df000215 	stw	fp,8(sp)
81112720:	df000204 	addi	fp,sp,8
81112724:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81112728:	e0bfff17 	ldw	r2,-4(fp)
8111272c:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81112730:	e0bfff17 	ldw	r2,-4(fp)
81112734:	00c00044 	movi	r3,1
81112738:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
8111273c:	d0a06317 	ldw	r2,-32372(gp)
81112740:	1009883a 	mov	r4,r2
81112744:	1138bc00 	call	81138bc0 <OSQFlush>
81112748:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
8111274c:	e0bffe03 	ldbu	r2,-8(fp)
81112750:	10000126 	beq	r2,zero,81112758 <vMebInit+0x4c>
		vFailFlushMEBQueue();
81112754:	11189b80 	call	811189b8 <vFailFlushMEBQueue>
	}
}
81112758:	0001883a 	nop
8111275c:	e037883a 	mov	sp,fp
81112760:	dfc00117 	ldw	ra,4(sp)
81112764:	df000017 	ldw	fp,0(sp)
81112768:	dec00204 	addi	sp,sp,8
8111276c:	f800283a 	ret

81112770 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81112770:	defffe04 	addi	sp,sp,-8
81112774:	de00012e 	bgeu	sp,et,8111277c <vSwapMemmory+0xc>
81112778:	003b68fa 	trap	3
8111277c:	df000115 	stw	fp,4(sp)
81112780:	df000104 	addi	fp,sp,4
81112784:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81112788:	e0bfff17 	ldw	r2,-4(fp)
8111278c:	10800203 	ldbu	r2,8(r2)
81112790:	10803fcc 	andi	r2,r2,255
81112794:	10c00044 	addi	r3,r2,1
81112798:	00a00034 	movhi	r2,32768
8111279c:	10800044 	addi	r2,r2,1
811127a0:	1884703a 	and	r2,r3,r2
811127a4:	1000040e 	bge	r2,zero,811127b8 <vSwapMemmory+0x48>
811127a8:	10bfffc4 	addi	r2,r2,-1
811127ac:	00ffff84 	movi	r3,-2
811127b0:	10c4b03a 	or	r2,r2,r3
811127b4:	10800044 	addi	r2,r2,1
811127b8:	1007883a 	mov	r3,r2
811127bc:	e0bfff17 	ldw	r2,-4(fp)
811127c0:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
811127c4:	e0bfff17 	ldw	r2,-4(fp)
811127c8:	10800243 	ldbu	r2,9(r2)
811127cc:	10803fcc 	andi	r2,r2,255
811127d0:	10c00044 	addi	r3,r2,1
811127d4:	00a00034 	movhi	r2,32768
811127d8:	10800044 	addi	r2,r2,1
811127dc:	1884703a 	and	r2,r3,r2
811127e0:	1000040e 	bge	r2,zero,811127f4 <vSwapMemmory+0x84>
811127e4:	10bfffc4 	addi	r2,r2,-1
811127e8:	00ffff84 	movi	r3,-2
811127ec:	10c4b03a 	or	r2,r2,r3
811127f0:	10800044 	addi	r2,r2,1
811127f4:	1007883a 	mov	r3,r2
811127f8:	e0bfff17 	ldw	r2,-4(fp)
811127fc:	10c00245 	stb	r3,9(r2)

}
81112800:	0001883a 	nop
81112804:	e037883a 	mov	sp,fp
81112808:	df000017 	ldw	fp,0(sp)
8111280c:	dec00104 	addi	sp,sp,4
81112810:	f800283a 	ret

81112814 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81112814:	defffc04 	addi	sp,sp,-16
81112818:	de00012e 	bgeu	sp,et,81112820 <vReleaseSyncMessages+0xc>
8111281c:	003b68fa 	trap	3
81112820:	dfc00315 	stw	ra,12(sp)
81112824:	df000215 	stw	fp,8(sp)
81112828:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
8111282c:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81112830:	00bff844 	movi	r2,-31
81112834:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81112838:	e03ffe05 	stb	zero,-8(fp)
8111283c:	00001606 	br	81112898 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
81112840:	e0bffe03 	ldbu	r2,-8(fp)
81112844:	10800444 	addi	r2,r2,17
81112848:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8111284c:	e0bffe03 	ldbu	r2,-8(fp)
81112850:	1085883a 	add	r2,r2,r2
81112854:	1087883a 	add	r3,r2,r2
81112858:	d0a05604 	addi	r2,gp,-32424
8111285c:	1885883a 	add	r2,r3,r2
81112860:	10800017 	ldw	r2,0(r2)
81112864:	e0ffff17 	ldw	r3,-4(fp)
81112868:	180b883a 	mov	r5,r3
8111286c:	1009883a 	mov	r4,r2
81112870:	11390880 	call	81139088 <OSQPost>
81112874:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81112878:	e0bffe43 	ldbu	r2,-7(fp)
8111287c:	10000326 	beq	r2,zero,8111288c <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81112880:	e0bffe03 	ldbu	r2,-8(fp)
81112884:	1009883a 	mov	r4,r2
81112888:	11187e80 	call	811187e8 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8111288c:	e0bffe03 	ldbu	r2,-8(fp)
81112890:	10800044 	addi	r2,r2,1
81112894:	e0bffe05 	stb	r2,-8(fp)
81112898:	e0bffe03 	ldbu	r2,-8(fp)
8111289c:	103fe826 	beq	r2,zero,81112840 <__reset+0xfb0f2840>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
811128a0:	0001883a 	nop
811128a4:	e037883a 	mov	sp,fp
811128a8:	dfc00117 	ldw	ra,4(sp)
811128ac:	df000017 	ldw	fp,0(sp)
811128b0:	dec00204 	addi	sp,sp,8
811128b4:	f800283a 	ret

811128b8 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
811128b8:	defff804 	addi	sp,sp,-32
811128bc:	de00012e 	bgeu	sp,et,811128c4 <vStackMonitor+0xc>
811128c0:	003b68fa 	trap	3
811128c4:	dfc00715 	stw	ra,28(sp)
811128c8:	df000615 	stw	fp,24(sp)
811128cc:	df000604 	addi	fp,sp,24
811128d0:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811128d4:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
811128d8:	d0a05c17 	ldw	r2,-32400(gp)
811128dc:	100f883a 	mov	r7,r2
811128e0:	018006c4 	movi	r6,27
811128e4:	01400044 	movi	r5,1
811128e8:	01204574 	movhi	r4,33045
811128ec:	2121d104 	addi	r4,r4,-30908
811128f0:	111c1380 	call	8111c138 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
811128f4:	d0a05c17 	ldw	r2,-32400(gp)
811128f8:	100f883a 	mov	r7,r2
811128fc:	01800b04 	movi	r6,44
81112900:	01400044 	movi	r5,1
81112904:	01204574 	movhi	r4,33045
81112908:	2121d804 	addi	r4,r4,-30880
8111290c:	111c1380 	call	8111c138 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81112910:	d0a05c17 	ldw	r2,-32400(gp)
81112914:	100f883a 	mov	r7,r2
81112918:	01800f84 	movi	r6,62
8111291c:	01400044 	movi	r5,1
81112920:	01204574 	movhi	r4,33045
81112924:	2121e404 	addi	r4,r4,-30832
81112928:	111c1380 	call	8111c138 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
8111292c:	e0bffd04 	addi	r2,fp,-12
81112930:	100b883a 	mov	r5,r2
81112934:	01000804 	movi	r4,32
81112938:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
8111293c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81112940:	e0bffc03 	ldbu	r2,-16(fp)
81112944:	10000f1e 	bne	r2,zero,81112984 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112948:	d1205c17 	ldw	r4,-32400(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
8111294c:	e0fffd17 	ldw	r3,-12(fp)
81112950:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112954:	188b883a 	add	r5,r3,r2
81112958:	e0bffd17 	ldw	r2,-12(fp)
8111295c:	e0fffe17 	ldw	r3,-8(fp)
81112960:	d8c00115 	stw	r3,4(sp)
81112964:	d8800015 	stw	r2,0(sp)
81112968:	280f883a 	mov	r7,r5
8111296c:	01a04574 	movhi	r6,33045
81112970:	31a1f404 	addi	r6,r6,-30768
81112974:	01604574 	movhi	r5,33045
81112978:	2961f804 	addi	r5,r5,-30752
8111297c:	111ba9c0 	call	8111ba9c <fprintf>
81112980:	00000706 	br	811129a0 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81112984:	d0a05c17 	ldw	r2,-32400(gp)
81112988:	100f883a 	mov	r7,r2
8111298c:	01800904 	movi	r6,36
81112990:	01400044 	movi	r5,1
81112994:	01204574 	movhi	r4,33045
81112998:	21220704 	addi	r4,r4,-30692
8111299c:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
811129a0:	e0bffd04 	addi	r2,fp,-12
811129a4:	100b883a 	mov	r5,r2
811129a8:	01000784 	movi	r4,30
811129ac:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
811129b0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811129b4:	e0bffc03 	ldbu	r2,-16(fp)
811129b8:	10000f1e 	bne	r2,zero,811129f8 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811129bc:	d1205c17 	ldw	r4,-32400(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
811129c0:	e0fffd17 	ldw	r3,-12(fp)
811129c4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811129c8:	188b883a 	add	r5,r3,r2
811129cc:	e0bffd17 	ldw	r2,-12(fp)
811129d0:	e0fffe17 	ldw	r3,-8(fp)
811129d4:	d8c00115 	stw	r3,4(sp)
811129d8:	d8800015 	stw	r2,0(sp)
811129dc:	280f883a 	mov	r7,r5
811129e0:	01a04574 	movhi	r6,33045
811129e4:	31a21104 	addi	r6,r6,-30652
811129e8:	01604574 	movhi	r5,33045
811129ec:	2961f804 	addi	r5,r5,-30752
811129f0:	111ba9c0 	call	8111ba9c <fprintf>
811129f4:	00000706 	br	81112a14 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
811129f8:	d0a05c17 	ldw	r2,-32400(gp)
811129fc:	100f883a 	mov	r7,r2
81112a00:	01800984 	movi	r6,38
81112a04:	01400044 	movi	r5,1
81112a08:	01204574 	movhi	r4,33045
81112a0c:	21221504 	addi	r4,r4,-30636
81112a10:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81112a14:	e0bffd04 	addi	r2,fp,-12
81112a18:	100b883a 	mov	r5,r2
81112a1c:	01000704 	movi	r4,28
81112a20:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112a24:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112a28:	e0bffc03 	ldbu	r2,-16(fp)
81112a2c:	10000f1e 	bne	r2,zero,81112a6c <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112a30:	d1205c17 	ldw	r4,-32400(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81112a34:	e0fffd17 	ldw	r3,-12(fp)
81112a38:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112a3c:	188b883a 	add	r5,r3,r2
81112a40:	e0bffd17 	ldw	r2,-12(fp)
81112a44:	e0fffe17 	ldw	r3,-8(fp)
81112a48:	d8c00115 	stw	r3,4(sp)
81112a4c:	d8800015 	stw	r2,0(sp)
81112a50:	280f883a 	mov	r7,r5
81112a54:	01a04574 	movhi	r6,33045
81112a58:	31a21f04 	addi	r6,r6,-30596
81112a5c:	01604574 	movhi	r5,33045
81112a60:	2961f804 	addi	r5,r5,-30752
81112a64:	111ba9c0 	call	8111ba9c <fprintf>
81112a68:	00000706 	br	81112a88 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81112a6c:	d0a05c17 	ldw	r2,-32400(gp)
81112a70:	100f883a 	mov	r7,r2
81112a74:	01800884 	movi	r6,34
81112a78:	01400044 	movi	r5,1
81112a7c:	01204574 	movhi	r4,33045
81112a80:	21222204 	addi	r4,r4,-30584
81112a84:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81112a88:	e0bffd04 	addi	r2,fp,-12
81112a8c:	100b883a 	mov	r5,r2
81112a90:	010006c4 	movi	r4,27
81112a94:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112a98:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112a9c:	e0bffc03 	ldbu	r2,-16(fp)
81112aa0:	10000f1e 	bne	r2,zero,81112ae0 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112aa4:	d1205c17 	ldw	r4,-32400(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81112aa8:	e0fffd17 	ldw	r3,-12(fp)
81112aac:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112ab0:	188b883a 	add	r5,r3,r2
81112ab4:	e0bffd17 	ldw	r2,-12(fp)
81112ab8:	e0fffe17 	ldw	r3,-8(fp)
81112abc:	d8c00115 	stw	r3,4(sp)
81112ac0:	d8800015 	stw	r2,0(sp)
81112ac4:	280f883a 	mov	r7,r5
81112ac8:	01a04574 	movhi	r6,33045
81112acc:	31a22b04 	addi	r6,r6,-30548
81112ad0:	01604574 	movhi	r5,33045
81112ad4:	2961f804 	addi	r5,r5,-30752
81112ad8:	111ba9c0 	call	8111ba9c <fprintf>
81112adc:	00000706 	br	81112afc <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81112ae0:	d0a05c17 	ldw	r2,-32400(gp)
81112ae4:	100f883a 	mov	r7,r2
81112ae8:	018008c4 	movi	r6,35
81112aec:	01400044 	movi	r5,1
81112af0:	01204574 	movhi	r4,33045
81112af4:	21222f04 	addi	r4,r4,-30532
81112af8:	111c1380 	call	8111c138 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81112afc:	e0bffd04 	addi	r2,fp,-12
81112b00:	100b883a 	mov	r5,r2
81112b04:	01000684 	movi	r4,26
81112b08:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112b0c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112b10:	e0bffc03 	ldbu	r2,-16(fp)
81112b14:	10000f1e 	bne	r2,zero,81112b54 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112b18:	d1205c17 	ldw	r4,-32400(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81112b1c:	e0fffd17 	ldw	r3,-12(fp)
81112b20:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112b24:	188b883a 	add	r5,r3,r2
81112b28:	e0bffd17 	ldw	r2,-12(fp)
81112b2c:	e0fffe17 	ldw	r3,-8(fp)
81112b30:	d8c00115 	stw	r3,4(sp)
81112b34:	d8800015 	stw	r2,0(sp)
81112b38:	280f883a 	mov	r7,r5
81112b3c:	01a04574 	movhi	r6,33045
81112b40:	31a23804 	addi	r6,r6,-30496
81112b44:	01604574 	movhi	r5,33045
81112b48:	2961f804 	addi	r5,r5,-30752
81112b4c:	111ba9c0 	call	8111ba9c <fprintf>
81112b50:	00000706 	br	81112b70 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81112b54:	d0a05c17 	ldw	r2,-32400(gp)
81112b58:	100f883a 	mov	r7,r2
81112b5c:	01800884 	movi	r6,34
81112b60:	01400044 	movi	r5,1
81112b64:	01204574 	movhi	r4,33045
81112b68:	21223b04 	addi	r4,r4,-30484
81112b6c:	111c1380 	call	8111c138 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81112b70:	e0bffd04 	addi	r2,fp,-12
81112b74:	100b883a 	mov	r5,r2
81112b78:	01000644 	movi	r4,25
81112b7c:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112b80:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112b84:	e0bffc03 	ldbu	r2,-16(fp)
81112b88:	10000f1e 	bne	r2,zero,81112bc8 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112b8c:	d1205c17 	ldw	r4,-32400(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81112b90:	e0fffd17 	ldw	r3,-12(fp)
81112b94:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112b98:	188b883a 	add	r5,r3,r2
81112b9c:	e0bffd17 	ldw	r2,-12(fp)
81112ba0:	e0fffe17 	ldw	r3,-8(fp)
81112ba4:	d8c00115 	stw	r3,4(sp)
81112ba8:	d8800015 	stw	r2,0(sp)
81112bac:	280f883a 	mov	r7,r5
81112bb0:	01a04574 	movhi	r6,33045
81112bb4:	31a24404 	addi	r6,r6,-30448
81112bb8:	01604574 	movhi	r5,33045
81112bbc:	2961f804 	addi	r5,r5,-30752
81112bc0:	111ba9c0 	call	8111ba9c <fprintf>
81112bc4:	00000706 	br	81112be4 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81112bc8:	d0a05c17 	ldw	r2,-32400(gp)
81112bcc:	100f883a 	mov	r7,r2
81112bd0:	01800884 	movi	r6,34
81112bd4:	01400044 	movi	r5,1
81112bd8:	01204574 	movhi	r4,33045
81112bdc:	21224704 	addi	r4,r4,-30436
81112be0:	111c1380 	call	8111c138 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81112be4:	e0bffd04 	addi	r2,fp,-12
81112be8:	100b883a 	mov	r5,r2
81112bec:	01000044 	movi	r4,1
81112bf0:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112bf4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112bf8:	e0bffc03 	ldbu	r2,-16(fp)
81112bfc:	10000f1e 	bne	r2,zero,81112c3c <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112c00:	d1205c17 	ldw	r4,-32400(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81112c04:	e0fffd17 	ldw	r3,-12(fp)
81112c08:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112c0c:	188b883a 	add	r5,r3,r2
81112c10:	e0bffd17 	ldw	r2,-12(fp)
81112c14:	e0fffe17 	ldw	r3,-8(fp)
81112c18:	d8c00115 	stw	r3,4(sp)
81112c1c:	d8800015 	stw	r2,0(sp)
81112c20:	280f883a 	mov	r7,r5
81112c24:	01a04574 	movhi	r6,33045
81112c28:	31a25004 	addi	r6,r6,-30400
81112c2c:	01604574 	movhi	r5,33045
81112c30:	2961f804 	addi	r5,r5,-30752
81112c34:	111ba9c0 	call	8111ba9c <fprintf>
81112c38:	00000706 	br	81112c58 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81112c3c:	d0a05c17 	ldw	r2,-32400(gp)
81112c40:	100f883a 	mov	r7,r2
81112c44:	01800804 	movi	r6,32
81112c48:	01400044 	movi	r5,1
81112c4c:	01204574 	movhi	r4,33045
81112c50:	21225304 	addi	r4,r4,-30388
81112c54:	111c1380 	call	8111c138 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81112c58:	e0bffd04 	addi	r2,fp,-12
81112c5c:	100b883a 	mov	r5,r2
81112c60:	01000244 	movi	r4,9
81112c64:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112c68:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112c6c:	e0bffc03 	ldbu	r2,-16(fp)
81112c70:	10000f1e 	bne	r2,zero,81112cb0 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112c74:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81112c78:	e0fffd17 	ldw	r3,-12(fp)
81112c7c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112c80:	188b883a 	add	r5,r3,r2
81112c84:	e0bffd17 	ldw	r2,-12(fp)
81112c88:	e0fffe17 	ldw	r3,-8(fp)
81112c8c:	d8c00115 	stw	r3,4(sp)
81112c90:	d8800015 	stw	r2,0(sp)
81112c94:	280f883a 	mov	r7,r5
81112c98:	01a04574 	movhi	r6,33045
81112c9c:	31a25c04 	addi	r6,r6,-30352
81112ca0:	01604574 	movhi	r5,33045
81112ca4:	2961f804 	addi	r5,r5,-30752
81112ca8:	111ba9c0 	call	8111ba9c <fprintf>
81112cac:	00000706 	br	81112ccc <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81112cb0:	d0a05c17 	ldw	r2,-32400(gp)
81112cb4:	100f883a 	mov	r7,r2
81112cb8:	018008c4 	movi	r6,35
81112cbc:	01400044 	movi	r5,1
81112cc0:	01204574 	movhi	r4,33045
81112cc4:	21225f04 	addi	r4,r4,-30340
81112cc8:	111c1380 	call	8111c138 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81112ccc:	e0bffd04 	addi	r2,fp,-12
81112cd0:	100b883a 	mov	r5,r2
81112cd4:	01000284 	movi	r4,10
81112cd8:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112cdc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112ce0:	e0bffc03 	ldbu	r2,-16(fp)
81112ce4:	10000f1e 	bne	r2,zero,81112d24 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112ce8:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81112cec:	e0fffd17 	ldw	r3,-12(fp)
81112cf0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112cf4:	188b883a 	add	r5,r3,r2
81112cf8:	e0bffd17 	ldw	r2,-12(fp)
81112cfc:	e0fffe17 	ldw	r3,-8(fp)
81112d00:	d8c00115 	stw	r3,4(sp)
81112d04:	d8800015 	stw	r2,0(sp)
81112d08:	280f883a 	mov	r7,r5
81112d0c:	01a04574 	movhi	r6,33045
81112d10:	31a26804 	addi	r6,r6,-30304
81112d14:	01604574 	movhi	r5,33045
81112d18:	2961f804 	addi	r5,r5,-30752
81112d1c:	111ba9c0 	call	8111ba9c <fprintf>
81112d20:	00000706 	br	81112d40 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81112d24:	d0a05c17 	ldw	r2,-32400(gp)
81112d28:	100f883a 	mov	r7,r2
81112d2c:	018008c4 	movi	r6,35
81112d30:	01400044 	movi	r5,1
81112d34:	01204574 	movhi	r4,33045
81112d38:	21226b04 	addi	r4,r4,-30292
81112d3c:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81112d40:	e0bffd04 	addi	r2,fp,-12
81112d44:	100b883a 	mov	r5,r2
81112d48:	010002c4 	movi	r4,11
81112d4c:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112d50:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112d54:	e0bffc03 	ldbu	r2,-16(fp)
81112d58:	10000f1e 	bne	r2,zero,81112d98 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112d5c:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81112d60:	e0fffd17 	ldw	r3,-12(fp)
81112d64:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112d68:	188b883a 	add	r5,r3,r2
81112d6c:	e0bffd17 	ldw	r2,-12(fp)
81112d70:	e0fffe17 	ldw	r3,-8(fp)
81112d74:	d8c00115 	stw	r3,4(sp)
81112d78:	d8800015 	stw	r2,0(sp)
81112d7c:	280f883a 	mov	r7,r5
81112d80:	01a04574 	movhi	r6,33045
81112d84:	31a27404 	addi	r6,r6,-30256
81112d88:	01604574 	movhi	r5,33045
81112d8c:	2961f804 	addi	r5,r5,-30752
81112d90:	111ba9c0 	call	8111ba9c <fprintf>
81112d94:	00000706 	br	81112db4 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81112d98:	d0a05c17 	ldw	r2,-32400(gp)
81112d9c:	100f883a 	mov	r7,r2
81112da0:	018008c4 	movi	r6,35
81112da4:	01400044 	movi	r5,1
81112da8:	01204574 	movhi	r4,33045
81112dac:	21227704 	addi	r4,r4,-30244
81112db0:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81112db4:	e0bffd04 	addi	r2,fp,-12
81112db8:	100b883a 	mov	r5,r2
81112dbc:	01000304 	movi	r4,12
81112dc0:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112dc4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112dc8:	e0bffc03 	ldbu	r2,-16(fp)
81112dcc:	10000f1e 	bne	r2,zero,81112e0c <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112dd0:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81112dd4:	e0fffd17 	ldw	r3,-12(fp)
81112dd8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112ddc:	188b883a 	add	r5,r3,r2
81112de0:	e0bffd17 	ldw	r2,-12(fp)
81112de4:	e0fffe17 	ldw	r3,-8(fp)
81112de8:	d8c00115 	stw	r3,4(sp)
81112dec:	d8800015 	stw	r2,0(sp)
81112df0:	280f883a 	mov	r7,r5
81112df4:	01a04574 	movhi	r6,33045
81112df8:	31a28004 	addi	r6,r6,-30208
81112dfc:	01604574 	movhi	r5,33045
81112e00:	2961f804 	addi	r5,r5,-30752
81112e04:	111ba9c0 	call	8111ba9c <fprintf>
81112e08:	00000706 	br	81112e28 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81112e0c:	d0a05c17 	ldw	r2,-32400(gp)
81112e10:	100f883a 	mov	r7,r2
81112e14:	018008c4 	movi	r6,35
81112e18:	01400044 	movi	r5,1
81112e1c:	01204574 	movhi	r4,33045
81112e20:	21228304 	addi	r4,r4,-30196
81112e24:	111c1380 	call	8111c138 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81112e28:	e0bffd04 	addi	r2,fp,-12
81112e2c:	100b883a 	mov	r5,r2
81112e30:	01000344 	movi	r4,13
81112e34:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112e38:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112e3c:	e0bffc03 	ldbu	r2,-16(fp)
81112e40:	10000f1e 	bne	r2,zero,81112e80 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112e44:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81112e48:	e0fffd17 	ldw	r3,-12(fp)
81112e4c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112e50:	188b883a 	add	r5,r3,r2
81112e54:	e0bffd17 	ldw	r2,-12(fp)
81112e58:	e0fffe17 	ldw	r3,-8(fp)
81112e5c:	d8c00115 	stw	r3,4(sp)
81112e60:	d8800015 	stw	r2,0(sp)
81112e64:	280f883a 	mov	r7,r5
81112e68:	01a04574 	movhi	r6,33045
81112e6c:	31a28c04 	addi	r6,r6,-30160
81112e70:	01604574 	movhi	r5,33045
81112e74:	2961f804 	addi	r5,r5,-30752
81112e78:	111ba9c0 	call	8111ba9c <fprintf>
81112e7c:	00000706 	br	81112e9c <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81112e80:	d0a05c17 	ldw	r2,-32400(gp)
81112e84:	100f883a 	mov	r7,r2
81112e88:	018008c4 	movi	r6,35
81112e8c:	01400044 	movi	r5,1
81112e90:	01204574 	movhi	r4,33045
81112e94:	21228f04 	addi	r4,r4,-30148
81112e98:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81112e9c:	e0bffd04 	addi	r2,fp,-12
81112ea0:	100b883a 	mov	r5,r2
81112ea4:	01000384 	movi	r4,14
81112ea8:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112eac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112eb0:	e0bffc03 	ldbu	r2,-16(fp)
81112eb4:	10000f1e 	bne	r2,zero,81112ef4 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112eb8:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81112ebc:	e0fffd17 	ldw	r3,-12(fp)
81112ec0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112ec4:	188b883a 	add	r5,r3,r2
81112ec8:	e0bffd17 	ldw	r2,-12(fp)
81112ecc:	e0fffe17 	ldw	r3,-8(fp)
81112ed0:	d8c00115 	stw	r3,4(sp)
81112ed4:	d8800015 	stw	r2,0(sp)
81112ed8:	280f883a 	mov	r7,r5
81112edc:	01a04574 	movhi	r6,33045
81112ee0:	31a29804 	addi	r6,r6,-30112
81112ee4:	01604574 	movhi	r5,33045
81112ee8:	2961f804 	addi	r5,r5,-30752
81112eec:	111ba9c0 	call	8111ba9c <fprintf>
81112ef0:	00000706 	br	81112f10 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81112ef4:	d0a05c17 	ldw	r2,-32400(gp)
81112ef8:	100f883a 	mov	r7,r2
81112efc:	018008c4 	movi	r6,35
81112f00:	01400044 	movi	r5,1
81112f04:	01204574 	movhi	r4,33045
81112f08:	21229b04 	addi	r4,r4,-30100
81112f0c:	111c1380 	call	8111c138 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81112f10:	e0bffd04 	addi	r2,fp,-12
81112f14:	100b883a 	mov	r5,r2
81112f18:	01000204 	movi	r4,8
81112f1c:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112f20:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112f24:	e0bffc03 	ldbu	r2,-16(fp)
81112f28:	10000f1e 	bne	r2,zero,81112f68 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112f2c:	d1205c17 	ldw	r4,-32400(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81112f30:	e0fffd17 	ldw	r3,-12(fp)
81112f34:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112f38:	188b883a 	add	r5,r3,r2
81112f3c:	e0bffd17 	ldw	r2,-12(fp)
81112f40:	e0fffe17 	ldw	r3,-8(fp)
81112f44:	d8c00115 	stw	r3,4(sp)
81112f48:	d8800015 	stw	r2,0(sp)
81112f4c:	280f883a 	mov	r7,r5
81112f50:	01a04574 	movhi	r6,33045
81112f54:	31a2a404 	addi	r6,r6,-30064
81112f58:	01604574 	movhi	r5,33045
81112f5c:	2961f804 	addi	r5,r5,-30752
81112f60:	111ba9c0 	call	8111ba9c <fprintf>
81112f64:	00000706 	br	81112f84 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81112f68:	d0a05c17 	ldw	r2,-32400(gp)
81112f6c:	100f883a 	mov	r7,r2
81112f70:	01800884 	movi	r6,34
81112f74:	01400044 	movi	r5,1
81112f78:	01204574 	movhi	r4,33045
81112f7c:	2122a704 	addi	r4,r4,-30052
81112f80:	111c1380 	call	8111c138 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81112f84:	e0bffd04 	addi	r2,fp,-12
81112f88:	100b883a 	mov	r5,r2
81112f8c:	010001c4 	movi	r4,7
81112f90:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81112f94:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112f98:	e0bffc03 	ldbu	r2,-16(fp)
81112f9c:	10000f1e 	bne	r2,zero,81112fdc <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112fa0:	d1205c17 	ldw	r4,-32400(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81112fa4:	e0fffd17 	ldw	r3,-12(fp)
81112fa8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112fac:	188b883a 	add	r5,r3,r2
81112fb0:	e0bffd17 	ldw	r2,-12(fp)
81112fb4:	e0fffe17 	ldw	r3,-8(fp)
81112fb8:	d8c00115 	stw	r3,4(sp)
81112fbc:	d8800015 	stw	r2,0(sp)
81112fc0:	280f883a 	mov	r7,r5
81112fc4:	01a04574 	movhi	r6,33045
81112fc8:	31a2b004 	addi	r6,r6,-30016
81112fcc:	01604574 	movhi	r5,33045
81112fd0:	2961f804 	addi	r5,r5,-30752
81112fd4:	111ba9c0 	call	8111ba9c <fprintf>
81112fd8:	00000706 	br	81112ff8 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81112fdc:	d0a05c17 	ldw	r2,-32400(gp)
81112fe0:	100f883a 	mov	r7,r2
81112fe4:	01800844 	movi	r6,33
81112fe8:	01400044 	movi	r5,1
81112fec:	01204574 	movhi	r4,33045
81112ff0:	2122b304 	addi	r4,r4,-30004
81112ff4:	111c1380 	call	8111c138 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81112ff8:	e0bffd04 	addi	r2,fp,-12
81112ffc:	100b883a 	mov	r5,r2
81113000:	01000184 	movi	r4,6
81113004:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81113008:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111300c:	e0bffc03 	ldbu	r2,-16(fp)
81113010:	10000f1e 	bne	r2,zero,81113050 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113014:	d1205c17 	ldw	r4,-32400(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81113018:	e0fffd17 	ldw	r3,-12(fp)
8111301c:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113020:	188b883a 	add	r5,r3,r2
81113024:	e0bffd17 	ldw	r2,-12(fp)
81113028:	e0fffe17 	ldw	r3,-8(fp)
8111302c:	d8c00115 	stw	r3,4(sp)
81113030:	d8800015 	stw	r2,0(sp)
81113034:	280f883a 	mov	r7,r5
81113038:	01a04574 	movhi	r6,33045
8111303c:	31a2bc04 	addi	r6,r6,-29968
81113040:	01604574 	movhi	r5,33045
81113044:	2961f804 	addi	r5,r5,-30752
81113048:	111ba9c0 	call	8111ba9c <fprintf>
8111304c:	00000706 	br	8111306c <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81113050:	d0a05c17 	ldw	r2,-32400(gp)
81113054:	100f883a 	mov	r7,r2
81113058:	018007c4 	movi	r6,31
8111305c:	01400044 	movi	r5,1
81113060:	01204574 	movhi	r4,33045
81113064:	2122bf04 	addi	r4,r4,-29956
81113068:	111c1380 	call	8111c138 <fwrite>
    	}		


    	fprintf(fp, "\n" );
8111306c:	d0a05c17 	ldw	r2,-32400(gp)
81113070:	100b883a 	mov	r5,r2
81113074:	01000284 	movi	r4,10
81113078:	111bb140 	call	8111bb14 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
8111307c:	000f883a 	mov	r7,zero
81113080:	01800284 	movi	r6,10
81113084:	000b883a 	mov	r5,zero
81113088:	0009883a 	mov	r4,zero
8111308c:	113b95c0 	call	8113b95c <OSTimeDlyHMSM>
    }
81113090:	003e1806 	br	811128f4 <__reset+0xfb0f28f4>

81113094 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81113094:	defffc04 	addi	sp,sp,-16
81113098:	de00012e 	bgeu	sp,et,811130a0 <vTimeoutCheckerTaskv2+0xc>
8111309c:	003b68fa 	trap	3
811130a0:	dfc00315 	stw	ra,12(sp)
811130a4:	df000215 	stw	fp,8(sp)
811130a8:	df000204 	addi	fp,sp,8
811130ac:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811130b0:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
811130b4:	d0a05c17 	ldw	r2,-32400(gp)
811130b8:	100f883a 	mov	r7,r2
811130bc:	01800844 	movi	r6,33
811130c0:	01400044 	movi	r5,1
811130c4:	01204574 	movhi	r4,33045
811130c8:	2122c704 	addi	r4,r4,-29924
811130cc:	111c1380 	call	8111c138 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
811130d0:	d0a06117 	ldw	r2,-32380(gp)
811130d4:	e1bffe04 	addi	r6,fp,-8
811130d8:	000b883a 	mov	r5,zero
811130dc:	1009883a 	mov	r4,r2
811130e0:	1139b780 	call	81139b78 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
811130e4:	e0bffe03 	ldbu	r2,-8(fp)
811130e8:	10803fcc 	andi	r2,r2,255
811130ec:	1000021e 	bne	r2,zero,811130f8 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
811130f0:	11131000 	call	81113100 <vCheck>
811130f4:	003ff606 	br	811130d0 <__reset+0xfb0f30d0>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
811130f8:	11179fc0 	call	811179fc <vFailGetBlockingSemTimeoutTask>
        }
    }
811130fc:	003ff406 	br	811130d0 <__reset+0xfb0f30d0>

81113100 <vCheck>:
}


void vCheck( void ) {
81113100:	defffd04 	addi	sp,sp,-12
81113104:	de00012e 	bgeu	sp,et,8111310c <vCheck+0xc>
81113108:	003b68fa 	trap	3
8111310c:	dfc00215 	stw	ra,8(sp)
81113110:	df000115 	stw	fp,4(sp)
81113114:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81113118:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
8111311c:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81113120:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81113124:	d0a06283 	ldbu	r2,-32374(gp)
81113128:	10803fcc 	andi	r2,r2,255
8111312c:	10800218 	cmpnei	r2,r2,8
81113130:	1000021e 	bne	r2,zero,8111313c <vCheck+0x3c>
81113134:	00c00104 	movi	r3,4
81113138:	00000106 	br	81113140 <vCheck+0x40>
8111313c:	0007883a 	mov	r3,zero
81113140:	d0a06f03 	ldbu	r2,-32324(gp)
81113144:	10803fcc 	andi	r2,r2,255
81113148:	10800218 	cmpnei	r2,r2,8
8111314c:	1000021e 	bne	r2,zero,81113158 <vCheck+0x58>
81113150:	00800084 	movi	r2,2
81113154:	00000106 	br	8111315c <vCheck+0x5c>
81113158:	0005883a 	mov	r2,zero
8111315c:	1884b03a 	or	r2,r3,r2
81113160:	1007883a 	mov	r3,r2
81113164:	d0a06f43 	ldbu	r2,-32323(gp)
81113168:	10803fcc 	andi	r2,r2,255
8111316c:	108001a0 	cmpeqi	r2,r2,6
81113170:	1884b03a 	or	r2,r3,r2
81113174:	1007883a 	mov	r3,r2
81113178:	e0bfff03 	ldbu	r2,-4(fp)
8111317c:	1884b03a 	or	r2,r3,r2
81113180:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81113184:	e0bfff03 	ldbu	r2,-4(fp)
81113188:	108001d8 	cmpnei	r2,r2,7
8111318c:	10003726 	beq	r2,zero,8111326c <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81113190:	d0a06e17 	ldw	r2,-32328(gp)
81113194:	e0ffff44 	addi	r3,fp,-3
81113198:	180d883a 	mov	r6,r3
8111319c:	000b883a 	mov	r5,zero
811131a0:	1009883a 	mov	r4,r2
811131a4:	1137b6c0 	call	81137b6c <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
811131a8:	e0bfff43 	ldbu	r2,-3(fp)
811131ac:	10803fcc 	andi	r2,r2,255
811131b0:	10000826 	beq	r2,zero,811131d4 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
811131b4:	d0a05c17 	ldw	r2,-32400(gp)
811131b8:	100f883a 	mov	r7,r2
811131bc:	01800f04 	movi	r6,60
811131c0:	01400044 	movi	r5,1
811131c4:	01204574 	movhi	r4,33045
811131c8:	2122d004 	addi	r4,r4,-29888
811131cc:	111c1380 	call	8111c138 <fwrite>
		#endif
        return;
811131d0:	00002706 	br	81113270 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
811131d4:	e0bfff03 	ldbu	r2,-4(fp)
811131d8:	1080004c 	andi	r2,r2,1
811131dc:	10803fcc 	andi	r2,r2,255
811131e0:	1000021e 	bne	r2,zero,811131ec <vCheck+0xec>
        vCheckRetransmission128();
811131e4:	11132840 	call	81113284 <vCheckRetransmission128>
811131e8:	00000506 	br	81113200 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
811131ec:	01800604 	movi	r6,24
811131f0:	000b883a 	mov	r5,zero
811131f4:	012045b4 	movhi	r4,33046
811131f8:	21239104 	addi	r4,r4,-29116
811131fc:	111cc9c0 	call	8111cc9c <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81113200:	e0bfff03 	ldbu	r2,-4(fp)
81113204:	1080008c 	andi	r2,r2,2
81113208:	10803fcc 	andi	r2,r2,255
8111320c:	1000021e 	bne	r2,zero,81113218 <vCheck+0x118>
        vCheckRetransmission64();
81113210:	11135080 	call	81113508 <vCheckRetransmission64>
81113214:	00000506 	br	8111322c <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81113218:	01800804 	movi	r6,32
8111321c:	000b883a 	mov	r5,zero
81113220:	012045b4 	movhi	r4,33046
81113224:	21239704 	addi	r4,r4,-29092
81113228:	111cc9c0 	call	8111cc9c <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
8111322c:	e0bfff03 	ldbu	r2,-4(fp)
81113230:	1080010c 	andi	r2,r2,4
81113234:	10803fcc 	andi	r2,r2,255
81113238:	1000021e 	bne	r2,zero,81113244 <vCheck+0x144>
        vCheckRetransmission32();
8111323c:	11137940 	call	81113794 <vCheckRetransmission32>
81113240:	00000506 	br	81113258 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81113244:	01800804 	movi	r6,32
81113248:	000b883a 	mov	r5,zero
8111324c:	012045b4 	movhi	r4,33046
81113250:	21239f04 	addi	r4,r4,-29060
81113254:	111cc9c0 	call	8111cc9c <memset>


    OSMutexPost(xTxUARTMutex);
81113258:	d0a06e17 	ldw	r2,-32328(gp)
8111325c:	1009883a 	mov	r4,r2
81113260:	11381100 	call	81138110 <OSMutexPost>

    return;
81113264:	0001883a 	nop
81113268:	00000106 	br	81113270 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
8111326c:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81113270:	e037883a 	mov	sp,fp
81113274:	dfc00117 	ldw	ra,4(sp)
81113278:	df000017 	ldw	fp,0(sp)
8111327c:	dec00204 	addi	sp,sp,8
81113280:	f800283a 	ret

81113284 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81113284:	defffd04 	addi	sp,sp,-12
81113288:	de00012e 	bgeu	sp,et,81113290 <vCheckRetransmission128+0xc>
8111328c:	003b68fa 	trap	3
81113290:	dfc00215 	stw	ra,8(sp)
81113294:	df000115 	stw	fp,4(sp)
81113298:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8111329c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811132a0:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811132a4:	d0a06817 	ldw	r2,-32352(gp)
811132a8:	e0ffff44 	addi	r3,fp,-3
811132ac:	180b883a 	mov	r5,r3
811132b0:	1009883a 	mov	r4,r2
811132b4:	11374ec0 	call	811374ec <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811132b8:	e0bfff43 	ldbu	r2,-3(fp)
811132bc:	10803fcc 	andi	r2,r2,255
811132c0:	10008b1e 	bne	r2,zero,811134f0 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811132c4:	e03fff05 	stb	zero,-4(fp)
811132c8:	00008106 	br	811134d0 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
811132cc:	e0ffff03 	ldbu	r3,-4(fp)
811132d0:	00a045b4 	movhi	r2,33046
811132d4:	10a39104 	addi	r2,r2,-29116
811132d8:	18c7883a 	add	r3,r3,r3
811132dc:	18c7883a 	add	r3,r3,r3
811132e0:	10c5883a 	add	r2,r2,r3
811132e4:	10800017 	ldw	r2,0(r2)
811132e8:	10800058 	cmpnei	r2,r2,1
811132ec:	1000751e 	bne	r2,zero,811134c4 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
811132f0:	e0ffff03 	ldbu	r3,-4(fp)
811132f4:	00a045b4 	movhi	r2,33046
811132f8:	10a3af04 	addi	r2,r2,-28996
811132fc:	18c02324 	muli	r3,r3,140
81113300:	10c5883a 	add	r2,r2,r3
81113304:	10802004 	addi	r2,r2,128
81113308:	10800017 	ldw	r2,0(r2)
8111330c:	10800058 	cmpnei	r2,r2,1
81113310:	1000211e 	bne	r2,zero,81113398 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81113314:	e0ffff03 	ldbu	r3,-4(fp)
81113318:	00a045b4 	movhi	r2,33046
8111331c:	10a3af04 	addi	r2,r2,-28996
81113320:	19002324 	muli	r4,r3,140
81113324:	1105883a 	add	r2,r2,r4
81113328:	10802184 	addi	r2,r2,134
8111332c:	1080000b 	ldhu	r2,0(r2)
81113330:	10800044 	addi	r2,r2,1
81113334:	100b883a 	mov	r5,r2
81113338:	00a045b4 	movhi	r2,33046
8111333c:	10a3af04 	addi	r2,r2,-28996
81113340:	19002324 	muli	r4,r3,140
81113344:	1105883a 	add	r2,r2,r4
81113348:	10802184 	addi	r2,r2,134
8111334c:	1140000d 	sth	r5,0(r2)
81113350:	00a045b4 	movhi	r2,33046
81113354:	10a3af04 	addi	r2,r2,-28996
81113358:	18c02324 	muli	r3,r3,140
8111335c:	10c5883a 	add	r2,r2,r3
81113360:	10802184 	addi	r2,r2,134
81113364:	1080000b 	ldhu	r2,0(r2)
81113368:	10bfffcc 	andi	r2,r2,65535
8111336c:	10a0001c 	xori	r2,r2,32768
81113370:	10a00004 	addi	r2,r2,-32768
81113374:	10800090 	cmplti	r2,r2,2
81113378:	1000071e 	bne	r2,zero,81113398 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
8111337c:	e0ffff03 	ldbu	r3,-4(fp)
81113380:	00a045b4 	movhi	r2,33046
81113384:	10a3af04 	addi	r2,r2,-28996
81113388:	18c02324 	muli	r3,r3,140
8111338c:	10c5883a 	add	r2,r2,r3
81113390:	10802004 	addi	r2,r2,128
81113394:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81113398:	e0ffff03 	ldbu	r3,-4(fp)
8111339c:	00a045b4 	movhi	r2,33046
811133a0:	10a3af04 	addi	r2,r2,-28996
811133a4:	18c02324 	muli	r3,r3,140
811133a8:	10c5883a 	add	r2,r2,r3
811133ac:	10802004 	addi	r2,r2,128
811133b0:	10800017 	ldw	r2,0(r2)
811133b4:	1000431e 	bne	r2,zero,811134c4 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
811133b8:	e0bfff03 	ldbu	r2,-4(fp)
811133bc:	10c02324 	muli	r3,r2,140
811133c0:	00a045b4 	movhi	r2,33046
811133c4:	10a3af04 	addi	r2,r2,-28996
811133c8:	1885883a 	add	r2,r3,r2
811133cc:	1009883a 	mov	r4,r2
811133d0:	111d0e80 	call	8111d0e8 <puts>
                xBuffer128[ucIL].bSent = TRUE;
811133d4:	e0ffff03 	ldbu	r3,-4(fp)
811133d8:	00a045b4 	movhi	r2,33046
811133dc:	10a3af04 	addi	r2,r2,-28996
811133e0:	18c02324 	muli	r3,r3,140
811133e4:	10c5883a 	add	r2,r2,r3
811133e8:	10802004 	addi	r2,r2,128
811133ec:	00c00044 	movi	r3,1
811133f0:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
811133f4:	e0ffff03 	ldbu	r3,-4(fp)
811133f8:	00a045b4 	movhi	r2,33046
811133fc:	10a3af04 	addi	r2,r2,-28996
81113400:	18c02324 	muli	r3,r3,140
81113404:	10c5883a 	add	r2,r2,r3
81113408:	10802184 	addi	r2,r2,134
8111340c:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81113410:	e0ffff03 	ldbu	r3,-4(fp)
81113414:	00a045b4 	movhi	r2,33046
81113418:	10a3af04 	addi	r2,r2,-28996
8111341c:	19002324 	muli	r4,r3,140
81113420:	1105883a 	add	r2,r2,r4
81113424:	10802204 	addi	r2,r2,136
81113428:	10800003 	ldbu	r2,0(r2)
8111342c:	10800044 	addi	r2,r2,1
81113430:	100b883a 	mov	r5,r2
81113434:	00a045b4 	movhi	r2,33046
81113438:	10a3af04 	addi	r2,r2,-28996
8111343c:	19002324 	muli	r4,r3,140
81113440:	1105883a 	add	r2,r2,r4
81113444:	10802204 	addi	r2,r2,136
81113448:	11400005 	stb	r5,0(r2)
8111344c:	00a045b4 	movhi	r2,33046
81113450:	10a3af04 	addi	r2,r2,-28996
81113454:	18c02324 	muli	r3,r3,140
81113458:	10c5883a 	add	r2,r2,r3
8111345c:	10802204 	addi	r2,r2,136
81113460:	10800003 	ldbu	r2,0(r2)
81113464:	10803fcc 	andi	r2,r2,255
81113468:	108000b0 	cmpltui	r2,r2,2
8111346c:	1000151e 	bne	r2,zero,811134c4 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81113470:	e0ffff03 	ldbu	r3,-4(fp)
81113474:	00a045b4 	movhi	r2,33046
81113478:	10a39104 	addi	r2,r2,-29116
8111347c:	18c7883a 	add	r3,r3,r3
81113480:	18c7883a 	add	r3,r3,r3
81113484:	10c5883a 	add	r2,r2,r3
81113488:	10000015 	stw	zero,0(r2)
                    SemCount128++;
8111348c:	d0a06f43 	ldbu	r2,-32323(gp)
81113490:	10800044 	addi	r2,r2,1
81113494:	d0a06f45 	stb	r2,-32323(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81113498:	d0a05d17 	ldw	r2,-32396(gp)
8111349c:	1009883a 	mov	r4,r2
811134a0:	1139f000 	call	81139f00 <OSSemPost>
811134a4:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811134a8:	e0bfff43 	ldbu	r2,-3(fp)
811134ac:	10803fcc 	andi	r2,r2,255
811134b0:	10000426 	beq	r2,zero,811134c4 <vCheckRetransmission128+0x240>
                        SemCount128--;
811134b4:	d0a06f43 	ldbu	r2,-32323(gp)
811134b8:	10bfffc4 	addi	r2,r2,-1
811134bc:	d0a06f45 	stb	r2,-32323(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811134c0:	11172ec0 	call	811172ec <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811134c4:	e0bfff03 	ldbu	r2,-4(fp)
811134c8:	10800044 	addi	r2,r2,1
811134cc:	e0bfff05 	stb	r2,-4(fp)
811134d0:	e0bfff03 	ldbu	r2,-4(fp)
811134d4:	108001b0 	cmpltui	r2,r2,6
811134d8:	103f7c1e 	bne	r2,zero,811132cc <__reset+0xfb0f32cc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
811134dc:	d0a06817 	ldw	r2,-32352(gp)
811134e0:	1009883a 	mov	r4,r2
811134e4:	11381100 	call	81138110 <OSMutexPost>

    return;
811134e8:	0001883a 	nop
811134ec:	00000106 	br	811134f4 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811134f0:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
811134f4:	e037883a 	mov	sp,fp
811134f8:	dfc00117 	ldw	ra,4(sp)
811134fc:	df000017 	ldw	fp,0(sp)
81113500:	dec00204 	addi	sp,sp,8
81113504:	f800283a 	ret

81113508 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81113508:	defffd04 	addi	sp,sp,-12
8111350c:	de00012e 	bgeu	sp,et,81113514 <vCheckRetransmission64+0xc>
81113510:	003b68fa 	trap	3
81113514:	dfc00215 	stw	ra,8(sp)
81113518:	df000115 	stw	fp,4(sp)
8111351c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81113520:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81113524:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81113528:	d0a06b17 	ldw	r2,-32340(gp)
8111352c:	e0ffff44 	addi	r3,fp,-3
81113530:	180b883a 	mov	r5,r3
81113534:	1009883a 	mov	r4,r2
81113538:	11374ec0 	call	811374ec <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8111353c:	e0bfff43 	ldbu	r2,-3(fp)
81113540:	10803fcc 	andi	r2,r2,255
81113544:	10008d1e 	bne	r2,zero,8111377c <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81113548:	e03fff05 	stb	zero,-4(fp)
8111354c:	00008306 	br	8111375c <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81113550:	e0ffff03 	ldbu	r3,-4(fp)
81113554:	00a045b4 	movhi	r2,33046
81113558:	10a39104 	addi	r2,r2,-29116
8111355c:	18c00184 	addi	r3,r3,6
81113560:	18c7883a 	add	r3,r3,r3
81113564:	18c7883a 	add	r3,r3,r3
81113568:	10c5883a 	add	r2,r2,r3
8111356c:	10800017 	ldw	r2,0(r2)
81113570:	10800058 	cmpnei	r2,r2,1
81113574:	1000761e 	bne	r2,zero,81113750 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81113578:	e0ffff03 	ldbu	r3,-4(fp)
8111357c:	00a04574 	movhi	r2,33045
81113580:	10bf7004 	addi	r2,r2,-576
81113584:	18c01324 	muli	r3,r3,76
81113588:	10c5883a 	add	r2,r2,r3
8111358c:	10801004 	addi	r2,r2,64
81113590:	10800017 	ldw	r2,0(r2)
81113594:	10800058 	cmpnei	r2,r2,1
81113598:	1000211e 	bne	r2,zero,81113620 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
8111359c:	e0ffff03 	ldbu	r3,-4(fp)
811135a0:	00a04574 	movhi	r2,33045
811135a4:	10bf7004 	addi	r2,r2,-576
811135a8:	19001324 	muli	r4,r3,76
811135ac:	1105883a 	add	r2,r2,r4
811135b0:	10801184 	addi	r2,r2,70
811135b4:	1080000b 	ldhu	r2,0(r2)
811135b8:	10800044 	addi	r2,r2,1
811135bc:	100b883a 	mov	r5,r2
811135c0:	00a04574 	movhi	r2,33045
811135c4:	10bf7004 	addi	r2,r2,-576
811135c8:	19001324 	muli	r4,r3,76
811135cc:	1105883a 	add	r2,r2,r4
811135d0:	10801184 	addi	r2,r2,70
811135d4:	1140000d 	sth	r5,0(r2)
811135d8:	00a04574 	movhi	r2,33045
811135dc:	10bf7004 	addi	r2,r2,-576
811135e0:	18c01324 	muli	r3,r3,76
811135e4:	10c5883a 	add	r2,r2,r3
811135e8:	10801184 	addi	r2,r2,70
811135ec:	1080000b 	ldhu	r2,0(r2)
811135f0:	10bfffcc 	andi	r2,r2,65535
811135f4:	10a0001c 	xori	r2,r2,32768
811135f8:	10a00004 	addi	r2,r2,-32768
811135fc:	10800090 	cmplti	r2,r2,2
81113600:	1000071e 	bne	r2,zero,81113620 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81113604:	e0ffff03 	ldbu	r3,-4(fp)
81113608:	00a04574 	movhi	r2,33045
8111360c:	10bf7004 	addi	r2,r2,-576
81113610:	18c01324 	muli	r3,r3,76
81113614:	10c5883a 	add	r2,r2,r3
81113618:	10801004 	addi	r2,r2,64
8111361c:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81113620:	e0ffff03 	ldbu	r3,-4(fp)
81113624:	00a04574 	movhi	r2,33045
81113628:	10bf7004 	addi	r2,r2,-576
8111362c:	18c01324 	muli	r3,r3,76
81113630:	10c5883a 	add	r2,r2,r3
81113634:	10801004 	addi	r2,r2,64
81113638:	10800017 	ldw	r2,0(r2)
8111363c:	1000441e 	bne	r2,zero,81113750 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81113640:	e0bfff03 	ldbu	r2,-4(fp)
81113644:	10c01324 	muli	r3,r2,76
81113648:	00a04574 	movhi	r2,33045
8111364c:	10bf7004 	addi	r2,r2,-576
81113650:	1885883a 	add	r2,r3,r2
81113654:	1009883a 	mov	r4,r2
81113658:	111d0e80 	call	8111d0e8 <puts>
                xBuffer64[ucIL].bSent = TRUE;
8111365c:	e0ffff03 	ldbu	r3,-4(fp)
81113660:	00a04574 	movhi	r2,33045
81113664:	10bf7004 	addi	r2,r2,-576
81113668:	18c01324 	muli	r3,r3,76
8111366c:	10c5883a 	add	r2,r2,r3
81113670:	10801004 	addi	r2,r2,64
81113674:	00c00044 	movi	r3,1
81113678:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
8111367c:	e0ffff03 	ldbu	r3,-4(fp)
81113680:	00a04574 	movhi	r2,33045
81113684:	10bf7004 	addi	r2,r2,-576
81113688:	18c01324 	muli	r3,r3,76
8111368c:	10c5883a 	add	r2,r2,r3
81113690:	10801184 	addi	r2,r2,70
81113694:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81113698:	e0ffff03 	ldbu	r3,-4(fp)
8111369c:	00a04574 	movhi	r2,33045
811136a0:	10bf7004 	addi	r2,r2,-576
811136a4:	19001324 	muli	r4,r3,76
811136a8:	1105883a 	add	r2,r2,r4
811136ac:	10801204 	addi	r2,r2,72
811136b0:	10800003 	ldbu	r2,0(r2)
811136b4:	10800044 	addi	r2,r2,1
811136b8:	100b883a 	mov	r5,r2
811136bc:	00a04574 	movhi	r2,33045
811136c0:	10bf7004 	addi	r2,r2,-576
811136c4:	19001324 	muli	r4,r3,76
811136c8:	1105883a 	add	r2,r2,r4
811136cc:	10801204 	addi	r2,r2,72
811136d0:	11400005 	stb	r5,0(r2)
811136d4:	00a04574 	movhi	r2,33045
811136d8:	10bf7004 	addi	r2,r2,-576
811136dc:	18c01324 	muli	r3,r3,76
811136e0:	10c5883a 	add	r2,r2,r3
811136e4:	10801204 	addi	r2,r2,72
811136e8:	10800003 	ldbu	r2,0(r2)
811136ec:	10803fcc 	andi	r2,r2,255
811136f0:	108000b0 	cmpltui	r2,r2,2
811136f4:	1000161e 	bne	r2,zero,81113750 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811136f8:	e0ffff03 	ldbu	r3,-4(fp)
811136fc:	00a045b4 	movhi	r2,33046
81113700:	10a39104 	addi	r2,r2,-29116
81113704:	18c00184 	addi	r3,r3,6
81113708:	18c7883a 	add	r3,r3,r3
8111370c:	18c7883a 	add	r3,r3,r3
81113710:	10c5883a 	add	r2,r2,r3
81113714:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81113718:	d0a06f03 	ldbu	r2,-32324(gp)
8111371c:	10800044 	addi	r2,r2,1
81113720:	d0a06f05 	stb	r2,-32324(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81113724:	d0a05817 	ldw	r2,-32416(gp)
81113728:	1009883a 	mov	r4,r2
8111372c:	1139f000 	call	81139f00 <OSSemPost>
81113730:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81113734:	e0bfff43 	ldbu	r2,-3(fp)
81113738:	10803fcc 	andi	r2,r2,255
8111373c:	10000426 	beq	r2,zero,81113750 <vCheckRetransmission64+0x248>
                        SemCount64--;
81113740:	d0a06f03 	ldbu	r2,-32324(gp)
81113744:	10bfffc4 	addi	r2,r2,-1
81113748:	d0a06f05 	stb	r2,-32324(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
8111374c:	11172840 	call	81117284 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81113750:	e0bfff03 	ldbu	r2,-4(fp)
81113754:	10800044 	addi	r2,r2,1
81113758:	e0bfff05 	stb	r2,-4(fp)
8111375c:	e0bfff03 	ldbu	r2,-4(fp)
81113760:	10800230 	cmpltui	r2,r2,8
81113764:	103f7a1e 	bne	r2,zero,81113550 <__reset+0xfb0f3550>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81113768:	d0a06b17 	ldw	r2,-32340(gp)
8111376c:	1009883a 	mov	r4,r2
81113770:	11381100 	call	81138110 <OSMutexPost>

    return;
81113774:	0001883a 	nop
81113778:	00000106 	br	81113780 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8111377c:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
81113780:	e037883a 	mov	sp,fp
81113784:	dfc00117 	ldw	ra,4(sp)
81113788:	df000017 	ldw	fp,0(sp)
8111378c:	dec00204 	addi	sp,sp,8
81113790:	f800283a 	ret

81113794 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81113794:	defffd04 	addi	sp,sp,-12
81113798:	de00012e 	bgeu	sp,et,811137a0 <vCheckRetransmission32+0xc>
8111379c:	003b68fa 	trap	3
811137a0:	dfc00215 	stw	ra,8(sp)
811137a4:	df000115 	stw	fp,4(sp)
811137a8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811137ac:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
811137b0:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
811137b4:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811137b8:	d0a06617 	ldw	r2,-32360(gp)
811137bc:	e0ffff84 	addi	r3,fp,-2
811137c0:	180b883a 	mov	r5,r3
811137c4:	1009883a 	mov	r4,r2
811137c8:	11374ec0 	call	811374ec <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811137cc:	e0bfff83 	ldbu	r2,-2(fp)
811137d0:	10803fcc 	andi	r2,r2,255
811137d4:	10009b1e 	bne	r2,zero,81113a44 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811137d8:	e03fff05 	stb	zero,-4(fp)
811137dc:	00009106 	br	81113a24 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811137e0:	e0ffff03 	ldbu	r3,-4(fp)
811137e4:	00a045b4 	movhi	r2,33046
811137e8:	10a39104 	addi	r2,r2,-29116
811137ec:	18c00384 	addi	r3,r3,14
811137f0:	18c7883a 	add	r3,r3,r3
811137f4:	18c7883a 	add	r3,r3,r3
811137f8:	10c5883a 	add	r2,r2,r3
811137fc:	10800017 	ldw	r2,0(r2)
81113800:	10800058 	cmpnei	r2,r2,1
81113804:	1000841e 	bne	r2,zero,81113a18 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81113808:	e0ffff03 	ldbu	r3,-4(fp)
8111380c:	00a04574 	movhi	r2,33045
81113810:	10911d04 	addi	r2,r2,17524
81113814:	18c00b24 	muli	r3,r3,44
81113818:	10c5883a 	add	r2,r2,r3
8111381c:	10800804 	addi	r2,r2,32
81113820:	10800017 	ldw	r2,0(r2)
81113824:	10800058 	cmpnei	r2,r2,1
81113828:	1000211e 	bne	r2,zero,811138b0 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
8111382c:	e0ffff03 	ldbu	r3,-4(fp)
81113830:	00a04574 	movhi	r2,33045
81113834:	10911d04 	addi	r2,r2,17524
81113838:	19000b24 	muli	r4,r3,44
8111383c:	1105883a 	add	r2,r2,r4
81113840:	10800984 	addi	r2,r2,38
81113844:	1080000b 	ldhu	r2,0(r2)
81113848:	10800044 	addi	r2,r2,1
8111384c:	100b883a 	mov	r5,r2
81113850:	00a04574 	movhi	r2,33045
81113854:	10911d04 	addi	r2,r2,17524
81113858:	19000b24 	muli	r4,r3,44
8111385c:	1105883a 	add	r2,r2,r4
81113860:	10800984 	addi	r2,r2,38
81113864:	1140000d 	sth	r5,0(r2)
81113868:	00a04574 	movhi	r2,33045
8111386c:	10911d04 	addi	r2,r2,17524
81113870:	18c00b24 	muli	r3,r3,44
81113874:	10c5883a 	add	r2,r2,r3
81113878:	10800984 	addi	r2,r2,38
8111387c:	1080000b 	ldhu	r2,0(r2)
81113880:	10bfffcc 	andi	r2,r2,65535
81113884:	10a0001c 	xori	r2,r2,32768
81113888:	10a00004 	addi	r2,r2,-32768
8111388c:	10800090 	cmplti	r2,r2,2
81113890:	1000071e 	bne	r2,zero,811138b0 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81113894:	e0ffff03 	ldbu	r3,-4(fp)
81113898:	00a04574 	movhi	r2,33045
8111389c:	10911d04 	addi	r2,r2,17524
811138a0:	18c00b24 	muli	r3,r3,44
811138a4:	10c5883a 	add	r2,r2,r3
811138a8:	10800804 	addi	r2,r2,32
811138ac:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
811138b0:	e0ffff03 	ldbu	r3,-4(fp)
811138b4:	00a04574 	movhi	r2,33045
811138b8:	10911d04 	addi	r2,r2,17524
811138bc:	18c00b24 	muli	r3,r3,44
811138c0:	10c5883a 	add	r2,r2,r3
811138c4:	10800804 	addi	r2,r2,32
811138c8:	10800017 	ldw	r2,0(r2)
811138cc:	1000521e 	bne	r2,zero,81113a18 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
811138d0:	e0bfff03 	ldbu	r2,-4(fp)
811138d4:	10c00b24 	muli	r3,r2,44
811138d8:	00a04574 	movhi	r2,33045
811138dc:	10911d04 	addi	r2,r2,17524
811138e0:	1885883a 	add	r2,r3,r2
811138e4:	1009883a 	mov	r4,r2
811138e8:	111d0e80 	call	8111d0e8 <puts>
                xBuffer32[ucIL].bSent = TRUE;
811138ec:	e0ffff03 	ldbu	r3,-4(fp)
811138f0:	00a04574 	movhi	r2,33045
811138f4:	10911d04 	addi	r2,r2,17524
811138f8:	18c00b24 	muli	r3,r3,44
811138fc:	10c5883a 	add	r2,r2,r3
81113900:	10800804 	addi	r2,r2,32
81113904:	00c00044 	movi	r3,1
81113908:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
8111390c:	e0ffff03 	ldbu	r3,-4(fp)
81113910:	00a04574 	movhi	r2,33045
81113914:	10911d04 	addi	r2,r2,17524
81113918:	18c00b24 	muli	r3,r3,44
8111391c:	10c5883a 	add	r2,r2,r3
81113920:	10800984 	addi	r2,r2,38
81113924:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81113928:	e0ffff03 	ldbu	r3,-4(fp)
8111392c:	00a04574 	movhi	r2,33045
81113930:	10911d04 	addi	r2,r2,17524
81113934:	18c00b24 	muli	r3,r3,44
81113938:	10c5883a 	add	r2,r2,r3
8111393c:	10800904 	addi	r2,r2,36
81113940:	1080000b 	ldhu	r2,0(r2)
81113944:	10bfffcc 	andi	r2,r2,65535
81113948:	10800058 	cmpnei	r2,r2,1
8111394c:	1000021e 	bne	r2,zero,81113958 <vCheckRetransmission32+0x1c4>
81113950:	00bffe84 	movi	r2,-6
81113954:	00000106 	br	8111395c <vCheckRetransmission32+0x1c8>
81113958:	00800044 	movi	r2,1
8111395c:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81113960:	e0ffff03 	ldbu	r3,-4(fp)
81113964:	00a04574 	movhi	r2,33045
81113968:	10911d04 	addi	r2,r2,17524
8111396c:	19000b24 	muli	r4,r3,44
81113970:	1105883a 	add	r2,r2,r4
81113974:	10800a04 	addi	r2,r2,40
81113978:	10800003 	ldbu	r2,0(r2)
8111397c:	10800044 	addi	r2,r2,1
81113980:	100b883a 	mov	r5,r2
81113984:	00a04574 	movhi	r2,33045
81113988:	10911d04 	addi	r2,r2,17524
8111398c:	19000b24 	muli	r4,r3,44
81113990:	1105883a 	add	r2,r2,r4
81113994:	10800a04 	addi	r2,r2,40
81113998:	11400005 	stb	r5,0(r2)
8111399c:	00a04574 	movhi	r2,33045
811139a0:	10911d04 	addi	r2,r2,17524
811139a4:	18c00b24 	muli	r3,r3,44
811139a8:	10c5883a 	add	r2,r2,r3
811139ac:	10800a04 	addi	r2,r2,40
811139b0:	10800003 	ldbu	r2,0(r2)
811139b4:	10803fcc 	andi	r2,r2,255
811139b8:	e0ffff43 	ldbu	r3,-3(fp)
811139bc:	1880162e 	bgeu	r3,r2,81113a18 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
811139c0:	e0ffff03 	ldbu	r3,-4(fp)
811139c4:	00a045b4 	movhi	r2,33046
811139c8:	10a39104 	addi	r2,r2,-29116
811139cc:	18c00384 	addi	r3,r3,14
811139d0:	18c7883a 	add	r3,r3,r3
811139d4:	18c7883a 	add	r3,r3,r3
811139d8:	10c5883a 	add	r2,r2,r3
811139dc:	10000015 	stw	zero,0(r2)
                    SemCount32++;
811139e0:	d0a06283 	ldbu	r2,-32374(gp)
811139e4:	10800044 	addi	r2,r2,1
811139e8:	d0a06285 	stb	r2,-32374(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
811139ec:	d0a06917 	ldw	r2,-32348(gp)
811139f0:	1009883a 	mov	r4,r2
811139f4:	1139f000 	call	81139f00 <OSSemPost>
811139f8:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811139fc:	e0bfff83 	ldbu	r2,-2(fp)
81113a00:	10803fcc 	andi	r2,r2,255
81113a04:	10000426 	beq	r2,zero,81113a18 <vCheckRetransmission32+0x284>
                        SemCount32--;
81113a08:	d0a06283 	ldbu	r2,-32374(gp)
81113a0c:	10bfffc4 	addi	r2,r2,-1
81113a10:	d0a06285 	stb	r2,-32374(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81113a14:	111721c0 	call	8111721c <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81113a18:	e0bfff03 	ldbu	r2,-4(fp)
81113a1c:	10800044 	addi	r2,r2,1
81113a20:	e0bfff05 	stb	r2,-4(fp)
81113a24:	e0bfff03 	ldbu	r2,-4(fp)
81113a28:	10800230 	cmpltui	r2,r2,8
81113a2c:	103f6c1e 	bne	r2,zero,811137e0 <__reset+0xfb0f37e0>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81113a30:	d0a06617 	ldw	r2,-32360(gp)
81113a34:	1009883a 	mov	r4,r2
81113a38:	11381100 	call	81138110 <OSMutexPost>

    return;
81113a3c:	0001883a 	nop
81113a40:	00000106 	br	81113a48 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81113a44:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81113a48:	e037883a 	mov	sp,fp
81113a4c:	dfc00117 	ldw	ra,4(sp)
81113a50:	df000017 	ldw	fp,0(sp)
81113a54:	dec00204 	addi	sp,sp,8
81113a58:	f800283a 	ret

81113a5c <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81113a5c:	defff904 	addi	sp,sp,-28
81113a60:	de00012e 	bgeu	sp,et,81113a68 <bResourcesInitRTOS+0xc>
81113a64:	003b68fa 	trap	3
81113a68:	dfc00615 	stw	ra,24(sp)
81113a6c:	df000515 	stw	fp,20(sp)
81113a70:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81113a74:	00800044 	movi	r2,1
81113a78:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81113a7c:	0009883a 	mov	r4,zero
81113a80:	11398500 	call	81139850 <OSSemCreate>
81113a84:	d0a05a15 	stw	r2,-32408(gp)
	if (!xSemCommInit) {
81113a88:	d0a05a17 	ldw	r2,-32408(gp)
81113a8c:	1000021e 	bne	r2,zero,81113a98 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81113a90:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113a94:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81113a98:	e0bfff04 	addi	r2,fp,-4
81113a9c:	100b883a 	mov	r5,r2
81113aa0:	01000444 	movi	r4,17
81113aa4:	11376980 	call	81137698 <OSMutexCreate>
81113aa8:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
81113aac:	e0bfff03 	ldbu	r2,-4(fp)
81113ab0:	10803fcc 	andi	r2,r2,255
81113ab4:	10000526 	beq	r2,zero,81113acc <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81113ab8:	e0bfff03 	ldbu	r2,-4(fp)
81113abc:	10803fcc 	andi	r2,r2,255
81113ac0:	1009883a 	mov	r4,r2
81113ac4:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113ac8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81113acc:	e0bfff04 	addi	r2,fp,-4
81113ad0:	100b883a 	mov	r5,r2
81113ad4:	01000504 	movi	r4,20
81113ad8:	11376980 	call	81137698 <OSMutexCreate>
81113adc:	d0a06815 	stw	r2,-32352(gp)
	if ( err != OS_ERR_NONE ) {
81113ae0:	e0bfff03 	ldbu	r2,-4(fp)
81113ae4:	10803fcc 	andi	r2,r2,255
81113ae8:	10000526 	beq	r2,zero,81113b00 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81113aec:	e0bfff03 	ldbu	r2,-4(fp)
81113af0:	10803fcc 	andi	r2,r2,255
81113af4:	1009883a 	mov	r4,r2
81113af8:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113afc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81113b00:	e0bfff04 	addi	r2,fp,-4
81113b04:	100b883a 	mov	r5,r2
81113b08:	01000544 	movi	r4,21
81113b0c:	11376980 	call	81137698 <OSMutexCreate>
81113b10:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81113b14:	e0bfff03 	ldbu	r2,-4(fp)
81113b18:	10803fcc 	andi	r2,r2,255
81113b1c:	10000526 	beq	r2,zero,81113b34 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81113b20:	e0bfff03 	ldbu	r2,-4(fp)
81113b24:	10803fcc 	andi	r2,r2,255
81113b28:	1009883a 	mov	r4,r2
81113b2c:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113b30:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81113b34:	e0bfff04 	addi	r2,fp,-4
81113b38:	100b883a 	mov	r5,r2
81113b3c:	01000584 	movi	r4,22
81113b40:	11376980 	call	81137698 <OSMutexCreate>
81113b44:	d0a06615 	stw	r2,-32360(gp)
	if ( err != OS_ERR_NONE ) {
81113b48:	e0bfff03 	ldbu	r2,-4(fp)
81113b4c:	10803fcc 	andi	r2,r2,255
81113b50:	10000526 	beq	r2,zero,81113b68 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81113b54:	e0bfff03 	ldbu	r2,-4(fp)
81113b58:	10803fcc 	andi	r2,r2,255
81113b5c:	1009883a 	mov	r4,r2
81113b60:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113b64:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81113b68:	00800184 	movi	r2,6
81113b6c:	d0a06f45 	stb	r2,-32323(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81113b70:	01000184 	movi	r4,6
81113b74:	11398500 	call	81139850 <OSSemCreate>
81113b78:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCountBuffer128) {
81113b7c:	d0a05d17 	ldw	r2,-32396(gp)
81113b80:	1000031e 	bne	r2,zero,81113b90 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81113b84:	d0206f45 	stb	zero,-32323(gp)
		vFailCreateSemaphoreResources();
81113b88:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113b8c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81113b90:	00800204 	movi	r2,8
81113b94:	d0a06f05 	stb	r2,-32324(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81113b98:	01000204 	movi	r4,8
81113b9c:	11398500 	call	81139850 <OSSemCreate>
81113ba0:	d0a05815 	stw	r2,-32416(gp)
	if (!xSemCountBuffer64) {
81113ba4:	d0a05817 	ldw	r2,-32416(gp)
81113ba8:	1000031e 	bne	r2,zero,81113bb8 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81113bac:	d0206f05 	stb	zero,-32324(gp)
		vFailCreateSemaphoreResources();
81113bb0:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113bb4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81113bb8:	00800204 	movi	r2,8
81113bbc:	d0a06285 	stb	r2,-32374(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81113bc0:	01000204 	movi	r4,8
81113bc4:	11398500 	call	81139850 <OSSemCreate>
81113bc8:	d0a06915 	stw	r2,-32348(gp)
	if (!xSemCountBuffer32) {
81113bcc:	d0a06917 	ldw	r2,-32348(gp)
81113bd0:	1000031e 	bne	r2,zero,81113be0 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81113bd4:	d0206285 	stb	zero,-32374(gp)
		vFailCreateSemaphoreResources();
81113bd8:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113bdc:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81113be0:	e0bfff04 	addi	r2,fp,-4
81113be4:	100b883a 	mov	r5,r2
81113be8:	010004c4 	movi	r4,19
81113bec:	11376980 	call	81137698 <OSMutexCreate>
81113bf0:	d0a05f15 	stw	r2,-32388(gp)
	if ( err != OS_ERR_NONE ) {
81113bf4:	e0bfff03 	ldbu	r2,-4(fp)
81113bf8:	10803fcc 	andi	r2,r2,255
81113bfc:	10000526 	beq	r2,zero,81113c14 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81113c00:	e0bfff03 	ldbu	r2,-4(fp)
81113c04:	10803fcc 	andi	r2,r2,255
81113c08:	1009883a 	mov	r4,r2
81113c0c:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113c10:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81113c14:	e0bfff04 	addi	r2,fp,-4
81113c18:	100b883a 	mov	r5,r2
81113c1c:	010005c4 	movi	r4,23
81113c20:	11376980 	call	81137698 <OSMutexCreate>
81113c24:	d0a06515 	stw	r2,-32364(gp)
	if ( err != OS_ERR_NONE ) {
81113c28:	e0bfff03 	ldbu	r2,-4(fp)
81113c2c:	10803fcc 	andi	r2,r2,255
81113c30:	10000526 	beq	r2,zero,81113c48 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81113c34:	e0bfff03 	ldbu	r2,-4(fp)
81113c38:	10803fcc 	andi	r2,r2,255
81113c3c:	1009883a 	mov	r4,r2
81113c40:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113c44:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81113c48:	0009883a 	mov	r4,zero
81113c4c:	11398500 	call	81139850 <OSSemCreate>
81113c50:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountReceivedACK) {
81113c54:	d0a06017 	ldw	r2,-32384(gp)
81113c58:	1000021e 	bne	r2,zero,81113c64 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81113c5c:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113c60:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81113c64:	0009883a 	mov	r4,zero
81113c68:	11398500 	call	81139850 <OSSemCreate>
81113c6c:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountPreParsed) {
81113c70:	d0a05e17 	ldw	r2,-32392(gp)
81113c74:	1000021e 	bne	r2,zero,81113c80 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81113c78:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113c7c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81113c80:	0009883a 	mov	r4,zero
81113c84:	11398500 	call	81139850 <OSSemCreate>
81113c88:	d0a05b15 	stw	r2,-32404(gp)
	if (!xSemCountSenderACK) {
81113c8c:	d0a05b17 	ldw	r2,-32404(gp)
81113c90:	1000021e 	bne	r2,zero,81113c9c <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81113c94:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113c98:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81113c9c:	e0bfff04 	addi	r2,fp,-4
81113ca0:	100b883a 	mov	r5,r2
81113ca4:	01000484 	movi	r4,18
81113ca8:	11376980 	call	81137698 <OSMutexCreate>
81113cac:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81113cb0:	e0bfff03 	ldbu	r2,-4(fp)
81113cb4:	10803fcc 	andi	r2,r2,255
81113cb8:	10000526 	beq	r2,zero,81113cd0 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81113cbc:	e0bfff03 	ldbu	r2,-4(fp)
81113cc0:	10803fcc 	andi	r2,r2,255
81113cc4:	1009883a 	mov	r4,r2
81113cc8:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113ccc:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81113cd0:	0009883a 	mov	r4,zero
81113cd4:	11398500 	call	81139850 <OSSemCreate>
81113cd8:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemTimeoutChecker) {
81113cdc:	d0a06117 	ldw	r2,-32380(gp)
81113ce0:	1000021e 	bne	r2,zero,81113cec <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81113ce4:	1116cb40 	call	81116cb4 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81113ce8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81113cec:	e0bfff04 	addi	r2,fp,-4
81113cf0:	d8800215 	stw	r2,8(sp)
81113cf4:	00a04574 	movhi	r2,33045
81113cf8:	10a2e004 	addi	r2,r2,-29824
81113cfc:	d8800115 	stw	r2,4(sp)
81113d00:	d8000015 	stw	zero,0(sp)
81113d04:	01e04474 	movhi	r7,33041
81113d08:	39d62304 	addi	r7,r7,22668
81113d0c:	01800084 	movi	r6,2
81113d10:	01400104 	movi	r5,4
81113d14:	01000284 	movi	r4,10
81113d18:	113bd680 	call	8113bd68 <OSTmrCreate>
81113d1c:	d0a06715 	stw	r2,-32356(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81113d20:	e0bfff03 	ldbu	r2,-4(fp)
81113d24:	10803fcc 	andi	r2,r2,255
81113d28:	10000226 	beq	r2,zero,81113d34 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81113d2c:	11179180 	call	81117918 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81113d30:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81113d34:	01400304 	movi	r5,12
81113d38:	01204574 	movhi	r4,33045
81113d3c:	21046404 	addi	r4,r4,4496
81113d40:	11387840 	call	81138784 <OSQCreate>
81113d44:	d0a05715 	stw	r2,-32420(gp)
	if ( xNfeeSchedule == NULL ) {
81113d48:	d0a05717 	ldw	r2,-32420(gp)
81113d4c:	1000021e 	bne	r2,zero,81113d58 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81113d50:	1117efc0 	call	81117efc <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81113d54:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81113d58:	01400104 	movi	r5,4
81113d5c:	012045b4 	movhi	r4,33046
81113d60:	21034b04 	addi	r4,r4,3372
81113d64:	11387840 	call	81138784 <OSQCreate>
81113d68:	d0a06415 	stw	r2,-32368(gp)
	if ( xFeeQ[0] == NULL ) {
81113d6c:	d0a06417 	ldw	r2,-32368(gp)
81113d70:	1000031e 	bne	r2,zero,81113d80 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81113d74:	0009883a 	mov	r4,zero
81113d78:	1117f640 	call	81117f64 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81113d7c:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL1[0], N_MSG_SYNC);
81113d80:	01400104 	movi	r5,4
81113d84:	012045b4 	movhi	r4,33046
81113d88:	21034f04 	addi	r4,r4,3388
81113d8c:	11387840 	call	81138784 <OSQCreate>
81113d90:	d0a05615 	stw	r2,-32424(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81113d94:	d0a05617 	ldw	r2,-32424(gp)
81113d98:	1000031e 	bne	r2,zero,81113da8 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81113d9c:	0009883a 	mov	r4,zero
81113da0:	1117fd40 	call	81117fd4 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81113da4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81113da8:	01400204 	movi	r5,8
81113dac:	012045b4 	movhi	r4,33046
81113db0:	2123a704 	addi	r4,r4,-29028
81113db4:	11387840 	call	81138784 <OSQCreate>
81113db8:	d0a06315 	stw	r2,-32372(gp)
	if ( xMebQ == NULL ) {
81113dbc:	d0a06317 	ldw	r2,-32372(gp)
81113dc0:	1000031e 	bne	r2,zero,81113dd0 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81113dc4:	01000144 	movi	r4,5
81113dc8:	1117f640 	call	81117f64 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81113dcc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81113dd0:	e0bfff04 	addi	r2,fp,-4
81113dd4:	100b883a 	mov	r5,r2
81113dd8:	01000144 	movi	r4,5
81113ddc:	11376980 	call	81137698 <OSMutexCreate>
81113de0:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
81113de4:	e0bfff03 	ldbu	r2,-4(fp)
81113de8:	10803fcc 	andi	r2,r2,255
81113dec:	10000526 	beq	r2,zero,81113e04 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81113df0:	e0bfff03 	ldbu	r2,-4(fp)
81113df4:	10803fcc 	andi	r2,r2,255
81113df8:	1009883a 	mov	r4,r2
81113dfc:	11183ec0 	call	811183ec <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81113e00:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81113e04:	01400404 	movi	r5,16
81113e08:	012045b4 	movhi	r4,33046
81113e0c:	21248104 	addi	r4,r4,-28156
81113e10:	11387840 	call	81138784 <OSQCreate>
81113e14:	d0a06a15 	stw	r2,-32344(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81113e18:	d0a06a17 	ldw	r2,-32344(gp)
81113e1c:	1000021e 	bne	r2,zero,81113e28 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81113e20:	111854c0 	call	8111854c <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81113e24:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81113e28:	01400404 	movi	r5,16
81113e2c:	01204574 	movhi	r4,33045
81113e30:	21177504 	addi	r4,r4,24020
81113e34:	11387840 	call	81138784 <OSQCreate>
81113e38:	d0a05915 	stw	r2,-32412(gp)
	if ( xQMaskDataCtrl == NULL ) {
81113e3c:	d0a05917 	ldw	r2,-32412(gp)
81113e40:	1000021e 	bne	r2,zero,81113e4c <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81113e44:	11185b40 	call	811185b4 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81113e48:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81113e4c:	e0bfff04 	addi	r2,fp,-4
81113e50:	100b883a 	mov	r5,r2
81113e54:	01000484 	movi	r4,18
81113e58:	11376980 	call	81137698 <OSMutexCreate>
81113e5c:	d0a06c15 	stw	r2,-32336(gp)
	if ( err != OS_ERR_NONE ) {
81113e60:	e0bfff03 	ldbu	r2,-4(fp)
81113e64:	10803fcc 	andi	r2,r2,255
81113e68:	10000526 	beq	r2,zero,81113e80 <bResourcesInitRTOS+0x424>
		vFailCreateMutexSResources(err);
81113e6c:	e0bfff03 	ldbu	r2,-4(fp)
81113e70:	10803fcc 	andi	r2,r2,255
81113e74:	1009883a 	mov	r4,r2
81113e78:	1116c080 	call	81116c08 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81113e7c:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81113e80:	e0bfff04 	addi	r2,fp,-4
81113e84:	100b883a 	mov	r5,r2
81113e88:	010000c4 	movi	r4,3
81113e8c:	11376980 	call	81137698 <OSMutexCreate>
81113e90:	1007883a 	mov	r3,r2
81113e94:	00a045b4 	movhi	r2,33046
81113e98:	10b6a304 	addi	r2,r2,-9588
81113e9c:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81113ea0:	e0bfff03 	ldbu	r2,-4(fp)
81113ea4:	10803fcc 	andi	r2,r2,255
81113ea8:	10000226 	beq	r2,zero,81113eb4 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81113eac:	1116c680 	call	81116c68 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81113eb0:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81113eb4:	e0bfff04 	addi	r2,fp,-4
81113eb8:	100b883a 	mov	r5,r2
81113ebc:	01000104 	movi	r4,4
81113ec0:	11376980 	call	81137698 <OSMutexCreate>
81113ec4:	1007883a 	mov	r3,r2
81113ec8:	00a045b4 	movhi	r2,33046
81113ecc:	10b6a304 	addi	r2,r2,-9588
81113ed0:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81113ed4:	e0bfff03 	ldbu	r2,-4(fp)
81113ed8:	10803fcc 	andi	r2,r2,255
81113edc:	10000226 	beq	r2,zero,81113ee8 <bResourcesInitRTOS+0x48c>
		vFailCreateMutexDMA();
81113ee0:	1116c680 	call	81116c68 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81113ee4:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81113ee8:	e0bffe17 	ldw	r2,-8(fp)
}
81113eec:	e037883a 	mov	sp,fp
81113ef0:	dfc00117 	ldw	ra,4(sp)
81113ef4:	df000017 	ldw	fp,0(sp)
81113ef8:	dec00204 	addi	sp,sp,8
81113efc:	f800283a 	ret

81113f00 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81113f00:	defffd04 	addi	sp,sp,-12
81113f04:	de00012e 	bgeu	sp,et,81113f0c <vVariablesInitialization+0xc>
81113f08:	003b68fa 	trap	3
81113f0c:	dfc00215 	stw	ra,8(sp)
81113f10:	df000115 	stw	fp,4(sp)
81113f14:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81113f18:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81113f1c:	00800084 	movi	r2,2
81113f20:	d0a0620d 	sth	r2,-32376(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81113f24:	01800604 	movi	r6,24
81113f28:	000b883a 	mov	r5,zero
81113f2c:	012045b4 	movhi	r4,33046
81113f30:	21239104 	addi	r4,r4,-29116
81113f34:	111cc9c0 	call	8111cc9c <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81113f38:	01800804 	movi	r6,32
81113f3c:	000b883a 	mov	r5,zero
81113f40:	012045b4 	movhi	r4,33046
81113f44:	21239704 	addi	r4,r4,-29092
81113f48:	111cc9c0 	call	8111cc9c <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81113f4c:	01800804 	movi	r6,32
81113f50:	000b883a 	mov	r5,zero
81113f54:	012045b4 	movhi	r4,33046
81113f58:	21239f04 	addi	r4,r4,-29060
81113f5c:	111cc9c0 	call	8111cc9c <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113f60:	e03fff05 	stb	zero,-4(fp)
81113f64:	00002806 	br	81114008 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81113f68:	e0bfff03 	ldbu	r2,-4(fp)
81113f6c:	10c02324 	muli	r3,r2,140
81113f70:	00a045b4 	movhi	r2,33046
81113f74:	10a3af04 	addi	r2,r2,-28996
81113f78:	1885883a 	add	r2,r3,r2
81113f7c:	01802004 	movi	r6,128
81113f80:	000b883a 	mov	r5,zero
81113f84:	1009883a 	mov	r4,r2
81113f88:	111cc9c0 	call	8111cc9c <memset>
		xBuffer128[ucIL].bSent = FALSE;
81113f8c:	e0ffff03 	ldbu	r3,-4(fp)
81113f90:	00a045b4 	movhi	r2,33046
81113f94:	10a3af04 	addi	r2,r2,-28996
81113f98:	18c02324 	muli	r3,r3,140
81113f9c:	10c5883a 	add	r2,r2,r3
81113fa0:	10802004 	addi	r2,r2,128
81113fa4:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81113fa8:	e0ffff03 	ldbu	r3,-4(fp)
81113fac:	00a045b4 	movhi	r2,33046
81113fb0:	10a3af04 	addi	r2,r2,-28996
81113fb4:	18c02324 	muli	r3,r3,140
81113fb8:	10c5883a 	add	r2,r2,r3
81113fbc:	10802104 	addi	r2,r2,132
81113fc0:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
81113fc4:	e0ffff03 	ldbu	r3,-4(fp)
81113fc8:	00a045b4 	movhi	r2,33046
81113fcc:	10a3af04 	addi	r2,r2,-28996
81113fd0:	18c02324 	muli	r3,r3,140
81113fd4:	10c5883a 	add	r2,r2,r3
81113fd8:	10802184 	addi	r2,r2,134
81113fdc:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81113fe0:	e0ffff03 	ldbu	r3,-4(fp)
81113fe4:	00a045b4 	movhi	r2,33046
81113fe8:	10a3af04 	addi	r2,r2,-28996
81113fec:	18c02324 	muli	r3,r3,140
81113ff0:	10c5883a 	add	r2,r2,r3
81113ff4:	10802204 	addi	r2,r2,136
81113ff8:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113ffc:	e0bfff03 	ldbu	r2,-4(fp)
81114000:	10800044 	addi	r2,r2,1
81114004:	e0bfff05 	stb	r2,-4(fp)
81114008:	e0bfff03 	ldbu	r2,-4(fp)
8111400c:	108001b0 	cmpltui	r2,r2,6
81114010:	103fd51e 	bne	r2,zero,81113f68 <__reset+0xfb0f3f68>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81114014:	e03fff05 	stb	zero,-4(fp)
81114018:	00002806 	br	811140bc <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8111401c:	e0bfff03 	ldbu	r2,-4(fp)
81114020:	10c01324 	muli	r3,r2,76
81114024:	00a04574 	movhi	r2,33045
81114028:	10bf7004 	addi	r2,r2,-576
8111402c:	1885883a 	add	r2,r3,r2
81114030:	01801004 	movi	r6,64
81114034:	000b883a 	mov	r5,zero
81114038:	1009883a 	mov	r4,r2
8111403c:	111cc9c0 	call	8111cc9c <memset>
		xBuffer64[ucIL].bSent = FALSE;
81114040:	e0ffff03 	ldbu	r3,-4(fp)
81114044:	00a04574 	movhi	r2,33045
81114048:	10bf7004 	addi	r2,r2,-576
8111404c:	18c01324 	muli	r3,r3,76
81114050:	10c5883a 	add	r2,r2,r3
81114054:	10801004 	addi	r2,r2,64
81114058:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
8111405c:	e0ffff03 	ldbu	r3,-4(fp)
81114060:	00a04574 	movhi	r2,33045
81114064:	10bf7004 	addi	r2,r2,-576
81114068:	18c01324 	muli	r3,r3,76
8111406c:	10c5883a 	add	r2,r2,r3
81114070:	10801104 	addi	r2,r2,68
81114074:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81114078:	e0ffff03 	ldbu	r3,-4(fp)
8111407c:	00a04574 	movhi	r2,33045
81114080:	10bf7004 	addi	r2,r2,-576
81114084:	18c01324 	muli	r3,r3,76
81114088:	10c5883a 	add	r2,r2,r3
8111408c:	10801184 	addi	r2,r2,70
81114090:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81114094:	e0ffff03 	ldbu	r3,-4(fp)
81114098:	00a04574 	movhi	r2,33045
8111409c:	10bf7004 	addi	r2,r2,-576
811140a0:	18c01324 	muli	r3,r3,76
811140a4:	10c5883a 	add	r2,r2,r3
811140a8:	10801204 	addi	r2,r2,72
811140ac:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811140b0:	e0bfff03 	ldbu	r2,-4(fp)
811140b4:	10800044 	addi	r2,r2,1
811140b8:	e0bfff05 	stb	r2,-4(fp)
811140bc:	e0bfff03 	ldbu	r2,-4(fp)
811140c0:	10800230 	cmpltui	r2,r2,8
811140c4:	103fd51e 	bne	r2,zero,8111401c <__reset+0xfb0f401c>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811140c8:	e03fff05 	stb	zero,-4(fp)
811140cc:	00002806 	br	81114170 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
811140d0:	e0bfff03 	ldbu	r2,-4(fp)
811140d4:	10c00b24 	muli	r3,r2,44
811140d8:	00a04574 	movhi	r2,33045
811140dc:	10911d04 	addi	r2,r2,17524
811140e0:	1885883a 	add	r2,r3,r2
811140e4:	01800804 	movi	r6,32
811140e8:	000b883a 	mov	r5,zero
811140ec:	1009883a 	mov	r4,r2
811140f0:	111cc9c0 	call	8111cc9c <memset>
		xBuffer32[ucIL].bSent = FALSE;
811140f4:	e0ffff03 	ldbu	r3,-4(fp)
811140f8:	00a04574 	movhi	r2,33045
811140fc:	10911d04 	addi	r2,r2,17524
81114100:	18c00b24 	muli	r3,r3,44
81114104:	10c5883a 	add	r2,r2,r3
81114108:	10800804 	addi	r2,r2,32
8111410c:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81114110:	e0ffff03 	ldbu	r3,-4(fp)
81114114:	00a04574 	movhi	r2,33045
81114118:	10911d04 	addi	r2,r2,17524
8111411c:	18c00b24 	muli	r3,r3,44
81114120:	10c5883a 	add	r2,r2,r3
81114124:	10800904 	addi	r2,r2,36
81114128:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
8111412c:	e0ffff03 	ldbu	r3,-4(fp)
81114130:	00a04574 	movhi	r2,33045
81114134:	10911d04 	addi	r2,r2,17524
81114138:	18c00b24 	muli	r3,r3,44
8111413c:	10c5883a 	add	r2,r2,r3
81114140:	10800984 	addi	r2,r2,38
81114144:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81114148:	e0ffff03 	ldbu	r3,-4(fp)
8111414c:	00a04574 	movhi	r2,33045
81114150:	10911d04 	addi	r2,r2,17524
81114154:	18c00b24 	muli	r3,r3,44
81114158:	10c5883a 	add	r2,r2,r3
8111415c:	10800a04 	addi	r2,r2,40
81114160:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81114164:	e0bfff03 	ldbu	r2,-4(fp)
81114168:	10800044 	addi	r2,r2,1
8111416c:	e0bfff05 	stb	r2,-4(fp)
81114170:	e0bfff03 	ldbu	r2,-4(fp)
81114174:	10800230 	cmpltui	r2,r2,8
81114178:	103fd51e 	bne	r2,zero,811140d0 <__reset+0xfb0f40d0>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8111417c:	e03fff05 	stb	zero,-4(fp)
81114180:	00001b06 	br	811141f0 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81114184:	e0ffff03 	ldbu	r3,-4(fp)
81114188:	00a04574 	movhi	r2,33045
8111418c:	10800804 	addi	r2,r2,32
81114190:	18c01524 	muli	r3,r3,84
81114194:	10c5883a 	add	r2,r2,r3
81114198:	10800104 	addi	r2,r2,4
8111419c:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
811141a0:	e0ffff03 	ldbu	r3,-4(fp)
811141a4:	00a04574 	movhi	r2,33045
811141a8:	10800804 	addi	r2,r2,32
811141ac:	18c01524 	muli	r3,r3,84
811141b0:	10c5883a 	add	r2,r2,r3
811141b4:	10800484 	addi	r2,r2,18
811141b8:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
811141bc:	e0bfff03 	ldbu	r2,-4(fp)
811141c0:	10801524 	muli	r2,r2,84
811141c4:	10c00504 	addi	r3,r2,20
811141c8:	00a04574 	movhi	r2,33045
811141cc:	10800804 	addi	r2,r2,32
811141d0:	1885883a 	add	r2,r3,r2
811141d4:	01801004 	movi	r6,64
811141d8:	000b883a 	mov	r5,zero
811141dc:	1009883a 	mov	r4,r2
811141e0:	111cc9c0 	call	8111cc9c <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811141e4:	e0bfff03 	ldbu	r2,-4(fp)
811141e8:	10800044 	addi	r2,r2,1
811141ec:	e0bfff05 	stb	r2,-4(fp)
811141f0:	e0bfff03 	ldbu	r2,-4(fp)
811141f4:	10800130 	cmpltui	r2,r2,4
811141f8:	103fe21e 	bne	r2,zero,81114184 <__reset+0xfb0f4184>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
811141fc:	0001883a 	nop
81114200:	e037883a 	mov	sp,fp
81114204:	dfc00117 	ldw	ra,4(sp)
81114208:	df000017 	ldw	fp,0(sp)
8111420c:	dec00204 	addi	sp,sp,8
81114210:	f800283a 	ret

81114214 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81114214:	defff704 	addi	sp,sp,-36
81114218:	de00012e 	bgeu	sp,et,81114220 <main+0xc>
8111421c:	003b68fa 	trap	3
81114220:	dfc00815 	stw	ra,32(sp)
81114224:	df000715 	stw	fp,28(sp)
81114228:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
8111422c:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81114230:	1133b340 	call	81133b34 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81114234:	01604574 	movhi	r5,33045
81114238:	2962e404 	addi	r5,r5,-29808
8111423c:	01204574 	movhi	r4,33045
81114240:	2122e504 	addi	r4,r4,-29804
81114244:	111ba540 	call	8111ba54 <fopen>
81114248:	d0a05c15 	stw	r2,-32400(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
8111424c:	d0a05c17 	ldw	r2,-32400(gp)
81114250:	100f883a 	mov	r7,r2
81114254:	01800484 	movi	r6,18
81114258:	01400044 	movi	r5,1
8111425c:	01204574 	movhi	r4,33045
81114260:	2122ea04 	addi	r4,r4,-29784
81114264:	111c1380 	call	8111c138 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81114268:	11193a00 	call	811193a0 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
8111426c:	1119fa80 	call	81119fa8 <bTestSimucamCriticalHW>
81114270:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81114274:	e0bffe17 	ldw	r2,-8(fp)
81114278:	1000031e 	bne	r2,zero,81114288 <main+0x74>
		vFailTestCriticasParts();
8111427c:	1116d000 	call	81116d00 <vFailTestCriticasParts>
		return -1;
81114280:	00bfffc4 	movi	r2,-1
81114284:	00003e06 	br	81114380 <main+0x16c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81114288:	1119b200 	call	81119b20 <bInitializeSDCard>
8111428c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81114290:	e0bffe17 	ldw	r2,-8(fp)
81114294:	1000031e 	bne	r2,zero,811142a4 <main+0x90>
		vFailTestCriticasParts();
81114298:	1116d000 	call	81116d00 <vFailTestCriticasParts>
		return -1;
8111429c:	00bfffc4 	movi	r2,-1
811142a0:	00003706 	br	81114380 <main+0x16c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
811142a4:	1115cb40 	call	81115cb4 <vLoadDefaultETHConf>
811142a8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811142ac:	e0bffe17 	ldw	r2,-8(fp)
811142b0:	1000091e 	bne	r2,zero,811142d8 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
811142b4:	d0a05c17 	ldw	r2,-32400(gp)
811142b8:	100f883a 	mov	r7,r2
811142bc:	01801644 	movi	r6,89
811142c0:	01400044 	movi	r5,1
811142c4:	01204574 	movhi	r4,33045
811142c8:	2122ef04 	addi	r4,r4,-29764
811142cc:	111c1380 	call	8111c138 <fwrite>
		#endif
		return -1;
811142d0:	00bfffc4 	movi	r2,-1
811142d4:	00002a06 	br	81114380 <main+0x16c>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
811142d8:	11166880 	call	81116688 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
811142dc:	1113a5c0 	call	81113a5c <bResourcesInitRTOS>
811142e0:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811142e4:	e0bffe17 	ldw	r2,-8(fp)
811142e8:	1000091e 	bne	r2,zero,81114310 <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
811142ec:	d0a05c17 	ldw	r2,-32400(gp)
811142f0:	100f883a 	mov	r7,r2
811142f4:	01800ac4 	movi	r6,43
811142f8:	01400044 	movi	r5,1
811142fc:	01204574 	movhi	r4,33045
81114300:	21230604 	addi	r4,r4,-29672
81114304:	111c1380 	call	8111c138 <fwrite>
		return -1;
81114308:	00bfffc4 	movi	r2,-1
8111430c:	00001c06 	br	81114380 <main+0x16c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81114310:	01204574 	movhi	r4,33045
81114314:	210c7004 	addi	r4,r4,12736
81114318:	11194e00 	call	811194e0 <vSimucamStructureInit>

	vVariablesInitialization();
8111431c:	1113f000 	call	81113f00 <vVariablesInitialization>

	bInitSync();
81114320:	1119cd40 	call	81119cd4 <bInitSync>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81114324:	d8000415 	stw	zero,16(sp)
81114328:	d8000315 	stw	zero,12(sp)
8111432c:	00810004 	movi	r2,1024
81114330:	d8800215 	stw	r2,8(sp)
81114334:	00a04574 	movhi	r2,33045
81114338:	109b8d04 	addi	r2,r2,28212
8111433c:	d8800115 	stw	r2,4(sp)
81114340:	00800044 	movi	r2,1
81114344:	d8800015 	stw	r2,0(sp)
81114348:	01c00044 	movi	r7,1
8111434c:	01a04574 	movhi	r6,33045
81114350:	319f8c04 	addi	r6,r6,32304
81114354:	000b883a 	mov	r5,zero
81114358:	01204474 	movhi	r4,33041
8111435c:	213ad504 	addi	r4,r4,-5292
81114360:	113a7300 	call	8113a730 <OSTaskCreateExt>
81114364:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81114368:	e0bfff03 	ldbu	r2,-4(fp)
8111436c:	1000021e 	bne	r2,zero,81114378 <main+0x164>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81114370:	1133e640 	call	81133e64 <OSStart>
81114374:	00000106 	br	8111437c <main+0x168>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81114378:	11170ec0 	call	811170ec <vFailInitialization>
	}
  
	return 0;
8111437c:	0005883a 	mov	r2,zero
}
81114380:	e037883a 	mov	sp,fp
81114384:	dfc00117 	ldw	ra,4(sp)
81114388:	df000017 	ldw	fp,0(sp)
8111438c:	dec00204 	addi	sp,sp,8
81114390:	f800283a 	ret

81114394 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81114394:	defff604 	addi	sp,sp,-40
81114398:	de00012e 	bgeu	sp,et,811143a0 <vFillMemmoryPattern+0xc>
8111439c:	003b68fa 	trap	3
811143a0:	dfc00915 	stw	ra,36(sp)
811143a4:	df000815 	stw	fp,32(sp)
811143a8:	df000804 	addi	fp,sp,32
811143ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
811143b0:	00800044 	movi	r2,1
811143b4:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
811143b8:	d0a05c17 	ldw	r2,-32400(gp)
811143bc:	100f883a 	mov	r7,r2
811143c0:	018009c4 	movi	r6,39
811143c4:	01400044 	movi	r5,1
811143c8:	01204574 	movhi	r4,33045
811143cc:	21231104 	addi	r4,r4,-29628
811143d0:	111c1380 	call	8111c138 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811143d4:	e03ffa05 	stb	zero,-24(fp)
811143d8:	00007606 	br	811145b4 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811143dc:	e03ffc85 	stb	zero,-14(fp)
811143e0:	00006706 	br	81114580 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
811143e4:	e0bffc83 	ldbu	r2,-14(fp)
811143e8:	e0ffff17 	ldw	r3,-4(fp)
811143ec:	10809524 	muli	r2,r2,596
811143f0:	1885883a 	add	r2,r3,r2
811143f4:	10804304 	addi	r2,r2,268
811143f8:	1080000b 	ldhu	r2,0(r2)
811143fc:	10ffffcc 	andi	r3,r2,65535
81114400:	e0bffc83 	ldbu	r2,-14(fp)
81114404:	e13fff17 	ldw	r4,-4(fp)
81114408:	10809524 	muli	r2,r2,596
8111440c:	2085883a 	add	r2,r4,r2
81114410:	10804204 	addi	r2,r2,264
81114414:	1080000b 	ldhu	r2,0(r2)
81114418:	10bfffcc 	andi	r2,r2,65535
8111441c:	1885883a 	add	r2,r3,r2
81114420:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81114424:	e0bffc83 	ldbu	r2,-14(fp)
81114428:	e0ffff17 	ldw	r3,-4(fp)
8111442c:	10809524 	muli	r2,r2,596
81114430:	1885883a 	add	r2,r3,r2
81114434:	10804284 	addi	r2,r2,266
81114438:	1080000b 	ldhu	r2,0(r2)
8111443c:	10ffffcc 	andi	r3,r2,65535
81114440:	e0bffc83 	ldbu	r2,-14(fp)
81114444:	e13fff17 	ldw	r4,-4(fp)
81114448:	10809524 	muli	r2,r2,596
8111444c:	2085883a 	add	r2,r4,r2
81114450:	10804184 	addi	r2,r2,262
81114454:	1080000b 	ldhu	r2,0(r2)
81114458:	10bfffcc 	andi	r2,r2,65535
8111445c:	1887883a 	add	r3,r3,r2
81114460:	e0bffc83 	ldbu	r2,-14(fp)
81114464:	e13fff17 	ldw	r4,-4(fp)
81114468:	10809524 	muli	r2,r2,596
8111446c:	2085883a 	add	r2,r4,r2
81114470:	10804104 	addi	r2,r2,260
81114474:	1080000b 	ldhu	r2,0(r2)
81114478:	10bfffcc 	andi	r2,r2,65535
8111447c:	1885883a 	add	r2,r3,r2
81114480:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81114484:	e03ffc05 	stb	zero,-16(fp)
81114488:	00003706 	br	81114568 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111448c:	e03ffc45 	stb	zero,-15(fp)
81114490:	00002606 	br	8111452c <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81114494:	e0bffc43 	ldbu	r2,-15(fp)
81114498:	10000b1e 	bne	r2,zero,811144c8 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
8111449c:	e0bffc83 	ldbu	r2,-14(fp)
811144a0:	e13ffc03 	ldbu	r4,-16(fp)
811144a4:	e0ffff17 	ldw	r3,-4(fp)
811144a8:	21000624 	muli	r4,r4,24
811144ac:	10809524 	muli	r2,r2,596
811144b0:	2085883a 	add	r2,r4,r2
811144b4:	1885883a 	add	r2,r3,r2
811144b8:	10801b04 	addi	r2,r2,108
811144bc:	10800017 	ldw	r2,0(r2)
811144c0:	e0bffb15 	stw	r2,-20(fp)
811144c4:	00000a06 	br	811144f0 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
811144c8:	e0bffc83 	ldbu	r2,-14(fp)
811144cc:	e13ffc03 	ldbu	r4,-16(fp)
811144d0:	e0ffff17 	ldw	r3,-4(fp)
811144d4:	21000624 	muli	r4,r4,24
811144d8:	10809524 	muli	r2,r2,596
811144dc:	2085883a 	add	r2,r4,r2
811144e0:	1885883a 	add	r2,r3,r2
811144e4:	10801e04 	addi	r2,r2,120
811144e8:	10800017 	ldw	r2,0(r2)
811144ec:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811144f0:	e0fffa03 	ldbu	r3,-24(fp)
811144f4:	e13ffc03 	ldbu	r4,-16(fp)
811144f8:	e17ffc43 	ldbu	r5,-15(fp)
811144fc:	e0bffe17 	ldw	r2,-8(fp)
81114500:	d8800115 	stw	r2,4(sp)
81114504:	e0bffd17 	ldw	r2,-12(fp)
81114508:	d8800015 	stw	r2,0(sp)
8111450c:	280f883a 	mov	r7,r5
81114510:	200d883a 	mov	r6,r4
81114514:	e17ffb17 	ldw	r5,-20(fp)
81114518:	1809883a 	mov	r4,r3
8111451c:	11198a40 	call	811198a4 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81114520:	e0bffc43 	ldbu	r2,-15(fp)
81114524:	10800044 	addi	r2,r2,1
81114528:	e0bffc45 	stb	r2,-15(fp)
8111452c:	e0bffc43 	ldbu	r2,-15(fp)
81114530:	108000b0 	cmpltui	r2,r2,2
81114534:	103fd71e 	bne	r2,zero,81114494 <__reset+0xfb0f4494>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81114538:	d0a05c17 	ldw	r2,-32400(gp)
8111453c:	e0fffc83 	ldbu	r3,-14(fp)
81114540:	e13ffc03 	ldbu	r4,-16(fp)
81114544:	200f883a 	mov	r7,r4
81114548:	180d883a 	mov	r6,r3
8111454c:	01604574 	movhi	r5,33045
81114550:	29631b04 	addi	r5,r5,-29588
81114554:	1009883a 	mov	r4,r2
81114558:	111ba9c0 	call	8111ba9c <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8111455c:	e0bffc03 	ldbu	r2,-16(fp)
81114560:	10800044 	addi	r2,r2,1
81114564:	e0bffc05 	stb	r2,-16(fp)
81114568:	e0bffc03 	ldbu	r2,-16(fp)
8111456c:	10800130 	cmpltui	r2,r2,4
81114570:	103fc61e 	bne	r2,zero,8111448c <__reset+0xfb0f448c>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81114574:	e0bffc83 	ldbu	r2,-14(fp)
81114578:	10800044 	addi	r2,r2,1
8111457c:	e0bffc85 	stb	r2,-14(fp)
81114580:	e0fffc83 	ldbu	r3,-14(fp)
81114584:	e0bffcc3 	ldbu	r2,-13(fp)
81114588:	18bf9636 	bltu	r3,r2,811143e4 <__reset+0xfb0f43e4>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
8111458c:	d0a05c17 	ldw	r2,-32400(gp)
81114590:	e0fffa03 	ldbu	r3,-24(fp)
81114594:	180d883a 	mov	r6,r3
81114598:	01604574 	movhi	r5,33045
8111459c:	29632004 	addi	r5,r5,-29568
811145a0:	1009883a 	mov	r4,r2
811145a4:	111ba9c0 	call	8111ba9c <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811145a8:	e0bffa03 	ldbu	r2,-24(fp)
811145ac:	10800044 	addi	r2,r2,1
811145b0:	e0bffa05 	stb	r2,-24(fp)
811145b4:	e0bffa03 	ldbu	r2,-24(fp)
811145b8:	108000b0 	cmpltui	r2,r2,2
811145bc:	103f871e 	bne	r2,zero,811143dc <__reset+0xfb0f43dc>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
811145c0:	d0a05c17 	ldw	r2,-32400(gp)
811145c4:	100f883a 	mov	r7,r2
811145c8:	01800404 	movi	r6,16
811145cc:	01400044 	movi	r5,1
811145d0:	01204574 	movhi	r4,33045
811145d4:	21232404 	addi	r4,r4,-29552
811145d8:	111c1380 	call	8111c138 <fwrite>
#endif


}
811145dc:	0001883a 	nop
811145e0:	e037883a 	mov	sp,fp
811145e4:	dfc00117 	ldw	ra,4(sp)
811145e8:	df000017 	ldw	fp,0(sp)
811145ec:	dec00204 	addi	sp,sp,8
811145f0:	f800283a 	ret

811145f4 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
811145f4:	defff604 	addi	sp,sp,-40
811145f8:	de00012e 	bgeu	sp,et,81114600 <vPrintMemmoryPattern+0xc>
811145fc:	003b68fa 	trap	3
81114600:	dfc00915 	stw	ra,36(sp)
81114604:	df000815 	stw	fp,32(sp)
81114608:	df000804 	addi	fp,sp,32
8111460c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81114610:	00800044 	movi	r2,1
81114614:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81114618:	d0a05c17 	ldw	r2,-32400(gp)
8111461c:	100f883a 	mov	r7,r2
81114620:	018009c4 	movi	r6,39
81114624:	01400044 	movi	r5,1
81114628:	01204574 	movhi	r4,33045
8111462c:	21231104 	addi	r4,r4,-29628
81114630:	111c1380 	call	8111c138 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114634:	e03ffa05 	stb	zero,-24(fp)
81114638:	00007606 	br	81114814 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8111463c:	e03ffc85 	stb	zero,-14(fp)
81114640:	00006706 	br	811147e0 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81114644:	e0bffc83 	ldbu	r2,-14(fp)
81114648:	e0ffff17 	ldw	r3,-4(fp)
8111464c:	10809524 	muli	r2,r2,596
81114650:	1885883a 	add	r2,r3,r2
81114654:	10804304 	addi	r2,r2,268
81114658:	1080000b 	ldhu	r2,0(r2)
8111465c:	10ffffcc 	andi	r3,r2,65535
81114660:	e0bffc83 	ldbu	r2,-14(fp)
81114664:	e13fff17 	ldw	r4,-4(fp)
81114668:	10809524 	muli	r2,r2,596
8111466c:	2085883a 	add	r2,r4,r2
81114670:	10804204 	addi	r2,r2,264
81114674:	1080000b 	ldhu	r2,0(r2)
81114678:	10bfffcc 	andi	r2,r2,65535
8111467c:	1885883a 	add	r2,r3,r2
81114680:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81114684:	e0bffc83 	ldbu	r2,-14(fp)
81114688:	e0ffff17 	ldw	r3,-4(fp)
8111468c:	10809524 	muli	r2,r2,596
81114690:	1885883a 	add	r2,r3,r2
81114694:	10804284 	addi	r2,r2,266
81114698:	1080000b 	ldhu	r2,0(r2)
8111469c:	10ffffcc 	andi	r3,r2,65535
811146a0:	e0bffc83 	ldbu	r2,-14(fp)
811146a4:	e13fff17 	ldw	r4,-4(fp)
811146a8:	10809524 	muli	r2,r2,596
811146ac:	2085883a 	add	r2,r4,r2
811146b0:	10804184 	addi	r2,r2,262
811146b4:	1080000b 	ldhu	r2,0(r2)
811146b8:	10bfffcc 	andi	r2,r2,65535
811146bc:	1887883a 	add	r3,r3,r2
811146c0:	e0bffc83 	ldbu	r2,-14(fp)
811146c4:	e13fff17 	ldw	r4,-4(fp)
811146c8:	10809524 	muli	r2,r2,596
811146cc:	2085883a 	add	r2,r4,r2
811146d0:	10804104 	addi	r2,r2,260
811146d4:	1080000b 	ldhu	r2,0(r2)
811146d8:	10bfffcc 	andi	r2,r2,65535
811146dc:	1885883a 	add	r2,r3,r2
811146e0:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811146e4:	e03ffc05 	stb	zero,-16(fp)
811146e8:	00003706 	br	811147c8 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811146ec:	e03ffc45 	stb	zero,-15(fp)
811146f0:	00002606 	br	8111478c <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
811146f4:	e0bffc43 	ldbu	r2,-15(fp)
811146f8:	10000b1e 	bne	r2,zero,81114728 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811146fc:	e0bffc83 	ldbu	r2,-14(fp)
81114700:	e13ffc03 	ldbu	r4,-16(fp)
81114704:	e0ffff17 	ldw	r3,-4(fp)
81114708:	21000624 	muli	r4,r4,24
8111470c:	10809524 	muli	r2,r2,596
81114710:	2085883a 	add	r2,r4,r2
81114714:	1885883a 	add	r2,r3,r2
81114718:	10801b04 	addi	r2,r2,108
8111471c:	10800017 	ldw	r2,0(r2)
81114720:	e0bffb15 	stw	r2,-20(fp)
81114724:	00000a06 	br	81114750 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81114728:	e0bffc83 	ldbu	r2,-14(fp)
8111472c:	e13ffc03 	ldbu	r4,-16(fp)
81114730:	e0ffff17 	ldw	r3,-4(fp)
81114734:	21000624 	muli	r4,r4,24
81114738:	10809524 	muli	r2,r2,596
8111473c:	2085883a 	add	r2,r4,r2
81114740:	1885883a 	add	r2,r3,r2
81114744:	10801e04 	addi	r2,r2,120
81114748:	10800017 	ldw	r2,0(r2)
8111474c:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81114750:	e0fffa03 	ldbu	r3,-24(fp)
81114754:	e13ffc03 	ldbu	r4,-16(fp)
81114758:	e17ffc43 	ldbu	r5,-15(fp)
8111475c:	e0bffe17 	ldw	r2,-8(fp)
81114760:	d8800115 	stw	r2,4(sp)
81114764:	e0bffd17 	ldw	r2,-12(fp)
81114768:	d8800015 	stw	r2,0(sp)
8111476c:	280f883a 	mov	r7,r5
81114770:	200d883a 	mov	r6,r4
81114774:	e17ffb17 	ldw	r5,-20(fp)
81114778:	1809883a 	mov	r4,r3
8111477c:	11198a40 	call	811198a4 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81114780:	e0bffc43 	ldbu	r2,-15(fp)
81114784:	10800044 	addi	r2,r2,1
81114788:	e0bffc45 	stb	r2,-15(fp)
8111478c:	e0bffc43 	ldbu	r2,-15(fp)
81114790:	108000b0 	cmpltui	r2,r2,2
81114794:	103fd71e 	bne	r2,zero,811146f4 <__reset+0xfb0f46f4>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81114798:	d0a05c17 	ldw	r2,-32400(gp)
8111479c:	e0fffc83 	ldbu	r3,-14(fp)
811147a0:	e13ffc03 	ldbu	r4,-16(fp)
811147a4:	200f883a 	mov	r7,r4
811147a8:	180d883a 	mov	r6,r3
811147ac:	01604574 	movhi	r5,33045
811147b0:	29631b04 	addi	r5,r5,-29588
811147b4:	1009883a 	mov	r4,r2
811147b8:	111ba9c0 	call	8111ba9c <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811147bc:	e0bffc03 	ldbu	r2,-16(fp)
811147c0:	10800044 	addi	r2,r2,1
811147c4:	e0bffc05 	stb	r2,-16(fp)
811147c8:	e0bffc03 	ldbu	r2,-16(fp)
811147cc:	10800130 	cmpltui	r2,r2,4
811147d0:	103fc61e 	bne	r2,zero,811146ec <__reset+0xfb0f46ec>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811147d4:	e0bffc83 	ldbu	r2,-14(fp)
811147d8:	10800044 	addi	r2,r2,1
811147dc:	e0bffc85 	stb	r2,-14(fp)
811147e0:	e0fffc83 	ldbu	r3,-14(fp)
811147e4:	e0bffcc3 	ldbu	r2,-13(fp)
811147e8:	18bf9636 	bltu	r3,r2,81114644 <__reset+0xfb0f4644>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
811147ec:	d0a05c17 	ldw	r2,-32400(gp)
811147f0:	e0fffa03 	ldbu	r3,-24(fp)
811147f4:	180d883a 	mov	r6,r3
811147f8:	01604574 	movhi	r5,33045
811147fc:	29632004 	addi	r5,r5,-29568
81114800:	1009883a 	mov	r4,r2
81114804:	111ba9c0 	call	8111ba9c <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81114808:	e0bffa03 	ldbu	r2,-24(fp)
8111480c:	10800044 	addi	r2,r2,1
81114810:	e0bffa05 	stb	r2,-24(fp)
81114814:	e0bffa03 	ldbu	r2,-24(fp)
81114818:	108000b0 	cmpltui	r2,r2,2
8111481c:	103f871e 	bne	r2,zero,8111463c <__reset+0xfb0f463c>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81114820:	d0a05c17 	ldw	r2,-32400(gp)
81114824:	100f883a 	mov	r7,r2
81114828:	01800404 	movi	r6,16
8111482c:	01400044 	movi	r5,1
81114830:	01204574 	movhi	r4,33045
81114834:	21232404 	addi	r4,r4,-29552
81114838:	111c1380 	call	8111c138 <fwrite>
#endif


}
8111483c:	0001883a 	nop
81114840:	e037883a 	mov	sp,fp
81114844:	dfc00117 	ldw	ra,4(sp)
81114848:	df000017 	ldw	fp,0(sp)
8111484c:	dec00204 	addi	sp,sp,8
81114850:	f800283a 	ret

81114854 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81114854:	defffe04 	addi	sp,sp,-8
81114858:	de00012e 	bgeu	sp,et,81114860 <vCCDLoadDefaultValues+0xc>
8111485c:	003b68fa 	trap	3
81114860:	df000115 	stw	fp,4(sp)
81114864:	df000104 	addi	fp,sp,4
81114868:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
8111486c:	e0bfff17 	ldw	r2,-4(fp)
81114870:	00c46784 	movi	r3,4510
81114874:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
81114878:	e0bfff17 	ldw	r2,-4(fp)
8111487c:	00c00784 	movi	r3,30
81114880:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
81114884:	e0bfff17 	ldw	r2,-4(fp)
81114888:	00c233c4 	movi	r3,2255
8111488c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
81114890:	e0bfff17 	ldw	r2,-4(fp)
81114894:	00c003c4 	movi	r3,15
81114898:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
8111489c:	e0bfff17 	ldw	r2,-4(fp)
811148a0:	00c00644 	movi	r3,25
811148a4:	10c0000d 	sth	r3,0(r2)
}
811148a8:	0001883a 	nop
811148ac:	e037883a 	mov	sp,fp
811148b0:	df000017 	ldw	fp,0(sp)
811148b4:	dec00104 	addi	sp,sp,4
811148b8:	f800283a 	ret

811148bc <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
811148bc:	defff904 	addi	sp,sp,-28
811148c0:	de00012e 	bgeu	sp,et,811148c8 <vCCDChangeValues+0xc>
811148c4:	003b68fa 	trap	3
811148c8:	df000615 	stw	fp,24(sp)
811148cc:	df000604 	addi	fp,sp,24
811148d0:	e13ffa15 	stw	r4,-24(fp)
811148d4:	2811883a 	mov	r8,r5
811148d8:	300b883a 	mov	r5,r6
811148dc:	3809883a 	mov	r4,r7
811148e0:	e0c00117 	ldw	r3,4(fp)
811148e4:	e0800217 	ldw	r2,8(fp)
811148e8:	e23ffb0d 	sth	r8,-20(fp)
811148ec:	e17ffc0d 	sth	r5,-16(fp)
811148f0:	e13ffd0d 	sth	r4,-12(fp)
811148f4:	e0fffe0d 	sth	r3,-8(fp)
811148f8:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
811148fc:	e0bffa17 	ldw	r2,-24(fp)
81114900:	e0fffb0b 	ldhu	r3,-20(fp)
81114904:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81114908:	e0bffa17 	ldw	r2,-24(fp)
8111490c:	e0fffc0b 	ldhu	r3,-16(fp)
81114910:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81114914:	e0bffa17 	ldw	r2,-24(fp)
81114918:	e0fffd0b 	ldhu	r3,-12(fp)
8111491c:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81114920:	e0bffa17 	ldw	r2,-24(fp)
81114924:	e0fffe0b 	ldhu	r3,-8(fp)
81114928:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
8111492c:	e0bffa17 	ldw	r2,-24(fp)
81114930:	e0ffff0b 	ldhu	r3,-4(fp)
81114934:	10c0000d 	sth	r3,0(r2)
}
81114938:	0001883a 	nop
8111493c:	e037883a 	mov	sp,fp
81114940:	df000017 	ldw	fp,0(sp)
81114944:	dec00104 	addi	sp,sp,4
81114948:	f800283a 	ret

8111494c <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
8111494c:	defff904 	addi	sp,sp,-28
81114950:	de00012e 	bgeu	sp,et,81114958 <bSendUART128v2+0xc>
81114954:	003b68fa 	trap	3
81114958:	dfc00615 	stw	ra,24(sp)
8111495c:	df000515 	stw	fp,20(sp)
81114960:	df000504 	addi	fp,sp,20
81114964:	e13ffe15 	stw	r4,-8(fp)
81114968:	2805883a 	mov	r2,r5
8111496c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81114970:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114974:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81114978:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
8111497c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81114980:	d0a05d17 	ldw	r2,-32396(gp)
81114984:	e0fffd04 	addi	r3,fp,-12
81114988:	180d883a 	mov	r6,r3
8111498c:	01400504 	movi	r5,20
81114990:	1009883a 	mov	r4,r2
81114994:	1139b780 	call	81139b78 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81114998:	e0bffd03 	ldbu	r2,-12(fp)
8111499c:	10803fcc 	andi	r2,r2,255
811149a0:	10000326 	beq	r2,zero,811149b0 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811149a4:	11173540 	call	81117354 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
811149a8:	e0bffc17 	ldw	r2,-16(fp)
811149ac:	00009e06 	br	81114c28 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811149b0:	d0a06817 	ldw	r2,-32352(gp)
811149b4:	e0fffd04 	addi	r3,fp,-12
811149b8:	180d883a 	mov	r6,r3
811149bc:	01400104 	movi	r5,4
811149c0:	1009883a 	mov	r4,r2
811149c4:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811149c8:	e0bffd03 	ldbu	r2,-12(fp)
811149cc:	10803fcc 	andi	r2,r2,255
811149d0:	10001126 	beq	r2,zero,81114a18 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
811149d4:	d0a05c17 	ldw	r2,-32400(gp)
811149d8:	100f883a 	mov	r7,r2
811149dc:	01801484 	movi	r6,82
811149e0:	01400044 	movi	r5,1
811149e4:	01204574 	movhi	r4,33045
811149e8:	21232904 	addi	r4,r4,-29532
811149ec:	111c1380 	call	8111c138 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811149f0:	d0a05d17 	ldw	r2,-32396(gp)
811149f4:	1009883a 	mov	r4,r2
811149f8:	1139f000 	call	81139f00 <OSSemPost>
811149fc:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81114a00:	e0bffd03 	ldbu	r2,-12(fp)
81114a04:	10803fcc 	andi	r2,r2,255
81114a08:	10000126 	beq	r2,zero,81114a10 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81114a0c:	11172ec0 	call	811172ec <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81114a10:	e0bffc17 	ldw	r2,-16(fp)
81114a14:	00008406 	br	81114c28 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114a18:	e03ffb05 	stb	zero,-20(fp)
81114a1c:	00004306 	br	81114b2c <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81114a20:	e0fffb03 	ldbu	r3,-20(fp)
81114a24:	00a045b4 	movhi	r2,33046
81114a28:	10a39104 	addi	r2,r2,-29116
81114a2c:	18c7883a 	add	r3,r3,r3
81114a30:	18c7883a 	add	r3,r3,r3
81114a34:	10c5883a 	add	r2,r2,r3
81114a38:	10800017 	ldw	r2,0(r2)
81114a3c:	1000381e 	bne	r2,zero,81114b20 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81114a40:	e0bffb03 	ldbu	r2,-20(fp)
81114a44:	10c02324 	muli	r3,r2,140
81114a48:	00a045b4 	movhi	r2,33046
81114a4c:	10a3af04 	addi	r2,r2,-28996
81114a50:	1885883a 	add	r2,r3,r2
81114a54:	01802004 	movi	r6,128
81114a58:	000b883a 	mov	r5,zero
81114a5c:	1009883a 	mov	r4,r2
81114a60:	111cc9c0 	call	8111cc9c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81114a64:	e0bffb03 	ldbu	r2,-20(fp)
81114a68:	10c02324 	muli	r3,r2,140
81114a6c:	00a045b4 	movhi	r2,33046
81114a70:	10a3af04 	addi	r2,r2,-28996
81114a74:	1885883a 	add	r2,r3,r2
81114a78:	01801fc4 	movi	r6,127
81114a7c:	e17ffe17 	ldw	r5,-8(fp)
81114a80:	1009883a 	mov	r4,r2
81114a84:	111cb4c0 	call	8111cb4c <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81114a88:	e13ffb03 	ldbu	r4,-20(fp)
81114a8c:	e0ffff0b 	ldhu	r3,-4(fp)
81114a90:	00a045b4 	movhi	r2,33046
81114a94:	10a3af04 	addi	r2,r2,-28996
81114a98:	21002324 	muli	r4,r4,140
81114a9c:	1105883a 	add	r2,r2,r4
81114aa0:	10802104 	addi	r2,r2,132
81114aa4:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81114aa8:	e0fffb03 	ldbu	r3,-20(fp)
81114aac:	00a045b4 	movhi	r2,33046
81114ab0:	10a3af04 	addi	r2,r2,-28996
81114ab4:	18c02324 	muli	r3,r3,140
81114ab8:	10c5883a 	add	r2,r2,r3
81114abc:	10802204 	addi	r2,r2,136
81114ac0:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81114ac4:	e0fffb03 	ldbu	r3,-20(fp)
81114ac8:	00a045b4 	movhi	r2,33046
81114acc:	10a3af04 	addi	r2,r2,-28996
81114ad0:	18c02324 	muli	r3,r3,140
81114ad4:	10c5883a 	add	r2,r2,r3
81114ad8:	10802184 	addi	r2,r2,134
81114adc:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81114ae0:	e0fffb03 	ldbu	r3,-20(fp)
81114ae4:	00a045b4 	movhi	r2,33046
81114ae8:	10a3af04 	addi	r2,r2,-28996
81114aec:	18c02324 	muli	r3,r3,140
81114af0:	10c5883a 	add	r2,r2,r3
81114af4:	10802004 	addi	r2,r2,128
81114af8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81114afc:	e0fffb03 	ldbu	r3,-20(fp)
81114b00:	00a045b4 	movhi	r2,33046
81114b04:	10a39104 	addi	r2,r2,-29116
81114b08:	18c7883a 	add	r3,r3,r3
81114b0c:	18c7883a 	add	r3,r3,r3
81114b10:	10c5883a 	add	r2,r2,r3
81114b14:	00c00044 	movi	r3,1
81114b18:	10c00015 	stw	r3,0(r2)
			break;
81114b1c:	00000606 	br	81114b38 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114b20:	e0bffb03 	ldbu	r2,-20(fp)
81114b24:	10800044 	addi	r2,r2,1
81114b28:	e0bffb05 	stb	r2,-20(fp)
81114b2c:	e0bffb03 	ldbu	r2,-20(fp)
81114b30:	108001b0 	cmpltui	r2,r2,6
81114b34:	103fba1e 	bne	r2,zero,81114a20 <__reset+0xfb0f4a20>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81114b38:	e0bffb03 	ldbu	r2,-20(fp)
81114b3c:	108001b0 	cmpltui	r2,r2,6
81114b40:	1000091e 	bne	r2,zero,81114b68 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81114b44:	d0a05d17 	ldw	r2,-32396(gp)
81114b48:	1009883a 	mov	r4,r2
81114b4c:	1139f000 	call	81139f00 <OSSemPost>
81114b50:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81114b54:	d0a06817 	ldw	r2,-32352(gp)
81114b58:	1009883a 	mov	r4,r2
81114b5c:	11381100 	call	81138110 <OSMutexPost>
		return bSuccessL;
81114b60:	e0bffc17 	ldw	r2,-16(fp)
81114b64:	00003006 	br	81114c28 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81114b68:	00800044 	movi	r2,1
81114b6c:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81114b70:	d0a06f43 	ldbu	r2,-32323(gp)
81114b74:	10bfffc4 	addi	r2,r2,-1
81114b78:	d0a06f45 	stb	r2,-32323(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81114b7c:	d0a06e17 	ldw	r2,-32328(gp)
81114b80:	e0fffd04 	addi	r3,fp,-12
81114b84:	180d883a 	mov	r6,r3
81114b88:	01400084 	movi	r5,2
81114b8c:	1009883a 	mov	r4,r2
81114b90:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114b94:	e0bffd03 	ldbu	r2,-12(fp)
81114b98:	10803fcc 	andi	r2,r2,255
81114b9c:	10000c26 	beq	r2,zero,81114bd0 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81114ba0:	d0a05c17 	ldw	r2,-32400(gp)
81114ba4:	100f883a 	mov	r7,r2
81114ba8:	01801c04 	movi	r6,112
81114bac:	01400044 	movi	r5,1
81114bb0:	01204574 	movhi	r4,33045
81114bb4:	21233e04 	addi	r4,r4,-29448
81114bb8:	111c1380 	call	8111c138 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81114bbc:	d0a06817 	ldw	r2,-32352(gp)
81114bc0:	1009883a 	mov	r4,r2
81114bc4:	11381100 	call	81138110 <OSMutexPost>
		return bSuccessL;
81114bc8:	e0bffc17 	ldw	r2,-16(fp)
81114bcc:	00001606 	br	81114c28 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81114bd0:	e0bffb03 	ldbu	r2,-20(fp)
81114bd4:	10c02324 	muli	r3,r2,140
81114bd8:	00a045b4 	movhi	r2,33046
81114bdc:	10a3af04 	addi	r2,r2,-28996
81114be0:	1885883a 	add	r2,r3,r2
81114be4:	1009883a 	mov	r4,r2
81114be8:	111d0e80 	call	8111d0e8 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81114bec:	e0fffb03 	ldbu	r3,-20(fp)
81114bf0:	00a045b4 	movhi	r2,33046
81114bf4:	10a3af04 	addi	r2,r2,-28996
81114bf8:	18c02324 	muli	r3,r3,140
81114bfc:	10c5883a 	add	r2,r2,r3
81114c00:	10802004 	addi	r2,r2,128
81114c04:	00c00044 	movi	r3,1
81114c08:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81114c0c:	d0a06e17 	ldw	r2,-32328(gp)
81114c10:	1009883a 	mov	r4,r2
81114c14:	11381100 	call	81138110 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81114c18:	d0a06817 	ldw	r2,-32352(gp)
81114c1c:	1009883a 	mov	r4,r2
81114c20:	11381100 	call	81138110 <OSMutexPost>

	return bSuccessL;
81114c24:	e0bffc17 	ldw	r2,-16(fp)
}
81114c28:	e037883a 	mov	sp,fp
81114c2c:	dfc00117 	ldw	ra,4(sp)
81114c30:	df000017 	ldw	fp,0(sp)
81114c34:	dec00204 	addi	sp,sp,8
81114c38:	f800283a 	ret

81114c3c <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81114c3c:	defff904 	addi	sp,sp,-28
81114c40:	de00012e 	bgeu	sp,et,81114c48 <bSendUART64v2+0xc>
81114c44:	003b68fa 	trap	3
81114c48:	dfc00615 	stw	ra,24(sp)
81114c4c:	df000515 	stw	fp,20(sp)
81114c50:	df000504 	addi	fp,sp,20
81114c54:	e13ffe15 	stw	r4,-8(fp)
81114c58:	2805883a 	mov	r2,r5
81114c5c:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81114c60:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114c64:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81114c68:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81114c6c:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81114c70:	d0a05817 	ldw	r2,-32416(gp)
81114c74:	e0fffd04 	addi	r3,fp,-12
81114c78:	180d883a 	mov	r6,r3
81114c7c:	01400504 	movi	r5,20
81114c80:	1009883a 	mov	r4,r2
81114c84:	1139b780 	call	81139b78 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81114c88:	e0bffd03 	ldbu	r2,-12(fp)
81114c8c:	10803fcc 	andi	r2,r2,255
81114c90:	10000326 	beq	r2,zero,81114ca0 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81114c94:	11173bc0 	call	811173bc <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81114c98:	e0bffc17 	ldw	r2,-16(fp)
81114c9c:	0000a006 	br	81114f20 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81114ca0:	d0a06b17 	ldw	r2,-32340(gp)
81114ca4:	e0fffd04 	addi	r3,fp,-12
81114ca8:	180d883a 	mov	r6,r3
81114cac:	01400104 	movi	r5,4
81114cb0:	1009883a 	mov	r4,r2
81114cb4:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114cb8:	e0bffd03 	ldbu	r2,-12(fp)
81114cbc:	10803fcc 	andi	r2,r2,255
81114cc0:	10001126 	beq	r2,zero,81114d08 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81114cc4:	d0a05c17 	ldw	r2,-32400(gp)
81114cc8:	100f883a 	mov	r7,r2
81114ccc:	018013c4 	movi	r6,79
81114cd0:	01400044 	movi	r5,1
81114cd4:	01204574 	movhi	r4,33045
81114cd8:	21235b04 	addi	r4,r4,-29332
81114cdc:	111c1380 	call	8111c138 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81114ce0:	d0a05817 	ldw	r2,-32416(gp)
81114ce4:	1009883a 	mov	r4,r2
81114ce8:	1139f000 	call	81139f00 <OSSemPost>
81114cec:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81114cf0:	e0bffd03 	ldbu	r2,-12(fp)
81114cf4:	10803fcc 	andi	r2,r2,255
81114cf8:	10000126 	beq	r2,zero,81114d00 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81114cfc:	11172840 	call	81117284 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81114d00:	e0bffc17 	ldw	r2,-16(fp)
81114d04:	00008606 	br	81114f20 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81114d08:	e03ffb05 	stb	zero,-20(fp)
81114d0c:	00004506 	br	81114e24 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81114d10:	e0fffb03 	ldbu	r3,-20(fp)
81114d14:	00a045b4 	movhi	r2,33046
81114d18:	10a39104 	addi	r2,r2,-29116
81114d1c:	18c00184 	addi	r3,r3,6
81114d20:	18c7883a 	add	r3,r3,r3
81114d24:	18c7883a 	add	r3,r3,r3
81114d28:	10c5883a 	add	r2,r2,r3
81114d2c:	10800017 	ldw	r2,0(r2)
81114d30:	1000391e 	bne	r2,zero,81114e18 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81114d34:	e0bffb03 	ldbu	r2,-20(fp)
81114d38:	10c01324 	muli	r3,r2,76
81114d3c:	00a04574 	movhi	r2,33045
81114d40:	10bf7004 	addi	r2,r2,-576
81114d44:	1885883a 	add	r2,r3,r2
81114d48:	01801004 	movi	r6,64
81114d4c:	000b883a 	mov	r5,zero
81114d50:	1009883a 	mov	r4,r2
81114d54:	111cc9c0 	call	8111cc9c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81114d58:	e0bffb03 	ldbu	r2,-20(fp)
81114d5c:	10c01324 	muli	r3,r2,76
81114d60:	00a04574 	movhi	r2,33045
81114d64:	10bf7004 	addi	r2,r2,-576
81114d68:	1885883a 	add	r2,r3,r2
81114d6c:	01800fc4 	movi	r6,63
81114d70:	e17ffe17 	ldw	r5,-8(fp)
81114d74:	1009883a 	mov	r4,r2
81114d78:	111cb4c0 	call	8111cb4c <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81114d7c:	e13ffb03 	ldbu	r4,-20(fp)
81114d80:	e0ffff0b 	ldhu	r3,-4(fp)
81114d84:	00a04574 	movhi	r2,33045
81114d88:	10bf7004 	addi	r2,r2,-576
81114d8c:	21001324 	muli	r4,r4,76
81114d90:	1105883a 	add	r2,r2,r4
81114d94:	10801104 	addi	r2,r2,68
81114d98:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81114d9c:	e0fffb03 	ldbu	r3,-20(fp)
81114da0:	00a04574 	movhi	r2,33045
81114da4:	10bf7004 	addi	r2,r2,-576
81114da8:	18c01324 	muli	r3,r3,76
81114dac:	10c5883a 	add	r2,r2,r3
81114db0:	10801204 	addi	r2,r2,72
81114db4:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81114db8:	e0fffb03 	ldbu	r3,-20(fp)
81114dbc:	00a04574 	movhi	r2,33045
81114dc0:	10bf7004 	addi	r2,r2,-576
81114dc4:	18c01324 	muli	r3,r3,76
81114dc8:	10c5883a 	add	r2,r2,r3
81114dcc:	10801184 	addi	r2,r2,70
81114dd0:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81114dd4:	e0fffb03 	ldbu	r3,-20(fp)
81114dd8:	00a04574 	movhi	r2,33045
81114ddc:	10bf7004 	addi	r2,r2,-576
81114de0:	18c01324 	muli	r3,r3,76
81114de4:	10c5883a 	add	r2,r2,r3
81114de8:	10801004 	addi	r2,r2,64
81114dec:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81114df0:	e0fffb03 	ldbu	r3,-20(fp)
81114df4:	00a045b4 	movhi	r2,33046
81114df8:	10a39104 	addi	r2,r2,-29116
81114dfc:	18c00184 	addi	r3,r3,6
81114e00:	18c7883a 	add	r3,r3,r3
81114e04:	18c7883a 	add	r3,r3,r3
81114e08:	10c5883a 	add	r2,r2,r3
81114e0c:	00c00044 	movi	r3,1
81114e10:	10c00015 	stw	r3,0(r2)
			break;
81114e14:	00000606 	br	81114e30 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81114e18:	e0bffb03 	ldbu	r2,-20(fp)
81114e1c:	10800044 	addi	r2,r2,1
81114e20:	e0bffb05 	stb	r2,-20(fp)
81114e24:	e0bffb03 	ldbu	r2,-20(fp)
81114e28:	10800230 	cmpltui	r2,r2,8
81114e2c:	103fb81e 	bne	r2,zero,81114d10 <__reset+0xfb0f4d10>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81114e30:	e0bffb03 	ldbu	r2,-20(fp)
81114e34:	10800230 	cmpltui	r2,r2,8
81114e38:	1000091e 	bne	r2,zero,81114e60 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81114e3c:	d0a05817 	ldw	r2,-32416(gp)
81114e40:	1009883a 	mov	r4,r2
81114e44:	1139f000 	call	81139f00 <OSSemPost>
81114e48:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81114e4c:	d0a06b17 	ldw	r2,-32340(gp)
81114e50:	1009883a 	mov	r4,r2
81114e54:	11381100 	call	81138110 <OSMutexPost>
		return bSuccessL;
81114e58:	e0bffc17 	ldw	r2,-16(fp)
81114e5c:	00003006 	br	81114f20 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
81114e60:	00800044 	movi	r2,1
81114e64:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81114e68:	d0a06f03 	ldbu	r2,-32324(gp)
81114e6c:	10bfffc4 	addi	r2,r2,-1
81114e70:	d0a06f05 	stb	r2,-32324(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81114e74:	d0a06e17 	ldw	r2,-32328(gp)
81114e78:	e0fffd04 	addi	r3,fp,-12
81114e7c:	180d883a 	mov	r6,r3
81114e80:	01400084 	movi	r5,2
81114e84:	1009883a 	mov	r4,r2
81114e88:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114e8c:	e0bffd03 	ldbu	r2,-12(fp)
81114e90:	10803fcc 	andi	r2,r2,255
81114e94:	10000c26 	beq	r2,zero,81114ec8 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81114e98:	d0a05c17 	ldw	r2,-32400(gp)
81114e9c:	100f883a 	mov	r7,r2
81114ea0:	01801bc4 	movi	r6,111
81114ea4:	01400044 	movi	r5,1
81114ea8:	01204574 	movhi	r4,33045
81114eac:	21236f04 	addi	r4,r4,-29252
81114eb0:	111c1380 	call	8111c138 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81114eb4:	d0a06b17 	ldw	r2,-32340(gp)
81114eb8:	1009883a 	mov	r4,r2
81114ebc:	11381100 	call	81138110 <OSMutexPost>
		return bSuccessL;
81114ec0:	e0bffc17 	ldw	r2,-16(fp)
81114ec4:	00001606 	br	81114f20 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81114ec8:	e0bffb03 	ldbu	r2,-20(fp)
81114ecc:	10c01324 	muli	r3,r2,76
81114ed0:	00a04574 	movhi	r2,33045
81114ed4:	10bf7004 	addi	r2,r2,-576
81114ed8:	1885883a 	add	r2,r3,r2
81114edc:	1009883a 	mov	r4,r2
81114ee0:	111d0e80 	call	8111d0e8 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81114ee4:	e0fffb03 	ldbu	r3,-20(fp)
81114ee8:	00a04574 	movhi	r2,33045
81114eec:	10bf7004 	addi	r2,r2,-576
81114ef0:	18c01324 	muli	r3,r3,76
81114ef4:	10c5883a 	add	r2,r2,r3
81114ef8:	10801004 	addi	r2,r2,64
81114efc:	00c00044 	movi	r3,1
81114f00:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81114f04:	d0a06e17 	ldw	r2,-32328(gp)
81114f08:	1009883a 	mov	r4,r2
81114f0c:	11381100 	call	81138110 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81114f10:	d0a06b17 	ldw	r2,-32340(gp)
81114f14:	1009883a 	mov	r4,r2
81114f18:	11381100 	call	81138110 <OSMutexPost>

	return bSuccessL;
81114f1c:	e0bffc17 	ldw	r2,-16(fp)
}
81114f20:	e037883a 	mov	sp,fp
81114f24:	dfc00117 	ldw	ra,4(sp)
81114f28:	df000017 	ldw	fp,0(sp)
81114f2c:	dec00204 	addi	sp,sp,8
81114f30:	f800283a 	ret

81114f34 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81114f34:	defff904 	addi	sp,sp,-28
81114f38:	de00012e 	bgeu	sp,et,81114f40 <bSendUART32v2+0xc>
81114f3c:	003b68fa 	trap	3
81114f40:	dfc00615 	stw	ra,24(sp)
81114f44:	df000515 	stw	fp,20(sp)
81114f48:	df000504 	addi	fp,sp,20
81114f4c:	e13ffe15 	stw	r4,-8(fp)
81114f50:	2805883a 	mov	r2,r5
81114f54:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81114f58:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81114f5c:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81114f60:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81114f64:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81114f68:	d0a06917 	ldw	r2,-32348(gp)
81114f6c:	e0fffd04 	addi	r3,fp,-12
81114f70:	180d883a 	mov	r6,r3
81114f74:	01400504 	movi	r5,20
81114f78:	1009883a 	mov	r4,r2
81114f7c:	1139b780 	call	81139b78 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81114f80:	e0bffd03 	ldbu	r2,-12(fp)
81114f84:	10803fcc 	andi	r2,r2,255
81114f88:	10000326 	beq	r2,zero,81114f98 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81114f8c:	11174240 	call	81117424 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
81114f90:	e0bffc17 	ldw	r2,-16(fp)
81114f94:	0000a006 	br	81115218 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81114f98:	d0a06617 	ldw	r2,-32360(gp)
81114f9c:	e0fffd04 	addi	r3,fp,-12
81114fa0:	180d883a 	mov	r6,r3
81114fa4:	01400104 	movi	r5,4
81114fa8:	1009883a 	mov	r4,r2
81114fac:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81114fb0:	e0bffd03 	ldbu	r2,-12(fp)
81114fb4:	10803fcc 	andi	r2,r2,255
81114fb8:	10001126 	beq	r2,zero,81115000 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81114fbc:	d0a05c17 	ldw	r2,-32400(gp)
81114fc0:	100f883a 	mov	r7,r2
81114fc4:	018013c4 	movi	r6,79
81114fc8:	01400044 	movi	r5,1
81114fcc:	01204574 	movhi	r4,33045
81114fd0:	21238b04 	addi	r4,r4,-29140
81114fd4:	111c1380 	call	8111c138 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81114fd8:	d0a06917 	ldw	r2,-32348(gp)
81114fdc:	1009883a 	mov	r4,r2
81114fe0:	1139f000 	call	81139f00 <OSSemPost>
81114fe4:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81114fe8:	e0bffd03 	ldbu	r2,-12(fp)
81114fec:	10803fcc 	andi	r2,r2,255
81114ff0:	10000126 	beq	r2,zero,81114ff8 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81114ff4:	111721c0 	call	8111721c <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81114ff8:	e0bffc17 	ldw	r2,-16(fp)
81114ffc:	00008606 	br	81115218 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81115000:	e03ffb05 	stb	zero,-20(fp)
81115004:	00004506 	br	8111511c <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81115008:	e0fffb03 	ldbu	r3,-20(fp)
8111500c:	00a045b4 	movhi	r2,33046
81115010:	10a39104 	addi	r2,r2,-29116
81115014:	18c00384 	addi	r3,r3,14
81115018:	18c7883a 	add	r3,r3,r3
8111501c:	18c7883a 	add	r3,r3,r3
81115020:	10c5883a 	add	r2,r2,r3
81115024:	10800017 	ldw	r2,0(r2)
81115028:	1000391e 	bne	r2,zero,81115110 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
8111502c:	e0bffb03 	ldbu	r2,-20(fp)
81115030:	10c00b24 	muli	r3,r2,44
81115034:	00a04574 	movhi	r2,33045
81115038:	10911d04 	addi	r2,r2,17524
8111503c:	1885883a 	add	r2,r3,r2
81115040:	01800804 	movi	r6,32
81115044:	000b883a 	mov	r5,zero
81115048:	1009883a 	mov	r4,r2
8111504c:	111cc9c0 	call	8111cc9c <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81115050:	e0bffb03 	ldbu	r2,-20(fp)
81115054:	10c00b24 	muli	r3,r2,44
81115058:	00a04574 	movhi	r2,33045
8111505c:	10911d04 	addi	r2,r2,17524
81115060:	1885883a 	add	r2,r3,r2
81115064:	018007c4 	movi	r6,31
81115068:	e17ffe17 	ldw	r5,-8(fp)
8111506c:	1009883a 	mov	r4,r2
81115070:	111cb4c0 	call	8111cb4c <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81115074:	e13ffb03 	ldbu	r4,-20(fp)
81115078:	e0ffff0b 	ldhu	r3,-4(fp)
8111507c:	00a04574 	movhi	r2,33045
81115080:	10911d04 	addi	r2,r2,17524
81115084:	21000b24 	muli	r4,r4,44
81115088:	1105883a 	add	r2,r2,r4
8111508c:	10800904 	addi	r2,r2,36
81115090:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81115094:	e0fffb03 	ldbu	r3,-20(fp)
81115098:	00a04574 	movhi	r2,33045
8111509c:	10911d04 	addi	r2,r2,17524
811150a0:	18c00b24 	muli	r3,r3,44
811150a4:	10c5883a 	add	r2,r2,r3
811150a8:	10800a04 	addi	r2,r2,40
811150ac:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
811150b0:	e0fffb03 	ldbu	r3,-20(fp)
811150b4:	00a04574 	movhi	r2,33045
811150b8:	10911d04 	addi	r2,r2,17524
811150bc:	18c00b24 	muli	r3,r3,44
811150c0:	10c5883a 	add	r2,r2,r3
811150c4:	10800984 	addi	r2,r2,38
811150c8:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
811150cc:	e0fffb03 	ldbu	r3,-20(fp)
811150d0:	00a04574 	movhi	r2,33045
811150d4:	10911d04 	addi	r2,r2,17524
811150d8:	18c00b24 	muli	r3,r3,44
811150dc:	10c5883a 	add	r2,r2,r3
811150e0:	10800804 	addi	r2,r2,32
811150e4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
811150e8:	e0fffb03 	ldbu	r3,-20(fp)
811150ec:	00a045b4 	movhi	r2,33046
811150f0:	10a39104 	addi	r2,r2,-29116
811150f4:	18c00384 	addi	r3,r3,14
811150f8:	18c7883a 	add	r3,r3,r3
811150fc:	18c7883a 	add	r3,r3,r3
81115100:	10c5883a 	add	r2,r2,r3
81115104:	00c00044 	movi	r3,1
81115108:	10c00015 	stw	r3,0(r2)
			break;
8111510c:	00000606 	br	81115128 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81115110:	e0bffb03 	ldbu	r2,-20(fp)
81115114:	10800044 	addi	r2,r2,1
81115118:	e0bffb05 	stb	r2,-20(fp)
8111511c:	e0bffb03 	ldbu	r2,-20(fp)
81115120:	10800230 	cmpltui	r2,r2,8
81115124:	103fb81e 	bne	r2,zero,81115008 <__reset+0xfb0f5008>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81115128:	e0bffb03 	ldbu	r2,-20(fp)
8111512c:	10800230 	cmpltui	r2,r2,8
81115130:	1000091e 	bne	r2,zero,81115158 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81115134:	d0a06917 	ldw	r2,-32348(gp)
81115138:	1009883a 	mov	r4,r2
8111513c:	1139f000 	call	81139f00 <OSSemPost>
81115140:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81115144:	d0a06617 	ldw	r2,-32360(gp)
81115148:	1009883a 	mov	r4,r2
8111514c:	11381100 	call	81138110 <OSMutexPost>
		return bSuccessL;
81115150:	e0bffc17 	ldw	r2,-16(fp)
81115154:	00003006 	br	81115218 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81115158:	00800044 	movi	r2,1
8111515c:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81115160:	d0a06283 	ldbu	r2,-32374(gp)
81115164:	10bfffc4 	addi	r2,r2,-1
81115168:	d0a06285 	stb	r2,-32374(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
8111516c:	d0a06e17 	ldw	r2,-32328(gp)
81115170:	e0fffd04 	addi	r3,fp,-12
81115174:	180d883a 	mov	r6,r3
81115178:	01400084 	movi	r5,2
8111517c:	1009883a 	mov	r4,r2
81115180:	1137b6c0 	call	81137b6c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81115184:	e0bffd03 	ldbu	r2,-12(fp)
81115188:	10803fcc 	andi	r2,r2,255
8111518c:	10000c26 	beq	r2,zero,811151c0 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81115190:	d0a05c17 	ldw	r2,-32400(gp)
81115194:	100f883a 	mov	r7,r2
81115198:	01801bc4 	movi	r6,111
8111519c:	01400044 	movi	r5,1
811151a0:	01204574 	movhi	r4,33045
811151a4:	21239f04 	addi	r4,r4,-29060
811151a8:	111c1380 	call	8111c138 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
811151ac:	d0a06617 	ldw	r2,-32360(gp)
811151b0:	1009883a 	mov	r4,r2
811151b4:	11381100 	call	81138110 <OSMutexPost>
		return bSuccessL;
811151b8:	e0bffc17 	ldw	r2,-16(fp)
811151bc:	00001606 	br	81115218 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
811151c0:	e0bffb03 	ldbu	r2,-20(fp)
811151c4:	10c00b24 	muli	r3,r2,44
811151c8:	00a04574 	movhi	r2,33045
811151cc:	10911d04 	addi	r2,r2,17524
811151d0:	1885883a 	add	r2,r3,r2
811151d4:	1009883a 	mov	r4,r2
811151d8:	111d0e80 	call	8111d0e8 <puts>
	xBuffer32[ucIL].bSent = TRUE;
811151dc:	e0fffb03 	ldbu	r3,-20(fp)
811151e0:	00a04574 	movhi	r2,33045
811151e4:	10911d04 	addi	r2,r2,17524
811151e8:	18c00b24 	muli	r3,r3,44
811151ec:	10c5883a 	add	r2,r2,r3
811151f0:	10800804 	addi	r2,r2,32
811151f4:	00c00044 	movi	r3,1
811151f8:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
811151fc:	d0a06e17 	ldw	r2,-32328(gp)
81115200:	1009883a 	mov	r4,r2
81115204:	11381100 	call	81138110 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81115208:	d0a06617 	ldw	r2,-32360(gp)
8111520c:	1009883a 	mov	r4,r2
81115210:	11381100 	call	81138110 <OSMutexPost>

	return bSuccessL;
81115214:	e0bffc17 	ldw	r2,-16(fp)
}
81115218:	e037883a 	mov	sp,fp
8111521c:	dfc00117 	ldw	ra,4(sp)
81115220:	df000017 	ldw	fp,0(sp)
81115224:	dec00204 	addi	sp,sp,8
81115228:	f800283a 	ret

8111522c <vSendEthConf>:


void vSendEthConf ( void ) {
8111522c:	deffc304 	addi	sp,sp,-244
81115230:	de00012e 	bgeu	sp,et,81115238 <vSendEthConf+0xc>
81115234:	003b68fa 	trap	3
81115238:	dfc03c15 	stw	ra,240(sp)
8111523c:	df003b15 	stw	fp,236(sp)
81115240:	dd403a15 	stw	r21,232(sp)
81115244:	dd003915 	stw	r20,228(sp)
81115248:	dcc03815 	stw	r19,224(sp)
8111524c:	dc803715 	stw	r18,220(sp)
81115250:	dc403615 	stw	r17,216(sp)
81115254:	dc003515 	stw	r16,212(sp)
81115258:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
8111525c:	e03fd98d 	sth	zero,-154(fp)
81115260:	e03fda0d 	sth	zero,-152(fp)
81115264:	e0bfda84 	addi	r2,fp,-150
81115268:	00c01f04 	movi	r3,124
8111526c:	180d883a 	mov	r6,r3
81115270:	000b883a 	mov	r5,zero
81115274:	1009883a 	mov	r4,r2
81115278:	111cc9c0 	call	8111cc9c <memset>
    unsigned char crc = 0;
8111527c:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115280:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115284:	11157ec0 	call	811157ec <usiGetIdCMD>
81115288:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111528c:	e57fd90b 	ldhu	r21,-156(fp)
81115290:	00a045b4 	movhi	r2,33046
81115294:	10835304 	addi	r2,r2,3404
81115298:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
8111529c:	00a045b4 	movhi	r2,33046
811152a0:	10835304 	addi	r2,r2,3404
811152a4:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811152a8:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811152ac:	00a045b4 	movhi	r2,33046
811152b0:	10835304 	addi	r2,r2,3404
811152b4:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811152b8:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811152bc:	00a045b4 	movhi	r2,33046
811152c0:	10835304 	addi	r2,r2,3404
811152c4:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811152c8:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811152cc:	00a045b4 	movhi	r2,33046
811152d0:	10835304 	addi	r2,r2,3404
811152d4:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811152d8:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811152dc:	00a045b4 	movhi	r2,33046
811152e0:	10835304 	addi	r2,r2,3404
811152e4:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811152e8:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811152ec:	00a045b4 	movhi	r2,33046
811152f0:	10835304 	addi	r2,r2,3404
811152f4:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811152f8:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811152fc:	00a045b4 	movhi	r2,33046
81115300:	10835304 	addi	r2,r2,3404
81115304:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115308:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
8111530c:	00a045b4 	movhi	r2,33046
81115310:	10835304 	addi	r2,r2,3404
81115314:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115318:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111531c:	00a045b4 	movhi	r2,33046
81115320:	10835304 	addi	r2,r2,3404
81115324:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115328:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111532c:	00a045b4 	movhi	r2,33046
81115330:	10835304 	addi	r2,r2,3404
81115334:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115338:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111533c:	00a045b4 	movhi	r2,33046
81115340:	10835304 	addi	r2,r2,3404
81115344:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115348:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
8111534c:	00a045b4 	movhi	r2,33046
81115350:	10835304 	addi	r2,r2,3404
81115354:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115358:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111535c:	00a045b4 	movhi	r2,33046
81115360:	10835304 	addi	r2,r2,3404
81115364:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115368:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111536c:	00a045b4 	movhi	r2,33046
81115370:	10835304 	addi	r2,r2,3404
81115374:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115378:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111537c:	00a045b4 	movhi	r2,33046
81115380:	10835304 	addi	r2,r2,3404
81115384:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115388:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
8111538c:	00a045b4 	movhi	r2,33046
81115390:	10835304 	addi	r2,r2,3404
81115394:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81115398:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
8111539c:	00a045b4 	movhi	r2,33046
811153a0:	10835304 	addi	r2,r2,3404
811153a4:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811153a8:	10bfffcc 	andi	r2,r2,65535
811153ac:	e53fd984 	addi	r20,fp,-154
811153b0:	d8801115 	stw	r2,68(sp)
811153b4:	dcc01015 	stw	r19,64(sp)
811153b8:	dc800f15 	stw	r18,60(sp)
811153bc:	dc400e15 	stw	r17,56(sp)
811153c0:	dc000d15 	stw	r16,52(sp)
811153c4:	dbc00c15 	stw	r15,48(sp)
811153c8:	db800b15 	stw	r14,44(sp)
811153cc:	db400a15 	stw	r13,40(sp)
811153d0:	db000915 	stw	r12,36(sp)
811153d4:	dac00815 	stw	r11,32(sp)
811153d8:	da800715 	stw	r10,28(sp)
811153dc:	da400615 	stw	r9,24(sp)
811153e0:	da000515 	stw	r8,20(sp)
811153e4:	d9c00415 	stw	r7,16(sp)
811153e8:	d9800315 	stw	r6,12(sp)
811153ec:	d9400215 	stw	r5,8(sp)
811153f0:	d9000115 	stw	r4,4(sp)
811153f4:	d8c00015 	stw	r3,0(sp)
811153f8:	a80f883a 	mov	r7,r21
811153fc:	018010c4 	movi	r6,67
81115400:	01604574 	movhi	r5,33045
81115404:	2963bb04 	addi	r5,r5,-28948
81115408:	a009883a 	mov	r4,r20
8111540c:	111d42c0 	call	8111d42c <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81115410:	e0bfd984 	addi	r2,fp,-154
81115414:	1009883a 	mov	r4,r2
81115418:	111d6400 	call	8111d640 <strlen>
8111541c:	1007883a 	mov	r3,r2
81115420:	e0bfd984 	addi	r2,fp,-154
81115424:	180b883a 	mov	r5,r3
81115428:	1009883a 	mov	r4,r2
8111542c:	1116a5c0 	call	81116a5c <ucCrc8wInit>
81115430:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81115434:	e13fd703 	ldbu	r4,-164(fp)
81115438:	e0ffd984 	addi	r3,fp,-154
8111543c:	e0bfd984 	addi	r2,fp,-154
81115440:	200f883a 	mov	r7,r4
81115444:	180d883a 	mov	r6,r3
81115448:	01604574 	movhi	r5,33045
8111544c:	2963d304 	addi	r5,r5,-28852
81115450:	1009883a 	mov	r4,r2
81115454:	111d42c0 	call	8111d42c <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81115458:	e0bfd90b 	ldhu	r2,-156(fp)
8111545c:	10ffffcc 	andi	r3,r2,65535
81115460:	18e0001c 	xori	r3,r3,32768
81115464:	18e00004 	addi	r3,r3,-32768
81115468:	e0bfd984 	addi	r2,fp,-154
8111546c:	180b883a 	mov	r5,r3
81115470:	1009883a 	mov	r4,r2
81115474:	111494c0 	call	8111494c <bSendUART128v2>
81115478:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
8111547c:	e0bfd817 	ldw	r2,-160(fp)
81115480:	10800060 	cmpeqi	r2,r2,1
81115484:	1000011e 	bne	r2,zero,8111548c <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81115488:	111762c0 	call	8111762c <vCouldNotSendEthConfUART>
	}
}
8111548c:	0001883a 	nop
81115490:	e6fffa04 	addi	sp,fp,-24
81115494:	dfc00717 	ldw	ra,28(sp)
81115498:	df000617 	ldw	fp,24(sp)
8111549c:	dd400517 	ldw	r21,20(sp)
811154a0:	dd000417 	ldw	r20,16(sp)
811154a4:	dcc00317 	ldw	r19,12(sp)
811154a8:	dc800217 	ldw	r18,8(sp)
811154ac:	dc400117 	ldw	r17,4(sp)
811154b0:	dc000017 	ldw	r16,0(sp)
811154b4:	dec00804 	addi	sp,sp,32
811154b8:	f800283a 	ret

811154bc <vSendTurnOff>:


void vSendTurnOff ( void ) {
811154bc:	defff304 	addi	sp,sp,-52
811154c0:	de00012e 	bgeu	sp,et,811154c8 <vSendTurnOff+0xc>
811154c4:	003b68fa 	trap	3
811154c8:	dfc00c15 	stw	ra,48(sp)
811154cc:	df000b15 	stw	fp,44(sp)
811154d0:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
811154d4:	e03ff78d 	sth	zero,-34(fp)
811154d8:	e03ff80d 	sth	zero,-32(fp)
811154dc:	e03ff88d 	sth	zero,-30(fp)
811154e0:	e03ff90d 	sth	zero,-28(fp)
811154e4:	e03ff98d 	sth	zero,-26(fp)
811154e8:	e03ffa0d 	sth	zero,-24(fp)
811154ec:	e03ffa8d 	sth	zero,-22(fp)
811154f0:	e03ffb0d 	sth	zero,-20(fp)
811154f4:	e03ffb8d 	sth	zero,-18(fp)
811154f8:	e03ffc0d 	sth	zero,-16(fp)
811154fc:	e03ffc8d 	sth	zero,-14(fp)
81115500:	e03ffd0d 	sth	zero,-12(fp)
81115504:	e03ffd8d 	sth	zero,-10(fp)
81115508:	e03ffe0d 	sth	zero,-8(fp)
8111550c:	e03ffe8d 	sth	zero,-6(fp)
81115510:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81115514:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115518:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111551c:	11157ec0 	call	811157ec <usiGetIdCMD>
81115520:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81115524:	e0fff70b 	ldhu	r3,-36(fp)
81115528:	e0bff784 	addi	r2,fp,-34
8111552c:	180d883a 	mov	r6,r3
81115530:	01604574 	movhi	r5,33045
81115534:	2963d604 	addi	r5,r5,-28840
81115538:	1009883a 	mov	r4,r2
8111553c:	111d42c0 	call	8111d42c <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81115540:	e0bff784 	addi	r2,fp,-34
81115544:	1009883a 	mov	r4,r2
81115548:	111d6400 	call	8111d640 <strlen>
8111554c:	1007883a 	mov	r3,r2
81115550:	e0bff784 	addi	r2,fp,-34
81115554:	180b883a 	mov	r5,r3
81115558:	1009883a 	mov	r4,r2
8111555c:	1116a5c0 	call	81116a5c <ucCrc8wInit>
81115560:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81115564:	e13ff503 	ldbu	r4,-44(fp)
81115568:	e0fff784 	addi	r3,fp,-34
8111556c:	e0bff784 	addi	r2,fp,-34
81115570:	200f883a 	mov	r7,r4
81115574:	180d883a 	mov	r6,r3
81115578:	01604574 	movhi	r5,33045
8111557c:	2963d304 	addi	r5,r5,-28852
81115580:	1009883a 	mov	r4,r2
81115584:	111d42c0 	call	8111d42c <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81115588:	e0bff70b 	ldhu	r2,-36(fp)
8111558c:	10ffffcc 	andi	r3,r2,65535
81115590:	18e0001c 	xori	r3,r3,32768
81115594:	18e00004 	addi	r3,r3,-32768
81115598:	e0bff784 	addi	r2,fp,-34
8111559c:	180b883a 	mov	r5,r3
811155a0:	1009883a 	mov	r4,r2
811155a4:	1114f340 	call	81114f34 <bSendUART32v2>
811155a8:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
811155ac:	e0bff617 	ldw	r2,-40(fp)
811155b0:	10800060 	cmpeqi	r2,r2,1
811155b4:	1000011e 	bne	r2,zero,811155bc <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
811155b8:	1117cd40 	call	81117cd4 <vCouldNotSendTurnOff>
	}
}
811155bc:	0001883a 	nop
811155c0:	e037883a 	mov	sp,fp
811155c4:	dfc00117 	ldw	ra,4(sp)
811155c8:	df000017 	ldw	fp,0(sp)
811155cc:	dec00204 	addi	sp,sp,8
811155d0:	f800283a 	ret

811155d4 <vSendReset>:

void vSendReset ( void ) {
811155d4:	defff304 	addi	sp,sp,-52
811155d8:	de00012e 	bgeu	sp,et,811155e0 <vSendReset+0xc>
811155dc:	003b68fa 	trap	3
811155e0:	dfc00c15 	stw	ra,48(sp)
811155e4:	df000b15 	stw	fp,44(sp)
811155e8:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
811155ec:	e03ff78d 	sth	zero,-34(fp)
811155f0:	e03ff80d 	sth	zero,-32(fp)
811155f4:	e03ff88d 	sth	zero,-30(fp)
811155f8:	e03ff90d 	sth	zero,-28(fp)
811155fc:	e03ff98d 	sth	zero,-26(fp)
81115600:	e03ffa0d 	sth	zero,-24(fp)
81115604:	e03ffa8d 	sth	zero,-22(fp)
81115608:	e03ffb0d 	sth	zero,-20(fp)
8111560c:	e03ffb8d 	sth	zero,-18(fp)
81115610:	e03ffc0d 	sth	zero,-16(fp)
81115614:	e03ffc8d 	sth	zero,-14(fp)
81115618:	e03ffd0d 	sth	zero,-12(fp)
8111561c:	e03ffd8d 	sth	zero,-10(fp)
81115620:	e03ffe0d 	sth	zero,-8(fp)
81115624:	e03ffe8d 	sth	zero,-6(fp)
81115628:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
8111562c:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81115630:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115634:	11157ec0 	call	811157ec <usiGetIdCMD>
81115638:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
8111563c:	e0fff70b 	ldhu	r3,-36(fp)
81115640:	e0bff784 	addi	r2,fp,-34
81115644:	180d883a 	mov	r6,r3
81115648:	01604574 	movhi	r5,33045
8111564c:	2963d804 	addi	r5,r5,-28832
81115650:	1009883a 	mov	r4,r2
81115654:	111d42c0 	call	8111d42c <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81115658:	e0bff784 	addi	r2,fp,-34
8111565c:	1009883a 	mov	r4,r2
81115660:	111d6400 	call	8111d640 <strlen>
81115664:	1007883a 	mov	r3,r2
81115668:	e0bff784 	addi	r2,fp,-34
8111566c:	180b883a 	mov	r5,r3
81115670:	1009883a 	mov	r4,r2
81115674:	1116a5c0 	call	81116a5c <ucCrc8wInit>
81115678:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
8111567c:	e13ff503 	ldbu	r4,-44(fp)
81115680:	e0fff784 	addi	r3,fp,-34
81115684:	e0bff784 	addi	r2,fp,-34
81115688:	200f883a 	mov	r7,r4
8111568c:	180d883a 	mov	r6,r3
81115690:	01604574 	movhi	r5,33045
81115694:	2963d304 	addi	r5,r5,-28852
81115698:	1009883a 	mov	r4,r2
8111569c:	111d42c0 	call	8111d42c <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811156a0:	e0bff70b 	ldhu	r2,-36(fp)
811156a4:	10ffffcc 	andi	r3,r2,65535
811156a8:	18e0001c 	xori	r3,r3,32768
811156ac:	18e00004 	addi	r3,r3,-32768
811156b0:	e0bff784 	addi	r2,fp,-34
811156b4:	180b883a 	mov	r5,r3
811156b8:	1009883a 	mov	r4,r2
811156bc:	1114f340 	call	81114f34 <bSendUART32v2>
811156c0:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
811156c4:	e0bff617 	ldw	r2,-40(fp)
811156c8:	10800060 	cmpeqi	r2,r2,1
811156cc:	1000011e 	bne	r2,zero,811156d4 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
811156d0:	1117cd40 	call	81117cd4 <vCouldNotSendTurnOff>
	}
}
811156d4:	0001883a 	nop
811156d8:	e037883a 	mov	sp,fp
811156dc:	dfc00117 	ldw	ra,4(sp)
811156e0:	df000017 	ldw	fp,0(sp)
811156e4:	dec00204 	addi	sp,sp,8
811156e8:	f800283a 	ret

811156ec <vSendLog>:

void vSendLog ( const char * cDataIn ) {
811156ec:	deffda04 	addi	sp,sp,-152
811156f0:	de00012e 	bgeu	sp,et,811156f8 <vSendLog+0xc>
811156f4:	003b68fa 	trap	3
811156f8:	dfc02515 	stw	ra,148(sp)
811156fc:	df002415 	stw	fp,144(sp)
81115700:	df002404 	addi	fp,sp,144
81115704:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81115708:	e03fde8d 	sth	zero,-134(fp)
8111570c:	e03fdf0d 	sth	zero,-132(fp)
81115710:	e0bfdf84 	addi	r2,fp,-130
81115714:	00c01f04 	movi	r3,124
81115718:	180d883a 	mov	r6,r3
8111571c:	000b883a 	mov	r5,zero
81115720:	1009883a 	mov	r4,r2
81115724:	111cc9c0 	call	8111cc9c <memset>
    unsigned char crc = 0;
81115728:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111572c:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115730:	11157ec0 	call	811157ec <usiGetIdCMD>
81115734:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81115738:	e0ffde0b 	ldhu	r3,-136(fp)
8111573c:	e0bfde84 	addi	r2,fp,-134
81115740:	e1ffff17 	ldw	r7,-4(fp)
81115744:	180d883a 	mov	r6,r3
81115748:	01604574 	movhi	r5,33045
8111574c:	2963da04 	addi	r5,r5,-28824
81115750:	1009883a 	mov	r4,r2
81115754:	111d42c0 	call	8111d42c <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81115758:	e0bfde84 	addi	r2,fp,-134
8111575c:	1009883a 	mov	r4,r2
81115760:	111d6400 	call	8111d640 <strlen>
81115764:	1007883a 	mov	r3,r2
81115768:	e0bfde84 	addi	r2,fp,-134
8111576c:	180b883a 	mov	r5,r3
81115770:	1009883a 	mov	r4,r2
81115774:	1116a5c0 	call	81116a5c <ucCrc8wInit>
81115778:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
8111577c:	e13fdc03 	ldbu	r4,-144(fp)
81115780:	e0ffde84 	addi	r3,fp,-134
81115784:	e0bfde84 	addi	r2,fp,-134
81115788:	200f883a 	mov	r7,r4
8111578c:	180d883a 	mov	r6,r3
81115790:	01604574 	movhi	r5,33045
81115794:	2963d304 	addi	r5,r5,-28852
81115798:	1009883a 	mov	r4,r2
8111579c:	111d42c0 	call	8111d42c <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
811157a0:	e0bfde0b 	ldhu	r2,-136(fp)
811157a4:	10ffffcc 	andi	r3,r2,65535
811157a8:	18e0001c 	xori	r3,r3,32768
811157ac:	18e00004 	addi	r3,r3,-32768
811157b0:	e0bfde84 	addi	r2,fp,-134
811157b4:	180b883a 	mov	r5,r3
811157b8:	1009883a 	mov	r4,r2
811157bc:	111494c0 	call	8111494c <bSendUART128v2>
811157c0:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
811157c4:	e0bfdd17 	ldw	r2,-140(fp)
811157c8:	10800060 	cmpeqi	r2,r2,1
811157cc:	1000011e 	bne	r2,zero,811157d4 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
811157d0:	1117da40 	call	81117da4 <vCouldNotSendLog>
	}
}
811157d4:	0001883a 	nop
811157d8:	e037883a 	mov	sp,fp
811157dc:	dfc00117 	ldw	ra,4(sp)
811157e0:	df000017 	ldw	fp,0(sp)
811157e4:	dec00204 	addi	sp,sp,8
811157e8:	f800283a 	ret

811157ec <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
811157ec:	deffff04 	addi	sp,sp,-4
811157f0:	de00012e 	bgeu	sp,et,811157f8 <usiGetIdCMD+0xc>
811157f4:	003b68fa 	trap	3
811157f8:	df000015 	stw	fp,0(sp)
811157fc:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81115800:	d0a0620b 	ldhu	r2,-32376(gp)
81115804:	10ffffcc 	andi	r3,r2,65535
81115808:	00bfffd4 	movui	r2,65535
8111580c:	1880031e 	bne	r3,r2,8111581c <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81115810:	00800084 	movi	r2,2
81115814:	d0a0620d 	sth	r2,-32376(gp)
81115818:	00000306 	br	81115828 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
8111581c:	d0a0620b 	ldhu	r2,-32376(gp)
81115820:	10800044 	addi	r2,r2,1
81115824:	d0a0620d 	sth	r2,-32376(gp)

    return usiIdCMD;
81115828:	d0a0620b 	ldhu	r2,-32376(gp)
}
8111582c:	e037883a 	mov	sp,fp
81115830:	df000017 	ldw	fp,0(sp)
81115834:	dec00104 	addi	sp,sp,4
81115838:	f800283a 	ret

8111583c <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
8111583c:	defffb04 	addi	sp,sp,-20
81115840:	de00012e 	bgeu	sp,et,81115848 <siPosStr+0xc>
81115844:	003b68fa 	trap	3
81115848:	dfc00415 	stw	ra,16(sp)
8111584c:	df000315 	stw	fp,12(sp)
81115850:	df000304 	addi	fp,sp,12
81115854:	e13ffe15 	stw	r4,-8(fp)
81115858:	2805883a 	mov	r2,r5
8111585c:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
81115860:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81115864:	e0bfff03 	ldbu	r2,-4(fp)
81115868:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
8111586c:	e17ffd04 	addi	r5,fp,-12
81115870:	e13ffe17 	ldw	r4,-8(fp)
81115874:	111d5f40 	call	8111d5f4 <strcspn>
}
81115878:	e037883a 	mov	sp,fp
8111587c:	dfc00117 	ldw	ra,4(sp)
81115880:	df000017 	ldw	fp,0(sp)
81115884:	dec00204 	addi	sp,sp,8
81115888:	f800283a 	ret

8111588c <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
8111588c:	defffc04 	addi	sp,sp,-16
81115890:	de00012e 	bgeu	sp,et,81115898 <vTimeoutCheck+0xc>
81115894:	003b68fa 	trap	3
81115898:	dfc00315 	stw	ra,12(sp)
8111589c:	df000215 	stw	fp,8(sp)
811158a0:	df000204 	addi	fp,sp,8
811158a4:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
811158a8:	d0a06117 	ldw	r2,-32380(gp)
811158ac:	1009883a 	mov	r4,r2
811158b0:	1139f000 	call	81139f00 <OSSemPost>
811158b4:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
811158b8:	e0bffe03 	ldbu	r2,-8(fp)
811158bc:	10000126 	beq	r2,zero,811158c4 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
811158c0:	1117a640 	call	81117a64 <vFailPostBlockingSemTimeoutTask>
	}
}
811158c4:	0001883a 	nop
811158c8:	e037883a 	mov	sp,fp
811158cc:	dfc00117 	ldw	ra,4(sp)
811158d0:	df000017 	ldw	fp,0(sp)
811158d4:	dec00204 	addi	sp,sp,8
811158d8:	f800283a 	ret

811158dc <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
811158dc:	deffe304 	addi	sp,sp,-116
811158e0:	de00012e 	bgeu	sp,et,811158e8 <vSendPusTM64+0xc>
811158e4:	003b68fa 	trap	3
811158e8:	dfc01815 	stw	ra,96(sp)
811158ec:	df001715 	stw	fp,92(sp)
811158f0:	df001704 	addi	fp,sp,92
811158f4:	e1000215 	stw	r4,8(fp)
811158f8:	e1400315 	stw	r5,12(fp)
811158fc:	e1800415 	stw	r6,16(fp)
81115900:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81115904:	e03fef8d 	sth	zero,-66(fp)
81115908:	e03ff00d 	sth	zero,-64(fp)
8111590c:	e0bff084 	addi	r2,fp,-62
81115910:	00c00f04 	movi	r3,60
81115914:	180d883a 	mov	r6,r3
81115918:	000b883a 	mov	r5,zero
8111591c:	1009883a 	mov	r4,r2
81115920:	111cc9c0 	call	8111cc9c <memset>
    unsigned char crc = 0;
81115924:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81115928:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111592c:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115930:	11157ec0 	call	811157ec <usiGetIdCMD>
81115934:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81115938:	e1bfef0b 	ldhu	r6,-68(fp)
8111593c:	e080040b 	ldhu	r2,16(fp)
81115940:	11ffffcc 	andi	r7,r2,65535
81115944:	e080048b 	ldhu	r2,18(fp)
81115948:	10bfffcc 	andi	r2,r2,65535
8111594c:	e0c0050b 	ldhu	r3,20(fp)
81115950:	18ffffcc 	andi	r3,r3,65535
81115954:	e100058b 	ldhu	r4,22(fp)
81115958:	213fffcc 	andi	r4,r4,65535
8111595c:	e140060b 	ldhu	r5,24(fp)
81115960:	297fffcc 	andi	r5,r5,65535
81115964:	e23fef84 	addi	r8,fp,-66
81115968:	d9400315 	stw	r5,12(sp)
8111596c:	d9000215 	stw	r4,8(sp)
81115970:	d8c00115 	stw	r3,4(sp)
81115974:	d8800015 	stw	r2,0(sp)
81115978:	01604574 	movhi	r5,33045
8111597c:	2963dd04 	addi	r5,r5,-28812
81115980:	4009883a 	mov	r4,r8
81115984:	111d42c0 	call	8111d42c <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115988:	e03fed05 	stb	zero,-76(fp)
8111598c:	00001206 	br	811159d8 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81115990:	e0bfed03 	ldbu	r2,-76(fp)
81115994:	10800284 	addi	r2,r2,10
81115998:	1085883a 	add	r2,r2,r2
8111599c:	e0c00204 	addi	r3,fp,8
811159a0:	1885883a 	add	r2,r3,r2
811159a4:	1080000b 	ldhu	r2,0(r2)
811159a8:	113fffcc 	andi	r4,r2,65535
811159ac:	e0ffef84 	addi	r3,fp,-66
811159b0:	e0bfef84 	addi	r2,fp,-66
811159b4:	200f883a 	mov	r7,r4
811159b8:	180d883a 	mov	r6,r3
811159bc:	01604574 	movhi	r5,33045
811159c0:	2963e404 	addi	r5,r5,-28784
811159c4:	1009883a 	mov	r4,r2
811159c8:	111d42c0 	call	8111d42c <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811159cc:	e0bfed03 	ldbu	r2,-76(fp)
811159d0:	10800044 	addi	r2,r2,1
811159d4:	e0bfed05 	stb	r2,-76(fp)
811159d8:	e0800683 	ldbu	r2,26(fp)
811159dc:	10803fcc 	andi	r2,r2,255
811159e0:	e0ffed03 	ldbu	r3,-76(fp)
811159e4:	18bfea36 	bltu	r3,r2,81115990 <__reset+0xfb0f5990>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811159e8:	e0bfef84 	addi	r2,fp,-66
811159ec:	1009883a 	mov	r4,r2
811159f0:	111d6400 	call	8111d640 <strlen>
811159f4:	1007883a 	mov	r3,r2
811159f8:	e0bfef84 	addi	r2,fp,-66
811159fc:	180b883a 	mov	r5,r3
81115a00:	1009883a 	mov	r4,r2
81115a04:	1116a5c0 	call	81116a5c <ucCrc8wInit>
81115a08:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81115a0c:	e13fed43 	ldbu	r4,-75(fp)
81115a10:	e0ffef84 	addi	r3,fp,-66
81115a14:	e0bfef84 	addi	r2,fp,-66
81115a18:	200f883a 	mov	r7,r4
81115a1c:	180d883a 	mov	r6,r3
81115a20:	01604574 	movhi	r5,33045
81115a24:	2963d304 	addi	r5,r5,-28852
81115a28:	1009883a 	mov	r4,r2
81115a2c:	111d42c0 	call	8111d42c <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81115a30:	e0bfef0b 	ldhu	r2,-68(fp)
81115a34:	10ffffcc 	andi	r3,r2,65535
81115a38:	18e0001c 	xori	r3,r3,32768
81115a3c:	18e00004 	addi	r3,r3,-32768
81115a40:	e0bfef84 	addi	r2,fp,-66
81115a44:	180b883a 	mov	r5,r3
81115a48:	1009883a 	mov	r4,r2
81115a4c:	1114c3c0 	call	81114c3c <bSendUART64v2>
81115a50:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81115a54:	e0bfee17 	ldw	r2,-72(fp)
81115a58:	10800060 	cmpeqi	r2,r2,1
81115a5c:	1000031e 	bne	r2,zero,81115a6c <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81115a60:	e0bfef84 	addi	r2,fp,-66
81115a64:	1009883a 	mov	r4,r2
81115a68:	1117e0c0 	call	81117e0c <vCouldNotSendTMPusCommand>
	}
}
81115a6c:	0001883a 	nop
81115a70:	e037883a 	mov	sp,fp
81115a74:	dfc00117 	ldw	ra,4(sp)
81115a78:	df000017 	ldw	fp,0(sp)
81115a7c:	dec00604 	addi	sp,sp,24
81115a80:	f800283a 	ret

81115a84 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81115a84:	deffd304 	addi	sp,sp,-180
81115a88:	de00012e 	bgeu	sp,et,81115a90 <vSendPusTM128+0xc>
81115a8c:	003b68fa 	trap	3
81115a90:	dfc02815 	stw	ra,160(sp)
81115a94:	df002715 	stw	fp,156(sp)
81115a98:	df002704 	addi	fp,sp,156
81115a9c:	e1000215 	stw	r4,8(fp)
81115aa0:	e1400315 	stw	r5,12(fp)
81115aa4:	e1800415 	stw	r6,16(fp)
81115aa8:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81115aac:	e03fdf8d 	sth	zero,-130(fp)
81115ab0:	e03fe00d 	sth	zero,-128(fp)
81115ab4:	e0bfe084 	addi	r2,fp,-126
81115ab8:	00c01f04 	movi	r3,124
81115abc:	180d883a 	mov	r6,r3
81115ac0:	000b883a 	mov	r5,zero
81115ac4:	1009883a 	mov	r4,r2
81115ac8:	111cc9c0 	call	8111cc9c <memset>
    unsigned char crc = 0;
81115acc:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81115ad0:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81115ad4:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81115ad8:	11157ec0 	call	811157ec <usiGetIdCMD>
81115adc:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81115ae0:	e1bfdf0b 	ldhu	r6,-132(fp)
81115ae4:	e080040b 	ldhu	r2,16(fp)
81115ae8:	11ffffcc 	andi	r7,r2,65535
81115aec:	e080048b 	ldhu	r2,18(fp)
81115af0:	10bfffcc 	andi	r2,r2,65535
81115af4:	e0c0050b 	ldhu	r3,20(fp)
81115af8:	18ffffcc 	andi	r3,r3,65535
81115afc:	e100058b 	ldhu	r4,22(fp)
81115b00:	213fffcc 	andi	r4,r4,65535
81115b04:	e140060b 	ldhu	r5,24(fp)
81115b08:	297fffcc 	andi	r5,r5,65535
81115b0c:	e23fdf84 	addi	r8,fp,-130
81115b10:	d9400315 	stw	r5,12(sp)
81115b14:	d9000215 	stw	r4,8(sp)
81115b18:	d8c00115 	stw	r3,4(sp)
81115b1c:	d8800015 	stw	r2,0(sp)
81115b20:	01604574 	movhi	r5,33045
81115b24:	2963dd04 	addi	r5,r5,-28812
81115b28:	4009883a 	mov	r4,r8
81115b2c:	111d42c0 	call	8111d42c <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115b30:	e03fdd05 	stb	zero,-140(fp)
81115b34:	00001206 	br	81115b80 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81115b38:	e0bfdd03 	ldbu	r2,-140(fp)
81115b3c:	10800284 	addi	r2,r2,10
81115b40:	1085883a 	add	r2,r2,r2
81115b44:	e0c00204 	addi	r3,fp,8
81115b48:	1885883a 	add	r2,r3,r2
81115b4c:	1080000b 	ldhu	r2,0(r2)
81115b50:	113fffcc 	andi	r4,r2,65535
81115b54:	e0ffdf84 	addi	r3,fp,-130
81115b58:	e0bfdf84 	addi	r2,fp,-130
81115b5c:	200f883a 	mov	r7,r4
81115b60:	180d883a 	mov	r6,r3
81115b64:	01604574 	movhi	r5,33045
81115b68:	2963e404 	addi	r5,r5,-28784
81115b6c:	1009883a 	mov	r4,r2
81115b70:	111d42c0 	call	8111d42c <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81115b74:	e0bfdd03 	ldbu	r2,-140(fp)
81115b78:	10800044 	addi	r2,r2,1
81115b7c:	e0bfdd05 	stb	r2,-140(fp)
81115b80:	e0800683 	ldbu	r2,26(fp)
81115b84:	10803fcc 	andi	r2,r2,255
81115b88:	e0ffdd03 	ldbu	r3,-140(fp)
81115b8c:	18bfea36 	bltu	r3,r2,81115b38 <__reset+0xfb0f5b38>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81115b90:	e0bfdf84 	addi	r2,fp,-130
81115b94:	1009883a 	mov	r4,r2
81115b98:	111d6400 	call	8111d640 <strlen>
81115b9c:	1007883a 	mov	r3,r2
81115ba0:	e0bfdf84 	addi	r2,fp,-130
81115ba4:	180b883a 	mov	r5,r3
81115ba8:	1009883a 	mov	r4,r2
81115bac:	1116a5c0 	call	81116a5c <ucCrc8wInit>
81115bb0:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81115bb4:	e13fdd43 	ldbu	r4,-139(fp)
81115bb8:	e0ffdf84 	addi	r3,fp,-130
81115bbc:	e0bfdf84 	addi	r2,fp,-130
81115bc0:	200f883a 	mov	r7,r4
81115bc4:	180d883a 	mov	r6,r3
81115bc8:	01604574 	movhi	r5,33045
81115bcc:	2963d304 	addi	r5,r5,-28852
81115bd0:	1009883a 	mov	r4,r2
81115bd4:	111d42c0 	call	8111d42c <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81115bd8:	e0bfdf0b 	ldhu	r2,-132(fp)
81115bdc:	10ffffcc 	andi	r3,r2,65535
81115be0:	18e0001c 	xori	r3,r3,32768
81115be4:	18e00004 	addi	r3,r3,-32768
81115be8:	e0bfdf84 	addi	r2,fp,-130
81115bec:	180b883a 	mov	r5,r3
81115bf0:	1009883a 	mov	r4,r2
81115bf4:	111494c0 	call	8111494c <bSendUART128v2>
81115bf8:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81115bfc:	e0bfde17 	ldw	r2,-136(fp)
81115c00:	10800060 	cmpeqi	r2,r2,1
81115c04:	1000031e 	bne	r2,zero,81115c14 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81115c08:	e0bfdf84 	addi	r2,fp,-130
81115c0c:	1009883a 	mov	r4,r2
81115c10:	1117e0c0 	call	81117e0c <vCouldNotSendTMPusCommand>
	}
}
81115c14:	0001883a 	nop
81115c18:	e037883a 	mov	sp,fp
81115c1c:	dfc00117 	ldw	ra,4(sp)
81115c20:	df000017 	ldw	fp,0(sp)
81115c24:	dec00604 	addi	sp,sp,24
81115c28:	f800283a 	ret

81115c2c <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81115c2c:	deffd704 	addi	sp,sp,-164
81115c30:	de00012e 	bgeu	sp,et,81115c38 <vTMPusTestConnection+0xc>
81115c34:	003b68fa 	trap	3
81115c38:	dfc02815 	stw	ra,160(sp)
81115c3c:	df002715 	stw	fp,156(sp)
81115c40:	df002704 	addi	fp,sp,156
81115c44:	2005883a 	mov	r2,r4
81115c48:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81115c4c:	e0bfff0b 	ldhu	r2,-4(fp)
81115c50:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81115c54:	00801c04 	movi	r2,112
81115c58:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81115c5c:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81115c60:	00800444 	movi	r2,17
81115c64:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81115c68:	00800084 	movi	r2,2
81115c6c:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81115c70:	d809883a 	mov	r4,sp
81115c74:	e0bfee04 	addi	r2,fp,-72
81115c78:	00c01104 	movi	r3,68
81115c7c:	180d883a 	mov	r6,r3
81115c80:	100b883a 	mov	r5,r2
81115c84:	111cb4c0 	call	8111cb4c <memcpy>
81115c88:	e13fea17 	ldw	r4,-88(fp)
81115c8c:	e17feb17 	ldw	r5,-84(fp)
81115c90:	e1bfec17 	ldw	r6,-80(fp)
81115c94:	e1ffed17 	ldw	r7,-76(fp)
81115c98:	11158dc0 	call	811158dc <vSendPusTM64>
}
81115c9c:	0001883a 	nop
81115ca0:	e037883a 	mov	sp,fp
81115ca4:	dfc00117 	ldw	ra,4(sp)
81115ca8:	df000017 	ldw	fp,0(sp)
81115cac:	dec00204 	addi	sp,sp,8
81115cb0:	f800283a 	ret

81115cb4 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
81115cb4:	defff504 	addi	sp,sp,-44
81115cb8:	de00012e 	bgeu	sp,et,81115cc0 <vLoadDefaultETHConf+0xc>
81115cbc:	003b68fa 	trap	3
81115cc0:	dfc00a15 	stw	ra,40(sp)
81115cc4:	df000915 	stw	fp,36(sp)
81115cc8:	dc000815 	stw	r16,32(sp)
81115ccc:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81115cd0:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81115cd4:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81115cd8:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81115cdc:	d0a07017 	ldw	r2,-32320(gp)
81115ce0:	10800058 	cmpnei	r2,r2,1
81115ce4:	1002041e 	bne	r2,zero,811164f8 <vLoadDefaultETHConf+0x844>
81115ce8:	1119ac00 	call	81119ac0 <bSDcardIsPresent>
81115cec:	10020226 	beq	r2,zero,811164f8 <vLoadDefaultETHConf+0x844>
81115cf0:	1119af00 	call	81119af0 <bSDcardFAT16Check>
81115cf4:	10020026 	beq	r2,zero,811164f8 <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
81115cf8:	01204574 	movhi	r4,33045
81115cfc:	2123e604 	addi	r4,r4,-28776
81115d00:	1119c180 	call	81119c18 <siOpenFile>
81115d04:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81115d08:	e0bffc0f 	ldh	r2,-16(fp)
81115d0c:	1001f216 	blt	r2,zero,811164d8 <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81115d10:	e0bffd04 	addi	r2,fp,-12
81115d14:	01800204 	movi	r6,8
81115d18:	01400284 	movi	r5,10
81115d1c:	1009883a 	mov	r4,r2
81115d20:	111cc9c0 	call	8111cc9c <memset>
			p_inteiro = inteiro;
81115d24:	e0bffd04 	addi	r2,fp,-12
81115d28:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81115d2c:	e0bffc0f 	ldh	r2,-16(fp)
81115d30:	1009883a 	mov	r4,r2
81115d34:	1119c940 	call	81119c94 <cGetNextChar>
81115d38:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81115d3c:	e0bff947 	ldb	r2,-27(fp)
81115d40:	10800084 	addi	r2,r2,2
81115d44:	10c015a8 	cmpgeui	r3,r2,86
81115d48:	1801d71e 	bne	r3,zero,811164a8 <vLoadDefaultETHConf+0x7f4>
81115d4c:	100690ba 	slli	r3,r2,2
81115d50:	00a04474 	movhi	r2,33041
81115d54:	10975904 	addi	r2,r2,23908
81115d58:	1885883a 	add	r2,r3,r2
81115d5c:	10800017 	ldw	r2,0(r2)
81115d60:	1000683a 	jmp	r2
81115d64:	81115efc 	xorhi	r4,r16,17787
81115d68:	81115ef0 	cmpltui	r4,r16,17787
81115d6c:	811164a8 	cmpgeui	r4,r16,17810
81115d70:	811164a8 	cmpgeui	r4,r16,17810
81115d74:	811164a8 	cmpgeui	r4,r16,17810
81115d78:	811164a8 	cmpgeui	r4,r16,17810
81115d7c:	811164a8 	cmpgeui	r4,r16,17810
81115d80:	811164a8 	cmpgeui	r4,r16,17810
81115d84:	811164a8 	cmpgeui	r4,r16,17810
81115d88:	811164a8 	cmpgeui	r4,r16,17810
81115d8c:	811164a8 	cmpgeui	r4,r16,17810
81115d90:	811164a8 	cmpgeui	r4,r16,17810
81115d94:	811164c8 	cmpgei	r4,r16,17811
81115d98:	811164a8 	cmpgeui	r4,r16,17810
81115d9c:	811164a8 	cmpgeui	r4,r16,17810
81115da0:	811164c8 	cmpgei	r4,r16,17811
81115da4:	811164a8 	cmpgeui	r4,r16,17810
81115da8:	811164a8 	cmpgeui	r4,r16,17810
81115dac:	811164a8 	cmpgeui	r4,r16,17810
81115db0:	811164a8 	cmpgeui	r4,r16,17810
81115db4:	811164a8 	cmpgeui	r4,r16,17810
81115db8:	811164a8 	cmpgeui	r4,r16,17810
81115dbc:	811164a8 	cmpgeui	r4,r16,17810
81115dc0:	811164a8 	cmpgeui	r4,r16,17810
81115dc4:	811164a8 	cmpgeui	r4,r16,17810
81115dc8:	811164a8 	cmpgeui	r4,r16,17810
81115dcc:	811164a8 	cmpgeui	r4,r16,17810
81115dd0:	811164a8 	cmpgeui	r4,r16,17810
81115dd4:	811164a8 	cmpgeui	r4,r16,17810
81115dd8:	811164a8 	cmpgeui	r4,r16,17810
81115ddc:	811164a8 	cmpgeui	r4,r16,17810
81115de0:	811164a8 	cmpgeui	r4,r16,17810
81115de4:	811164a8 	cmpgeui	r4,r16,17810
81115de8:	811164a8 	cmpgeui	r4,r16,17810
81115dec:	811164c8 	cmpgei	r4,r16,17811
81115df0:	811164a8 	cmpgeui	r4,r16,17810
81115df4:	811164a8 	cmpgeui	r4,r16,17810
81115df8:	811164a8 	cmpgeui	r4,r16,17810
81115dfc:	811164a8 	cmpgeui	r4,r16,17810
81115e00:	811164a8 	cmpgeui	r4,r16,17810
81115e04:	811164a8 	cmpgeui	r4,r16,17810
81115e08:	81115ebc 	xorhi	r4,r16,17786
81115e0c:	811164a8 	cmpgeui	r4,r16,17810
81115e10:	811164a8 	cmpgeui	r4,r16,17810
81115e14:	811164a8 	cmpgeui	r4,r16,17810
81115e18:	811164a8 	cmpgeui	r4,r16,17810
81115e1c:	811164a8 	cmpgeui	r4,r16,17810
81115e20:	811164a8 	cmpgeui	r4,r16,17810
81115e24:	811164a8 	cmpgeui	r4,r16,17810
81115e28:	811164a8 	cmpgeui	r4,r16,17810
81115e2c:	811164a8 	cmpgeui	r4,r16,17810
81115e30:	811164a8 	cmpgeui	r4,r16,17810
81115e34:	811164a8 	cmpgeui	r4,r16,17810
81115e38:	811164a8 	cmpgeui	r4,r16,17810
81115e3c:	811164a8 	cmpgeui	r4,r16,17810
81115e40:	811164a8 	cmpgeui	r4,r16,17810
81115e44:	811164a8 	cmpgeui	r4,r16,17810
81115e48:	811164a8 	cmpgeui	r4,r16,17810
81115e4c:	811164a8 	cmpgeui	r4,r16,17810
81115e50:	811164a8 	cmpgeui	r4,r16,17810
81115e54:	811164a8 	cmpgeui	r4,r16,17810
81115e58:	811164a8 	cmpgeui	r4,r16,17810
81115e5c:	81116460 	cmpeqi	r4,r16,17809
81115e60:	811164a8 	cmpgeui	r4,r16,17810
81115e64:	811164a8 	cmpgeui	r4,r16,17810
81115e68:	811164a8 	cmpgeui	r4,r16,17810
81115e6c:	811164a8 	cmpgeui	r4,r16,17810
81115e70:	811164a8 	cmpgeui	r4,r16,17810
81115e74:	811164a8 	cmpgeui	r4,r16,17810
81115e78:	811164a8 	cmpgeui	r4,r16,17810
81115e7c:	81116260 	cmpeqi	r4,r16,17801
81115e80:	811164a8 	cmpgeui	r4,r16,17810
81115e84:	811164a8 	cmpgeui	r4,r16,17810
81115e88:	811160c0 	call	8811160c <__reset+0x20f160c>
81115e8c:	811163b8 	rdprs	r4,r16,17806
81115e90:	81115ff4 	orhi	r4,r16,17791
81115e94:	811164a8 	cmpgeui	r4,r16,17810
81115e98:	811164a8 	cmpgeui	r4,r16,17810
81115e9c:	811164a8 	cmpgeui	r4,r16,17810
81115ea0:	81115f24 	muli	r4,r16,17788
81115ea4:	811164a8 	cmpgeui	r4,r16,17810
81115ea8:	811164a8 	cmpgeui	r4,r16,17810
81115eac:	81116330 	cmpltui	r4,r16,17804
81115eb0:	811164a8 	cmpgeui	r4,r16,17810
81115eb4:	811164a8 	cmpgeui	r4,r16,17810
81115eb8:	81116190 	cmplti	r4,r16,17798
					case 39:// single quote '
						c = cGetNextChar(siFile);
81115ebc:	e0bffc0f 	ldh	r2,-16(fp)
81115ec0:	1009883a 	mov	r4,r2
81115ec4:	1119c940 	call	81119c94 <cGetNextChar>
81115ec8:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81115ecc:	00000406 	br	81115ee0 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81115ed0:	e0bffc0f 	ldh	r2,-16(fp)
81115ed4:	1009883a 	mov	r4,r2
81115ed8:	1119c940 	call	81119c94 <cGetNextChar>
81115edc:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81115ee0:	e0bff947 	ldb	r2,-27(fp)
81115ee4:	108009d8 	cmpnei	r2,r2,39
81115ee8:	103ff91e 	bne	r2,zero,81115ed0 <__reset+0xfb0f5ed0>
							c = cGetNextChar(siFile);
						}
						break;
81115eec:	00017706 	br	811164cc <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
81115ef0:	00800044 	movi	r2,1
81115ef4:	e0bff815 	stw	r2,-32(fp)
						break;
81115ef8:	00017406 	br	811164cc <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81115efc:	d0a05c17 	ldw	r2,-32400(gp)
81115f00:	100f883a 	mov	r7,r2
81115f04:	018006c4 	movi	r6,27
81115f08:	01400044 	movi	r5,1
81115f0c:	01204574 	movhi	r4,33045
81115f10:	2123e804 	addi	r4,r4,-28768
81115f14:	111c1380 	call	8111c138 <fwrite>
						#endif
						bEOF = TRUE;
81115f18:	00800044 	movi	r2,1
81115f1c:	e0bff815 	stw	r2,-32(fp)
						break;
81115f20:	00016a06 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81115f24:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115f28:	e0bffc0f 	ldh	r2,-16(fp)
81115f2c:	1009883a 	mov	r4,r2
81115f30:	1119c940 	call	81119c94 <cGetNextChar>
81115f34:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115f38:	d0e00317 	ldw	r3,-32756(gp)
81115f3c:	e0bff947 	ldb	r2,-27(fp)
81115f40:	10800044 	addi	r2,r2,1
81115f44:	1885883a 	add	r2,r3,r2
81115f48:	10800003 	ldbu	r2,0(r2)
81115f4c:	10803fcc 	andi	r2,r2,255
81115f50:	1080010c 	andi	r2,r2,4
81115f54:	10000626 	beq	r2,zero,81115f70 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81115f58:	e0bffa17 	ldw	r2,-24(fp)
81115f5c:	e0fff943 	ldbu	r3,-27(fp)
81115f60:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115f64:	e0bffa17 	ldw	r2,-24(fp)
81115f68:	10800044 	addi	r2,r2,1
81115f6c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
81115f70:	e0bff947 	ldb	r2,-27(fp)
81115f74:	10800ea0 	cmpeqi	r2,r2,58
81115f78:	1000031e 	bne	r2,zero,81115f88 <vLoadDefaultETHConf+0x2d4>
81115f7c:	e0bff947 	ldb	r2,-27(fp)
81115f80:	10800ed8 	cmpnei	r2,r2,59
81115f84:	103fe81e 	bne	r2,zero,81115f28 <__reset+0xfb0f5f28>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115f88:	e0bffa17 	ldw	r2,-24(fp)
81115f8c:	00c00284 	movi	r3,10
81115f90:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81115f94:	e0bff903 	ldbu	r2,-28(fp)
81115f98:	10800168 	cmpgeui	r2,r2,5
81115f9c:	1000021e 	bne	r2,zero,81115fa8 <vLoadDefaultETHConf+0x2f4>
81115fa0:	e43ff903 	ldbu	r16,-28(fp)
81115fa4:	00000106 	br	81115fac <vLoadDefaultETHConf+0x2f8>
81115fa8:	04000144 	movi	r16,5
81115fac:	e0bffd04 	addi	r2,fp,-12
81115fb0:	1009883a 	mov	r4,r2
81115fb4:	111b9400 	call	8111b940 <atoi>
81115fb8:	1007883a 	mov	r3,r2
81115fbc:	00a045b4 	movhi	r2,33046
81115fc0:	10835304 	addi	r2,r2,3404
81115fc4:	1405883a 	add	r2,r2,r16
81115fc8:	10800404 	addi	r2,r2,16
81115fcc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115fd0:	e0bffd04 	addi	r2,fp,-12
81115fd4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115fd8:	e0bff903 	ldbu	r2,-28(fp)
81115fdc:	10800044 	addi	r2,r2,1
81115fe0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115fe4:	e0bff947 	ldb	r2,-27(fp)
81115fe8:	10800ed8 	cmpnei	r2,r2,59
81115fec:	103fce1e 	bne	r2,zero,81115f28 <__reset+0xfb0f5f28>

						break;
81115ff0:	00013606 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
81115ff4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115ff8:	e0bffc0f 	ldh	r2,-16(fp)
81115ffc:	1009883a 	mov	r4,r2
81116000:	1119c940 	call	81119c94 <cGetNextChar>
81116004:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116008:	d0e00317 	ldw	r3,-32756(gp)
8111600c:	e0bff947 	ldb	r2,-27(fp)
81116010:	10800044 	addi	r2,r2,1
81116014:	1885883a 	add	r2,r3,r2
81116018:	10800003 	ldbu	r2,0(r2)
8111601c:	10803fcc 	andi	r2,r2,255
81116020:	1080010c 	andi	r2,r2,4
81116024:	10000626 	beq	r2,zero,81116040 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81116028:	e0bffa17 	ldw	r2,-24(fp)
8111602c:	e0fff943 	ldbu	r3,-27(fp)
81116030:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116034:	e0bffa17 	ldw	r2,-24(fp)
81116038:	10800044 	addi	r2,r2,1
8111603c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81116040:	e0bff947 	ldb	r2,-27(fp)
81116044:	10800ba0 	cmpeqi	r2,r2,46
81116048:	1000031e 	bne	r2,zero,81116058 <vLoadDefaultETHConf+0x3a4>
8111604c:	e0bff947 	ldb	r2,-27(fp)
81116050:	10800ed8 	cmpnei	r2,r2,59
81116054:	103fe81e 	bne	r2,zero,81115ff8 <__reset+0xfb0f5ff8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116058:	e0bffa17 	ldw	r2,-24(fp)
8111605c:	00c00284 	movi	r3,10
81116060:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81116064:	e0bff903 	ldbu	r2,-28(fp)
81116068:	108000e8 	cmpgeui	r2,r2,3
8111606c:	1000021e 	bne	r2,zero,81116078 <vLoadDefaultETHConf+0x3c4>
81116070:	e43ff903 	ldbu	r16,-28(fp)
81116074:	00000106 	br	8111607c <vLoadDefaultETHConf+0x3c8>
81116078:	040000c4 	movi	r16,3
8111607c:	e0bffd04 	addi	r2,fp,-12
81116080:	1009883a 	mov	r4,r2
81116084:	111b9400 	call	8111b940 <atoi>
81116088:	1007883a 	mov	r3,r2
8111608c:	00a045b4 	movhi	r2,33046
81116090:	10835304 	addi	r2,r2,3404
81116094:	1405883a 	add	r2,r2,r16
81116098:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111609c:	e0bffd04 	addi	r2,fp,-12
811160a0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811160a4:	e0bff903 	ldbu	r2,-28(fp)
811160a8:	10800044 	addi	r2,r2,1
811160ac:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811160b0:	e0bff947 	ldb	r2,-27(fp)
811160b4:	10800ed8 	cmpnei	r2,r2,59
811160b8:	103fcf1e 	bne	r2,zero,81115ff8 <__reset+0xfb0f5ff8>

						break;
811160bc:	00010306 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
811160c0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811160c4:	e0bffc0f 	ldh	r2,-16(fp)
811160c8:	1009883a 	mov	r4,r2
811160cc:	1119c940 	call	81119c94 <cGetNextChar>
811160d0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811160d4:	d0e00317 	ldw	r3,-32756(gp)
811160d8:	e0bff947 	ldb	r2,-27(fp)
811160dc:	10800044 	addi	r2,r2,1
811160e0:	1885883a 	add	r2,r3,r2
811160e4:	10800003 	ldbu	r2,0(r2)
811160e8:	10803fcc 	andi	r2,r2,255
811160ec:	1080010c 	andi	r2,r2,4
811160f0:	10000626 	beq	r2,zero,8111610c <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
811160f4:	e0bffa17 	ldw	r2,-24(fp)
811160f8:	e0fff943 	ldbu	r3,-27(fp)
811160fc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116100:	e0bffa17 	ldw	r2,-24(fp)
81116104:	10800044 	addi	r2,r2,1
81116108:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111610c:	e0bff947 	ldb	r2,-27(fp)
81116110:	10800ba0 	cmpeqi	r2,r2,46
81116114:	1000031e 	bne	r2,zero,81116124 <vLoadDefaultETHConf+0x470>
81116118:	e0bff947 	ldb	r2,-27(fp)
8111611c:	10800ed8 	cmpnei	r2,r2,59
81116120:	103fe81e 	bne	r2,zero,811160c4 <__reset+0xfb0f60c4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116124:	e0bffa17 	ldw	r2,-24(fp)
81116128:	00c00284 	movi	r3,10
8111612c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81116130:	e0bff903 	ldbu	r2,-28(fp)
81116134:	108000e8 	cmpgeui	r2,r2,3
81116138:	1000021e 	bne	r2,zero,81116144 <vLoadDefaultETHConf+0x490>
8111613c:	e43ff903 	ldbu	r16,-28(fp)
81116140:	00000106 	br	81116148 <vLoadDefaultETHConf+0x494>
81116144:	040000c4 	movi	r16,3
81116148:	e0bffd04 	addi	r2,fp,-12
8111614c:	1009883a 	mov	r4,r2
81116150:	111b9400 	call	8111b940 <atoi>
81116154:	1007883a 	mov	r3,r2
81116158:	00a045b4 	movhi	r2,33046
8111615c:	10835304 	addi	r2,r2,3404
81116160:	1405883a 	add	r2,r2,r16
81116164:	10800104 	addi	r2,r2,4
81116168:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111616c:	e0bffd04 	addi	r2,fp,-12
81116170:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116174:	e0bff903 	ldbu	r2,-28(fp)
81116178:	10800044 	addi	r2,r2,1
8111617c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116180:	e0bff947 	ldb	r2,-27(fp)
81116184:	10800ed8 	cmpnei	r2,r2,59
81116188:	103fce1e 	bne	r2,zero,811160c4 <__reset+0xfb0f60c4>

						break;
8111618c:	0000cf06 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
81116190:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116194:	e0bffc0f 	ldh	r2,-16(fp)
81116198:	1009883a 	mov	r4,r2
8111619c:	1119c940 	call	81119c94 <cGetNextChar>
811161a0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811161a4:	d0e00317 	ldw	r3,-32756(gp)
811161a8:	e0bff947 	ldb	r2,-27(fp)
811161ac:	10800044 	addi	r2,r2,1
811161b0:	1885883a 	add	r2,r3,r2
811161b4:	10800003 	ldbu	r2,0(r2)
811161b8:	10803fcc 	andi	r2,r2,255
811161bc:	1080010c 	andi	r2,r2,4
811161c0:	10000626 	beq	r2,zero,811161dc <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
811161c4:	e0bffa17 	ldw	r2,-24(fp)
811161c8:	e0fff943 	ldbu	r3,-27(fp)
811161cc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811161d0:	e0bffa17 	ldw	r2,-24(fp)
811161d4:	10800044 	addi	r2,r2,1
811161d8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811161dc:	e0bff947 	ldb	r2,-27(fp)
811161e0:	10800ba0 	cmpeqi	r2,r2,46
811161e4:	1000031e 	bne	r2,zero,811161f4 <vLoadDefaultETHConf+0x540>
811161e8:	e0bff947 	ldb	r2,-27(fp)
811161ec:	10800ed8 	cmpnei	r2,r2,59
811161f0:	103fe81e 	bne	r2,zero,81116194 <__reset+0xfb0f6194>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811161f4:	e0bffa17 	ldw	r2,-24(fp)
811161f8:	00c00284 	movi	r3,10
811161fc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81116200:	e0bff903 	ldbu	r2,-28(fp)
81116204:	108000e8 	cmpgeui	r2,r2,3
81116208:	1000021e 	bne	r2,zero,81116214 <vLoadDefaultETHConf+0x560>
8111620c:	e43ff903 	ldbu	r16,-28(fp)
81116210:	00000106 	br	81116218 <vLoadDefaultETHConf+0x564>
81116214:	040000c4 	movi	r16,3
81116218:	e0bffd04 	addi	r2,fp,-12
8111621c:	1009883a 	mov	r4,r2
81116220:	111b9400 	call	8111b940 <atoi>
81116224:	1007883a 	mov	r3,r2
81116228:	00a045b4 	movhi	r2,33046
8111622c:	10835304 	addi	r2,r2,3404
81116230:	1405883a 	add	r2,r2,r16
81116234:	10800204 	addi	r2,r2,8
81116238:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111623c:	e0bffd04 	addi	r2,fp,-12
81116240:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116244:	e0bff903 	ldbu	r2,-28(fp)
81116248:	10800044 	addi	r2,r2,1
8111624c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116250:	e0bff947 	ldb	r2,-27(fp)
81116254:	10800ed8 	cmpnei	r2,r2,59
81116258:	103fce1e 	bne	r2,zero,81116194 <__reset+0xfb0f6194>

						break;
8111625c:	00009b06 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
81116260:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116264:	e0bffc0f 	ldh	r2,-16(fp)
81116268:	1009883a 	mov	r4,r2
8111626c:	1119c940 	call	81119c94 <cGetNextChar>
81116270:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116274:	d0e00317 	ldw	r3,-32756(gp)
81116278:	e0bff947 	ldb	r2,-27(fp)
8111627c:	10800044 	addi	r2,r2,1
81116280:	1885883a 	add	r2,r3,r2
81116284:	10800003 	ldbu	r2,0(r2)
81116288:	10803fcc 	andi	r2,r2,255
8111628c:	1080010c 	andi	r2,r2,4
81116290:	10000626 	beq	r2,zero,811162ac <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
81116294:	e0bffa17 	ldw	r2,-24(fp)
81116298:	e0fff943 	ldbu	r3,-27(fp)
8111629c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811162a0:	e0bffa17 	ldw	r2,-24(fp)
811162a4:	10800044 	addi	r2,r2,1
811162a8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811162ac:	e0bff947 	ldb	r2,-27(fp)
811162b0:	10800ba0 	cmpeqi	r2,r2,46
811162b4:	1000031e 	bne	r2,zero,811162c4 <vLoadDefaultETHConf+0x610>
811162b8:	e0bff947 	ldb	r2,-27(fp)
811162bc:	10800ed8 	cmpnei	r2,r2,59
811162c0:	103fe81e 	bne	r2,zero,81116264 <__reset+0xfb0f6264>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811162c4:	e0bffa17 	ldw	r2,-24(fp)
811162c8:	00c00284 	movi	r3,10
811162cc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
811162d0:	e0bff903 	ldbu	r2,-28(fp)
811162d4:	108000e8 	cmpgeui	r2,r2,3
811162d8:	1000021e 	bne	r2,zero,811162e4 <vLoadDefaultETHConf+0x630>
811162dc:	e43ff903 	ldbu	r16,-28(fp)
811162e0:	00000106 	br	811162e8 <vLoadDefaultETHConf+0x634>
811162e4:	040000c4 	movi	r16,3
811162e8:	e0bffd04 	addi	r2,fp,-12
811162ec:	1009883a 	mov	r4,r2
811162f0:	111b9400 	call	8111b940 <atoi>
811162f4:	1007883a 	mov	r3,r2
811162f8:	00a045b4 	movhi	r2,33046
811162fc:	10835304 	addi	r2,r2,3404
81116300:	1405883a 	add	r2,r2,r16
81116304:	10800304 	addi	r2,r2,12
81116308:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111630c:	e0bffd04 	addi	r2,fp,-12
81116310:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116314:	e0bff903 	ldbu	r2,-28(fp)
81116318:	10800044 	addi	r2,r2,1
8111631c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116320:	e0bff947 	ldb	r2,-27(fp)
81116324:	10800ed8 	cmpnei	r2,r2,59
81116328:	103fce1e 	bne	r2,zero,81116264 <__reset+0xfb0f6264>

						break;						
8111632c:	00006706 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
81116330:	e0bffc0f 	ldh	r2,-16(fp)
81116334:	1009883a 	mov	r4,r2
81116338:	1119c940 	call	81119c94 <cGetNextChar>
8111633c:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81116340:	d0e00317 	ldw	r3,-32756(gp)
81116344:	e0bff947 	ldb	r2,-27(fp)
81116348:	10800044 	addi	r2,r2,1
8111634c:	1885883a 	add	r2,r3,r2
81116350:	10800003 	ldbu	r2,0(r2)
81116354:	10803fcc 	andi	r2,r2,255
81116358:	1080010c 	andi	r2,r2,4
8111635c:	10000626 	beq	r2,zero,81116378 <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
81116360:	e0bffa17 	ldw	r2,-24(fp)
81116364:	e0fff943 	ldbu	r3,-27(fp)
81116368:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111636c:	e0bffa17 	ldw	r2,-24(fp)
81116370:	10800044 	addi	r2,r2,1
81116374:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116378:	e0bff947 	ldb	r2,-27(fp)
8111637c:	10800ed8 	cmpnei	r2,r2,59
81116380:	103feb1e 	bne	r2,zero,81116330 <__reset+0xfb0f6330>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116384:	e0bffa17 	ldw	r2,-24(fp)
81116388:	00c00284 	movi	r3,10
8111638c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81116390:	e0bffd04 	addi	r2,fp,-12
81116394:	1009883a 	mov	r4,r2
81116398:	111b9400 	call	8111b940 <atoi>
8111639c:	1007883a 	mov	r3,r2
811163a0:	00a045b4 	movhi	r2,33046
811163a4:	10835304 	addi	r2,r2,3404
811163a8:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811163ac:	e0bffd04 	addi	r2,fp,-12
811163b0:	e0bffa15 	stw	r2,-24(fp)

						break;
811163b4:	00004506 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
811163b8:	e0bffc0f 	ldh	r2,-16(fp)
811163bc:	1009883a 	mov	r4,r2
811163c0:	1119c940 	call	81119c94 <cGetNextChar>
811163c4:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811163c8:	d0e00317 	ldw	r3,-32756(gp)
811163cc:	e0bff947 	ldb	r2,-27(fp)
811163d0:	10800044 	addi	r2,r2,1
811163d4:	1885883a 	add	r2,r3,r2
811163d8:	10800003 	ldbu	r2,0(r2)
811163dc:	10803fcc 	andi	r2,r2,255
811163e0:	1080010c 	andi	r2,r2,4
811163e4:	10000626 	beq	r2,zero,81116400 <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
811163e8:	e0bffa17 	ldw	r2,-24(fp)
811163ec:	e0fff943 	ldbu	r3,-27(fp)
811163f0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811163f4:	e0bffa17 	ldw	r2,-24(fp)
811163f8:	10800044 	addi	r2,r2,1
811163fc:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116400:	e0bff947 	ldb	r2,-27(fp)
81116404:	10800ed8 	cmpnei	r2,r2,59
81116408:	103feb1e 	bne	r2,zero,811163b8 <__reset+0xfb0f63b8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111640c:	e0bffa17 	ldw	r2,-24(fp)
81116410:	00c00284 	movi	r3,10
81116414:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81116418:	e0bffd04 	addi	r2,fp,-12
8111641c:	1009883a 	mov	r4,r2
81116420:	111b9400 	call	8111b940 <atoi>
81116424:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81116428:	e0bffc8f 	ldh	r2,-14(fp)
8111642c:	10800058 	cmpnei	r2,r2,1
81116430:	1000051e 	bne	r2,zero,81116448 <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81116434:	00a045b4 	movhi	r2,33046
81116438:	10835304 	addi	r2,r2,3404
8111643c:	00c00044 	movi	r3,1
81116440:	10c00615 	stw	r3,24(r2)
81116444:	00000306 	br	81116454 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
81116448:	00a045b4 	movhi	r2,33046
8111644c:	10835304 	addi	r2,r2,3404
81116450:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81116454:	e0bffd04 	addi	r2,fp,-12
81116458:	e0bffa15 	stw	r2,-24(fp)

						break;
8111645c:	00001b06 	br	811164cc <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81116460:	e0bffc0f 	ldh	r2,-16(fp)
81116464:	1009883a 	mov	r4,r2
81116468:	1119c540 	call	81119c54 <siCloseFile>
8111646c:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81116470:	e0bffb17 	ldw	r2,-20(fp)
81116474:	1000071e 	bne	r2,zero,81116494 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81116478:	d0a05c17 	ldw	r2,-32400(gp)
8111647c:	100f883a 	mov	r7,r2
81116480:	01800784 	movi	r6,30
81116484:	01400044 	movi	r5,1
81116488:	01204574 	movhi	r4,33045
8111648c:	2123ef04 	addi	r4,r4,-28740
81116490:	111c1380 	call	8111c138 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81116494:	00800044 	movi	r2,1
81116498:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111649c:	00800044 	movi	r2,1
811164a0:	e0bff715 	stw	r2,-36(fp)
						break;
811164a4:	00000906 	br	811164cc <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
811164a8:	d0a05c17 	ldw	r2,-32400(gp)
811164ac:	100f883a 	mov	r7,r2
811164b0:	01800844 	movi	r6,33
811164b4:	01400044 	movi	r5,1
811164b8:	01204574 	movhi	r4,33045
811164bc:	2123f704 	addi	r4,r4,-28708
811164c0:	111c1380 	call	8111c138 <fwrite>
						#endif
						break;
811164c4:	00000106 	br	811164cc <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
811164c8:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
811164cc:	e0bff817 	ldw	r2,-32(fp)
811164d0:	103e1626 	beq	r2,zero,81115d2c <__reset+0xfb0f5d2c>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
811164d4:	00000f06 	br	81116514 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
811164d8:	d0a05c17 	ldw	r2,-32400(gp)
811164dc:	100f883a 	mov	r7,r2
811164e0:	01800604 	movi	r6,24
811164e4:	01400044 	movi	r5,1
811164e8:	01204574 	movhi	r4,33045
811164ec:	21240004 	addi	r4,r4,-28672
811164f0:	111c1380 	call	8111c138 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
811164f4:	00000706 	br	81116514 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
811164f8:	d0a05c17 	ldw	r2,-32400(gp)
811164fc:	100f883a 	mov	r7,r2
81116500:	018004c4 	movi	r6,19
81116504:	01400044 	movi	r5,1
81116508:	01204574 	movhi	r4,33045
8111650c:	21240704 	addi	r4,r4,-28644
81116510:	111c1380 	call	8111c138 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81116514:	e0bff717 	ldw	r2,-36(fp)
81116518:	1000541e 	bne	r2,zero,8111666c <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
8111651c:	01204574 	movhi	r4,33045
81116520:	21240c04 	addi	r4,r4,-28624
81116524:	111d0e80 	call	8111d0e8 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81116528:	01604574 	movhi	r5,33045
8111652c:	2963e604 	addi	r5,r5,-28776
81116530:	01204574 	movhi	r4,33045
81116534:	21242004 	addi	r4,r4,-28544
81116538:	111ce640 	call	8111ce64 <printf>


		xConfEth.siPortPUS = 17000;
8111653c:	00a045b4 	movhi	r2,33046
81116540:	10835304 	addi	r2,r2,3404
81116544:	00d09a04 	movi	r3,17000
81116548:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111654c:	00a045b4 	movhi	r2,33046
81116550:	10835304 	addi	r2,r2,3404
81116554:	00fff004 	movi	r3,-64
81116558:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111655c:	00a045b4 	movhi	r2,33046
81116560:	10835304 	addi	r2,r2,3404
81116564:	00ffea04 	movi	r3,-88
81116568:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111656c:	00a045b4 	movhi	r2,33046
81116570:	10835304 	addi	r2,r2,3404
81116574:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81116578:	00a045b4 	movhi	r2,33046
8111657c:	10835304 	addi	r2,r2,3404
81116580:	00c00144 	movi	r3,5
81116584:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81116588:	00a045b4 	movhi	r2,33046
8111658c:	10835304 	addi	r2,r2,3404
81116590:	00fff004 	movi	r3,-64
81116594:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81116598:	00a045b4 	movhi	r2,33046
8111659c:	10835304 	addi	r2,r2,3404
811165a0:	00ffea04 	movi	r3,-88
811165a4:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
811165a8:	00a045b4 	movhi	r2,33046
811165ac:	10835304 	addi	r2,r2,3404
811165b0:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
811165b4:	00a045b4 	movhi	r2,33046
811165b8:	10835304 	addi	r2,r2,3404
811165bc:	00c00044 	movi	r3,1
811165c0:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
811165c4:	00a045b4 	movhi	r2,33046
811165c8:	10835304 	addi	r2,r2,3404
811165cc:	00ffffc4 	movi	r3,-1
811165d0:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
811165d4:	00a045b4 	movhi	r2,33046
811165d8:	10835304 	addi	r2,r2,3404
811165dc:	00ffffc4 	movi	r3,-1
811165e0:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
811165e4:	00a045b4 	movhi	r2,33046
811165e8:	10835304 	addi	r2,r2,3404
811165ec:	00ffffc4 	movi	r3,-1
811165f0:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
811165f4:	00a045b4 	movhi	r2,33046
811165f8:	10835304 	addi	r2,r2,3404
811165fc:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81116600:	00a045b4 	movhi	r2,33046
81116604:	10835304 	addi	r2,r2,3404
81116608:	00ffff04 	movi	r3,-4
8111660c:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
81116610:	00a045b4 	movhi	r2,33046
81116614:	10835304 	addi	r2,r2,3404
81116618:	00fffdc4 	movi	r3,-9
8111661c:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
81116620:	00a045b4 	movhi	r2,33046
81116624:	10835304 	addi	r2,r2,3404
81116628:	00c018c4 	movi	r3,99
8111662c:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81116630:	00a045b4 	movhi	r2,33046
81116634:	10835304 	addi	r2,r2,3404
81116638:	00c01344 	movi	r3,77
8111663c:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81116640:	00a045b4 	movhi	r2,33046
81116644:	10835304 	addi	r2,r2,3404
81116648:	00c007c4 	movi	r3,31
8111664c:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81116650:	00a045b4 	movhi	r2,33046
81116654:	10835304 	addi	r2,r2,3404
81116658:	00c01084 	movi	r3,66
8111665c:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
81116660:	00a045b4 	movhi	r2,33046
81116664:	10835304 	addi	r2,r2,3404
81116668:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111666c:	e0bff717 	ldw	r2,-36(fp)
}
81116670:	e6ffff04 	addi	sp,fp,-4
81116674:	dfc00217 	ldw	ra,8(sp)
81116678:	df000117 	ldw	fp,4(sp)
8111667c:	dc000017 	ldw	r16,0(sp)
81116680:	dec00304 	addi	sp,sp,12
81116684:	f800283a 	ret

81116688 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81116688:	defff004 	addi	sp,sp,-64
8111668c:	de00012e 	bgeu	sp,et,81116694 <vShowEthConfig+0xc>
81116690:	003b68fa 	trap	3
81116694:	dfc00f15 	stw	ra,60(sp)
81116698:	df000e15 	stw	fp,56(sp)
8111669c:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
811166a0:	d0a05c17 	ldw	r2,-32400(gp)
811166a4:	100f883a 	mov	r7,r2
811166a8:	018007c4 	movi	r6,31
811166ac:	01400044 	movi	r5,1
811166b0:	01204574 	movhi	r4,33045
811166b4:	21242604 	addi	r4,r4,-28520
811166b8:	111c1380 	call	8111c138 <fwrite>

		memset(buffer,0,40);
811166bc:	01800a04 	movi	r6,40
811166c0:	000b883a 	mov	r5,zero
811166c4:	e13ff604 	addi	r4,fp,-40
811166c8:	111cc9c0 	call	8111cc9c <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
811166cc:	00a045b4 	movhi	r2,33046
811166d0:	10835304 	addi	r2,r2,3404
811166d4:	10800403 	ldbu	r2,16(r2)
811166d8:	11803fcc 	andi	r6,r2,255
811166dc:	00a045b4 	movhi	r2,33046
811166e0:	10835304 	addi	r2,r2,3404
811166e4:	10800443 	ldbu	r2,17(r2)
811166e8:	11c03fcc 	andi	r7,r2,255
811166ec:	00a045b4 	movhi	r2,33046
811166f0:	10835304 	addi	r2,r2,3404
811166f4:	10800483 	ldbu	r2,18(r2)
811166f8:	10c03fcc 	andi	r3,r2,255
811166fc:	00a045b4 	movhi	r2,33046
81116700:	10835304 	addi	r2,r2,3404
81116704:	108004c3 	ldbu	r2,19(r2)
81116708:	11003fcc 	andi	r4,r2,255
8111670c:	00a045b4 	movhi	r2,33046
81116710:	10835304 	addi	r2,r2,3404
81116714:	10800503 	ldbu	r2,20(r2)
81116718:	11403fcc 	andi	r5,r2,255
8111671c:	00a045b4 	movhi	r2,33046
81116720:	10835304 	addi	r2,r2,3404
81116724:	10800543 	ldbu	r2,21(r2)
81116728:	10803fcc 	andi	r2,r2,255
8111672c:	d8800315 	stw	r2,12(sp)
81116730:	d9400215 	stw	r5,8(sp)
81116734:	d9000115 	stw	r4,4(sp)
81116738:	d8c00015 	stw	r3,0(sp)
8111673c:	01604574 	movhi	r5,33045
81116740:	29642e04 	addi	r5,r5,-28488
81116744:	e13ff604 	addi	r4,fp,-40
81116748:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer );
8111674c:	d0a05c17 	ldw	r2,-32400(gp)
81116750:	e17ff604 	addi	r5,fp,-40
81116754:	1009883a 	mov	r4,r2
81116758:	111ba9c0 	call	8111ba9c <fprintf>

		memset(buffer,0,40);
8111675c:	01800a04 	movi	r6,40
81116760:	000b883a 	mov	r5,zero
81116764:	e13ff604 	addi	r4,fp,-40
81116768:	111cc9c0 	call	8111cc9c <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111676c:	00a045b4 	movhi	r2,33046
81116770:	10835304 	addi	r2,r2,3404
81116774:	10800003 	ldbu	r2,0(r2)
81116778:	11003fcc 	andi	r4,r2,255
8111677c:	00a045b4 	movhi	r2,33046
81116780:	10835304 	addi	r2,r2,3404
81116784:	10800043 	ldbu	r2,1(r2)
81116788:	11403fcc 	andi	r5,r2,255
8111678c:	00a045b4 	movhi	r2,33046
81116790:	10835304 	addi	r2,r2,3404
81116794:	10800083 	ldbu	r2,2(r2)
81116798:	10c03fcc 	andi	r3,r2,255
8111679c:	00a045b4 	movhi	r2,33046
811167a0:	10835304 	addi	r2,r2,3404
811167a4:	108000c3 	ldbu	r2,3(r2)
811167a8:	10803fcc 	andi	r2,r2,255
811167ac:	d8800115 	stw	r2,4(sp)
811167b0:	d8c00015 	stw	r3,0(sp)
811167b4:	280f883a 	mov	r7,r5
811167b8:	200d883a 	mov	r6,r4
811167bc:	01604574 	movhi	r5,33045
811167c0:	29643704 	addi	r5,r5,-28452
811167c4:	e13ff604 	addi	r4,fp,-40
811167c8:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer );
811167cc:	d0a05c17 	ldw	r2,-32400(gp)
811167d0:	e17ff604 	addi	r5,fp,-40
811167d4:	1009883a 	mov	r4,r2
811167d8:	111ba9c0 	call	8111ba9c <fprintf>

		memset(buffer,0,40);
811167dc:	01800a04 	movi	r6,40
811167e0:	000b883a 	mov	r5,zero
811167e4:	e13ff604 	addi	r4,fp,-40
811167e8:	111cc9c0 	call	8111cc9c <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
811167ec:	00a045b4 	movhi	r2,33046
811167f0:	10835304 	addi	r2,r2,3404
811167f4:	10800103 	ldbu	r2,4(r2)
811167f8:	11003fcc 	andi	r4,r2,255
811167fc:	00a045b4 	movhi	r2,33046
81116800:	10835304 	addi	r2,r2,3404
81116804:	10800143 	ldbu	r2,5(r2)
81116808:	11403fcc 	andi	r5,r2,255
8111680c:	00a045b4 	movhi	r2,33046
81116810:	10835304 	addi	r2,r2,3404
81116814:	10800183 	ldbu	r2,6(r2)
81116818:	10c03fcc 	andi	r3,r2,255
8111681c:	00a045b4 	movhi	r2,33046
81116820:	10835304 	addi	r2,r2,3404
81116824:	108001c3 	ldbu	r2,7(r2)
81116828:	10803fcc 	andi	r2,r2,255
8111682c:	d8800115 	stw	r2,4(sp)
81116830:	d8c00015 	stw	r3,0(sp)
81116834:	280f883a 	mov	r7,r5
81116838:	200d883a 	mov	r6,r4
8111683c:	01604574 	movhi	r5,33045
81116840:	29643d04 	addi	r5,r5,-28428
81116844:	e13ff604 	addi	r4,fp,-40
81116848:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer );
8111684c:	d0a05c17 	ldw	r2,-32400(gp)
81116850:	e17ff604 	addi	r5,fp,-40
81116854:	1009883a 	mov	r4,r2
81116858:	111ba9c0 	call	8111ba9c <fprintf>

		memset(buffer,0,40);
8111685c:	01800a04 	movi	r6,40
81116860:	000b883a 	mov	r5,zero
81116864:	e13ff604 	addi	r4,fp,-40
81116868:	111cc9c0 	call	8111cc9c <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
8111686c:	00a045b4 	movhi	r2,33046
81116870:	10835304 	addi	r2,r2,3404
81116874:	10800203 	ldbu	r2,8(r2)
81116878:	11003fcc 	andi	r4,r2,255
8111687c:	00a045b4 	movhi	r2,33046
81116880:	10835304 	addi	r2,r2,3404
81116884:	10800243 	ldbu	r2,9(r2)
81116888:	11403fcc 	andi	r5,r2,255
8111688c:	00a045b4 	movhi	r2,33046
81116890:	10835304 	addi	r2,r2,3404
81116894:	10800283 	ldbu	r2,10(r2)
81116898:	10c03fcc 	andi	r3,r2,255
8111689c:	00a045b4 	movhi	r2,33046
811168a0:	10835304 	addi	r2,r2,3404
811168a4:	108002c3 	ldbu	r2,11(r2)
811168a8:	10803fcc 	andi	r2,r2,255
811168ac:	d8800115 	stw	r2,4(sp)
811168b0:	d8c00015 	stw	r3,0(sp)
811168b4:	280f883a 	mov	r7,r5
811168b8:	200d883a 	mov	r6,r4
811168bc:	01604574 	movhi	r5,33045
811168c0:	29644404 	addi	r5,r5,-28400
811168c4:	e13ff604 	addi	r4,fp,-40
811168c8:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer );
811168cc:	d0a05c17 	ldw	r2,-32400(gp)
811168d0:	e17ff604 	addi	r5,fp,-40
811168d4:	1009883a 	mov	r4,r2
811168d8:	111ba9c0 	call	8111ba9c <fprintf>

		memset(buffer,0,40);
811168dc:	01800a04 	movi	r6,40
811168e0:	000b883a 	mov	r5,zero
811168e4:	e13ff604 	addi	r4,fp,-40
811168e8:	111cc9c0 	call	8111cc9c <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
811168ec:	00a045b4 	movhi	r2,33046
811168f0:	10835304 	addi	r2,r2,3404
811168f4:	10800303 	ldbu	r2,12(r2)
811168f8:	11003fcc 	andi	r4,r2,255
811168fc:	00a045b4 	movhi	r2,33046
81116900:	10835304 	addi	r2,r2,3404
81116904:	10800343 	ldbu	r2,13(r2)
81116908:	11403fcc 	andi	r5,r2,255
8111690c:	00a045b4 	movhi	r2,33046
81116910:	10835304 	addi	r2,r2,3404
81116914:	10800383 	ldbu	r2,14(r2)
81116918:	10c03fcc 	andi	r3,r2,255
8111691c:	00a045b4 	movhi	r2,33046
81116920:	10835304 	addi	r2,r2,3404
81116924:	108003c3 	ldbu	r2,15(r2)
81116928:	10803fcc 	andi	r2,r2,255
8111692c:	d8800115 	stw	r2,4(sp)
81116930:	d8c00015 	stw	r3,0(sp)
81116934:	280f883a 	mov	r7,r5
81116938:	200d883a 	mov	r6,r4
8111693c:	01604574 	movhi	r5,33045
81116940:	29644b04 	addi	r5,r5,-28372
81116944:	e13ff604 	addi	r4,fp,-40
81116948:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer );
8111694c:	d0a05c17 	ldw	r2,-32400(gp)
81116950:	e17ff604 	addi	r5,fp,-40
81116954:	1009883a 	mov	r4,r2
81116958:	111ba9c0 	call	8111ba9c <fprintf>

		memset(buffer,0,40);
8111695c:	01800a04 	movi	r6,40
81116960:	000b883a 	mov	r5,zero
81116964:	e13ff604 	addi	r4,fp,-40
81116968:	111cc9c0 	call	8111cc9c <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
8111696c:	00a045b4 	movhi	r2,33046
81116970:	10835304 	addi	r2,r2,3404
81116974:	1080058b 	ldhu	r2,22(r2)
81116978:	10bfffcc 	andi	r2,r2,65535
8111697c:	100d883a 	mov	r6,r2
81116980:	01604574 	movhi	r5,33045
81116984:	29645204 	addi	r5,r5,-28344
81116988:	e13ff604 	addi	r4,fp,-40
8111698c:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer );
81116990:	d0a05c17 	ldw	r2,-32400(gp)
81116994:	e17ff604 	addi	r5,fp,-40
81116998:	1009883a 	mov	r4,r2
8111699c:	111ba9c0 	call	8111ba9c <fprintf>

	}
811169a0:	0001883a 	nop
811169a4:	e037883a 	mov	sp,fp
811169a8:	dfc00117 	ldw	ra,4(sp)
811169ac:	df000017 	ldw	fp,0(sp)
811169b0:	dec00204 	addi	sp,sp,8
811169b4:	f800283a 	ret

811169b8 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
811169b8:	defffb04 	addi	sp,sp,-20
811169bc:	de00012e 	bgeu	sp,et,811169c4 <ucCrc8+0xc>
811169c0:	003b68fa 	trap	3
811169c4:	df000415 	stw	fp,16(sp)
811169c8:	df000404 	addi	fp,sp,16
811169cc:	e13ffd15 	stw	r4,-12(fp)
811169d0:	e17ffe15 	stw	r5,-8(fp)
811169d4:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
811169d8:	e0bffe17 	ldw	r2,-8(fp)
811169dc:	1000021e 	bne	r2,zero,811169e8 <ucCrc8+0x30>
        return 0;
811169e0:	0005883a 	mov	r2,zero
811169e4:	00001906 	br	81116a4c <ucCrc8+0x94>
    crc &= 0xff;
811169e8:	e0bffd17 	ldw	r2,-12(fp)
811169ec:	10803fcc 	andi	r2,r2,255
811169f0:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
811169f4:	e0fffe17 	ldw	r3,-8(fp)
811169f8:	e0bfff17 	ldw	r2,-4(fp)
811169fc:	1885883a 	add	r2,r3,r2
81116a00:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81116a04:	00000d06 	br	81116a3c <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
81116a08:	e0bffe17 	ldw	r2,-8(fp)
81116a0c:	10c00044 	addi	r3,r2,1
81116a10:	e0fffe15 	stw	r3,-8(fp)
81116a14:	10800003 	ldbu	r2,0(r2)
81116a18:	10c03fcc 	andi	r3,r2,255
81116a1c:	e0bffd17 	ldw	r2,-12(fp)
81116a20:	1886f03a 	xor	r3,r3,r2
81116a24:	00a04574 	movhi	r2,33045
81116a28:	10a455c4 	addi	r2,r2,-28329
81116a2c:	10c5883a 	add	r2,r2,r3
81116a30:	10800003 	ldbu	r2,0(r2)
81116a34:	10803fcc 	andi	r2,r2,255
81116a38:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
81116a3c:	e0fffe17 	ldw	r3,-8(fp)
81116a40:	e0bffc17 	ldw	r2,-16(fp)
81116a44:	18bff036 	bltu	r3,r2,81116a08 <__reset+0xfb0f6a08>
        crc = crc8_table[crc ^ *data++];
    return crc;
81116a48:	e0bffd17 	ldw	r2,-12(fp)
}
81116a4c:	e037883a 	mov	sp,fp
81116a50:	df000017 	ldw	fp,0(sp)
81116a54:	dec00104 	addi	sp,sp,4
81116a58:	f800283a 	ret

81116a5c <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
81116a5c:	defffb04 	addi	sp,sp,-20
81116a60:	de00012e 	bgeu	sp,et,81116a68 <ucCrc8wInit+0xc>
81116a64:	003b68fa 	trap	3
81116a68:	dfc00415 	stw	ra,16(sp)
81116a6c:	df000315 	stw	fp,12(sp)
81116a70:	df000304 	addi	fp,sp,12
81116a74:	e13ffe15 	stw	r4,-8(fp)
81116a78:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
81116a7c:	000d883a 	mov	r6,zero
81116a80:	000b883a 	mov	r5,zero
81116a84:	0009883a 	mov	r4,zero
81116a88:	11169b80 	call	811169b8 <ucCrc8>
81116a8c:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
81116a90:	e0bffd03 	ldbu	r2,-12(fp)
81116a94:	e1bfff17 	ldw	r6,-4(fp)
81116a98:	e17ffe17 	ldw	r5,-8(fp)
81116a9c:	1009883a 	mov	r4,r2
81116aa0:	11169b80 	call	811169b8 <ucCrc8>
}
81116aa4:	e037883a 	mov	sp,fp
81116aa8:	dfc00117 	ldw	ra,4(sp)
81116aac:	df000017 	ldw	fp,0(sp)
81116ab0:	dec00204 	addi	sp,sp,8
81116ab4:	f800283a 	ret

81116ab8 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
81116ab8:	defffc04 	addi	sp,sp,-16
81116abc:	de00012e 	bgeu	sp,et,81116ac4 <vDataControllerInit+0xc>
81116ac0:	003b68fa 	trap	3
81116ac4:	df000315 	stw	fp,12(sp)
81116ac8:	df000304 	addi	fp,sp,12
81116acc:	e13ffe15 	stw	r4,-8(fp)
81116ad0:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
81116ad4:	e0bffe17 	ldw	r2,-8(fp)
81116ad8:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81116adc:	e03ffd05 	stb	zero,-12(fp)
81116ae0:	00001c06 	br	81116b54 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
81116ae4:	e0bffd03 	ldbu	r2,-12(fp)
81116ae8:	e0fffd03 	ldbu	r3,-12(fp)
81116aec:	18c09524 	muli	r3,r3,596
81116af0:	e13fff17 	ldw	r4,-4(fp)
81116af4:	20c7883a 	add	r3,r4,r3
81116af8:	e13ffe17 	ldw	r4,-8(fp)
81116afc:	10800084 	addi	r2,r2,2
81116b00:	1085883a 	add	r2,r2,r2
81116b04:	1085883a 	add	r2,r2,r2
81116b08:	2085883a 	add	r2,r4,r2
81116b0c:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
81116b10:	e17ffd03 	ldbu	r5,-12(fp)
81116b14:	e0bffd03 	ldbu	r2,-12(fp)
81116b18:	e0ffff17 	ldw	r3,-4(fp)
81116b1c:	10802584 	addi	r2,r2,150
81116b20:	1085883a 	add	r2,r2,r2
81116b24:	1085883a 	add	r2,r2,r2
81116b28:	1885883a 	add	r2,r3,r2
81116b2c:	10c00017 	ldw	r3,0(r2)
81116b30:	e13ffe17 	ldw	r4,-8(fp)
81116b34:	288000c4 	addi	r2,r5,3
81116b38:	1085883a 	add	r2,r2,r2
81116b3c:	1085883a 	add	r2,r2,r2
81116b40:	2085883a 	add	r2,r4,r2
81116b44:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81116b48:	e0bffd03 	ldbu	r2,-12(fp)
81116b4c:	10800044 	addi	r2,r2,1
81116b50:	e0bffd05 	stb	r2,-12(fp)
81116b54:	e0bffd03 	ldbu	r2,-12(fp)
81116b58:	103fe226 	beq	r2,zero,81116ae4 <__reset+0xfb0f6ae4>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
81116b5c:	e0bfff17 	ldw	r2,-4(fp)
81116b60:	10c09804 	addi	r3,r2,608
81116b64:	e0bffe17 	ldw	r2,-8(fp)
81116b68:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
81116b6c:	e0bffe17 	ldw	r2,-8(fp)
81116b70:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81116b74:	e0bffe17 	ldw	r2,-8(fp)
81116b78:	10c00504 	addi	r3,r2,20
81116b7c:	e0bfff17 	ldw	r2,-4(fp)
81116b80:	10c09a15 	stw	r3,616(r2)
}
81116b84:	0001883a 	nop
81116b88:	e037883a 	mov	sp,fp
81116b8c:	df000017 	ldw	fp,0(sp)
81116b90:	dec00104 	addi	sp,sp,4
81116b94:	f800283a 	ret

81116b98 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81116b98:	defff904 	addi	sp,sp,-28
81116b9c:	de00012e 	bgeu	sp,et,81116ba4 <printErrorTask+0xc>
81116ba0:	003b68fa 	trap	3
81116ba4:	dfc00615 	stw	ra,24(sp)
81116ba8:	df000515 	stw	fp,20(sp)
81116bac:	df000504 	addi	fp,sp,20
81116bb0:	2005883a 	mov	r2,r4
81116bb4:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81116bb8:	e03ffb15 	stw	zero,-20(fp)
81116bbc:	e03ffc15 	stw	zero,-16(fp)
81116bc0:	e03ffd15 	stw	zero,-12(fp)
81116bc4:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81116bc8:	e0bfff03 	ldbu	r2,-4(fp)
81116bcc:	100d883a 	mov	r6,r2
81116bd0:	01604574 	movhi	r5,33045
81116bd4:	29649604 	addi	r5,r5,-28072
81116bd8:	e13ffb04 	addi	r4,fp,-20
81116bdc:	111d42c0 	call	8111d42c <sprintf>
		debug(fp, buffer);
81116be0:	d0a05c17 	ldw	r2,-32400(gp)
81116be4:	e17ffb04 	addi	r5,fp,-20
81116be8:	1009883a 	mov	r4,r2
81116bec:	111ba9c0 	call	8111ba9c <fprintf>
	}
81116bf0:	0001883a 	nop
81116bf4:	e037883a 	mov	sp,fp
81116bf8:	dfc00117 	ldw	ra,4(sp)
81116bfc:	df000017 	ldw	fp,0(sp)
81116c00:	dec00204 	addi	sp,sp,8
81116c04:	f800283a 	ret

81116c08 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81116c08:	defffd04 	addi	sp,sp,-12
81116c0c:	de00012e 	bgeu	sp,et,81116c14 <vFailCreateMutexSResources+0xc>
81116c10:	003b68fa 	trap	3
81116c14:	dfc00215 	stw	ra,8(sp)
81116c18:	df000115 	stw	fp,4(sp)
81116c1c:	df000104 	addi	fp,sp,4
81116c20:	2005883a 	mov	r2,r4
81116c24:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
81116c28:	d0a05c17 	ldw	r2,-32400(gp)
81116c2c:	100f883a 	mov	r7,r2
81116c30:	018008c4 	movi	r6,35
81116c34:	01400044 	movi	r5,1
81116c38:	01204574 	movhi	r4,33045
81116c3c:	21249904 	addi	r4,r4,-28060
81116c40:	111c1380 	call	8111c138 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81116c44:	e0bfff03 	ldbu	r2,-4(fp)
81116c48:	1009883a 	mov	r4,r2
81116c4c:	1116b980 	call	81116b98 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c50:	0001883a 	nop
81116c54:	e037883a 	mov	sp,fp
81116c58:	dfc00117 	ldw	ra,4(sp)
81116c5c:	df000017 	ldw	fp,0(sp)
81116c60:	dec00204 	addi	sp,sp,8
81116c64:	f800283a 	ret

81116c68 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81116c68:	defffe04 	addi	sp,sp,-8
81116c6c:	de00012e 	bgeu	sp,et,81116c74 <vFailCreateMutexDMA+0xc>
81116c70:	003b68fa 	trap	3
81116c74:	dfc00115 	stw	ra,4(sp)
81116c78:	df000015 	stw	fp,0(sp)
81116c7c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
81116c80:	d0a05c17 	ldw	r2,-32400(gp)
81116c84:	100f883a 	mov	r7,r2
81116c88:	018009c4 	movi	r6,39
81116c8c:	01400044 	movi	r5,1
81116c90:	01204574 	movhi	r4,33045
81116c94:	2124a204 	addi	r4,r4,-28024
81116c98:	111c1380 	call	8111c138 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c9c:	0001883a 	nop
81116ca0:	e037883a 	mov	sp,fp
81116ca4:	dfc00117 	ldw	ra,4(sp)
81116ca8:	df000017 	ldw	fp,0(sp)
81116cac:	dec00204 	addi	sp,sp,8
81116cb0:	f800283a 	ret

81116cb4 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
81116cb4:	defffe04 	addi	sp,sp,-8
81116cb8:	de00012e 	bgeu	sp,et,81116cc0 <vFailCreateSemaphoreResources+0xc>
81116cbc:	003b68fa 	trap	3
81116cc0:	dfc00115 	stw	ra,4(sp)
81116cc4:	df000015 	stw	fp,0(sp)
81116cc8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
81116ccc:	d0a05c17 	ldw	r2,-32400(gp)
81116cd0:	100f883a 	mov	r7,r2
81116cd4:	01800984 	movi	r6,38
81116cd8:	01400044 	movi	r5,1
81116cdc:	01204574 	movhi	r4,33045
81116ce0:	2124ac04 	addi	r4,r4,-27984
81116ce4:	111c1380 	call	8111c138 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ce8:	0001883a 	nop
81116cec:	e037883a 	mov	sp,fp
81116cf0:	dfc00117 	ldw	ra,4(sp)
81116cf4:	df000017 	ldw	fp,0(sp)
81116cf8:	dec00204 	addi	sp,sp,8
81116cfc:	f800283a 	ret

81116d00 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81116d00:	defffe04 	addi	sp,sp,-8
81116d04:	de00012e 	bgeu	sp,et,81116d0c <vFailTestCriticasParts+0xc>
81116d08:	003b68fa 	trap	3
81116d0c:	dfc00115 	stw	ra,4(sp)
81116d10:	df000015 	stw	fp,0(sp)
81116d14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
81116d18:	d0a05c17 	ldw	r2,-32400(gp)
81116d1c:	100f883a 	mov	r7,r2
81116d20:	018007c4 	movi	r6,31
81116d24:	01400044 	movi	r5,1
81116d28:	01204574 	movhi	r4,33045
81116d2c:	2124b604 	addi	r4,r4,-27944
81116d30:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d34:	0001883a 	nop
81116d38:	e037883a 	mov	sp,fp
81116d3c:	dfc00117 	ldw	ra,4(sp)
81116d40:	df000017 	ldw	fp,0(sp)
81116d44:	dec00204 	addi	sp,sp,8
81116d48:	f800283a 	ret

81116d4c <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81116d4c:	defffe04 	addi	sp,sp,-8
81116d50:	de00012e 	bgeu	sp,et,81116d58 <vFailSendxSemCommInit+0xc>
81116d54:	003b68fa 	trap	3
81116d58:	dfc00115 	stw	ra,4(sp)
81116d5c:	df000015 	stw	fp,0(sp)
81116d60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81116d64:	d0a05c17 	ldw	r2,-32400(gp)
81116d68:	100f883a 	mov	r7,r2
81116d6c:	01800744 	movi	r6,29
81116d70:	01400044 	movi	r5,1
81116d74:	01204574 	movhi	r4,33045
81116d78:	2124be04 	addi	r4,r4,-27912
81116d7c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
81116d80:	d0a05c17 	ldw	r2,-32400(gp)
81116d84:	100f883a 	mov	r7,r2
81116d88:	01800a44 	movi	r6,41
81116d8c:	01400044 	movi	r5,1
81116d90:	01204574 	movhi	r4,33045
81116d94:	2124c604 	addi	r4,r4,-27880
81116d98:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d9c:	0001883a 	nop
81116da0:	e037883a 	mov	sp,fp
81116da4:	dfc00117 	ldw	ra,4(sp)
81116da8:	df000017 	ldw	fp,0(sp)
81116dac:	dec00204 	addi	sp,sp,8
81116db0:	f800283a 	ret

81116db4 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
81116db4:	defffe04 	addi	sp,sp,-8
81116db8:	de00012e 	bgeu	sp,et,81116dc0 <vFailSendPreParsedSemaphore+0xc>
81116dbc:	003b68fa 	trap	3
81116dc0:	dfc00115 	stw	ra,4(sp)
81116dc4:	df000015 	stw	fp,0(sp)
81116dc8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
81116dcc:	d0a05c17 	ldw	r2,-32400(gp)
81116dd0:	100f883a 	mov	r7,r2
81116dd4:	01800904 	movi	r6,36
81116dd8:	01400044 	movi	r5,1
81116ddc:	01204574 	movhi	r4,33045
81116de0:	2124d104 	addi	r4,r4,-27836
81116de4:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116de8:	0001883a 	nop
81116dec:	e037883a 	mov	sp,fp
81116df0:	dfc00117 	ldw	ra,4(sp)
81116df4:	df000017 	ldw	fp,0(sp)
81116df8:	dec00204 	addi	sp,sp,8
81116dfc:	f800283a 	ret

81116e00 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81116e00:	defffe04 	addi	sp,sp,-8
81116e04:	de00012e 	bgeu	sp,et,81116e0c <vFailSendPreAckReceiverSemaphore+0xc>
81116e08:	003b68fa 	trap	3
81116e0c:	dfc00115 	stw	ra,4(sp)
81116e10:	df000015 	stw	fp,0(sp)
81116e14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
81116e18:	d0a05c17 	ldw	r2,-32400(gp)
81116e1c:	100f883a 	mov	r7,r2
81116e20:	01800a44 	movi	r6,41
81116e24:	01400044 	movi	r5,1
81116e28:	01204574 	movhi	r4,33045
81116e2c:	2124db04 	addi	r4,r4,-27796
81116e30:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e34:	0001883a 	nop
81116e38:	e037883a 	mov	sp,fp
81116e3c:	dfc00117 	ldw	ra,4(sp)
81116e40:	df000017 	ldw	fp,0(sp)
81116e44:	dec00204 	addi	sp,sp,8
81116e48:	f800283a 	ret

81116e4c <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81116e4c:	defffe04 	addi	sp,sp,-8
81116e50:	de00012e 	bgeu	sp,et,81116e58 <vFailSendPreAckSenderSemaphore+0xc>
81116e54:	003b68fa 	trap	3
81116e58:	dfc00115 	stw	ra,4(sp)
81116e5c:	df000015 	stw	fp,0(sp)
81116e60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81116e64:	d0a05c17 	ldw	r2,-32400(gp)
81116e68:	100f883a 	mov	r7,r2
81116e6c:	018009c4 	movi	r6,39
81116e70:	01400044 	movi	r5,1
81116e74:	01204574 	movhi	r4,33045
81116e78:	2124e604 	addi	r4,r4,-27752
81116e7c:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e80:	0001883a 	nop
81116e84:	e037883a 	mov	sp,fp
81116e88:	dfc00117 	ldw	ra,4(sp)
81116e8c:	df000017 	ldw	fp,0(sp)
81116e90:	dec00204 	addi	sp,sp,8
81116e94:	f800283a 	ret

81116e98 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
81116e98:	defffe04 	addi	sp,sp,-8
81116e9c:	de00012e 	bgeu	sp,et,81116ea4 <vFailGetCountSemaphoreSenderTask+0xc>
81116ea0:	003b68fa 	trap	3
81116ea4:	dfc00115 	stw	ra,4(sp)
81116ea8:	df000015 	stw	fp,0(sp)
81116eac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
81116eb0:	d0a05c17 	ldw	r2,-32400(gp)
81116eb4:	100f883a 	mov	r7,r2
81116eb8:	01800a44 	movi	r6,41
81116ebc:	01400044 	movi	r5,1
81116ec0:	01204574 	movhi	r4,33045
81116ec4:	2124f004 	addi	r4,r4,-27712
81116ec8:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
81116ecc:	d0a05c17 	ldw	r2,-32400(gp)
81116ed0:	100f883a 	mov	r7,r2
81116ed4:	01801104 	movi	r6,68
81116ed8:	01400044 	movi	r5,1
81116edc:	01204574 	movhi	r4,33045
81116ee0:	2124fb04 	addi	r4,r4,-27668
81116ee4:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ee8:	0001883a 	nop
81116eec:	e037883a 	mov	sp,fp
81116ef0:	dfc00117 	ldw	ra,4(sp)
81116ef4:	df000017 	ldw	fp,0(sp)
81116ef8:	dec00204 	addi	sp,sp,8
81116efc:	f800283a 	ret

81116f00 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81116f00:	defffe04 	addi	sp,sp,-8
81116f04:	de00012e 	bgeu	sp,et,81116f0c <vFailGetMutexSenderTask+0xc>
81116f08:	003b68fa 	trap	3
81116f0c:	dfc00115 	stw	ra,4(sp)
81116f10:	df000015 	stw	fp,0(sp)
81116f14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
81116f18:	d0a05c17 	ldw	r2,-32400(gp)
81116f1c:	100f883a 	mov	r7,r2
81116f20:	01800804 	movi	r6,32
81116f24:	01400044 	movi	r5,1
81116f28:	01204574 	movhi	r4,33045
81116f2c:	21250d04 	addi	r4,r4,-27596
81116f30:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81116f34:	d0a05c17 	ldw	r2,-32400(gp)
81116f38:	100f883a 	mov	r7,r2
81116f3c:	01801084 	movi	r6,66
81116f40:	01400044 	movi	r5,1
81116f44:	01204574 	movhi	r4,33045
81116f48:	21251604 	addi	r4,r4,-27560
81116f4c:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f50:	0001883a 	nop
81116f54:	e037883a 	mov	sp,fp
81116f58:	dfc00117 	ldw	ra,4(sp)
81116f5c:	df000017 	ldw	fp,0(sp)
81116f60:	dec00204 	addi	sp,sp,8
81116f64:	f800283a 	ret

81116f68 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81116f68:	defffe04 	addi	sp,sp,-8
81116f6c:	de00012e 	bgeu	sp,et,81116f74 <vFailGetCountSemaphoreReceiverTask+0xc>
81116f70:	003b68fa 	trap	3
81116f74:	dfc00115 	stw	ra,4(sp)
81116f78:	df000015 	stw	fp,0(sp)
81116f7c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
81116f80:	d0a05c17 	ldw	r2,-32400(gp)
81116f84:	100f883a 	mov	r7,r2
81116f88:	01800ac4 	movi	r6,43
81116f8c:	01400044 	movi	r5,1
81116f90:	01204574 	movhi	r4,33045
81116f94:	21252704 	addi	r4,r4,-27492
81116f98:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
81116f9c:	d0a05c17 	ldw	r2,-32400(gp)
81116fa0:	100f883a 	mov	r7,r2
81116fa4:	01801184 	movi	r6,70
81116fa8:	01400044 	movi	r5,1
81116fac:	01204574 	movhi	r4,33045
81116fb0:	21253204 	addi	r4,r4,-27448
81116fb4:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116fb8:	0001883a 	nop
81116fbc:	e037883a 	mov	sp,fp
81116fc0:	dfc00117 	ldw	ra,4(sp)
81116fc4:	df000017 	ldw	fp,0(sp)
81116fc8:	dec00204 	addi	sp,sp,8
81116fcc:	f800283a 	ret

81116fd0 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
81116fd0:	defffe04 	addi	sp,sp,-8
81116fd4:	de00012e 	bgeu	sp,et,81116fdc <vFailGetMutexReceiverTask+0xc>
81116fd8:	003b68fa 	trap	3
81116fdc:	dfc00115 	stw	ra,4(sp)
81116fe0:	df000015 	stw	fp,0(sp)
81116fe4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
81116fe8:	d0a05c17 	ldw	r2,-32400(gp)
81116fec:	100f883a 	mov	r7,r2
81116ff0:	01800884 	movi	r6,34
81116ff4:	01400044 	movi	r5,1
81116ff8:	01204574 	movhi	r4,33045
81116ffc:	21254404 	addi	r4,r4,-27376
81117000:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81117004:	d0a05c17 	ldw	r2,-32400(gp)
81117008:	100f883a 	mov	r7,r2
8111700c:	01801104 	movi	r6,68
81117010:	01400044 	movi	r5,1
81117014:	01204574 	movhi	r4,33045
81117018:	21254d04 	addi	r4,r4,-27340
8111701c:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117020:	0001883a 	nop
81117024:	e037883a 	mov	sp,fp
81117028:	dfc00117 	ldw	ra,4(sp)
8111702c:	df000017 	ldw	fp,0(sp)
81117030:	dec00204 	addi	sp,sp,8
81117034:	f800283a 	ret

81117038 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81117038:	defffe04 	addi	sp,sp,-8
8111703c:	de00012e 	bgeu	sp,et,81117044 <vFailGetMutexTxUARTSenderTask+0xc>
81117040:	003b68fa 	trap	3
81117044:	dfc00115 	stw	ra,4(sp)
81117048:	df000015 	stw	fp,0(sp)
8111704c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81117050:	d0a05c17 	ldw	r2,-32400(gp)
81117054:	100f883a 	mov	r7,r2
81117058:	01800984 	movi	r6,38
8111705c:	01400044 	movi	r5,1
81117060:	01204574 	movhi	r4,33045
81117064:	21255f04 	addi	r4,r4,-27268
81117068:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111706c:	d0a05c17 	ldw	r2,-32400(gp)
81117070:	100f883a 	mov	r7,r2
81117074:	01801044 	movi	r6,65
81117078:	01400044 	movi	r5,1
8111707c:	01204574 	movhi	r4,33045
81117080:	21256904 	addi	r4,r4,-27228
81117084:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117088:	0001883a 	nop
8111708c:	e037883a 	mov	sp,fp
81117090:	dfc00117 	ldw	ra,4(sp)
81117094:	df000017 	ldw	fp,0(sp)
81117098:	dec00204 	addi	sp,sp,8
8111709c:	f800283a 	ret

811170a0 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
811170a0:	defffe04 	addi	sp,sp,-8
811170a4:	de00012e 	bgeu	sp,et,811170ac <vFailGetMacRTC+0xc>
811170a8:	003b68fa 	trap	3
811170ac:	dfc00115 	stw	ra,4(sp)
811170b0:	df000015 	stw	fp,0(sp)
811170b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
811170b8:	d0a05c17 	ldw	r2,-32400(gp)
811170bc:	100f883a 	mov	r7,r2
811170c0:	018003c4 	movi	r6,15
811170c4:	01400044 	movi	r5,1
811170c8:	01204574 	movhi	r4,33045
811170cc:	21257a04 	addi	r4,r4,-27160
811170d0:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811170d4:	0001883a 	nop
811170d8:	e037883a 	mov	sp,fp
811170dc:	dfc00117 	ldw	ra,4(sp)
811170e0:	df000017 	ldw	fp,0(sp)
811170e4:	dec00204 	addi	sp,sp,8
811170e8:	f800283a 	ret

811170ec <vFailInitialization>:


void vFailInitialization( void )
{
811170ec:	defffe04 	addi	sp,sp,-8
811170f0:	de00012e 	bgeu	sp,et,811170f8 <vFailInitialization+0xc>
811170f4:	003b68fa 	trap	3
811170f8:	dfc00115 	stw	ra,4(sp)
811170fc:	df000015 	stw	fp,0(sp)
81117100:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81117104:	d0a05c17 	ldw	r2,-32400(gp)
81117108:	100f883a 	mov	r7,r2
8111710c:	01800504 	movi	r6,20
81117110:	01400044 	movi	r5,1
81117114:	01204574 	movhi	r4,33045
81117118:	21257e04 	addi	r4,r4,-27144
8111711c:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117120:	0001883a 	nop
81117124:	e037883a 	mov	sp,fp
81117128:	dfc00117 	ldw	ra,4(sp)
8111712c:	df000017 	ldw	fp,0(sp)
81117130:	dec00204 	addi	sp,sp,8
81117134:	f800283a 	ret

81117138 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81117138:	defffe04 	addi	sp,sp,-8
8111713c:	de00012e 	bgeu	sp,et,81117144 <vFailReceiverCreate+0xc>
81117140:	003b68fa 	trap	3
81117144:	dfc00115 	stw	ra,4(sp)
81117148:	df000015 	stw	fp,0(sp)
8111714c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81117150:	d0a05c17 	ldw	r2,-32400(gp)
81117154:	100f883a 	mov	r7,r2
81117158:	01800484 	movi	r6,18
8111715c:	01400044 	movi	r5,1
81117160:	01204574 	movhi	r4,33045
81117164:	21258404 	addi	r4,r4,-27120
81117168:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111716c:	0001883a 	nop
81117170:	e037883a 	mov	sp,fp
81117174:	dfc00117 	ldw	ra,4(sp)
81117178:	df000017 	ldw	fp,0(sp)
8111717c:	dec00204 	addi	sp,sp,8
81117180:	f800283a 	ret

81117184 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
81117184:	defffe04 	addi	sp,sp,-8
81117188:	de00012e 	bgeu	sp,et,81117190 <vFailSenderCreate+0xc>
8111718c:	003b68fa 	trap	3
81117190:	dfc00115 	stw	ra,4(sp)
81117194:	df000015 	stw	fp,0(sp)
81117198:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
8111719c:	d0a05c17 	ldw	r2,-32400(gp)
811171a0:	100f883a 	mov	r7,r2
811171a4:	01800484 	movi	r6,18
811171a8:	01400044 	movi	r5,1
811171ac:	01204574 	movhi	r4,33045
811171b0:	21258904 	addi	r4,r4,-27100
811171b4:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811171b8:	0001883a 	nop
811171bc:	e037883a 	mov	sp,fp
811171c0:	dfc00117 	ldw	ra,4(sp)
811171c4:	df000017 	ldw	fp,0(sp)
811171c8:	dec00204 	addi	sp,sp,8
811171cc:	f800283a 	ret

811171d0 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
811171d0:	defffe04 	addi	sp,sp,-8
811171d4:	de00012e 	bgeu	sp,et,811171dc <vFailDeleteInitialization+0xc>
811171d8:	003b68fa 	trap	3
811171dc:	dfc00115 	stw	ra,4(sp)
811171e0:	df000015 	stw	fp,0(sp)
811171e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
811171e8:	d0a05c17 	ldw	r2,-32400(gp)
811171ec:	100f883a 	mov	r7,r2
811171f0:	01800684 	movi	r6,26
811171f4:	01400044 	movi	r5,1
811171f8:	01204574 	movhi	r4,33045
811171fc:	21258e04 	addi	r4,r4,-27080
81117200:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117204:	0001883a 	nop
81117208:	e037883a 	mov	sp,fp
8111720c:	dfc00117 	ldw	ra,4(sp)
81117210:	df000017 	ldw	fp,0(sp)
81117214:	dec00204 	addi	sp,sp,8
81117218:	f800283a 	ret

8111721c <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111721c:	defffe04 	addi	sp,sp,-8
81117220:	de00012e 	bgeu	sp,et,81117228 <vFailSetCountSemaphorexBuffer32+0xc>
81117224:	003b68fa 	trap	3
81117228:	dfc00115 	stw	ra,4(sp)
8111722c:	df000015 	stw	fp,0(sp)
81117230:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81117234:	d0a05c17 	ldw	r2,-32400(gp)
81117238:	100f883a 	mov	r7,r2
8111723c:	01800a04 	movi	r6,40
81117240:	01400044 	movi	r5,1
81117244:	01204574 	movhi	r4,33045
81117248:	21259504 	addi	r4,r4,-27052
8111724c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81117250:	d0a05c17 	ldw	r2,-32400(gp)
81117254:	100f883a 	mov	r7,r2
81117258:	018008c4 	movi	r6,35
8111725c:	01400044 	movi	r5,1
81117260:	01204574 	movhi	r4,33045
81117264:	2125a004 	addi	r4,r4,-27008
81117268:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111726c:	0001883a 	nop
81117270:	e037883a 	mov	sp,fp
81117274:	dfc00117 	ldw	ra,4(sp)
81117278:	df000017 	ldw	fp,0(sp)
8111727c:	dec00204 	addi	sp,sp,8
81117280:	f800283a 	ret

81117284 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
81117284:	defffe04 	addi	sp,sp,-8
81117288:	de00012e 	bgeu	sp,et,81117290 <vFailSetCountSemaphorexBuffer64+0xc>
8111728c:	003b68fa 	trap	3
81117290:	dfc00115 	stw	ra,4(sp)
81117294:	df000015 	stw	fp,0(sp)
81117298:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111729c:	d0a05c17 	ldw	r2,-32400(gp)
811172a0:	100f883a 	mov	r7,r2
811172a4:	01800a04 	movi	r6,40
811172a8:	01400044 	movi	r5,1
811172ac:	01204574 	movhi	r4,33045
811172b0:	2125a904 	addi	r4,r4,-26972
811172b4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
811172b8:	d0a05c17 	ldw	r2,-32400(gp)
811172bc:	100f883a 	mov	r7,r2
811172c0:	018008c4 	movi	r6,35
811172c4:	01400044 	movi	r5,1
811172c8:	01204574 	movhi	r4,33045
811172cc:	2125a004 	addi	r4,r4,-27008
811172d0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172d4:	0001883a 	nop
811172d8:	e037883a 	mov	sp,fp
811172dc:	dfc00117 	ldw	ra,4(sp)
811172e0:	df000017 	ldw	fp,0(sp)
811172e4:	dec00204 	addi	sp,sp,8
811172e8:	f800283a 	ret

811172ec <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
811172ec:	defffe04 	addi	sp,sp,-8
811172f0:	de00012e 	bgeu	sp,et,811172f8 <vFailSetCountSemaphorexBuffer128+0xc>
811172f4:	003b68fa 	trap	3
811172f8:	dfc00115 	stw	ra,4(sp)
811172fc:	df000015 	stw	fp,0(sp)
81117300:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81117304:	d0a05c17 	ldw	r2,-32400(gp)
81117308:	100f883a 	mov	r7,r2
8111730c:	01800a44 	movi	r6,41
81117310:	01400044 	movi	r5,1
81117314:	01204574 	movhi	r4,33045
81117318:	2125b404 	addi	r4,r4,-26928
8111731c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81117320:	d0a05c17 	ldw	r2,-32400(gp)
81117324:	100f883a 	mov	r7,r2
81117328:	018008c4 	movi	r6,35
8111732c:	01400044 	movi	r5,1
81117330:	01204574 	movhi	r4,33045
81117334:	2125a004 	addi	r4,r4,-27008
81117338:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111733c:	0001883a 	nop
81117340:	e037883a 	mov	sp,fp
81117344:	dfc00117 	ldw	ra,4(sp)
81117348:	df000017 	ldw	fp,0(sp)
8111734c:	dec00204 	addi	sp,sp,8
81117350:	f800283a 	ret

81117354 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
81117354:	defffe04 	addi	sp,sp,-8
81117358:	de00012e 	bgeu	sp,et,81117360 <vFailGetCountSemaphorexBuffer128+0xc>
8111735c:	003b68fa 	trap	3
81117360:	dfc00115 	stw	ra,4(sp)
81117364:	df000015 	stw	fp,0(sp)
81117368:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111736c:	d0a05c17 	ldw	r2,-32400(gp)
81117370:	100f883a 	mov	r7,r2
81117374:	01800a44 	movi	r6,41
81117378:	01400044 	movi	r5,1
8111737c:	01204574 	movhi	r4,33045
81117380:	2125bf04 	addi	r4,r4,-26884
81117384:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81117388:	d0a05c17 	ldw	r2,-32400(gp)
8111738c:	100f883a 	mov	r7,r2
81117390:	01800884 	movi	r6,34
81117394:	01400044 	movi	r5,1
81117398:	01204574 	movhi	r4,33045
8111739c:	2125ca04 	addi	r4,r4,-26840
811173a0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173a4:	0001883a 	nop
811173a8:	e037883a 	mov	sp,fp
811173ac:	dfc00117 	ldw	ra,4(sp)
811173b0:	df000017 	ldw	fp,0(sp)
811173b4:	dec00204 	addi	sp,sp,8
811173b8:	f800283a 	ret

811173bc <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
811173bc:	defffe04 	addi	sp,sp,-8
811173c0:	de00012e 	bgeu	sp,et,811173c8 <vFailGetCountSemaphorexBuffer64+0xc>
811173c4:	003b68fa 	trap	3
811173c8:	dfc00115 	stw	ra,4(sp)
811173cc:	df000015 	stw	fp,0(sp)
811173d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
811173d4:	d0a05c17 	ldw	r2,-32400(gp)
811173d8:	100f883a 	mov	r7,r2
811173dc:	01800a04 	movi	r6,40
811173e0:	01400044 	movi	r5,1
811173e4:	01204574 	movhi	r4,33045
811173e8:	2125d304 	addi	r4,r4,-26804
811173ec:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
811173f0:	d0a05c17 	ldw	r2,-32400(gp)
811173f4:	100f883a 	mov	r7,r2
811173f8:	01800884 	movi	r6,34
811173fc:	01400044 	movi	r5,1
81117400:	01204574 	movhi	r4,33045
81117404:	2125ca04 	addi	r4,r4,-26840
81117408:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111740c:	0001883a 	nop
81117410:	e037883a 	mov	sp,fp
81117414:	dfc00117 	ldw	ra,4(sp)
81117418:	df000017 	ldw	fp,0(sp)
8111741c:	dec00204 	addi	sp,sp,8
81117420:	f800283a 	ret

81117424 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81117424:	defffe04 	addi	sp,sp,-8
81117428:	de00012e 	bgeu	sp,et,81117430 <vFailGetCountSemaphorexBuffer32+0xc>
8111742c:	003b68fa 	trap	3
81117430:	dfc00115 	stw	ra,4(sp)
81117434:	df000015 	stw	fp,0(sp)
81117438:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111743c:	d0a05c17 	ldw	r2,-32400(gp)
81117440:	100f883a 	mov	r7,r2
81117444:	01800a04 	movi	r6,40
81117448:	01400044 	movi	r5,1
8111744c:	01204574 	movhi	r4,33045
81117450:	2125de04 	addi	r4,r4,-26760
81117454:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81117458:	d0a05c17 	ldw	r2,-32400(gp)
8111745c:	100f883a 	mov	r7,r2
81117460:	01800884 	movi	r6,34
81117464:	01400044 	movi	r5,1
81117468:	01204574 	movhi	r4,33045
8111746c:	2125ca04 	addi	r4,r4,-26840
81117470:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117474:	0001883a 	nop
81117478:	e037883a 	mov	sp,fp
8111747c:	dfc00117 	ldw	ra,4(sp)
81117480:	df000017 	ldw	fp,0(sp)
81117484:	dec00204 	addi	sp,sp,8
81117488:	f800283a 	ret

8111748c <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111748c:	defffe04 	addi	sp,sp,-8
81117490:	de00012e 	bgeu	sp,et,81117498 <vFailFoundBufferRetransmission+0xc>
81117494:	003b68fa 	trap	3
81117498:	dfc00115 	stw	ra,4(sp)
8111749c:	df000015 	stw	fp,0(sp)
811174a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
811174a4:	d0a05c17 	ldw	r2,-32400(gp)
811174a8:	100f883a 	mov	r7,r2
811174ac:	01800a84 	movi	r6,42
811174b0:	01400044 	movi	r5,1
811174b4:	01204574 	movhi	r4,33045
811174b8:	2125e904 	addi	r4,r4,-26716
811174bc:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
811174c0:	d0a05c17 	ldw	r2,-32400(gp)
811174c4:	100f883a 	mov	r7,r2
811174c8:	01801204 	movi	r6,72
811174cc:	01400044 	movi	r5,1
811174d0:	01204574 	movhi	r4,33045
811174d4:	2125f404 	addi	r4,r4,-26672
811174d8:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811174dc:	0001883a 	nop
811174e0:	e037883a 	mov	sp,fp
811174e4:	dfc00117 	ldw	ra,4(sp)
811174e8:	df000017 	ldw	fp,0(sp)
811174ec:	dec00204 	addi	sp,sp,8
811174f0:	f800283a 	ret

811174f4 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
811174f4:	defffe04 	addi	sp,sp,-8
811174f8:	de00012e 	bgeu	sp,et,81117500 <vFailGetCountSemaphorePreParsedBuffer+0xc>
811174fc:	003b68fa 	trap	3
81117500:	dfc00115 	stw	ra,4(sp)
81117504:	df000015 	stw	fp,0(sp)
81117508:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111750c:	d0a05c17 	ldw	r2,-32400(gp)
81117510:	100f883a 	mov	r7,r2
81117514:	01800b84 	movi	r6,46
81117518:	01400044 	movi	r5,1
8111751c:	01204574 	movhi	r4,33045
81117520:	21260704 	addi	r4,r4,-26596
81117524:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
81117528:	d0a05c17 	ldw	r2,-32400(gp)
8111752c:	100f883a 	mov	r7,r2
81117530:	018010c4 	movi	r6,67
81117534:	01400044 	movi	r5,1
81117538:	01204574 	movhi	r4,33045
8111753c:	21261304 	addi	r4,r4,-26548
81117540:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117544:	0001883a 	nop
81117548:	e037883a 	mov	sp,fp
8111754c:	dfc00117 	ldw	ra,4(sp)
81117550:	df000017 	ldw	fp,0(sp)
81117554:	dec00204 	addi	sp,sp,8
81117558:	f800283a 	ret

8111755c <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111755c:	defffe04 	addi	sp,sp,-8
81117560:	de00012e 	bgeu	sp,et,81117568 <vFailGetxMutexPreParsedParserRxTask+0xc>
81117564:	003b68fa 	trap	3
81117568:	dfc00115 	stw	ra,4(sp)
8111756c:	df000015 	stw	fp,0(sp)
81117570:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
81117574:	d0a05c17 	ldw	r2,-32400(gp)
81117578:	100f883a 	mov	r7,r2
8111757c:	01800b04 	movi	r6,44
81117580:	01400044 	movi	r5,1
81117584:	01204574 	movhi	r4,33045
81117588:	21262404 	addi	r4,r4,-26480
8111758c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
81117590:	d0a05c17 	ldw	r2,-32400(gp)
81117594:	100f883a 	mov	r7,r2
81117598:	01800fc4 	movi	r6,63
8111759c:	01400044 	movi	r5,1
811175a0:	01204574 	movhi	r4,33045
811175a4:	21263004 	addi	r4,r4,-26432
811175a8:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811175ac:	0001883a 	nop
811175b0:	e037883a 	mov	sp,fp
811175b4:	dfc00117 	ldw	ra,4(sp)
811175b8:	df000017 	ldw	fp,0(sp)
811175bc:	dec00204 	addi	sp,sp,8
811175c0:	f800283a 	ret

811175c4 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
811175c4:	defffe04 	addi	sp,sp,-8
811175c8:	de00012e 	bgeu	sp,et,811175d0 <vNoContentInPreParsedBuffer+0xc>
811175cc:	003b68fa 	trap	3
811175d0:	dfc00115 	stw	ra,4(sp)
811175d4:	df000015 	stw	fp,0(sp)
811175d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
811175dc:	d0a05c17 	ldw	r2,-32400(gp)
811175e0:	100f883a 	mov	r7,r2
811175e4:	01800904 	movi	r6,36
811175e8:	01400044 	movi	r5,1
811175ec:	01204574 	movhi	r4,33045
811175f0:	21264004 	addi	r4,r4,-26368
811175f4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
811175f8:	d0a05c17 	ldw	r2,-32400(gp)
811175fc:	100f883a 	mov	r7,r2
81117600:	01801684 	movi	r6,90
81117604:	01400044 	movi	r5,1
81117608:	01204574 	movhi	r4,33045
8111760c:	21264a04 	addi	r4,r4,-26328
81117610:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117614:	0001883a 	nop
81117618:	e037883a 	mov	sp,fp
8111761c:	dfc00117 	ldw	ra,4(sp)
81117620:	df000017 	ldw	fp,0(sp)
81117624:	dec00204 	addi	sp,sp,8
81117628:	f800283a 	ret

8111762c <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111762c:	defffe04 	addi	sp,sp,-8
81117630:	de00012e 	bgeu	sp,et,81117638 <vCouldNotSendEthConfUART+0xc>
81117634:	003b68fa 	trap	3
81117638:	dfc00115 	stw	ra,4(sp)
8111763c:	df000015 	stw	fp,0(sp)
81117640:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
81117644:	d0a05c17 	ldw	r2,-32400(gp)
81117648:	100f883a 	mov	r7,r2
8111764c:	01800844 	movi	r6,33
81117650:	01400044 	movi	r5,1
81117654:	01204574 	movhi	r4,33045
81117658:	21266104 	addi	r4,r4,-26236
8111765c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
81117660:	d0a05c17 	ldw	r2,-32400(gp)
81117664:	100f883a 	mov	r7,r2
81117668:	01801784 	movi	r6,94
8111766c:	01400044 	movi	r5,1
81117670:	01204574 	movhi	r4,33045
81117674:	21266a04 	addi	r4,r4,-26200
81117678:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111767c:	0001883a 	nop
81117680:	e037883a 	mov	sp,fp
81117684:	dfc00117 	ldw	ra,4(sp)
81117688:	df000017 	ldw	fp,0(sp)
8111768c:	dec00204 	addi	sp,sp,8
81117690:	f800283a 	ret

81117694 <vFailSendNack>:

void vFailSendNack( void )
{
81117694:	defffe04 	addi	sp,sp,-8
81117698:	de00012e 	bgeu	sp,et,811176a0 <vFailSendNack+0xc>
8111769c:	003b68fa 	trap	3
811176a0:	dfc00115 	stw	ra,4(sp)
811176a4:	df000015 	stw	fp,0(sp)
811176a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
811176ac:	d0a05c17 	ldw	r2,-32400(gp)
811176b0:	100f883a 	mov	r7,r2
811176b4:	01800584 	movi	r6,22
811176b8:	01400044 	movi	r5,1
811176bc:	01204574 	movhi	r4,33045
811176c0:	21268204 	addi	r4,r4,-26104
811176c4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
811176c8:	d0a05c17 	ldw	r2,-32400(gp)
811176cc:	100f883a 	mov	r7,r2
811176d0:	01800a84 	movi	r6,42
811176d4:	01400044 	movi	r5,1
811176d8:	01204574 	movhi	r4,33045
811176dc:	21268804 	addi	r4,r4,-26080
811176e0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811176e4:	0001883a 	nop
811176e8:	e037883a 	mov	sp,fp
811176ec:	dfc00117 	ldw	ra,4(sp)
811176f0:	df000017 	ldw	fp,0(sp)
811176f4:	dec00204 	addi	sp,sp,8
811176f8:	f800283a 	ret

811176fc <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
811176fc:	defffe04 	addi	sp,sp,-8
81117700:	de00012e 	bgeu	sp,et,81117708 <vFailSetPreAckSenderBuffer+0xc>
81117704:	003b68fa 	trap	3
81117708:	dfc00115 	stw	ra,4(sp)
8111770c:	df000015 	stw	fp,0(sp)
81117710:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
81117714:	d0a05c17 	ldw	r2,-32400(gp)
81117718:	100f883a 	mov	r7,r2
8111771c:	018008c4 	movi	r6,35
81117720:	01400044 	movi	r5,1
81117724:	01204574 	movhi	r4,33045
81117728:	21269304 	addi	r4,r4,-26036
8111772c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
81117730:	d0a05c17 	ldw	r2,-32400(gp)
81117734:	100f883a 	mov	r7,r2
81117738:	01801584 	movi	r6,86
8111773c:	01400044 	movi	r5,1
81117740:	01204574 	movhi	r4,33045
81117744:	21269c04 	addi	r4,r4,-26000
81117748:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111774c:	0001883a 	nop
81117750:	e037883a 	mov	sp,fp
81117754:	dfc00117 	ldw	ra,4(sp)
81117758:	df000017 	ldw	fp,0(sp)
8111775c:	dec00204 	addi	sp,sp,8
81117760:	f800283a 	ret

81117764 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81117764:	defffe04 	addi	sp,sp,-8
81117768:	de00012e 	bgeu	sp,et,81117770 <vFailSetPreParsedBuffer+0xc>
8111776c:	003b68fa 	trap	3
81117770:	dfc00115 	stw	ra,4(sp)
81117774:	df000015 	stw	fp,0(sp)
81117778:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111777c:	d0a05c17 	ldw	r2,-32400(gp)
81117780:	100f883a 	mov	r7,r2
81117784:	01800804 	movi	r6,32
81117788:	01400044 	movi	r5,1
8111778c:	01204574 	movhi	r4,33045
81117790:	2126b204 	addi	r4,r4,-25912
81117794:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81117798:	d0a05c17 	ldw	r2,-32400(gp)
8111779c:	100f883a 	mov	r7,r2
811177a0:	018013c4 	movi	r6,79
811177a4:	01400044 	movi	r5,1
811177a8:	01204574 	movhi	r4,33045
811177ac:	2126bb04 	addi	r4,r4,-25876
811177b0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811177b4:	0001883a 	nop
811177b8:	e037883a 	mov	sp,fp
811177bc:	dfc00117 	ldw	ra,4(sp)
811177c0:	df000017 	ldw	fp,0(sp)
811177c4:	dec00204 	addi	sp,sp,8
811177c8:	f800283a 	ret

811177cc <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
811177cc:	defffe04 	addi	sp,sp,-8
811177d0:	de00012e 	bgeu	sp,et,811177d8 <vFailSetPreAckReceiverBuffer+0xc>
811177d4:	003b68fa 	trap	3
811177d8:	dfc00115 	stw	ra,4(sp)
811177dc:	df000015 	stw	fp,0(sp)
811177e0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
811177e4:	d0a05c17 	ldw	r2,-32400(gp)
811177e8:	100f883a 	mov	r7,r2
811177ec:	01800944 	movi	r6,37
811177f0:	01400044 	movi	r5,1
811177f4:	01204574 	movhi	r4,33045
811177f8:	2126cf04 	addi	r4,r4,-25796
811177fc:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
81117800:	d0a05c17 	ldw	r2,-32400(gp)
81117804:	100f883a 	mov	r7,r2
81117808:	018015c4 	movi	r6,87
8111780c:	01400044 	movi	r5,1
81117810:	01204574 	movhi	r4,33045
81117814:	2126d904 	addi	r4,r4,-25756
81117818:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111781c:	0001883a 	nop
81117820:	e037883a 	mov	sp,fp
81117824:	dfc00117 	ldw	ra,4(sp)
81117828:	df000017 	ldw	fp,0(sp)
8111782c:	dec00204 	addi	sp,sp,8
81117830:	f800283a 	ret

81117834 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81117834:	defffe04 	addi	sp,sp,-8
81117838:	de00012e 	bgeu	sp,et,81117840 <vFailParserCommTaskCreate+0xc>
8111783c:	003b68fa 	trap	3
81117840:	dfc00115 	stw	ra,4(sp)
81117844:	df000015 	stw	fp,0(sp)
81117848:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8111784c:	d0a05c17 	ldw	r2,-32400(gp)
81117850:	100f883a 	mov	r7,r2
81117854:	01800684 	movi	r6,26
81117858:	01400044 	movi	r5,1
8111785c:	01204574 	movhi	r4,33045
81117860:	2126ef04 	addi	r4,r4,-25668
81117864:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117868:	0001883a 	nop
8111786c:	e037883a 	mov	sp,fp
81117870:	dfc00117 	ldw	ra,4(sp)
81117874:	df000017 	ldw	fp,0(sp)
81117878:	dec00204 	addi	sp,sp,8
8111787c:	f800283a 	ret

81117880 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
81117880:	defffe04 	addi	sp,sp,-8
81117884:	de00012e 	bgeu	sp,et,8111788c <vFailInAckHandlerTaskCreate+0xc>
81117888:	003b68fa 	trap	3
8111788c:	dfc00115 	stw	ra,4(sp)
81117890:	df000015 	stw	fp,0(sp)
81117894:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81117898:	d0a05c17 	ldw	r2,-32400(gp)
8111789c:	100f883a 	mov	r7,r2
811178a0:	01800704 	movi	r6,28
811178a4:	01400044 	movi	r5,1
811178a8:	01204574 	movhi	r4,33045
811178ac:	2126f604 	addi	r4,r4,-25640
811178b0:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811178b4:	0001883a 	nop
811178b8:	e037883a 	mov	sp,fp
811178bc:	dfc00117 	ldw	ra,4(sp)
811178c0:	df000017 	ldw	fp,0(sp)
811178c4:	dec00204 	addi	sp,sp,8
811178c8:	f800283a 	ret

811178cc <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
811178cc:	defffe04 	addi	sp,sp,-8
811178d0:	de00012e 	bgeu	sp,et,811178d8 <vFailOutAckHandlerTaskCreate+0xc>
811178d4:	003b68fa 	trap	3
811178d8:	dfc00115 	stw	ra,4(sp)
811178dc:	df000015 	stw	fp,0(sp)
811178e0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
811178e4:	d0a05c17 	ldw	r2,-32400(gp)
811178e8:	100f883a 	mov	r7,r2
811178ec:	01800704 	movi	r6,28
811178f0:	01400044 	movi	r5,1
811178f4:	01204574 	movhi	r4,33045
811178f8:	2126f604 	addi	r4,r4,-25640
811178fc:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117900:	0001883a 	nop
81117904:	e037883a 	mov	sp,fp
81117908:	dfc00117 	ldw	ra,4(sp)
8111790c:	df000017 	ldw	fp,0(sp)
81117910:	dec00204 	addi	sp,sp,8
81117914:	f800283a 	ret

81117918 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
81117918:	defffe04 	addi	sp,sp,-8
8111791c:	de00012e 	bgeu	sp,et,81117924 <vFailCreateTimerRetransmisison+0xc>
81117920:	003b68fa 	trap	3
81117924:	dfc00115 	stw	ra,4(sp)
81117928:	df000015 	stw	fp,0(sp)
8111792c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
81117930:	d0a05c17 	ldw	r2,-32400(gp)
81117934:	100f883a 	mov	r7,r2
81117938:	018007c4 	movi	r6,31
8111793c:	01400044 	movi	r5,1
81117940:	01204574 	movhi	r4,33045
81117944:	2126fe04 	addi	r4,r4,-25608
81117948:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111794c:	0001883a 	nop
81117950:	e037883a 	mov	sp,fp
81117954:	dfc00117 	ldw	ra,4(sp)
81117958:	df000017 	ldw	fp,0(sp)
8111795c:	dec00204 	addi	sp,sp,8
81117960:	f800283a 	ret

81117964 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81117964:	defffe04 	addi	sp,sp,-8
81117968:	de00012e 	bgeu	sp,et,81117970 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111796c:	003b68fa 	trap	3
81117970:	dfc00115 	stw	ra,4(sp)
81117974:	df000015 	stw	fp,0(sp)
81117978:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111797c:	d0a05c17 	ldw	r2,-32400(gp)
81117980:	100f883a 	mov	r7,r2
81117984:	01800904 	movi	r6,36
81117988:	01400044 	movi	r5,1
8111798c:	01204574 	movhi	r4,33045
81117990:	21270604 	addi	r4,r4,-25576
81117994:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117998:	0001883a 	nop
8111799c:	e037883a 	mov	sp,fp
811179a0:	dfc00117 	ldw	ra,4(sp)
811179a4:	df000017 	ldw	fp,0(sp)
811179a8:	dec00204 	addi	sp,sp,8
811179ac:	f800283a 	ret

811179b0 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
811179b0:	defffe04 	addi	sp,sp,-8
811179b4:	de00012e 	bgeu	sp,et,811179bc <vFailTimeoutCheckerTaskCreate+0xc>
811179b8:	003b68fa 	trap	3
811179bc:	dfc00115 	stw	ra,4(sp)
811179c0:	df000015 	stw	fp,0(sp)
811179c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
811179c8:	d0a05c17 	ldw	r2,-32400(gp)
811179cc:	100f883a 	mov	r7,r2
811179d0:	01800a04 	movi	r6,40
811179d4:	01400044 	movi	r5,1
811179d8:	01204574 	movhi	r4,33045
811179dc:	21271004 	addi	r4,r4,-25536
811179e0:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811179e4:	0001883a 	nop
811179e8:	e037883a 	mov	sp,fp
811179ec:	dfc00117 	ldw	ra,4(sp)
811179f0:	df000017 	ldw	fp,0(sp)
811179f4:	dec00204 	addi	sp,sp,8
811179f8:	f800283a 	ret

811179fc <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
811179fc:	defffe04 	addi	sp,sp,-8
81117a00:	de00012e 	bgeu	sp,et,81117a08 <vFailGetBlockingSemTimeoutTask+0xc>
81117a04:	003b68fa 	trap	3
81117a08:	dfc00115 	stw	ra,4(sp)
81117a0c:	df000015 	stw	fp,0(sp)
81117a10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81117a14:	d0a05c17 	ldw	r2,-32400(gp)
81117a18:	100f883a 	mov	r7,r2
81117a1c:	018009c4 	movi	r6,39
81117a20:	01400044 	movi	r5,1
81117a24:	01204574 	movhi	r4,33045
81117a28:	21271b04 	addi	r4,r4,-25492
81117a2c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
81117a30:	d0a05c17 	ldw	r2,-32400(gp)
81117a34:	100f883a 	mov	r7,r2
81117a38:	01800cc4 	movi	r6,51
81117a3c:	01400044 	movi	r5,1
81117a40:	01204574 	movhi	r4,33045
81117a44:	21272504 	addi	r4,r4,-25452
81117a48:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117a4c:	0001883a 	nop
81117a50:	e037883a 	mov	sp,fp
81117a54:	dfc00117 	ldw	ra,4(sp)
81117a58:	df000017 	ldw	fp,0(sp)
81117a5c:	dec00204 	addi	sp,sp,8
81117a60:	f800283a 	ret

81117a64 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81117a64:	defffe04 	addi	sp,sp,-8
81117a68:	de00012e 	bgeu	sp,et,81117a70 <vFailPostBlockingSemTimeoutTask+0xc>
81117a6c:	003b68fa 	trap	3
81117a70:	dfc00115 	stw	ra,4(sp)
81117a74:	df000015 	stw	fp,0(sp)
81117a78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
81117a7c:	d0a05c17 	ldw	r2,-32400(gp)
81117a80:	100f883a 	mov	r7,r2
81117a84:	01800a04 	movi	r6,40
81117a88:	01400044 	movi	r5,1
81117a8c:	01204574 	movhi	r4,33045
81117a90:	21273204 	addi	r4,r4,-25400
81117a94:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
81117a98:	d0a05c17 	ldw	r2,-32400(gp)
81117a9c:	100f883a 	mov	r7,r2
81117aa0:	01800c84 	movi	r6,50
81117aa4:	01400044 	movi	r5,1
81117aa8:	01204574 	movhi	r4,33045
81117aac:	21273d04 	addi	r4,r4,-25356
81117ab0:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ab4:	0001883a 	nop
81117ab8:	e037883a 	mov	sp,fp
81117abc:	dfc00117 	ldw	ra,4(sp)
81117ac0:	df000017 	ldw	fp,0(sp)
81117ac4:	dec00204 	addi	sp,sp,8
81117ac8:	f800283a 	ret

81117acc <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
81117acc:	defffe04 	addi	sp,sp,-8
81117ad0:	de00012e 	bgeu	sp,et,81117ad8 <vFailCouldNotRetransmitTimeoutTask+0xc>
81117ad4:	003b68fa 	trap	3
81117ad8:	dfc00115 	stw	ra,4(sp)
81117adc:	df000015 	stw	fp,0(sp)
81117ae0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
81117ae4:	d0a05c17 	ldw	r2,-32400(gp)
81117ae8:	100f883a 	mov	r7,r2
81117aec:	01800ac4 	movi	r6,43
81117af0:	01400044 	movi	r5,1
81117af4:	01204574 	movhi	r4,33045
81117af8:	21274a04 	addi	r4,r4,-25304
81117afc:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
81117b00:	d0a05c17 	ldw	r2,-32400(gp)
81117b04:	100f883a 	mov	r7,r2
81117b08:	01801644 	movi	r6,89
81117b0c:	01400044 	movi	r5,1
81117b10:	01204574 	movhi	r4,33045
81117b14:	21275504 	addi	r4,r4,-25260
81117b18:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b1c:	0001883a 	nop
81117b20:	e037883a 	mov	sp,fp
81117b24:	dfc00117 	ldw	ra,4(sp)
81117b28:	df000017 	ldw	fp,0(sp)
81117b2c:	dec00204 	addi	sp,sp,8
81117b30:	f800283a 	ret

81117b34 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81117b34:	defffe04 	addi	sp,sp,-8
81117b38:	de00012e 	bgeu	sp,et,81117b40 <vCouldNotRetransmitB32TimeoutTask+0xc>
81117b3c:	003b68fa 	trap	3
81117b40:	dfc00115 	stw	ra,4(sp)
81117b44:	df000015 	stw	fp,0(sp)
81117b48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
81117b4c:	d0a05c17 	ldw	r2,-32400(gp)
81117b50:	100f883a 	mov	r7,r2
81117b54:	01800a84 	movi	r6,42
81117b58:	01400044 	movi	r5,1
81117b5c:	01204574 	movhi	r4,33045
81117b60:	21276c04 	addi	r4,r4,-25168
81117b64:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
81117b68:	d0a05c17 	ldw	r2,-32400(gp)
81117b6c:	100f883a 	mov	r7,r2
81117b70:	01801444 	movi	r6,81
81117b74:	01400044 	movi	r5,1
81117b78:	01204574 	movhi	r4,33045
81117b7c:	21277704 	addi	r4,r4,-25124
81117b80:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b84:	0001883a 	nop
81117b88:	e037883a 	mov	sp,fp
81117b8c:	dfc00117 	ldw	ra,4(sp)
81117b90:	df000017 	ldw	fp,0(sp)
81117b94:	dec00204 	addi	sp,sp,8
81117b98:	f800283a 	ret

81117b9c <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81117b9c:	defffe04 	addi	sp,sp,-8
81117ba0:	de00012e 	bgeu	sp,et,81117ba8 <vCouldNotRetransmitB64TimeoutTask+0xc>
81117ba4:	003b68fa 	trap	3
81117ba8:	dfc00115 	stw	ra,4(sp)
81117bac:	df000015 	stw	fp,0(sp)
81117bb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
81117bb4:	d0a05c17 	ldw	r2,-32400(gp)
81117bb8:	100f883a 	mov	r7,r2
81117bbc:	01800a84 	movi	r6,42
81117bc0:	01400044 	movi	r5,1
81117bc4:	01204574 	movhi	r4,33045
81117bc8:	21278c04 	addi	r4,r4,-25040
81117bcc:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
81117bd0:	d0a05c17 	ldw	r2,-32400(gp)
81117bd4:	100f883a 	mov	r7,r2
81117bd8:	01801444 	movi	r6,81
81117bdc:	01400044 	movi	r5,1
81117be0:	01204574 	movhi	r4,33045
81117be4:	21279704 	addi	r4,r4,-24996
81117be8:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117bec:	0001883a 	nop
81117bf0:	e037883a 	mov	sp,fp
81117bf4:	dfc00117 	ldw	ra,4(sp)
81117bf8:	df000017 	ldw	fp,0(sp)
81117bfc:	dec00204 	addi	sp,sp,8
81117c00:	f800283a 	ret

81117c04 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81117c04:	defffe04 	addi	sp,sp,-8
81117c08:	de00012e 	bgeu	sp,et,81117c10 <vCouldNotRetransmitB128TimeoutTask+0xc>
81117c0c:	003b68fa 	trap	3
81117c10:	dfc00115 	stw	ra,4(sp)
81117c14:	df000015 	stw	fp,0(sp)
81117c18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
81117c1c:	d0a05c17 	ldw	r2,-32400(gp)
81117c20:	100f883a 	mov	r7,r2
81117c24:	01800ac4 	movi	r6,43
81117c28:	01400044 	movi	r5,1
81117c2c:	01204574 	movhi	r4,33045
81117c30:	2127ac04 	addi	r4,r4,-24912
81117c34:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
81117c38:	d0a05c17 	ldw	r2,-32400(gp)
81117c3c:	100f883a 	mov	r7,r2
81117c40:	01801484 	movi	r6,82
81117c44:	01400044 	movi	r5,1
81117c48:	01204574 	movhi	r4,33045
81117c4c:	2127b704 	addi	r4,r4,-24868
81117c50:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c54:	0001883a 	nop
81117c58:	e037883a 	mov	sp,fp
81117c5c:	dfc00117 	ldw	ra,4(sp)
81117c60:	df000017 	ldw	fp,0(sp)
81117c64:	dec00204 	addi	sp,sp,8
81117c68:	f800283a 	ret

81117c6c <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81117c6c:	defffe04 	addi	sp,sp,-8
81117c70:	de00012e 	bgeu	sp,et,81117c78 <vFailStartTimerRetransmission+0xc>
81117c74:	003b68fa 	trap	3
81117c78:	dfc00115 	stw	ra,4(sp)
81117c7c:	df000015 	stw	fp,0(sp)
81117c80:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
81117c84:	d0a05c17 	ldw	r2,-32400(gp)
81117c88:	100f883a 	mov	r7,r2
81117c8c:	01800984 	movi	r6,38
81117c90:	01400044 	movi	r5,1
81117c94:	01204574 	movhi	r4,33045
81117c98:	2127cc04 	addi	r4,r4,-24784
81117c9c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
81117ca0:	d0a05c17 	ldw	r2,-32400(gp)
81117ca4:	100f883a 	mov	r7,r2
81117ca8:	01800d44 	movi	r6,53
81117cac:	01400044 	movi	r5,1
81117cb0:	01204574 	movhi	r4,33045
81117cb4:	2127d604 	addi	r4,r4,-24744
81117cb8:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117cbc:	0001883a 	nop
81117cc0:	e037883a 	mov	sp,fp
81117cc4:	dfc00117 	ldw	ra,4(sp)
81117cc8:	df000017 	ldw	fp,0(sp)
81117ccc:	dec00204 	addi	sp,sp,8
81117cd0:	f800283a 	ret

81117cd4 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
81117cd4:	defffe04 	addi	sp,sp,-8
81117cd8:	de00012e 	bgeu	sp,et,81117ce0 <vCouldNotSendTurnOff+0xc>
81117cdc:	003b68fa 	trap	3
81117ce0:	dfc00115 	stw	ra,4(sp)
81117ce4:	df000015 	stw	fp,0(sp)
81117ce8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
81117cec:	d0a05c17 	ldw	r2,-32400(gp)
81117cf0:	100f883a 	mov	r7,r2
81117cf4:	01800744 	movi	r6,29
81117cf8:	01400044 	movi	r5,1
81117cfc:	01204574 	movhi	r4,33045
81117d00:	2127e404 	addi	r4,r4,-24688
81117d04:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
81117d08:	d0a05c17 	ldw	r2,-32400(gp)
81117d0c:	100f883a 	mov	r7,r2
81117d10:	01800984 	movi	r6,38
81117d14:	01400044 	movi	r5,1
81117d18:	01204574 	movhi	r4,33045
81117d1c:	2127ec04 	addi	r4,r4,-24656
81117d20:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117d24:	0001883a 	nop
81117d28:	e037883a 	mov	sp,fp
81117d2c:	dfc00117 	ldw	ra,4(sp)
81117d30:	df000017 	ldw	fp,0(sp)
81117d34:	dec00204 	addi	sp,sp,8
81117d38:	f800283a 	ret

81117d3c <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81117d3c:	defffe04 	addi	sp,sp,-8
81117d40:	de00012e 	bgeu	sp,et,81117d48 <vCouldNotSendReset+0xc>
81117d44:	003b68fa 	trap	3
81117d48:	dfc00115 	stw	ra,4(sp)
81117d4c:	df000015 	stw	fp,0(sp)
81117d50:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81117d54:	d0a05c17 	ldw	r2,-32400(gp)
81117d58:	100f883a 	mov	r7,r2
81117d5c:	018006c4 	movi	r6,27
81117d60:	01400044 	movi	r5,1
81117d64:	01204574 	movhi	r4,33045
81117d68:	2127f604 	addi	r4,r4,-24616
81117d6c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
81117d70:	d0a05c17 	ldw	r2,-32400(gp)
81117d74:	100f883a 	mov	r7,r2
81117d78:	018008c4 	movi	r6,35
81117d7c:	01400044 	movi	r5,1
81117d80:	01204574 	movhi	r4,33045
81117d84:	2127fd04 	addi	r4,r4,-24588
81117d88:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117d8c:	0001883a 	nop
81117d90:	e037883a 	mov	sp,fp
81117d94:	dfc00117 	ldw	ra,4(sp)
81117d98:	df000017 	ldw	fp,0(sp)
81117d9c:	dec00204 	addi	sp,sp,8
81117da0:	f800283a 	ret

81117da4 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
81117da4:	defffe04 	addi	sp,sp,-8
81117da8:	de00012e 	bgeu	sp,et,81117db0 <vCouldNotSendLog+0xc>
81117dac:	003b68fa 	trap	3
81117db0:	dfc00115 	stw	ra,4(sp)
81117db4:	df000015 	stw	fp,0(sp)
81117db8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
81117dbc:	d0a05c17 	ldw	r2,-32400(gp)
81117dc0:	100f883a 	mov	r7,r2
81117dc4:	01800644 	movi	r6,25
81117dc8:	01400044 	movi	r5,1
81117dcc:	01204574 	movhi	r4,33045
81117dd0:	21280604 	addi	r4,r4,-24552
81117dd4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
81117dd8:	d0a05c17 	ldw	r2,-32400(gp)
81117ddc:	100f883a 	mov	r7,r2
81117de0:	018008c4 	movi	r6,35
81117de4:	01400044 	movi	r5,1
81117de8:	01204574 	movhi	r4,33045
81117dec:	21280d04 	addi	r4,r4,-24524
81117df0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117df4:	0001883a 	nop
81117df8:	e037883a 	mov	sp,fp
81117dfc:	dfc00117 	ldw	ra,4(sp)
81117e00:	df000017 	ldw	fp,0(sp)
81117e04:	dec00204 	addi	sp,sp,8
81117e08:	f800283a 	ret

81117e0c <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81117e0c:	defffd04 	addi	sp,sp,-12
81117e10:	de00012e 	bgeu	sp,et,81117e18 <vCouldNotSendTMPusCommand+0xc>
81117e14:	003b68fa 	trap	3
81117e18:	dfc00215 	stw	ra,8(sp)
81117e1c:	df000115 	stw	fp,4(sp)
81117e20:	df000104 	addi	fp,sp,4
81117e24:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
81117e28:	d0a05c17 	ldw	r2,-32400(gp)
81117e2c:	100f883a 	mov	r7,r2
81117e30:	01800884 	movi	r6,34
81117e34:	01400044 	movi	r5,1
81117e38:	01204574 	movhi	r4,33045
81117e3c:	21281604 	addi	r4,r4,-24488
81117e40:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81117e44:	d0a05c17 	ldw	r2,-32400(gp)
81117e48:	100f883a 	mov	r7,r2
81117e4c:	01800ac4 	movi	r6,43
81117e50:	01400044 	movi	r5,1
81117e54:	01204574 	movhi	r4,33045
81117e58:	21281f04 	addi	r4,r4,-24452
81117e5c:	111c1380 	call	8111c138 <fwrite>
		debug(fp,"cData");
81117e60:	d0a05c17 	ldw	r2,-32400(gp)
81117e64:	100f883a 	mov	r7,r2
81117e68:	01800144 	movi	r6,5
81117e6c:	01400044 	movi	r5,1
81117e70:	01204574 	movhi	r4,33045
81117e74:	21282a04 	addi	r4,r4,-24408
81117e78:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e7c:	0001883a 	nop
81117e80:	e037883a 	mov	sp,fp
81117e84:	dfc00117 	ldw	ra,4(sp)
81117e88:	df000017 	ldw	fp,0(sp)
81117e8c:	dec00204 	addi	sp,sp,8
81117e90:	f800283a 	ret

81117e94 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
81117e94:	defffe04 	addi	sp,sp,-8
81117e98:	de00012e 	bgeu	sp,et,81117ea0 <vWarnCouldNotgetMutexRetrans128+0xc>
81117e9c:	003b68fa 	trap	3
81117ea0:	dfc00115 	stw	ra,4(sp)
81117ea4:	df000015 	stw	fp,0(sp)
81117ea8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
81117eac:	d0a05c17 	ldw	r2,-32400(gp)
81117eb0:	100f883a 	mov	r7,r2
81117eb4:	01800a04 	movi	r6,40
81117eb8:	01400044 	movi	r5,1
81117ebc:	01204574 	movhi	r4,33045
81117ec0:	21282c04 	addi	r4,r4,-24400
81117ec4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
81117ec8:	d0a05c17 	ldw	r2,-32400(gp)
81117ecc:	100f883a 	mov	r7,r2
81117ed0:	018014c4 	movi	r6,83
81117ed4:	01400044 	movi	r5,1
81117ed8:	01204574 	movhi	r4,33045
81117edc:	21283704 	addi	r4,r4,-24356
81117ee0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ee4:	0001883a 	nop
81117ee8:	e037883a 	mov	sp,fp
81117eec:	dfc00117 	ldw	ra,4(sp)
81117ef0:	df000017 	ldw	fp,0(sp)
81117ef4:	dec00204 	addi	sp,sp,8
81117ef8:	f800283a 	ret

81117efc <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
81117efc:	defffe04 	addi	sp,sp,-8
81117f00:	de00012e 	bgeu	sp,et,81117f08 <vFailCreateScheduleQueue+0xc>
81117f04:	003b68fa 	trap	3
81117f08:	dfc00115 	stw	ra,4(sp)
81117f0c:	df000015 	stw	fp,0(sp)
81117f10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
81117f14:	d0a05c17 	ldw	r2,-32400(gp)
81117f18:	100f883a 	mov	r7,r2
81117f1c:	01800844 	movi	r6,33
81117f20:	01400044 	movi	r5,1
81117f24:	01204574 	movhi	r4,33045
81117f28:	21284c04 	addi	r4,r4,-24272
81117f2c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
81117f30:	d0a05c17 	ldw	r2,-32400(gp)
81117f34:	100f883a 	mov	r7,r2
81117f38:	01801204 	movi	r6,72
81117f3c:	01400044 	movi	r5,1
81117f40:	01204574 	movhi	r4,33045
81117f44:	21285504 	addi	r4,r4,-24236
81117f48:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f4c:	0001883a 	nop
81117f50:	e037883a 	mov	sp,fp
81117f54:	dfc00117 	ldw	ra,4(sp)
81117f58:	df000017 	ldw	fp,0(sp)
81117f5c:	dec00204 	addi	sp,sp,8
81117f60:	f800283a 	ret

81117f64 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81117f64:	defffd04 	addi	sp,sp,-12
81117f68:	de00012e 	bgeu	sp,et,81117f70 <vFailCreateNFEEQueue+0xc>
81117f6c:	003b68fa 	trap	3
81117f70:	dfc00215 	stw	ra,8(sp)
81117f74:	df000115 	stw	fp,4(sp)
81117f78:	df000104 	addi	fp,sp,4
81117f7c:	2005883a 	mov	r2,r4
81117f80:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
81117f84:	d0a05c17 	ldw	r2,-32400(gp)
81117f88:	100f883a 	mov	r7,r2
81117f8c:	01800744 	movi	r6,29
81117f90:	01400044 	movi	r5,1
81117f94:	01204574 	movhi	r4,33045
81117f98:	21286804 	addi	r4,r4,-24160
81117f9c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
81117fa0:	d0a05c17 	ldw	r2,-32400(gp)
81117fa4:	e0ffff03 	ldbu	r3,-4(fp)
81117fa8:	180d883a 	mov	r6,r3
81117fac:	01604574 	movhi	r5,33045
81117fb0:	29687004 	addi	r5,r5,-24128
81117fb4:	1009883a 	mov	r4,r2
81117fb8:	111ce640 	call	8111ce64 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117fbc:	0001883a 	nop
81117fc0:	e037883a 	mov	sp,fp
81117fc4:	dfc00117 	ldw	ra,4(sp)
81117fc8:	df000017 	ldw	fp,0(sp)
81117fcc:	dec00204 	addi	sp,sp,8
81117fd0:	f800283a 	ret

81117fd4 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
81117fd4:	defffd04 	addi	sp,sp,-12
81117fd8:	de00012e 	bgeu	sp,et,81117fe0 <vFailCreateNFEESyncQueue+0xc>
81117fdc:	003b68fa 	trap	3
81117fe0:	dfc00215 	stw	ra,8(sp)
81117fe4:	df000115 	stw	fp,4(sp)
81117fe8:	df000104 	addi	fp,sp,4
81117fec:	2005883a 	mov	r2,r4
81117ff0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
81117ff4:	d0a05c17 	ldw	r2,-32400(gp)
81117ff8:	100f883a 	mov	r7,r2
81117ffc:	01800844 	movi	r6,33
81118000:	01400044 	movi	r5,1
81118004:	01204574 	movhi	r4,33045
81118008:	21287e04 	addi	r4,r4,-24072
8111800c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
81118010:	d0a05c17 	ldw	r2,-32400(gp)
81118014:	e0ffff03 	ldbu	r3,-4(fp)
81118018:	180d883a 	mov	r6,r3
8111801c:	01604574 	movhi	r5,33045
81118020:	29688704 	addi	r5,r5,-24036
81118024:	1009883a 	mov	r4,r2
81118028:	111ce640 	call	8111ce64 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111802c:	0001883a 	nop
81118030:	e037883a 	mov	sp,fp
81118034:	dfc00117 	ldw	ra,4(sp)
81118038:	df000017 	ldw	fp,0(sp)
8111803c:	dec00204 	addi	sp,sp,8
81118040:	f800283a 	ret

81118044 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
81118044:	defffe04 	addi	sp,sp,-8
81118048:	de00012e 	bgeu	sp,et,81118050 <vCoudlNotCreateNFee0Task+0xc>
8111804c:	003b68fa 	trap	3
81118050:	dfc00115 	stw	ra,4(sp)
81118054:	df000015 	stw	fp,0(sp)
81118058:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111805c:	d0a05c17 	ldw	r2,-32400(gp)
81118060:	100f883a 	mov	r7,r2
81118064:	01800844 	movi	r6,33
81118068:	01400044 	movi	r5,1
8111806c:	01204574 	movhi	r4,33045
81118070:	21289504 	addi	r4,r4,-23980
81118074:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
81118078:	d0a05c17 	ldw	r2,-32400(gp)
8111807c:	100f883a 	mov	r7,r2
81118080:	01800784 	movi	r6,30
81118084:	01400044 	movi	r5,1
81118088:	01204574 	movhi	r4,33045
8111808c:	21289e04 	addi	r4,r4,-23944
81118090:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118094:	0001883a 	nop
81118098:	e037883a 	mov	sp,fp
8111809c:	dfc00117 	ldw	ra,4(sp)
811180a0:	df000017 	ldw	fp,0(sp)
811180a4:	dec00204 	addi	sp,sp,8
811180a8:	f800283a 	ret

811180ac <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
811180ac:	defffe04 	addi	sp,sp,-8
811180b0:	de00012e 	bgeu	sp,et,811180b8 <vCoudlNotCreateNFee1Task+0xc>
811180b4:	003b68fa 	trap	3
811180b8:	dfc00115 	stw	ra,4(sp)
811180bc:	df000015 	stw	fp,0(sp)
811180c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
811180c4:	d0a05c17 	ldw	r2,-32400(gp)
811180c8:	100f883a 	mov	r7,r2
811180cc:	01800844 	movi	r6,33
811180d0:	01400044 	movi	r5,1
811180d4:	01204574 	movhi	r4,33045
811180d8:	2128a604 	addi	r4,r4,-23912
811180dc:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
811180e0:	d0a05c17 	ldw	r2,-32400(gp)
811180e4:	100f883a 	mov	r7,r2
811180e8:	01800784 	movi	r6,30
811180ec:	01400044 	movi	r5,1
811180f0:	01204574 	movhi	r4,33045
811180f4:	2128af04 	addi	r4,r4,-23876
811180f8:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811180fc:	0001883a 	nop
81118100:	e037883a 	mov	sp,fp
81118104:	dfc00117 	ldw	ra,4(sp)
81118108:	df000017 	ldw	fp,0(sp)
8111810c:	dec00204 	addi	sp,sp,8
81118110:	f800283a 	ret

81118114 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
81118114:	defffe04 	addi	sp,sp,-8
81118118:	de00012e 	bgeu	sp,et,81118120 <vCoudlNotCreateNFee2Task+0xc>
8111811c:	003b68fa 	trap	3
81118120:	dfc00115 	stw	ra,4(sp)
81118124:	df000015 	stw	fp,0(sp)
81118128:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111812c:	d0a05c17 	ldw	r2,-32400(gp)
81118130:	100f883a 	mov	r7,r2
81118134:	01800844 	movi	r6,33
81118138:	01400044 	movi	r5,1
8111813c:	01204574 	movhi	r4,33045
81118140:	2128b704 	addi	r4,r4,-23844
81118144:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
81118148:	d0a05c17 	ldw	r2,-32400(gp)
8111814c:	100f883a 	mov	r7,r2
81118150:	01800784 	movi	r6,30
81118154:	01400044 	movi	r5,1
81118158:	01204574 	movhi	r4,33045
8111815c:	2128c004 	addi	r4,r4,-23808
81118160:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118164:	0001883a 	nop
81118168:	e037883a 	mov	sp,fp
8111816c:	dfc00117 	ldw	ra,4(sp)
81118170:	df000017 	ldw	fp,0(sp)
81118174:	dec00204 	addi	sp,sp,8
81118178:	f800283a 	ret

8111817c <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111817c:	defffe04 	addi	sp,sp,-8
81118180:	de00012e 	bgeu	sp,et,81118188 <vCoudlNotCreateNFee3Task+0xc>
81118184:	003b68fa 	trap	3
81118188:	dfc00115 	stw	ra,4(sp)
8111818c:	df000015 	stw	fp,0(sp)
81118190:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
81118194:	d0a05c17 	ldw	r2,-32400(gp)
81118198:	100f883a 	mov	r7,r2
8111819c:	01800844 	movi	r6,33
811181a0:	01400044 	movi	r5,1
811181a4:	01204574 	movhi	r4,33045
811181a8:	2128c804 	addi	r4,r4,-23776
811181ac:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
811181b0:	d0a05c17 	ldw	r2,-32400(gp)
811181b4:	100f883a 	mov	r7,r2
811181b8:	01800784 	movi	r6,30
811181bc:	01400044 	movi	r5,1
811181c0:	01204574 	movhi	r4,33045
811181c4:	2128d104 	addi	r4,r4,-23740
811181c8:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811181cc:	0001883a 	nop
811181d0:	e037883a 	mov	sp,fp
811181d4:	dfc00117 	ldw	ra,4(sp)
811181d8:	df000017 	ldw	fp,0(sp)
811181dc:	dec00204 	addi	sp,sp,8
811181e0:	f800283a 	ret

811181e4 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
811181e4:	defffe04 	addi	sp,sp,-8
811181e8:	de00012e 	bgeu	sp,et,811181f0 <vCoudlNotCreateNFee4Task+0xc>
811181ec:	003b68fa 	trap	3
811181f0:	dfc00115 	stw	ra,4(sp)
811181f4:	df000015 	stw	fp,0(sp)
811181f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
811181fc:	d0a05c17 	ldw	r2,-32400(gp)
81118200:	100f883a 	mov	r7,r2
81118204:	01800844 	movi	r6,33
81118208:	01400044 	movi	r5,1
8111820c:	01204574 	movhi	r4,33045
81118210:	2128d904 	addi	r4,r4,-23708
81118214:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
81118218:	d0a05c17 	ldw	r2,-32400(gp)
8111821c:	100f883a 	mov	r7,r2
81118220:	01800784 	movi	r6,30
81118224:	01400044 	movi	r5,1
81118228:	01204574 	movhi	r4,33045
8111822c:	2128e204 	addi	r4,r4,-23672
81118230:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118234:	0001883a 	nop
81118238:	e037883a 	mov	sp,fp
8111823c:	dfc00117 	ldw	ra,4(sp)
81118240:	df000017 	ldw	fp,0(sp)
81118244:	dec00204 	addi	sp,sp,8
81118248:	f800283a 	ret

8111824c <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111824c:	defffe04 	addi	sp,sp,-8
81118250:	de00012e 	bgeu	sp,et,81118258 <vCoudlNotCreateNFee5Task+0xc>
81118254:	003b68fa 	trap	3
81118258:	dfc00115 	stw	ra,4(sp)
8111825c:	df000015 	stw	fp,0(sp)
81118260:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
81118264:	d0a05c17 	ldw	r2,-32400(gp)
81118268:	100f883a 	mov	r7,r2
8111826c:	01800844 	movi	r6,33
81118270:	01400044 	movi	r5,1
81118274:	01204574 	movhi	r4,33045
81118278:	2128ea04 	addi	r4,r4,-23640
8111827c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81118280:	d0a05c17 	ldw	r2,-32400(gp)
81118284:	100f883a 	mov	r7,r2
81118288:	01800784 	movi	r6,30
8111828c:	01400044 	movi	r5,1
81118290:	01204574 	movhi	r4,33045
81118294:	2128f304 	addi	r4,r4,-23604
81118298:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111829c:	0001883a 	nop
811182a0:	e037883a 	mov	sp,fp
811182a4:	dfc00117 	ldw	ra,4(sp)
811182a8:	df000017 	ldw	fp,0(sp)
811182ac:	dec00204 	addi	sp,sp,8
811182b0:	f800283a 	ret

811182b4 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
811182b4:	defffe04 	addi	sp,sp,-8
811182b8:	de00012e 	bgeu	sp,et,811182c0 <vCoudlNotCreateNFeeControllerTask+0xc>
811182bc:	003b68fa 	trap	3
811182c0:	dfc00115 	stw	ra,4(sp)
811182c4:	df000015 	stw	fp,0(sp)
811182c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
811182cc:	d0a05c17 	ldw	r2,-32400(gp)
811182d0:	100f883a 	mov	r7,r2
811182d4:	01800a84 	movi	r6,42
811182d8:	01400044 	movi	r5,1
811182dc:	01204574 	movhi	r4,33045
811182e0:	2128fb04 	addi	r4,r4,-23572
811182e4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
811182e8:	d0a05c17 	ldw	r2,-32400(gp)
811182ec:	100f883a 	mov	r7,r2
811182f0:	018009c4 	movi	r6,39
811182f4:	01400044 	movi	r5,1
811182f8:	01204574 	movhi	r4,33045
811182fc:	21290604 	addi	r4,r4,-23528
81118300:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118304:	0001883a 	nop
81118308:	e037883a 	mov	sp,fp
8111830c:	dfc00117 	ldw	ra,4(sp)
81118310:	df000017 	ldw	fp,0(sp)
81118314:	dec00204 	addi	sp,sp,8
81118318:	f800283a 	ret

8111831c <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111831c:	defffe04 	addi	sp,sp,-8
81118320:	de00012e 	bgeu	sp,et,81118328 <vCoudlNotCreateDataControllerTask+0xc>
81118324:	003b68fa 	trap	3
81118328:	dfc00115 	stw	ra,4(sp)
8111832c:	df000015 	stw	fp,0(sp)
81118330:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
81118334:	d0a05c17 	ldw	r2,-32400(gp)
81118338:	100f883a 	mov	r7,r2
8111833c:	01800a84 	movi	r6,42
81118340:	01400044 	movi	r5,1
81118344:	01204574 	movhi	r4,33045
81118348:	21291004 	addi	r4,r4,-23488
8111834c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81118350:	d0a05c17 	ldw	r2,-32400(gp)
81118354:	100f883a 	mov	r7,r2
81118358:	018009c4 	movi	r6,39
8111835c:	01400044 	movi	r5,1
81118360:	01204574 	movhi	r4,33045
81118364:	21291b04 	addi	r4,r4,-23444
81118368:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111836c:	0001883a 	nop
81118370:	e037883a 	mov	sp,fp
81118374:	dfc00117 	ldw	ra,4(sp)
81118378:	df000017 	ldw	fp,0(sp)
8111837c:	dec00204 	addi	sp,sp,8
81118380:	f800283a 	ret

81118384 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81118384:	defffe04 	addi	sp,sp,-8
81118388:	de00012e 	bgeu	sp,et,81118390 <vCoudlNotCreateMebTask+0xc>
8111838c:	003b68fa 	trap	3
81118390:	dfc00115 	stw	ra,4(sp)
81118394:	df000015 	stw	fp,0(sp)
81118398:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111839c:	d0a05c17 	ldw	r2,-32400(gp)
811183a0:	100f883a 	mov	r7,r2
811183a4:	018007c4 	movi	r6,31
811183a8:	01400044 	movi	r5,1
811183ac:	01204574 	movhi	r4,33045
811183b0:	21292504 	addi	r4,r4,-23404
811183b4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
811183b8:	d0a05c17 	ldw	r2,-32400(gp)
811183bc:	100f883a 	mov	r7,r2
811183c0:	018006c4 	movi	r6,27
811183c4:	01400044 	movi	r5,1
811183c8:	01204574 	movhi	r4,33045
811183cc:	21292d04 	addi	r4,r4,-23372
811183d0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811183d4:	0001883a 	nop
811183d8:	e037883a 	mov	sp,fp
811183dc:	dfc00117 	ldw	ra,4(sp)
811183e0:	df000017 	ldw	fp,0(sp)
811183e4:	dec00204 	addi	sp,sp,8
811183e8:	f800283a 	ret

811183ec <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
811183ec:	defffd04 	addi	sp,sp,-12
811183f0:	de00012e 	bgeu	sp,et,811183f8 <vFailCreateMutexSPUSQueueMeb+0xc>
811183f4:	003b68fa 	trap	3
811183f8:	dfc00215 	stw	ra,8(sp)
811183fc:	df000115 	stw	fp,4(sp)
81118400:	df000104 	addi	fp,sp,4
81118404:	2005883a 	mov	r2,r4
81118408:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111840c:	d0a05c17 	ldw	r2,-32400(gp)
81118410:	100f883a 	mov	r7,r2
81118414:	01800944 	movi	r6,37
81118418:	01400044 	movi	r5,1
8111841c:	01204574 	movhi	r4,33045
81118420:	21293404 	addi	r4,r4,-23344
81118424:	111c1380 	call	8111c138 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81118428:	e0bfff03 	ldbu	r2,-4(fp)
8111842c:	1009883a 	mov	r4,r2
81118430:	1116b980 	call	81116b98 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118434:	0001883a 	nop
81118438:	e037883a 	mov	sp,fp
8111843c:	dfc00117 	ldw	ra,4(sp)
81118440:	df000017 	ldw	fp,0(sp)
81118444:	dec00204 	addi	sp,sp,8
81118448:	f800283a 	ret

8111844c <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111844c:	defffe04 	addi	sp,sp,-8
81118450:	de00012e 	bgeu	sp,et,81118458 <vFailSendPUStoMebTask+0xc>
81118454:	003b68fa 	trap	3
81118458:	dfc00115 	stw	ra,4(sp)
8111845c:	df000015 	stw	fp,0(sp)
81118460:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
81118464:	d0a05c17 	ldw	r2,-32400(gp)
81118468:	100f883a 	mov	r7,r2
8111846c:	01800784 	movi	r6,30
81118470:	01400044 	movi	r5,1
81118474:	01204574 	movhi	r4,33045
81118478:	21293e04 	addi	r4,r4,-23304
8111847c:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118480:	0001883a 	nop
81118484:	e037883a 	mov	sp,fp
81118488:	dfc00117 	ldw	ra,4(sp)
8111848c:	df000017 	ldw	fp,0(sp)
81118490:	dec00204 	addi	sp,sp,8
81118494:	f800283a 	ret

81118498 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
81118498:	defffe04 	addi	sp,sp,-8
8111849c:	de00012e 	bgeu	sp,et,811184a4 <vCouldNotGetCmdQueueMeb+0xc>
811184a0:	003b68fa 	trap	3
811184a4:	dfc00115 	stw	ra,4(sp)
811184a8:	df000015 	stw	fp,0(sp)
811184ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
811184b0:	d0a05c17 	ldw	r2,-32400(gp)
811184b4:	100f883a 	mov	r7,r2
811184b8:	01800a84 	movi	r6,42
811184bc:	01400044 	movi	r5,1
811184c0:	01204574 	movhi	r4,33045
811184c4:	21294604 	addi	r4,r4,-23272
811184c8:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
811184cc:	d0a05c17 	ldw	r2,-32400(gp)
811184d0:	100f883a 	mov	r7,r2
811184d4:	01800cc4 	movi	r6,51
811184d8:	01400044 	movi	r5,1
811184dc:	01204574 	movhi	r4,33045
811184e0:	21295104 	addi	r4,r4,-23228
811184e4:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811184e8:	0001883a 	nop
811184ec:	e037883a 	mov	sp,fp
811184f0:	dfc00117 	ldw	ra,4(sp)
811184f4:	df000017 	ldw	fp,0(sp)
811184f8:	dec00204 	addi	sp,sp,8
811184fc:	f800283a 	ret

81118500 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
81118500:	defffe04 	addi	sp,sp,-8
81118504:	de00012e 	bgeu	sp,et,8111850c <vCouldNotGetMutexMebPus+0xc>
81118508:	003b68fa 	trap	3
8111850c:	dfc00115 	stw	ra,4(sp)
81118510:	df000015 	stw	fp,0(sp)
81118514:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
81118518:	d0a05c17 	ldw	r2,-32400(gp)
8111851c:	100f883a 	mov	r7,r2
81118520:	01800804 	movi	r6,32
81118524:	01400044 	movi	r5,1
81118528:	01204574 	movhi	r4,33045
8111852c:	21295e04 	addi	r4,r4,-23176
81118530:	111c1380 	call	8111c138 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118534:	0001883a 	nop
81118538:	e037883a 	mov	sp,fp
8111853c:	dfc00117 	ldw	ra,4(sp)
81118540:	df000017 	ldw	fp,0(sp)
81118544:	dec00204 	addi	sp,sp,8
81118548:	f800283a 	ret

8111854c <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111854c:	defffe04 	addi	sp,sp,-8
81118550:	de00012e 	bgeu	sp,et,81118558 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
81118554:	003b68fa 	trap	3
81118558:	dfc00115 	stw	ra,4(sp)
8111855c:	df000015 	stw	fp,0(sp)
81118560:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
81118564:	d0a05c17 	ldw	r2,-32400(gp)
81118568:	100f883a 	mov	r7,r2
8111856c:	01800a44 	movi	r6,41
81118570:	01400044 	movi	r5,1
81118574:	01204574 	movhi	r4,33045
81118578:	21296704 	addi	r4,r4,-23140
8111857c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81118580:	d0a05c17 	ldw	r2,-32400(gp)
81118584:	100f883a 	mov	r7,r2
81118588:	01800c84 	movi	r6,50
8111858c:	01400044 	movi	r5,1
81118590:	01204574 	movhi	r4,33045
81118594:	21297204 	addi	r4,r4,-23096
81118598:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111859c:	0001883a 	nop
811185a0:	e037883a 	mov	sp,fp
811185a4:	dfc00117 	ldw	ra,4(sp)
811185a8:	df000017 	ldw	fp,0(sp)
811185ac:	dec00204 	addi	sp,sp,8
811185b0:	f800283a 	ret

811185b4 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
811185b4:	defffe04 	addi	sp,sp,-8
811185b8:	de00012e 	bgeu	sp,et,811185c0 <vCouldNotCreateQueueMaskDataCtrl+0xc>
811185bc:	003b68fa 	trap	3
811185c0:	dfc00115 	stw	ra,4(sp)
811185c4:	df000015 	stw	fp,0(sp)
811185c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
811185cc:	d0a05c17 	ldw	r2,-32400(gp)
811185d0:	100f883a 	mov	r7,r2
811185d4:	01800a44 	movi	r6,41
811185d8:	01400044 	movi	r5,1
811185dc:	01204574 	movhi	r4,33045
811185e0:	21297f04 	addi	r4,r4,-23044
811185e4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
811185e8:	d0a05c17 	ldw	r2,-32400(gp)
811185ec:	100f883a 	mov	r7,r2
811185f0:	01800c84 	movi	r6,50
811185f4:	01400044 	movi	r5,1
811185f8:	01204574 	movhi	r4,33045
811185fc:	21298a04 	addi	r4,r4,-23000
81118600:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118604:	0001883a 	nop
81118608:	e037883a 	mov	sp,fp
8111860c:	dfc00117 	ldw	ra,4(sp)
81118610:	df000017 	ldw	fp,0(sp)
81118614:	dec00204 	addi	sp,sp,8
81118618:	f800283a 	ret

8111861c <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111861c:	defffe04 	addi	sp,sp,-8
81118620:	de00012e 	bgeu	sp,et,81118628 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
81118624:	003b68fa 	trap	3
81118628:	dfc00115 	stw	ra,4(sp)
8111862c:	df000015 	stw	fp,0(sp)
81118630:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81118634:	d0a05c17 	ldw	r2,-32400(gp)
81118638:	100f883a 	mov	r7,r2
8111863c:	01800984 	movi	r6,38
81118640:	01400044 	movi	r5,1
81118644:	01204574 	movhi	r4,33045
81118648:	21299704 	addi	r4,r4,-22948
8111864c:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
81118650:	d0a05c17 	ldw	r2,-32400(gp)
81118654:	100f883a 	mov	r7,r2
81118658:	01800bc4 	movi	r6,47
8111865c:	01400044 	movi	r5,1
81118660:	01204574 	movhi	r4,33045
81118664:	2129a104 	addi	r4,r4,-22908
81118668:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111866c:	0001883a 	nop
81118670:	e037883a 	mov	sp,fp
81118674:	dfc00117 	ldw	ra,4(sp)
81118678:	df000017 	ldw	fp,0(sp)
8111867c:	dec00204 	addi	sp,sp,8
81118680:	f800283a 	ret

81118684 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
81118684:	defffe04 	addi	sp,sp,-8
81118688:	de00012e 	bgeu	sp,et,81118690 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111868c:	003b68fa 	trap	3
81118690:	dfc00115 	stw	ra,4(sp)
81118694:	df000015 	stw	fp,0(sp)
81118698:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111869c:	d0a05c17 	ldw	r2,-32400(gp)
811186a0:	100f883a 	mov	r7,r2
811186a4:	01800984 	movi	r6,38
811186a8:	01400044 	movi	r5,1
811186ac:	01204574 	movhi	r4,33045
811186b0:	2129ad04 	addi	r4,r4,-22860
811186b4:	111c1380 	call	8111c138 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
811186b8:	d0a05c17 	ldw	r2,-32400(gp)
811186bc:	100f883a 	mov	r7,r2
811186c0:	01800bc4 	movi	r6,47
811186c4:	01400044 	movi	r5,1
811186c8:	01204574 	movhi	r4,33045
811186cc:	2129b704 	addi	r4,r4,-22820
811186d0:	111c1380 	call	8111c138 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811186d4:	0001883a 	nop
811186d8:	e037883a 	mov	sp,fp
811186dc:	dfc00117 	ldw	ra,4(sp)
811186e0:	df000017 	ldw	fp,0(sp)
811186e4:	dec00204 	addi	sp,sp,8
811186e8:	f800283a 	ret

811186ec <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
811186ec:	defffd04 	addi	sp,sp,-12
811186f0:	de00012e 	bgeu	sp,et,811186f8 <vFailSendMsgAccessDMA+0xc>
811186f4:	003b68fa 	trap	3
811186f8:	dfc00215 	stw	ra,8(sp)
811186fc:	df000115 	stw	fp,4(sp)
81118700:	df000104 	addi	fp,sp,4
81118704:	2005883a 	mov	r2,r4
81118708:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111870c:	d0a05c17 	ldw	r2,-32400(gp)
81118710:	e0ffff03 	ldbu	r3,-4(fp)
81118714:	180d883a 	mov	r6,r3
81118718:	01604574 	movhi	r5,33045
8111871c:	2969c304 	addi	r5,r5,-22772
81118720:	1009883a 	mov	r4,r2
81118724:	111ba9c0 	call	8111ba9c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118728:	0001883a 	nop
8111872c:	e037883a 	mov	sp,fp
81118730:	dfc00117 	ldw	ra,4(sp)
81118734:	df000017 	ldw	fp,0(sp)
81118738:	dec00204 	addi	sp,sp,8
8111873c:	f800283a 	ret

81118740 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
81118740:	defffd04 	addi	sp,sp,-12
81118744:	de00012e 	bgeu	sp,et,8111874c <vFailRequestDMA+0xc>
81118748:	003b68fa 	trap	3
8111874c:	dfc00215 	stw	ra,8(sp)
81118750:	df000115 	stw	fp,4(sp)
81118754:	df000104 	addi	fp,sp,4
81118758:	2005883a 	mov	r2,r4
8111875c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
81118760:	d0a05c17 	ldw	r2,-32400(gp)
81118764:	e0ffff03 	ldbu	r3,-4(fp)
81118768:	180d883a 	mov	r6,r3
8111876c:	01604574 	movhi	r5,33045
81118770:	2969cb04 	addi	r5,r5,-22740
81118774:	1009883a 	mov	r4,r2
81118778:	111ba9c0 	call	8111ba9c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111877c:	0001883a 	nop
81118780:	e037883a 	mov	sp,fp
81118784:	dfc00117 	ldw	ra,4(sp)
81118788:	df000017 	ldw	fp,0(sp)
8111878c:	dec00204 	addi	sp,sp,8
81118790:	f800283a 	ret

81118794 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
81118794:	defffd04 	addi	sp,sp,-12
81118798:	de00012e 	bgeu	sp,et,811187a0 <vFailRequestDMAFromIRQ+0xc>
8111879c:	003b68fa 	trap	3
811187a0:	dfc00215 	stw	ra,8(sp)
811187a4:	df000115 	stw	fp,4(sp)
811187a8:	df000104 	addi	fp,sp,4
811187ac:	2005883a 	mov	r2,r4
811187b0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
811187b4:	d0a05c17 	ldw	r2,-32400(gp)
811187b8:	e0ffff03 	ldbu	r3,-4(fp)
811187bc:	180d883a 	mov	r6,r3
811187c0:	01604574 	movhi	r5,33045
811187c4:	2969cb04 	addi	r5,r5,-22740
811187c8:	1009883a 	mov	r4,r2
811187cc:	111ba9c0 	call	8111ba9c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811187d0:	0001883a 	nop
811187d4:	e037883a 	mov	sp,fp
811187d8:	dfc00117 	ldw	ra,4(sp)
811187dc:	df000017 	ldw	fp,0(sp)
811187e0:	dec00204 	addi	sp,sp,8
811187e4:	f800283a 	ret

811187e8 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
811187e8:	defffd04 	addi	sp,sp,-12
811187ec:	de00012e 	bgeu	sp,et,811187f4 <vFailSendMsgSync+0xc>
811187f0:	003b68fa 	trap	3
811187f4:	dfc00215 	stw	ra,8(sp)
811187f8:	df000115 	stw	fp,4(sp)
811187fc:	df000104 	addi	fp,sp,4
81118800:	2005883a 	mov	r2,r4
81118804:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
81118808:	d0a05c17 	ldw	r2,-32400(gp)
8111880c:	e0ffff03 	ldbu	r3,-4(fp)
81118810:	180d883a 	mov	r6,r3
81118814:	01604574 	movhi	r5,33045
81118818:	2969d204 	addi	r5,r5,-22712
8111881c:	1009883a 	mov	r4,r2
81118820:	111ba9c0 	call	8111ba9c <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118824:	0001883a 	nop
81118828:	e037883a 	mov	sp,fp
8111882c:	dfc00117 	ldw	ra,4(sp)
81118830:	df000017 	ldw	fp,0(sp)
81118834:	dec00204 	addi	sp,sp,8
81118838:	f800283a 	ret

8111883c <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111883c:	defffe04 	addi	sp,sp,-8
81118840:	de00012e 	bgeu	sp,et,81118848 <vFailSendMsgMasterSyncMeb+0xc>
81118844:	003b68fa 	trap	3
81118848:	dfc00115 	stw	ra,4(sp)
8111884c:	df000015 	stw	fp,0(sp)
81118850:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
81118854:	d0a05c17 	ldw	r2,-32400(gp)
81118858:	100f883a 	mov	r7,r2
8111885c:	018006c4 	movi	r6,27
81118860:	01400044 	movi	r5,1
81118864:	01204574 	movhi	r4,33045
81118868:	2129d904 	addi	r4,r4,-22684
8111886c:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118870:	0001883a 	nop
81118874:	e037883a 	mov	sp,fp
81118878:	dfc00117 	ldw	ra,4(sp)
8111887c:	df000017 	ldw	fp,0(sp)
81118880:	dec00204 	addi	sp,sp,8
81118884:	f800283a 	ret

81118888 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
81118888:	defffe04 	addi	sp,sp,-8
8111888c:	de00012e 	bgeu	sp,et,81118894 <vFailSendMsgFeeCTRL+0xc>
81118890:	003b68fa 	trap	3
81118894:	dfc00115 	stw	ra,4(sp)
81118898:	df000015 	stw	fp,0(sp)
8111889c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
811188a0:	d0a05c17 	ldw	r2,-32400(gp)
811188a4:	100f883a 	mov	r7,r2
811188a8:	018005c4 	movi	r6,23
811188ac:	01400044 	movi	r5,1
811188b0:	01204574 	movhi	r4,33045
811188b4:	2129e004 	addi	r4,r4,-22656
811188b8:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811188bc:	0001883a 	nop
811188c0:	e037883a 	mov	sp,fp
811188c4:	dfc00117 	ldw	ra,4(sp)
811188c8:	df000017 	ldw	fp,0(sp)
811188cc:	dec00204 	addi	sp,sp,8
811188d0:	f800283a 	ret

811188d4 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
811188d4:	defffe04 	addi	sp,sp,-8
811188d8:	de00012e 	bgeu	sp,et,811188e0 <vFailSendMsgDataCTRL+0xc>
811188dc:	003b68fa 	trap	3
811188e0:	dfc00115 	stw	ra,4(sp)
811188e4:	df000015 	stw	fp,0(sp)
811188e8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
811188ec:	d0a05c17 	ldw	r2,-32400(gp)
811188f0:	100f883a 	mov	r7,r2
811188f4:	01800604 	movi	r6,24
811188f8:	01400044 	movi	r5,1
811188fc:	01204574 	movhi	r4,33045
81118900:	2129e604 	addi	r4,r4,-22632
81118904:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118908:	0001883a 	nop
8111890c:	e037883a 	mov	sp,fp
81118910:	dfc00117 	ldw	ra,4(sp)
81118914:	df000017 	ldw	fp,0(sp)
81118918:	dec00204 	addi	sp,sp,8
8111891c:	f800283a 	ret

81118920 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
81118920:	defffe04 	addi	sp,sp,-8
81118924:	de00012e 	bgeu	sp,et,8111892c <vFailFlushQueue+0xc>
81118928:	003b68fa 	trap	3
8111892c:	dfc00115 	stw	ra,4(sp)
81118930:	df000015 	stw	fp,0(sp)
81118934:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
81118938:	d0a05c17 	ldw	r2,-32400(gp)
8111893c:	100f883a 	mov	r7,r2
81118940:	01800744 	movi	r6,29
81118944:	01400044 	movi	r5,1
81118948:	01204574 	movhi	r4,33045
8111894c:	2129ed04 	addi	r4,r4,-22604
81118950:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118954:	0001883a 	nop
81118958:	e037883a 	mov	sp,fp
8111895c:	dfc00117 	ldw	ra,4(sp)
81118960:	df000017 	ldw	fp,0(sp)
81118964:	dec00204 	addi	sp,sp,8
81118968:	f800283a 	ret

8111896c <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111896c:	defffe04 	addi	sp,sp,-8
81118970:	de00012e 	bgeu	sp,et,81118978 <vFailFlushQueueData+0xc>
81118974:	003b68fa 	trap	3
81118978:	dfc00115 	stw	ra,4(sp)
8111897c:	df000015 	stw	fp,0(sp)
81118980:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
81118984:	d0a05c17 	ldw	r2,-32400(gp)
81118988:	100f883a 	mov	r7,r2
8111898c:	01800844 	movi	r6,33
81118990:	01400044 	movi	r5,1
81118994:	01204574 	movhi	r4,33045
81118998:	2129f504 	addi	r4,r4,-22572
8111899c:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811189a0:	0001883a 	nop
811189a4:	e037883a 	mov	sp,fp
811189a8:	dfc00117 	ldw	ra,4(sp)
811189ac:	df000017 	ldw	fp,0(sp)
811189b0:	dec00204 	addi	sp,sp,8
811189b4:	f800283a 	ret

811189b8 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
811189b8:	defffe04 	addi	sp,sp,-8
811189bc:	de00012e 	bgeu	sp,et,811189c4 <vFailFlushMEBQueue+0xc>
811189c0:	003b68fa 	trap	3
811189c4:	dfc00115 	stw	ra,4(sp)
811189c8:	df000015 	stw	fp,0(sp)
811189cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
811189d0:	d0a05c17 	ldw	r2,-32400(gp)
811189d4:	100f883a 	mov	r7,r2
811189d8:	01800804 	movi	r6,32
811189dc:	01400044 	movi	r5,1
811189e0:	01204574 	movhi	r4,33045
811189e4:	2129fe04 	addi	r4,r4,-22536
811189e8:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811189ec:	0001883a 	nop
811189f0:	e037883a 	mov	sp,fp
811189f4:	dfc00117 	ldw	ra,4(sp)
811189f8:	df000017 	ldw	fp,0(sp)
811189fc:	dec00204 	addi	sp,sp,8
81118a00:	f800283a 	ret

81118a04 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
81118a04:	defffe04 	addi	sp,sp,-8
81118a08:	de00012e 	bgeu	sp,et,81118a10 <vFailFlushNFEEQueue+0xc>
81118a0c:	003b68fa 	trap	3
81118a10:	dfc00115 	stw	ra,4(sp)
81118a14:	df000015 	stw	fp,0(sp)
81118a18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
81118a1c:	d0a05c17 	ldw	r2,-32400(gp)
81118a20:	100f883a 	mov	r7,r2
81118a24:	01800844 	movi	r6,33
81118a28:	01400044 	movi	r5,1
81118a2c:	01204574 	movhi	r4,33045
81118a30:	212a0704 	addi	r4,r4,-22500
81118a34:	111c1380 	call	8111c138 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118a38:	0001883a 	nop
81118a3c:	e037883a 	mov	sp,fp
81118a40:	dfc00117 	ldw	ra,4(sp)
81118a44:	df000017 	ldw	fp,0(sp)
81118a48:	dec00204 	addi	sp,sp,8
81118a4c:	f800283a 	ret

81118a50 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
81118a50:	deffff04 	addi	sp,sp,-4
81118a54:	de00012e 	bgeu	sp,et,81118a5c <vEvtChangeMebMode+0xc>
81118a58:	003b68fa 	trap	3
81118a5c:	df000015 	stw	fp,0(sp)
81118a60:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81118a64:	0001883a 	nop
81118a68:	e037883a 	mov	sp,fp
81118a6c:	df000017 	ldw	fp,0(sp)
81118a70:	dec00104 	addi	sp,sp,4
81118a74:	f800283a 	ret

81118a78 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
81118a78:	deffff04 	addi	sp,sp,-4
81118a7c:	de00012e 	bgeu	sp,et,81118a84 <vEvtChangeFeeControllerMode+0xc>
81118a80:	003b68fa 	trap	3
81118a84:	df000015 	stw	fp,0(sp)
81118a88:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81118a8c:	0001883a 	nop
81118a90:	e037883a 	mov	sp,fp
81118a94:	df000017 	ldw	fp,0(sp)
81118a98:	dec00104 	addi	sp,sp,4
81118a9c:	f800283a 	ret

81118aa0 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
81118aa0:	deffff04 	addi	sp,sp,-4
81118aa4:	de00012e 	bgeu	sp,et,81118aac <vEvtChangeDataControllerMode+0xc>
81118aa8:	003b68fa 	trap	3
81118aac:	df000015 	stw	fp,0(sp)
81118ab0:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81118ab4:	0001883a 	nop
81118ab8:	e037883a 	mov	sp,fp
81118abc:	df000017 	ldw	fp,0(sp)
81118ac0:	dec00104 	addi	sp,sp,4
81118ac4:	f800283a 	ret

81118ac8 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81118ac8:	defffd04 	addi	sp,sp,-12
81118acc:	de00012e 	bgeu	sp,et,81118ad4 <vNFeeNotInUse+0xc>
81118ad0:	003b68fa 	trap	3
81118ad4:	df000215 	stw	fp,8(sp)
81118ad8:	df000204 	addi	fp,sp,8
81118adc:	e13ffe15 	stw	r4,-8(fp)
81118ae0:	2805883a 	mov	r2,r5
81118ae4:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
81118ae8:	e0bffe17 	ldw	r2,-8(fp)
81118aec:	e0ffff03 	ldbu	r3,-4(fp)
81118af0:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81118af4:	e0bffe17 	ldw	r2,-8(fp)
81118af8:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81118afc:	e0bffe17 	ldw	r2,-8(fp)
81118b00:	10002315 	stw	zero,140(r2)
}
81118b04:	0001883a 	nop
81118b08:	e037883a 	mov	sp,fp
81118b0c:	df000017 	ldw	fp,0(sp)
81118b10:	dec00104 	addi	sp,sp,4
81118b14:	f800283a 	ret

81118b18 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81118b18:	defffb04 	addi	sp,sp,-20
81118b1c:	de00012e 	bgeu	sp,et,81118b24 <vNFeeStructureInit+0xc>
81118b20:	003b68fa 	trap	3
81118b24:	dfc00415 	stw	ra,16(sp)
81118b28:	df000315 	stw	fp,12(sp)
81118b2c:	df000304 	addi	fp,sp,12
81118b30:	e13ffe15 	stw	r4,-8(fp)
81118b34:	2805883a 	mov	r2,r5
81118b38:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
81118b3c:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
81118b40:	e0bffe17 	ldw	r2,-8(fp)
81118b44:	e0ffff03 	ldbu	r3,-4(fp)
81118b48:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
81118b4c:	e0bffe17 	ldw	r2,-8(fp)
81118b50:	10802f04 	addi	r2,r2,188
81118b54:	1009883a 	mov	r4,r2
81118b58:	11148540 	call	81114854 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
81118b5c:	e13ffe17 	ldw	r4,-8(fp)
81118b60:	1118c580 	call	81118c58 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
81118b64:	e0bffe17 	ldw	r2,-8(fp)
81118b68:	00c00044 	movi	r3,1
81118b6c:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81118b70:	e0bffe17 	ldw	r2,-8(fp)
81118b74:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81118b78:	e0bffe17 	ldw	r2,-8(fp)
81118b7c:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
81118b80:	e0bffe17 	ldw	r2,-8(fp)
81118b84:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
81118b88:	e0bffe17 	ldw	r2,-8(fp)
81118b8c:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
81118b90:	e0bffe17 	ldw	r2,-8(fp)
81118b94:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
81118b98:	e0bffe17 	ldw	r2,-8(fp)
81118b9c:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
81118ba0:	e0bffe17 	ldw	r2,-8(fp)
81118ba4:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
81118ba8:	e0bffe17 	ldw	r2,-8(fp)
81118bac:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
81118bb0:	e0bffe17 	ldw	r2,-8(fp)
81118bb4:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
81118bb8:	e0bffe17 	ldw	r2,-8(fp)
81118bbc:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
81118bc0:	e0bffe17 	ldw	r2,-8(fp)
81118bc4:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81118bc8:	e03ffd05 	stb	zero,-12(fp)
81118bcc:	00000906 	br	81118bf4 <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
81118bd0:	e0bffd03 	ldbu	r2,-12(fp)
81118bd4:	e0fffe17 	ldw	r3,-8(fp)
81118bd8:	1885883a 	add	r2,r3,r2
81118bdc:	10802a44 	addi	r2,r2,169
81118be0:	e0fffd03 	ldbu	r3,-12(fp)
81118be4:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81118be8:	e0bffd03 	ldbu	r2,-12(fp)
81118bec:	10800044 	addi	r2,r2,1
81118bf0:	e0bffd05 	stb	r2,-12(fp)
81118bf4:	e0bffd03 	ldbu	r2,-12(fp)
81118bf8:	10800130 	cmpltui	r2,r2,4
81118bfc:	103ff41e 	bne	r2,zero,81118bd0 <__reset+0xfb0f8bd0>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
81118c00:	e0bffe17 	ldw	r2,-8(fp)
81118c04:	10803204 	addi	r2,r2,200
81118c08:	e0ffff03 	ldbu	r3,-4(fp)
81118c0c:	180b883a 	mov	r5,r3
81118c10:	1009883a 	mov	r4,r2
81118c14:	11044b00 	call	811044b0 <bCommInitCh>
81118c18:	1000091e 	bne	r2,zero,81118c40 <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
81118c1c:	d0e05c17 	ldw	r3,-32400(gp)
81118c20:	e0bffe17 	ldw	r2,-8(fp)
81118c24:	10800003 	ldbu	r2,0(r2)
81118c28:	10803fcc 	andi	r2,r2,255
81118c2c:	100d883a 	mov	r6,r2
81118c30:	01604574 	movhi	r5,33045
81118c34:	296a1004 	addi	r5,r5,-22464
81118c38:	1809883a 	mov	r4,r3
81118c3c:	111ba9c0 	call	8111ba9c <fprintf>
		#endif
    }

}
81118c40:	0001883a 	nop
81118c44:	e037883a 	mov	sp,fp
81118c48:	dfc00117 	ldw	ra,4(sp)
81118c4c:	df000017 	ldw	fp,0(sp)
81118c50:	dec00204 	addi	sp,sp,8
81118c54:	f800283a 	ret

81118c58 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
81118c58:	defff404 	addi	sp,sp,-48
81118c5c:	de00012e 	bgeu	sp,et,81118c64 <vUpdateMemMapFEE+0xc>
81118c60:	003b68fa 	trap	3
81118c64:	df000b15 	stw	fp,44(sp)
81118c68:	df000b04 	addi	fp,sp,44
81118c6c:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
81118c70:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
81118c74:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
81118c78:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
81118c7c:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
81118c80:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
81118c84:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
81118c88:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
81118c8c:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
81118c90:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
81118c94:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
81118c98:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
81118c9c:	e17fff17 	ldw	r5,-4(fp)
81118ca0:	01035a34 	movhi	r4,3432
81118ca4:	21348c04 	addi	r4,r4,-11728
81118ca8:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
81118cac:	e13fff17 	ldw	r4,-4(fp)
81118cb0:	21000003 	ldbu	r4,0(r4)
81118cb4:	21403fcc 	andi	r5,r4,255
81118cb8:	01035a34 	movhi	r4,3432
81118cbc:	21348c04 	addi	r4,r4,-11728
81118cc0:	2909383a 	mul	r4,r5,r4
81118cc4:	200b883a 	mov	r5,r4
81118cc8:	e13fff17 	ldw	r4,-4(fp)
81118ccc:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
81118cd0:	e13fff17 	ldw	r4,-4(fp)
81118cd4:	21400117 	ldw	r5,4(r4)
81118cd8:	01033234 	movhi	r4,3272
81118cdc:	21348c04 	addi	r4,r4,-11728
81118ce0:	290b883a 	add	r5,r5,r4
81118ce4:	e13fff17 	ldw	r4,-4(fp)
81118ce8:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81118cec:	e13fff17 	ldw	r4,-4(fp)
81118cf0:	2100310b 	ldhu	r4,196(r4)
81118cf4:	217fffcc 	andi	r5,r4,65535
81118cf8:	e13fff17 	ldw	r4,-4(fp)
81118cfc:	2100300b 	ldhu	r4,192(r4)
81118d00:	213fffcc 	andi	r4,r4,65535
81118d04:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
81118d08:	e13fff17 	ldw	r4,-4(fp)
81118d0c:	2100308b 	ldhu	r4,194(r4)
81118d10:	21bfffcc 	andi	r6,r4,65535
81118d14:	e13fff17 	ldw	r4,-4(fp)
81118d18:	21002f8b 	ldhu	r4,190(r4)
81118d1c:	213fffcc 	andi	r4,r4,65535
81118d20:	310d883a 	add	r6,r6,r4
81118d24:	e13fff17 	ldw	r4,-4(fp)
81118d28:	21002f0b 	ldhu	r4,188(r4)
81118d2c:	213fffcc 	andi	r4,r4,65535
81118d30:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81118d34:	2909383a 	mul	r4,r5,r4
81118d38:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81118d3c:	e13ffa17 	ldw	r4,-24(fp)
81118d40:	2109883a 	add	r4,r4,r4
81118d44:	200b883a 	mov	r5,r4
81118d48:	e13fff17 	ldw	r4,-4(fp)
81118d4c:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81118d50:	e13fff17 	ldw	r4,-4(fp)
81118d54:	21000517 	ldw	r4,20(r4)
81118d58:	2008d0fa 	srli	r4,r4,3
81118d5c:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
81118d60:	e13fff17 	ldw	r4,-4(fp)
81118d64:	21000517 	ldw	r4,20(r4)
81118d68:	210001cc 	andi	r4,r4,7
81118d6c:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
81118d70:	e13ffb17 	ldw	r4,-20(fp)
81118d74:	20001226 	beq	r4,zero,81118dc0 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
81118d78:	e13ff517 	ldw	r4,-44(fp)
81118d7c:	21000044 	addi	r4,r4,1
81118d80:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
81118d84:	e13fff17 	ldw	r4,-4(fp)
81118d88:	21400517 	ldw	r5,20(r4)
81118d8c:	e13ffb17 	ldw	r4,-20(fp)
81118d90:	2909c83a 	sub	r4,r5,r4
81118d94:	21400204 	addi	r5,r4,8
81118d98:	e13fff17 	ldw	r4,-4(fp)
81118d9c:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
81118da0:	e13ffb17 	ldw	r4,-20(fp)
81118da4:	200b883a 	mov	r5,r4
81118da8:	01000204 	movi	r4,8
81118dac:	2149c83a 	sub	r4,r4,r5
81118db0:	200b883a 	mov	r5,r4
81118db4:	e13fff17 	ldw	r4,-4(fp)
81118db8:	21400605 	stb	r5,24(r4)
81118dbc:	00000206 	br	81118dc8 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
81118dc0:	e13fff17 	ldw	r4,-4(fp)
81118dc4:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
81118dc8:	e13ff517 	ldw	r4,-44(fp)
81118dcc:	2008d13a 	srli	r4,r4,4
81118dd0:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
81118dd4:	e13ff517 	ldw	r4,-44(fp)
81118dd8:	210003cc 	andi	r4,r4,15
81118ddc:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
81118de0:	e13ffc17 	ldw	r4,-16(fp)
81118de4:	20000b26 	beq	r4,zero,81118e14 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
81118de8:	e13ff717 	ldw	r4,-36(fp)
81118dec:	21000044 	addi	r4,r4,1
81118df0:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81118df4:	e17ff517 	ldw	r5,-44(fp)
81118df8:	e13ffc17 	ldw	r4,-16(fp)
81118dfc:	290bc83a 	sub	r5,r5,r4
81118e00:	e13ff717 	ldw	r4,-36(fp)
81118e04:	2909883a 	add	r4,r5,r4
81118e08:	21000404 	addi	r4,r4,16
81118e0c:	e13ff615 	stw	r4,-40(fp)
81118e10:	00000406 	br	81118e24 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81118e14:	e17ff517 	ldw	r5,-44(fp)
81118e18:	e13ff717 	ldw	r4,-36(fp)
81118e1c:	2909883a 	add	r4,r5,r4
81118e20:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
81118e24:	e13ff617 	ldw	r4,-40(fp)
81118e28:	200a90fa 	slli	r5,r4,3
81118e2c:	e13fff17 	ldw	r4,-4(fp)
81118e30:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81118e34:	e13ffb17 	ldw	r4,-20(fp)
81118e38:	20000926 	beq	r4,zero,81118e60 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81118e3c:	e13ffc17 	ldw	r4,-16(fp)
81118e40:	2109883a 	add	r4,r4,r4
81118e44:	2109883a 	add	r4,r4,r4
81118e48:	200b883a 	mov	r5,r4
81118e4c:	e13ffb17 	ldw	r4,-20(fp)
81118e50:	2008d07a 	srli	r4,r4,1
81118e54:	2909883a 	add	r4,r5,r4
81118e58:	e13ff805 	stb	r4,-32(fp)
81118e5c:	00000406 	br	81118e70 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
81118e60:	e13ffc17 	ldw	r4,-16(fp)
81118e64:	2109883a 	add	r4,r4,r4
81118e68:	2109883a 	add	r4,r4,r4
81118e6c:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
81118e70:	e13ff803 	ldbu	r4,-32(fp)
81118e74:	01401004 	movi	r5,64
81118e78:	2909c83a 	sub	r4,r5,r4
81118e7c:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
81118e80:	e13ffd03 	ldbu	r4,-12(fp)
81118e84:	217ff804 	addi	r5,r4,-32
81118e88:	28000416 	blt	r5,zero,81118e9c <vUpdateMemMapFEE+0x244>
81118e8c:	013fffc4 	movi	r4,-1
81118e90:	2144d83a 	srl	r2,r4,r5
81118e94:	0007883a 	mov	r3,zero
81118e98:	00000a06 	br	81118ec4 <vUpdateMemMapFEE+0x26c>
81118e9c:	017fffc4 	movi	r5,-1
81118ea0:	280c907a 	slli	r6,r5,1
81118ea4:	014007c4 	movi	r5,31
81118ea8:	290bc83a 	sub	r5,r5,r4
81118eac:	314a983a 	sll	r5,r6,r5
81118eb0:	01bfffc4 	movi	r6,-1
81118eb4:	3104d83a 	srl	r2,r6,r4
81118eb8:	2884b03a 	or	r2,r5,r2
81118ebc:	017fffc4 	movi	r5,-1
81118ec0:	2906d83a 	srl	r3,r5,r4
81118ec4:	e13fff17 	ldw	r4,-4(fp)
81118ec8:	20800715 	stw	r2,28(r4)
81118ecc:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
81118ed0:	e0bfff17 	ldw	r2,-4(fp)
81118ed4:	e0fff717 	ldw	r3,-36(fp)
81118ed8:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
81118edc:	e0bfff17 	ldw	r2,-4(fp)
81118ee0:	10c00117 	ldw	r3,4(r2)
81118ee4:	008004b4 	movhi	r2,18
81118ee8:	10a40004 	addi	r2,r2,-28672
81118eec:	1885883a 	add	r2,r3,r2
81118ef0:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
81118ef4:	e0bfff17 	ldw	r2,-4(fp)
81118ef8:	10c00517 	ldw	r3,20(r2)
81118efc:	008000b4 	movhi	r2,2
81118f00:	10a40004 	addi	r2,r2,-28672
81118f04:	1885883a 	add	r2,r3,r2
81118f08:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81118f0c:	e03ff845 	stb	zero,-31(fp)
81118f10:	00001906 	br	81118f78 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
81118f14:	e0bff843 	ldbu	r2,-31(fp)
81118f18:	e0ffff17 	ldw	r3,-4(fp)
81118f1c:	10800624 	muli	r2,r2,24
81118f20:	1885883a 	add	r2,r3,r2
81118f24:	10800904 	addi	r2,r2,36
81118f28:	e0fff917 	ldw	r3,-28(fp)
81118f2c:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81118f30:	e0fff917 	ldw	r3,-28(fp)
81118f34:	e0bffe17 	ldw	r2,-8(fp)
81118f38:	1885883a 	add	r2,r3,r2
81118f3c:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81118f40:	e0bff843 	ldbu	r2,-31(fp)
81118f44:	e0ffff17 	ldw	r3,-4(fp)
81118f48:	10800624 	muli	r2,r2,24
81118f4c:	1885883a 	add	r2,r3,r2
81118f50:	10800c04 	addi	r2,r2,48
81118f54:	e0fff917 	ldw	r3,-28(fp)
81118f58:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81118f5c:	e0fff917 	ldw	r3,-28(fp)
81118f60:	e0bffe17 	ldw	r2,-8(fp)
81118f64:	1885883a 	add	r2,r3,r2
81118f68:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81118f6c:	e0bff843 	ldbu	r2,-31(fp)
81118f70:	10800044 	addi	r2,r2,1
81118f74:	e0bff845 	stb	r2,-31(fp)
81118f78:	e0bff843 	ldbu	r2,-31(fp)
81118f7c:	10800130 	cmpltui	r2,r2,4
81118f80:	103fe41e 	bne	r2,zero,81118f14 <__reset+0xfb0f8f14>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
81118f84:	0001883a 	nop
81118f88:	e037883a 	mov	sp,fp
81118f8c:	df000017 	ldw	fp,0(sp)
81118f90:	dec00104 	addi	sp,sp,4
81118f94:	f800283a 	ret

81118f98 <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
81118f98:	defffe04 	addi	sp,sp,-8
81118f9c:	de00012e 	bgeu	sp,et,81118fa4 <vFeeSpwRMAPLoadDefault+0xc>
81118fa0:	003b68fa 	trap	3
81118fa4:	df000115 	stw	fp,4(sp)
81118fa8:	df000104 	addi	fp,sp,4
81118fac:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
81118fb0:	0001883a 	nop
81118fb4:	e037883a 	mov	sp,fp
81118fb8:	df000017 	ldw	fp,0(sp)
81118fbc:	dec00104 	addi	sp,sp,4
81118fc0:	f800283a 	ret

81118fc4 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81118fc4:	defffe04 	addi	sp,sp,-8
81118fc8:	de00012e 	bgeu	sp,et,81118fd0 <vFeeSpwRMAPChangeConfig+0xc>
81118fcc:	003b68fa 	trap	3
81118fd0:	df000115 	stw	fp,4(sp)
81118fd4:	df000104 	addi	fp,sp,4
81118fd8:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81118fdc:	0001883a 	nop
81118fe0:	e037883a 	mov	sp,fp
81118fe4:	df000017 	ldw	fp,0(sp)
81118fe8:	dec00104 	addi	sp,sp,4
81118fec:	f800283a 	ret

81118ff0 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81118ff0:	defffe04 	addi	sp,sp,-8
81118ff4:	de00012e 	bgeu	sp,et,81118ffc <vFeeSpwRMAPChangeDefault+0xc>
81118ff8:	003b68fa 	trap	3
81118ffc:	df000115 	stw	fp,4(sp)
81119000:	df000104 	addi	fp,sp,4
81119004:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
81119008:	0001883a 	nop
8111900c:	e037883a 	mov	sp,fp
81119010:	df000017 	ldw	fp,0(sp)
81119014:	dec00104 	addi	sp,sp,4
81119018:	f800283a 	ret

8111901c <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111901c:	defffe04 	addi	sp,sp,-8
81119020:	de00012e 	bgeu	sp,et,81119028 <cFeeSpwChannelEnable+0xc>
81119024:	003b68fa 	trap	3
81119028:	df000115 	stw	fp,4(sp)
8111902c:	df000104 	addi	fp,sp,4
81119030:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81119034:	0001883a 	nop
81119038:	e037883a 	mov	sp,fp
8111903c:	df000017 	ldw	fp,0(sp)
81119040:	dec00104 	addi	sp,sp,4
81119044:	f800283a 	ret

81119048 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81119048:	defffe04 	addi	sp,sp,-8
8111904c:	de00012e 	bgeu	sp,et,81119054 <cFeeSpwChannelDisable+0xc>
81119050:	003b68fa 	trap	3
81119054:	df000115 	stw	fp,4(sp)
81119058:	df000104 	addi	fp,sp,4
8111905c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81119060:	0001883a 	nop
81119064:	e037883a 	mov	sp,fp
81119068:	df000017 	ldw	fp,0(sp)
8111906c:	dec00104 	addi	sp,sp,4
81119070:	f800283a 	ret

81119074 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
81119074:	defffe04 	addi	sp,sp,-8
81119078:	de00012e 	bgeu	sp,et,81119080 <cFeeRMAPDump+0xc>
8111907c:	003b68fa 	trap	3
81119080:	df000115 	stw	fp,4(sp)
81119084:	df000104 	addi	fp,sp,4
81119088:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111908c:	0001883a 	nop
81119090:	e037883a 	mov	sp,fp
81119094:	df000017 	ldw	fp,0(sp)
81119098:	dec00104 	addi	sp,sp,4
8111909c:	f800283a 	ret

811190a0 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
811190a0:	defffe04 	addi	sp,sp,-8
811190a4:	de00012e 	bgeu	sp,et,811190ac <cFeeRMAPEchoingEnable+0xc>
811190a8:	003b68fa 	trap	3
811190ac:	df000115 	stw	fp,4(sp)
811190b0:	df000104 	addi	fp,sp,4
811190b4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
811190b8:	e0bfff17 	ldw	r2,-4(fp)
811190bc:	00c00044 	movi	r3,1
811190c0:	10c02515 	stw	r3,148(r2)
}
811190c4:	0001883a 	nop
811190c8:	e037883a 	mov	sp,fp
811190cc:	df000017 	ldw	fp,0(sp)
811190d0:	dec00104 	addi	sp,sp,4
811190d4:	f800283a 	ret

811190d8 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
811190d8:	defffe04 	addi	sp,sp,-8
811190dc:	de00012e 	bgeu	sp,et,811190e4 <cFeeRMAPEchoingDisable+0xc>
811190e0:	003b68fa 	trap	3
811190e4:	df000115 	stw	fp,4(sp)
811190e8:	df000104 	addi	fp,sp,4
811190ec:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
811190f0:	e0bfff17 	ldw	r2,-4(fp)
811190f4:	10002515 	stw	zero,148(r2)
}
811190f8:	0001883a 	nop
811190fc:	e037883a 	mov	sp,fp
81119100:	df000017 	ldw	fp,0(sp)
81119104:	dec00104 	addi	sp,sp,4
81119108:	f800283a 	ret

8111910c <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111910c:	defffe04 	addi	sp,sp,-8
81119110:	de00012e 	bgeu	sp,et,81119118 <cFeeRMAPLogEnable+0xc>
81119114:	003b68fa 	trap	3
81119118:	df000115 	stw	fp,4(sp)
8111911c:	df000104 	addi	fp,sp,4
81119120:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
81119124:	e0bfff17 	ldw	r2,-4(fp)
81119128:	00c00044 	movi	r3,1
8111912c:	10c02415 	stw	r3,144(r2)
}
81119130:	0001883a 	nop
81119134:	e037883a 	mov	sp,fp
81119138:	df000017 	ldw	fp,0(sp)
8111913c:	dec00104 	addi	sp,sp,4
81119140:	f800283a 	ret

81119144 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
81119144:	defffe04 	addi	sp,sp,-8
81119148:	de00012e 	bgeu	sp,et,81119150 <cFeeRMAPLogDisable+0xc>
8111914c:	003b68fa 	trap	3
81119150:	df000115 	stw	fp,4(sp)
81119154:	df000104 	addi	fp,sp,4
81119158:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111915c:	e0bfff17 	ldw	r2,-4(fp)
81119160:	10002415 	stw	zero,144(r2)
}
81119164:	0001883a 	nop
81119168:	e037883a 	mov	sp,fp
8111916c:	df000017 	ldw	fp,0(sp)
81119170:	dec00104 	addi	sp,sp,4
81119174:	f800283a 	ret

81119178 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
81119178:	defffc04 	addi	sp,sp,-16
8111917c:	de00012e 	bgeu	sp,et,81119184 <vNFeeControlInit+0xc>
81119180:	003b68fa 	trap	3
81119184:	dfc00315 	stw	ra,12(sp)
81119188:	df000215 	stw	fp,8(sp)
8111918c:	df000204 	addi	fp,sp,8
81119190:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
81119194:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
81119198:	e13fff17 	ldw	r4,-4(fp)
8111919c:	11192c40 	call	811192c4 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
811191a0:	e13fff17 	ldw	r4,-4(fp)
811191a4:	11192f80 	call	811192f8 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
811191a8:	e0bfff17 	ldw	r2,-4(fp)
811191ac:	10009915 	stw	zero,612(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811191b0:	e03ffe05 	stb	zero,-8(fp)
811191b4:	00002b06 	br	81119264 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
811191b8:	e0bffe03 	ldbu	r2,-8(fp)
811191bc:	10809524 	muli	r2,r2,596
811191c0:	e0ffff17 	ldw	r3,-4(fp)
811191c4:	1885883a 	add	r2,r3,r2
811191c8:	e0fffe03 	ldbu	r3,-8(fp)
811191cc:	180b883a 	mov	r5,r3
811191d0:	1009883a 	mov	r4,r2
811191d4:	1118b180 	call	81118b18 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
811191d8:	e0bffe03 	ldbu	r2,-8(fp)
811191dc:	e0fffe03 	ldbu	r3,-8(fp)
811191e0:	18c09524 	muli	r3,r3,596
811191e4:	18c02104 	addi	r3,r3,132
811191e8:	e13fff17 	ldw	r4,-4(fp)
811191ec:	20c7883a 	add	r3,r4,r3
811191f0:	e13fff17 	ldw	r4,-4(fp)
811191f4:	10802584 	addi	r2,r2,150
811191f8:	1085883a 	add	r2,r2,r2
811191fc:	1085883a 	add	r2,r2,r2
81119200:	2085883a 	add	r2,r4,r2
81119204:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
81119208:	e0bffe03 	ldbu	r2,-8(fp)
8111920c:	e0fffe03 	ldbu	r3,-8(fp)
81119210:	18c09524 	muli	r3,r3,596
81119214:	18c02704 	addi	r3,r3,156
81119218:	e13fff17 	ldw	r4,-4(fp)
8111921c:	20c7883a 	add	r3,r4,r3
81119220:	e13fff17 	ldw	r4,-4(fp)
81119224:	108025c4 	addi	r2,r2,151
81119228:	1085883a 	add	r2,r2,r2
8111922c:	1085883a 	add	r2,r2,r2
81119230:	2085883a 	add	r2,r4,r2
81119234:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
81119238:	e0bffe03 	ldbu	r2,-8(fp)
8111923c:	e0ffff17 	ldw	r3,-4(fp)
81119240:	18c09517 	ldw	r3,596(r3)
81119244:	e13fff17 	ldw	r4,-4(fp)
81119248:	10809524 	muli	r2,r2,596
8111924c:	2085883a 	add	r2,r4,r2
81119250:	10802904 	addi	r2,r2,164
81119254:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81119258:	e0bffe03 	ldbu	r2,-8(fp)
8111925c:	10800044 	addi	r2,r2,1
81119260:	e0bffe05 	stb	r2,-8(fp)
81119264:	e0bffe03 	ldbu	r2,-8(fp)
81119268:	103fd326 	beq	r2,zero,811191b8 <__reset+0xfb0f91b8>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111926c:	0001883a 	nop
81119270:	e037883a 	mov	sp,fp
81119274:	dfc00117 	ldw	ra,4(sp)
81119278:	df000017 	ldw	fp,0(sp)
8111927c:	dec00204 	addi	sp,sp,8
81119280:	f800283a 	ret

81119284 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
81119284:	defffd04 	addi	sp,sp,-12
81119288:	de00012e 	bgeu	sp,et,81119290 <vSetTimeCode+0xc>
8111928c:	003b68fa 	trap	3
81119290:	df000215 	stw	fp,8(sp)
81119294:	df000204 	addi	fp,sp,8
81119298:	e13ffe15 	stw	r4,-8(fp)
8111929c:	2805883a 	mov	r2,r5
811192a0:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
811192a4:	e0bffe17 	ldw	r2,-8(fp)
811192a8:	e0ffff03 	ldbu	r3,-4(fp)
811192ac:	10c09805 	stb	r3,608(r2)
}
811192b0:	0001883a 	nop
811192b4:	e037883a 	mov	sp,fp
811192b8:	df000017 	ldw	fp,0(sp)
811192bc:	dec00104 	addi	sp,sp,4
811192c0:	f800283a 	ret

811192c4 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
811192c4:	defffe04 	addi	sp,sp,-8
811192c8:	de00012e 	bgeu	sp,et,811192d0 <vResetTimeCode+0xc>
811192cc:	003b68fa 	trap	3
811192d0:	df000115 	stw	fp,4(sp)
811192d4:	df000104 	addi	fp,sp,4
811192d8:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
811192dc:	e0bfff17 	ldw	r2,-4(fp)
811192e0:	10009805 	stb	zero,608(r2)
}
811192e4:	0001883a 	nop
811192e8:	e037883a 	mov	sp,fp
811192ec:	df000017 	ldw	fp,0(sp)
811192f0:	dec00104 	addi	sp,sp,4
811192f4:	f800283a 	ret

811192f8 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
811192f8:	defffe04 	addi	sp,sp,-8
811192fc:	de00012e 	bgeu	sp,et,81119304 <vLoadDefaultIdNFEEMaster+0xc>
81119300:	003b68fa 	trap	3
81119304:	df000115 	stw	fp,4(sp)
81119308:	df000104 	addi	fp,sp,4
8111930c:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
81119310:	e0bfff17 	ldw	r2,-4(fp)
81119314:	10009845 	stb	zero,609(r2)
}
81119318:	0001883a 	nop
8111931c:	e037883a 	mov	sp,fp
81119320:	df000017 	ldw	fp,0(sp)
81119324:	dec00104 	addi	sp,sp,4
81119328:	f800283a 	ret

8111932c <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111932c:	defffd04 	addi	sp,sp,-12
81119330:	de00012e 	bgeu	sp,et,81119338 <vChangeIdNFEEMaster+0xc>
81119334:	003b68fa 	trap	3
81119338:	df000215 	stw	fp,8(sp)
8111933c:	df000204 	addi	fp,sp,8
81119340:	e13ffe15 	stw	r4,-8(fp)
81119344:	2805883a 	mov	r2,r5
81119348:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111934c:	e0bffe17 	ldw	r2,-8(fp)
81119350:	e0ffff03 	ldbu	r3,-4(fp)
81119354:	10c09845 	stb	r3,609(r2)
}
81119358:	0001883a 	nop
8111935c:	e037883a 	mov	sp,fp
81119360:	df000017 	ldw	fp,0(sp)
81119364:	dec00104 	addi	sp,sp,4
81119368:	f800283a 	ret

8111936c <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111936c:	defffd04 	addi	sp,sp,-12
81119370:	de00012e 	bgeu	sp,et,81119378 <vChangeDefaultIdNFEEMaster+0xc>
81119374:	003b68fa 	trap	3
81119378:	df000215 	stw	fp,8(sp)
8111937c:	df000204 	addi	fp,sp,8
81119380:	e13ffe15 	stw	r4,-8(fp)
81119384:	2805883a 	mov	r2,r5
81119388:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111938c:	0001883a 	nop
81119390:	e037883a 	mov	sp,fp
81119394:	df000017 	ldw	fp,0(sp)
81119398:	dec00104 	addi	sp,sp,4
8111939c:	f800283a 	ret

811193a0 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
811193a0:	defffe04 	addi	sp,sp,-8
811193a4:	de00012e 	bgeu	sp,et,811193ac <vInitSimucamBasicHW+0xc>
811193a8:	003b68fa 	trap	3
811193ac:	dfc00115 	stw	ra,4(sp)
811193b0:	df000015 	stw	fp,0(sp)
811193b4:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
811193b8:	01403fc4 	movi	r5,255
811193bc:	0009883a 	mov	r4,zero
811193c0:	1109ff80 	call	81109ff8 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
811193c4:	01400834 	movhi	r5,32
811193c8:	297fffc4 	addi	r5,r5,-1
811193cc:	0009883a 	mov	r4,zero
811193d0:	110a0780 	call	8110a078 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
811193d4:	01400074 	movhi	r5,1
811193d8:	01000044 	movi	r4,1
811193dc:	110a0780 	call	8110a078 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
811193e0:	0009883a 	mov	r4,zero
811193e4:	110b6540 	call	8110b654 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
811193e8:	0009883a 	mov	r4,zero
811193ec:	110b7240 	call	8110b724 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
811193f0:	01008004 	movi	r4,512
811193f4:	110b1b40 	call	8110b1b4 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
811193f8:	01008004 	movi	r4,512
811193fc:	110b1400 	call	8110b140 <vRstcReleaseDeviceReset>

}
81119400:	0001883a 	nop
81119404:	e037883a 	mov	sp,fp
81119408:	dfc00117 	ldw	ra,4(sp)
8111940c:	df000017 	ldw	fp,0(sp)
81119410:	dec00204 	addi	sp,sp,8
81119414:	f800283a 	ret

81119418 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81119418:	defffd04 	addi	sp,sp,-12
8111941c:	de00012e 	bgeu	sp,et,81119424 <bLogWriteSDCard+0xc>
81119420:	003b68fa 	trap	3
81119424:	df000215 	stw	fp,8(sp)
81119428:	df000204 	addi	fp,sp,8
8111942c:	e13ffe15 	stw	r4,-8(fp)
81119430:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81119434:	00800044 	movi	r2,1
}
81119438:	e037883a 	mov	sp,fp
8111943c:	df000017 	ldw	fp,0(sp)
81119440:	dec00104 	addi	sp,sp,4
81119444:	f800283a 	ret

81119448 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
81119448:	deffe004 	addi	sp,sp,-128
8111944c:	de00012e 	bgeu	sp,et,81119454 <vLogWriteNUC+0xc>
81119450:	003b68fa 	trap	3
81119454:	dfc01f15 	stw	ra,124(sp)
81119458:	df001e15 	stw	fp,120(sp)
8111945c:	df001e04 	addi	fp,sp,120
81119460:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81119464:	e03fe215 	stw	zero,-120(fp)
81119468:	e0bfe304 	addi	r2,fp,-116
8111946c:	00c01b84 	movi	r3,110
81119470:	180d883a 	mov	r6,r3
81119474:	000b883a 	mov	r5,zero
81119478:	1009883a 	mov	r4,r2
8111947c:	111cc9c0 	call	8111cc9c <memset>
	memset(cTemp,0,114);
81119480:	01801c84 	movi	r6,114
81119484:	000b883a 	mov	r5,zero
81119488:	e13fe204 	addi	r4,fp,-120
8111948c:	111cc9c0 	call	8111cc9c <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81119490:	e13fff17 	ldw	r4,-4(fp)
81119494:	111d6400 	call	8111d640 <strlen>
81119498:	10801c68 	cmpgeui	r2,r2,113
8111949c:	1000031e 	bne	r2,zero,811194ac <vLogWriteNUC+0x64>
811194a0:	e13fff17 	ldw	r4,-4(fp)
811194a4:	111d6400 	call	8111d640 <strlen>
811194a8:	00000106 	br	811194b0 <vLogWriteNUC+0x68>
811194ac:	00801c44 	movi	r2,113
811194b0:	100d883a 	mov	r6,r2
811194b4:	e17fff17 	ldw	r5,-4(fp)
811194b8:	e13fe204 	addi	r4,fp,-120
811194bc:	111cb4c0 	call	8111cb4c <memcpy>
	vSendLog ( cDataIn );
811194c0:	e13fff17 	ldw	r4,-4(fp)
811194c4:	11156ec0 	call	811156ec <vSendLog>
}
811194c8:	0001883a 	nop
811194cc:	e037883a 	mov	sp,fp
811194d0:	dfc00117 	ldw	ra,4(sp)
811194d4:	df000017 	ldw	fp,0(sp)
811194d8:	dec00204 	addi	sp,sp,8
811194dc:	f800283a 	ret

811194e0 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
811194e0:	defffd04 	addi	sp,sp,-12
811194e4:	de00012e 	bgeu	sp,et,811194ec <vSimucamStructureInit+0xc>
811194e8:	003b68fa 	trap	3
811194ec:	dfc00215 	stw	ra,8(sp)
811194f0:	df000115 	stw	fp,4(sp)
811194f4:	df000104 	addi	fp,sp,4
811194f8:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
811194fc:	e0bfff17 	ldw	r2,-4(fp)
81119500:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
81119504:	e0bfff17 	ldw	r2,-4(fp)
81119508:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111950c:	e13fff17 	ldw	r4,-4(fp)
81119510:	11195cc0 	call	811195cc <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81119514:	e13fff17 	ldw	r4,-4(fp)
81119518:	11196700 	call	81119670 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111951c:	e13fff17 	ldw	r4,-4(fp)
81119520:	11197180 	call	81119718 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81119524:	e13fff17 	ldw	r4,-4(fp)
81119528:	11197b80 	call	811197b8 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111952c:	e0bfff17 	ldw	r2,-4(fp)
81119530:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
81119534:	e0bfff17 	ldw	r2,-4(fp)
81119538:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111953c:	e0bfff17 	ldw	r2,-4(fp)
81119540:	00c07d04 	movi	r3,500
81119544:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
81119548:	e0bfff17 	ldw	r2,-4(fp)
8111954c:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
81119550:	e0bfff17 	ldw	r2,-4(fp)
81119554:	00c00044 	movi	r3,1
81119558:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111955c:	e0bfff17 	ldw	r2,-4(fp)
81119560:	10c00204 	addi	r3,r2,8
81119564:	e0bfff17 	ldw	r2,-4(fp)
81119568:	10c0a715 	stw	r3,668(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111956c:	e0bfff17 	ldw	r2,-4(fp)
81119570:	10c00244 	addi	r3,r2,9
81119574:	e0bfff17 	ldw	r2,-4(fp)
81119578:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111957c:	e0bfff17 	ldw	r2,-4(fp)
81119580:	10800017 	ldw	r2,0(r2)
81119584:	10000b1e 	bne	r2,zero,811195b4 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
81119588:	e0bfff17 	ldw	r2,-4(fp)
8111958c:	10801204 	addi	r2,r2,72
81119590:	1009883a 	mov	r4,r2
81119594:	11191780 	call	81119178 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
81119598:	e0bfff17 	ldw	r2,-4(fp)
8111959c:	10c00a04 	addi	r3,r2,40
811195a0:	e0bfff17 	ldw	r2,-4(fp)
811195a4:	10801204 	addi	r2,r2,72
811195a8:	100b883a 	mov	r5,r2
811195ac:	1809883a 	mov	r4,r3
811195b0:	1116ab80 	call	81116ab8 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
811195b4:	0001883a 	nop
811195b8:	e037883a 	mov	sp,fp
811195bc:	dfc00117 	ldw	ra,4(sp)
811195c0:	df000017 	ldw	fp,0(sp)
811195c4:	dec00204 	addi	sp,sp,8
811195c8:	f800283a 	ret

811195cc <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
811195cc:	defffe04 	addi	sp,sp,-8
811195d0:	de00012e 	bgeu	sp,et,811195d8 <vLoadDefaultEPValue+0xc>
811195d4:	003b68fa 	trap	3
811195d8:	df000115 	stw	fp,4(sp)
811195dc:	df000104 	addi	fp,sp,4
811195e0:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
811195e4:	e0bfff17 	ldw	r2,-4(fp)
811195e8:	00d07234 	movhi	r3,16840
811195ec:	10c00315 	stw	r3,12(r2)
}
811195f0:	0001883a 	nop
811195f4:	e037883a 	mov	sp,fp
811195f8:	df000017 	ldw	fp,0(sp)
811195fc:	dec00104 	addi	sp,sp,4
81119600:	f800283a 	ret

81119604 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81119604:	defffd04 	addi	sp,sp,-12
81119608:	de00012e 	bgeu	sp,et,81119610 <vChangeEPValue+0xc>
8111960c:	003b68fa 	trap	3
81119610:	df000215 	stw	fp,8(sp)
81119614:	df000204 	addi	fp,sp,8
81119618:	e13ffe15 	stw	r4,-8(fp)
8111961c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
81119620:	e0bffe17 	ldw	r2,-8(fp)
81119624:	e0ffff17 	ldw	r3,-4(fp)
81119628:	10c00315 	stw	r3,12(r2)
}
8111962c:	0001883a 	nop
81119630:	e037883a 	mov	sp,fp
81119634:	df000017 	ldw	fp,0(sp)
81119638:	dec00104 	addi	sp,sp,4
8111963c:	f800283a 	ret

81119640 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81119640:	defffd04 	addi	sp,sp,-12
81119644:	de00012e 	bgeu	sp,et,8111964c <vChangeDefaultEPValue+0xc>
81119648:	003b68fa 	trap	3
8111964c:	df000215 	stw	fp,8(sp)
81119650:	df000204 	addi	fp,sp,8
81119654:	e13ffe15 	stw	r4,-8(fp)
81119658:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111965c:	0001883a 	nop
81119660:	e037883a 	mov	sp,fp
81119664:	df000017 	ldw	fp,0(sp)
81119668:	dec00104 	addi	sp,sp,4
8111966c:	f800283a 	ret

81119670 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
81119670:	defffe04 	addi	sp,sp,-8
81119674:	de00012e 	bgeu	sp,et,8111967c <vLoadDefaultRTValue+0xc>
81119678:	003b68fa 	trap	3
8111967c:	df000115 	stw	fp,4(sp)
81119680:	df000104 	addi	fp,sp,4
81119684:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
81119688:	e0ffff17 	ldw	r3,-4(fp)
8111968c:	00901eb4 	movhi	r2,16506
81119690:	10a66684 	addi	r2,r2,-26214
81119694:	18800415 	stw	r2,16(r3)
}
81119698:	0001883a 	nop
8111969c:	e037883a 	mov	sp,fp
811196a0:	df000017 	ldw	fp,0(sp)
811196a4:	dec00104 	addi	sp,sp,4
811196a8:	f800283a 	ret

811196ac <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
811196ac:	defffd04 	addi	sp,sp,-12
811196b0:	de00012e 	bgeu	sp,et,811196b8 <vChangeRTValue+0xc>
811196b4:	003b68fa 	trap	3
811196b8:	df000215 	stw	fp,8(sp)
811196bc:	df000204 	addi	fp,sp,8
811196c0:	e13ffe15 	stw	r4,-8(fp)
811196c4:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
811196c8:	e0bffe17 	ldw	r2,-8(fp)
811196cc:	e0ffff17 	ldw	r3,-4(fp)
811196d0:	10c00415 	stw	r3,16(r2)
}
811196d4:	0001883a 	nop
811196d8:	e037883a 	mov	sp,fp
811196dc:	df000017 	ldw	fp,0(sp)
811196e0:	dec00104 	addi	sp,sp,4
811196e4:	f800283a 	ret

811196e8 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
811196e8:	defffd04 	addi	sp,sp,-12
811196ec:	de00012e 	bgeu	sp,et,811196f4 <vChangeDefaultRTValue+0xc>
811196f0:	003b68fa 	trap	3
811196f4:	df000215 	stw	fp,8(sp)
811196f8:	df000204 	addi	fp,sp,8
811196fc:	e13ffe15 	stw	r4,-8(fp)
81119700:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
81119704:	0001883a 	nop
81119708:	e037883a 	mov	sp,fp
8111970c:	df000017 	ldw	fp,0(sp)
81119710:	dec00104 	addi	sp,sp,4
81119714:	f800283a 	ret

81119718 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81119718:	defffe04 	addi	sp,sp,-8
8111971c:	de00012e 	bgeu	sp,et,81119724 <vLoadDefaultSyncSource+0xc>
81119720:	003b68fa 	trap	3
81119724:	df000115 	stw	fp,4(sp)
81119728:	df000104 	addi	fp,sp,4
8111972c:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
81119730:	e0bfff17 	ldw	r2,-4(fp)
81119734:	10000815 	stw	zero,32(r2)
}
81119738:	0001883a 	nop
8111973c:	e037883a 	mov	sp,fp
81119740:	df000017 	ldw	fp,0(sp)
81119744:	dec00104 	addi	sp,sp,4
81119748:	f800283a 	ret

8111974c <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111974c:	defffd04 	addi	sp,sp,-12
81119750:	de00012e 	bgeu	sp,et,81119758 <vChangeSyncSource+0xc>
81119754:	003b68fa 	trap	3
81119758:	df000215 	stw	fp,8(sp)
8111975c:	df000204 	addi	fp,sp,8
81119760:	e13ffe15 	stw	r4,-8(fp)
81119764:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
81119768:	e0bffe17 	ldw	r2,-8(fp)
8111976c:	e0ffff17 	ldw	r3,-4(fp)
81119770:	10c00815 	stw	r3,32(r2)
}
81119774:	0001883a 	nop
81119778:	e037883a 	mov	sp,fp
8111977c:	df000017 	ldw	fp,0(sp)
81119780:	dec00104 	addi	sp,sp,4
81119784:	f800283a 	ret

81119788 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81119788:	defffd04 	addi	sp,sp,-12
8111978c:	de00012e 	bgeu	sp,et,81119794 <vChangeDefaultSyncSource+0xc>
81119790:	003b68fa 	trap	3
81119794:	df000215 	stw	fp,8(sp)
81119798:	df000204 	addi	fp,sp,8
8111979c:	e13ffe15 	stw	r4,-8(fp)
811197a0:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
811197a4:	0001883a 	nop
811197a8:	e037883a 	mov	sp,fp
811197ac:	df000017 	ldw	fp,0(sp)
811197b0:	dec00104 	addi	sp,sp,4
811197b4:	f800283a 	ret

811197b8 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
811197b8:	defffe04 	addi	sp,sp,-8
811197bc:	de00012e 	bgeu	sp,et,811197c4 <vLoadDefaultAutoResetSync+0xc>
811197c0:	003b68fa 	trap	3
811197c4:	df000115 	stw	fp,4(sp)
811197c8:	df000104 	addi	fp,sp,4
811197cc:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
811197d0:	e0bfff17 	ldw	r2,-4(fp)
811197d4:	00c00044 	movi	r3,1
811197d8:	10c00915 	stw	r3,36(r2)
}
811197dc:	0001883a 	nop
811197e0:	e037883a 	mov	sp,fp
811197e4:	df000017 	ldw	fp,0(sp)
811197e8:	dec00104 	addi	sp,sp,4
811197ec:	f800283a 	ret

811197f0 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
811197f0:	defffd04 	addi	sp,sp,-12
811197f4:	de00012e 	bgeu	sp,et,811197fc <vChangeAutoResetSync+0xc>
811197f8:	003b68fa 	trap	3
811197fc:	df000215 	stw	fp,8(sp)
81119800:	df000204 	addi	fp,sp,8
81119804:	e13ffe15 	stw	r4,-8(fp)
81119808:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111980c:	e0bffe17 	ldw	r2,-8(fp)
81119810:	e0ffff17 	ldw	r3,-4(fp)
81119814:	10c00915 	stw	r3,36(r2)
}
81119818:	0001883a 	nop
8111981c:	e037883a 	mov	sp,fp
81119820:	df000017 	ldw	fp,0(sp)
81119824:	dec00104 	addi	sp,sp,4
81119828:	f800283a 	ret

8111982c <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111982c:	defffd04 	addi	sp,sp,-12
81119830:	de00012e 	bgeu	sp,et,81119838 <vChangeDefaultAutoResetSync+0xc>
81119834:	003b68fa 	trap	3
81119838:	df000215 	stw	fp,8(sp)
8111983c:	df000204 	addi	fp,sp,8
81119840:	e13ffe15 	stw	r4,-8(fp)
81119844:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
81119848:	0001883a 	nop
8111984c:	e037883a 	mov	sp,fp
81119850:	df000017 	ldw	fp,0(sp)
81119854:	dec00104 	addi	sp,sp,4
81119858:	f800283a 	ret

8111985c <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111985c:	defffc04 	addi	sp,sp,-16
81119860:	de00012e 	bgeu	sp,et,81119868 <vSyncReset+0xc>
81119864:	003b68fa 	trap	3
81119868:	dfc00315 	stw	ra,12(sp)
8111986c:	df000215 	stw	fp,8(sp)
81119870:	df000204 	addi	fp,sp,8
81119874:	e13ffe15 	stw	r4,-8(fp)
81119878:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111987c:	e0bffe17 	ldw	r2,-8(fp)
81119880:	10801204 	addi	r2,r2,72
81119884:	1009883a 	mov	r4,r2
81119888:	11192c40 	call	811192c4 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111988c:	0001883a 	nop
81119890:	e037883a 	mov	sp,fp
81119894:	dfc00117 	ldw	ra,4(sp)
81119898:	df000017 	ldw	fp,0(sp)
8111989c:	dec00204 	addi	sp,sp,8
811198a0:	f800283a 	ret

811198a4 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
811198a4:	defff004 	addi	sp,sp,-64
811198a8:	de00012e 	bgeu	sp,et,811198b0 <pattern_createPattern+0xc>
811198ac:	003b68fa 	trap	3
811198b0:	dfc00f15 	stw	ra,60(sp)
811198b4:	df000e15 	stw	fp,56(sp)
811198b8:	dcc00d15 	stw	r19,52(sp)
811198bc:	dc800c15 	stw	r18,48(sp)
811198c0:	dc400b15 	stw	r17,44(sp)
811198c4:	dc000a15 	stw	r16,40(sp)
811198c8:	df000e04 	addi	fp,sp,56
811198cc:	e17ff915 	stw	r5,-28(fp)
811198d0:	3007883a 	mov	r3,r6
811198d4:	3805883a 	mov	r2,r7
811198d8:	e13ff805 	stb	r4,-32(fp)
811198dc:	e0fffa05 	stb	r3,-24(fp)
811198e0:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
811198e4:	e0bff803 	ldbu	r2,-32(fp)
811198e8:	1009883a 	mov	r4,r2
811198ec:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
811198f0:	e0bff917 	ldw	r2,-28(fp)
811198f4:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
811198f8:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
811198fc:	e0bff217 	ldw	r2,-56(fp)
81119900:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81119904:	e03ff515 	stw	zero,-44(fp)
81119908:	00003606 	br	811199e4 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111990c:	e03ff615 	stw	zero,-40(fp)
81119910:	00002e06 	br	811199cc <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
81119914:	e0bff303 	ldbu	r2,-52(fp)
81119918:	10801018 	cmpnei	r2,r2,64
8111991c:	10000b1e 	bne	r2,zero,8111994c <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
81119920:	e0bff417 	ldw	r2,-48(fp)
81119924:	00ffffc4 	movi	r3,-1
81119928:	10c02015 	stw	r3,128(r2)
8111992c:	00ffffc4 	movi	r3,-1
81119930:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
81119934:	e0bff217 	ldw	r2,-56(fp)
81119938:	10802204 	addi	r2,r2,136
8111993c:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
81119940:	e0bff217 	ldw	r2,-56(fp)
81119944:	e0bff415 	stw	r2,-48(fp)
				i = 0;
81119948:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111994c:	e0bff303 	ldbu	r2,-52(fp)
81119950:	10c00044 	addi	r3,r2,1
81119954:	e0fff305 	stb	r3,-52(fp)
81119958:	10803fcc 	andi	r2,r2,255
8111995c:	e0fffa03 	ldbu	r3,-24(fp)
81119960:	18c000cc 	andi	r3,r3,3
81119964:	180692fa 	slli	r3,r3,11
81119968:	1809883a 	mov	r4,r3
8111996c:	00f80004 	movi	r3,-8192
81119970:	20c6b03a 	or	r3,r4,r3
81119974:	1809883a 	mov	r4,r3
81119978:	e0fffb03 	ldbu	r3,-20(fp)
8111997c:	18c0004c 	andi	r3,r3,1
81119980:	180692ba 	slli	r3,r3,10
81119984:	20c6b03a 	or	r3,r4,r3
81119988:	1809883a 	mov	r4,r3
8111998c:	e0fff517 	ldw	r3,-44(fp)
81119990:	18c007cc 	andi	r3,r3,31
81119994:	1806917a 	slli	r3,r3,5
81119998:	20c6b03a 	or	r3,r4,r3
8111999c:	1809883a 	mov	r4,r3
811199a0:	e0fff617 	ldw	r3,-40(fp)
811199a4:	18c007cc 	andi	r3,r3,31
811199a8:	20c6b03a 	or	r3,r4,r3
811199ac:	1809883a 	mov	r4,r3
811199b0:	e0fff417 	ldw	r3,-48(fp)
811199b4:	1085883a 	add	r2,r2,r2
811199b8:	1885883a 	add	r2,r3,r2
811199bc:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
811199c0:	e0bff617 	ldw	r2,-40(fp)
811199c4:	10800044 	addi	r2,r2,1
811199c8:	e0bff615 	stw	r2,-40(fp)
811199cc:	e0fff617 	ldw	r3,-40(fp)
811199d0:	e0800217 	ldw	r2,8(fp)
811199d4:	18bfcf36 	bltu	r3,r2,81119914 <__reset+0xfb0f9914>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
811199d8:	e0bff517 	ldw	r2,-44(fp)
811199dc:	10800044 	addi	r2,r2,1
811199e0:	e0bff515 	stw	r2,-44(fp)
811199e4:	e0fff517 	ldw	r3,-44(fp)
811199e8:	e0800317 	ldw	r2,12(fp)
811199ec:	18bfc736 	bltu	r3,r2,8111990c <__reset+0xfb0f990c>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
811199f0:	e0bff303 	ldbu	r2,-52(fp)
811199f4:	e0bff705 	stb	r2,-36(fp)
811199f8:	00000806 	br	81119a1c <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
811199fc:	e0bff703 	ldbu	r2,-36(fp)
81119a00:	e0fff417 	ldw	r3,-48(fp)
81119a04:	1085883a 	add	r2,r2,r2
81119a08:	1885883a 	add	r2,r3,r2
81119a0c:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81119a10:	e0bff703 	ldbu	r2,-36(fp)
81119a14:	10800044 	addi	r2,r2,1
81119a18:	e0bff705 	stb	r2,-36(fp)
81119a1c:	e0bff703 	ldbu	r2,-36(fp)
81119a20:	10801030 	cmpltui	r2,r2,64
81119a24:	103ff51e 	bne	r2,zero,811199fc <__reset+0xfb0f99fc>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
81119a28:	e0bff417 	ldw	r2,-48(fp)
81119a2c:	10002015 	stw	zero,128(r2)
81119a30:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81119a34:	e03ff745 	stb	zero,-35(fp)
81119a38:	00001106 	br	81119a80 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
81119a3c:	e13ff417 	ldw	r4,-48(fp)
81119a40:	20802017 	ldw	r2,128(r4)
81119a44:	20c02117 	ldw	r3,132(r4)
81119a48:	e13ff743 	ldbu	r4,-35(fp)
81119a4c:	01400044 	movi	r5,1
81119a50:	2908983a 	sll	r4,r5,r4
81119a54:	2025883a 	mov	r18,r4
81119a58:	2009d7fa 	srai	r4,r4,31
81119a5c:	2027883a 	mov	r19,r4
81119a60:	14a0b03a 	or	r16,r2,r18
81119a64:	1ce2b03a 	or	r17,r3,r19
81119a68:	e0bff417 	ldw	r2,-48(fp)
81119a6c:	14002015 	stw	r16,128(r2)
81119a70:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
81119a74:	e0bff743 	ldbu	r2,-35(fp)
81119a78:	10800044 	addi	r2,r2,1
81119a7c:	e0bff745 	stb	r2,-35(fp)
81119a80:	e0fff743 	ldbu	r3,-35(fp)
81119a84:	e0bff303 	ldbu	r2,-52(fp)
81119a88:	18bfec36 	bltu	r3,r2,81119a3c <__reset+0xfb0f9a3c>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
81119a8c:	e0bff217 	ldw	r2,-56(fp)
81119a90:	10802204 	addi	r2,r2,136
81119a94:	e0bff215 	stw	r2,-56(fp)
	return offset;
81119a98:	e0bff217 	ldw	r2,-56(fp)
}
81119a9c:	e6fffc04 	addi	sp,fp,-16
81119aa0:	dfc00517 	ldw	ra,20(sp)
81119aa4:	df000417 	ldw	fp,16(sp)
81119aa8:	dcc00317 	ldw	r19,12(sp)
81119aac:	dc800217 	ldw	r18,8(sp)
81119ab0:	dc400117 	ldw	r17,4(sp)
81119ab4:	dc000017 	ldw	r16,0(sp)
81119ab8:	dec00604 	addi	sp,sp,24
81119abc:	f800283a 	ret

81119ac0 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81119ac0:	defffe04 	addi	sp,sp,-8
81119ac4:	de00012e 	bgeu	sp,et,81119acc <bSDcardIsPresent+0xc>
81119ac8:	003b68fa 	trap	3
81119acc:	dfc00115 	stw	ra,4(sp)
81119ad0:	df000015 	stw	fp,0(sp)
81119ad4:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81119ad8:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
}
81119adc:	e037883a 	mov	sp,fp
81119ae0:	dfc00117 	ldw	ra,4(sp)
81119ae4:	df000017 	ldw	fp,0(sp)
81119ae8:	dec00204 	addi	sp,sp,8
81119aec:	f800283a 	ret

81119af0 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81119af0:	defffe04 	addi	sp,sp,-8
81119af4:	de00012e 	bgeu	sp,et,81119afc <bSDcardFAT16Check+0xc>
81119af8:	003b68fa 	trap	3
81119afc:	dfc00115 	stw	ra,4(sp)
81119b00:	df000015 	stw	fp,0(sp)
81119b04:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
81119b08:	113fed00 	call	8113fed0 <alt_up_sd_card_is_FAT16>
}
81119b0c:	e037883a 	mov	sp,fp
81119b10:	dfc00117 	ldw	ra,4(sp)
81119b14:	df000017 	ldw	fp,0(sp)
81119b18:	dec00204 	addi	sp,sp,8
81119b1c:	f800283a 	ret

81119b20 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81119b20:	defffd04 	addi	sp,sp,-12
81119b24:	de00012e 	bgeu	sp,et,81119b2c <bInitializeSDCard+0xc>
81119b28:	003b68fa 	trap	3
81119b2c:	dfc00215 	stw	ra,8(sp)
81119b30:	df000115 	stw	fp,4(sp)
81119b34:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
81119b38:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81119b3c:	d0207115 	stw	zero,-32316(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81119b40:	01204574 	movhi	r4,33045
81119b44:	212a1c04 	addi	r4,r4,-22416
81119b48:	113fd400 	call	8113fd40 <alt_up_sd_card_open_dev>
81119b4c:	d0a07115 	stw	r2,-32316(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81119b50:	d0a07117 	ldw	r2,-32316(gp)
81119b54:	10002226 	beq	r2,zero,81119be0 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
81119b58:	1119ac00 	call	81119ac0 <bSDcardIsPresent>
81119b5c:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81119b60:	e0bfff17 	ldw	r2,-4(fp)
81119b64:	10001626 	beq	r2,zero,81119bc0 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
81119b68:	1119af00 	call	81119af0 <bSDcardFAT16Check>
81119b6c:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81119b70:	e0bfff17 	ldw	r2,-4(fp)
81119b74:	10000a26 	beq	r2,zero,81119ba0 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
81119b78:	00800044 	movi	r2,1
81119b7c:	d0a07015 	stw	r2,-32320(gp)
				debug(fp, "SD is up.\r\n");
81119b80:	d0a05c17 	ldw	r2,-32400(gp)
81119b84:	100f883a 	mov	r7,r2
81119b88:	018002c4 	movi	r6,11
81119b8c:	01400044 	movi	r5,1
81119b90:	01204574 	movhi	r4,33045
81119b94:	212a2704 	addi	r4,r4,-22372
81119b98:	111c1380 	call	8111c138 <fwrite>
81119b9c:	00001806 	br	81119c00 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
81119ba0:	d0a05c17 	ldw	r2,-32400(gp)
81119ba4:	100f883a 	mov	r7,r2
81119ba8:	01800984 	movi	r6,38
81119bac:	01400044 	movi	r5,1
81119bb0:	01204574 	movhi	r4,33045
81119bb4:	212a2a04 	addi	r4,r4,-22360
81119bb8:	111c1380 	call	8111c138 <fwrite>
81119bbc:	00001006 	br	81119c00 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
81119bc0:	d0a05c17 	ldw	r2,-32400(gp)
81119bc4:	100f883a 	mov	r7,r2
81119bc8:	01800744 	movi	r6,29
81119bcc:	01400044 	movi	r5,1
81119bd0:	01204574 	movhi	r4,33045
81119bd4:	212a3404 	addi	r4,r4,-22320
81119bd8:	111c1380 	call	8111c138 <fwrite>
81119bdc:	00000806 	br	81119c00 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81119be0:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
81119be4:	d0a05c17 	ldw	r2,-32400(gp)
81119be8:	100f883a 	mov	r7,r2
81119bec:	018008c4 	movi	r6,35
81119bf0:	01400044 	movi	r5,1
81119bf4:	01204574 	movhi	r4,33045
81119bf8:	212a3c04 	addi	r4,r4,-22288
81119bfc:	111c1380 	call	8111c138 <fwrite>
	}

	return bSucess;
81119c00:	e0bfff17 	ldw	r2,-4(fp)
}
81119c04:	e037883a 	mov	sp,fp
81119c08:	dfc00117 	ldw	ra,4(sp)
81119c0c:	df000017 	ldw	fp,0(sp)
81119c10:	dec00204 	addi	sp,sp,8
81119c14:	f800283a 	ret

81119c18 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
81119c18:	defffd04 	addi	sp,sp,-12
81119c1c:	de00012e 	bgeu	sp,et,81119c24 <siOpenFile+0xc>
81119c20:	003b68fa 	trap	3
81119c24:	dfc00215 	stw	ra,8(sp)
81119c28:	df000115 	stw	fp,4(sp)
81119c2c:	df000104 	addi	fp,sp,4
81119c30:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81119c34:	000b883a 	mov	r5,zero
81119c38:	e13fff17 	ldw	r4,-4(fp)
81119c3c:	11403dc0 	call	811403dc <alt_up_sd_card_fopen>
}
81119c40:	e037883a 	mov	sp,fp
81119c44:	dfc00117 	ldw	ra,4(sp)
81119c48:	df000017 	ldw	fp,0(sp)
81119c4c:	dec00204 	addi	sp,sp,8
81119c50:	f800283a 	ret

81119c54 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81119c54:	defffd04 	addi	sp,sp,-12
81119c58:	de00012e 	bgeu	sp,et,81119c60 <siCloseFile+0xc>
81119c5c:	003b68fa 	trap	3
81119c60:	dfc00215 	stw	ra,8(sp)
81119c64:	df000115 	stw	fp,4(sp)
81119c68:	df000104 	addi	fp,sp,4
81119c6c:	2005883a 	mov	r2,r4
81119c70:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81119c74:	e0bfff0f 	ldh	r2,-4(fp)
81119c78:	1009883a 	mov	r4,r2
81119c7c:	11412280 	call	81141228 <alt_up_sd_card_fclose>
}
81119c80:	e037883a 	mov	sp,fp
81119c84:	dfc00117 	ldw	ra,4(sp)
81119c88:	df000017 	ldw	fp,0(sp)
81119c8c:	dec00204 	addi	sp,sp,8
81119c90:	f800283a 	ret

81119c94 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81119c94:	defffd04 	addi	sp,sp,-12
81119c98:	de00012e 	bgeu	sp,et,81119ca0 <cGetNextChar+0xc>
81119c9c:	003b68fa 	trap	3
81119ca0:	dfc00215 	stw	ra,8(sp)
81119ca4:	df000115 	stw	fp,4(sp)
81119ca8:	df000104 	addi	fp,sp,4
81119cac:	2005883a 	mov	r2,r4
81119cb0:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81119cb4:	e0bfff0f 	ldh	r2,-4(fp)
81119cb8:	1009883a 	mov	r4,r2
81119cbc:	11408800 	call	81140880 <alt_up_sd_card_read>
}
81119cc0:	e037883a 	mov	sp,fp
81119cc4:	dfc00117 	ldw	ra,4(sp)
81119cc8:	df000017 	ldw	fp,0(sp)
81119ccc:	dec00204 	addi	sp,sp,8
81119cd0:	f800283a 	ret

81119cd4 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81119cd4:	defffc04 	addi	sp,sp,-16
81119cd8:	de00012e 	bgeu	sp,et,81119ce0 <bInitSync+0xc>
81119cdc:	003b68fa 	trap	3
81119ce0:	dfc00315 	stw	ra,12(sp)
81119ce4:	df000215 	stw	fp,8(sp)
81119ce8:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
81119cec:	110b8e80 	call	8110b8e8 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
81119cf0:	d0a05c17 	ldw	r2,-32400(gp)
81119cf4:	100f883a 	mov	r7,r2
81119cf8:	01800684 	movi	r6,26
81119cfc:	01400044 	movi	r5,1
81119d00:	01204574 	movhi	r4,33045
81119d04:	212a4504 	addi	r4,r4,-22252
81119d08:	111c1380 	call	8111c138 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
81119d0c:	01004c74 	movhi	r4,305
81119d10:	210b4004 	addi	r4,r4,11520
81119d14:	110baf00 	call	8110baf0 <bSyncSetMbt>
81119d18:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119d1c:	e0bffe17 	ldw	r2,-8(fp)
81119d20:	1000091e 	bne	r2,zero,81119d48 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119d24:	d0a05c17 	ldw	r2,-32400(gp)
81119d28:	100f883a 	mov	r7,r2
81119d2c:	018005c4 	movi	r6,23
81119d30:	01400044 	movi	r5,1
81119d34:	01204574 	movhi	r4,33045
81119d38:	212a4c04 	addi	r4,r4,-22224
81119d3c:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119d40:	e0bffe17 	ldw	r2,-8(fp)
81119d44:	00006c06 	br	81119ef8 <bInitSync+0x224>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
81119d48:	01002674 	movhi	r4,153
81119d4c:	2125a004 	addi	r4,r4,-27008
81119d50:	110bb300 	call	8110bb30 <bSyncSetBt>
81119d54:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119d58:	e0bffe17 	ldw	r2,-8(fp)
81119d5c:	1000091e 	bne	r2,zero,81119d84 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119d60:	d0a05c17 	ldw	r2,-32400(gp)
81119d64:	100f883a 	mov	r7,r2
81119d68:	018005c4 	movi	r6,23
81119d6c:	01400044 	movi	r5,1
81119d70:	01204574 	movhi	r4,33045
81119d74:	212a4c04 	addi	r4,r4,-22224
81119d78:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119d7c:	e0bffe17 	ldw	r2,-8(fp)
81119d80:	00005d06 	br	81119ef8 <bInitSync+0x224>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer((alt_u32)PER);
81119d84:	0104a834 	movhi	r4,4768
81119d88:	2117c804 	addi	r4,r4,24352
81119d8c:	110bb700 	call	8110bb70 <bSyncSetPer>
81119d90:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119d94:	e0bffe17 	ldw	r2,-8(fp)
81119d98:	1000091e 	bne	r2,zero,81119dc0 <bInitSync+0xec>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119d9c:	d0a05c17 	ldw	r2,-32400(gp)
81119da0:	100f883a 	mov	r7,r2
81119da4:	018005c4 	movi	r6,23
81119da8:	01400044 	movi	r5,1
81119dac:	01204574 	movhi	r4,33045
81119db0:	212a4c04 	addi	r4,r4,-22224
81119db4:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119db8:	e0bffe17 	ldw	r2,-8(fp)
81119dbc:	00004e06 	br	81119ef8 <bInitSync+0x224>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
81119dc0:	01005f74 	movhi	r4,381
81119dc4:	211e1004 	addi	r4,r4,30784
81119dc8:	110bbb00 	call	8110bbb0 <bSyncSetOst>
81119dcc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119dd0:	e0bffe17 	ldw	r2,-8(fp)
81119dd4:	1000091e 	bne	r2,zero,81119dfc <bInitSync+0x128>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119dd8:	d0a05c17 	ldw	r2,-32400(gp)
81119ddc:	100f883a 	mov	r7,r2
81119de0:	018005c4 	movi	r6,23
81119de4:	01400044 	movi	r5,1
81119de8:	01204574 	movhi	r4,33045
81119dec:	212a4c04 	addi	r4,r4,-22224
81119df0:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119df4:	e0bffe17 	ldw	r2,-8(fp)
81119df8:	00003f06 	br	81119ef8 <bInitSync+0x224>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
81119dfc:	0009883a 	mov	r4,zero
81119e00:	110bbf00 	call	8110bbf0 <bSyncSetPolarity>
81119e04:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119e08:	e0bffe17 	ldw	r2,-8(fp)
81119e0c:	1000091e 	bne	r2,zero,81119e34 <bInitSync+0x160>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119e10:	d0a05c17 	ldw	r2,-32400(gp)
81119e14:	100f883a 	mov	r7,r2
81119e18:	018005c4 	movi	r6,23
81119e1c:	01400044 	movi	r5,1
81119e20:	01204574 	movhi	r4,33045
81119e24:	212a4c04 	addi	r4,r4,-22224
81119e28:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119e2c:	e0bffe17 	ldw	r2,-8(fp)
81119e30:	00003106 	br	81119ef8 <bInitSync+0x224>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81119e34:	01000104 	movi	r4,4
81119e38:	110bc640 	call	8110bc64 <bSyncSetNCycles>
81119e3c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119e40:	e0bffe17 	ldw	r2,-8(fp)
81119e44:	1000091e 	bne	r2,zero,81119e6c <bInitSync+0x198>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119e48:	d0a05c17 	ldw	r2,-32400(gp)
81119e4c:	100f883a 	mov	r7,r2
81119e50:	018005c4 	movi	r6,23
81119e54:	01400044 	movi	r5,1
81119e58:	01204574 	movhi	r4,33045
81119e5c:	212a4c04 	addi	r4,r4,-22224
81119e60:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119e64:	e0bffe17 	ldw	r2,-8(fp)
81119e68:	00002306 	br	81119ef8 <bInitSync+0x224>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
81119e6c:	01000044 	movi	r4,1
81119e70:	110be400 	call	8110be40 <bSyncCtrExtnIrq>
81119e74:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119e78:	e0bffe17 	ldw	r2,-8(fp)
81119e7c:	1000091e 	bne	r2,zero,81119ea4 <bInitSync+0x1d0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119e80:	d0a05c17 	ldw	r2,-32400(gp)
81119e84:	100f883a 	mov	r7,r2
81119e88:	018005c4 	movi	r6,23
81119e8c:	01400044 	movi	r5,1
81119e90:	01204574 	movhi	r4,33045
81119e94:	212a4c04 	addi	r4,r4,-22224
81119e98:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119e9c:	e0bffe17 	ldw	r2,-8(fp)
81119ea0:	00001506 	br	81119ef8 <bInitSync+0x224>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
81119ea4:	01000044 	movi	r4,1
81119ea8:	110c0080 	call	8110c008 <bSyncCtrSyncOutEnable>
81119eac:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81119eb0:	e0bffe17 	ldw	r2,-8(fp)
81119eb4:	1000091e 	bne	r2,zero,81119edc <bInitSync+0x208>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81119eb8:	d0a05c17 	ldw	r2,-32400(gp)
81119ebc:	100f883a 	mov	r7,r2
81119ec0:	018005c4 	movi	r6,23
81119ec4:	01400044 	movi	r5,1
81119ec8:	01204574 	movhi	r4,33045
81119ecc:	212a4c04 	addi	r4,r4,-22224
81119ed0:	111c1380 	call	8111c138 <fwrite>
		#endif
		return bSuccess;
81119ed4:	e0bffe17 	ldw	r2,-8(fp)
81119ed8:	00000706 	br	81119ef8 <bInitSync+0x224>
	}

	bSuccess = bSyncCtrStart();
81119edc:	110beb80 	call	8110beb8 <bSyncCtrStart>
81119ee0:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
81119ee4:	110bf0c0 	call	8110bf0c <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
81119ee8:	01000044 	movi	r4,1
81119eec:	110c4900 	call	8110c490 <bSyncIrqEnableBlank>
81119ef0:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
81119ef4:	e0bffe17 	ldw	r2,-8(fp)
}
81119ef8:	e037883a 	mov	sp,fp
81119efc:	dfc00117 	ldw	ra,4(sp)
81119f00:	df000017 	ldw	fp,0(sp)
81119f04:	dec00204 	addi	sp,sp,8
81119f08:	f800283a 	ret

81119f0c <bStartSync>:


bool bStartSync(void) {
81119f0c:	defffd04 	addi	sp,sp,-12
81119f10:	de00012e 	bgeu	sp,et,81119f18 <bStartSync+0xc>
81119f14:	003b68fa 	trap	3
81119f18:	dfc00215 	stw	ra,8(sp)
81119f1c:	df000115 	stw	fp,4(sp)
81119f20:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSuccess = bSyncCtrStart();
81119f24:	110beb80 	call	8110beb8 <bSyncCtrStart>
81119f28:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
81119f2c:	e0bfff17 	ldw	r2,-4(fp)
}
81119f30:	e037883a 	mov	sp,fp
81119f34:	dfc00117 	ldw	ra,4(sp)
81119f38:	df000017 	ldw	fp,0(sp)
81119f3c:	dec00204 	addi	sp,sp,8
81119f40:	f800283a 	ret

81119f44 <bStopSync>:

bool bStopSync(void) {
81119f44:	defffe04 	addi	sp,sp,-8
81119f48:	de00012e 	bgeu	sp,et,81119f50 <bStopSync+0xc>
81119f4c:	003b68fa 	trap	3
81119f50:	dfc00115 	stw	ra,4(sp)
81119f54:	df000015 	stw	fp,0(sp)
81119f58:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
81119f5c:	110bf0c0 	call	8110bf0c <bSyncCtrReset>
}
81119f60:	e037883a 	mov	sp,fp
81119f64:	dfc00117 	ldw	ra,4(sp)
81119f68:	df000017 	ldw	fp,0(sp)
81119f6c:	dec00204 	addi	sp,sp,8
81119f70:	f800283a 	ret

81119f74 <bClearCounterSync>:

void bClearCounterSync(void) {
81119f74:	defffe04 	addi	sp,sp,-8
81119f78:	de00012e 	bgeu	sp,et,81119f80 <bClearCounterSync+0xc>
81119f7c:	003b68fa 	trap	3
81119f80:	dfc00115 	stw	ra,4(sp)
81119f84:	df000015 	stw	fp,0(sp)
81119f88:	d839883a 	mov	fp,sp

	vSyncClearCounter();
81119f8c:	110b8bc0 	call	8110b8bc <vSyncClearCounter>
}
81119f90:	0001883a 	nop
81119f94:	e037883a 	mov	sp,fp
81119f98:	dfc00117 	ldw	ra,4(sp)
81119f9c:	df000017 	ldw	fp,0(sp)
81119fa0:	dec00204 	addi	sp,sp,8
81119fa4:	f800283a 	ret

81119fa8 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
81119fa8:	defffd04 	addi	sp,sp,-12
81119fac:	de00012e 	bgeu	sp,et,81119fb4 <bTestSimucamCriticalHW+0xc>
81119fb0:	003b68fa 	trap	3
81119fb4:	dfc00215 	stw	ra,8(sp)
81119fb8:	df000115 	stw	fp,4(sp)
81119fbc:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
81119fc0:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
81119fc4:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81119fc8:	e0bfff17 	ldw	r2,-4(fp)
81119fcc:	1000021e 	bne	r2,zero,81119fd8 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
81119fd0:	e0bfff17 	ldw	r2,-4(fp)
81119fd4:	00001106 	br	8111a01c <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
81119fd8:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
81119fdc:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81119fe0:	e0bfff17 	ldw	r2,-4(fp)
81119fe4:	1000021e 	bne	r2,zero,81119ff0 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
81119fe8:	e0bfff17 	ldw	r2,-4(fp)
81119fec:	00000b06 	br	8111a01c <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
81119ff0:	00a045b4 	movhi	r2,33046
81119ff4:	10b6a304 	addi	r2,r2,-9588
81119ff8:	00e04434 	movhi	r3,33040
81119ffc:	18cf2404 	addi	r3,r3,15504
8111a000:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111a004:	00a045b4 	movhi	r2,33046
8111a008:	10b6a304 	addi	r2,r2,-9588
8111a00c:	00e04434 	movhi	r3,33040
8111a010:	18d02704 	addi	r3,r3,16540
8111a014:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111a018:	00800044 	movi	r2,1
}
8111a01c:	e037883a 	mov	sp,fp
8111a020:	dfc00117 	ldw	ra,4(sp)
8111a024:	df000017 	ldw	fp,0(sp)
8111a028:	dec00204 	addi	sp,sp,8
8111a02c:	f800283a 	ret

8111a030 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111a030:	defffc04 	addi	sp,sp,-16
8111a034:	de00012e 	bgeu	sp,et,8111a03c <_reg_write+0xc>
8111a038:	003b68fa 	trap	3
8111a03c:	df000315 	stw	fp,12(sp)
8111a040:	df000304 	addi	fp,sp,12
8111a044:	e13ffd15 	stw	r4,-12(fp)
8111a048:	e17ffe15 	stw	r5,-8(fp)
8111a04c:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111a050:	e0bffe17 	ldw	r2,-8(fp)
8111a054:	1085883a 	add	r2,r2,r2
8111a058:	1085883a 	add	r2,r2,r2
8111a05c:	1007883a 	mov	r3,r2
8111a060:	e0bffd17 	ldw	r2,-12(fp)
8111a064:	1885883a 	add	r2,r3,r2
8111a068:	1007883a 	mov	r3,r2
8111a06c:	e0bfff17 	ldw	r2,-4(fp)
8111a070:	18800035 	stwio	r2,0(r3)
	return 1;
8111a074:	00800044 	movi	r2,1

}
8111a078:	e037883a 	mov	sp,fp
8111a07c:	df000017 	ldw	fp,0(sp)
8111a080:	dec00104 	addi	sp,sp,4
8111a084:	f800283a 	ret

8111a088 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111a088:	defffc04 	addi	sp,sp,-16
8111a08c:	de00012e 	bgeu	sp,et,8111a094 <_reg_read+0xc>
8111a090:	003b68fa 	trap	3
8111a094:	df000315 	stw	fp,12(sp)
8111a098:	df000304 	addi	fp,sp,12
8111a09c:	e13ffd15 	stw	r4,-12(fp)
8111a0a0:	e17ffe15 	stw	r5,-8(fp)
8111a0a4:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111a0a8:	e0bffe17 	ldw	r2,-8(fp)
8111a0ac:	1085883a 	add	r2,r2,r2
8111a0b0:	1085883a 	add	r2,r2,r2
8111a0b4:	1007883a 	mov	r3,r2
8111a0b8:	e0bffd17 	ldw	r2,-12(fp)
8111a0bc:	1885883a 	add	r2,r3,r2
8111a0c0:	10c00037 	ldwio	r3,0(r2)
8111a0c4:	e0bfff17 	ldw	r2,-4(fp)
8111a0c8:	10c00015 	stw	r3,0(r2)
	return 1;
8111a0cc:	00800044 	movi	r2,1

}
8111a0d0:	e037883a 	mov	sp,fp
8111a0d4:	df000017 	ldw	fp,0(sp)
8111a0d8:	dec00104 	addi	sp,sp,4
8111a0dc:	f800283a 	ret

8111a0e0 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111a0e0:	defffa04 	addi	sp,sp,-24
8111a0e4:	de00012e 	bgeu	sp,et,8111a0ec <_print_codec_status+0xc>
8111a0e8:	003b68fa 	trap	3
8111a0ec:	dfc00515 	stw	ra,20(sp)
8111a0f0:	df000415 	stw	fp,16(sp)
8111a0f4:	df000404 	addi	fp,sp,16
8111a0f8:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111a0fc:	e0bfff17 	ldw	r2,-4(fp)
8111a100:	1005d1ba 	srai	r2,r2,6
8111a104:	1080004c 	andi	r2,r2,1
8111a108:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111a10c:	e0bfff17 	ldw	r2,-4(fp)
8111a110:	1005d17a 	srai	r2,r2,5
8111a114:	1080004c 	andi	r2,r2,1
8111a118:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111a11c:	e0bfff17 	ldw	r2,-4(fp)
8111a120:	1005d13a 	srai	r2,r2,4
8111a124:	1080004c 	andi	r2,r2,1
8111a128:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111a12c:	00e04574 	movhi	r3,33045
8111a130:	18f63004 	addi	r3,r3,-10048
8111a134:	00a04574 	movhi	r2,33045
8111a138:	10aa5204 	addi	r2,r2,-22200
8111a13c:	1009883a 	mov	r4,r2
8111a140:	008005c4 	movi	r2,23
8111a144:	100d883a 	mov	r6,r2
8111a148:	200b883a 	mov	r5,r4
8111a14c:	1809883a 	mov	r4,r3
8111a150:	111cb4c0 	call	8111cb4c <memcpy>
	debug(fp, cDebugBuffer);
8111a154:	d0a05c17 	ldw	r2,-32400(gp)
8111a158:	01604574 	movhi	r5,33045
8111a15c:	29763004 	addi	r5,r5,-10048
8111a160:	1009883a 	mov	r4,r2
8111a164:	111ba9c0 	call	8111ba9c <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111a168:	e0bffc17 	ldw	r2,-16(fp)
8111a16c:	10800058 	cmpnei	r2,r2,1
8111a170:	1000031e 	bne	r2,zero,8111a180 <_print_codec_status+0xa0>
8111a174:	00a04574 	movhi	r2,33045
8111a178:	10aa5804 	addi	r2,r2,-22176
8111a17c:	00000206 	br	8111a188 <_print_codec_status+0xa8>
8111a180:	00a04574 	movhi	r2,33045
8111a184:	10aa5904 	addi	r2,r2,-22172
8111a188:	100d883a 	mov	r6,r2
8111a18c:	01604574 	movhi	r5,33045
8111a190:	296a5a04 	addi	r5,r5,-22168
8111a194:	01204574 	movhi	r4,33045
8111a198:	21363004 	addi	r4,r4,-10048
8111a19c:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
8111a1a0:	d0a05c17 	ldw	r2,-32400(gp)
8111a1a4:	01604574 	movhi	r5,33045
8111a1a8:	29763004 	addi	r5,r5,-10048
8111a1ac:	1009883a 	mov	r4,r2
8111a1b0:	111ba9c0 	call	8111ba9c <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111a1b4:	e0bffd17 	ldw	r2,-12(fp)
8111a1b8:	10800058 	cmpnei	r2,r2,1
8111a1bc:	1000031e 	bne	r2,zero,8111a1cc <_print_codec_status+0xec>
8111a1c0:	00a04574 	movhi	r2,33045
8111a1c4:	10aa5804 	addi	r2,r2,-22176
8111a1c8:	00000206 	br	8111a1d4 <_print_codec_status+0xf4>
8111a1cc:	00a04574 	movhi	r2,33045
8111a1d0:	10aa5904 	addi	r2,r2,-22172
8111a1d4:	100d883a 	mov	r6,r2
8111a1d8:	01604574 	movhi	r5,33045
8111a1dc:	296a6004 	addi	r5,r5,-22144
8111a1e0:	01204574 	movhi	r4,33045
8111a1e4:	21363004 	addi	r4,r4,-10048
8111a1e8:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
8111a1ec:	d0a05c17 	ldw	r2,-32400(gp)
8111a1f0:	01604574 	movhi	r5,33045
8111a1f4:	29763004 	addi	r5,r5,-10048
8111a1f8:	1009883a 	mov	r4,r2
8111a1fc:	111ba9c0 	call	8111ba9c <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111a200:	e0bffe17 	ldw	r2,-8(fp)
8111a204:	10800058 	cmpnei	r2,r2,1
8111a208:	1000031e 	bne	r2,zero,8111a218 <_print_codec_status+0x138>
8111a20c:	00a04574 	movhi	r2,33045
8111a210:	10aa5804 	addi	r2,r2,-22176
8111a214:	00000206 	br	8111a220 <_print_codec_status+0x140>
8111a218:	00a04574 	movhi	r2,33045
8111a21c:	10aa5904 	addi	r2,r2,-22172
8111a220:	100d883a 	mov	r6,r2
8111a224:	01604574 	movhi	r5,33045
8111a228:	296a6604 	addi	r5,r5,-22120
8111a22c:	01204574 	movhi	r4,33045
8111a230:	21363004 	addi	r4,r4,-10048
8111a234:	111d42c0 	call	8111d42c <sprintf>
	debug(fp, cDebugBuffer);
8111a238:	d0a05c17 	ldw	r2,-32400(gp)
8111a23c:	01604574 	movhi	r5,33045
8111a240:	29763004 	addi	r5,r5,-10048
8111a244:	1009883a 	mov	r4,r2
8111a248:	111ba9c0 	call	8111ba9c <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111a24c:	00a04574 	movhi	r2,33045
8111a250:	10b63004 	addi	r2,r2,-10048
8111a254:	00c00b44 	movi	r3,45
8111a258:	10c00005 	stb	r3,0(r2)
8111a25c:	00c00b44 	movi	r3,45
8111a260:	10c00045 	stb	r3,1(r2)
8111a264:	00c00b44 	movi	r3,45
8111a268:	10c00085 	stb	r3,2(r2)
8111a26c:	00c00b44 	movi	r3,45
8111a270:	10c000c5 	stb	r3,3(r2)
8111a274:	00c00b44 	movi	r3,45
8111a278:	10c00105 	stb	r3,4(r2)
8111a27c:	00c00b44 	movi	r3,45
8111a280:	10c00145 	stb	r3,5(r2)
8111a284:	00c00b44 	movi	r3,45
8111a288:	10c00185 	stb	r3,6(r2)
8111a28c:	00c00b44 	movi	r3,45
8111a290:	10c001c5 	stb	r3,7(r2)
8111a294:	00c00804 	movi	r3,32
8111a298:	10c00205 	stb	r3,8(r2)
8111a29c:	00c00804 	movi	r3,32
8111a2a0:	10c00245 	stb	r3,9(r2)
8111a2a4:	00c00284 	movi	r3,10
8111a2a8:	10c00285 	stb	r3,10(r2)
8111a2ac:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111a2b0:	d0a05c17 	ldw	r2,-32400(gp)
8111a2b4:	01604574 	movhi	r5,33045
8111a2b8:	29763004 	addi	r5,r5,-10048
8111a2bc:	1009883a 	mov	r4,r2
8111a2c0:	111ba9c0 	call	8111ba9c <fprintf>
#endif
}
8111a2c4:	0001883a 	nop
8111a2c8:	e037883a 	mov	sp,fp
8111a2cc:	dfc00117 	ldw	ra,4(sp)
8111a2d0:	df000017 	ldw	fp,0(sp)
8111a2d4:	dec00204 	addi	sp,sp,8
8111a2d8:	f800283a 	ret

8111a2dc <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111a2dc:	defffb04 	addi	sp,sp,-20
8111a2e0:	de00012e 	bgeu	sp,et,8111a2e8 <_split_codec_status+0xc>
8111a2e4:	003b68fa 	trap	3
8111a2e8:	df000415 	stw	fp,16(sp)
8111a2ec:	df000404 	addi	fp,sp,16
8111a2f0:	e13ffc15 	stw	r4,-16(fp)
8111a2f4:	e17ffd15 	stw	r5,-12(fp)
8111a2f8:	e1bffe15 	stw	r6,-8(fp)
8111a2fc:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111a300:	e0bffc17 	ldw	r2,-16(fp)
8111a304:	1005d1ba 	srai	r2,r2,6
8111a308:	10c0004c 	andi	r3,r2,1
8111a30c:	e0bffd17 	ldw	r2,-12(fp)
8111a310:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111a314:	e0bffc17 	ldw	r2,-16(fp)
8111a318:	1005d17a 	srai	r2,r2,5
8111a31c:	10c0004c 	andi	r3,r2,1
8111a320:	e0bffe17 	ldw	r2,-8(fp)
8111a324:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111a328:	e0bffc17 	ldw	r2,-16(fp)
8111a32c:	1005d13a 	srai	r2,r2,4
8111a330:	10c0004c 	andi	r3,r2,1
8111a334:	e0bfff17 	ldw	r2,-4(fp)
8111a338:	10c00015 	stw	r3,0(r2)
}
8111a33c:	0001883a 	nop
8111a340:	e037883a 	mov	sp,fp
8111a344:	df000017 	ldw	fp,0(sp)
8111a348:	dec00104 	addi	sp,sp,4
8111a34c:	f800283a 	ret

8111a350 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111a350:	defffc04 	addi	sp,sp,-16
8111a354:	de00012e 	bgeu	sp,et,8111a35c <aatoh+0xc>
8111a358:	003b68fa 	trap	3
8111a35c:	df000315 	stw	fp,12(sp)
8111a360:	df000304 	addi	fp,sp,12
8111a364:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111a368:	e0bfff17 	ldw	r2,-4(fp)
8111a36c:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111a370:	e0bffd17 	ldw	r2,-12(fp)
8111a374:	10c00003 	ldbu	r3,0(r2)
8111a378:	e0bffd17 	ldw	r2,-12(fp)
8111a37c:	10800003 	ldbu	r2,0(r2)
8111a380:	10803fcc 	andi	r2,r2,255
8111a384:	10800eb0 	cmpltui	r2,r2,58
8111a388:	1000021e 	bne	r2,zero,8111a394 <aatoh+0x44>
8111a38c:	00800dc4 	movi	r2,55
8111a390:	00000106 	br	8111a398 <aatoh+0x48>
8111a394:	00800c04 	movi	r2,48
8111a398:	1885c83a 	sub	r2,r3,r2
8111a39c:	1004913a 	slli	r2,r2,4
8111a3a0:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111a3a4:	e0bffd17 	ldw	r2,-12(fp)
8111a3a8:	10800044 	addi	r2,r2,1
8111a3ac:	10c00003 	ldbu	r3,0(r2)
8111a3b0:	e0bffd17 	ldw	r2,-12(fp)
8111a3b4:	10800044 	addi	r2,r2,1
8111a3b8:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111a3bc:	10803fcc 	andi	r2,r2,255
8111a3c0:	10800eb0 	cmpltui	r2,r2,58
8111a3c4:	1000021e 	bne	r2,zero,8111a3d0 <aatoh+0x80>
8111a3c8:	00800dc4 	movi	r2,55
8111a3cc:	00000106 	br	8111a3d4 <aatoh+0x84>
8111a3d0:	00800c04 	movi	r2,48
8111a3d4:	1885c83a 	sub	r2,r3,r2
8111a3d8:	2085883a 	add	r2,r4,r2
8111a3dc:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111a3e0:	e0bffe03 	ldbu	r2,-8(fp)
}
8111a3e4:	e037883a 	mov	sp,fp
8111a3e8:	df000017 	ldw	fp,0(sp)
8111a3ec:	dec00104 	addi	sp,sp,4
8111a3f0:	f800283a 	ret

8111a3f4 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111a3f4:	defffd04 	addi	sp,sp,-12
8111a3f8:	de00012e 	bgeu	sp,et,8111a400 <Verif_Error+0xc>
8111a3fc:	003b68fa 	trap	3
8111a400:	dfc00215 	stw	ra,8(sp)
8111a404:	df000115 	stw	fp,4(sp)
8111a408:	df000104 	addi	fp,sp,4
8111a40c:	2005883a 	mov	r2,r4
8111a410:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111a414:	e0bfff03 	ldbu	r2,-4(fp)
8111a418:	1000091e 	bne	r2,zero,8111a440 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111a41c:	d0a05c17 	ldw	r2,-32400(gp)
8111a420:	100f883a 	mov	r7,r2
8111a424:	018001c4 	movi	r6,7
8111a428:	01400044 	movi	r5,1
8111a42c:	01204574 	movhi	r4,33045
8111a430:	212a6c04 	addi	r4,r4,-22096
8111a434:	111c1380 	call	8111c138 <fwrite>
#endif
		return 0;
8111a438:	0005883a 	mov	r2,zero
8111a43c:	00000106 	br	8111a444 <Verif_Error+0x50>
	} else
		return 1;
8111a440:	00800044 	movi	r2,1
}
8111a444:	e037883a 	mov	sp,fp
8111a448:	dfc00117 	ldw	ra,4(sp)
8111a44c:	df000017 	ldw	fp,0(sp)
8111a450:	dec00204 	addi	sp,sp,8
8111a454:	f800283a 	ret

8111a458 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111a458:	defffe04 	addi	sp,sp,-8
8111a45c:	de00012e 	bgeu	sp,et,8111a464 <toInt+0xc>
8111a460:	003b68fa 	trap	3
8111a464:	df000115 	stw	fp,4(sp)
8111a468:	df000104 	addi	fp,sp,4
8111a46c:	2005883a 	mov	r2,r4
8111a470:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111a474:	e0bfff03 	ldbu	r2,-4(fp)
8111a478:	10bff404 	addi	r2,r2,-48
}
8111a47c:	e037883a 	mov	sp,fp
8111a480:	df000017 	ldw	fp,0(sp)
8111a484:	dec00104 	addi	sp,sp,4
8111a488:	f800283a 	ret

8111a48c <__divsf3>:
8111a48c:	defff504 	addi	sp,sp,-44
8111a490:	200cd5fa 	srli	r6,r4,23
8111a494:	de00012e 	bgeu	sp,et,8111a49c <__divsf3+0x10>
8111a498:	003b68fa 	trap	3
8111a49c:	dcc00415 	stw	r19,16(sp)
8111a4a0:	2026d7fa 	srli	r19,r4,31
8111a4a4:	00c02034 	movhi	r3,128
8111a4a8:	dd800715 	stw	r22,28(sp)
8111a4ac:	dd000515 	stw	r20,20(sp)
8111a4b0:	dc800315 	stw	r18,12(sp)
8111a4b4:	18ffffc4 	addi	r3,r3,-1
8111a4b8:	dfc00a15 	stw	ra,40(sp)
8111a4bc:	df000915 	stw	fp,36(sp)
8111a4c0:	ddc00815 	stw	r23,32(sp)
8111a4c4:	dd400615 	stw	r21,24(sp)
8111a4c8:	dc400215 	stw	r17,8(sp)
8111a4cc:	dc000115 	stw	r16,4(sp)
8111a4d0:	35003fcc 	andi	r20,r6,255
8111a4d4:	1924703a 	and	r18,r3,r4
8111a4d8:	9d803fcc 	andi	r22,r19,255
8111a4dc:	a0005226 	beq	r20,zero,8111a628 <__divsf3+0x19c>
8111a4e0:	00803fc4 	movi	r2,255
8111a4e4:	a0802e26 	beq	r20,r2,8111a5a0 <__divsf3+0x114>
8111a4e8:	91002034 	orhi	r4,r18,128
8111a4ec:	202490fa 	slli	r18,r4,3
8111a4f0:	a53fe044 	addi	r20,r20,-127
8111a4f4:	0021883a 	mov	r16,zero
8111a4f8:	002f883a 	mov	r23,zero
8111a4fc:	280cd5fa 	srli	r6,r5,23
8111a500:	282ad7fa 	srli	r21,r5,31
8111a504:	00c02034 	movhi	r3,128
8111a508:	18ffffc4 	addi	r3,r3,-1
8111a50c:	31803fcc 	andi	r6,r6,255
8111a510:	1962703a 	and	r17,r3,r5
8111a514:	af003fcc 	andi	fp,r21,255
8111a518:	30004a26 	beq	r6,zero,8111a644 <__divsf3+0x1b8>
8111a51c:	00803fc4 	movi	r2,255
8111a520:	30804526 	beq	r6,r2,8111a638 <__divsf3+0x1ac>
8111a524:	89402034 	orhi	r5,r17,128
8111a528:	282290fa 	slli	r17,r5,3
8111a52c:	31bfe044 	addi	r6,r6,-127
8111a530:	000b883a 	mov	r5,zero
8111a534:	2c20b03a 	or	r16,r5,r16
8111a538:	802090ba 	slli	r16,r16,2
8111a53c:	00a044b4 	movhi	r2,33042
8111a540:	10a95804 	addi	r2,r2,-23200
8111a544:	80a1883a 	add	r16,r16,r2
8111a548:	81000017 	ldw	r4,0(r16)
8111a54c:	9d46f03a 	xor	r3,r19,r21
8111a550:	180f883a 	mov	r7,r3
8111a554:	18803fcc 	andi	r2,r3,255
8111a558:	a18dc83a 	sub	r6,r20,r6
8111a55c:	2000683a 	jmp	r4
8111a560:	8111a744 	addi	r4,r16,18077
8111a564:	8111a5c8 	cmpgei	r4,r16,18071
8111a568:	8111a738 	rdprs	r4,r16,18076
8111a56c:	8111a5b4 	orhi	r4,r16,18070
8111a570:	8111a738 	rdprs	r4,r16,18076
8111a574:	8111a710 	cmplti	r4,r16,18076
8111a578:	8111a738 	rdprs	r4,r16,18076
8111a57c:	8111a5b4 	orhi	r4,r16,18070
8111a580:	8111a5c8 	cmpgei	r4,r16,18071
8111a584:	8111a5c8 	cmpgei	r4,r16,18071
8111a588:	8111a710 	cmplti	r4,r16,18076
8111a58c:	8111a5b4 	orhi	r4,r16,18070
8111a590:	8111a824 	muli	r4,r16,18080
8111a594:	8111a824 	muli	r4,r16,18080
8111a598:	8111a824 	muli	r4,r16,18080
8111a59c:	8111a7d8 	cmpnei	r4,r16,18079
8111a5a0:	9000581e 	bne	r18,zero,8111a704 <__divsf3+0x278>
8111a5a4:	04000204 	movi	r16,8
8111a5a8:	05c00084 	movi	r23,2
8111a5ac:	003fd306 	br	8111a4fc <__reset+0xfb0fa4fc>
8111a5b0:	0023883a 	mov	r17,zero
8111a5b4:	e02d883a 	mov	r22,fp
8111a5b8:	282f883a 	mov	r23,r5
8111a5bc:	00800084 	movi	r2,2
8111a5c0:	b8808f1e 	bne	r23,r2,8111a800 <__divsf3+0x374>
8111a5c4:	b005883a 	mov	r2,r22
8111a5c8:	11c0004c 	andi	r7,r2,1
8111a5cc:	013fffc4 	movi	r4,-1
8111a5d0:	000d883a 	mov	r6,zero
8111a5d4:	21003fcc 	andi	r4,r4,255
8111a5d8:	200895fa 	slli	r4,r4,23
8111a5dc:	38803fcc 	andi	r2,r7,255
8111a5e0:	00c02034 	movhi	r3,128
8111a5e4:	100497fa 	slli	r2,r2,31
8111a5e8:	18ffffc4 	addi	r3,r3,-1
8111a5ec:	30c6703a 	and	r3,r6,r3
8111a5f0:	1906b03a 	or	r3,r3,r4
8111a5f4:	1884b03a 	or	r2,r3,r2
8111a5f8:	dfc00a17 	ldw	ra,40(sp)
8111a5fc:	df000917 	ldw	fp,36(sp)
8111a600:	ddc00817 	ldw	r23,32(sp)
8111a604:	dd800717 	ldw	r22,28(sp)
8111a608:	dd400617 	ldw	r21,24(sp)
8111a60c:	dd000517 	ldw	r20,20(sp)
8111a610:	dcc00417 	ldw	r19,16(sp)
8111a614:	dc800317 	ldw	r18,12(sp)
8111a618:	dc400217 	ldw	r17,8(sp)
8111a61c:	dc000117 	ldw	r16,4(sp)
8111a620:	dec00b04 	addi	sp,sp,44
8111a624:	f800283a 	ret
8111a628:	90002b1e 	bne	r18,zero,8111a6d8 <__divsf3+0x24c>
8111a62c:	04000104 	movi	r16,4
8111a630:	05c00044 	movi	r23,1
8111a634:	003fb106 	br	8111a4fc <__reset+0xfb0fa4fc>
8111a638:	8800251e 	bne	r17,zero,8111a6d0 <__divsf3+0x244>
8111a63c:	01400084 	movi	r5,2
8111a640:	00000206 	br	8111a64c <__divsf3+0x1c0>
8111a644:	88001a1e 	bne	r17,zero,8111a6b0 <__divsf3+0x224>
8111a648:	01400044 	movi	r5,1
8111a64c:	8160b03a 	or	r16,r16,r5
8111a650:	802090ba 	slli	r16,r16,2
8111a654:	00e044b4 	movhi	r3,33042
8111a658:	18e99c04 	addi	r3,r3,-22928
8111a65c:	80e1883a 	add	r16,r16,r3
8111a660:	80c00017 	ldw	r3,0(r16)
8111a664:	9d44f03a 	xor	r2,r19,r21
8111a668:	a18dc83a 	sub	r6,r20,r6
8111a66c:	1800683a 	jmp	r3
8111a670:	8111a5c8 	cmpgei	r4,r16,18071
8111a674:	8111a5c8 	cmpgei	r4,r16,18071
8111a678:	8111a814 	ori	r4,r16,18080
8111a67c:	8111a5b0 	cmpltui	r4,r16,18070
8111a680:	8111a814 	ori	r4,r16,18080
8111a684:	8111a710 	cmplti	r4,r16,18076
8111a688:	8111a814 	ori	r4,r16,18080
8111a68c:	8111a5b0 	cmpltui	r4,r16,18070
8111a690:	8111a5c8 	cmpgei	r4,r16,18071
8111a694:	8111a5c8 	cmpgei	r4,r16,18071
8111a698:	8111a710 	cmplti	r4,r16,18076
8111a69c:	8111a5b0 	cmpltui	r4,r16,18070
8111a6a0:	8111a824 	muli	r4,r16,18080
8111a6a4:	8111a824 	muli	r4,r16,18080
8111a6a8:	8111a824 	muli	r4,r16,18080
8111a6ac:	8111a83c 	xorhi	r4,r16,18080
8111a6b0:	8809883a 	mov	r4,r17
8111a6b4:	111b8dc0 	call	8111b8dc <__clzsi2>
8111a6b8:	10fffec4 	addi	r3,r2,-5
8111a6bc:	10801d84 	addi	r2,r2,118
8111a6c0:	88e2983a 	sll	r17,r17,r3
8111a6c4:	008dc83a 	sub	r6,zero,r2
8111a6c8:	000b883a 	mov	r5,zero
8111a6cc:	003f9906 	br	8111a534 <__reset+0xfb0fa534>
8111a6d0:	014000c4 	movi	r5,3
8111a6d4:	003f9706 	br	8111a534 <__reset+0xfb0fa534>
8111a6d8:	9009883a 	mov	r4,r18
8111a6dc:	d9400015 	stw	r5,0(sp)
8111a6e0:	111b8dc0 	call	8111b8dc <__clzsi2>
8111a6e4:	10fffec4 	addi	r3,r2,-5
8111a6e8:	11801d84 	addi	r6,r2,118
8111a6ec:	90e4983a 	sll	r18,r18,r3
8111a6f0:	01a9c83a 	sub	r20,zero,r6
8111a6f4:	0021883a 	mov	r16,zero
8111a6f8:	002f883a 	mov	r23,zero
8111a6fc:	d9400017 	ldw	r5,0(sp)
8111a700:	003f7e06 	br	8111a4fc <__reset+0xfb0fa4fc>
8111a704:	04000304 	movi	r16,12
8111a708:	05c000c4 	movi	r23,3
8111a70c:	003f7b06 	br	8111a4fc <__reset+0xfb0fa4fc>
8111a710:	01802034 	movhi	r6,128
8111a714:	000f883a 	mov	r7,zero
8111a718:	31bfffc4 	addi	r6,r6,-1
8111a71c:	013fffc4 	movi	r4,-1
8111a720:	003fac06 	br	8111a5d4 <__reset+0xfb0fa5d4>
8111a724:	01400044 	movi	r5,1
8111a728:	2909c83a 	sub	r4,r5,r4
8111a72c:	00c006c4 	movi	r3,27
8111a730:	19004b0e 	bge	r3,r4,8111a860 <__divsf3+0x3d4>
8111a734:	114e703a 	and	r7,r2,r5
8111a738:	0009883a 	mov	r4,zero
8111a73c:	000d883a 	mov	r6,zero
8111a740:	003fa406 	br	8111a5d4 <__reset+0xfb0fa5d4>
8111a744:	9006917a 	slli	r3,r18,5
8111a748:	8822917a 	slli	r17,r17,5
8111a74c:	1c40372e 	bgeu	r3,r17,8111a82c <__divsf3+0x3a0>
8111a750:	31bfffc4 	addi	r6,r6,-1
8111a754:	010006c4 	movi	r4,27
8111a758:	000b883a 	mov	r5,zero
8111a75c:	180f883a 	mov	r7,r3
8111a760:	294b883a 	add	r5,r5,r5
8111a764:	18c7883a 	add	r3,r3,r3
8111a768:	38000116 	blt	r7,zero,8111a770 <__divsf3+0x2e4>
8111a76c:	1c400236 	bltu	r3,r17,8111a778 <__divsf3+0x2ec>
8111a770:	1c47c83a 	sub	r3,r3,r17
8111a774:	29400054 	ori	r5,r5,1
8111a778:	213fffc4 	addi	r4,r4,-1
8111a77c:	203ff71e 	bne	r4,zero,8111a75c <__reset+0xfb0fa75c>
8111a780:	1806c03a 	cmpne	r3,r3,zero
8111a784:	1962b03a 	or	r17,r3,r5
8111a788:	31001fc4 	addi	r4,r6,127
8111a78c:	013fe50e 	bge	zero,r4,8111a724 <__reset+0xfb0fa724>
8111a790:	88c001cc 	andi	r3,r17,7
8111a794:	18000426 	beq	r3,zero,8111a7a8 <__divsf3+0x31c>
8111a798:	88c003cc 	andi	r3,r17,15
8111a79c:	01400104 	movi	r5,4
8111a7a0:	19400126 	beq	r3,r5,8111a7a8 <__divsf3+0x31c>
8111a7a4:	8963883a 	add	r17,r17,r5
8111a7a8:	88c2002c 	andhi	r3,r17,2048
8111a7ac:	18000426 	beq	r3,zero,8111a7c0 <__divsf3+0x334>
8111a7b0:	00fe0034 	movhi	r3,63488
8111a7b4:	18ffffc4 	addi	r3,r3,-1
8111a7b8:	31002004 	addi	r4,r6,128
8111a7bc:	88e2703a 	and	r17,r17,r3
8111a7c0:	00c03f84 	movi	r3,254
8111a7c4:	193f8016 	blt	r3,r4,8111a5c8 <__reset+0xfb0fa5c8>
8111a7c8:	880c91ba 	slli	r6,r17,6
8111a7cc:	11c0004c 	andi	r7,r2,1
8111a7d0:	300cd27a 	srli	r6,r6,9
8111a7d4:	003f7f06 	br	8111a5d4 <__reset+0xfb0fa5d4>
8111a7d8:	9080102c 	andhi	r2,r18,64
8111a7dc:	10000226 	beq	r2,zero,8111a7e8 <__divsf3+0x35c>
8111a7e0:	8880102c 	andhi	r2,r17,64
8111a7e4:	10001826 	beq	r2,zero,8111a848 <__divsf3+0x3bc>
8111a7e8:	00802034 	movhi	r2,128
8111a7ec:	91801034 	orhi	r6,r18,64
8111a7f0:	10bfffc4 	addi	r2,r2,-1
8111a7f4:	980f883a 	mov	r7,r19
8111a7f8:	308c703a 	and	r6,r6,r2
8111a7fc:	003fc706 	br	8111a71c <__reset+0xfb0fa71c>
8111a800:	008000c4 	movi	r2,3
8111a804:	b8802d26 	beq	r23,r2,8111a8bc <__divsf3+0x430>
8111a808:	00c00044 	movi	r3,1
8111a80c:	b005883a 	mov	r2,r22
8111a810:	b8ffdd1e 	bne	r23,r3,8111a788 <__reset+0xfb0fa788>
8111a814:	11c0004c 	andi	r7,r2,1
8111a818:	0009883a 	mov	r4,zero
8111a81c:	000d883a 	mov	r6,zero
8111a820:	003f6c06 	br	8111a5d4 <__reset+0xfb0fa5d4>
8111a824:	9023883a 	mov	r17,r18
8111a828:	003f6406 	br	8111a5bc <__reset+0xfb0fa5bc>
8111a82c:	1c47c83a 	sub	r3,r3,r17
8111a830:	01000684 	movi	r4,26
8111a834:	01400044 	movi	r5,1
8111a838:	003fc806 	br	8111a75c <__reset+0xfb0fa75c>
8111a83c:	9080102c 	andhi	r2,r18,64
8111a840:	103fe926 	beq	r2,zero,8111a7e8 <__reset+0xfb0fa7e8>
8111a844:	0023883a 	mov	r17,zero
8111a848:	00802034 	movhi	r2,128
8111a84c:	89801034 	orhi	r6,r17,64
8111a850:	10bfffc4 	addi	r2,r2,-1
8111a854:	a80f883a 	mov	r7,r21
8111a858:	308c703a 	and	r6,r6,r2
8111a85c:	003faf06 	br	8111a71c <__reset+0xfb0fa71c>
8111a860:	01c00804 	movi	r7,32
8111a864:	390fc83a 	sub	r7,r7,r4
8111a868:	89ce983a 	sll	r7,r17,r7
8111a86c:	890ad83a 	srl	r5,r17,r4
8111a870:	380ec03a 	cmpne	r7,r7,zero
8111a874:	29cab03a 	or	r5,r5,r7
8111a878:	28c001cc 	andi	r3,r5,7
8111a87c:	18000426 	beq	r3,zero,8111a890 <__divsf3+0x404>
8111a880:	28c003cc 	andi	r3,r5,15
8111a884:	01000104 	movi	r4,4
8111a888:	19000126 	beq	r3,r4,8111a890 <__divsf3+0x404>
8111a88c:	290b883a 	add	r5,r5,r4
8111a890:	28c1002c 	andhi	r3,r5,1024
8111a894:	18000426 	beq	r3,zero,8111a8a8 <__divsf3+0x41c>
8111a898:	11c0004c 	andi	r7,r2,1
8111a89c:	01000044 	movi	r4,1
8111a8a0:	000d883a 	mov	r6,zero
8111a8a4:	003f4b06 	br	8111a5d4 <__reset+0xfb0fa5d4>
8111a8a8:	280a91ba 	slli	r5,r5,6
8111a8ac:	11c0004c 	andi	r7,r2,1
8111a8b0:	0009883a 	mov	r4,zero
8111a8b4:	280cd27a 	srli	r6,r5,9
8111a8b8:	003f4606 	br	8111a5d4 <__reset+0xfb0fa5d4>
8111a8bc:	00802034 	movhi	r2,128
8111a8c0:	89801034 	orhi	r6,r17,64
8111a8c4:	10bfffc4 	addi	r2,r2,-1
8111a8c8:	b00f883a 	mov	r7,r22
8111a8cc:	308c703a 	and	r6,r6,r2
8111a8d0:	003f9206 	br	8111a71c <__reset+0xfb0fa71c>

8111a8d4 <__mulsf3>:
8111a8d4:	defff504 	addi	sp,sp,-44
8111a8d8:	de00012e 	bgeu	sp,et,8111a8e0 <__mulsf3+0xc>
8111a8dc:	003b68fa 	trap	3
8111a8e0:	dc000115 	stw	r16,4(sp)
8111a8e4:	2020d5fa 	srli	r16,r4,23
8111a8e8:	dd400615 	stw	r21,24(sp)
8111a8ec:	202ad7fa 	srli	r21,r4,31
8111a8f0:	dc800315 	stw	r18,12(sp)
8111a8f4:	04802034 	movhi	r18,128
8111a8f8:	df000915 	stw	fp,36(sp)
8111a8fc:	dd000515 	stw	r20,20(sp)
8111a900:	94bfffc4 	addi	r18,r18,-1
8111a904:	dfc00a15 	stw	ra,40(sp)
8111a908:	ddc00815 	stw	r23,32(sp)
8111a90c:	dd800715 	stw	r22,28(sp)
8111a910:	dcc00415 	stw	r19,16(sp)
8111a914:	dc400215 	stw	r17,8(sp)
8111a918:	84003fcc 	andi	r16,r16,255
8111a91c:	9124703a 	and	r18,r18,r4
8111a920:	a829883a 	mov	r20,r21
8111a924:	af003fcc 	andi	fp,r21,255
8111a928:	80005426 	beq	r16,zero,8111aa7c <__mulsf3+0x1a8>
8111a92c:	00803fc4 	movi	r2,255
8111a930:	80802f26 	beq	r16,r2,8111a9f0 <__mulsf3+0x11c>
8111a934:	91002034 	orhi	r4,r18,128
8111a938:	202490fa 	slli	r18,r4,3
8111a93c:	843fe044 	addi	r16,r16,-127
8111a940:	0023883a 	mov	r17,zero
8111a944:	002f883a 	mov	r23,zero
8111a948:	2804d5fa 	srli	r2,r5,23
8111a94c:	282cd7fa 	srli	r22,r5,31
8111a950:	01002034 	movhi	r4,128
8111a954:	213fffc4 	addi	r4,r4,-1
8111a958:	10803fcc 	andi	r2,r2,255
8111a95c:	2166703a 	and	r19,r4,r5
8111a960:	b1803fcc 	andi	r6,r22,255
8111a964:	10004c26 	beq	r2,zero,8111aa98 <__mulsf3+0x1c4>
8111a968:	00c03fc4 	movi	r3,255
8111a96c:	10c04726 	beq	r2,r3,8111aa8c <__mulsf3+0x1b8>
8111a970:	99002034 	orhi	r4,r19,128
8111a974:	202690fa 	slli	r19,r4,3
8111a978:	10bfe044 	addi	r2,r2,-127
8111a97c:	0007883a 	mov	r3,zero
8111a980:	80a1883a 	add	r16,r16,r2
8111a984:	010003c4 	movi	r4,15
8111a988:	1c44b03a 	or	r2,r3,r17
8111a98c:	b56af03a 	xor	r21,r22,r21
8111a990:	81c00044 	addi	r7,r16,1
8111a994:	20806b36 	bltu	r4,r2,8111ab44 <__mulsf3+0x270>
8111a998:	100490ba 	slli	r2,r2,2
8111a99c:	012044b4 	movhi	r4,33042
8111a9a0:	212a6c04 	addi	r4,r4,-22096
8111a9a4:	1105883a 	add	r2,r2,r4
8111a9a8:	10800017 	ldw	r2,0(r2)
8111a9ac:	1000683a 	jmp	r2
8111a9b0:	8111ab44 	addi	r4,r16,18093
8111a9b4:	8111aa04 	addi	r4,r16,18088
8111a9b8:	8111aa04 	addi	r4,r16,18088
8111a9bc:	8111aa00 	call	88111aa0 <__reset+0x20f1aa0>
8111a9c0:	8111ab28 	cmpgeui	r4,r16,18092
8111a9c4:	8111ab28 	cmpgeui	r4,r16,18092
8111a9c8:	8111ab14 	ori	r4,r16,18092
8111a9cc:	8111aa00 	call	88111aa0 <__reset+0x20f1aa0>
8111a9d0:	8111ab28 	cmpgeui	r4,r16,18092
8111a9d4:	8111ab14 	ori	r4,r16,18092
8111a9d8:	8111ab28 	cmpgeui	r4,r16,18092
8111a9dc:	8111aa00 	call	88111aa0 <__reset+0x20f1aa0>
8111a9e0:	8111ab34 	orhi	r4,r16,18092
8111a9e4:	8111ab34 	orhi	r4,r16,18092
8111a9e8:	8111ab34 	orhi	r4,r16,18092
8111a9ec:	8111ac10 	cmplti	r4,r16,18096
8111a9f0:	90003b1e 	bne	r18,zero,8111aae0 <__mulsf3+0x20c>
8111a9f4:	04400204 	movi	r17,8
8111a9f8:	05c00084 	movi	r23,2
8111a9fc:	003fd206 	br	8111a948 <__reset+0xfb0fa948>
8111aa00:	302b883a 	mov	r21,r6
8111aa04:	00800084 	movi	r2,2
8111aa08:	18802626 	beq	r3,r2,8111aaa4 <__mulsf3+0x1d0>
8111aa0c:	008000c4 	movi	r2,3
8111aa10:	1880ab26 	beq	r3,r2,8111acc0 <__mulsf3+0x3ec>
8111aa14:	00800044 	movi	r2,1
8111aa18:	1880a21e 	bne	r3,r2,8111aca4 <__mulsf3+0x3d0>
8111aa1c:	a829883a 	mov	r20,r21
8111aa20:	0007883a 	mov	r3,zero
8111aa24:	0009883a 	mov	r4,zero
8111aa28:	18803fcc 	andi	r2,r3,255
8111aa2c:	100695fa 	slli	r3,r2,23
8111aa30:	a0803fcc 	andi	r2,r20,255
8111aa34:	100a97fa 	slli	r5,r2,31
8111aa38:	00802034 	movhi	r2,128
8111aa3c:	10bfffc4 	addi	r2,r2,-1
8111aa40:	2084703a 	and	r2,r4,r2
8111aa44:	10c4b03a 	or	r2,r2,r3
8111aa48:	1144b03a 	or	r2,r2,r5
8111aa4c:	dfc00a17 	ldw	ra,40(sp)
8111aa50:	df000917 	ldw	fp,36(sp)
8111aa54:	ddc00817 	ldw	r23,32(sp)
8111aa58:	dd800717 	ldw	r22,28(sp)
8111aa5c:	dd400617 	ldw	r21,24(sp)
8111aa60:	dd000517 	ldw	r20,20(sp)
8111aa64:	dcc00417 	ldw	r19,16(sp)
8111aa68:	dc800317 	ldw	r18,12(sp)
8111aa6c:	dc400217 	ldw	r17,8(sp)
8111aa70:	dc000117 	ldw	r16,4(sp)
8111aa74:	dec00b04 	addi	sp,sp,44
8111aa78:	f800283a 	ret
8111aa7c:	90000d1e 	bne	r18,zero,8111aab4 <__mulsf3+0x1e0>
8111aa80:	04400104 	movi	r17,4
8111aa84:	05c00044 	movi	r23,1
8111aa88:	003faf06 	br	8111a948 <__reset+0xfb0fa948>
8111aa8c:	9806c03a 	cmpne	r3,r19,zero
8111aa90:	18c00084 	addi	r3,r3,2
8111aa94:	003fba06 	br	8111a980 <__reset+0xfb0fa980>
8111aa98:	9800141e 	bne	r19,zero,8111aaec <__mulsf3+0x218>
8111aa9c:	00c00044 	movi	r3,1
8111aaa0:	003fb706 	br	8111a980 <__reset+0xfb0fa980>
8111aaa4:	a829883a 	mov	r20,r21
8111aaa8:	00ffffc4 	movi	r3,-1
8111aaac:	0009883a 	mov	r4,zero
8111aab0:	003fdd06 	br	8111aa28 <__reset+0xfb0faa28>
8111aab4:	9009883a 	mov	r4,r18
8111aab8:	d9400015 	stw	r5,0(sp)
8111aabc:	111b8dc0 	call	8111b8dc <__clzsi2>
8111aac0:	10fffec4 	addi	r3,r2,-5
8111aac4:	10801d84 	addi	r2,r2,118
8111aac8:	90e4983a 	sll	r18,r18,r3
8111aacc:	00a1c83a 	sub	r16,zero,r2
8111aad0:	0023883a 	mov	r17,zero
8111aad4:	002f883a 	mov	r23,zero
8111aad8:	d9400017 	ldw	r5,0(sp)
8111aadc:	003f9a06 	br	8111a948 <__reset+0xfb0fa948>
8111aae0:	04400304 	movi	r17,12
8111aae4:	05c000c4 	movi	r23,3
8111aae8:	003f9706 	br	8111a948 <__reset+0xfb0fa948>
8111aaec:	9809883a 	mov	r4,r19
8111aaf0:	d9800015 	stw	r6,0(sp)
8111aaf4:	111b8dc0 	call	8111b8dc <__clzsi2>
8111aaf8:	10fffec4 	addi	r3,r2,-5
8111aafc:	10801d84 	addi	r2,r2,118
8111ab00:	98e6983a 	sll	r19,r19,r3
8111ab04:	0085c83a 	sub	r2,zero,r2
8111ab08:	0007883a 	mov	r3,zero
8111ab0c:	d9800017 	ldw	r6,0(sp)
8111ab10:	003f9b06 	br	8111a980 <__reset+0xfb0fa980>
8111ab14:	01002034 	movhi	r4,128
8111ab18:	0029883a 	mov	r20,zero
8111ab1c:	213fffc4 	addi	r4,r4,-1
8111ab20:	00ffffc4 	movi	r3,-1
8111ab24:	003fc006 	br	8111aa28 <__reset+0xfb0faa28>
8111ab28:	9027883a 	mov	r19,r18
8111ab2c:	b807883a 	mov	r3,r23
8111ab30:	003fb406 	br	8111aa04 <__reset+0xfb0faa04>
8111ab34:	9027883a 	mov	r19,r18
8111ab38:	e02b883a 	mov	r21,fp
8111ab3c:	b807883a 	mov	r3,r23
8111ab40:	003fb006 	br	8111aa04 <__reset+0xfb0faa04>
8111ab44:	9004d43a 	srli	r2,r18,16
8111ab48:	9810d43a 	srli	r8,r19,16
8111ab4c:	94bfffcc 	andi	r18,r18,65535
8111ab50:	993fffcc 	andi	r4,r19,65535
8111ab54:	910d383a 	mul	r6,r18,r4
8111ab58:	20a7383a 	mul	r19,r4,r2
8111ab5c:	9225383a 	mul	r18,r18,r8
8111ab60:	3006d43a 	srli	r3,r6,16
8111ab64:	1211383a 	mul	r8,r2,r8
8111ab68:	94e5883a 	add	r18,r18,r19
8111ab6c:	1c87883a 	add	r3,r3,r18
8111ab70:	1cc0022e 	bgeu	r3,r19,8111ab7c <__mulsf3+0x2a8>
8111ab74:	00800074 	movhi	r2,1
8111ab78:	4091883a 	add	r8,r8,r2
8111ab7c:	1804943a 	slli	r2,r3,16
8111ab80:	31bfffcc 	andi	r6,r6,65535
8111ab84:	1806d43a 	srli	r3,r3,16
8111ab88:	1185883a 	add	r2,r2,r6
8111ab8c:	102691ba 	slli	r19,r2,6
8111ab90:	1a07883a 	add	r3,r3,r8
8111ab94:	1004d6ba 	srli	r2,r2,26
8111ab98:	180891ba 	slli	r4,r3,6
8111ab9c:	9826c03a 	cmpne	r19,r19,zero
8111aba0:	9884b03a 	or	r2,r19,r2
8111aba4:	1126b03a 	or	r19,r2,r4
8111aba8:	9882002c 	andhi	r2,r19,2048
8111abac:	10000426 	beq	r2,zero,8111abc0 <__mulsf3+0x2ec>
8111abb0:	9804d07a 	srli	r2,r19,1
8111abb4:	9900004c 	andi	r4,r19,1
8111abb8:	3821883a 	mov	r16,r7
8111abbc:	1126b03a 	or	r19,r2,r4
8111abc0:	80c01fc4 	addi	r3,r16,127
8111abc4:	00c0210e 	bge	zero,r3,8111ac4c <__mulsf3+0x378>
8111abc8:	988001cc 	andi	r2,r19,7
8111abcc:	10000426 	beq	r2,zero,8111abe0 <__mulsf3+0x30c>
8111abd0:	988003cc 	andi	r2,r19,15
8111abd4:	01000104 	movi	r4,4
8111abd8:	11000126 	beq	r2,r4,8111abe0 <__mulsf3+0x30c>
8111abdc:	9927883a 	add	r19,r19,r4
8111abe0:	9882002c 	andhi	r2,r19,2048
8111abe4:	10000426 	beq	r2,zero,8111abf8 <__mulsf3+0x324>
8111abe8:	00be0034 	movhi	r2,63488
8111abec:	10bfffc4 	addi	r2,r2,-1
8111abf0:	80c02004 	addi	r3,r16,128
8111abf4:	98a6703a 	and	r19,r19,r2
8111abf8:	00803f84 	movi	r2,254
8111abfc:	10ffa916 	blt	r2,r3,8111aaa4 <__reset+0xfb0faaa4>
8111ac00:	980891ba 	slli	r4,r19,6
8111ac04:	a829883a 	mov	r20,r21
8111ac08:	2008d27a 	srli	r4,r4,9
8111ac0c:	003f8606 	br	8111aa28 <__reset+0xfb0faa28>
8111ac10:	9080102c 	andhi	r2,r18,64
8111ac14:	10000826 	beq	r2,zero,8111ac38 <__mulsf3+0x364>
8111ac18:	9880102c 	andhi	r2,r19,64
8111ac1c:	1000061e 	bne	r2,zero,8111ac38 <__mulsf3+0x364>
8111ac20:	00802034 	movhi	r2,128
8111ac24:	99001034 	orhi	r4,r19,64
8111ac28:	10bfffc4 	addi	r2,r2,-1
8111ac2c:	b029883a 	mov	r20,r22
8111ac30:	2088703a 	and	r4,r4,r2
8111ac34:	003fba06 	br	8111ab20 <__reset+0xfb0fab20>
8111ac38:	00802034 	movhi	r2,128
8111ac3c:	91001034 	orhi	r4,r18,64
8111ac40:	10bfffc4 	addi	r2,r2,-1
8111ac44:	2088703a 	and	r4,r4,r2
8111ac48:	003fb506 	br	8111ab20 <__reset+0xfb0fab20>
8111ac4c:	00800044 	movi	r2,1
8111ac50:	10c7c83a 	sub	r3,r2,r3
8111ac54:	008006c4 	movi	r2,27
8111ac58:	10ff7016 	blt	r2,r3,8111aa1c <__reset+0xfb0faa1c>
8111ac5c:	00800804 	movi	r2,32
8111ac60:	10c5c83a 	sub	r2,r2,r3
8111ac64:	9884983a 	sll	r2,r19,r2
8111ac68:	98c6d83a 	srl	r3,r19,r3
8111ac6c:	1004c03a 	cmpne	r2,r2,zero
8111ac70:	1884b03a 	or	r2,r3,r2
8111ac74:	10c001cc 	andi	r3,r2,7
8111ac78:	18000426 	beq	r3,zero,8111ac8c <__mulsf3+0x3b8>
8111ac7c:	10c003cc 	andi	r3,r2,15
8111ac80:	01000104 	movi	r4,4
8111ac84:	19000126 	beq	r3,r4,8111ac8c <__mulsf3+0x3b8>
8111ac88:	1105883a 	add	r2,r2,r4
8111ac8c:	10c1002c 	andhi	r3,r2,1024
8111ac90:	18000626 	beq	r3,zero,8111acac <__mulsf3+0x3d8>
8111ac94:	a829883a 	mov	r20,r21
8111ac98:	00c00044 	movi	r3,1
8111ac9c:	0009883a 	mov	r4,zero
8111aca0:	003f6106 	br	8111aa28 <__reset+0xfb0faa28>
8111aca4:	3821883a 	mov	r16,r7
8111aca8:	003fc506 	br	8111abc0 <__reset+0xfb0fabc0>
8111acac:	100491ba 	slli	r2,r2,6
8111acb0:	a829883a 	mov	r20,r21
8111acb4:	0007883a 	mov	r3,zero
8111acb8:	1008d27a 	srli	r4,r2,9
8111acbc:	003f5a06 	br	8111aa28 <__reset+0xfb0faa28>
8111acc0:	00802034 	movhi	r2,128
8111acc4:	99001034 	orhi	r4,r19,64
8111acc8:	10bfffc4 	addi	r2,r2,-1
8111accc:	a829883a 	mov	r20,r21
8111acd0:	2088703a 	and	r4,r4,r2
8111acd4:	003f9206 	br	8111ab20 <__reset+0xfb0fab20>

8111acd8 <__floatsisf>:
8111acd8:	defffd04 	addi	sp,sp,-12
8111acdc:	de00012e 	bgeu	sp,et,8111ace4 <__floatsisf+0xc>
8111ace0:	003b68fa 	trap	3
8111ace4:	dfc00215 	stw	ra,8(sp)
8111ace8:	dc400115 	stw	r17,4(sp)
8111acec:	dc000015 	stw	r16,0(sp)
8111acf0:	20003526 	beq	r4,zero,8111adc8 <__floatsisf+0xf0>
8111acf4:	2021883a 	mov	r16,r4
8111acf8:	2022d7fa 	srli	r17,r4,31
8111acfc:	20003616 	blt	r4,zero,8111add8 <__floatsisf+0x100>
8111ad00:	8009883a 	mov	r4,r16
8111ad04:	111b8dc0 	call	8111b8dc <__clzsi2>
8111ad08:	00c02784 	movi	r3,158
8111ad0c:	1887c83a 	sub	r3,r3,r2
8111ad10:	01002584 	movi	r4,150
8111ad14:	20c01416 	blt	r4,r3,8111ad68 <__floatsisf+0x90>
8111ad18:	20c9c83a 	sub	r4,r4,r3
8111ad1c:	8120983a 	sll	r16,r16,r4
8111ad20:	00802034 	movhi	r2,128
8111ad24:	10bfffc4 	addi	r2,r2,-1
8111ad28:	8809883a 	mov	r4,r17
8111ad2c:	80a0703a 	and	r16,r16,r2
8111ad30:	18803fcc 	andi	r2,r3,255
8111ad34:	100695fa 	slli	r3,r2,23
8111ad38:	20803fcc 	andi	r2,r4,255
8111ad3c:	100897fa 	slli	r4,r2,31
8111ad40:	00802034 	movhi	r2,128
8111ad44:	10bfffc4 	addi	r2,r2,-1
8111ad48:	8084703a 	and	r2,r16,r2
8111ad4c:	10c4b03a 	or	r2,r2,r3
8111ad50:	1104b03a 	or	r2,r2,r4
8111ad54:	dfc00217 	ldw	ra,8(sp)
8111ad58:	dc400117 	ldw	r17,4(sp)
8111ad5c:	dc000017 	ldw	r16,0(sp)
8111ad60:	dec00304 	addi	sp,sp,12
8111ad64:	f800283a 	ret
8111ad68:	01002644 	movi	r4,153
8111ad6c:	20c01c16 	blt	r4,r3,8111ade0 <__floatsisf+0x108>
8111ad70:	20c9c83a 	sub	r4,r4,r3
8111ad74:	8120983a 	sll	r16,r16,r4
8111ad78:	013f0034 	movhi	r4,64512
8111ad7c:	213fffc4 	addi	r4,r4,-1
8111ad80:	814001cc 	andi	r5,r16,7
8111ad84:	8108703a 	and	r4,r16,r4
8111ad88:	28000426 	beq	r5,zero,8111ad9c <__floatsisf+0xc4>
8111ad8c:	840003cc 	andi	r16,r16,15
8111ad90:	01400104 	movi	r5,4
8111ad94:	81400126 	beq	r16,r5,8111ad9c <__floatsisf+0xc4>
8111ad98:	2149883a 	add	r4,r4,r5
8111ad9c:	2141002c 	andhi	r5,r4,1024
8111ada0:	28000526 	beq	r5,zero,8111adb8 <__floatsisf+0xe0>
8111ada4:	00c027c4 	movi	r3,159
8111ada8:	1887c83a 	sub	r3,r3,r2
8111adac:	00bf0034 	movhi	r2,64512
8111adb0:	10bfffc4 	addi	r2,r2,-1
8111adb4:	2088703a 	and	r4,r4,r2
8111adb8:	202091ba 	slli	r16,r4,6
8111adbc:	8809883a 	mov	r4,r17
8111adc0:	8020d27a 	srli	r16,r16,9
8111adc4:	003fda06 	br	8111ad30 <__reset+0xfb0fad30>
8111adc8:	0009883a 	mov	r4,zero
8111adcc:	0007883a 	mov	r3,zero
8111add0:	0021883a 	mov	r16,zero
8111add4:	003fd606 	br	8111ad30 <__reset+0xfb0fad30>
8111add8:	0121c83a 	sub	r16,zero,r4
8111addc:	003fc806 	br	8111ad00 <__reset+0xfb0fad00>
8111ade0:	01002e44 	movi	r4,185
8111ade4:	20c9c83a 	sub	r4,r4,r3
8111ade8:	01400144 	movi	r5,5
8111adec:	8108983a 	sll	r4,r16,r4
8111adf0:	288bc83a 	sub	r5,r5,r2
8111adf4:	8160d83a 	srl	r16,r16,r5
8111adf8:	2008c03a 	cmpne	r4,r4,zero
8111adfc:	8120b03a 	or	r16,r16,r4
8111ae00:	003fdd06 	br	8111ad78 <__reset+0xfb0fad78>

8111ae04 <__floatunsisf>:
8111ae04:	defffe04 	addi	sp,sp,-8
8111ae08:	de00012e 	bgeu	sp,et,8111ae10 <__floatunsisf+0xc>
8111ae0c:	003b68fa 	trap	3
8111ae10:	dfc00115 	stw	ra,4(sp)
8111ae14:	dc000015 	stw	r16,0(sp)
8111ae18:	20002c26 	beq	r4,zero,8111aecc <__floatunsisf+0xc8>
8111ae1c:	2021883a 	mov	r16,r4
8111ae20:	111b8dc0 	call	8111b8dc <__clzsi2>
8111ae24:	00c02784 	movi	r3,158
8111ae28:	1887c83a 	sub	r3,r3,r2
8111ae2c:	01002584 	movi	r4,150
8111ae30:	20c00f16 	blt	r4,r3,8111ae70 <__floatunsisf+0x6c>
8111ae34:	20c9c83a 	sub	r4,r4,r3
8111ae38:	8108983a 	sll	r4,r16,r4
8111ae3c:	00802034 	movhi	r2,128
8111ae40:	10bfffc4 	addi	r2,r2,-1
8111ae44:	2088703a 	and	r4,r4,r2
8111ae48:	18803fcc 	andi	r2,r3,255
8111ae4c:	100695fa 	slli	r3,r2,23
8111ae50:	00802034 	movhi	r2,128
8111ae54:	10bfffc4 	addi	r2,r2,-1
8111ae58:	2084703a 	and	r2,r4,r2
8111ae5c:	10c4b03a 	or	r2,r2,r3
8111ae60:	dfc00117 	ldw	ra,4(sp)
8111ae64:	dc000017 	ldw	r16,0(sp)
8111ae68:	dec00204 	addi	sp,sp,8
8111ae6c:	f800283a 	ret
8111ae70:	01002644 	movi	r4,153
8111ae74:	20c01816 	blt	r4,r3,8111aed8 <__floatunsisf+0xd4>
8111ae78:	20c9c83a 	sub	r4,r4,r3
8111ae7c:	8108983a 	sll	r4,r16,r4
8111ae80:	017f0034 	movhi	r5,64512
8111ae84:	297fffc4 	addi	r5,r5,-1
8111ae88:	218001cc 	andi	r6,r4,7
8111ae8c:	214a703a 	and	r5,r4,r5
8111ae90:	30000426 	beq	r6,zero,8111aea4 <__floatunsisf+0xa0>
8111ae94:	210003cc 	andi	r4,r4,15
8111ae98:	01800104 	movi	r6,4
8111ae9c:	21800126 	beq	r4,r6,8111aea4 <__floatunsisf+0xa0>
8111aea0:	298b883a 	add	r5,r5,r6
8111aea4:	2901002c 	andhi	r4,r5,1024
8111aea8:	20000526 	beq	r4,zero,8111aec0 <__floatunsisf+0xbc>
8111aeac:	00c027c4 	movi	r3,159
8111aeb0:	1887c83a 	sub	r3,r3,r2
8111aeb4:	00bf0034 	movhi	r2,64512
8111aeb8:	10bfffc4 	addi	r2,r2,-1
8111aebc:	288a703a 	and	r5,r5,r2
8111aec0:	280891ba 	slli	r4,r5,6
8111aec4:	2008d27a 	srli	r4,r4,9
8111aec8:	003fdf06 	br	8111ae48 <__reset+0xfb0fae48>
8111aecc:	0007883a 	mov	r3,zero
8111aed0:	0009883a 	mov	r4,zero
8111aed4:	003fdc06 	br	8111ae48 <__reset+0xfb0fae48>
8111aed8:	01402e44 	movi	r5,185
8111aedc:	28cbc83a 	sub	r5,r5,r3
8111aee0:	01000144 	movi	r4,5
8111aee4:	2089c83a 	sub	r4,r4,r2
8111aee8:	814a983a 	sll	r5,r16,r5
8111aeec:	8108d83a 	srl	r4,r16,r4
8111aef0:	2820c03a 	cmpne	r16,r5,zero
8111aef4:	2408b03a 	or	r4,r4,r16
8111aef8:	003fe106 	br	8111ae80 <__reset+0xfb0fae80>

8111aefc <__muldf3>:
8111aefc:	defff304 	addi	sp,sp,-52
8111af00:	2804d53a 	srli	r2,r5,20
8111af04:	de00012e 	bgeu	sp,et,8111af0c <__muldf3+0x10>
8111af08:	003b68fa 	trap	3
8111af0c:	dd800915 	stw	r22,36(sp)
8111af10:	282cd7fa 	srli	r22,r5,31
8111af14:	dc000315 	stw	r16,12(sp)
8111af18:	04000434 	movhi	r16,16
8111af1c:	dd400815 	stw	r21,32(sp)
8111af20:	dc800515 	stw	r18,20(sp)
8111af24:	843fffc4 	addi	r16,r16,-1
8111af28:	dfc00c15 	stw	ra,48(sp)
8111af2c:	df000b15 	stw	fp,44(sp)
8111af30:	ddc00a15 	stw	r23,40(sp)
8111af34:	dd000715 	stw	r20,28(sp)
8111af38:	dcc00615 	stw	r19,24(sp)
8111af3c:	dc400415 	stw	r17,16(sp)
8111af40:	1481ffcc 	andi	r18,r2,2047
8111af44:	2c20703a 	and	r16,r5,r16
8111af48:	b02b883a 	mov	r21,r22
8111af4c:	b2403fcc 	andi	r9,r22,255
8111af50:	90006026 	beq	r18,zero,8111b0d4 <__muldf3+0x1d8>
8111af54:	0081ffc4 	movi	r2,2047
8111af58:	2029883a 	mov	r20,r4
8111af5c:	90803626 	beq	r18,r2,8111b038 <__muldf3+0x13c>
8111af60:	80800434 	orhi	r2,r16,16
8111af64:	100490fa 	slli	r2,r2,3
8111af68:	2020d77a 	srli	r16,r4,29
8111af6c:	202890fa 	slli	r20,r4,3
8111af70:	94bf0044 	addi	r18,r18,-1023
8111af74:	80a0b03a 	or	r16,r16,r2
8111af78:	0027883a 	mov	r19,zero
8111af7c:	0039883a 	mov	fp,zero
8111af80:	3804d53a 	srli	r2,r7,20
8111af84:	382ed7fa 	srli	r23,r7,31
8111af88:	04400434 	movhi	r17,16
8111af8c:	8c7fffc4 	addi	r17,r17,-1
8111af90:	1081ffcc 	andi	r2,r2,2047
8111af94:	3011883a 	mov	r8,r6
8111af98:	3c62703a 	and	r17,r7,r17
8111af9c:	ba803fcc 	andi	r10,r23,255
8111afa0:	10006d26 	beq	r2,zero,8111b158 <__muldf3+0x25c>
8111afa4:	00c1ffc4 	movi	r3,2047
8111afa8:	10c06526 	beq	r2,r3,8111b140 <__muldf3+0x244>
8111afac:	88c00434 	orhi	r3,r17,16
8111afb0:	180690fa 	slli	r3,r3,3
8111afb4:	3022d77a 	srli	r17,r6,29
8111afb8:	301090fa 	slli	r8,r6,3
8111afbc:	10bf0044 	addi	r2,r2,-1023
8111afc0:	88e2b03a 	or	r17,r17,r3
8111afc4:	000b883a 	mov	r5,zero
8111afc8:	9085883a 	add	r2,r18,r2
8111afcc:	2cc8b03a 	or	r4,r5,r19
8111afd0:	00c003c4 	movi	r3,15
8111afd4:	bdacf03a 	xor	r22,r23,r22
8111afd8:	12c00044 	addi	r11,r2,1
8111afdc:	19009936 	bltu	r3,r4,8111b244 <__muldf3+0x348>
8111afe0:	200890ba 	slli	r4,r4,2
8111afe4:	00e044b4 	movhi	r3,33042
8111afe8:	18ebfe04 	addi	r3,r3,-20488
8111afec:	20c9883a 	add	r4,r4,r3
8111aff0:	20c00017 	ldw	r3,0(r4)
8111aff4:	1800683a 	jmp	r3
8111aff8:	8111b244 	addi	r4,r16,18121
8111affc:	8111b058 	cmpnei	r4,r16,18113
8111b000:	8111b058 	cmpnei	r4,r16,18113
8111b004:	8111b054 	ori	r4,r16,18113
8111b008:	8111b220 	cmpeqi	r4,r16,18120
8111b00c:	8111b220 	cmpeqi	r4,r16,18120
8111b010:	8111b208 	cmpgei	r4,r16,18120
8111b014:	8111b054 	ori	r4,r16,18113
8111b018:	8111b220 	cmpeqi	r4,r16,18120
8111b01c:	8111b208 	cmpgei	r4,r16,18120
8111b020:	8111b220 	cmpeqi	r4,r16,18120
8111b024:	8111b054 	ori	r4,r16,18113
8111b028:	8111b230 	cmpltui	r4,r16,18120
8111b02c:	8111b230 	cmpltui	r4,r16,18120
8111b030:	8111b230 	cmpltui	r4,r16,18120
8111b034:	8111b44c 	andi	r4,r16,18129
8111b038:	2404b03a 	or	r2,r4,r16
8111b03c:	10006f1e 	bne	r2,zero,8111b1fc <__muldf3+0x300>
8111b040:	04c00204 	movi	r19,8
8111b044:	0021883a 	mov	r16,zero
8111b048:	0029883a 	mov	r20,zero
8111b04c:	07000084 	movi	fp,2
8111b050:	003fcb06 	br	8111af80 <__reset+0xfb0faf80>
8111b054:	502d883a 	mov	r22,r10
8111b058:	00800084 	movi	r2,2
8111b05c:	28805726 	beq	r5,r2,8111b1bc <__muldf3+0x2c0>
8111b060:	008000c4 	movi	r2,3
8111b064:	28816626 	beq	r5,r2,8111b600 <__muldf3+0x704>
8111b068:	00800044 	movi	r2,1
8111b06c:	2881411e 	bne	r5,r2,8111b574 <__muldf3+0x678>
8111b070:	b02b883a 	mov	r21,r22
8111b074:	0005883a 	mov	r2,zero
8111b078:	000b883a 	mov	r5,zero
8111b07c:	0029883a 	mov	r20,zero
8111b080:	1004953a 	slli	r2,r2,20
8111b084:	a8c03fcc 	andi	r3,r21,255
8111b088:	04400434 	movhi	r17,16
8111b08c:	8c7fffc4 	addi	r17,r17,-1
8111b090:	180697fa 	slli	r3,r3,31
8111b094:	2c4a703a 	and	r5,r5,r17
8111b098:	288ab03a 	or	r5,r5,r2
8111b09c:	28c6b03a 	or	r3,r5,r3
8111b0a0:	a005883a 	mov	r2,r20
8111b0a4:	dfc00c17 	ldw	ra,48(sp)
8111b0a8:	df000b17 	ldw	fp,44(sp)
8111b0ac:	ddc00a17 	ldw	r23,40(sp)
8111b0b0:	dd800917 	ldw	r22,36(sp)
8111b0b4:	dd400817 	ldw	r21,32(sp)
8111b0b8:	dd000717 	ldw	r20,28(sp)
8111b0bc:	dcc00617 	ldw	r19,24(sp)
8111b0c0:	dc800517 	ldw	r18,20(sp)
8111b0c4:	dc400417 	ldw	r17,16(sp)
8111b0c8:	dc000317 	ldw	r16,12(sp)
8111b0cc:	dec00d04 	addi	sp,sp,52
8111b0d0:	f800283a 	ret
8111b0d4:	2404b03a 	or	r2,r4,r16
8111b0d8:	2027883a 	mov	r19,r4
8111b0dc:	10004226 	beq	r2,zero,8111b1e8 <__muldf3+0x2ec>
8111b0e0:	8000fc26 	beq	r16,zero,8111b4d4 <__muldf3+0x5d8>
8111b0e4:	8009883a 	mov	r4,r16
8111b0e8:	d9800215 	stw	r6,8(sp)
8111b0ec:	d9c00015 	stw	r7,0(sp)
8111b0f0:	da400115 	stw	r9,4(sp)
8111b0f4:	111b8dc0 	call	8111b8dc <__clzsi2>
8111b0f8:	d9800217 	ldw	r6,8(sp)
8111b0fc:	d9c00017 	ldw	r7,0(sp)
8111b100:	da400117 	ldw	r9,4(sp)
8111b104:	113ffd44 	addi	r4,r2,-11
8111b108:	00c00704 	movi	r3,28
8111b10c:	1900ed16 	blt	r3,r4,8111b4c4 <__muldf3+0x5c8>
8111b110:	00c00744 	movi	r3,29
8111b114:	147ffe04 	addi	r17,r2,-8
8111b118:	1907c83a 	sub	r3,r3,r4
8111b11c:	8460983a 	sll	r16,r16,r17
8111b120:	98c6d83a 	srl	r3,r19,r3
8111b124:	9c68983a 	sll	r20,r19,r17
8111b128:	1c20b03a 	or	r16,r3,r16
8111b12c:	1080fcc4 	addi	r2,r2,1011
8111b130:	00a5c83a 	sub	r18,zero,r2
8111b134:	0027883a 	mov	r19,zero
8111b138:	0039883a 	mov	fp,zero
8111b13c:	003f9006 	br	8111af80 <__reset+0xfb0faf80>
8111b140:	3446b03a 	or	r3,r6,r17
8111b144:	1800261e 	bne	r3,zero,8111b1e0 <__muldf3+0x2e4>
8111b148:	0023883a 	mov	r17,zero
8111b14c:	0011883a 	mov	r8,zero
8111b150:	01400084 	movi	r5,2
8111b154:	003f9c06 	br	8111afc8 <__reset+0xfb0fafc8>
8111b158:	3446b03a 	or	r3,r6,r17
8111b15c:	18001c26 	beq	r3,zero,8111b1d0 <__muldf3+0x2d4>
8111b160:	8800ce26 	beq	r17,zero,8111b49c <__muldf3+0x5a0>
8111b164:	8809883a 	mov	r4,r17
8111b168:	d9800215 	stw	r6,8(sp)
8111b16c:	da400115 	stw	r9,4(sp)
8111b170:	da800015 	stw	r10,0(sp)
8111b174:	111b8dc0 	call	8111b8dc <__clzsi2>
8111b178:	d9800217 	ldw	r6,8(sp)
8111b17c:	da400117 	ldw	r9,4(sp)
8111b180:	da800017 	ldw	r10,0(sp)
8111b184:	113ffd44 	addi	r4,r2,-11
8111b188:	00c00704 	movi	r3,28
8111b18c:	1900bf16 	blt	r3,r4,8111b48c <__muldf3+0x590>
8111b190:	00c00744 	movi	r3,29
8111b194:	123ffe04 	addi	r8,r2,-8
8111b198:	1907c83a 	sub	r3,r3,r4
8111b19c:	8a22983a 	sll	r17,r17,r8
8111b1a0:	30c6d83a 	srl	r3,r6,r3
8111b1a4:	3210983a 	sll	r8,r6,r8
8111b1a8:	1c62b03a 	or	r17,r3,r17
8111b1ac:	1080fcc4 	addi	r2,r2,1011
8111b1b0:	0085c83a 	sub	r2,zero,r2
8111b1b4:	000b883a 	mov	r5,zero
8111b1b8:	003f8306 	br	8111afc8 <__reset+0xfb0fafc8>
8111b1bc:	b02b883a 	mov	r21,r22
8111b1c0:	0081ffc4 	movi	r2,2047
8111b1c4:	000b883a 	mov	r5,zero
8111b1c8:	0029883a 	mov	r20,zero
8111b1cc:	003fac06 	br	8111b080 <__reset+0xfb0fb080>
8111b1d0:	0023883a 	mov	r17,zero
8111b1d4:	0011883a 	mov	r8,zero
8111b1d8:	01400044 	movi	r5,1
8111b1dc:	003f7a06 	br	8111afc8 <__reset+0xfb0fafc8>
8111b1e0:	014000c4 	movi	r5,3
8111b1e4:	003f7806 	br	8111afc8 <__reset+0xfb0fafc8>
8111b1e8:	04c00104 	movi	r19,4
8111b1ec:	0021883a 	mov	r16,zero
8111b1f0:	0029883a 	mov	r20,zero
8111b1f4:	07000044 	movi	fp,1
8111b1f8:	003f6106 	br	8111af80 <__reset+0xfb0faf80>
8111b1fc:	04c00304 	movi	r19,12
8111b200:	070000c4 	movi	fp,3
8111b204:	003f5e06 	br	8111af80 <__reset+0xfb0faf80>
8111b208:	01400434 	movhi	r5,16
8111b20c:	002b883a 	mov	r21,zero
8111b210:	297fffc4 	addi	r5,r5,-1
8111b214:	053fffc4 	movi	r20,-1
8111b218:	0081ffc4 	movi	r2,2047
8111b21c:	003f9806 	br	8111b080 <__reset+0xfb0fb080>
8111b220:	8023883a 	mov	r17,r16
8111b224:	a011883a 	mov	r8,r20
8111b228:	e00b883a 	mov	r5,fp
8111b22c:	003f8a06 	br	8111b058 <__reset+0xfb0fb058>
8111b230:	8023883a 	mov	r17,r16
8111b234:	a011883a 	mov	r8,r20
8111b238:	482d883a 	mov	r22,r9
8111b23c:	e00b883a 	mov	r5,fp
8111b240:	003f8506 	br	8111b058 <__reset+0xfb0fb058>
8111b244:	a00ad43a 	srli	r5,r20,16
8111b248:	401ad43a 	srli	r13,r8,16
8111b24c:	a53fffcc 	andi	r20,r20,65535
8111b250:	423fffcc 	andi	r8,r8,65535
8111b254:	4519383a 	mul	r12,r8,r20
8111b258:	4147383a 	mul	r3,r8,r5
8111b25c:	6d09383a 	mul	r4,r13,r20
8111b260:	600cd43a 	srli	r6,r12,16
8111b264:	2b5d383a 	mul	r14,r5,r13
8111b268:	20c9883a 	add	r4,r4,r3
8111b26c:	310d883a 	add	r6,r6,r4
8111b270:	30c0022e 	bgeu	r6,r3,8111b27c <__muldf3+0x380>
8111b274:	00c00074 	movhi	r3,1
8111b278:	70dd883a 	add	r14,r14,r3
8111b27c:	8826d43a 	srli	r19,r17,16
8111b280:	8bffffcc 	andi	r15,r17,65535
8111b284:	7d23383a 	mul	r17,r15,r20
8111b288:	7949383a 	mul	r4,r15,r5
8111b28c:	9d29383a 	mul	r20,r19,r20
8111b290:	8814d43a 	srli	r10,r17,16
8111b294:	3012943a 	slli	r9,r6,16
8111b298:	a129883a 	add	r20,r20,r4
8111b29c:	633fffcc 	andi	r12,r12,65535
8111b2a0:	5515883a 	add	r10,r10,r20
8111b2a4:	3006d43a 	srli	r3,r6,16
8111b2a8:	4b13883a 	add	r9,r9,r12
8111b2ac:	2ccb383a 	mul	r5,r5,r19
8111b2b0:	5100022e 	bgeu	r10,r4,8111b2bc <__muldf3+0x3c0>
8111b2b4:	01000074 	movhi	r4,1
8111b2b8:	290b883a 	add	r5,r5,r4
8111b2bc:	802ad43a 	srli	r21,r16,16
8111b2c0:	843fffcc 	andi	r16,r16,65535
8111b2c4:	440d383a 	mul	r6,r8,r16
8111b2c8:	4565383a 	mul	r18,r8,r21
8111b2cc:	8349383a 	mul	r4,r16,r13
8111b2d0:	500e943a 	slli	r7,r10,16
8111b2d4:	3010d43a 	srli	r8,r6,16
8111b2d8:	5028d43a 	srli	r20,r10,16
8111b2dc:	2489883a 	add	r4,r4,r18
8111b2e0:	8abfffcc 	andi	r10,r17,65535
8111b2e4:	3a95883a 	add	r10,r7,r10
8111b2e8:	4119883a 	add	r12,r8,r4
8111b2ec:	a169883a 	add	r20,r20,r5
8111b2f0:	1a87883a 	add	r3,r3,r10
8111b2f4:	6d5b383a 	mul	r13,r13,r21
8111b2f8:	6480022e 	bgeu	r12,r18,8111b304 <__muldf3+0x408>
8111b2fc:	01000074 	movhi	r4,1
8111b300:	691b883a 	add	r13,r13,r4
8111b304:	7c25383a 	mul	r18,r15,r16
8111b308:	7d4b383a 	mul	r5,r15,r21
8111b30c:	84cf383a 	mul	r7,r16,r19
8111b310:	901ed43a 	srli	r15,r18,16
8111b314:	6008d43a 	srli	r4,r12,16
8111b318:	6010943a 	slli	r8,r12,16
8111b31c:	394f883a 	add	r7,r7,r5
8111b320:	333fffcc 	andi	r12,r6,65535
8111b324:	79df883a 	add	r15,r15,r7
8111b328:	235b883a 	add	r13,r4,r13
8111b32c:	9d63383a 	mul	r17,r19,r21
8111b330:	4309883a 	add	r4,r8,r12
8111b334:	7940022e 	bgeu	r15,r5,8111b340 <__muldf3+0x444>
8111b338:	01400074 	movhi	r5,1
8111b33c:	8963883a 	add	r17,r17,r5
8111b340:	780a943a 	slli	r5,r15,16
8111b344:	91bfffcc 	andi	r6,r18,65535
8111b348:	70c7883a 	add	r3,r14,r3
8111b34c:	298d883a 	add	r6,r5,r6
8111b350:	1a8f803a 	cmpltu	r7,r3,r10
8111b354:	350b883a 	add	r5,r6,r20
8111b358:	20c7883a 	add	r3,r4,r3
8111b35c:	3955883a 	add	r10,r7,r5
8111b360:	1909803a 	cmpltu	r4,r3,r4
8111b364:	6a91883a 	add	r8,r13,r10
8111b368:	780cd43a 	srli	r6,r15,16
8111b36c:	2219883a 	add	r12,r4,r8
8111b370:	2d0b803a 	cmpltu	r5,r5,r20
8111b374:	51cf803a 	cmpltu	r7,r10,r7
8111b378:	29ceb03a 	or	r7,r5,r7
8111b37c:	4351803a 	cmpltu	r8,r8,r13
8111b380:	610b803a 	cmpltu	r5,r12,r4
8111b384:	4148b03a 	or	r4,r8,r5
8111b388:	398f883a 	add	r7,r7,r6
8111b38c:	3909883a 	add	r4,r7,r4
8111b390:	1810927a 	slli	r8,r3,9
8111b394:	2449883a 	add	r4,r4,r17
8111b398:	2008927a 	slli	r4,r4,9
8111b39c:	6022d5fa 	srli	r17,r12,23
8111b3a0:	1806d5fa 	srli	r3,r3,23
8111b3a4:	4252b03a 	or	r9,r8,r9
8111b3a8:	600a927a 	slli	r5,r12,9
8111b3ac:	4810c03a 	cmpne	r8,r9,zero
8111b3b0:	2462b03a 	or	r17,r4,r17
8111b3b4:	40c6b03a 	or	r3,r8,r3
8111b3b8:	8900402c 	andhi	r4,r17,256
8111b3bc:	1950b03a 	or	r8,r3,r5
8111b3c0:	20000726 	beq	r4,zero,8111b3e0 <__muldf3+0x4e4>
8111b3c4:	4006d07a 	srli	r3,r8,1
8111b3c8:	880497fa 	slli	r2,r17,31
8111b3cc:	4200004c 	andi	r8,r8,1
8111b3d0:	8822d07a 	srli	r17,r17,1
8111b3d4:	1a10b03a 	or	r8,r3,r8
8111b3d8:	1210b03a 	or	r8,r2,r8
8111b3dc:	5805883a 	mov	r2,r11
8111b3e0:	1140ffc4 	addi	r5,r2,1023
8111b3e4:	0140440e 	bge	zero,r5,8111b4f8 <__muldf3+0x5fc>
8111b3e8:	40c001cc 	andi	r3,r8,7
8111b3ec:	18000726 	beq	r3,zero,8111b40c <__muldf3+0x510>
8111b3f0:	40c003cc 	andi	r3,r8,15
8111b3f4:	01000104 	movi	r4,4
8111b3f8:	19000426 	beq	r3,r4,8111b40c <__muldf3+0x510>
8111b3fc:	4107883a 	add	r3,r8,r4
8111b400:	1a11803a 	cmpltu	r8,r3,r8
8111b404:	8a23883a 	add	r17,r17,r8
8111b408:	1811883a 	mov	r8,r3
8111b40c:	88c0402c 	andhi	r3,r17,256
8111b410:	18000426 	beq	r3,zero,8111b424 <__muldf3+0x528>
8111b414:	11410004 	addi	r5,r2,1024
8111b418:	00bfc034 	movhi	r2,65280
8111b41c:	10bfffc4 	addi	r2,r2,-1
8111b420:	88a2703a 	and	r17,r17,r2
8111b424:	0081ff84 	movi	r2,2046
8111b428:	117f6416 	blt	r2,r5,8111b1bc <__reset+0xfb0fb1bc>
8111b42c:	8828977a 	slli	r20,r17,29
8111b430:	4010d0fa 	srli	r8,r8,3
8111b434:	8822927a 	slli	r17,r17,9
8111b438:	2881ffcc 	andi	r2,r5,2047
8111b43c:	a228b03a 	or	r20,r20,r8
8111b440:	880ad33a 	srli	r5,r17,12
8111b444:	b02b883a 	mov	r21,r22
8111b448:	003f0d06 	br	8111b080 <__reset+0xfb0fb080>
8111b44c:	8080022c 	andhi	r2,r16,8
8111b450:	10000926 	beq	r2,zero,8111b478 <__muldf3+0x57c>
8111b454:	8880022c 	andhi	r2,r17,8
8111b458:	1000071e 	bne	r2,zero,8111b478 <__muldf3+0x57c>
8111b45c:	00800434 	movhi	r2,16
8111b460:	89400234 	orhi	r5,r17,8
8111b464:	10bfffc4 	addi	r2,r2,-1
8111b468:	b82b883a 	mov	r21,r23
8111b46c:	288a703a 	and	r5,r5,r2
8111b470:	4029883a 	mov	r20,r8
8111b474:	003f6806 	br	8111b218 <__reset+0xfb0fb218>
8111b478:	00800434 	movhi	r2,16
8111b47c:	81400234 	orhi	r5,r16,8
8111b480:	10bfffc4 	addi	r2,r2,-1
8111b484:	288a703a 	and	r5,r5,r2
8111b488:	003f6306 	br	8111b218 <__reset+0xfb0fb218>
8111b48c:	147ff604 	addi	r17,r2,-40
8111b490:	3462983a 	sll	r17,r6,r17
8111b494:	0011883a 	mov	r8,zero
8111b498:	003f4406 	br	8111b1ac <__reset+0xfb0fb1ac>
8111b49c:	3009883a 	mov	r4,r6
8111b4a0:	d9800215 	stw	r6,8(sp)
8111b4a4:	da400115 	stw	r9,4(sp)
8111b4a8:	da800015 	stw	r10,0(sp)
8111b4ac:	111b8dc0 	call	8111b8dc <__clzsi2>
8111b4b0:	10800804 	addi	r2,r2,32
8111b4b4:	da800017 	ldw	r10,0(sp)
8111b4b8:	da400117 	ldw	r9,4(sp)
8111b4bc:	d9800217 	ldw	r6,8(sp)
8111b4c0:	003f3006 	br	8111b184 <__reset+0xfb0fb184>
8111b4c4:	143ff604 	addi	r16,r2,-40
8111b4c8:	9c20983a 	sll	r16,r19,r16
8111b4cc:	0029883a 	mov	r20,zero
8111b4d0:	003f1606 	br	8111b12c <__reset+0xfb0fb12c>
8111b4d4:	d9800215 	stw	r6,8(sp)
8111b4d8:	d9c00015 	stw	r7,0(sp)
8111b4dc:	da400115 	stw	r9,4(sp)
8111b4e0:	111b8dc0 	call	8111b8dc <__clzsi2>
8111b4e4:	10800804 	addi	r2,r2,32
8111b4e8:	da400117 	ldw	r9,4(sp)
8111b4ec:	d9c00017 	ldw	r7,0(sp)
8111b4f0:	d9800217 	ldw	r6,8(sp)
8111b4f4:	003f0306 	br	8111b104 <__reset+0xfb0fb104>
8111b4f8:	00c00044 	movi	r3,1
8111b4fc:	1947c83a 	sub	r3,r3,r5
8111b500:	00800e04 	movi	r2,56
8111b504:	10feda16 	blt	r2,r3,8111b070 <__reset+0xfb0fb070>
8111b508:	008007c4 	movi	r2,31
8111b50c:	10c01b16 	blt	r2,r3,8111b57c <__muldf3+0x680>
8111b510:	00800804 	movi	r2,32
8111b514:	10c5c83a 	sub	r2,r2,r3
8111b518:	888a983a 	sll	r5,r17,r2
8111b51c:	40c8d83a 	srl	r4,r8,r3
8111b520:	4084983a 	sll	r2,r8,r2
8111b524:	88e2d83a 	srl	r17,r17,r3
8111b528:	2906b03a 	or	r3,r5,r4
8111b52c:	1004c03a 	cmpne	r2,r2,zero
8111b530:	1886b03a 	or	r3,r3,r2
8111b534:	188001cc 	andi	r2,r3,7
8111b538:	10000726 	beq	r2,zero,8111b558 <__muldf3+0x65c>
8111b53c:	188003cc 	andi	r2,r3,15
8111b540:	01000104 	movi	r4,4
8111b544:	11000426 	beq	r2,r4,8111b558 <__muldf3+0x65c>
8111b548:	1805883a 	mov	r2,r3
8111b54c:	10c00104 	addi	r3,r2,4
8111b550:	1885803a 	cmpltu	r2,r3,r2
8111b554:	88a3883a 	add	r17,r17,r2
8111b558:	8880202c 	andhi	r2,r17,128
8111b55c:	10001c26 	beq	r2,zero,8111b5d0 <__muldf3+0x6d4>
8111b560:	b02b883a 	mov	r21,r22
8111b564:	00800044 	movi	r2,1
8111b568:	000b883a 	mov	r5,zero
8111b56c:	0029883a 	mov	r20,zero
8111b570:	003ec306 	br	8111b080 <__reset+0xfb0fb080>
8111b574:	5805883a 	mov	r2,r11
8111b578:	003f9906 	br	8111b3e0 <__reset+0xfb0fb3e0>
8111b57c:	00bff844 	movi	r2,-31
8111b580:	1145c83a 	sub	r2,r2,r5
8111b584:	8888d83a 	srl	r4,r17,r2
8111b588:	00800804 	movi	r2,32
8111b58c:	18801a26 	beq	r3,r2,8111b5f8 <__muldf3+0x6fc>
8111b590:	00801004 	movi	r2,64
8111b594:	10c5c83a 	sub	r2,r2,r3
8111b598:	8884983a 	sll	r2,r17,r2
8111b59c:	1204b03a 	or	r2,r2,r8
8111b5a0:	1004c03a 	cmpne	r2,r2,zero
8111b5a4:	2084b03a 	or	r2,r4,r2
8111b5a8:	144001cc 	andi	r17,r2,7
8111b5ac:	88000d1e 	bne	r17,zero,8111b5e4 <__muldf3+0x6e8>
8111b5b0:	000b883a 	mov	r5,zero
8111b5b4:	1028d0fa 	srli	r20,r2,3
8111b5b8:	b02b883a 	mov	r21,r22
8111b5bc:	0005883a 	mov	r2,zero
8111b5c0:	a468b03a 	or	r20,r20,r17
8111b5c4:	003eae06 	br	8111b080 <__reset+0xfb0fb080>
8111b5c8:	1007883a 	mov	r3,r2
8111b5cc:	0023883a 	mov	r17,zero
8111b5d0:	880a927a 	slli	r5,r17,9
8111b5d4:	1805883a 	mov	r2,r3
8111b5d8:	8822977a 	slli	r17,r17,29
8111b5dc:	280ad33a 	srli	r5,r5,12
8111b5e0:	003ff406 	br	8111b5b4 <__reset+0xfb0fb5b4>
8111b5e4:	10c003cc 	andi	r3,r2,15
8111b5e8:	01000104 	movi	r4,4
8111b5ec:	193ff626 	beq	r3,r4,8111b5c8 <__reset+0xfb0fb5c8>
8111b5f0:	0023883a 	mov	r17,zero
8111b5f4:	003fd506 	br	8111b54c <__reset+0xfb0fb54c>
8111b5f8:	0005883a 	mov	r2,zero
8111b5fc:	003fe706 	br	8111b59c <__reset+0xfb0fb59c>
8111b600:	00800434 	movhi	r2,16
8111b604:	89400234 	orhi	r5,r17,8
8111b608:	10bfffc4 	addi	r2,r2,-1
8111b60c:	b02b883a 	mov	r21,r22
8111b610:	288a703a 	and	r5,r5,r2
8111b614:	4029883a 	mov	r20,r8
8111b618:	003eff06 	br	8111b218 <__reset+0xfb0fb218>

8111b61c <__extendsfdf2>:
8111b61c:	200ad5fa 	srli	r5,r4,23
8111b620:	defffd04 	addi	sp,sp,-12
8111b624:	de00012e 	bgeu	sp,et,8111b62c <__extendsfdf2+0x10>
8111b628:	003b68fa 	trap	3
8111b62c:	29403fcc 	andi	r5,r5,255
8111b630:	dc400115 	stw	r17,4(sp)
8111b634:	29800044 	addi	r6,r5,1
8111b638:	04402034 	movhi	r17,128
8111b63c:	dc000015 	stw	r16,0(sp)
8111b640:	8c7fffc4 	addi	r17,r17,-1
8111b644:	dfc00215 	stw	ra,8(sp)
8111b648:	31803fcc 	andi	r6,r6,255
8111b64c:	00800044 	movi	r2,1
8111b650:	8922703a 	and	r17,r17,r4
8111b654:	2020d7fa 	srli	r16,r4,31
8111b658:	1180110e 	bge	r2,r6,8111b6a0 <__extendsfdf2+0x84>
8111b65c:	880cd0fa 	srli	r6,r17,3
8111b660:	8822977a 	slli	r17,r17,29
8111b664:	2940e004 	addi	r5,r5,896
8111b668:	2941ffcc 	andi	r5,r5,2047
8111b66c:	2804953a 	slli	r2,r5,20
8111b670:	01400434 	movhi	r5,16
8111b674:	800697fa 	slli	r3,r16,31
8111b678:	297fffc4 	addi	r5,r5,-1
8111b67c:	314a703a 	and	r5,r6,r5
8111b680:	288ab03a 	or	r5,r5,r2
8111b684:	28c6b03a 	or	r3,r5,r3
8111b688:	8805883a 	mov	r2,r17
8111b68c:	dfc00217 	ldw	ra,8(sp)
8111b690:	dc400117 	ldw	r17,4(sp)
8111b694:	dc000017 	ldw	r16,0(sp)
8111b698:	dec00304 	addi	sp,sp,12
8111b69c:	f800283a 	ret
8111b6a0:	2800111e 	bne	r5,zero,8111b6e8 <__extendsfdf2+0xcc>
8111b6a4:	88001c26 	beq	r17,zero,8111b718 <__extendsfdf2+0xfc>
8111b6a8:	8809883a 	mov	r4,r17
8111b6ac:	111b8dc0 	call	8111b8dc <__clzsi2>
8111b6b0:	00c00284 	movi	r3,10
8111b6b4:	18801b16 	blt	r3,r2,8111b724 <__extendsfdf2+0x108>
8111b6b8:	018002c4 	movi	r6,11
8111b6bc:	308dc83a 	sub	r6,r6,r2
8111b6c0:	11000544 	addi	r4,r2,21
8111b6c4:	8986d83a 	srl	r3,r17,r6
8111b6c8:	8922983a 	sll	r17,r17,r4
8111b6cc:	0180e244 	movi	r6,905
8111b6d0:	01400434 	movhi	r5,16
8111b6d4:	3085c83a 	sub	r2,r6,r2
8111b6d8:	297fffc4 	addi	r5,r5,-1
8111b6dc:	194c703a 	and	r6,r3,r5
8111b6e0:	1141ffcc 	andi	r5,r2,2047
8111b6e4:	003fe006 	br	8111b668 <__reset+0xfb0fb668>
8111b6e8:	88000826 	beq	r17,zero,8111b70c <__extendsfdf2+0xf0>
8111b6ec:	880cd0fa 	srli	r6,r17,3
8111b6f0:	00800434 	movhi	r2,16
8111b6f4:	10bfffc4 	addi	r2,r2,-1
8111b6f8:	31800234 	orhi	r6,r6,8
8111b6fc:	8822977a 	slli	r17,r17,29
8111b700:	308c703a 	and	r6,r6,r2
8111b704:	0141ffc4 	movi	r5,2047
8111b708:	003fd706 	br	8111b668 <__reset+0xfb0fb668>
8111b70c:	0141ffc4 	movi	r5,2047
8111b710:	000d883a 	mov	r6,zero
8111b714:	003fd406 	br	8111b668 <__reset+0xfb0fb668>
8111b718:	000b883a 	mov	r5,zero
8111b71c:	000d883a 	mov	r6,zero
8111b720:	003fd106 	br	8111b668 <__reset+0xfb0fb668>
8111b724:	11bffd44 	addi	r6,r2,-11
8111b728:	8986983a 	sll	r3,r17,r6
8111b72c:	0023883a 	mov	r17,zero
8111b730:	003fe606 	br	8111b6cc <__reset+0xfb0fb6cc>

8111b734 <__truncdfsf2>:
8111b734:	2810d53a 	srli	r8,r5,20
8111b738:	01c00434 	movhi	r7,16
8111b73c:	39ffffc4 	addi	r7,r7,-1
8111b740:	29ce703a 	and	r7,r5,r7
8111b744:	4201ffcc 	andi	r8,r8,2047
8111b748:	380e90fa 	slli	r7,r7,3
8111b74c:	200cd77a 	srli	r6,r4,29
8111b750:	42400044 	addi	r9,r8,1
8111b754:	4a41ffcc 	andi	r9,r9,2047
8111b758:	00c00044 	movi	r3,1
8111b75c:	280ad7fa 	srli	r5,r5,31
8111b760:	31ceb03a 	or	r7,r6,r7
8111b764:	200490fa 	slli	r2,r4,3
8111b768:	1a40230e 	bge	r3,r9,8111b7f8 <__truncdfsf2+0xc4>
8111b76c:	40ff2004 	addi	r3,r8,-896
8111b770:	01803f84 	movi	r6,254
8111b774:	30c01516 	blt	r6,r3,8111b7cc <__truncdfsf2+0x98>
8111b778:	00c0380e 	bge	zero,r3,8111b85c <__truncdfsf2+0x128>
8111b77c:	200c91ba 	slli	r6,r4,6
8111b780:	380e90fa 	slli	r7,r7,3
8111b784:	1004d77a 	srli	r2,r2,29
8111b788:	300cc03a 	cmpne	r6,r6,zero
8111b78c:	31ccb03a 	or	r6,r6,r7
8111b790:	308cb03a 	or	r6,r6,r2
8111b794:	308001cc 	andi	r2,r6,7
8111b798:	10000426 	beq	r2,zero,8111b7ac <__truncdfsf2+0x78>
8111b79c:	308003cc 	andi	r2,r6,15
8111b7a0:	01000104 	movi	r4,4
8111b7a4:	11000126 	beq	r2,r4,8111b7ac <__truncdfsf2+0x78>
8111b7a8:	31800104 	addi	r6,r6,4
8111b7ac:	3081002c 	andhi	r2,r6,1024
8111b7b0:	10001626 	beq	r2,zero,8111b80c <__truncdfsf2+0xd8>
8111b7b4:	18c00044 	addi	r3,r3,1
8111b7b8:	00803fc4 	movi	r2,255
8111b7bc:	18800326 	beq	r3,r2,8111b7cc <__truncdfsf2+0x98>
8111b7c0:	300c91ba 	slli	r6,r6,6
8111b7c4:	300cd27a 	srli	r6,r6,9
8111b7c8:	00000206 	br	8111b7d4 <__truncdfsf2+0xa0>
8111b7cc:	00ffffc4 	movi	r3,-1
8111b7d0:	000d883a 	mov	r6,zero
8111b7d4:	18c03fcc 	andi	r3,r3,255
8111b7d8:	180895fa 	slli	r4,r3,23
8111b7dc:	00c02034 	movhi	r3,128
8111b7e0:	280a97fa 	slli	r5,r5,31
8111b7e4:	18ffffc4 	addi	r3,r3,-1
8111b7e8:	30c6703a 	and	r3,r6,r3
8111b7ec:	1906b03a 	or	r3,r3,r4
8111b7f0:	1944b03a 	or	r2,r3,r5
8111b7f4:	f800283a 	ret
8111b7f8:	40000b1e 	bne	r8,zero,8111b828 <__truncdfsf2+0xf4>
8111b7fc:	388cb03a 	or	r6,r7,r2
8111b800:	0007883a 	mov	r3,zero
8111b804:	30000426 	beq	r6,zero,8111b818 <__truncdfsf2+0xe4>
8111b808:	01800144 	movi	r6,5
8111b80c:	00803fc4 	movi	r2,255
8111b810:	300cd0fa 	srli	r6,r6,3
8111b814:	18800a26 	beq	r3,r2,8111b840 <__truncdfsf2+0x10c>
8111b818:	00802034 	movhi	r2,128
8111b81c:	10bfffc4 	addi	r2,r2,-1
8111b820:	308c703a 	and	r6,r6,r2
8111b824:	003feb06 	br	8111b7d4 <__reset+0xfb0fb7d4>
8111b828:	3888b03a 	or	r4,r7,r2
8111b82c:	203fe726 	beq	r4,zero,8111b7cc <__reset+0xfb0fb7cc>
8111b830:	380c90fa 	slli	r6,r7,3
8111b834:	00c03fc4 	movi	r3,255
8111b838:	31808034 	orhi	r6,r6,512
8111b83c:	003fd506 	br	8111b794 <__reset+0xfb0fb794>
8111b840:	303fe226 	beq	r6,zero,8111b7cc <__reset+0xfb0fb7cc>
8111b844:	00802034 	movhi	r2,128
8111b848:	31801034 	orhi	r6,r6,64
8111b84c:	10bfffc4 	addi	r2,r2,-1
8111b850:	00ffffc4 	movi	r3,-1
8111b854:	308c703a 	and	r6,r6,r2
8111b858:	003fde06 	br	8111b7d4 <__reset+0xfb0fb7d4>
8111b85c:	013ffa44 	movi	r4,-23
8111b860:	19000e16 	blt	r3,r4,8111b89c <__truncdfsf2+0x168>
8111b864:	01000784 	movi	r4,30
8111b868:	20c9c83a 	sub	r4,r4,r3
8111b86c:	018007c4 	movi	r6,31
8111b870:	39c02034 	orhi	r7,r7,128
8111b874:	31000b16 	blt	r6,r4,8111b8a4 <__truncdfsf2+0x170>
8111b878:	423f2084 	addi	r8,r8,-894
8111b87c:	120c983a 	sll	r6,r2,r8
8111b880:	3a0e983a 	sll	r7,r7,r8
8111b884:	1104d83a 	srl	r2,r2,r4
8111b888:	300cc03a 	cmpne	r6,r6,zero
8111b88c:	31ceb03a 	or	r7,r6,r7
8111b890:	388cb03a 	or	r6,r7,r2
8111b894:	0007883a 	mov	r3,zero
8111b898:	003fbe06 	br	8111b794 <__reset+0xfb0fb794>
8111b89c:	0007883a 	mov	r3,zero
8111b8a0:	003fd906 	br	8111b808 <__reset+0xfb0fb808>
8111b8a4:	01bfff84 	movi	r6,-2
8111b8a8:	30cdc83a 	sub	r6,r6,r3
8111b8ac:	00c00804 	movi	r3,32
8111b8b0:	398cd83a 	srl	r6,r7,r6
8111b8b4:	20c00726 	beq	r4,r3,8111b8d4 <__truncdfsf2+0x1a0>
8111b8b8:	423f2884 	addi	r8,r8,-862
8111b8bc:	3a0e983a 	sll	r7,r7,r8
8111b8c0:	3884b03a 	or	r2,r7,r2
8111b8c4:	1004c03a 	cmpne	r2,r2,zero
8111b8c8:	118cb03a 	or	r6,r2,r6
8111b8cc:	0007883a 	mov	r3,zero
8111b8d0:	003fb006 	br	8111b794 <__reset+0xfb0fb794>
8111b8d4:	000f883a 	mov	r7,zero
8111b8d8:	003ff906 	br	8111b8c0 <__reset+0xfb0fb8c0>

8111b8dc <__clzsi2>:
8111b8dc:	00bfffd4 	movui	r2,65535
8111b8e0:	11000536 	bltu	r2,r4,8111b8f8 <__clzsi2+0x1c>
8111b8e4:	00803fc4 	movi	r2,255
8111b8e8:	11000f36 	bltu	r2,r4,8111b928 <__clzsi2+0x4c>
8111b8ec:	00800804 	movi	r2,32
8111b8f0:	0007883a 	mov	r3,zero
8111b8f4:	00000506 	br	8111b90c <__clzsi2+0x30>
8111b8f8:	00804034 	movhi	r2,256
8111b8fc:	10bfffc4 	addi	r2,r2,-1
8111b900:	11000c2e 	bgeu	r2,r4,8111b934 <__clzsi2+0x58>
8111b904:	00800204 	movi	r2,8
8111b908:	00c00604 	movi	r3,24
8111b90c:	20c8d83a 	srl	r4,r4,r3
8111b910:	00e04574 	movhi	r3,33045
8111b914:	18ea6e04 	addi	r3,r3,-22088
8111b918:	1909883a 	add	r4,r3,r4
8111b91c:	20c00003 	ldbu	r3,0(r4)
8111b920:	10c5c83a 	sub	r2,r2,r3
8111b924:	f800283a 	ret
8111b928:	00800604 	movi	r2,24
8111b92c:	00c00204 	movi	r3,8
8111b930:	003ff606 	br	8111b90c <__reset+0xfb0fb90c>
8111b934:	00800404 	movi	r2,16
8111b938:	1007883a 	mov	r3,r2
8111b93c:	003ff306 	br	8111b90c <__reset+0xfb0fb90c>

8111b940 <atoi>:
8111b940:	01800284 	movi	r6,10
8111b944:	000b883a 	mov	r5,zero
8111b948:	111d95c1 	jmpi	8111d95c <strtol>

8111b94c <_atoi_r>:
8111b94c:	01c00284 	movi	r7,10
8111b950:	000d883a 	mov	r6,zero
8111b954:	111d71c1 	jmpi	8111d71c <_strtol_r>

8111b958 <_fopen_r>:
8111b958:	defffa04 	addi	sp,sp,-24
8111b95c:	3005883a 	mov	r2,r6
8111b960:	de00012e 	bgeu	sp,et,8111b968 <_fopen_r+0x10>
8111b964:	003b68fa 	trap	3
8111b968:	d80d883a 	mov	r6,sp
8111b96c:	dcc00415 	stw	r19,16(sp)
8111b970:	2827883a 	mov	r19,r5
8111b974:	100b883a 	mov	r5,r2
8111b978:	dc800315 	stw	r18,12(sp)
8111b97c:	dfc00515 	stw	ra,20(sp)
8111b980:	dc400215 	stw	r17,8(sp)
8111b984:	dc000115 	stw	r16,4(sp)
8111b988:	2025883a 	mov	r18,r4
8111b98c:	11259640 	call	81125964 <__sflags>
8111b990:	10002726 	beq	r2,zero,8111ba30 <_fopen_r+0xd8>
8111b994:	9009883a 	mov	r4,r18
8111b998:	1023883a 	mov	r17,r2
8111b99c:	11257dc0 	call	811257dc <__sfp>
8111b9a0:	1021883a 	mov	r16,r2
8111b9a4:	10002226 	beq	r2,zero,8111ba30 <_fopen_r+0xd8>
8111b9a8:	d9800017 	ldw	r6,0(sp)
8111b9ac:	01c06d84 	movi	r7,438
8111b9b0:	980b883a 	mov	r5,r19
8111b9b4:	9009883a 	mov	r4,r18
8111b9b8:	111cdc40 	call	8111cdc4 <_open_r>
8111b9bc:	10001916 	blt	r2,zero,8111ba24 <_fopen_r+0xcc>
8111b9c0:	8080038d 	sth	r2,14(r16)
8111b9c4:	00a044b4 	movhi	r2,33042
8111b9c8:	10b52804 	addi	r2,r2,-11104
8111b9cc:	80800815 	stw	r2,32(r16)
8111b9d0:	00a044b4 	movhi	r2,33042
8111b9d4:	10b54104 	addi	r2,r2,-11004
8111b9d8:	80800915 	stw	r2,36(r16)
8111b9dc:	00a044b4 	movhi	r2,33042
8111b9e0:	10b56204 	addi	r2,r2,-10872
8111b9e4:	80800a15 	stw	r2,40(r16)
8111b9e8:	00a044b4 	movhi	r2,33042
8111b9ec:	10b57b04 	addi	r2,r2,-10772
8111b9f0:	8440030d 	sth	r17,12(r16)
8111b9f4:	84000715 	stw	r16,28(r16)
8111b9f8:	80800b15 	stw	r2,44(r16)
8111b9fc:	8c40400c 	andi	r17,r17,256
8111ba00:	88000d1e 	bne	r17,zero,8111ba38 <_fopen_r+0xe0>
8111ba04:	8005883a 	mov	r2,r16
8111ba08:	dfc00517 	ldw	ra,20(sp)
8111ba0c:	dcc00417 	ldw	r19,16(sp)
8111ba10:	dc800317 	ldw	r18,12(sp)
8111ba14:	dc400217 	ldw	r17,8(sp)
8111ba18:	dc000117 	ldw	r16,4(sp)
8111ba1c:	dec00604 	addi	sp,sp,24
8111ba20:	f800283a 	ret
8111ba24:	11259240 	call	81125924 <__sfp_lock_acquire>
8111ba28:	8000030d 	sth	zero,12(r16)
8111ba2c:	11259280 	call	81125928 <__sfp_lock_release>
8111ba30:	0005883a 	mov	r2,zero
8111ba34:	003ff406 	br	8111ba08 <__reset+0xfb0fba08>
8111ba38:	01c00084 	movi	r7,2
8111ba3c:	000d883a 	mov	r6,zero
8111ba40:	800b883a 	mov	r5,r16
8111ba44:	9009883a 	mov	r4,r18
8111ba48:	111bb780 	call	8111bb78 <_fseek_r>
8111ba4c:	8005883a 	mov	r2,r16
8111ba50:	003fed06 	br	8111ba08 <__reset+0xfb0fba08>

8111ba54 <fopen>:
8111ba54:	00a04574 	movhi	r2,33045
8111ba58:	10b52904 	addi	r2,r2,-11100
8111ba5c:	280d883a 	mov	r6,r5
8111ba60:	200b883a 	mov	r5,r4
8111ba64:	11000017 	ldw	r4,0(r2)
8111ba68:	111b9581 	jmpi	8111b958 <_fopen_r>

8111ba6c <_fprintf_r>:
8111ba6c:	defffe04 	addi	sp,sp,-8
8111ba70:	2809883a 	mov	r4,r5
8111ba74:	300b883a 	mov	r5,r6
8111ba78:	de00012e 	bgeu	sp,et,8111ba80 <_fprintf_r+0x14>
8111ba7c:	003b68fa 	trap	3
8111ba80:	dfc00015 	stw	ra,0(sp)
8111ba84:	d9c00115 	stw	r7,4(sp)
8111ba88:	d9800104 	addi	r6,sp,4
8111ba8c:	1121d580 	call	81121d58 <__vfprintf_internal>
8111ba90:	dfc00017 	ldw	ra,0(sp)
8111ba94:	dec00204 	addi	sp,sp,8
8111ba98:	f800283a 	ret

8111ba9c <fprintf>:
8111ba9c:	defffd04 	addi	sp,sp,-12
8111baa0:	de00012e 	bgeu	sp,et,8111baa8 <fprintf+0xc>
8111baa4:	003b68fa 	trap	3
8111baa8:	dfc00015 	stw	ra,0(sp)
8111baac:	d9800115 	stw	r6,4(sp)
8111bab0:	d9c00215 	stw	r7,8(sp)
8111bab4:	d9800104 	addi	r6,sp,4
8111bab8:	1121d580 	call	81121d58 <__vfprintf_internal>
8111babc:	dfc00017 	ldw	ra,0(sp)
8111bac0:	dec00304 	addi	sp,sp,12
8111bac4:	f800283a 	ret

8111bac8 <_fputc_r>:
8111bac8:	defffc04 	addi	sp,sp,-16
8111bacc:	de00012e 	bgeu	sp,et,8111bad4 <_fputc_r+0xc>
8111bad0:	003b68fa 	trap	3
8111bad4:	dc000215 	stw	r16,8(sp)
8111bad8:	dfc00315 	stw	ra,12(sp)
8111badc:	2021883a 	mov	r16,r4
8111bae0:	20000726 	beq	r4,zero,8111bb00 <_fputc_r+0x38>
8111bae4:	20800e17 	ldw	r2,56(r4)
8111bae8:	1000051e 	bne	r2,zero,8111bb00 <_fputc_r+0x38>
8111baec:	d9400015 	stw	r5,0(sp)
8111baf0:	d9800115 	stw	r6,4(sp)
8111baf4:	11259140 	call	81125914 <__sinit>
8111baf8:	d9800117 	ldw	r6,4(sp)
8111bafc:	d9400017 	ldw	r5,0(sp)
8111bb00:	8009883a 	mov	r4,r16
8111bb04:	dfc00317 	ldw	ra,12(sp)
8111bb08:	dc000217 	ldw	r16,8(sp)
8111bb0c:	dec00404 	addi	sp,sp,16
8111bb10:	111cea81 	jmpi	8111cea8 <_putc_r>

8111bb14 <fputc>:
8111bb14:	00a04574 	movhi	r2,33045
8111bb18:	defffc04 	addi	sp,sp,-16
8111bb1c:	10b52904 	addi	r2,r2,-11100
8111bb20:	de00012e 	bgeu	sp,et,8111bb28 <fputc+0x14>
8111bb24:	003b68fa 	trap	3
8111bb28:	dc000115 	stw	r16,4(sp)
8111bb2c:	14000017 	ldw	r16,0(r2)
8111bb30:	dc400215 	stw	r17,8(sp)
8111bb34:	dfc00315 	stw	ra,12(sp)
8111bb38:	2023883a 	mov	r17,r4
8111bb3c:	80000626 	beq	r16,zero,8111bb58 <fputc+0x44>
8111bb40:	80800e17 	ldw	r2,56(r16)
8111bb44:	1000041e 	bne	r2,zero,8111bb58 <fputc+0x44>
8111bb48:	8009883a 	mov	r4,r16
8111bb4c:	d9400015 	stw	r5,0(sp)
8111bb50:	11259140 	call	81125914 <__sinit>
8111bb54:	d9400017 	ldw	r5,0(sp)
8111bb58:	280d883a 	mov	r6,r5
8111bb5c:	8009883a 	mov	r4,r16
8111bb60:	880b883a 	mov	r5,r17
8111bb64:	dfc00317 	ldw	ra,12(sp)
8111bb68:	dc400217 	ldw	r17,8(sp)
8111bb6c:	dc000117 	ldw	r16,4(sp)
8111bb70:	dec00404 	addi	sp,sp,16
8111bb74:	111cea81 	jmpi	8111cea8 <_putc_r>

8111bb78 <_fseek_r>:
8111bb78:	111bb981 	jmpi	8111bb98 <_fseeko_r>

8111bb7c <fseek>:
8111bb7c:	00a04574 	movhi	r2,33045
8111bb80:	10b52904 	addi	r2,r2,-11100
8111bb84:	300f883a 	mov	r7,r6
8111bb88:	280d883a 	mov	r6,r5
8111bb8c:	200b883a 	mov	r5,r4
8111bb90:	11000017 	ldw	r4,0(r2)
8111bb94:	111bb981 	jmpi	8111bb98 <_fseeko_r>

8111bb98 <_fseeko_r>:
8111bb98:	deffe804 	addi	sp,sp,-96
8111bb9c:	de00012e 	bgeu	sp,et,8111bba4 <_fseeko_r+0xc>
8111bba0:	003b68fa 	trap	3
8111bba4:	dd401415 	stw	r21,80(sp)
8111bba8:	dc801115 	stw	r18,68(sp)
8111bbac:	dc401015 	stw	r17,64(sp)
8111bbb0:	dc000f15 	stw	r16,60(sp)
8111bbb4:	dfc01715 	stw	ra,92(sp)
8111bbb8:	ddc01615 	stw	r23,88(sp)
8111bbbc:	dd801515 	stw	r22,84(sp)
8111bbc0:	dd001315 	stw	r20,76(sp)
8111bbc4:	dcc01215 	stw	r19,72(sp)
8111bbc8:	2023883a 	mov	r17,r4
8111bbcc:	2821883a 	mov	r16,r5
8111bbd0:	302b883a 	mov	r21,r6
8111bbd4:	3825883a 	mov	r18,r7
8111bbd8:	20000226 	beq	r4,zero,8111bbe4 <_fseeko_r+0x4c>
8111bbdc:	20800e17 	ldw	r2,56(r4)
8111bbe0:	10005a26 	beq	r2,zero,8111bd4c <_fseeko_r+0x1b4>
8111bbe4:	8080030b 	ldhu	r2,12(r16)
8111bbe8:	00c04204 	movi	r3,264
8111bbec:	1080420c 	andi	r2,r2,264
8111bbf0:	10c05b26 	beq	r2,r3,8111bd60 <_fseeko_r+0x1c8>
8111bbf4:	85000a17 	ldw	r20,40(r16)
8111bbf8:	a000f626 	beq	r20,zero,8111bfd4 <_fseeko_r+0x43c>
8111bbfc:	00800044 	movi	r2,1
8111bc00:	90803e26 	beq	r18,r2,8111bcfc <_fseeko_r+0x164>
8111bc04:	00800084 	movi	r2,2
8111bc08:	90801026 	beq	r18,r2,8111bc4c <_fseeko_r+0xb4>
8111bc0c:	90000f26 	beq	r18,zero,8111bc4c <_fseeko_r+0xb4>
8111bc10:	00800584 	movi	r2,22
8111bc14:	88800015 	stw	r2,0(r17)
8111bc18:	04ffffc4 	movi	r19,-1
8111bc1c:	9805883a 	mov	r2,r19
8111bc20:	dfc01717 	ldw	ra,92(sp)
8111bc24:	ddc01617 	ldw	r23,88(sp)
8111bc28:	dd801517 	ldw	r22,84(sp)
8111bc2c:	dd401417 	ldw	r21,80(sp)
8111bc30:	dd001317 	ldw	r20,76(sp)
8111bc34:	dcc01217 	ldw	r19,72(sp)
8111bc38:	dc801117 	ldw	r18,68(sp)
8111bc3c:	dc401017 	ldw	r17,64(sp)
8111bc40:	dc000f17 	ldw	r16,60(sp)
8111bc44:	dec01804 	addi	sp,sp,96
8111bc48:	f800283a 	ret
8111bc4c:	80800417 	ldw	r2,16(r16)
8111bc50:	002f883a 	mov	r23,zero
8111bc54:	0027883a 	mov	r19,zero
8111bc58:	1000cb26 	beq	r2,zero,8111bf88 <_fseeko_r+0x3f0>
8111bc5c:	8080030b 	ldhu	r2,12(r16)
8111bc60:	10c2068c 	andi	r3,r2,2074
8111bc64:	1800071e 	bne	r3,zero,8111bc84 <_fseeko_r+0xec>
8111bc68:	10c1000c 	andi	r3,r2,1024
8111bc6c:	1800451e 	bne	r3,zero,8111bd84 <_fseeko_r+0x1ec>
8111bc70:	00e044b4 	movhi	r3,33042
8111bc74:	18f56204 	addi	r3,r3,-10872
8111bc78:	a0c0b726 	beq	r20,r3,8111bf58 <_fseeko_r+0x3c0>
8111bc7c:	10820014 	ori	r2,r2,2048
8111bc80:	8080030d 	sth	r2,12(r16)
8111bc84:	800b883a 	mov	r5,r16
8111bc88:	8809883a 	mov	r4,r17
8111bc8c:	11255180 	call	81125518 <_fflush_r>
8111bc90:	1027883a 	mov	r19,r2
8111bc94:	103fe01e 	bne	r2,zero,8111bc18 <__reset+0xfb0fbc18>
8111bc98:	81400717 	ldw	r5,28(r16)
8111bc9c:	900f883a 	mov	r7,r18
8111bca0:	a80d883a 	mov	r6,r21
8111bca4:	8809883a 	mov	r4,r17
8111bca8:	a03ee83a 	callr	r20
8111bcac:	00ffffc4 	movi	r3,-1
8111bcb0:	10ffd926 	beq	r2,r3,8111bc18 <__reset+0xfb0fbc18>
8111bcb4:	81400c17 	ldw	r5,48(r16)
8111bcb8:	28000526 	beq	r5,zero,8111bcd0 <_fseeko_r+0x138>
8111bcbc:	80801004 	addi	r2,r16,64
8111bcc0:	28800226 	beq	r5,r2,8111bccc <_fseeko_r+0x134>
8111bcc4:	8809883a 	mov	r4,r17
8111bcc8:	1125dac0 	call	81125dac <_free_r>
8111bccc:	80000c15 	stw	zero,48(r16)
8111bcd0:	8080030b 	ldhu	r2,12(r16)
8111bcd4:	80c00417 	ldw	r3,16(r16)
8111bcd8:	80000115 	stw	zero,4(r16)
8111bcdc:	10bdf7cc 	andi	r2,r2,63455
8111bce0:	80c00015 	stw	r3,0(r16)
8111bce4:	8080030d 	sth	r2,12(r16)
8111bce8:	01800204 	movi	r6,8
8111bcec:	000b883a 	mov	r5,zero
8111bcf0:	81001704 	addi	r4,r16,92
8111bcf4:	111cc9c0 	call	8111cc9c <memset>
8111bcf8:	003fc806 	br	8111bc1c <__reset+0xfb0fbc1c>
8111bcfc:	800b883a 	mov	r5,r16
8111bd00:	8809883a 	mov	r4,r17
8111bd04:	11255180 	call	81125518 <_fflush_r>
8111bd08:	8080030b 	ldhu	r2,12(r16)
8111bd0c:	10c4000c 	andi	r3,r2,4096
8111bd10:	18008726 	beq	r3,zero,8111bf30 <_fseeko_r+0x398>
8111bd14:	84c01417 	ldw	r19,80(r16)
8111bd18:	10c0010c 	andi	r3,r2,4
8111bd1c:	1800431e 	bne	r3,zero,8111be2c <_fseeko_r+0x294>
8111bd20:	1080020c 	andi	r2,r2,8
8111bd24:	10008026 	beq	r2,zero,8111bf28 <_fseeko_r+0x390>
8111bd28:	80c00017 	ldw	r3,0(r16)
8111bd2c:	80800417 	ldw	r2,16(r16)
8111bd30:	18000226 	beq	r3,zero,8111bd3c <_fseeko_r+0x1a4>
8111bd34:	1887c83a 	sub	r3,r3,r2
8111bd38:	98e7883a 	add	r19,r19,r3
8111bd3c:	aceb883a 	add	r21,r21,r19
8111bd40:	05c00044 	movi	r23,1
8111bd44:	0025883a 	mov	r18,zero
8111bd48:	003fc306 	br	8111bc58 <__reset+0xfb0fbc58>
8111bd4c:	11259140 	call	81125914 <__sinit>
8111bd50:	8080030b 	ldhu	r2,12(r16)
8111bd54:	00c04204 	movi	r3,264
8111bd58:	1080420c 	andi	r2,r2,264
8111bd5c:	10ffa51e 	bne	r2,r3,8111bbf4 <__reset+0xfb0fbbf4>
8111bd60:	800b883a 	mov	r5,r16
8111bd64:	8809883a 	mov	r4,r17
8111bd68:	11255180 	call	81125518 <_fflush_r>
8111bd6c:	003fa106 	br	8111bbf4 <__reset+0xfb0fbbf4>
8111bd70:	8080030b 	ldhu	r2,12(r16)
8111bd74:	00c10004 	movi	r3,1024
8111bd78:	80c01315 	stw	r3,76(r16)
8111bd7c:	10c4b03a 	or	r2,r2,r3
8111bd80:	8080030d 	sth	r2,12(r16)
8111bd84:	9000311e 	bne	r18,zero,8111be4c <_fseeko_r+0x2b4>
8111bd88:	a82d883a 	mov	r22,r21
8111bd8c:	b800371e 	bne	r23,zero,8111be6c <_fseeko_r+0x2d4>
8111bd90:	8080030b 	ldhu	r2,12(r16)
8111bd94:	1084000c 	andi	r2,r2,4096
8111bd98:	10007f26 	beq	r2,zero,8111bf98 <_fseeko_r+0x400>
8111bd9c:	80801417 	ldw	r2,80(r16)
8111bda0:	81800117 	ldw	r6,4(r16)
8111bda4:	81400c17 	ldw	r5,48(r16)
8111bda8:	11a7c83a 	sub	r19,r2,r6
8111bdac:	28008226 	beq	r5,zero,8111bfb8 <_fseeko_r+0x420>
8111bdb0:	81c00f17 	ldw	r7,60(r16)
8111bdb4:	99e7c83a 	sub	r19,r19,r7
8111bdb8:	81000e17 	ldw	r4,56(r16)
8111bdbc:	80800417 	ldw	r2,16(r16)
8111bdc0:	99a7883a 	add	r19,r19,r6
8111bdc4:	2087c83a 	sub	r3,r4,r2
8111bdc8:	98e7c83a 	sub	r19,r19,r3
8111bdcc:	38c7883a 	add	r3,r7,r3
8111bdd0:	b4c02b16 	blt	r22,r19,8111be80 <_fseeko_r+0x2e8>
8111bdd4:	98c9883a 	add	r4,r19,r3
8111bdd8:	b100292e 	bgeu	r22,r4,8111be80 <_fseeko_r+0x2e8>
8111bddc:	b4e7c83a 	sub	r19,r22,r19
8111bde0:	14c5883a 	add	r2,r2,r19
8111bde4:	1ce7c83a 	sub	r19,r3,r19
8111bde8:	80800015 	stw	r2,0(r16)
8111bdec:	84c00115 	stw	r19,4(r16)
8111bdf0:	28000526 	beq	r5,zero,8111be08 <_fseeko_r+0x270>
8111bdf4:	80801004 	addi	r2,r16,64
8111bdf8:	28800226 	beq	r5,r2,8111be04 <_fseeko_r+0x26c>
8111bdfc:	8809883a 	mov	r4,r17
8111be00:	1125dac0 	call	81125dac <_free_r>
8111be04:	80000c15 	stw	zero,48(r16)
8111be08:	8080030b 	ldhu	r2,12(r16)
8111be0c:	01800204 	movi	r6,8
8111be10:	000b883a 	mov	r5,zero
8111be14:	10bff7cc 	andi	r2,r2,65503
8111be18:	8080030d 	sth	r2,12(r16)
8111be1c:	81001704 	addi	r4,r16,92
8111be20:	111cc9c0 	call	8111cc9c <memset>
8111be24:	0027883a 	mov	r19,zero
8111be28:	003f7c06 	br	8111bc1c <__reset+0xfb0fbc1c>
8111be2c:	80c00117 	ldw	r3,4(r16)
8111be30:	80800c17 	ldw	r2,48(r16)
8111be34:	98e7c83a 	sub	r19,r19,r3
8111be38:	10003b26 	beq	r2,zero,8111bf28 <_fseeko_r+0x390>
8111be3c:	80c00f17 	ldw	r3,60(r16)
8111be40:	80800417 	ldw	r2,16(r16)
8111be44:	98e7c83a 	sub	r19,r19,r3
8111be48:	003fbc06 	br	8111bd3c <__reset+0xfb0fbd3c>
8111be4c:	8140038f 	ldh	r5,14(r16)
8111be50:	d80d883a 	mov	r6,sp
8111be54:	8809883a 	mov	r4,r17
8111be58:	111c0000 	call	8111c000 <_fstat_r>
8111be5c:	103f891e 	bne	r2,zero,8111bc84 <__reset+0xfb0fbc84>
8111be60:	dd800417 	ldw	r22,16(sp)
8111be64:	adad883a 	add	r22,r21,r22
8111be68:	b83fc926 	beq	r23,zero,8111bd90 <__reset+0xfb0fbd90>
8111be6c:	81400c17 	ldw	r5,48(r16)
8111be70:	81800117 	ldw	r6,4(r16)
8111be74:	28005026 	beq	r5,zero,8111bfb8 <_fseeko_r+0x420>
8111be78:	81c00f17 	ldw	r7,60(r16)
8111be7c:	003fce06 	br	8111bdb8 <__reset+0xfb0fbdb8>
8111be80:	84c01317 	ldw	r19,76(r16)
8111be84:	81400717 	ldw	r5,28(r16)
8111be88:	000f883a 	mov	r7,zero
8111be8c:	04e7c83a 	sub	r19,zero,r19
8111be90:	9da6703a 	and	r19,r19,r22
8111be94:	980d883a 	mov	r6,r19
8111be98:	8809883a 	mov	r4,r17
8111be9c:	a03ee83a 	callr	r20
8111bea0:	00ffffc4 	movi	r3,-1
8111bea4:	10ff7726 	beq	r2,r3,8111bc84 <__reset+0xfb0fbc84>
8111bea8:	80800417 	ldw	r2,16(r16)
8111beac:	81400c17 	ldw	r5,48(r16)
8111beb0:	80000115 	stw	zero,4(r16)
8111beb4:	80800015 	stw	r2,0(r16)
8111beb8:	28000526 	beq	r5,zero,8111bed0 <_fseeko_r+0x338>
8111bebc:	80801004 	addi	r2,r16,64
8111bec0:	28800226 	beq	r5,r2,8111becc <_fseeko_r+0x334>
8111bec4:	8809883a 	mov	r4,r17
8111bec8:	1125dac0 	call	81125dac <_free_r>
8111becc:	80000c15 	stw	zero,48(r16)
8111bed0:	8080030b 	ldhu	r2,12(r16)
8111bed4:	b4e7c83a 	sub	r19,r22,r19
8111bed8:	10bff7cc 	andi	r2,r2,65503
8111bedc:	8080030d 	sth	r2,12(r16)
8111bee0:	98000b26 	beq	r19,zero,8111bf10 <_fseeko_r+0x378>
8111bee4:	800b883a 	mov	r5,r16
8111bee8:	8809883a 	mov	r4,r17
8111beec:	111d1180 	call	8111d118 <__srefill_r>
8111bef0:	103f641e 	bne	r2,zero,8111bc84 <__reset+0xfb0fbc84>
8111bef4:	80800117 	ldw	r2,4(r16)
8111bef8:	14ff6236 	bltu	r2,r19,8111bc84 <__reset+0xfb0fbc84>
8111befc:	80c00017 	ldw	r3,0(r16)
8111bf00:	14c5c83a 	sub	r2,r2,r19
8111bf04:	80800115 	stw	r2,4(r16)
8111bf08:	1ce7883a 	add	r19,r3,r19
8111bf0c:	84c00015 	stw	r19,0(r16)
8111bf10:	01800204 	movi	r6,8
8111bf14:	000b883a 	mov	r5,zero
8111bf18:	81001704 	addi	r4,r16,92
8111bf1c:	111cc9c0 	call	8111cc9c <memset>
8111bf20:	0027883a 	mov	r19,zero
8111bf24:	003f3d06 	br	8111bc1c <__reset+0xfb0fbc1c>
8111bf28:	80800417 	ldw	r2,16(r16)
8111bf2c:	003f8306 	br	8111bd3c <__reset+0xfb0fbd3c>
8111bf30:	81400717 	ldw	r5,28(r16)
8111bf34:	900f883a 	mov	r7,r18
8111bf38:	000d883a 	mov	r6,zero
8111bf3c:	8809883a 	mov	r4,r17
8111bf40:	a03ee83a 	callr	r20
8111bf44:	1027883a 	mov	r19,r2
8111bf48:	00bfffc4 	movi	r2,-1
8111bf4c:	98bf3226 	beq	r19,r2,8111bc18 <__reset+0xfb0fbc18>
8111bf50:	8080030b 	ldhu	r2,12(r16)
8111bf54:	003f7006 	br	8111bd18 <__reset+0xfb0fbd18>
8111bf58:	8140038f 	ldh	r5,14(r16)
8111bf5c:	283f4716 	blt	r5,zero,8111bc7c <__reset+0xfb0fbc7c>
8111bf60:	d80d883a 	mov	r6,sp
8111bf64:	8809883a 	mov	r4,r17
8111bf68:	111c0000 	call	8111c000 <_fstat_r>
8111bf6c:	1000041e 	bne	r2,zero,8111bf80 <_fseeko_r+0x3e8>
8111bf70:	d8800117 	ldw	r2,4(sp)
8111bf74:	00e00014 	movui	r3,32768
8111bf78:	10bc000c 	andi	r2,r2,61440
8111bf7c:	10ff7c26 	beq	r2,r3,8111bd70 <__reset+0xfb0fbd70>
8111bf80:	8080030b 	ldhu	r2,12(r16)
8111bf84:	003f3d06 	br	8111bc7c <__reset+0xfb0fbc7c>
8111bf88:	800b883a 	mov	r5,r16
8111bf8c:	8809883a 	mov	r4,r17
8111bf90:	111c1740 	call	8111c174 <__smakebuf_r>
8111bf94:	003f3106 	br	8111bc5c <__reset+0xfb0fbc5c>
8111bf98:	81400717 	ldw	r5,28(r16)
8111bf9c:	01c00044 	movi	r7,1
8111bfa0:	000d883a 	mov	r6,zero
8111bfa4:	8809883a 	mov	r4,r17
8111bfa8:	a03ee83a 	callr	r20
8111bfac:	00ffffc4 	movi	r3,-1
8111bfb0:	10ff7b1e 	bne	r2,r3,8111bda0 <__reset+0xfb0fbda0>
8111bfb4:	003f3306 	br	8111bc84 <__reset+0xfb0fbc84>
8111bfb8:	80c00017 	ldw	r3,0(r16)
8111bfbc:	80800417 	ldw	r2,16(r16)
8111bfc0:	000b883a 	mov	r5,zero
8111bfc4:	1887c83a 	sub	r3,r3,r2
8111bfc8:	98e7c83a 	sub	r19,r19,r3
8111bfcc:	30c7883a 	add	r3,r6,r3
8111bfd0:	003f7f06 	br	8111bdd0 <__reset+0xfb0fbdd0>
8111bfd4:	00800744 	movi	r2,29
8111bfd8:	88800015 	stw	r2,0(r17)
8111bfdc:	04ffffc4 	movi	r19,-1
8111bfe0:	003f0e06 	br	8111bc1c <__reset+0xfb0fbc1c>

8111bfe4 <fseeko>:
8111bfe4:	00a04574 	movhi	r2,33045
8111bfe8:	10b52904 	addi	r2,r2,-11100
8111bfec:	300f883a 	mov	r7,r6
8111bff0:	280d883a 	mov	r6,r5
8111bff4:	200b883a 	mov	r5,r4
8111bff8:	11000017 	ldw	r4,0(r2)
8111bffc:	111bb981 	jmpi	8111bb98 <_fseeko_r>

8111c000 <_fstat_r>:
8111c000:	defffd04 	addi	sp,sp,-12
8111c004:	de00012e 	bgeu	sp,et,8111c00c <_fstat_r+0xc>
8111c008:	003b68fa 	trap	3
8111c00c:	2805883a 	mov	r2,r5
8111c010:	dc000015 	stw	r16,0(sp)
8111c014:	04204574 	movhi	r16,33045
8111c018:	dc400115 	stw	r17,4(sp)
8111c01c:	84359604 	addi	r16,r16,-10664
8111c020:	2023883a 	mov	r17,r4
8111c024:	300b883a 	mov	r5,r6
8111c028:	1009883a 	mov	r4,r2
8111c02c:	dfc00215 	stw	ra,8(sp)
8111c030:	80000015 	stw	zero,0(r16)
8111c034:	11315ec0 	call	811315ec <fstat>
8111c038:	00ffffc4 	movi	r3,-1
8111c03c:	10c00526 	beq	r2,r3,8111c054 <_fstat_r+0x54>
8111c040:	dfc00217 	ldw	ra,8(sp)
8111c044:	dc400117 	ldw	r17,4(sp)
8111c048:	dc000017 	ldw	r16,0(sp)
8111c04c:	dec00304 	addi	sp,sp,12
8111c050:	f800283a 	ret
8111c054:	80c00017 	ldw	r3,0(r16)
8111c058:	183ff926 	beq	r3,zero,8111c040 <__reset+0xfb0fc040>
8111c05c:	88c00015 	stw	r3,0(r17)
8111c060:	003ff706 	br	8111c040 <__reset+0xfb0fc040>

8111c064 <_fwrite_r>:
8111c064:	defff504 	addi	sp,sp,-44
8111c068:	de00012e 	bgeu	sp,et,8111c070 <_fwrite_r+0xc>
8111c06c:	003b68fa 	trap	3
8111c070:	dc800815 	stw	r18,32(sp)
8111c074:	39a5383a 	mul	r18,r7,r6
8111c078:	d8800304 	addi	r2,sp,12
8111c07c:	d8800015 	stw	r2,0(sp)
8111c080:	00800044 	movi	r2,1
8111c084:	dcc00915 	stw	r19,36(sp)
8111c088:	dc400715 	stw	r17,28(sp)
8111c08c:	dc000615 	stw	r16,24(sp)
8111c090:	d9400315 	stw	r5,12(sp)
8111c094:	dfc00a15 	stw	ra,40(sp)
8111c098:	dc800415 	stw	r18,16(sp)
8111c09c:	dc800215 	stw	r18,8(sp)
8111c0a0:	d8800115 	stw	r2,4(sp)
8111c0a4:	3027883a 	mov	r19,r6
8111c0a8:	3821883a 	mov	r16,r7
8111c0ac:	2023883a 	mov	r17,r4
8111c0b0:	d9400b17 	ldw	r5,44(sp)
8111c0b4:	20000226 	beq	r4,zero,8111c0c0 <_fwrite_r+0x5c>
8111c0b8:	20800e17 	ldw	r2,56(r4)
8111c0bc:	10001a26 	beq	r2,zero,8111c128 <_fwrite_r+0xc4>
8111c0c0:	2880030b 	ldhu	r2,12(r5)
8111c0c4:	10c8000c 	andi	r3,r2,8192
8111c0c8:	1800061e 	bne	r3,zero,8111c0e4 <_fwrite_r+0x80>
8111c0cc:	29001917 	ldw	r4,100(r5)
8111c0d0:	00f7ffc4 	movi	r3,-8193
8111c0d4:	10880014 	ori	r2,r2,8192
8111c0d8:	20c6703a 	and	r3,r4,r3
8111c0dc:	2880030d 	sth	r2,12(r5)
8111c0e0:	28c01915 	stw	r3,100(r5)
8111c0e4:	d80d883a 	mov	r6,sp
8111c0e8:	8809883a 	mov	r4,r17
8111c0ec:	11260c40 	call	811260c4 <__sfvwrite_r>
8111c0f0:	10000b26 	beq	r2,zero,8111c120 <_fwrite_r+0xbc>
8111c0f4:	d9000217 	ldw	r4,8(sp)
8111c0f8:	980b883a 	mov	r5,r19
8111c0fc:	9109c83a 	sub	r4,r18,r4
8111c100:	112f1340 	call	8112f134 <__udivsi3>
8111c104:	dfc00a17 	ldw	ra,40(sp)
8111c108:	dcc00917 	ldw	r19,36(sp)
8111c10c:	dc800817 	ldw	r18,32(sp)
8111c110:	dc400717 	ldw	r17,28(sp)
8111c114:	dc000617 	ldw	r16,24(sp)
8111c118:	dec00b04 	addi	sp,sp,44
8111c11c:	f800283a 	ret
8111c120:	8005883a 	mov	r2,r16
8111c124:	003ff706 	br	8111c104 <__reset+0xfb0fc104>
8111c128:	d9400515 	stw	r5,20(sp)
8111c12c:	11259140 	call	81125914 <__sinit>
8111c130:	d9400517 	ldw	r5,20(sp)
8111c134:	003fe206 	br	8111c0c0 <__reset+0xfb0fc0c0>

8111c138 <fwrite>:
8111c138:	defffe04 	addi	sp,sp,-8
8111c13c:	00a04574 	movhi	r2,33045
8111c140:	de00012e 	bgeu	sp,et,8111c148 <fwrite+0x10>
8111c144:	003b68fa 	trap	3
8111c148:	10b52904 	addi	r2,r2,-11100
8111c14c:	d9c00015 	stw	r7,0(sp)
8111c150:	300f883a 	mov	r7,r6
8111c154:	280d883a 	mov	r6,r5
8111c158:	200b883a 	mov	r5,r4
8111c15c:	11000017 	ldw	r4,0(r2)
8111c160:	dfc00115 	stw	ra,4(sp)
8111c164:	111c0640 	call	8111c064 <_fwrite_r>
8111c168:	dfc00117 	ldw	ra,4(sp)
8111c16c:	dec00204 	addi	sp,sp,8
8111c170:	f800283a 	ret

8111c174 <__smakebuf_r>:
8111c174:	2880030b 	ldhu	r2,12(r5)
8111c178:	10c0008c 	andi	r3,r2,2
8111c17c:	1800431e 	bne	r3,zero,8111c28c <__smakebuf_r+0x118>
8111c180:	deffec04 	addi	sp,sp,-80
8111c184:	de00012e 	bgeu	sp,et,8111c18c <__smakebuf_r+0x18>
8111c188:	003b68fa 	trap	3
8111c18c:	dc000f15 	stw	r16,60(sp)
8111c190:	2821883a 	mov	r16,r5
8111c194:	2940038f 	ldh	r5,14(r5)
8111c198:	dc401015 	stw	r17,64(sp)
8111c19c:	dfc01315 	stw	ra,76(sp)
8111c1a0:	dcc01215 	stw	r19,72(sp)
8111c1a4:	dc801115 	stw	r18,68(sp)
8111c1a8:	2023883a 	mov	r17,r4
8111c1ac:	28001c16 	blt	r5,zero,8111c220 <__smakebuf_r+0xac>
8111c1b0:	d80d883a 	mov	r6,sp
8111c1b4:	111c0000 	call	8111c000 <_fstat_r>
8111c1b8:	10001816 	blt	r2,zero,8111c21c <__smakebuf_r+0xa8>
8111c1bc:	d8800117 	ldw	r2,4(sp)
8111c1c0:	00e00014 	movui	r3,32768
8111c1c4:	10bc000c 	andi	r2,r2,61440
8111c1c8:	14c80020 	cmpeqi	r19,r2,8192
8111c1cc:	10c03726 	beq	r2,r3,8111c2ac <__smakebuf_r+0x138>
8111c1d0:	80c0030b 	ldhu	r3,12(r16)
8111c1d4:	18c20014 	ori	r3,r3,2048
8111c1d8:	80c0030d 	sth	r3,12(r16)
8111c1dc:	00c80004 	movi	r3,8192
8111c1e0:	10c0521e 	bne	r2,r3,8111c32c <__smakebuf_r+0x1b8>
8111c1e4:	8140038f 	ldh	r5,14(r16)
8111c1e8:	8809883a 	mov	r4,r17
8111c1ec:	11267200 	call	81126720 <_isatty_r>
8111c1f0:	10004c26 	beq	r2,zero,8111c324 <__smakebuf_r+0x1b0>
8111c1f4:	8080030b 	ldhu	r2,12(r16)
8111c1f8:	80c010c4 	addi	r3,r16,67
8111c1fc:	80c00015 	stw	r3,0(r16)
8111c200:	10800054 	ori	r2,r2,1
8111c204:	8080030d 	sth	r2,12(r16)
8111c208:	00800044 	movi	r2,1
8111c20c:	80c00415 	stw	r3,16(r16)
8111c210:	80800515 	stw	r2,20(r16)
8111c214:	04810004 	movi	r18,1024
8111c218:	00000706 	br	8111c238 <__smakebuf_r+0xc4>
8111c21c:	8080030b 	ldhu	r2,12(r16)
8111c220:	10c0200c 	andi	r3,r2,128
8111c224:	18001f1e 	bne	r3,zero,8111c2a4 <__smakebuf_r+0x130>
8111c228:	04810004 	movi	r18,1024
8111c22c:	10820014 	ori	r2,r2,2048
8111c230:	8080030d 	sth	r2,12(r16)
8111c234:	0027883a 	mov	r19,zero
8111c238:	900b883a 	mov	r5,r18
8111c23c:	8809883a 	mov	r4,r17
8111c240:	111c3380 	call	8111c338 <_malloc_r>
8111c244:	10002c26 	beq	r2,zero,8111c2f8 <__smakebuf_r+0x184>
8111c248:	80c0030b 	ldhu	r3,12(r16)
8111c24c:	012044b4 	movhi	r4,33042
8111c250:	21156d04 	addi	r4,r4,21940
8111c254:	89000f15 	stw	r4,60(r17)
8111c258:	18c02014 	ori	r3,r3,128
8111c25c:	80c0030d 	sth	r3,12(r16)
8111c260:	80800015 	stw	r2,0(r16)
8111c264:	80800415 	stw	r2,16(r16)
8111c268:	84800515 	stw	r18,20(r16)
8111c26c:	98001a1e 	bne	r19,zero,8111c2d8 <__smakebuf_r+0x164>
8111c270:	dfc01317 	ldw	ra,76(sp)
8111c274:	dcc01217 	ldw	r19,72(sp)
8111c278:	dc801117 	ldw	r18,68(sp)
8111c27c:	dc401017 	ldw	r17,64(sp)
8111c280:	dc000f17 	ldw	r16,60(sp)
8111c284:	dec01404 	addi	sp,sp,80
8111c288:	f800283a 	ret
8111c28c:	288010c4 	addi	r2,r5,67
8111c290:	28800015 	stw	r2,0(r5)
8111c294:	28800415 	stw	r2,16(r5)
8111c298:	00800044 	movi	r2,1
8111c29c:	28800515 	stw	r2,20(r5)
8111c2a0:	f800283a 	ret
8111c2a4:	04801004 	movi	r18,64
8111c2a8:	003fe006 	br	8111c22c <__reset+0xfb0fc22c>
8111c2ac:	81000a17 	ldw	r4,40(r16)
8111c2b0:	00e044b4 	movhi	r3,33042
8111c2b4:	18f56204 	addi	r3,r3,-10872
8111c2b8:	20ffc51e 	bne	r4,r3,8111c1d0 <__reset+0xfb0fc1d0>
8111c2bc:	8080030b 	ldhu	r2,12(r16)
8111c2c0:	04810004 	movi	r18,1024
8111c2c4:	84801315 	stw	r18,76(r16)
8111c2c8:	1484b03a 	or	r2,r2,r18
8111c2cc:	8080030d 	sth	r2,12(r16)
8111c2d0:	0027883a 	mov	r19,zero
8111c2d4:	003fd806 	br	8111c238 <__reset+0xfb0fc238>
8111c2d8:	8140038f 	ldh	r5,14(r16)
8111c2dc:	8809883a 	mov	r4,r17
8111c2e0:	11267200 	call	81126720 <_isatty_r>
8111c2e4:	103fe226 	beq	r2,zero,8111c270 <__reset+0xfb0fc270>
8111c2e8:	8080030b 	ldhu	r2,12(r16)
8111c2ec:	10800054 	ori	r2,r2,1
8111c2f0:	8080030d 	sth	r2,12(r16)
8111c2f4:	003fde06 	br	8111c270 <__reset+0xfb0fc270>
8111c2f8:	8080030b 	ldhu	r2,12(r16)
8111c2fc:	10c0800c 	andi	r3,r2,512
8111c300:	183fdb1e 	bne	r3,zero,8111c270 <__reset+0xfb0fc270>
8111c304:	10800094 	ori	r2,r2,2
8111c308:	80c010c4 	addi	r3,r16,67
8111c30c:	8080030d 	sth	r2,12(r16)
8111c310:	00800044 	movi	r2,1
8111c314:	80c00015 	stw	r3,0(r16)
8111c318:	80c00415 	stw	r3,16(r16)
8111c31c:	80800515 	stw	r2,20(r16)
8111c320:	003fd306 	br	8111c270 <__reset+0xfb0fc270>
8111c324:	04810004 	movi	r18,1024
8111c328:	003fc306 	br	8111c238 <__reset+0xfb0fc238>
8111c32c:	0027883a 	mov	r19,zero
8111c330:	04810004 	movi	r18,1024
8111c334:	003fc006 	br	8111c238 <__reset+0xfb0fc238>

8111c338 <_malloc_r>:
8111c338:	defff504 	addi	sp,sp,-44
8111c33c:	de00012e 	bgeu	sp,et,8111c344 <_malloc_r+0xc>
8111c340:	003b68fa 	trap	3
8111c344:	288002c4 	addi	r2,r5,11
8111c348:	dc800315 	stw	r18,12(sp)
8111c34c:	dfc00a15 	stw	ra,40(sp)
8111c350:	df000915 	stw	fp,36(sp)
8111c354:	ddc00815 	stw	r23,32(sp)
8111c358:	dd800715 	stw	r22,28(sp)
8111c35c:	dd400615 	stw	r21,24(sp)
8111c360:	dd000515 	stw	r20,20(sp)
8111c364:	dcc00415 	stw	r19,16(sp)
8111c368:	dc400215 	stw	r17,8(sp)
8111c36c:	dc000115 	stw	r16,4(sp)
8111c370:	00c00584 	movi	r3,22
8111c374:	2025883a 	mov	r18,r4
8111c378:	18807f2e 	bgeu	r3,r2,8111c578 <_malloc_r+0x240>
8111c37c:	047ffe04 	movi	r17,-8
8111c380:	1462703a 	and	r17,r2,r17
8111c384:	8800a316 	blt	r17,zero,8111c614 <_malloc_r+0x2dc>
8111c388:	8940a236 	bltu	r17,r5,8111c614 <_malloc_r+0x2dc>
8111c38c:	11331340 	call	81133134 <__malloc_lock>
8111c390:	00807dc4 	movi	r2,503
8111c394:	1441e92e 	bgeu	r2,r17,8111cb3c <_malloc_r+0x804>
8111c398:	8804d27a 	srli	r2,r17,9
8111c39c:	1000a126 	beq	r2,zero,8111c624 <_malloc_r+0x2ec>
8111c3a0:	00c00104 	movi	r3,4
8111c3a4:	18811e36 	bltu	r3,r2,8111c820 <_malloc_r+0x4e8>
8111c3a8:	8804d1ba 	srli	r2,r17,6
8111c3ac:	12000e44 	addi	r8,r2,57
8111c3b0:	11c00e04 	addi	r7,r2,56
8111c3b4:	4209883a 	add	r4,r8,r8
8111c3b8:	04e04574 	movhi	r19,33045
8111c3bc:	2109883a 	add	r4,r4,r4
8111c3c0:	9ceee704 	addi	r19,r19,-17508
8111c3c4:	2109883a 	add	r4,r4,r4
8111c3c8:	9909883a 	add	r4,r19,r4
8111c3cc:	24000117 	ldw	r16,4(r4)
8111c3d0:	213ffe04 	addi	r4,r4,-8
8111c3d4:	24009726 	beq	r4,r16,8111c634 <_malloc_r+0x2fc>
8111c3d8:	80800117 	ldw	r2,4(r16)
8111c3dc:	01bfff04 	movi	r6,-4
8111c3e0:	014003c4 	movi	r5,15
8111c3e4:	1184703a 	and	r2,r2,r6
8111c3e8:	1447c83a 	sub	r3,r2,r17
8111c3ec:	28c00716 	blt	r5,r3,8111c40c <_malloc_r+0xd4>
8111c3f0:	1800920e 	bge	r3,zero,8111c63c <_malloc_r+0x304>
8111c3f4:	84000317 	ldw	r16,12(r16)
8111c3f8:	24008e26 	beq	r4,r16,8111c634 <_malloc_r+0x2fc>
8111c3fc:	80800117 	ldw	r2,4(r16)
8111c400:	1184703a 	and	r2,r2,r6
8111c404:	1447c83a 	sub	r3,r2,r17
8111c408:	28fff90e 	bge	r5,r3,8111c3f0 <__reset+0xfb0fc3f0>
8111c40c:	3809883a 	mov	r4,r7
8111c410:	01a04574 	movhi	r6,33045
8111c414:	9c000417 	ldw	r16,16(r19)
8111c418:	31aee704 	addi	r6,r6,-17508
8111c41c:	32000204 	addi	r8,r6,8
8111c420:	82013426 	beq	r16,r8,8111c8f4 <_malloc_r+0x5bc>
8111c424:	80c00117 	ldw	r3,4(r16)
8111c428:	00bfff04 	movi	r2,-4
8111c42c:	188e703a 	and	r7,r3,r2
8111c430:	3c45c83a 	sub	r2,r7,r17
8111c434:	00c003c4 	movi	r3,15
8111c438:	18811f16 	blt	r3,r2,8111c8b8 <_malloc_r+0x580>
8111c43c:	32000515 	stw	r8,20(r6)
8111c440:	32000415 	stw	r8,16(r6)
8111c444:	10007f0e 	bge	r2,zero,8111c644 <_malloc_r+0x30c>
8111c448:	00807fc4 	movi	r2,511
8111c44c:	11c0fd36 	bltu	r2,r7,8111c844 <_malloc_r+0x50c>
8111c450:	3806d0fa 	srli	r3,r7,3
8111c454:	01c00044 	movi	r7,1
8111c458:	30800117 	ldw	r2,4(r6)
8111c45c:	19400044 	addi	r5,r3,1
8111c460:	294b883a 	add	r5,r5,r5
8111c464:	1807d0ba 	srai	r3,r3,2
8111c468:	294b883a 	add	r5,r5,r5
8111c46c:	294b883a 	add	r5,r5,r5
8111c470:	298b883a 	add	r5,r5,r6
8111c474:	38c6983a 	sll	r3,r7,r3
8111c478:	29c00017 	ldw	r7,0(r5)
8111c47c:	2a7ffe04 	addi	r9,r5,-8
8111c480:	1886b03a 	or	r3,r3,r2
8111c484:	82400315 	stw	r9,12(r16)
8111c488:	81c00215 	stw	r7,8(r16)
8111c48c:	30c00115 	stw	r3,4(r6)
8111c490:	2c000015 	stw	r16,0(r5)
8111c494:	3c000315 	stw	r16,12(r7)
8111c498:	2005d0ba 	srai	r2,r4,2
8111c49c:	01400044 	movi	r5,1
8111c4a0:	288a983a 	sll	r5,r5,r2
8111c4a4:	19406f36 	bltu	r3,r5,8111c664 <_malloc_r+0x32c>
8111c4a8:	28c4703a 	and	r2,r5,r3
8111c4ac:	10000a1e 	bne	r2,zero,8111c4d8 <_malloc_r+0x1a0>
8111c4b0:	00bfff04 	movi	r2,-4
8111c4b4:	294b883a 	add	r5,r5,r5
8111c4b8:	2088703a 	and	r4,r4,r2
8111c4bc:	28c4703a 	and	r2,r5,r3
8111c4c0:	21000104 	addi	r4,r4,4
8111c4c4:	1000041e 	bne	r2,zero,8111c4d8 <_malloc_r+0x1a0>
8111c4c8:	294b883a 	add	r5,r5,r5
8111c4cc:	28c4703a 	and	r2,r5,r3
8111c4d0:	21000104 	addi	r4,r4,4
8111c4d4:	103ffc26 	beq	r2,zero,8111c4c8 <__reset+0xfb0fc4c8>
8111c4d8:	02bfff04 	movi	r10,-4
8111c4dc:	024003c4 	movi	r9,15
8111c4e0:	21800044 	addi	r6,r4,1
8111c4e4:	318d883a 	add	r6,r6,r6
8111c4e8:	318d883a 	add	r6,r6,r6
8111c4ec:	318d883a 	add	r6,r6,r6
8111c4f0:	998d883a 	add	r6,r19,r6
8111c4f4:	333ffe04 	addi	r12,r6,-8
8111c4f8:	2017883a 	mov	r11,r4
8111c4fc:	31800104 	addi	r6,r6,4
8111c500:	34000017 	ldw	r16,0(r6)
8111c504:	31fffd04 	addi	r7,r6,-12
8111c508:	81c0041e 	bne	r16,r7,8111c51c <_malloc_r+0x1e4>
8111c50c:	0000fb06 	br	8111c8fc <_malloc_r+0x5c4>
8111c510:	1801030e 	bge	r3,zero,8111c920 <_malloc_r+0x5e8>
8111c514:	84000317 	ldw	r16,12(r16)
8111c518:	81c0f826 	beq	r16,r7,8111c8fc <_malloc_r+0x5c4>
8111c51c:	80800117 	ldw	r2,4(r16)
8111c520:	1284703a 	and	r2,r2,r10
8111c524:	1447c83a 	sub	r3,r2,r17
8111c528:	48fff90e 	bge	r9,r3,8111c510 <__reset+0xfb0fc510>
8111c52c:	80800317 	ldw	r2,12(r16)
8111c530:	81000217 	ldw	r4,8(r16)
8111c534:	89400054 	ori	r5,r17,1
8111c538:	81400115 	stw	r5,4(r16)
8111c53c:	20800315 	stw	r2,12(r4)
8111c540:	11000215 	stw	r4,8(r2)
8111c544:	8463883a 	add	r17,r16,r17
8111c548:	9c400515 	stw	r17,20(r19)
8111c54c:	9c400415 	stw	r17,16(r19)
8111c550:	18800054 	ori	r2,r3,1
8111c554:	88800115 	stw	r2,4(r17)
8111c558:	8a000315 	stw	r8,12(r17)
8111c55c:	8a000215 	stw	r8,8(r17)
8111c560:	88e3883a 	add	r17,r17,r3
8111c564:	88c00015 	stw	r3,0(r17)
8111c568:	9009883a 	mov	r4,r18
8111c56c:	113325c0 	call	8113325c <__malloc_unlock>
8111c570:	80800204 	addi	r2,r16,8
8111c574:	00001b06 	br	8111c5e4 <_malloc_r+0x2ac>
8111c578:	04400404 	movi	r17,16
8111c57c:	89402536 	bltu	r17,r5,8111c614 <_malloc_r+0x2dc>
8111c580:	11331340 	call	81133134 <__malloc_lock>
8111c584:	00800184 	movi	r2,6
8111c588:	01000084 	movi	r4,2
8111c58c:	04e04574 	movhi	r19,33045
8111c590:	1085883a 	add	r2,r2,r2
8111c594:	9ceee704 	addi	r19,r19,-17508
8111c598:	1085883a 	add	r2,r2,r2
8111c59c:	9885883a 	add	r2,r19,r2
8111c5a0:	14000117 	ldw	r16,4(r2)
8111c5a4:	10fffe04 	addi	r3,r2,-8
8111c5a8:	80c0d926 	beq	r16,r3,8111c910 <_malloc_r+0x5d8>
8111c5ac:	80c00117 	ldw	r3,4(r16)
8111c5b0:	81000317 	ldw	r4,12(r16)
8111c5b4:	00bfff04 	movi	r2,-4
8111c5b8:	1884703a 	and	r2,r3,r2
8111c5bc:	81400217 	ldw	r5,8(r16)
8111c5c0:	8085883a 	add	r2,r16,r2
8111c5c4:	10c00117 	ldw	r3,4(r2)
8111c5c8:	29000315 	stw	r4,12(r5)
8111c5cc:	21400215 	stw	r5,8(r4)
8111c5d0:	18c00054 	ori	r3,r3,1
8111c5d4:	10c00115 	stw	r3,4(r2)
8111c5d8:	9009883a 	mov	r4,r18
8111c5dc:	113325c0 	call	8113325c <__malloc_unlock>
8111c5e0:	80800204 	addi	r2,r16,8
8111c5e4:	dfc00a17 	ldw	ra,40(sp)
8111c5e8:	df000917 	ldw	fp,36(sp)
8111c5ec:	ddc00817 	ldw	r23,32(sp)
8111c5f0:	dd800717 	ldw	r22,28(sp)
8111c5f4:	dd400617 	ldw	r21,24(sp)
8111c5f8:	dd000517 	ldw	r20,20(sp)
8111c5fc:	dcc00417 	ldw	r19,16(sp)
8111c600:	dc800317 	ldw	r18,12(sp)
8111c604:	dc400217 	ldw	r17,8(sp)
8111c608:	dc000117 	ldw	r16,4(sp)
8111c60c:	dec00b04 	addi	sp,sp,44
8111c610:	f800283a 	ret
8111c614:	00800304 	movi	r2,12
8111c618:	90800015 	stw	r2,0(r18)
8111c61c:	0005883a 	mov	r2,zero
8111c620:	003ff006 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c624:	01002004 	movi	r4,128
8111c628:	02001004 	movi	r8,64
8111c62c:	01c00fc4 	movi	r7,63
8111c630:	003f6106 	br	8111c3b8 <__reset+0xfb0fc3b8>
8111c634:	4009883a 	mov	r4,r8
8111c638:	003f7506 	br	8111c410 <__reset+0xfb0fc410>
8111c63c:	81000317 	ldw	r4,12(r16)
8111c640:	003fde06 	br	8111c5bc <__reset+0xfb0fc5bc>
8111c644:	81c5883a 	add	r2,r16,r7
8111c648:	11400117 	ldw	r5,4(r2)
8111c64c:	9009883a 	mov	r4,r18
8111c650:	29400054 	ori	r5,r5,1
8111c654:	11400115 	stw	r5,4(r2)
8111c658:	113325c0 	call	8113325c <__malloc_unlock>
8111c65c:	80800204 	addi	r2,r16,8
8111c660:	003fe006 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c664:	9c000217 	ldw	r16,8(r19)
8111c668:	00bfff04 	movi	r2,-4
8111c66c:	85800117 	ldw	r22,4(r16)
8111c670:	b0ac703a 	and	r22,r22,r2
8111c674:	b4400336 	bltu	r22,r17,8111c684 <_malloc_r+0x34c>
8111c678:	b445c83a 	sub	r2,r22,r17
8111c67c:	00c003c4 	movi	r3,15
8111c680:	18805d16 	blt	r3,r2,8111c7f8 <_malloc_r+0x4c0>
8111c684:	05e04574 	movhi	r23,33045
8111c688:	00a04574 	movhi	r2,33045
8111c68c:	10b59904 	addi	r2,r2,-10652
8111c690:	bdf52a04 	addi	r23,r23,-11096
8111c694:	15400017 	ldw	r21,0(r2)
8111c698:	b8c00017 	ldw	r3,0(r23)
8111c69c:	00bfffc4 	movi	r2,-1
8111c6a0:	858d883a 	add	r6,r16,r22
8111c6a4:	8d6b883a 	add	r21,r17,r21
8111c6a8:	1880ea26 	beq	r3,r2,8111ca54 <_malloc_r+0x71c>
8111c6ac:	ad4403c4 	addi	r21,r21,4111
8111c6b0:	00bc0004 	movi	r2,-4096
8111c6b4:	a8aa703a 	and	r21,r21,r2
8111c6b8:	a80b883a 	mov	r5,r21
8111c6bc:	9009883a 	mov	r4,r18
8111c6c0:	d9800015 	stw	r6,0(sp)
8111c6c4:	111d2f40 	call	8111d2f4 <_sbrk_r>
8111c6c8:	1029883a 	mov	r20,r2
8111c6cc:	00bfffc4 	movi	r2,-1
8111c6d0:	d9800017 	ldw	r6,0(sp)
8111c6d4:	a080e826 	beq	r20,r2,8111ca78 <_malloc_r+0x740>
8111c6d8:	a180a636 	bltu	r20,r6,8111c974 <_malloc_r+0x63c>
8111c6dc:	07204574 	movhi	fp,33045
8111c6e0:	e7362604 	addi	fp,fp,-10088
8111c6e4:	e0800017 	ldw	r2,0(fp)
8111c6e8:	a887883a 	add	r3,r21,r2
8111c6ec:	e0c00015 	stw	r3,0(fp)
8111c6f0:	3500e626 	beq	r6,r20,8111ca8c <_malloc_r+0x754>
8111c6f4:	b9000017 	ldw	r4,0(r23)
8111c6f8:	00bfffc4 	movi	r2,-1
8111c6fc:	2080ee26 	beq	r4,r2,8111cab8 <_malloc_r+0x780>
8111c700:	a185c83a 	sub	r2,r20,r6
8111c704:	10c5883a 	add	r2,r2,r3
8111c708:	e0800015 	stw	r2,0(fp)
8111c70c:	a0c001cc 	andi	r3,r20,7
8111c710:	1800bc26 	beq	r3,zero,8111ca04 <_malloc_r+0x6cc>
8111c714:	a0e9c83a 	sub	r20,r20,r3
8111c718:	00840204 	movi	r2,4104
8111c71c:	a5000204 	addi	r20,r20,8
8111c720:	10c7c83a 	sub	r3,r2,r3
8111c724:	a545883a 	add	r2,r20,r21
8111c728:	1083ffcc 	andi	r2,r2,4095
8111c72c:	18abc83a 	sub	r21,r3,r2
8111c730:	a80b883a 	mov	r5,r21
8111c734:	9009883a 	mov	r4,r18
8111c738:	111d2f40 	call	8111d2f4 <_sbrk_r>
8111c73c:	00ffffc4 	movi	r3,-1
8111c740:	10c0e126 	beq	r2,r3,8111cac8 <_malloc_r+0x790>
8111c744:	1505c83a 	sub	r2,r2,r20
8111c748:	1545883a 	add	r2,r2,r21
8111c74c:	10800054 	ori	r2,r2,1
8111c750:	e0c00017 	ldw	r3,0(fp)
8111c754:	9d000215 	stw	r20,8(r19)
8111c758:	a0800115 	stw	r2,4(r20)
8111c75c:	a8c7883a 	add	r3,r21,r3
8111c760:	e0c00015 	stw	r3,0(fp)
8111c764:	84c00e26 	beq	r16,r19,8111c7a0 <_malloc_r+0x468>
8111c768:	018003c4 	movi	r6,15
8111c76c:	3580a72e 	bgeu	r6,r22,8111ca0c <_malloc_r+0x6d4>
8111c770:	81400117 	ldw	r5,4(r16)
8111c774:	013ffe04 	movi	r4,-8
8111c778:	b0bffd04 	addi	r2,r22,-12
8111c77c:	1104703a 	and	r2,r2,r4
8111c780:	2900004c 	andi	r4,r5,1
8111c784:	2088b03a 	or	r4,r4,r2
8111c788:	81000115 	stw	r4,4(r16)
8111c78c:	01400144 	movi	r5,5
8111c790:	8089883a 	add	r4,r16,r2
8111c794:	21400115 	stw	r5,4(r4)
8111c798:	21400215 	stw	r5,8(r4)
8111c79c:	3080cd36 	bltu	r6,r2,8111cad4 <_malloc_r+0x79c>
8111c7a0:	00a04574 	movhi	r2,33045
8111c7a4:	10b59804 	addi	r2,r2,-10656
8111c7a8:	11000017 	ldw	r4,0(r2)
8111c7ac:	20c0012e 	bgeu	r4,r3,8111c7b4 <_malloc_r+0x47c>
8111c7b0:	10c00015 	stw	r3,0(r2)
8111c7b4:	00a04574 	movhi	r2,33045
8111c7b8:	10b59704 	addi	r2,r2,-10660
8111c7bc:	11000017 	ldw	r4,0(r2)
8111c7c0:	9c000217 	ldw	r16,8(r19)
8111c7c4:	20c0012e 	bgeu	r4,r3,8111c7cc <_malloc_r+0x494>
8111c7c8:	10c00015 	stw	r3,0(r2)
8111c7cc:	80c00117 	ldw	r3,4(r16)
8111c7d0:	00bfff04 	movi	r2,-4
8111c7d4:	1886703a 	and	r3,r3,r2
8111c7d8:	1c45c83a 	sub	r2,r3,r17
8111c7dc:	1c400236 	bltu	r3,r17,8111c7e8 <_malloc_r+0x4b0>
8111c7e0:	00c003c4 	movi	r3,15
8111c7e4:	18800416 	blt	r3,r2,8111c7f8 <_malloc_r+0x4c0>
8111c7e8:	9009883a 	mov	r4,r18
8111c7ec:	113325c0 	call	8113325c <__malloc_unlock>
8111c7f0:	0005883a 	mov	r2,zero
8111c7f4:	003f7b06 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c7f8:	88c00054 	ori	r3,r17,1
8111c7fc:	80c00115 	stw	r3,4(r16)
8111c800:	8463883a 	add	r17,r16,r17
8111c804:	10800054 	ori	r2,r2,1
8111c808:	9c400215 	stw	r17,8(r19)
8111c80c:	88800115 	stw	r2,4(r17)
8111c810:	9009883a 	mov	r4,r18
8111c814:	113325c0 	call	8113325c <__malloc_unlock>
8111c818:	80800204 	addi	r2,r16,8
8111c81c:	003f7106 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c820:	00c00504 	movi	r3,20
8111c824:	18804a2e 	bgeu	r3,r2,8111c950 <_malloc_r+0x618>
8111c828:	00c01504 	movi	r3,84
8111c82c:	18806e36 	bltu	r3,r2,8111c9e8 <_malloc_r+0x6b0>
8111c830:	8804d33a 	srli	r2,r17,12
8111c834:	12001bc4 	addi	r8,r2,111
8111c838:	11c01b84 	addi	r7,r2,110
8111c83c:	4209883a 	add	r4,r8,r8
8111c840:	003edd06 	br	8111c3b8 <__reset+0xfb0fc3b8>
8111c844:	3804d27a 	srli	r2,r7,9
8111c848:	00c00104 	movi	r3,4
8111c84c:	1880442e 	bgeu	r3,r2,8111c960 <_malloc_r+0x628>
8111c850:	00c00504 	movi	r3,20
8111c854:	18808136 	bltu	r3,r2,8111ca5c <_malloc_r+0x724>
8111c858:	11401704 	addi	r5,r2,92
8111c85c:	10c016c4 	addi	r3,r2,91
8111c860:	294b883a 	add	r5,r5,r5
8111c864:	294b883a 	add	r5,r5,r5
8111c868:	294b883a 	add	r5,r5,r5
8111c86c:	994b883a 	add	r5,r19,r5
8111c870:	28800017 	ldw	r2,0(r5)
8111c874:	01a04574 	movhi	r6,33045
8111c878:	297ffe04 	addi	r5,r5,-8
8111c87c:	31aee704 	addi	r6,r6,-17508
8111c880:	28806526 	beq	r5,r2,8111ca18 <_malloc_r+0x6e0>
8111c884:	01bfff04 	movi	r6,-4
8111c888:	10c00117 	ldw	r3,4(r2)
8111c88c:	1986703a 	and	r3,r3,r6
8111c890:	38c0022e 	bgeu	r7,r3,8111c89c <_malloc_r+0x564>
8111c894:	10800217 	ldw	r2,8(r2)
8111c898:	28bffb1e 	bne	r5,r2,8111c888 <__reset+0xfb0fc888>
8111c89c:	11400317 	ldw	r5,12(r2)
8111c8a0:	98c00117 	ldw	r3,4(r19)
8111c8a4:	81400315 	stw	r5,12(r16)
8111c8a8:	80800215 	stw	r2,8(r16)
8111c8ac:	2c000215 	stw	r16,8(r5)
8111c8b0:	14000315 	stw	r16,12(r2)
8111c8b4:	003ef806 	br	8111c498 <__reset+0xfb0fc498>
8111c8b8:	88c00054 	ori	r3,r17,1
8111c8bc:	80c00115 	stw	r3,4(r16)
8111c8c0:	8463883a 	add	r17,r16,r17
8111c8c4:	34400515 	stw	r17,20(r6)
8111c8c8:	34400415 	stw	r17,16(r6)
8111c8cc:	10c00054 	ori	r3,r2,1
8111c8d0:	8a000315 	stw	r8,12(r17)
8111c8d4:	8a000215 	stw	r8,8(r17)
8111c8d8:	88c00115 	stw	r3,4(r17)
8111c8dc:	88a3883a 	add	r17,r17,r2
8111c8e0:	88800015 	stw	r2,0(r17)
8111c8e4:	9009883a 	mov	r4,r18
8111c8e8:	113325c0 	call	8113325c <__malloc_unlock>
8111c8ec:	80800204 	addi	r2,r16,8
8111c8f0:	003f3c06 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c8f4:	30c00117 	ldw	r3,4(r6)
8111c8f8:	003ee706 	br	8111c498 <__reset+0xfb0fc498>
8111c8fc:	5ac00044 	addi	r11,r11,1
8111c900:	588000cc 	andi	r2,r11,3
8111c904:	31800204 	addi	r6,r6,8
8111c908:	103efd1e 	bne	r2,zero,8111c500 <__reset+0xfb0fc500>
8111c90c:	00002406 	br	8111c9a0 <_malloc_r+0x668>
8111c910:	14000317 	ldw	r16,12(r2)
8111c914:	143f251e 	bne	r2,r16,8111c5ac <__reset+0xfb0fc5ac>
8111c918:	21000084 	addi	r4,r4,2
8111c91c:	003ebc06 	br	8111c410 <__reset+0xfb0fc410>
8111c920:	8085883a 	add	r2,r16,r2
8111c924:	10c00117 	ldw	r3,4(r2)
8111c928:	81000317 	ldw	r4,12(r16)
8111c92c:	81400217 	ldw	r5,8(r16)
8111c930:	18c00054 	ori	r3,r3,1
8111c934:	10c00115 	stw	r3,4(r2)
8111c938:	29000315 	stw	r4,12(r5)
8111c93c:	21400215 	stw	r5,8(r4)
8111c940:	9009883a 	mov	r4,r18
8111c944:	113325c0 	call	8113325c <__malloc_unlock>
8111c948:	80800204 	addi	r2,r16,8
8111c94c:	003f2506 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c950:	12001704 	addi	r8,r2,92
8111c954:	11c016c4 	addi	r7,r2,91
8111c958:	4209883a 	add	r4,r8,r8
8111c95c:	003e9606 	br	8111c3b8 <__reset+0xfb0fc3b8>
8111c960:	3804d1ba 	srli	r2,r7,6
8111c964:	11400e44 	addi	r5,r2,57
8111c968:	10c00e04 	addi	r3,r2,56
8111c96c:	294b883a 	add	r5,r5,r5
8111c970:	003fbc06 	br	8111c864 <__reset+0xfb0fc864>
8111c974:	84ff5926 	beq	r16,r19,8111c6dc <__reset+0xfb0fc6dc>
8111c978:	00a04574 	movhi	r2,33045
8111c97c:	10aee704 	addi	r2,r2,-17508
8111c980:	14000217 	ldw	r16,8(r2)
8111c984:	00bfff04 	movi	r2,-4
8111c988:	80c00117 	ldw	r3,4(r16)
8111c98c:	1886703a 	and	r3,r3,r2
8111c990:	003f9106 	br	8111c7d8 <__reset+0xfb0fc7d8>
8111c994:	60800217 	ldw	r2,8(r12)
8111c998:	213fffc4 	addi	r4,r4,-1
8111c99c:	1300651e 	bne	r2,r12,8111cb34 <_malloc_r+0x7fc>
8111c9a0:	208000cc 	andi	r2,r4,3
8111c9a4:	633ffe04 	addi	r12,r12,-8
8111c9a8:	103ffa1e 	bne	r2,zero,8111c994 <__reset+0xfb0fc994>
8111c9ac:	98800117 	ldw	r2,4(r19)
8111c9b0:	0146303a 	nor	r3,zero,r5
8111c9b4:	1884703a 	and	r2,r3,r2
8111c9b8:	98800115 	stw	r2,4(r19)
8111c9bc:	294b883a 	add	r5,r5,r5
8111c9c0:	117f2836 	bltu	r2,r5,8111c664 <__reset+0xfb0fc664>
8111c9c4:	283f2726 	beq	r5,zero,8111c664 <__reset+0xfb0fc664>
8111c9c8:	2886703a 	and	r3,r5,r2
8111c9cc:	5809883a 	mov	r4,r11
8111c9d0:	183ec31e 	bne	r3,zero,8111c4e0 <__reset+0xfb0fc4e0>
8111c9d4:	294b883a 	add	r5,r5,r5
8111c9d8:	2886703a 	and	r3,r5,r2
8111c9dc:	21000104 	addi	r4,r4,4
8111c9e0:	183ffc26 	beq	r3,zero,8111c9d4 <__reset+0xfb0fc9d4>
8111c9e4:	003ebe06 	br	8111c4e0 <__reset+0xfb0fc4e0>
8111c9e8:	00c05504 	movi	r3,340
8111c9ec:	18801236 	bltu	r3,r2,8111ca38 <_malloc_r+0x700>
8111c9f0:	8804d3fa 	srli	r2,r17,15
8111c9f4:	12001e04 	addi	r8,r2,120
8111c9f8:	11c01dc4 	addi	r7,r2,119
8111c9fc:	4209883a 	add	r4,r8,r8
8111ca00:	003e6d06 	br	8111c3b8 <__reset+0xfb0fc3b8>
8111ca04:	00c40004 	movi	r3,4096
8111ca08:	003f4606 	br	8111c724 <__reset+0xfb0fc724>
8111ca0c:	00800044 	movi	r2,1
8111ca10:	a0800115 	stw	r2,4(r20)
8111ca14:	003f7406 	br	8111c7e8 <__reset+0xfb0fc7e8>
8111ca18:	1805d0ba 	srai	r2,r3,2
8111ca1c:	01c00044 	movi	r7,1
8111ca20:	30c00117 	ldw	r3,4(r6)
8111ca24:	388e983a 	sll	r7,r7,r2
8111ca28:	2805883a 	mov	r2,r5
8111ca2c:	38c6b03a 	or	r3,r7,r3
8111ca30:	30c00115 	stw	r3,4(r6)
8111ca34:	003f9b06 	br	8111c8a4 <__reset+0xfb0fc8a4>
8111ca38:	00c15504 	movi	r3,1364
8111ca3c:	18801a36 	bltu	r3,r2,8111caa8 <_malloc_r+0x770>
8111ca40:	8804d4ba 	srli	r2,r17,18
8111ca44:	12001f44 	addi	r8,r2,125
8111ca48:	11c01f04 	addi	r7,r2,124
8111ca4c:	4209883a 	add	r4,r8,r8
8111ca50:	003e5906 	br	8111c3b8 <__reset+0xfb0fc3b8>
8111ca54:	ad400404 	addi	r21,r21,16
8111ca58:	003f1706 	br	8111c6b8 <__reset+0xfb0fc6b8>
8111ca5c:	00c01504 	movi	r3,84
8111ca60:	18802336 	bltu	r3,r2,8111caf0 <_malloc_r+0x7b8>
8111ca64:	3804d33a 	srli	r2,r7,12
8111ca68:	11401bc4 	addi	r5,r2,111
8111ca6c:	10c01b84 	addi	r3,r2,110
8111ca70:	294b883a 	add	r5,r5,r5
8111ca74:	003f7b06 	br	8111c864 <__reset+0xfb0fc864>
8111ca78:	9c000217 	ldw	r16,8(r19)
8111ca7c:	00bfff04 	movi	r2,-4
8111ca80:	80c00117 	ldw	r3,4(r16)
8111ca84:	1886703a 	and	r3,r3,r2
8111ca88:	003f5306 	br	8111c7d8 <__reset+0xfb0fc7d8>
8111ca8c:	3083ffcc 	andi	r2,r6,4095
8111ca90:	103f181e 	bne	r2,zero,8111c6f4 <__reset+0xfb0fc6f4>
8111ca94:	99000217 	ldw	r4,8(r19)
8111ca98:	b545883a 	add	r2,r22,r21
8111ca9c:	10800054 	ori	r2,r2,1
8111caa0:	20800115 	stw	r2,4(r4)
8111caa4:	003f3e06 	br	8111c7a0 <__reset+0xfb0fc7a0>
8111caa8:	01003f84 	movi	r4,254
8111caac:	02001fc4 	movi	r8,127
8111cab0:	01c01f84 	movi	r7,126
8111cab4:	003e4006 	br	8111c3b8 <__reset+0xfb0fc3b8>
8111cab8:	00a04574 	movhi	r2,33045
8111cabc:	10b52a04 	addi	r2,r2,-11096
8111cac0:	15000015 	stw	r20,0(r2)
8111cac4:	003f1106 	br	8111c70c <__reset+0xfb0fc70c>
8111cac8:	00800044 	movi	r2,1
8111cacc:	002b883a 	mov	r21,zero
8111cad0:	003f1f06 	br	8111c750 <__reset+0xfb0fc750>
8111cad4:	81400204 	addi	r5,r16,8
8111cad8:	9009883a 	mov	r4,r18
8111cadc:	1125dac0 	call	81125dac <_free_r>
8111cae0:	00a04574 	movhi	r2,33045
8111cae4:	10b62604 	addi	r2,r2,-10088
8111cae8:	10c00017 	ldw	r3,0(r2)
8111caec:	003f2c06 	br	8111c7a0 <__reset+0xfb0fc7a0>
8111caf0:	00c05504 	movi	r3,340
8111caf4:	18800536 	bltu	r3,r2,8111cb0c <_malloc_r+0x7d4>
8111caf8:	3804d3fa 	srli	r2,r7,15
8111cafc:	11401e04 	addi	r5,r2,120
8111cb00:	10c01dc4 	addi	r3,r2,119
8111cb04:	294b883a 	add	r5,r5,r5
8111cb08:	003f5606 	br	8111c864 <__reset+0xfb0fc864>
8111cb0c:	00c15504 	movi	r3,1364
8111cb10:	18800536 	bltu	r3,r2,8111cb28 <_malloc_r+0x7f0>
8111cb14:	3804d4ba 	srli	r2,r7,18
8111cb18:	11401f44 	addi	r5,r2,125
8111cb1c:	10c01f04 	addi	r3,r2,124
8111cb20:	294b883a 	add	r5,r5,r5
8111cb24:	003f4f06 	br	8111c864 <__reset+0xfb0fc864>
8111cb28:	01403f84 	movi	r5,254
8111cb2c:	00c01f84 	movi	r3,126
8111cb30:	003f4c06 	br	8111c864 <__reset+0xfb0fc864>
8111cb34:	98800117 	ldw	r2,4(r19)
8111cb38:	003fa006 	br	8111c9bc <__reset+0xfb0fc9bc>
8111cb3c:	8808d0fa 	srli	r4,r17,3
8111cb40:	20800044 	addi	r2,r4,1
8111cb44:	1085883a 	add	r2,r2,r2
8111cb48:	003e9006 	br	8111c58c <__reset+0xfb0fc58c>

8111cb4c <memcpy>:
8111cb4c:	defffd04 	addi	sp,sp,-12
8111cb50:	de00012e 	bgeu	sp,et,8111cb58 <memcpy+0xc>
8111cb54:	003b68fa 	trap	3
8111cb58:	00c003c4 	movi	r3,15
8111cb5c:	dfc00215 	stw	ra,8(sp)
8111cb60:	dc400115 	stw	r17,4(sp)
8111cb64:	dc000015 	stw	r16,0(sp)
8111cb68:	2005883a 	mov	r2,r4
8111cb6c:	1980452e 	bgeu	r3,r6,8111cc84 <memcpy+0x138>
8111cb70:	2906b03a 	or	r3,r5,r4
8111cb74:	18c000cc 	andi	r3,r3,3
8111cb78:	1800441e 	bne	r3,zero,8111cc8c <memcpy+0x140>
8111cb7c:	347ffc04 	addi	r17,r6,-16
8111cb80:	8822d13a 	srli	r17,r17,4
8111cb84:	28c00104 	addi	r3,r5,4
8111cb88:	23400104 	addi	r13,r4,4
8111cb8c:	8820913a 	slli	r16,r17,4
8111cb90:	2b000204 	addi	r12,r5,8
8111cb94:	22c00204 	addi	r11,r4,8
8111cb98:	84000504 	addi	r16,r16,20
8111cb9c:	2a800304 	addi	r10,r5,12
8111cba0:	22400304 	addi	r9,r4,12
8111cba4:	2c21883a 	add	r16,r5,r16
8111cba8:	2811883a 	mov	r8,r5
8111cbac:	200f883a 	mov	r7,r4
8111cbb0:	41000017 	ldw	r4,0(r8)
8111cbb4:	1fc00017 	ldw	ra,0(r3)
8111cbb8:	63c00017 	ldw	r15,0(r12)
8111cbbc:	39000015 	stw	r4,0(r7)
8111cbc0:	53800017 	ldw	r14,0(r10)
8111cbc4:	6fc00015 	stw	ra,0(r13)
8111cbc8:	5bc00015 	stw	r15,0(r11)
8111cbcc:	4b800015 	stw	r14,0(r9)
8111cbd0:	18c00404 	addi	r3,r3,16
8111cbd4:	39c00404 	addi	r7,r7,16
8111cbd8:	42000404 	addi	r8,r8,16
8111cbdc:	6b400404 	addi	r13,r13,16
8111cbe0:	63000404 	addi	r12,r12,16
8111cbe4:	5ac00404 	addi	r11,r11,16
8111cbe8:	52800404 	addi	r10,r10,16
8111cbec:	4a400404 	addi	r9,r9,16
8111cbf0:	1c3fef1e 	bne	r3,r16,8111cbb0 <__reset+0xfb0fcbb0>
8111cbf4:	89c00044 	addi	r7,r17,1
8111cbf8:	380e913a 	slli	r7,r7,4
8111cbfc:	310003cc 	andi	r4,r6,15
8111cc00:	02c000c4 	movi	r11,3
8111cc04:	11c7883a 	add	r3,r2,r7
8111cc08:	29cb883a 	add	r5,r5,r7
8111cc0c:	5900212e 	bgeu	r11,r4,8111cc94 <memcpy+0x148>
8111cc10:	1813883a 	mov	r9,r3
8111cc14:	2811883a 	mov	r8,r5
8111cc18:	200f883a 	mov	r7,r4
8111cc1c:	42800017 	ldw	r10,0(r8)
8111cc20:	4a400104 	addi	r9,r9,4
8111cc24:	39ffff04 	addi	r7,r7,-4
8111cc28:	4abfff15 	stw	r10,-4(r9)
8111cc2c:	42000104 	addi	r8,r8,4
8111cc30:	59fffa36 	bltu	r11,r7,8111cc1c <__reset+0xfb0fcc1c>
8111cc34:	213fff04 	addi	r4,r4,-4
8111cc38:	2008d0ba 	srli	r4,r4,2
8111cc3c:	318000cc 	andi	r6,r6,3
8111cc40:	21000044 	addi	r4,r4,1
8111cc44:	2109883a 	add	r4,r4,r4
8111cc48:	2109883a 	add	r4,r4,r4
8111cc4c:	1907883a 	add	r3,r3,r4
8111cc50:	290b883a 	add	r5,r5,r4
8111cc54:	30000626 	beq	r6,zero,8111cc70 <memcpy+0x124>
8111cc58:	198d883a 	add	r6,r3,r6
8111cc5c:	29c00003 	ldbu	r7,0(r5)
8111cc60:	18c00044 	addi	r3,r3,1
8111cc64:	29400044 	addi	r5,r5,1
8111cc68:	19ffffc5 	stb	r7,-1(r3)
8111cc6c:	19bffb1e 	bne	r3,r6,8111cc5c <__reset+0xfb0fcc5c>
8111cc70:	dfc00217 	ldw	ra,8(sp)
8111cc74:	dc400117 	ldw	r17,4(sp)
8111cc78:	dc000017 	ldw	r16,0(sp)
8111cc7c:	dec00304 	addi	sp,sp,12
8111cc80:	f800283a 	ret
8111cc84:	2007883a 	mov	r3,r4
8111cc88:	003ff206 	br	8111cc54 <__reset+0xfb0fcc54>
8111cc8c:	2007883a 	mov	r3,r4
8111cc90:	003ff106 	br	8111cc58 <__reset+0xfb0fcc58>
8111cc94:	200d883a 	mov	r6,r4
8111cc98:	003fee06 	br	8111cc54 <__reset+0xfb0fcc54>

8111cc9c <memset>:
8111cc9c:	20c000cc 	andi	r3,r4,3
8111cca0:	2005883a 	mov	r2,r4
8111cca4:	18004426 	beq	r3,zero,8111cdb8 <memset+0x11c>
8111cca8:	31ffffc4 	addi	r7,r6,-1
8111ccac:	30004026 	beq	r6,zero,8111cdb0 <memset+0x114>
8111ccb0:	2813883a 	mov	r9,r5
8111ccb4:	200d883a 	mov	r6,r4
8111ccb8:	2007883a 	mov	r3,r4
8111ccbc:	00000406 	br	8111ccd0 <memset+0x34>
8111ccc0:	3a3fffc4 	addi	r8,r7,-1
8111ccc4:	31800044 	addi	r6,r6,1
8111ccc8:	38003926 	beq	r7,zero,8111cdb0 <memset+0x114>
8111cccc:	400f883a 	mov	r7,r8
8111ccd0:	18c00044 	addi	r3,r3,1
8111ccd4:	32400005 	stb	r9,0(r6)
8111ccd8:	1a0000cc 	andi	r8,r3,3
8111ccdc:	403ff81e 	bne	r8,zero,8111ccc0 <__reset+0xfb0fccc0>
8111cce0:	010000c4 	movi	r4,3
8111cce4:	21c02d2e 	bgeu	r4,r7,8111cd9c <memset+0x100>
8111cce8:	29003fcc 	andi	r4,r5,255
8111ccec:	200c923a 	slli	r6,r4,8
8111ccf0:	3108b03a 	or	r4,r6,r4
8111ccf4:	200c943a 	slli	r6,r4,16
8111ccf8:	218cb03a 	or	r6,r4,r6
8111ccfc:	010003c4 	movi	r4,15
8111cd00:	21c0182e 	bgeu	r4,r7,8111cd64 <memset+0xc8>
8111cd04:	3b3ffc04 	addi	r12,r7,-16
8111cd08:	6018d13a 	srli	r12,r12,4
8111cd0c:	1a000104 	addi	r8,r3,4
8111cd10:	1ac00204 	addi	r11,r3,8
8111cd14:	6008913a 	slli	r4,r12,4
8111cd18:	1a800304 	addi	r10,r3,12
8111cd1c:	1813883a 	mov	r9,r3
8111cd20:	21000504 	addi	r4,r4,20
8111cd24:	1909883a 	add	r4,r3,r4
8111cd28:	49800015 	stw	r6,0(r9)
8111cd2c:	41800015 	stw	r6,0(r8)
8111cd30:	59800015 	stw	r6,0(r11)
8111cd34:	51800015 	stw	r6,0(r10)
8111cd38:	42000404 	addi	r8,r8,16
8111cd3c:	4a400404 	addi	r9,r9,16
8111cd40:	5ac00404 	addi	r11,r11,16
8111cd44:	52800404 	addi	r10,r10,16
8111cd48:	413ff71e 	bne	r8,r4,8111cd28 <__reset+0xfb0fcd28>
8111cd4c:	63000044 	addi	r12,r12,1
8111cd50:	6018913a 	slli	r12,r12,4
8111cd54:	39c003cc 	andi	r7,r7,15
8111cd58:	010000c4 	movi	r4,3
8111cd5c:	1b07883a 	add	r3,r3,r12
8111cd60:	21c00e2e 	bgeu	r4,r7,8111cd9c <memset+0x100>
8111cd64:	1813883a 	mov	r9,r3
8111cd68:	3811883a 	mov	r8,r7
8111cd6c:	010000c4 	movi	r4,3
8111cd70:	49800015 	stw	r6,0(r9)
8111cd74:	423fff04 	addi	r8,r8,-4
8111cd78:	4a400104 	addi	r9,r9,4
8111cd7c:	223ffc36 	bltu	r4,r8,8111cd70 <__reset+0xfb0fcd70>
8111cd80:	393fff04 	addi	r4,r7,-4
8111cd84:	2008d0ba 	srli	r4,r4,2
8111cd88:	39c000cc 	andi	r7,r7,3
8111cd8c:	21000044 	addi	r4,r4,1
8111cd90:	2109883a 	add	r4,r4,r4
8111cd94:	2109883a 	add	r4,r4,r4
8111cd98:	1907883a 	add	r3,r3,r4
8111cd9c:	38000526 	beq	r7,zero,8111cdb4 <memset+0x118>
8111cda0:	19cf883a 	add	r7,r3,r7
8111cda4:	19400005 	stb	r5,0(r3)
8111cda8:	18c00044 	addi	r3,r3,1
8111cdac:	38fffd1e 	bne	r7,r3,8111cda4 <__reset+0xfb0fcda4>
8111cdb0:	f800283a 	ret
8111cdb4:	f800283a 	ret
8111cdb8:	2007883a 	mov	r3,r4
8111cdbc:	300f883a 	mov	r7,r6
8111cdc0:	003fc706 	br	8111cce0 <__reset+0xfb0fcce0>

8111cdc4 <_open_r>:
8111cdc4:	defffd04 	addi	sp,sp,-12
8111cdc8:	de00012e 	bgeu	sp,et,8111cdd0 <_open_r+0xc>
8111cdcc:	003b68fa 	trap	3
8111cdd0:	2805883a 	mov	r2,r5
8111cdd4:	dc000015 	stw	r16,0(sp)
8111cdd8:	04204574 	movhi	r16,33045
8111cddc:	dc400115 	stw	r17,4(sp)
8111cde0:	300b883a 	mov	r5,r6
8111cde4:	84359604 	addi	r16,r16,-10664
8111cde8:	2023883a 	mov	r17,r4
8111cdec:	380d883a 	mov	r6,r7
8111cdf0:	1009883a 	mov	r4,r2
8111cdf4:	dfc00215 	stw	ra,8(sp)
8111cdf8:	80000015 	stw	zero,0(r16)
8111cdfc:	11327b40 	call	811327b4 <open>
8111ce00:	00ffffc4 	movi	r3,-1
8111ce04:	10c00526 	beq	r2,r3,8111ce1c <_open_r+0x58>
8111ce08:	dfc00217 	ldw	ra,8(sp)
8111ce0c:	dc400117 	ldw	r17,4(sp)
8111ce10:	dc000017 	ldw	r16,0(sp)
8111ce14:	dec00304 	addi	sp,sp,12
8111ce18:	f800283a 	ret
8111ce1c:	80c00017 	ldw	r3,0(r16)
8111ce20:	183ff926 	beq	r3,zero,8111ce08 <__reset+0xfb0fce08>
8111ce24:	88c00015 	stw	r3,0(r17)
8111ce28:	003ff706 	br	8111ce08 <__reset+0xfb0fce08>

8111ce2c <_printf_r>:
8111ce2c:	defffd04 	addi	sp,sp,-12
8111ce30:	2805883a 	mov	r2,r5
8111ce34:	de00012e 	bgeu	sp,et,8111ce3c <_printf_r+0x10>
8111ce38:	003b68fa 	trap	3
8111ce3c:	dfc00015 	stw	ra,0(sp)
8111ce40:	d9800115 	stw	r6,4(sp)
8111ce44:	d9c00215 	stw	r7,8(sp)
8111ce48:	21400217 	ldw	r5,8(r4)
8111ce4c:	d9c00104 	addi	r7,sp,4
8111ce50:	100d883a 	mov	r6,r2
8111ce54:	111fb580 	call	8111fb58 <___vfprintf_internal_r>
8111ce58:	dfc00017 	ldw	ra,0(sp)
8111ce5c:	dec00304 	addi	sp,sp,12
8111ce60:	f800283a 	ret

8111ce64 <printf>:
8111ce64:	defffc04 	addi	sp,sp,-16
8111ce68:	de00012e 	bgeu	sp,et,8111ce70 <printf+0xc>
8111ce6c:	003b68fa 	trap	3
8111ce70:	dfc00015 	stw	ra,0(sp)
8111ce74:	d9400115 	stw	r5,4(sp)
8111ce78:	d9800215 	stw	r6,8(sp)
8111ce7c:	d9c00315 	stw	r7,12(sp)
8111ce80:	00a04574 	movhi	r2,33045
8111ce84:	10b52904 	addi	r2,r2,-11100
8111ce88:	10800017 	ldw	r2,0(r2)
8111ce8c:	200b883a 	mov	r5,r4
8111ce90:	d9800104 	addi	r6,sp,4
8111ce94:	11000217 	ldw	r4,8(r2)
8111ce98:	1121d580 	call	81121d58 <__vfprintf_internal>
8111ce9c:	dfc00017 	ldw	ra,0(sp)
8111cea0:	dec00404 	addi	sp,sp,16
8111cea4:	f800283a 	ret

8111cea8 <_putc_r>:
8111cea8:	defffc04 	addi	sp,sp,-16
8111ceac:	de00012e 	bgeu	sp,et,8111ceb4 <_putc_r+0xc>
8111ceb0:	003b68fa 	trap	3
8111ceb4:	dc000215 	stw	r16,8(sp)
8111ceb8:	dfc00315 	stw	ra,12(sp)
8111cebc:	2021883a 	mov	r16,r4
8111cec0:	20000226 	beq	r4,zero,8111cecc <_putc_r+0x24>
8111cec4:	20800e17 	ldw	r2,56(r4)
8111cec8:	10001b26 	beq	r2,zero,8111cf38 <_putc_r+0x90>
8111cecc:	30800217 	ldw	r2,8(r6)
8111ced0:	10bfffc4 	addi	r2,r2,-1
8111ced4:	30800215 	stw	r2,8(r6)
8111ced8:	10000a16 	blt	r2,zero,8111cf04 <_putc_r+0x5c>
8111cedc:	30800017 	ldw	r2,0(r6)
8111cee0:	11400005 	stb	r5,0(r2)
8111cee4:	30800017 	ldw	r2,0(r6)
8111cee8:	10c00044 	addi	r3,r2,1
8111ceec:	30c00015 	stw	r3,0(r6)
8111cef0:	10800003 	ldbu	r2,0(r2)
8111cef4:	dfc00317 	ldw	ra,12(sp)
8111cef8:	dc000217 	ldw	r16,8(sp)
8111cefc:	dec00404 	addi	sp,sp,16
8111cf00:	f800283a 	ret
8111cf04:	30c00617 	ldw	r3,24(r6)
8111cf08:	10c00616 	blt	r2,r3,8111cf24 <_putc_r+0x7c>
8111cf0c:	30800017 	ldw	r2,0(r6)
8111cf10:	00c00284 	movi	r3,10
8111cf14:	11400005 	stb	r5,0(r2)
8111cf18:	30800017 	ldw	r2,0(r6)
8111cf1c:	11400003 	ldbu	r5,0(r2)
8111cf20:	28fff11e 	bne	r5,r3,8111cee8 <__reset+0xfb0fcee8>
8111cf24:	8009883a 	mov	r4,r16
8111cf28:	dfc00317 	ldw	ra,12(sp)
8111cf2c:	dc000217 	ldw	r16,8(sp)
8111cf30:	dec00404 	addi	sp,sp,16
8111cf34:	11236dc1 	jmpi	811236dc <__swbuf_r>
8111cf38:	d9400015 	stw	r5,0(sp)
8111cf3c:	d9800115 	stw	r6,4(sp)
8111cf40:	11259140 	call	81125914 <__sinit>
8111cf44:	d9800117 	ldw	r6,4(sp)
8111cf48:	d9400017 	ldw	r5,0(sp)
8111cf4c:	003fdf06 	br	8111cecc <__reset+0xfb0fcecc>

8111cf50 <putc>:
8111cf50:	00a04574 	movhi	r2,33045
8111cf54:	defffc04 	addi	sp,sp,-16
8111cf58:	10b52904 	addi	r2,r2,-11100
8111cf5c:	de00012e 	bgeu	sp,et,8111cf64 <putc+0x14>
8111cf60:	003b68fa 	trap	3
8111cf64:	dc000115 	stw	r16,4(sp)
8111cf68:	14000017 	ldw	r16,0(r2)
8111cf6c:	dc400215 	stw	r17,8(sp)
8111cf70:	dfc00315 	stw	ra,12(sp)
8111cf74:	2023883a 	mov	r17,r4
8111cf78:	80000226 	beq	r16,zero,8111cf84 <putc+0x34>
8111cf7c:	80800e17 	ldw	r2,56(r16)
8111cf80:	10001a26 	beq	r2,zero,8111cfec <putc+0x9c>
8111cf84:	28800217 	ldw	r2,8(r5)
8111cf88:	10bfffc4 	addi	r2,r2,-1
8111cf8c:	28800215 	stw	r2,8(r5)
8111cf90:	10000b16 	blt	r2,zero,8111cfc0 <putc+0x70>
8111cf94:	28800017 	ldw	r2,0(r5)
8111cf98:	14400005 	stb	r17,0(r2)
8111cf9c:	28800017 	ldw	r2,0(r5)
8111cfa0:	10c00044 	addi	r3,r2,1
8111cfa4:	28c00015 	stw	r3,0(r5)
8111cfa8:	10800003 	ldbu	r2,0(r2)
8111cfac:	dfc00317 	ldw	ra,12(sp)
8111cfb0:	dc400217 	ldw	r17,8(sp)
8111cfb4:	dc000117 	ldw	r16,4(sp)
8111cfb8:	dec00404 	addi	sp,sp,16
8111cfbc:	f800283a 	ret
8111cfc0:	28c00617 	ldw	r3,24(r5)
8111cfc4:	10c00e16 	blt	r2,r3,8111d000 <putc+0xb0>
8111cfc8:	28800017 	ldw	r2,0(r5)
8111cfcc:	01000284 	movi	r4,10
8111cfd0:	14400005 	stb	r17,0(r2)
8111cfd4:	28800017 	ldw	r2,0(r5)
8111cfd8:	10c00003 	ldbu	r3,0(r2)
8111cfdc:	193ff01e 	bne	r3,r4,8111cfa0 <__reset+0xfb0fcfa0>
8111cfe0:	280d883a 	mov	r6,r5
8111cfe4:	180b883a 	mov	r5,r3
8111cfe8:	00000706 	br	8111d008 <putc+0xb8>
8111cfec:	8009883a 	mov	r4,r16
8111cff0:	d9400015 	stw	r5,0(sp)
8111cff4:	11259140 	call	81125914 <__sinit>
8111cff8:	d9400017 	ldw	r5,0(sp)
8111cffc:	003fe106 	br	8111cf84 <__reset+0xfb0fcf84>
8111d000:	280d883a 	mov	r6,r5
8111d004:	880b883a 	mov	r5,r17
8111d008:	8009883a 	mov	r4,r16
8111d00c:	dfc00317 	ldw	ra,12(sp)
8111d010:	dc400217 	ldw	r17,8(sp)
8111d014:	dc000117 	ldw	r16,4(sp)
8111d018:	dec00404 	addi	sp,sp,16
8111d01c:	11236dc1 	jmpi	811236dc <__swbuf_r>

8111d020 <_puts_r>:
8111d020:	defff604 	addi	sp,sp,-40
8111d024:	de00012e 	bgeu	sp,et,8111d02c <_puts_r+0xc>
8111d028:	003b68fa 	trap	3
8111d02c:	dc000715 	stw	r16,28(sp)
8111d030:	2021883a 	mov	r16,r4
8111d034:	2809883a 	mov	r4,r5
8111d038:	dc400815 	stw	r17,32(sp)
8111d03c:	dfc00915 	stw	ra,36(sp)
8111d040:	2823883a 	mov	r17,r5
8111d044:	111d6400 	call	8111d640 <strlen>
8111d048:	10c00044 	addi	r3,r2,1
8111d04c:	d8800115 	stw	r2,4(sp)
8111d050:	00a04574 	movhi	r2,33045
8111d054:	10ab5004 	addi	r2,r2,-21184
8111d058:	d8800215 	stw	r2,8(sp)
8111d05c:	00800044 	movi	r2,1
8111d060:	d8800315 	stw	r2,12(sp)
8111d064:	00800084 	movi	r2,2
8111d068:	dc400015 	stw	r17,0(sp)
8111d06c:	d8c00615 	stw	r3,24(sp)
8111d070:	dec00415 	stw	sp,16(sp)
8111d074:	d8800515 	stw	r2,20(sp)
8111d078:	80000226 	beq	r16,zero,8111d084 <_puts_r+0x64>
8111d07c:	80800e17 	ldw	r2,56(r16)
8111d080:	10001426 	beq	r2,zero,8111d0d4 <_puts_r+0xb4>
8111d084:	81400217 	ldw	r5,8(r16)
8111d088:	2880030b 	ldhu	r2,12(r5)
8111d08c:	10c8000c 	andi	r3,r2,8192
8111d090:	1800061e 	bne	r3,zero,8111d0ac <_puts_r+0x8c>
8111d094:	29001917 	ldw	r4,100(r5)
8111d098:	00f7ffc4 	movi	r3,-8193
8111d09c:	10880014 	ori	r2,r2,8192
8111d0a0:	20c6703a 	and	r3,r4,r3
8111d0a4:	2880030d 	sth	r2,12(r5)
8111d0a8:	28c01915 	stw	r3,100(r5)
8111d0ac:	d9800404 	addi	r6,sp,16
8111d0b0:	8009883a 	mov	r4,r16
8111d0b4:	11260c40 	call	811260c4 <__sfvwrite_r>
8111d0b8:	1000091e 	bne	r2,zero,8111d0e0 <_puts_r+0xc0>
8111d0bc:	00800284 	movi	r2,10
8111d0c0:	dfc00917 	ldw	ra,36(sp)
8111d0c4:	dc400817 	ldw	r17,32(sp)
8111d0c8:	dc000717 	ldw	r16,28(sp)
8111d0cc:	dec00a04 	addi	sp,sp,40
8111d0d0:	f800283a 	ret
8111d0d4:	8009883a 	mov	r4,r16
8111d0d8:	11259140 	call	81125914 <__sinit>
8111d0dc:	003fe906 	br	8111d084 <__reset+0xfb0fd084>
8111d0e0:	00bfffc4 	movi	r2,-1
8111d0e4:	003ff606 	br	8111d0c0 <__reset+0xfb0fd0c0>

8111d0e8 <puts>:
8111d0e8:	00a04574 	movhi	r2,33045
8111d0ec:	10b52904 	addi	r2,r2,-11100
8111d0f0:	200b883a 	mov	r5,r4
8111d0f4:	11000017 	ldw	r4,0(r2)
8111d0f8:	111d0201 	jmpi	8111d020 <_puts_r>

8111d0fc <lflush>:
8111d0fc:	2080030b 	ldhu	r2,12(r4)
8111d100:	00c00244 	movi	r3,9
8111d104:	1080024c 	andi	r2,r2,9
8111d108:	10c00226 	beq	r2,r3,8111d114 <lflush+0x18>
8111d10c:	0005883a 	mov	r2,zero
8111d110:	f800283a 	ret
8111d114:	112557c1 	jmpi	8112557c <fflush>

8111d118 <__srefill_r>:
8111d118:	defffc04 	addi	sp,sp,-16
8111d11c:	de00012e 	bgeu	sp,et,8111d124 <__srefill_r+0xc>
8111d120:	003b68fa 	trap	3
8111d124:	dc400115 	stw	r17,4(sp)
8111d128:	dc000015 	stw	r16,0(sp)
8111d12c:	dfc00315 	stw	ra,12(sp)
8111d130:	dc800215 	stw	r18,8(sp)
8111d134:	2023883a 	mov	r17,r4
8111d138:	2821883a 	mov	r16,r5
8111d13c:	20000226 	beq	r4,zero,8111d148 <__srefill_r+0x30>
8111d140:	20800e17 	ldw	r2,56(r4)
8111d144:	10003c26 	beq	r2,zero,8111d238 <__srefill_r+0x120>
8111d148:	80c0030b 	ldhu	r3,12(r16)
8111d14c:	1908000c 	andi	r4,r3,8192
8111d150:	1805883a 	mov	r2,r3
8111d154:	2000071e 	bne	r4,zero,8111d174 <__srefill_r+0x5c>
8111d158:	81001917 	ldw	r4,100(r16)
8111d15c:	18880014 	ori	r2,r3,8192
8111d160:	00f7ffc4 	movi	r3,-8193
8111d164:	20c8703a 	and	r4,r4,r3
8111d168:	8080030d 	sth	r2,12(r16)
8111d16c:	1007883a 	mov	r3,r2
8111d170:	81001915 	stw	r4,100(r16)
8111d174:	80000115 	stw	zero,4(r16)
8111d178:	1100080c 	andi	r4,r2,32
8111d17c:	2000571e 	bne	r4,zero,8111d2dc <__srefill_r+0x1c4>
8111d180:	1100010c 	andi	r4,r2,4
8111d184:	20001f26 	beq	r4,zero,8111d204 <__srefill_r+0xec>
8111d188:	81400c17 	ldw	r5,48(r16)
8111d18c:	28000826 	beq	r5,zero,8111d1b0 <__srefill_r+0x98>
8111d190:	80801004 	addi	r2,r16,64
8111d194:	28800226 	beq	r5,r2,8111d1a0 <__srefill_r+0x88>
8111d198:	8809883a 	mov	r4,r17
8111d19c:	1125dac0 	call	81125dac <_free_r>
8111d1a0:	80800f17 	ldw	r2,60(r16)
8111d1a4:	80000c15 	stw	zero,48(r16)
8111d1a8:	80800115 	stw	r2,4(r16)
8111d1ac:	1000391e 	bne	r2,zero,8111d294 <__srefill_r+0x17c>
8111d1b0:	80800417 	ldw	r2,16(r16)
8111d1b4:	10004b26 	beq	r2,zero,8111d2e4 <__srefill_r+0x1cc>
8111d1b8:	8480030b 	ldhu	r18,12(r16)
8111d1bc:	908000cc 	andi	r2,r18,3
8111d1c0:	10001f1e 	bne	r2,zero,8111d240 <__srefill_r+0x128>
8111d1c4:	81800417 	ldw	r6,16(r16)
8111d1c8:	80800817 	ldw	r2,32(r16)
8111d1cc:	81c00517 	ldw	r7,20(r16)
8111d1d0:	81400717 	ldw	r5,28(r16)
8111d1d4:	81800015 	stw	r6,0(r16)
8111d1d8:	8809883a 	mov	r4,r17
8111d1dc:	103ee83a 	callr	r2
8111d1e0:	80800115 	stw	r2,4(r16)
8111d1e4:	00800e0e 	bge	zero,r2,8111d220 <__srefill_r+0x108>
8111d1e8:	0005883a 	mov	r2,zero
8111d1ec:	dfc00317 	ldw	ra,12(sp)
8111d1f0:	dc800217 	ldw	r18,8(sp)
8111d1f4:	dc400117 	ldw	r17,4(sp)
8111d1f8:	dc000017 	ldw	r16,0(sp)
8111d1fc:	dec00404 	addi	sp,sp,16
8111d200:	f800283a 	ret
8111d204:	1100040c 	andi	r4,r2,16
8111d208:	20003026 	beq	r4,zero,8111d2cc <__srefill_r+0x1b4>
8111d20c:	1080020c 	andi	r2,r2,8
8111d210:	1000241e 	bne	r2,zero,8111d2a4 <__srefill_r+0x18c>
8111d214:	18c00114 	ori	r3,r3,4
8111d218:	80c0030d 	sth	r3,12(r16)
8111d21c:	003fe406 	br	8111d1b0 <__reset+0xfb0fd1b0>
8111d220:	80c0030b 	ldhu	r3,12(r16)
8111d224:	1000161e 	bne	r2,zero,8111d280 <__srefill_r+0x168>
8111d228:	18c00814 	ori	r3,r3,32
8111d22c:	00bfffc4 	movi	r2,-1
8111d230:	80c0030d 	sth	r3,12(r16)
8111d234:	003fed06 	br	8111d1ec <__reset+0xfb0fd1ec>
8111d238:	11259140 	call	81125914 <__sinit>
8111d23c:	003fc206 	br	8111d148 <__reset+0xfb0fd148>
8111d240:	00a04574 	movhi	r2,33045
8111d244:	10b52804 	addi	r2,r2,-11104
8111d248:	11000017 	ldw	r4,0(r2)
8111d24c:	016044b4 	movhi	r5,33042
8111d250:	00800044 	movi	r2,1
8111d254:	29743f04 	addi	r5,r5,-12036
8111d258:	8080030d 	sth	r2,12(r16)
8111d25c:	11265880 	call	81126588 <_fwalk>
8111d260:	00800244 	movi	r2,9
8111d264:	8480030d 	sth	r18,12(r16)
8111d268:	9480024c 	andi	r18,r18,9
8111d26c:	90bfd51e 	bne	r18,r2,8111d1c4 <__reset+0xfb0fd1c4>
8111d270:	800b883a 	mov	r5,r16
8111d274:	8809883a 	mov	r4,r17
8111d278:	11252f40 	call	811252f4 <__sflush_r>
8111d27c:	003fd106 	br	8111d1c4 <__reset+0xfb0fd1c4>
8111d280:	18c01014 	ori	r3,r3,64
8111d284:	80000115 	stw	zero,4(r16)
8111d288:	00bfffc4 	movi	r2,-1
8111d28c:	80c0030d 	sth	r3,12(r16)
8111d290:	003fd606 	br	8111d1ec <__reset+0xfb0fd1ec>
8111d294:	80c00e17 	ldw	r3,56(r16)
8111d298:	0005883a 	mov	r2,zero
8111d29c:	80c00015 	stw	r3,0(r16)
8111d2a0:	003fd206 	br	8111d1ec <__reset+0xfb0fd1ec>
8111d2a4:	800b883a 	mov	r5,r16
8111d2a8:	8809883a 	mov	r4,r17
8111d2ac:	11255180 	call	81125518 <_fflush_r>
8111d2b0:	10000a1e 	bne	r2,zero,8111d2dc <__srefill_r+0x1c4>
8111d2b4:	8080030b 	ldhu	r2,12(r16)
8111d2b8:	00fffdc4 	movi	r3,-9
8111d2bc:	80000215 	stw	zero,8(r16)
8111d2c0:	1886703a 	and	r3,r3,r2
8111d2c4:	80000615 	stw	zero,24(r16)
8111d2c8:	003fd206 	br	8111d214 <__reset+0xfb0fd214>
8111d2cc:	00800244 	movi	r2,9
8111d2d0:	88800015 	stw	r2,0(r17)
8111d2d4:	18c01014 	ori	r3,r3,64
8111d2d8:	80c0030d 	sth	r3,12(r16)
8111d2dc:	00bfffc4 	movi	r2,-1
8111d2e0:	003fc206 	br	8111d1ec <__reset+0xfb0fd1ec>
8111d2e4:	800b883a 	mov	r5,r16
8111d2e8:	8809883a 	mov	r4,r17
8111d2ec:	111c1740 	call	8111c174 <__smakebuf_r>
8111d2f0:	003fb106 	br	8111d1b8 <__reset+0xfb0fd1b8>

8111d2f4 <_sbrk_r>:
8111d2f4:	defffd04 	addi	sp,sp,-12
8111d2f8:	de00012e 	bgeu	sp,et,8111d300 <_sbrk_r+0xc>
8111d2fc:	003b68fa 	trap	3
8111d300:	dc000015 	stw	r16,0(sp)
8111d304:	04204574 	movhi	r16,33045
8111d308:	dc400115 	stw	r17,4(sp)
8111d30c:	84359604 	addi	r16,r16,-10664
8111d310:	2023883a 	mov	r17,r4
8111d314:	2809883a 	mov	r4,r5
8111d318:	dfc00215 	stw	ra,8(sp)
8111d31c:	80000015 	stw	zero,0(r16)
8111d320:	1132ac40 	call	81132ac4 <sbrk>
8111d324:	00ffffc4 	movi	r3,-1
8111d328:	10c00526 	beq	r2,r3,8111d340 <_sbrk_r+0x4c>
8111d32c:	dfc00217 	ldw	ra,8(sp)
8111d330:	dc400117 	ldw	r17,4(sp)
8111d334:	dc000017 	ldw	r16,0(sp)
8111d338:	dec00304 	addi	sp,sp,12
8111d33c:	f800283a 	ret
8111d340:	80c00017 	ldw	r3,0(r16)
8111d344:	183ff926 	beq	r3,zero,8111d32c <__reset+0xfb0fd32c>
8111d348:	88c00015 	stw	r3,0(r17)
8111d34c:	003ff706 	br	8111d32c <__reset+0xfb0fd32c>

8111d350 <scanf>:
8111d350:	defffc04 	addi	sp,sp,-16
8111d354:	de00012e 	bgeu	sp,et,8111d35c <scanf+0xc>
8111d358:	003b68fa 	trap	3
8111d35c:	dfc00015 	stw	ra,0(sp)
8111d360:	d9400115 	stw	r5,4(sp)
8111d364:	d9800215 	stw	r6,8(sp)
8111d368:	d9c00315 	stw	r7,12(sp)
8111d36c:	00a04574 	movhi	r2,33045
8111d370:	10b52904 	addi	r2,r2,-11100
8111d374:	200d883a 	mov	r6,r4
8111d378:	11000017 	ldw	r4,0(r2)
8111d37c:	d9c00104 	addi	r7,sp,4
8111d380:	21400117 	ldw	r5,4(r4)
8111d384:	11236880 	call	81123688 <_vfscanf_r>
8111d388:	dfc00017 	ldw	ra,0(sp)
8111d38c:	dec00404 	addi	sp,sp,16
8111d390:	f800283a 	ret

8111d394 <_scanf_r>:
8111d394:	defffd04 	addi	sp,sp,-12
8111d398:	2805883a 	mov	r2,r5
8111d39c:	de00012e 	bgeu	sp,et,8111d3a4 <_scanf_r+0x10>
8111d3a0:	003b68fa 	trap	3
8111d3a4:	dfc00015 	stw	ra,0(sp)
8111d3a8:	d9800115 	stw	r6,4(sp)
8111d3ac:	d9c00215 	stw	r7,8(sp)
8111d3b0:	21400117 	ldw	r5,4(r4)
8111d3b4:	d9c00104 	addi	r7,sp,4
8111d3b8:	100d883a 	mov	r6,r2
8111d3bc:	11236880 	call	81123688 <_vfscanf_r>
8111d3c0:	dfc00017 	ldw	ra,0(sp)
8111d3c4:	dec00304 	addi	sp,sp,12
8111d3c8:	f800283a 	ret

8111d3cc <_sprintf_r>:
8111d3cc:	deffe404 	addi	sp,sp,-112
8111d3d0:	2807883a 	mov	r3,r5
8111d3d4:	de00012e 	bgeu	sp,et,8111d3dc <_sprintf_r+0x10>
8111d3d8:	003b68fa 	trap	3
8111d3dc:	dfc01a15 	stw	ra,104(sp)
8111d3e0:	d9c01b15 	stw	r7,108(sp)
8111d3e4:	00a00034 	movhi	r2,32768
8111d3e8:	10bfffc4 	addi	r2,r2,-1
8111d3ec:	02008204 	movi	r8,520
8111d3f0:	d8800215 	stw	r2,8(sp)
8111d3f4:	d8800515 	stw	r2,20(sp)
8111d3f8:	d9c01b04 	addi	r7,sp,108
8111d3fc:	d80b883a 	mov	r5,sp
8111d400:	00bfffc4 	movi	r2,-1
8111d404:	d8c00015 	stw	r3,0(sp)
8111d408:	d8c00415 	stw	r3,16(sp)
8111d40c:	da00030d 	sth	r8,12(sp)
8111d410:	d880038d 	sth	r2,14(sp)
8111d414:	111d9780 	call	8111d978 <___svfprintf_internal_r>
8111d418:	d8c00017 	ldw	r3,0(sp)
8111d41c:	18000005 	stb	zero,0(r3)
8111d420:	dfc01a17 	ldw	ra,104(sp)
8111d424:	dec01c04 	addi	sp,sp,112
8111d428:	f800283a 	ret

8111d42c <sprintf>:
8111d42c:	deffe304 	addi	sp,sp,-116
8111d430:	2007883a 	mov	r3,r4
8111d434:	de00012e 	bgeu	sp,et,8111d43c <sprintf+0x10>
8111d438:	003b68fa 	trap	3
8111d43c:	dfc01a15 	stw	ra,104(sp)
8111d440:	d9801b15 	stw	r6,108(sp)
8111d444:	d9c01c15 	stw	r7,112(sp)
8111d448:	01204574 	movhi	r4,33045
8111d44c:	21352904 	addi	r4,r4,-11100
8111d450:	21000017 	ldw	r4,0(r4)
8111d454:	00a00034 	movhi	r2,32768
8111d458:	10bfffc4 	addi	r2,r2,-1
8111d45c:	280d883a 	mov	r6,r5
8111d460:	02008204 	movi	r8,520
8111d464:	d8800215 	stw	r2,8(sp)
8111d468:	d8800515 	stw	r2,20(sp)
8111d46c:	d9c01b04 	addi	r7,sp,108
8111d470:	d80b883a 	mov	r5,sp
8111d474:	00bfffc4 	movi	r2,-1
8111d478:	d8c00015 	stw	r3,0(sp)
8111d47c:	d8c00415 	stw	r3,16(sp)
8111d480:	da00030d 	sth	r8,12(sp)
8111d484:	d880038d 	sth	r2,14(sp)
8111d488:	111d9780 	call	8111d978 <___svfprintf_internal_r>
8111d48c:	d8c00017 	ldw	r3,0(sp)
8111d490:	18000005 	stb	zero,0(r3)
8111d494:	dfc01a17 	ldw	ra,104(sp)
8111d498:	dec01d04 	addi	sp,sp,116
8111d49c:	f800283a 	ret

8111d4a0 <__sread>:
8111d4a0:	defffe04 	addi	sp,sp,-8
8111d4a4:	de00012e 	bgeu	sp,et,8111d4ac <__sread+0xc>
8111d4a8:	003b68fa 	trap	3
8111d4ac:	dc000015 	stw	r16,0(sp)
8111d4b0:	2821883a 	mov	r16,r5
8111d4b4:	2940038f 	ldh	r5,14(r5)
8111d4b8:	dfc00115 	stw	ra,4(sp)
8111d4bc:	1127dd80 	call	81127dd8 <_read_r>
8111d4c0:	10000716 	blt	r2,zero,8111d4e0 <__sread+0x40>
8111d4c4:	80c01417 	ldw	r3,80(r16)
8111d4c8:	1887883a 	add	r3,r3,r2
8111d4cc:	80c01415 	stw	r3,80(r16)
8111d4d0:	dfc00117 	ldw	ra,4(sp)
8111d4d4:	dc000017 	ldw	r16,0(sp)
8111d4d8:	dec00204 	addi	sp,sp,8
8111d4dc:	f800283a 	ret
8111d4e0:	80c0030b 	ldhu	r3,12(r16)
8111d4e4:	18fbffcc 	andi	r3,r3,61439
8111d4e8:	80c0030d 	sth	r3,12(r16)
8111d4ec:	dfc00117 	ldw	ra,4(sp)
8111d4f0:	dc000017 	ldw	r16,0(sp)
8111d4f4:	dec00204 	addi	sp,sp,8
8111d4f8:	f800283a 	ret

8111d4fc <__seofread>:
8111d4fc:	0005883a 	mov	r2,zero
8111d500:	f800283a 	ret

8111d504 <__swrite>:
8111d504:	defffb04 	addi	sp,sp,-20
8111d508:	de00012e 	bgeu	sp,et,8111d510 <__swrite+0xc>
8111d50c:	003b68fa 	trap	3
8111d510:	2880030b 	ldhu	r2,12(r5)
8111d514:	dcc00315 	stw	r19,12(sp)
8111d518:	dc800215 	stw	r18,8(sp)
8111d51c:	dc400115 	stw	r17,4(sp)
8111d520:	dc000015 	stw	r16,0(sp)
8111d524:	dfc00415 	stw	ra,16(sp)
8111d528:	10c0400c 	andi	r3,r2,256
8111d52c:	2821883a 	mov	r16,r5
8111d530:	2023883a 	mov	r17,r4
8111d534:	3025883a 	mov	r18,r6
8111d538:	3827883a 	mov	r19,r7
8111d53c:	18000526 	beq	r3,zero,8111d554 <__swrite+0x50>
8111d540:	2940038f 	ldh	r5,14(r5)
8111d544:	01c00084 	movi	r7,2
8111d548:	000d883a 	mov	r6,zero
8111d54c:	11268900 	call	81126890 <_lseek_r>
8111d550:	8080030b 	ldhu	r2,12(r16)
8111d554:	8140038f 	ldh	r5,14(r16)
8111d558:	10bbffcc 	andi	r2,r2,61439
8111d55c:	980f883a 	mov	r7,r19
8111d560:	900d883a 	mov	r6,r18
8111d564:	8809883a 	mov	r4,r17
8111d568:	8080030d 	sth	r2,12(r16)
8111d56c:	dfc00417 	ldw	ra,16(sp)
8111d570:	dcc00317 	ldw	r19,12(sp)
8111d574:	dc800217 	ldw	r18,8(sp)
8111d578:	dc400117 	ldw	r17,4(sp)
8111d57c:	dc000017 	ldw	r16,0(sp)
8111d580:	dec00504 	addi	sp,sp,20
8111d584:	112383c1 	jmpi	8112383c <_write_r>

8111d588 <__sseek>:
8111d588:	defffe04 	addi	sp,sp,-8
8111d58c:	de00012e 	bgeu	sp,et,8111d594 <__sseek+0xc>
8111d590:	003b68fa 	trap	3
8111d594:	dc000015 	stw	r16,0(sp)
8111d598:	2821883a 	mov	r16,r5
8111d59c:	2940038f 	ldh	r5,14(r5)
8111d5a0:	dfc00115 	stw	ra,4(sp)
8111d5a4:	11268900 	call	81126890 <_lseek_r>
8111d5a8:	00ffffc4 	movi	r3,-1
8111d5ac:	10c00826 	beq	r2,r3,8111d5d0 <__sseek+0x48>
8111d5b0:	80c0030b 	ldhu	r3,12(r16)
8111d5b4:	80801415 	stw	r2,80(r16)
8111d5b8:	18c40014 	ori	r3,r3,4096
8111d5bc:	80c0030d 	sth	r3,12(r16)
8111d5c0:	dfc00117 	ldw	ra,4(sp)
8111d5c4:	dc000017 	ldw	r16,0(sp)
8111d5c8:	dec00204 	addi	sp,sp,8
8111d5cc:	f800283a 	ret
8111d5d0:	80c0030b 	ldhu	r3,12(r16)
8111d5d4:	18fbffcc 	andi	r3,r3,61439
8111d5d8:	80c0030d 	sth	r3,12(r16)
8111d5dc:	dfc00117 	ldw	ra,4(sp)
8111d5e0:	dc000017 	ldw	r16,0(sp)
8111d5e4:	dec00204 	addi	sp,sp,8
8111d5e8:	f800283a 	ret

8111d5ec <__sclose>:
8111d5ec:	2940038f 	ldh	r5,14(r5)
8111d5f0:	1123a001 	jmpi	81123a00 <_close_r>

8111d5f4 <strcspn>:
8111d5f4:	21c00007 	ldb	r7,0(r4)
8111d5f8:	38000f26 	beq	r7,zero,8111d638 <strcspn+0x44>
8111d5fc:	2a000007 	ldb	r8,0(r5)
8111d600:	2005883a 	mov	r2,r4
8111d604:	40000726 	beq	r8,zero,8111d624 <strcspn+0x30>
8111d608:	3a000926 	beq	r7,r8,8111d630 <strcspn+0x3c>
8111d60c:	2807883a 	mov	r3,r5
8111d610:	00000106 	br	8111d618 <strcspn+0x24>
8111d614:	31c00626 	beq	r6,r7,8111d630 <strcspn+0x3c>
8111d618:	18c00044 	addi	r3,r3,1
8111d61c:	19800007 	ldb	r6,0(r3)
8111d620:	303ffc1e 	bne	r6,zero,8111d614 <__reset+0xfb0fd614>
8111d624:	10800044 	addi	r2,r2,1
8111d628:	11c00007 	ldb	r7,0(r2)
8111d62c:	383ff51e 	bne	r7,zero,8111d604 <__reset+0xfb0fd604>
8111d630:	1105c83a 	sub	r2,r2,r4
8111d634:	f800283a 	ret
8111d638:	0005883a 	mov	r2,zero
8111d63c:	f800283a 	ret

8111d640 <strlen>:
8111d640:	208000cc 	andi	r2,r4,3
8111d644:	10002026 	beq	r2,zero,8111d6c8 <strlen+0x88>
8111d648:	20800007 	ldb	r2,0(r4)
8111d64c:	10002026 	beq	r2,zero,8111d6d0 <strlen+0x90>
8111d650:	2005883a 	mov	r2,r4
8111d654:	00000206 	br	8111d660 <strlen+0x20>
8111d658:	10c00007 	ldb	r3,0(r2)
8111d65c:	18001826 	beq	r3,zero,8111d6c0 <strlen+0x80>
8111d660:	10800044 	addi	r2,r2,1
8111d664:	10c000cc 	andi	r3,r2,3
8111d668:	183ffb1e 	bne	r3,zero,8111d658 <__reset+0xfb0fd658>
8111d66c:	10c00017 	ldw	r3,0(r2)
8111d670:	01ffbff4 	movhi	r7,65279
8111d674:	39ffbfc4 	addi	r7,r7,-257
8111d678:	00ca303a 	nor	r5,zero,r3
8111d67c:	01a02074 	movhi	r6,32897
8111d680:	19c7883a 	add	r3,r3,r7
8111d684:	31a02004 	addi	r6,r6,-32640
8111d688:	1946703a 	and	r3,r3,r5
8111d68c:	1986703a 	and	r3,r3,r6
8111d690:	1800091e 	bne	r3,zero,8111d6b8 <strlen+0x78>
8111d694:	10800104 	addi	r2,r2,4
8111d698:	10c00017 	ldw	r3,0(r2)
8111d69c:	19cb883a 	add	r5,r3,r7
8111d6a0:	00c6303a 	nor	r3,zero,r3
8111d6a4:	28c6703a 	and	r3,r5,r3
8111d6a8:	1986703a 	and	r3,r3,r6
8111d6ac:	183ff926 	beq	r3,zero,8111d694 <__reset+0xfb0fd694>
8111d6b0:	00000106 	br	8111d6b8 <strlen+0x78>
8111d6b4:	10800044 	addi	r2,r2,1
8111d6b8:	10c00007 	ldb	r3,0(r2)
8111d6bc:	183ffd1e 	bne	r3,zero,8111d6b4 <__reset+0xfb0fd6b4>
8111d6c0:	1105c83a 	sub	r2,r2,r4
8111d6c4:	f800283a 	ret
8111d6c8:	2005883a 	mov	r2,r4
8111d6cc:	003fe706 	br	8111d66c <__reset+0xfb0fd66c>
8111d6d0:	0005883a 	mov	r2,zero
8111d6d4:	f800283a 	ret

8111d6d8 <strnlen>:
8111d6d8:	28000e26 	beq	r5,zero,8111d714 <strnlen+0x3c>
8111d6dc:	20800007 	ldb	r2,0(r4)
8111d6e0:	10000c26 	beq	r2,zero,8111d714 <strnlen+0x3c>
8111d6e4:	20c00044 	addi	r3,r4,1
8111d6e8:	214b883a 	add	r5,r4,r5
8111d6ec:	28c00526 	beq	r5,r3,8111d704 <strnlen+0x2c>
8111d6f0:	19800007 	ldb	r6,0(r3)
8111d6f4:	19c00044 	addi	r7,r3,1
8111d6f8:	30000426 	beq	r6,zero,8111d70c <strnlen+0x34>
8111d6fc:	3807883a 	mov	r3,r7
8111d700:	28fffb1e 	bne	r5,r3,8111d6f0 <__reset+0xfb0fd6f0>
8111d704:	2905c83a 	sub	r2,r5,r4
8111d708:	f800283a 	ret
8111d70c:	1905c83a 	sub	r2,r3,r4
8111d710:	f800283a 	ret
8111d714:	0005883a 	mov	r2,zero
8111d718:	f800283a 	ret

8111d71c <_strtol_r>:
8111d71c:	00a04574 	movhi	r2,33045
8111d720:	defff404 	addi	sp,sp,-48
8111d724:	10b52704 	addi	r2,r2,-11108
8111d728:	de00012e 	bgeu	sp,et,8111d730 <_strtol_r+0x14>
8111d72c:	003b68fa 	trap	3
8111d730:	dd400715 	stw	r21,28(sp)
8111d734:	15400017 	ldw	r21,0(r2)
8111d738:	dd800815 	stw	r22,32(sp)
8111d73c:	dd000615 	stw	r20,24(sp)
8111d740:	dcc00515 	stw	r19,20(sp)
8111d744:	d9000015 	stw	r4,0(sp)
8111d748:	dfc00b15 	stw	ra,44(sp)
8111d74c:	df000a15 	stw	fp,40(sp)
8111d750:	ddc00915 	stw	r23,36(sp)
8111d754:	dc800415 	stw	r18,16(sp)
8111d758:	dc400315 	stw	r17,12(sp)
8111d75c:	dc000215 	stw	r16,8(sp)
8111d760:	2829883a 	mov	r20,r5
8111d764:	3027883a 	mov	r19,r6
8111d768:	382d883a 	mov	r22,r7
8111d76c:	2809883a 	mov	r4,r5
8111d770:	24000003 	ldbu	r16,0(r4)
8111d774:	24400044 	addi	r17,r4,1
8111d778:	2007883a 	mov	r3,r4
8111d77c:	ac05883a 	add	r2,r21,r16
8111d780:	10800043 	ldbu	r2,1(r2)
8111d784:	8809883a 	mov	r4,r17
8111d788:	1080020c 	andi	r2,r2,8
8111d78c:	103ff81e 	bne	r2,zero,8111d770 <__reset+0xfb0fd770>
8111d790:	00800b44 	movi	r2,45
8111d794:	80805826 	beq	r16,r2,8111d8f8 <_strtol_r+0x1dc>
8111d798:	00800ac4 	movi	r2,43
8111d79c:	80805a26 	beq	r16,r2,8111d908 <_strtol_r+0x1ec>
8111d7a0:	0039883a 	mov	fp,zero
8111d7a4:	b0004426 	beq	r22,zero,8111d8b8 <_strtol_r+0x19c>
8111d7a8:	00800404 	movi	r2,16
8111d7ac:	b0806026 	beq	r22,r2,8111d930 <_strtol_r+0x214>
8111d7b0:	b02f883a 	mov	r23,r22
8111d7b4:	00a00034 	movhi	r2,32768
8111d7b8:	e025003a 	cmpeq	r18,fp,zero
8111d7bc:	14a5c83a 	sub	r18,r2,r18
8111d7c0:	b80b883a 	mov	r5,r23
8111d7c4:	9009883a 	mov	r4,r18
8111d7c8:	112f1980 	call	8112f198 <__umodsi3>
8111d7cc:	b80b883a 	mov	r5,r23
8111d7d0:	9009883a 	mov	r4,r18
8111d7d4:	d8800115 	stw	r2,4(sp)
8111d7d8:	112f1340 	call	8112f134 <__udivsi3>
8111d7dc:	ac07883a 	add	r3,r21,r16
8111d7e0:	18c00043 	ldbu	r3,1(r3)
8111d7e4:	880b883a 	mov	r5,r17
8111d7e8:	000d883a 	mov	r6,zero
8111d7ec:	1a00010c 	andi	r8,r3,4
8111d7f0:	0009883a 	mov	r4,zero
8111d7f4:	02800044 	movi	r10,1
8111d7f8:	027fffc4 	movi	r9,-1
8111d7fc:	d9c00117 	ldw	r7,4(sp)
8111d800:	40000e26 	beq	r8,zero,8111d83c <_strtol_r+0x120>
8111d804:	843ff404 	addi	r16,r16,-48
8111d808:	8580120e 	bge	r16,r22,8111d854 <_strtol_r+0x138>
8111d80c:	32400526 	beq	r6,r9,8111d824 <_strtol_r+0x108>
8111d810:	11002536 	bltu	r2,r4,8111d8a8 <_strtol_r+0x18c>
8111d814:	20802326 	beq	r4,r2,8111d8a4 <_strtol_r+0x188>
8111d818:	25c9383a 	mul	r4,r4,r23
8111d81c:	01800044 	movi	r6,1
8111d820:	8109883a 	add	r4,r16,r4
8111d824:	2c000003 	ldbu	r16,0(r5)
8111d828:	29400044 	addi	r5,r5,1
8111d82c:	ac07883a 	add	r3,r21,r16
8111d830:	18c00043 	ldbu	r3,1(r3)
8111d834:	1a00010c 	andi	r8,r3,4
8111d838:	403ff21e 	bne	r8,zero,8111d804 <__reset+0xfb0fd804>
8111d83c:	18c000cc 	andi	r3,r3,3
8111d840:	18000426 	beq	r3,zero,8111d854 <_strtol_r+0x138>
8111d844:	1a801a26 	beq	r3,r10,8111d8b0 <_strtol_r+0x194>
8111d848:	00c015c4 	movi	r3,87
8111d84c:	80e1c83a 	sub	r16,r16,r3
8111d850:	85bfee16 	blt	r16,r22,8111d80c <__reset+0xfb0fd80c>
8111d854:	00bfffc4 	movi	r2,-1
8111d858:	30801e26 	beq	r6,r2,8111d8d4 <_strtol_r+0x1b8>
8111d85c:	e0001b1e 	bne	fp,zero,8111d8cc <_strtol_r+0x1b0>
8111d860:	2005883a 	mov	r2,r4
8111d864:	98000326 	beq	r19,zero,8111d874 <_strtol_r+0x158>
8111d868:	3000211e 	bne	r6,zero,8111d8f0 <_strtol_r+0x1d4>
8111d86c:	a00b883a 	mov	r5,r20
8111d870:	99400015 	stw	r5,0(r19)
8111d874:	dfc00b17 	ldw	ra,44(sp)
8111d878:	df000a17 	ldw	fp,40(sp)
8111d87c:	ddc00917 	ldw	r23,36(sp)
8111d880:	dd800817 	ldw	r22,32(sp)
8111d884:	dd400717 	ldw	r21,28(sp)
8111d888:	dd000617 	ldw	r20,24(sp)
8111d88c:	dcc00517 	ldw	r19,20(sp)
8111d890:	dc800417 	ldw	r18,16(sp)
8111d894:	dc400317 	ldw	r17,12(sp)
8111d898:	dc000217 	ldw	r16,8(sp)
8111d89c:	dec00c04 	addi	sp,sp,48
8111d8a0:	f800283a 	ret
8111d8a4:	3c3fdc0e 	bge	r7,r16,8111d818 <__reset+0xfb0fd818>
8111d8a8:	01bfffc4 	movi	r6,-1
8111d8ac:	003fdd06 	br	8111d824 <__reset+0xfb0fd824>
8111d8b0:	00c00dc4 	movi	r3,55
8111d8b4:	003fe506 	br	8111d84c <__reset+0xfb0fd84c>
8111d8b8:	00800c04 	movi	r2,48
8111d8bc:	80801626 	beq	r16,r2,8111d918 <_strtol_r+0x1fc>
8111d8c0:	05800284 	movi	r22,10
8111d8c4:	b02f883a 	mov	r23,r22
8111d8c8:	003fba06 	br	8111d7b4 <__reset+0xfb0fd7b4>
8111d8cc:	0109c83a 	sub	r4,zero,r4
8111d8d0:	003fe306 	br	8111d860 <__reset+0xfb0fd860>
8111d8d4:	d9000017 	ldw	r4,0(sp)
8111d8d8:	00c00884 	movi	r3,34
8111d8dc:	e005003a 	cmpeq	r2,fp,zero
8111d8e0:	20c00015 	stw	r3,0(r4)
8111d8e4:	00e00034 	movhi	r3,32768
8111d8e8:	1885c83a 	sub	r2,r3,r2
8111d8ec:	983fe126 	beq	r19,zero,8111d874 <__reset+0xfb0fd874>
8111d8f0:	297fffc4 	addi	r5,r5,-1
8111d8f4:	003fde06 	br	8111d870 <__reset+0xfb0fd870>
8111d8f8:	1c400084 	addi	r17,r3,2
8111d8fc:	1c000043 	ldbu	r16,1(r3)
8111d900:	07000044 	movi	fp,1
8111d904:	003fa706 	br	8111d7a4 <__reset+0xfb0fd7a4>
8111d908:	1c400084 	addi	r17,r3,2
8111d90c:	1c000043 	ldbu	r16,1(r3)
8111d910:	0039883a 	mov	fp,zero
8111d914:	003fa306 	br	8111d7a4 <__reset+0xfb0fd7a4>
8111d918:	88800003 	ldbu	r2,0(r17)
8111d91c:	00c01604 	movi	r3,88
8111d920:	108037cc 	andi	r2,r2,223
8111d924:	10c00826 	beq	r2,r3,8111d948 <_strtol_r+0x22c>
8111d928:	05800204 	movi	r22,8
8111d92c:	003fa006 	br	8111d7b0 <__reset+0xfb0fd7b0>
8111d930:	00800c04 	movi	r2,48
8111d934:	80bf9e1e 	bne	r16,r2,8111d7b0 <__reset+0xfb0fd7b0>
8111d938:	88800003 	ldbu	r2,0(r17)
8111d93c:	00c01604 	movi	r3,88
8111d940:	108037cc 	andi	r2,r2,223
8111d944:	10ff9a1e 	bne	r2,r3,8111d7b0 <__reset+0xfb0fd7b0>
8111d948:	05c00404 	movi	r23,16
8111d94c:	8c000043 	ldbu	r16,1(r17)
8111d950:	b82d883a 	mov	r22,r23
8111d954:	8c400084 	addi	r17,r17,2
8111d958:	003f9606 	br	8111d7b4 <__reset+0xfb0fd7b4>

8111d95c <strtol>:
8111d95c:	00a04574 	movhi	r2,33045
8111d960:	10b52904 	addi	r2,r2,-11100
8111d964:	300f883a 	mov	r7,r6
8111d968:	280d883a 	mov	r6,r5
8111d96c:	200b883a 	mov	r5,r4
8111d970:	11000017 	ldw	r4,0(r2)
8111d974:	111d71c1 	jmpi	8111d71c <_strtol_r>

8111d978 <___svfprintf_internal_r>:
8111d978:	deffb704 	addi	sp,sp,-292
8111d97c:	de00012e 	bgeu	sp,et,8111d984 <___svfprintf_internal_r+0xc>
8111d980:	003b68fa 	trap	3
8111d984:	dfc04815 	stw	ra,288(sp)
8111d988:	ddc04615 	stw	r23,280(sp)
8111d98c:	d9402c15 	stw	r5,176(sp)
8111d990:	d9003915 	stw	r4,228(sp)
8111d994:	302f883a 	mov	r23,r6
8111d998:	d9c02d15 	stw	r7,180(sp)
8111d99c:	df004715 	stw	fp,284(sp)
8111d9a0:	dd804515 	stw	r22,276(sp)
8111d9a4:	dd404415 	stw	r21,272(sp)
8111d9a8:	dd004315 	stw	r20,268(sp)
8111d9ac:	dcc04215 	stw	r19,264(sp)
8111d9b0:	dc804115 	stw	r18,260(sp)
8111d9b4:	dc404015 	stw	r17,256(sp)
8111d9b8:	dc003f15 	stw	r16,252(sp)
8111d9bc:	11268600 	call	81126860 <_localeconv_r>
8111d9c0:	10800017 	ldw	r2,0(r2)
8111d9c4:	1009883a 	mov	r4,r2
8111d9c8:	d8803415 	stw	r2,208(sp)
8111d9cc:	111d6400 	call	8111d640 <strlen>
8111d9d0:	d8c02c17 	ldw	r3,176(sp)
8111d9d4:	d8803815 	stw	r2,224(sp)
8111d9d8:	1880030b 	ldhu	r2,12(r3)
8111d9dc:	1080200c 	andi	r2,r2,128
8111d9e0:	10000226 	beq	r2,zero,8111d9ec <___svfprintf_internal_r+0x74>
8111d9e4:	18800417 	ldw	r2,16(r3)
8111d9e8:	10067f26 	beq	r2,zero,8111f3e8 <___svfprintf_internal_r+0x1a70>
8111d9ec:	dcc03917 	ldw	r19,228(sp)
8111d9f0:	d8c00404 	addi	r3,sp,16
8111d9f4:	05604574 	movhi	r21,33045
8111d9f8:	d9001e04 	addi	r4,sp,120
8111d9fc:	ad6b6184 	addi	r21,r21,-21114
8111da00:	d8c01e15 	stw	r3,120(sp)
8111da04:	d8002015 	stw	zero,128(sp)
8111da08:	d8001f15 	stw	zero,124(sp)
8111da0c:	d8003315 	stw	zero,204(sp)
8111da10:	d8003615 	stw	zero,216(sp)
8111da14:	d8003715 	stw	zero,220(sp)
8111da18:	1811883a 	mov	r8,r3
8111da1c:	d8003a15 	stw	zero,232(sp)
8111da20:	d8003b15 	stw	zero,236(sp)
8111da24:	d8002f15 	stw	zero,188(sp)
8111da28:	d9002815 	stw	r4,160(sp)
8111da2c:	b8800007 	ldb	r2,0(r23)
8111da30:	10026726 	beq	r2,zero,8111e3d0 <___svfprintf_internal_r+0xa58>
8111da34:	00c00944 	movi	r3,37
8111da38:	b821883a 	mov	r16,r23
8111da3c:	10c0021e 	bne	r2,r3,8111da48 <___svfprintf_internal_r+0xd0>
8111da40:	00001406 	br	8111da94 <___svfprintf_internal_r+0x11c>
8111da44:	10c00326 	beq	r2,r3,8111da54 <___svfprintf_internal_r+0xdc>
8111da48:	84000044 	addi	r16,r16,1
8111da4c:	80800007 	ldb	r2,0(r16)
8111da50:	103ffc1e 	bne	r2,zero,8111da44 <__reset+0xfb0fda44>
8111da54:	85e3c83a 	sub	r17,r16,r23
8111da58:	88000e26 	beq	r17,zero,8111da94 <___svfprintf_internal_r+0x11c>
8111da5c:	d8c02017 	ldw	r3,128(sp)
8111da60:	d8801f17 	ldw	r2,124(sp)
8111da64:	45c00015 	stw	r23,0(r8)
8111da68:	1c47883a 	add	r3,r3,r17
8111da6c:	10800044 	addi	r2,r2,1
8111da70:	d8c02015 	stw	r3,128(sp)
8111da74:	44400115 	stw	r17,4(r8)
8111da78:	d8801f15 	stw	r2,124(sp)
8111da7c:	00c001c4 	movi	r3,7
8111da80:	18809716 	blt	r3,r2,8111dce0 <___svfprintf_internal_r+0x368>
8111da84:	42000204 	addi	r8,r8,8
8111da88:	d9402f17 	ldw	r5,188(sp)
8111da8c:	2c4b883a 	add	r5,r5,r17
8111da90:	d9402f15 	stw	r5,188(sp)
8111da94:	80800007 	ldb	r2,0(r16)
8111da98:	10009826 	beq	r2,zero,8111dcfc <___svfprintf_internal_r+0x384>
8111da9c:	84400047 	ldb	r17,1(r16)
8111daa0:	00bfffc4 	movi	r2,-1
8111daa4:	85c00044 	addi	r23,r16,1
8111daa8:	d8002785 	stb	zero,158(sp)
8111daac:	0007883a 	mov	r3,zero
8111dab0:	000f883a 	mov	r7,zero
8111dab4:	d8802915 	stw	r2,164(sp)
8111dab8:	d8003115 	stw	zero,196(sp)
8111dabc:	0025883a 	mov	r18,zero
8111dac0:	01401604 	movi	r5,88
8111dac4:	01800244 	movi	r6,9
8111dac8:	02800a84 	movi	r10,42
8111dacc:	02401b04 	movi	r9,108
8111dad0:	bdc00044 	addi	r23,r23,1
8111dad4:	88bff804 	addi	r2,r17,-32
8111dad8:	2882f036 	bltu	r5,r2,8111e69c <___svfprintf_internal_r+0xd24>
8111dadc:	100490ba 	slli	r2,r2,2
8111dae0:	012044b4 	movhi	r4,33042
8111dae4:	2136bd04 	addi	r4,r4,-9484
8111dae8:	1105883a 	add	r2,r2,r4
8111daec:	10800017 	ldw	r2,0(r2)
8111daf0:	1000683a 	jmp	r2
8111daf4:	8111e604 	addi	r4,r16,18328
8111daf8:	8111e69c 	xori	r4,r16,18330
8111dafc:	8111e69c 	xori	r4,r16,18330
8111db00:	8111e5f8 	rdprs	r4,r16,18327
8111db04:	8111e69c 	xori	r4,r16,18330
8111db08:	8111e69c 	xori	r4,r16,18330
8111db0c:	8111e69c 	xori	r4,r16,18330
8111db10:	8111e69c 	xori	r4,r16,18330
8111db14:	8111e69c 	xori	r4,r16,18330
8111db18:	8111e69c 	xori	r4,r16,18330
8111db1c:	8111dd58 	cmpnei	r4,r16,18293
8111db20:	8111e534 	orhi	r4,r16,18324
8111db24:	8111e69c 	xori	r4,r16,18330
8111db28:	8111dc68 	cmpgeui	r4,r16,18289
8111db2c:	8111dd80 	call	88111dd8 <__reset+0x20f1dd8>
8111db30:	8111e69c 	xori	r4,r16,18330
8111db34:	8111ddf4 	orhi	r4,r16,18295
8111db38:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db3c:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db40:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db44:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db48:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db4c:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db50:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db54:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db58:	8111ddc0 	call	88111ddc <__reset+0x20f1ddc>
8111db5c:	8111e69c 	xori	r4,r16,18330
8111db60:	8111e69c 	xori	r4,r16,18330
8111db64:	8111e69c 	xori	r4,r16,18330
8111db68:	8111e69c 	xori	r4,r16,18330
8111db6c:	8111e69c 	xori	r4,r16,18330
8111db70:	8111e69c 	xori	r4,r16,18330
8111db74:	8111e69c 	xori	r4,r16,18330
8111db78:	8111e69c 	xori	r4,r16,18330
8111db7c:	8111e69c 	xori	r4,r16,18330
8111db80:	8111e69c 	xori	r4,r16,18330
8111db84:	8111deac 	andhi	r4,r16,18298
8111db88:	8111de00 	call	88111de0 <__reset+0x20f1de0>
8111db8c:	8111e69c 	xori	r4,r16,18330
8111db90:	8111de00 	call	88111de0 <__reset+0x20f1de0>
8111db94:	8111e69c 	xori	r4,r16,18330
8111db98:	8111e69c 	xori	r4,r16,18330
8111db9c:	8111e69c 	xori	r4,r16,18330
8111dba0:	8111e69c 	xori	r4,r16,18330
8111dba4:	8111dea0 	cmpeqi	r4,r16,18298
8111dba8:	8111e69c 	xori	r4,r16,18330
8111dbac:	8111e69c 	xori	r4,r16,18330
8111dbb0:	8111df68 	cmpgeui	r4,r16,18301
8111dbb4:	8111e69c 	xori	r4,r16,18330
8111dbb8:	8111e69c 	xori	r4,r16,18330
8111dbbc:	8111e69c 	xori	r4,r16,18330
8111dbc0:	8111e69c 	xori	r4,r16,18330
8111dbc4:	8111e69c 	xori	r4,r16,18330
8111dbc8:	8111e3d8 	cmpnei	r4,r16,18319
8111dbcc:	8111e69c 	xori	r4,r16,18330
8111dbd0:	8111e69c 	xori	r4,r16,18330
8111dbd4:	8111e438 	rdprs	r4,r16,18320
8111dbd8:	8111e69c 	xori	r4,r16,18330
8111dbdc:	8111e69c 	xori	r4,r16,18330
8111dbe0:	8111e69c 	xori	r4,r16,18330
8111dbe4:	8111e69c 	xori	r4,r16,18330
8111dbe8:	8111e69c 	xori	r4,r16,18330
8111dbec:	8111e69c 	xori	r4,r16,18330
8111dbf0:	8111e69c 	xori	r4,r16,18330
8111dbf4:	8111e69c 	xori	r4,r16,18330
8111dbf8:	8111e69c 	xori	r4,r16,18330
8111dbfc:	8111e69c 	xori	r4,r16,18330
8111dc00:	8111e4e8 	cmpgeui	r4,r16,18323
8111dc04:	8111e624 	muli	r4,r16,18328
8111dc08:	8111de00 	call	88111de0 <__reset+0x20f1de0>
8111dc0c:	8111de00 	call	88111de0 <__reset+0x20f1de0>
8111dc10:	8111de00 	call	88111de0 <__reset+0x20f1de0>
8111dc14:	8111e678 	rdprs	r4,r16,18329
8111dc18:	8111e624 	muli	r4,r16,18328
8111dc1c:	8111e69c 	xori	r4,r16,18330
8111dc20:	8111e69c 	xori	r4,r16,18330
8111dc24:	8111e634 	orhi	r4,r16,18328
8111dc28:	8111e69c 	xori	r4,r16,18330
8111dc2c:	8111e644 	addi	r4,r16,18329
8111dc30:	8111e524 	muli	r4,r16,18324
8111dc34:	8111dc74 	orhi	r4,r16,18289
8111dc38:	8111e544 	addi	r4,r16,18325
8111dc3c:	8111e69c 	xori	r4,r16,18330
8111dc40:	8111e550 	cmplti	r4,r16,18325
8111dc44:	8111e69c 	xori	r4,r16,18330
8111dc48:	8111e5ac 	andhi	r4,r16,18326
8111dc4c:	8111e69c 	xori	r4,r16,18330
8111dc50:	8111e69c 	xori	r4,r16,18330
8111dc54:	8111e5bc 	xorhi	r4,r16,18326
8111dc58:	d9003117 	ldw	r4,196(sp)
8111dc5c:	d8802d15 	stw	r2,180(sp)
8111dc60:	0109c83a 	sub	r4,zero,r4
8111dc64:	d9003115 	stw	r4,196(sp)
8111dc68:	94800114 	ori	r18,r18,4
8111dc6c:	bc400007 	ldb	r17,0(r23)
8111dc70:	003f9706 	br	8111dad0 <__reset+0xfb0fdad0>
8111dc74:	00800c04 	movi	r2,48
8111dc78:	d9002d17 	ldw	r4,180(sp)
8111dc7c:	d9402917 	ldw	r5,164(sp)
8111dc80:	d8802705 	stb	r2,156(sp)
8111dc84:	00801e04 	movi	r2,120
8111dc88:	d8802745 	stb	r2,157(sp)
8111dc8c:	d8002785 	stb	zero,158(sp)
8111dc90:	20c00104 	addi	r3,r4,4
8111dc94:	25000017 	ldw	r20,0(r4)
8111dc98:	002d883a 	mov	r22,zero
8111dc9c:	90800094 	ori	r2,r18,2
8111dca0:	28028616 	blt	r5,zero,8111e6bc <___svfprintf_internal_r+0xd44>
8111dca4:	00bfdfc4 	movi	r2,-129
8111dca8:	90a4703a 	and	r18,r18,r2
8111dcac:	d8c02d15 	stw	r3,180(sp)
8111dcb0:	94800094 	ori	r18,r18,2
8111dcb4:	a002731e 	bne	r20,zero,8111e684 <___svfprintf_internal_r+0xd0c>
8111dcb8:	00a04574 	movhi	r2,33045
8111dcbc:	10ab5a04 	addi	r2,r2,-21144
8111dcc0:	d8803a15 	stw	r2,232(sp)
8111dcc4:	04401e04 	movi	r17,120
8111dcc8:	d8c02917 	ldw	r3,164(sp)
8111dccc:	0039883a 	mov	fp,zero
8111dcd0:	1801d526 	beq	r3,zero,8111e428 <___svfprintf_internal_r+0xab0>
8111dcd4:	0029883a 	mov	r20,zero
8111dcd8:	002d883a 	mov	r22,zero
8111dcdc:	0001f106 	br	8111e4a4 <___svfprintf_internal_r+0xb2c>
8111dce0:	d9402c17 	ldw	r5,176(sp)
8111dce4:	d9801e04 	addi	r6,sp,120
8111dce8:	9809883a 	mov	r4,r19
8111dcec:	112a5980 	call	8112a598 <__ssprint_r>
8111dcf0:	1000081e 	bne	r2,zero,8111dd14 <___svfprintf_internal_r+0x39c>
8111dcf4:	da000404 	addi	r8,sp,16
8111dcf8:	003f6306 	br	8111da88 <__reset+0xfb0fda88>
8111dcfc:	d8802017 	ldw	r2,128(sp)
8111dd00:	10000426 	beq	r2,zero,8111dd14 <___svfprintf_internal_r+0x39c>
8111dd04:	d9402c17 	ldw	r5,176(sp)
8111dd08:	d9003917 	ldw	r4,228(sp)
8111dd0c:	d9801e04 	addi	r6,sp,120
8111dd10:	112a5980 	call	8112a598 <__ssprint_r>
8111dd14:	d8802c17 	ldw	r2,176(sp)
8111dd18:	10c0030b 	ldhu	r3,12(r2)
8111dd1c:	d8802f17 	ldw	r2,188(sp)
8111dd20:	18c0100c 	andi	r3,r3,64
8111dd24:	1805f51e 	bne	r3,zero,8111f4fc <___svfprintf_internal_r+0x1b84>
8111dd28:	dfc04817 	ldw	ra,288(sp)
8111dd2c:	df004717 	ldw	fp,284(sp)
8111dd30:	ddc04617 	ldw	r23,280(sp)
8111dd34:	dd804517 	ldw	r22,276(sp)
8111dd38:	dd404417 	ldw	r21,272(sp)
8111dd3c:	dd004317 	ldw	r20,268(sp)
8111dd40:	dcc04217 	ldw	r19,264(sp)
8111dd44:	dc804117 	ldw	r18,260(sp)
8111dd48:	dc404017 	ldw	r17,256(sp)
8111dd4c:	dc003f17 	ldw	r16,252(sp)
8111dd50:	dec04904 	addi	sp,sp,292
8111dd54:	f800283a 	ret
8111dd58:	d8802d17 	ldw	r2,180(sp)
8111dd5c:	d9002d17 	ldw	r4,180(sp)
8111dd60:	10800017 	ldw	r2,0(r2)
8111dd64:	d8803115 	stw	r2,196(sp)
8111dd68:	20800104 	addi	r2,r4,4
8111dd6c:	d9003117 	ldw	r4,196(sp)
8111dd70:	203fb916 	blt	r4,zero,8111dc58 <__reset+0xfb0fdc58>
8111dd74:	d8802d15 	stw	r2,180(sp)
8111dd78:	bc400007 	ldb	r17,0(r23)
8111dd7c:	003f5406 	br	8111dad0 <__reset+0xfb0fdad0>
8111dd80:	bc400007 	ldb	r17,0(r23)
8111dd84:	bac00044 	addi	r11,r23,1
8111dd88:	8a873926 	beq	r17,r10,8111fa70 <___svfprintf_internal_r+0x20f8>
8111dd8c:	88bff404 	addi	r2,r17,-48
8111dd90:	0009883a 	mov	r4,zero
8111dd94:	30868836 	bltu	r6,r2,8111f7b8 <___svfprintf_internal_r+0x1e40>
8111dd98:	5c400007 	ldb	r17,0(r11)
8111dd9c:	210002a4 	muli	r4,r4,10
8111dda0:	5dc00044 	addi	r23,r11,1
8111dda4:	b817883a 	mov	r11,r23
8111dda8:	2089883a 	add	r4,r4,r2
8111ddac:	88bff404 	addi	r2,r17,-48
8111ddb0:	30bff92e 	bgeu	r6,r2,8111dd98 <__reset+0xfb0fdd98>
8111ddb4:	2005d716 	blt	r4,zero,8111f514 <___svfprintf_internal_r+0x1b9c>
8111ddb8:	d9002915 	stw	r4,164(sp)
8111ddbc:	003f4506 	br	8111dad4 <__reset+0xfb0fdad4>
8111ddc0:	b809883a 	mov	r4,r23
8111ddc4:	d8003115 	stw	zero,196(sp)
8111ddc8:	88bff404 	addi	r2,r17,-48
8111ddcc:	0017883a 	mov	r11,zero
8111ddd0:	24400007 	ldb	r17,0(r4)
8111ddd4:	5ac002a4 	muli	r11,r11,10
8111ddd8:	bdc00044 	addi	r23,r23,1
8111dddc:	b809883a 	mov	r4,r23
8111dde0:	12d7883a 	add	r11,r2,r11
8111dde4:	88bff404 	addi	r2,r17,-48
8111dde8:	30bff92e 	bgeu	r6,r2,8111ddd0 <__reset+0xfb0fddd0>
8111ddec:	dac03115 	stw	r11,196(sp)
8111ddf0:	003f3806 	br	8111dad4 <__reset+0xfb0fdad4>
8111ddf4:	94802014 	ori	r18,r18,128
8111ddf8:	bc400007 	ldb	r17,0(r23)
8111ddfc:	003f3406 	br	8111dad0 <__reset+0xfb0fdad0>
8111de00:	18c03fcc 	andi	r3,r3,255
8111de04:	1807471e 	bne	r3,zero,8111fb24 <___svfprintf_internal_r+0x21ac>
8111de08:	9080020c 	andi	r2,r18,8
8111de0c:	10047d26 	beq	r2,zero,8111f004 <___svfprintf_internal_r+0x168c>
8111de10:	d8c02d17 	ldw	r3,180(sp)
8111de14:	d9002d17 	ldw	r4,180(sp)
8111de18:	d9402d17 	ldw	r5,180(sp)
8111de1c:	18c00017 	ldw	r3,0(r3)
8111de20:	21000117 	ldw	r4,4(r4)
8111de24:	29400204 	addi	r5,r5,8
8111de28:	d8c03615 	stw	r3,216(sp)
8111de2c:	d9003715 	stw	r4,220(sp)
8111de30:	d9402d15 	stw	r5,180(sp)
8111de34:	d9003617 	ldw	r4,216(sp)
8111de38:	d9403717 	ldw	r5,220(sp)
8111de3c:	da003e15 	stw	r8,248(sp)
8111de40:	04000044 	movi	r16,1
8111de44:	11283ac0 	call	811283ac <__fpclassifyd>
8111de48:	da003e17 	ldw	r8,248(sp)
8111de4c:	14044b1e 	bne	r2,r16,8111ef7c <___svfprintf_internal_r+0x1604>
8111de50:	d9003617 	ldw	r4,216(sp)
8111de54:	d9403717 	ldw	r5,220(sp)
8111de58:	000d883a 	mov	r6,zero
8111de5c:	000f883a 	mov	r7,zero
8111de60:	11306f40 	call	811306f4 <__ledf2>
8111de64:	da003e17 	ldw	r8,248(sp)
8111de68:	1005f316 	blt	r2,zero,8111f638 <___svfprintf_internal_r+0x1cc0>
8111de6c:	df002783 	ldbu	fp,158(sp)
8111de70:	008011c4 	movi	r2,71
8111de74:	1445590e 	bge	r2,r17,8111f3dc <___svfprintf_internal_r+0x1a64>
8111de78:	04204574 	movhi	r16,33045
8111de7c:	842b5204 	addi	r16,r16,-21176
8111de80:	00c000c4 	movi	r3,3
8111de84:	00bfdfc4 	movi	r2,-129
8111de88:	d8c02a15 	stw	r3,168(sp)
8111de8c:	90a4703a 	and	r18,r18,r2
8111de90:	d8c02e15 	stw	r3,184(sp)
8111de94:	d8002915 	stw	zero,164(sp)
8111de98:	d8003215 	stw	zero,200(sp)
8111de9c:	00006606 	br	8111e038 <___svfprintf_internal_r+0x6c0>
8111dea0:	94800214 	ori	r18,r18,8
8111dea4:	bc400007 	ldb	r17,0(r23)
8111dea8:	003f0906 	br	8111dad0 <__reset+0xfb0fdad0>
8111deac:	18c03fcc 	andi	r3,r3,255
8111deb0:	1807181e 	bne	r3,zero,8111fb14 <___svfprintf_internal_r+0x219c>
8111deb4:	94800414 	ori	r18,r18,16
8111deb8:	9080080c 	andi	r2,r18,32
8111debc:	10039626 	beq	r2,zero,8111ed18 <___svfprintf_internal_r+0x13a0>
8111dec0:	d9402d17 	ldw	r5,180(sp)
8111dec4:	28800117 	ldw	r2,4(r5)
8111dec8:	2d000017 	ldw	r20,0(r5)
8111decc:	29400204 	addi	r5,r5,8
8111ded0:	d9402d15 	stw	r5,180(sp)
8111ded4:	102d883a 	mov	r22,r2
8111ded8:	10039816 	blt	r2,zero,8111ed3c <___svfprintf_internal_r+0x13c4>
8111dedc:	d9402917 	ldw	r5,164(sp)
8111dee0:	df002783 	ldbu	fp,158(sp)
8111dee4:	2803ab16 	blt	r5,zero,8111ed94 <___svfprintf_internal_r+0x141c>
8111dee8:	00ffdfc4 	movi	r3,-129
8111deec:	a584b03a 	or	r2,r20,r22
8111def0:	90e4703a 	and	r18,r18,r3
8111def4:	10014a26 	beq	r2,zero,8111e420 <___svfprintf_internal_r+0xaa8>
8111def8:	b0034b26 	beq	r22,zero,8111ec28 <___svfprintf_internal_r+0x12b0>
8111defc:	dc402a15 	stw	r17,168(sp)
8111df00:	dc001e04 	addi	r16,sp,120
8111df04:	b023883a 	mov	r17,r22
8111df08:	402d883a 	mov	r22,r8
8111df0c:	a009883a 	mov	r4,r20
8111df10:	880b883a 	mov	r5,r17
8111df14:	01800284 	movi	r6,10
8111df18:	000f883a 	mov	r7,zero
8111df1c:	112eafc0 	call	8112eafc <__umoddi3>
8111df20:	10800c04 	addi	r2,r2,48
8111df24:	843fffc4 	addi	r16,r16,-1
8111df28:	a009883a 	mov	r4,r20
8111df2c:	880b883a 	mov	r5,r17
8111df30:	80800005 	stb	r2,0(r16)
8111df34:	01800284 	movi	r6,10
8111df38:	000f883a 	mov	r7,zero
8111df3c:	112e57c0 	call	8112e57c <__udivdi3>
8111df40:	1029883a 	mov	r20,r2
8111df44:	10c4b03a 	or	r2,r2,r3
8111df48:	1823883a 	mov	r17,r3
8111df4c:	103fef1e 	bne	r2,zero,8111df0c <__reset+0xfb0fdf0c>
8111df50:	d8c02817 	ldw	r3,160(sp)
8111df54:	dc402a17 	ldw	r17,168(sp)
8111df58:	b011883a 	mov	r8,r22
8111df5c:	1c07c83a 	sub	r3,r3,r16
8111df60:	d8c02e15 	stw	r3,184(sp)
8111df64:	00002e06 	br	8111e020 <___svfprintf_internal_r+0x6a8>
8111df68:	18c03fcc 	andi	r3,r3,255
8111df6c:	1806e71e 	bne	r3,zero,8111fb0c <___svfprintf_internal_r+0x2194>
8111df70:	94800414 	ori	r18,r18,16
8111df74:	9080080c 	andi	r2,r18,32
8111df78:	1002d426 	beq	r2,zero,8111eacc <___svfprintf_internal_r+0x1154>
8111df7c:	d9402d17 	ldw	r5,180(sp)
8111df80:	d8c02917 	ldw	r3,164(sp)
8111df84:	d8002785 	stb	zero,158(sp)
8111df88:	28800204 	addi	r2,r5,8
8111df8c:	2d000017 	ldw	r20,0(r5)
8111df90:	2d800117 	ldw	r22,4(r5)
8111df94:	18041516 	blt	r3,zero,8111efec <___svfprintf_internal_r+0x1674>
8111df98:	013fdfc4 	movi	r4,-129
8111df9c:	a586b03a 	or	r3,r20,r22
8111dfa0:	d8802d15 	stw	r2,180(sp)
8111dfa4:	9124703a 	and	r18,r18,r4
8111dfa8:	1802d51e 	bne	r3,zero,8111eb00 <___svfprintf_internal_r+0x1188>
8111dfac:	d9402917 	ldw	r5,164(sp)
8111dfb0:	0039883a 	mov	fp,zero
8111dfb4:	2806be26 	beq	r5,zero,8111fab0 <___svfprintf_internal_r+0x2138>
8111dfb8:	0029883a 	mov	r20,zero
8111dfbc:	002d883a 	mov	r22,zero
8111dfc0:	dc001e04 	addi	r16,sp,120
8111dfc4:	a006d0fa 	srli	r3,r20,3
8111dfc8:	b008977a 	slli	r4,r22,29
8111dfcc:	b02cd0fa 	srli	r22,r22,3
8111dfd0:	a50001cc 	andi	r20,r20,7
8111dfd4:	a0800c04 	addi	r2,r20,48
8111dfd8:	843fffc4 	addi	r16,r16,-1
8111dfdc:	20e8b03a 	or	r20,r4,r3
8111dfe0:	80800005 	stb	r2,0(r16)
8111dfe4:	a586b03a 	or	r3,r20,r22
8111dfe8:	183ff61e 	bne	r3,zero,8111dfc4 <__reset+0xfb0fdfc4>
8111dfec:	90c0004c 	andi	r3,r18,1
8111dff0:	18013926 	beq	r3,zero,8111e4d8 <___svfprintf_internal_r+0xb60>
8111dff4:	10803fcc 	andi	r2,r2,255
8111dff8:	1080201c 	xori	r2,r2,128
8111dffc:	10bfe004 	addi	r2,r2,-128
8111e000:	00c00c04 	movi	r3,48
8111e004:	10c13426 	beq	r2,r3,8111e4d8 <___svfprintf_internal_r+0xb60>
8111e008:	80ffffc5 	stb	r3,-1(r16)
8111e00c:	d8c02817 	ldw	r3,160(sp)
8111e010:	80bfffc4 	addi	r2,r16,-1
8111e014:	1021883a 	mov	r16,r2
8111e018:	1887c83a 	sub	r3,r3,r2
8111e01c:	d8c02e15 	stw	r3,184(sp)
8111e020:	d8802e17 	ldw	r2,184(sp)
8111e024:	d9002917 	ldw	r4,164(sp)
8111e028:	1100010e 	bge	r2,r4,8111e030 <___svfprintf_internal_r+0x6b8>
8111e02c:	2005883a 	mov	r2,r4
8111e030:	d8802a15 	stw	r2,168(sp)
8111e034:	d8003215 	stw	zero,200(sp)
8111e038:	e7003fcc 	andi	fp,fp,255
8111e03c:	e700201c 	xori	fp,fp,128
8111e040:	e73fe004 	addi	fp,fp,-128
8111e044:	e0000326 	beq	fp,zero,8111e054 <___svfprintf_internal_r+0x6dc>
8111e048:	d8c02a17 	ldw	r3,168(sp)
8111e04c:	18c00044 	addi	r3,r3,1
8111e050:	d8c02a15 	stw	r3,168(sp)
8111e054:	90c0008c 	andi	r3,r18,2
8111e058:	d8c02b15 	stw	r3,172(sp)
8111e05c:	18000326 	beq	r3,zero,8111e06c <___svfprintf_internal_r+0x6f4>
8111e060:	d8c02a17 	ldw	r3,168(sp)
8111e064:	18c00084 	addi	r3,r3,2
8111e068:	d8c02a15 	stw	r3,168(sp)
8111e06c:	90c0210c 	andi	r3,r18,132
8111e070:	d8c03015 	stw	r3,192(sp)
8111e074:	1801a11e 	bne	r3,zero,8111e6fc <___svfprintf_internal_r+0xd84>
8111e078:	d9003117 	ldw	r4,196(sp)
8111e07c:	d8c02a17 	ldw	r3,168(sp)
8111e080:	20e9c83a 	sub	r20,r4,r3
8111e084:	05019d0e 	bge	zero,r20,8111e6fc <___svfprintf_internal_r+0xd84>
8111e088:	02400404 	movi	r9,16
8111e08c:	d8c02017 	ldw	r3,128(sp)
8111e090:	d8801f17 	ldw	r2,124(sp)
8111e094:	4d051b0e 	bge	r9,r20,8111f504 <___svfprintf_internal_r+0x1b8c>
8111e098:	01604574 	movhi	r5,33045
8111e09c:	296b6584 	addi	r5,r5,-21098
8111e0a0:	dc403c15 	stw	r17,240(sp)
8111e0a4:	d9403515 	stw	r5,212(sp)
8111e0a8:	a023883a 	mov	r17,r20
8111e0ac:	482d883a 	mov	r22,r9
8111e0b0:	9029883a 	mov	r20,r18
8111e0b4:	070001c4 	movi	fp,7
8111e0b8:	8025883a 	mov	r18,r16
8111e0bc:	dc002c17 	ldw	r16,176(sp)
8111e0c0:	00000306 	br	8111e0d0 <___svfprintf_internal_r+0x758>
8111e0c4:	8c7ffc04 	addi	r17,r17,-16
8111e0c8:	42000204 	addi	r8,r8,8
8111e0cc:	b440130e 	bge	r22,r17,8111e11c <___svfprintf_internal_r+0x7a4>
8111e0d0:	01204574 	movhi	r4,33045
8111e0d4:	18c00404 	addi	r3,r3,16
8111e0d8:	10800044 	addi	r2,r2,1
8111e0dc:	212b6584 	addi	r4,r4,-21098
8111e0e0:	41000015 	stw	r4,0(r8)
8111e0e4:	45800115 	stw	r22,4(r8)
8111e0e8:	d8c02015 	stw	r3,128(sp)
8111e0ec:	d8801f15 	stw	r2,124(sp)
8111e0f0:	e0bff40e 	bge	fp,r2,8111e0c4 <__reset+0xfb0fe0c4>
8111e0f4:	d9801e04 	addi	r6,sp,120
8111e0f8:	800b883a 	mov	r5,r16
8111e0fc:	9809883a 	mov	r4,r19
8111e100:	112a5980 	call	8112a598 <__ssprint_r>
8111e104:	103f031e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111e108:	8c7ffc04 	addi	r17,r17,-16
8111e10c:	d8c02017 	ldw	r3,128(sp)
8111e110:	d8801f17 	ldw	r2,124(sp)
8111e114:	da000404 	addi	r8,sp,16
8111e118:	b47fed16 	blt	r22,r17,8111e0d0 <__reset+0xfb0fe0d0>
8111e11c:	9021883a 	mov	r16,r18
8111e120:	a025883a 	mov	r18,r20
8111e124:	8829883a 	mov	r20,r17
8111e128:	dc403c17 	ldw	r17,240(sp)
8111e12c:	d9403517 	ldw	r5,212(sp)
8111e130:	a0c7883a 	add	r3,r20,r3
8111e134:	10800044 	addi	r2,r2,1
8111e138:	41400015 	stw	r5,0(r8)
8111e13c:	45000115 	stw	r20,4(r8)
8111e140:	d8c02015 	stw	r3,128(sp)
8111e144:	d8801f15 	stw	r2,124(sp)
8111e148:	010001c4 	movi	r4,7
8111e14c:	20829f16 	blt	r4,r2,8111ebcc <___svfprintf_internal_r+0x1254>
8111e150:	df002787 	ldb	fp,158(sp)
8111e154:	42000204 	addi	r8,r8,8
8111e158:	e0000c26 	beq	fp,zero,8111e18c <___svfprintf_internal_r+0x814>
8111e15c:	d8801f17 	ldw	r2,124(sp)
8111e160:	d9002784 	addi	r4,sp,158
8111e164:	18c00044 	addi	r3,r3,1
8111e168:	10800044 	addi	r2,r2,1
8111e16c:	41000015 	stw	r4,0(r8)
8111e170:	01000044 	movi	r4,1
8111e174:	41000115 	stw	r4,4(r8)
8111e178:	d8c02015 	stw	r3,128(sp)
8111e17c:	d8801f15 	stw	r2,124(sp)
8111e180:	010001c4 	movi	r4,7
8111e184:	20823816 	blt	r4,r2,8111ea68 <___svfprintf_internal_r+0x10f0>
8111e188:	42000204 	addi	r8,r8,8
8111e18c:	d8802b17 	ldw	r2,172(sp)
8111e190:	10000c26 	beq	r2,zero,8111e1c4 <___svfprintf_internal_r+0x84c>
8111e194:	d8801f17 	ldw	r2,124(sp)
8111e198:	d9002704 	addi	r4,sp,156
8111e19c:	18c00084 	addi	r3,r3,2
8111e1a0:	10800044 	addi	r2,r2,1
8111e1a4:	41000015 	stw	r4,0(r8)
8111e1a8:	01000084 	movi	r4,2
8111e1ac:	41000115 	stw	r4,4(r8)
8111e1b0:	d8c02015 	stw	r3,128(sp)
8111e1b4:	d8801f15 	stw	r2,124(sp)
8111e1b8:	010001c4 	movi	r4,7
8111e1bc:	20823216 	blt	r4,r2,8111ea88 <___svfprintf_internal_r+0x1110>
8111e1c0:	42000204 	addi	r8,r8,8
8111e1c4:	d9003017 	ldw	r4,192(sp)
8111e1c8:	00802004 	movi	r2,128
8111e1cc:	20819726 	beq	r4,r2,8111e82c <___svfprintf_internal_r+0xeb4>
8111e1d0:	d9402917 	ldw	r5,164(sp)
8111e1d4:	d8802e17 	ldw	r2,184(sp)
8111e1d8:	28adc83a 	sub	r22,r5,r2
8111e1dc:	05802f0e 	bge	zero,r22,8111e29c <___svfprintf_internal_r+0x924>
8111e1e0:	07000404 	movi	fp,16
8111e1e4:	d8801f17 	ldw	r2,124(sp)
8111e1e8:	e583c00e 	bge	fp,r22,8111f0ec <___svfprintf_internal_r+0x1774>
8111e1ec:	01604574 	movhi	r5,33045
8111e1f0:	296b6184 	addi	r5,r5,-21114
8111e1f4:	dc402915 	stw	r17,164(sp)
8111e1f8:	d9402b15 	stw	r5,172(sp)
8111e1fc:	b023883a 	mov	r17,r22
8111e200:	050001c4 	movi	r20,7
8111e204:	902d883a 	mov	r22,r18
8111e208:	8025883a 	mov	r18,r16
8111e20c:	dc002c17 	ldw	r16,176(sp)
8111e210:	00000306 	br	8111e220 <___svfprintf_internal_r+0x8a8>
8111e214:	8c7ffc04 	addi	r17,r17,-16
8111e218:	42000204 	addi	r8,r8,8
8111e21c:	e440110e 	bge	fp,r17,8111e264 <___svfprintf_internal_r+0x8ec>
8111e220:	18c00404 	addi	r3,r3,16
8111e224:	10800044 	addi	r2,r2,1
8111e228:	45400015 	stw	r21,0(r8)
8111e22c:	47000115 	stw	fp,4(r8)
8111e230:	d8c02015 	stw	r3,128(sp)
8111e234:	d8801f15 	stw	r2,124(sp)
8111e238:	a0bff60e 	bge	r20,r2,8111e214 <__reset+0xfb0fe214>
8111e23c:	d9801e04 	addi	r6,sp,120
8111e240:	800b883a 	mov	r5,r16
8111e244:	9809883a 	mov	r4,r19
8111e248:	112a5980 	call	8112a598 <__ssprint_r>
8111e24c:	103eb11e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111e250:	8c7ffc04 	addi	r17,r17,-16
8111e254:	d8c02017 	ldw	r3,128(sp)
8111e258:	d8801f17 	ldw	r2,124(sp)
8111e25c:	da000404 	addi	r8,sp,16
8111e260:	e47fef16 	blt	fp,r17,8111e220 <__reset+0xfb0fe220>
8111e264:	9021883a 	mov	r16,r18
8111e268:	b025883a 	mov	r18,r22
8111e26c:	882d883a 	mov	r22,r17
8111e270:	dc402917 	ldw	r17,164(sp)
8111e274:	d9002b17 	ldw	r4,172(sp)
8111e278:	1d87883a 	add	r3,r3,r22
8111e27c:	10800044 	addi	r2,r2,1
8111e280:	41000015 	stw	r4,0(r8)
8111e284:	45800115 	stw	r22,4(r8)
8111e288:	d8c02015 	stw	r3,128(sp)
8111e28c:	d8801f15 	stw	r2,124(sp)
8111e290:	010001c4 	movi	r4,7
8111e294:	2081ec16 	blt	r4,r2,8111ea48 <___svfprintf_internal_r+0x10d0>
8111e298:	42000204 	addi	r8,r8,8
8111e29c:	9080400c 	andi	r2,r18,256
8111e2a0:	1001181e 	bne	r2,zero,8111e704 <___svfprintf_internal_r+0xd8c>
8111e2a4:	d9402e17 	ldw	r5,184(sp)
8111e2a8:	d8801f17 	ldw	r2,124(sp)
8111e2ac:	44000015 	stw	r16,0(r8)
8111e2b0:	1947883a 	add	r3,r3,r5
8111e2b4:	10800044 	addi	r2,r2,1
8111e2b8:	41400115 	stw	r5,4(r8)
8111e2bc:	d8c02015 	stw	r3,128(sp)
8111e2c0:	d8801f15 	stw	r2,124(sp)
8111e2c4:	010001c4 	movi	r4,7
8111e2c8:	2081d116 	blt	r4,r2,8111ea10 <___svfprintf_internal_r+0x1098>
8111e2cc:	42000204 	addi	r8,r8,8
8111e2d0:	9480010c 	andi	r18,r18,4
8111e2d4:	90003226 	beq	r18,zero,8111e3a0 <___svfprintf_internal_r+0xa28>
8111e2d8:	d9403117 	ldw	r5,196(sp)
8111e2dc:	d8802a17 	ldw	r2,168(sp)
8111e2e0:	28a1c83a 	sub	r16,r5,r2
8111e2e4:	04002e0e 	bge	zero,r16,8111e3a0 <___svfprintf_internal_r+0xa28>
8111e2e8:	04400404 	movi	r17,16
8111e2ec:	d8801f17 	ldw	r2,124(sp)
8111e2f0:	8c04b90e 	bge	r17,r16,8111f5d8 <___svfprintf_internal_r+0x1c60>
8111e2f4:	01604574 	movhi	r5,33045
8111e2f8:	296b6584 	addi	r5,r5,-21098
8111e2fc:	d9403515 	stw	r5,212(sp)
8111e300:	048001c4 	movi	r18,7
8111e304:	dd002c17 	ldw	r20,176(sp)
8111e308:	00000306 	br	8111e318 <___svfprintf_internal_r+0x9a0>
8111e30c:	843ffc04 	addi	r16,r16,-16
8111e310:	42000204 	addi	r8,r8,8
8111e314:	8c00130e 	bge	r17,r16,8111e364 <___svfprintf_internal_r+0x9ec>
8111e318:	01204574 	movhi	r4,33045
8111e31c:	18c00404 	addi	r3,r3,16
8111e320:	10800044 	addi	r2,r2,1
8111e324:	212b6584 	addi	r4,r4,-21098
8111e328:	41000015 	stw	r4,0(r8)
8111e32c:	44400115 	stw	r17,4(r8)
8111e330:	d8c02015 	stw	r3,128(sp)
8111e334:	d8801f15 	stw	r2,124(sp)
8111e338:	90bff40e 	bge	r18,r2,8111e30c <__reset+0xfb0fe30c>
8111e33c:	d9801e04 	addi	r6,sp,120
8111e340:	a00b883a 	mov	r5,r20
8111e344:	9809883a 	mov	r4,r19
8111e348:	112a5980 	call	8112a598 <__ssprint_r>
8111e34c:	103e711e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111e350:	843ffc04 	addi	r16,r16,-16
8111e354:	d8c02017 	ldw	r3,128(sp)
8111e358:	d8801f17 	ldw	r2,124(sp)
8111e35c:	da000404 	addi	r8,sp,16
8111e360:	8c3fed16 	blt	r17,r16,8111e318 <__reset+0xfb0fe318>
8111e364:	d9403517 	ldw	r5,212(sp)
8111e368:	1c07883a 	add	r3,r3,r16
8111e36c:	10800044 	addi	r2,r2,1
8111e370:	41400015 	stw	r5,0(r8)
8111e374:	44000115 	stw	r16,4(r8)
8111e378:	d8c02015 	stw	r3,128(sp)
8111e37c:	d8801f15 	stw	r2,124(sp)
8111e380:	010001c4 	movi	r4,7
8111e384:	2080060e 	bge	r4,r2,8111e3a0 <___svfprintf_internal_r+0xa28>
8111e388:	d9402c17 	ldw	r5,176(sp)
8111e38c:	d9801e04 	addi	r6,sp,120
8111e390:	9809883a 	mov	r4,r19
8111e394:	112a5980 	call	8112a598 <__ssprint_r>
8111e398:	103e5e1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111e39c:	d8c02017 	ldw	r3,128(sp)
8111e3a0:	d8803117 	ldw	r2,196(sp)
8111e3a4:	d9002a17 	ldw	r4,168(sp)
8111e3a8:	1100010e 	bge	r2,r4,8111e3b0 <___svfprintf_internal_r+0xa38>
8111e3ac:	2005883a 	mov	r2,r4
8111e3b0:	d9402f17 	ldw	r5,188(sp)
8111e3b4:	288b883a 	add	r5,r5,r2
8111e3b8:	d9402f15 	stw	r5,188(sp)
8111e3bc:	18019c1e 	bne	r3,zero,8111ea30 <___svfprintf_internal_r+0x10b8>
8111e3c0:	b8800007 	ldb	r2,0(r23)
8111e3c4:	d8001f15 	stw	zero,124(sp)
8111e3c8:	da000404 	addi	r8,sp,16
8111e3cc:	103d991e 	bne	r2,zero,8111da34 <__reset+0xfb0fda34>
8111e3d0:	b821883a 	mov	r16,r23
8111e3d4:	003daf06 	br	8111da94 <__reset+0xfb0fda94>
8111e3d8:	18c03fcc 	andi	r3,r3,255
8111e3dc:	1805c71e 	bne	r3,zero,8111fafc <___svfprintf_internal_r+0x2184>
8111e3e0:	94800414 	ori	r18,r18,16
8111e3e4:	9080080c 	andi	r2,r18,32
8111e3e8:	10020126 	beq	r2,zero,8111ebf0 <___svfprintf_internal_r+0x1278>
8111e3ec:	d8802d17 	ldw	r2,180(sp)
8111e3f0:	d9002917 	ldw	r4,164(sp)
8111e3f4:	d8002785 	stb	zero,158(sp)
8111e3f8:	10c00204 	addi	r3,r2,8
8111e3fc:	15000017 	ldw	r20,0(r2)
8111e400:	15800117 	ldw	r22,4(r2)
8111e404:	20038e16 	blt	r4,zero,8111f240 <___svfprintf_internal_r+0x18c8>
8111e408:	013fdfc4 	movi	r4,-129
8111e40c:	a584b03a 	or	r2,r20,r22
8111e410:	d8c02d15 	stw	r3,180(sp)
8111e414:	9124703a 	and	r18,r18,r4
8111e418:	0039883a 	mov	fp,zero
8111e41c:	103eb61e 	bne	r2,zero,8111def8 <__reset+0xfb0fdef8>
8111e420:	d8802917 	ldw	r2,164(sp)
8111e424:	1002c81e 	bne	r2,zero,8111ef48 <___svfprintf_internal_r+0x15d0>
8111e428:	d8002915 	stw	zero,164(sp)
8111e42c:	d8002e15 	stw	zero,184(sp)
8111e430:	dc001e04 	addi	r16,sp,120
8111e434:	003efa06 	br	8111e020 <__reset+0xfb0fe020>
8111e438:	18c03fcc 	andi	r3,r3,255
8111e43c:	1805ad1e 	bne	r3,zero,8111faf4 <___svfprintf_internal_r+0x217c>
8111e440:	01604574 	movhi	r5,33045
8111e444:	296b5504 	addi	r5,r5,-21164
8111e448:	d9403a15 	stw	r5,232(sp)
8111e44c:	9080080c 	andi	r2,r18,32
8111e450:	10006126 	beq	r2,zero,8111e5d8 <___svfprintf_internal_r+0xc60>
8111e454:	d8802d17 	ldw	r2,180(sp)
8111e458:	15000017 	ldw	r20,0(r2)
8111e45c:	15800117 	ldw	r22,4(r2)
8111e460:	10800204 	addi	r2,r2,8
8111e464:	d8802d15 	stw	r2,180(sp)
8111e468:	9080004c 	andi	r2,r18,1
8111e46c:	10018e26 	beq	r2,zero,8111eaa8 <___svfprintf_internal_r+0x1130>
8111e470:	a584b03a 	or	r2,r20,r22
8111e474:	10030926 	beq	r2,zero,8111f09c <___svfprintf_internal_r+0x1724>
8111e478:	d8c02917 	ldw	r3,164(sp)
8111e47c:	00800c04 	movi	r2,48
8111e480:	d8802705 	stb	r2,156(sp)
8111e484:	dc402745 	stb	r17,157(sp)
8111e488:	d8002785 	stb	zero,158(sp)
8111e48c:	90800094 	ori	r2,r18,2
8111e490:	18048716 	blt	r3,zero,8111f6b0 <___svfprintf_internal_r+0x1d38>
8111e494:	00bfdfc4 	movi	r2,-129
8111e498:	90a4703a 	and	r18,r18,r2
8111e49c:	94800094 	ori	r18,r18,2
8111e4a0:	0039883a 	mov	fp,zero
8111e4a4:	d9003a17 	ldw	r4,232(sp)
8111e4a8:	dc001e04 	addi	r16,sp,120
8111e4ac:	a08003cc 	andi	r2,r20,15
8111e4b0:	b006973a 	slli	r3,r22,28
8111e4b4:	2085883a 	add	r2,r4,r2
8111e4b8:	a028d13a 	srli	r20,r20,4
8111e4bc:	10800003 	ldbu	r2,0(r2)
8111e4c0:	b02cd13a 	srli	r22,r22,4
8111e4c4:	843fffc4 	addi	r16,r16,-1
8111e4c8:	1d28b03a 	or	r20,r3,r20
8111e4cc:	80800005 	stb	r2,0(r16)
8111e4d0:	a584b03a 	or	r2,r20,r22
8111e4d4:	103ff51e 	bne	r2,zero,8111e4ac <__reset+0xfb0fe4ac>
8111e4d8:	d8c02817 	ldw	r3,160(sp)
8111e4dc:	1c07c83a 	sub	r3,r3,r16
8111e4e0:	d8c02e15 	stw	r3,184(sp)
8111e4e4:	003ece06 	br	8111e020 <__reset+0xfb0fe020>
8111e4e8:	d8c02d17 	ldw	r3,180(sp)
8111e4ec:	d9002d17 	ldw	r4,180(sp)
8111e4f0:	d8002785 	stb	zero,158(sp)
8111e4f4:	18800017 	ldw	r2,0(r3)
8111e4f8:	21000104 	addi	r4,r4,4
8111e4fc:	00c00044 	movi	r3,1
8111e500:	d8c02a15 	stw	r3,168(sp)
8111e504:	d8801405 	stb	r2,80(sp)
8111e508:	d9002d15 	stw	r4,180(sp)
8111e50c:	d8c02e15 	stw	r3,184(sp)
8111e510:	d8002915 	stw	zero,164(sp)
8111e514:	d8003215 	stw	zero,200(sp)
8111e518:	dc001404 	addi	r16,sp,80
8111e51c:	0039883a 	mov	fp,zero
8111e520:	003ecc06 	br	8111e054 <__reset+0xfb0fe054>
8111e524:	18c03fcc 	andi	r3,r3,255
8111e528:	183e9226 	beq	r3,zero,8111df74 <__reset+0xfb0fdf74>
8111e52c:	d9c02785 	stb	r7,158(sp)
8111e530:	003e9006 	br	8111df74 <__reset+0xfb0fdf74>
8111e534:	00c00044 	movi	r3,1
8111e538:	01c00ac4 	movi	r7,43
8111e53c:	bc400007 	ldb	r17,0(r23)
8111e540:	003d6306 	br	8111dad0 <__reset+0xfb0fdad0>
8111e544:	94800814 	ori	r18,r18,32
8111e548:	bc400007 	ldb	r17,0(r23)
8111e54c:	003d6006 	br	8111dad0 <__reset+0xfb0fdad0>
8111e550:	d8c02d17 	ldw	r3,180(sp)
8111e554:	d8002785 	stb	zero,158(sp)
8111e558:	1c000017 	ldw	r16,0(r3)
8111e55c:	1d000104 	addi	r20,r3,4
8111e560:	80040f26 	beq	r16,zero,8111f5a0 <___svfprintf_internal_r+0x1c28>
8111e564:	d9002917 	ldw	r4,164(sp)
8111e568:	2003dc16 	blt	r4,zero,8111f4dc <___svfprintf_internal_r+0x1b64>
8111e56c:	200d883a 	mov	r6,r4
8111e570:	000b883a 	mov	r5,zero
8111e574:	8009883a 	mov	r4,r16
8111e578:	da003e15 	stw	r8,248(sp)
8111e57c:	1126b3c0 	call	81126b3c <memchr>
8111e580:	da003e17 	ldw	r8,248(sp)
8111e584:	10045826 	beq	r2,zero,8111f6e8 <___svfprintf_internal_r+0x1d70>
8111e588:	1405c83a 	sub	r2,r2,r16
8111e58c:	d8802e15 	stw	r2,184(sp)
8111e590:	1003d816 	blt	r2,zero,8111f4f4 <___svfprintf_internal_r+0x1b7c>
8111e594:	df002783 	ldbu	fp,158(sp)
8111e598:	d8802a15 	stw	r2,168(sp)
8111e59c:	dd002d15 	stw	r20,180(sp)
8111e5a0:	d8002915 	stw	zero,164(sp)
8111e5a4:	d8003215 	stw	zero,200(sp)
8111e5a8:	003ea306 	br	8111e038 <__reset+0xfb0fe038>
8111e5ac:	18c03fcc 	andi	r3,r3,255
8111e5b0:	183f8c26 	beq	r3,zero,8111e3e4 <__reset+0xfb0fe3e4>
8111e5b4:	d9c02785 	stb	r7,158(sp)
8111e5b8:	003f8a06 	br	8111e3e4 <__reset+0xfb0fe3e4>
8111e5bc:	18c03fcc 	andi	r3,r3,255
8111e5c0:	1805631e 	bne	r3,zero,8111fb50 <___svfprintf_internal_r+0x21d8>
8111e5c4:	01604574 	movhi	r5,33045
8111e5c8:	296b5a04 	addi	r5,r5,-21144
8111e5cc:	d9403a15 	stw	r5,232(sp)
8111e5d0:	9080080c 	andi	r2,r18,32
8111e5d4:	103f9f1e 	bne	r2,zero,8111e454 <__reset+0xfb0fe454>
8111e5d8:	9080040c 	andi	r2,r18,16
8111e5dc:	10029c26 	beq	r2,zero,8111f050 <___svfprintf_internal_r+0x16d8>
8111e5e0:	d8c02d17 	ldw	r3,180(sp)
8111e5e4:	002d883a 	mov	r22,zero
8111e5e8:	1d000017 	ldw	r20,0(r3)
8111e5ec:	18c00104 	addi	r3,r3,4
8111e5f0:	d8c02d15 	stw	r3,180(sp)
8111e5f4:	003f9c06 	br	8111e468 <__reset+0xfb0fe468>
8111e5f8:	94800054 	ori	r18,r18,1
8111e5fc:	bc400007 	ldb	r17,0(r23)
8111e600:	003d3306 	br	8111dad0 <__reset+0xfb0fdad0>
8111e604:	38803fcc 	andi	r2,r7,255
8111e608:	1080201c 	xori	r2,r2,128
8111e60c:	10bfe004 	addi	r2,r2,-128
8111e610:	1002971e 	bne	r2,zero,8111f070 <___svfprintf_internal_r+0x16f8>
8111e614:	00c00044 	movi	r3,1
8111e618:	01c00804 	movi	r7,32
8111e61c:	bc400007 	ldb	r17,0(r23)
8111e620:	003d2b06 	br	8111dad0 <__reset+0xfb0fdad0>
8111e624:	18c03fcc 	andi	r3,r3,255
8111e628:	183e2326 	beq	r3,zero,8111deb8 <__reset+0xfb0fdeb8>
8111e62c:	d9c02785 	stb	r7,158(sp)
8111e630:	003e2106 	br	8111deb8 <__reset+0xfb0fdeb8>
8111e634:	bc400007 	ldb	r17,0(r23)
8111e638:	8a430426 	beq	r17,r9,8111f24c <___svfprintf_internal_r+0x18d4>
8111e63c:	94800414 	ori	r18,r18,16
8111e640:	003d2306 	br	8111dad0 <__reset+0xfb0fdad0>
8111e644:	18c03fcc 	andi	r3,r3,255
8111e648:	18053f1e 	bne	r3,zero,8111fb48 <___svfprintf_internal_r+0x21d0>
8111e64c:	9080080c 	andi	r2,r18,32
8111e650:	10028926 	beq	r2,zero,8111f078 <___svfprintf_internal_r+0x1700>
8111e654:	d9402d17 	ldw	r5,180(sp)
8111e658:	d9002f17 	ldw	r4,188(sp)
8111e65c:	28800017 	ldw	r2,0(r5)
8111e660:	2007d7fa 	srai	r3,r4,31
8111e664:	29400104 	addi	r5,r5,4
8111e668:	d9402d15 	stw	r5,180(sp)
8111e66c:	11000015 	stw	r4,0(r2)
8111e670:	10c00115 	stw	r3,4(r2)
8111e674:	003ced06 	br	8111da2c <__reset+0xfb0fda2c>
8111e678:	94801014 	ori	r18,r18,64
8111e67c:	bc400007 	ldb	r17,0(r23)
8111e680:	003d1306 	br	8111dad0 <__reset+0xfb0fdad0>
8111e684:	01204574 	movhi	r4,33045
8111e688:	212b5a04 	addi	r4,r4,-21144
8111e68c:	0039883a 	mov	fp,zero
8111e690:	d9003a15 	stw	r4,232(sp)
8111e694:	04401e04 	movi	r17,120
8111e698:	003f8206 	br	8111e4a4 <__reset+0xfb0fe4a4>
8111e69c:	18c03fcc 	andi	r3,r3,255
8111e6a0:	1805221e 	bne	r3,zero,8111fb2c <___svfprintf_internal_r+0x21b4>
8111e6a4:	883d9526 	beq	r17,zero,8111dcfc <__reset+0xfb0fdcfc>
8111e6a8:	00c00044 	movi	r3,1
8111e6ac:	d8c02a15 	stw	r3,168(sp)
8111e6b0:	dc401405 	stb	r17,80(sp)
8111e6b4:	d8002785 	stb	zero,158(sp)
8111e6b8:	003f9406 	br	8111e50c <__reset+0xfb0fe50c>
8111e6bc:	01204574 	movhi	r4,33045
8111e6c0:	212b5a04 	addi	r4,r4,-21144
8111e6c4:	d9003a15 	stw	r4,232(sp)
8111e6c8:	d8c02d15 	stw	r3,180(sp)
8111e6cc:	1025883a 	mov	r18,r2
8111e6d0:	04401e04 	movi	r17,120
8111e6d4:	a584b03a 	or	r2,r20,r22
8111e6d8:	1000fa1e 	bne	r2,zero,8111eac4 <___svfprintf_internal_r+0x114c>
8111e6dc:	0039883a 	mov	fp,zero
8111e6e0:	00800084 	movi	r2,2
8111e6e4:	10803fcc 	andi	r2,r2,255
8111e6e8:	00c00044 	movi	r3,1
8111e6ec:	10c21626 	beq	r2,r3,8111ef48 <___svfprintf_internal_r+0x15d0>
8111e6f0:	00c00084 	movi	r3,2
8111e6f4:	10fe301e 	bne	r2,r3,8111dfb8 <__reset+0xfb0fdfb8>
8111e6f8:	003d7606 	br	8111dcd4 <__reset+0xfb0fdcd4>
8111e6fc:	d8c02017 	ldw	r3,128(sp)
8111e700:	003e9506 	br	8111e158 <__reset+0xfb0fe158>
8111e704:	00801944 	movi	r2,101
8111e708:	14407c0e 	bge	r2,r17,8111e8fc <___svfprintf_internal_r+0xf84>
8111e70c:	d9003617 	ldw	r4,216(sp)
8111e710:	d9403717 	ldw	r5,220(sp)
8111e714:	000d883a 	mov	r6,zero
8111e718:	000f883a 	mov	r7,zero
8111e71c:	d8c03d15 	stw	r3,244(sp)
8111e720:	da003e15 	stw	r8,248(sp)
8111e724:	11305900 	call	81130590 <__eqdf2>
8111e728:	d8c03d17 	ldw	r3,244(sp)
8111e72c:	da003e17 	ldw	r8,248(sp)
8111e730:	1000f51e 	bne	r2,zero,8111eb08 <___svfprintf_internal_r+0x1190>
8111e734:	d8801f17 	ldw	r2,124(sp)
8111e738:	01204574 	movhi	r4,33045
8111e73c:	212b6104 	addi	r4,r4,-21116
8111e740:	18c00044 	addi	r3,r3,1
8111e744:	10800044 	addi	r2,r2,1
8111e748:	41000015 	stw	r4,0(r8)
8111e74c:	01000044 	movi	r4,1
8111e750:	41000115 	stw	r4,4(r8)
8111e754:	d8c02015 	stw	r3,128(sp)
8111e758:	d8801f15 	stw	r2,124(sp)
8111e75c:	010001c4 	movi	r4,7
8111e760:	20826616 	blt	r4,r2,8111f0fc <___svfprintf_internal_r+0x1784>
8111e764:	42000204 	addi	r8,r8,8
8111e768:	d8802617 	ldw	r2,152(sp)
8111e76c:	d9403317 	ldw	r5,204(sp)
8111e770:	11400216 	blt	r2,r5,8111e77c <___svfprintf_internal_r+0xe04>
8111e774:	9080004c 	andi	r2,r18,1
8111e778:	103ed526 	beq	r2,zero,8111e2d0 <__reset+0xfb0fe2d0>
8111e77c:	d8803817 	ldw	r2,224(sp)
8111e780:	d9003417 	ldw	r4,208(sp)
8111e784:	d9403817 	ldw	r5,224(sp)
8111e788:	1887883a 	add	r3,r3,r2
8111e78c:	d8801f17 	ldw	r2,124(sp)
8111e790:	41000015 	stw	r4,0(r8)
8111e794:	41400115 	stw	r5,4(r8)
8111e798:	10800044 	addi	r2,r2,1
8111e79c:	d8c02015 	stw	r3,128(sp)
8111e7a0:	d8801f15 	stw	r2,124(sp)
8111e7a4:	010001c4 	movi	r4,7
8111e7a8:	2082af16 	blt	r4,r2,8111f268 <___svfprintf_internal_r+0x18f0>
8111e7ac:	42000204 	addi	r8,r8,8
8111e7b0:	d8803317 	ldw	r2,204(sp)
8111e7b4:	143fffc4 	addi	r16,r2,-1
8111e7b8:	043ec50e 	bge	zero,r16,8111e2d0 <__reset+0xfb0fe2d0>
8111e7bc:	04400404 	movi	r17,16
8111e7c0:	d8801f17 	ldw	r2,124(sp)
8111e7c4:	8c00860e 	bge	r17,r16,8111e9e0 <___svfprintf_internal_r+0x1068>
8111e7c8:	01604574 	movhi	r5,33045
8111e7cc:	296b6184 	addi	r5,r5,-21114
8111e7d0:	d9402b15 	stw	r5,172(sp)
8111e7d4:	058001c4 	movi	r22,7
8111e7d8:	dd002c17 	ldw	r20,176(sp)
8111e7dc:	00000306 	br	8111e7ec <___svfprintf_internal_r+0xe74>
8111e7e0:	42000204 	addi	r8,r8,8
8111e7e4:	843ffc04 	addi	r16,r16,-16
8111e7e8:	8c00800e 	bge	r17,r16,8111e9ec <___svfprintf_internal_r+0x1074>
8111e7ec:	18c00404 	addi	r3,r3,16
8111e7f0:	10800044 	addi	r2,r2,1
8111e7f4:	45400015 	stw	r21,0(r8)
8111e7f8:	44400115 	stw	r17,4(r8)
8111e7fc:	d8c02015 	stw	r3,128(sp)
8111e800:	d8801f15 	stw	r2,124(sp)
8111e804:	b0bff60e 	bge	r22,r2,8111e7e0 <__reset+0xfb0fe7e0>
8111e808:	d9801e04 	addi	r6,sp,120
8111e80c:	a00b883a 	mov	r5,r20
8111e810:	9809883a 	mov	r4,r19
8111e814:	112a5980 	call	8112a598 <__ssprint_r>
8111e818:	103d3e1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111e81c:	d8c02017 	ldw	r3,128(sp)
8111e820:	d8801f17 	ldw	r2,124(sp)
8111e824:	da000404 	addi	r8,sp,16
8111e828:	003fee06 	br	8111e7e4 <__reset+0xfb0fe7e4>
8111e82c:	d9403117 	ldw	r5,196(sp)
8111e830:	d8802a17 	ldw	r2,168(sp)
8111e834:	28adc83a 	sub	r22,r5,r2
8111e838:	05be650e 	bge	zero,r22,8111e1d0 <__reset+0xfb0fe1d0>
8111e83c:	07000404 	movi	fp,16
8111e840:	d8801f17 	ldw	r2,124(sp)
8111e844:	e583a20e 	bge	fp,r22,8111f6d0 <___svfprintf_internal_r+0x1d58>
8111e848:	01604574 	movhi	r5,33045
8111e84c:	296b6184 	addi	r5,r5,-21114
8111e850:	dc403015 	stw	r17,192(sp)
8111e854:	d9402b15 	stw	r5,172(sp)
8111e858:	b023883a 	mov	r17,r22
8111e85c:	050001c4 	movi	r20,7
8111e860:	902d883a 	mov	r22,r18
8111e864:	8025883a 	mov	r18,r16
8111e868:	dc002c17 	ldw	r16,176(sp)
8111e86c:	00000306 	br	8111e87c <___svfprintf_internal_r+0xf04>
8111e870:	8c7ffc04 	addi	r17,r17,-16
8111e874:	42000204 	addi	r8,r8,8
8111e878:	e440110e 	bge	fp,r17,8111e8c0 <___svfprintf_internal_r+0xf48>
8111e87c:	18c00404 	addi	r3,r3,16
8111e880:	10800044 	addi	r2,r2,1
8111e884:	45400015 	stw	r21,0(r8)
8111e888:	47000115 	stw	fp,4(r8)
8111e88c:	d8c02015 	stw	r3,128(sp)
8111e890:	d8801f15 	stw	r2,124(sp)
8111e894:	a0bff60e 	bge	r20,r2,8111e870 <__reset+0xfb0fe870>
8111e898:	d9801e04 	addi	r6,sp,120
8111e89c:	800b883a 	mov	r5,r16
8111e8a0:	9809883a 	mov	r4,r19
8111e8a4:	112a5980 	call	8112a598 <__ssprint_r>
8111e8a8:	103d1a1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111e8ac:	8c7ffc04 	addi	r17,r17,-16
8111e8b0:	d8c02017 	ldw	r3,128(sp)
8111e8b4:	d8801f17 	ldw	r2,124(sp)
8111e8b8:	da000404 	addi	r8,sp,16
8111e8bc:	e47fef16 	blt	fp,r17,8111e87c <__reset+0xfb0fe87c>
8111e8c0:	9021883a 	mov	r16,r18
8111e8c4:	b025883a 	mov	r18,r22
8111e8c8:	882d883a 	mov	r22,r17
8111e8cc:	dc403017 	ldw	r17,192(sp)
8111e8d0:	d9002b17 	ldw	r4,172(sp)
8111e8d4:	1d87883a 	add	r3,r3,r22
8111e8d8:	10800044 	addi	r2,r2,1
8111e8dc:	41000015 	stw	r4,0(r8)
8111e8e0:	45800115 	stw	r22,4(r8)
8111e8e4:	d8c02015 	stw	r3,128(sp)
8111e8e8:	d8801f15 	stw	r2,124(sp)
8111e8ec:	010001c4 	movi	r4,7
8111e8f0:	20819a16 	blt	r4,r2,8111ef5c <___svfprintf_internal_r+0x15e4>
8111e8f4:	42000204 	addi	r8,r8,8
8111e8f8:	003e3506 	br	8111e1d0 <__reset+0xfb0fe1d0>
8111e8fc:	d9403317 	ldw	r5,204(sp)
8111e900:	00800044 	movi	r2,1
8111e904:	18c00044 	addi	r3,r3,1
8111e908:	1141710e 	bge	r2,r5,8111eed0 <___svfprintf_internal_r+0x1558>
8111e90c:	dc401f17 	ldw	r17,124(sp)
8111e910:	00800044 	movi	r2,1
8111e914:	40800115 	stw	r2,4(r8)
8111e918:	8c400044 	addi	r17,r17,1
8111e91c:	44000015 	stw	r16,0(r8)
8111e920:	d8c02015 	stw	r3,128(sp)
8111e924:	dc401f15 	stw	r17,124(sp)
8111e928:	008001c4 	movi	r2,7
8111e92c:	14417416 	blt	r2,r17,8111ef00 <___svfprintf_internal_r+0x1588>
8111e930:	42000204 	addi	r8,r8,8
8111e934:	d8803817 	ldw	r2,224(sp)
8111e938:	d9003417 	ldw	r4,208(sp)
8111e93c:	8c400044 	addi	r17,r17,1
8111e940:	10c7883a 	add	r3,r2,r3
8111e944:	40800115 	stw	r2,4(r8)
8111e948:	41000015 	stw	r4,0(r8)
8111e94c:	d8c02015 	stw	r3,128(sp)
8111e950:	dc401f15 	stw	r17,124(sp)
8111e954:	008001c4 	movi	r2,7
8111e958:	14417216 	blt	r2,r17,8111ef24 <___svfprintf_internal_r+0x15ac>
8111e95c:	45800204 	addi	r22,r8,8
8111e960:	d9003617 	ldw	r4,216(sp)
8111e964:	d9403717 	ldw	r5,220(sp)
8111e968:	000d883a 	mov	r6,zero
8111e96c:	000f883a 	mov	r7,zero
8111e970:	d8c03d15 	stw	r3,244(sp)
8111e974:	11305900 	call	81130590 <__eqdf2>
8111e978:	d8c03d17 	ldw	r3,244(sp)
8111e97c:	1000b326 	beq	r2,zero,8111ec4c <___svfprintf_internal_r+0x12d4>
8111e980:	d9403317 	ldw	r5,204(sp)
8111e984:	84000044 	addi	r16,r16,1
8111e988:	8c400044 	addi	r17,r17,1
8111e98c:	28bfffc4 	addi	r2,r5,-1
8111e990:	1887883a 	add	r3,r3,r2
8111e994:	b0800115 	stw	r2,4(r22)
8111e998:	b4000015 	stw	r16,0(r22)
8111e99c:	d8c02015 	stw	r3,128(sp)
8111e9a0:	dc401f15 	stw	r17,124(sp)
8111e9a4:	008001c4 	movi	r2,7
8111e9a8:	1440d216 	blt	r2,r17,8111ecf4 <___svfprintf_internal_r+0x137c>
8111e9ac:	b5800204 	addi	r22,r22,8
8111e9b0:	d9003b17 	ldw	r4,236(sp)
8111e9b4:	df0022c4 	addi	fp,sp,139
8111e9b8:	8c400044 	addi	r17,r17,1
8111e9bc:	20c7883a 	add	r3,r4,r3
8111e9c0:	b7000015 	stw	fp,0(r22)
8111e9c4:	b1000115 	stw	r4,4(r22)
8111e9c8:	d8c02015 	stw	r3,128(sp)
8111e9cc:	dc401f15 	stw	r17,124(sp)
8111e9d0:	008001c4 	movi	r2,7
8111e9d4:	14400e16 	blt	r2,r17,8111ea10 <___svfprintf_internal_r+0x1098>
8111e9d8:	b2000204 	addi	r8,r22,8
8111e9dc:	003e3c06 	br	8111e2d0 <__reset+0xfb0fe2d0>
8111e9e0:	01204574 	movhi	r4,33045
8111e9e4:	212b6184 	addi	r4,r4,-21114
8111e9e8:	d9002b15 	stw	r4,172(sp)
8111e9ec:	d9002b17 	ldw	r4,172(sp)
8111e9f0:	1c07883a 	add	r3,r3,r16
8111e9f4:	44000115 	stw	r16,4(r8)
8111e9f8:	41000015 	stw	r4,0(r8)
8111e9fc:	10800044 	addi	r2,r2,1
8111ea00:	d8c02015 	stw	r3,128(sp)
8111ea04:	d8801f15 	stw	r2,124(sp)
8111ea08:	010001c4 	movi	r4,7
8111ea0c:	20be2f0e 	bge	r4,r2,8111e2cc <__reset+0xfb0fe2cc>
8111ea10:	d9402c17 	ldw	r5,176(sp)
8111ea14:	d9801e04 	addi	r6,sp,120
8111ea18:	9809883a 	mov	r4,r19
8111ea1c:	112a5980 	call	8112a598 <__ssprint_r>
8111ea20:	103cbc1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ea24:	d8c02017 	ldw	r3,128(sp)
8111ea28:	da000404 	addi	r8,sp,16
8111ea2c:	003e2806 	br	8111e2d0 <__reset+0xfb0fe2d0>
8111ea30:	d9402c17 	ldw	r5,176(sp)
8111ea34:	d9801e04 	addi	r6,sp,120
8111ea38:	9809883a 	mov	r4,r19
8111ea3c:	112a5980 	call	8112a598 <__ssprint_r>
8111ea40:	103e5f26 	beq	r2,zero,8111e3c0 <__reset+0xfb0fe3c0>
8111ea44:	003cb306 	br	8111dd14 <__reset+0xfb0fdd14>
8111ea48:	d9402c17 	ldw	r5,176(sp)
8111ea4c:	d9801e04 	addi	r6,sp,120
8111ea50:	9809883a 	mov	r4,r19
8111ea54:	112a5980 	call	8112a598 <__ssprint_r>
8111ea58:	103cae1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ea5c:	d8c02017 	ldw	r3,128(sp)
8111ea60:	da000404 	addi	r8,sp,16
8111ea64:	003e0d06 	br	8111e29c <__reset+0xfb0fe29c>
8111ea68:	d9402c17 	ldw	r5,176(sp)
8111ea6c:	d9801e04 	addi	r6,sp,120
8111ea70:	9809883a 	mov	r4,r19
8111ea74:	112a5980 	call	8112a598 <__ssprint_r>
8111ea78:	103ca61e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ea7c:	d8c02017 	ldw	r3,128(sp)
8111ea80:	da000404 	addi	r8,sp,16
8111ea84:	003dc106 	br	8111e18c <__reset+0xfb0fe18c>
8111ea88:	d9402c17 	ldw	r5,176(sp)
8111ea8c:	d9801e04 	addi	r6,sp,120
8111ea90:	9809883a 	mov	r4,r19
8111ea94:	112a5980 	call	8112a598 <__ssprint_r>
8111ea98:	103c9e1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ea9c:	d8c02017 	ldw	r3,128(sp)
8111eaa0:	da000404 	addi	r8,sp,16
8111eaa4:	003dc706 	br	8111e1c4 <__reset+0xfb0fe1c4>
8111eaa8:	d8802917 	ldw	r2,164(sp)
8111eaac:	d8002785 	stb	zero,158(sp)
8111eab0:	103f0816 	blt	r2,zero,8111e6d4 <__reset+0xfb0fe6d4>
8111eab4:	00ffdfc4 	movi	r3,-129
8111eab8:	a584b03a 	or	r2,r20,r22
8111eabc:	90e4703a 	and	r18,r18,r3
8111eac0:	103c8126 	beq	r2,zero,8111dcc8 <__reset+0xfb0fdcc8>
8111eac4:	0039883a 	mov	fp,zero
8111eac8:	003e7606 	br	8111e4a4 <__reset+0xfb0fe4a4>
8111eacc:	9080040c 	andi	r2,r18,16
8111ead0:	10013d26 	beq	r2,zero,8111efc8 <___svfprintf_internal_r+0x1650>
8111ead4:	d9002d17 	ldw	r4,180(sp)
8111ead8:	d9402917 	ldw	r5,164(sp)
8111eadc:	d8002785 	stb	zero,158(sp)
8111eae0:	20800104 	addi	r2,r4,4
8111eae4:	25000017 	ldw	r20,0(r4)
8111eae8:	002d883a 	mov	r22,zero
8111eaec:	28013f16 	blt	r5,zero,8111efec <___svfprintf_internal_r+0x1674>
8111eaf0:	00ffdfc4 	movi	r3,-129
8111eaf4:	d8802d15 	stw	r2,180(sp)
8111eaf8:	90e4703a 	and	r18,r18,r3
8111eafc:	a03d2b26 	beq	r20,zero,8111dfac <__reset+0xfb0fdfac>
8111eb00:	0039883a 	mov	fp,zero
8111eb04:	003d2e06 	br	8111dfc0 <__reset+0xfb0fdfc0>
8111eb08:	dc402617 	ldw	r17,152(sp)
8111eb0c:	0441830e 	bge	zero,r17,8111f11c <___svfprintf_internal_r+0x17a4>
8111eb10:	dc403217 	ldw	r17,200(sp)
8111eb14:	d8803317 	ldw	r2,204(sp)
8111eb18:	1440010e 	bge	r2,r17,8111eb20 <___svfprintf_internal_r+0x11a8>
8111eb1c:	1023883a 	mov	r17,r2
8111eb20:	04400a0e 	bge	zero,r17,8111eb4c <___svfprintf_internal_r+0x11d4>
8111eb24:	d8801f17 	ldw	r2,124(sp)
8111eb28:	1c47883a 	add	r3,r3,r17
8111eb2c:	44000015 	stw	r16,0(r8)
8111eb30:	10800044 	addi	r2,r2,1
8111eb34:	44400115 	stw	r17,4(r8)
8111eb38:	d8c02015 	stw	r3,128(sp)
8111eb3c:	d8801f15 	stw	r2,124(sp)
8111eb40:	010001c4 	movi	r4,7
8111eb44:	20827516 	blt	r4,r2,8111f51c <___svfprintf_internal_r+0x1ba4>
8111eb48:	42000204 	addi	r8,r8,8
8111eb4c:	88027b16 	blt	r17,zero,8111f53c <___svfprintf_internal_r+0x1bc4>
8111eb50:	d9003217 	ldw	r4,200(sp)
8111eb54:	2463c83a 	sub	r17,r4,r17
8111eb58:	0440990e 	bge	zero,r17,8111edc0 <___svfprintf_internal_r+0x1448>
8111eb5c:	05800404 	movi	r22,16
8111eb60:	d8801f17 	ldw	r2,124(sp)
8111eb64:	b441530e 	bge	r22,r17,8111f0b4 <___svfprintf_internal_r+0x173c>
8111eb68:	01204574 	movhi	r4,33045
8111eb6c:	212b6184 	addi	r4,r4,-21114
8111eb70:	d9002b15 	stw	r4,172(sp)
8111eb74:	070001c4 	movi	fp,7
8111eb78:	dd002c17 	ldw	r20,176(sp)
8111eb7c:	00000306 	br	8111eb8c <___svfprintf_internal_r+0x1214>
8111eb80:	42000204 	addi	r8,r8,8
8111eb84:	8c7ffc04 	addi	r17,r17,-16
8111eb88:	b4414d0e 	bge	r22,r17,8111f0c0 <___svfprintf_internal_r+0x1748>
8111eb8c:	18c00404 	addi	r3,r3,16
8111eb90:	10800044 	addi	r2,r2,1
8111eb94:	45400015 	stw	r21,0(r8)
8111eb98:	45800115 	stw	r22,4(r8)
8111eb9c:	d8c02015 	stw	r3,128(sp)
8111eba0:	d8801f15 	stw	r2,124(sp)
8111eba4:	e0bff60e 	bge	fp,r2,8111eb80 <__reset+0xfb0feb80>
8111eba8:	d9801e04 	addi	r6,sp,120
8111ebac:	a00b883a 	mov	r5,r20
8111ebb0:	9809883a 	mov	r4,r19
8111ebb4:	112a5980 	call	8112a598 <__ssprint_r>
8111ebb8:	103c561e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ebbc:	d8c02017 	ldw	r3,128(sp)
8111ebc0:	d8801f17 	ldw	r2,124(sp)
8111ebc4:	da000404 	addi	r8,sp,16
8111ebc8:	003fee06 	br	8111eb84 <__reset+0xfb0feb84>
8111ebcc:	d9402c17 	ldw	r5,176(sp)
8111ebd0:	d9801e04 	addi	r6,sp,120
8111ebd4:	9809883a 	mov	r4,r19
8111ebd8:	112a5980 	call	8112a598 <__ssprint_r>
8111ebdc:	103c4d1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ebe0:	d8c02017 	ldw	r3,128(sp)
8111ebe4:	df002787 	ldb	fp,158(sp)
8111ebe8:	da000404 	addi	r8,sp,16
8111ebec:	003d5a06 	br	8111e158 <__reset+0xfb0fe158>
8111ebf0:	9080040c 	andi	r2,r18,16
8111ebf4:	10005c26 	beq	r2,zero,8111ed68 <___svfprintf_internal_r+0x13f0>
8111ebf8:	d9402d17 	ldw	r5,180(sp)
8111ebfc:	d8c02917 	ldw	r3,164(sp)
8111ec00:	d8002785 	stb	zero,158(sp)
8111ec04:	28800104 	addi	r2,r5,4
8111ec08:	2d000017 	ldw	r20,0(r5)
8111ec0c:	002d883a 	mov	r22,zero
8111ec10:	18005e16 	blt	r3,zero,8111ed8c <___svfprintf_internal_r+0x1414>
8111ec14:	00ffdfc4 	movi	r3,-129
8111ec18:	d8802d15 	stw	r2,180(sp)
8111ec1c:	90e4703a 	and	r18,r18,r3
8111ec20:	0039883a 	mov	fp,zero
8111ec24:	a03dfe26 	beq	r20,zero,8111e420 <__reset+0xfb0fe420>
8111ec28:	00800244 	movi	r2,9
8111ec2c:	153cb336 	bltu	r2,r20,8111defc <__reset+0xfb0fdefc>
8111ec30:	a5000c04 	addi	r20,r20,48
8111ec34:	dc001dc4 	addi	r16,sp,119
8111ec38:	dd001dc5 	stb	r20,119(sp)
8111ec3c:	d8c02817 	ldw	r3,160(sp)
8111ec40:	1c07c83a 	sub	r3,r3,r16
8111ec44:	d8c02e15 	stw	r3,184(sp)
8111ec48:	003cf506 	br	8111e020 <__reset+0xfb0fe020>
8111ec4c:	d8803317 	ldw	r2,204(sp)
8111ec50:	143fffc4 	addi	r16,r2,-1
8111ec54:	043f560e 	bge	zero,r16,8111e9b0 <__reset+0xfb0fe9b0>
8111ec58:	07000404 	movi	fp,16
8111ec5c:	e403530e 	bge	fp,r16,8111f9ac <___svfprintf_internal_r+0x2034>
8111ec60:	01604574 	movhi	r5,33045
8111ec64:	296b6184 	addi	r5,r5,-21114
8111ec68:	d9402b15 	stw	r5,172(sp)
8111ec6c:	01c001c4 	movi	r7,7
8111ec70:	dd002c17 	ldw	r20,176(sp)
8111ec74:	00000306 	br	8111ec84 <___svfprintf_internal_r+0x130c>
8111ec78:	843ffc04 	addi	r16,r16,-16
8111ec7c:	b5800204 	addi	r22,r22,8
8111ec80:	e400130e 	bge	fp,r16,8111ecd0 <___svfprintf_internal_r+0x1358>
8111ec84:	18c00404 	addi	r3,r3,16
8111ec88:	8c400044 	addi	r17,r17,1
8111ec8c:	b5400015 	stw	r21,0(r22)
8111ec90:	b7000115 	stw	fp,4(r22)
8111ec94:	d8c02015 	stw	r3,128(sp)
8111ec98:	dc401f15 	stw	r17,124(sp)
8111ec9c:	3c7ff60e 	bge	r7,r17,8111ec78 <__reset+0xfb0fec78>
8111eca0:	d9801e04 	addi	r6,sp,120
8111eca4:	a00b883a 	mov	r5,r20
8111eca8:	9809883a 	mov	r4,r19
8111ecac:	d9c03d15 	stw	r7,244(sp)
8111ecb0:	112a5980 	call	8112a598 <__ssprint_r>
8111ecb4:	d9c03d17 	ldw	r7,244(sp)
8111ecb8:	103c161e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ecbc:	843ffc04 	addi	r16,r16,-16
8111ecc0:	d8c02017 	ldw	r3,128(sp)
8111ecc4:	dc401f17 	ldw	r17,124(sp)
8111ecc8:	dd800404 	addi	r22,sp,16
8111eccc:	e43fed16 	blt	fp,r16,8111ec84 <__reset+0xfb0fec84>
8111ecd0:	d8802b17 	ldw	r2,172(sp)
8111ecd4:	1c07883a 	add	r3,r3,r16
8111ecd8:	8c400044 	addi	r17,r17,1
8111ecdc:	b0800015 	stw	r2,0(r22)
8111ece0:	b4000115 	stw	r16,4(r22)
8111ece4:	d8c02015 	stw	r3,128(sp)
8111ece8:	dc401f15 	stw	r17,124(sp)
8111ecec:	008001c4 	movi	r2,7
8111ecf0:	147f2e0e 	bge	r2,r17,8111e9ac <__reset+0xfb0fe9ac>
8111ecf4:	d9402c17 	ldw	r5,176(sp)
8111ecf8:	d9801e04 	addi	r6,sp,120
8111ecfc:	9809883a 	mov	r4,r19
8111ed00:	112a5980 	call	8112a598 <__ssprint_r>
8111ed04:	103c031e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ed08:	d8c02017 	ldw	r3,128(sp)
8111ed0c:	dc401f17 	ldw	r17,124(sp)
8111ed10:	dd800404 	addi	r22,sp,16
8111ed14:	003f2606 	br	8111e9b0 <__reset+0xfb0fe9b0>
8111ed18:	9080040c 	andi	r2,r18,16
8111ed1c:	1000c326 	beq	r2,zero,8111f02c <___svfprintf_internal_r+0x16b4>
8111ed20:	d8802d17 	ldw	r2,180(sp)
8111ed24:	15000017 	ldw	r20,0(r2)
8111ed28:	10800104 	addi	r2,r2,4
8111ed2c:	d8802d15 	stw	r2,180(sp)
8111ed30:	a02dd7fa 	srai	r22,r20,31
8111ed34:	b005883a 	mov	r2,r22
8111ed38:	103c680e 	bge	r2,zero,8111dedc <__reset+0xfb0fdedc>
8111ed3c:	0529c83a 	sub	r20,zero,r20
8111ed40:	a004c03a 	cmpne	r2,r20,zero
8111ed44:	05adc83a 	sub	r22,zero,r22
8111ed48:	b0adc83a 	sub	r22,r22,r2
8111ed4c:	d8802917 	ldw	r2,164(sp)
8111ed50:	07000b44 	movi	fp,45
8111ed54:	df002785 	stb	fp,158(sp)
8111ed58:	10022e16 	blt	r2,zero,8111f614 <___svfprintf_internal_r+0x1c9c>
8111ed5c:	00bfdfc4 	movi	r2,-129
8111ed60:	90a4703a 	and	r18,r18,r2
8111ed64:	003c6406 	br	8111def8 <__reset+0xfb0fdef8>
8111ed68:	9080100c 	andi	r2,r18,64
8111ed6c:	d8002785 	stb	zero,158(sp)
8111ed70:	10012526 	beq	r2,zero,8111f208 <___svfprintf_internal_r+0x1890>
8111ed74:	d9002d17 	ldw	r4,180(sp)
8111ed78:	d9402917 	ldw	r5,164(sp)
8111ed7c:	002d883a 	mov	r22,zero
8111ed80:	20800104 	addi	r2,r4,4
8111ed84:	2500000b 	ldhu	r20,0(r4)
8111ed88:	283fa20e 	bge	r5,zero,8111ec14 <__reset+0xfb0fec14>
8111ed8c:	d8802d15 	stw	r2,180(sp)
8111ed90:	0039883a 	mov	fp,zero
8111ed94:	a584b03a 	or	r2,r20,r22
8111ed98:	103c571e 	bne	r2,zero,8111def8 <__reset+0xfb0fdef8>
8111ed9c:	00800044 	movi	r2,1
8111eda0:	003e5006 	br	8111e6e4 <__reset+0xfb0fe6e4>
8111eda4:	d9402c17 	ldw	r5,176(sp)
8111eda8:	d9801e04 	addi	r6,sp,120
8111edac:	9809883a 	mov	r4,r19
8111edb0:	112a5980 	call	8112a598 <__ssprint_r>
8111edb4:	103bd71e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111edb8:	d8c02017 	ldw	r3,128(sp)
8111edbc:	da000404 	addi	r8,sp,16
8111edc0:	d9003217 	ldw	r4,200(sp)
8111edc4:	d8802617 	ldw	r2,152(sp)
8111edc8:	d9403317 	ldw	r5,204(sp)
8111edcc:	8123883a 	add	r17,r16,r4
8111edd0:	11400216 	blt	r2,r5,8111eddc <___svfprintf_internal_r+0x1464>
8111edd4:	9100004c 	andi	r4,r18,1
8111edd8:	20000d26 	beq	r4,zero,8111ee10 <___svfprintf_internal_r+0x1498>
8111eddc:	d9003817 	ldw	r4,224(sp)
8111ede0:	d9403417 	ldw	r5,208(sp)
8111ede4:	1907883a 	add	r3,r3,r4
8111ede8:	d9001f17 	ldw	r4,124(sp)
8111edec:	41400015 	stw	r5,0(r8)
8111edf0:	d9403817 	ldw	r5,224(sp)
8111edf4:	21000044 	addi	r4,r4,1
8111edf8:	d8c02015 	stw	r3,128(sp)
8111edfc:	41400115 	stw	r5,4(r8)
8111ee00:	d9001f15 	stw	r4,124(sp)
8111ee04:	014001c4 	movi	r5,7
8111ee08:	2901dc16 	blt	r5,r4,8111f57c <___svfprintf_internal_r+0x1c04>
8111ee0c:	42000204 	addi	r8,r8,8
8111ee10:	d9003317 	ldw	r4,204(sp)
8111ee14:	8121883a 	add	r16,r16,r4
8111ee18:	2085c83a 	sub	r2,r4,r2
8111ee1c:	8461c83a 	sub	r16,r16,r17
8111ee20:	1400010e 	bge	r2,r16,8111ee28 <___svfprintf_internal_r+0x14b0>
8111ee24:	1021883a 	mov	r16,r2
8111ee28:	04000a0e 	bge	zero,r16,8111ee54 <___svfprintf_internal_r+0x14dc>
8111ee2c:	d9001f17 	ldw	r4,124(sp)
8111ee30:	1c07883a 	add	r3,r3,r16
8111ee34:	44400015 	stw	r17,0(r8)
8111ee38:	21000044 	addi	r4,r4,1
8111ee3c:	44000115 	stw	r16,4(r8)
8111ee40:	d8c02015 	stw	r3,128(sp)
8111ee44:	d9001f15 	stw	r4,124(sp)
8111ee48:	014001c4 	movi	r5,7
8111ee4c:	2901e616 	blt	r5,r4,8111f5e8 <___svfprintf_internal_r+0x1c70>
8111ee50:	42000204 	addi	r8,r8,8
8111ee54:	8001f616 	blt	r16,zero,8111f630 <___svfprintf_internal_r+0x1cb8>
8111ee58:	1421c83a 	sub	r16,r2,r16
8111ee5c:	043d1c0e 	bge	zero,r16,8111e2d0 <__reset+0xfb0fe2d0>
8111ee60:	04400404 	movi	r17,16
8111ee64:	d8801f17 	ldw	r2,124(sp)
8111ee68:	8c3edd0e 	bge	r17,r16,8111e9e0 <__reset+0xfb0fe9e0>
8111ee6c:	01604574 	movhi	r5,33045
8111ee70:	296b6184 	addi	r5,r5,-21114
8111ee74:	d9402b15 	stw	r5,172(sp)
8111ee78:	058001c4 	movi	r22,7
8111ee7c:	dd002c17 	ldw	r20,176(sp)
8111ee80:	00000306 	br	8111ee90 <___svfprintf_internal_r+0x1518>
8111ee84:	42000204 	addi	r8,r8,8
8111ee88:	843ffc04 	addi	r16,r16,-16
8111ee8c:	8c3ed70e 	bge	r17,r16,8111e9ec <__reset+0xfb0fe9ec>
8111ee90:	18c00404 	addi	r3,r3,16
8111ee94:	10800044 	addi	r2,r2,1
8111ee98:	45400015 	stw	r21,0(r8)
8111ee9c:	44400115 	stw	r17,4(r8)
8111eea0:	d8c02015 	stw	r3,128(sp)
8111eea4:	d8801f15 	stw	r2,124(sp)
8111eea8:	b0bff60e 	bge	r22,r2,8111ee84 <__reset+0xfb0fee84>
8111eeac:	d9801e04 	addi	r6,sp,120
8111eeb0:	a00b883a 	mov	r5,r20
8111eeb4:	9809883a 	mov	r4,r19
8111eeb8:	112a5980 	call	8112a598 <__ssprint_r>
8111eebc:	103b951e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111eec0:	d8c02017 	ldw	r3,128(sp)
8111eec4:	d8801f17 	ldw	r2,124(sp)
8111eec8:	da000404 	addi	r8,sp,16
8111eecc:	003fee06 	br	8111ee88 <__reset+0xfb0fee88>
8111eed0:	9088703a 	and	r4,r18,r2
8111eed4:	203e8d1e 	bne	r4,zero,8111e90c <__reset+0xfb0fe90c>
8111eed8:	dc401f17 	ldw	r17,124(sp)
8111eedc:	40800115 	stw	r2,4(r8)
8111eee0:	44000015 	stw	r16,0(r8)
8111eee4:	8c400044 	addi	r17,r17,1
8111eee8:	d8c02015 	stw	r3,128(sp)
8111eeec:	dc401f15 	stw	r17,124(sp)
8111eef0:	008001c4 	movi	r2,7
8111eef4:	147f7f16 	blt	r2,r17,8111ecf4 <__reset+0xfb0fecf4>
8111eef8:	45800204 	addi	r22,r8,8
8111eefc:	003eac06 	br	8111e9b0 <__reset+0xfb0fe9b0>
8111ef00:	d9402c17 	ldw	r5,176(sp)
8111ef04:	d9801e04 	addi	r6,sp,120
8111ef08:	9809883a 	mov	r4,r19
8111ef0c:	112a5980 	call	8112a598 <__ssprint_r>
8111ef10:	103b801e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ef14:	d8c02017 	ldw	r3,128(sp)
8111ef18:	dc401f17 	ldw	r17,124(sp)
8111ef1c:	da000404 	addi	r8,sp,16
8111ef20:	003e8406 	br	8111e934 <__reset+0xfb0fe934>
8111ef24:	d9402c17 	ldw	r5,176(sp)
8111ef28:	d9801e04 	addi	r6,sp,120
8111ef2c:	9809883a 	mov	r4,r19
8111ef30:	112a5980 	call	8112a598 <__ssprint_r>
8111ef34:	103b771e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ef38:	d8c02017 	ldw	r3,128(sp)
8111ef3c:	dc401f17 	ldw	r17,124(sp)
8111ef40:	dd800404 	addi	r22,sp,16
8111ef44:	003e8606 	br	8111e960 <__reset+0xfb0fe960>
8111ef48:	0029883a 	mov	r20,zero
8111ef4c:	a5000c04 	addi	r20,r20,48
8111ef50:	dc001dc4 	addi	r16,sp,119
8111ef54:	dd001dc5 	stb	r20,119(sp)
8111ef58:	003f3806 	br	8111ec3c <__reset+0xfb0fec3c>
8111ef5c:	d9402c17 	ldw	r5,176(sp)
8111ef60:	d9801e04 	addi	r6,sp,120
8111ef64:	9809883a 	mov	r4,r19
8111ef68:	112a5980 	call	8112a598 <__ssprint_r>
8111ef6c:	103b691e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111ef70:	d8c02017 	ldw	r3,128(sp)
8111ef74:	da000404 	addi	r8,sp,16
8111ef78:	003c9506 	br	8111e1d0 <__reset+0xfb0fe1d0>
8111ef7c:	d9003617 	ldw	r4,216(sp)
8111ef80:	d9403717 	ldw	r5,220(sp)
8111ef84:	da003e15 	stw	r8,248(sp)
8111ef88:	11283ac0 	call	811283ac <__fpclassifyd>
8111ef8c:	da003e17 	ldw	r8,248(sp)
8111ef90:	1000bd1e 	bne	r2,zero,8111f288 <___svfprintf_internal_r+0x1910>
8111ef94:	008011c4 	movi	r2,71
8111ef98:	14411e0e 	bge	r2,r17,8111f414 <___svfprintf_internal_r+0x1a9c>
8111ef9c:	04204574 	movhi	r16,33045
8111efa0:	842b5404 	addi	r16,r16,-21168
8111efa4:	00c000c4 	movi	r3,3
8111efa8:	00bfdfc4 	movi	r2,-129
8111efac:	d8c02a15 	stw	r3,168(sp)
8111efb0:	90a4703a 	and	r18,r18,r2
8111efb4:	df002783 	ldbu	fp,158(sp)
8111efb8:	d8c02e15 	stw	r3,184(sp)
8111efbc:	d8002915 	stw	zero,164(sp)
8111efc0:	d8003215 	stw	zero,200(sp)
8111efc4:	003c1c06 	br	8111e038 <__reset+0xfb0fe038>
8111efc8:	9080100c 	andi	r2,r18,64
8111efcc:	d8002785 	stb	zero,158(sp)
8111efd0:	10009426 	beq	r2,zero,8111f224 <___svfprintf_internal_r+0x18ac>
8111efd4:	d8c02d17 	ldw	r3,180(sp)
8111efd8:	d9002917 	ldw	r4,164(sp)
8111efdc:	002d883a 	mov	r22,zero
8111efe0:	18800104 	addi	r2,r3,4
8111efe4:	1d00000b 	ldhu	r20,0(r3)
8111efe8:	203ec10e 	bge	r4,zero,8111eaf0 <__reset+0xfb0feaf0>
8111efec:	a586b03a 	or	r3,r20,r22
8111eff0:	d8802d15 	stw	r2,180(sp)
8111eff4:	183ec21e 	bne	r3,zero,8111eb00 <__reset+0xfb0feb00>
8111eff8:	0039883a 	mov	fp,zero
8111effc:	0005883a 	mov	r2,zero
8111f000:	003db806 	br	8111e6e4 <__reset+0xfb0fe6e4>
8111f004:	d8802d17 	ldw	r2,180(sp)
8111f008:	d8c02d17 	ldw	r3,180(sp)
8111f00c:	d9002d17 	ldw	r4,180(sp)
8111f010:	10800017 	ldw	r2,0(r2)
8111f014:	18c00117 	ldw	r3,4(r3)
8111f018:	21000204 	addi	r4,r4,8
8111f01c:	d8803615 	stw	r2,216(sp)
8111f020:	d8c03715 	stw	r3,220(sp)
8111f024:	d9002d15 	stw	r4,180(sp)
8111f028:	003b8206 	br	8111de34 <__reset+0xfb0fde34>
8111f02c:	9080100c 	andi	r2,r18,64
8111f030:	10010726 	beq	r2,zero,8111f450 <___svfprintf_internal_r+0x1ad8>
8111f034:	d8c02d17 	ldw	r3,180(sp)
8111f038:	1d00000f 	ldh	r20,0(r3)
8111f03c:	18c00104 	addi	r3,r3,4
8111f040:	d8c02d15 	stw	r3,180(sp)
8111f044:	a02dd7fa 	srai	r22,r20,31
8111f048:	b005883a 	mov	r2,r22
8111f04c:	003ba206 	br	8111ded8 <__reset+0xfb0fded8>
8111f050:	9080100c 	andi	r2,r18,64
8111f054:	10010526 	beq	r2,zero,8111f46c <___svfprintf_internal_r+0x1af4>
8111f058:	d9002d17 	ldw	r4,180(sp)
8111f05c:	002d883a 	mov	r22,zero
8111f060:	2500000b 	ldhu	r20,0(r4)
8111f064:	21000104 	addi	r4,r4,4
8111f068:	d9002d15 	stw	r4,180(sp)
8111f06c:	003cfe06 	br	8111e468 <__reset+0xfb0fe468>
8111f070:	bc400007 	ldb	r17,0(r23)
8111f074:	003a9606 	br	8111dad0 <__reset+0xfb0fdad0>
8111f078:	9080040c 	andi	r2,r18,16
8111f07c:	10010126 	beq	r2,zero,8111f484 <___svfprintf_internal_r+0x1b0c>
8111f080:	d9402d17 	ldw	r5,180(sp)
8111f084:	d8c02f17 	ldw	r3,188(sp)
8111f088:	28800017 	ldw	r2,0(r5)
8111f08c:	29400104 	addi	r5,r5,4
8111f090:	d9402d15 	stw	r5,180(sp)
8111f094:	10c00015 	stw	r3,0(r2)
8111f098:	003a6406 	br	8111da2c <__reset+0xfb0fda2c>
8111f09c:	d9002917 	ldw	r4,164(sp)
8111f0a0:	d8002785 	stb	zero,158(sp)
8111f0a4:	203d8d16 	blt	r4,zero,8111e6dc <__reset+0xfb0fe6dc>
8111f0a8:	00bfdfc4 	movi	r2,-129
8111f0ac:	90a4703a 	and	r18,r18,r2
8111f0b0:	003b0506 	br	8111dcc8 <__reset+0xfb0fdcc8>
8111f0b4:	01604574 	movhi	r5,33045
8111f0b8:	296b6184 	addi	r5,r5,-21114
8111f0bc:	d9402b15 	stw	r5,172(sp)
8111f0c0:	d9402b17 	ldw	r5,172(sp)
8111f0c4:	1c47883a 	add	r3,r3,r17
8111f0c8:	10800044 	addi	r2,r2,1
8111f0cc:	41400015 	stw	r5,0(r8)
8111f0d0:	44400115 	stw	r17,4(r8)
8111f0d4:	d8c02015 	stw	r3,128(sp)
8111f0d8:	d8801f15 	stw	r2,124(sp)
8111f0dc:	010001c4 	movi	r4,7
8111f0e0:	20bf3016 	blt	r4,r2,8111eda4 <__reset+0xfb0feda4>
8111f0e4:	42000204 	addi	r8,r8,8
8111f0e8:	003f3506 	br	8111edc0 <__reset+0xfb0fedc0>
8111f0ec:	01204574 	movhi	r4,33045
8111f0f0:	212b6184 	addi	r4,r4,-21114
8111f0f4:	d9002b15 	stw	r4,172(sp)
8111f0f8:	003c5e06 	br	8111e274 <__reset+0xfb0fe274>
8111f0fc:	d9402c17 	ldw	r5,176(sp)
8111f100:	d9801e04 	addi	r6,sp,120
8111f104:	9809883a 	mov	r4,r19
8111f108:	112a5980 	call	8112a598 <__ssprint_r>
8111f10c:	103b011e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f110:	d8c02017 	ldw	r3,128(sp)
8111f114:	da000404 	addi	r8,sp,16
8111f118:	003d9306 	br	8111e768 <__reset+0xfb0fe768>
8111f11c:	d8801f17 	ldw	r2,124(sp)
8111f120:	01604574 	movhi	r5,33045
8111f124:	01000044 	movi	r4,1
8111f128:	18c00044 	addi	r3,r3,1
8111f12c:	10800044 	addi	r2,r2,1
8111f130:	296b6104 	addi	r5,r5,-21116
8111f134:	41000115 	stw	r4,4(r8)
8111f138:	41400015 	stw	r5,0(r8)
8111f13c:	d8c02015 	stw	r3,128(sp)
8111f140:	d8801f15 	stw	r2,124(sp)
8111f144:	010001c4 	movi	r4,7
8111f148:	2080b516 	blt	r4,r2,8111f420 <___svfprintf_internal_r+0x1aa8>
8111f14c:	42000204 	addi	r8,r8,8
8111f150:	8800041e 	bne	r17,zero,8111f164 <___svfprintf_internal_r+0x17ec>
8111f154:	d8803317 	ldw	r2,204(sp)
8111f158:	1000021e 	bne	r2,zero,8111f164 <___svfprintf_internal_r+0x17ec>
8111f15c:	9080004c 	andi	r2,r18,1
8111f160:	103c5b26 	beq	r2,zero,8111e2d0 <__reset+0xfb0fe2d0>
8111f164:	d9003817 	ldw	r4,224(sp)
8111f168:	d8801f17 	ldw	r2,124(sp)
8111f16c:	d9403417 	ldw	r5,208(sp)
8111f170:	20c7883a 	add	r3,r4,r3
8111f174:	10800044 	addi	r2,r2,1
8111f178:	41000115 	stw	r4,4(r8)
8111f17c:	41400015 	stw	r5,0(r8)
8111f180:	d8c02015 	stw	r3,128(sp)
8111f184:	d8801f15 	stw	r2,124(sp)
8111f188:	010001c4 	movi	r4,7
8111f18c:	20818016 	blt	r4,r2,8111f790 <___svfprintf_internal_r+0x1e18>
8111f190:	42000204 	addi	r8,r8,8
8111f194:	0463c83a 	sub	r17,zero,r17
8111f198:	0440cb0e 	bge	zero,r17,8111f4c8 <___svfprintf_internal_r+0x1b50>
8111f19c:	05800404 	movi	r22,16
8111f1a0:	b440e80e 	bge	r22,r17,8111f544 <___svfprintf_internal_r+0x1bcc>
8111f1a4:	01604574 	movhi	r5,33045
8111f1a8:	296b6184 	addi	r5,r5,-21114
8111f1ac:	d9402b15 	stw	r5,172(sp)
8111f1b0:	070001c4 	movi	fp,7
8111f1b4:	dd002c17 	ldw	r20,176(sp)
8111f1b8:	00000306 	br	8111f1c8 <___svfprintf_internal_r+0x1850>
8111f1bc:	42000204 	addi	r8,r8,8
8111f1c0:	8c7ffc04 	addi	r17,r17,-16
8111f1c4:	b440e20e 	bge	r22,r17,8111f550 <___svfprintf_internal_r+0x1bd8>
8111f1c8:	18c00404 	addi	r3,r3,16
8111f1cc:	10800044 	addi	r2,r2,1
8111f1d0:	45400015 	stw	r21,0(r8)
8111f1d4:	45800115 	stw	r22,4(r8)
8111f1d8:	d8c02015 	stw	r3,128(sp)
8111f1dc:	d8801f15 	stw	r2,124(sp)
8111f1e0:	e0bff60e 	bge	fp,r2,8111f1bc <__reset+0xfb0ff1bc>
8111f1e4:	d9801e04 	addi	r6,sp,120
8111f1e8:	a00b883a 	mov	r5,r20
8111f1ec:	9809883a 	mov	r4,r19
8111f1f0:	112a5980 	call	8112a598 <__ssprint_r>
8111f1f4:	103ac71e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f1f8:	d8c02017 	ldw	r3,128(sp)
8111f1fc:	d8801f17 	ldw	r2,124(sp)
8111f200:	da000404 	addi	r8,sp,16
8111f204:	003fee06 	br	8111f1c0 <__reset+0xfb0ff1c0>
8111f208:	d8c02d17 	ldw	r3,180(sp)
8111f20c:	d9002917 	ldw	r4,164(sp)
8111f210:	002d883a 	mov	r22,zero
8111f214:	18800104 	addi	r2,r3,4
8111f218:	1d000017 	ldw	r20,0(r3)
8111f21c:	203e7d0e 	bge	r4,zero,8111ec14 <__reset+0xfb0fec14>
8111f220:	003eda06 	br	8111ed8c <__reset+0xfb0fed8c>
8111f224:	d9402d17 	ldw	r5,180(sp)
8111f228:	d8c02917 	ldw	r3,164(sp)
8111f22c:	002d883a 	mov	r22,zero
8111f230:	28800104 	addi	r2,r5,4
8111f234:	2d000017 	ldw	r20,0(r5)
8111f238:	183e2d0e 	bge	r3,zero,8111eaf0 <__reset+0xfb0feaf0>
8111f23c:	003f6b06 	br	8111efec <__reset+0xfb0fefec>
8111f240:	d8c02d15 	stw	r3,180(sp)
8111f244:	0039883a 	mov	fp,zero
8111f248:	003ed206 	br	8111ed94 <__reset+0xfb0fed94>
8111f24c:	bc400043 	ldbu	r17,1(r23)
8111f250:	94800814 	ori	r18,r18,32
8111f254:	bdc00044 	addi	r23,r23,1
8111f258:	8c403fcc 	andi	r17,r17,255
8111f25c:	8c40201c 	xori	r17,r17,128
8111f260:	8c7fe004 	addi	r17,r17,-128
8111f264:	003a1a06 	br	8111dad0 <__reset+0xfb0fdad0>
8111f268:	d9402c17 	ldw	r5,176(sp)
8111f26c:	d9801e04 	addi	r6,sp,120
8111f270:	9809883a 	mov	r4,r19
8111f274:	112a5980 	call	8112a598 <__ssprint_r>
8111f278:	103aa61e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f27c:	d8c02017 	ldw	r3,128(sp)
8111f280:	da000404 	addi	r8,sp,16
8111f284:	003d4a06 	br	8111e7b0 <__reset+0xfb0fe7b0>
8111f288:	d9002917 	ldw	r4,164(sp)
8111f28c:	05bff7c4 	movi	r22,-33
8111f290:	00bfffc4 	movi	r2,-1
8111f294:	8dac703a 	and	r22,r17,r22
8111f298:	20806a26 	beq	r4,r2,8111f444 <___svfprintf_internal_r+0x1acc>
8111f29c:	008011c4 	movi	r2,71
8111f2a0:	b0813726 	beq	r22,r2,8111f780 <___svfprintf_internal_r+0x1e08>
8111f2a4:	d9003717 	ldw	r4,220(sp)
8111f2a8:	90c04014 	ori	r3,r18,256
8111f2ac:	d8c02b15 	stw	r3,172(sp)
8111f2b0:	20015d16 	blt	r4,zero,8111f828 <___svfprintf_internal_r+0x1eb0>
8111f2b4:	dd003717 	ldw	r20,220(sp)
8111f2b8:	d8002a05 	stb	zero,168(sp)
8111f2bc:	00801984 	movi	r2,102
8111f2c0:	88814026 	beq	r17,r2,8111f7c4 <___svfprintf_internal_r+0x1e4c>
8111f2c4:	00801184 	movi	r2,70
8111f2c8:	88817126 	beq	r17,r2,8111f890 <___svfprintf_internal_r+0x1f18>
8111f2cc:	00801144 	movi	r2,69
8111f2d0:	b0816226 	beq	r22,r2,8111f85c <___svfprintf_internal_r+0x1ee4>
8111f2d4:	d8c02917 	ldw	r3,164(sp)
8111f2d8:	d8802104 	addi	r2,sp,132
8111f2dc:	d8800315 	stw	r2,12(sp)
8111f2e0:	d9403617 	ldw	r5,216(sp)
8111f2e4:	d8802504 	addi	r2,sp,148
8111f2e8:	d8800215 	stw	r2,8(sp)
8111f2ec:	d8802604 	addi	r2,sp,152
8111f2f0:	d8c00015 	stw	r3,0(sp)
8111f2f4:	d8800115 	stw	r2,4(sp)
8111f2f8:	01c00084 	movi	r7,2
8111f2fc:	a00d883a 	mov	r6,r20
8111f300:	9809883a 	mov	r4,r19
8111f304:	d8c03d15 	stw	r3,244(sp)
8111f308:	da003e15 	stw	r8,248(sp)
8111f30c:	1123c640 	call	81123c64 <_dtoa_r>
8111f310:	1021883a 	mov	r16,r2
8111f314:	008019c4 	movi	r2,103
8111f318:	d8c03d17 	ldw	r3,244(sp)
8111f31c:	da003e17 	ldw	r8,248(sp)
8111f320:	8880e726 	beq	r17,r2,8111f6c0 <___svfprintf_internal_r+0x1d48>
8111f324:	008011c4 	movi	r2,71
8111f328:	8880d426 	beq	r17,r2,8111f67c <___svfprintf_internal_r+0x1d04>
8111f32c:	80f9883a 	add	fp,r16,r3
8111f330:	d9003617 	ldw	r4,216(sp)
8111f334:	000d883a 	mov	r6,zero
8111f338:	000f883a 	mov	r7,zero
8111f33c:	a00b883a 	mov	r5,r20
8111f340:	da003e15 	stw	r8,248(sp)
8111f344:	11305900 	call	81130590 <__eqdf2>
8111f348:	da003e17 	ldw	r8,248(sp)
8111f34c:	1000e426 	beq	r2,zero,8111f6e0 <___svfprintf_internal_r+0x1d68>
8111f350:	d8802117 	ldw	r2,132(sp)
8111f354:	1700062e 	bgeu	r2,fp,8111f370 <___svfprintf_internal_r+0x19f8>
8111f358:	01000c04 	movi	r4,48
8111f35c:	10c00044 	addi	r3,r2,1
8111f360:	d8c02115 	stw	r3,132(sp)
8111f364:	11000005 	stb	r4,0(r2)
8111f368:	d8802117 	ldw	r2,132(sp)
8111f36c:	173ffb36 	bltu	r2,fp,8111f35c <__reset+0xfb0ff35c>
8111f370:	1405c83a 	sub	r2,r2,r16
8111f374:	d8803315 	stw	r2,204(sp)
8111f378:	008011c4 	movi	r2,71
8111f37c:	b080c526 	beq	r22,r2,8111f694 <___svfprintf_internal_r+0x1d1c>
8111f380:	00801944 	movi	r2,101
8111f384:	1441d90e 	bge	r2,r17,8111faec <___svfprintf_internal_r+0x2174>
8111f388:	d8c02617 	ldw	r3,152(sp)
8111f38c:	00801984 	movi	r2,102
8111f390:	d8c03215 	stw	r3,200(sp)
8111f394:	88813426 	beq	r17,r2,8111f868 <___svfprintf_internal_r+0x1ef0>
8111f398:	d8c03217 	ldw	r3,200(sp)
8111f39c:	d9003317 	ldw	r4,204(sp)
8111f3a0:	19012516 	blt	r3,r4,8111f838 <___svfprintf_internal_r+0x1ec0>
8111f3a4:	9480004c 	andi	r18,r18,1
8111f3a8:	9001841e 	bne	r18,zero,8111f9bc <___svfprintf_internal_r+0x2044>
8111f3ac:	1805883a 	mov	r2,r3
8111f3b0:	1801cc16 	blt	r3,zero,8111fae4 <___svfprintf_internal_r+0x216c>
8111f3b4:	d8c03217 	ldw	r3,200(sp)
8111f3b8:	044019c4 	movi	r17,103
8111f3bc:	d8c02e15 	stw	r3,184(sp)
8111f3c0:	df002a07 	ldb	fp,168(sp)
8111f3c4:	e000a61e 	bne	fp,zero,8111f660 <___svfprintf_internal_r+0x1ce8>
8111f3c8:	df002783 	ldbu	fp,158(sp)
8111f3cc:	d8802a15 	stw	r2,168(sp)
8111f3d0:	dc802b17 	ldw	r18,172(sp)
8111f3d4:	d8002915 	stw	zero,164(sp)
8111f3d8:	003b1706 	br	8111e038 <__reset+0xfb0fe038>
8111f3dc:	04204574 	movhi	r16,33045
8111f3e0:	842b5104 	addi	r16,r16,-21180
8111f3e4:	003aa606 	br	8111de80 <__reset+0xfb0fde80>
8111f3e8:	d9003917 	ldw	r4,228(sp)
8111f3ec:	04001004 	movi	r16,64
8111f3f0:	800b883a 	mov	r5,r16
8111f3f4:	111c3380 	call	8111c338 <_malloc_r>
8111f3f8:	d9002c17 	ldw	r4,176(sp)
8111f3fc:	20800015 	stw	r2,0(r4)
8111f400:	20800415 	stw	r2,16(r4)
8111f404:	1001cb26 	beq	r2,zero,8111fb34 <___svfprintf_internal_r+0x21bc>
8111f408:	d8802c17 	ldw	r2,176(sp)
8111f40c:	14000515 	stw	r16,20(r2)
8111f410:	00397606 	br	8111d9ec <__reset+0xfb0fd9ec>
8111f414:	04204574 	movhi	r16,33045
8111f418:	842b5304 	addi	r16,r16,-21172
8111f41c:	003ee106 	br	8111efa4 <__reset+0xfb0fefa4>
8111f420:	d9402c17 	ldw	r5,176(sp)
8111f424:	d9801e04 	addi	r6,sp,120
8111f428:	9809883a 	mov	r4,r19
8111f42c:	112a5980 	call	8112a598 <__ssprint_r>
8111f430:	103a381e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f434:	dc402617 	ldw	r17,152(sp)
8111f438:	d8c02017 	ldw	r3,128(sp)
8111f43c:	da000404 	addi	r8,sp,16
8111f440:	003f4306 	br	8111f150 <__reset+0xfb0ff150>
8111f444:	01400184 	movi	r5,6
8111f448:	d9402915 	stw	r5,164(sp)
8111f44c:	003f9506 	br	8111f2a4 <__reset+0xfb0ff2a4>
8111f450:	d9002d17 	ldw	r4,180(sp)
8111f454:	25000017 	ldw	r20,0(r4)
8111f458:	21000104 	addi	r4,r4,4
8111f45c:	d9002d15 	stw	r4,180(sp)
8111f460:	a02dd7fa 	srai	r22,r20,31
8111f464:	b005883a 	mov	r2,r22
8111f468:	003a9b06 	br	8111ded8 <__reset+0xfb0fded8>
8111f46c:	d9402d17 	ldw	r5,180(sp)
8111f470:	002d883a 	mov	r22,zero
8111f474:	2d000017 	ldw	r20,0(r5)
8111f478:	29400104 	addi	r5,r5,4
8111f47c:	d9402d15 	stw	r5,180(sp)
8111f480:	003bf906 	br	8111e468 <__reset+0xfb0fe468>
8111f484:	9480100c 	andi	r18,r18,64
8111f488:	90006e26 	beq	r18,zero,8111f644 <___svfprintf_internal_r+0x1ccc>
8111f48c:	d9002d17 	ldw	r4,180(sp)
8111f490:	d9402f17 	ldw	r5,188(sp)
8111f494:	20800017 	ldw	r2,0(r4)
8111f498:	21000104 	addi	r4,r4,4
8111f49c:	d9002d15 	stw	r4,180(sp)
8111f4a0:	1140000d 	sth	r5,0(r2)
8111f4a4:	00396106 	br	8111da2c <__reset+0xfb0fda2c>
8111f4a8:	d9402c17 	ldw	r5,176(sp)
8111f4ac:	d9801e04 	addi	r6,sp,120
8111f4b0:	9809883a 	mov	r4,r19
8111f4b4:	112a5980 	call	8112a598 <__ssprint_r>
8111f4b8:	103a161e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f4bc:	d8c02017 	ldw	r3,128(sp)
8111f4c0:	d8801f17 	ldw	r2,124(sp)
8111f4c4:	da000404 	addi	r8,sp,16
8111f4c8:	d9403317 	ldw	r5,204(sp)
8111f4cc:	10800044 	addi	r2,r2,1
8111f4d0:	44000015 	stw	r16,0(r8)
8111f4d4:	28c7883a 	add	r3,r5,r3
8111f4d8:	003b7706 	br	8111e2b8 <__reset+0xfb0fe2b8>
8111f4dc:	8009883a 	mov	r4,r16
8111f4e0:	da003e15 	stw	r8,248(sp)
8111f4e4:	111d6400 	call	8111d640 <strlen>
8111f4e8:	d8802e15 	stw	r2,184(sp)
8111f4ec:	da003e17 	ldw	r8,248(sp)
8111f4f0:	103c280e 	bge	r2,zero,8111e594 <__reset+0xfb0fe594>
8111f4f4:	0005883a 	mov	r2,zero
8111f4f8:	003c2606 	br	8111e594 <__reset+0xfb0fe594>
8111f4fc:	00bfffc4 	movi	r2,-1
8111f500:	003a0906 	br	8111dd28 <__reset+0xfb0fdd28>
8111f504:	01204574 	movhi	r4,33045
8111f508:	212b6584 	addi	r4,r4,-21098
8111f50c:	d9003515 	stw	r4,212(sp)
8111f510:	003b0606 	br	8111e12c <__reset+0xfb0fe12c>
8111f514:	013fffc4 	movi	r4,-1
8111f518:	003a2706 	br	8111ddb8 <__reset+0xfb0fddb8>
8111f51c:	d9402c17 	ldw	r5,176(sp)
8111f520:	d9801e04 	addi	r6,sp,120
8111f524:	9809883a 	mov	r4,r19
8111f528:	112a5980 	call	8112a598 <__ssprint_r>
8111f52c:	1039f91e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f530:	d8c02017 	ldw	r3,128(sp)
8111f534:	da000404 	addi	r8,sp,16
8111f538:	003d8406 	br	8111eb4c <__reset+0xfb0feb4c>
8111f53c:	0023883a 	mov	r17,zero
8111f540:	003d8306 	br	8111eb50 <__reset+0xfb0feb50>
8111f544:	01204574 	movhi	r4,33045
8111f548:	212b6184 	addi	r4,r4,-21114
8111f54c:	d9002b15 	stw	r4,172(sp)
8111f550:	d9002b17 	ldw	r4,172(sp)
8111f554:	1c47883a 	add	r3,r3,r17
8111f558:	10800044 	addi	r2,r2,1
8111f55c:	41000015 	stw	r4,0(r8)
8111f560:	44400115 	stw	r17,4(r8)
8111f564:	d8c02015 	stw	r3,128(sp)
8111f568:	d8801f15 	stw	r2,124(sp)
8111f56c:	010001c4 	movi	r4,7
8111f570:	20bfcd16 	blt	r4,r2,8111f4a8 <__reset+0xfb0ff4a8>
8111f574:	42000204 	addi	r8,r8,8
8111f578:	003fd306 	br	8111f4c8 <__reset+0xfb0ff4c8>
8111f57c:	d9402c17 	ldw	r5,176(sp)
8111f580:	d9801e04 	addi	r6,sp,120
8111f584:	9809883a 	mov	r4,r19
8111f588:	112a5980 	call	8112a598 <__ssprint_r>
8111f58c:	1039e11e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f590:	d8802617 	ldw	r2,152(sp)
8111f594:	d8c02017 	ldw	r3,128(sp)
8111f598:	da000404 	addi	r8,sp,16
8111f59c:	003e1c06 	br	8111ee10 <__reset+0xfb0fee10>
8111f5a0:	d8802917 	ldw	r2,164(sp)
8111f5a4:	00c00184 	movi	r3,6
8111f5a8:	1880012e 	bgeu	r3,r2,8111f5b0 <___svfprintf_internal_r+0x1c38>
8111f5ac:	1805883a 	mov	r2,r3
8111f5b0:	d8802e15 	stw	r2,184(sp)
8111f5b4:	1000f316 	blt	r2,zero,8111f984 <___svfprintf_internal_r+0x200c>
8111f5b8:	04204574 	movhi	r16,33045
8111f5bc:	d8802a15 	stw	r2,168(sp)
8111f5c0:	dd002d15 	stw	r20,180(sp)
8111f5c4:	d8002915 	stw	zero,164(sp)
8111f5c8:	d8003215 	stw	zero,200(sp)
8111f5cc:	842b5f04 	addi	r16,r16,-21124
8111f5d0:	0039883a 	mov	fp,zero
8111f5d4:	003a9f06 	br	8111e054 <__reset+0xfb0fe054>
8111f5d8:	01204574 	movhi	r4,33045
8111f5dc:	212b6584 	addi	r4,r4,-21098
8111f5e0:	d9003515 	stw	r4,212(sp)
8111f5e4:	003b5f06 	br	8111e364 <__reset+0xfb0fe364>
8111f5e8:	d9402c17 	ldw	r5,176(sp)
8111f5ec:	d9801e04 	addi	r6,sp,120
8111f5f0:	9809883a 	mov	r4,r19
8111f5f4:	112a5980 	call	8112a598 <__ssprint_r>
8111f5f8:	1039c61e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f5fc:	d8802617 	ldw	r2,152(sp)
8111f600:	d9403317 	ldw	r5,204(sp)
8111f604:	d8c02017 	ldw	r3,128(sp)
8111f608:	da000404 	addi	r8,sp,16
8111f60c:	2885c83a 	sub	r2,r5,r2
8111f610:	003e1006 	br	8111ee54 <__reset+0xfb0fee54>
8111f614:	00800044 	movi	r2,1
8111f618:	10803fcc 	andi	r2,r2,255
8111f61c:	00c00044 	movi	r3,1
8111f620:	10fa3526 	beq	r2,r3,8111def8 <__reset+0xfb0fdef8>
8111f624:	00c00084 	movi	r3,2
8111f628:	10fb9e26 	beq	r2,r3,8111e4a4 <__reset+0xfb0fe4a4>
8111f62c:	003a6406 	br	8111dfc0 <__reset+0xfb0fdfc0>
8111f630:	0021883a 	mov	r16,zero
8111f634:	003e0806 	br	8111ee58 <__reset+0xfb0fee58>
8111f638:	07000b44 	movi	fp,45
8111f63c:	df002785 	stb	fp,158(sp)
8111f640:	003a0b06 	br	8111de70 <__reset+0xfb0fde70>
8111f644:	d8c02d17 	ldw	r3,180(sp)
8111f648:	d9002f17 	ldw	r4,188(sp)
8111f64c:	18800017 	ldw	r2,0(r3)
8111f650:	18c00104 	addi	r3,r3,4
8111f654:	d8c02d15 	stw	r3,180(sp)
8111f658:	11000015 	stw	r4,0(r2)
8111f65c:	0038f306 	br	8111da2c <__reset+0xfb0fda2c>
8111f660:	00c00b44 	movi	r3,45
8111f664:	d8c02785 	stb	r3,158(sp)
8111f668:	d8802a15 	stw	r2,168(sp)
8111f66c:	dc802b17 	ldw	r18,172(sp)
8111f670:	d8002915 	stw	zero,164(sp)
8111f674:	07000b44 	movi	fp,45
8111f678:	003a7306 	br	8111e048 <__reset+0xfb0fe048>
8111f67c:	9080004c 	andi	r2,r18,1
8111f680:	1000941e 	bne	r2,zero,8111f8d4 <___svfprintf_internal_r+0x1f5c>
8111f684:	d8802117 	ldw	r2,132(sp)
8111f688:	1405c83a 	sub	r2,r2,r16
8111f68c:	d8803315 	stw	r2,204(sp)
8111f690:	b441161e 	bne	r22,r17,8111faec <___svfprintf_internal_r+0x2174>
8111f694:	dd802617 	ldw	r22,152(sp)
8111f698:	00bfff44 	movi	r2,-3
8111f69c:	b0801a16 	blt	r22,r2,8111f708 <___svfprintf_internal_r+0x1d90>
8111f6a0:	d9402917 	ldw	r5,164(sp)
8111f6a4:	2d801816 	blt	r5,r22,8111f708 <___svfprintf_internal_r+0x1d90>
8111f6a8:	dd803215 	stw	r22,200(sp)
8111f6ac:	003f3a06 	br	8111f398 <__reset+0xfb0ff398>
8111f6b0:	1025883a 	mov	r18,r2
8111f6b4:	0039883a 	mov	fp,zero
8111f6b8:	00800084 	movi	r2,2
8111f6bc:	003fd606 	br	8111f618 <__reset+0xfb0ff618>
8111f6c0:	9080004c 	andi	r2,r18,1
8111f6c4:	103f191e 	bne	r2,zero,8111f32c <__reset+0xfb0ff32c>
8111f6c8:	d8802117 	ldw	r2,132(sp)
8111f6cc:	003f2806 	br	8111f370 <__reset+0xfb0ff370>
8111f6d0:	01204574 	movhi	r4,33045
8111f6d4:	212b6184 	addi	r4,r4,-21114
8111f6d8:	d9002b15 	stw	r4,172(sp)
8111f6dc:	003c7c06 	br	8111e8d0 <__reset+0xfb0fe8d0>
8111f6e0:	e005883a 	mov	r2,fp
8111f6e4:	003f2206 	br	8111f370 <__reset+0xfb0ff370>
8111f6e8:	d9402917 	ldw	r5,164(sp)
8111f6ec:	df002783 	ldbu	fp,158(sp)
8111f6f0:	dd002d15 	stw	r20,180(sp)
8111f6f4:	d9402a15 	stw	r5,168(sp)
8111f6f8:	d9402e15 	stw	r5,184(sp)
8111f6fc:	d8002915 	stw	zero,164(sp)
8111f700:	d8003215 	stw	zero,200(sp)
8111f704:	003a4c06 	br	8111e038 <__reset+0xfb0fe038>
8111f708:	8c7fff84 	addi	r17,r17,-2
8111f70c:	b5bfffc4 	addi	r22,r22,-1
8111f710:	dd802615 	stw	r22,152(sp)
8111f714:	dc4022c5 	stb	r17,139(sp)
8111f718:	b000c316 	blt	r22,zero,8111fa28 <___svfprintf_internal_r+0x20b0>
8111f71c:	00800ac4 	movi	r2,43
8111f720:	d8802305 	stb	r2,140(sp)
8111f724:	00800244 	movi	r2,9
8111f728:	15806e16 	blt	r2,r22,8111f8e4 <___svfprintf_internal_r+0x1f6c>
8111f72c:	00800c04 	movi	r2,48
8111f730:	b5800c04 	addi	r22,r22,48
8111f734:	d8802345 	stb	r2,141(sp)
8111f738:	dd802385 	stb	r22,142(sp)
8111f73c:	d88023c4 	addi	r2,sp,143
8111f740:	df0022c4 	addi	fp,sp,139
8111f744:	d8c03317 	ldw	r3,204(sp)
8111f748:	1739c83a 	sub	fp,r2,fp
8111f74c:	d9003317 	ldw	r4,204(sp)
8111f750:	e0c7883a 	add	r3,fp,r3
8111f754:	df003b15 	stw	fp,236(sp)
8111f758:	d8c02e15 	stw	r3,184(sp)
8111f75c:	00800044 	movi	r2,1
8111f760:	1100b70e 	bge	r2,r4,8111fa40 <___svfprintf_internal_r+0x20c8>
8111f764:	d8c02e17 	ldw	r3,184(sp)
8111f768:	18c00044 	addi	r3,r3,1
8111f76c:	d8c02e15 	stw	r3,184(sp)
8111f770:	1805883a 	mov	r2,r3
8111f774:	1800b016 	blt	r3,zero,8111fa38 <___svfprintf_internal_r+0x20c0>
8111f778:	d8003215 	stw	zero,200(sp)
8111f77c:	003f1006 	br	8111f3c0 <__reset+0xfb0ff3c0>
8111f780:	d8802917 	ldw	r2,164(sp)
8111f784:	103ec71e 	bne	r2,zero,8111f2a4 <__reset+0xfb0ff2a4>
8111f788:	dc002915 	stw	r16,164(sp)
8111f78c:	003ec506 	br	8111f2a4 <__reset+0xfb0ff2a4>
8111f790:	d9402c17 	ldw	r5,176(sp)
8111f794:	d9801e04 	addi	r6,sp,120
8111f798:	9809883a 	mov	r4,r19
8111f79c:	112a5980 	call	8112a598 <__ssprint_r>
8111f7a0:	10395c1e 	bne	r2,zero,8111dd14 <__reset+0xfb0fdd14>
8111f7a4:	dc402617 	ldw	r17,152(sp)
8111f7a8:	d8c02017 	ldw	r3,128(sp)
8111f7ac:	d8801f17 	ldw	r2,124(sp)
8111f7b0:	da000404 	addi	r8,sp,16
8111f7b4:	003e7706 	br	8111f194 <__reset+0xfb0ff194>
8111f7b8:	582f883a 	mov	r23,r11
8111f7bc:	d8002915 	stw	zero,164(sp)
8111f7c0:	0038c406 	br	8111dad4 <__reset+0xfb0fdad4>
8111f7c4:	d8c02917 	ldw	r3,164(sp)
8111f7c8:	d8802104 	addi	r2,sp,132
8111f7cc:	d8800315 	stw	r2,12(sp)
8111f7d0:	d9403617 	ldw	r5,216(sp)
8111f7d4:	d8802504 	addi	r2,sp,148
8111f7d8:	d8800215 	stw	r2,8(sp)
8111f7dc:	d8802604 	addi	r2,sp,152
8111f7e0:	d8c00015 	stw	r3,0(sp)
8111f7e4:	9809883a 	mov	r4,r19
8111f7e8:	d8800115 	stw	r2,4(sp)
8111f7ec:	01c000c4 	movi	r7,3
8111f7f0:	a00d883a 	mov	r6,r20
8111f7f4:	da003e15 	stw	r8,248(sp)
8111f7f8:	1123c640 	call	81123c64 <_dtoa_r>
8111f7fc:	d9002917 	ldw	r4,164(sp)
8111f800:	da003e17 	ldw	r8,248(sp)
8111f804:	1021883a 	mov	r16,r2
8111f808:	1139883a 	add	fp,r2,r4
8111f80c:	2007883a 	mov	r3,r4
8111f810:	81000007 	ldb	r4,0(r16)
8111f814:	00800c04 	movi	r2,48
8111f818:	20806f26 	beq	r4,r2,8111f9d8 <___svfprintf_internal_r+0x2060>
8111f81c:	d8c02617 	ldw	r3,152(sp)
8111f820:	e0f9883a 	add	fp,fp,r3
8111f824:	003ec206 	br	8111f330 <__reset+0xfb0ff330>
8111f828:	00c00b44 	movi	r3,45
8111f82c:	2520003c 	xorhi	r20,r4,32768
8111f830:	d8c02a05 	stb	r3,168(sp)
8111f834:	003ea106 	br	8111f2bc <__reset+0xfb0ff2bc>
8111f838:	d8c03217 	ldw	r3,200(sp)
8111f83c:	00c0890e 	bge	zero,r3,8111fa64 <___svfprintf_internal_r+0x20ec>
8111f840:	00800044 	movi	r2,1
8111f844:	d9003317 	ldw	r4,204(sp)
8111f848:	1105883a 	add	r2,r2,r4
8111f84c:	d8802e15 	stw	r2,184(sp)
8111f850:	10005f16 	blt	r2,zero,8111f9d0 <___svfprintf_internal_r+0x2058>
8111f854:	044019c4 	movi	r17,103
8111f858:	003ed906 	br	8111f3c0 <__reset+0xfb0ff3c0>
8111f85c:	d9002917 	ldw	r4,164(sp)
8111f860:	20c00044 	addi	r3,r4,1
8111f864:	003e9c06 	br	8111f2d8 <__reset+0xfb0ff2d8>
8111f868:	d9002917 	ldw	r4,164(sp)
8111f86c:	00c0680e 	bge	zero,r3,8111fa10 <___svfprintf_internal_r+0x2098>
8111f870:	2000461e 	bne	r4,zero,8111f98c <___svfprintf_internal_r+0x2014>
8111f874:	9480004c 	andi	r18,r18,1
8111f878:	9000441e 	bne	r18,zero,8111f98c <___svfprintf_internal_r+0x2014>
8111f87c:	1805883a 	mov	r2,r3
8111f880:	1800a016 	blt	r3,zero,8111fb04 <___svfprintf_internal_r+0x218c>
8111f884:	d8c03217 	ldw	r3,200(sp)
8111f888:	d8c02e15 	stw	r3,184(sp)
8111f88c:	003ecc06 	br	8111f3c0 <__reset+0xfb0ff3c0>
8111f890:	d9402917 	ldw	r5,164(sp)
8111f894:	d8802104 	addi	r2,sp,132
8111f898:	d8800315 	stw	r2,12(sp)
8111f89c:	d9400015 	stw	r5,0(sp)
8111f8a0:	d8802504 	addi	r2,sp,148
8111f8a4:	d9403617 	ldw	r5,216(sp)
8111f8a8:	d8800215 	stw	r2,8(sp)
8111f8ac:	d8802604 	addi	r2,sp,152
8111f8b0:	d8800115 	stw	r2,4(sp)
8111f8b4:	01c000c4 	movi	r7,3
8111f8b8:	a00d883a 	mov	r6,r20
8111f8bc:	9809883a 	mov	r4,r19
8111f8c0:	da003e15 	stw	r8,248(sp)
8111f8c4:	1123c640 	call	81123c64 <_dtoa_r>
8111f8c8:	d8c02917 	ldw	r3,164(sp)
8111f8cc:	da003e17 	ldw	r8,248(sp)
8111f8d0:	1021883a 	mov	r16,r2
8111f8d4:	00801184 	movi	r2,70
8111f8d8:	80f9883a 	add	fp,r16,r3
8111f8dc:	88bfcc26 	beq	r17,r2,8111f810 <__reset+0xfb0ff810>
8111f8e0:	003e9306 	br	8111f330 <__reset+0xfb0ff330>
8111f8e4:	df0022c4 	addi	fp,sp,139
8111f8e8:	dc002915 	stw	r16,164(sp)
8111f8ec:	9829883a 	mov	r20,r19
8111f8f0:	e021883a 	mov	r16,fp
8111f8f4:	4027883a 	mov	r19,r8
8111f8f8:	b009883a 	mov	r4,r22
8111f8fc:	01400284 	movi	r5,10
8111f900:	112f0c00 	call	8112f0c0 <__modsi3>
8111f904:	10800c04 	addi	r2,r2,48
8111f908:	843fffc4 	addi	r16,r16,-1
8111f90c:	b009883a 	mov	r4,r22
8111f910:	01400284 	movi	r5,10
8111f914:	80800005 	stb	r2,0(r16)
8111f918:	112f03c0 	call	8112f03c <__divsi3>
8111f91c:	102d883a 	mov	r22,r2
8111f920:	00800244 	movi	r2,9
8111f924:	15bff416 	blt	r2,r22,8111f8f8 <__reset+0xfb0ff8f8>
8111f928:	9811883a 	mov	r8,r19
8111f92c:	b0800c04 	addi	r2,r22,48
8111f930:	a027883a 	mov	r19,r20
8111f934:	8029883a 	mov	r20,r16
8111f938:	a17fffc4 	addi	r5,r20,-1
8111f93c:	a0bfffc5 	stb	r2,-1(r20)
8111f940:	dc002917 	ldw	r16,164(sp)
8111f944:	2f00752e 	bgeu	r5,fp,8111fb1c <___svfprintf_internal_r+0x21a4>
8111f948:	d9c02384 	addi	r7,sp,142
8111f94c:	3d0fc83a 	sub	r7,r7,r20
8111f950:	d9002344 	addi	r4,sp,141
8111f954:	e1cf883a 	add	r7,fp,r7
8111f958:	00000106 	br	8111f960 <___svfprintf_internal_r+0x1fe8>
8111f95c:	28800003 	ldbu	r2,0(r5)
8111f960:	20800005 	stb	r2,0(r4)
8111f964:	21000044 	addi	r4,r4,1
8111f968:	29400044 	addi	r5,r5,1
8111f96c:	21fffb1e 	bne	r4,r7,8111f95c <__reset+0xfb0ff95c>
8111f970:	d8802304 	addi	r2,sp,140
8111f974:	1505c83a 	sub	r2,r2,r20
8111f978:	d8c02344 	addi	r3,sp,141
8111f97c:	1885883a 	add	r2,r3,r2
8111f980:	003f7006 	br	8111f744 <__reset+0xfb0ff744>
8111f984:	0005883a 	mov	r2,zero
8111f988:	003f0b06 	br	8111f5b8 <__reset+0xfb0ff5b8>
8111f98c:	d9002917 	ldw	r4,164(sp)
8111f990:	d8c03217 	ldw	r3,200(sp)
8111f994:	20800044 	addi	r2,r4,1
8111f998:	1885883a 	add	r2,r3,r2
8111f99c:	d8802e15 	stw	r2,184(sp)
8111f9a0:	103e870e 	bge	r2,zero,8111f3c0 <__reset+0xfb0ff3c0>
8111f9a4:	0005883a 	mov	r2,zero
8111f9a8:	003e8506 	br	8111f3c0 <__reset+0xfb0ff3c0>
8111f9ac:	01204574 	movhi	r4,33045
8111f9b0:	212b6184 	addi	r4,r4,-21114
8111f9b4:	d9002b15 	stw	r4,172(sp)
8111f9b8:	003cc506 	br	8111ecd0 <__reset+0xfb0fecd0>
8111f9bc:	d8c03217 	ldw	r3,200(sp)
8111f9c0:	18c00044 	addi	r3,r3,1
8111f9c4:	d8c02e15 	stw	r3,184(sp)
8111f9c8:	1805883a 	mov	r2,r3
8111f9cc:	183fa10e 	bge	r3,zero,8111f854 <__reset+0xfb0ff854>
8111f9d0:	0005883a 	mov	r2,zero
8111f9d4:	003f9f06 	br	8111f854 <__reset+0xfb0ff854>
8111f9d8:	d9003617 	ldw	r4,216(sp)
8111f9dc:	000d883a 	mov	r6,zero
8111f9e0:	000f883a 	mov	r7,zero
8111f9e4:	a00b883a 	mov	r5,r20
8111f9e8:	d8c03d15 	stw	r3,244(sp)
8111f9ec:	da003e15 	stw	r8,248(sp)
8111f9f0:	11305900 	call	81130590 <__eqdf2>
8111f9f4:	d8c03d17 	ldw	r3,244(sp)
8111f9f8:	da003e17 	ldw	r8,248(sp)
8111f9fc:	103f8726 	beq	r2,zero,8111f81c <__reset+0xfb0ff81c>
8111fa00:	00800044 	movi	r2,1
8111fa04:	10c7c83a 	sub	r3,r2,r3
8111fa08:	d8c02615 	stw	r3,152(sp)
8111fa0c:	003f8406 	br	8111f820 <__reset+0xfb0ff820>
8111fa10:	20000e1e 	bne	r4,zero,8111fa4c <___svfprintf_internal_r+0x20d4>
8111fa14:	9480004c 	andi	r18,r18,1
8111fa18:	90000c1e 	bne	r18,zero,8111fa4c <___svfprintf_internal_r+0x20d4>
8111fa1c:	00800044 	movi	r2,1
8111fa20:	d8802e15 	stw	r2,184(sp)
8111fa24:	003e6606 	br	8111f3c0 <__reset+0xfb0ff3c0>
8111fa28:	00800b44 	movi	r2,45
8111fa2c:	05adc83a 	sub	r22,zero,r22
8111fa30:	d8802305 	stb	r2,140(sp)
8111fa34:	003f3b06 	br	8111f724 <__reset+0xfb0ff724>
8111fa38:	0005883a 	mov	r2,zero
8111fa3c:	003f4e06 	br	8111f778 <__reset+0xfb0ff778>
8111fa40:	90a4703a 	and	r18,r18,r2
8111fa44:	903f4a26 	beq	r18,zero,8111f770 <__reset+0xfb0ff770>
8111fa48:	003f4606 	br	8111f764 <__reset+0xfb0ff764>
8111fa4c:	d8c02917 	ldw	r3,164(sp)
8111fa50:	18c00084 	addi	r3,r3,2
8111fa54:	d8c02e15 	stw	r3,184(sp)
8111fa58:	1805883a 	mov	r2,r3
8111fa5c:	183e580e 	bge	r3,zero,8111f3c0 <__reset+0xfb0ff3c0>
8111fa60:	003fd006 	br	8111f9a4 <__reset+0xfb0ff9a4>
8111fa64:	00800084 	movi	r2,2
8111fa68:	10c5c83a 	sub	r2,r2,r3
8111fa6c:	003f7506 	br	8111f844 <__reset+0xfb0ff844>
8111fa70:	d8802d17 	ldw	r2,180(sp)
8111fa74:	d9002d17 	ldw	r4,180(sp)
8111fa78:	bc400043 	ldbu	r17,1(r23)
8111fa7c:	10800017 	ldw	r2,0(r2)
8111fa80:	582f883a 	mov	r23,r11
8111fa84:	d8802915 	stw	r2,164(sp)
8111fa88:	20800104 	addi	r2,r4,4
8111fa8c:	d9002917 	ldw	r4,164(sp)
8111fa90:	d8802d15 	stw	r2,180(sp)
8111fa94:	203df00e 	bge	r4,zero,8111f258 <__reset+0xfb0ff258>
8111fa98:	8c403fcc 	andi	r17,r17,255
8111fa9c:	00bfffc4 	movi	r2,-1
8111faa0:	8c40201c 	xori	r17,r17,128
8111faa4:	d8802915 	stw	r2,164(sp)
8111faa8:	8c7fe004 	addi	r17,r17,-128
8111faac:	00380806 	br	8111dad0 <__reset+0xfb0fdad0>
8111fab0:	9080004c 	andi	r2,r18,1
8111fab4:	0039883a 	mov	fp,zero
8111fab8:	10000726 	beq	r2,zero,8111fad8 <___svfprintf_internal_r+0x2160>
8111fabc:	d8c02817 	ldw	r3,160(sp)
8111fac0:	dc001dc4 	addi	r16,sp,119
8111fac4:	00800c04 	movi	r2,48
8111fac8:	1c07c83a 	sub	r3,r3,r16
8111facc:	d8801dc5 	stb	r2,119(sp)
8111fad0:	d8c02e15 	stw	r3,184(sp)
8111fad4:	00395206 	br	8111e020 <__reset+0xfb0fe020>
8111fad8:	d8002e15 	stw	zero,184(sp)
8111fadc:	dc001e04 	addi	r16,sp,120
8111fae0:	00394f06 	br	8111e020 <__reset+0xfb0fe020>
8111fae4:	0005883a 	mov	r2,zero
8111fae8:	003e3206 	br	8111f3b4 <__reset+0xfb0ff3b4>
8111faec:	dd802617 	ldw	r22,152(sp)
8111faf0:	003f0606 	br	8111f70c <__reset+0xfb0ff70c>
8111faf4:	d9c02785 	stb	r7,158(sp)
8111faf8:	003a5106 	br	8111e440 <__reset+0xfb0fe440>
8111fafc:	d9c02785 	stb	r7,158(sp)
8111fb00:	003a3706 	br	8111e3e0 <__reset+0xfb0fe3e0>
8111fb04:	0005883a 	mov	r2,zero
8111fb08:	003f5e06 	br	8111f884 <__reset+0xfb0ff884>
8111fb0c:	d9c02785 	stb	r7,158(sp)
8111fb10:	00391706 	br	8111df70 <__reset+0xfb0fdf70>
8111fb14:	d9c02785 	stb	r7,158(sp)
8111fb18:	0038e606 	br	8111deb4 <__reset+0xfb0fdeb4>
8111fb1c:	d8802344 	addi	r2,sp,141
8111fb20:	003f0806 	br	8111f744 <__reset+0xfb0ff744>
8111fb24:	d9c02785 	stb	r7,158(sp)
8111fb28:	0038b706 	br	8111de08 <__reset+0xfb0fde08>
8111fb2c:	d9c02785 	stb	r7,158(sp)
8111fb30:	003adc06 	br	8111e6a4 <__reset+0xfb0fe6a4>
8111fb34:	d9403917 	ldw	r5,228(sp)
8111fb38:	00800304 	movi	r2,12
8111fb3c:	28800015 	stw	r2,0(r5)
8111fb40:	00bfffc4 	movi	r2,-1
8111fb44:	00387806 	br	8111dd28 <__reset+0xfb0fdd28>
8111fb48:	d9c02785 	stb	r7,158(sp)
8111fb4c:	003abf06 	br	8111e64c <__reset+0xfb0fe64c>
8111fb50:	d9c02785 	stb	r7,158(sp)
8111fb54:	003a9b06 	br	8111e5c4 <__reset+0xfb0fe5c4>

8111fb58 <___vfprintf_internal_r>:
8111fb58:	deffb804 	addi	sp,sp,-288
8111fb5c:	de00012e 	bgeu	sp,et,8111fb64 <___vfprintf_internal_r+0xc>
8111fb60:	003b68fa 	trap	3
8111fb64:	dfc04715 	stw	ra,284(sp)
8111fb68:	ddc04515 	stw	r23,276(sp)
8111fb6c:	dd404315 	stw	r21,268(sp)
8111fb70:	d9002c15 	stw	r4,176(sp)
8111fb74:	282f883a 	mov	r23,r5
8111fb78:	302b883a 	mov	r21,r6
8111fb7c:	d9c02d15 	stw	r7,180(sp)
8111fb80:	df004615 	stw	fp,280(sp)
8111fb84:	dd804415 	stw	r22,272(sp)
8111fb88:	dd004215 	stw	r20,264(sp)
8111fb8c:	dcc04115 	stw	r19,260(sp)
8111fb90:	dc804015 	stw	r18,256(sp)
8111fb94:	dc403f15 	stw	r17,252(sp)
8111fb98:	dc003e15 	stw	r16,248(sp)
8111fb9c:	11268600 	call	81126860 <_localeconv_r>
8111fba0:	10800017 	ldw	r2,0(r2)
8111fba4:	1009883a 	mov	r4,r2
8111fba8:	d8803415 	stw	r2,208(sp)
8111fbac:	111d6400 	call	8111d640 <strlen>
8111fbb0:	d8803715 	stw	r2,220(sp)
8111fbb4:	d8802c17 	ldw	r2,176(sp)
8111fbb8:	10000226 	beq	r2,zero,8111fbc4 <___vfprintf_internal_r+0x6c>
8111fbbc:	10800e17 	ldw	r2,56(r2)
8111fbc0:	1000f926 	beq	r2,zero,8111ffa8 <___vfprintf_internal_r+0x450>
8111fbc4:	b880030b 	ldhu	r2,12(r23)
8111fbc8:	10c8000c 	andi	r3,r2,8192
8111fbcc:	1800061e 	bne	r3,zero,8111fbe8 <___vfprintf_internal_r+0x90>
8111fbd0:	b9001917 	ldw	r4,100(r23)
8111fbd4:	00f7ffc4 	movi	r3,-8193
8111fbd8:	10880014 	ori	r2,r2,8192
8111fbdc:	20c6703a 	and	r3,r4,r3
8111fbe0:	b880030d 	sth	r2,12(r23)
8111fbe4:	b8c01915 	stw	r3,100(r23)
8111fbe8:	10c0020c 	andi	r3,r2,8
8111fbec:	1800c126 	beq	r3,zero,8111fef4 <___vfprintf_internal_r+0x39c>
8111fbf0:	b8c00417 	ldw	r3,16(r23)
8111fbf4:	1800bf26 	beq	r3,zero,8111fef4 <___vfprintf_internal_r+0x39c>
8111fbf8:	1080068c 	andi	r2,r2,26
8111fbfc:	00c00284 	movi	r3,10
8111fc00:	10c0c426 	beq	r2,r3,8111ff14 <___vfprintf_internal_r+0x3bc>
8111fc04:	d8c00404 	addi	r3,sp,16
8111fc08:	05204574 	movhi	r20,33045
8111fc0c:	d9001e04 	addi	r4,sp,120
8111fc10:	a52b6984 	addi	r20,r20,-21082
8111fc14:	d8c01e15 	stw	r3,120(sp)
8111fc18:	d8002015 	stw	zero,128(sp)
8111fc1c:	d8001f15 	stw	zero,124(sp)
8111fc20:	d8003315 	stw	zero,204(sp)
8111fc24:	d8003615 	stw	zero,216(sp)
8111fc28:	d8003815 	stw	zero,224(sp)
8111fc2c:	1811883a 	mov	r8,r3
8111fc30:	d8003915 	stw	zero,228(sp)
8111fc34:	d8003a15 	stw	zero,232(sp)
8111fc38:	d8002f15 	stw	zero,188(sp)
8111fc3c:	d9002815 	stw	r4,160(sp)
8111fc40:	a8800007 	ldb	r2,0(r21)
8111fc44:	10027b26 	beq	r2,zero,81120634 <___vfprintf_internal_r+0xadc>
8111fc48:	00c00944 	movi	r3,37
8111fc4c:	a821883a 	mov	r16,r21
8111fc50:	10c0021e 	bne	r2,r3,8111fc5c <___vfprintf_internal_r+0x104>
8111fc54:	00001406 	br	8111fca8 <___vfprintf_internal_r+0x150>
8111fc58:	10c00326 	beq	r2,r3,8111fc68 <___vfprintf_internal_r+0x110>
8111fc5c:	84000044 	addi	r16,r16,1
8111fc60:	80800007 	ldb	r2,0(r16)
8111fc64:	103ffc1e 	bne	r2,zero,8111fc58 <__reset+0xfb0ffc58>
8111fc68:	8563c83a 	sub	r17,r16,r21
8111fc6c:	88000e26 	beq	r17,zero,8111fca8 <___vfprintf_internal_r+0x150>
8111fc70:	d8c02017 	ldw	r3,128(sp)
8111fc74:	d8801f17 	ldw	r2,124(sp)
8111fc78:	45400015 	stw	r21,0(r8)
8111fc7c:	1c47883a 	add	r3,r3,r17
8111fc80:	10800044 	addi	r2,r2,1
8111fc84:	d8c02015 	stw	r3,128(sp)
8111fc88:	44400115 	stw	r17,4(r8)
8111fc8c:	d8801f15 	stw	r2,124(sp)
8111fc90:	00c001c4 	movi	r3,7
8111fc94:	1880a716 	blt	r3,r2,8111ff34 <___vfprintf_internal_r+0x3dc>
8111fc98:	42000204 	addi	r8,r8,8
8111fc9c:	d9402f17 	ldw	r5,188(sp)
8111fca0:	2c4b883a 	add	r5,r5,r17
8111fca4:	d9402f15 	stw	r5,188(sp)
8111fca8:	80800007 	ldb	r2,0(r16)
8111fcac:	1000a826 	beq	r2,zero,8111ff50 <___vfprintf_internal_r+0x3f8>
8111fcb0:	84400047 	ldb	r17,1(r16)
8111fcb4:	00bfffc4 	movi	r2,-1
8111fcb8:	85400044 	addi	r21,r16,1
8111fcbc:	d8002785 	stb	zero,158(sp)
8111fcc0:	0007883a 	mov	r3,zero
8111fcc4:	000f883a 	mov	r7,zero
8111fcc8:	d8802915 	stw	r2,164(sp)
8111fccc:	d8003115 	stw	zero,196(sp)
8111fcd0:	0025883a 	mov	r18,zero
8111fcd4:	01401604 	movi	r5,88
8111fcd8:	01800244 	movi	r6,9
8111fcdc:	02800a84 	movi	r10,42
8111fce0:	02401b04 	movi	r9,108
8111fce4:	ad400044 	addi	r21,r21,1
8111fce8:	88bff804 	addi	r2,r17,-32
8111fcec:	28830436 	bltu	r5,r2,81120900 <___vfprintf_internal_r+0xda8>
8111fcf0:	100490ba 	slli	r2,r2,2
8111fcf4:	012044b4 	movhi	r4,33042
8111fcf8:	213f4204 	addi	r4,r4,-760
8111fcfc:	1105883a 	add	r2,r2,r4
8111fd00:	10800017 	ldw	r2,0(r2)
8111fd04:	1000683a 	jmp	r2
8111fd08:	81120820 	cmpeqi	r4,r16,18464
8111fd0c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd10:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd14:	81120840 	call	88112084 <__reset+0x20f2084>
8111fd18:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd1c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd20:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd24:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd28:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd2c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd30:	8111ffb4 	orhi	r4,r16,18430
8111fd34:	8112075c 	xori	r4,r16,18461
8111fd38:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd3c:	8111fe7c 	xorhi	r4,r16,18425
8111fd40:	8111ffdc 	xori	r4,r16,18431
8111fd44:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd48:	8112001c 	xori	r4,r16,18432
8111fd4c:	81120028 	cmpgeui	r4,r16,18432
8111fd50:	81120028 	cmpgeui	r4,r16,18432
8111fd54:	81120028 	cmpgeui	r4,r16,18432
8111fd58:	81120028 	cmpgeui	r4,r16,18432
8111fd5c:	81120028 	cmpgeui	r4,r16,18432
8111fd60:	81120028 	cmpgeui	r4,r16,18432
8111fd64:	81120028 	cmpgeui	r4,r16,18432
8111fd68:	81120028 	cmpgeui	r4,r16,18432
8111fd6c:	81120028 	cmpgeui	r4,r16,18432
8111fd70:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd74:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd78:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd7c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd80:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd84:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd88:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd8c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd90:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd94:	81120900 	call	88112090 <__reset+0x20f2090>
8111fd98:	8112005c 	xori	r4,r16,18433
8111fd9c:	81120118 	cmpnei	r4,r16,18436
8111fda0:	81120900 	call	88112090 <__reset+0x20f2090>
8111fda4:	81120118 	cmpnei	r4,r16,18436
8111fda8:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdac:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdb0:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdb4:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdb8:	811201b8 	rdprs	r4,r16,18438
8111fdbc:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdc0:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdc4:	811201c4 	addi	r4,r16,18439
8111fdc8:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdcc:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdd0:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdd4:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdd8:	81120900 	call	88112090 <__reset+0x20f2090>
8111fddc:	8112063c 	xorhi	r4,r16,18456
8111fde0:	81120900 	call	88112090 <__reset+0x20f2090>
8111fde4:	81120900 	call	88112090 <__reset+0x20f2090>
8111fde8:	8112069c 	xori	r4,r16,18458
8111fdec:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdf0:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdf4:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdf8:	81120900 	call	88112090 <__reset+0x20f2090>
8111fdfc:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe00:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe04:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe08:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe0c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe10:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe14:	811208ac 	andhi	r4,r16,18466
8111fe18:	8112084c 	andi	r4,r16,18465
8111fe1c:	81120118 	cmpnei	r4,r16,18436
8111fe20:	81120118 	cmpnei	r4,r16,18436
8111fe24:	81120118 	cmpnei	r4,r16,18436
8111fe28:	8112085c 	xori	r4,r16,18465
8111fe2c:	8112084c 	andi	r4,r16,18465
8111fe30:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe34:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe38:	81120868 	cmpgeui	r4,r16,18465
8111fe3c:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe40:	81120878 	rdprs	r4,r16,18465
8111fe44:	8112074c 	andi	r4,r16,18461
8111fe48:	8111fe88 	cmpgei	r4,r16,18426
8111fe4c:	8112076c 	andhi	r4,r16,18461
8111fe50:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe54:	81120778 	rdprs	r4,r16,18461
8111fe58:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe5c:	811207d4 	ori	r4,r16,18463
8111fe60:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe64:	81120900 	call	88112090 <__reset+0x20f2090>
8111fe68:	811207e4 	muli	r4,r16,18463
8111fe6c:	d9003117 	ldw	r4,196(sp)
8111fe70:	d8802d15 	stw	r2,180(sp)
8111fe74:	0109c83a 	sub	r4,zero,r4
8111fe78:	d9003115 	stw	r4,196(sp)
8111fe7c:	94800114 	ori	r18,r18,4
8111fe80:	ac400007 	ldb	r17,0(r21)
8111fe84:	003f9706 	br	8111fce4 <__reset+0xfb0ffce4>
8111fe88:	00800c04 	movi	r2,48
8111fe8c:	d9002d17 	ldw	r4,180(sp)
8111fe90:	d9402917 	ldw	r5,164(sp)
8111fe94:	d8802705 	stb	r2,156(sp)
8111fe98:	00801e04 	movi	r2,120
8111fe9c:	d8802745 	stb	r2,157(sp)
8111fea0:	d8002785 	stb	zero,158(sp)
8111fea4:	20c00104 	addi	r3,r4,4
8111fea8:	24c00017 	ldw	r19,0(r4)
8111feac:	002d883a 	mov	r22,zero
8111feb0:	90800094 	ori	r2,r18,2
8111feb4:	28029a16 	blt	r5,zero,81120920 <___vfprintf_internal_r+0xdc8>
8111feb8:	00bfdfc4 	movi	r2,-129
8111febc:	90a4703a 	and	r18,r18,r2
8111fec0:	d8c02d15 	stw	r3,180(sp)
8111fec4:	94800094 	ori	r18,r18,2
8111fec8:	9802871e 	bne	r19,zero,811208e8 <___vfprintf_internal_r+0xd90>
8111fecc:	00a04574 	movhi	r2,33045
8111fed0:	10ab5a04 	addi	r2,r2,-21144
8111fed4:	d8803915 	stw	r2,228(sp)
8111fed8:	04401e04 	movi	r17,120
8111fedc:	d8802917 	ldw	r2,164(sp)
8111fee0:	0039883a 	mov	fp,zero
8111fee4:	1001e926 	beq	r2,zero,8112068c <___vfprintf_internal_r+0xb34>
8111fee8:	0027883a 	mov	r19,zero
8111feec:	002d883a 	mov	r22,zero
8111fef0:	00020506 	br	81120708 <___vfprintf_internal_r+0xbb0>
8111fef4:	d9002c17 	ldw	r4,176(sp)
8111fef8:	b80b883a 	mov	r5,r23
8111fefc:	11238a40 	call	811238a4 <__swsetup_r>
8111ff00:	1005ac1e 	bne	r2,zero,811215b4 <___vfprintf_internal_r+0x1a5c>
8111ff04:	b880030b 	ldhu	r2,12(r23)
8111ff08:	00c00284 	movi	r3,10
8111ff0c:	1080068c 	andi	r2,r2,26
8111ff10:	10ff3c1e 	bne	r2,r3,8111fc04 <__reset+0xfb0ffc04>
8111ff14:	b880038f 	ldh	r2,14(r23)
8111ff18:	103f3a16 	blt	r2,zero,8111fc04 <__reset+0xfb0ffc04>
8111ff1c:	d9c02d17 	ldw	r7,180(sp)
8111ff20:	d9002c17 	ldw	r4,176(sp)
8111ff24:	a80d883a 	mov	r6,r21
8111ff28:	b80b883a 	mov	r5,r23
8111ff2c:	1121d740 	call	81121d74 <__sbprintf>
8111ff30:	00001106 	br	8111ff78 <___vfprintf_internal_r+0x420>
8111ff34:	d9002c17 	ldw	r4,176(sp)
8111ff38:	d9801e04 	addi	r6,sp,120
8111ff3c:	b80b883a 	mov	r5,r23
8111ff40:	112bd480 	call	8112bd48 <__sprint_r>
8111ff44:	1000081e 	bne	r2,zero,8111ff68 <___vfprintf_internal_r+0x410>
8111ff48:	da000404 	addi	r8,sp,16
8111ff4c:	003f5306 	br	8111fc9c <__reset+0xfb0ffc9c>
8111ff50:	d8802017 	ldw	r2,128(sp)
8111ff54:	10000426 	beq	r2,zero,8111ff68 <___vfprintf_internal_r+0x410>
8111ff58:	d9002c17 	ldw	r4,176(sp)
8111ff5c:	d9801e04 	addi	r6,sp,120
8111ff60:	b80b883a 	mov	r5,r23
8111ff64:	112bd480 	call	8112bd48 <__sprint_r>
8111ff68:	b880030b 	ldhu	r2,12(r23)
8111ff6c:	1080100c 	andi	r2,r2,64
8111ff70:	1005901e 	bne	r2,zero,811215b4 <___vfprintf_internal_r+0x1a5c>
8111ff74:	d8802f17 	ldw	r2,188(sp)
8111ff78:	dfc04717 	ldw	ra,284(sp)
8111ff7c:	df004617 	ldw	fp,280(sp)
8111ff80:	ddc04517 	ldw	r23,276(sp)
8111ff84:	dd804417 	ldw	r22,272(sp)
8111ff88:	dd404317 	ldw	r21,268(sp)
8111ff8c:	dd004217 	ldw	r20,264(sp)
8111ff90:	dcc04117 	ldw	r19,260(sp)
8111ff94:	dc804017 	ldw	r18,256(sp)
8111ff98:	dc403f17 	ldw	r17,252(sp)
8111ff9c:	dc003e17 	ldw	r16,248(sp)
8111ffa0:	dec04804 	addi	sp,sp,288
8111ffa4:	f800283a 	ret
8111ffa8:	d9002c17 	ldw	r4,176(sp)
8111ffac:	11259140 	call	81125914 <__sinit>
8111ffb0:	003f0406 	br	8111fbc4 <__reset+0xfb0ffbc4>
8111ffb4:	d8802d17 	ldw	r2,180(sp)
8111ffb8:	d9002d17 	ldw	r4,180(sp)
8111ffbc:	10800017 	ldw	r2,0(r2)
8111ffc0:	d8803115 	stw	r2,196(sp)
8111ffc4:	20800104 	addi	r2,r4,4
8111ffc8:	d9003117 	ldw	r4,196(sp)
8111ffcc:	203fa716 	blt	r4,zero,8111fe6c <__reset+0xfb0ffe6c>
8111ffd0:	d8802d15 	stw	r2,180(sp)
8111ffd4:	ac400007 	ldb	r17,0(r21)
8111ffd8:	003f4206 	br	8111fce4 <__reset+0xfb0ffce4>
8111ffdc:	ac400007 	ldb	r17,0(r21)
8111ffe0:	aac00044 	addi	r11,r21,1
8111ffe4:	8a872826 	beq	r17,r10,81121c88 <___vfprintf_internal_r+0x2130>
8111ffe8:	88bff404 	addi	r2,r17,-48
8111ffec:	0009883a 	mov	r4,zero
8111fff0:	30867d36 	bltu	r6,r2,811219e8 <___vfprintf_internal_r+0x1e90>
8111fff4:	5c400007 	ldb	r17,0(r11)
8111fff8:	210002a4 	muli	r4,r4,10
8111fffc:	5d400044 	addi	r21,r11,1
81120000:	a817883a 	mov	r11,r21
81120004:	2089883a 	add	r4,r4,r2
81120008:	88bff404 	addi	r2,r17,-48
8112000c:	30bff92e 	bgeu	r6,r2,8111fff4 <__reset+0xfb0ffff4>
81120010:	2005c916 	blt	r4,zero,81121738 <___vfprintf_internal_r+0x1be0>
81120014:	d9002915 	stw	r4,164(sp)
81120018:	003f3306 	br	8111fce8 <__reset+0xfb0ffce8>
8112001c:	94802014 	ori	r18,r18,128
81120020:	ac400007 	ldb	r17,0(r21)
81120024:	003f2f06 	br	8111fce4 <__reset+0xfb0ffce4>
81120028:	a809883a 	mov	r4,r21
8112002c:	d8003115 	stw	zero,196(sp)
81120030:	88bff404 	addi	r2,r17,-48
81120034:	0017883a 	mov	r11,zero
81120038:	24400007 	ldb	r17,0(r4)
8112003c:	5ac002a4 	muli	r11,r11,10
81120040:	ad400044 	addi	r21,r21,1
81120044:	a809883a 	mov	r4,r21
81120048:	12d7883a 	add	r11,r2,r11
8112004c:	88bff404 	addi	r2,r17,-48
81120050:	30bff92e 	bgeu	r6,r2,81120038 <__reset+0xfb100038>
81120054:	dac03115 	stw	r11,196(sp)
81120058:	003f2306 	br	8111fce8 <__reset+0xfb0ffce8>
8112005c:	18c03fcc 	andi	r3,r3,255
81120060:	18072b1e 	bne	r3,zero,81121d10 <___vfprintf_internal_r+0x21b8>
81120064:	94800414 	ori	r18,r18,16
81120068:	9080080c 	andi	r2,r18,32
8112006c:	10037b26 	beq	r2,zero,81120e5c <___vfprintf_internal_r+0x1304>
81120070:	d9402d17 	ldw	r5,180(sp)
81120074:	28800117 	ldw	r2,4(r5)
81120078:	2cc00017 	ldw	r19,0(r5)
8112007c:	29400204 	addi	r5,r5,8
81120080:	d9402d15 	stw	r5,180(sp)
81120084:	102d883a 	mov	r22,r2
81120088:	10044b16 	blt	r2,zero,811211b8 <___vfprintf_internal_r+0x1660>
8112008c:	d9402917 	ldw	r5,164(sp)
81120090:	df002783 	ldbu	fp,158(sp)
81120094:	2803bc16 	blt	r5,zero,81120f88 <___vfprintf_internal_r+0x1430>
81120098:	00ffdfc4 	movi	r3,-129
8112009c:	9d84b03a 	or	r2,r19,r22
811200a0:	90e4703a 	and	r18,r18,r3
811200a4:	10017726 	beq	r2,zero,81120684 <___vfprintf_internal_r+0xb2c>
811200a8:	b0038326 	beq	r22,zero,81120eb8 <___vfprintf_internal_r+0x1360>
811200ac:	dc402a15 	stw	r17,168(sp)
811200b0:	dc001e04 	addi	r16,sp,120
811200b4:	b023883a 	mov	r17,r22
811200b8:	402d883a 	mov	r22,r8
811200bc:	9809883a 	mov	r4,r19
811200c0:	880b883a 	mov	r5,r17
811200c4:	01800284 	movi	r6,10
811200c8:	000f883a 	mov	r7,zero
811200cc:	112eafc0 	call	8112eafc <__umoddi3>
811200d0:	10800c04 	addi	r2,r2,48
811200d4:	843fffc4 	addi	r16,r16,-1
811200d8:	9809883a 	mov	r4,r19
811200dc:	880b883a 	mov	r5,r17
811200e0:	80800005 	stb	r2,0(r16)
811200e4:	01800284 	movi	r6,10
811200e8:	000f883a 	mov	r7,zero
811200ec:	112e57c0 	call	8112e57c <__udivdi3>
811200f0:	1027883a 	mov	r19,r2
811200f4:	10c4b03a 	or	r2,r2,r3
811200f8:	1823883a 	mov	r17,r3
811200fc:	103fef1e 	bne	r2,zero,811200bc <__reset+0xfb1000bc>
81120100:	d8c02817 	ldw	r3,160(sp)
81120104:	dc402a17 	ldw	r17,168(sp)
81120108:	b011883a 	mov	r8,r22
8112010c:	1c07c83a 	sub	r3,r3,r16
81120110:	d8c02e15 	stw	r3,184(sp)
81120114:	00005906 	br	8112027c <___vfprintf_internal_r+0x724>
81120118:	18c03fcc 	andi	r3,r3,255
8112011c:	1806fa1e 	bne	r3,zero,81121d08 <___vfprintf_internal_r+0x21b0>
81120120:	9080020c 	andi	r2,r18,8
81120124:	10048a26 	beq	r2,zero,81121350 <___vfprintf_internal_r+0x17f8>
81120128:	d8c02d17 	ldw	r3,180(sp)
8112012c:	d9002d17 	ldw	r4,180(sp)
81120130:	d9402d17 	ldw	r5,180(sp)
81120134:	18c00017 	ldw	r3,0(r3)
81120138:	21000117 	ldw	r4,4(r4)
8112013c:	29400204 	addi	r5,r5,8
81120140:	d8c03615 	stw	r3,216(sp)
81120144:	d9003815 	stw	r4,224(sp)
81120148:	d9402d15 	stw	r5,180(sp)
8112014c:	d9003617 	ldw	r4,216(sp)
81120150:	d9403817 	ldw	r5,224(sp)
81120154:	da003d15 	stw	r8,244(sp)
81120158:	04000044 	movi	r16,1
8112015c:	11283ac0 	call	811283ac <__fpclassifyd>
81120160:	da003d17 	ldw	r8,244(sp)
81120164:	14041f1e 	bne	r2,r16,811211e4 <___vfprintf_internal_r+0x168c>
81120168:	d9003617 	ldw	r4,216(sp)
8112016c:	d9403817 	ldw	r5,224(sp)
81120170:	000d883a 	mov	r6,zero
81120174:	000f883a 	mov	r7,zero
81120178:	11306f40 	call	811306f4 <__ledf2>
8112017c:	da003d17 	ldw	r8,244(sp)
81120180:	1005be16 	blt	r2,zero,8112187c <___vfprintf_internal_r+0x1d24>
81120184:	df002783 	ldbu	fp,158(sp)
81120188:	008011c4 	movi	r2,71
8112018c:	1445330e 	bge	r2,r17,8112165c <___vfprintf_internal_r+0x1b04>
81120190:	04204574 	movhi	r16,33045
81120194:	842b5204 	addi	r16,r16,-21176
81120198:	00c000c4 	movi	r3,3
8112019c:	00bfdfc4 	movi	r2,-129
811201a0:	d8c02a15 	stw	r3,168(sp)
811201a4:	90a4703a 	and	r18,r18,r2
811201a8:	d8c02e15 	stw	r3,184(sp)
811201ac:	d8002915 	stw	zero,164(sp)
811201b0:	d8003215 	stw	zero,200(sp)
811201b4:	00003706 	br	81120294 <___vfprintf_internal_r+0x73c>
811201b8:	94800214 	ori	r18,r18,8
811201bc:	ac400007 	ldb	r17,0(r21)
811201c0:	003ec806 	br	8111fce4 <__reset+0xfb0ffce4>
811201c4:	18c03fcc 	andi	r3,r3,255
811201c8:	1806db1e 	bne	r3,zero,81121d38 <___vfprintf_internal_r+0x21e0>
811201cc:	94800414 	ori	r18,r18,16
811201d0:	9080080c 	andi	r2,r18,32
811201d4:	1002d826 	beq	r2,zero,81120d38 <___vfprintf_internal_r+0x11e0>
811201d8:	d9402d17 	ldw	r5,180(sp)
811201dc:	d8c02917 	ldw	r3,164(sp)
811201e0:	d8002785 	stb	zero,158(sp)
811201e4:	28800204 	addi	r2,r5,8
811201e8:	2cc00017 	ldw	r19,0(r5)
811201ec:	2d800117 	ldw	r22,4(r5)
811201f0:	18048f16 	blt	r3,zero,81121430 <___vfprintf_internal_r+0x18d8>
811201f4:	013fdfc4 	movi	r4,-129
811201f8:	9d86b03a 	or	r3,r19,r22
811201fc:	d8802d15 	stw	r2,180(sp)
81120200:	9124703a 	and	r18,r18,r4
81120204:	1802d91e 	bne	r3,zero,81120d6c <___vfprintf_internal_r+0x1214>
81120208:	d8c02917 	ldw	r3,164(sp)
8112020c:	0039883a 	mov	fp,zero
81120210:	1805c326 	beq	r3,zero,81121920 <___vfprintf_internal_r+0x1dc8>
81120214:	0027883a 	mov	r19,zero
81120218:	002d883a 	mov	r22,zero
8112021c:	dc001e04 	addi	r16,sp,120
81120220:	9806d0fa 	srli	r3,r19,3
81120224:	b008977a 	slli	r4,r22,29
81120228:	b02cd0fa 	srli	r22,r22,3
8112022c:	9cc001cc 	andi	r19,r19,7
81120230:	98800c04 	addi	r2,r19,48
81120234:	843fffc4 	addi	r16,r16,-1
81120238:	20e6b03a 	or	r19,r4,r3
8112023c:	80800005 	stb	r2,0(r16)
81120240:	9d86b03a 	or	r3,r19,r22
81120244:	183ff61e 	bne	r3,zero,81120220 <__reset+0xfb100220>
81120248:	90c0004c 	andi	r3,r18,1
8112024c:	18013b26 	beq	r3,zero,8112073c <___vfprintf_internal_r+0xbe4>
81120250:	10803fcc 	andi	r2,r2,255
81120254:	1080201c 	xori	r2,r2,128
81120258:	10bfe004 	addi	r2,r2,-128
8112025c:	00c00c04 	movi	r3,48
81120260:	10c13626 	beq	r2,r3,8112073c <___vfprintf_internal_r+0xbe4>
81120264:	80ffffc5 	stb	r3,-1(r16)
81120268:	d8c02817 	ldw	r3,160(sp)
8112026c:	80bfffc4 	addi	r2,r16,-1
81120270:	1021883a 	mov	r16,r2
81120274:	1887c83a 	sub	r3,r3,r2
81120278:	d8c02e15 	stw	r3,184(sp)
8112027c:	d8802e17 	ldw	r2,184(sp)
81120280:	d9002917 	ldw	r4,164(sp)
81120284:	1100010e 	bge	r2,r4,8112028c <___vfprintf_internal_r+0x734>
81120288:	2005883a 	mov	r2,r4
8112028c:	d8802a15 	stw	r2,168(sp)
81120290:	d8003215 	stw	zero,200(sp)
81120294:	e7003fcc 	andi	fp,fp,255
81120298:	e700201c 	xori	fp,fp,128
8112029c:	e73fe004 	addi	fp,fp,-128
811202a0:	e0000326 	beq	fp,zero,811202b0 <___vfprintf_internal_r+0x758>
811202a4:	d8c02a17 	ldw	r3,168(sp)
811202a8:	18c00044 	addi	r3,r3,1
811202ac:	d8c02a15 	stw	r3,168(sp)
811202b0:	90c0008c 	andi	r3,r18,2
811202b4:	d8c02b15 	stw	r3,172(sp)
811202b8:	18000326 	beq	r3,zero,811202c8 <___vfprintf_internal_r+0x770>
811202bc:	d8c02a17 	ldw	r3,168(sp)
811202c0:	18c00084 	addi	r3,r3,2
811202c4:	d8c02a15 	stw	r3,168(sp)
811202c8:	90c0210c 	andi	r3,r18,132
811202cc:	d8c03015 	stw	r3,192(sp)
811202d0:	1801a31e 	bne	r3,zero,81120960 <___vfprintf_internal_r+0xe08>
811202d4:	d9003117 	ldw	r4,196(sp)
811202d8:	d8c02a17 	ldw	r3,168(sp)
811202dc:	20e7c83a 	sub	r19,r4,r3
811202e0:	04c19f0e 	bge	zero,r19,81120960 <___vfprintf_internal_r+0xe08>
811202e4:	02400404 	movi	r9,16
811202e8:	d8c02017 	ldw	r3,128(sp)
811202ec:	d8801f17 	ldw	r2,124(sp)
811202f0:	4cc50d0e 	bge	r9,r19,81121728 <___vfprintf_internal_r+0x1bd0>
811202f4:	01604574 	movhi	r5,33045
811202f8:	296b6d84 	addi	r5,r5,-21066
811202fc:	dc403b15 	stw	r17,236(sp)
81120300:	d9403515 	stw	r5,212(sp)
81120304:	9823883a 	mov	r17,r19
81120308:	482d883a 	mov	r22,r9
8112030c:	9027883a 	mov	r19,r18
81120310:	070001c4 	movi	fp,7
81120314:	8025883a 	mov	r18,r16
81120318:	dc002c17 	ldw	r16,176(sp)
8112031c:	00000306 	br	8112032c <___vfprintf_internal_r+0x7d4>
81120320:	8c7ffc04 	addi	r17,r17,-16
81120324:	42000204 	addi	r8,r8,8
81120328:	b440130e 	bge	r22,r17,81120378 <___vfprintf_internal_r+0x820>
8112032c:	01204574 	movhi	r4,33045
81120330:	18c00404 	addi	r3,r3,16
81120334:	10800044 	addi	r2,r2,1
81120338:	212b6d84 	addi	r4,r4,-21066
8112033c:	41000015 	stw	r4,0(r8)
81120340:	45800115 	stw	r22,4(r8)
81120344:	d8c02015 	stw	r3,128(sp)
81120348:	d8801f15 	stw	r2,124(sp)
8112034c:	e0bff40e 	bge	fp,r2,81120320 <__reset+0xfb100320>
81120350:	d9801e04 	addi	r6,sp,120
81120354:	b80b883a 	mov	r5,r23
81120358:	8009883a 	mov	r4,r16
8112035c:	112bd480 	call	8112bd48 <__sprint_r>
81120360:	103f011e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120364:	8c7ffc04 	addi	r17,r17,-16
81120368:	d8c02017 	ldw	r3,128(sp)
8112036c:	d8801f17 	ldw	r2,124(sp)
81120370:	da000404 	addi	r8,sp,16
81120374:	b47fed16 	blt	r22,r17,8112032c <__reset+0xfb10032c>
81120378:	9021883a 	mov	r16,r18
8112037c:	9825883a 	mov	r18,r19
81120380:	8827883a 	mov	r19,r17
81120384:	dc403b17 	ldw	r17,236(sp)
81120388:	d9403517 	ldw	r5,212(sp)
8112038c:	98c7883a 	add	r3,r19,r3
81120390:	10800044 	addi	r2,r2,1
81120394:	41400015 	stw	r5,0(r8)
81120398:	44c00115 	stw	r19,4(r8)
8112039c:	d8c02015 	stw	r3,128(sp)
811203a0:	d8801f15 	stw	r2,124(sp)
811203a4:	010001c4 	movi	r4,7
811203a8:	2082a316 	blt	r4,r2,81120e38 <___vfprintf_internal_r+0x12e0>
811203ac:	df002787 	ldb	fp,158(sp)
811203b0:	42000204 	addi	r8,r8,8
811203b4:	e0000c26 	beq	fp,zero,811203e8 <___vfprintf_internal_r+0x890>
811203b8:	d8801f17 	ldw	r2,124(sp)
811203bc:	d9002784 	addi	r4,sp,158
811203c0:	18c00044 	addi	r3,r3,1
811203c4:	10800044 	addi	r2,r2,1
811203c8:	41000015 	stw	r4,0(r8)
811203cc:	01000044 	movi	r4,1
811203d0:	41000115 	stw	r4,4(r8)
811203d4:	d8c02015 	stw	r3,128(sp)
811203d8:	d8801f15 	stw	r2,124(sp)
811203dc:	010001c4 	movi	r4,7
811203e0:	20823c16 	blt	r4,r2,81120cd4 <___vfprintf_internal_r+0x117c>
811203e4:	42000204 	addi	r8,r8,8
811203e8:	d8802b17 	ldw	r2,172(sp)
811203ec:	10000c26 	beq	r2,zero,81120420 <___vfprintf_internal_r+0x8c8>
811203f0:	d8801f17 	ldw	r2,124(sp)
811203f4:	d9002704 	addi	r4,sp,156
811203f8:	18c00084 	addi	r3,r3,2
811203fc:	10800044 	addi	r2,r2,1
81120400:	41000015 	stw	r4,0(r8)
81120404:	01000084 	movi	r4,2
81120408:	41000115 	stw	r4,4(r8)
8112040c:	d8c02015 	stw	r3,128(sp)
81120410:	d8801f15 	stw	r2,124(sp)
81120414:	010001c4 	movi	r4,7
81120418:	20823616 	blt	r4,r2,81120cf4 <___vfprintf_internal_r+0x119c>
8112041c:	42000204 	addi	r8,r8,8
81120420:	d9003017 	ldw	r4,192(sp)
81120424:	00802004 	movi	r2,128
81120428:	20819926 	beq	r4,r2,81120a90 <___vfprintf_internal_r+0xf38>
8112042c:	d9402917 	ldw	r5,164(sp)
81120430:	d8802e17 	ldw	r2,184(sp)
81120434:	28adc83a 	sub	r22,r5,r2
81120438:	0580310e 	bge	zero,r22,81120500 <___vfprintf_internal_r+0x9a8>
8112043c:	07000404 	movi	fp,16
81120440:	d8801f17 	ldw	r2,124(sp)
81120444:	e584140e 	bge	fp,r22,81121498 <___vfprintf_internal_r+0x1940>
81120448:	01604574 	movhi	r5,33045
8112044c:	296b6984 	addi	r5,r5,-21082
81120450:	dc402915 	stw	r17,164(sp)
81120454:	d9402b15 	stw	r5,172(sp)
81120458:	b023883a 	mov	r17,r22
8112045c:	04c001c4 	movi	r19,7
81120460:	a82d883a 	mov	r22,r21
81120464:	902b883a 	mov	r21,r18
81120468:	8025883a 	mov	r18,r16
8112046c:	dc002c17 	ldw	r16,176(sp)
81120470:	00000306 	br	81120480 <___vfprintf_internal_r+0x928>
81120474:	8c7ffc04 	addi	r17,r17,-16
81120478:	42000204 	addi	r8,r8,8
8112047c:	e440110e 	bge	fp,r17,811204c4 <___vfprintf_internal_r+0x96c>
81120480:	18c00404 	addi	r3,r3,16
81120484:	10800044 	addi	r2,r2,1
81120488:	45000015 	stw	r20,0(r8)
8112048c:	47000115 	stw	fp,4(r8)
81120490:	d8c02015 	stw	r3,128(sp)
81120494:	d8801f15 	stw	r2,124(sp)
81120498:	98bff60e 	bge	r19,r2,81120474 <__reset+0xfb100474>
8112049c:	d9801e04 	addi	r6,sp,120
811204a0:	b80b883a 	mov	r5,r23
811204a4:	8009883a 	mov	r4,r16
811204a8:	112bd480 	call	8112bd48 <__sprint_r>
811204ac:	103eae1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811204b0:	8c7ffc04 	addi	r17,r17,-16
811204b4:	d8c02017 	ldw	r3,128(sp)
811204b8:	d8801f17 	ldw	r2,124(sp)
811204bc:	da000404 	addi	r8,sp,16
811204c0:	e47fef16 	blt	fp,r17,81120480 <__reset+0xfb100480>
811204c4:	9021883a 	mov	r16,r18
811204c8:	a825883a 	mov	r18,r21
811204cc:	b02b883a 	mov	r21,r22
811204d0:	882d883a 	mov	r22,r17
811204d4:	dc402917 	ldw	r17,164(sp)
811204d8:	d9002b17 	ldw	r4,172(sp)
811204dc:	1d87883a 	add	r3,r3,r22
811204e0:	10800044 	addi	r2,r2,1
811204e4:	41000015 	stw	r4,0(r8)
811204e8:	45800115 	stw	r22,4(r8)
811204ec:	d8c02015 	stw	r3,128(sp)
811204f0:	d8801f15 	stw	r2,124(sp)
811204f4:	010001c4 	movi	r4,7
811204f8:	2081ee16 	blt	r4,r2,81120cb4 <___vfprintf_internal_r+0x115c>
811204fc:	42000204 	addi	r8,r8,8
81120500:	9080400c 	andi	r2,r18,256
81120504:	1001181e 	bne	r2,zero,81120968 <___vfprintf_internal_r+0xe10>
81120508:	d9402e17 	ldw	r5,184(sp)
8112050c:	d8801f17 	ldw	r2,124(sp)
81120510:	44000015 	stw	r16,0(r8)
81120514:	1947883a 	add	r3,r3,r5
81120518:	10800044 	addi	r2,r2,1
8112051c:	41400115 	stw	r5,4(r8)
81120520:	d8c02015 	stw	r3,128(sp)
81120524:	d8801f15 	stw	r2,124(sp)
81120528:	010001c4 	movi	r4,7
8112052c:	2081d316 	blt	r4,r2,81120c7c <___vfprintf_internal_r+0x1124>
81120530:	42000204 	addi	r8,r8,8
81120534:	9480010c 	andi	r18,r18,4
81120538:	90003226 	beq	r18,zero,81120604 <___vfprintf_internal_r+0xaac>
8112053c:	d9403117 	ldw	r5,196(sp)
81120540:	d8802a17 	ldw	r2,168(sp)
81120544:	28a1c83a 	sub	r16,r5,r2
81120548:	04002e0e 	bge	zero,r16,81120604 <___vfprintf_internal_r+0xaac>
8112054c:	04400404 	movi	r17,16
81120550:	d8801f17 	ldw	r2,124(sp)
81120554:	8c04a20e 	bge	r17,r16,811217e0 <___vfprintf_internal_r+0x1c88>
81120558:	01604574 	movhi	r5,33045
8112055c:	296b6d84 	addi	r5,r5,-21066
81120560:	d9403515 	stw	r5,212(sp)
81120564:	048001c4 	movi	r18,7
81120568:	dcc02c17 	ldw	r19,176(sp)
8112056c:	00000306 	br	8112057c <___vfprintf_internal_r+0xa24>
81120570:	843ffc04 	addi	r16,r16,-16
81120574:	42000204 	addi	r8,r8,8
81120578:	8c00130e 	bge	r17,r16,811205c8 <___vfprintf_internal_r+0xa70>
8112057c:	01204574 	movhi	r4,33045
81120580:	18c00404 	addi	r3,r3,16
81120584:	10800044 	addi	r2,r2,1
81120588:	212b6d84 	addi	r4,r4,-21066
8112058c:	41000015 	stw	r4,0(r8)
81120590:	44400115 	stw	r17,4(r8)
81120594:	d8c02015 	stw	r3,128(sp)
81120598:	d8801f15 	stw	r2,124(sp)
8112059c:	90bff40e 	bge	r18,r2,81120570 <__reset+0xfb100570>
811205a0:	d9801e04 	addi	r6,sp,120
811205a4:	b80b883a 	mov	r5,r23
811205a8:	9809883a 	mov	r4,r19
811205ac:	112bd480 	call	8112bd48 <__sprint_r>
811205b0:	103e6d1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811205b4:	843ffc04 	addi	r16,r16,-16
811205b8:	d8c02017 	ldw	r3,128(sp)
811205bc:	d8801f17 	ldw	r2,124(sp)
811205c0:	da000404 	addi	r8,sp,16
811205c4:	8c3fed16 	blt	r17,r16,8112057c <__reset+0xfb10057c>
811205c8:	d9403517 	ldw	r5,212(sp)
811205cc:	1c07883a 	add	r3,r3,r16
811205d0:	10800044 	addi	r2,r2,1
811205d4:	41400015 	stw	r5,0(r8)
811205d8:	44000115 	stw	r16,4(r8)
811205dc:	d8c02015 	stw	r3,128(sp)
811205e0:	d8801f15 	stw	r2,124(sp)
811205e4:	010001c4 	movi	r4,7
811205e8:	2080060e 	bge	r4,r2,81120604 <___vfprintf_internal_r+0xaac>
811205ec:	d9002c17 	ldw	r4,176(sp)
811205f0:	d9801e04 	addi	r6,sp,120
811205f4:	b80b883a 	mov	r5,r23
811205f8:	112bd480 	call	8112bd48 <__sprint_r>
811205fc:	103e5a1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120600:	d8c02017 	ldw	r3,128(sp)
81120604:	d8803117 	ldw	r2,196(sp)
81120608:	d9002a17 	ldw	r4,168(sp)
8112060c:	1100010e 	bge	r2,r4,81120614 <___vfprintf_internal_r+0xabc>
81120610:	2005883a 	mov	r2,r4
81120614:	d9402f17 	ldw	r5,188(sp)
81120618:	288b883a 	add	r5,r5,r2
8112061c:	d9402f15 	stw	r5,188(sp)
81120620:	18019e1e 	bne	r3,zero,81120c9c <___vfprintf_internal_r+0x1144>
81120624:	a8800007 	ldb	r2,0(r21)
81120628:	d8001f15 	stw	zero,124(sp)
8112062c:	da000404 	addi	r8,sp,16
81120630:	103d851e 	bne	r2,zero,8111fc48 <__reset+0xfb0ffc48>
81120634:	a821883a 	mov	r16,r21
81120638:	003d9b06 	br	8111fca8 <__reset+0xfb0ffca8>
8112063c:	18c03fcc 	andi	r3,r3,255
81120640:	1805c11e 	bne	r3,zero,81121d48 <___vfprintf_internal_r+0x21f0>
81120644:	94800414 	ori	r18,r18,16
81120648:	9080080c 	andi	r2,r18,32
8112064c:	10020c26 	beq	r2,zero,81120e80 <___vfprintf_internal_r+0x1328>
81120650:	d8802d17 	ldw	r2,180(sp)
81120654:	d9002917 	ldw	r4,164(sp)
81120658:	d8002785 	stb	zero,158(sp)
8112065c:	10c00204 	addi	r3,r2,8
81120660:	14c00017 	ldw	r19,0(r2)
81120664:	15800117 	ldw	r22,4(r2)
81120668:	20040f16 	blt	r4,zero,811216a8 <___vfprintf_internal_r+0x1b50>
8112066c:	013fdfc4 	movi	r4,-129
81120670:	9d84b03a 	or	r2,r19,r22
81120674:	d8c02d15 	stw	r3,180(sp)
81120678:	9124703a 	and	r18,r18,r4
8112067c:	0039883a 	mov	fp,zero
81120680:	103e891e 	bne	r2,zero,811200a8 <__reset+0xfb1000a8>
81120684:	d9002917 	ldw	r4,164(sp)
81120688:	2002c11e 	bne	r4,zero,81121190 <___vfprintf_internal_r+0x1638>
8112068c:	d8002915 	stw	zero,164(sp)
81120690:	d8002e15 	stw	zero,184(sp)
81120694:	dc001e04 	addi	r16,sp,120
81120698:	003ef806 	br	8112027c <__reset+0xfb10027c>
8112069c:	18c03fcc 	andi	r3,r3,255
811206a0:	18059d1e 	bne	r3,zero,81121d18 <___vfprintf_internal_r+0x21c0>
811206a4:	01604574 	movhi	r5,33045
811206a8:	296b5504 	addi	r5,r5,-21164
811206ac:	d9403915 	stw	r5,228(sp)
811206b0:	9080080c 	andi	r2,r18,32
811206b4:	10005226 	beq	r2,zero,81120800 <___vfprintf_internal_r+0xca8>
811206b8:	d8802d17 	ldw	r2,180(sp)
811206bc:	14c00017 	ldw	r19,0(r2)
811206c0:	15800117 	ldw	r22,4(r2)
811206c4:	10800204 	addi	r2,r2,8
811206c8:	d8802d15 	stw	r2,180(sp)
811206cc:	9080004c 	andi	r2,r18,1
811206d0:	10019026 	beq	r2,zero,81120d14 <___vfprintf_internal_r+0x11bc>
811206d4:	9d84b03a 	or	r2,r19,r22
811206d8:	10036926 	beq	r2,zero,81121480 <___vfprintf_internal_r+0x1928>
811206dc:	d8c02917 	ldw	r3,164(sp)
811206e0:	00800c04 	movi	r2,48
811206e4:	d8802705 	stb	r2,156(sp)
811206e8:	dc402745 	stb	r17,157(sp)
811206ec:	d8002785 	stb	zero,158(sp)
811206f0:	90800094 	ori	r2,r18,2
811206f4:	18045d16 	blt	r3,zero,8112186c <___vfprintf_internal_r+0x1d14>
811206f8:	00bfdfc4 	movi	r2,-129
811206fc:	90a4703a 	and	r18,r18,r2
81120700:	94800094 	ori	r18,r18,2
81120704:	0039883a 	mov	fp,zero
81120708:	d9003917 	ldw	r4,228(sp)
8112070c:	dc001e04 	addi	r16,sp,120
81120710:	988003cc 	andi	r2,r19,15
81120714:	b006973a 	slli	r3,r22,28
81120718:	2085883a 	add	r2,r4,r2
8112071c:	9826d13a 	srli	r19,r19,4
81120720:	10800003 	ldbu	r2,0(r2)
81120724:	b02cd13a 	srli	r22,r22,4
81120728:	843fffc4 	addi	r16,r16,-1
8112072c:	1ce6b03a 	or	r19,r3,r19
81120730:	80800005 	stb	r2,0(r16)
81120734:	9d84b03a 	or	r2,r19,r22
81120738:	103ff51e 	bne	r2,zero,81120710 <__reset+0xfb100710>
8112073c:	d8c02817 	ldw	r3,160(sp)
81120740:	1c07c83a 	sub	r3,r3,r16
81120744:	d8c02e15 	stw	r3,184(sp)
81120748:	003ecc06 	br	8112027c <__reset+0xfb10027c>
8112074c:	18c03fcc 	andi	r3,r3,255
81120750:	183e9f26 	beq	r3,zero,811201d0 <__reset+0xfb1001d0>
81120754:	d9c02785 	stb	r7,158(sp)
81120758:	003e9d06 	br	811201d0 <__reset+0xfb1001d0>
8112075c:	00c00044 	movi	r3,1
81120760:	01c00ac4 	movi	r7,43
81120764:	ac400007 	ldb	r17,0(r21)
81120768:	003d5e06 	br	8111fce4 <__reset+0xfb0ffce4>
8112076c:	94800814 	ori	r18,r18,32
81120770:	ac400007 	ldb	r17,0(r21)
81120774:	003d5b06 	br	8111fce4 <__reset+0xfb0ffce4>
81120778:	d8c02d17 	ldw	r3,180(sp)
8112077c:	d8002785 	stb	zero,158(sp)
81120780:	1c000017 	ldw	r16,0(r3)
81120784:	1cc00104 	addi	r19,r3,4
81120788:	80041926 	beq	r16,zero,811217f0 <___vfprintf_internal_r+0x1c98>
8112078c:	d9002917 	ldw	r4,164(sp)
81120790:	2003d016 	blt	r4,zero,811216d4 <___vfprintf_internal_r+0x1b7c>
81120794:	200d883a 	mov	r6,r4
81120798:	000b883a 	mov	r5,zero
8112079c:	8009883a 	mov	r4,r16
811207a0:	da003d15 	stw	r8,244(sp)
811207a4:	1126b3c0 	call	81126b3c <memchr>
811207a8:	da003d17 	ldw	r8,244(sp)
811207ac:	10045426 	beq	r2,zero,81121900 <___vfprintf_internal_r+0x1da8>
811207b0:	1405c83a 	sub	r2,r2,r16
811207b4:	d8802e15 	stw	r2,184(sp)
811207b8:	1003cc16 	blt	r2,zero,811216ec <___vfprintf_internal_r+0x1b94>
811207bc:	df002783 	ldbu	fp,158(sp)
811207c0:	d8802a15 	stw	r2,168(sp)
811207c4:	dcc02d15 	stw	r19,180(sp)
811207c8:	d8002915 	stw	zero,164(sp)
811207cc:	d8003215 	stw	zero,200(sp)
811207d0:	003eb006 	br	81120294 <__reset+0xfb100294>
811207d4:	18c03fcc 	andi	r3,r3,255
811207d8:	183f9b26 	beq	r3,zero,81120648 <__reset+0xfb100648>
811207dc:	d9c02785 	stb	r7,158(sp)
811207e0:	003f9906 	br	81120648 <__reset+0xfb100648>
811207e4:	18c03fcc 	andi	r3,r3,255
811207e8:	1805551e 	bne	r3,zero,81121d40 <___vfprintf_internal_r+0x21e8>
811207ec:	01604574 	movhi	r5,33045
811207f0:	296b5a04 	addi	r5,r5,-21144
811207f4:	d9403915 	stw	r5,228(sp)
811207f8:	9080080c 	andi	r2,r18,32
811207fc:	103fae1e 	bne	r2,zero,811206b8 <__reset+0xfb1006b8>
81120800:	9080040c 	andi	r2,r18,16
81120804:	1002de26 	beq	r2,zero,81121380 <___vfprintf_internal_r+0x1828>
81120808:	d8c02d17 	ldw	r3,180(sp)
8112080c:	002d883a 	mov	r22,zero
81120810:	1cc00017 	ldw	r19,0(r3)
81120814:	18c00104 	addi	r3,r3,4
81120818:	d8c02d15 	stw	r3,180(sp)
8112081c:	003fab06 	br	811206cc <__reset+0xfb1006cc>
81120820:	38803fcc 	andi	r2,r7,255
81120824:	1080201c 	xori	r2,r2,128
81120828:	10bfe004 	addi	r2,r2,-128
8112082c:	1002d21e 	bne	r2,zero,81121378 <___vfprintf_internal_r+0x1820>
81120830:	00c00044 	movi	r3,1
81120834:	01c00804 	movi	r7,32
81120838:	ac400007 	ldb	r17,0(r21)
8112083c:	003d2906 	br	8111fce4 <__reset+0xfb0ffce4>
81120840:	94800054 	ori	r18,r18,1
81120844:	ac400007 	ldb	r17,0(r21)
81120848:	003d2606 	br	8111fce4 <__reset+0xfb0ffce4>
8112084c:	18c03fcc 	andi	r3,r3,255
81120850:	183e0526 	beq	r3,zero,81120068 <__reset+0xfb100068>
81120854:	d9c02785 	stb	r7,158(sp)
81120858:	003e0306 	br	81120068 <__reset+0xfb100068>
8112085c:	94801014 	ori	r18,r18,64
81120860:	ac400007 	ldb	r17,0(r21)
81120864:	003d1f06 	br	8111fce4 <__reset+0xfb0ffce4>
81120868:	ac400007 	ldb	r17,0(r21)
8112086c:	8a438726 	beq	r17,r9,8112168c <___vfprintf_internal_r+0x1b34>
81120870:	94800414 	ori	r18,r18,16
81120874:	003d1b06 	br	8111fce4 <__reset+0xfb0ffce4>
81120878:	18c03fcc 	andi	r3,r3,255
8112087c:	1805341e 	bne	r3,zero,81121d50 <___vfprintf_internal_r+0x21f8>
81120880:	9080080c 	andi	r2,r18,32
81120884:	1002cd26 	beq	r2,zero,811213bc <___vfprintf_internal_r+0x1864>
81120888:	d9402d17 	ldw	r5,180(sp)
8112088c:	d9002f17 	ldw	r4,188(sp)
81120890:	28800017 	ldw	r2,0(r5)
81120894:	2007d7fa 	srai	r3,r4,31
81120898:	29400104 	addi	r5,r5,4
8112089c:	d9402d15 	stw	r5,180(sp)
811208a0:	11000015 	stw	r4,0(r2)
811208a4:	10c00115 	stw	r3,4(r2)
811208a8:	003ce506 	br	8111fc40 <__reset+0xfb0ffc40>
811208ac:	d8c02d17 	ldw	r3,180(sp)
811208b0:	d9002d17 	ldw	r4,180(sp)
811208b4:	d8002785 	stb	zero,158(sp)
811208b8:	18800017 	ldw	r2,0(r3)
811208bc:	21000104 	addi	r4,r4,4
811208c0:	00c00044 	movi	r3,1
811208c4:	d8c02a15 	stw	r3,168(sp)
811208c8:	d8801405 	stb	r2,80(sp)
811208cc:	d9002d15 	stw	r4,180(sp)
811208d0:	d8c02e15 	stw	r3,184(sp)
811208d4:	d8002915 	stw	zero,164(sp)
811208d8:	d8003215 	stw	zero,200(sp)
811208dc:	dc001404 	addi	r16,sp,80
811208e0:	0039883a 	mov	fp,zero
811208e4:	003e7206 	br	811202b0 <__reset+0xfb1002b0>
811208e8:	01204574 	movhi	r4,33045
811208ec:	212b5a04 	addi	r4,r4,-21144
811208f0:	0039883a 	mov	fp,zero
811208f4:	d9003915 	stw	r4,228(sp)
811208f8:	04401e04 	movi	r17,120
811208fc:	003f8206 	br	81120708 <__reset+0xfb100708>
81120900:	18c03fcc 	andi	r3,r3,255
81120904:	1805061e 	bne	r3,zero,81121d20 <___vfprintf_internal_r+0x21c8>
81120908:	883d9126 	beq	r17,zero,8111ff50 <__reset+0xfb0fff50>
8112090c:	00c00044 	movi	r3,1
81120910:	d8c02a15 	stw	r3,168(sp)
81120914:	dc401405 	stb	r17,80(sp)
81120918:	d8002785 	stb	zero,158(sp)
8112091c:	003fec06 	br	811208d0 <__reset+0xfb1008d0>
81120920:	01604574 	movhi	r5,33045
81120924:	296b5a04 	addi	r5,r5,-21144
81120928:	d9403915 	stw	r5,228(sp)
8112092c:	d8c02d15 	stw	r3,180(sp)
81120930:	1025883a 	mov	r18,r2
81120934:	04401e04 	movi	r17,120
81120938:	9d84b03a 	or	r2,r19,r22
8112093c:	1000fc1e 	bne	r2,zero,81120d30 <___vfprintf_internal_r+0x11d8>
81120940:	0039883a 	mov	fp,zero
81120944:	00800084 	movi	r2,2
81120948:	10803fcc 	andi	r2,r2,255
8112094c:	00c00044 	movi	r3,1
81120950:	10c20f26 	beq	r2,r3,81121190 <___vfprintf_internal_r+0x1638>
81120954:	00c00084 	movi	r3,2
81120958:	10fd6326 	beq	r2,r3,8111fee8 <__reset+0xfb0ffee8>
8112095c:	003e2d06 	br	81120214 <__reset+0xfb100214>
81120960:	d8c02017 	ldw	r3,128(sp)
81120964:	003e9306 	br	811203b4 <__reset+0xfb1003b4>
81120968:	00801944 	movi	r2,101
8112096c:	14407e0e 	bge	r2,r17,81120b68 <___vfprintf_internal_r+0x1010>
81120970:	d9003617 	ldw	r4,216(sp)
81120974:	d9403817 	ldw	r5,224(sp)
81120978:	000d883a 	mov	r6,zero
8112097c:	000f883a 	mov	r7,zero
81120980:	d8c03c15 	stw	r3,240(sp)
81120984:	da003d15 	stw	r8,244(sp)
81120988:	11305900 	call	81130590 <__eqdf2>
8112098c:	d8c03c17 	ldw	r3,240(sp)
81120990:	da003d17 	ldw	r8,244(sp)
81120994:	1000f71e 	bne	r2,zero,81120d74 <___vfprintf_internal_r+0x121c>
81120998:	d8801f17 	ldw	r2,124(sp)
8112099c:	01204574 	movhi	r4,33045
811209a0:	212b6104 	addi	r4,r4,-21116
811209a4:	18c00044 	addi	r3,r3,1
811209a8:	10800044 	addi	r2,r2,1
811209ac:	41000015 	stw	r4,0(r8)
811209b0:	01000044 	movi	r4,1
811209b4:	41000115 	stw	r4,4(r8)
811209b8:	d8c02015 	stw	r3,128(sp)
811209bc:	d8801f15 	stw	r2,124(sp)
811209c0:	010001c4 	movi	r4,7
811209c4:	2082b816 	blt	r4,r2,811214a8 <___vfprintf_internal_r+0x1950>
811209c8:	42000204 	addi	r8,r8,8
811209cc:	d8802617 	ldw	r2,152(sp)
811209d0:	d9403317 	ldw	r5,204(sp)
811209d4:	11400216 	blt	r2,r5,811209e0 <___vfprintf_internal_r+0xe88>
811209d8:	9080004c 	andi	r2,r18,1
811209dc:	103ed526 	beq	r2,zero,81120534 <__reset+0xfb100534>
811209e0:	d8803717 	ldw	r2,220(sp)
811209e4:	d9003417 	ldw	r4,208(sp)
811209e8:	d9403717 	ldw	r5,220(sp)
811209ec:	1887883a 	add	r3,r3,r2
811209f0:	d8801f17 	ldw	r2,124(sp)
811209f4:	41000015 	stw	r4,0(r8)
811209f8:	41400115 	stw	r5,4(r8)
811209fc:	10800044 	addi	r2,r2,1
81120a00:	d8c02015 	stw	r3,128(sp)
81120a04:	d8801f15 	stw	r2,124(sp)
81120a08:	010001c4 	movi	r4,7
81120a0c:	20832916 	blt	r4,r2,811216b4 <___vfprintf_internal_r+0x1b5c>
81120a10:	42000204 	addi	r8,r8,8
81120a14:	d8803317 	ldw	r2,204(sp)
81120a18:	143fffc4 	addi	r16,r2,-1
81120a1c:	043ec50e 	bge	zero,r16,81120534 <__reset+0xfb100534>
81120a20:	04400404 	movi	r17,16
81120a24:	d8801f17 	ldw	r2,124(sp)
81120a28:	8c00880e 	bge	r17,r16,81120c4c <___vfprintf_internal_r+0x10f4>
81120a2c:	01604574 	movhi	r5,33045
81120a30:	296b6984 	addi	r5,r5,-21082
81120a34:	d9402b15 	stw	r5,172(sp)
81120a38:	058001c4 	movi	r22,7
81120a3c:	dcc02c17 	ldw	r19,176(sp)
81120a40:	00000306 	br	81120a50 <___vfprintf_internal_r+0xef8>
81120a44:	42000204 	addi	r8,r8,8
81120a48:	843ffc04 	addi	r16,r16,-16
81120a4c:	8c00820e 	bge	r17,r16,81120c58 <___vfprintf_internal_r+0x1100>
81120a50:	18c00404 	addi	r3,r3,16
81120a54:	10800044 	addi	r2,r2,1
81120a58:	45000015 	stw	r20,0(r8)
81120a5c:	44400115 	stw	r17,4(r8)
81120a60:	d8c02015 	stw	r3,128(sp)
81120a64:	d8801f15 	stw	r2,124(sp)
81120a68:	b0bff60e 	bge	r22,r2,81120a44 <__reset+0xfb100a44>
81120a6c:	d9801e04 	addi	r6,sp,120
81120a70:	b80b883a 	mov	r5,r23
81120a74:	9809883a 	mov	r4,r19
81120a78:	112bd480 	call	8112bd48 <__sprint_r>
81120a7c:	103d3a1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120a80:	d8c02017 	ldw	r3,128(sp)
81120a84:	d8801f17 	ldw	r2,124(sp)
81120a88:	da000404 	addi	r8,sp,16
81120a8c:	003fee06 	br	81120a48 <__reset+0xfb100a48>
81120a90:	d9403117 	ldw	r5,196(sp)
81120a94:	d8802a17 	ldw	r2,168(sp)
81120a98:	28adc83a 	sub	r22,r5,r2
81120a9c:	05be630e 	bge	zero,r22,8112042c <__reset+0xfb10042c>
81120aa0:	07000404 	movi	fp,16
81120aa4:	d8801f17 	ldw	r2,124(sp)
81120aa8:	e5838f0e 	bge	fp,r22,811218e8 <___vfprintf_internal_r+0x1d90>
81120aac:	01604574 	movhi	r5,33045
81120ab0:	296b6984 	addi	r5,r5,-21082
81120ab4:	dc403015 	stw	r17,192(sp)
81120ab8:	d9402b15 	stw	r5,172(sp)
81120abc:	b023883a 	mov	r17,r22
81120ac0:	04c001c4 	movi	r19,7
81120ac4:	a82d883a 	mov	r22,r21
81120ac8:	902b883a 	mov	r21,r18
81120acc:	8025883a 	mov	r18,r16
81120ad0:	dc002c17 	ldw	r16,176(sp)
81120ad4:	00000306 	br	81120ae4 <___vfprintf_internal_r+0xf8c>
81120ad8:	8c7ffc04 	addi	r17,r17,-16
81120adc:	42000204 	addi	r8,r8,8
81120ae0:	e440110e 	bge	fp,r17,81120b28 <___vfprintf_internal_r+0xfd0>
81120ae4:	18c00404 	addi	r3,r3,16
81120ae8:	10800044 	addi	r2,r2,1
81120aec:	45000015 	stw	r20,0(r8)
81120af0:	47000115 	stw	fp,4(r8)
81120af4:	d8c02015 	stw	r3,128(sp)
81120af8:	d8801f15 	stw	r2,124(sp)
81120afc:	98bff60e 	bge	r19,r2,81120ad8 <__reset+0xfb100ad8>
81120b00:	d9801e04 	addi	r6,sp,120
81120b04:	b80b883a 	mov	r5,r23
81120b08:	8009883a 	mov	r4,r16
81120b0c:	112bd480 	call	8112bd48 <__sprint_r>
81120b10:	103d151e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120b14:	8c7ffc04 	addi	r17,r17,-16
81120b18:	d8c02017 	ldw	r3,128(sp)
81120b1c:	d8801f17 	ldw	r2,124(sp)
81120b20:	da000404 	addi	r8,sp,16
81120b24:	e47fef16 	blt	fp,r17,81120ae4 <__reset+0xfb100ae4>
81120b28:	9021883a 	mov	r16,r18
81120b2c:	a825883a 	mov	r18,r21
81120b30:	b02b883a 	mov	r21,r22
81120b34:	882d883a 	mov	r22,r17
81120b38:	dc403017 	ldw	r17,192(sp)
81120b3c:	d9002b17 	ldw	r4,172(sp)
81120b40:	1d87883a 	add	r3,r3,r22
81120b44:	10800044 	addi	r2,r2,1
81120b48:	41000015 	stw	r4,0(r8)
81120b4c:	45800115 	stw	r22,4(r8)
81120b50:	d8c02015 	stw	r3,128(sp)
81120b54:	d8801f15 	stw	r2,124(sp)
81120b58:	010001c4 	movi	r4,7
81120b5c:	20818e16 	blt	r4,r2,81121198 <___vfprintf_internal_r+0x1640>
81120b60:	42000204 	addi	r8,r8,8
81120b64:	003e3106 	br	8112042c <__reset+0xfb10042c>
81120b68:	d9403317 	ldw	r5,204(sp)
81120b6c:	00800044 	movi	r2,1
81120b70:	18c00044 	addi	r3,r3,1
81120b74:	1141530e 	bge	r2,r5,811210c4 <___vfprintf_internal_r+0x156c>
81120b78:	dc401f17 	ldw	r17,124(sp)
81120b7c:	00800044 	movi	r2,1
81120b80:	40800115 	stw	r2,4(r8)
81120b84:	8c400044 	addi	r17,r17,1
81120b88:	44000015 	stw	r16,0(r8)
81120b8c:	d8c02015 	stw	r3,128(sp)
81120b90:	dc401f15 	stw	r17,124(sp)
81120b94:	008001c4 	movi	r2,7
81120b98:	14416b16 	blt	r2,r17,81121148 <___vfprintf_internal_r+0x15f0>
81120b9c:	42000204 	addi	r8,r8,8
81120ba0:	d8803717 	ldw	r2,220(sp)
81120ba4:	d9003417 	ldw	r4,208(sp)
81120ba8:	8c400044 	addi	r17,r17,1
81120bac:	10c7883a 	add	r3,r2,r3
81120bb0:	40800115 	stw	r2,4(r8)
81120bb4:	41000015 	stw	r4,0(r8)
81120bb8:	d8c02015 	stw	r3,128(sp)
81120bbc:	dc401f15 	stw	r17,124(sp)
81120bc0:	008001c4 	movi	r2,7
81120bc4:	14416916 	blt	r2,r17,8112116c <___vfprintf_internal_r+0x1614>
81120bc8:	45800204 	addi	r22,r8,8
81120bcc:	d9003617 	ldw	r4,216(sp)
81120bd0:	d9403817 	ldw	r5,224(sp)
81120bd4:	000d883a 	mov	r6,zero
81120bd8:	000f883a 	mov	r7,zero
81120bdc:	d8c03c15 	stw	r3,240(sp)
81120be0:	11305900 	call	81130590 <__eqdf2>
81120be4:	d8c03c17 	ldw	r3,240(sp)
81120be8:	1000bc26 	beq	r2,zero,81120edc <___vfprintf_internal_r+0x1384>
81120bec:	d9403317 	ldw	r5,204(sp)
81120bf0:	84000044 	addi	r16,r16,1
81120bf4:	8c400044 	addi	r17,r17,1
81120bf8:	28bfffc4 	addi	r2,r5,-1
81120bfc:	1887883a 	add	r3,r3,r2
81120c00:	b0800115 	stw	r2,4(r22)
81120c04:	b4000015 	stw	r16,0(r22)
81120c08:	d8c02015 	stw	r3,128(sp)
81120c0c:	dc401f15 	stw	r17,124(sp)
81120c10:	008001c4 	movi	r2,7
81120c14:	14414316 	blt	r2,r17,81121124 <___vfprintf_internal_r+0x15cc>
81120c18:	b5800204 	addi	r22,r22,8
81120c1c:	d9003a17 	ldw	r4,232(sp)
81120c20:	df0022c4 	addi	fp,sp,139
81120c24:	8c400044 	addi	r17,r17,1
81120c28:	20c7883a 	add	r3,r4,r3
81120c2c:	b7000015 	stw	fp,0(r22)
81120c30:	b1000115 	stw	r4,4(r22)
81120c34:	d8c02015 	stw	r3,128(sp)
81120c38:	dc401f15 	stw	r17,124(sp)
81120c3c:	008001c4 	movi	r2,7
81120c40:	14400e16 	blt	r2,r17,81120c7c <___vfprintf_internal_r+0x1124>
81120c44:	b2000204 	addi	r8,r22,8
81120c48:	003e3a06 	br	81120534 <__reset+0xfb100534>
81120c4c:	01204574 	movhi	r4,33045
81120c50:	212b6984 	addi	r4,r4,-21082
81120c54:	d9002b15 	stw	r4,172(sp)
81120c58:	d9002b17 	ldw	r4,172(sp)
81120c5c:	1c07883a 	add	r3,r3,r16
81120c60:	44000115 	stw	r16,4(r8)
81120c64:	41000015 	stw	r4,0(r8)
81120c68:	10800044 	addi	r2,r2,1
81120c6c:	d8c02015 	stw	r3,128(sp)
81120c70:	d8801f15 	stw	r2,124(sp)
81120c74:	010001c4 	movi	r4,7
81120c78:	20be2d0e 	bge	r4,r2,81120530 <__reset+0xfb100530>
81120c7c:	d9002c17 	ldw	r4,176(sp)
81120c80:	d9801e04 	addi	r6,sp,120
81120c84:	b80b883a 	mov	r5,r23
81120c88:	112bd480 	call	8112bd48 <__sprint_r>
81120c8c:	103cb61e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120c90:	d8c02017 	ldw	r3,128(sp)
81120c94:	da000404 	addi	r8,sp,16
81120c98:	003e2606 	br	81120534 <__reset+0xfb100534>
81120c9c:	d9002c17 	ldw	r4,176(sp)
81120ca0:	d9801e04 	addi	r6,sp,120
81120ca4:	b80b883a 	mov	r5,r23
81120ca8:	112bd480 	call	8112bd48 <__sprint_r>
81120cac:	103e5d26 	beq	r2,zero,81120624 <__reset+0xfb100624>
81120cb0:	003cad06 	br	8111ff68 <__reset+0xfb0fff68>
81120cb4:	d9002c17 	ldw	r4,176(sp)
81120cb8:	d9801e04 	addi	r6,sp,120
81120cbc:	b80b883a 	mov	r5,r23
81120cc0:	112bd480 	call	8112bd48 <__sprint_r>
81120cc4:	103ca81e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120cc8:	d8c02017 	ldw	r3,128(sp)
81120ccc:	da000404 	addi	r8,sp,16
81120cd0:	003e0b06 	br	81120500 <__reset+0xfb100500>
81120cd4:	d9002c17 	ldw	r4,176(sp)
81120cd8:	d9801e04 	addi	r6,sp,120
81120cdc:	b80b883a 	mov	r5,r23
81120ce0:	112bd480 	call	8112bd48 <__sprint_r>
81120ce4:	103ca01e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120ce8:	d8c02017 	ldw	r3,128(sp)
81120cec:	da000404 	addi	r8,sp,16
81120cf0:	003dbd06 	br	811203e8 <__reset+0xfb1003e8>
81120cf4:	d9002c17 	ldw	r4,176(sp)
81120cf8:	d9801e04 	addi	r6,sp,120
81120cfc:	b80b883a 	mov	r5,r23
81120d00:	112bd480 	call	8112bd48 <__sprint_r>
81120d04:	103c981e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120d08:	d8c02017 	ldw	r3,128(sp)
81120d0c:	da000404 	addi	r8,sp,16
81120d10:	003dc306 	br	81120420 <__reset+0xfb100420>
81120d14:	d8802917 	ldw	r2,164(sp)
81120d18:	d8002785 	stb	zero,158(sp)
81120d1c:	103f0616 	blt	r2,zero,81120938 <__reset+0xfb100938>
81120d20:	00ffdfc4 	movi	r3,-129
81120d24:	9d84b03a 	or	r2,r19,r22
81120d28:	90e4703a 	and	r18,r18,r3
81120d2c:	103c6b26 	beq	r2,zero,8111fedc <__reset+0xfb0ffedc>
81120d30:	0039883a 	mov	fp,zero
81120d34:	003e7406 	br	81120708 <__reset+0xfb100708>
81120d38:	9080040c 	andi	r2,r18,16
81120d3c:	1001b326 	beq	r2,zero,8112140c <___vfprintf_internal_r+0x18b4>
81120d40:	d9002d17 	ldw	r4,180(sp)
81120d44:	d9402917 	ldw	r5,164(sp)
81120d48:	d8002785 	stb	zero,158(sp)
81120d4c:	20800104 	addi	r2,r4,4
81120d50:	24c00017 	ldw	r19,0(r4)
81120d54:	002d883a 	mov	r22,zero
81120d58:	2801b516 	blt	r5,zero,81121430 <___vfprintf_internal_r+0x18d8>
81120d5c:	00ffdfc4 	movi	r3,-129
81120d60:	d8802d15 	stw	r2,180(sp)
81120d64:	90e4703a 	and	r18,r18,r3
81120d68:	983d2726 	beq	r19,zero,81120208 <__reset+0xfb100208>
81120d6c:	0039883a 	mov	fp,zero
81120d70:	003d2a06 	br	8112021c <__reset+0xfb10021c>
81120d74:	dc402617 	ldw	r17,152(sp)
81120d78:	0441d30e 	bge	zero,r17,811214c8 <___vfprintf_internal_r+0x1970>
81120d7c:	dc403217 	ldw	r17,200(sp)
81120d80:	d8803317 	ldw	r2,204(sp)
81120d84:	1440010e 	bge	r2,r17,81120d8c <___vfprintf_internal_r+0x1234>
81120d88:	1023883a 	mov	r17,r2
81120d8c:	04400a0e 	bge	zero,r17,81120db8 <___vfprintf_internal_r+0x1260>
81120d90:	d8801f17 	ldw	r2,124(sp)
81120d94:	1c47883a 	add	r3,r3,r17
81120d98:	44000015 	stw	r16,0(r8)
81120d9c:	10800044 	addi	r2,r2,1
81120da0:	44400115 	stw	r17,4(r8)
81120da4:	d8c02015 	stw	r3,128(sp)
81120da8:	d8801f15 	stw	r2,124(sp)
81120dac:	010001c4 	movi	r4,7
81120db0:	20826516 	blt	r4,r2,81121748 <___vfprintf_internal_r+0x1bf0>
81120db4:	42000204 	addi	r8,r8,8
81120db8:	88026116 	blt	r17,zero,81121740 <___vfprintf_internal_r+0x1be8>
81120dbc:	d9003217 	ldw	r4,200(sp)
81120dc0:	2463c83a 	sub	r17,r4,r17
81120dc4:	04407b0e 	bge	zero,r17,81120fb4 <___vfprintf_internal_r+0x145c>
81120dc8:	05800404 	movi	r22,16
81120dcc:	d8801f17 	ldw	r2,124(sp)
81120dd0:	b4419d0e 	bge	r22,r17,81121448 <___vfprintf_internal_r+0x18f0>
81120dd4:	01204574 	movhi	r4,33045
81120dd8:	212b6984 	addi	r4,r4,-21082
81120ddc:	d9002b15 	stw	r4,172(sp)
81120de0:	070001c4 	movi	fp,7
81120de4:	dcc02c17 	ldw	r19,176(sp)
81120de8:	00000306 	br	81120df8 <___vfprintf_internal_r+0x12a0>
81120dec:	42000204 	addi	r8,r8,8
81120df0:	8c7ffc04 	addi	r17,r17,-16
81120df4:	b441970e 	bge	r22,r17,81121454 <___vfprintf_internal_r+0x18fc>
81120df8:	18c00404 	addi	r3,r3,16
81120dfc:	10800044 	addi	r2,r2,1
81120e00:	45000015 	stw	r20,0(r8)
81120e04:	45800115 	stw	r22,4(r8)
81120e08:	d8c02015 	stw	r3,128(sp)
81120e0c:	d8801f15 	stw	r2,124(sp)
81120e10:	e0bff60e 	bge	fp,r2,81120dec <__reset+0xfb100dec>
81120e14:	d9801e04 	addi	r6,sp,120
81120e18:	b80b883a 	mov	r5,r23
81120e1c:	9809883a 	mov	r4,r19
81120e20:	112bd480 	call	8112bd48 <__sprint_r>
81120e24:	103c501e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120e28:	d8c02017 	ldw	r3,128(sp)
81120e2c:	d8801f17 	ldw	r2,124(sp)
81120e30:	da000404 	addi	r8,sp,16
81120e34:	003fee06 	br	81120df0 <__reset+0xfb100df0>
81120e38:	d9002c17 	ldw	r4,176(sp)
81120e3c:	d9801e04 	addi	r6,sp,120
81120e40:	b80b883a 	mov	r5,r23
81120e44:	112bd480 	call	8112bd48 <__sprint_r>
81120e48:	103c471e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120e4c:	d8c02017 	ldw	r3,128(sp)
81120e50:	df002787 	ldb	fp,158(sp)
81120e54:	da000404 	addi	r8,sp,16
81120e58:	003d5606 	br	811203b4 <__reset+0xfb1003b4>
81120e5c:	9080040c 	andi	r2,r18,16
81120e60:	10016126 	beq	r2,zero,811213e8 <___vfprintf_internal_r+0x1890>
81120e64:	d8802d17 	ldw	r2,180(sp)
81120e68:	14c00017 	ldw	r19,0(r2)
81120e6c:	10800104 	addi	r2,r2,4
81120e70:	d8802d15 	stw	r2,180(sp)
81120e74:	982dd7fa 	srai	r22,r19,31
81120e78:	b005883a 	mov	r2,r22
81120e7c:	003c8206 	br	81120088 <__reset+0xfb100088>
81120e80:	9080040c 	andi	r2,r18,16
81120e84:	10003526 	beq	r2,zero,81120f5c <___vfprintf_internal_r+0x1404>
81120e88:	d9402d17 	ldw	r5,180(sp)
81120e8c:	d8c02917 	ldw	r3,164(sp)
81120e90:	d8002785 	stb	zero,158(sp)
81120e94:	28800104 	addi	r2,r5,4
81120e98:	2cc00017 	ldw	r19,0(r5)
81120e9c:	002d883a 	mov	r22,zero
81120ea0:	18003716 	blt	r3,zero,81120f80 <___vfprintf_internal_r+0x1428>
81120ea4:	00ffdfc4 	movi	r3,-129
81120ea8:	d8802d15 	stw	r2,180(sp)
81120eac:	90e4703a 	and	r18,r18,r3
81120eb0:	0039883a 	mov	fp,zero
81120eb4:	983df326 	beq	r19,zero,81120684 <__reset+0xfb100684>
81120eb8:	00800244 	movi	r2,9
81120ebc:	14fc7b36 	bltu	r2,r19,811200ac <__reset+0xfb1000ac>
81120ec0:	d8c02817 	ldw	r3,160(sp)
81120ec4:	dc001dc4 	addi	r16,sp,119
81120ec8:	9cc00c04 	addi	r19,r19,48
81120ecc:	1c07c83a 	sub	r3,r3,r16
81120ed0:	dcc01dc5 	stb	r19,119(sp)
81120ed4:	d8c02e15 	stw	r3,184(sp)
81120ed8:	003ce806 	br	8112027c <__reset+0xfb10027c>
81120edc:	d8803317 	ldw	r2,204(sp)
81120ee0:	143fffc4 	addi	r16,r2,-1
81120ee4:	043f4d0e 	bge	zero,r16,81120c1c <__reset+0xfb100c1c>
81120ee8:	07000404 	movi	fp,16
81120eec:	e400810e 	bge	fp,r16,811210f4 <___vfprintf_internal_r+0x159c>
81120ef0:	01604574 	movhi	r5,33045
81120ef4:	296b6984 	addi	r5,r5,-21082
81120ef8:	d9402b15 	stw	r5,172(sp)
81120efc:	01c001c4 	movi	r7,7
81120f00:	dcc02c17 	ldw	r19,176(sp)
81120f04:	00000306 	br	81120f14 <___vfprintf_internal_r+0x13bc>
81120f08:	b5800204 	addi	r22,r22,8
81120f0c:	843ffc04 	addi	r16,r16,-16
81120f10:	e4007b0e 	bge	fp,r16,81121100 <___vfprintf_internal_r+0x15a8>
81120f14:	18c00404 	addi	r3,r3,16
81120f18:	8c400044 	addi	r17,r17,1
81120f1c:	b5000015 	stw	r20,0(r22)
81120f20:	b7000115 	stw	fp,4(r22)
81120f24:	d8c02015 	stw	r3,128(sp)
81120f28:	dc401f15 	stw	r17,124(sp)
81120f2c:	3c7ff60e 	bge	r7,r17,81120f08 <__reset+0xfb100f08>
81120f30:	d9801e04 	addi	r6,sp,120
81120f34:	b80b883a 	mov	r5,r23
81120f38:	9809883a 	mov	r4,r19
81120f3c:	d9c03c15 	stw	r7,240(sp)
81120f40:	112bd480 	call	8112bd48 <__sprint_r>
81120f44:	d9c03c17 	ldw	r7,240(sp)
81120f48:	103c071e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120f4c:	d8c02017 	ldw	r3,128(sp)
81120f50:	dc401f17 	ldw	r17,124(sp)
81120f54:	dd800404 	addi	r22,sp,16
81120f58:	003fec06 	br	81120f0c <__reset+0xfb100f0c>
81120f5c:	9080100c 	andi	r2,r18,64
81120f60:	d8002785 	stb	zero,158(sp)
81120f64:	10010e26 	beq	r2,zero,811213a0 <___vfprintf_internal_r+0x1848>
81120f68:	d9002d17 	ldw	r4,180(sp)
81120f6c:	d9402917 	ldw	r5,164(sp)
81120f70:	002d883a 	mov	r22,zero
81120f74:	20800104 	addi	r2,r4,4
81120f78:	24c0000b 	ldhu	r19,0(r4)
81120f7c:	283fc90e 	bge	r5,zero,81120ea4 <__reset+0xfb100ea4>
81120f80:	d8802d15 	stw	r2,180(sp)
81120f84:	0039883a 	mov	fp,zero
81120f88:	9d84b03a 	or	r2,r19,r22
81120f8c:	103c461e 	bne	r2,zero,811200a8 <__reset+0xfb1000a8>
81120f90:	00800044 	movi	r2,1
81120f94:	003e6c06 	br	81120948 <__reset+0xfb100948>
81120f98:	d9002c17 	ldw	r4,176(sp)
81120f9c:	d9801e04 	addi	r6,sp,120
81120fa0:	b80b883a 	mov	r5,r23
81120fa4:	112bd480 	call	8112bd48 <__sprint_r>
81120fa8:	103bef1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81120fac:	d8c02017 	ldw	r3,128(sp)
81120fb0:	da000404 	addi	r8,sp,16
81120fb4:	d9003217 	ldw	r4,200(sp)
81120fb8:	d8802617 	ldw	r2,152(sp)
81120fbc:	d9403317 	ldw	r5,204(sp)
81120fc0:	8123883a 	add	r17,r16,r4
81120fc4:	11400216 	blt	r2,r5,81120fd0 <___vfprintf_internal_r+0x1478>
81120fc8:	9100004c 	andi	r4,r18,1
81120fcc:	20000d26 	beq	r4,zero,81121004 <___vfprintf_internal_r+0x14ac>
81120fd0:	d9003717 	ldw	r4,220(sp)
81120fd4:	d9403417 	ldw	r5,208(sp)
81120fd8:	1907883a 	add	r3,r3,r4
81120fdc:	d9001f17 	ldw	r4,124(sp)
81120fe0:	41400015 	stw	r5,0(r8)
81120fe4:	d9403717 	ldw	r5,220(sp)
81120fe8:	21000044 	addi	r4,r4,1
81120fec:	d8c02015 	stw	r3,128(sp)
81120ff0:	41400115 	stw	r5,4(r8)
81120ff4:	d9001f15 	stw	r4,124(sp)
81120ff8:	014001c4 	movi	r5,7
81120ffc:	2901e816 	blt	r5,r4,811217a0 <___vfprintf_internal_r+0x1c48>
81121000:	42000204 	addi	r8,r8,8
81121004:	d9003317 	ldw	r4,204(sp)
81121008:	8121883a 	add	r16,r16,r4
8112100c:	2085c83a 	sub	r2,r4,r2
81121010:	8461c83a 	sub	r16,r16,r17
81121014:	1400010e 	bge	r2,r16,8112101c <___vfprintf_internal_r+0x14c4>
81121018:	1021883a 	mov	r16,r2
8112101c:	04000a0e 	bge	zero,r16,81121048 <___vfprintf_internal_r+0x14f0>
81121020:	d9001f17 	ldw	r4,124(sp)
81121024:	1c07883a 	add	r3,r3,r16
81121028:	44400015 	stw	r17,0(r8)
8112102c:	21000044 	addi	r4,r4,1
81121030:	44000115 	stw	r16,4(r8)
81121034:	d8c02015 	stw	r3,128(sp)
81121038:	d9001f15 	stw	r4,124(sp)
8112103c:	014001c4 	movi	r5,7
81121040:	2901fb16 	blt	r5,r4,81121830 <___vfprintf_internal_r+0x1cd8>
81121044:	42000204 	addi	r8,r8,8
81121048:	8001f716 	blt	r16,zero,81121828 <___vfprintf_internal_r+0x1cd0>
8112104c:	1421c83a 	sub	r16,r2,r16
81121050:	043d380e 	bge	zero,r16,81120534 <__reset+0xfb100534>
81121054:	04400404 	movi	r17,16
81121058:	d8801f17 	ldw	r2,124(sp)
8112105c:	8c3efb0e 	bge	r17,r16,81120c4c <__reset+0xfb100c4c>
81121060:	01604574 	movhi	r5,33045
81121064:	296b6984 	addi	r5,r5,-21082
81121068:	d9402b15 	stw	r5,172(sp)
8112106c:	058001c4 	movi	r22,7
81121070:	dcc02c17 	ldw	r19,176(sp)
81121074:	00000306 	br	81121084 <___vfprintf_internal_r+0x152c>
81121078:	42000204 	addi	r8,r8,8
8112107c:	843ffc04 	addi	r16,r16,-16
81121080:	8c3ef50e 	bge	r17,r16,81120c58 <__reset+0xfb100c58>
81121084:	18c00404 	addi	r3,r3,16
81121088:	10800044 	addi	r2,r2,1
8112108c:	45000015 	stw	r20,0(r8)
81121090:	44400115 	stw	r17,4(r8)
81121094:	d8c02015 	stw	r3,128(sp)
81121098:	d8801f15 	stw	r2,124(sp)
8112109c:	b0bff60e 	bge	r22,r2,81121078 <__reset+0xfb101078>
811210a0:	d9801e04 	addi	r6,sp,120
811210a4:	b80b883a 	mov	r5,r23
811210a8:	9809883a 	mov	r4,r19
811210ac:	112bd480 	call	8112bd48 <__sprint_r>
811210b0:	103bad1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811210b4:	d8c02017 	ldw	r3,128(sp)
811210b8:	d8801f17 	ldw	r2,124(sp)
811210bc:	da000404 	addi	r8,sp,16
811210c0:	003fee06 	br	8112107c <__reset+0xfb10107c>
811210c4:	9088703a 	and	r4,r18,r2
811210c8:	203eab1e 	bne	r4,zero,81120b78 <__reset+0xfb100b78>
811210cc:	dc401f17 	ldw	r17,124(sp)
811210d0:	40800115 	stw	r2,4(r8)
811210d4:	44000015 	stw	r16,0(r8)
811210d8:	8c400044 	addi	r17,r17,1
811210dc:	d8c02015 	stw	r3,128(sp)
811210e0:	dc401f15 	stw	r17,124(sp)
811210e4:	008001c4 	movi	r2,7
811210e8:	14400e16 	blt	r2,r17,81121124 <___vfprintf_internal_r+0x15cc>
811210ec:	45800204 	addi	r22,r8,8
811210f0:	003eca06 	br	81120c1c <__reset+0xfb100c1c>
811210f4:	01204574 	movhi	r4,33045
811210f8:	212b6984 	addi	r4,r4,-21082
811210fc:	d9002b15 	stw	r4,172(sp)
81121100:	d8802b17 	ldw	r2,172(sp)
81121104:	1c07883a 	add	r3,r3,r16
81121108:	8c400044 	addi	r17,r17,1
8112110c:	b0800015 	stw	r2,0(r22)
81121110:	b4000115 	stw	r16,4(r22)
81121114:	d8c02015 	stw	r3,128(sp)
81121118:	dc401f15 	stw	r17,124(sp)
8112111c:	008001c4 	movi	r2,7
81121120:	147ebd0e 	bge	r2,r17,81120c18 <__reset+0xfb100c18>
81121124:	d9002c17 	ldw	r4,176(sp)
81121128:	d9801e04 	addi	r6,sp,120
8112112c:	b80b883a 	mov	r5,r23
81121130:	112bd480 	call	8112bd48 <__sprint_r>
81121134:	103b8c1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81121138:	d8c02017 	ldw	r3,128(sp)
8112113c:	dc401f17 	ldw	r17,124(sp)
81121140:	dd800404 	addi	r22,sp,16
81121144:	003eb506 	br	81120c1c <__reset+0xfb100c1c>
81121148:	d9002c17 	ldw	r4,176(sp)
8112114c:	d9801e04 	addi	r6,sp,120
81121150:	b80b883a 	mov	r5,r23
81121154:	112bd480 	call	8112bd48 <__sprint_r>
81121158:	103b831e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
8112115c:	d8c02017 	ldw	r3,128(sp)
81121160:	dc401f17 	ldw	r17,124(sp)
81121164:	da000404 	addi	r8,sp,16
81121168:	003e8d06 	br	81120ba0 <__reset+0xfb100ba0>
8112116c:	d9002c17 	ldw	r4,176(sp)
81121170:	d9801e04 	addi	r6,sp,120
81121174:	b80b883a 	mov	r5,r23
81121178:	112bd480 	call	8112bd48 <__sprint_r>
8112117c:	103b7a1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81121180:	d8c02017 	ldw	r3,128(sp)
81121184:	dc401f17 	ldw	r17,124(sp)
81121188:	dd800404 	addi	r22,sp,16
8112118c:	003e8f06 	br	81120bcc <__reset+0xfb100bcc>
81121190:	0027883a 	mov	r19,zero
81121194:	003f4a06 	br	81120ec0 <__reset+0xfb100ec0>
81121198:	d9002c17 	ldw	r4,176(sp)
8112119c:	d9801e04 	addi	r6,sp,120
811211a0:	b80b883a 	mov	r5,r23
811211a4:	112bd480 	call	8112bd48 <__sprint_r>
811211a8:	103b6f1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811211ac:	d8c02017 	ldw	r3,128(sp)
811211b0:	da000404 	addi	r8,sp,16
811211b4:	003c9d06 	br	8112042c <__reset+0xfb10042c>
811211b8:	04e7c83a 	sub	r19,zero,r19
811211bc:	9804c03a 	cmpne	r2,r19,zero
811211c0:	05adc83a 	sub	r22,zero,r22
811211c4:	b0adc83a 	sub	r22,r22,r2
811211c8:	d8802917 	ldw	r2,164(sp)
811211cc:	07000b44 	movi	fp,45
811211d0:	df002785 	stb	fp,158(sp)
811211d4:	10017b16 	blt	r2,zero,811217c4 <___vfprintf_internal_r+0x1c6c>
811211d8:	00bfdfc4 	movi	r2,-129
811211dc:	90a4703a 	and	r18,r18,r2
811211e0:	003bb106 	br	811200a8 <__reset+0xfb1000a8>
811211e4:	d9003617 	ldw	r4,216(sp)
811211e8:	d9403817 	ldw	r5,224(sp)
811211ec:	da003d15 	stw	r8,244(sp)
811211f0:	11283ac0 	call	811283ac <__fpclassifyd>
811211f4:	da003d17 	ldw	r8,244(sp)
811211f8:	1000f026 	beq	r2,zero,811215bc <___vfprintf_internal_r+0x1a64>
811211fc:	d9002917 	ldw	r4,164(sp)
81121200:	05bff7c4 	movi	r22,-33
81121204:	00bfffc4 	movi	r2,-1
81121208:	8dac703a 	and	r22,r17,r22
8112120c:	20820026 	beq	r4,r2,81121a10 <___vfprintf_internal_r+0x1eb8>
81121210:	008011c4 	movi	r2,71
81121214:	b081f726 	beq	r22,r2,811219f4 <___vfprintf_internal_r+0x1e9c>
81121218:	d9003817 	ldw	r4,224(sp)
8112121c:	90c04014 	ori	r3,r18,256
81121220:	d8c02b15 	stw	r3,172(sp)
81121224:	20021516 	blt	r4,zero,81121a7c <___vfprintf_internal_r+0x1f24>
81121228:	dcc03817 	ldw	r19,224(sp)
8112122c:	d8002a05 	stb	zero,168(sp)
81121230:	00801984 	movi	r2,102
81121234:	8881f926 	beq	r17,r2,81121a1c <___vfprintf_internal_r+0x1ec4>
81121238:	00801184 	movi	r2,70
8112123c:	88821c26 	beq	r17,r2,81121ab0 <___vfprintf_internal_r+0x1f58>
81121240:	00801144 	movi	r2,69
81121244:	b081ef26 	beq	r22,r2,81121a04 <___vfprintf_internal_r+0x1eac>
81121248:	d8c02917 	ldw	r3,164(sp)
8112124c:	d8802104 	addi	r2,sp,132
81121250:	d8800315 	stw	r2,12(sp)
81121254:	d9403617 	ldw	r5,216(sp)
81121258:	d8802504 	addi	r2,sp,148
8112125c:	d9002c17 	ldw	r4,176(sp)
81121260:	d8800215 	stw	r2,8(sp)
81121264:	d8802604 	addi	r2,sp,152
81121268:	d8c00015 	stw	r3,0(sp)
8112126c:	d8800115 	stw	r2,4(sp)
81121270:	01c00084 	movi	r7,2
81121274:	980d883a 	mov	r6,r19
81121278:	d8c03c15 	stw	r3,240(sp)
8112127c:	da003d15 	stw	r8,244(sp)
81121280:	1123c640 	call	81123c64 <_dtoa_r>
81121284:	1021883a 	mov	r16,r2
81121288:	008019c4 	movi	r2,103
8112128c:	d8c03c17 	ldw	r3,240(sp)
81121290:	da003d17 	ldw	r8,244(sp)
81121294:	88817126 	beq	r17,r2,8112185c <___vfprintf_internal_r+0x1d04>
81121298:	008011c4 	movi	r2,71
8112129c:	88829226 	beq	r17,r2,81121ce8 <___vfprintf_internal_r+0x2190>
811212a0:	80f9883a 	add	fp,r16,r3
811212a4:	d9003617 	ldw	r4,216(sp)
811212a8:	000d883a 	mov	r6,zero
811212ac:	000f883a 	mov	r7,zero
811212b0:	980b883a 	mov	r5,r19
811212b4:	da003d15 	stw	r8,244(sp)
811212b8:	11305900 	call	81130590 <__eqdf2>
811212bc:	da003d17 	ldw	r8,244(sp)
811212c0:	10018d26 	beq	r2,zero,811218f8 <___vfprintf_internal_r+0x1da0>
811212c4:	d8802117 	ldw	r2,132(sp)
811212c8:	1700062e 	bgeu	r2,fp,811212e4 <___vfprintf_internal_r+0x178c>
811212cc:	01000c04 	movi	r4,48
811212d0:	10c00044 	addi	r3,r2,1
811212d4:	d8c02115 	stw	r3,132(sp)
811212d8:	11000005 	stb	r4,0(r2)
811212dc:	d8802117 	ldw	r2,132(sp)
811212e0:	173ffb36 	bltu	r2,fp,811212d0 <__reset+0xfb1012d0>
811212e4:	1405c83a 	sub	r2,r2,r16
811212e8:	d8803315 	stw	r2,204(sp)
811212ec:	008011c4 	movi	r2,71
811212f0:	b0817626 	beq	r22,r2,811218cc <___vfprintf_internal_r+0x1d74>
811212f4:	00801944 	movi	r2,101
811212f8:	1442810e 	bge	r2,r17,81121d00 <___vfprintf_internal_r+0x21a8>
811212fc:	d8c02617 	ldw	r3,152(sp)
81121300:	00801984 	movi	r2,102
81121304:	d8c03215 	stw	r3,200(sp)
81121308:	8881fe26 	beq	r17,r2,81121b04 <___vfprintf_internal_r+0x1fac>
8112130c:	d8c03217 	ldw	r3,200(sp)
81121310:	d9003317 	ldw	r4,204(sp)
81121314:	1901dd16 	blt	r3,r4,81121a8c <___vfprintf_internal_r+0x1f34>
81121318:	9480004c 	andi	r18,r18,1
8112131c:	90022b1e 	bne	r18,zero,81121bcc <___vfprintf_internal_r+0x2074>
81121320:	1805883a 	mov	r2,r3
81121324:	18028016 	blt	r3,zero,81121d28 <___vfprintf_internal_r+0x21d0>
81121328:	d8c03217 	ldw	r3,200(sp)
8112132c:	044019c4 	movi	r17,103
81121330:	d8c02e15 	stw	r3,184(sp)
81121334:	df002a07 	ldb	fp,168(sp)
81121338:	e001531e 	bne	fp,zero,81121888 <___vfprintf_internal_r+0x1d30>
8112133c:	df002783 	ldbu	fp,158(sp)
81121340:	d8802a15 	stw	r2,168(sp)
81121344:	dc802b17 	ldw	r18,172(sp)
81121348:	d8002915 	stw	zero,164(sp)
8112134c:	003bd106 	br	81120294 <__reset+0xfb100294>
81121350:	d8802d17 	ldw	r2,180(sp)
81121354:	d8c02d17 	ldw	r3,180(sp)
81121358:	d9002d17 	ldw	r4,180(sp)
8112135c:	10800017 	ldw	r2,0(r2)
81121360:	18c00117 	ldw	r3,4(r3)
81121364:	21000204 	addi	r4,r4,8
81121368:	d8803615 	stw	r2,216(sp)
8112136c:	d8c03815 	stw	r3,224(sp)
81121370:	d9002d15 	stw	r4,180(sp)
81121374:	003b7506 	br	8112014c <__reset+0xfb10014c>
81121378:	ac400007 	ldb	r17,0(r21)
8112137c:	003a5906 	br	8111fce4 <__reset+0xfb0ffce4>
81121380:	9080100c 	andi	r2,r18,64
81121384:	1000a826 	beq	r2,zero,81121628 <___vfprintf_internal_r+0x1ad0>
81121388:	d9002d17 	ldw	r4,180(sp)
8112138c:	002d883a 	mov	r22,zero
81121390:	24c0000b 	ldhu	r19,0(r4)
81121394:	21000104 	addi	r4,r4,4
81121398:	d9002d15 	stw	r4,180(sp)
8112139c:	003ccb06 	br	811206cc <__reset+0xfb1006cc>
811213a0:	d8c02d17 	ldw	r3,180(sp)
811213a4:	d9002917 	ldw	r4,164(sp)
811213a8:	002d883a 	mov	r22,zero
811213ac:	18800104 	addi	r2,r3,4
811213b0:	1cc00017 	ldw	r19,0(r3)
811213b4:	203ebb0e 	bge	r4,zero,81120ea4 <__reset+0xfb100ea4>
811213b8:	003ef106 	br	81120f80 <__reset+0xfb100f80>
811213bc:	9080040c 	andi	r2,r18,16
811213c0:	1000921e 	bne	r2,zero,8112160c <___vfprintf_internal_r+0x1ab4>
811213c4:	9480100c 	andi	r18,r18,64
811213c8:	90013926 	beq	r18,zero,811218b0 <___vfprintf_internal_r+0x1d58>
811213cc:	d9002d17 	ldw	r4,180(sp)
811213d0:	d9402f17 	ldw	r5,188(sp)
811213d4:	20800017 	ldw	r2,0(r4)
811213d8:	21000104 	addi	r4,r4,4
811213dc:	d9002d15 	stw	r4,180(sp)
811213e0:	1140000d 	sth	r5,0(r2)
811213e4:	003a1606 	br	8111fc40 <__reset+0xfb0ffc40>
811213e8:	9080100c 	andi	r2,r18,64
811213ec:	10008026 	beq	r2,zero,811215f0 <___vfprintf_internal_r+0x1a98>
811213f0:	d8c02d17 	ldw	r3,180(sp)
811213f4:	1cc0000f 	ldh	r19,0(r3)
811213f8:	18c00104 	addi	r3,r3,4
811213fc:	d8c02d15 	stw	r3,180(sp)
81121400:	982dd7fa 	srai	r22,r19,31
81121404:	b005883a 	mov	r2,r22
81121408:	003b1f06 	br	81120088 <__reset+0xfb100088>
8112140c:	9080100c 	andi	r2,r18,64
81121410:	d8002785 	stb	zero,158(sp)
81121414:	10008a1e 	bne	r2,zero,81121640 <___vfprintf_internal_r+0x1ae8>
81121418:	d9402d17 	ldw	r5,180(sp)
8112141c:	d8c02917 	ldw	r3,164(sp)
81121420:	002d883a 	mov	r22,zero
81121424:	28800104 	addi	r2,r5,4
81121428:	2cc00017 	ldw	r19,0(r5)
8112142c:	183e4b0e 	bge	r3,zero,81120d5c <__reset+0xfb100d5c>
81121430:	9d86b03a 	or	r3,r19,r22
81121434:	d8802d15 	stw	r2,180(sp)
81121438:	183e4c1e 	bne	r3,zero,81120d6c <__reset+0xfb100d6c>
8112143c:	0039883a 	mov	fp,zero
81121440:	0005883a 	mov	r2,zero
81121444:	003d4006 	br	81120948 <__reset+0xfb100948>
81121448:	01604574 	movhi	r5,33045
8112144c:	296b6984 	addi	r5,r5,-21082
81121450:	d9402b15 	stw	r5,172(sp)
81121454:	d9402b17 	ldw	r5,172(sp)
81121458:	1c47883a 	add	r3,r3,r17
8112145c:	10800044 	addi	r2,r2,1
81121460:	41400015 	stw	r5,0(r8)
81121464:	44400115 	stw	r17,4(r8)
81121468:	d8c02015 	stw	r3,128(sp)
8112146c:	d8801f15 	stw	r2,124(sp)
81121470:	010001c4 	movi	r4,7
81121474:	20bec816 	blt	r4,r2,81120f98 <__reset+0xfb100f98>
81121478:	42000204 	addi	r8,r8,8
8112147c:	003ecd06 	br	81120fb4 <__reset+0xfb100fb4>
81121480:	d9002917 	ldw	r4,164(sp)
81121484:	d8002785 	stb	zero,158(sp)
81121488:	203d2d16 	blt	r4,zero,81120940 <__reset+0xfb100940>
8112148c:	00bfdfc4 	movi	r2,-129
81121490:	90a4703a 	and	r18,r18,r2
81121494:	003a9106 	br	8111fedc <__reset+0xfb0ffedc>
81121498:	01204574 	movhi	r4,33045
8112149c:	212b6984 	addi	r4,r4,-21082
811214a0:	d9002b15 	stw	r4,172(sp)
811214a4:	003c0c06 	br	811204d8 <__reset+0xfb1004d8>
811214a8:	d9002c17 	ldw	r4,176(sp)
811214ac:	d9801e04 	addi	r6,sp,120
811214b0:	b80b883a 	mov	r5,r23
811214b4:	112bd480 	call	8112bd48 <__sprint_r>
811214b8:	103aab1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811214bc:	d8c02017 	ldw	r3,128(sp)
811214c0:	da000404 	addi	r8,sp,16
811214c4:	003d4106 	br	811209cc <__reset+0xfb1009cc>
811214c8:	d8801f17 	ldw	r2,124(sp)
811214cc:	01604574 	movhi	r5,33045
811214d0:	01000044 	movi	r4,1
811214d4:	18c00044 	addi	r3,r3,1
811214d8:	10800044 	addi	r2,r2,1
811214dc:	296b6104 	addi	r5,r5,-21116
811214e0:	41000115 	stw	r4,4(r8)
811214e4:	41400015 	stw	r5,0(r8)
811214e8:	d8c02015 	stw	r3,128(sp)
811214ec:	d8801f15 	stw	r2,124(sp)
811214f0:	010001c4 	movi	r4,7
811214f4:	20805c16 	blt	r4,r2,81121668 <___vfprintf_internal_r+0x1b10>
811214f8:	42000204 	addi	r8,r8,8
811214fc:	8800041e 	bne	r17,zero,81121510 <___vfprintf_internal_r+0x19b8>
81121500:	d8803317 	ldw	r2,204(sp)
81121504:	1000021e 	bne	r2,zero,81121510 <___vfprintf_internal_r+0x19b8>
81121508:	9080004c 	andi	r2,r18,1
8112150c:	103c0926 	beq	r2,zero,81120534 <__reset+0xfb100534>
81121510:	d9003717 	ldw	r4,220(sp)
81121514:	d8801f17 	ldw	r2,124(sp)
81121518:	d9403417 	ldw	r5,208(sp)
8112151c:	20c7883a 	add	r3,r4,r3
81121520:	10800044 	addi	r2,r2,1
81121524:	41000115 	stw	r4,4(r8)
81121528:	41400015 	stw	r5,0(r8)
8112152c:	d8c02015 	stw	r3,128(sp)
81121530:	d8801f15 	stw	r2,124(sp)
81121534:	010001c4 	movi	r4,7
81121538:	20812116 	blt	r4,r2,811219c0 <___vfprintf_internal_r+0x1e68>
8112153c:	42000204 	addi	r8,r8,8
81121540:	0463c83a 	sub	r17,zero,r17
81121544:	0440730e 	bge	zero,r17,81121714 <___vfprintf_internal_r+0x1bbc>
81121548:	05800404 	movi	r22,16
8112154c:	b440860e 	bge	r22,r17,81121768 <___vfprintf_internal_r+0x1c10>
81121550:	01604574 	movhi	r5,33045
81121554:	296b6984 	addi	r5,r5,-21082
81121558:	d9402b15 	stw	r5,172(sp)
8112155c:	070001c4 	movi	fp,7
81121560:	dcc02c17 	ldw	r19,176(sp)
81121564:	00000306 	br	81121574 <___vfprintf_internal_r+0x1a1c>
81121568:	42000204 	addi	r8,r8,8
8112156c:	8c7ffc04 	addi	r17,r17,-16
81121570:	b440800e 	bge	r22,r17,81121774 <___vfprintf_internal_r+0x1c1c>
81121574:	18c00404 	addi	r3,r3,16
81121578:	10800044 	addi	r2,r2,1
8112157c:	45000015 	stw	r20,0(r8)
81121580:	45800115 	stw	r22,4(r8)
81121584:	d8c02015 	stw	r3,128(sp)
81121588:	d8801f15 	stw	r2,124(sp)
8112158c:	e0bff60e 	bge	fp,r2,81121568 <__reset+0xfb101568>
81121590:	d9801e04 	addi	r6,sp,120
81121594:	b80b883a 	mov	r5,r23
81121598:	9809883a 	mov	r4,r19
8112159c:	112bd480 	call	8112bd48 <__sprint_r>
811215a0:	103a711e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811215a4:	d8c02017 	ldw	r3,128(sp)
811215a8:	d8801f17 	ldw	r2,124(sp)
811215ac:	da000404 	addi	r8,sp,16
811215b0:	003fee06 	br	8112156c <__reset+0xfb10156c>
811215b4:	00bfffc4 	movi	r2,-1
811215b8:	003a6f06 	br	8111ff78 <__reset+0xfb0fff78>
811215bc:	008011c4 	movi	r2,71
811215c0:	1440b816 	blt	r2,r17,811218a4 <___vfprintf_internal_r+0x1d4c>
811215c4:	04204574 	movhi	r16,33045
811215c8:	842b5304 	addi	r16,r16,-21172
811215cc:	00c000c4 	movi	r3,3
811215d0:	00bfdfc4 	movi	r2,-129
811215d4:	d8c02a15 	stw	r3,168(sp)
811215d8:	90a4703a 	and	r18,r18,r2
811215dc:	df002783 	ldbu	fp,158(sp)
811215e0:	d8c02e15 	stw	r3,184(sp)
811215e4:	d8002915 	stw	zero,164(sp)
811215e8:	d8003215 	stw	zero,200(sp)
811215ec:	003b2906 	br	81120294 <__reset+0xfb100294>
811215f0:	d9002d17 	ldw	r4,180(sp)
811215f4:	24c00017 	ldw	r19,0(r4)
811215f8:	21000104 	addi	r4,r4,4
811215fc:	d9002d15 	stw	r4,180(sp)
81121600:	982dd7fa 	srai	r22,r19,31
81121604:	b005883a 	mov	r2,r22
81121608:	003a9f06 	br	81120088 <__reset+0xfb100088>
8112160c:	d9402d17 	ldw	r5,180(sp)
81121610:	d8c02f17 	ldw	r3,188(sp)
81121614:	28800017 	ldw	r2,0(r5)
81121618:	29400104 	addi	r5,r5,4
8112161c:	d9402d15 	stw	r5,180(sp)
81121620:	10c00015 	stw	r3,0(r2)
81121624:	00398606 	br	8111fc40 <__reset+0xfb0ffc40>
81121628:	d9402d17 	ldw	r5,180(sp)
8112162c:	002d883a 	mov	r22,zero
81121630:	2cc00017 	ldw	r19,0(r5)
81121634:	29400104 	addi	r5,r5,4
81121638:	d9402d15 	stw	r5,180(sp)
8112163c:	003c2306 	br	811206cc <__reset+0xfb1006cc>
81121640:	d8c02d17 	ldw	r3,180(sp)
81121644:	d9002917 	ldw	r4,164(sp)
81121648:	002d883a 	mov	r22,zero
8112164c:	18800104 	addi	r2,r3,4
81121650:	1cc0000b 	ldhu	r19,0(r3)
81121654:	203dc10e 	bge	r4,zero,81120d5c <__reset+0xfb100d5c>
81121658:	003f7506 	br	81121430 <__reset+0xfb101430>
8112165c:	04204574 	movhi	r16,33045
81121660:	842b5104 	addi	r16,r16,-21180
81121664:	003acc06 	br	81120198 <__reset+0xfb100198>
81121668:	d9002c17 	ldw	r4,176(sp)
8112166c:	d9801e04 	addi	r6,sp,120
81121670:	b80b883a 	mov	r5,r23
81121674:	112bd480 	call	8112bd48 <__sprint_r>
81121678:	103a3b1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
8112167c:	dc402617 	ldw	r17,152(sp)
81121680:	d8c02017 	ldw	r3,128(sp)
81121684:	da000404 	addi	r8,sp,16
81121688:	003f9c06 	br	811214fc <__reset+0xfb1014fc>
8112168c:	ac400043 	ldbu	r17,1(r21)
81121690:	94800814 	ori	r18,r18,32
81121694:	ad400044 	addi	r21,r21,1
81121698:	8c403fcc 	andi	r17,r17,255
8112169c:	8c40201c 	xori	r17,r17,128
811216a0:	8c7fe004 	addi	r17,r17,-128
811216a4:	00398f06 	br	8111fce4 <__reset+0xfb0ffce4>
811216a8:	d8c02d15 	stw	r3,180(sp)
811216ac:	0039883a 	mov	fp,zero
811216b0:	003e3506 	br	81120f88 <__reset+0xfb100f88>
811216b4:	d9002c17 	ldw	r4,176(sp)
811216b8:	d9801e04 	addi	r6,sp,120
811216bc:	b80b883a 	mov	r5,r23
811216c0:	112bd480 	call	8112bd48 <__sprint_r>
811216c4:	103a281e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811216c8:	d8c02017 	ldw	r3,128(sp)
811216cc:	da000404 	addi	r8,sp,16
811216d0:	003cd006 	br	81120a14 <__reset+0xfb100a14>
811216d4:	8009883a 	mov	r4,r16
811216d8:	da003d15 	stw	r8,244(sp)
811216dc:	111d6400 	call	8111d640 <strlen>
811216e0:	d8802e15 	stw	r2,184(sp)
811216e4:	da003d17 	ldw	r8,244(sp)
811216e8:	103c340e 	bge	r2,zero,811207bc <__reset+0xfb1007bc>
811216ec:	0005883a 	mov	r2,zero
811216f0:	003c3206 	br	811207bc <__reset+0xfb1007bc>
811216f4:	d9002c17 	ldw	r4,176(sp)
811216f8:	d9801e04 	addi	r6,sp,120
811216fc:	b80b883a 	mov	r5,r23
81121700:	112bd480 	call	8112bd48 <__sprint_r>
81121704:	103a181e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81121708:	d8c02017 	ldw	r3,128(sp)
8112170c:	d8801f17 	ldw	r2,124(sp)
81121710:	da000404 	addi	r8,sp,16
81121714:	d9403317 	ldw	r5,204(sp)
81121718:	10800044 	addi	r2,r2,1
8112171c:	44000015 	stw	r16,0(r8)
81121720:	28c7883a 	add	r3,r5,r3
81121724:	003b7d06 	br	8112051c <__reset+0xfb10051c>
81121728:	01204574 	movhi	r4,33045
8112172c:	212b6d84 	addi	r4,r4,-21066
81121730:	d9003515 	stw	r4,212(sp)
81121734:	003b1406 	br	81120388 <__reset+0xfb100388>
81121738:	013fffc4 	movi	r4,-1
8112173c:	003a3506 	br	81120014 <__reset+0xfb100014>
81121740:	0023883a 	mov	r17,zero
81121744:	003d9d06 	br	81120dbc <__reset+0xfb100dbc>
81121748:	d9002c17 	ldw	r4,176(sp)
8112174c:	d9801e04 	addi	r6,sp,120
81121750:	b80b883a 	mov	r5,r23
81121754:	112bd480 	call	8112bd48 <__sprint_r>
81121758:	103a031e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
8112175c:	d8c02017 	ldw	r3,128(sp)
81121760:	da000404 	addi	r8,sp,16
81121764:	003d9406 	br	81120db8 <__reset+0xfb100db8>
81121768:	01204574 	movhi	r4,33045
8112176c:	212b6984 	addi	r4,r4,-21082
81121770:	d9002b15 	stw	r4,172(sp)
81121774:	d9002b17 	ldw	r4,172(sp)
81121778:	1c47883a 	add	r3,r3,r17
8112177c:	10800044 	addi	r2,r2,1
81121780:	41000015 	stw	r4,0(r8)
81121784:	44400115 	stw	r17,4(r8)
81121788:	d8c02015 	stw	r3,128(sp)
8112178c:	d8801f15 	stw	r2,124(sp)
81121790:	010001c4 	movi	r4,7
81121794:	20bfd716 	blt	r4,r2,811216f4 <__reset+0xfb1016f4>
81121798:	42000204 	addi	r8,r8,8
8112179c:	003fdd06 	br	81121714 <__reset+0xfb101714>
811217a0:	d9002c17 	ldw	r4,176(sp)
811217a4:	d9801e04 	addi	r6,sp,120
811217a8:	b80b883a 	mov	r5,r23
811217ac:	112bd480 	call	8112bd48 <__sprint_r>
811217b0:	1039ed1e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811217b4:	d8802617 	ldw	r2,152(sp)
811217b8:	d8c02017 	ldw	r3,128(sp)
811217bc:	da000404 	addi	r8,sp,16
811217c0:	003e1006 	br	81121004 <__reset+0xfb101004>
811217c4:	00800044 	movi	r2,1
811217c8:	10803fcc 	andi	r2,r2,255
811217cc:	00c00044 	movi	r3,1
811217d0:	10fa3526 	beq	r2,r3,811200a8 <__reset+0xfb1000a8>
811217d4:	00c00084 	movi	r3,2
811217d8:	10fbcb26 	beq	r2,r3,81120708 <__reset+0xfb100708>
811217dc:	003a8f06 	br	8112021c <__reset+0xfb10021c>
811217e0:	01204574 	movhi	r4,33045
811217e4:	212b6d84 	addi	r4,r4,-21066
811217e8:	d9003515 	stw	r4,212(sp)
811217ec:	003b7606 	br	811205c8 <__reset+0xfb1005c8>
811217f0:	d8802917 	ldw	r2,164(sp)
811217f4:	00c00184 	movi	r3,6
811217f8:	1880012e 	bgeu	r3,r2,81121800 <___vfprintf_internal_r+0x1ca8>
811217fc:	1805883a 	mov	r2,r3
81121800:	d8802e15 	stw	r2,184(sp)
81121804:	1000ef16 	blt	r2,zero,81121bc4 <___vfprintf_internal_r+0x206c>
81121808:	04204574 	movhi	r16,33045
8112180c:	d8802a15 	stw	r2,168(sp)
81121810:	dcc02d15 	stw	r19,180(sp)
81121814:	d8002915 	stw	zero,164(sp)
81121818:	d8003215 	stw	zero,200(sp)
8112181c:	842b5f04 	addi	r16,r16,-21124
81121820:	0039883a 	mov	fp,zero
81121824:	003aa206 	br	811202b0 <__reset+0xfb1002b0>
81121828:	0021883a 	mov	r16,zero
8112182c:	003e0706 	br	8112104c <__reset+0xfb10104c>
81121830:	d9002c17 	ldw	r4,176(sp)
81121834:	d9801e04 	addi	r6,sp,120
81121838:	b80b883a 	mov	r5,r23
8112183c:	112bd480 	call	8112bd48 <__sprint_r>
81121840:	1039c91e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
81121844:	d8802617 	ldw	r2,152(sp)
81121848:	d9403317 	ldw	r5,204(sp)
8112184c:	d8c02017 	ldw	r3,128(sp)
81121850:	da000404 	addi	r8,sp,16
81121854:	2885c83a 	sub	r2,r5,r2
81121858:	003dfb06 	br	81121048 <__reset+0xfb101048>
8112185c:	9080004c 	andi	r2,r18,1
81121860:	103e8f1e 	bne	r2,zero,811212a0 <__reset+0xfb1012a0>
81121864:	d8802117 	ldw	r2,132(sp)
81121868:	003e9e06 	br	811212e4 <__reset+0xfb1012e4>
8112186c:	1025883a 	mov	r18,r2
81121870:	0039883a 	mov	fp,zero
81121874:	00800084 	movi	r2,2
81121878:	003fd306 	br	811217c8 <__reset+0xfb1017c8>
8112187c:	07000b44 	movi	fp,45
81121880:	df002785 	stb	fp,158(sp)
81121884:	003a4006 	br	81120188 <__reset+0xfb100188>
81121888:	00c00b44 	movi	r3,45
8112188c:	d8c02785 	stb	r3,158(sp)
81121890:	d8802a15 	stw	r2,168(sp)
81121894:	dc802b17 	ldw	r18,172(sp)
81121898:	d8002915 	stw	zero,164(sp)
8112189c:	07000b44 	movi	fp,45
811218a0:	003a8006 	br	811202a4 <__reset+0xfb1002a4>
811218a4:	04204574 	movhi	r16,33045
811218a8:	842b5404 	addi	r16,r16,-21168
811218ac:	003f4706 	br	811215cc <__reset+0xfb1015cc>
811218b0:	d8c02d17 	ldw	r3,180(sp)
811218b4:	d9002f17 	ldw	r4,188(sp)
811218b8:	18800017 	ldw	r2,0(r3)
811218bc:	18c00104 	addi	r3,r3,4
811218c0:	d8c02d15 	stw	r3,180(sp)
811218c4:	11000015 	stw	r4,0(r2)
811218c8:	0038dd06 	br	8111fc40 <__reset+0xfb0ffc40>
811218cc:	dd802617 	ldw	r22,152(sp)
811218d0:	00bfff44 	movi	r2,-3
811218d4:	b0801c16 	blt	r22,r2,81121948 <___vfprintf_internal_r+0x1df0>
811218d8:	d9402917 	ldw	r5,164(sp)
811218dc:	2d801a16 	blt	r5,r22,81121948 <___vfprintf_internal_r+0x1df0>
811218e0:	dd803215 	stw	r22,200(sp)
811218e4:	003e8906 	br	8112130c <__reset+0xfb10130c>
811218e8:	01204574 	movhi	r4,33045
811218ec:	212b6984 	addi	r4,r4,-21082
811218f0:	d9002b15 	stw	r4,172(sp)
811218f4:	003c9106 	br	81120b3c <__reset+0xfb100b3c>
811218f8:	e005883a 	mov	r2,fp
811218fc:	003e7906 	br	811212e4 <__reset+0xfb1012e4>
81121900:	d9402917 	ldw	r5,164(sp)
81121904:	df002783 	ldbu	fp,158(sp)
81121908:	dcc02d15 	stw	r19,180(sp)
8112190c:	d9402a15 	stw	r5,168(sp)
81121910:	d9402e15 	stw	r5,184(sp)
81121914:	d8002915 	stw	zero,164(sp)
81121918:	d8003215 	stw	zero,200(sp)
8112191c:	003a5d06 	br	81120294 <__reset+0xfb100294>
81121920:	9080004c 	andi	r2,r18,1
81121924:	0039883a 	mov	fp,zero
81121928:	10000426 	beq	r2,zero,8112193c <___vfprintf_internal_r+0x1de4>
8112192c:	00800c04 	movi	r2,48
81121930:	dc001dc4 	addi	r16,sp,119
81121934:	d8801dc5 	stb	r2,119(sp)
81121938:	003b8006 	br	8112073c <__reset+0xfb10073c>
8112193c:	d8002e15 	stw	zero,184(sp)
81121940:	dc001e04 	addi	r16,sp,120
81121944:	003a4d06 	br	8112027c <__reset+0xfb10027c>
81121948:	8c7fff84 	addi	r17,r17,-2
8112194c:	b5bfffc4 	addi	r22,r22,-1
81121950:	dd802615 	stw	r22,152(sp)
81121954:	dc4022c5 	stb	r17,139(sp)
81121958:	b000bf16 	blt	r22,zero,81121c58 <___vfprintf_internal_r+0x2100>
8112195c:	00800ac4 	movi	r2,43
81121960:	d8802305 	stb	r2,140(sp)
81121964:	00800244 	movi	r2,9
81121968:	15807016 	blt	r2,r22,81121b2c <___vfprintf_internal_r+0x1fd4>
8112196c:	00800c04 	movi	r2,48
81121970:	b5800c04 	addi	r22,r22,48
81121974:	d8802345 	stb	r2,141(sp)
81121978:	dd802385 	stb	r22,142(sp)
8112197c:	d88023c4 	addi	r2,sp,143
81121980:	df0022c4 	addi	fp,sp,139
81121984:	d8c03317 	ldw	r3,204(sp)
81121988:	1739c83a 	sub	fp,r2,fp
8112198c:	d9003317 	ldw	r4,204(sp)
81121990:	e0c7883a 	add	r3,fp,r3
81121994:	df003a15 	stw	fp,232(sp)
81121998:	d8c02e15 	stw	r3,184(sp)
8112199c:	00800044 	movi	r2,1
811219a0:	1100b30e 	bge	r2,r4,81121c70 <___vfprintf_internal_r+0x2118>
811219a4:	d8c02e17 	ldw	r3,184(sp)
811219a8:	18c00044 	addi	r3,r3,1
811219ac:	d8c02e15 	stw	r3,184(sp)
811219b0:	1805883a 	mov	r2,r3
811219b4:	1800ac16 	blt	r3,zero,81121c68 <___vfprintf_internal_r+0x2110>
811219b8:	d8003215 	stw	zero,200(sp)
811219bc:	003e5d06 	br	81121334 <__reset+0xfb101334>
811219c0:	d9002c17 	ldw	r4,176(sp)
811219c4:	d9801e04 	addi	r6,sp,120
811219c8:	b80b883a 	mov	r5,r23
811219cc:	112bd480 	call	8112bd48 <__sprint_r>
811219d0:	1039651e 	bne	r2,zero,8111ff68 <__reset+0xfb0fff68>
811219d4:	dc402617 	ldw	r17,152(sp)
811219d8:	d8c02017 	ldw	r3,128(sp)
811219dc:	d8801f17 	ldw	r2,124(sp)
811219e0:	da000404 	addi	r8,sp,16
811219e4:	003ed606 	br	81121540 <__reset+0xfb101540>
811219e8:	582b883a 	mov	r21,r11
811219ec:	d8002915 	stw	zero,164(sp)
811219f0:	0038bd06 	br	8111fce8 <__reset+0xfb0ffce8>
811219f4:	d8802917 	ldw	r2,164(sp)
811219f8:	103e071e 	bne	r2,zero,81121218 <__reset+0xfb101218>
811219fc:	dc002915 	stw	r16,164(sp)
81121a00:	003e0506 	br	81121218 <__reset+0xfb101218>
81121a04:	d9002917 	ldw	r4,164(sp)
81121a08:	20c00044 	addi	r3,r4,1
81121a0c:	003e0f06 	br	8112124c <__reset+0xfb10124c>
81121a10:	01400184 	movi	r5,6
81121a14:	d9402915 	stw	r5,164(sp)
81121a18:	003dff06 	br	81121218 <__reset+0xfb101218>
81121a1c:	d8802104 	addi	r2,sp,132
81121a20:	d8800315 	stw	r2,12(sp)
81121a24:	d8802504 	addi	r2,sp,148
81121a28:	d8800215 	stw	r2,8(sp)
81121a2c:	d8802604 	addi	r2,sp,152
81121a30:	d8800115 	stw	r2,4(sp)
81121a34:	d8802917 	ldw	r2,164(sp)
81121a38:	d9403617 	ldw	r5,216(sp)
81121a3c:	d9002c17 	ldw	r4,176(sp)
81121a40:	d8800015 	stw	r2,0(sp)
81121a44:	01c000c4 	movi	r7,3
81121a48:	980d883a 	mov	r6,r19
81121a4c:	da003d15 	stw	r8,244(sp)
81121a50:	1123c640 	call	81123c64 <_dtoa_r>
81121a54:	d8c02917 	ldw	r3,164(sp)
81121a58:	da003d17 	ldw	r8,244(sp)
81121a5c:	1021883a 	mov	r16,r2
81121a60:	10f9883a 	add	fp,r2,r3
81121a64:	81000007 	ldb	r4,0(r16)
81121a68:	00800c04 	movi	r2,48
81121a6c:	20805e26 	beq	r4,r2,81121be8 <___vfprintf_internal_r+0x2090>
81121a70:	d8c02617 	ldw	r3,152(sp)
81121a74:	e0f9883a 	add	fp,fp,r3
81121a78:	003e0a06 	br	811212a4 <__reset+0xfb1012a4>
81121a7c:	00c00b44 	movi	r3,45
81121a80:	24e0003c 	xorhi	r19,r4,32768
81121a84:	d8c02a05 	stb	r3,168(sp)
81121a88:	003de906 	br	81121230 <__reset+0xfb101230>
81121a8c:	d8c03217 	ldw	r3,200(sp)
81121a90:	00c07a0e 	bge	zero,r3,81121c7c <___vfprintf_internal_r+0x2124>
81121a94:	00800044 	movi	r2,1
81121a98:	d9003317 	ldw	r4,204(sp)
81121a9c:	1105883a 	add	r2,r2,r4
81121aa0:	d8802e15 	stw	r2,184(sp)
81121aa4:	10004e16 	blt	r2,zero,81121be0 <___vfprintf_internal_r+0x2088>
81121aa8:	044019c4 	movi	r17,103
81121aac:	003e2106 	br	81121334 <__reset+0xfb101334>
81121ab0:	d9002917 	ldw	r4,164(sp)
81121ab4:	d8802104 	addi	r2,sp,132
81121ab8:	d8800315 	stw	r2,12(sp)
81121abc:	d9000015 	stw	r4,0(sp)
81121ac0:	d8802504 	addi	r2,sp,148
81121ac4:	d9403617 	ldw	r5,216(sp)
81121ac8:	d9002c17 	ldw	r4,176(sp)
81121acc:	d8800215 	stw	r2,8(sp)
81121ad0:	d8802604 	addi	r2,sp,152
81121ad4:	d8800115 	stw	r2,4(sp)
81121ad8:	01c000c4 	movi	r7,3
81121adc:	980d883a 	mov	r6,r19
81121ae0:	da003d15 	stw	r8,244(sp)
81121ae4:	1123c640 	call	81123c64 <_dtoa_r>
81121ae8:	d8c02917 	ldw	r3,164(sp)
81121aec:	da003d17 	ldw	r8,244(sp)
81121af0:	1021883a 	mov	r16,r2
81121af4:	00801184 	movi	r2,70
81121af8:	80f9883a 	add	fp,r16,r3
81121afc:	88bfd926 	beq	r17,r2,81121a64 <__reset+0xfb101a64>
81121b00:	003de806 	br	811212a4 <__reset+0xfb1012a4>
81121b04:	d9002917 	ldw	r4,164(sp)
81121b08:	00c04d0e 	bge	zero,r3,81121c40 <___vfprintf_internal_r+0x20e8>
81121b0c:	2000441e 	bne	r4,zero,81121c20 <___vfprintf_internal_r+0x20c8>
81121b10:	9480004c 	andi	r18,r18,1
81121b14:	9000421e 	bne	r18,zero,81121c20 <___vfprintf_internal_r+0x20c8>
81121b18:	1805883a 	mov	r2,r3
81121b1c:	18007016 	blt	r3,zero,81121ce0 <___vfprintf_internal_r+0x2188>
81121b20:	d8c03217 	ldw	r3,200(sp)
81121b24:	d8c02e15 	stw	r3,184(sp)
81121b28:	003e0206 	br	81121334 <__reset+0xfb101334>
81121b2c:	df0022c4 	addi	fp,sp,139
81121b30:	dc002915 	stw	r16,164(sp)
81121b34:	4027883a 	mov	r19,r8
81121b38:	e021883a 	mov	r16,fp
81121b3c:	b009883a 	mov	r4,r22
81121b40:	01400284 	movi	r5,10
81121b44:	112f0c00 	call	8112f0c0 <__modsi3>
81121b48:	10800c04 	addi	r2,r2,48
81121b4c:	843fffc4 	addi	r16,r16,-1
81121b50:	b009883a 	mov	r4,r22
81121b54:	01400284 	movi	r5,10
81121b58:	80800005 	stb	r2,0(r16)
81121b5c:	112f03c0 	call	8112f03c <__divsi3>
81121b60:	102d883a 	mov	r22,r2
81121b64:	00800244 	movi	r2,9
81121b68:	15bff416 	blt	r2,r22,81121b3c <__reset+0xfb101b3c>
81121b6c:	9811883a 	mov	r8,r19
81121b70:	b0800c04 	addi	r2,r22,48
81121b74:	8027883a 	mov	r19,r16
81121b78:	997fffc4 	addi	r5,r19,-1
81121b7c:	98bfffc5 	stb	r2,-1(r19)
81121b80:	dc002917 	ldw	r16,164(sp)
81121b84:	2f006a2e 	bgeu	r5,fp,81121d30 <___vfprintf_internal_r+0x21d8>
81121b88:	d9c02384 	addi	r7,sp,142
81121b8c:	3ccfc83a 	sub	r7,r7,r19
81121b90:	d9002344 	addi	r4,sp,141
81121b94:	e1cf883a 	add	r7,fp,r7
81121b98:	00000106 	br	81121ba0 <___vfprintf_internal_r+0x2048>
81121b9c:	28800003 	ldbu	r2,0(r5)
81121ba0:	20800005 	stb	r2,0(r4)
81121ba4:	21000044 	addi	r4,r4,1
81121ba8:	29400044 	addi	r5,r5,1
81121bac:	393ffb1e 	bne	r7,r4,81121b9c <__reset+0xfb101b9c>
81121bb0:	d8802304 	addi	r2,sp,140
81121bb4:	14c5c83a 	sub	r2,r2,r19
81121bb8:	d8c02344 	addi	r3,sp,141
81121bbc:	1885883a 	add	r2,r3,r2
81121bc0:	003f7006 	br	81121984 <__reset+0xfb101984>
81121bc4:	0005883a 	mov	r2,zero
81121bc8:	003f0f06 	br	81121808 <__reset+0xfb101808>
81121bcc:	d8c03217 	ldw	r3,200(sp)
81121bd0:	18c00044 	addi	r3,r3,1
81121bd4:	d8c02e15 	stw	r3,184(sp)
81121bd8:	1805883a 	mov	r2,r3
81121bdc:	183fb20e 	bge	r3,zero,81121aa8 <__reset+0xfb101aa8>
81121be0:	0005883a 	mov	r2,zero
81121be4:	003fb006 	br	81121aa8 <__reset+0xfb101aa8>
81121be8:	d9003617 	ldw	r4,216(sp)
81121bec:	000d883a 	mov	r6,zero
81121bf0:	000f883a 	mov	r7,zero
81121bf4:	980b883a 	mov	r5,r19
81121bf8:	d8c03c15 	stw	r3,240(sp)
81121bfc:	da003d15 	stw	r8,244(sp)
81121c00:	11305900 	call	81130590 <__eqdf2>
81121c04:	d8c03c17 	ldw	r3,240(sp)
81121c08:	da003d17 	ldw	r8,244(sp)
81121c0c:	103f9826 	beq	r2,zero,81121a70 <__reset+0xfb101a70>
81121c10:	00800044 	movi	r2,1
81121c14:	10c7c83a 	sub	r3,r2,r3
81121c18:	d8c02615 	stw	r3,152(sp)
81121c1c:	003f9506 	br	81121a74 <__reset+0xfb101a74>
81121c20:	d9002917 	ldw	r4,164(sp)
81121c24:	d8c03217 	ldw	r3,200(sp)
81121c28:	20800044 	addi	r2,r4,1
81121c2c:	1885883a 	add	r2,r3,r2
81121c30:	d8802e15 	stw	r2,184(sp)
81121c34:	103dbf0e 	bge	r2,zero,81121334 <__reset+0xfb101334>
81121c38:	0005883a 	mov	r2,zero
81121c3c:	003dbd06 	br	81121334 <__reset+0xfb101334>
81121c40:	2000211e 	bne	r4,zero,81121cc8 <___vfprintf_internal_r+0x2170>
81121c44:	9480004c 	andi	r18,r18,1
81121c48:	90001f1e 	bne	r18,zero,81121cc8 <___vfprintf_internal_r+0x2170>
81121c4c:	00800044 	movi	r2,1
81121c50:	d8802e15 	stw	r2,184(sp)
81121c54:	003db706 	br	81121334 <__reset+0xfb101334>
81121c58:	00800b44 	movi	r2,45
81121c5c:	05adc83a 	sub	r22,zero,r22
81121c60:	d8802305 	stb	r2,140(sp)
81121c64:	003f3f06 	br	81121964 <__reset+0xfb101964>
81121c68:	0005883a 	mov	r2,zero
81121c6c:	003f5206 	br	811219b8 <__reset+0xfb1019b8>
81121c70:	90a4703a 	and	r18,r18,r2
81121c74:	903f4e26 	beq	r18,zero,811219b0 <__reset+0xfb1019b0>
81121c78:	003f4a06 	br	811219a4 <__reset+0xfb1019a4>
81121c7c:	00800084 	movi	r2,2
81121c80:	10c5c83a 	sub	r2,r2,r3
81121c84:	003f8406 	br	81121a98 <__reset+0xfb101a98>
81121c88:	d8802d17 	ldw	r2,180(sp)
81121c8c:	d9002d17 	ldw	r4,180(sp)
81121c90:	ac400043 	ldbu	r17,1(r21)
81121c94:	10800017 	ldw	r2,0(r2)
81121c98:	582b883a 	mov	r21,r11
81121c9c:	d8802915 	stw	r2,164(sp)
81121ca0:	20800104 	addi	r2,r4,4
81121ca4:	d9002917 	ldw	r4,164(sp)
81121ca8:	d8802d15 	stw	r2,180(sp)
81121cac:	203e7a0e 	bge	r4,zero,81121698 <__reset+0xfb101698>
81121cb0:	8c403fcc 	andi	r17,r17,255
81121cb4:	00bfffc4 	movi	r2,-1
81121cb8:	8c40201c 	xori	r17,r17,128
81121cbc:	d8802915 	stw	r2,164(sp)
81121cc0:	8c7fe004 	addi	r17,r17,-128
81121cc4:	00380706 	br	8111fce4 <__reset+0xfb0ffce4>
81121cc8:	d8c02917 	ldw	r3,164(sp)
81121ccc:	18c00084 	addi	r3,r3,2
81121cd0:	d8c02e15 	stw	r3,184(sp)
81121cd4:	1805883a 	mov	r2,r3
81121cd8:	183d960e 	bge	r3,zero,81121334 <__reset+0xfb101334>
81121cdc:	003fd606 	br	81121c38 <__reset+0xfb101c38>
81121ce0:	0005883a 	mov	r2,zero
81121ce4:	003f8e06 	br	81121b20 <__reset+0xfb101b20>
81121ce8:	9080004c 	andi	r2,r18,1
81121cec:	103f811e 	bne	r2,zero,81121af4 <__reset+0xfb101af4>
81121cf0:	d8802117 	ldw	r2,132(sp)
81121cf4:	1405c83a 	sub	r2,r2,r16
81121cf8:	d8803315 	stw	r2,204(sp)
81121cfc:	b47ef326 	beq	r22,r17,811218cc <__reset+0xfb1018cc>
81121d00:	dd802617 	ldw	r22,152(sp)
81121d04:	003f1106 	br	8112194c <__reset+0xfb10194c>
81121d08:	d9c02785 	stb	r7,158(sp)
81121d0c:	00390406 	br	81120120 <__reset+0xfb100120>
81121d10:	d9c02785 	stb	r7,158(sp)
81121d14:	0038d306 	br	81120064 <__reset+0xfb100064>
81121d18:	d9c02785 	stb	r7,158(sp)
81121d1c:	003a6106 	br	811206a4 <__reset+0xfb1006a4>
81121d20:	d9c02785 	stb	r7,158(sp)
81121d24:	003af806 	br	81120908 <__reset+0xfb100908>
81121d28:	0005883a 	mov	r2,zero
81121d2c:	003d7e06 	br	81121328 <__reset+0xfb101328>
81121d30:	d8802344 	addi	r2,sp,141
81121d34:	003f1306 	br	81121984 <__reset+0xfb101984>
81121d38:	d9c02785 	stb	r7,158(sp)
81121d3c:	00392306 	br	811201cc <__reset+0xfb1001cc>
81121d40:	d9c02785 	stb	r7,158(sp)
81121d44:	003aa906 	br	811207ec <__reset+0xfb1007ec>
81121d48:	d9c02785 	stb	r7,158(sp)
81121d4c:	003a3d06 	br	81120644 <__reset+0xfb100644>
81121d50:	d9c02785 	stb	r7,158(sp)
81121d54:	003aca06 	br	81120880 <__reset+0xfb100880>

81121d58 <__vfprintf_internal>:
81121d58:	00a04574 	movhi	r2,33045
81121d5c:	10b52904 	addi	r2,r2,-11100
81121d60:	300f883a 	mov	r7,r6
81121d64:	280d883a 	mov	r6,r5
81121d68:	200b883a 	mov	r5,r4
81121d6c:	11000017 	ldw	r4,0(r2)
81121d70:	111fb581 	jmpi	8111fb58 <___vfprintf_internal_r>

81121d74 <__sbprintf>:
81121d74:	defee204 	addi	sp,sp,-1144
81121d78:	de00012e 	bgeu	sp,et,81121d80 <__sbprintf+0xc>
81121d7c:	003b68fa 	trap	3
81121d80:	2880030b 	ldhu	r2,12(r5)
81121d84:	2ac01917 	ldw	r11,100(r5)
81121d88:	2a80038b 	ldhu	r10,14(r5)
81121d8c:	2a400717 	ldw	r9,28(r5)
81121d90:	2a000917 	ldw	r8,36(r5)
81121d94:	00c10004 	movi	r3,1024
81121d98:	dc011a15 	stw	r16,1128(sp)
81121d9c:	10bfff4c 	andi	r2,r2,65533
81121da0:	2821883a 	mov	r16,r5
81121da4:	d8cb883a 	add	r5,sp,r3
81121da8:	dc811c15 	stw	r18,1136(sp)
81121dac:	dc411b15 	stw	r17,1132(sp)
81121db0:	dfc11d15 	stw	ra,1140(sp)
81121db4:	2025883a 	mov	r18,r4
81121db8:	d881030d 	sth	r2,1036(sp)
81121dbc:	dac11915 	stw	r11,1124(sp)
81121dc0:	da81038d 	sth	r10,1038(sp)
81121dc4:	da410715 	stw	r9,1052(sp)
81121dc8:	da010915 	stw	r8,1060(sp)
81121dcc:	dec10015 	stw	sp,1024(sp)
81121dd0:	dec10415 	stw	sp,1040(sp)
81121dd4:	d8c10215 	stw	r3,1032(sp)
81121dd8:	d8c10515 	stw	r3,1044(sp)
81121ddc:	d8010615 	stw	zero,1048(sp)
81121de0:	111fb580 	call	8111fb58 <___vfprintf_internal_r>
81121de4:	1023883a 	mov	r17,r2
81121de8:	10000416 	blt	r2,zero,81121dfc <__sbprintf+0x88>
81121dec:	d9410004 	addi	r5,sp,1024
81121df0:	9009883a 	mov	r4,r18
81121df4:	11255180 	call	81125518 <_fflush_r>
81121df8:	10000d1e 	bne	r2,zero,81121e30 <__sbprintf+0xbc>
81121dfc:	d881030b 	ldhu	r2,1036(sp)
81121e00:	1080100c 	andi	r2,r2,64
81121e04:	10000326 	beq	r2,zero,81121e14 <__sbprintf+0xa0>
81121e08:	8080030b 	ldhu	r2,12(r16)
81121e0c:	10801014 	ori	r2,r2,64
81121e10:	8080030d 	sth	r2,12(r16)
81121e14:	8805883a 	mov	r2,r17
81121e18:	dfc11d17 	ldw	ra,1140(sp)
81121e1c:	dc811c17 	ldw	r18,1136(sp)
81121e20:	dc411b17 	ldw	r17,1132(sp)
81121e24:	dc011a17 	ldw	r16,1128(sp)
81121e28:	dec11e04 	addi	sp,sp,1144
81121e2c:	f800283a 	ret
81121e30:	047fffc4 	movi	r17,-1
81121e34:	003ff106 	br	81121dfc <__reset+0xfb101dfc>

81121e38 <__svfscanf_r>:
81121e38:	deff4b04 	addi	sp,sp,-724
81121e3c:	de00012e 	bgeu	sp,et,81121e44 <__svfscanf_r+0xc>
81121e40:	003b68fa 	trap	3
81121e44:	2880030b 	ldhu	r2,12(r5)
81121e48:	df00b315 	stw	fp,716(sp)
81121e4c:	dd80b115 	stw	r22,708(sp)
81121e50:	dfc0b415 	stw	ra,720(sp)
81121e54:	ddc0b215 	stw	r23,712(sp)
81121e58:	dd40b015 	stw	r21,704(sp)
81121e5c:	dd00af15 	stw	r20,700(sp)
81121e60:	dcc0ae15 	stw	r19,696(sp)
81121e64:	dc80ad15 	stw	r18,692(sp)
81121e68:	dc40ac15 	stw	r17,688(sp)
81121e6c:	dc00ab15 	stw	r16,684(sp)
81121e70:	10c8000c 	andi	r3,r2,8192
81121e74:	d9c09c15 	stw	r7,624(sp)
81121e78:	2839883a 	mov	fp,r5
81121e7c:	202d883a 	mov	r22,r4
81121e80:	1800061e 	bne	r3,zero,81121e9c <__svfscanf_r+0x64>
81121e84:	29001917 	ldw	r4,100(r5)
81121e88:	00f7ffc4 	movi	r3,-8193
81121e8c:	10880014 	ori	r2,r2,8192
81121e90:	20c6703a 	and	r3,r4,r3
81121e94:	2880030d 	sth	r2,12(r5)
81121e98:	28c01915 	stw	r3,100(r5)
81121e9c:	30800003 	ldbu	r2,0(r6)
81121ea0:	0021883a 	mov	r16,zero
81121ea4:	05e04574 	movhi	r23,33045
81121ea8:	d800a115 	stw	zero,644(sp)
81121eac:	d8009e15 	stw	zero,632(sp)
81121eb0:	d800a015 	stw	zero,640(sp)
81121eb4:	d8809b15 	stw	r2,620(sp)
81121eb8:	bdf52704 	addi	r23,r23,-11108
81121ebc:	8025883a 	mov	r18,r16
81121ec0:	35000044 	addi	r20,r6,1
81121ec4:	10001e26 	beq	r2,zero,81121f40 <__svfscanf_r+0x108>
81121ec8:	b9c00017 	ldw	r7,0(r23)
81121ecc:	3887883a 	add	r3,r7,r2
81121ed0:	18c00043 	ldbu	r3,1(r3)
81121ed4:	18c0020c 	andi	r3,r3,8
81121ed8:	18001b26 	beq	r3,zero,81121f48 <__svfscanf_r+0x110>
81121edc:	e0800117 	ldw	r2,4(fp)
81121ee0:	00800e0e 	bge	zero,r2,81121f1c <__svfscanf_r+0xe4>
81121ee4:	e0c00017 	ldw	r3,0(fp)
81121ee8:	b9000017 	ldw	r4,0(r23)
81121eec:	18800003 	ldbu	r2,0(r3)
81121ef0:	2085883a 	add	r2,r4,r2
81121ef4:	10800043 	ldbu	r2,1(r2)
81121ef8:	1080020c 	andi	r2,r2,8
81121efc:	10000b26 	beq	r2,zero,81121f2c <__svfscanf_r+0xf4>
81121f00:	e0800117 	ldw	r2,4(fp)
81121f04:	18c00044 	addi	r3,r3,1
81121f08:	e0c00015 	stw	r3,0(fp)
81121f0c:	10bfffc4 	addi	r2,r2,-1
81121f10:	e0800115 	stw	r2,4(fp)
81121f14:	94800044 	addi	r18,r18,1
81121f18:	00bff216 	blt	zero,r2,81121ee4 <__reset+0xfb101ee4>
81121f1c:	e00b883a 	mov	r5,fp
81121f20:	b009883a 	mov	r4,r22
81121f24:	111d1180 	call	8111d118 <__srefill_r>
81121f28:	103fee26 	beq	r2,zero,81121ee4 <__reset+0xfb101ee4>
81121f2c:	a00d883a 	mov	r6,r20
81121f30:	30800003 	ldbu	r2,0(r6)
81121f34:	35000044 	addi	r20,r6,1
81121f38:	d8809b15 	stw	r2,620(sp)
81121f3c:	103fe21e 	bne	r2,zero,81121ec8 <__reset+0xfb101ec8>
81121f40:	d880a017 	ldw	r2,640(sp)
81121f44:	00009906 	br	811221ac <__svfscanf_r+0x374>
81121f48:	00c00944 	movi	r3,37
81121f4c:	10c0881e 	bne	r2,r3,81122170 <__svfscanf_r+0x338>
81121f50:	30c00043 	ldbu	r3,1(r6)
81121f54:	0023883a 	mov	r17,zero
81121f58:	0027883a 	mov	r19,zero
81121f5c:	01001e04 	movi	r4,120
81121f60:	01401b04 	movi	r5,108
81121f64:	a1800044 	addi	r6,r20,1
81121f68:	20c0a236 	bltu	r4,r3,811221f4 <__svfscanf_r+0x3bc>
81121f6c:	180490ba 	slli	r2,r3,2
81121f70:	022044b4 	movhi	r8,33042
81121f74:	4207e104 	addi	r8,r8,8068
81121f78:	1205883a 	add	r2,r2,r8
81121f7c:	10800017 	ldw	r2,0(r2)
81121f80:	1000683a 	jmp	r2
81121f84:	811221a8 	cmpgeui	r4,r16,18566
81121f88:	811221f4 	orhi	r4,r16,18567
81121f8c:	811221f4 	orhi	r4,r16,18567
81121f90:	811221f4 	orhi	r4,r16,18567
81121f94:	811221f4 	orhi	r4,r16,18567
81121f98:	811221f4 	orhi	r4,r16,18567
81121f9c:	811221f4 	orhi	r4,r16,18567
81121fa0:	811221f4 	orhi	r4,r16,18567
81121fa4:	811221f4 	orhi	r4,r16,18567
81121fa8:	811221f4 	orhi	r4,r16,18567
81121fac:	811221f4 	orhi	r4,r16,18567
81121fb0:	811221f4 	orhi	r4,r16,18567
81121fb4:	811221f4 	orhi	r4,r16,18567
81121fb8:	811221f4 	orhi	r4,r16,18567
81121fbc:	811221f4 	orhi	r4,r16,18567
81121fc0:	811221f4 	orhi	r4,r16,18567
81121fc4:	811221f4 	orhi	r4,r16,18567
81121fc8:	811221f4 	orhi	r4,r16,18567
81121fcc:	811221f4 	orhi	r4,r16,18567
81121fd0:	811221f4 	orhi	r4,r16,18567
81121fd4:	811221f4 	orhi	r4,r16,18567
81121fd8:	811221f4 	orhi	r4,r16,18567
81121fdc:	811221f4 	orhi	r4,r16,18567
81121fe0:	811221f4 	orhi	r4,r16,18567
81121fe4:	811221f4 	orhi	r4,r16,18567
81121fe8:	811221f4 	orhi	r4,r16,18567
81121fec:	811221f4 	orhi	r4,r16,18567
81121ff0:	811221f4 	orhi	r4,r16,18567
81121ff4:	811221f4 	orhi	r4,r16,18567
81121ff8:	811221f4 	orhi	r4,r16,18567
81121ffc:	811221f4 	orhi	r4,r16,18567
81122000:	811221f4 	orhi	r4,r16,18567
81122004:	811221f4 	orhi	r4,r16,18567
81122008:	811221f4 	orhi	r4,r16,18567
8112200c:	811221f4 	orhi	r4,r16,18567
81122010:	811221f4 	orhi	r4,r16,18567
81122014:	811221f4 	orhi	r4,r16,18567
81122018:	81122168 	cmpgeui	r4,r16,18565
8112201c:	811221f4 	orhi	r4,r16,18567
81122020:	811221f4 	orhi	r4,r16,18567
81122024:	811221f4 	orhi	r4,r16,18567
81122028:	811221f4 	orhi	r4,r16,18567
8112202c:	811221dc 	xori	r4,r16,18567
81122030:	811221f4 	orhi	r4,r16,18567
81122034:	811221f4 	orhi	r4,r16,18567
81122038:	811221f4 	orhi	r4,r16,18567
8112203c:	811221f4 	orhi	r4,r16,18567
81122040:	811221f4 	orhi	r4,r16,18567
81122044:	81122310 	cmplti	r4,r16,18572
81122048:	81122310 	cmplti	r4,r16,18572
8112204c:	81122310 	cmplti	r4,r16,18572
81122050:	81122310 	cmplti	r4,r16,18572
81122054:	81122310 	cmplti	r4,r16,18572
81122058:	81122310 	cmplti	r4,r16,18572
8112205c:	81122310 	cmplti	r4,r16,18572
81122060:	81122310 	cmplti	r4,r16,18572
81122064:	81122310 	cmplti	r4,r16,18572
81122068:	81122310 	cmplti	r4,r16,18572
8112206c:	811221f4 	orhi	r4,r16,18567
81122070:	811221f4 	orhi	r4,r16,18567
81122074:	811221f4 	orhi	r4,r16,18567
81122078:	811221f4 	orhi	r4,r16,18567
8112207c:	811221f4 	orhi	r4,r16,18567
81122080:	811221f4 	orhi	r4,r16,18567
81122084:	811221f4 	orhi	r4,r16,18567
81122088:	811221f4 	orhi	r4,r16,18567
8112208c:	811221f4 	orhi	r4,r16,18567
81122090:	811221f4 	orhi	r4,r16,18567
81122094:	811222e4 	muli	r4,r16,18571
81122098:	81122394 	ori	r4,r16,18574
8112209c:	811221f4 	orhi	r4,r16,18567
811220a0:	81122394 	ori	r4,r16,18574
811220a4:	811221f4 	orhi	r4,r16,18567
811220a8:	811221f4 	orhi	r4,r16,18567
811220ac:	811221f4 	orhi	r4,r16,18567
811220b0:	811221f4 	orhi	r4,r16,18567
811220b4:	81122380 	call	88112238 <__reset+0x20f2238>
811220b8:	811221f4 	orhi	r4,r16,18567
811220bc:	811221f4 	orhi	r4,r16,18567
811220c0:	81122354 	ori	r4,r16,18573
811220c4:	811221f4 	orhi	r4,r16,18567
811220c8:	811221f4 	orhi	r4,r16,18567
811220cc:	811221f4 	orhi	r4,r16,18567
811220d0:	811221f4 	orhi	r4,r16,18567
811220d4:	811221f4 	orhi	r4,r16,18567
811220d8:	811221f4 	orhi	r4,r16,18567
811220dc:	811221f4 	orhi	r4,r16,18567
811220e0:	811221f4 	orhi	r4,r16,18567
811220e4:	8112232c 	andhi	r4,r16,18572
811220e8:	811221f4 	orhi	r4,r16,18567
811220ec:	811221f4 	orhi	r4,r16,18567
811220f0:	811224c8 	cmpgei	r4,r16,18579
811220f4:	811221f4 	orhi	r4,r16,18567
811220f8:	811221f4 	orhi	r4,r16,18567
811220fc:	811221f4 	orhi	r4,r16,18567
81122100:	811221f4 	orhi	r4,r16,18567
81122104:	811221f4 	orhi	r4,r16,18567
81122108:	811221f4 	orhi	r4,r16,18567
8112210c:	811221f4 	orhi	r4,r16,18567
81122110:	8112244c 	andi	r4,r16,18577
81122114:	81122424 	muli	r4,r16,18576
81122118:	81122394 	ori	r4,r16,18574
8112211c:	81122394 	ori	r4,r16,18574
81122120:	81122394 	ori	r4,r16,18574
81122124:	81122410 	cmplti	r4,r16,18576
81122128:	81122554 	ori	r4,r16,18581
8112212c:	811221f4 	orhi	r4,r16,18567
81122130:	811221f4 	orhi	r4,r16,18567
81122134:	811223fc 	xorhi	r4,r16,18575
81122138:	811221f4 	orhi	r4,r16,18567
8112213c:	811223cc 	andi	r4,r16,18575
81122140:	811223a8 	cmpgeui	r4,r16,18574
81122144:	811222b8 	rdprs	r4,r16,18570
81122148:	811221f4 	orhi	r4,r16,18567
8112214c:	811221f4 	orhi	r4,r16,18567
81122150:	811222a4 	muli	r4,r16,18570
81122154:	811221f4 	orhi	r4,r16,18567
81122158:	8112222c 	andhi	r4,r16,18568
8112215c:	811221f4 	orhi	r4,r16,18567
81122160:	811221f4 	orhi	r4,r16,18567
81122164:	8112232c 	andhi	r4,r16,18572
81122168:	d9809d15 	stw	r6,628(sp)
8112216c:	3029883a 	mov	r20,r6
81122170:	e0800117 	ldw	r2,4(fp)
81122174:	0081aa0e 	bge	zero,r2,81122820 <__svfscanf_r+0x9e8>
81122178:	e0800017 	ldw	r2,0(fp)
8112217c:	a0ffffc3 	ldbu	r3,-1(r20)
81122180:	11000003 	ldbu	r4,0(r2)
81122184:	20ff6e1e 	bne	r4,r3,81121f40 <__reset+0xfb101f40>
81122188:	e0c00117 	ldw	r3,4(fp)
8112218c:	10800044 	addi	r2,r2,1
81122190:	e0800015 	stw	r2,0(fp)
81122194:	18bfffc4 	addi	r2,r3,-1
81122198:	e0800115 	stw	r2,4(fp)
8112219c:	94800044 	addi	r18,r18,1
811221a0:	a00d883a 	mov	r6,r20
811221a4:	003f6206 	br	81121f30 <__reset+0xfb101f30>
811221a8:	00bfffc4 	movi	r2,-1
811221ac:	dfc0b417 	ldw	ra,720(sp)
811221b0:	df00b317 	ldw	fp,716(sp)
811221b4:	ddc0b217 	ldw	r23,712(sp)
811221b8:	dd80b117 	ldw	r22,708(sp)
811221bc:	dd40b017 	ldw	r21,704(sp)
811221c0:	dd00af17 	ldw	r20,700(sp)
811221c4:	dcc0ae17 	ldw	r19,696(sp)
811221c8:	dc80ad17 	ldw	r18,692(sp)
811221cc:	dc40ac17 	ldw	r17,688(sp)
811221d0:	dc00ab17 	ldw	r16,684(sp)
811221d4:	dec0b504 	addi	sp,sp,724
811221d8:	f800283a 	ret
811221dc:	a0800043 	ldbu	r2,1(r20)
811221e0:	3029883a 	mov	r20,r6
811221e4:	8c400414 	ori	r17,r17,16
811221e8:	10c03fcc 	andi	r3,r2,255
811221ec:	a1800044 	addi	r6,r20,1
811221f0:	20ff5e2e 	bgeu	r4,r3,81121f6c <__reset+0xfb101f6c>
811221f4:	38c7883a 	add	r3,r7,r3
811221f8:	18800043 	ldbu	r2,1(r3)
811221fc:	d9809d15 	stw	r6,628(sp)
81122200:	00c00044 	movi	r3,1
81122204:	108000cc 	andi	r2,r2,3
81122208:	10c18f26 	beq	r2,r3,81122848 <__svfscanf_r+0xa10>
8112220c:	e0800117 	ldw	r2,4(fp)
81122210:	00808716 	blt	zero,r2,81122430 <__svfscanf_r+0x5f8>
81122214:	e00b883a 	mov	r5,fp
81122218:	b009883a 	mov	r4,r22
8112221c:	111d1180 	call	8111d118 <__srefill_r>
81122220:	1001431e 	bne	r2,zero,81122730 <__svfscanf_r+0x8f8>
81122224:	b9c00017 	ldw	r7,0(r23)
81122228:	00008106 	br	81122430 <__svfscanf_r+0x5f8>
8112222c:	e0800117 	ldw	r2,4(fp)
81122230:	d9809d15 	stw	r6,628(sp)
81122234:	0081a30e 	bge	zero,r2,811228c4 <__svfscanf_r+0xa8c>
81122238:	00a044f4 	movhi	r2,33043
8112223c:	10a81204 	addi	r2,r2,-24504
81122240:	02000284 	movi	r8,10
81122244:	d880a115 	stw	r2,644(sp)
81122248:	da009e15 	stw	r8,632(sp)
8112224c:	050000c4 	movi	r20,3
81122250:	e0c00017 	ldw	r3,0(fp)
81122254:	00000206 	br	81122260 <__svfscanf_r+0x428>
81122258:	18c00044 	addi	r3,r3,1
8112225c:	e0c00015 	stw	r3,0(fp)
81122260:	19000003 	ldbu	r4,0(r3)
81122264:	20803fcc 	andi	r2,r4,255
81122268:	3885883a 	add	r2,r7,r2
8112226c:	10800043 	ldbu	r2,1(r2)
81122270:	1140020c 	andi	r5,r2,8
81122274:	2801ab26 	beq	r5,zero,81122924 <__svfscanf_r+0xaec>
81122278:	e0800117 	ldw	r2,4(fp)
8112227c:	94800044 	addi	r18,r18,1
81122280:	10bfffc4 	addi	r2,r2,-1
81122284:	e0800115 	stw	r2,4(fp)
81122288:	00bff316 	blt	zero,r2,81122258 <__reset+0xfb102258>
8112228c:	e00b883a 	mov	r5,fp
81122290:	b009883a 	mov	r4,r22
81122294:	111d1180 	call	8111d118 <__srefill_r>
81122298:	1001251e 	bne	r2,zero,81122730 <__svfscanf_r+0x8f8>
8112229c:	b9c00017 	ldw	r7,0(r23)
811222a0:	003feb06 	br	81122250 <__reset+0xfb102250>
811222a4:	e0800117 	ldw	r2,4(fp)
811222a8:	d9809d15 	stw	r6,628(sp)
811222ac:	00818b0e 	bge	zero,r2,811228dc <__svfscanf_r+0xaa4>
811222b0:	05000084 	movi	r20,2
811222b4:	003fe606 	br	81122250 <__reset+0xfb102250>
811222b8:	e0800117 	ldw	r2,4(fp)
811222bc:	d9809d15 	stw	r6,628(sp)
811222c0:	8c408814 	ori	r17,r17,544
811222c4:	00801d0e 	bge	zero,r2,8112233c <__svfscanf_r+0x504>
811222c8:	00a044f4 	movhi	r2,33043
811222cc:	10a81204 	addi	r2,r2,-24504
811222d0:	02000404 	movi	r8,16
811222d4:	d880a115 	stw	r2,644(sp)
811222d8:	da009e15 	stw	r8,632(sp)
811222dc:	050000c4 	movi	r20,3
811222e0:	003fdb06 	br	81122250 <__reset+0xfb102250>
811222e4:	e0800117 	ldw	r2,4(fp)
811222e8:	d9809d15 	stw	r6,628(sp)
811222ec:	8c400054 	ori	r17,r17,1
811222f0:	00bfc80e 	bge	zero,r2,81122214 <__reset+0xfb102214>
811222f4:	00e044b4 	movhi	r3,33042
811222f8:	18f5c704 	addi	r3,r3,-10468
811222fc:	02000284 	movi	r8,10
81122300:	d8c0a115 	stw	r3,644(sp)
81122304:	da009e15 	stw	r8,632(sp)
81122308:	050000c4 	movi	r20,3
8112230c:	003fd006 	br	81122250 <__reset+0xfb102250>
81122310:	9cc002a4 	muli	r19,r19,10
81122314:	a0800043 	ldbu	r2,1(r20)
81122318:	3029883a 	mov	r20,r6
8112231c:	98e7883a 	add	r19,r19,r3
81122320:	9cfff404 	addi	r19,r19,-48
81122324:	10c03fcc 	andi	r3,r2,255
81122328:	003f0e06 	br	81121f64 <__reset+0xfb101f64>
8112232c:	e0800117 	ldw	r2,4(fp)
81122330:	d9809d15 	stw	r6,628(sp)
81122334:	8c408014 	ori	r17,r17,512
81122338:	00bfe316 	blt	zero,r2,811222c8 <__reset+0xfb1022c8>
8112233c:	e00b883a 	mov	r5,fp
81122340:	b009883a 	mov	r4,r22
81122344:	111d1180 	call	8111d118 <__srefill_r>
81122348:	1000f91e 	bne	r2,zero,81122730 <__svfscanf_r+0x8f8>
8112234c:	b9c00017 	ldw	r7,0(r23)
81122350:	003fdd06 	br	811222c8 <__reset+0xfb1022c8>
81122354:	e0800117 	ldw	r2,4(fp)
81122358:	d9809d15 	stw	r6,628(sp)
8112235c:	8c400054 	ori	r17,r17,1
81122360:	0080140e 	bge	zero,r2,811223b4 <__svfscanf_r+0x57c>
81122364:	00a044f4 	movhi	r2,33043
81122368:	10a81204 	addi	r2,r2,-24504
8112236c:	02000204 	movi	r8,8
81122370:	d880a115 	stw	r2,644(sp)
81122374:	da009e15 	stw	r8,632(sp)
81122378:	050000c4 	movi	r20,3
8112237c:	003fb406 	br	81122250 <__reset+0xfb102250>
81122380:	a0800043 	ldbu	r2,1(r20)
81122384:	8c400094 	ori	r17,r17,2
81122388:	3029883a 	mov	r20,r6
8112238c:	10c03fcc 	andi	r3,r2,255
81122390:	003ef406 	br	81121f64 <__reset+0xfb101f64>
81122394:	e0800117 	ldw	r2,4(fp)
81122398:	d9809d15 	stw	r6,628(sp)
8112239c:	0081420e 	bge	zero,r2,811228a8 <__svfscanf_r+0xa70>
811223a0:	05000104 	movi	r20,4
811223a4:	003faa06 	br	81122250 <__reset+0xfb102250>
811223a8:	e0800117 	ldw	r2,4(fp)
811223ac:	d9809d15 	stw	r6,628(sp)
811223b0:	00bfec16 	blt	zero,r2,81122364 <__reset+0xfb102364>
811223b4:	e00b883a 	mov	r5,fp
811223b8:	b009883a 	mov	r4,r22
811223bc:	111d1180 	call	8111d118 <__srefill_r>
811223c0:	1000db1e 	bne	r2,zero,81122730 <__svfscanf_r+0x8f8>
811223c4:	b9c00017 	ldw	r7,0(r23)
811223c8:	003fe606 	br	81122364 <__reset+0xfb102364>
811223cc:	d9809d15 	stw	r6,628(sp)
811223d0:	8880040c 	andi	r2,r17,16
811223d4:	10009c1e 	bne	r2,zero,81122648 <__svfscanf_r+0x810>
811223d8:	8880010c 	andi	r2,r17,4
811223dc:	10011e26 	beq	r2,zero,81122858 <__svfscanf_r+0xa20>
811223e0:	da009c17 	ldw	r8,624(sp)
811223e4:	3029883a 	mov	r20,r6
811223e8:	40800017 	ldw	r2,0(r8)
811223ec:	42000104 	addi	r8,r8,4
811223f0:	da009c15 	stw	r8,624(sp)
811223f4:	1480000d 	sth	r18,0(r2)
811223f8:	003ecc06 	br	81121f2c <__reset+0xfb101f2c>
811223fc:	a0c00043 	ldbu	r3,1(r20)
81122400:	19410c26 	beq	r3,r5,81122834 <__svfscanf_r+0x9fc>
81122404:	8c400054 	ori	r17,r17,1
81122408:	3029883a 	mov	r20,r6
8112240c:	003ed506 	br	81121f64 <__reset+0xfb101f64>
81122410:	a0800043 	ldbu	r2,1(r20)
81122414:	8c400114 	ori	r17,r17,4
81122418:	3029883a 	mov	r20,r6
8112241c:	10c03fcc 	andi	r3,r2,255
81122420:	003ed006 	br	81121f64 <__reset+0xfb101f64>
81122424:	e0800117 	ldw	r2,4(fp)
81122428:	d9809d15 	stw	r6,628(sp)
8112242c:	00bf790e 	bge	zero,r2,81122214 <__reset+0xfb102214>
81122430:	00a044b4 	movhi	r2,33042
81122434:	10b5c704 	addi	r2,r2,-10468
81122438:	02000284 	movi	r8,10
8112243c:	d880a115 	stw	r2,644(sp)
81122440:	da009e15 	stw	r8,632(sp)
81122444:	050000c4 	movi	r20,3
81122448:	003f8106 	br	81122250 <__reset+0xfb102250>
8112244c:	e0800117 	ldw	r2,4(fp)
81122450:	d9809d15 	stw	r6,628(sp)
81122454:	0080c40e 	bge	zero,r2,81122768 <__svfscanf_r+0x930>
81122458:	9800011e 	bne	r19,zero,81122460 <__svfscanf_r+0x628>
8112245c:	04c00044 	movi	r19,1
81122460:	8880004c 	andi	r2,r17,1
81122464:	1000441e 	bne	r2,zero,81122578 <__svfscanf_r+0x740>
81122468:	8c40040c 	andi	r17,r17,16
8112246c:	8800da26 	beq	r17,zero,811227d8 <__svfscanf_r+0x9a0>
81122470:	0021883a 	mov	r16,zero
81122474:	00000806 	br	81122498 <__svfscanf_r+0x660>
81122478:	1887883a 	add	r3,r3,r2
8112247c:	e00b883a 	mov	r5,fp
81122480:	b009883a 	mov	r4,r22
81122484:	e0c00015 	stw	r3,0(fp)
81122488:	80a1883a 	add	r16,r16,r2
8112248c:	98a7c83a 	sub	r19,r19,r2
81122490:	111d1180 	call	8111d118 <__srefill_r>
81122494:	1000ca1e 	bne	r2,zero,811227c0 <__svfscanf_r+0x988>
81122498:	e0800117 	ldw	r2,4(fp)
8112249c:	e0c00017 	ldw	r3,0(fp)
811224a0:	14fff516 	blt	r2,r19,81122478 <__reset+0xfb102478>
811224a4:	14c5c83a 	sub	r2,r2,r19
811224a8:	1cd5883a 	add	r10,r3,r19
811224ac:	84e1883a 	add	r16,r16,r19
811224b0:	e0800115 	stw	r2,4(fp)
811224b4:	e2800015 	stw	r10,0(fp)
811224b8:	dd009d17 	ldw	r20,628(sp)
811224bc:	9425883a 	add	r18,r18,r16
811224c0:	a00d883a 	mov	r6,r20
811224c4:	003e9a06 	br	81121f30 <__reset+0xfb101f30>
811224c8:	300b883a 	mov	r5,r6
811224cc:	d9005884 	addi	r4,sp,354
811224d0:	d9809d15 	stw	r6,628(sp)
811224d4:	11284200 	call	81128420 <__sccl>
811224d8:	1029883a 	mov	r20,r2
811224dc:	e0800117 	ldw	r2,4(fp)
811224e0:	0081050e 	bge	zero,r2,811228f8 <__svfscanf_r+0xac0>
811224e4:	e1000017 	ldw	r4,0(fp)
811224e8:	20800003 	ldbu	r2,0(r4)
811224ec:	98005926 	beq	r19,zero,81122654 <__svfscanf_r+0x81c>
811224f0:	8c40040c 	andi	r17,r17,16
811224f4:	88005a26 	beq	r17,zero,81122660 <__svfscanf_r+0x828>
811224f8:	9823883a 	mov	r17,r19
811224fc:	0021883a 	mov	r16,zero
81122500:	00000106 	br	81122508 <__svfscanf_r+0x6d0>
81122504:	20800003 	ldbu	r2,0(r4)
81122508:	10803fcc 	andi	r2,r2,255
8112250c:	d8c05884 	addi	r3,sp,354
81122510:	1885883a 	add	r2,r3,r2
81122514:	10800007 	ldb	r2,0(r2)
81122518:	1000ad26 	beq	r2,zero,811227d0 <__svfscanf_r+0x998>
8112251c:	e0800117 	ldw	r2,4(fp)
81122520:	21000044 	addi	r4,r4,1
81122524:	84000044 	addi	r16,r16,1
81122528:	10bfffc4 	addi	r2,r2,-1
8112252c:	e0800115 	stw	r2,4(fp)
81122530:	e1000015 	stw	r4,0(fp)
81122534:	84c0a026 	beq	r16,r19,811227b8 <__svfscanf_r+0x980>
81122538:	00bff216 	blt	zero,r2,81122504 <__reset+0xfb102504>
8112253c:	e00b883a 	mov	r5,fp
81122540:	b009883a 	mov	r4,r22
81122544:	111d1180 	call	8111d118 <__srefill_r>
81122548:	10009a1e 	bne	r2,zero,811227b4 <__svfscanf_r+0x97c>
8112254c:	e1000017 	ldw	r4,0(fp)
81122550:	003fec06 	br	81122504 <__reset+0xfb102504>
81122554:	e0800117 	ldw	r2,4(fp)
81122558:	d9809d15 	stw	r6,628(sp)
8112255c:	0080eb0e 	bge	zero,r2,8112290c <__svfscanf_r+0xad4>
81122560:	00a044b4 	movhi	r2,33042
81122564:	10b5c704 	addi	r2,r2,-10468
81122568:	d880a115 	stw	r2,644(sp)
8112256c:	d8009e15 	stw	zero,632(sp)
81122570:	050000c4 	movi	r20,3
81122574:	003f3606 	br	81122250 <__reset+0xfb102250>
81122578:	dd409904 	addi	r21,sp,612
8112257c:	8c40040c 	andi	r17,r17,16
81122580:	01800204 	movi	r6,8
81122584:	000b883a 	mov	r5,zero
81122588:	a809883a 	mov	r4,r21
8112258c:	dc409f15 	stw	r17,636(sp)
81122590:	111cc9c0 	call	8111cc9c <memset>
81122594:	dc409f17 	ldw	r17,636(sp)
81122598:	88006e26 	beq	r17,zero,81122754 <__svfscanf_r+0x91c>
8112259c:	0029883a 	mov	r20,zero
811225a0:	0023883a 	mov	r17,zero
811225a4:	112683c0 	call	8112683c <__locale_mb_cur_max>
811225a8:	14406126 	beq	r2,r17,81122730 <__svfscanf_r+0x8f8>
811225ac:	e0800017 	ldw	r2,0(fp)
811225b0:	e0c00117 	ldw	r3,4(fp)
811225b4:	d9000104 	addi	r4,sp,4
811225b8:	12000003 	ldbu	r8,0(r2)
811225bc:	18ffffc4 	addi	r3,r3,-1
811225c0:	10800044 	addi	r2,r2,1
811225c4:	e0c00115 	stw	r3,4(fp)
811225c8:	e0800015 	stw	r2,0(fp)
811225cc:	8c000044 	addi	r16,r17,1
811225d0:	dd400015 	stw	r21,0(sp)
811225d4:	2463883a 	add	r17,r4,r17
811225d8:	200d883a 	mov	r6,r4
811225dc:	a00b883a 	mov	r5,r20
811225e0:	800f883a 	mov	r7,r16
811225e4:	b009883a 	mov	r4,r22
811225e8:	8a000005 	stb	r8,0(r17)
811225ec:	11268f80 	call	811268f8 <_mbrtowc_r>
811225f0:	017fffc4 	movi	r5,-1
811225f4:	11404e26 	beq	r2,r5,81122730 <__svfscanf_r+0x8f8>
811225f8:	1000601e 	bne	r2,zero,8112277c <__svfscanf_r+0x944>
811225fc:	da009f17 	ldw	r8,636(sp)
81122600:	4000641e 	bne	r8,zero,81122794 <__svfscanf_r+0x95c>
81122604:	a0000015 	stw	zero,0(r20)
81122608:	9425883a 	add	r18,r18,r16
8112260c:	9967883a 	add	r19,r19,r5
81122610:	a5000104 	addi	r20,r20,4
81122614:	e0800117 	ldw	r2,4(fp)
81122618:	0023883a 	mov	r17,zero
8112261c:	00804b16 	blt	zero,r2,8112274c <__svfscanf_r+0x914>
81122620:	e00b883a 	mov	r5,fp
81122624:	b009883a 	mov	r4,r22
81122628:	111d1180 	call	8111d118 <__srefill_r>
8112262c:	10004726 	beq	r2,zero,8112274c <__svfscanf_r+0x914>
81122630:	88003f1e 	bne	r17,zero,81122730 <__svfscanf_r+0x8f8>
81122634:	d8c09f17 	ldw	r3,636(sp)
81122638:	1800031e 	bne	r3,zero,81122648 <__svfscanf_r+0x810>
8112263c:	da00a017 	ldw	r8,640(sp)
81122640:	42000044 	addi	r8,r8,1
81122644:	da00a015 	stw	r8,640(sp)
81122648:	dd009d17 	ldw	r20,628(sp)
8112264c:	a00d883a 	mov	r6,r20
81122650:	003e3706 	br	81121f30 <__reset+0xfb101f30>
81122654:	8c40040c 	andi	r17,r17,16
81122658:	04ffffc4 	movi	r19,-1
8112265c:	883fa61e 	bne	r17,zero,811224f8 <__reset+0xfb1024f8>
81122660:	da009c17 	ldw	r8,624(sp)
81122664:	9abfffc4 	addi	r10,r19,-1
81122668:	44000017 	ldw	r16,0(r8)
8112266c:	44400104 	addi	r17,r8,4
81122670:	8007883a 	mov	r3,r16
81122674:	82ab883a 	add	r21,r16,r10
81122678:	00000306 	br	81122688 <__svfscanf_r+0x850>
8112267c:	e1000017 	ldw	r4,0(fp)
81122680:	9807883a 	mov	r3,r19
81122684:	20800003 	ldbu	r2,0(r4)
81122688:	10803fcc 	andi	r2,r2,255
8112268c:	d9405884 	addi	r5,sp,354
81122690:	2885883a 	add	r2,r5,r2
81122694:	10800007 	ldb	r2,0(r2)
81122698:	10004b26 	beq	r2,zero,811227c8 <__svfscanf_r+0x990>
8112269c:	e0800117 	ldw	r2,4(fp)
811226a0:	21400044 	addi	r5,r4,1
811226a4:	e1400015 	stw	r5,0(fp)
811226a8:	10bfffc4 	addi	r2,r2,-1
811226ac:	e0800115 	stw	r2,4(fp)
811226b0:	20800003 	ldbu	r2,0(r4)
811226b4:	1cc00044 	addi	r19,r3,1
811226b8:	18800005 	stb	r2,0(r3)
811226bc:	1d400726 	beq	r3,r21,811226dc <__svfscanf_r+0x8a4>
811226c0:	e0800117 	ldw	r2,4(fp)
811226c4:	00bfed16 	blt	zero,r2,8112267c <__reset+0xfb10267c>
811226c8:	e00b883a 	mov	r5,fp
811226cc:	b009883a 	mov	r4,r22
811226d0:	111d1180 	call	8111d118 <__srefill_r>
811226d4:	103fe926 	beq	r2,zero,8112267c <__reset+0xfb10267c>
811226d8:	84c01526 	beq	r16,r19,81122730 <__svfscanf_r+0x8f8>
811226dc:	9c21c83a 	sub	r16,r19,r16
811226e0:	803e1726 	beq	r16,zero,81121f40 <__reset+0xfb101f40>
811226e4:	da00a017 	ldw	r8,640(sp)
811226e8:	98000005 	stb	zero,0(r19)
811226ec:	dc409c15 	stw	r17,624(sp)
811226f0:	42000044 	addi	r8,r8,1
811226f4:	da00a015 	stw	r8,640(sp)
811226f8:	9425883a 	add	r18,r18,r16
811226fc:	a00d883a 	mov	r6,r20
81122700:	003e0b06 	br	81121f30 <__reset+0xfb101f30>
81122704:	017fff84 	movi	r5,-2
81122708:	11439b1e 	bne	r2,r5,81123578 <__svfscanf_r+0x1740>
8112270c:	8821883a 	mov	r16,r17
81122710:	e0800117 	ldw	r2,4(fp)
81122714:	0082e516 	blt	zero,r2,811232ac <__svfscanf_r+0x1474>
81122718:	e00b883a 	mov	r5,fp
8112271c:	b009883a 	mov	r4,r22
81122720:	111d1180 	call	8111d118 <__srefill_r>
81122724:	1002e126 	beq	r2,zero,811232ac <__svfscanf_r+0x1474>
81122728:	dc409f17 	ldw	r17,636(sp)
8112272c:	8002e826 	beq	r16,zero,811232d0 <__svfscanf_r+0x1498>
81122730:	da00a017 	ldw	r8,640(sp)
81122734:	403e9c26 	beq	r8,zero,811221a8 <__reset+0xfb1021a8>
81122738:	e080030b 	ldhu	r2,12(fp)
8112273c:	1080100c 	andi	r2,r2,64
81122740:	103e991e 	bne	r2,zero,811221a8 <__reset+0xfb1021a8>
81122744:	4005883a 	mov	r2,r8
81122748:	003e9806 	br	811221ac <__reset+0xfb1021ac>
8112274c:	983f951e 	bne	r19,zero,811225a4 <__reset+0xfb1025a4>
81122750:	003fb806 	br	81122634 <__reset+0xfb102634>
81122754:	da009c17 	ldw	r8,624(sp)
81122758:	45000017 	ldw	r20,0(r8)
8112275c:	42000104 	addi	r8,r8,4
81122760:	da009c15 	stw	r8,624(sp)
81122764:	003f8e06 	br	811225a0 <__reset+0xfb1025a0>
81122768:	e00b883a 	mov	r5,fp
8112276c:	b009883a 	mov	r4,r22
81122770:	111d1180 	call	8111d118 <__srefill_r>
81122774:	103f3826 	beq	r2,zero,81122458 <__reset+0xfb102458>
81122778:	003fed06 	br	81122730 <__reset+0xfb102730>
8112277c:	00ffff84 	movi	r3,-2
81122780:	10c0071e 	bne	r2,r3,811227a0 <__svfscanf_r+0x968>
81122784:	e0800117 	ldw	r2,4(fp)
81122788:	8023883a 	mov	r17,r16
8112278c:	00bf8516 	blt	zero,r2,811225a4 <__reset+0xfb1025a4>
81122790:	003fa306 	br	81122620 <__reset+0xfb102620>
81122794:	9425883a 	add	r18,r18,r16
81122798:	9cffffc4 	addi	r19,r19,-1
8112279c:	003f9d06 	br	81122614 <__reset+0xfb102614>
811227a0:	da009f17 	ldw	r8,636(sp)
811227a4:	9425883a 	add	r18,r18,r16
811227a8:	9cffffc4 	addi	r19,r19,-1
811227ac:	403f9826 	beq	r8,zero,81122610 <__reset+0xfb102610>
811227b0:	003f9806 	br	81122614 <__reset+0xfb102614>
811227b4:	8023883a 	mov	r17,r16
811227b8:	8821883a 	mov	r16,r17
811227bc:	003fce06 	br	811226f8 <__reset+0xfb1026f8>
811227c0:	803f3d1e 	bne	r16,zero,811224b8 <__reset+0xfb1024b8>
811227c4:	003fda06 	br	81122730 <__reset+0xfb102730>
811227c8:	1827883a 	mov	r19,r3
811227cc:	003fc306 	br	811226dc <__reset+0xfb1026dc>
811227d0:	803fc91e 	bne	r16,zero,811226f8 <__reset+0xfb1026f8>
811227d4:	003dda06 	br	81121f40 <__reset+0xfb101f40>
811227d8:	da009c17 	ldw	r8,624(sp)
811227dc:	df000015 	stw	fp,0(sp)
811227e0:	980f883a 	mov	r7,r19
811227e4:	41400017 	ldw	r5,0(r8)
811227e8:	01800044 	movi	r6,1
811227ec:	b009883a 	mov	r4,r22
811227f0:	1125a100 	call	81125a10 <_fread_r>
811227f4:	da009c17 	ldw	r8,624(sp)
811227f8:	40c00104 	addi	r3,r8,4
811227fc:	103fcc26 	beq	r2,zero,81122730 <__reset+0xfb102730>
81122800:	da00a017 	ldw	r8,640(sp)
81122804:	dd009d17 	ldw	r20,628(sp)
81122808:	90a5883a 	add	r18,r18,r2
8112280c:	42000044 	addi	r8,r8,1
81122810:	da00a015 	stw	r8,640(sp)
81122814:	d8c09c15 	stw	r3,624(sp)
81122818:	a00d883a 	mov	r6,r20
8112281c:	003dc406 	br	81121f30 <__reset+0xfb101f30>
81122820:	e00b883a 	mov	r5,fp
81122824:	b009883a 	mov	r4,r22
81122828:	111d1180 	call	8111d118 <__srefill_r>
8112282c:	103e5226 	beq	r2,zero,81122178 <__reset+0xfb102178>
81122830:	003fbf06 	br	81122730 <__reset+0xfb102730>
81122834:	a0800083 	ldbu	r2,2(r20)
81122838:	8c400094 	ori	r17,r17,2
8112283c:	a5000084 	addi	r20,r20,2
81122840:	10c03fcc 	andi	r3,r2,255
81122844:	003dc706 	br	81121f64 <__reset+0xfb101f64>
81122848:	e0800117 	ldw	r2,4(fp)
8112284c:	88e2b03a 	or	r17,r17,r3
81122850:	00bef716 	blt	zero,r2,81122430 <__reset+0xfb102430>
81122854:	003e6f06 	br	81122214 <__reset+0xfb102214>
81122858:	8880004c 	andi	r2,r17,1
8112285c:	10000b1e 	bne	r2,zero,8112288c <__svfscanf_r+0xa54>
81122860:	8c40008c 	andi	r17,r17,2
81122864:	88000926 	beq	r17,zero,8112288c <__svfscanf_r+0xa54>
81122868:	da009c17 	ldw	r8,624(sp)
8112286c:	9007d7fa 	srai	r3,r18,31
81122870:	dd009d17 	ldw	r20,628(sp)
81122874:	40800017 	ldw	r2,0(r8)
81122878:	42000104 	addi	r8,r8,4
8112287c:	da009c15 	stw	r8,624(sp)
81122880:	14800015 	stw	r18,0(r2)
81122884:	10c00115 	stw	r3,4(r2)
81122888:	003da806 	br	81121f2c <__reset+0xfb101f2c>
8112288c:	da009c17 	ldw	r8,624(sp)
81122890:	dd009d17 	ldw	r20,628(sp)
81122894:	40800017 	ldw	r2,0(r8)
81122898:	42000104 	addi	r8,r8,4
8112289c:	da009c15 	stw	r8,624(sp)
811228a0:	14800015 	stw	r18,0(r2)
811228a4:	003da106 	br	81121f2c <__reset+0xfb101f2c>
811228a8:	e00b883a 	mov	r5,fp
811228ac:	b009883a 	mov	r4,r22
811228b0:	111d1180 	call	8111d118 <__srefill_r>
811228b4:	103f9e1e 	bne	r2,zero,81122730 <__reset+0xfb102730>
811228b8:	b9c00017 	ldw	r7,0(r23)
811228bc:	05000104 	movi	r20,4
811228c0:	003e6306 	br	81122250 <__reset+0xfb102250>
811228c4:	e00b883a 	mov	r5,fp
811228c8:	b009883a 	mov	r4,r22
811228cc:	111d1180 	call	8111d118 <__srefill_r>
811228d0:	103f971e 	bne	r2,zero,81122730 <__reset+0xfb102730>
811228d4:	b9c00017 	ldw	r7,0(r23)
811228d8:	003e5706 	br	81122238 <__reset+0xfb102238>
811228dc:	e00b883a 	mov	r5,fp
811228e0:	b009883a 	mov	r4,r22
811228e4:	111d1180 	call	8111d118 <__srefill_r>
811228e8:	103f911e 	bne	r2,zero,81122730 <__reset+0xfb102730>
811228ec:	b9c00017 	ldw	r7,0(r23)
811228f0:	05000084 	movi	r20,2
811228f4:	003e5606 	br	81122250 <__reset+0xfb102250>
811228f8:	e00b883a 	mov	r5,fp
811228fc:	b009883a 	mov	r4,r22
81122900:	111d1180 	call	8111d118 <__srefill_r>
81122904:	103ef726 	beq	r2,zero,811224e4 <__reset+0xfb1024e4>
81122908:	003f8906 	br	81122730 <__reset+0xfb102730>
8112290c:	e00b883a 	mov	r5,fp
81122910:	b009883a 	mov	r4,r22
81122914:	111d1180 	call	8111d118 <__srefill_r>
81122918:	103f851e 	bne	r2,zero,81122730 <__reset+0xfb102730>
8112291c:	b9c00017 	ldw	r7,0(r23)
81122920:	003f0f06 	br	81122560 <__reset+0xfb102560>
81122924:	014000c4 	movi	r5,3
81122928:	a1414a26 	beq	r20,r5,81122e54 <__svfscanf_r+0x101c>
8112292c:	01000104 	movi	r4,4
81122930:	a101f11e 	bne	r20,r4,811230f8 <__svfscanf_r+0x12c0>
81122934:	b009883a 	mov	r4,r22
81122938:	11268600 	call	81126860 <_localeconv_r>
8112293c:	10800017 	ldw	r2,0(r2)
81122940:	98ffffc4 	addi	r3,r19,-1
81122944:	d880a315 	stw	r2,652(sp)
81122948:	00805704 	movi	r2,348
8112294c:	10c21e2e 	bgeu	r2,r3,811231c8 <__svfscanf_r+0x1390>
81122950:	9cffa8c4 	addi	r19,r19,-349
81122954:	dcc0a215 	stw	r19,648(sp)
81122958:	04c05744 	movi	r19,349
8112295c:	8d01e014 	ori	r20,r17,1920
81122960:	0023883a 	mov	r17,zero
81122964:	dc000104 	addi	r16,sp,4
81122968:	8805883a 	mov	r2,r17
8112296c:	0019883a 	mov	r12,zero
81122970:	8023883a 	mov	r17,r16
81122974:	b007883a 	mov	r3,r22
81122978:	9821883a 	mov	r16,r19
8112297c:	002b883a 	mov	r21,zero
81122980:	d800a515 	stw	zero,660(sp)
81122984:	d800a415 	stw	zero,656(sp)
81122988:	d8009f15 	stw	zero,636(sp)
8112298c:	01c01384 	movi	r7,78
81122990:	602d883a 	mov	r22,r12
81122994:	1027883a 	mov	r19,r2
81122998:	e1000017 	ldw	r4,0(fp)
8112299c:	21400003 	ldbu	r5,0(r4)
811229a0:	28bff544 	addi	r2,r5,-43
811229a4:	10803fcc 	andi	r2,r2,255
811229a8:	38810e36 	bltu	r7,r2,81122de4 <__svfscanf_r+0xfac>
811229ac:	100490ba 	slli	r2,r2,2
811229b0:	01a044b4 	movhi	r6,33042
811229b4:	318a7104 	addi	r6,r6,10692
811229b8:	1185883a 	add	r2,r2,r6
811229bc:	10800017 	ldw	r2,0(r2)
811229c0:	1000683a 	jmp	r2
811229c4:	81122cbc 	xorhi	r4,r16,18610
811229c8:	81122de4 	muli	r4,r16,18615
811229cc:	81122cbc 	xorhi	r4,r16,18610
811229d0:	81122de4 	muli	r4,r16,18615
811229d4:	81122de4 	muli	r4,r16,18615
811229d8:	81122c90 	cmplti	r4,r16,18610
811229dc:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229e0:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229e4:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229e8:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229ec:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229f0:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229f4:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229f8:	81122b00 	call	881122b0 <__reset+0x20f22b0>
811229fc:	81122b00 	call	881122b0 <__reset+0x20f22b0>
81122a00:	81122de4 	muli	r4,r16,18615
81122a04:	81122de4 	muli	r4,r16,18615
81122a08:	81122de4 	muli	r4,r16,18615
81122a0c:	81122de4 	muli	r4,r16,18615
81122a10:	81122de4 	muli	r4,r16,18615
81122a14:	81122de4 	muli	r4,r16,18615
81122a18:	81122de4 	muli	r4,r16,18615
81122a1c:	81122dd4 	ori	r4,r16,18615
81122a20:	81122de4 	muli	r4,r16,18615
81122a24:	81122de4 	muli	r4,r16,18615
81122a28:	81122de4 	muli	r4,r16,18615
81122a2c:	81122d90 	cmplti	r4,r16,18614
81122a30:	81122d74 	orhi	r4,r16,18613
81122a34:	81122de4 	muli	r4,r16,18615
81122a38:	81122de4 	muli	r4,r16,18615
81122a3c:	81122d40 	call	881122d4 <__reset+0x20f22d4>
81122a40:	81122de4 	muli	r4,r16,18615
81122a44:	81122de4 	muli	r4,r16,18615
81122a48:	81122de4 	muli	r4,r16,18615
81122a4c:	81122de4 	muli	r4,r16,18615
81122a50:	81122d08 	cmpgei	r4,r16,18612
81122a54:	81122de4 	muli	r4,r16,18615
81122a58:	81122de4 	muli	r4,r16,18615
81122a5c:	81122de4 	muli	r4,r16,18615
81122a60:	81122de4 	muli	r4,r16,18615
81122a64:	81122de4 	muli	r4,r16,18615
81122a68:	81122cec 	andhi	r4,r16,18611
81122a6c:	81122de4 	muli	r4,r16,18615
81122a70:	81122de4 	muli	r4,r16,18615
81122a74:	81122de4 	muli	r4,r16,18615
81122a78:	81122de4 	muli	r4,r16,18615
81122a7c:	81122cd0 	cmplti	r4,r16,18611
81122a80:	81122de4 	muli	r4,r16,18615
81122a84:	81122de4 	muli	r4,r16,18615
81122a88:	81122de4 	muli	r4,r16,18615
81122a8c:	81122de4 	muli	r4,r16,18615
81122a90:	81122de4 	muli	r4,r16,18615
81122a94:	81122de4 	muli	r4,r16,18615
81122a98:	81122de4 	muli	r4,r16,18615
81122a9c:	81122dd4 	ori	r4,r16,18615
81122aa0:	81122de4 	muli	r4,r16,18615
81122aa4:	81122de4 	muli	r4,r16,18615
81122aa8:	81122de4 	muli	r4,r16,18615
81122aac:	81122d90 	cmplti	r4,r16,18614
81122ab0:	81122d74 	orhi	r4,r16,18613
81122ab4:	81122de4 	muli	r4,r16,18615
81122ab8:	81122de4 	muli	r4,r16,18615
81122abc:	81122d40 	call	881122d4 <__reset+0x20f22d4>
81122ac0:	81122de4 	muli	r4,r16,18615
81122ac4:	81122de4 	muli	r4,r16,18615
81122ac8:	81122de4 	muli	r4,r16,18615
81122acc:	81122de4 	muli	r4,r16,18615
81122ad0:	81122d08 	cmpgei	r4,r16,18612
81122ad4:	81122de4 	muli	r4,r16,18615
81122ad8:	81122de4 	muli	r4,r16,18615
81122adc:	81122de4 	muli	r4,r16,18615
81122ae0:	81122de4 	muli	r4,r16,18615
81122ae4:	81122de4 	muli	r4,r16,18615
81122ae8:	81122cec 	andhi	r4,r16,18611
81122aec:	81122de4 	muli	r4,r16,18615
81122af0:	81122de4 	muli	r4,r16,18615
81122af4:	81122de4 	muli	r4,r16,18615
81122af8:	81122de4 	muli	r4,r16,18615
81122afc:	81122cd0 	cmplti	r4,r16,18611
81122b00:	a8803fcc 	andi	r2,r21,255
81122b04:	1080201c 	xori	r2,r2,128
81122b08:	10bfe004 	addi	r2,r2,-128
81122b0c:	b085883a 	add	r2,r22,r2
81122b10:	10000d1e 	bne	r2,zero,81122b48 <__svfscanf_r+0xd10>
81122b14:	00bf9fc4 	movi	r2,-385
81122b18:	a0a8703a 	and	r20,r20,r2
81122b1c:	89400005 	stb	r5,0(r17)
81122b20:	8c400044 	addi	r17,r17,1
81122b24:	e0800117 	ldw	r2,4(fp)
81122b28:	843fffc4 	addi	r16,r16,-1
81122b2c:	94800044 	addi	r18,r18,1
81122b30:	10bfffc4 	addi	r2,r2,-1
81122b34:	e0800115 	stw	r2,4(fp)
81122b38:	0080b40e 	bge	zero,r2,81122e0c <__svfscanf_r+0xfd4>
81122b3c:	21000044 	addi	r4,r4,1
81122b40:	e1000015 	stw	r4,0(fp)
81122b44:	803f941e 	bne	r16,zero,81122998 <__reset+0xfb102998>
81122b48:	8821883a 	mov	r16,r17
81122b4c:	b019883a 	mov	r12,r22
81122b50:	9823883a 	mov	r17,r19
81122b54:	182d883a 	mov	r22,r3
81122b58:	9801961e 	bne	r19,zero,811231b4 <__svfscanf_r+0x137c>
81122b5c:	633fffc4 	addi	r12,r12,-1
81122b60:	00800044 	movi	r2,1
81122b64:	1302882e 	bgeu	r2,r12,81123588 <__svfscanf_r+0x1750>
81122b68:	a8803fcc 	andi	r2,r21,255
81122b6c:	1080201c 	xori	r2,r2,128
81122b70:	10bfe004 	addi	r2,r2,-128
81122b74:	113fffc4 	addi	r4,r2,-1
81122b78:	01400184 	movi	r5,6
81122b7c:	29001136 	bltu	r5,r4,81122bc4 <__svfscanf_r+0xd8c>
81122b80:	01000084 	movi	r4,2
81122b84:	2082900e 	bge	r4,r2,811235c8 <__svfscanf_r+0x1790>
81122b88:	00c000c4 	movi	r3,3
81122b8c:	10c00d26 	beq	r2,r3,81122bc4 <__svfscanf_r+0xd8c>
81122b90:	9425c83a 	sub	r18,r18,r16
81122b94:	1827883a 	mov	r19,r3
81122b98:	843fffc4 	addi	r16,r16,-1
81122b9c:	81400007 	ldb	r5,0(r16)
81122ba0:	e00d883a 	mov	r6,fp
81122ba4:	b009883a 	mov	r4,r22
81122ba8:	112ba900 	call	8112ba90 <_ungetc_r>
81122bac:	a8bfffc4 	addi	r2,r21,-1
81122bb0:	10c03fcc 	andi	r3,r2,255
81122bb4:	8493883a 	add	r9,r16,r18
81122bb8:	102b883a 	mov	r21,r2
81122bbc:	98fff636 	bltu	r19,r3,81122b98 <__reset+0xfb102b98>
81122bc0:	4825883a 	mov	r18,r9
81122bc4:	a080400c 	andi	r2,r20,256
81122bc8:	10001426 	beq	r2,zero,81122c1c <__svfscanf_r+0xde4>
81122bcc:	a081000c 	andi	r2,r20,1024
81122bd0:	1002571e 	bne	r2,zero,81123530 <__svfscanf_r+0x16f8>
81122bd4:	817fffc7 	ldb	r5,-1(r16)
81122bd8:	00801944 	movi	r2,101
81122bdc:	84ffffc4 	addi	r19,r16,-1
81122be0:	957fffc4 	addi	r21,r18,-1
81122be4:	28800826 	beq	r5,r2,81122c08 <__svfscanf_r+0xdd0>
81122be8:	00801144 	movi	r2,69
81122bec:	28800626 	beq	r5,r2,81122c08 <__svfscanf_r+0xdd0>
81122bf0:	e00d883a 	mov	r6,fp
81122bf4:	b009883a 	mov	r4,r22
81122bf8:	112ba900 	call	8112ba90 <_ungetc_r>
81122bfc:	817fff87 	ldb	r5,-2(r16)
81122c00:	84ffff84 	addi	r19,r16,-2
81122c04:	957fff84 	addi	r21,r18,-2
81122c08:	e00d883a 	mov	r6,fp
81122c0c:	b009883a 	mov	r4,r22
81122c10:	112ba900 	call	8112ba90 <_ungetc_r>
81122c14:	a825883a 	mov	r18,r21
81122c18:	9821883a 	mov	r16,r19
81122c1c:	a080040c 	andi	r2,r20,16
81122c20:	103e891e 	bne	r2,zero,81122648 <__reset+0xfb102648>
81122c24:	80000005 	stb	zero,0(r16)
81122c28:	a081800c 	andi	r2,r20,1536
81122c2c:	01010004 	movi	r4,1024
81122c30:	1101dd26 	beq	r2,r4,811233a8 <__svfscanf_r+0x1570>
81122c34:	da00a417 	ldw	r8,656(sp)
81122c38:	4001e71e 	bne	r8,zero,811233d8 <__svfscanf_r+0x15a0>
81122c3c:	000d883a 	mov	r6,zero
81122c40:	d9400104 	addi	r5,sp,4
81122c44:	b009883a 	mov	r4,r22
81122c48:	11286400 	call	81128640 <_strtod_r>
81122c4c:	1021883a 	mov	r16,r2
81122c50:	a080004c 	andi	r2,r20,1
81122c54:	1000021e 	bne	r2,zero,81122c60 <__svfscanf_r+0xe28>
81122c58:	a2c0008c 	andi	r11,r20,2
81122c5c:	5801e826 	beq	r11,zero,81123400 <__svfscanf_r+0x15c8>
81122c60:	da009c17 	ldw	r8,624(sp)
81122c64:	40800017 	ldw	r2,0(r8)
81122c68:	42000104 	addi	r8,r8,4
81122c6c:	da009c15 	stw	r8,624(sp)
81122c70:	14000015 	stw	r16,0(r2)
81122c74:	10c00115 	stw	r3,4(r2)
81122c78:	da00a017 	ldw	r8,640(sp)
81122c7c:	dd009d17 	ldw	r20,628(sp)
81122c80:	42000044 	addi	r8,r8,1
81122c84:	da00a015 	stw	r8,640(sp)
81122c88:	a00d883a 	mov	r6,r20
81122c8c:	003ca806 	br	81121f30 <__reset+0xfb101f30>
81122c90:	a080400c 	andi	r2,r20,256
81122c94:	103f9a26 	beq	r2,zero,81122b00 <__reset+0xfb102b00>
81122c98:	da00a217 	ldw	r8,648(sp)
81122c9c:	00bfdfc4 	movi	r2,-129
81122ca0:	a0a8703a 	and	r20,r20,r2
81122ca4:	9cc00044 	addi	r19,r19,1
81122ca8:	403f9e26 	beq	r8,zero,81122b24 <__reset+0xfb102b24>
81122cac:	423fffc4 	addi	r8,r8,-1
81122cb0:	da00a215 	stw	r8,648(sp)
81122cb4:	84000044 	addi	r16,r16,1
81122cb8:	003f9a06 	br	81122b24 <__reset+0xfb102b24>
81122cbc:	a080200c 	andi	r2,r20,128
81122cc0:	103fa126 	beq	r2,zero,81122b48 <__reset+0xfb102b48>
81122cc4:	00bfdfc4 	movi	r2,-129
81122cc8:	a0a8703a 	and	r20,r20,r2
81122ccc:	003f9306 	br	81122b1c <__reset+0xfb102b1c>
81122cd0:	a8803fcc 	andi	r2,r21,255
81122cd4:	1080201c 	xori	r2,r2,128
81122cd8:	10bfe004 	addi	r2,r2,-128
81122cdc:	020001c4 	movi	r8,7
81122ce0:	123f991e 	bne	r2,r8,81122b48 <__reset+0xfb102b48>
81122ce4:	05400204 	movi	r21,8
81122ce8:	003f8c06 	br	81122b1c <__reset+0xfb102b1c>
81122cec:	a8803fcc 	andi	r2,r21,255
81122cf0:	1080201c 	xori	r2,r2,128
81122cf4:	10bfe004 	addi	r2,r2,-128
81122cf8:	01800184 	movi	r6,6
81122cfc:	11bf921e 	bne	r2,r6,81122b48 <__reset+0xfb102b48>
81122d00:	054001c4 	movi	r21,7
81122d04:	003f8506 	br	81122b1c <__reset+0xfb102b1c>
81122d08:	b000491e 	bne	r22,zero,81122e30 <__svfscanf_r+0xff8>
81122d0c:	9800031e 	bne	r19,zero,81122d1c <__svfscanf_r+0xee4>
81122d10:	a081c00c 	andi	r2,r20,1792
81122d14:	0181c004 	movi	r6,1792
81122d18:	11819f26 	beq	r2,r6,81123398 <__svfscanf_r+0x1560>
81122d1c:	a8803fcc 	andi	r2,r21,255
81122d20:	1080201c 	xori	r2,r2,128
81122d24:	10bfe004 	addi	r2,r2,-128
81122d28:	01800044 	movi	r6,1
81122d2c:	11800226 	beq	r2,r6,81122d38 <__svfscanf_r+0xf00>
81122d30:	01800104 	movi	r6,4
81122d34:	11bf841e 	bne	r2,r6,81122b48 <__reset+0xfb102b48>
81122d38:	ad400044 	addi	r21,r21,1
81122d3c:	003f7706 	br	81122b1c <__reset+0xfb102b1c>
81122d40:	a8803fcc 	andi	r2,r21,255
81122d44:	1080201c 	xori	r2,r2,128
81122d48:	10bfe004 	addi	r2,r2,-128
81122d4c:	10003c1e 	bne	r2,zero,81122e40 <__svfscanf_r+0x1008>
81122d50:	9801141e 	bne	r19,zero,811231a4 <__svfscanf_r+0x136c>
81122d54:	a081c00c 	andi	r2,r20,1792
81122d58:	0181c004 	movi	r6,1792
81122d5c:	11818226 	beq	r2,r6,81123368 <__svfscanf_r+0x1530>
81122d60:	8821883a 	mov	r16,r17
81122d64:	b019883a 	mov	r12,r22
81122d68:	9823883a 	mov	r17,r19
81122d6c:	182d883a 	mov	r22,r3
81122d70:	003f7a06 	br	81122b5c <__reset+0xfb102b5c>
81122d74:	a8803fcc 	andi	r2,r21,255
81122d78:	1080201c 	xori	r2,r2,128
81122d7c:	10bfe004 	addi	r2,r2,-128
81122d80:	01800084 	movi	r6,2
81122d84:	11bf701e 	bne	r2,r6,81122b48 <__reset+0xfb102b48>
81122d88:	054000c4 	movi	r21,3
81122d8c:	003f6306 	br	81122b1c <__reset+0xfb102b1c>
81122d90:	a081400c 	andi	r2,r20,1280
81122d94:	01810004 	movi	r6,1024
81122d98:	11800326 	beq	r2,r6,81122da8 <__svfscanf_r+0xf70>
81122d9c:	a184703a 	and	r2,r20,r6
81122da0:	103f6926 	beq	r2,zero,81122b48 <__reset+0xfb102b48>
81122da4:	983fee26 	beq	r19,zero,81122d60 <__reset+0xfb102d60>
81122da8:	a080800c 	andi	r2,r20,512
81122dac:	1000041e 	bne	r2,zero,81122dc0 <__svfscanf_r+0xf88>
81122db0:	da009f17 	ldw	r8,636(sp)
81122db4:	dc40a515 	stw	r17,660(sp)
81122db8:	9a27c83a 	sub	r19,r19,r8
81122dbc:	dcc0a415 	stw	r19,656(sp)
81122dc0:	00be1fc4 	movi	r2,-1921
81122dc4:	a0a8703a 	and	r20,r20,r2
81122dc8:	a5006014 	ori	r20,r20,384
81122dcc:	0027883a 	mov	r19,zero
81122dd0:	003f5206 	br	81122b1c <__reset+0xfb102b1c>
81122dd4:	00800044 	movi	r2,1
81122dd8:	b0bf5b1e 	bne	r22,r2,81122b48 <__reset+0xfb102b48>
81122ddc:	05800084 	movi	r22,2
81122de0:	003f4e06 	br	81122b1c <__reset+0xfb102b1c>
81122de4:	d980a317 	ldw	r6,652(sp)
81122de8:	30800003 	ldbu	r2,0(r6)
81122dec:	29803fcc 	andi	r6,r5,255
81122df0:	30bf551e 	bne	r6,r2,81122b48 <__reset+0xfb102b48>
81122df4:	a080800c 	andi	r2,r20,512
81122df8:	103f5326 	beq	r2,zero,81122b48 <__reset+0xfb102b48>
81122dfc:	023f5fc4 	movi	r8,-641
81122e00:	a228703a 	and	r20,r20,r8
81122e04:	dcc09f15 	stw	r19,636(sp)
81122e08:	003f4406 	br	81122b1c <__reset+0xfb102b1c>
81122e0c:	1809883a 	mov	r4,r3
81122e10:	e00b883a 	mov	r5,fp
81122e14:	d8c0a615 	stw	r3,664(sp)
81122e18:	d9c0aa15 	stw	r7,680(sp)
81122e1c:	111d1180 	call	8111d118 <__srefill_r>
81122e20:	d8c0a617 	ldw	r3,664(sp)
81122e24:	d9c0aa17 	ldw	r7,680(sp)
81122e28:	103f4626 	beq	r2,zero,81122b44 <__reset+0xfb102b44>
81122e2c:	003f4606 	br	81122b48 <__reset+0xfb102b48>
81122e30:	00800084 	movi	r2,2
81122e34:	b0bfb91e 	bne	r22,r2,81122d1c <__reset+0xfb102d1c>
81122e38:	058000c4 	movi	r22,3
81122e3c:	003f3706 	br	81122b1c <__reset+0xfb102b1c>
81122e40:	018000c4 	movi	r6,3
81122e44:	11bfbc26 	beq	r2,r6,81122d38 <__reset+0xfb102d38>
81122e48:	01800144 	movi	r6,5
81122e4c:	11bfba26 	beq	r2,r6,81122d38 <__reset+0xfb102d38>
81122e50:	003f3d06 	br	81122b48 <__reset+0xfb102b48>
81122e54:	98bfffc4 	addi	r2,r19,-1
81122e58:	01405704 	movi	r5,348
81122e5c:	2880d82e 	bgeu	r5,r2,811231c0 <__svfscanf_r+0x1388>
81122e60:	99ffa8c4 	addi	r7,r19,-349
81122e64:	04c05744 	movi	r19,349
81122e68:	8c436014 	ori	r17,r17,3456
81122e6c:	9013883a 	mov	r9,r18
81122e70:	8825883a 	mov	r18,r17
81122e74:	dc409e17 	ldw	r17,632(sp)
81122e78:	0029883a 	mov	r20,zero
81122e7c:	dc000104 	addi	r16,sp,4
81122e80:	05401344 	movi	r21,77
81122e84:	02c08004 	movi	r11,512
81122e88:	01bf7fc4 	movi	r6,-513
81122e8c:	023fdfc4 	movi	r8,-129
81122e90:	20bff544 	addi	r2,r4,-43
81122e94:	10803fcc 	andi	r2,r2,255
81122e98:	a8807236 	bltu	r21,r2,81123064 <__svfscanf_r+0x122c>
81122e9c:	100490ba 	slli	r2,r2,2
81122ea0:	016044b4 	movhi	r5,33042
81122ea4:	294bad04 	addi	r5,r5,11956
81122ea8:	1145883a 	add	r2,r2,r5
81122eac:	10800017 	ldw	r2,0(r2)
81122eb0:	1000683a 	jmp	r2
81122eb4:	811230e8 	cmpgeui	r4,r16,18627
81122eb8:	81123064 	muli	r4,r16,18625
81122ebc:	811230e8 	cmpgeui	r4,r16,18627
81122ec0:	81123064 	muli	r4,r16,18625
81122ec4:	81123064 	muli	r4,r16,18625
81122ec8:	811230c0 	call	8811230c <__reset+0x20f230c>
81122ecc:	811230a0 	cmpeqi	r4,r16,18626
81122ed0:	811230a0 	cmpeqi	r4,r16,18626
81122ed4:	811230a0 	cmpeqi	r4,r16,18626
81122ed8:	811230a0 	cmpeqi	r4,r16,18626
81122edc:	811230a0 	cmpeqi	r4,r16,18626
81122ee0:	811230a0 	cmpeqi	r4,r16,18626
81122ee4:	811230a0 	cmpeqi	r4,r16,18626
81122ee8:	81123048 	cmpgei	r4,r16,18625
81122eec:	81123048 	cmpgei	r4,r16,18625
81122ef0:	81123064 	muli	r4,r16,18625
81122ef4:	81123064 	muli	r4,r16,18625
81122ef8:	81123064 	muli	r4,r16,18625
81122efc:	81123064 	muli	r4,r16,18625
81122f00:	81123064 	muli	r4,r16,18625
81122f04:	81123064 	muli	r4,r16,18625
81122f08:	81123064 	muli	r4,r16,18625
81122f0c:	81123034 	orhi	r4,r16,18624
81122f10:	81123034 	orhi	r4,r16,18624
81122f14:	81123034 	orhi	r4,r16,18624
81122f18:	81123034 	orhi	r4,r16,18624
81122f1c:	81123034 	orhi	r4,r16,18624
81122f20:	81123034 	orhi	r4,r16,18624
81122f24:	81123064 	muli	r4,r16,18625
81122f28:	81123064 	muli	r4,r16,18625
81122f2c:	81123064 	muli	r4,r16,18625
81122f30:	81123064 	muli	r4,r16,18625
81122f34:	81123064 	muli	r4,r16,18625
81122f38:	81123064 	muli	r4,r16,18625
81122f3c:	81123064 	muli	r4,r16,18625
81122f40:	81123064 	muli	r4,r16,18625
81122f44:	81123064 	muli	r4,r16,18625
81122f48:	81123064 	muli	r4,r16,18625
81122f4c:	81123064 	muli	r4,r16,18625
81122f50:	81123064 	muli	r4,r16,18625
81122f54:	81123064 	muli	r4,r16,18625
81122f58:	81123064 	muli	r4,r16,18625
81122f5c:	81123064 	muli	r4,r16,18625
81122f60:	81123064 	muli	r4,r16,18625
81122f64:	81123064 	muli	r4,r16,18625
81122f68:	81122fec 	andhi	r4,r16,18623
81122f6c:	81123064 	muli	r4,r16,18625
81122f70:	81123064 	muli	r4,r16,18625
81122f74:	81123064 	muli	r4,r16,18625
81122f78:	81123064 	muli	r4,r16,18625
81122f7c:	81123064 	muli	r4,r16,18625
81122f80:	81123064 	muli	r4,r16,18625
81122f84:	81123064 	muli	r4,r16,18625
81122f88:	81123064 	muli	r4,r16,18625
81122f8c:	81123034 	orhi	r4,r16,18624
81122f90:	81123034 	orhi	r4,r16,18624
81122f94:	81123034 	orhi	r4,r16,18624
81122f98:	81123034 	orhi	r4,r16,18624
81122f9c:	81123034 	orhi	r4,r16,18624
81122fa0:	81123034 	orhi	r4,r16,18624
81122fa4:	81123064 	muli	r4,r16,18625
81122fa8:	81123064 	muli	r4,r16,18625
81122fac:	81123064 	muli	r4,r16,18625
81122fb0:	81123064 	muli	r4,r16,18625
81122fb4:	81123064 	muli	r4,r16,18625
81122fb8:	81123064 	muli	r4,r16,18625
81122fbc:	81123064 	muli	r4,r16,18625
81122fc0:	81123064 	muli	r4,r16,18625
81122fc4:	81123064 	muli	r4,r16,18625
81122fc8:	81123064 	muli	r4,r16,18625
81122fcc:	81123064 	muli	r4,r16,18625
81122fd0:	81123064 	muli	r4,r16,18625
81122fd4:	81123064 	muli	r4,r16,18625
81122fd8:	81123064 	muli	r4,r16,18625
81122fdc:	81123064 	muli	r4,r16,18625
81122fe0:	81123064 	muli	r4,r16,18625
81122fe4:	81123064 	muli	r4,r16,18625
81122fe8:	81122fec 	andhi	r4,r16,18623
81122fec:	9081800c 	andi	r2,r18,1536
81122ff0:	12c01c1e 	bne	r2,r11,81123064 <__svfscanf_r+0x122c>
81122ff4:	91a4703a 	and	r18,r18,r6
81122ff8:	94814014 	ori	r18,r18,1280
81122ffc:	04400404 	movi	r17,16
81123000:	81000005 	stb	r4,0(r16)
81123004:	84000044 	addi	r16,r16,1
81123008:	e0800117 	ldw	r2,4(fp)
8112300c:	10bfffc4 	addi	r2,r2,-1
81123010:	e0800115 	stw	r2,4(fp)
81123014:	0080540e 	bge	zero,r2,81123168 <__svfscanf_r+0x1330>
81123018:	18c00044 	addi	r3,r3,1
8112301c:	e0c00015 	stw	r3,0(fp)
81123020:	9cffffc4 	addi	r19,r19,-1
81123024:	98000f26 	beq	r19,zero,81123064 <__svfscanf_r+0x122c>
81123028:	e0c00017 	ldw	r3,0(fp)
8112302c:	19000003 	ldbu	r4,0(r3)
81123030:	003f9706 	br	81122e90 <__reset+0xfb102e90>
81123034:	00800284 	movi	r2,10
81123038:	14400a0e 	bge	r2,r17,81123064 <__svfscanf_r+0x122c>
8112303c:	00bd1fc4 	movi	r2,-2945
81123040:	90a4703a 	and	r18,r18,r2
81123044:	003fee06 	br	81123000 <__reset+0xfb103000>
81123048:	01604574 	movhi	r5,33045
8112304c:	8c63883a 	add	r17,r17,r17
81123050:	296b7384 	addi	r5,r5,-21042
81123054:	2c45883a 	add	r2,r5,r17
81123058:	1440000f 	ldh	r17,0(r2)
8112305c:	00800204 	movi	r2,8
81123060:	147ff616 	blt	r2,r17,8112303c <__reset+0xfb10303c>
81123064:	dc409e15 	stw	r17,632(sp)
81123068:	9023883a 	mov	r17,r18
8112306c:	8880400c 	andi	r2,r17,256
81123070:	4825883a 	mov	r18,r9
81123074:	10000426 	beq	r2,zero,81123088 <__svfscanf_r+0x1250>
81123078:	d9800104 	addi	r6,sp,4
8112307c:	3400be36 	bltu	r6,r16,81123378 <__svfscanf_r+0x1540>
81123080:	da000104 	addi	r8,sp,4
81123084:	443bae26 	beq	r8,r16,81121f40 <__reset+0xfb101f40>
81123088:	8880040c 	andi	r2,r17,16
8112308c:	10009326 	beq	r2,zero,811232dc <__svfscanf_r+0x14a4>
81123090:	d8800104 	addi	r2,sp,4
81123094:	80a1c83a 	sub	r16,r16,r2
81123098:	8521883a 	add	r16,r16,r20
8112309c:	003d0606 	br	811224b8 <__reset+0xfb1024b8>
811230a0:	01604574 	movhi	r5,33045
811230a4:	8c63883a 	add	r17,r17,r17
811230a8:	296b7384 	addi	r5,r5,-21042
811230ac:	2c45883a 	add	r2,r5,r17
811230b0:	1440000f 	ldh	r17,0(r2)
811230b4:	00bd1fc4 	movi	r2,-2945
811230b8:	90a4703a 	and	r18,r18,r2
811230bc:	003fd006 	br	81123000 <__reset+0xfb103000>
811230c0:	9082000c 	andi	r2,r18,2048
811230c4:	103fce26 	beq	r2,zero,81123000 <__reset+0xfb103000>
811230c8:	8800021e 	bne	r17,zero,811230d4 <__svfscanf_r+0x129c>
811230cc:	94808014 	ori	r18,r18,512
811230d0:	04400204 	movi	r17,8
811230d4:	9081000c 	andi	r2,r18,1024
811230d8:	10009426 	beq	r2,zero,8112332c <__svfscanf_r+0x14f4>
811230dc:	00be9fc4 	movi	r2,-1409
811230e0:	90a4703a 	and	r18,r18,r2
811230e4:	003fc606 	br	81123000 <__reset+0xfb103000>
811230e8:	9080200c 	andi	r2,r18,128
811230ec:	103fdd26 	beq	r2,zero,81123064 <__reset+0xfb103064>
811230f0:	9224703a 	and	r18,r18,r8
811230f4:	003fc206 	br	81123000 <__reset+0xfb103000>
811230f8:	9800011e 	bne	r19,zero,81123100 <__svfscanf_r+0x12c8>
811230fc:	04ffffc4 	movi	r19,-1
81123100:	8900004c 	andi	r4,r17,1
81123104:	20005b1e 	bne	r4,zero,81123274 <__svfscanf_r+0x143c>
81123108:	8c40040c 	andi	r17,r17,16
8112310c:	88003026 	beq	r17,zero,811231d0 <__svfscanf_r+0x1398>
81123110:	0021883a 	mov	r16,zero
81123114:	00000306 	br	81123124 <__svfscanf_r+0x12ec>
81123118:	18800003 	ldbu	r2,0(r3)
8112311c:	3885883a 	add	r2,r7,r2
81123120:	10800043 	ldbu	r2,1(r2)
81123124:	1080020c 	andi	r2,r2,8
81123128:	103ce31e 	bne	r2,zero,811224b8 <__reset+0xfb1024b8>
8112312c:	e0800117 	ldw	r2,4(fp)
81123130:	18c00044 	addi	r3,r3,1
81123134:	84000044 	addi	r16,r16,1
81123138:	10bfffc4 	addi	r2,r2,-1
8112313c:	e0800115 	stw	r2,4(fp)
81123140:	e0c00015 	stw	r3,0(fp)
81123144:	84fcdc26 	beq	r16,r19,811224b8 <__reset+0xfb1024b8>
81123148:	00bff316 	blt	zero,r2,81123118 <__reset+0xfb103118>
8112314c:	e00b883a 	mov	r5,fp
81123150:	b009883a 	mov	r4,r22
81123154:	111d1180 	call	8111d118 <__srefill_r>
81123158:	103cd71e 	bne	r2,zero,811224b8 <__reset+0xfb1024b8>
8112315c:	b9c00017 	ldw	r7,0(r23)
81123160:	e0c00017 	ldw	r3,0(fp)
81123164:	003fec06 	br	81123118 <__reset+0xfb103118>
81123168:	e00b883a 	mov	r5,fp
8112316c:	b009883a 	mov	r4,r22
81123170:	d980a715 	stw	r6,668(sp)
81123174:	d9c0aa15 	stw	r7,680(sp)
81123178:	da00a815 	stw	r8,672(sp)
8112317c:	da40a915 	stw	r9,676(sp)
81123180:	dac0a615 	stw	r11,664(sp)
81123184:	111d1180 	call	8111d118 <__srefill_r>
81123188:	d980a717 	ldw	r6,668(sp)
8112318c:	d9c0aa17 	ldw	r7,680(sp)
81123190:	da00a817 	ldw	r8,672(sp)
81123194:	da40a917 	ldw	r9,676(sp)
81123198:	dac0a617 	ldw	r11,664(sp)
8112319c:	103fa026 	beq	r2,zero,81123020 <__reset+0xfb103020>
811231a0:	003fb006 	br	81123064 <__reset+0xfb103064>
811231a4:	8821883a 	mov	r16,r17
811231a8:	b019883a 	mov	r12,r22
811231ac:	9823883a 	mov	r17,r19
811231b0:	182d883a 	mov	r22,r3
811231b4:	00bfbfc4 	movi	r2,-257
811231b8:	a0a8703a 	and	r20,r20,r2
811231bc:	003e6706 	br	81122b5c <__reset+0xfb102b5c>
811231c0:	000f883a 	mov	r7,zero
811231c4:	003f2806 	br	81122e68 <__reset+0xfb102e68>
811231c8:	d800a215 	stw	zero,648(sp)
811231cc:	003de306 	br	8112295c <__reset+0xfb10295c>
811231d0:	da009c17 	ldw	r8,624(sp)
811231d4:	9abfffc4 	addi	r10,r19,-1
811231d8:	44400017 	ldw	r17,0(r8)
811231dc:	44000104 	addi	r16,r8,4
811231e0:	880b883a 	mov	r5,r17
811231e4:	8aa9883a 	add	r20,r17,r10
811231e8:	00000606 	br	81123204 <__svfscanf_r+0x13cc>
811231ec:	e0c00017 	ldw	r3,0(fp)
811231f0:	b9000017 	ldw	r4,0(r23)
811231f4:	a80b883a 	mov	r5,r21
811231f8:	18800003 	ldbu	r2,0(r3)
811231fc:	2085883a 	add	r2,r4,r2
81123200:	10800043 	ldbu	r2,1(r2)
81123204:	1080020c 	andi	r2,r2,8
81123208:	1000551e 	bne	r2,zero,81123360 <__svfscanf_r+0x1528>
8112320c:	e0800117 	ldw	r2,4(fp)
81123210:	19000044 	addi	r4,r3,1
81123214:	e1000015 	stw	r4,0(fp)
81123218:	10bfffc4 	addi	r2,r2,-1
8112321c:	e0800115 	stw	r2,4(fp)
81123220:	18800003 	ldbu	r2,0(r3)
81123224:	2d400044 	addi	r21,r5,1
81123228:	a827883a 	mov	r19,r21
8112322c:	28800005 	stb	r2,0(r5)
81123230:	2d000626 	beq	r5,r20,8112324c <__svfscanf_r+0x1414>
81123234:	e0800117 	ldw	r2,4(fp)
81123238:	00bfec16 	blt	zero,r2,811231ec <__reset+0xfb1031ec>
8112323c:	e00b883a 	mov	r5,fp
81123240:	b009883a 	mov	r4,r22
81123244:	111d1180 	call	8111d118 <__srefill_r>
81123248:	103fe826 	beq	r2,zero,811231ec <__reset+0xfb1031ec>
8112324c:	da00a017 	ldw	r8,640(sp)
81123250:	dd009d17 	ldw	r20,628(sp)
81123254:	9c63c83a 	sub	r17,r19,r17
81123258:	42000044 	addi	r8,r8,1
8112325c:	98000005 	stb	zero,0(r19)
81123260:	9465883a 	add	r18,r18,r17
81123264:	da00a015 	stw	r8,640(sp)
81123268:	dc009c15 	stw	r16,624(sp)
8112326c:	a00d883a 	mov	r6,r20
81123270:	003b2f06 	br	81121f30 <__reset+0xfb101f30>
81123274:	dd409904 	addi	r21,sp,612
81123278:	8c40040c 	andi	r17,r17,16
8112327c:	01800204 	movi	r6,8
81123280:	000b883a 	mov	r5,zero
81123284:	a809883a 	mov	r4,r21
81123288:	111cc9c0 	call	8111cc9c <memset>
8112328c:	8800401e 	bne	r17,zero,81123390 <__svfscanf_r+0x1558>
81123290:	da009c17 	ldw	r8,624(sp)
81123294:	45000017 	ldw	r20,0(r8)
81123298:	42000104 	addi	r8,r8,4
8112329c:	da009c15 	stw	r8,624(sp)
811232a0:	000d883a 	mov	r6,zero
811232a4:	3021883a 	mov	r16,r6
811232a8:	dc409f15 	stw	r17,636(sp)
811232ac:	e0800017 	ldw	r2,0(fp)
811232b0:	b8c00017 	ldw	r3,0(r23)
811232b4:	10800003 	ldbu	r2,0(r2)
811232b8:	1885883a 	add	r2,r3,r2
811232bc:	10800043 	ldbu	r2,1(r2)
811232c0:	1080020c 	andi	r2,r2,8
811232c4:	1000011e 	bne	r2,zero,811232cc <__svfscanf_r+0x1494>
811232c8:	9800701e 	bne	r19,zero,8112348c <__svfscanf_r+0x1654>
811232cc:	dc409f17 	ldw	r17,636(sp)
811232d0:	883cdd1e 	bne	r17,zero,81122648 <__reset+0xfb102648>
811232d4:	a0000015 	stw	zero,0(r20)
811232d8:	003cd806 	br	8112263c <__reset+0xfb10263c>
811232dc:	d9c09e17 	ldw	r7,632(sp)
811232e0:	da00a117 	ldw	r8,644(sp)
811232e4:	000d883a 	mov	r6,zero
811232e8:	d9400104 	addi	r5,sp,4
811232ec:	b009883a 	mov	r4,r22
811232f0:	80000005 	stb	zero,0(r16)
811232f4:	403ee83a 	callr	r8
811232f8:	88c0080c 	andi	r3,r17,32
811232fc:	1800121e 	bne	r3,zero,81123348 <__svfscanf_r+0x1510>
81123300:	88c0010c 	andi	r3,r17,4
81123304:	18004d26 	beq	r3,zero,8112343c <__svfscanf_r+0x1604>
81123308:	da009c17 	ldw	r8,624(sp)
8112330c:	40c00017 	ldw	r3,0(r8)
81123310:	42000104 	addi	r8,r8,4
81123314:	da009c15 	stw	r8,624(sp)
81123318:	1880000d 	sth	r2,0(r3)
8112331c:	da00a017 	ldw	r8,640(sp)
81123320:	42000044 	addi	r8,r8,1
81123324:	da00a015 	stw	r8,640(sp)
81123328:	003f5906 	br	81123090 <__reset+0xfb103090>
8112332c:	00bf1fc4 	movi	r2,-897
81123330:	90a4703a 	and	r18,r18,r2
81123334:	38000226 	beq	r7,zero,81123340 <__svfscanf_r+0x1508>
81123338:	39ffffc4 	addi	r7,r7,-1
8112333c:	9cc00044 	addi	r19,r19,1
81123340:	a5000044 	addi	r20,r20,1
81123344:	003f3006 	br	81123008 <__reset+0xfb103008>
81123348:	da009c17 	ldw	r8,624(sp)
8112334c:	40c00017 	ldw	r3,0(r8)
81123350:	42000104 	addi	r8,r8,4
81123354:	da009c15 	stw	r8,624(sp)
81123358:	18800015 	stw	r2,0(r3)
8112335c:	003fef06 	br	8112331c <__reset+0xfb10331c>
81123360:	2827883a 	mov	r19,r5
81123364:	003fb906 	br	8112324c <__reset+0xfb10324c>
81123368:	01be1fc4 	movi	r6,-1921
8112336c:	a1a8703a 	and	r20,r20,r6
81123370:	05400044 	movi	r21,1
81123374:	003de906 	br	81122b1c <__reset+0xfb102b1c>
81123378:	817fffc7 	ldb	r5,-1(r16)
8112337c:	e00d883a 	mov	r6,fp
81123380:	b009883a 	mov	r4,r22
81123384:	843fffc4 	addi	r16,r16,-1
81123388:	112ba900 	call	8112ba90 <_ungetc_r>
8112338c:	003f3c06 	br	81123080 <__reset+0xfb103080>
81123390:	dd009b04 	addi	r20,sp,620
81123394:	003fc206 	br	811232a0 <__reset+0xfb1032a0>
81123398:	00be1fc4 	movi	r2,-1921
8112339c:	a0a8703a 	and	r20,r20,r2
811233a0:	05800044 	movi	r22,1
811233a4:	003ddd06 	br	81122b1c <__reset+0xfb102b1c>
811233a8:	d8c09f17 	ldw	r3,636(sp)
811233ac:	88e3c83a 	sub	r17,r17,r3
811233b0:	044dc83a 	sub	r6,zero,r17
811233b4:	883e2126 	beq	r17,zero,81122c3c <__reset+0xfb102c3c>
811233b8:	d88055c4 	addi	r2,sp,343
811233bc:	80800136 	bltu	r16,r2,811233c4 <__svfscanf_r+0x158c>
811233c0:	dc005584 	addi	r16,sp,342
811233c4:	01604574 	movhi	r5,33045
811233c8:	296b7204 	addi	r5,r5,-21048
811233cc:	8009883a 	mov	r4,r16
811233d0:	111d42c0 	call	8111d42c <sprintf>
811233d4:	003e1906 	br	81122c3c <__reset+0xfb102c3c>
811233d8:	d8c0a517 	ldw	r3,660(sp)
811233dc:	000d883a 	mov	r6,zero
811233e0:	01c00284 	movi	r7,10
811233e4:	19400044 	addi	r5,r3,1
811233e8:	b009883a 	mov	r4,r22
811233ec:	111d71c0 	call	8111d71c <_strtol_r>
811233f0:	da00a417 	ldw	r8,656(sp)
811233f4:	dc00a517 	ldw	r16,660(sp)
811233f8:	120dc83a 	sub	r6,r2,r8
811233fc:	003fee06 	br	811233b8 <__reset+0xfb1033b8>
81123400:	da009c17 	ldw	r8,624(sp)
81123404:	180b883a 	mov	r5,r3
81123408:	8009883a 	mov	r4,r16
8112340c:	45000017 	ldw	r20,0(r8)
81123410:	44400104 	addi	r17,r8,4
81123414:	d8c0a615 	stw	r3,664(sp)
81123418:	11283ac0 	call	811283ac <__fpclassifyd>
8112341c:	d8c0a617 	ldw	r3,664(sp)
81123420:	10006426 	beq	r2,zero,811235b4 <__svfscanf_r+0x177c>
81123424:	8009883a 	mov	r4,r16
81123428:	180b883a 	mov	r5,r3
8112342c:	111b7340 	call	8111b734 <__truncdfsf2>
81123430:	a0800015 	stw	r2,0(r20)
81123434:	dc409c15 	stw	r17,624(sp)
81123438:	003e0f06 	br	81122c78 <__reset+0xfb102c78>
8112343c:	88c0004c 	andi	r3,r17,1
81123440:	183fc11e 	bne	r3,zero,81123348 <__reset+0xfb103348>
81123444:	8c40008c 	andi	r17,r17,2
81123448:	883fbf26 	beq	r17,zero,81123348 <__reset+0xfb103348>
8112344c:	da00a117 	ldw	r8,644(sp)
81123450:	00a044f4 	movhi	r2,33043
81123454:	10a81204 	addi	r2,r2,-24504
81123458:	d9c09e17 	ldw	r7,632(sp)
8112345c:	000d883a 	mov	r6,zero
81123460:	d9400104 	addi	r5,sp,4
81123464:	b009883a 	mov	r4,r22
81123468:	40806226 	beq	r8,r2,811235f4 <__svfscanf_r+0x17bc>
8112346c:	1129d600 	call	81129d60 <_strtoll_r>
81123470:	da009c17 	ldw	r8,624(sp)
81123474:	41000017 	ldw	r4,0(r8)
81123478:	42000104 	addi	r8,r8,4
8112347c:	da009c15 	stw	r8,624(sp)
81123480:	20800015 	stw	r2,0(r4)
81123484:	20c00115 	stw	r3,4(r4)
81123488:	003fa406 	br	8112331c <__reset+0xfb10331c>
8112348c:	112683c0 	call	8112683c <__locale_mb_cur_max>
81123490:	80bca726 	beq	r16,r2,81122730 <__reset+0xfb102730>
81123494:	e0800017 	ldw	r2,0(fp)
81123498:	e1000117 	ldw	r4,4(fp)
8112349c:	d8c00104 	addi	r3,sp,4
811234a0:	12000003 	ldbu	r8,0(r2)
811234a4:	213fffc4 	addi	r4,r4,-1
811234a8:	10800044 	addi	r2,r2,1
811234ac:	e1000115 	stw	r4,4(fp)
811234b0:	e0800015 	stw	r2,0(fp)
811234b4:	84400044 	addi	r17,r16,1
811234b8:	dd400015 	stw	r21,0(sp)
811234bc:	1c21883a 	add	r16,r3,r16
811234c0:	b009883a 	mov	r4,r22
811234c4:	880f883a 	mov	r7,r17
811234c8:	180d883a 	mov	r6,r3
811234cc:	a00b883a 	mov	r5,r20
811234d0:	82000005 	stb	r8,0(r16)
811234d4:	11268f80 	call	811268f8 <_mbrtowc_r>
811234d8:	013fffc4 	movi	r4,-1
811234dc:	113c9426 	beq	r2,r4,81122730 <__reset+0xfb102730>
811234e0:	103c881e 	bne	r2,zero,81122704 <__reset+0xfb102704>
811234e4:	a0000015 	stw	zero,0(r20)
811234e8:	0009883a 	mov	r4,zero
811234ec:	112677c0 	call	8112677c <iswspace>
811234f0:	10001a26 	beq	r2,zero,8112355c <__svfscanf_r+0x1724>
811234f4:	8821883a 	mov	r16,r17
811234f8:	dc409f17 	ldw	r17,636(sp)
811234fc:	803f7426 	beq	r16,zero,811232d0 <__reset+0xfb1032d0>
81123500:	843fffc4 	addi	r16,r16,-1
81123504:	d9800104 	addi	r6,sp,4
81123508:	342b883a 	add	r21,r6,r16
8112350c:	00000106 	br	81123514 <__svfscanf_r+0x16dc>
81123510:	843fffc4 	addi	r16,r16,-1
81123514:	a9400003 	ldbu	r5,0(r21)
81123518:	e00d883a 	mov	r6,fp
8112351c:	b009883a 	mov	r4,r22
81123520:	112ba900 	call	8112ba90 <_ungetc_r>
81123524:	ad7fffc4 	addi	r21,r21,-1
81123528:	803ff91e 	bne	r16,zero,81123510 <__reset+0xfb103510>
8112352c:	003f6806 	br	811232d0 <__reset+0xfb1032d0>
81123530:	d9800104 	addi	r6,sp,4
81123534:	802b883a 	mov	r21,r16
81123538:	343a812e 	bgeu	r6,r16,81121f40 <__reset+0xfb101f40>
8112353c:	ad7fffc4 	addi	r21,r21,-1
81123540:	a9400007 	ldb	r5,0(r21)
81123544:	e00d883a 	mov	r6,fp
81123548:	b009883a 	mov	r4,r22
8112354c:	112ba900 	call	8112ba90 <_ungetc_r>
81123550:	da000104 	addi	r8,sp,4
81123554:	457ff91e 	bne	r8,r21,8112353c <__reset+0xfb10353c>
81123558:	003a7906 	br	81121f40 <__reset+0xfb101f40>
8112355c:	da009f17 	ldw	r8,636(sp)
81123560:	9465883a 	add	r18,r18,r17
81123564:	9cffffc4 	addi	r19,r19,-1
81123568:	4000051e 	bne	r8,zero,81123580 <__svfscanf_r+0x1748>
8112356c:	a5000104 	addi	r20,r20,4
81123570:	0021883a 	mov	r16,zero
81123574:	003c6606 	br	81122710 <__reset+0xfb102710>
81123578:	a1000017 	ldw	r4,0(r20)
8112357c:	003fdb06 	br	811234ec <__reset+0xfb1034ec>
81123580:	0021883a 	mov	r16,zero
81123584:	003c6206 	br	81122710 <__reset+0xfb102710>
81123588:	d8800104 	addi	r2,sp,4
8112358c:	802b883a 	mov	r21,r16
81123590:	143a6b2e 	bgeu	r2,r16,81121f40 <__reset+0xfb101f40>
81123594:	ad7fffc4 	addi	r21,r21,-1
81123598:	a9400007 	ldb	r5,0(r21)
8112359c:	e00d883a 	mov	r6,fp
811235a0:	b009883a 	mov	r4,r22
811235a4:	112ba900 	call	8112ba90 <_ungetc_r>
811235a8:	d8c00104 	addi	r3,sp,4
811235ac:	1d7ff91e 	bne	r3,r21,81123594 <__reset+0xfb103594>
811235b0:	003a6306 	br	81121f40 <__reset+0xfb101f40>
811235b4:	0009883a 	mov	r4,zero
811235b8:	11284f00 	call	811284f0 <nanf>
811235bc:	a0800015 	stw	r2,0(r20)
811235c0:	dc409c15 	stw	r17,624(sp)
811235c4:	003dac06 	br	81122c78 <__reset+0xfb102c78>
811235c8:	d9000104 	addi	r4,sp,4
811235cc:	802b883a 	mov	r21,r16
811235d0:	243a5b2e 	bgeu	r4,r16,81121f40 <__reset+0xfb101f40>
811235d4:	ad7fffc4 	addi	r21,r21,-1
811235d8:	a9400007 	ldb	r5,0(r21)
811235dc:	e00d883a 	mov	r6,fp
811235e0:	b009883a 	mov	r4,r22
811235e4:	112ba900 	call	8112ba90 <_ungetc_r>
811235e8:	d9400104 	addi	r5,sp,4
811235ec:	2d7ff91e 	bne	r5,r21,811235d4 <__reset+0xfb1035d4>
811235f0:	003a5306 	br	81121f40 <__reset+0xfb101f40>
811235f4:	112a2b80 	call	8112a2b8 <_strtoull_r>
811235f8:	003f9d06 	br	81123470 <__reset+0xfb103470>

811235fc <vfscanf>:
811235fc:	00a04574 	movhi	r2,33045
81123600:	defffb04 	addi	sp,sp,-20
81123604:	10b52904 	addi	r2,r2,-11100
81123608:	de00012e 	bgeu	sp,et,81123610 <vfscanf+0x14>
8112360c:	003b68fa 	trap	3
81123610:	dc000215 	stw	r16,8(sp)
81123614:	14000017 	ldw	r16,0(r2)
81123618:	dc400315 	stw	r17,12(sp)
8112361c:	dfc00415 	stw	ra,16(sp)
81123620:	2023883a 	mov	r17,r4
81123624:	80000826 	beq	r16,zero,81123648 <vfscanf+0x4c>
81123628:	80800e17 	ldw	r2,56(r16)
8112362c:	1000061e 	bne	r2,zero,81123648 <vfscanf+0x4c>
81123630:	8009883a 	mov	r4,r16
81123634:	d9400015 	stw	r5,0(sp)
81123638:	d9800115 	stw	r6,4(sp)
8112363c:	11259140 	call	81125914 <__sinit>
81123640:	d9800117 	ldw	r6,4(sp)
81123644:	d9400017 	ldw	r5,0(sp)
81123648:	300f883a 	mov	r7,r6
8112364c:	8009883a 	mov	r4,r16
81123650:	280d883a 	mov	r6,r5
81123654:	880b883a 	mov	r5,r17
81123658:	dfc00417 	ldw	ra,16(sp)
8112365c:	dc400317 	ldw	r17,12(sp)
81123660:	dc000217 	ldw	r16,8(sp)
81123664:	dec00504 	addi	sp,sp,20
81123668:	1121e381 	jmpi	81121e38 <__svfscanf_r>

8112366c <__svfscanf>:
8112366c:	00a04574 	movhi	r2,33045
81123670:	10b52904 	addi	r2,r2,-11100
81123674:	300f883a 	mov	r7,r6
81123678:	280d883a 	mov	r6,r5
8112367c:	200b883a 	mov	r5,r4
81123680:	11000017 	ldw	r4,0(r2)
81123684:	1121e381 	jmpi	81121e38 <__svfscanf_r>

81123688 <_vfscanf_r>:
81123688:	defffb04 	addi	sp,sp,-20
8112368c:	de00012e 	bgeu	sp,et,81123694 <_vfscanf_r+0xc>
81123690:	003b68fa 	trap	3
81123694:	dc000315 	stw	r16,12(sp)
81123698:	dfc00415 	stw	ra,16(sp)
8112369c:	2021883a 	mov	r16,r4
811236a0:	20000926 	beq	r4,zero,811236c8 <_vfscanf_r+0x40>
811236a4:	20800e17 	ldw	r2,56(r4)
811236a8:	1000071e 	bne	r2,zero,811236c8 <_vfscanf_r+0x40>
811236ac:	d9400015 	stw	r5,0(sp)
811236b0:	d9800115 	stw	r6,4(sp)
811236b4:	d9c00215 	stw	r7,8(sp)
811236b8:	11259140 	call	81125914 <__sinit>
811236bc:	d9c00217 	ldw	r7,8(sp)
811236c0:	d9800117 	ldw	r6,4(sp)
811236c4:	d9400017 	ldw	r5,0(sp)
811236c8:	8009883a 	mov	r4,r16
811236cc:	dfc00417 	ldw	ra,16(sp)
811236d0:	dc000317 	ldw	r16,12(sp)
811236d4:	dec00504 	addi	sp,sp,20
811236d8:	1121e381 	jmpi	81121e38 <__svfscanf_r>

811236dc <__swbuf_r>:
811236dc:	defffb04 	addi	sp,sp,-20
811236e0:	de00012e 	bgeu	sp,et,811236e8 <__swbuf_r+0xc>
811236e4:	003b68fa 	trap	3
811236e8:	dcc00315 	stw	r19,12(sp)
811236ec:	dc800215 	stw	r18,8(sp)
811236f0:	dc000015 	stw	r16,0(sp)
811236f4:	dfc00415 	stw	ra,16(sp)
811236f8:	dc400115 	stw	r17,4(sp)
811236fc:	2025883a 	mov	r18,r4
81123700:	2827883a 	mov	r19,r5
81123704:	3021883a 	mov	r16,r6
81123708:	20000226 	beq	r4,zero,81123714 <__swbuf_r+0x38>
8112370c:	20800e17 	ldw	r2,56(r4)
81123710:	10004226 	beq	r2,zero,8112381c <__swbuf_r+0x140>
81123714:	80800617 	ldw	r2,24(r16)
81123718:	8100030b 	ldhu	r4,12(r16)
8112371c:	80800215 	stw	r2,8(r16)
81123720:	2080020c 	andi	r2,r4,8
81123724:	10003626 	beq	r2,zero,81123800 <__swbuf_r+0x124>
81123728:	80c00417 	ldw	r3,16(r16)
8112372c:	18003426 	beq	r3,zero,81123800 <__swbuf_r+0x124>
81123730:	2088000c 	andi	r2,r4,8192
81123734:	9c403fcc 	andi	r17,r19,255
81123738:	10001a26 	beq	r2,zero,811237a4 <__swbuf_r+0xc8>
8112373c:	80800017 	ldw	r2,0(r16)
81123740:	81000517 	ldw	r4,20(r16)
81123744:	10c7c83a 	sub	r3,r2,r3
81123748:	1900200e 	bge	r3,r4,811237cc <__swbuf_r+0xf0>
8112374c:	18c00044 	addi	r3,r3,1
81123750:	81000217 	ldw	r4,8(r16)
81123754:	11400044 	addi	r5,r2,1
81123758:	81400015 	stw	r5,0(r16)
8112375c:	213fffc4 	addi	r4,r4,-1
81123760:	81000215 	stw	r4,8(r16)
81123764:	14c00005 	stb	r19,0(r2)
81123768:	80800517 	ldw	r2,20(r16)
8112376c:	10c01e26 	beq	r2,r3,811237e8 <__swbuf_r+0x10c>
81123770:	8080030b 	ldhu	r2,12(r16)
81123774:	1080004c 	andi	r2,r2,1
81123778:	10000226 	beq	r2,zero,81123784 <__swbuf_r+0xa8>
8112377c:	00800284 	movi	r2,10
81123780:	88801926 	beq	r17,r2,811237e8 <__swbuf_r+0x10c>
81123784:	8805883a 	mov	r2,r17
81123788:	dfc00417 	ldw	ra,16(sp)
8112378c:	dcc00317 	ldw	r19,12(sp)
81123790:	dc800217 	ldw	r18,8(sp)
81123794:	dc400117 	ldw	r17,4(sp)
81123798:	dc000017 	ldw	r16,0(sp)
8112379c:	dec00504 	addi	sp,sp,20
811237a0:	f800283a 	ret
811237a4:	81401917 	ldw	r5,100(r16)
811237a8:	00b7ffc4 	movi	r2,-8193
811237ac:	21080014 	ori	r4,r4,8192
811237b0:	2884703a 	and	r2,r5,r2
811237b4:	80801915 	stw	r2,100(r16)
811237b8:	80800017 	ldw	r2,0(r16)
811237bc:	8100030d 	sth	r4,12(r16)
811237c0:	81000517 	ldw	r4,20(r16)
811237c4:	10c7c83a 	sub	r3,r2,r3
811237c8:	193fe016 	blt	r3,r4,8112374c <__reset+0xfb10374c>
811237cc:	800b883a 	mov	r5,r16
811237d0:	9009883a 	mov	r4,r18
811237d4:	11255180 	call	81125518 <_fflush_r>
811237d8:	1000071e 	bne	r2,zero,811237f8 <__swbuf_r+0x11c>
811237dc:	80800017 	ldw	r2,0(r16)
811237e0:	00c00044 	movi	r3,1
811237e4:	003fda06 	br	81123750 <__reset+0xfb103750>
811237e8:	800b883a 	mov	r5,r16
811237ec:	9009883a 	mov	r4,r18
811237f0:	11255180 	call	81125518 <_fflush_r>
811237f4:	103fe326 	beq	r2,zero,81123784 <__reset+0xfb103784>
811237f8:	00bfffc4 	movi	r2,-1
811237fc:	003fe206 	br	81123788 <__reset+0xfb103788>
81123800:	800b883a 	mov	r5,r16
81123804:	9009883a 	mov	r4,r18
81123808:	11238a40 	call	811238a4 <__swsetup_r>
8112380c:	103ffa1e 	bne	r2,zero,811237f8 <__reset+0xfb1037f8>
81123810:	8100030b 	ldhu	r4,12(r16)
81123814:	80c00417 	ldw	r3,16(r16)
81123818:	003fc506 	br	81123730 <__reset+0xfb103730>
8112381c:	11259140 	call	81125914 <__sinit>
81123820:	003fbc06 	br	81123714 <__reset+0xfb103714>

81123824 <__swbuf>:
81123824:	00a04574 	movhi	r2,33045
81123828:	10b52904 	addi	r2,r2,-11100
8112382c:	280d883a 	mov	r6,r5
81123830:	200b883a 	mov	r5,r4
81123834:	11000017 	ldw	r4,0(r2)
81123838:	11236dc1 	jmpi	811236dc <__swbuf_r>

8112383c <_write_r>:
8112383c:	defffd04 	addi	sp,sp,-12
81123840:	de00012e 	bgeu	sp,et,81123848 <_write_r+0xc>
81123844:	003b68fa 	trap	3
81123848:	2805883a 	mov	r2,r5
8112384c:	dc000015 	stw	r16,0(sp)
81123850:	04204574 	movhi	r16,33045
81123854:	dc400115 	stw	r17,4(sp)
81123858:	300b883a 	mov	r5,r6
8112385c:	84359604 	addi	r16,r16,-10664
81123860:	2023883a 	mov	r17,r4
81123864:	380d883a 	mov	r6,r7
81123868:	1009883a 	mov	r4,r2
8112386c:	dfc00215 	stw	ra,8(sp)
81123870:	80000015 	stw	zero,0(r16)
81123874:	1132ef40 	call	81132ef4 <write>
81123878:	00ffffc4 	movi	r3,-1
8112387c:	10c00526 	beq	r2,r3,81123894 <_write_r+0x58>
81123880:	dfc00217 	ldw	ra,8(sp)
81123884:	dc400117 	ldw	r17,4(sp)
81123888:	dc000017 	ldw	r16,0(sp)
8112388c:	dec00304 	addi	sp,sp,12
81123890:	f800283a 	ret
81123894:	80c00017 	ldw	r3,0(r16)
81123898:	183ff926 	beq	r3,zero,81123880 <__reset+0xfb103880>
8112389c:	88c00015 	stw	r3,0(r17)
811238a0:	003ff706 	br	81123880 <__reset+0xfb103880>

811238a4 <__swsetup_r>:
811238a4:	00a04574 	movhi	r2,33045
811238a8:	defffd04 	addi	sp,sp,-12
811238ac:	10b52904 	addi	r2,r2,-11100
811238b0:	de00012e 	bgeu	sp,et,811238b8 <__swsetup_r+0x14>
811238b4:	003b68fa 	trap	3
811238b8:	dc400115 	stw	r17,4(sp)
811238bc:	2023883a 	mov	r17,r4
811238c0:	11000017 	ldw	r4,0(r2)
811238c4:	dc000015 	stw	r16,0(sp)
811238c8:	dfc00215 	stw	ra,8(sp)
811238cc:	2821883a 	mov	r16,r5
811238d0:	20000226 	beq	r4,zero,811238dc <__swsetup_r+0x38>
811238d4:	20800e17 	ldw	r2,56(r4)
811238d8:	10003126 	beq	r2,zero,811239a0 <__swsetup_r+0xfc>
811238dc:	8080030b 	ldhu	r2,12(r16)
811238e0:	10c0020c 	andi	r3,r2,8
811238e4:	1009883a 	mov	r4,r2
811238e8:	18000f26 	beq	r3,zero,81123928 <__swsetup_r+0x84>
811238ec:	80c00417 	ldw	r3,16(r16)
811238f0:	18001526 	beq	r3,zero,81123948 <__swsetup_r+0xa4>
811238f4:	1100004c 	andi	r4,r2,1
811238f8:	20001c1e 	bne	r4,zero,8112396c <__swsetup_r+0xc8>
811238fc:	1080008c 	andi	r2,r2,2
81123900:	1000291e 	bne	r2,zero,811239a8 <__swsetup_r+0x104>
81123904:	80800517 	ldw	r2,20(r16)
81123908:	80800215 	stw	r2,8(r16)
8112390c:	18001c26 	beq	r3,zero,81123980 <__swsetup_r+0xdc>
81123910:	0005883a 	mov	r2,zero
81123914:	dfc00217 	ldw	ra,8(sp)
81123918:	dc400117 	ldw	r17,4(sp)
8112391c:	dc000017 	ldw	r16,0(sp)
81123920:	dec00304 	addi	sp,sp,12
81123924:	f800283a 	ret
81123928:	2080040c 	andi	r2,r4,16
8112392c:	10002e26 	beq	r2,zero,811239e8 <__swsetup_r+0x144>
81123930:	2080010c 	andi	r2,r4,4
81123934:	10001e1e 	bne	r2,zero,811239b0 <__swsetup_r+0x10c>
81123938:	80c00417 	ldw	r3,16(r16)
8112393c:	20800214 	ori	r2,r4,8
81123940:	8080030d 	sth	r2,12(r16)
81123944:	183feb1e 	bne	r3,zero,811238f4 <__reset+0xfb1038f4>
81123948:	1100a00c 	andi	r4,r2,640
8112394c:	01408004 	movi	r5,512
81123950:	217fe826 	beq	r4,r5,811238f4 <__reset+0xfb1038f4>
81123954:	800b883a 	mov	r5,r16
81123958:	8809883a 	mov	r4,r17
8112395c:	111c1740 	call	8111c174 <__smakebuf_r>
81123960:	8080030b 	ldhu	r2,12(r16)
81123964:	80c00417 	ldw	r3,16(r16)
81123968:	003fe206 	br	811238f4 <__reset+0xfb1038f4>
8112396c:	80800517 	ldw	r2,20(r16)
81123970:	80000215 	stw	zero,8(r16)
81123974:	0085c83a 	sub	r2,zero,r2
81123978:	80800615 	stw	r2,24(r16)
8112397c:	183fe41e 	bne	r3,zero,81123910 <__reset+0xfb103910>
81123980:	80c0030b 	ldhu	r3,12(r16)
81123984:	0005883a 	mov	r2,zero
81123988:	1900200c 	andi	r4,r3,128
8112398c:	203fe126 	beq	r4,zero,81123914 <__reset+0xfb103914>
81123990:	18c01014 	ori	r3,r3,64
81123994:	80c0030d 	sth	r3,12(r16)
81123998:	00bfffc4 	movi	r2,-1
8112399c:	003fdd06 	br	81123914 <__reset+0xfb103914>
811239a0:	11259140 	call	81125914 <__sinit>
811239a4:	003fcd06 	br	811238dc <__reset+0xfb1038dc>
811239a8:	0005883a 	mov	r2,zero
811239ac:	003fd606 	br	81123908 <__reset+0xfb103908>
811239b0:	81400c17 	ldw	r5,48(r16)
811239b4:	28000626 	beq	r5,zero,811239d0 <__swsetup_r+0x12c>
811239b8:	80801004 	addi	r2,r16,64
811239bc:	28800326 	beq	r5,r2,811239cc <__swsetup_r+0x128>
811239c0:	8809883a 	mov	r4,r17
811239c4:	1125dac0 	call	81125dac <_free_r>
811239c8:	8100030b 	ldhu	r4,12(r16)
811239cc:	80000c15 	stw	zero,48(r16)
811239d0:	80c00417 	ldw	r3,16(r16)
811239d4:	00bff6c4 	movi	r2,-37
811239d8:	1108703a 	and	r4,r2,r4
811239dc:	80000115 	stw	zero,4(r16)
811239e0:	80c00015 	stw	r3,0(r16)
811239e4:	003fd506 	br	8112393c <__reset+0xfb10393c>
811239e8:	00800244 	movi	r2,9
811239ec:	88800015 	stw	r2,0(r17)
811239f0:	20801014 	ori	r2,r4,64
811239f4:	8080030d 	sth	r2,12(r16)
811239f8:	00bfffc4 	movi	r2,-1
811239fc:	003fc506 	br	81123914 <__reset+0xfb103914>

81123a00 <_close_r>:
81123a00:	defffd04 	addi	sp,sp,-12
81123a04:	de00012e 	bgeu	sp,et,81123a0c <_close_r+0xc>
81123a08:	003b68fa 	trap	3
81123a0c:	dc000015 	stw	r16,0(sp)
81123a10:	04204574 	movhi	r16,33045
81123a14:	dc400115 	stw	r17,4(sp)
81123a18:	84359604 	addi	r16,r16,-10664
81123a1c:	2023883a 	mov	r17,r4
81123a20:	2809883a 	mov	r4,r5
81123a24:	dfc00215 	stw	ra,8(sp)
81123a28:	80000015 	stw	zero,0(r16)
81123a2c:	11314740 	call	81131474 <close>
81123a30:	00ffffc4 	movi	r3,-1
81123a34:	10c00526 	beq	r2,r3,81123a4c <_close_r+0x4c>
81123a38:	dfc00217 	ldw	ra,8(sp)
81123a3c:	dc400117 	ldw	r17,4(sp)
81123a40:	dc000017 	ldw	r16,0(sp)
81123a44:	dec00304 	addi	sp,sp,12
81123a48:	f800283a 	ret
81123a4c:	80c00017 	ldw	r3,0(r16)
81123a50:	183ff926 	beq	r3,zero,81123a38 <__reset+0xfb103a38>
81123a54:	88c00015 	stw	r3,0(r17)
81123a58:	003ff706 	br	81123a38 <__reset+0xfb103a38>

81123a5c <quorem>:
81123a5c:	defff704 	addi	sp,sp,-36
81123a60:	de00012e 	bgeu	sp,et,81123a68 <quorem+0xc>
81123a64:	003b68fa 	trap	3
81123a68:	dc800215 	stw	r18,8(sp)
81123a6c:	20800417 	ldw	r2,16(r4)
81123a70:	2c800417 	ldw	r18,16(r5)
81123a74:	dfc00815 	stw	ra,32(sp)
81123a78:	ddc00715 	stw	r23,28(sp)
81123a7c:	dd800615 	stw	r22,24(sp)
81123a80:	dd400515 	stw	r21,20(sp)
81123a84:	dd000415 	stw	r20,16(sp)
81123a88:	dcc00315 	stw	r19,12(sp)
81123a8c:	dc400115 	stw	r17,4(sp)
81123a90:	dc000015 	stw	r16,0(sp)
81123a94:	14807116 	blt	r2,r18,81123c5c <quorem+0x200>
81123a98:	94bfffc4 	addi	r18,r18,-1
81123a9c:	94ad883a 	add	r22,r18,r18
81123aa0:	b5ad883a 	add	r22,r22,r22
81123aa4:	2c400504 	addi	r17,r5,20
81123aa8:	8da9883a 	add	r20,r17,r22
81123aac:	25400504 	addi	r21,r4,20
81123ab0:	282f883a 	mov	r23,r5
81123ab4:	adad883a 	add	r22,r21,r22
81123ab8:	a1400017 	ldw	r5,0(r20)
81123abc:	2021883a 	mov	r16,r4
81123ac0:	b1000017 	ldw	r4,0(r22)
81123ac4:	29400044 	addi	r5,r5,1
81123ac8:	112f1340 	call	8112f134 <__udivsi3>
81123acc:	1027883a 	mov	r19,r2
81123ad0:	10002c26 	beq	r2,zero,81123b84 <quorem+0x128>
81123ad4:	a813883a 	mov	r9,r21
81123ad8:	880b883a 	mov	r5,r17
81123adc:	0009883a 	mov	r4,zero
81123ae0:	000d883a 	mov	r6,zero
81123ae4:	2a000017 	ldw	r8,0(r5)
81123ae8:	49c00017 	ldw	r7,0(r9)
81123aec:	29400104 	addi	r5,r5,4
81123af0:	40bfffcc 	andi	r2,r8,65535
81123af4:	14c5383a 	mul	r2,r2,r19
81123af8:	4010d43a 	srli	r8,r8,16
81123afc:	38ffffcc 	andi	r3,r7,65535
81123b00:	1105883a 	add	r2,r2,r4
81123b04:	1008d43a 	srli	r4,r2,16
81123b08:	44d1383a 	mul	r8,r8,r19
81123b0c:	198d883a 	add	r6,r3,r6
81123b10:	10ffffcc 	andi	r3,r2,65535
81123b14:	30c7c83a 	sub	r3,r6,r3
81123b18:	380ed43a 	srli	r7,r7,16
81123b1c:	4105883a 	add	r2,r8,r4
81123b20:	180dd43a 	srai	r6,r3,16
81123b24:	113fffcc 	andi	r4,r2,65535
81123b28:	390fc83a 	sub	r7,r7,r4
81123b2c:	398d883a 	add	r6,r7,r6
81123b30:	300e943a 	slli	r7,r6,16
81123b34:	18ffffcc 	andi	r3,r3,65535
81123b38:	1008d43a 	srli	r4,r2,16
81123b3c:	38ceb03a 	or	r7,r7,r3
81123b40:	49c00015 	stw	r7,0(r9)
81123b44:	300dd43a 	srai	r6,r6,16
81123b48:	4a400104 	addi	r9,r9,4
81123b4c:	a17fe52e 	bgeu	r20,r5,81123ae4 <__reset+0xfb103ae4>
81123b50:	b0800017 	ldw	r2,0(r22)
81123b54:	10000b1e 	bne	r2,zero,81123b84 <quorem+0x128>
81123b58:	b0bfff04 	addi	r2,r22,-4
81123b5c:	a880082e 	bgeu	r21,r2,81123b80 <quorem+0x124>
81123b60:	b0ffff17 	ldw	r3,-4(r22)
81123b64:	18000326 	beq	r3,zero,81123b74 <quorem+0x118>
81123b68:	00000506 	br	81123b80 <quorem+0x124>
81123b6c:	10c00017 	ldw	r3,0(r2)
81123b70:	1800031e 	bne	r3,zero,81123b80 <quorem+0x124>
81123b74:	10bfff04 	addi	r2,r2,-4
81123b78:	94bfffc4 	addi	r18,r18,-1
81123b7c:	a8bffb36 	bltu	r21,r2,81123b6c <__reset+0xfb103b6c>
81123b80:	84800415 	stw	r18,16(r16)
81123b84:	b80b883a 	mov	r5,r23
81123b88:	8009883a 	mov	r4,r16
81123b8c:	112767c0 	call	8112767c <__mcmp>
81123b90:	10002616 	blt	r2,zero,81123c2c <quorem+0x1d0>
81123b94:	9cc00044 	addi	r19,r19,1
81123b98:	a805883a 	mov	r2,r21
81123b9c:	000b883a 	mov	r5,zero
81123ba0:	11000017 	ldw	r4,0(r2)
81123ba4:	89800017 	ldw	r6,0(r17)
81123ba8:	10800104 	addi	r2,r2,4
81123bac:	20ffffcc 	andi	r3,r4,65535
81123bb0:	194b883a 	add	r5,r3,r5
81123bb4:	30ffffcc 	andi	r3,r6,65535
81123bb8:	28c7c83a 	sub	r3,r5,r3
81123bbc:	300cd43a 	srli	r6,r6,16
81123bc0:	2008d43a 	srli	r4,r4,16
81123bc4:	180bd43a 	srai	r5,r3,16
81123bc8:	18ffffcc 	andi	r3,r3,65535
81123bcc:	2189c83a 	sub	r4,r4,r6
81123bd0:	2149883a 	add	r4,r4,r5
81123bd4:	200c943a 	slli	r6,r4,16
81123bd8:	8c400104 	addi	r17,r17,4
81123bdc:	200bd43a 	srai	r5,r4,16
81123be0:	30c6b03a 	or	r3,r6,r3
81123be4:	10ffff15 	stw	r3,-4(r2)
81123be8:	a47fed2e 	bgeu	r20,r17,81123ba0 <__reset+0xfb103ba0>
81123bec:	9485883a 	add	r2,r18,r18
81123bf0:	1085883a 	add	r2,r2,r2
81123bf4:	a887883a 	add	r3,r21,r2
81123bf8:	18800017 	ldw	r2,0(r3)
81123bfc:	10000b1e 	bne	r2,zero,81123c2c <quorem+0x1d0>
81123c00:	18bfff04 	addi	r2,r3,-4
81123c04:	a880082e 	bgeu	r21,r2,81123c28 <quorem+0x1cc>
81123c08:	18ffff17 	ldw	r3,-4(r3)
81123c0c:	18000326 	beq	r3,zero,81123c1c <quorem+0x1c0>
81123c10:	00000506 	br	81123c28 <quorem+0x1cc>
81123c14:	10c00017 	ldw	r3,0(r2)
81123c18:	1800031e 	bne	r3,zero,81123c28 <quorem+0x1cc>
81123c1c:	10bfff04 	addi	r2,r2,-4
81123c20:	94bfffc4 	addi	r18,r18,-1
81123c24:	a8bffb36 	bltu	r21,r2,81123c14 <__reset+0xfb103c14>
81123c28:	84800415 	stw	r18,16(r16)
81123c2c:	9805883a 	mov	r2,r19
81123c30:	dfc00817 	ldw	ra,32(sp)
81123c34:	ddc00717 	ldw	r23,28(sp)
81123c38:	dd800617 	ldw	r22,24(sp)
81123c3c:	dd400517 	ldw	r21,20(sp)
81123c40:	dd000417 	ldw	r20,16(sp)
81123c44:	dcc00317 	ldw	r19,12(sp)
81123c48:	dc800217 	ldw	r18,8(sp)
81123c4c:	dc400117 	ldw	r17,4(sp)
81123c50:	dc000017 	ldw	r16,0(sp)
81123c54:	dec00904 	addi	sp,sp,36
81123c58:	f800283a 	ret
81123c5c:	0005883a 	mov	r2,zero
81123c60:	003ff306 	br	81123c30 <__reset+0xfb103c30>

81123c64 <_dtoa_r>:
81123c64:	deffde04 	addi	sp,sp,-136
81123c68:	de00012e 	bgeu	sp,et,81123c70 <_dtoa_r+0xc>
81123c6c:	003b68fa 	trap	3
81123c70:	20801017 	ldw	r2,64(r4)
81123c74:	df002015 	stw	fp,128(sp)
81123c78:	dcc01b15 	stw	r19,108(sp)
81123c7c:	dc801a15 	stw	r18,104(sp)
81123c80:	dc401915 	stw	r17,100(sp)
81123c84:	dc001815 	stw	r16,96(sp)
81123c88:	dfc02115 	stw	ra,132(sp)
81123c8c:	ddc01f15 	stw	r23,124(sp)
81123c90:	dd801e15 	stw	r22,120(sp)
81123c94:	dd401d15 	stw	r21,116(sp)
81123c98:	dd001c15 	stw	r20,112(sp)
81123c9c:	d9c00315 	stw	r7,12(sp)
81123ca0:	2039883a 	mov	fp,r4
81123ca4:	3023883a 	mov	r17,r6
81123ca8:	2825883a 	mov	r18,r5
81123cac:	dc002417 	ldw	r16,144(sp)
81123cb0:	3027883a 	mov	r19,r6
81123cb4:	10000826 	beq	r2,zero,81123cd8 <_dtoa_r+0x74>
81123cb8:	21801117 	ldw	r6,68(r4)
81123cbc:	00c00044 	movi	r3,1
81123cc0:	100b883a 	mov	r5,r2
81123cc4:	1986983a 	sll	r3,r3,r6
81123cc8:	11800115 	stw	r6,4(r2)
81123ccc:	10c00215 	stw	r3,8(r2)
81123cd0:	1126e2c0 	call	81126e2c <_Bfree>
81123cd4:	e0001015 	stw	zero,64(fp)
81123cd8:	88002e16 	blt	r17,zero,81123d94 <_dtoa_r+0x130>
81123cdc:	80000015 	stw	zero,0(r16)
81123ce0:	889ffc2c 	andhi	r2,r17,32752
81123ce4:	00dffc34 	movhi	r3,32752
81123ce8:	10c01c26 	beq	r2,r3,81123d5c <_dtoa_r+0xf8>
81123cec:	000d883a 	mov	r6,zero
81123cf0:	000f883a 	mov	r7,zero
81123cf4:	9009883a 	mov	r4,r18
81123cf8:	980b883a 	mov	r5,r19
81123cfc:	11305900 	call	81130590 <__eqdf2>
81123d00:	10002b1e 	bne	r2,zero,81123db0 <_dtoa_r+0x14c>
81123d04:	d9c02317 	ldw	r7,140(sp)
81123d08:	00800044 	movi	r2,1
81123d0c:	38800015 	stw	r2,0(r7)
81123d10:	d8802517 	ldw	r2,148(sp)
81123d14:	10019e26 	beq	r2,zero,81124390 <_dtoa_r+0x72c>
81123d18:	d8c02517 	ldw	r3,148(sp)
81123d1c:	00a04574 	movhi	r2,33045
81123d20:	10ab6144 	addi	r2,r2,-21115
81123d24:	18800015 	stw	r2,0(r3)
81123d28:	10bfffc4 	addi	r2,r2,-1
81123d2c:	dfc02117 	ldw	ra,132(sp)
81123d30:	df002017 	ldw	fp,128(sp)
81123d34:	ddc01f17 	ldw	r23,124(sp)
81123d38:	dd801e17 	ldw	r22,120(sp)
81123d3c:	dd401d17 	ldw	r21,116(sp)
81123d40:	dd001c17 	ldw	r20,112(sp)
81123d44:	dcc01b17 	ldw	r19,108(sp)
81123d48:	dc801a17 	ldw	r18,104(sp)
81123d4c:	dc401917 	ldw	r17,100(sp)
81123d50:	dc001817 	ldw	r16,96(sp)
81123d54:	dec02204 	addi	sp,sp,136
81123d58:	f800283a 	ret
81123d5c:	d8c02317 	ldw	r3,140(sp)
81123d60:	0089c3c4 	movi	r2,9999
81123d64:	18800015 	stw	r2,0(r3)
81123d68:	90017726 	beq	r18,zero,81124348 <_dtoa_r+0x6e4>
81123d6c:	00a04574 	movhi	r2,33045
81123d70:	10ab7f04 	addi	r2,r2,-20996
81123d74:	d9002517 	ldw	r4,148(sp)
81123d78:	203fec26 	beq	r4,zero,81123d2c <__reset+0xfb103d2c>
81123d7c:	10c000c7 	ldb	r3,3(r2)
81123d80:	1801781e 	bne	r3,zero,81124364 <_dtoa_r+0x700>
81123d84:	10c000c4 	addi	r3,r2,3
81123d88:	d9802517 	ldw	r6,148(sp)
81123d8c:	30c00015 	stw	r3,0(r6)
81123d90:	003fe606 	br	81123d2c <__reset+0xfb103d2c>
81123d94:	04e00034 	movhi	r19,32768
81123d98:	9cffffc4 	addi	r19,r19,-1
81123d9c:	00800044 	movi	r2,1
81123da0:	8ce6703a 	and	r19,r17,r19
81123da4:	80800015 	stw	r2,0(r16)
81123da8:	9823883a 	mov	r17,r19
81123dac:	003fcc06 	br	81123ce0 <__reset+0xfb103ce0>
81123db0:	d8800204 	addi	r2,sp,8
81123db4:	d8800015 	stw	r2,0(sp)
81123db8:	d9c00104 	addi	r7,sp,4
81123dbc:	900b883a 	mov	r5,r18
81123dc0:	980d883a 	mov	r6,r19
81123dc4:	e009883a 	mov	r4,fp
81123dc8:	8820d53a 	srli	r16,r17,20
81123dcc:	1127a580 	call	81127a58 <__d2b>
81123dd0:	d8800915 	stw	r2,36(sp)
81123dd4:	8001651e 	bne	r16,zero,8112436c <_dtoa_r+0x708>
81123dd8:	dd800217 	ldw	r22,8(sp)
81123ddc:	dc000117 	ldw	r16,4(sp)
81123de0:	00800804 	movi	r2,32
81123de4:	b421883a 	add	r16,r22,r16
81123de8:	80c10c84 	addi	r3,r16,1074
81123dec:	10c2d10e 	bge	r2,r3,81124934 <_dtoa_r+0xcd0>
81123df0:	00801004 	movi	r2,64
81123df4:	81010484 	addi	r4,r16,1042
81123df8:	10c7c83a 	sub	r3,r2,r3
81123dfc:	9108d83a 	srl	r4,r18,r4
81123e00:	88e2983a 	sll	r17,r17,r3
81123e04:	2448b03a 	or	r4,r4,r17
81123e08:	11312500 	call	81131250 <__floatunsidf>
81123e0c:	017f8434 	movhi	r5,65040
81123e10:	01800044 	movi	r6,1
81123e14:	1009883a 	mov	r4,r2
81123e18:	194b883a 	add	r5,r3,r5
81123e1c:	843fffc4 	addi	r16,r16,-1
81123e20:	d9801115 	stw	r6,68(sp)
81123e24:	000d883a 	mov	r6,zero
81123e28:	01cffe34 	movhi	r7,16376
81123e2c:	11307e80 	call	811307e8 <__subdf3>
81123e30:	0198dbf4 	movhi	r6,25455
81123e34:	01cff4f4 	movhi	r7,16339
81123e38:	3190d844 	addi	r6,r6,17249
81123e3c:	39e1e9c4 	addi	r7,r7,-30809
81123e40:	1009883a 	mov	r4,r2
81123e44:	180b883a 	mov	r5,r3
81123e48:	111aefc0 	call	8111aefc <__muldf3>
81123e4c:	01a2d874 	movhi	r6,35681
81123e50:	01cff1f4 	movhi	r7,16327
81123e54:	31b22cc4 	addi	r6,r6,-14157
81123e58:	39e28a04 	addi	r7,r7,-30168
81123e5c:	180b883a 	mov	r5,r3
81123e60:	1009883a 	mov	r4,r2
81123e64:	112f3ec0 	call	8112f3ec <__adddf3>
81123e68:	8009883a 	mov	r4,r16
81123e6c:	1029883a 	mov	r20,r2
81123e70:	1823883a 	mov	r17,r3
81123e74:	113116c0 	call	8113116c <__floatsidf>
81123e78:	019427f4 	movhi	r6,20639
81123e7c:	01cff4f4 	movhi	r7,16339
81123e80:	319e7ec4 	addi	r6,r6,31227
81123e84:	39d104c4 	addi	r7,r7,17427
81123e88:	1009883a 	mov	r4,r2
81123e8c:	180b883a 	mov	r5,r3
81123e90:	111aefc0 	call	8111aefc <__muldf3>
81123e94:	100d883a 	mov	r6,r2
81123e98:	180f883a 	mov	r7,r3
81123e9c:	a009883a 	mov	r4,r20
81123ea0:	880b883a 	mov	r5,r17
81123ea4:	112f3ec0 	call	8112f3ec <__adddf3>
81123ea8:	1009883a 	mov	r4,r2
81123eac:	180b883a 	mov	r5,r3
81123eb0:	1029883a 	mov	r20,r2
81123eb4:	1823883a 	mov	r17,r3
81123eb8:	11310ec0 	call	811310ec <__fixdfsi>
81123ebc:	000d883a 	mov	r6,zero
81123ec0:	000f883a 	mov	r7,zero
81123ec4:	a009883a 	mov	r4,r20
81123ec8:	880b883a 	mov	r5,r17
81123ecc:	d8800515 	stw	r2,20(sp)
81123ed0:	11306f40 	call	811306f4 <__ledf2>
81123ed4:	10028716 	blt	r2,zero,811248f4 <_dtoa_r+0xc90>
81123ed8:	d8c00517 	ldw	r3,20(sp)
81123edc:	00800584 	movi	r2,22
81123ee0:	10c27536 	bltu	r2,r3,811248b8 <_dtoa_r+0xc54>
81123ee4:	180490fa 	slli	r2,r3,3
81123ee8:	00e04574 	movhi	r3,33045
81123eec:	18eb9a04 	addi	r3,r3,-20888
81123ef0:	1885883a 	add	r2,r3,r2
81123ef4:	11000017 	ldw	r4,0(r2)
81123ef8:	11400117 	ldw	r5,4(r2)
81123efc:	900d883a 	mov	r6,r18
81123f00:	980f883a 	mov	r7,r19
81123f04:	11306180 	call	81130618 <__gedf2>
81123f08:	00828d0e 	bge	zero,r2,81124940 <_dtoa_r+0xcdc>
81123f0c:	d9000517 	ldw	r4,20(sp)
81123f10:	d8000e15 	stw	zero,56(sp)
81123f14:	213fffc4 	addi	r4,r4,-1
81123f18:	d9000515 	stw	r4,20(sp)
81123f1c:	b42dc83a 	sub	r22,r22,r16
81123f20:	b5bfffc4 	addi	r22,r22,-1
81123f24:	b0026f16 	blt	r22,zero,811248e4 <_dtoa_r+0xc80>
81123f28:	d8000815 	stw	zero,32(sp)
81123f2c:	d9c00517 	ldw	r7,20(sp)
81123f30:	38026416 	blt	r7,zero,811248c4 <_dtoa_r+0xc60>
81123f34:	b1ed883a 	add	r22,r22,r7
81123f38:	d9c00d15 	stw	r7,52(sp)
81123f3c:	d8000a15 	stw	zero,40(sp)
81123f40:	d9800317 	ldw	r6,12(sp)
81123f44:	00800244 	movi	r2,9
81123f48:	11811436 	bltu	r2,r6,8112439c <_dtoa_r+0x738>
81123f4c:	00800144 	movi	r2,5
81123f50:	1184e10e 	bge	r2,r6,811252d8 <_dtoa_r+0x1674>
81123f54:	31bfff04 	addi	r6,r6,-4
81123f58:	d9800315 	stw	r6,12(sp)
81123f5c:	0023883a 	mov	r17,zero
81123f60:	d9800317 	ldw	r6,12(sp)
81123f64:	008000c4 	movi	r2,3
81123f68:	30836726 	beq	r6,r2,81124d08 <_dtoa_r+0x10a4>
81123f6c:	1183410e 	bge	r2,r6,81124c74 <_dtoa_r+0x1010>
81123f70:	d9c00317 	ldw	r7,12(sp)
81123f74:	00800104 	movi	r2,4
81123f78:	38827c26 	beq	r7,r2,8112496c <_dtoa_r+0xd08>
81123f7c:	00800144 	movi	r2,5
81123f80:	3884c41e 	bne	r7,r2,81125294 <_dtoa_r+0x1630>
81123f84:	00800044 	movi	r2,1
81123f88:	d8800b15 	stw	r2,44(sp)
81123f8c:	d8c00517 	ldw	r3,20(sp)
81123f90:	d9002217 	ldw	r4,136(sp)
81123f94:	1907883a 	add	r3,r3,r4
81123f98:	19800044 	addi	r6,r3,1
81123f9c:	d8c00c15 	stw	r3,48(sp)
81123fa0:	d9800615 	stw	r6,24(sp)
81123fa4:	0183a40e 	bge	zero,r6,81124e38 <_dtoa_r+0x11d4>
81123fa8:	d9800617 	ldw	r6,24(sp)
81123fac:	3021883a 	mov	r16,r6
81123fb0:	e0001115 	stw	zero,68(fp)
81123fb4:	008005c4 	movi	r2,23
81123fb8:	1184c92e 	bgeu	r2,r6,811252e0 <_dtoa_r+0x167c>
81123fbc:	00c00044 	movi	r3,1
81123fc0:	00800104 	movi	r2,4
81123fc4:	1085883a 	add	r2,r2,r2
81123fc8:	11000504 	addi	r4,r2,20
81123fcc:	180b883a 	mov	r5,r3
81123fd0:	18c00044 	addi	r3,r3,1
81123fd4:	313ffb2e 	bgeu	r6,r4,81123fc4 <__reset+0xfb103fc4>
81123fd8:	e1401115 	stw	r5,68(fp)
81123fdc:	e009883a 	mov	r4,fp
81123fe0:	1126d7c0 	call	81126d7c <_Balloc>
81123fe4:	d8800715 	stw	r2,28(sp)
81123fe8:	e0801015 	stw	r2,64(fp)
81123fec:	00800384 	movi	r2,14
81123ff0:	1400f736 	bltu	r2,r16,811243d0 <_dtoa_r+0x76c>
81123ff4:	8800f626 	beq	r17,zero,811243d0 <_dtoa_r+0x76c>
81123ff8:	d9c00517 	ldw	r7,20(sp)
81123ffc:	01c39a0e 	bge	zero,r7,81124e68 <_dtoa_r+0x1204>
81124000:	388003cc 	andi	r2,r7,15
81124004:	100490fa 	slli	r2,r2,3
81124008:	382bd13a 	srai	r21,r7,4
8112400c:	00e04574 	movhi	r3,33045
81124010:	18eb9a04 	addi	r3,r3,-20888
81124014:	1885883a 	add	r2,r3,r2
81124018:	a8c0040c 	andi	r3,r21,16
8112401c:	12400017 	ldw	r9,0(r2)
81124020:	12000117 	ldw	r8,4(r2)
81124024:	18037926 	beq	r3,zero,81124e0c <_dtoa_r+0x11a8>
81124028:	00a04574 	movhi	r2,33045
8112402c:	10ab9004 	addi	r2,r2,-20928
81124030:	11800817 	ldw	r6,32(r2)
81124034:	11c00917 	ldw	r7,36(r2)
81124038:	9009883a 	mov	r4,r18
8112403c:	980b883a 	mov	r5,r19
81124040:	da001715 	stw	r8,92(sp)
81124044:	da401615 	stw	r9,88(sp)
81124048:	112fca00 	call	8112fca0 <__divdf3>
8112404c:	da001717 	ldw	r8,92(sp)
81124050:	da401617 	ldw	r9,88(sp)
81124054:	ad4003cc 	andi	r21,r21,15
81124058:	040000c4 	movi	r16,3
8112405c:	1023883a 	mov	r17,r2
81124060:	1829883a 	mov	r20,r3
81124064:	a8001126 	beq	r21,zero,811240ac <_dtoa_r+0x448>
81124068:	05e04574 	movhi	r23,33045
8112406c:	bdeb9004 	addi	r23,r23,-20928
81124070:	4805883a 	mov	r2,r9
81124074:	4007883a 	mov	r3,r8
81124078:	a980004c 	andi	r6,r21,1
8112407c:	1009883a 	mov	r4,r2
81124080:	a82bd07a 	srai	r21,r21,1
81124084:	180b883a 	mov	r5,r3
81124088:	30000426 	beq	r6,zero,8112409c <_dtoa_r+0x438>
8112408c:	b9800017 	ldw	r6,0(r23)
81124090:	b9c00117 	ldw	r7,4(r23)
81124094:	84000044 	addi	r16,r16,1
81124098:	111aefc0 	call	8111aefc <__muldf3>
8112409c:	bdc00204 	addi	r23,r23,8
811240a0:	a83ff51e 	bne	r21,zero,81124078 <__reset+0xfb104078>
811240a4:	1013883a 	mov	r9,r2
811240a8:	1811883a 	mov	r8,r3
811240ac:	480d883a 	mov	r6,r9
811240b0:	400f883a 	mov	r7,r8
811240b4:	8809883a 	mov	r4,r17
811240b8:	a00b883a 	mov	r5,r20
811240bc:	112fca00 	call	8112fca0 <__divdf3>
811240c0:	d8800f15 	stw	r2,60(sp)
811240c4:	d8c01015 	stw	r3,64(sp)
811240c8:	d8c00e17 	ldw	r3,56(sp)
811240cc:	18000626 	beq	r3,zero,811240e8 <_dtoa_r+0x484>
811240d0:	d9000f17 	ldw	r4,60(sp)
811240d4:	d9401017 	ldw	r5,64(sp)
811240d8:	000d883a 	mov	r6,zero
811240dc:	01cffc34 	movhi	r7,16368
811240e0:	11306f40 	call	811306f4 <__ledf2>
811240e4:	10040b16 	blt	r2,zero,81125114 <_dtoa_r+0x14b0>
811240e8:	8009883a 	mov	r4,r16
811240ec:	113116c0 	call	8113116c <__floatsidf>
811240f0:	d9800f17 	ldw	r6,60(sp)
811240f4:	d9c01017 	ldw	r7,64(sp)
811240f8:	1009883a 	mov	r4,r2
811240fc:	180b883a 	mov	r5,r3
81124100:	111aefc0 	call	8111aefc <__muldf3>
81124104:	000d883a 	mov	r6,zero
81124108:	01d00734 	movhi	r7,16412
8112410c:	1009883a 	mov	r4,r2
81124110:	180b883a 	mov	r5,r3
81124114:	112f3ec0 	call	8112f3ec <__adddf3>
81124118:	1021883a 	mov	r16,r2
8112411c:	d8800617 	ldw	r2,24(sp)
81124120:	047f3034 	movhi	r17,64704
81124124:	1c63883a 	add	r17,r3,r17
81124128:	10031826 	beq	r2,zero,81124d8c <_dtoa_r+0x1128>
8112412c:	d8c00517 	ldw	r3,20(sp)
81124130:	db000617 	ldw	r12,24(sp)
81124134:	d8c01315 	stw	r3,76(sp)
81124138:	d9000b17 	ldw	r4,44(sp)
8112413c:	20038f26 	beq	r4,zero,81124f7c <_dtoa_r+0x1318>
81124140:	60bfffc4 	addi	r2,r12,-1
81124144:	100490fa 	slli	r2,r2,3
81124148:	00e04574 	movhi	r3,33045
8112414c:	18eb9a04 	addi	r3,r3,-20888
81124150:	1885883a 	add	r2,r3,r2
81124154:	11800017 	ldw	r6,0(r2)
81124158:	11c00117 	ldw	r7,4(r2)
8112415c:	d8800717 	ldw	r2,28(sp)
81124160:	0009883a 	mov	r4,zero
81124164:	014ff834 	movhi	r5,16352
81124168:	db001615 	stw	r12,88(sp)
8112416c:	15c00044 	addi	r23,r2,1
81124170:	112fca00 	call	8112fca0 <__divdf3>
81124174:	800d883a 	mov	r6,r16
81124178:	880f883a 	mov	r7,r17
8112417c:	1009883a 	mov	r4,r2
81124180:	180b883a 	mov	r5,r3
81124184:	11307e80 	call	811307e8 <__subdf3>
81124188:	d9401017 	ldw	r5,64(sp)
8112418c:	d9000f17 	ldw	r4,60(sp)
81124190:	102b883a 	mov	r21,r2
81124194:	d8c01215 	stw	r3,72(sp)
81124198:	11310ec0 	call	811310ec <__fixdfsi>
8112419c:	1009883a 	mov	r4,r2
811241a0:	1029883a 	mov	r20,r2
811241a4:	113116c0 	call	8113116c <__floatsidf>
811241a8:	d9000f17 	ldw	r4,60(sp)
811241ac:	d9401017 	ldw	r5,64(sp)
811241b0:	100d883a 	mov	r6,r2
811241b4:	180f883a 	mov	r7,r3
811241b8:	11307e80 	call	811307e8 <__subdf3>
811241bc:	1823883a 	mov	r17,r3
811241c0:	d8c00717 	ldw	r3,28(sp)
811241c4:	d9401217 	ldw	r5,72(sp)
811241c8:	a2000c04 	addi	r8,r20,48
811241cc:	1021883a 	mov	r16,r2
811241d0:	1a000005 	stb	r8,0(r3)
811241d4:	800d883a 	mov	r6,r16
811241d8:	880f883a 	mov	r7,r17
811241dc:	a809883a 	mov	r4,r21
811241e0:	4029883a 	mov	r20,r8
811241e4:	11306180 	call	81130618 <__gedf2>
811241e8:	00841d16 	blt	zero,r2,81125260 <_dtoa_r+0x15fc>
811241ec:	800d883a 	mov	r6,r16
811241f0:	880f883a 	mov	r7,r17
811241f4:	0009883a 	mov	r4,zero
811241f8:	014ffc34 	movhi	r5,16368
811241fc:	11307e80 	call	811307e8 <__subdf3>
81124200:	d9401217 	ldw	r5,72(sp)
81124204:	100d883a 	mov	r6,r2
81124208:	180f883a 	mov	r7,r3
8112420c:	a809883a 	mov	r4,r21
81124210:	11306180 	call	81130618 <__gedf2>
81124214:	db001617 	ldw	r12,88(sp)
81124218:	00840e16 	blt	zero,r2,81125254 <_dtoa_r+0x15f0>
8112421c:	00800044 	movi	r2,1
81124220:	13006b0e 	bge	r2,r12,811243d0 <_dtoa_r+0x76c>
81124224:	d9000717 	ldw	r4,28(sp)
81124228:	dd800f15 	stw	r22,60(sp)
8112422c:	dcc01015 	stw	r19,64(sp)
81124230:	2319883a 	add	r12,r4,r12
81124234:	dcc01217 	ldw	r19,72(sp)
81124238:	602d883a 	mov	r22,r12
8112423c:	dc801215 	stw	r18,72(sp)
81124240:	b825883a 	mov	r18,r23
81124244:	00000906 	br	8112426c <_dtoa_r+0x608>
81124248:	11307e80 	call	811307e8 <__subdf3>
8112424c:	a80d883a 	mov	r6,r21
81124250:	980f883a 	mov	r7,r19
81124254:	1009883a 	mov	r4,r2
81124258:	180b883a 	mov	r5,r3
8112425c:	11306f40 	call	811306f4 <__ledf2>
81124260:	1003e816 	blt	r2,zero,81125204 <_dtoa_r+0x15a0>
81124264:	b825883a 	mov	r18,r23
81124268:	bd83e926 	beq	r23,r22,81125210 <_dtoa_r+0x15ac>
8112426c:	a809883a 	mov	r4,r21
81124270:	980b883a 	mov	r5,r19
81124274:	000d883a 	mov	r6,zero
81124278:	01d00934 	movhi	r7,16420
8112427c:	111aefc0 	call	8111aefc <__muldf3>
81124280:	000d883a 	mov	r6,zero
81124284:	01d00934 	movhi	r7,16420
81124288:	8009883a 	mov	r4,r16
8112428c:	880b883a 	mov	r5,r17
81124290:	102b883a 	mov	r21,r2
81124294:	1827883a 	mov	r19,r3
81124298:	111aefc0 	call	8111aefc <__muldf3>
8112429c:	180b883a 	mov	r5,r3
811242a0:	1009883a 	mov	r4,r2
811242a4:	1821883a 	mov	r16,r3
811242a8:	1023883a 	mov	r17,r2
811242ac:	11310ec0 	call	811310ec <__fixdfsi>
811242b0:	1009883a 	mov	r4,r2
811242b4:	1029883a 	mov	r20,r2
811242b8:	113116c0 	call	8113116c <__floatsidf>
811242bc:	8809883a 	mov	r4,r17
811242c0:	800b883a 	mov	r5,r16
811242c4:	100d883a 	mov	r6,r2
811242c8:	180f883a 	mov	r7,r3
811242cc:	11307e80 	call	811307e8 <__subdf3>
811242d0:	a5000c04 	addi	r20,r20,48
811242d4:	a80d883a 	mov	r6,r21
811242d8:	980f883a 	mov	r7,r19
811242dc:	1009883a 	mov	r4,r2
811242e0:	180b883a 	mov	r5,r3
811242e4:	95000005 	stb	r20,0(r18)
811242e8:	1021883a 	mov	r16,r2
811242ec:	1823883a 	mov	r17,r3
811242f0:	11306f40 	call	811306f4 <__ledf2>
811242f4:	bdc00044 	addi	r23,r23,1
811242f8:	800d883a 	mov	r6,r16
811242fc:	880f883a 	mov	r7,r17
81124300:	0009883a 	mov	r4,zero
81124304:	014ffc34 	movhi	r5,16368
81124308:	103fcf0e 	bge	r2,zero,81124248 <__reset+0xfb104248>
8112430c:	d8c01317 	ldw	r3,76(sp)
81124310:	d8c00515 	stw	r3,20(sp)
81124314:	d9400917 	ldw	r5,36(sp)
81124318:	e009883a 	mov	r4,fp
8112431c:	1126e2c0 	call	81126e2c <_Bfree>
81124320:	d9000517 	ldw	r4,20(sp)
81124324:	d9802317 	ldw	r6,140(sp)
81124328:	d9c02517 	ldw	r7,148(sp)
8112432c:	b8000005 	stb	zero,0(r23)
81124330:	20800044 	addi	r2,r4,1
81124334:	30800015 	stw	r2,0(r6)
81124338:	3802aa26 	beq	r7,zero,81124de4 <_dtoa_r+0x1180>
8112433c:	3dc00015 	stw	r23,0(r7)
81124340:	d8800717 	ldw	r2,28(sp)
81124344:	003e7906 	br	81123d2c <__reset+0xfb103d2c>
81124348:	00800434 	movhi	r2,16
8112434c:	10bfffc4 	addi	r2,r2,-1
81124350:	88a2703a 	and	r17,r17,r2
81124354:	883e851e 	bne	r17,zero,81123d6c <__reset+0xfb103d6c>
81124358:	00a04574 	movhi	r2,33045
8112435c:	10ab7c04 	addi	r2,r2,-21008
81124360:	003e8406 	br	81123d74 <__reset+0xfb103d74>
81124364:	10c00204 	addi	r3,r2,8
81124368:	003e8706 	br	81123d88 <__reset+0xfb103d88>
8112436c:	01400434 	movhi	r5,16
81124370:	297fffc4 	addi	r5,r5,-1
81124374:	994a703a 	and	r5,r19,r5
81124378:	9009883a 	mov	r4,r18
8112437c:	843f0044 	addi	r16,r16,-1023
81124380:	294ffc34 	orhi	r5,r5,16368
81124384:	dd800217 	ldw	r22,8(sp)
81124388:	d8001115 	stw	zero,68(sp)
8112438c:	003ea506 	br	81123e24 <__reset+0xfb103e24>
81124390:	00a04574 	movhi	r2,33045
81124394:	10ab6104 	addi	r2,r2,-21116
81124398:	003e6406 	br	81123d2c <__reset+0xfb103d2c>
8112439c:	e0001115 	stw	zero,68(fp)
811243a0:	000b883a 	mov	r5,zero
811243a4:	e009883a 	mov	r4,fp
811243a8:	1126d7c0 	call	81126d7c <_Balloc>
811243ac:	01bfffc4 	movi	r6,-1
811243b0:	01c00044 	movi	r7,1
811243b4:	d8800715 	stw	r2,28(sp)
811243b8:	d9800c15 	stw	r6,48(sp)
811243bc:	e0801015 	stw	r2,64(fp)
811243c0:	d8000315 	stw	zero,12(sp)
811243c4:	d9c00b15 	stw	r7,44(sp)
811243c8:	d9800615 	stw	r6,24(sp)
811243cc:	d8002215 	stw	zero,136(sp)
811243d0:	d8800117 	ldw	r2,4(sp)
811243d4:	10008916 	blt	r2,zero,811245fc <_dtoa_r+0x998>
811243d8:	d9000517 	ldw	r4,20(sp)
811243dc:	00c00384 	movi	r3,14
811243e0:	19008616 	blt	r3,r4,811245fc <_dtoa_r+0x998>
811243e4:	200490fa 	slli	r2,r4,3
811243e8:	00e04574 	movhi	r3,33045
811243ec:	d9802217 	ldw	r6,136(sp)
811243f0:	18eb9a04 	addi	r3,r3,-20888
811243f4:	1885883a 	add	r2,r3,r2
811243f8:	14000017 	ldw	r16,0(r2)
811243fc:	14400117 	ldw	r17,4(r2)
81124400:	30016316 	blt	r6,zero,81124990 <_dtoa_r+0xd2c>
81124404:	800d883a 	mov	r6,r16
81124408:	880f883a 	mov	r7,r17
8112440c:	9009883a 	mov	r4,r18
81124410:	980b883a 	mov	r5,r19
81124414:	112fca00 	call	8112fca0 <__divdf3>
81124418:	180b883a 	mov	r5,r3
8112441c:	1009883a 	mov	r4,r2
81124420:	11310ec0 	call	811310ec <__fixdfsi>
81124424:	1009883a 	mov	r4,r2
81124428:	102b883a 	mov	r21,r2
8112442c:	113116c0 	call	8113116c <__floatsidf>
81124430:	800d883a 	mov	r6,r16
81124434:	880f883a 	mov	r7,r17
81124438:	1009883a 	mov	r4,r2
8112443c:	180b883a 	mov	r5,r3
81124440:	111aefc0 	call	8111aefc <__muldf3>
81124444:	100d883a 	mov	r6,r2
81124448:	180f883a 	mov	r7,r3
8112444c:	9009883a 	mov	r4,r18
81124450:	980b883a 	mov	r5,r19
81124454:	11307e80 	call	811307e8 <__subdf3>
81124458:	d9c00717 	ldw	r7,28(sp)
8112445c:	1009883a 	mov	r4,r2
81124460:	a8800c04 	addi	r2,r21,48
81124464:	38800005 	stb	r2,0(r7)
81124468:	3dc00044 	addi	r23,r7,1
8112446c:	d9c00617 	ldw	r7,24(sp)
81124470:	01800044 	movi	r6,1
81124474:	180b883a 	mov	r5,r3
81124478:	2005883a 	mov	r2,r4
8112447c:	39803826 	beq	r7,r6,81124560 <_dtoa_r+0x8fc>
81124480:	000d883a 	mov	r6,zero
81124484:	01d00934 	movhi	r7,16420
81124488:	111aefc0 	call	8111aefc <__muldf3>
8112448c:	000d883a 	mov	r6,zero
81124490:	000f883a 	mov	r7,zero
81124494:	1009883a 	mov	r4,r2
81124498:	180b883a 	mov	r5,r3
8112449c:	1025883a 	mov	r18,r2
811244a0:	1827883a 	mov	r19,r3
811244a4:	11305900 	call	81130590 <__eqdf2>
811244a8:	103f9a26 	beq	r2,zero,81124314 <__reset+0xfb104314>
811244ac:	d9c00617 	ldw	r7,24(sp)
811244b0:	d8c00717 	ldw	r3,28(sp)
811244b4:	b829883a 	mov	r20,r23
811244b8:	38bfffc4 	addi	r2,r7,-1
811244bc:	18ad883a 	add	r22,r3,r2
811244c0:	00000a06 	br	811244ec <_dtoa_r+0x888>
811244c4:	111aefc0 	call	8111aefc <__muldf3>
811244c8:	000d883a 	mov	r6,zero
811244cc:	000f883a 	mov	r7,zero
811244d0:	1009883a 	mov	r4,r2
811244d4:	180b883a 	mov	r5,r3
811244d8:	1025883a 	mov	r18,r2
811244dc:	1827883a 	mov	r19,r3
811244e0:	b829883a 	mov	r20,r23
811244e4:	11305900 	call	81130590 <__eqdf2>
811244e8:	103f8a26 	beq	r2,zero,81124314 <__reset+0xfb104314>
811244ec:	800d883a 	mov	r6,r16
811244f0:	880f883a 	mov	r7,r17
811244f4:	9009883a 	mov	r4,r18
811244f8:	980b883a 	mov	r5,r19
811244fc:	112fca00 	call	8112fca0 <__divdf3>
81124500:	180b883a 	mov	r5,r3
81124504:	1009883a 	mov	r4,r2
81124508:	11310ec0 	call	811310ec <__fixdfsi>
8112450c:	1009883a 	mov	r4,r2
81124510:	102b883a 	mov	r21,r2
81124514:	113116c0 	call	8113116c <__floatsidf>
81124518:	800d883a 	mov	r6,r16
8112451c:	880f883a 	mov	r7,r17
81124520:	1009883a 	mov	r4,r2
81124524:	180b883a 	mov	r5,r3
81124528:	111aefc0 	call	8111aefc <__muldf3>
8112452c:	100d883a 	mov	r6,r2
81124530:	180f883a 	mov	r7,r3
81124534:	9009883a 	mov	r4,r18
81124538:	980b883a 	mov	r5,r19
8112453c:	11307e80 	call	811307e8 <__subdf3>
81124540:	aa000c04 	addi	r8,r21,48
81124544:	a2000005 	stb	r8,0(r20)
81124548:	000d883a 	mov	r6,zero
8112454c:	01d00934 	movhi	r7,16420
81124550:	1009883a 	mov	r4,r2
81124554:	180b883a 	mov	r5,r3
81124558:	a5c00044 	addi	r23,r20,1
8112455c:	b53fd91e 	bne	r22,r20,811244c4 <__reset+0xfb1044c4>
81124560:	100d883a 	mov	r6,r2
81124564:	180f883a 	mov	r7,r3
81124568:	1009883a 	mov	r4,r2
8112456c:	180b883a 	mov	r5,r3
81124570:	112f3ec0 	call	8112f3ec <__adddf3>
81124574:	100d883a 	mov	r6,r2
81124578:	180f883a 	mov	r7,r3
8112457c:	8009883a 	mov	r4,r16
81124580:	880b883a 	mov	r5,r17
81124584:	1027883a 	mov	r19,r2
81124588:	1825883a 	mov	r18,r3
8112458c:	11306f40 	call	811306f4 <__ledf2>
81124590:	10000816 	blt	r2,zero,811245b4 <_dtoa_r+0x950>
81124594:	980d883a 	mov	r6,r19
81124598:	900f883a 	mov	r7,r18
8112459c:	8009883a 	mov	r4,r16
811245a0:	880b883a 	mov	r5,r17
811245a4:	11305900 	call	81130590 <__eqdf2>
811245a8:	103f5a1e 	bne	r2,zero,81124314 <__reset+0xfb104314>
811245ac:	ad40004c 	andi	r21,r21,1
811245b0:	a83f5826 	beq	r21,zero,81124314 <__reset+0xfb104314>
811245b4:	bd3fffc3 	ldbu	r20,-1(r23)
811245b8:	b8bfffc4 	addi	r2,r23,-1
811245bc:	1007883a 	mov	r3,r2
811245c0:	01400e44 	movi	r5,57
811245c4:	d9800717 	ldw	r6,28(sp)
811245c8:	00000506 	br	811245e0 <_dtoa_r+0x97c>
811245cc:	18ffffc4 	addi	r3,r3,-1
811245d0:	11824726 	beq	r2,r6,81124ef0 <_dtoa_r+0x128c>
811245d4:	1d000003 	ldbu	r20,0(r3)
811245d8:	102f883a 	mov	r23,r2
811245dc:	10bfffc4 	addi	r2,r2,-1
811245e0:	a1003fcc 	andi	r4,r20,255
811245e4:	2100201c 	xori	r4,r4,128
811245e8:	213fe004 	addi	r4,r4,-128
811245ec:	217ff726 	beq	r4,r5,811245cc <__reset+0xfb1045cc>
811245f0:	a2000044 	addi	r8,r20,1
811245f4:	12000005 	stb	r8,0(r2)
811245f8:	003f4606 	br	81124314 <__reset+0xfb104314>
811245fc:	d9000b17 	ldw	r4,44(sp)
81124600:	2000c826 	beq	r4,zero,81124924 <_dtoa_r+0xcc0>
81124604:	d9800317 	ldw	r6,12(sp)
81124608:	00c00044 	movi	r3,1
8112460c:	1980f90e 	bge	r3,r6,811249f4 <_dtoa_r+0xd90>
81124610:	d8800617 	ldw	r2,24(sp)
81124614:	d8c00a17 	ldw	r3,40(sp)
81124618:	157fffc4 	addi	r21,r2,-1
8112461c:	1d41f316 	blt	r3,r21,81124dec <_dtoa_r+0x1188>
81124620:	1d6bc83a 	sub	r21,r3,r21
81124624:	d9c00617 	ldw	r7,24(sp)
81124628:	3802aa16 	blt	r7,zero,811250d4 <_dtoa_r+0x1470>
8112462c:	dd000817 	ldw	r20,32(sp)
81124630:	d8800617 	ldw	r2,24(sp)
81124634:	d8c00817 	ldw	r3,32(sp)
81124638:	01400044 	movi	r5,1
8112463c:	e009883a 	mov	r4,fp
81124640:	1887883a 	add	r3,r3,r2
81124644:	d8c00815 	stw	r3,32(sp)
81124648:	b0ad883a 	add	r22,r22,r2
8112464c:	11271a00 	call	811271a0 <__i2b>
81124650:	1023883a 	mov	r17,r2
81124654:	a0000826 	beq	r20,zero,81124678 <_dtoa_r+0xa14>
81124658:	0580070e 	bge	zero,r22,81124678 <_dtoa_r+0xa14>
8112465c:	a005883a 	mov	r2,r20
81124660:	b500b916 	blt	r22,r20,81124948 <_dtoa_r+0xce4>
81124664:	d9000817 	ldw	r4,32(sp)
81124668:	a0a9c83a 	sub	r20,r20,r2
8112466c:	b0adc83a 	sub	r22,r22,r2
81124670:	2089c83a 	sub	r4,r4,r2
81124674:	d9000815 	stw	r4,32(sp)
81124678:	d9800a17 	ldw	r6,40(sp)
8112467c:	0181810e 	bge	zero,r6,81124c84 <_dtoa_r+0x1020>
81124680:	d9c00b17 	ldw	r7,44(sp)
81124684:	3800b326 	beq	r7,zero,81124954 <_dtoa_r+0xcf0>
81124688:	a800b226 	beq	r21,zero,81124954 <_dtoa_r+0xcf0>
8112468c:	880b883a 	mov	r5,r17
81124690:	a80d883a 	mov	r6,r21
81124694:	e009883a 	mov	r4,fp
81124698:	11273e40 	call	811273e4 <__pow5mult>
8112469c:	d9800917 	ldw	r6,36(sp)
811246a0:	100b883a 	mov	r5,r2
811246a4:	e009883a 	mov	r4,fp
811246a8:	1023883a 	mov	r17,r2
811246ac:	11271e40 	call	811271e4 <__multiply>
811246b0:	1021883a 	mov	r16,r2
811246b4:	d8800a17 	ldw	r2,40(sp)
811246b8:	d9400917 	ldw	r5,36(sp)
811246bc:	e009883a 	mov	r4,fp
811246c0:	1545c83a 	sub	r2,r2,r21
811246c4:	d8800a15 	stw	r2,40(sp)
811246c8:	1126e2c0 	call	81126e2c <_Bfree>
811246cc:	d8c00a17 	ldw	r3,40(sp)
811246d0:	18009f1e 	bne	r3,zero,81124950 <_dtoa_r+0xcec>
811246d4:	05c00044 	movi	r23,1
811246d8:	e009883a 	mov	r4,fp
811246dc:	b80b883a 	mov	r5,r23
811246e0:	11271a00 	call	811271a0 <__i2b>
811246e4:	d9000d17 	ldw	r4,52(sp)
811246e8:	102b883a 	mov	r21,r2
811246ec:	2000ce26 	beq	r4,zero,81124a28 <_dtoa_r+0xdc4>
811246f0:	200d883a 	mov	r6,r4
811246f4:	100b883a 	mov	r5,r2
811246f8:	e009883a 	mov	r4,fp
811246fc:	11273e40 	call	811273e4 <__pow5mult>
81124700:	d9800317 	ldw	r6,12(sp)
81124704:	102b883a 	mov	r21,r2
81124708:	b981810e 	bge	r23,r6,81124d10 <_dtoa_r+0x10ac>
8112470c:	0027883a 	mov	r19,zero
81124710:	a8800417 	ldw	r2,16(r21)
81124714:	05c00804 	movi	r23,32
81124718:	10800104 	addi	r2,r2,4
8112471c:	1085883a 	add	r2,r2,r2
81124720:	1085883a 	add	r2,r2,r2
81124724:	a885883a 	add	r2,r21,r2
81124728:	11000017 	ldw	r4,0(r2)
8112472c:	11270880 	call	81127088 <__hi0bits>
81124730:	b885c83a 	sub	r2,r23,r2
81124734:	1585883a 	add	r2,r2,r22
81124738:	108007cc 	andi	r2,r2,31
8112473c:	1000b326 	beq	r2,zero,81124a0c <_dtoa_r+0xda8>
81124740:	00c00804 	movi	r3,32
81124744:	1887c83a 	sub	r3,r3,r2
81124748:	01000104 	movi	r4,4
8112474c:	20c2cd0e 	bge	r4,r3,81125284 <_dtoa_r+0x1620>
81124750:	00c00704 	movi	r3,28
81124754:	1885c83a 	sub	r2,r3,r2
81124758:	d8c00817 	ldw	r3,32(sp)
8112475c:	a0a9883a 	add	r20,r20,r2
81124760:	b0ad883a 	add	r22,r22,r2
81124764:	1887883a 	add	r3,r3,r2
81124768:	d8c00815 	stw	r3,32(sp)
8112476c:	d9800817 	ldw	r6,32(sp)
81124770:	0180040e 	bge	zero,r6,81124784 <_dtoa_r+0xb20>
81124774:	800b883a 	mov	r5,r16
81124778:	e009883a 	mov	r4,fp
8112477c:	112752c0 	call	8112752c <__lshift>
81124780:	1021883a 	mov	r16,r2
81124784:	0580050e 	bge	zero,r22,8112479c <_dtoa_r+0xb38>
81124788:	a80b883a 	mov	r5,r21
8112478c:	b00d883a 	mov	r6,r22
81124790:	e009883a 	mov	r4,fp
81124794:	112752c0 	call	8112752c <__lshift>
81124798:	102b883a 	mov	r21,r2
8112479c:	d9c00e17 	ldw	r7,56(sp)
811247a0:	3801211e 	bne	r7,zero,81124c28 <_dtoa_r+0xfc4>
811247a4:	d9800617 	ldw	r6,24(sp)
811247a8:	0181380e 	bge	zero,r6,81124c8c <_dtoa_r+0x1028>
811247ac:	d8c00b17 	ldw	r3,44(sp)
811247b0:	1800ab1e 	bne	r3,zero,81124a60 <_dtoa_r+0xdfc>
811247b4:	dc800717 	ldw	r18,28(sp)
811247b8:	dcc00617 	ldw	r19,24(sp)
811247bc:	9029883a 	mov	r20,r18
811247c0:	00000206 	br	811247cc <_dtoa_r+0xb68>
811247c4:	1126e540 	call	81126e54 <__multadd>
811247c8:	1021883a 	mov	r16,r2
811247cc:	a80b883a 	mov	r5,r21
811247d0:	8009883a 	mov	r4,r16
811247d4:	1123a5c0 	call	81123a5c <quorem>
811247d8:	10800c04 	addi	r2,r2,48
811247dc:	90800005 	stb	r2,0(r18)
811247e0:	94800044 	addi	r18,r18,1
811247e4:	9507c83a 	sub	r3,r18,r20
811247e8:	000f883a 	mov	r7,zero
811247ec:	01800284 	movi	r6,10
811247f0:	800b883a 	mov	r5,r16
811247f4:	e009883a 	mov	r4,fp
811247f8:	1cfff216 	blt	r3,r19,811247c4 <__reset+0xfb1047c4>
811247fc:	1011883a 	mov	r8,r2
81124800:	d8800617 	ldw	r2,24(sp)
81124804:	0082370e 	bge	zero,r2,811250e4 <_dtoa_r+0x1480>
81124808:	d9000717 	ldw	r4,28(sp)
8112480c:	0025883a 	mov	r18,zero
81124810:	20af883a 	add	r23,r4,r2
81124814:	01800044 	movi	r6,1
81124818:	800b883a 	mov	r5,r16
8112481c:	e009883a 	mov	r4,fp
81124820:	da001715 	stw	r8,92(sp)
81124824:	112752c0 	call	8112752c <__lshift>
81124828:	a80b883a 	mov	r5,r21
8112482c:	1009883a 	mov	r4,r2
81124830:	d8800915 	stw	r2,36(sp)
81124834:	112767c0 	call	8112767c <__mcmp>
81124838:	da001717 	ldw	r8,92(sp)
8112483c:	0081800e 	bge	zero,r2,81124e40 <_dtoa_r+0x11dc>
81124840:	b93fffc3 	ldbu	r4,-1(r23)
81124844:	b8bfffc4 	addi	r2,r23,-1
81124848:	1007883a 	mov	r3,r2
8112484c:	01800e44 	movi	r6,57
81124850:	d9c00717 	ldw	r7,28(sp)
81124854:	00000506 	br	8112486c <_dtoa_r+0xc08>
81124858:	18ffffc4 	addi	r3,r3,-1
8112485c:	11c12326 	beq	r2,r7,81124cec <_dtoa_r+0x1088>
81124860:	19000003 	ldbu	r4,0(r3)
81124864:	102f883a 	mov	r23,r2
81124868:	10bfffc4 	addi	r2,r2,-1
8112486c:	21403fcc 	andi	r5,r4,255
81124870:	2940201c 	xori	r5,r5,128
81124874:	297fe004 	addi	r5,r5,-128
81124878:	29bff726 	beq	r5,r6,81124858 <__reset+0xfb104858>
8112487c:	21000044 	addi	r4,r4,1
81124880:	11000005 	stb	r4,0(r2)
81124884:	a80b883a 	mov	r5,r21
81124888:	e009883a 	mov	r4,fp
8112488c:	1126e2c0 	call	81126e2c <_Bfree>
81124890:	883ea026 	beq	r17,zero,81124314 <__reset+0xfb104314>
81124894:	90000426 	beq	r18,zero,811248a8 <_dtoa_r+0xc44>
81124898:	94400326 	beq	r18,r17,811248a8 <_dtoa_r+0xc44>
8112489c:	900b883a 	mov	r5,r18
811248a0:	e009883a 	mov	r4,fp
811248a4:	1126e2c0 	call	81126e2c <_Bfree>
811248a8:	880b883a 	mov	r5,r17
811248ac:	e009883a 	mov	r4,fp
811248b0:	1126e2c0 	call	81126e2c <_Bfree>
811248b4:	003e9706 	br	81124314 <__reset+0xfb104314>
811248b8:	01800044 	movi	r6,1
811248bc:	d9800e15 	stw	r6,56(sp)
811248c0:	003d9606 	br	81123f1c <__reset+0xfb103f1c>
811248c4:	d8800817 	ldw	r2,32(sp)
811248c8:	d8c00517 	ldw	r3,20(sp)
811248cc:	d8000d15 	stw	zero,52(sp)
811248d0:	10c5c83a 	sub	r2,r2,r3
811248d4:	00c9c83a 	sub	r4,zero,r3
811248d8:	d8800815 	stw	r2,32(sp)
811248dc:	d9000a15 	stw	r4,40(sp)
811248e0:	003d9706 	br	81123f40 <__reset+0xfb103f40>
811248e4:	05adc83a 	sub	r22,zero,r22
811248e8:	dd800815 	stw	r22,32(sp)
811248ec:	002d883a 	mov	r22,zero
811248f0:	003d8e06 	br	81123f2c <__reset+0xfb103f2c>
811248f4:	d9000517 	ldw	r4,20(sp)
811248f8:	113116c0 	call	8113116c <__floatsidf>
811248fc:	100d883a 	mov	r6,r2
81124900:	180f883a 	mov	r7,r3
81124904:	a009883a 	mov	r4,r20
81124908:	880b883a 	mov	r5,r17
8112490c:	11305900 	call	81130590 <__eqdf2>
81124910:	103d7126 	beq	r2,zero,81123ed8 <__reset+0xfb103ed8>
81124914:	d9c00517 	ldw	r7,20(sp)
81124918:	39ffffc4 	addi	r7,r7,-1
8112491c:	d9c00515 	stw	r7,20(sp)
81124920:	003d6d06 	br	81123ed8 <__reset+0xfb103ed8>
81124924:	dd400a17 	ldw	r21,40(sp)
81124928:	dd000817 	ldw	r20,32(sp)
8112492c:	0023883a 	mov	r17,zero
81124930:	003f4806 	br	81124654 <__reset+0xfb104654>
81124934:	10e3c83a 	sub	r17,r2,r3
81124938:	9448983a 	sll	r4,r18,r17
8112493c:	003d3206 	br	81123e08 <__reset+0xfb103e08>
81124940:	d8000e15 	stw	zero,56(sp)
81124944:	003d7506 	br	81123f1c <__reset+0xfb103f1c>
81124948:	b005883a 	mov	r2,r22
8112494c:	003f4506 	br	81124664 <__reset+0xfb104664>
81124950:	dc000915 	stw	r16,36(sp)
81124954:	d9800a17 	ldw	r6,40(sp)
81124958:	d9400917 	ldw	r5,36(sp)
8112495c:	e009883a 	mov	r4,fp
81124960:	11273e40 	call	811273e4 <__pow5mult>
81124964:	1021883a 	mov	r16,r2
81124968:	003f5a06 	br	811246d4 <__reset+0xfb1046d4>
8112496c:	01c00044 	movi	r7,1
81124970:	d9c00b15 	stw	r7,44(sp)
81124974:	d8802217 	ldw	r2,136(sp)
81124978:	0081280e 	bge	zero,r2,81124e1c <_dtoa_r+0x11b8>
8112497c:	100d883a 	mov	r6,r2
81124980:	1021883a 	mov	r16,r2
81124984:	d8800c15 	stw	r2,48(sp)
81124988:	d8800615 	stw	r2,24(sp)
8112498c:	003d8806 	br	81123fb0 <__reset+0xfb103fb0>
81124990:	d8800617 	ldw	r2,24(sp)
81124994:	00be9b16 	blt	zero,r2,81124404 <__reset+0xfb104404>
81124998:	10010f1e 	bne	r2,zero,81124dd8 <_dtoa_r+0x1174>
8112499c:	880b883a 	mov	r5,r17
811249a0:	000d883a 	mov	r6,zero
811249a4:	01d00534 	movhi	r7,16404
811249a8:	8009883a 	mov	r4,r16
811249ac:	111aefc0 	call	8111aefc <__muldf3>
811249b0:	900d883a 	mov	r6,r18
811249b4:	980f883a 	mov	r7,r19
811249b8:	1009883a 	mov	r4,r2
811249bc:	180b883a 	mov	r5,r3
811249c0:	11306180 	call	81130618 <__gedf2>
811249c4:	002b883a 	mov	r21,zero
811249c8:	0023883a 	mov	r17,zero
811249cc:	1000bf16 	blt	r2,zero,81124ccc <_dtoa_r+0x1068>
811249d0:	d9802217 	ldw	r6,136(sp)
811249d4:	ddc00717 	ldw	r23,28(sp)
811249d8:	018c303a 	nor	r6,zero,r6
811249dc:	d9800515 	stw	r6,20(sp)
811249e0:	a80b883a 	mov	r5,r21
811249e4:	e009883a 	mov	r4,fp
811249e8:	1126e2c0 	call	81126e2c <_Bfree>
811249ec:	883e4926 	beq	r17,zero,81124314 <__reset+0xfb104314>
811249f0:	003fad06 	br	811248a8 <__reset+0xfb1048a8>
811249f4:	d9c01117 	ldw	r7,68(sp)
811249f8:	3801bc26 	beq	r7,zero,811250ec <_dtoa_r+0x1488>
811249fc:	10810cc4 	addi	r2,r2,1075
81124a00:	dd400a17 	ldw	r21,40(sp)
81124a04:	dd000817 	ldw	r20,32(sp)
81124a08:	003f0a06 	br	81124634 <__reset+0xfb104634>
81124a0c:	00800704 	movi	r2,28
81124a10:	d9000817 	ldw	r4,32(sp)
81124a14:	a0a9883a 	add	r20,r20,r2
81124a18:	b0ad883a 	add	r22,r22,r2
81124a1c:	2089883a 	add	r4,r4,r2
81124a20:	d9000815 	stw	r4,32(sp)
81124a24:	003f5106 	br	8112476c <__reset+0xfb10476c>
81124a28:	d8c00317 	ldw	r3,12(sp)
81124a2c:	b8c1fc0e 	bge	r23,r3,81125220 <_dtoa_r+0x15bc>
81124a30:	0027883a 	mov	r19,zero
81124a34:	b805883a 	mov	r2,r23
81124a38:	003f3e06 	br	81124734 <__reset+0xfb104734>
81124a3c:	880b883a 	mov	r5,r17
81124a40:	e009883a 	mov	r4,fp
81124a44:	000f883a 	mov	r7,zero
81124a48:	01800284 	movi	r6,10
81124a4c:	1126e540 	call	81126e54 <__multadd>
81124a50:	d9000c17 	ldw	r4,48(sp)
81124a54:	1023883a 	mov	r17,r2
81124a58:	0102040e 	bge	zero,r4,8112526c <_dtoa_r+0x1608>
81124a5c:	d9000615 	stw	r4,24(sp)
81124a60:	0500050e 	bge	zero,r20,81124a78 <_dtoa_r+0xe14>
81124a64:	880b883a 	mov	r5,r17
81124a68:	a00d883a 	mov	r6,r20
81124a6c:	e009883a 	mov	r4,fp
81124a70:	112752c0 	call	8112752c <__lshift>
81124a74:	1023883a 	mov	r17,r2
81124a78:	9801241e 	bne	r19,zero,81124f0c <_dtoa_r+0x12a8>
81124a7c:	8829883a 	mov	r20,r17
81124a80:	d9000617 	ldw	r4,24(sp)
81124a84:	dcc00717 	ldw	r19,28(sp)
81124a88:	9480004c 	andi	r18,r18,1
81124a8c:	20bfffc4 	addi	r2,r4,-1
81124a90:	9885883a 	add	r2,r19,r2
81124a94:	d8800415 	stw	r2,16(sp)
81124a98:	dc800615 	stw	r18,24(sp)
81124a9c:	a80b883a 	mov	r5,r21
81124aa0:	8009883a 	mov	r4,r16
81124aa4:	1123a5c0 	call	81123a5c <quorem>
81124aa8:	880b883a 	mov	r5,r17
81124aac:	8009883a 	mov	r4,r16
81124ab0:	102f883a 	mov	r23,r2
81124ab4:	112767c0 	call	8112767c <__mcmp>
81124ab8:	a80b883a 	mov	r5,r21
81124abc:	a00d883a 	mov	r6,r20
81124ac0:	e009883a 	mov	r4,fp
81124ac4:	102d883a 	mov	r22,r2
81124ac8:	11276dc0 	call	811276dc <__mdiff>
81124acc:	1007883a 	mov	r3,r2
81124ad0:	10800317 	ldw	r2,12(r2)
81124ad4:	bc800c04 	addi	r18,r23,48
81124ad8:	180b883a 	mov	r5,r3
81124adc:	10004e1e 	bne	r2,zero,81124c18 <_dtoa_r+0xfb4>
81124ae0:	8009883a 	mov	r4,r16
81124ae4:	d8c01615 	stw	r3,88(sp)
81124ae8:	112767c0 	call	8112767c <__mcmp>
81124aec:	d8c01617 	ldw	r3,88(sp)
81124af0:	e009883a 	mov	r4,fp
81124af4:	d8801615 	stw	r2,88(sp)
81124af8:	180b883a 	mov	r5,r3
81124afc:	1126e2c0 	call	81126e2c <_Bfree>
81124b00:	d8801617 	ldw	r2,88(sp)
81124b04:	1000041e 	bne	r2,zero,81124b18 <_dtoa_r+0xeb4>
81124b08:	d9800317 	ldw	r6,12(sp)
81124b0c:	3000021e 	bne	r6,zero,81124b18 <_dtoa_r+0xeb4>
81124b10:	d8c00617 	ldw	r3,24(sp)
81124b14:	18003726 	beq	r3,zero,81124bf4 <_dtoa_r+0xf90>
81124b18:	b0002016 	blt	r22,zero,81124b9c <_dtoa_r+0xf38>
81124b1c:	b000041e 	bne	r22,zero,81124b30 <_dtoa_r+0xecc>
81124b20:	d9000317 	ldw	r4,12(sp)
81124b24:	2000021e 	bne	r4,zero,81124b30 <_dtoa_r+0xecc>
81124b28:	d8c00617 	ldw	r3,24(sp)
81124b2c:	18001b26 	beq	r3,zero,81124b9c <_dtoa_r+0xf38>
81124b30:	00810716 	blt	zero,r2,81124f50 <_dtoa_r+0x12ec>
81124b34:	d8c00417 	ldw	r3,16(sp)
81124b38:	9d800044 	addi	r22,r19,1
81124b3c:	9c800005 	stb	r18,0(r19)
81124b40:	b02f883a 	mov	r23,r22
81124b44:	98c10626 	beq	r19,r3,81124f60 <_dtoa_r+0x12fc>
81124b48:	800b883a 	mov	r5,r16
81124b4c:	000f883a 	mov	r7,zero
81124b50:	01800284 	movi	r6,10
81124b54:	e009883a 	mov	r4,fp
81124b58:	1126e540 	call	81126e54 <__multadd>
81124b5c:	1021883a 	mov	r16,r2
81124b60:	000f883a 	mov	r7,zero
81124b64:	01800284 	movi	r6,10
81124b68:	880b883a 	mov	r5,r17
81124b6c:	e009883a 	mov	r4,fp
81124b70:	8d002526 	beq	r17,r20,81124c08 <_dtoa_r+0xfa4>
81124b74:	1126e540 	call	81126e54 <__multadd>
81124b78:	a00b883a 	mov	r5,r20
81124b7c:	000f883a 	mov	r7,zero
81124b80:	01800284 	movi	r6,10
81124b84:	e009883a 	mov	r4,fp
81124b88:	1023883a 	mov	r17,r2
81124b8c:	1126e540 	call	81126e54 <__multadd>
81124b90:	1029883a 	mov	r20,r2
81124b94:	b027883a 	mov	r19,r22
81124b98:	003fc006 	br	81124a9c <__reset+0xfb104a9c>
81124b9c:	9011883a 	mov	r8,r18
81124ba0:	00800e0e 	bge	zero,r2,81124bdc <_dtoa_r+0xf78>
81124ba4:	800b883a 	mov	r5,r16
81124ba8:	01800044 	movi	r6,1
81124bac:	e009883a 	mov	r4,fp
81124bb0:	da001715 	stw	r8,92(sp)
81124bb4:	112752c0 	call	8112752c <__lshift>
81124bb8:	a80b883a 	mov	r5,r21
81124bbc:	1009883a 	mov	r4,r2
81124bc0:	1021883a 	mov	r16,r2
81124bc4:	112767c0 	call	8112767c <__mcmp>
81124bc8:	da001717 	ldw	r8,92(sp)
81124bcc:	0081960e 	bge	zero,r2,81125228 <_dtoa_r+0x15c4>
81124bd0:	00800e44 	movi	r2,57
81124bd4:	40817026 	beq	r8,r2,81125198 <_dtoa_r+0x1534>
81124bd8:	ba000c44 	addi	r8,r23,49
81124bdc:	8825883a 	mov	r18,r17
81124be0:	9dc00044 	addi	r23,r19,1
81124be4:	9a000005 	stb	r8,0(r19)
81124be8:	a023883a 	mov	r17,r20
81124bec:	dc000915 	stw	r16,36(sp)
81124bf0:	003f2406 	br	81124884 <__reset+0xfb104884>
81124bf4:	00800e44 	movi	r2,57
81124bf8:	9011883a 	mov	r8,r18
81124bfc:	90816626 	beq	r18,r2,81125198 <_dtoa_r+0x1534>
81124c00:	05bff516 	blt	zero,r22,81124bd8 <__reset+0xfb104bd8>
81124c04:	003ff506 	br	81124bdc <__reset+0xfb104bdc>
81124c08:	1126e540 	call	81126e54 <__multadd>
81124c0c:	1023883a 	mov	r17,r2
81124c10:	1029883a 	mov	r20,r2
81124c14:	003fdf06 	br	81124b94 <__reset+0xfb104b94>
81124c18:	e009883a 	mov	r4,fp
81124c1c:	1126e2c0 	call	81126e2c <_Bfree>
81124c20:	00800044 	movi	r2,1
81124c24:	003fbc06 	br	81124b18 <__reset+0xfb104b18>
81124c28:	a80b883a 	mov	r5,r21
81124c2c:	8009883a 	mov	r4,r16
81124c30:	112767c0 	call	8112767c <__mcmp>
81124c34:	103edb0e 	bge	r2,zero,811247a4 <__reset+0xfb1047a4>
81124c38:	800b883a 	mov	r5,r16
81124c3c:	000f883a 	mov	r7,zero
81124c40:	01800284 	movi	r6,10
81124c44:	e009883a 	mov	r4,fp
81124c48:	1126e540 	call	81126e54 <__multadd>
81124c4c:	1021883a 	mov	r16,r2
81124c50:	d8800517 	ldw	r2,20(sp)
81124c54:	d8c00b17 	ldw	r3,44(sp)
81124c58:	10bfffc4 	addi	r2,r2,-1
81124c5c:	d8800515 	stw	r2,20(sp)
81124c60:	183f761e 	bne	r3,zero,81124a3c <__reset+0xfb104a3c>
81124c64:	d9000c17 	ldw	r4,48(sp)
81124c68:	0101730e 	bge	zero,r4,81125238 <_dtoa_r+0x15d4>
81124c6c:	d9000615 	stw	r4,24(sp)
81124c70:	003ed006 	br	811247b4 <__reset+0xfb1047b4>
81124c74:	00800084 	movi	r2,2
81124c78:	3081861e 	bne	r6,r2,81125294 <_dtoa_r+0x1630>
81124c7c:	d8000b15 	stw	zero,44(sp)
81124c80:	003f3c06 	br	81124974 <__reset+0xfb104974>
81124c84:	dc000917 	ldw	r16,36(sp)
81124c88:	003e9206 	br	811246d4 <__reset+0xfb1046d4>
81124c8c:	d9c00317 	ldw	r7,12(sp)
81124c90:	00800084 	movi	r2,2
81124c94:	11fec50e 	bge	r2,r7,811247ac <__reset+0xfb1047ac>
81124c98:	d9000617 	ldw	r4,24(sp)
81124c9c:	20013c1e 	bne	r4,zero,81125190 <_dtoa_r+0x152c>
81124ca0:	a80b883a 	mov	r5,r21
81124ca4:	000f883a 	mov	r7,zero
81124ca8:	01800144 	movi	r6,5
81124cac:	e009883a 	mov	r4,fp
81124cb0:	1126e540 	call	81126e54 <__multadd>
81124cb4:	100b883a 	mov	r5,r2
81124cb8:	8009883a 	mov	r4,r16
81124cbc:	102b883a 	mov	r21,r2
81124cc0:	112767c0 	call	8112767c <__mcmp>
81124cc4:	dc000915 	stw	r16,36(sp)
81124cc8:	00bf410e 	bge	zero,r2,811249d0 <__reset+0xfb1049d0>
81124ccc:	d9c00717 	ldw	r7,28(sp)
81124cd0:	00800c44 	movi	r2,49
81124cd4:	38800005 	stb	r2,0(r7)
81124cd8:	d8800517 	ldw	r2,20(sp)
81124cdc:	3dc00044 	addi	r23,r7,1
81124ce0:	10800044 	addi	r2,r2,1
81124ce4:	d8800515 	stw	r2,20(sp)
81124ce8:	003f3d06 	br	811249e0 <__reset+0xfb1049e0>
81124cec:	d9800517 	ldw	r6,20(sp)
81124cf0:	d9c00717 	ldw	r7,28(sp)
81124cf4:	00800c44 	movi	r2,49
81124cf8:	31800044 	addi	r6,r6,1
81124cfc:	d9800515 	stw	r6,20(sp)
81124d00:	38800005 	stb	r2,0(r7)
81124d04:	003edf06 	br	81124884 <__reset+0xfb104884>
81124d08:	d8000b15 	stw	zero,44(sp)
81124d0c:	003c9f06 	br	81123f8c <__reset+0xfb103f8c>
81124d10:	903e7e1e 	bne	r18,zero,8112470c <__reset+0xfb10470c>
81124d14:	00800434 	movhi	r2,16
81124d18:	10bfffc4 	addi	r2,r2,-1
81124d1c:	9884703a 	and	r2,r19,r2
81124d20:	1000ea1e 	bne	r2,zero,811250cc <_dtoa_r+0x1468>
81124d24:	9cdffc2c 	andhi	r19,r19,32752
81124d28:	9800e826 	beq	r19,zero,811250cc <_dtoa_r+0x1468>
81124d2c:	d9c00817 	ldw	r7,32(sp)
81124d30:	b5800044 	addi	r22,r22,1
81124d34:	04c00044 	movi	r19,1
81124d38:	39c00044 	addi	r7,r7,1
81124d3c:	d9c00815 	stw	r7,32(sp)
81124d40:	d8800d17 	ldw	r2,52(sp)
81124d44:	103e721e 	bne	r2,zero,81124710 <__reset+0xfb104710>
81124d48:	00800044 	movi	r2,1
81124d4c:	003e7906 	br	81124734 <__reset+0xfb104734>
81124d50:	8009883a 	mov	r4,r16
81124d54:	113116c0 	call	8113116c <__floatsidf>
81124d58:	d9800f17 	ldw	r6,60(sp)
81124d5c:	d9c01017 	ldw	r7,64(sp)
81124d60:	1009883a 	mov	r4,r2
81124d64:	180b883a 	mov	r5,r3
81124d68:	111aefc0 	call	8111aefc <__muldf3>
81124d6c:	000d883a 	mov	r6,zero
81124d70:	01d00734 	movhi	r7,16412
81124d74:	1009883a 	mov	r4,r2
81124d78:	180b883a 	mov	r5,r3
81124d7c:	112f3ec0 	call	8112f3ec <__adddf3>
81124d80:	047f3034 	movhi	r17,64704
81124d84:	1021883a 	mov	r16,r2
81124d88:	1c63883a 	add	r17,r3,r17
81124d8c:	d9000f17 	ldw	r4,60(sp)
81124d90:	d9401017 	ldw	r5,64(sp)
81124d94:	000d883a 	mov	r6,zero
81124d98:	01d00534 	movhi	r7,16404
81124d9c:	11307e80 	call	811307e8 <__subdf3>
81124da0:	800d883a 	mov	r6,r16
81124da4:	880f883a 	mov	r7,r17
81124da8:	1009883a 	mov	r4,r2
81124dac:	180b883a 	mov	r5,r3
81124db0:	102b883a 	mov	r21,r2
81124db4:	1829883a 	mov	r20,r3
81124db8:	11306180 	call	81130618 <__gedf2>
81124dbc:	00806c16 	blt	zero,r2,81124f70 <_dtoa_r+0x130c>
81124dc0:	89e0003c 	xorhi	r7,r17,32768
81124dc4:	800d883a 	mov	r6,r16
81124dc8:	a809883a 	mov	r4,r21
81124dcc:	a00b883a 	mov	r5,r20
81124dd0:	11306f40 	call	811306f4 <__ledf2>
81124dd4:	103d7e0e 	bge	r2,zero,811243d0 <__reset+0xfb1043d0>
81124dd8:	002b883a 	mov	r21,zero
81124ddc:	0023883a 	mov	r17,zero
81124de0:	003efb06 	br	811249d0 <__reset+0xfb1049d0>
81124de4:	d8800717 	ldw	r2,28(sp)
81124de8:	003bd006 	br	81123d2c <__reset+0xfb103d2c>
81124dec:	d9000a17 	ldw	r4,40(sp)
81124df0:	d9800d17 	ldw	r6,52(sp)
81124df4:	dd400a15 	stw	r21,40(sp)
81124df8:	a905c83a 	sub	r2,r21,r4
81124dfc:	308d883a 	add	r6,r6,r2
81124e00:	d9800d15 	stw	r6,52(sp)
81124e04:	002b883a 	mov	r21,zero
81124e08:	003e0606 	br	81124624 <__reset+0xfb104624>
81124e0c:	9023883a 	mov	r17,r18
81124e10:	9829883a 	mov	r20,r19
81124e14:	04000084 	movi	r16,2
81124e18:	003c9206 	br	81124064 <__reset+0xfb104064>
81124e1c:	04000044 	movi	r16,1
81124e20:	dc000c15 	stw	r16,48(sp)
81124e24:	dc000615 	stw	r16,24(sp)
81124e28:	dc002215 	stw	r16,136(sp)
81124e2c:	e0001115 	stw	zero,68(fp)
81124e30:	000b883a 	mov	r5,zero
81124e34:	003c6906 	br	81123fdc <__reset+0xfb103fdc>
81124e38:	3021883a 	mov	r16,r6
81124e3c:	003ffb06 	br	81124e2c <__reset+0xfb104e2c>
81124e40:	1000021e 	bne	r2,zero,81124e4c <_dtoa_r+0x11e8>
81124e44:	4200004c 	andi	r8,r8,1
81124e48:	403e7d1e 	bne	r8,zero,81124840 <__reset+0xfb104840>
81124e4c:	01000c04 	movi	r4,48
81124e50:	00000106 	br	81124e58 <_dtoa_r+0x11f4>
81124e54:	102f883a 	mov	r23,r2
81124e58:	b8bfffc4 	addi	r2,r23,-1
81124e5c:	10c00007 	ldb	r3,0(r2)
81124e60:	193ffc26 	beq	r3,r4,81124e54 <__reset+0xfb104e54>
81124e64:	003e8706 	br	81124884 <__reset+0xfb104884>
81124e68:	d8800517 	ldw	r2,20(sp)
81124e6c:	00a3c83a 	sub	r17,zero,r2
81124e70:	8800a426 	beq	r17,zero,81125104 <_dtoa_r+0x14a0>
81124e74:	888003cc 	andi	r2,r17,15
81124e78:	100490fa 	slli	r2,r2,3
81124e7c:	00e04574 	movhi	r3,33045
81124e80:	18eb9a04 	addi	r3,r3,-20888
81124e84:	1885883a 	add	r2,r3,r2
81124e88:	11800017 	ldw	r6,0(r2)
81124e8c:	11c00117 	ldw	r7,4(r2)
81124e90:	9009883a 	mov	r4,r18
81124e94:	980b883a 	mov	r5,r19
81124e98:	8823d13a 	srai	r17,r17,4
81124e9c:	111aefc0 	call	8111aefc <__muldf3>
81124ea0:	d8800f15 	stw	r2,60(sp)
81124ea4:	d8c01015 	stw	r3,64(sp)
81124ea8:	8800e826 	beq	r17,zero,8112524c <_dtoa_r+0x15e8>
81124eac:	05204574 	movhi	r20,33045
81124eb0:	a52b9004 	addi	r20,r20,-20928
81124eb4:	04000084 	movi	r16,2
81124eb8:	8980004c 	andi	r6,r17,1
81124ebc:	1009883a 	mov	r4,r2
81124ec0:	8823d07a 	srai	r17,r17,1
81124ec4:	180b883a 	mov	r5,r3
81124ec8:	30000426 	beq	r6,zero,81124edc <_dtoa_r+0x1278>
81124ecc:	a1800017 	ldw	r6,0(r20)
81124ed0:	a1c00117 	ldw	r7,4(r20)
81124ed4:	84000044 	addi	r16,r16,1
81124ed8:	111aefc0 	call	8111aefc <__muldf3>
81124edc:	a5000204 	addi	r20,r20,8
81124ee0:	883ff51e 	bne	r17,zero,81124eb8 <__reset+0xfb104eb8>
81124ee4:	d8800f15 	stw	r2,60(sp)
81124ee8:	d8c01015 	stw	r3,64(sp)
81124eec:	003c7606 	br	811240c8 <__reset+0xfb1040c8>
81124ef0:	00c00c04 	movi	r3,48
81124ef4:	10c00005 	stb	r3,0(r2)
81124ef8:	d8c00517 	ldw	r3,20(sp)
81124efc:	bd3fffc3 	ldbu	r20,-1(r23)
81124f00:	18c00044 	addi	r3,r3,1
81124f04:	d8c00515 	stw	r3,20(sp)
81124f08:	003db906 	br	811245f0 <__reset+0xfb1045f0>
81124f0c:	89400117 	ldw	r5,4(r17)
81124f10:	e009883a 	mov	r4,fp
81124f14:	1126d7c0 	call	81126d7c <_Balloc>
81124f18:	89800417 	ldw	r6,16(r17)
81124f1c:	89400304 	addi	r5,r17,12
81124f20:	11000304 	addi	r4,r2,12
81124f24:	31800084 	addi	r6,r6,2
81124f28:	318d883a 	add	r6,r6,r6
81124f2c:	318d883a 	add	r6,r6,r6
81124f30:	1027883a 	mov	r19,r2
81124f34:	111cb4c0 	call	8111cb4c <memcpy>
81124f38:	01800044 	movi	r6,1
81124f3c:	980b883a 	mov	r5,r19
81124f40:	e009883a 	mov	r4,fp
81124f44:	112752c0 	call	8112752c <__lshift>
81124f48:	1029883a 	mov	r20,r2
81124f4c:	003ecc06 	br	81124a80 <__reset+0xfb104a80>
81124f50:	00800e44 	movi	r2,57
81124f54:	90809026 	beq	r18,r2,81125198 <_dtoa_r+0x1534>
81124f58:	92000044 	addi	r8,r18,1
81124f5c:	003f1f06 	br	81124bdc <__reset+0xfb104bdc>
81124f60:	9011883a 	mov	r8,r18
81124f64:	8825883a 	mov	r18,r17
81124f68:	a023883a 	mov	r17,r20
81124f6c:	003e2906 	br	81124814 <__reset+0xfb104814>
81124f70:	002b883a 	mov	r21,zero
81124f74:	0023883a 	mov	r17,zero
81124f78:	003f5406 	br	81124ccc <__reset+0xfb104ccc>
81124f7c:	61bfffc4 	addi	r6,r12,-1
81124f80:	300490fa 	slli	r2,r6,3
81124f84:	00e04574 	movhi	r3,33045
81124f88:	18eb9a04 	addi	r3,r3,-20888
81124f8c:	1885883a 	add	r2,r3,r2
81124f90:	11000017 	ldw	r4,0(r2)
81124f94:	11400117 	ldw	r5,4(r2)
81124f98:	d8800717 	ldw	r2,28(sp)
81124f9c:	880f883a 	mov	r7,r17
81124fa0:	d9801215 	stw	r6,72(sp)
81124fa4:	800d883a 	mov	r6,r16
81124fa8:	db001615 	stw	r12,88(sp)
81124fac:	15c00044 	addi	r23,r2,1
81124fb0:	111aefc0 	call	8111aefc <__muldf3>
81124fb4:	d9401017 	ldw	r5,64(sp)
81124fb8:	d9000f17 	ldw	r4,60(sp)
81124fbc:	d8c01515 	stw	r3,84(sp)
81124fc0:	d8801415 	stw	r2,80(sp)
81124fc4:	11310ec0 	call	811310ec <__fixdfsi>
81124fc8:	1009883a 	mov	r4,r2
81124fcc:	1021883a 	mov	r16,r2
81124fd0:	113116c0 	call	8113116c <__floatsidf>
81124fd4:	d9000f17 	ldw	r4,60(sp)
81124fd8:	d9401017 	ldw	r5,64(sp)
81124fdc:	100d883a 	mov	r6,r2
81124fe0:	180f883a 	mov	r7,r3
81124fe4:	11307e80 	call	811307e8 <__subdf3>
81124fe8:	1829883a 	mov	r20,r3
81124fec:	d8c00717 	ldw	r3,28(sp)
81124ff0:	84000c04 	addi	r16,r16,48
81124ff4:	1023883a 	mov	r17,r2
81124ff8:	1c000005 	stb	r16,0(r3)
81124ffc:	db001617 	ldw	r12,88(sp)
81125000:	00800044 	movi	r2,1
81125004:	60802226 	beq	r12,r2,81125090 <_dtoa_r+0x142c>
81125008:	d9c00717 	ldw	r7,28(sp)
8112500c:	8805883a 	mov	r2,r17
81125010:	b82b883a 	mov	r21,r23
81125014:	3b19883a 	add	r12,r7,r12
81125018:	6023883a 	mov	r17,r12
8112501c:	a007883a 	mov	r3,r20
81125020:	dc800f15 	stw	r18,60(sp)
81125024:	000d883a 	mov	r6,zero
81125028:	01d00934 	movhi	r7,16420
8112502c:	1009883a 	mov	r4,r2
81125030:	180b883a 	mov	r5,r3
81125034:	111aefc0 	call	8111aefc <__muldf3>
81125038:	180b883a 	mov	r5,r3
8112503c:	1009883a 	mov	r4,r2
81125040:	1829883a 	mov	r20,r3
81125044:	1025883a 	mov	r18,r2
81125048:	11310ec0 	call	811310ec <__fixdfsi>
8112504c:	1009883a 	mov	r4,r2
81125050:	1021883a 	mov	r16,r2
81125054:	113116c0 	call	8113116c <__floatsidf>
81125058:	100d883a 	mov	r6,r2
8112505c:	180f883a 	mov	r7,r3
81125060:	9009883a 	mov	r4,r18
81125064:	a00b883a 	mov	r5,r20
81125068:	84000c04 	addi	r16,r16,48
8112506c:	11307e80 	call	811307e8 <__subdf3>
81125070:	ad400044 	addi	r21,r21,1
81125074:	ac3fffc5 	stb	r16,-1(r21)
81125078:	ac7fea1e 	bne	r21,r17,81125024 <__reset+0xfb105024>
8112507c:	1023883a 	mov	r17,r2
81125080:	d8801217 	ldw	r2,72(sp)
81125084:	dc800f17 	ldw	r18,60(sp)
81125088:	1829883a 	mov	r20,r3
8112508c:	b8af883a 	add	r23,r23,r2
81125090:	d9001417 	ldw	r4,80(sp)
81125094:	d9401517 	ldw	r5,84(sp)
81125098:	000d883a 	mov	r6,zero
8112509c:	01cff834 	movhi	r7,16352
811250a0:	112f3ec0 	call	8112f3ec <__adddf3>
811250a4:	880d883a 	mov	r6,r17
811250a8:	a00f883a 	mov	r7,r20
811250ac:	1009883a 	mov	r4,r2
811250b0:	180b883a 	mov	r5,r3
811250b4:	11306f40 	call	811306f4 <__ledf2>
811250b8:	10003e0e 	bge	r2,zero,811251b4 <_dtoa_r+0x1550>
811250bc:	d9001317 	ldw	r4,76(sp)
811250c0:	bd3fffc3 	ldbu	r20,-1(r23)
811250c4:	d9000515 	stw	r4,20(sp)
811250c8:	003d3b06 	br	811245b8 <__reset+0xfb1045b8>
811250cc:	0027883a 	mov	r19,zero
811250d0:	003f1b06 	br	81124d40 <__reset+0xfb104d40>
811250d4:	d8800817 	ldw	r2,32(sp)
811250d8:	11e9c83a 	sub	r20,r2,r7
811250dc:	0005883a 	mov	r2,zero
811250e0:	003d5406 	br	81124634 <__reset+0xfb104634>
811250e4:	00800044 	movi	r2,1
811250e8:	003dc706 	br	81124808 <__reset+0xfb104808>
811250ec:	d8c00217 	ldw	r3,8(sp)
811250f0:	00800d84 	movi	r2,54
811250f4:	dd400a17 	ldw	r21,40(sp)
811250f8:	10c5c83a 	sub	r2,r2,r3
811250fc:	dd000817 	ldw	r20,32(sp)
81125100:	003d4c06 	br	81124634 <__reset+0xfb104634>
81125104:	dc800f15 	stw	r18,60(sp)
81125108:	dcc01015 	stw	r19,64(sp)
8112510c:	04000084 	movi	r16,2
81125110:	003bed06 	br	811240c8 <__reset+0xfb1040c8>
81125114:	d9000617 	ldw	r4,24(sp)
81125118:	203f0d26 	beq	r4,zero,81124d50 <__reset+0xfb104d50>
8112511c:	d9800c17 	ldw	r6,48(sp)
81125120:	01bcab0e 	bge	zero,r6,811243d0 <__reset+0xfb1043d0>
81125124:	d9401017 	ldw	r5,64(sp)
81125128:	d9000f17 	ldw	r4,60(sp)
8112512c:	000d883a 	mov	r6,zero
81125130:	01d00934 	movhi	r7,16420
81125134:	111aefc0 	call	8111aefc <__muldf3>
81125138:	81000044 	addi	r4,r16,1
8112513c:	d8800f15 	stw	r2,60(sp)
81125140:	d8c01015 	stw	r3,64(sp)
81125144:	113116c0 	call	8113116c <__floatsidf>
81125148:	d9800f17 	ldw	r6,60(sp)
8112514c:	d9c01017 	ldw	r7,64(sp)
81125150:	1009883a 	mov	r4,r2
81125154:	180b883a 	mov	r5,r3
81125158:	111aefc0 	call	8111aefc <__muldf3>
8112515c:	01d00734 	movhi	r7,16412
81125160:	000d883a 	mov	r6,zero
81125164:	1009883a 	mov	r4,r2
81125168:	180b883a 	mov	r5,r3
8112516c:	112f3ec0 	call	8112f3ec <__adddf3>
81125170:	d9c00517 	ldw	r7,20(sp)
81125174:	047f3034 	movhi	r17,64704
81125178:	1021883a 	mov	r16,r2
8112517c:	39ffffc4 	addi	r7,r7,-1
81125180:	d9c01315 	stw	r7,76(sp)
81125184:	1c63883a 	add	r17,r3,r17
81125188:	db000c17 	ldw	r12,48(sp)
8112518c:	003bea06 	br	81124138 <__reset+0xfb104138>
81125190:	dc000915 	stw	r16,36(sp)
81125194:	003e0e06 	br	811249d0 <__reset+0xfb1049d0>
81125198:	01000e44 	movi	r4,57
8112519c:	8825883a 	mov	r18,r17
811251a0:	9dc00044 	addi	r23,r19,1
811251a4:	99000005 	stb	r4,0(r19)
811251a8:	a023883a 	mov	r17,r20
811251ac:	dc000915 	stw	r16,36(sp)
811251b0:	003da406 	br	81124844 <__reset+0xfb104844>
811251b4:	d9801417 	ldw	r6,80(sp)
811251b8:	d9c01517 	ldw	r7,84(sp)
811251bc:	0009883a 	mov	r4,zero
811251c0:	014ff834 	movhi	r5,16352
811251c4:	11307e80 	call	811307e8 <__subdf3>
811251c8:	880d883a 	mov	r6,r17
811251cc:	a00f883a 	mov	r7,r20
811251d0:	1009883a 	mov	r4,r2
811251d4:	180b883a 	mov	r5,r3
811251d8:	11306180 	call	81130618 <__gedf2>
811251dc:	00bc7c0e 	bge	zero,r2,811243d0 <__reset+0xfb1043d0>
811251e0:	01000c04 	movi	r4,48
811251e4:	00000106 	br	811251ec <_dtoa_r+0x1588>
811251e8:	102f883a 	mov	r23,r2
811251ec:	b8bfffc4 	addi	r2,r23,-1
811251f0:	10c00007 	ldb	r3,0(r2)
811251f4:	193ffc26 	beq	r3,r4,811251e8 <__reset+0xfb1051e8>
811251f8:	d9801317 	ldw	r6,76(sp)
811251fc:	d9800515 	stw	r6,20(sp)
81125200:	003c4406 	br	81124314 <__reset+0xfb104314>
81125204:	d9801317 	ldw	r6,76(sp)
81125208:	d9800515 	stw	r6,20(sp)
8112520c:	003cea06 	br	811245b8 <__reset+0xfb1045b8>
81125210:	dd800f17 	ldw	r22,60(sp)
81125214:	dcc01017 	ldw	r19,64(sp)
81125218:	dc801217 	ldw	r18,72(sp)
8112521c:	003c6c06 	br	811243d0 <__reset+0xfb1043d0>
81125220:	903e031e 	bne	r18,zero,81124a30 <__reset+0xfb104a30>
81125224:	003ebb06 	br	81124d14 <__reset+0xfb104d14>
81125228:	103e6c1e 	bne	r2,zero,81124bdc <__reset+0xfb104bdc>
8112522c:	4080004c 	andi	r2,r8,1
81125230:	103e6a26 	beq	r2,zero,81124bdc <__reset+0xfb104bdc>
81125234:	003e6606 	br	81124bd0 <__reset+0xfb104bd0>
81125238:	d8c00317 	ldw	r3,12(sp)
8112523c:	00800084 	movi	r2,2
81125240:	10c02916 	blt	r2,r3,811252e8 <_dtoa_r+0x1684>
81125244:	d9000c17 	ldw	r4,48(sp)
81125248:	003e8806 	br	81124c6c <__reset+0xfb104c6c>
8112524c:	04000084 	movi	r16,2
81125250:	003b9d06 	br	811240c8 <__reset+0xfb1040c8>
81125254:	d9001317 	ldw	r4,76(sp)
81125258:	d9000515 	stw	r4,20(sp)
8112525c:	003cd606 	br	811245b8 <__reset+0xfb1045b8>
81125260:	d8801317 	ldw	r2,76(sp)
81125264:	d8800515 	stw	r2,20(sp)
81125268:	003c2a06 	br	81124314 <__reset+0xfb104314>
8112526c:	d9800317 	ldw	r6,12(sp)
81125270:	00800084 	movi	r2,2
81125274:	11801516 	blt	r2,r6,811252cc <_dtoa_r+0x1668>
81125278:	d9c00c17 	ldw	r7,48(sp)
8112527c:	d9c00615 	stw	r7,24(sp)
81125280:	003df706 	br	81124a60 <__reset+0xfb104a60>
81125284:	193d3926 	beq	r3,r4,8112476c <__reset+0xfb10476c>
81125288:	00c00f04 	movi	r3,60
8112528c:	1885c83a 	sub	r2,r3,r2
81125290:	003ddf06 	br	81124a10 <__reset+0xfb104a10>
81125294:	e009883a 	mov	r4,fp
81125298:	e0001115 	stw	zero,68(fp)
8112529c:	000b883a 	mov	r5,zero
811252a0:	1126d7c0 	call	81126d7c <_Balloc>
811252a4:	d8800715 	stw	r2,28(sp)
811252a8:	d8c00717 	ldw	r3,28(sp)
811252ac:	00bfffc4 	movi	r2,-1
811252b0:	01000044 	movi	r4,1
811252b4:	d8800c15 	stw	r2,48(sp)
811252b8:	e0c01015 	stw	r3,64(fp)
811252bc:	d9000b15 	stw	r4,44(sp)
811252c0:	d8800615 	stw	r2,24(sp)
811252c4:	d8002215 	stw	zero,136(sp)
811252c8:	003c4106 	br	811243d0 <__reset+0xfb1043d0>
811252cc:	d8c00c17 	ldw	r3,48(sp)
811252d0:	d8c00615 	stw	r3,24(sp)
811252d4:	003e7006 	br	81124c98 <__reset+0xfb104c98>
811252d8:	04400044 	movi	r17,1
811252dc:	003b2006 	br	81123f60 <__reset+0xfb103f60>
811252e0:	000b883a 	mov	r5,zero
811252e4:	003b3d06 	br	81123fdc <__reset+0xfb103fdc>
811252e8:	d8800c17 	ldw	r2,48(sp)
811252ec:	d8800615 	stw	r2,24(sp)
811252f0:	003e6906 	br	81124c98 <__reset+0xfb104c98>

811252f4 <__sflush_r>:
811252f4:	defffb04 	addi	sp,sp,-20
811252f8:	de00012e 	bgeu	sp,et,81125300 <__sflush_r+0xc>
811252fc:	003b68fa 	trap	3
81125300:	2880030b 	ldhu	r2,12(r5)
81125304:	dcc00315 	stw	r19,12(sp)
81125308:	dc400115 	stw	r17,4(sp)
8112530c:	dfc00415 	stw	ra,16(sp)
81125310:	dc800215 	stw	r18,8(sp)
81125314:	dc000015 	stw	r16,0(sp)
81125318:	10c0020c 	andi	r3,r2,8
8112531c:	2823883a 	mov	r17,r5
81125320:	2027883a 	mov	r19,r4
81125324:	1800311e 	bne	r3,zero,811253ec <__sflush_r+0xf8>
81125328:	28c00117 	ldw	r3,4(r5)
8112532c:	10820014 	ori	r2,r2,2048
81125330:	2880030d 	sth	r2,12(r5)
81125334:	00c04b0e 	bge	zero,r3,81125464 <__sflush_r+0x170>
81125338:	8a000a17 	ldw	r8,40(r17)
8112533c:	40002326 	beq	r8,zero,811253cc <__sflush_r+0xd8>
81125340:	9c000017 	ldw	r16,0(r19)
81125344:	10c4000c 	andi	r3,r2,4096
81125348:	98000015 	stw	zero,0(r19)
8112534c:	18004826 	beq	r3,zero,81125470 <__sflush_r+0x17c>
81125350:	89801417 	ldw	r6,80(r17)
81125354:	10c0010c 	andi	r3,r2,4
81125358:	18000626 	beq	r3,zero,81125374 <__sflush_r+0x80>
8112535c:	88c00117 	ldw	r3,4(r17)
81125360:	88800c17 	ldw	r2,48(r17)
81125364:	30cdc83a 	sub	r6,r6,r3
81125368:	10000226 	beq	r2,zero,81125374 <__sflush_r+0x80>
8112536c:	88800f17 	ldw	r2,60(r17)
81125370:	308dc83a 	sub	r6,r6,r2
81125374:	89400717 	ldw	r5,28(r17)
81125378:	000f883a 	mov	r7,zero
8112537c:	9809883a 	mov	r4,r19
81125380:	403ee83a 	callr	r8
81125384:	00ffffc4 	movi	r3,-1
81125388:	10c04426 	beq	r2,r3,8112549c <__sflush_r+0x1a8>
8112538c:	88c0030b 	ldhu	r3,12(r17)
81125390:	89000417 	ldw	r4,16(r17)
81125394:	88000115 	stw	zero,4(r17)
81125398:	197dffcc 	andi	r5,r3,63487
8112539c:	8940030d 	sth	r5,12(r17)
811253a0:	89000015 	stw	r4,0(r17)
811253a4:	18c4000c 	andi	r3,r3,4096
811253a8:	18002c1e 	bne	r3,zero,8112545c <__sflush_r+0x168>
811253ac:	89400c17 	ldw	r5,48(r17)
811253b0:	9c000015 	stw	r16,0(r19)
811253b4:	28000526 	beq	r5,zero,811253cc <__sflush_r+0xd8>
811253b8:	88801004 	addi	r2,r17,64
811253bc:	28800226 	beq	r5,r2,811253c8 <__sflush_r+0xd4>
811253c0:	9809883a 	mov	r4,r19
811253c4:	1125dac0 	call	81125dac <_free_r>
811253c8:	88000c15 	stw	zero,48(r17)
811253cc:	0005883a 	mov	r2,zero
811253d0:	dfc00417 	ldw	ra,16(sp)
811253d4:	dcc00317 	ldw	r19,12(sp)
811253d8:	dc800217 	ldw	r18,8(sp)
811253dc:	dc400117 	ldw	r17,4(sp)
811253e0:	dc000017 	ldw	r16,0(sp)
811253e4:	dec00504 	addi	sp,sp,20
811253e8:	f800283a 	ret
811253ec:	2c800417 	ldw	r18,16(r5)
811253f0:	903ff626 	beq	r18,zero,811253cc <__reset+0xfb1053cc>
811253f4:	2c000017 	ldw	r16,0(r5)
811253f8:	108000cc 	andi	r2,r2,3
811253fc:	2c800015 	stw	r18,0(r5)
81125400:	84a1c83a 	sub	r16,r16,r18
81125404:	1000131e 	bne	r2,zero,81125454 <__sflush_r+0x160>
81125408:	28800517 	ldw	r2,20(r5)
8112540c:	88800215 	stw	r2,8(r17)
81125410:	04000316 	blt	zero,r16,81125420 <__sflush_r+0x12c>
81125414:	003fed06 	br	811253cc <__reset+0xfb1053cc>
81125418:	90a5883a 	add	r18,r18,r2
8112541c:	043feb0e 	bge	zero,r16,811253cc <__reset+0xfb1053cc>
81125420:	88800917 	ldw	r2,36(r17)
81125424:	89400717 	ldw	r5,28(r17)
81125428:	800f883a 	mov	r7,r16
8112542c:	900d883a 	mov	r6,r18
81125430:	9809883a 	mov	r4,r19
81125434:	103ee83a 	callr	r2
81125438:	80a1c83a 	sub	r16,r16,r2
8112543c:	00bff616 	blt	zero,r2,81125418 <__reset+0xfb105418>
81125440:	88c0030b 	ldhu	r3,12(r17)
81125444:	00bfffc4 	movi	r2,-1
81125448:	18c01014 	ori	r3,r3,64
8112544c:	88c0030d 	sth	r3,12(r17)
81125450:	003fdf06 	br	811253d0 <__reset+0xfb1053d0>
81125454:	0005883a 	mov	r2,zero
81125458:	003fec06 	br	8112540c <__reset+0xfb10540c>
8112545c:	88801415 	stw	r2,80(r17)
81125460:	003fd206 	br	811253ac <__reset+0xfb1053ac>
81125464:	28c00f17 	ldw	r3,60(r5)
81125468:	00ffb316 	blt	zero,r3,81125338 <__reset+0xfb105338>
8112546c:	003fd706 	br	811253cc <__reset+0xfb1053cc>
81125470:	89400717 	ldw	r5,28(r17)
81125474:	000d883a 	mov	r6,zero
81125478:	01c00044 	movi	r7,1
8112547c:	9809883a 	mov	r4,r19
81125480:	403ee83a 	callr	r8
81125484:	100d883a 	mov	r6,r2
81125488:	00bfffc4 	movi	r2,-1
8112548c:	30801426 	beq	r6,r2,811254e0 <__sflush_r+0x1ec>
81125490:	8880030b 	ldhu	r2,12(r17)
81125494:	8a000a17 	ldw	r8,40(r17)
81125498:	003fae06 	br	81125354 <__reset+0xfb105354>
8112549c:	98c00017 	ldw	r3,0(r19)
811254a0:	183fba26 	beq	r3,zero,8112538c <__reset+0xfb10538c>
811254a4:	01000744 	movi	r4,29
811254a8:	19000626 	beq	r3,r4,811254c4 <__sflush_r+0x1d0>
811254ac:	01000584 	movi	r4,22
811254b0:	19000426 	beq	r3,r4,811254c4 <__sflush_r+0x1d0>
811254b4:	88c0030b 	ldhu	r3,12(r17)
811254b8:	18c01014 	ori	r3,r3,64
811254bc:	88c0030d 	sth	r3,12(r17)
811254c0:	003fc306 	br	811253d0 <__reset+0xfb1053d0>
811254c4:	8880030b 	ldhu	r2,12(r17)
811254c8:	88c00417 	ldw	r3,16(r17)
811254cc:	88000115 	stw	zero,4(r17)
811254d0:	10bdffcc 	andi	r2,r2,63487
811254d4:	8880030d 	sth	r2,12(r17)
811254d8:	88c00015 	stw	r3,0(r17)
811254dc:	003fb306 	br	811253ac <__reset+0xfb1053ac>
811254e0:	98800017 	ldw	r2,0(r19)
811254e4:	103fea26 	beq	r2,zero,81125490 <__reset+0xfb105490>
811254e8:	00c00744 	movi	r3,29
811254ec:	10c00226 	beq	r2,r3,811254f8 <__sflush_r+0x204>
811254f0:	00c00584 	movi	r3,22
811254f4:	10c0031e 	bne	r2,r3,81125504 <__sflush_r+0x210>
811254f8:	9c000015 	stw	r16,0(r19)
811254fc:	0005883a 	mov	r2,zero
81125500:	003fb306 	br	811253d0 <__reset+0xfb1053d0>
81125504:	88c0030b 	ldhu	r3,12(r17)
81125508:	3005883a 	mov	r2,r6
8112550c:	18c01014 	ori	r3,r3,64
81125510:	88c0030d 	sth	r3,12(r17)
81125514:	003fae06 	br	811253d0 <__reset+0xfb1053d0>

81125518 <_fflush_r>:
81125518:	defffd04 	addi	sp,sp,-12
8112551c:	de00012e 	bgeu	sp,et,81125524 <_fflush_r+0xc>
81125520:	003b68fa 	trap	3
81125524:	dc000115 	stw	r16,4(sp)
81125528:	dfc00215 	stw	ra,8(sp)
8112552c:	2021883a 	mov	r16,r4
81125530:	20000226 	beq	r4,zero,8112553c <_fflush_r+0x24>
81125534:	20800e17 	ldw	r2,56(r4)
81125538:	10000c26 	beq	r2,zero,8112556c <_fflush_r+0x54>
8112553c:	2880030f 	ldh	r2,12(r5)
81125540:	1000051e 	bne	r2,zero,81125558 <_fflush_r+0x40>
81125544:	0005883a 	mov	r2,zero
81125548:	dfc00217 	ldw	ra,8(sp)
8112554c:	dc000117 	ldw	r16,4(sp)
81125550:	dec00304 	addi	sp,sp,12
81125554:	f800283a 	ret
81125558:	8009883a 	mov	r4,r16
8112555c:	dfc00217 	ldw	ra,8(sp)
81125560:	dc000117 	ldw	r16,4(sp)
81125564:	dec00304 	addi	sp,sp,12
81125568:	11252f41 	jmpi	811252f4 <__sflush_r>
8112556c:	d9400015 	stw	r5,0(sp)
81125570:	11259140 	call	81125914 <__sinit>
81125574:	d9400017 	ldw	r5,0(sp)
81125578:	003ff006 	br	8112553c <__reset+0xfb10553c>

8112557c <fflush>:
8112557c:	20000526 	beq	r4,zero,81125594 <fflush+0x18>
81125580:	00a04574 	movhi	r2,33045
81125584:	10b52904 	addi	r2,r2,-11100
81125588:	200b883a 	mov	r5,r4
8112558c:	11000017 	ldw	r4,0(r2)
81125590:	11255181 	jmpi	81125518 <_fflush_r>
81125594:	00a04574 	movhi	r2,33045
81125598:	10b52804 	addi	r2,r2,-11104
8112559c:	11000017 	ldw	r4,0(r2)
811255a0:	016044b4 	movhi	r5,33042
811255a4:	29554604 	addi	r5,r5,21784
811255a8:	11266541 	jmpi	81126654 <_fwalk_reent>

811255ac <__fp_unlock>:
811255ac:	0005883a 	mov	r2,zero
811255b0:	f800283a 	ret

811255b4 <_cleanup_r>:
811255b4:	016044f4 	movhi	r5,33043
811255b8:	2974dc04 	addi	r5,r5,-11408
811255bc:	11266541 	jmpi	81126654 <_fwalk_reent>

811255c0 <__sinit.part.1>:
811255c0:	defff704 	addi	sp,sp,-36
811255c4:	00e044b4 	movhi	r3,33042
811255c8:	de00012e 	bgeu	sp,et,811255d0 <__sinit.part.1+0x10>
811255cc:	003b68fa 	trap	3
811255d0:	18d56d04 	addi	r3,r3,21940
811255d4:	dfc00815 	stw	ra,32(sp)
811255d8:	ddc00715 	stw	r23,28(sp)
811255dc:	dd800615 	stw	r22,24(sp)
811255e0:	dd400515 	stw	r21,20(sp)
811255e4:	dd000415 	stw	r20,16(sp)
811255e8:	dcc00315 	stw	r19,12(sp)
811255ec:	dc800215 	stw	r18,8(sp)
811255f0:	dc400115 	stw	r17,4(sp)
811255f4:	dc000015 	stw	r16,0(sp)
811255f8:	24000117 	ldw	r16,4(r4)
811255fc:	20c00f15 	stw	r3,60(r4)
81125600:	2080bb04 	addi	r2,r4,748
81125604:	00c000c4 	movi	r3,3
81125608:	20c0b915 	stw	r3,740(r4)
8112560c:	2080ba15 	stw	r2,744(r4)
81125610:	2000b815 	stw	zero,736(r4)
81125614:	05c00204 	movi	r23,8
81125618:	00800104 	movi	r2,4
8112561c:	2025883a 	mov	r18,r4
81125620:	b80d883a 	mov	r6,r23
81125624:	81001704 	addi	r4,r16,92
81125628:	000b883a 	mov	r5,zero
8112562c:	80000015 	stw	zero,0(r16)
81125630:	80000115 	stw	zero,4(r16)
81125634:	80000215 	stw	zero,8(r16)
81125638:	8080030d 	sth	r2,12(r16)
8112563c:	80001915 	stw	zero,100(r16)
81125640:	8000038d 	sth	zero,14(r16)
81125644:	80000415 	stw	zero,16(r16)
81125648:	80000515 	stw	zero,20(r16)
8112564c:	80000615 	stw	zero,24(r16)
81125650:	111cc9c0 	call	8111cc9c <memset>
81125654:	05a044b4 	movhi	r22,33042
81125658:	94400217 	ldw	r17,8(r18)
8112565c:	056044b4 	movhi	r21,33042
81125660:	052044b4 	movhi	r20,33042
81125664:	04e044b4 	movhi	r19,33042
81125668:	b5b52804 	addi	r22,r22,-11104
8112566c:	ad754104 	addi	r21,r21,-11004
81125670:	a5356204 	addi	r20,r20,-10872
81125674:	9cf57b04 	addi	r19,r19,-10772
81125678:	85800815 	stw	r22,32(r16)
8112567c:	85400915 	stw	r21,36(r16)
81125680:	85000a15 	stw	r20,40(r16)
81125684:	84c00b15 	stw	r19,44(r16)
81125688:	84000715 	stw	r16,28(r16)
8112568c:	00800284 	movi	r2,10
81125690:	8880030d 	sth	r2,12(r17)
81125694:	00800044 	movi	r2,1
81125698:	b80d883a 	mov	r6,r23
8112569c:	89001704 	addi	r4,r17,92
811256a0:	000b883a 	mov	r5,zero
811256a4:	88000015 	stw	zero,0(r17)
811256a8:	88000115 	stw	zero,4(r17)
811256ac:	88000215 	stw	zero,8(r17)
811256b0:	88001915 	stw	zero,100(r17)
811256b4:	8880038d 	sth	r2,14(r17)
811256b8:	88000415 	stw	zero,16(r17)
811256bc:	88000515 	stw	zero,20(r17)
811256c0:	88000615 	stw	zero,24(r17)
811256c4:	111cc9c0 	call	8111cc9c <memset>
811256c8:	94000317 	ldw	r16,12(r18)
811256cc:	00800484 	movi	r2,18
811256d0:	8c400715 	stw	r17,28(r17)
811256d4:	8d800815 	stw	r22,32(r17)
811256d8:	8d400915 	stw	r21,36(r17)
811256dc:	8d000a15 	stw	r20,40(r17)
811256e0:	8cc00b15 	stw	r19,44(r17)
811256e4:	8080030d 	sth	r2,12(r16)
811256e8:	00800084 	movi	r2,2
811256ec:	80000015 	stw	zero,0(r16)
811256f0:	80000115 	stw	zero,4(r16)
811256f4:	80000215 	stw	zero,8(r16)
811256f8:	80001915 	stw	zero,100(r16)
811256fc:	8080038d 	sth	r2,14(r16)
81125700:	80000415 	stw	zero,16(r16)
81125704:	80000515 	stw	zero,20(r16)
81125708:	80000615 	stw	zero,24(r16)
8112570c:	b80d883a 	mov	r6,r23
81125710:	000b883a 	mov	r5,zero
81125714:	81001704 	addi	r4,r16,92
81125718:	111cc9c0 	call	8111cc9c <memset>
8112571c:	00800044 	movi	r2,1
81125720:	84000715 	stw	r16,28(r16)
81125724:	85800815 	stw	r22,32(r16)
81125728:	85400915 	stw	r21,36(r16)
8112572c:	85000a15 	stw	r20,40(r16)
81125730:	84c00b15 	stw	r19,44(r16)
81125734:	90800e15 	stw	r2,56(r18)
81125738:	dfc00817 	ldw	ra,32(sp)
8112573c:	ddc00717 	ldw	r23,28(sp)
81125740:	dd800617 	ldw	r22,24(sp)
81125744:	dd400517 	ldw	r21,20(sp)
81125748:	dd000417 	ldw	r20,16(sp)
8112574c:	dcc00317 	ldw	r19,12(sp)
81125750:	dc800217 	ldw	r18,8(sp)
81125754:	dc400117 	ldw	r17,4(sp)
81125758:	dc000017 	ldw	r16,0(sp)
8112575c:	dec00904 	addi	sp,sp,36
81125760:	f800283a 	ret

81125764 <__fp_lock>:
81125764:	0005883a 	mov	r2,zero
81125768:	f800283a 	ret

8112576c <__sfmoreglue>:
8112576c:	defffc04 	addi	sp,sp,-16
81125770:	de00012e 	bgeu	sp,et,81125778 <__sfmoreglue+0xc>
81125774:	003b68fa 	trap	3
81125778:	dc400115 	stw	r17,4(sp)
8112577c:	2c7fffc4 	addi	r17,r5,-1
81125780:	8c401a24 	muli	r17,r17,104
81125784:	dc800215 	stw	r18,8(sp)
81125788:	2825883a 	mov	r18,r5
8112578c:	89401d04 	addi	r5,r17,116
81125790:	dc000015 	stw	r16,0(sp)
81125794:	dfc00315 	stw	ra,12(sp)
81125798:	111c3380 	call	8111c338 <_malloc_r>
8112579c:	1021883a 	mov	r16,r2
811257a0:	10000726 	beq	r2,zero,811257c0 <__sfmoreglue+0x54>
811257a4:	11000304 	addi	r4,r2,12
811257a8:	10000015 	stw	zero,0(r2)
811257ac:	14800115 	stw	r18,4(r2)
811257b0:	11000215 	stw	r4,8(r2)
811257b4:	89801a04 	addi	r6,r17,104
811257b8:	000b883a 	mov	r5,zero
811257bc:	111cc9c0 	call	8111cc9c <memset>
811257c0:	8005883a 	mov	r2,r16
811257c4:	dfc00317 	ldw	ra,12(sp)
811257c8:	dc800217 	ldw	r18,8(sp)
811257cc:	dc400117 	ldw	r17,4(sp)
811257d0:	dc000017 	ldw	r16,0(sp)
811257d4:	dec00404 	addi	sp,sp,16
811257d8:	f800283a 	ret

811257dc <__sfp>:
811257dc:	defffb04 	addi	sp,sp,-20
811257e0:	de00012e 	bgeu	sp,et,811257e8 <__sfp+0xc>
811257e4:	003b68fa 	trap	3
811257e8:	dc000015 	stw	r16,0(sp)
811257ec:	04204574 	movhi	r16,33045
811257f0:	84352804 	addi	r16,r16,-11104
811257f4:	dcc00315 	stw	r19,12(sp)
811257f8:	2027883a 	mov	r19,r4
811257fc:	81000017 	ldw	r4,0(r16)
81125800:	dfc00415 	stw	ra,16(sp)
81125804:	dc800215 	stw	r18,8(sp)
81125808:	20800e17 	ldw	r2,56(r4)
8112580c:	dc400115 	stw	r17,4(sp)
81125810:	1000021e 	bne	r2,zero,8112581c <__sfp+0x40>
81125814:	11255c00 	call	811255c0 <__sinit.part.1>
81125818:	81000017 	ldw	r4,0(r16)
8112581c:	2480b804 	addi	r18,r4,736
81125820:	047fffc4 	movi	r17,-1
81125824:	91000117 	ldw	r4,4(r18)
81125828:	94000217 	ldw	r16,8(r18)
8112582c:	213fffc4 	addi	r4,r4,-1
81125830:	20000a16 	blt	r4,zero,8112585c <__sfp+0x80>
81125834:	8080030f 	ldh	r2,12(r16)
81125838:	10000c26 	beq	r2,zero,8112586c <__sfp+0x90>
8112583c:	80c01d04 	addi	r3,r16,116
81125840:	00000206 	br	8112584c <__sfp+0x70>
81125844:	18bfe60f 	ldh	r2,-104(r3)
81125848:	10000826 	beq	r2,zero,8112586c <__sfp+0x90>
8112584c:	213fffc4 	addi	r4,r4,-1
81125850:	1c3ffd04 	addi	r16,r3,-12
81125854:	18c01a04 	addi	r3,r3,104
81125858:	247ffa1e 	bne	r4,r17,81125844 <__reset+0xfb105844>
8112585c:	90800017 	ldw	r2,0(r18)
81125860:	10001d26 	beq	r2,zero,811258d8 <__sfp+0xfc>
81125864:	1025883a 	mov	r18,r2
81125868:	003fee06 	br	81125824 <__reset+0xfb105824>
8112586c:	00bfffc4 	movi	r2,-1
81125870:	8080038d 	sth	r2,14(r16)
81125874:	00800044 	movi	r2,1
81125878:	8080030d 	sth	r2,12(r16)
8112587c:	80001915 	stw	zero,100(r16)
81125880:	80000015 	stw	zero,0(r16)
81125884:	80000215 	stw	zero,8(r16)
81125888:	80000115 	stw	zero,4(r16)
8112588c:	80000415 	stw	zero,16(r16)
81125890:	80000515 	stw	zero,20(r16)
81125894:	80000615 	stw	zero,24(r16)
81125898:	01800204 	movi	r6,8
8112589c:	000b883a 	mov	r5,zero
811258a0:	81001704 	addi	r4,r16,92
811258a4:	111cc9c0 	call	8111cc9c <memset>
811258a8:	8005883a 	mov	r2,r16
811258ac:	80000c15 	stw	zero,48(r16)
811258b0:	80000d15 	stw	zero,52(r16)
811258b4:	80001115 	stw	zero,68(r16)
811258b8:	80001215 	stw	zero,72(r16)
811258bc:	dfc00417 	ldw	ra,16(sp)
811258c0:	dcc00317 	ldw	r19,12(sp)
811258c4:	dc800217 	ldw	r18,8(sp)
811258c8:	dc400117 	ldw	r17,4(sp)
811258cc:	dc000017 	ldw	r16,0(sp)
811258d0:	dec00504 	addi	sp,sp,20
811258d4:	f800283a 	ret
811258d8:	01400104 	movi	r5,4
811258dc:	9809883a 	mov	r4,r19
811258e0:	112576c0 	call	8112576c <__sfmoreglue>
811258e4:	90800015 	stw	r2,0(r18)
811258e8:	103fde1e 	bne	r2,zero,81125864 <__reset+0xfb105864>
811258ec:	00800304 	movi	r2,12
811258f0:	98800015 	stw	r2,0(r19)
811258f4:	0005883a 	mov	r2,zero
811258f8:	003ff006 	br	811258bc <__reset+0xfb1058bc>

811258fc <_cleanup>:
811258fc:	00a04574 	movhi	r2,33045
81125900:	10b52804 	addi	r2,r2,-11104
81125904:	11000017 	ldw	r4,0(r2)
81125908:	016044f4 	movhi	r5,33043
8112590c:	2974dc04 	addi	r5,r5,-11408
81125910:	11266541 	jmpi	81126654 <_fwalk_reent>

81125914 <__sinit>:
81125914:	20800e17 	ldw	r2,56(r4)
81125918:	10000126 	beq	r2,zero,81125920 <__sinit+0xc>
8112591c:	f800283a 	ret
81125920:	11255c01 	jmpi	811255c0 <__sinit.part.1>

81125924 <__sfp_lock_acquire>:
81125924:	f800283a 	ret

81125928 <__sfp_lock_release>:
81125928:	f800283a 	ret

8112592c <__sinit_lock_acquire>:
8112592c:	f800283a 	ret

81125930 <__sinit_lock_release>:
81125930:	f800283a 	ret

81125934 <__fp_lock_all>:
81125934:	00a04574 	movhi	r2,33045
81125938:	10b52904 	addi	r2,r2,-11100
8112593c:	11000017 	ldw	r4,0(r2)
81125940:	016044b4 	movhi	r5,33042
81125944:	2955d904 	addi	r5,r5,22372
81125948:	11265881 	jmpi	81126588 <_fwalk>

8112594c <__fp_unlock_all>:
8112594c:	00a04574 	movhi	r2,33045
81125950:	10b52904 	addi	r2,r2,-11100
81125954:	11000017 	ldw	r4,0(r2)
81125958:	016044b4 	movhi	r5,33042
8112595c:	29556b04 	addi	r5,r5,21932
81125960:	11265881 	jmpi	81126588 <_fwalk>

81125964 <__sflags>:
81125964:	28800007 	ldb	r2,0(r5)
81125968:	00c01c84 	movi	r3,114
8112596c:	10c02426 	beq	r2,r3,81125a00 <__sflags+0x9c>
81125970:	00c01dc4 	movi	r3,119
81125974:	10c01e26 	beq	r2,r3,811259f0 <__sflags+0x8c>
81125978:	00c01844 	movi	r3,97
8112597c:	10c00426 	beq	r2,r3,81125990 <__sflags+0x2c>
81125980:	00800584 	movi	r2,22
81125984:	20800015 	stw	r2,0(r4)
81125988:	0005883a 	mov	r2,zero
8112598c:	f800283a 	ret
81125990:	02c08204 	movi	r11,520
81125994:	01000044 	movi	r4,1
81125998:	00804204 	movi	r2,264
8112599c:	01c00ac4 	movi	r7,43
811259a0:	02bff8c4 	movi	r10,-29
811259a4:	027fff04 	movi	r9,-4
811259a8:	02001e04 	movi	r8,120
811259ac:	29400044 	addi	r5,r5,1
811259b0:	28c00007 	ldb	r3,0(r5)
811259b4:	18000626 	beq	r3,zero,811259d0 <__sflags+0x6c>
811259b8:	19c00826 	beq	r3,r7,811259dc <__sflags+0x78>
811259bc:	1a3ffb1e 	bne	r3,r8,811259ac <__reset+0xfb1059ac>
811259c0:	29400044 	addi	r5,r5,1
811259c4:	28c00007 	ldb	r3,0(r5)
811259c8:	21020014 	ori	r4,r4,2048
811259cc:	183ffa1e 	bne	r3,zero,811259b8 <__reset+0xfb1059b8>
811259d0:	22c8b03a 	or	r4,r4,r11
811259d4:	31000015 	stw	r4,0(r6)
811259d8:	f800283a 	ret
811259dc:	1284703a 	and	r2,r2,r10
811259e0:	2248703a 	and	r4,r4,r9
811259e4:	10800414 	ori	r2,r2,16
811259e8:	21000094 	ori	r4,r4,2
811259ec:	003fef06 	br	811259ac <__reset+0xfb1059ac>
811259f0:	02c18004 	movi	r11,1536
811259f4:	01000044 	movi	r4,1
811259f8:	00800204 	movi	r2,8
811259fc:	003fe706 	br	8112599c <__reset+0xfb10599c>
81125a00:	0017883a 	mov	r11,zero
81125a04:	0009883a 	mov	r4,zero
81125a08:	00800104 	movi	r2,4
81125a0c:	003fe306 	br	8112599c <__reset+0xfb10599c>

81125a10 <_fread_r>:
81125a10:	defff404 	addi	sp,sp,-48
81125a14:	de00012e 	bgeu	sp,et,81125a1c <_fread_r+0xc>
81125a18:	003b68fa 	trap	3
81125a1c:	dd800815 	stw	r22,32(sp)
81125a20:	39ad383a 	mul	r22,r7,r6
81125a24:	dc000215 	stw	r16,8(sp)
81125a28:	dfc00b15 	stw	ra,44(sp)
81125a2c:	df000a15 	stw	fp,40(sp)
81125a30:	ddc00915 	stw	r23,36(sp)
81125a34:	dd400715 	stw	r21,28(sp)
81125a38:	dd000615 	stw	r20,24(sp)
81125a3c:	dcc00515 	stw	r19,20(sp)
81125a40:	dc800415 	stw	r18,16(sp)
81125a44:	dc400315 	stw	r17,12(sp)
81125a48:	dc000c17 	ldw	r16,48(sp)
81125a4c:	b0003b26 	beq	r22,zero,81125b3c <_fread_r+0x12c>
81125a50:	302f883a 	mov	r23,r6
81125a54:	382b883a 	mov	r21,r7
81125a58:	2029883a 	mov	r20,r4
81125a5c:	2827883a 	mov	r19,r5
81125a60:	20000226 	beq	r4,zero,81125a6c <_fread_r+0x5c>
81125a64:	20800e17 	ldw	r2,56(r4)
81125a68:	10006e26 	beq	r2,zero,81125c24 <_fread_r+0x214>
81125a6c:	8080030b 	ldhu	r2,12(r16)
81125a70:	10c8000c 	andi	r3,r2,8192
81125a74:	1800061e 	bne	r3,zero,81125a90 <_fread_r+0x80>
81125a78:	81001917 	ldw	r4,100(r16)
81125a7c:	00f7ffc4 	movi	r3,-8193
81125a80:	10880014 	ori	r2,r2,8192
81125a84:	20c6703a 	and	r3,r4,r3
81125a88:	8080030d 	sth	r2,12(r16)
81125a8c:	80c01915 	stw	r3,100(r16)
81125a90:	84400117 	ldw	r17,4(r16)
81125a94:	88005f16 	blt	r17,zero,81125c14 <_fread_r+0x204>
81125a98:	8809883a 	mov	r4,r17
81125a9c:	1080008c 	andi	r2,r2,2
81125aa0:	1000281e 	bne	r2,zero,81125b44 <_fread_r+0x134>
81125aa4:	b025883a 	mov	r18,r22
81125aa8:	00000b06 	br	81125ad8 <_fread_r+0xc8>
81125aac:	111cb4c0 	call	8111cb4c <memcpy>
81125ab0:	80800017 	ldw	r2,0(r16)
81125ab4:	9c67883a 	add	r19,r19,r17
81125ab8:	9465c83a 	sub	r18,r18,r17
81125abc:	1463883a 	add	r17,r2,r17
81125ac0:	800b883a 	mov	r5,r16
81125ac4:	a009883a 	mov	r4,r20
81125ac8:	84400015 	stw	r17,0(r16)
81125acc:	111d1180 	call	8111d118 <__srefill_r>
81125ad0:	10004c1e 	bne	r2,zero,81125c04 <_fread_r+0x1f4>
81125ad4:	84400117 	ldw	r17,4(r16)
81125ad8:	880d883a 	mov	r6,r17
81125adc:	9809883a 	mov	r4,r19
81125ae0:	81400017 	ldw	r5,0(r16)
81125ae4:	8cbff136 	bltu	r17,r18,81125aac <__reset+0xfb105aac>
81125ae8:	900d883a 	mov	r6,r18
81125aec:	111cb4c0 	call	8111cb4c <memcpy>
81125af0:	80c00117 	ldw	r3,4(r16)
81125af4:	81000017 	ldw	r4,0(r16)
81125af8:	a805883a 	mov	r2,r21
81125afc:	1c87c83a 	sub	r3,r3,r18
81125b00:	24a5883a 	add	r18,r4,r18
81125b04:	80c00115 	stw	r3,4(r16)
81125b08:	84800015 	stw	r18,0(r16)
81125b0c:	dfc00b17 	ldw	ra,44(sp)
81125b10:	df000a17 	ldw	fp,40(sp)
81125b14:	ddc00917 	ldw	r23,36(sp)
81125b18:	dd800817 	ldw	r22,32(sp)
81125b1c:	dd400717 	ldw	r21,28(sp)
81125b20:	dd000617 	ldw	r20,24(sp)
81125b24:	dcc00517 	ldw	r19,20(sp)
81125b28:	dc800417 	ldw	r18,16(sp)
81125b2c:	dc400317 	ldw	r17,12(sp)
81125b30:	dc000217 	ldw	r16,8(sp)
81125b34:	dec00c04 	addi	sp,sp,48
81125b38:	f800283a 	ret
81125b3c:	0005883a 	mov	r2,zero
81125b40:	003ff206 	br	81125b0c <__reset+0xfb105b0c>
81125b44:	b007883a 	mov	r3,r22
81125b48:	2580012e 	bgeu	r4,r22,81125b50 <_fread_r+0x140>
81125b4c:	2007883a 	mov	r3,r4
81125b50:	81400017 	ldw	r5,0(r16)
81125b54:	180d883a 	mov	r6,r3
81125b58:	9809883a 	mov	r4,r19
81125b5c:	d8c00115 	stw	r3,4(sp)
81125b60:	111cb4c0 	call	8111cb4c <memcpy>
81125b64:	d8c00117 	ldw	r3,4(sp)
81125b68:	84400017 	ldw	r17,0(r16)
81125b6c:	80800117 	ldw	r2,4(r16)
81125b70:	81400c17 	ldw	r5,48(r16)
81125b74:	88e3883a 	add	r17,r17,r3
81125b78:	10c5c83a 	sub	r2,r2,r3
81125b7c:	84400015 	stw	r17,0(r16)
81125b80:	80800115 	stw	r2,4(r16)
81125b84:	b0e5c83a 	sub	r18,r22,r3
81125b88:	28002b26 	beq	r5,zero,81125c38 <_fread_r+0x228>
81125b8c:	90002b26 	beq	r18,zero,81125c3c <_fread_r+0x22c>
81125b90:	80801004 	addi	r2,r16,64
81125b94:	28800526 	beq	r5,r2,81125bac <_fread_r+0x19c>
81125b98:	a009883a 	mov	r4,r20
81125b9c:	d8c00115 	stw	r3,4(sp)
81125ba0:	1125dac0 	call	81125dac <_free_r>
81125ba4:	d8c00117 	ldw	r3,4(sp)
81125ba8:	84400017 	ldw	r17,0(r16)
81125bac:	80000c15 	stw	zero,48(r16)
81125bb0:	80800517 	ldw	r2,20(r16)
81125bb4:	87000417 	ldw	fp,16(r16)
81125bb8:	98e7883a 	add	r19,r19,r3
81125bbc:	d8800015 	stw	r2,0(sp)
81125bc0:	00000106 	br	81125bc8 <_fread_r+0x1b8>
81125bc4:	90001d26 	beq	r18,zero,81125c3c <_fread_r+0x22c>
81125bc8:	84c00415 	stw	r19,16(r16)
81125bcc:	84800515 	stw	r18,20(r16)
81125bd0:	84c00015 	stw	r19,0(r16)
81125bd4:	a009883a 	mov	r4,r20
81125bd8:	800b883a 	mov	r5,r16
81125bdc:	111d1180 	call	8111d118 <__srefill_r>
81125be0:	d9000017 	ldw	r4,0(sp)
81125be4:	80c00117 	ldw	r3,4(r16)
81125be8:	87000415 	stw	fp,16(r16)
81125bec:	81000515 	stw	r4,20(r16)
81125bf0:	84400015 	stw	r17,0(r16)
81125bf4:	80000115 	stw	zero,4(r16)
81125bf8:	90e5c83a 	sub	r18,r18,r3
81125bfc:	98e7883a 	add	r19,r19,r3
81125c00:	103ff026 	beq	r2,zero,81125bc4 <__reset+0xfb105bc4>
81125c04:	b80b883a 	mov	r5,r23
81125c08:	b489c83a 	sub	r4,r22,r18
81125c0c:	112f1340 	call	8112f134 <__udivsi3>
81125c10:	003fbe06 	br	81125b0c <__reset+0xfb105b0c>
81125c14:	80000115 	stw	zero,4(r16)
81125c18:	0009883a 	mov	r4,zero
81125c1c:	0023883a 	mov	r17,zero
81125c20:	003f9e06 	br	81125a9c <__reset+0xfb105a9c>
81125c24:	11259140 	call	81125914 <__sinit>
81125c28:	8080030b 	ldhu	r2,12(r16)
81125c2c:	10c8000c 	andi	r3,r2,8192
81125c30:	183f971e 	bne	r3,zero,81125a90 <__reset+0xfb105a90>
81125c34:	003f9006 	br	81125a78 <__reset+0xfb105a78>
81125c38:	903fdd1e 	bne	r18,zero,81125bb0 <__reset+0xfb105bb0>
81125c3c:	a805883a 	mov	r2,r21
81125c40:	003fb206 	br	81125b0c <__reset+0xfb105b0c>

81125c44 <fread>:
81125c44:	defffe04 	addi	sp,sp,-8
81125c48:	00a04574 	movhi	r2,33045
81125c4c:	de00012e 	bgeu	sp,et,81125c54 <fread+0x10>
81125c50:	003b68fa 	trap	3
81125c54:	10b52904 	addi	r2,r2,-11100
81125c58:	d9c00015 	stw	r7,0(sp)
81125c5c:	300f883a 	mov	r7,r6
81125c60:	280d883a 	mov	r6,r5
81125c64:	200b883a 	mov	r5,r4
81125c68:	11000017 	ldw	r4,0(r2)
81125c6c:	dfc00115 	stw	ra,4(sp)
81125c70:	1125a100 	call	81125a10 <_fread_r>
81125c74:	dfc00117 	ldw	ra,4(sp)
81125c78:	dec00204 	addi	sp,sp,8
81125c7c:	f800283a 	ret

81125c80 <_malloc_trim_r>:
81125c80:	defffb04 	addi	sp,sp,-20
81125c84:	de00012e 	bgeu	sp,et,81125c8c <_malloc_trim_r+0xc>
81125c88:	003b68fa 	trap	3
81125c8c:	dcc00315 	stw	r19,12(sp)
81125c90:	04e04574 	movhi	r19,33045
81125c94:	dc800215 	stw	r18,8(sp)
81125c98:	dc400115 	stw	r17,4(sp)
81125c9c:	dc000015 	stw	r16,0(sp)
81125ca0:	dfc00415 	stw	ra,16(sp)
81125ca4:	2821883a 	mov	r16,r5
81125ca8:	9ceee704 	addi	r19,r19,-17508
81125cac:	2025883a 	mov	r18,r4
81125cb0:	11331340 	call	81133134 <__malloc_lock>
81125cb4:	98800217 	ldw	r2,8(r19)
81125cb8:	14400117 	ldw	r17,4(r2)
81125cbc:	00bfff04 	movi	r2,-4
81125cc0:	88a2703a 	and	r17,r17,r2
81125cc4:	8c21c83a 	sub	r16,r17,r16
81125cc8:	8403fbc4 	addi	r16,r16,4079
81125ccc:	8020d33a 	srli	r16,r16,12
81125cd0:	0083ffc4 	movi	r2,4095
81125cd4:	843fffc4 	addi	r16,r16,-1
81125cd8:	8020933a 	slli	r16,r16,12
81125cdc:	1400060e 	bge	r2,r16,81125cf8 <_malloc_trim_r+0x78>
81125ce0:	000b883a 	mov	r5,zero
81125ce4:	9009883a 	mov	r4,r18
81125ce8:	111d2f40 	call	8111d2f4 <_sbrk_r>
81125cec:	98c00217 	ldw	r3,8(r19)
81125cf0:	1c47883a 	add	r3,r3,r17
81125cf4:	10c00a26 	beq	r2,r3,81125d20 <_malloc_trim_r+0xa0>
81125cf8:	9009883a 	mov	r4,r18
81125cfc:	113325c0 	call	8113325c <__malloc_unlock>
81125d00:	0005883a 	mov	r2,zero
81125d04:	dfc00417 	ldw	ra,16(sp)
81125d08:	dcc00317 	ldw	r19,12(sp)
81125d0c:	dc800217 	ldw	r18,8(sp)
81125d10:	dc400117 	ldw	r17,4(sp)
81125d14:	dc000017 	ldw	r16,0(sp)
81125d18:	dec00504 	addi	sp,sp,20
81125d1c:	f800283a 	ret
81125d20:	040bc83a 	sub	r5,zero,r16
81125d24:	9009883a 	mov	r4,r18
81125d28:	111d2f40 	call	8111d2f4 <_sbrk_r>
81125d2c:	00ffffc4 	movi	r3,-1
81125d30:	10c00d26 	beq	r2,r3,81125d68 <_malloc_trim_r+0xe8>
81125d34:	00e04574 	movhi	r3,33045
81125d38:	18f62604 	addi	r3,r3,-10088
81125d3c:	18800017 	ldw	r2,0(r3)
81125d40:	99000217 	ldw	r4,8(r19)
81125d44:	8c23c83a 	sub	r17,r17,r16
81125d48:	8c400054 	ori	r17,r17,1
81125d4c:	1421c83a 	sub	r16,r2,r16
81125d50:	24400115 	stw	r17,4(r4)
81125d54:	9009883a 	mov	r4,r18
81125d58:	1c000015 	stw	r16,0(r3)
81125d5c:	113325c0 	call	8113325c <__malloc_unlock>
81125d60:	00800044 	movi	r2,1
81125d64:	003fe706 	br	81125d04 <__reset+0xfb105d04>
81125d68:	000b883a 	mov	r5,zero
81125d6c:	9009883a 	mov	r4,r18
81125d70:	111d2f40 	call	8111d2f4 <_sbrk_r>
81125d74:	99000217 	ldw	r4,8(r19)
81125d78:	014003c4 	movi	r5,15
81125d7c:	1107c83a 	sub	r3,r2,r4
81125d80:	28ffdd0e 	bge	r5,r3,81125cf8 <__reset+0xfb105cf8>
81125d84:	01604574 	movhi	r5,33045
81125d88:	29752a04 	addi	r5,r5,-11096
81125d8c:	29400017 	ldw	r5,0(r5)
81125d90:	18c00054 	ori	r3,r3,1
81125d94:	20c00115 	stw	r3,4(r4)
81125d98:	00e04574 	movhi	r3,33045
81125d9c:	1145c83a 	sub	r2,r2,r5
81125da0:	18f62604 	addi	r3,r3,-10088
81125da4:	18800015 	stw	r2,0(r3)
81125da8:	003fd306 	br	81125cf8 <__reset+0xfb105cf8>

81125dac <_free_r>:
81125dac:	28004326 	beq	r5,zero,81125ebc <_free_r+0x110>
81125db0:	defffd04 	addi	sp,sp,-12
81125db4:	de00012e 	bgeu	sp,et,81125dbc <_free_r+0x10>
81125db8:	003b68fa 	trap	3
81125dbc:	dc400115 	stw	r17,4(sp)
81125dc0:	dc000015 	stw	r16,0(sp)
81125dc4:	2023883a 	mov	r17,r4
81125dc8:	2821883a 	mov	r16,r5
81125dcc:	dfc00215 	stw	ra,8(sp)
81125dd0:	11331340 	call	81133134 <__malloc_lock>
81125dd4:	81ffff17 	ldw	r7,-4(r16)
81125dd8:	00bfff84 	movi	r2,-2
81125ddc:	01204574 	movhi	r4,33045
81125de0:	81bffe04 	addi	r6,r16,-8
81125de4:	3884703a 	and	r2,r7,r2
81125de8:	212ee704 	addi	r4,r4,-17508
81125dec:	308b883a 	add	r5,r6,r2
81125df0:	2a400117 	ldw	r9,4(r5)
81125df4:	22000217 	ldw	r8,8(r4)
81125df8:	00ffff04 	movi	r3,-4
81125dfc:	48c6703a 	and	r3,r9,r3
81125e00:	2a005726 	beq	r5,r8,81125f60 <_free_r+0x1b4>
81125e04:	28c00115 	stw	r3,4(r5)
81125e08:	39c0004c 	andi	r7,r7,1
81125e0c:	3800091e 	bne	r7,zero,81125e34 <_free_r+0x88>
81125e10:	823ffe17 	ldw	r8,-8(r16)
81125e14:	22400204 	addi	r9,r4,8
81125e18:	320dc83a 	sub	r6,r6,r8
81125e1c:	31c00217 	ldw	r7,8(r6)
81125e20:	1205883a 	add	r2,r2,r8
81125e24:	3a406526 	beq	r7,r9,81125fbc <_free_r+0x210>
81125e28:	32000317 	ldw	r8,12(r6)
81125e2c:	3a000315 	stw	r8,12(r7)
81125e30:	41c00215 	stw	r7,8(r8)
81125e34:	28cf883a 	add	r7,r5,r3
81125e38:	39c00117 	ldw	r7,4(r7)
81125e3c:	39c0004c 	andi	r7,r7,1
81125e40:	38003a26 	beq	r7,zero,81125f2c <_free_r+0x180>
81125e44:	10c00054 	ori	r3,r2,1
81125e48:	30c00115 	stw	r3,4(r6)
81125e4c:	3087883a 	add	r3,r6,r2
81125e50:	18800015 	stw	r2,0(r3)
81125e54:	00c07fc4 	movi	r3,511
81125e58:	18801936 	bltu	r3,r2,81125ec0 <_free_r+0x114>
81125e5c:	1004d0fa 	srli	r2,r2,3
81125e60:	01c00044 	movi	r7,1
81125e64:	21400117 	ldw	r5,4(r4)
81125e68:	10c00044 	addi	r3,r2,1
81125e6c:	18c7883a 	add	r3,r3,r3
81125e70:	1005d0ba 	srai	r2,r2,2
81125e74:	18c7883a 	add	r3,r3,r3
81125e78:	18c7883a 	add	r3,r3,r3
81125e7c:	1907883a 	add	r3,r3,r4
81125e80:	3884983a 	sll	r2,r7,r2
81125e84:	19c00017 	ldw	r7,0(r3)
81125e88:	1a3ffe04 	addi	r8,r3,-8
81125e8c:	1144b03a 	or	r2,r2,r5
81125e90:	32000315 	stw	r8,12(r6)
81125e94:	31c00215 	stw	r7,8(r6)
81125e98:	20800115 	stw	r2,4(r4)
81125e9c:	19800015 	stw	r6,0(r3)
81125ea0:	39800315 	stw	r6,12(r7)
81125ea4:	8809883a 	mov	r4,r17
81125ea8:	dfc00217 	ldw	ra,8(sp)
81125eac:	dc400117 	ldw	r17,4(sp)
81125eb0:	dc000017 	ldw	r16,0(sp)
81125eb4:	dec00304 	addi	sp,sp,12
81125eb8:	113325c1 	jmpi	8113325c <__malloc_unlock>
81125ebc:	f800283a 	ret
81125ec0:	100ad27a 	srli	r5,r2,9
81125ec4:	00c00104 	movi	r3,4
81125ec8:	19404a36 	bltu	r3,r5,81125ff4 <_free_r+0x248>
81125ecc:	100ad1ba 	srli	r5,r2,6
81125ed0:	28c00e44 	addi	r3,r5,57
81125ed4:	18c7883a 	add	r3,r3,r3
81125ed8:	29400e04 	addi	r5,r5,56
81125edc:	18c7883a 	add	r3,r3,r3
81125ee0:	18c7883a 	add	r3,r3,r3
81125ee4:	1909883a 	add	r4,r3,r4
81125ee8:	20c00017 	ldw	r3,0(r4)
81125eec:	01e04574 	movhi	r7,33045
81125ef0:	213ffe04 	addi	r4,r4,-8
81125ef4:	39eee704 	addi	r7,r7,-17508
81125ef8:	20c04426 	beq	r4,r3,8112600c <_free_r+0x260>
81125efc:	01ffff04 	movi	r7,-4
81125f00:	19400117 	ldw	r5,4(r3)
81125f04:	29ca703a 	and	r5,r5,r7
81125f08:	1140022e 	bgeu	r2,r5,81125f14 <_free_r+0x168>
81125f0c:	18c00217 	ldw	r3,8(r3)
81125f10:	20fffb1e 	bne	r4,r3,81125f00 <__reset+0xfb105f00>
81125f14:	19000317 	ldw	r4,12(r3)
81125f18:	31000315 	stw	r4,12(r6)
81125f1c:	30c00215 	stw	r3,8(r6)
81125f20:	21800215 	stw	r6,8(r4)
81125f24:	19800315 	stw	r6,12(r3)
81125f28:	003fde06 	br	81125ea4 <__reset+0xfb105ea4>
81125f2c:	29c00217 	ldw	r7,8(r5)
81125f30:	10c5883a 	add	r2,r2,r3
81125f34:	00e04574 	movhi	r3,33045
81125f38:	18eee904 	addi	r3,r3,-17500
81125f3c:	38c03b26 	beq	r7,r3,8112602c <_free_r+0x280>
81125f40:	2a000317 	ldw	r8,12(r5)
81125f44:	11400054 	ori	r5,r2,1
81125f48:	3087883a 	add	r3,r6,r2
81125f4c:	3a000315 	stw	r8,12(r7)
81125f50:	41c00215 	stw	r7,8(r8)
81125f54:	31400115 	stw	r5,4(r6)
81125f58:	18800015 	stw	r2,0(r3)
81125f5c:	003fbd06 	br	81125e54 <__reset+0xfb105e54>
81125f60:	39c0004c 	andi	r7,r7,1
81125f64:	10c5883a 	add	r2,r2,r3
81125f68:	3800071e 	bne	r7,zero,81125f88 <_free_r+0x1dc>
81125f6c:	81fffe17 	ldw	r7,-8(r16)
81125f70:	31cdc83a 	sub	r6,r6,r7
81125f74:	30c00317 	ldw	r3,12(r6)
81125f78:	31400217 	ldw	r5,8(r6)
81125f7c:	11c5883a 	add	r2,r2,r7
81125f80:	28c00315 	stw	r3,12(r5)
81125f84:	19400215 	stw	r5,8(r3)
81125f88:	10c00054 	ori	r3,r2,1
81125f8c:	30c00115 	stw	r3,4(r6)
81125f90:	00e04574 	movhi	r3,33045
81125f94:	18f52b04 	addi	r3,r3,-11092
81125f98:	18c00017 	ldw	r3,0(r3)
81125f9c:	21800215 	stw	r6,8(r4)
81125fa0:	10ffc036 	bltu	r2,r3,81125ea4 <__reset+0xfb105ea4>
81125fa4:	00a04574 	movhi	r2,33045
81125fa8:	10b59904 	addi	r2,r2,-10652
81125fac:	11400017 	ldw	r5,0(r2)
81125fb0:	8809883a 	mov	r4,r17
81125fb4:	1125c800 	call	81125c80 <_malloc_trim_r>
81125fb8:	003fba06 	br	81125ea4 <__reset+0xfb105ea4>
81125fbc:	28c9883a 	add	r4,r5,r3
81125fc0:	21000117 	ldw	r4,4(r4)
81125fc4:	2100004c 	andi	r4,r4,1
81125fc8:	2000391e 	bne	r4,zero,811260b0 <_free_r+0x304>
81125fcc:	29c00217 	ldw	r7,8(r5)
81125fd0:	29000317 	ldw	r4,12(r5)
81125fd4:	1885883a 	add	r2,r3,r2
81125fd8:	10c00054 	ori	r3,r2,1
81125fdc:	39000315 	stw	r4,12(r7)
81125fe0:	21c00215 	stw	r7,8(r4)
81125fe4:	30c00115 	stw	r3,4(r6)
81125fe8:	308d883a 	add	r6,r6,r2
81125fec:	30800015 	stw	r2,0(r6)
81125ff0:	003fac06 	br	81125ea4 <__reset+0xfb105ea4>
81125ff4:	00c00504 	movi	r3,20
81125ff8:	19401536 	bltu	r3,r5,81126050 <_free_r+0x2a4>
81125ffc:	28c01704 	addi	r3,r5,92
81126000:	18c7883a 	add	r3,r3,r3
81126004:	294016c4 	addi	r5,r5,91
81126008:	003fb406 	br	81125edc <__reset+0xfb105edc>
8112600c:	280bd0ba 	srai	r5,r5,2
81126010:	00c00044 	movi	r3,1
81126014:	38800117 	ldw	r2,4(r7)
81126018:	194a983a 	sll	r5,r3,r5
8112601c:	2007883a 	mov	r3,r4
81126020:	2884b03a 	or	r2,r5,r2
81126024:	38800115 	stw	r2,4(r7)
81126028:	003fbb06 	br	81125f18 <__reset+0xfb105f18>
8112602c:	21800515 	stw	r6,20(r4)
81126030:	21800415 	stw	r6,16(r4)
81126034:	10c00054 	ori	r3,r2,1
81126038:	31c00315 	stw	r7,12(r6)
8112603c:	31c00215 	stw	r7,8(r6)
81126040:	30c00115 	stw	r3,4(r6)
81126044:	308d883a 	add	r6,r6,r2
81126048:	30800015 	stw	r2,0(r6)
8112604c:	003f9506 	br	81125ea4 <__reset+0xfb105ea4>
81126050:	00c01504 	movi	r3,84
81126054:	19400536 	bltu	r3,r5,8112606c <_free_r+0x2c0>
81126058:	100ad33a 	srli	r5,r2,12
8112605c:	28c01bc4 	addi	r3,r5,111
81126060:	18c7883a 	add	r3,r3,r3
81126064:	29401b84 	addi	r5,r5,110
81126068:	003f9c06 	br	81125edc <__reset+0xfb105edc>
8112606c:	00c05504 	movi	r3,340
81126070:	19400536 	bltu	r3,r5,81126088 <_free_r+0x2dc>
81126074:	100ad3fa 	srli	r5,r2,15
81126078:	28c01e04 	addi	r3,r5,120
8112607c:	18c7883a 	add	r3,r3,r3
81126080:	29401dc4 	addi	r5,r5,119
81126084:	003f9506 	br	81125edc <__reset+0xfb105edc>
81126088:	00c15504 	movi	r3,1364
8112608c:	19400536 	bltu	r3,r5,811260a4 <_free_r+0x2f8>
81126090:	100ad4ba 	srli	r5,r2,18
81126094:	28c01f44 	addi	r3,r5,125
81126098:	18c7883a 	add	r3,r3,r3
8112609c:	29401f04 	addi	r5,r5,124
811260a0:	003f8e06 	br	81125edc <__reset+0xfb105edc>
811260a4:	00c03f84 	movi	r3,254
811260a8:	01401f84 	movi	r5,126
811260ac:	003f8b06 	br	81125edc <__reset+0xfb105edc>
811260b0:	10c00054 	ori	r3,r2,1
811260b4:	30c00115 	stw	r3,4(r6)
811260b8:	308d883a 	add	r6,r6,r2
811260bc:	30800015 	stw	r2,0(r6)
811260c0:	003f7806 	br	81125ea4 <__reset+0xfb105ea4>

811260c4 <__sfvwrite_r>:
811260c4:	30800217 	ldw	r2,8(r6)
811260c8:	10006926 	beq	r2,zero,81126270 <__sfvwrite_r+0x1ac>
811260cc:	defff404 	addi	sp,sp,-48
811260d0:	de00012e 	bgeu	sp,et,811260d8 <__sfvwrite_r+0x14>
811260d4:	003b68fa 	trap	3
811260d8:	28c0030b 	ldhu	r3,12(r5)
811260dc:	dd400715 	stw	r21,28(sp)
811260e0:	dd000615 	stw	r20,24(sp)
811260e4:	dc000215 	stw	r16,8(sp)
811260e8:	dfc00b15 	stw	ra,44(sp)
811260ec:	df000a15 	stw	fp,40(sp)
811260f0:	ddc00915 	stw	r23,36(sp)
811260f4:	dd800815 	stw	r22,32(sp)
811260f8:	dcc00515 	stw	r19,20(sp)
811260fc:	dc800415 	stw	r18,16(sp)
81126100:	dc400315 	stw	r17,12(sp)
81126104:	1880020c 	andi	r2,r3,8
81126108:	2821883a 	mov	r16,r5
8112610c:	202b883a 	mov	r21,r4
81126110:	3029883a 	mov	r20,r6
81126114:	10002726 	beq	r2,zero,811261b4 <__sfvwrite_r+0xf0>
81126118:	28800417 	ldw	r2,16(r5)
8112611c:	10002526 	beq	r2,zero,811261b4 <__sfvwrite_r+0xf0>
81126120:	1880008c 	andi	r2,r3,2
81126124:	a4400017 	ldw	r17,0(r20)
81126128:	10002a26 	beq	r2,zero,811261d4 <__sfvwrite_r+0x110>
8112612c:	05a00034 	movhi	r22,32768
81126130:	0027883a 	mov	r19,zero
81126134:	0025883a 	mov	r18,zero
81126138:	b5bf0004 	addi	r22,r22,-1024
8112613c:	980d883a 	mov	r6,r19
81126140:	a809883a 	mov	r4,r21
81126144:	90004626 	beq	r18,zero,81126260 <__sfvwrite_r+0x19c>
81126148:	900f883a 	mov	r7,r18
8112614c:	b480022e 	bgeu	r22,r18,81126158 <__sfvwrite_r+0x94>
81126150:	01e00034 	movhi	r7,32768
81126154:	39ff0004 	addi	r7,r7,-1024
81126158:	80800917 	ldw	r2,36(r16)
8112615c:	81400717 	ldw	r5,28(r16)
81126160:	103ee83a 	callr	r2
81126164:	0080570e 	bge	zero,r2,811262c4 <__sfvwrite_r+0x200>
81126168:	a0c00217 	ldw	r3,8(r20)
8112616c:	98a7883a 	add	r19,r19,r2
81126170:	90a5c83a 	sub	r18,r18,r2
81126174:	1885c83a 	sub	r2,r3,r2
81126178:	a0800215 	stw	r2,8(r20)
8112617c:	103fef1e 	bne	r2,zero,8112613c <__reset+0xfb10613c>
81126180:	0005883a 	mov	r2,zero
81126184:	dfc00b17 	ldw	ra,44(sp)
81126188:	df000a17 	ldw	fp,40(sp)
8112618c:	ddc00917 	ldw	r23,36(sp)
81126190:	dd800817 	ldw	r22,32(sp)
81126194:	dd400717 	ldw	r21,28(sp)
81126198:	dd000617 	ldw	r20,24(sp)
8112619c:	dcc00517 	ldw	r19,20(sp)
811261a0:	dc800417 	ldw	r18,16(sp)
811261a4:	dc400317 	ldw	r17,12(sp)
811261a8:	dc000217 	ldw	r16,8(sp)
811261ac:	dec00c04 	addi	sp,sp,48
811261b0:	f800283a 	ret
811261b4:	800b883a 	mov	r5,r16
811261b8:	a809883a 	mov	r4,r21
811261bc:	11238a40 	call	811238a4 <__swsetup_r>
811261c0:	1000eb1e 	bne	r2,zero,81126570 <__sfvwrite_r+0x4ac>
811261c4:	80c0030b 	ldhu	r3,12(r16)
811261c8:	a4400017 	ldw	r17,0(r20)
811261cc:	1880008c 	andi	r2,r3,2
811261d0:	103fd61e 	bne	r2,zero,8112612c <__reset+0xfb10612c>
811261d4:	1880004c 	andi	r2,r3,1
811261d8:	10003f1e 	bne	r2,zero,811262d8 <__sfvwrite_r+0x214>
811261dc:	0039883a 	mov	fp,zero
811261e0:	0025883a 	mov	r18,zero
811261e4:	90001a26 	beq	r18,zero,81126250 <__sfvwrite_r+0x18c>
811261e8:	1880800c 	andi	r2,r3,512
811261ec:	84c00217 	ldw	r19,8(r16)
811261f0:	10002126 	beq	r2,zero,81126278 <__sfvwrite_r+0x1b4>
811261f4:	982f883a 	mov	r23,r19
811261f8:	94c09336 	bltu	r18,r19,81126448 <__sfvwrite_r+0x384>
811261fc:	1881200c 	andi	r2,r3,1152
81126200:	10009e1e 	bne	r2,zero,8112647c <__sfvwrite_r+0x3b8>
81126204:	81000017 	ldw	r4,0(r16)
81126208:	b80d883a 	mov	r6,r23
8112620c:	e00b883a 	mov	r5,fp
81126210:	1126c200 	call	81126c20 <memmove>
81126214:	80c00217 	ldw	r3,8(r16)
81126218:	81000017 	ldw	r4,0(r16)
8112621c:	9005883a 	mov	r2,r18
81126220:	1ce7c83a 	sub	r19,r3,r19
81126224:	25cf883a 	add	r7,r4,r23
81126228:	84c00215 	stw	r19,8(r16)
8112622c:	81c00015 	stw	r7,0(r16)
81126230:	a0c00217 	ldw	r3,8(r20)
81126234:	e0b9883a 	add	fp,fp,r2
81126238:	90a5c83a 	sub	r18,r18,r2
8112623c:	18a7c83a 	sub	r19,r3,r2
81126240:	a4c00215 	stw	r19,8(r20)
81126244:	983fce26 	beq	r19,zero,81126180 <__reset+0xfb106180>
81126248:	80c0030b 	ldhu	r3,12(r16)
8112624c:	903fe61e 	bne	r18,zero,811261e8 <__reset+0xfb1061e8>
81126250:	8f000017 	ldw	fp,0(r17)
81126254:	8c800117 	ldw	r18,4(r17)
81126258:	8c400204 	addi	r17,r17,8
8112625c:	003fe106 	br	811261e4 <__reset+0xfb1061e4>
81126260:	8cc00017 	ldw	r19,0(r17)
81126264:	8c800117 	ldw	r18,4(r17)
81126268:	8c400204 	addi	r17,r17,8
8112626c:	003fb306 	br	8112613c <__reset+0xfb10613c>
81126270:	0005883a 	mov	r2,zero
81126274:	f800283a 	ret
81126278:	81000017 	ldw	r4,0(r16)
8112627c:	80800417 	ldw	r2,16(r16)
81126280:	11005736 	bltu	r2,r4,811263e0 <__sfvwrite_r+0x31c>
81126284:	85c00517 	ldw	r23,20(r16)
81126288:	95c05536 	bltu	r18,r23,811263e0 <__sfvwrite_r+0x31c>
8112628c:	00a00034 	movhi	r2,32768
81126290:	10bfffc4 	addi	r2,r2,-1
81126294:	9009883a 	mov	r4,r18
81126298:	1480012e 	bgeu	r2,r18,811262a0 <__sfvwrite_r+0x1dc>
8112629c:	1009883a 	mov	r4,r2
811262a0:	b80b883a 	mov	r5,r23
811262a4:	112f03c0 	call	8112f03c <__divsi3>
811262a8:	15cf383a 	mul	r7,r2,r23
811262ac:	81400717 	ldw	r5,28(r16)
811262b0:	80800917 	ldw	r2,36(r16)
811262b4:	e00d883a 	mov	r6,fp
811262b8:	a809883a 	mov	r4,r21
811262bc:	103ee83a 	callr	r2
811262c0:	00bfdb16 	blt	zero,r2,81126230 <__reset+0xfb106230>
811262c4:	8080030b 	ldhu	r2,12(r16)
811262c8:	10801014 	ori	r2,r2,64
811262cc:	8080030d 	sth	r2,12(r16)
811262d0:	00bfffc4 	movi	r2,-1
811262d4:	003fab06 	br	81126184 <__reset+0xfb106184>
811262d8:	0027883a 	mov	r19,zero
811262dc:	0011883a 	mov	r8,zero
811262e0:	0039883a 	mov	fp,zero
811262e4:	0025883a 	mov	r18,zero
811262e8:	90001f26 	beq	r18,zero,81126368 <__sfvwrite_r+0x2a4>
811262ec:	40005a26 	beq	r8,zero,81126458 <__sfvwrite_r+0x394>
811262f0:	982d883a 	mov	r22,r19
811262f4:	94c0012e 	bgeu	r18,r19,811262fc <__sfvwrite_r+0x238>
811262f8:	902d883a 	mov	r22,r18
811262fc:	81000017 	ldw	r4,0(r16)
81126300:	80800417 	ldw	r2,16(r16)
81126304:	b02f883a 	mov	r23,r22
81126308:	81c00517 	ldw	r7,20(r16)
8112630c:	1100032e 	bgeu	r2,r4,8112631c <__sfvwrite_r+0x258>
81126310:	80c00217 	ldw	r3,8(r16)
81126314:	38c7883a 	add	r3,r7,r3
81126318:	1d801816 	blt	r3,r22,8112637c <__sfvwrite_r+0x2b8>
8112631c:	b1c03e16 	blt	r22,r7,81126418 <__sfvwrite_r+0x354>
81126320:	80800917 	ldw	r2,36(r16)
81126324:	81400717 	ldw	r5,28(r16)
81126328:	e00d883a 	mov	r6,fp
8112632c:	da000115 	stw	r8,4(sp)
81126330:	a809883a 	mov	r4,r21
81126334:	103ee83a 	callr	r2
81126338:	102f883a 	mov	r23,r2
8112633c:	da000117 	ldw	r8,4(sp)
81126340:	00bfe00e 	bge	zero,r2,811262c4 <__reset+0xfb1062c4>
81126344:	9de7c83a 	sub	r19,r19,r23
81126348:	98001f26 	beq	r19,zero,811263c8 <__sfvwrite_r+0x304>
8112634c:	a0800217 	ldw	r2,8(r20)
81126350:	e5f9883a 	add	fp,fp,r23
81126354:	95e5c83a 	sub	r18,r18,r23
81126358:	15efc83a 	sub	r23,r2,r23
8112635c:	a5c00215 	stw	r23,8(r20)
81126360:	b83f8726 	beq	r23,zero,81126180 <__reset+0xfb106180>
81126364:	903fe11e 	bne	r18,zero,811262ec <__reset+0xfb1062ec>
81126368:	8f000017 	ldw	fp,0(r17)
8112636c:	8c800117 	ldw	r18,4(r17)
81126370:	0011883a 	mov	r8,zero
81126374:	8c400204 	addi	r17,r17,8
81126378:	003fdb06 	br	811262e8 <__reset+0xfb1062e8>
8112637c:	180d883a 	mov	r6,r3
81126380:	e00b883a 	mov	r5,fp
81126384:	da000115 	stw	r8,4(sp)
81126388:	d8c00015 	stw	r3,0(sp)
8112638c:	1126c200 	call	81126c20 <memmove>
81126390:	d8c00017 	ldw	r3,0(sp)
81126394:	80800017 	ldw	r2,0(r16)
81126398:	800b883a 	mov	r5,r16
8112639c:	a809883a 	mov	r4,r21
811263a0:	10c5883a 	add	r2,r2,r3
811263a4:	80800015 	stw	r2,0(r16)
811263a8:	d8c00015 	stw	r3,0(sp)
811263ac:	11255180 	call	81125518 <_fflush_r>
811263b0:	d8c00017 	ldw	r3,0(sp)
811263b4:	da000117 	ldw	r8,4(sp)
811263b8:	103fc21e 	bne	r2,zero,811262c4 <__reset+0xfb1062c4>
811263bc:	182f883a 	mov	r23,r3
811263c0:	9de7c83a 	sub	r19,r19,r23
811263c4:	983fe11e 	bne	r19,zero,8112634c <__reset+0xfb10634c>
811263c8:	800b883a 	mov	r5,r16
811263cc:	a809883a 	mov	r4,r21
811263d0:	11255180 	call	81125518 <_fflush_r>
811263d4:	103fbb1e 	bne	r2,zero,811262c4 <__reset+0xfb1062c4>
811263d8:	0011883a 	mov	r8,zero
811263dc:	003fdb06 	br	8112634c <__reset+0xfb10634c>
811263e0:	94c0012e 	bgeu	r18,r19,811263e8 <__sfvwrite_r+0x324>
811263e4:	9027883a 	mov	r19,r18
811263e8:	980d883a 	mov	r6,r19
811263ec:	e00b883a 	mov	r5,fp
811263f0:	1126c200 	call	81126c20 <memmove>
811263f4:	80800217 	ldw	r2,8(r16)
811263f8:	80c00017 	ldw	r3,0(r16)
811263fc:	14c5c83a 	sub	r2,r2,r19
81126400:	1cc7883a 	add	r3,r3,r19
81126404:	80800215 	stw	r2,8(r16)
81126408:	80c00015 	stw	r3,0(r16)
8112640c:	10004326 	beq	r2,zero,8112651c <__sfvwrite_r+0x458>
81126410:	9805883a 	mov	r2,r19
81126414:	003f8606 	br	81126230 <__reset+0xfb106230>
81126418:	b00d883a 	mov	r6,r22
8112641c:	e00b883a 	mov	r5,fp
81126420:	da000115 	stw	r8,4(sp)
81126424:	1126c200 	call	81126c20 <memmove>
81126428:	80800217 	ldw	r2,8(r16)
8112642c:	80c00017 	ldw	r3,0(r16)
81126430:	da000117 	ldw	r8,4(sp)
81126434:	1585c83a 	sub	r2,r2,r22
81126438:	1dad883a 	add	r22,r3,r22
8112643c:	80800215 	stw	r2,8(r16)
81126440:	85800015 	stw	r22,0(r16)
81126444:	003fbf06 	br	81126344 <__reset+0xfb106344>
81126448:	81000017 	ldw	r4,0(r16)
8112644c:	9027883a 	mov	r19,r18
81126450:	902f883a 	mov	r23,r18
81126454:	003f6c06 	br	81126208 <__reset+0xfb106208>
81126458:	900d883a 	mov	r6,r18
8112645c:	01400284 	movi	r5,10
81126460:	e009883a 	mov	r4,fp
81126464:	1126b3c0 	call	81126b3c <memchr>
81126468:	10003e26 	beq	r2,zero,81126564 <__sfvwrite_r+0x4a0>
8112646c:	10800044 	addi	r2,r2,1
81126470:	1727c83a 	sub	r19,r2,fp
81126474:	02000044 	movi	r8,1
81126478:	003f9d06 	br	811262f0 <__reset+0xfb1062f0>
8112647c:	80800517 	ldw	r2,20(r16)
81126480:	81400417 	ldw	r5,16(r16)
81126484:	81c00017 	ldw	r7,0(r16)
81126488:	10a7883a 	add	r19,r2,r2
8112648c:	9885883a 	add	r2,r19,r2
81126490:	1026d7fa 	srli	r19,r2,31
81126494:	396dc83a 	sub	r22,r7,r5
81126498:	b1000044 	addi	r4,r22,1
8112649c:	9885883a 	add	r2,r19,r2
811264a0:	1027d07a 	srai	r19,r2,1
811264a4:	2485883a 	add	r2,r4,r18
811264a8:	980d883a 	mov	r6,r19
811264ac:	9880022e 	bgeu	r19,r2,811264b8 <__sfvwrite_r+0x3f4>
811264b0:	1027883a 	mov	r19,r2
811264b4:	100d883a 	mov	r6,r2
811264b8:	18c1000c 	andi	r3,r3,1024
811264bc:	18001c26 	beq	r3,zero,81126530 <__sfvwrite_r+0x46c>
811264c0:	300b883a 	mov	r5,r6
811264c4:	a809883a 	mov	r4,r21
811264c8:	111c3380 	call	8111c338 <_malloc_r>
811264cc:	102f883a 	mov	r23,r2
811264d0:	10002926 	beq	r2,zero,81126578 <__sfvwrite_r+0x4b4>
811264d4:	81400417 	ldw	r5,16(r16)
811264d8:	b00d883a 	mov	r6,r22
811264dc:	1009883a 	mov	r4,r2
811264e0:	111cb4c0 	call	8111cb4c <memcpy>
811264e4:	8080030b 	ldhu	r2,12(r16)
811264e8:	00fedfc4 	movi	r3,-1153
811264ec:	10c4703a 	and	r2,r2,r3
811264f0:	10802014 	ori	r2,r2,128
811264f4:	8080030d 	sth	r2,12(r16)
811264f8:	bd89883a 	add	r4,r23,r22
811264fc:	9d8fc83a 	sub	r7,r19,r22
81126500:	85c00415 	stw	r23,16(r16)
81126504:	84c00515 	stw	r19,20(r16)
81126508:	81000015 	stw	r4,0(r16)
8112650c:	9027883a 	mov	r19,r18
81126510:	81c00215 	stw	r7,8(r16)
81126514:	902f883a 	mov	r23,r18
81126518:	003f3b06 	br	81126208 <__reset+0xfb106208>
8112651c:	800b883a 	mov	r5,r16
81126520:	a809883a 	mov	r4,r21
81126524:	11255180 	call	81125518 <_fflush_r>
81126528:	103fb926 	beq	r2,zero,81126410 <__reset+0xfb106410>
8112652c:	003f6506 	br	811262c4 <__reset+0xfb1062c4>
81126530:	a809883a 	mov	r4,r21
81126534:	1127e400 	call	81127e40 <_realloc_r>
81126538:	102f883a 	mov	r23,r2
8112653c:	103fee1e 	bne	r2,zero,811264f8 <__reset+0xfb1064f8>
81126540:	81400417 	ldw	r5,16(r16)
81126544:	a809883a 	mov	r4,r21
81126548:	1125dac0 	call	81125dac <_free_r>
8112654c:	8080030b 	ldhu	r2,12(r16)
81126550:	00ffdfc4 	movi	r3,-129
81126554:	1884703a 	and	r2,r3,r2
81126558:	00c00304 	movi	r3,12
8112655c:	a8c00015 	stw	r3,0(r21)
81126560:	003f5906 	br	811262c8 <__reset+0xfb1062c8>
81126564:	94c00044 	addi	r19,r18,1
81126568:	02000044 	movi	r8,1
8112656c:	003f6006 	br	811262f0 <__reset+0xfb1062f0>
81126570:	00bfffc4 	movi	r2,-1
81126574:	003f0306 	br	81126184 <__reset+0xfb106184>
81126578:	00800304 	movi	r2,12
8112657c:	a8800015 	stw	r2,0(r21)
81126580:	8080030b 	ldhu	r2,12(r16)
81126584:	003f5006 	br	811262c8 <__reset+0xfb1062c8>

81126588 <_fwalk>:
81126588:	defff704 	addi	sp,sp,-36
8112658c:	de00012e 	bgeu	sp,et,81126594 <_fwalk+0xc>
81126590:	003b68fa 	trap	3
81126594:	dd000415 	stw	r20,16(sp)
81126598:	dfc00815 	stw	ra,32(sp)
8112659c:	ddc00715 	stw	r23,28(sp)
811265a0:	dd800615 	stw	r22,24(sp)
811265a4:	dd400515 	stw	r21,20(sp)
811265a8:	dcc00315 	stw	r19,12(sp)
811265ac:	dc800215 	stw	r18,8(sp)
811265b0:	dc400115 	stw	r17,4(sp)
811265b4:	dc000015 	stw	r16,0(sp)
811265b8:	2500b804 	addi	r20,r4,736
811265bc:	a0002326 	beq	r20,zero,8112664c <_fwalk+0xc4>
811265c0:	282b883a 	mov	r21,r5
811265c4:	002f883a 	mov	r23,zero
811265c8:	05800044 	movi	r22,1
811265cc:	04ffffc4 	movi	r19,-1
811265d0:	a4400117 	ldw	r17,4(r20)
811265d4:	a4800217 	ldw	r18,8(r20)
811265d8:	8c7fffc4 	addi	r17,r17,-1
811265dc:	88000d16 	blt	r17,zero,81126614 <_fwalk+0x8c>
811265e0:	94000304 	addi	r16,r18,12
811265e4:	94800384 	addi	r18,r18,14
811265e8:	8080000b 	ldhu	r2,0(r16)
811265ec:	8c7fffc4 	addi	r17,r17,-1
811265f0:	813ffd04 	addi	r4,r16,-12
811265f4:	b080042e 	bgeu	r22,r2,81126608 <_fwalk+0x80>
811265f8:	9080000f 	ldh	r2,0(r18)
811265fc:	14c00226 	beq	r2,r19,81126608 <_fwalk+0x80>
81126600:	a83ee83a 	callr	r21
81126604:	b8aeb03a 	or	r23,r23,r2
81126608:	84001a04 	addi	r16,r16,104
8112660c:	94801a04 	addi	r18,r18,104
81126610:	8cfff51e 	bne	r17,r19,811265e8 <__reset+0xfb1065e8>
81126614:	a5000017 	ldw	r20,0(r20)
81126618:	a03fed1e 	bne	r20,zero,811265d0 <__reset+0xfb1065d0>
8112661c:	b805883a 	mov	r2,r23
81126620:	dfc00817 	ldw	ra,32(sp)
81126624:	ddc00717 	ldw	r23,28(sp)
81126628:	dd800617 	ldw	r22,24(sp)
8112662c:	dd400517 	ldw	r21,20(sp)
81126630:	dd000417 	ldw	r20,16(sp)
81126634:	dcc00317 	ldw	r19,12(sp)
81126638:	dc800217 	ldw	r18,8(sp)
8112663c:	dc400117 	ldw	r17,4(sp)
81126640:	dc000017 	ldw	r16,0(sp)
81126644:	dec00904 	addi	sp,sp,36
81126648:	f800283a 	ret
8112664c:	002f883a 	mov	r23,zero
81126650:	003ff206 	br	8112661c <__reset+0xfb10661c>

81126654 <_fwalk_reent>:
81126654:	defff704 	addi	sp,sp,-36
81126658:	de00012e 	bgeu	sp,et,81126660 <_fwalk_reent+0xc>
8112665c:	003b68fa 	trap	3
81126660:	dd000415 	stw	r20,16(sp)
81126664:	dfc00815 	stw	ra,32(sp)
81126668:	ddc00715 	stw	r23,28(sp)
8112666c:	dd800615 	stw	r22,24(sp)
81126670:	dd400515 	stw	r21,20(sp)
81126674:	dcc00315 	stw	r19,12(sp)
81126678:	dc800215 	stw	r18,8(sp)
8112667c:	dc400115 	stw	r17,4(sp)
81126680:	dc000015 	stw	r16,0(sp)
81126684:	2500b804 	addi	r20,r4,736
81126688:	a0002326 	beq	r20,zero,81126718 <_fwalk_reent+0xc4>
8112668c:	282b883a 	mov	r21,r5
81126690:	2027883a 	mov	r19,r4
81126694:	002f883a 	mov	r23,zero
81126698:	05800044 	movi	r22,1
8112669c:	04bfffc4 	movi	r18,-1
811266a0:	a4400117 	ldw	r17,4(r20)
811266a4:	a4000217 	ldw	r16,8(r20)
811266a8:	8c7fffc4 	addi	r17,r17,-1
811266ac:	88000c16 	blt	r17,zero,811266e0 <_fwalk_reent+0x8c>
811266b0:	84000304 	addi	r16,r16,12
811266b4:	8080000b 	ldhu	r2,0(r16)
811266b8:	8c7fffc4 	addi	r17,r17,-1
811266bc:	817ffd04 	addi	r5,r16,-12
811266c0:	b080052e 	bgeu	r22,r2,811266d8 <_fwalk_reent+0x84>
811266c4:	8080008f 	ldh	r2,2(r16)
811266c8:	9809883a 	mov	r4,r19
811266cc:	14800226 	beq	r2,r18,811266d8 <_fwalk_reent+0x84>
811266d0:	a83ee83a 	callr	r21
811266d4:	b8aeb03a 	or	r23,r23,r2
811266d8:	84001a04 	addi	r16,r16,104
811266dc:	8cbff51e 	bne	r17,r18,811266b4 <__reset+0xfb1066b4>
811266e0:	a5000017 	ldw	r20,0(r20)
811266e4:	a03fee1e 	bne	r20,zero,811266a0 <__reset+0xfb1066a0>
811266e8:	b805883a 	mov	r2,r23
811266ec:	dfc00817 	ldw	ra,32(sp)
811266f0:	ddc00717 	ldw	r23,28(sp)
811266f4:	dd800617 	ldw	r22,24(sp)
811266f8:	dd400517 	ldw	r21,20(sp)
811266fc:	dd000417 	ldw	r20,16(sp)
81126700:	dcc00317 	ldw	r19,12(sp)
81126704:	dc800217 	ldw	r18,8(sp)
81126708:	dc400117 	ldw	r17,4(sp)
8112670c:	dc000017 	ldw	r16,0(sp)
81126710:	dec00904 	addi	sp,sp,36
81126714:	f800283a 	ret
81126718:	002f883a 	mov	r23,zero
8112671c:	003ff206 	br	811266e8 <__reset+0xfb1066e8>

81126720 <_isatty_r>:
81126720:	defffd04 	addi	sp,sp,-12
81126724:	de00012e 	bgeu	sp,et,8112672c <_isatty_r+0xc>
81126728:	003b68fa 	trap	3
8112672c:	dc000015 	stw	r16,0(sp)
81126730:	04204574 	movhi	r16,33045
81126734:	dc400115 	stw	r17,4(sp)
81126738:	84359604 	addi	r16,r16,-10664
8112673c:	2023883a 	mov	r17,r4
81126740:	2809883a 	mov	r4,r5
81126744:	dfc00215 	stw	ra,8(sp)
81126748:	80000015 	stw	zero,0(r16)
8112674c:	11318700 	call	81131870 <isatty>
81126750:	00ffffc4 	movi	r3,-1
81126754:	10c00526 	beq	r2,r3,8112676c <_isatty_r+0x4c>
81126758:	dfc00217 	ldw	ra,8(sp)
8112675c:	dc400117 	ldw	r17,4(sp)
81126760:	dc000017 	ldw	r16,0(sp)
81126764:	dec00304 	addi	sp,sp,12
81126768:	f800283a 	ret
8112676c:	80c00017 	ldw	r3,0(r16)
81126770:	183ff926 	beq	r3,zero,81126758 <__reset+0xfb106758>
81126774:	88c00015 	stw	r3,0(r17)
81126778:	003ff706 	br	81126758 <__reset+0xfb106758>

8112677c <iswspace>:
8112677c:	00803fc4 	movi	r2,255
81126780:	11000836 	bltu	r2,r4,811267a4 <iswspace+0x28>
81126784:	00a04574 	movhi	r2,33045
81126788:	10b52704 	addi	r2,r2,-11108
8112678c:	10800017 	ldw	r2,0(r2)
81126790:	1109883a 	add	r4,r2,r4
81126794:	20800043 	ldbu	r2,1(r4)
81126798:	1080020c 	andi	r2,r2,8
8112679c:	10803fcc 	andi	r2,r2,255
811267a0:	f800283a 	ret
811267a4:	0005883a 	mov	r2,zero
811267a8:	f800283a 	ret

811267ac <_setlocale_r>:
811267ac:	30001d26 	beq	r6,zero,81126824 <_setlocale_r+0x78>
811267b0:	01604574 	movhi	r5,33045
811267b4:	defffe04 	addi	sp,sp,-8
811267b8:	296b8004 	addi	r5,r5,-20992
811267bc:	3009883a 	mov	r4,r6
811267c0:	de00012e 	bgeu	sp,et,811267c8 <_setlocale_r+0x1c>
811267c4:	003b68fa 	trap	3
811267c8:	dc000015 	stw	r16,0(sp)
811267cc:	dfc00115 	stw	ra,4(sp)
811267d0:	3021883a 	mov	r16,r6
811267d4:	11284f80 	call	811284f8 <strcmp>
811267d8:	1000061e 	bne	r2,zero,811267f4 <_setlocale_r+0x48>
811267dc:	00a04574 	movhi	r2,33045
811267e0:	10ab4f04 	addi	r2,r2,-21188
811267e4:	dfc00117 	ldw	ra,4(sp)
811267e8:	dc000017 	ldw	r16,0(sp)
811267ec:	dec00204 	addi	sp,sp,8
811267f0:	f800283a 	ret
811267f4:	01604574 	movhi	r5,33045
811267f8:	296b4f04 	addi	r5,r5,-21188
811267fc:	8009883a 	mov	r4,r16
81126800:	11284f80 	call	811284f8 <strcmp>
81126804:	103ff526 	beq	r2,zero,811267dc <__reset+0xfb1067dc>
81126808:	01604574 	movhi	r5,33045
8112680c:	296b5904 	addi	r5,r5,-21148
81126810:	8009883a 	mov	r4,r16
81126814:	11284f80 	call	811284f8 <strcmp>
81126818:	103ff026 	beq	r2,zero,811267dc <__reset+0xfb1067dc>
8112681c:	0005883a 	mov	r2,zero
81126820:	003ff006 	br	811267e4 <__reset+0xfb1067e4>
81126824:	00a04574 	movhi	r2,33045
81126828:	10ab4f04 	addi	r2,r2,-21188
8112682c:	f800283a 	ret

81126830 <__locale_charset>:
81126830:	00a04574 	movhi	r2,33045
81126834:	10aff104 	addi	r2,r2,-16444
81126838:	f800283a 	ret

8112683c <__locale_mb_cur_max>:
8112683c:	00a04574 	movhi	r2,33045
81126840:	10b52c04 	addi	r2,r2,-11088
81126844:	10800017 	ldw	r2,0(r2)
81126848:	f800283a 	ret

8112684c <__locale_msgcharset>:
8112684c:	00a04574 	movhi	r2,33045
81126850:	10afe904 	addi	r2,r2,-16476
81126854:	f800283a 	ret

81126858 <__locale_cjk_lang>:
81126858:	0005883a 	mov	r2,zero
8112685c:	f800283a 	ret

81126860 <_localeconv_r>:
81126860:	00a04574 	movhi	r2,33045
81126864:	10aff904 	addi	r2,r2,-16412
81126868:	f800283a 	ret

8112686c <setlocale>:
8112686c:	00a04574 	movhi	r2,33045
81126870:	10b52904 	addi	r2,r2,-11100
81126874:	280d883a 	mov	r6,r5
81126878:	200b883a 	mov	r5,r4
8112687c:	11000017 	ldw	r4,0(r2)
81126880:	11267ac1 	jmpi	811267ac <_setlocale_r>

81126884 <localeconv>:
81126884:	00a04574 	movhi	r2,33045
81126888:	10aff904 	addi	r2,r2,-16412
8112688c:	f800283a 	ret

81126890 <_lseek_r>:
81126890:	defffd04 	addi	sp,sp,-12
81126894:	de00012e 	bgeu	sp,et,8112689c <_lseek_r+0xc>
81126898:	003b68fa 	trap	3
8112689c:	2805883a 	mov	r2,r5
811268a0:	dc000015 	stw	r16,0(sp)
811268a4:	04204574 	movhi	r16,33045
811268a8:	dc400115 	stw	r17,4(sp)
811268ac:	300b883a 	mov	r5,r6
811268b0:	84359604 	addi	r16,r16,-10664
811268b4:	2023883a 	mov	r17,r4
811268b8:	380d883a 	mov	r6,r7
811268bc:	1009883a 	mov	r4,r2
811268c0:	dfc00215 	stw	ra,8(sp)
811268c4:	80000015 	stw	zero,0(r16)
811268c8:	113246c0 	call	8113246c <lseek>
811268cc:	00ffffc4 	movi	r3,-1
811268d0:	10c00526 	beq	r2,r3,811268e8 <_lseek_r+0x58>
811268d4:	dfc00217 	ldw	ra,8(sp)
811268d8:	dc400117 	ldw	r17,4(sp)
811268dc:	dc000017 	ldw	r16,0(sp)
811268e0:	dec00304 	addi	sp,sp,12
811268e4:	f800283a 	ret
811268e8:	80c00017 	ldw	r3,0(r16)
811268ec:	183ff926 	beq	r3,zero,811268d4 <__reset+0xfb1068d4>
811268f0:	88c00015 	stw	r3,0(r17)
811268f4:	003ff706 	br	811268d4 <__reset+0xfb1068d4>

811268f8 <_mbrtowc_r>:
811268f8:	defff704 	addi	sp,sp,-36
811268fc:	00a04574 	movhi	r2,33045
81126900:	de00012e 	bgeu	sp,et,81126908 <_mbrtowc_r+0x10>
81126904:	003b68fa 	trap	3
81126908:	10b52d04 	addi	r2,r2,-11084
8112690c:	dc800715 	stw	r18,28(sp)
81126910:	dc400615 	stw	r17,24(sp)
81126914:	dc000515 	stw	r16,20(sp)
81126918:	dfc00815 	stw	ra,32(sp)
8112691c:	2021883a 	mov	r16,r4
81126920:	dc400917 	ldw	r17,36(sp)
81126924:	14800017 	ldw	r18,0(r2)
81126928:	30001626 	beq	r6,zero,81126984 <_mbrtowc_r+0x8c>
8112692c:	d9400215 	stw	r5,8(sp)
81126930:	d9800315 	stw	r6,12(sp)
81126934:	d9c00415 	stw	r7,16(sp)
81126938:	11268300 	call	81126830 <__locale_charset>
8112693c:	d9c00417 	ldw	r7,16(sp)
81126940:	d9800317 	ldw	r6,12(sp)
81126944:	d9400217 	ldw	r5,8(sp)
81126948:	d8800015 	stw	r2,0(sp)
8112694c:	dc400115 	stw	r17,4(sp)
81126950:	8009883a 	mov	r4,r16
81126954:	903ee83a 	callr	r18
81126958:	00ffffc4 	movi	r3,-1
8112695c:	10c0031e 	bne	r2,r3,8112696c <_mbrtowc_r+0x74>
81126960:	88000015 	stw	zero,0(r17)
81126964:	00c02284 	movi	r3,138
81126968:	80c00015 	stw	r3,0(r16)
8112696c:	dfc00817 	ldw	ra,32(sp)
81126970:	dc800717 	ldw	r18,28(sp)
81126974:	dc400617 	ldw	r17,24(sp)
81126978:	dc000517 	ldw	r16,20(sp)
8112697c:	dec00904 	addi	sp,sp,36
81126980:	f800283a 	ret
81126984:	11268300 	call	81126830 <__locale_charset>
81126988:	01a04574 	movhi	r6,33045
8112698c:	31ab5904 	addi	r6,r6,-21148
81126990:	dc400115 	stw	r17,4(sp)
81126994:	d8800015 	stw	r2,0(sp)
81126998:	01c00044 	movi	r7,1
8112699c:	000b883a 	mov	r5,zero
811269a0:	8009883a 	mov	r4,r16
811269a4:	903ee83a 	callr	r18
811269a8:	003feb06 	br	81126958 <__reset+0xfb106958>

811269ac <mbrtowc>:
811269ac:	defff704 	addi	sp,sp,-36
811269b0:	00a04574 	movhi	r2,33045
811269b4:	de00012e 	bgeu	sp,et,811269bc <mbrtowc+0x10>
811269b8:	003b68fa 	trap	3
811269bc:	10b52904 	addi	r2,r2,-11100
811269c0:	dc800415 	stw	r18,16(sp)
811269c4:	dc400315 	stw	r17,12(sp)
811269c8:	dfc00815 	stw	ra,32(sp)
811269cc:	dd400715 	stw	r21,28(sp)
811269d0:	dd000615 	stw	r20,24(sp)
811269d4:	dcc00515 	stw	r19,20(sp)
811269d8:	dc000215 	stw	r16,8(sp)
811269dc:	3825883a 	mov	r18,r7
811269e0:	14400017 	ldw	r17,0(r2)
811269e4:	28001c26 	beq	r5,zero,81126a58 <mbrtowc+0xac>
811269e8:	00a04574 	movhi	r2,33045
811269ec:	10b52d04 	addi	r2,r2,-11084
811269f0:	15400017 	ldw	r21,0(r2)
811269f4:	2821883a 	mov	r16,r5
811269f8:	2027883a 	mov	r19,r4
811269fc:	3029883a 	mov	r20,r6
81126a00:	11268300 	call	81126830 <__locale_charset>
81126a04:	d8800015 	stw	r2,0(sp)
81126a08:	dc800115 	stw	r18,4(sp)
81126a0c:	a00f883a 	mov	r7,r20
81126a10:	800d883a 	mov	r6,r16
81126a14:	980b883a 	mov	r5,r19
81126a18:	8809883a 	mov	r4,r17
81126a1c:	a83ee83a 	callr	r21
81126a20:	00ffffc4 	movi	r3,-1
81126a24:	10c0031e 	bne	r2,r3,81126a34 <mbrtowc+0x88>
81126a28:	90000015 	stw	zero,0(r18)
81126a2c:	00c02284 	movi	r3,138
81126a30:	88c00015 	stw	r3,0(r17)
81126a34:	dfc00817 	ldw	ra,32(sp)
81126a38:	dd400717 	ldw	r21,28(sp)
81126a3c:	dd000617 	ldw	r20,24(sp)
81126a40:	dcc00517 	ldw	r19,20(sp)
81126a44:	dc800417 	ldw	r18,16(sp)
81126a48:	dc400317 	ldw	r17,12(sp)
81126a4c:	dc000217 	ldw	r16,8(sp)
81126a50:	dec00904 	addi	sp,sp,36
81126a54:	f800283a 	ret
81126a58:	00a04574 	movhi	r2,33045
81126a5c:	10b52d04 	addi	r2,r2,-11084
81126a60:	14000017 	ldw	r16,0(r2)
81126a64:	11268300 	call	81126830 <__locale_charset>
81126a68:	01a04574 	movhi	r6,33045
81126a6c:	31ab5904 	addi	r6,r6,-21148
81126a70:	dc800115 	stw	r18,4(sp)
81126a74:	d8800015 	stw	r2,0(sp)
81126a78:	01c00044 	movi	r7,1
81126a7c:	000b883a 	mov	r5,zero
81126a80:	8809883a 	mov	r4,r17
81126a84:	803ee83a 	callr	r16
81126a88:	003fe506 	br	81126a20 <__reset+0xfb106a20>

81126a8c <__ascii_mbtowc>:
81126a8c:	deffff04 	addi	sp,sp,-4
81126a90:	de00012e 	bgeu	sp,et,81126a98 <__ascii_mbtowc+0xc>
81126a94:	003b68fa 	trap	3
81126a98:	28000826 	beq	r5,zero,81126abc <__ascii_mbtowc+0x30>
81126a9c:	30000926 	beq	r6,zero,81126ac4 <__ascii_mbtowc+0x38>
81126aa0:	38000b26 	beq	r7,zero,81126ad0 <__ascii_mbtowc+0x44>
81126aa4:	30800003 	ldbu	r2,0(r6)
81126aa8:	28800015 	stw	r2,0(r5)
81126aac:	30800003 	ldbu	r2,0(r6)
81126ab0:	1004c03a 	cmpne	r2,r2,zero
81126ab4:	dec00104 	addi	sp,sp,4
81126ab8:	f800283a 	ret
81126abc:	d80b883a 	mov	r5,sp
81126ac0:	303ff71e 	bne	r6,zero,81126aa0 <__reset+0xfb106aa0>
81126ac4:	0005883a 	mov	r2,zero
81126ac8:	dec00104 	addi	sp,sp,4
81126acc:	f800283a 	ret
81126ad0:	00bfff84 	movi	r2,-2
81126ad4:	003ff706 	br	81126ab4 <__reset+0xfb106ab4>

81126ad8 <_mbtowc_r>:
81126ad8:	00a04574 	movhi	r2,33045
81126adc:	defff804 	addi	sp,sp,-32
81126ae0:	10b52d04 	addi	r2,r2,-11084
81126ae4:	de00012e 	bgeu	sp,et,81126aec <_mbtowc_r+0x14>
81126ae8:	003b68fa 	trap	3
81126aec:	dfc00715 	stw	ra,28(sp)
81126af0:	dc000615 	stw	r16,24(sp)
81126af4:	14000017 	ldw	r16,0(r2)
81126af8:	d9000215 	stw	r4,8(sp)
81126afc:	d9400315 	stw	r5,12(sp)
81126b00:	d9800415 	stw	r6,16(sp)
81126b04:	d9c00515 	stw	r7,20(sp)
81126b08:	11268300 	call	81126830 <__locale_charset>
81126b0c:	d8800015 	stw	r2,0(sp)
81126b10:	d8800817 	ldw	r2,32(sp)
81126b14:	d9c00517 	ldw	r7,20(sp)
81126b18:	d9800417 	ldw	r6,16(sp)
81126b1c:	d9400317 	ldw	r5,12(sp)
81126b20:	d9000217 	ldw	r4,8(sp)
81126b24:	d8800115 	stw	r2,4(sp)
81126b28:	803ee83a 	callr	r16
81126b2c:	dfc00717 	ldw	ra,28(sp)
81126b30:	dc000617 	ldw	r16,24(sp)
81126b34:	dec00804 	addi	sp,sp,32
81126b38:	f800283a 	ret

81126b3c <memchr>:
81126b3c:	208000cc 	andi	r2,r4,3
81126b40:	280f883a 	mov	r7,r5
81126b44:	10003426 	beq	r2,zero,81126c18 <memchr+0xdc>
81126b48:	30bfffc4 	addi	r2,r6,-1
81126b4c:	30001a26 	beq	r6,zero,81126bb8 <memchr+0x7c>
81126b50:	20c00003 	ldbu	r3,0(r4)
81126b54:	29803fcc 	andi	r6,r5,255
81126b58:	30c0051e 	bne	r6,r3,81126b70 <memchr+0x34>
81126b5c:	00001806 	br	81126bc0 <memchr+0x84>
81126b60:	10001526 	beq	r2,zero,81126bb8 <memchr+0x7c>
81126b64:	20c00003 	ldbu	r3,0(r4)
81126b68:	10bfffc4 	addi	r2,r2,-1
81126b6c:	30c01426 	beq	r6,r3,81126bc0 <memchr+0x84>
81126b70:	21000044 	addi	r4,r4,1
81126b74:	20c000cc 	andi	r3,r4,3
81126b78:	183ff91e 	bne	r3,zero,81126b60 <__reset+0xfb106b60>
81126b7c:	020000c4 	movi	r8,3
81126b80:	40801136 	bltu	r8,r2,81126bc8 <memchr+0x8c>
81126b84:	10000c26 	beq	r2,zero,81126bb8 <memchr+0x7c>
81126b88:	20c00003 	ldbu	r3,0(r4)
81126b8c:	29403fcc 	andi	r5,r5,255
81126b90:	28c00b26 	beq	r5,r3,81126bc0 <memchr+0x84>
81126b94:	20c00044 	addi	r3,r4,1
81126b98:	39803fcc 	andi	r6,r7,255
81126b9c:	2089883a 	add	r4,r4,r2
81126ba0:	00000306 	br	81126bb0 <memchr+0x74>
81126ba4:	18c00044 	addi	r3,r3,1
81126ba8:	197fffc3 	ldbu	r5,-1(r3)
81126bac:	31400526 	beq	r6,r5,81126bc4 <memchr+0x88>
81126bb0:	1805883a 	mov	r2,r3
81126bb4:	20fffb1e 	bne	r4,r3,81126ba4 <__reset+0xfb106ba4>
81126bb8:	0005883a 	mov	r2,zero
81126bbc:	f800283a 	ret
81126bc0:	2005883a 	mov	r2,r4
81126bc4:	f800283a 	ret
81126bc8:	28c03fcc 	andi	r3,r5,255
81126bcc:	1812923a 	slli	r9,r3,8
81126bd0:	02ffbff4 	movhi	r11,65279
81126bd4:	02a02074 	movhi	r10,32897
81126bd8:	48d2b03a 	or	r9,r9,r3
81126bdc:	4806943a 	slli	r3,r9,16
81126be0:	5affbfc4 	addi	r11,r11,-257
81126be4:	52a02004 	addi	r10,r10,-32640
81126be8:	48d2b03a 	or	r9,r9,r3
81126bec:	20c00017 	ldw	r3,0(r4)
81126bf0:	48c6f03a 	xor	r3,r9,r3
81126bf4:	1acd883a 	add	r6,r3,r11
81126bf8:	00c6303a 	nor	r3,zero,r3
81126bfc:	30c6703a 	and	r3,r6,r3
81126c00:	1a86703a 	and	r3,r3,r10
81126c04:	183fe01e 	bne	r3,zero,81126b88 <__reset+0xfb106b88>
81126c08:	10bfff04 	addi	r2,r2,-4
81126c0c:	21000104 	addi	r4,r4,4
81126c10:	40bff636 	bltu	r8,r2,81126bec <__reset+0xfb106bec>
81126c14:	003fdb06 	br	81126b84 <__reset+0xfb106b84>
81126c18:	3005883a 	mov	r2,r6
81126c1c:	003fd706 	br	81126b7c <__reset+0xfb106b7c>

81126c20 <memmove>:
81126c20:	2005883a 	mov	r2,r4
81126c24:	29000b2e 	bgeu	r5,r4,81126c54 <memmove+0x34>
81126c28:	298f883a 	add	r7,r5,r6
81126c2c:	21c0092e 	bgeu	r4,r7,81126c54 <memmove+0x34>
81126c30:	2187883a 	add	r3,r4,r6
81126c34:	198bc83a 	sub	r5,r3,r6
81126c38:	30004826 	beq	r6,zero,81126d5c <memmove+0x13c>
81126c3c:	39ffffc4 	addi	r7,r7,-1
81126c40:	39000003 	ldbu	r4,0(r7)
81126c44:	18ffffc4 	addi	r3,r3,-1
81126c48:	19000005 	stb	r4,0(r3)
81126c4c:	28fffb1e 	bne	r5,r3,81126c3c <__reset+0xfb106c3c>
81126c50:	f800283a 	ret
81126c54:	00c003c4 	movi	r3,15
81126c58:	1980412e 	bgeu	r3,r6,81126d60 <memmove+0x140>
81126c5c:	2886b03a 	or	r3,r5,r2
81126c60:	18c000cc 	andi	r3,r3,3
81126c64:	1800401e 	bne	r3,zero,81126d68 <memmove+0x148>
81126c68:	33fffc04 	addi	r15,r6,-16
81126c6c:	781ed13a 	srli	r15,r15,4
81126c70:	28c00104 	addi	r3,r5,4
81126c74:	13400104 	addi	r13,r2,4
81126c78:	781c913a 	slli	r14,r15,4
81126c7c:	2b000204 	addi	r12,r5,8
81126c80:	12c00204 	addi	r11,r2,8
81126c84:	73800504 	addi	r14,r14,20
81126c88:	2a800304 	addi	r10,r5,12
81126c8c:	12400304 	addi	r9,r2,12
81126c90:	2b9d883a 	add	r14,r5,r14
81126c94:	2811883a 	mov	r8,r5
81126c98:	100f883a 	mov	r7,r2
81126c9c:	41000017 	ldw	r4,0(r8)
81126ca0:	39c00404 	addi	r7,r7,16
81126ca4:	18c00404 	addi	r3,r3,16
81126ca8:	393ffc15 	stw	r4,-16(r7)
81126cac:	193ffc17 	ldw	r4,-16(r3)
81126cb0:	6b400404 	addi	r13,r13,16
81126cb4:	5ac00404 	addi	r11,r11,16
81126cb8:	693ffc15 	stw	r4,-16(r13)
81126cbc:	61000017 	ldw	r4,0(r12)
81126cc0:	4a400404 	addi	r9,r9,16
81126cc4:	42000404 	addi	r8,r8,16
81126cc8:	593ffc15 	stw	r4,-16(r11)
81126ccc:	51000017 	ldw	r4,0(r10)
81126cd0:	63000404 	addi	r12,r12,16
81126cd4:	52800404 	addi	r10,r10,16
81126cd8:	493ffc15 	stw	r4,-16(r9)
81126cdc:	1bbfef1e 	bne	r3,r14,81126c9c <__reset+0xfb106c9c>
81126ce0:	79000044 	addi	r4,r15,1
81126ce4:	2008913a 	slli	r4,r4,4
81126ce8:	328003cc 	andi	r10,r6,15
81126cec:	02c000c4 	movi	r11,3
81126cf0:	1107883a 	add	r3,r2,r4
81126cf4:	290b883a 	add	r5,r5,r4
81126cf8:	5a801e2e 	bgeu	r11,r10,81126d74 <memmove+0x154>
81126cfc:	1813883a 	mov	r9,r3
81126d00:	2811883a 	mov	r8,r5
81126d04:	500f883a 	mov	r7,r10
81126d08:	41000017 	ldw	r4,0(r8)
81126d0c:	4a400104 	addi	r9,r9,4
81126d10:	39ffff04 	addi	r7,r7,-4
81126d14:	493fff15 	stw	r4,-4(r9)
81126d18:	42000104 	addi	r8,r8,4
81126d1c:	59fffa36 	bltu	r11,r7,81126d08 <__reset+0xfb106d08>
81126d20:	513fff04 	addi	r4,r10,-4
81126d24:	2008d0ba 	srli	r4,r4,2
81126d28:	318000cc 	andi	r6,r6,3
81126d2c:	21000044 	addi	r4,r4,1
81126d30:	2109883a 	add	r4,r4,r4
81126d34:	2109883a 	add	r4,r4,r4
81126d38:	1907883a 	add	r3,r3,r4
81126d3c:	290b883a 	add	r5,r5,r4
81126d40:	30000b26 	beq	r6,zero,81126d70 <memmove+0x150>
81126d44:	198d883a 	add	r6,r3,r6
81126d48:	29c00003 	ldbu	r7,0(r5)
81126d4c:	18c00044 	addi	r3,r3,1
81126d50:	29400044 	addi	r5,r5,1
81126d54:	19ffffc5 	stb	r7,-1(r3)
81126d58:	19bffb1e 	bne	r3,r6,81126d48 <__reset+0xfb106d48>
81126d5c:	f800283a 	ret
81126d60:	1007883a 	mov	r3,r2
81126d64:	003ff606 	br	81126d40 <__reset+0xfb106d40>
81126d68:	1007883a 	mov	r3,r2
81126d6c:	003ff506 	br	81126d44 <__reset+0xfb106d44>
81126d70:	f800283a 	ret
81126d74:	500d883a 	mov	r6,r10
81126d78:	003ff106 	br	81126d40 <__reset+0xfb106d40>

81126d7c <_Balloc>:
81126d7c:	defffc04 	addi	sp,sp,-16
81126d80:	de00012e 	bgeu	sp,et,81126d88 <_Balloc+0xc>
81126d84:	003b68fa 	trap	3
81126d88:	20801317 	ldw	r2,76(r4)
81126d8c:	dc400115 	stw	r17,4(sp)
81126d90:	dc000015 	stw	r16,0(sp)
81126d94:	dfc00315 	stw	ra,12(sp)
81126d98:	dc800215 	stw	r18,8(sp)
81126d9c:	2023883a 	mov	r17,r4
81126da0:	2821883a 	mov	r16,r5
81126da4:	10000f26 	beq	r2,zero,81126de4 <_Balloc+0x68>
81126da8:	8407883a 	add	r3,r16,r16
81126dac:	18c7883a 	add	r3,r3,r3
81126db0:	10c7883a 	add	r3,r2,r3
81126db4:	18800017 	ldw	r2,0(r3)
81126db8:	10001126 	beq	r2,zero,81126e00 <_Balloc+0x84>
81126dbc:	11000017 	ldw	r4,0(r2)
81126dc0:	19000015 	stw	r4,0(r3)
81126dc4:	10000415 	stw	zero,16(r2)
81126dc8:	10000315 	stw	zero,12(r2)
81126dcc:	dfc00317 	ldw	ra,12(sp)
81126dd0:	dc800217 	ldw	r18,8(sp)
81126dd4:	dc400117 	ldw	r17,4(sp)
81126dd8:	dc000017 	ldw	r16,0(sp)
81126ddc:	dec00404 	addi	sp,sp,16
81126de0:	f800283a 	ret
81126de4:	01800844 	movi	r6,33
81126de8:	01400104 	movi	r5,4
81126dec:	112d2a40 	call	8112d2a4 <_calloc_r>
81126df0:	88801315 	stw	r2,76(r17)
81126df4:	103fec1e 	bne	r2,zero,81126da8 <__reset+0xfb106da8>
81126df8:	0005883a 	mov	r2,zero
81126dfc:	003ff306 	br	81126dcc <__reset+0xfb106dcc>
81126e00:	01400044 	movi	r5,1
81126e04:	2c24983a 	sll	r18,r5,r16
81126e08:	8809883a 	mov	r4,r17
81126e0c:	91800144 	addi	r6,r18,5
81126e10:	318d883a 	add	r6,r6,r6
81126e14:	318d883a 	add	r6,r6,r6
81126e18:	112d2a40 	call	8112d2a4 <_calloc_r>
81126e1c:	103ff626 	beq	r2,zero,81126df8 <__reset+0xfb106df8>
81126e20:	14000115 	stw	r16,4(r2)
81126e24:	14800215 	stw	r18,8(r2)
81126e28:	003fe606 	br	81126dc4 <__reset+0xfb106dc4>

81126e2c <_Bfree>:
81126e2c:	28000826 	beq	r5,zero,81126e50 <_Bfree+0x24>
81126e30:	28c00117 	ldw	r3,4(r5)
81126e34:	20801317 	ldw	r2,76(r4)
81126e38:	18c7883a 	add	r3,r3,r3
81126e3c:	18c7883a 	add	r3,r3,r3
81126e40:	10c5883a 	add	r2,r2,r3
81126e44:	10c00017 	ldw	r3,0(r2)
81126e48:	28c00015 	stw	r3,0(r5)
81126e4c:	11400015 	stw	r5,0(r2)
81126e50:	f800283a 	ret

81126e54 <__multadd>:
81126e54:	defffa04 	addi	sp,sp,-24
81126e58:	de00012e 	bgeu	sp,et,81126e60 <__multadd+0xc>
81126e5c:	003b68fa 	trap	3
81126e60:	0011883a 	mov	r8,zero
81126e64:	dc800315 	stw	r18,12(sp)
81126e68:	dc400215 	stw	r17,8(sp)
81126e6c:	dc000115 	stw	r16,4(sp)
81126e70:	2823883a 	mov	r17,r5
81126e74:	2c000417 	ldw	r16,16(r5)
81126e78:	dfc00515 	stw	ra,20(sp)
81126e7c:	dcc00415 	stw	r19,16(sp)
81126e80:	2025883a 	mov	r18,r4
81126e84:	29400504 	addi	r5,r5,20
81126e88:	28c00017 	ldw	r3,0(r5)
81126e8c:	29400104 	addi	r5,r5,4
81126e90:	42000044 	addi	r8,r8,1
81126e94:	18bfffcc 	andi	r2,r3,65535
81126e98:	1185383a 	mul	r2,r2,r6
81126e9c:	1806d43a 	srli	r3,r3,16
81126ea0:	11cf883a 	add	r7,r2,r7
81126ea4:	3808d43a 	srli	r4,r7,16
81126ea8:	1987383a 	mul	r3,r3,r6
81126eac:	38bfffcc 	andi	r2,r7,65535
81126eb0:	1907883a 	add	r3,r3,r4
81126eb4:	1808943a 	slli	r4,r3,16
81126eb8:	180ed43a 	srli	r7,r3,16
81126ebc:	2085883a 	add	r2,r4,r2
81126ec0:	28bfff15 	stw	r2,-4(r5)
81126ec4:	443ff016 	blt	r8,r16,81126e88 <__reset+0xfb106e88>
81126ec8:	38000926 	beq	r7,zero,81126ef0 <__multadd+0x9c>
81126ecc:	88800217 	ldw	r2,8(r17)
81126ed0:	80800f0e 	bge	r16,r2,81126f10 <__multadd+0xbc>
81126ed4:	80800144 	addi	r2,r16,5
81126ed8:	1085883a 	add	r2,r2,r2
81126edc:	1085883a 	add	r2,r2,r2
81126ee0:	8885883a 	add	r2,r17,r2
81126ee4:	11c00015 	stw	r7,0(r2)
81126ee8:	84000044 	addi	r16,r16,1
81126eec:	8c000415 	stw	r16,16(r17)
81126ef0:	8805883a 	mov	r2,r17
81126ef4:	dfc00517 	ldw	ra,20(sp)
81126ef8:	dcc00417 	ldw	r19,16(sp)
81126efc:	dc800317 	ldw	r18,12(sp)
81126f00:	dc400217 	ldw	r17,8(sp)
81126f04:	dc000117 	ldw	r16,4(sp)
81126f08:	dec00604 	addi	sp,sp,24
81126f0c:	f800283a 	ret
81126f10:	89400117 	ldw	r5,4(r17)
81126f14:	9009883a 	mov	r4,r18
81126f18:	d9c00015 	stw	r7,0(sp)
81126f1c:	29400044 	addi	r5,r5,1
81126f20:	1126d7c0 	call	81126d7c <_Balloc>
81126f24:	89800417 	ldw	r6,16(r17)
81126f28:	89400304 	addi	r5,r17,12
81126f2c:	11000304 	addi	r4,r2,12
81126f30:	31800084 	addi	r6,r6,2
81126f34:	318d883a 	add	r6,r6,r6
81126f38:	318d883a 	add	r6,r6,r6
81126f3c:	1027883a 	mov	r19,r2
81126f40:	111cb4c0 	call	8111cb4c <memcpy>
81126f44:	d9c00017 	ldw	r7,0(sp)
81126f48:	88000a26 	beq	r17,zero,81126f74 <__multadd+0x120>
81126f4c:	88c00117 	ldw	r3,4(r17)
81126f50:	90801317 	ldw	r2,76(r18)
81126f54:	18c7883a 	add	r3,r3,r3
81126f58:	18c7883a 	add	r3,r3,r3
81126f5c:	10c5883a 	add	r2,r2,r3
81126f60:	10c00017 	ldw	r3,0(r2)
81126f64:	88c00015 	stw	r3,0(r17)
81126f68:	14400015 	stw	r17,0(r2)
81126f6c:	9823883a 	mov	r17,r19
81126f70:	003fd806 	br	81126ed4 <__reset+0xfb106ed4>
81126f74:	9823883a 	mov	r17,r19
81126f78:	003fd606 	br	81126ed4 <__reset+0xfb106ed4>

81126f7c <__s2b>:
81126f7c:	defff904 	addi	sp,sp,-28
81126f80:	de00012e 	bgeu	sp,et,81126f88 <__s2b+0xc>
81126f84:	003b68fa 	trap	3
81126f88:	dc400115 	stw	r17,4(sp)
81126f8c:	dc000015 	stw	r16,0(sp)
81126f90:	2023883a 	mov	r17,r4
81126f94:	2821883a 	mov	r16,r5
81126f98:	39000204 	addi	r4,r7,8
81126f9c:	01400244 	movi	r5,9
81126fa0:	dcc00315 	stw	r19,12(sp)
81126fa4:	dc800215 	stw	r18,8(sp)
81126fa8:	dfc00615 	stw	ra,24(sp)
81126fac:	dd400515 	stw	r21,20(sp)
81126fb0:	dd000415 	stw	r20,16(sp)
81126fb4:	3825883a 	mov	r18,r7
81126fb8:	3027883a 	mov	r19,r6
81126fbc:	112f03c0 	call	8112f03c <__divsi3>
81126fc0:	00c00044 	movi	r3,1
81126fc4:	000b883a 	mov	r5,zero
81126fc8:	1880030e 	bge	r3,r2,81126fd8 <__s2b+0x5c>
81126fcc:	18c7883a 	add	r3,r3,r3
81126fd0:	29400044 	addi	r5,r5,1
81126fd4:	18bffd16 	blt	r3,r2,81126fcc <__reset+0xfb106fcc>
81126fd8:	8809883a 	mov	r4,r17
81126fdc:	1126d7c0 	call	81126d7c <_Balloc>
81126fe0:	d8c00717 	ldw	r3,28(sp)
81126fe4:	10c00515 	stw	r3,20(r2)
81126fe8:	00c00044 	movi	r3,1
81126fec:	10c00415 	stw	r3,16(r2)
81126ff0:	00c00244 	movi	r3,9
81126ff4:	1cc0210e 	bge	r3,r19,8112707c <__s2b+0x100>
81126ff8:	80eb883a 	add	r21,r16,r3
81126ffc:	a829883a 	mov	r20,r21
81127000:	84e1883a 	add	r16,r16,r19
81127004:	a1c00007 	ldb	r7,0(r20)
81127008:	01800284 	movi	r6,10
8112700c:	a5000044 	addi	r20,r20,1
81127010:	100b883a 	mov	r5,r2
81127014:	39fff404 	addi	r7,r7,-48
81127018:	8809883a 	mov	r4,r17
8112701c:	1126e540 	call	81126e54 <__multadd>
81127020:	a43ff81e 	bne	r20,r16,81127004 <__reset+0xfb107004>
81127024:	ace1883a 	add	r16,r21,r19
81127028:	843ffe04 	addi	r16,r16,-8
8112702c:	9c800a0e 	bge	r19,r18,81127058 <__s2b+0xdc>
81127030:	94e5c83a 	sub	r18,r18,r19
81127034:	84a5883a 	add	r18,r16,r18
81127038:	81c00007 	ldb	r7,0(r16)
8112703c:	01800284 	movi	r6,10
81127040:	84000044 	addi	r16,r16,1
81127044:	100b883a 	mov	r5,r2
81127048:	39fff404 	addi	r7,r7,-48
8112704c:	8809883a 	mov	r4,r17
81127050:	1126e540 	call	81126e54 <__multadd>
81127054:	84bff81e 	bne	r16,r18,81127038 <__reset+0xfb107038>
81127058:	dfc00617 	ldw	ra,24(sp)
8112705c:	dd400517 	ldw	r21,20(sp)
81127060:	dd000417 	ldw	r20,16(sp)
81127064:	dcc00317 	ldw	r19,12(sp)
81127068:	dc800217 	ldw	r18,8(sp)
8112706c:	dc400117 	ldw	r17,4(sp)
81127070:	dc000017 	ldw	r16,0(sp)
81127074:	dec00704 	addi	sp,sp,28
81127078:	f800283a 	ret
8112707c:	84000284 	addi	r16,r16,10
81127080:	1827883a 	mov	r19,r3
81127084:	003fe906 	br	8112702c <__reset+0xfb10702c>

81127088 <__hi0bits>:
81127088:	20bfffec 	andhi	r2,r4,65535
8112708c:	1000141e 	bne	r2,zero,811270e0 <__hi0bits+0x58>
81127090:	2008943a 	slli	r4,r4,16
81127094:	00800404 	movi	r2,16
81127098:	20ffc02c 	andhi	r3,r4,65280
8112709c:	1800021e 	bne	r3,zero,811270a8 <__hi0bits+0x20>
811270a0:	2008923a 	slli	r4,r4,8
811270a4:	10800204 	addi	r2,r2,8
811270a8:	20fc002c 	andhi	r3,r4,61440
811270ac:	1800021e 	bne	r3,zero,811270b8 <__hi0bits+0x30>
811270b0:	2008913a 	slli	r4,r4,4
811270b4:	10800104 	addi	r2,r2,4
811270b8:	20f0002c 	andhi	r3,r4,49152
811270bc:	1800031e 	bne	r3,zero,811270cc <__hi0bits+0x44>
811270c0:	2109883a 	add	r4,r4,r4
811270c4:	10800084 	addi	r2,r2,2
811270c8:	2109883a 	add	r4,r4,r4
811270cc:	20000316 	blt	r4,zero,811270dc <__hi0bits+0x54>
811270d0:	2110002c 	andhi	r4,r4,16384
811270d4:	2000041e 	bne	r4,zero,811270e8 <__hi0bits+0x60>
811270d8:	00800804 	movi	r2,32
811270dc:	f800283a 	ret
811270e0:	0005883a 	mov	r2,zero
811270e4:	003fec06 	br	81127098 <__reset+0xfb107098>
811270e8:	10800044 	addi	r2,r2,1
811270ec:	f800283a 	ret

811270f0 <__lo0bits>:
811270f0:	20c00017 	ldw	r3,0(r4)
811270f4:	188001cc 	andi	r2,r3,7
811270f8:	10000826 	beq	r2,zero,8112711c <__lo0bits+0x2c>
811270fc:	1880004c 	andi	r2,r3,1
81127100:	1000211e 	bne	r2,zero,81127188 <__lo0bits+0x98>
81127104:	1880008c 	andi	r2,r3,2
81127108:	1000211e 	bne	r2,zero,81127190 <__lo0bits+0xa0>
8112710c:	1806d0ba 	srli	r3,r3,2
81127110:	00800084 	movi	r2,2
81127114:	20c00015 	stw	r3,0(r4)
81127118:	f800283a 	ret
8112711c:	18bfffcc 	andi	r2,r3,65535
81127120:	10001326 	beq	r2,zero,81127170 <__lo0bits+0x80>
81127124:	0005883a 	mov	r2,zero
81127128:	19403fcc 	andi	r5,r3,255
8112712c:	2800021e 	bne	r5,zero,81127138 <__lo0bits+0x48>
81127130:	1806d23a 	srli	r3,r3,8
81127134:	10800204 	addi	r2,r2,8
81127138:	194003cc 	andi	r5,r3,15
8112713c:	2800021e 	bne	r5,zero,81127148 <__lo0bits+0x58>
81127140:	1806d13a 	srli	r3,r3,4
81127144:	10800104 	addi	r2,r2,4
81127148:	194000cc 	andi	r5,r3,3
8112714c:	2800021e 	bne	r5,zero,81127158 <__lo0bits+0x68>
81127150:	1806d0ba 	srli	r3,r3,2
81127154:	10800084 	addi	r2,r2,2
81127158:	1940004c 	andi	r5,r3,1
8112715c:	2800081e 	bne	r5,zero,81127180 <__lo0bits+0x90>
81127160:	1806d07a 	srli	r3,r3,1
81127164:	1800051e 	bne	r3,zero,8112717c <__lo0bits+0x8c>
81127168:	00800804 	movi	r2,32
8112716c:	f800283a 	ret
81127170:	1806d43a 	srli	r3,r3,16
81127174:	00800404 	movi	r2,16
81127178:	003feb06 	br	81127128 <__reset+0xfb107128>
8112717c:	10800044 	addi	r2,r2,1
81127180:	20c00015 	stw	r3,0(r4)
81127184:	f800283a 	ret
81127188:	0005883a 	mov	r2,zero
8112718c:	f800283a 	ret
81127190:	1806d07a 	srli	r3,r3,1
81127194:	00800044 	movi	r2,1
81127198:	20c00015 	stw	r3,0(r4)
8112719c:	f800283a 	ret

811271a0 <__i2b>:
811271a0:	defffd04 	addi	sp,sp,-12
811271a4:	de00012e 	bgeu	sp,et,811271ac <__i2b+0xc>
811271a8:	003b68fa 	trap	3
811271ac:	dc000015 	stw	r16,0(sp)
811271b0:	04000044 	movi	r16,1
811271b4:	dc400115 	stw	r17,4(sp)
811271b8:	2823883a 	mov	r17,r5
811271bc:	800b883a 	mov	r5,r16
811271c0:	dfc00215 	stw	ra,8(sp)
811271c4:	1126d7c0 	call	81126d7c <_Balloc>
811271c8:	14400515 	stw	r17,20(r2)
811271cc:	14000415 	stw	r16,16(r2)
811271d0:	dfc00217 	ldw	ra,8(sp)
811271d4:	dc400117 	ldw	r17,4(sp)
811271d8:	dc000017 	ldw	r16,0(sp)
811271dc:	dec00304 	addi	sp,sp,12
811271e0:	f800283a 	ret

811271e4 <__multiply>:
811271e4:	defffa04 	addi	sp,sp,-24
811271e8:	de00012e 	bgeu	sp,et,811271f0 <__multiply+0xc>
811271ec:	003b68fa 	trap	3
811271f0:	dcc00315 	stw	r19,12(sp)
811271f4:	dc800215 	stw	r18,8(sp)
811271f8:	34c00417 	ldw	r19,16(r6)
811271fc:	2c800417 	ldw	r18,16(r5)
81127200:	dd000415 	stw	r20,16(sp)
81127204:	dc400115 	stw	r17,4(sp)
81127208:	dfc00515 	stw	ra,20(sp)
8112720c:	dc000015 	stw	r16,0(sp)
81127210:	2829883a 	mov	r20,r5
81127214:	3023883a 	mov	r17,r6
81127218:	94c0050e 	bge	r18,r19,81127230 <__multiply+0x4c>
8112721c:	9007883a 	mov	r3,r18
81127220:	3029883a 	mov	r20,r6
81127224:	9825883a 	mov	r18,r19
81127228:	2823883a 	mov	r17,r5
8112722c:	1827883a 	mov	r19,r3
81127230:	a0800217 	ldw	r2,8(r20)
81127234:	94e1883a 	add	r16,r18,r19
81127238:	a1400117 	ldw	r5,4(r20)
8112723c:	1400010e 	bge	r2,r16,81127244 <__multiply+0x60>
81127240:	29400044 	addi	r5,r5,1
81127244:	1126d7c0 	call	81126d7c <_Balloc>
81127248:	8415883a 	add	r10,r16,r16
8112724c:	12c00504 	addi	r11,r2,20
81127250:	5295883a 	add	r10,r10,r10
81127254:	5a95883a 	add	r10,r11,r10
81127258:	5807883a 	mov	r3,r11
8112725c:	5a80032e 	bgeu	r11,r10,8112726c <__multiply+0x88>
81127260:	18000015 	stw	zero,0(r3)
81127264:	18c00104 	addi	r3,r3,4
81127268:	1abffd36 	bltu	r3,r10,81127260 <__reset+0xfb107260>
8112726c:	9ce7883a 	add	r19,r19,r19
81127270:	94a5883a 	add	r18,r18,r18
81127274:	89800504 	addi	r6,r17,20
81127278:	9ce7883a 	add	r19,r19,r19
8112727c:	a3400504 	addi	r13,r20,20
81127280:	94a5883a 	add	r18,r18,r18
81127284:	34d9883a 	add	r12,r6,r19
81127288:	6c93883a 	add	r9,r13,r18
8112728c:	3300422e 	bgeu	r6,r12,81127398 <__multiply+0x1b4>
81127290:	37c00017 	ldw	ra,0(r6)
81127294:	fbffffcc 	andi	r15,ra,65535
81127298:	78001b26 	beq	r15,zero,81127308 <__multiply+0x124>
8112729c:	5811883a 	mov	r8,r11
811272a0:	681d883a 	mov	r14,r13
811272a4:	000f883a 	mov	r7,zero
811272a8:	71000017 	ldw	r4,0(r14)
811272ac:	40c00017 	ldw	r3,0(r8)
811272b0:	73800104 	addi	r14,r14,4
811272b4:	217fffcc 	andi	r5,r4,65535
811272b8:	2bcb383a 	mul	r5,r5,r15
811272bc:	2008d43a 	srli	r4,r4,16
811272c0:	1c7fffcc 	andi	r17,r3,65535
811272c4:	2c4b883a 	add	r5,r5,r17
811272c8:	29cb883a 	add	r5,r5,r7
811272cc:	23c9383a 	mul	r4,r4,r15
811272d0:	1806d43a 	srli	r3,r3,16
811272d4:	280ed43a 	srli	r7,r5,16
811272d8:	297fffcc 	andi	r5,r5,65535
811272dc:	20c7883a 	add	r3,r4,r3
811272e0:	19c7883a 	add	r3,r3,r7
811272e4:	1808943a 	slli	r4,r3,16
811272e8:	4023883a 	mov	r17,r8
811272ec:	180ed43a 	srli	r7,r3,16
811272f0:	214ab03a 	or	r5,r4,r5
811272f4:	41400015 	stw	r5,0(r8)
811272f8:	42000104 	addi	r8,r8,4
811272fc:	727fea36 	bltu	r14,r9,811272a8 <__reset+0xfb1072a8>
81127300:	89c00115 	stw	r7,4(r17)
81127304:	37c00017 	ldw	ra,0(r6)
81127308:	f83ed43a 	srli	ra,ra,16
8112730c:	f8001f26 	beq	ra,zero,8112738c <__multiply+0x1a8>
81127310:	58c00017 	ldw	r3,0(r11)
81127314:	681d883a 	mov	r14,r13
81127318:	581f883a 	mov	r15,r11
8112731c:	1811883a 	mov	r8,r3
81127320:	5825883a 	mov	r18,r11
81127324:	000f883a 	mov	r7,zero
81127328:	00000106 	br	81127330 <__multiply+0x14c>
8112732c:	8825883a 	mov	r18,r17
81127330:	7140000b 	ldhu	r5,0(r14)
81127334:	4010d43a 	srli	r8,r8,16
81127338:	193fffcc 	andi	r4,r3,65535
8112733c:	2fcb383a 	mul	r5,r5,ra
81127340:	7bc00104 	addi	r15,r15,4
81127344:	73800104 	addi	r14,r14,4
81127348:	2a0b883a 	add	r5,r5,r8
8112734c:	29cb883a 	add	r5,r5,r7
81127350:	2806943a 	slli	r3,r5,16
81127354:	94400104 	addi	r17,r18,4
81127358:	280ad43a 	srli	r5,r5,16
8112735c:	1908b03a 	or	r4,r3,r4
81127360:	793fff15 	stw	r4,-4(r15)
81127364:	70ffff17 	ldw	r3,-4(r14)
81127368:	8a000017 	ldw	r8,0(r17)
8112736c:	1806d43a 	srli	r3,r3,16
81127370:	413fffcc 	andi	r4,r8,65535
81127374:	1fc7383a 	mul	r3,r3,ra
81127378:	1907883a 	add	r3,r3,r4
8112737c:	1947883a 	add	r3,r3,r5
81127380:	180ed43a 	srli	r7,r3,16
81127384:	727fe936 	bltu	r14,r9,8112732c <__reset+0xfb10732c>
81127388:	90c00115 	stw	r3,4(r18)
8112738c:	31800104 	addi	r6,r6,4
81127390:	5ac00104 	addi	r11,r11,4
81127394:	333fbe36 	bltu	r6,r12,81127290 <__reset+0xfb107290>
81127398:	0400090e 	bge	zero,r16,811273c0 <__multiply+0x1dc>
8112739c:	50ffff17 	ldw	r3,-4(r10)
811273a0:	52bfff04 	addi	r10,r10,-4
811273a4:	18000326 	beq	r3,zero,811273b4 <__multiply+0x1d0>
811273a8:	00000506 	br	811273c0 <__multiply+0x1dc>
811273ac:	50c00017 	ldw	r3,0(r10)
811273b0:	1800031e 	bne	r3,zero,811273c0 <__multiply+0x1dc>
811273b4:	843fffc4 	addi	r16,r16,-1
811273b8:	52bfff04 	addi	r10,r10,-4
811273bc:	803ffb1e 	bne	r16,zero,811273ac <__reset+0xfb1073ac>
811273c0:	14000415 	stw	r16,16(r2)
811273c4:	dfc00517 	ldw	ra,20(sp)
811273c8:	dd000417 	ldw	r20,16(sp)
811273cc:	dcc00317 	ldw	r19,12(sp)
811273d0:	dc800217 	ldw	r18,8(sp)
811273d4:	dc400117 	ldw	r17,4(sp)
811273d8:	dc000017 	ldw	r16,0(sp)
811273dc:	dec00604 	addi	sp,sp,24
811273e0:	f800283a 	ret

811273e4 <__pow5mult>:
811273e4:	defffa04 	addi	sp,sp,-24
811273e8:	de00012e 	bgeu	sp,et,811273f0 <__pow5mult+0xc>
811273ec:	003b68fa 	trap	3
811273f0:	308000cc 	andi	r2,r6,3
811273f4:	dcc00315 	stw	r19,12(sp)
811273f8:	dc000015 	stw	r16,0(sp)
811273fc:	dfc00515 	stw	ra,20(sp)
81127400:	dd000415 	stw	r20,16(sp)
81127404:	dc800215 	stw	r18,8(sp)
81127408:	dc400115 	stw	r17,4(sp)
8112740c:	3021883a 	mov	r16,r6
81127410:	2027883a 	mov	r19,r4
81127414:	10002f1e 	bne	r2,zero,811274d4 <__pow5mult+0xf0>
81127418:	2825883a 	mov	r18,r5
8112741c:	8021d0ba 	srai	r16,r16,2
81127420:	80001a26 	beq	r16,zero,8112748c <__pow5mult+0xa8>
81127424:	9c401217 	ldw	r17,72(r19)
81127428:	8800061e 	bne	r17,zero,81127444 <__pow5mult+0x60>
8112742c:	00003406 	br	81127500 <__pow5mult+0x11c>
81127430:	8021d07a 	srai	r16,r16,1
81127434:	80001526 	beq	r16,zero,8112748c <__pow5mult+0xa8>
81127438:	88800017 	ldw	r2,0(r17)
8112743c:	10001c26 	beq	r2,zero,811274b0 <__pow5mult+0xcc>
81127440:	1023883a 	mov	r17,r2
81127444:	8080004c 	andi	r2,r16,1
81127448:	103ff926 	beq	r2,zero,81127430 <__reset+0xfb107430>
8112744c:	880d883a 	mov	r6,r17
81127450:	900b883a 	mov	r5,r18
81127454:	9809883a 	mov	r4,r19
81127458:	11271e40 	call	811271e4 <__multiply>
8112745c:	90001b26 	beq	r18,zero,811274cc <__pow5mult+0xe8>
81127460:	91000117 	ldw	r4,4(r18)
81127464:	98c01317 	ldw	r3,76(r19)
81127468:	8021d07a 	srai	r16,r16,1
8112746c:	2109883a 	add	r4,r4,r4
81127470:	2109883a 	add	r4,r4,r4
81127474:	1907883a 	add	r3,r3,r4
81127478:	19000017 	ldw	r4,0(r3)
8112747c:	91000015 	stw	r4,0(r18)
81127480:	1c800015 	stw	r18,0(r3)
81127484:	1025883a 	mov	r18,r2
81127488:	803feb1e 	bne	r16,zero,81127438 <__reset+0xfb107438>
8112748c:	9005883a 	mov	r2,r18
81127490:	dfc00517 	ldw	ra,20(sp)
81127494:	dd000417 	ldw	r20,16(sp)
81127498:	dcc00317 	ldw	r19,12(sp)
8112749c:	dc800217 	ldw	r18,8(sp)
811274a0:	dc400117 	ldw	r17,4(sp)
811274a4:	dc000017 	ldw	r16,0(sp)
811274a8:	dec00604 	addi	sp,sp,24
811274ac:	f800283a 	ret
811274b0:	880d883a 	mov	r6,r17
811274b4:	880b883a 	mov	r5,r17
811274b8:	9809883a 	mov	r4,r19
811274bc:	11271e40 	call	811271e4 <__multiply>
811274c0:	88800015 	stw	r2,0(r17)
811274c4:	10000015 	stw	zero,0(r2)
811274c8:	003fdd06 	br	81127440 <__reset+0xfb107440>
811274cc:	1025883a 	mov	r18,r2
811274d0:	003fd706 	br	81127430 <__reset+0xfb107430>
811274d4:	10bfffc4 	addi	r2,r2,-1
811274d8:	1085883a 	add	r2,r2,r2
811274dc:	00e04574 	movhi	r3,33045
811274e0:	18eb8304 	addi	r3,r3,-20980
811274e4:	1085883a 	add	r2,r2,r2
811274e8:	1885883a 	add	r2,r3,r2
811274ec:	11800017 	ldw	r6,0(r2)
811274f0:	000f883a 	mov	r7,zero
811274f4:	1126e540 	call	81126e54 <__multadd>
811274f8:	1025883a 	mov	r18,r2
811274fc:	003fc706 	br	8112741c <__reset+0xfb10741c>
81127500:	05000044 	movi	r20,1
81127504:	a00b883a 	mov	r5,r20
81127508:	9809883a 	mov	r4,r19
8112750c:	1126d7c0 	call	81126d7c <_Balloc>
81127510:	1023883a 	mov	r17,r2
81127514:	00809c44 	movi	r2,625
81127518:	88800515 	stw	r2,20(r17)
8112751c:	8d000415 	stw	r20,16(r17)
81127520:	9c401215 	stw	r17,72(r19)
81127524:	88000015 	stw	zero,0(r17)
81127528:	003fc606 	br	81127444 <__reset+0xfb107444>

8112752c <__lshift>:
8112752c:	defff904 	addi	sp,sp,-28
81127530:	de00012e 	bgeu	sp,et,81127538 <__lshift+0xc>
81127534:	003b68fa 	trap	3
81127538:	dd400515 	stw	r21,20(sp)
8112753c:	dcc00315 	stw	r19,12(sp)
81127540:	302bd17a 	srai	r21,r6,5
81127544:	2cc00417 	ldw	r19,16(r5)
81127548:	28800217 	ldw	r2,8(r5)
8112754c:	dd000415 	stw	r20,16(sp)
81127550:	ace7883a 	add	r19,r21,r19
81127554:	dc800215 	stw	r18,8(sp)
81127558:	dc400115 	stw	r17,4(sp)
8112755c:	dc000015 	stw	r16,0(sp)
81127560:	dfc00615 	stw	ra,24(sp)
81127564:	9c000044 	addi	r16,r19,1
81127568:	2823883a 	mov	r17,r5
8112756c:	3029883a 	mov	r20,r6
81127570:	2025883a 	mov	r18,r4
81127574:	29400117 	ldw	r5,4(r5)
81127578:	1400030e 	bge	r2,r16,81127588 <__lshift+0x5c>
8112757c:	1085883a 	add	r2,r2,r2
81127580:	29400044 	addi	r5,r5,1
81127584:	143ffd16 	blt	r2,r16,8112757c <__reset+0xfb10757c>
81127588:	9009883a 	mov	r4,r18
8112758c:	1126d7c0 	call	81126d7c <_Balloc>
81127590:	10c00504 	addi	r3,r2,20
81127594:	0540070e 	bge	zero,r21,811275b4 <__lshift+0x88>
81127598:	ad6b883a 	add	r21,r21,r21
8112759c:	ad6b883a 	add	r21,r21,r21
811275a0:	1809883a 	mov	r4,r3
811275a4:	1d47883a 	add	r3,r3,r21
811275a8:	20000015 	stw	zero,0(r4)
811275ac:	21000104 	addi	r4,r4,4
811275b0:	193ffd1e 	bne	r3,r4,811275a8 <__reset+0xfb1075a8>
811275b4:	8a000417 	ldw	r8,16(r17)
811275b8:	89000504 	addi	r4,r17,20
811275bc:	a18007cc 	andi	r6,r20,31
811275c0:	4211883a 	add	r8,r8,r8
811275c4:	4211883a 	add	r8,r8,r8
811275c8:	2211883a 	add	r8,r4,r8
811275cc:	30002326 	beq	r6,zero,8112765c <__lshift+0x130>
811275d0:	02400804 	movi	r9,32
811275d4:	4993c83a 	sub	r9,r9,r6
811275d8:	000b883a 	mov	r5,zero
811275dc:	21c00017 	ldw	r7,0(r4)
811275e0:	1815883a 	mov	r10,r3
811275e4:	18c00104 	addi	r3,r3,4
811275e8:	398e983a 	sll	r7,r7,r6
811275ec:	21000104 	addi	r4,r4,4
811275f0:	394ab03a 	or	r5,r7,r5
811275f4:	197fff15 	stw	r5,-4(r3)
811275f8:	217fff17 	ldw	r5,-4(r4)
811275fc:	2a4ad83a 	srl	r5,r5,r9
81127600:	223ff636 	bltu	r4,r8,811275dc <__reset+0xfb1075dc>
81127604:	51400115 	stw	r5,4(r10)
81127608:	28001a1e 	bne	r5,zero,81127674 <__lshift+0x148>
8112760c:	843fffc4 	addi	r16,r16,-1
81127610:	14000415 	stw	r16,16(r2)
81127614:	88000826 	beq	r17,zero,81127638 <__lshift+0x10c>
81127618:	89000117 	ldw	r4,4(r17)
8112761c:	90c01317 	ldw	r3,76(r18)
81127620:	2109883a 	add	r4,r4,r4
81127624:	2109883a 	add	r4,r4,r4
81127628:	1907883a 	add	r3,r3,r4
8112762c:	19000017 	ldw	r4,0(r3)
81127630:	89000015 	stw	r4,0(r17)
81127634:	1c400015 	stw	r17,0(r3)
81127638:	dfc00617 	ldw	ra,24(sp)
8112763c:	dd400517 	ldw	r21,20(sp)
81127640:	dd000417 	ldw	r20,16(sp)
81127644:	dcc00317 	ldw	r19,12(sp)
81127648:	dc800217 	ldw	r18,8(sp)
8112764c:	dc400117 	ldw	r17,4(sp)
81127650:	dc000017 	ldw	r16,0(sp)
81127654:	dec00704 	addi	sp,sp,28
81127658:	f800283a 	ret
8112765c:	21400017 	ldw	r5,0(r4)
81127660:	18c00104 	addi	r3,r3,4
81127664:	21000104 	addi	r4,r4,4
81127668:	197fff15 	stw	r5,-4(r3)
8112766c:	223ffb36 	bltu	r4,r8,8112765c <__reset+0xfb10765c>
81127670:	003fe606 	br	8112760c <__reset+0xfb10760c>
81127674:	9c000084 	addi	r16,r19,2
81127678:	003fe406 	br	8112760c <__reset+0xfb10760c>

8112767c <__mcmp>:
8112767c:	20800417 	ldw	r2,16(r4)
81127680:	28c00417 	ldw	r3,16(r5)
81127684:	10c5c83a 	sub	r2,r2,r3
81127688:	1000111e 	bne	r2,zero,811276d0 <__mcmp+0x54>
8112768c:	18c7883a 	add	r3,r3,r3
81127690:	18c7883a 	add	r3,r3,r3
81127694:	21000504 	addi	r4,r4,20
81127698:	29400504 	addi	r5,r5,20
8112769c:	20c5883a 	add	r2,r4,r3
811276a0:	28cb883a 	add	r5,r5,r3
811276a4:	00000106 	br	811276ac <__mcmp+0x30>
811276a8:	20800a2e 	bgeu	r4,r2,811276d4 <__mcmp+0x58>
811276ac:	10bfff04 	addi	r2,r2,-4
811276b0:	297fff04 	addi	r5,r5,-4
811276b4:	11800017 	ldw	r6,0(r2)
811276b8:	28c00017 	ldw	r3,0(r5)
811276bc:	30fffa26 	beq	r6,r3,811276a8 <__reset+0xfb1076a8>
811276c0:	30c00236 	bltu	r6,r3,811276cc <__mcmp+0x50>
811276c4:	00800044 	movi	r2,1
811276c8:	f800283a 	ret
811276cc:	00bfffc4 	movi	r2,-1
811276d0:	f800283a 	ret
811276d4:	0005883a 	mov	r2,zero
811276d8:	f800283a 	ret

811276dc <__mdiff>:
811276dc:	defffa04 	addi	sp,sp,-24
811276e0:	de00012e 	bgeu	sp,et,811276e8 <__mdiff+0xc>
811276e4:	003b68fa 	trap	3
811276e8:	28c00417 	ldw	r3,16(r5)
811276ec:	30800417 	ldw	r2,16(r6)
811276f0:	dcc00315 	stw	r19,12(sp)
811276f4:	dc800215 	stw	r18,8(sp)
811276f8:	dfc00515 	stw	ra,20(sp)
811276fc:	dd000415 	stw	r20,16(sp)
81127700:	dc400115 	stw	r17,4(sp)
81127704:	dc000015 	stw	r16,0(sp)
81127708:	1887c83a 	sub	r3,r3,r2
8112770c:	2825883a 	mov	r18,r5
81127710:	3027883a 	mov	r19,r6
81127714:	1800141e 	bne	r3,zero,81127768 <__mdiff+0x8c>
81127718:	1085883a 	add	r2,r2,r2
8112771c:	1085883a 	add	r2,r2,r2
81127720:	2a000504 	addi	r8,r5,20
81127724:	34000504 	addi	r16,r6,20
81127728:	4087883a 	add	r3,r8,r2
8112772c:	8085883a 	add	r2,r16,r2
81127730:	00000106 	br	81127738 <__mdiff+0x5c>
81127734:	40c0592e 	bgeu	r8,r3,8112789c <__mdiff+0x1c0>
81127738:	18ffff04 	addi	r3,r3,-4
8112773c:	10bfff04 	addi	r2,r2,-4
81127740:	19c00017 	ldw	r7,0(r3)
81127744:	11400017 	ldw	r5,0(r2)
81127748:	397ffa26 	beq	r7,r5,81127734 <__reset+0xfb107734>
8112774c:	3940592e 	bgeu	r7,r5,811278b4 <__mdiff+0x1d8>
81127750:	9005883a 	mov	r2,r18
81127754:	4023883a 	mov	r17,r8
81127758:	9825883a 	mov	r18,r19
8112775c:	05000044 	movi	r20,1
81127760:	1027883a 	mov	r19,r2
81127764:	00000406 	br	81127778 <__mdiff+0x9c>
81127768:	18005616 	blt	r3,zero,811278c4 <__mdiff+0x1e8>
8112776c:	34400504 	addi	r17,r6,20
81127770:	2c000504 	addi	r16,r5,20
81127774:	0029883a 	mov	r20,zero
81127778:	91400117 	ldw	r5,4(r18)
8112777c:	1126d7c0 	call	81126d7c <_Balloc>
81127780:	92400417 	ldw	r9,16(r18)
81127784:	9b000417 	ldw	r12,16(r19)
81127788:	12c00504 	addi	r11,r2,20
8112778c:	4a51883a 	add	r8,r9,r9
81127790:	6319883a 	add	r12,r12,r12
81127794:	4211883a 	add	r8,r8,r8
81127798:	6319883a 	add	r12,r12,r12
8112779c:	15000315 	stw	r20,12(r2)
811277a0:	8211883a 	add	r8,r16,r8
811277a4:	8b19883a 	add	r12,r17,r12
811277a8:	0007883a 	mov	r3,zero
811277ac:	81400017 	ldw	r5,0(r16)
811277b0:	89c00017 	ldw	r7,0(r17)
811277b4:	59800104 	addi	r6,r11,4
811277b8:	293fffcc 	andi	r4,r5,65535
811277bc:	20c7883a 	add	r3,r4,r3
811277c0:	393fffcc 	andi	r4,r7,65535
811277c4:	1909c83a 	sub	r4,r3,r4
811277c8:	280ad43a 	srli	r5,r5,16
811277cc:	380ed43a 	srli	r7,r7,16
811277d0:	2007d43a 	srai	r3,r4,16
811277d4:	213fffcc 	andi	r4,r4,65535
811277d8:	29cbc83a 	sub	r5,r5,r7
811277dc:	28c7883a 	add	r3,r5,r3
811277e0:	180a943a 	slli	r5,r3,16
811277e4:	8c400104 	addi	r17,r17,4
811277e8:	84000104 	addi	r16,r16,4
811277ec:	2908b03a 	or	r4,r5,r4
811277f0:	59000015 	stw	r4,0(r11)
811277f4:	1807d43a 	srai	r3,r3,16
811277f8:	3015883a 	mov	r10,r6
811277fc:	3017883a 	mov	r11,r6
81127800:	8b3fea36 	bltu	r17,r12,811277ac <__reset+0xfb1077ac>
81127804:	8200162e 	bgeu	r16,r8,81127860 <__mdiff+0x184>
81127808:	8017883a 	mov	r11,r16
8112780c:	59400017 	ldw	r5,0(r11)
81127810:	31800104 	addi	r6,r6,4
81127814:	5ac00104 	addi	r11,r11,4
81127818:	293fffcc 	andi	r4,r5,65535
8112781c:	20c7883a 	add	r3,r4,r3
81127820:	280ed43a 	srli	r7,r5,16
81127824:	180bd43a 	srai	r5,r3,16
81127828:	193fffcc 	andi	r4,r3,65535
8112782c:	3947883a 	add	r3,r7,r5
81127830:	180a943a 	slli	r5,r3,16
81127834:	1807d43a 	srai	r3,r3,16
81127838:	2908b03a 	or	r4,r5,r4
8112783c:	313fff15 	stw	r4,-4(r6)
81127840:	5a3ff236 	bltu	r11,r8,8112780c <__reset+0xfb10780c>
81127844:	0406303a 	nor	r3,zero,r16
81127848:	1a07883a 	add	r3,r3,r8
8112784c:	1806d0ba 	srli	r3,r3,2
81127850:	18c00044 	addi	r3,r3,1
81127854:	18c7883a 	add	r3,r3,r3
81127858:	18c7883a 	add	r3,r3,r3
8112785c:	50d5883a 	add	r10,r10,r3
81127860:	50ffff04 	addi	r3,r10,-4
81127864:	2000041e 	bne	r4,zero,81127878 <__mdiff+0x19c>
81127868:	18ffff04 	addi	r3,r3,-4
8112786c:	19000017 	ldw	r4,0(r3)
81127870:	4a7fffc4 	addi	r9,r9,-1
81127874:	203ffc26 	beq	r4,zero,81127868 <__reset+0xfb107868>
81127878:	12400415 	stw	r9,16(r2)
8112787c:	dfc00517 	ldw	ra,20(sp)
81127880:	dd000417 	ldw	r20,16(sp)
81127884:	dcc00317 	ldw	r19,12(sp)
81127888:	dc800217 	ldw	r18,8(sp)
8112788c:	dc400117 	ldw	r17,4(sp)
81127890:	dc000017 	ldw	r16,0(sp)
81127894:	dec00604 	addi	sp,sp,24
81127898:	f800283a 	ret
8112789c:	000b883a 	mov	r5,zero
811278a0:	1126d7c0 	call	81126d7c <_Balloc>
811278a4:	00c00044 	movi	r3,1
811278a8:	10c00415 	stw	r3,16(r2)
811278ac:	10000515 	stw	zero,20(r2)
811278b0:	003ff206 	br	8112787c <__reset+0xfb10787c>
811278b4:	8023883a 	mov	r17,r16
811278b8:	0029883a 	mov	r20,zero
811278bc:	4021883a 	mov	r16,r8
811278c0:	003fad06 	br	81127778 <__reset+0xfb107778>
811278c4:	9005883a 	mov	r2,r18
811278c8:	94400504 	addi	r17,r18,20
811278cc:	9c000504 	addi	r16,r19,20
811278d0:	9825883a 	mov	r18,r19
811278d4:	05000044 	movi	r20,1
811278d8:	1027883a 	mov	r19,r2
811278dc:	003fa606 	br	81127778 <__reset+0xfb107778>

811278e0 <__ulp>:
811278e0:	295ffc2c 	andhi	r5,r5,32752
811278e4:	00bf3034 	movhi	r2,64704
811278e8:	2887883a 	add	r3,r5,r2
811278ec:	00c0020e 	bge	zero,r3,811278f8 <__ulp+0x18>
811278f0:	0005883a 	mov	r2,zero
811278f4:	f800283a 	ret
811278f8:	00c7c83a 	sub	r3,zero,r3
811278fc:	1807d53a 	srai	r3,r3,20
81127900:	008004c4 	movi	r2,19
81127904:	10c00b0e 	bge	r2,r3,81127934 <__ulp+0x54>
81127908:	18bffb04 	addi	r2,r3,-20
8112790c:	01000784 	movi	r4,30
81127910:	0007883a 	mov	r3,zero
81127914:	20800516 	blt	r4,r2,8112792c <__ulp+0x4c>
81127918:	010007c4 	movi	r4,31
8112791c:	2089c83a 	sub	r4,r4,r2
81127920:	00800044 	movi	r2,1
81127924:	1104983a 	sll	r2,r2,r4
81127928:	f800283a 	ret
8112792c:	00800044 	movi	r2,1
81127930:	f800283a 	ret
81127934:	01400234 	movhi	r5,8
81127938:	28c7d83a 	sra	r3,r5,r3
8112793c:	0005883a 	mov	r2,zero
81127940:	f800283a 	ret

81127944 <__b2d>:
81127944:	defffa04 	addi	sp,sp,-24
81127948:	de00012e 	bgeu	sp,et,81127950 <__b2d+0xc>
8112794c:	003b68fa 	trap	3
81127950:	dc000015 	stw	r16,0(sp)
81127954:	24000417 	ldw	r16,16(r4)
81127958:	dc400115 	stw	r17,4(sp)
8112795c:	24400504 	addi	r17,r4,20
81127960:	8421883a 	add	r16,r16,r16
81127964:	8421883a 	add	r16,r16,r16
81127968:	8c21883a 	add	r16,r17,r16
8112796c:	dc800215 	stw	r18,8(sp)
81127970:	84bfff17 	ldw	r18,-4(r16)
81127974:	dd000415 	stw	r20,16(sp)
81127978:	dcc00315 	stw	r19,12(sp)
8112797c:	9009883a 	mov	r4,r18
81127980:	2829883a 	mov	r20,r5
81127984:	dfc00515 	stw	ra,20(sp)
81127988:	11270880 	call	81127088 <__hi0bits>
8112798c:	00c00804 	movi	r3,32
81127990:	1889c83a 	sub	r4,r3,r2
81127994:	a1000015 	stw	r4,0(r20)
81127998:	01000284 	movi	r4,10
8112799c:	84ffff04 	addi	r19,r16,-4
811279a0:	20801216 	blt	r4,r2,811279ec <__b2d+0xa8>
811279a4:	018002c4 	movi	r6,11
811279a8:	308dc83a 	sub	r6,r6,r2
811279ac:	9186d83a 	srl	r3,r18,r6
811279b0:	18cffc34 	orhi	r3,r3,16368
811279b4:	8cc0212e 	bgeu	r17,r19,81127a3c <__b2d+0xf8>
811279b8:	813ffe17 	ldw	r4,-8(r16)
811279bc:	218cd83a 	srl	r6,r4,r6
811279c0:	10800544 	addi	r2,r2,21
811279c4:	9084983a 	sll	r2,r18,r2
811279c8:	1184b03a 	or	r2,r2,r6
811279cc:	dfc00517 	ldw	ra,20(sp)
811279d0:	dd000417 	ldw	r20,16(sp)
811279d4:	dcc00317 	ldw	r19,12(sp)
811279d8:	dc800217 	ldw	r18,8(sp)
811279dc:	dc400117 	ldw	r17,4(sp)
811279e0:	dc000017 	ldw	r16,0(sp)
811279e4:	dec00604 	addi	sp,sp,24
811279e8:	f800283a 	ret
811279ec:	8cc00f2e 	bgeu	r17,r19,81127a2c <__b2d+0xe8>
811279f0:	117ffd44 	addi	r5,r2,-11
811279f4:	80bffe17 	ldw	r2,-8(r16)
811279f8:	28000e26 	beq	r5,zero,81127a34 <__b2d+0xf0>
811279fc:	1949c83a 	sub	r4,r3,r5
81127a00:	9164983a 	sll	r18,r18,r5
81127a04:	1106d83a 	srl	r3,r2,r4
81127a08:	81bffe04 	addi	r6,r16,-8
81127a0c:	948ffc34 	orhi	r18,r18,16368
81127a10:	90c6b03a 	or	r3,r18,r3
81127a14:	89800e2e 	bgeu	r17,r6,81127a50 <__b2d+0x10c>
81127a18:	81bffd17 	ldw	r6,-12(r16)
81127a1c:	1144983a 	sll	r2,r2,r5
81127a20:	310ad83a 	srl	r5,r6,r4
81127a24:	2884b03a 	or	r2,r5,r2
81127a28:	003fe806 	br	811279cc <__reset+0xfb1079cc>
81127a2c:	10bffd44 	addi	r2,r2,-11
81127a30:	1000041e 	bne	r2,zero,81127a44 <__b2d+0x100>
81127a34:	90cffc34 	orhi	r3,r18,16368
81127a38:	003fe406 	br	811279cc <__reset+0xfb1079cc>
81127a3c:	000d883a 	mov	r6,zero
81127a40:	003fdf06 	br	811279c0 <__reset+0xfb1079c0>
81127a44:	90a4983a 	sll	r18,r18,r2
81127a48:	0005883a 	mov	r2,zero
81127a4c:	003ff906 	br	81127a34 <__reset+0xfb107a34>
81127a50:	1144983a 	sll	r2,r2,r5
81127a54:	003fdd06 	br	811279cc <__reset+0xfb1079cc>

81127a58 <__d2b>:
81127a58:	defff804 	addi	sp,sp,-32
81127a5c:	de00012e 	bgeu	sp,et,81127a64 <__d2b+0xc>
81127a60:	003b68fa 	trap	3
81127a64:	dc000215 	stw	r16,8(sp)
81127a68:	3021883a 	mov	r16,r6
81127a6c:	dc400315 	stw	r17,12(sp)
81127a70:	8022907a 	slli	r17,r16,1
81127a74:	dd000615 	stw	r20,24(sp)
81127a78:	2829883a 	mov	r20,r5
81127a7c:	01400044 	movi	r5,1
81127a80:	dcc00515 	stw	r19,20(sp)
81127a84:	dc800415 	stw	r18,16(sp)
81127a88:	dfc00715 	stw	ra,28(sp)
81127a8c:	3825883a 	mov	r18,r7
81127a90:	8822d57a 	srli	r17,r17,21
81127a94:	1126d7c0 	call	81126d7c <_Balloc>
81127a98:	1027883a 	mov	r19,r2
81127a9c:	00800434 	movhi	r2,16
81127aa0:	10bfffc4 	addi	r2,r2,-1
81127aa4:	808c703a 	and	r6,r16,r2
81127aa8:	88000126 	beq	r17,zero,81127ab0 <__d2b+0x58>
81127aac:	31800434 	orhi	r6,r6,16
81127ab0:	d9800015 	stw	r6,0(sp)
81127ab4:	a0002426 	beq	r20,zero,81127b48 <__d2b+0xf0>
81127ab8:	d9000104 	addi	r4,sp,4
81127abc:	dd000115 	stw	r20,4(sp)
81127ac0:	11270f00 	call	811270f0 <__lo0bits>
81127ac4:	d8c00017 	ldw	r3,0(sp)
81127ac8:	10002f1e 	bne	r2,zero,81127b88 <__d2b+0x130>
81127acc:	d9000117 	ldw	r4,4(sp)
81127ad0:	99000515 	stw	r4,20(r19)
81127ad4:	1821003a 	cmpeq	r16,r3,zero
81127ad8:	01000084 	movi	r4,2
81127adc:	2421c83a 	sub	r16,r4,r16
81127ae0:	98c00615 	stw	r3,24(r19)
81127ae4:	9c000415 	stw	r16,16(r19)
81127ae8:	88001f1e 	bne	r17,zero,81127b68 <__d2b+0x110>
81127aec:	10bef384 	addi	r2,r2,-1074
81127af0:	90800015 	stw	r2,0(r18)
81127af4:	00900034 	movhi	r2,16384
81127af8:	10bfffc4 	addi	r2,r2,-1
81127afc:	8085883a 	add	r2,r16,r2
81127b00:	1085883a 	add	r2,r2,r2
81127b04:	1085883a 	add	r2,r2,r2
81127b08:	9885883a 	add	r2,r19,r2
81127b0c:	11000517 	ldw	r4,20(r2)
81127b10:	8020917a 	slli	r16,r16,5
81127b14:	11270880 	call	81127088 <__hi0bits>
81127b18:	d8c00817 	ldw	r3,32(sp)
81127b1c:	8085c83a 	sub	r2,r16,r2
81127b20:	18800015 	stw	r2,0(r3)
81127b24:	9805883a 	mov	r2,r19
81127b28:	dfc00717 	ldw	ra,28(sp)
81127b2c:	dd000617 	ldw	r20,24(sp)
81127b30:	dcc00517 	ldw	r19,20(sp)
81127b34:	dc800417 	ldw	r18,16(sp)
81127b38:	dc400317 	ldw	r17,12(sp)
81127b3c:	dc000217 	ldw	r16,8(sp)
81127b40:	dec00804 	addi	sp,sp,32
81127b44:	f800283a 	ret
81127b48:	d809883a 	mov	r4,sp
81127b4c:	11270f00 	call	811270f0 <__lo0bits>
81127b50:	d8c00017 	ldw	r3,0(sp)
81127b54:	04000044 	movi	r16,1
81127b58:	9c000415 	stw	r16,16(r19)
81127b5c:	98c00515 	stw	r3,20(r19)
81127b60:	10800804 	addi	r2,r2,32
81127b64:	883fe126 	beq	r17,zero,81127aec <__reset+0xfb107aec>
81127b68:	00c00d44 	movi	r3,53
81127b6c:	8c7ef344 	addi	r17,r17,-1075
81127b70:	88a3883a 	add	r17,r17,r2
81127b74:	1885c83a 	sub	r2,r3,r2
81127b78:	d8c00817 	ldw	r3,32(sp)
81127b7c:	94400015 	stw	r17,0(r18)
81127b80:	18800015 	stw	r2,0(r3)
81127b84:	003fe706 	br	81127b24 <__reset+0xfb107b24>
81127b88:	01000804 	movi	r4,32
81127b8c:	2089c83a 	sub	r4,r4,r2
81127b90:	1908983a 	sll	r4,r3,r4
81127b94:	d9400117 	ldw	r5,4(sp)
81127b98:	1886d83a 	srl	r3,r3,r2
81127b9c:	2148b03a 	or	r4,r4,r5
81127ba0:	99000515 	stw	r4,20(r19)
81127ba4:	d8c00015 	stw	r3,0(sp)
81127ba8:	003fca06 	br	81127ad4 <__reset+0xfb107ad4>

81127bac <__ratio>:
81127bac:	defff904 	addi	sp,sp,-28
81127bb0:	de00012e 	bgeu	sp,et,81127bb8 <__ratio+0xc>
81127bb4:	003b68fa 	trap	3
81127bb8:	dc400315 	stw	r17,12(sp)
81127bbc:	2823883a 	mov	r17,r5
81127bc0:	d9400104 	addi	r5,sp,4
81127bc4:	dfc00615 	stw	ra,24(sp)
81127bc8:	dcc00515 	stw	r19,20(sp)
81127bcc:	dc800415 	stw	r18,16(sp)
81127bd0:	2027883a 	mov	r19,r4
81127bd4:	dc000215 	stw	r16,8(sp)
81127bd8:	11279440 	call	81127944 <__b2d>
81127bdc:	d80b883a 	mov	r5,sp
81127be0:	8809883a 	mov	r4,r17
81127be4:	1025883a 	mov	r18,r2
81127be8:	1821883a 	mov	r16,r3
81127bec:	11279440 	call	81127944 <__b2d>
81127bf0:	8a000417 	ldw	r8,16(r17)
81127bf4:	99000417 	ldw	r4,16(r19)
81127bf8:	d9400117 	ldw	r5,4(sp)
81127bfc:	2209c83a 	sub	r4,r4,r8
81127c00:	2010917a 	slli	r8,r4,5
81127c04:	d9000017 	ldw	r4,0(sp)
81127c08:	2909c83a 	sub	r4,r5,r4
81127c0c:	4109883a 	add	r4,r8,r4
81127c10:	01000e0e 	bge	zero,r4,81127c4c <__ratio+0xa0>
81127c14:	2008953a 	slli	r4,r4,20
81127c18:	2421883a 	add	r16,r4,r16
81127c1c:	100d883a 	mov	r6,r2
81127c20:	180f883a 	mov	r7,r3
81127c24:	9009883a 	mov	r4,r18
81127c28:	800b883a 	mov	r5,r16
81127c2c:	112fca00 	call	8112fca0 <__divdf3>
81127c30:	dfc00617 	ldw	ra,24(sp)
81127c34:	dcc00517 	ldw	r19,20(sp)
81127c38:	dc800417 	ldw	r18,16(sp)
81127c3c:	dc400317 	ldw	r17,12(sp)
81127c40:	dc000217 	ldw	r16,8(sp)
81127c44:	dec00704 	addi	sp,sp,28
81127c48:	f800283a 	ret
81127c4c:	2008953a 	slli	r4,r4,20
81127c50:	1907c83a 	sub	r3,r3,r4
81127c54:	003ff106 	br	81127c1c <__reset+0xfb107c1c>

81127c58 <_mprec_log10>:
81127c58:	defffe04 	addi	sp,sp,-8
81127c5c:	de00012e 	bgeu	sp,et,81127c64 <_mprec_log10+0xc>
81127c60:	003b68fa 	trap	3
81127c64:	008005c4 	movi	r2,23
81127c68:	dc000015 	stw	r16,0(sp)
81127c6c:	dfc00115 	stw	ra,4(sp)
81127c70:	2021883a 	mov	r16,r4
81127c74:	11000d0e 	bge	r2,r4,81127cac <_mprec_log10+0x54>
81127c78:	0005883a 	mov	r2,zero
81127c7c:	00cffc34 	movhi	r3,16368
81127c80:	843fffc4 	addi	r16,r16,-1
81127c84:	000d883a 	mov	r6,zero
81127c88:	01d00934 	movhi	r7,16420
81127c8c:	1009883a 	mov	r4,r2
81127c90:	180b883a 	mov	r5,r3
81127c94:	111aefc0 	call	8111aefc <__muldf3>
81127c98:	803ff91e 	bne	r16,zero,81127c80 <__reset+0xfb107c80>
81127c9c:	dfc00117 	ldw	ra,4(sp)
81127ca0:	dc000017 	ldw	r16,0(sp)
81127ca4:	dec00204 	addi	sp,sp,8
81127ca8:	f800283a 	ret
81127cac:	202090fa 	slli	r16,r4,3
81127cb0:	00a04574 	movhi	r2,33045
81127cb4:	10ab9a04 	addi	r2,r2,-20888
81127cb8:	1421883a 	add	r16,r2,r16
81127cbc:	80800017 	ldw	r2,0(r16)
81127cc0:	80c00117 	ldw	r3,4(r16)
81127cc4:	dfc00117 	ldw	ra,4(sp)
81127cc8:	dc000017 	ldw	r16,0(sp)
81127ccc:	dec00204 	addi	sp,sp,8
81127cd0:	f800283a 	ret

81127cd4 <__copybits>:
81127cd4:	297fffc4 	addi	r5,r5,-1
81127cd8:	280fd17a 	srai	r7,r5,5
81127cdc:	30c00417 	ldw	r3,16(r6)
81127ce0:	30800504 	addi	r2,r6,20
81127ce4:	39c00044 	addi	r7,r7,1
81127ce8:	18c7883a 	add	r3,r3,r3
81127cec:	39cf883a 	add	r7,r7,r7
81127cf0:	18c7883a 	add	r3,r3,r3
81127cf4:	39cf883a 	add	r7,r7,r7
81127cf8:	10c7883a 	add	r3,r2,r3
81127cfc:	21cf883a 	add	r7,r4,r7
81127d00:	10c00d2e 	bgeu	r2,r3,81127d38 <__copybits+0x64>
81127d04:	200b883a 	mov	r5,r4
81127d08:	12000017 	ldw	r8,0(r2)
81127d0c:	29400104 	addi	r5,r5,4
81127d10:	10800104 	addi	r2,r2,4
81127d14:	2a3fff15 	stw	r8,-4(r5)
81127d18:	10fffb36 	bltu	r2,r3,81127d08 <__reset+0xfb107d08>
81127d1c:	1985c83a 	sub	r2,r3,r6
81127d20:	10bffac4 	addi	r2,r2,-21
81127d24:	1004d0ba 	srli	r2,r2,2
81127d28:	10800044 	addi	r2,r2,1
81127d2c:	1085883a 	add	r2,r2,r2
81127d30:	1085883a 	add	r2,r2,r2
81127d34:	2089883a 	add	r4,r4,r2
81127d38:	21c0032e 	bgeu	r4,r7,81127d48 <__copybits+0x74>
81127d3c:	20000015 	stw	zero,0(r4)
81127d40:	21000104 	addi	r4,r4,4
81127d44:	21fffd36 	bltu	r4,r7,81127d3c <__reset+0xfb107d3c>
81127d48:	f800283a 	ret

81127d4c <__any_on>:
81127d4c:	20c00417 	ldw	r3,16(r4)
81127d50:	2805d17a 	srai	r2,r5,5
81127d54:	21000504 	addi	r4,r4,20
81127d58:	18800d0e 	bge	r3,r2,81127d90 <__any_on+0x44>
81127d5c:	18c7883a 	add	r3,r3,r3
81127d60:	18c7883a 	add	r3,r3,r3
81127d64:	20c7883a 	add	r3,r4,r3
81127d68:	20c0192e 	bgeu	r4,r3,81127dd0 <__any_on+0x84>
81127d6c:	18bfff17 	ldw	r2,-4(r3)
81127d70:	18ffff04 	addi	r3,r3,-4
81127d74:	1000041e 	bne	r2,zero,81127d88 <__any_on+0x3c>
81127d78:	20c0142e 	bgeu	r4,r3,81127dcc <__any_on+0x80>
81127d7c:	18ffff04 	addi	r3,r3,-4
81127d80:	19400017 	ldw	r5,0(r3)
81127d84:	283ffc26 	beq	r5,zero,81127d78 <__reset+0xfb107d78>
81127d88:	00800044 	movi	r2,1
81127d8c:	f800283a 	ret
81127d90:	10c00a0e 	bge	r2,r3,81127dbc <__any_on+0x70>
81127d94:	1085883a 	add	r2,r2,r2
81127d98:	1085883a 	add	r2,r2,r2
81127d9c:	294007cc 	andi	r5,r5,31
81127da0:	2087883a 	add	r3,r4,r2
81127da4:	283ff026 	beq	r5,zero,81127d68 <__reset+0xfb107d68>
81127da8:	19800017 	ldw	r6,0(r3)
81127dac:	3144d83a 	srl	r2,r6,r5
81127db0:	114a983a 	sll	r5,r2,r5
81127db4:	317ff41e 	bne	r6,r5,81127d88 <__reset+0xfb107d88>
81127db8:	003feb06 	br	81127d68 <__reset+0xfb107d68>
81127dbc:	1085883a 	add	r2,r2,r2
81127dc0:	1085883a 	add	r2,r2,r2
81127dc4:	2087883a 	add	r3,r4,r2
81127dc8:	003fe706 	br	81127d68 <__reset+0xfb107d68>
81127dcc:	f800283a 	ret
81127dd0:	0005883a 	mov	r2,zero
81127dd4:	f800283a 	ret

81127dd8 <_read_r>:
81127dd8:	defffd04 	addi	sp,sp,-12
81127ddc:	de00012e 	bgeu	sp,et,81127de4 <_read_r+0xc>
81127de0:	003b68fa 	trap	3
81127de4:	2805883a 	mov	r2,r5
81127de8:	dc000015 	stw	r16,0(sp)
81127dec:	04204574 	movhi	r16,33045
81127df0:	dc400115 	stw	r17,4(sp)
81127df4:	300b883a 	mov	r5,r6
81127df8:	84359604 	addi	r16,r16,-10664
81127dfc:	2023883a 	mov	r17,r4
81127e00:	380d883a 	mov	r6,r7
81127e04:	1009883a 	mov	r4,r2
81127e08:	dfc00215 	stw	ra,8(sp)
81127e0c:	80000015 	stw	zero,0(r16)
81127e10:	11329540 	call	81132954 <read>
81127e14:	00ffffc4 	movi	r3,-1
81127e18:	10c00526 	beq	r2,r3,81127e30 <_read_r+0x58>
81127e1c:	dfc00217 	ldw	ra,8(sp)
81127e20:	dc400117 	ldw	r17,4(sp)
81127e24:	dc000017 	ldw	r16,0(sp)
81127e28:	dec00304 	addi	sp,sp,12
81127e2c:	f800283a 	ret
81127e30:	80c00017 	ldw	r3,0(r16)
81127e34:	183ff926 	beq	r3,zero,81127e1c <__reset+0xfb107e1c>
81127e38:	88c00015 	stw	r3,0(r17)
81127e3c:	003ff706 	br	81127e1c <__reset+0xfb107e1c>

81127e40 <_realloc_r>:
81127e40:	defff604 	addi	sp,sp,-40
81127e44:	de00012e 	bgeu	sp,et,81127e4c <_realloc_r+0xc>
81127e48:	003b68fa 	trap	3
81127e4c:	dc800215 	stw	r18,8(sp)
81127e50:	dfc00915 	stw	ra,36(sp)
81127e54:	df000815 	stw	fp,32(sp)
81127e58:	ddc00715 	stw	r23,28(sp)
81127e5c:	dd800615 	stw	r22,24(sp)
81127e60:	dd400515 	stw	r21,20(sp)
81127e64:	dd000415 	stw	r20,16(sp)
81127e68:	dcc00315 	stw	r19,12(sp)
81127e6c:	dc400115 	stw	r17,4(sp)
81127e70:	dc000015 	stw	r16,0(sp)
81127e74:	3025883a 	mov	r18,r6
81127e78:	2800b726 	beq	r5,zero,81128158 <_realloc_r+0x318>
81127e7c:	282b883a 	mov	r21,r5
81127e80:	2029883a 	mov	r20,r4
81127e84:	11331340 	call	81133134 <__malloc_lock>
81127e88:	a8bfff17 	ldw	r2,-4(r21)
81127e8c:	043fff04 	movi	r16,-4
81127e90:	90c002c4 	addi	r3,r18,11
81127e94:	01000584 	movi	r4,22
81127e98:	acfffe04 	addi	r19,r21,-8
81127e9c:	1420703a 	and	r16,r2,r16
81127ea0:	20c0332e 	bgeu	r4,r3,81127f70 <_realloc_r+0x130>
81127ea4:	047ffe04 	movi	r17,-8
81127ea8:	1c62703a 	and	r17,r3,r17
81127eac:	8807883a 	mov	r3,r17
81127eb0:	88005816 	blt	r17,zero,81128014 <_realloc_r+0x1d4>
81127eb4:	8c805736 	bltu	r17,r18,81128014 <_realloc_r+0x1d4>
81127eb8:	80c0300e 	bge	r16,r3,81127f7c <_realloc_r+0x13c>
81127ebc:	07204574 	movhi	fp,33045
81127ec0:	e72ee704 	addi	fp,fp,-17508
81127ec4:	e1c00217 	ldw	r7,8(fp)
81127ec8:	9c09883a 	add	r4,r19,r16
81127ecc:	22000117 	ldw	r8,4(r4)
81127ed0:	21c06326 	beq	r4,r7,81128060 <_realloc_r+0x220>
81127ed4:	017fff84 	movi	r5,-2
81127ed8:	414a703a 	and	r5,r8,r5
81127edc:	214b883a 	add	r5,r4,r5
81127ee0:	29800117 	ldw	r6,4(r5)
81127ee4:	3180004c 	andi	r6,r6,1
81127ee8:	30003f26 	beq	r6,zero,81127fe8 <_realloc_r+0x1a8>
81127eec:	1080004c 	andi	r2,r2,1
81127ef0:	10008326 	beq	r2,zero,81128100 <_realloc_r+0x2c0>
81127ef4:	900b883a 	mov	r5,r18
81127ef8:	a009883a 	mov	r4,r20
81127efc:	111c3380 	call	8111c338 <_malloc_r>
81127f00:	1025883a 	mov	r18,r2
81127f04:	10011e26 	beq	r2,zero,81128380 <_realloc_r+0x540>
81127f08:	a93fff17 	ldw	r4,-4(r21)
81127f0c:	10fffe04 	addi	r3,r2,-8
81127f10:	00bfff84 	movi	r2,-2
81127f14:	2084703a 	and	r2,r4,r2
81127f18:	9885883a 	add	r2,r19,r2
81127f1c:	1880ee26 	beq	r3,r2,811282d8 <_realloc_r+0x498>
81127f20:	81bfff04 	addi	r6,r16,-4
81127f24:	00800904 	movi	r2,36
81127f28:	1180b836 	bltu	r2,r6,8112820c <_realloc_r+0x3cc>
81127f2c:	00c004c4 	movi	r3,19
81127f30:	19809636 	bltu	r3,r6,8112818c <_realloc_r+0x34c>
81127f34:	9005883a 	mov	r2,r18
81127f38:	a807883a 	mov	r3,r21
81127f3c:	19000017 	ldw	r4,0(r3)
81127f40:	11000015 	stw	r4,0(r2)
81127f44:	19000117 	ldw	r4,4(r3)
81127f48:	11000115 	stw	r4,4(r2)
81127f4c:	18c00217 	ldw	r3,8(r3)
81127f50:	10c00215 	stw	r3,8(r2)
81127f54:	a80b883a 	mov	r5,r21
81127f58:	a009883a 	mov	r4,r20
81127f5c:	1125dac0 	call	81125dac <_free_r>
81127f60:	a009883a 	mov	r4,r20
81127f64:	113325c0 	call	8113325c <__malloc_unlock>
81127f68:	9005883a 	mov	r2,r18
81127f6c:	00001206 	br	81127fb8 <_realloc_r+0x178>
81127f70:	00c00404 	movi	r3,16
81127f74:	1823883a 	mov	r17,r3
81127f78:	003fce06 	br	81127eb4 <__reset+0xfb107eb4>
81127f7c:	a825883a 	mov	r18,r21
81127f80:	8445c83a 	sub	r2,r16,r17
81127f84:	00c003c4 	movi	r3,15
81127f88:	18802636 	bltu	r3,r2,81128024 <_realloc_r+0x1e4>
81127f8c:	99800117 	ldw	r6,4(r19)
81127f90:	9c07883a 	add	r3,r19,r16
81127f94:	3180004c 	andi	r6,r6,1
81127f98:	3420b03a 	or	r16,r6,r16
81127f9c:	9c000115 	stw	r16,4(r19)
81127fa0:	18800117 	ldw	r2,4(r3)
81127fa4:	10800054 	ori	r2,r2,1
81127fa8:	18800115 	stw	r2,4(r3)
81127fac:	a009883a 	mov	r4,r20
81127fb0:	113325c0 	call	8113325c <__malloc_unlock>
81127fb4:	9005883a 	mov	r2,r18
81127fb8:	dfc00917 	ldw	ra,36(sp)
81127fbc:	df000817 	ldw	fp,32(sp)
81127fc0:	ddc00717 	ldw	r23,28(sp)
81127fc4:	dd800617 	ldw	r22,24(sp)
81127fc8:	dd400517 	ldw	r21,20(sp)
81127fcc:	dd000417 	ldw	r20,16(sp)
81127fd0:	dcc00317 	ldw	r19,12(sp)
81127fd4:	dc800217 	ldw	r18,8(sp)
81127fd8:	dc400117 	ldw	r17,4(sp)
81127fdc:	dc000017 	ldw	r16,0(sp)
81127fe0:	dec00a04 	addi	sp,sp,40
81127fe4:	f800283a 	ret
81127fe8:	017fff04 	movi	r5,-4
81127fec:	414a703a 	and	r5,r8,r5
81127ff0:	814d883a 	add	r6,r16,r5
81127ff4:	30c01f16 	blt	r6,r3,81128074 <_realloc_r+0x234>
81127ff8:	20800317 	ldw	r2,12(r4)
81127ffc:	20c00217 	ldw	r3,8(r4)
81128000:	a825883a 	mov	r18,r21
81128004:	3021883a 	mov	r16,r6
81128008:	18800315 	stw	r2,12(r3)
8112800c:	10c00215 	stw	r3,8(r2)
81128010:	003fdb06 	br	81127f80 <__reset+0xfb107f80>
81128014:	00800304 	movi	r2,12
81128018:	a0800015 	stw	r2,0(r20)
8112801c:	0005883a 	mov	r2,zero
81128020:	003fe506 	br	81127fb8 <__reset+0xfb107fb8>
81128024:	98c00117 	ldw	r3,4(r19)
81128028:	9c4b883a 	add	r5,r19,r17
8112802c:	11000054 	ori	r4,r2,1
81128030:	18c0004c 	andi	r3,r3,1
81128034:	1c62b03a 	or	r17,r3,r17
81128038:	9c400115 	stw	r17,4(r19)
8112803c:	29000115 	stw	r4,4(r5)
81128040:	2885883a 	add	r2,r5,r2
81128044:	10c00117 	ldw	r3,4(r2)
81128048:	29400204 	addi	r5,r5,8
8112804c:	a009883a 	mov	r4,r20
81128050:	18c00054 	ori	r3,r3,1
81128054:	10c00115 	stw	r3,4(r2)
81128058:	1125dac0 	call	81125dac <_free_r>
8112805c:	003fd306 	br	81127fac <__reset+0xfb107fac>
81128060:	017fff04 	movi	r5,-4
81128064:	414a703a 	and	r5,r8,r5
81128068:	89800404 	addi	r6,r17,16
8112806c:	8151883a 	add	r8,r16,r5
81128070:	4180590e 	bge	r8,r6,811281d8 <_realloc_r+0x398>
81128074:	1080004c 	andi	r2,r2,1
81128078:	103f9e1e 	bne	r2,zero,81127ef4 <__reset+0xfb107ef4>
8112807c:	adbffe17 	ldw	r22,-8(r21)
81128080:	00bfff04 	movi	r2,-4
81128084:	9dadc83a 	sub	r22,r19,r22
81128088:	b1800117 	ldw	r6,4(r22)
8112808c:	3084703a 	and	r2,r6,r2
81128090:	20002026 	beq	r4,zero,81128114 <_realloc_r+0x2d4>
81128094:	80af883a 	add	r23,r16,r2
81128098:	b96f883a 	add	r23,r23,r5
8112809c:	21c05f26 	beq	r4,r7,8112821c <_realloc_r+0x3dc>
811280a0:	b8c01c16 	blt	r23,r3,81128114 <_realloc_r+0x2d4>
811280a4:	20800317 	ldw	r2,12(r4)
811280a8:	20c00217 	ldw	r3,8(r4)
811280ac:	81bfff04 	addi	r6,r16,-4
811280b0:	01000904 	movi	r4,36
811280b4:	18800315 	stw	r2,12(r3)
811280b8:	10c00215 	stw	r3,8(r2)
811280bc:	b0c00217 	ldw	r3,8(r22)
811280c0:	b0800317 	ldw	r2,12(r22)
811280c4:	b4800204 	addi	r18,r22,8
811280c8:	18800315 	stw	r2,12(r3)
811280cc:	10c00215 	stw	r3,8(r2)
811280d0:	21801b36 	bltu	r4,r6,81128140 <_realloc_r+0x300>
811280d4:	008004c4 	movi	r2,19
811280d8:	1180352e 	bgeu	r2,r6,811281b0 <_realloc_r+0x370>
811280dc:	a8800017 	ldw	r2,0(r21)
811280e0:	b0800215 	stw	r2,8(r22)
811280e4:	a8800117 	ldw	r2,4(r21)
811280e8:	b0800315 	stw	r2,12(r22)
811280ec:	008006c4 	movi	r2,27
811280f0:	11807f36 	bltu	r2,r6,811282f0 <_realloc_r+0x4b0>
811280f4:	b0800404 	addi	r2,r22,16
811280f8:	ad400204 	addi	r21,r21,8
811280fc:	00002d06 	br	811281b4 <_realloc_r+0x374>
81128100:	adbffe17 	ldw	r22,-8(r21)
81128104:	00bfff04 	movi	r2,-4
81128108:	9dadc83a 	sub	r22,r19,r22
8112810c:	b1000117 	ldw	r4,4(r22)
81128110:	2084703a 	and	r2,r4,r2
81128114:	b03f7726 	beq	r22,zero,81127ef4 <__reset+0xfb107ef4>
81128118:	80af883a 	add	r23,r16,r2
8112811c:	b8ff7516 	blt	r23,r3,81127ef4 <__reset+0xfb107ef4>
81128120:	b0800317 	ldw	r2,12(r22)
81128124:	b0c00217 	ldw	r3,8(r22)
81128128:	81bfff04 	addi	r6,r16,-4
8112812c:	01000904 	movi	r4,36
81128130:	18800315 	stw	r2,12(r3)
81128134:	10c00215 	stw	r3,8(r2)
81128138:	b4800204 	addi	r18,r22,8
8112813c:	21bfe52e 	bgeu	r4,r6,811280d4 <__reset+0xfb1080d4>
81128140:	a80b883a 	mov	r5,r21
81128144:	9009883a 	mov	r4,r18
81128148:	1126c200 	call	81126c20 <memmove>
8112814c:	b821883a 	mov	r16,r23
81128150:	b027883a 	mov	r19,r22
81128154:	003f8a06 	br	81127f80 <__reset+0xfb107f80>
81128158:	300b883a 	mov	r5,r6
8112815c:	dfc00917 	ldw	ra,36(sp)
81128160:	df000817 	ldw	fp,32(sp)
81128164:	ddc00717 	ldw	r23,28(sp)
81128168:	dd800617 	ldw	r22,24(sp)
8112816c:	dd400517 	ldw	r21,20(sp)
81128170:	dd000417 	ldw	r20,16(sp)
81128174:	dcc00317 	ldw	r19,12(sp)
81128178:	dc800217 	ldw	r18,8(sp)
8112817c:	dc400117 	ldw	r17,4(sp)
81128180:	dc000017 	ldw	r16,0(sp)
81128184:	dec00a04 	addi	sp,sp,40
81128188:	111c3381 	jmpi	8111c338 <_malloc_r>
8112818c:	a8c00017 	ldw	r3,0(r21)
81128190:	90c00015 	stw	r3,0(r18)
81128194:	a8c00117 	ldw	r3,4(r21)
81128198:	90c00115 	stw	r3,4(r18)
8112819c:	00c006c4 	movi	r3,27
811281a0:	19804536 	bltu	r3,r6,811282b8 <_realloc_r+0x478>
811281a4:	90800204 	addi	r2,r18,8
811281a8:	a8c00204 	addi	r3,r21,8
811281ac:	003f6306 	br	81127f3c <__reset+0xfb107f3c>
811281b0:	9005883a 	mov	r2,r18
811281b4:	a8c00017 	ldw	r3,0(r21)
811281b8:	b821883a 	mov	r16,r23
811281bc:	b027883a 	mov	r19,r22
811281c0:	10c00015 	stw	r3,0(r2)
811281c4:	a8c00117 	ldw	r3,4(r21)
811281c8:	10c00115 	stw	r3,4(r2)
811281cc:	a8c00217 	ldw	r3,8(r21)
811281d0:	10c00215 	stw	r3,8(r2)
811281d4:	003f6a06 	br	81127f80 <__reset+0xfb107f80>
811281d8:	9c67883a 	add	r19,r19,r17
811281dc:	4445c83a 	sub	r2,r8,r17
811281e0:	e4c00215 	stw	r19,8(fp)
811281e4:	10800054 	ori	r2,r2,1
811281e8:	98800115 	stw	r2,4(r19)
811281ec:	a8bfff17 	ldw	r2,-4(r21)
811281f0:	a009883a 	mov	r4,r20
811281f4:	1080004c 	andi	r2,r2,1
811281f8:	1462b03a 	or	r17,r2,r17
811281fc:	ac7fff15 	stw	r17,-4(r21)
81128200:	113325c0 	call	8113325c <__malloc_unlock>
81128204:	a805883a 	mov	r2,r21
81128208:	003f6b06 	br	81127fb8 <__reset+0xfb107fb8>
8112820c:	a80b883a 	mov	r5,r21
81128210:	9009883a 	mov	r4,r18
81128214:	1126c200 	call	81126c20 <memmove>
81128218:	003f4e06 	br	81127f54 <__reset+0xfb107f54>
8112821c:	89000404 	addi	r4,r17,16
81128220:	b93fbc16 	blt	r23,r4,81128114 <__reset+0xfb108114>
81128224:	b0800317 	ldw	r2,12(r22)
81128228:	b0c00217 	ldw	r3,8(r22)
8112822c:	81bfff04 	addi	r6,r16,-4
81128230:	01000904 	movi	r4,36
81128234:	18800315 	stw	r2,12(r3)
81128238:	10c00215 	stw	r3,8(r2)
8112823c:	b4800204 	addi	r18,r22,8
81128240:	21804336 	bltu	r4,r6,81128350 <_realloc_r+0x510>
81128244:	008004c4 	movi	r2,19
81128248:	11803f2e 	bgeu	r2,r6,81128348 <_realloc_r+0x508>
8112824c:	a8800017 	ldw	r2,0(r21)
81128250:	b0800215 	stw	r2,8(r22)
81128254:	a8800117 	ldw	r2,4(r21)
81128258:	b0800315 	stw	r2,12(r22)
8112825c:	008006c4 	movi	r2,27
81128260:	11803f36 	bltu	r2,r6,81128360 <_realloc_r+0x520>
81128264:	b0800404 	addi	r2,r22,16
81128268:	ad400204 	addi	r21,r21,8
8112826c:	a8c00017 	ldw	r3,0(r21)
81128270:	10c00015 	stw	r3,0(r2)
81128274:	a8c00117 	ldw	r3,4(r21)
81128278:	10c00115 	stw	r3,4(r2)
8112827c:	a8c00217 	ldw	r3,8(r21)
81128280:	10c00215 	stw	r3,8(r2)
81128284:	b447883a 	add	r3,r22,r17
81128288:	bc45c83a 	sub	r2,r23,r17
8112828c:	e0c00215 	stw	r3,8(fp)
81128290:	10800054 	ori	r2,r2,1
81128294:	18800115 	stw	r2,4(r3)
81128298:	b0800117 	ldw	r2,4(r22)
8112829c:	a009883a 	mov	r4,r20
811282a0:	1080004c 	andi	r2,r2,1
811282a4:	1462b03a 	or	r17,r2,r17
811282a8:	b4400115 	stw	r17,4(r22)
811282ac:	113325c0 	call	8113325c <__malloc_unlock>
811282b0:	9005883a 	mov	r2,r18
811282b4:	003f4006 	br	81127fb8 <__reset+0xfb107fb8>
811282b8:	a8c00217 	ldw	r3,8(r21)
811282bc:	90c00215 	stw	r3,8(r18)
811282c0:	a8c00317 	ldw	r3,12(r21)
811282c4:	90c00315 	stw	r3,12(r18)
811282c8:	30801126 	beq	r6,r2,81128310 <_realloc_r+0x4d0>
811282cc:	90800404 	addi	r2,r18,16
811282d0:	a8c00404 	addi	r3,r21,16
811282d4:	003f1906 	br	81127f3c <__reset+0xfb107f3c>
811282d8:	90ffff17 	ldw	r3,-4(r18)
811282dc:	00bfff04 	movi	r2,-4
811282e0:	a825883a 	mov	r18,r21
811282e4:	1884703a 	and	r2,r3,r2
811282e8:	80a1883a 	add	r16,r16,r2
811282ec:	003f2406 	br	81127f80 <__reset+0xfb107f80>
811282f0:	a8800217 	ldw	r2,8(r21)
811282f4:	b0800415 	stw	r2,16(r22)
811282f8:	a8800317 	ldw	r2,12(r21)
811282fc:	b0800515 	stw	r2,20(r22)
81128300:	31000a26 	beq	r6,r4,8112832c <_realloc_r+0x4ec>
81128304:	b0800604 	addi	r2,r22,24
81128308:	ad400404 	addi	r21,r21,16
8112830c:	003fa906 	br	811281b4 <__reset+0xfb1081b4>
81128310:	a9000417 	ldw	r4,16(r21)
81128314:	90800604 	addi	r2,r18,24
81128318:	a8c00604 	addi	r3,r21,24
8112831c:	91000415 	stw	r4,16(r18)
81128320:	a9000517 	ldw	r4,20(r21)
81128324:	91000515 	stw	r4,20(r18)
81128328:	003f0406 	br	81127f3c <__reset+0xfb107f3c>
8112832c:	a8c00417 	ldw	r3,16(r21)
81128330:	ad400604 	addi	r21,r21,24
81128334:	b0800804 	addi	r2,r22,32
81128338:	b0c00615 	stw	r3,24(r22)
8112833c:	a8ffff17 	ldw	r3,-4(r21)
81128340:	b0c00715 	stw	r3,28(r22)
81128344:	003f9b06 	br	811281b4 <__reset+0xfb1081b4>
81128348:	9005883a 	mov	r2,r18
8112834c:	003fc706 	br	8112826c <__reset+0xfb10826c>
81128350:	a80b883a 	mov	r5,r21
81128354:	9009883a 	mov	r4,r18
81128358:	1126c200 	call	81126c20 <memmove>
8112835c:	003fc906 	br	81128284 <__reset+0xfb108284>
81128360:	a8800217 	ldw	r2,8(r21)
81128364:	b0800415 	stw	r2,16(r22)
81128368:	a8800317 	ldw	r2,12(r21)
8112836c:	b0800515 	stw	r2,20(r22)
81128370:	31000726 	beq	r6,r4,81128390 <_realloc_r+0x550>
81128374:	b0800604 	addi	r2,r22,24
81128378:	ad400404 	addi	r21,r21,16
8112837c:	003fbb06 	br	8112826c <__reset+0xfb10826c>
81128380:	a009883a 	mov	r4,r20
81128384:	113325c0 	call	8113325c <__malloc_unlock>
81128388:	0005883a 	mov	r2,zero
8112838c:	003f0a06 	br	81127fb8 <__reset+0xfb107fb8>
81128390:	a8c00417 	ldw	r3,16(r21)
81128394:	ad400604 	addi	r21,r21,24
81128398:	b0800804 	addi	r2,r22,32
8112839c:	b0c00615 	stw	r3,24(r22)
811283a0:	a8ffff17 	ldw	r3,-4(r21)
811283a4:	b0c00715 	stw	r3,28(r22)
811283a8:	003fb006 	br	8112826c <__reset+0xfb10826c>

811283ac <__fpclassifyd>:
811283ac:	00a00034 	movhi	r2,32768
811283b0:	10bfffc4 	addi	r2,r2,-1
811283b4:	2884703a 	and	r2,r5,r2
811283b8:	10000726 	beq	r2,zero,811283d8 <__fpclassifyd+0x2c>
811283bc:	00fffc34 	movhi	r3,65520
811283c0:	019ff834 	movhi	r6,32736
811283c4:	28c7883a 	add	r3,r5,r3
811283c8:	31bfffc4 	addi	r6,r6,-1
811283cc:	30c00536 	bltu	r6,r3,811283e4 <__fpclassifyd+0x38>
811283d0:	00800104 	movi	r2,4
811283d4:	f800283a 	ret
811283d8:	2000021e 	bne	r4,zero,811283e4 <__fpclassifyd+0x38>
811283dc:	00800084 	movi	r2,2
811283e0:	f800283a 	ret
811283e4:	00dffc34 	movhi	r3,32752
811283e8:	019ff834 	movhi	r6,32736
811283ec:	28cb883a 	add	r5,r5,r3
811283f0:	31bfffc4 	addi	r6,r6,-1
811283f4:	317ff62e 	bgeu	r6,r5,811283d0 <__reset+0xfb1083d0>
811283f8:	01400434 	movhi	r5,16
811283fc:	297fffc4 	addi	r5,r5,-1
81128400:	28800236 	bltu	r5,r2,8112840c <__fpclassifyd+0x60>
81128404:	008000c4 	movi	r2,3
81128408:	f800283a 	ret
8112840c:	10c00226 	beq	r2,r3,81128418 <__fpclassifyd+0x6c>
81128410:	0005883a 	mov	r2,zero
81128414:	f800283a 	ret
81128418:	2005003a 	cmpeq	r2,r4,zero
8112841c:	f800283a 	ret

81128420 <__sccl>:
81128420:	2a000003 	ldbu	r8,0(r5)
81128424:	00801784 	movi	r2,94
81128428:	40802a26 	beq	r8,r2,811284d4 <__sccl+0xb4>
8112842c:	29400044 	addi	r5,r5,1
81128430:	000f883a 	mov	r7,zero
81128434:	0013883a 	mov	r9,zero
81128438:	2007883a 	mov	r3,r4
8112843c:	21804004 	addi	r6,r4,256
81128440:	19c00005 	stb	r7,0(r3)
81128444:	18c00044 	addi	r3,r3,1
81128448:	19bffd1e 	bne	r3,r6,81128440 <__reset+0xfb108440>
8112844c:	40001126 	beq	r8,zero,81128494 <__sccl+0x74>
81128450:	00800044 	movi	r2,1
81128454:	124fc83a 	sub	r7,r2,r9
81128458:	02800b44 	movi	r10,45
8112845c:	02c01744 	movi	r11,93
81128460:	2205883a 	add	r2,r4,r8
81128464:	11c00005 	stb	r7,0(r2)
81128468:	28800044 	addi	r2,r5,1
8112846c:	28c00003 	ldbu	r3,0(r5)
81128470:	1a800a26 	beq	r3,r10,8112849c <__sccl+0x7c>
81128474:	1ac00426 	beq	r3,r11,81128488 <__sccl+0x68>
81128478:	18000426 	beq	r3,zero,8112848c <__sccl+0x6c>
8112847c:	1811883a 	mov	r8,r3
81128480:	100b883a 	mov	r5,r2
81128484:	003ff606 	br	81128460 <__reset+0xfb108460>
81128488:	f800283a 	ret
8112848c:	2805883a 	mov	r2,r5
81128490:	f800283a 	ret
81128494:	28bfffc4 	addi	r2,r5,-1
81128498:	f800283a 	ret
8112849c:	12400003 	ldbu	r9,0(r2)
811284a0:	4ac01126 	beq	r9,r11,811284e8 <__sccl+0xc8>
811284a4:	4a001016 	blt	r9,r8,811284e8 <__sccl+0xc8>
811284a8:	41800044 	addi	r6,r8,1
811284ac:	29400084 	addi	r5,r5,2
811284b0:	2187883a 	add	r3,r4,r6
811284b4:	00000106 	br	811284bc <__sccl+0x9c>
811284b8:	31800044 	addi	r6,r6,1
811284bc:	19c00005 	stb	r7,0(r3)
811284c0:	3011883a 	mov	r8,r6
811284c4:	18c00044 	addi	r3,r3,1
811284c8:	327ffb16 	blt	r6,r9,811284b8 <__reset+0xfb1084b8>
811284cc:	10800084 	addi	r2,r2,2
811284d0:	003fe606 	br	8112846c <__reset+0xfb10846c>
811284d4:	2a000043 	ldbu	r8,1(r5)
811284d8:	01c00044 	movi	r7,1
811284dc:	29400084 	addi	r5,r5,2
811284e0:	02400044 	movi	r9,1
811284e4:	003fd406 	br	81128438 <__reset+0xfb108438>
811284e8:	5011883a 	mov	r8,r10
811284ec:	003fe406 	br	81128480 <__reset+0xfb108480>

811284f0 <nanf>:
811284f0:	009ff034 	movhi	r2,32704
811284f4:	f800283a 	ret

811284f8 <strcmp>:
811284f8:	2144b03a 	or	r2,r4,r5
811284fc:	108000cc 	andi	r2,r2,3
81128500:	1000171e 	bne	r2,zero,81128560 <strcmp+0x68>
81128504:	20800017 	ldw	r2,0(r4)
81128508:	28c00017 	ldw	r3,0(r5)
8112850c:	10c0141e 	bne	r2,r3,81128560 <strcmp+0x68>
81128510:	027fbff4 	movhi	r9,65279
81128514:	4a7fbfc4 	addi	r9,r9,-257
81128518:	0086303a 	nor	r3,zero,r2
8112851c:	02202074 	movhi	r8,32897
81128520:	1245883a 	add	r2,r2,r9
81128524:	42202004 	addi	r8,r8,-32640
81128528:	10c4703a 	and	r2,r2,r3
8112852c:	1204703a 	and	r2,r2,r8
81128530:	10000226 	beq	r2,zero,8112853c <strcmp+0x44>
81128534:	00002306 	br	811285c4 <strcmp+0xcc>
81128538:	1000221e 	bne	r2,zero,811285c4 <strcmp+0xcc>
8112853c:	21000104 	addi	r4,r4,4
81128540:	20c00017 	ldw	r3,0(r4)
81128544:	29400104 	addi	r5,r5,4
81128548:	29800017 	ldw	r6,0(r5)
8112854c:	1a4f883a 	add	r7,r3,r9
81128550:	00c4303a 	nor	r2,zero,r3
81128554:	3884703a 	and	r2,r7,r2
81128558:	1204703a 	and	r2,r2,r8
8112855c:	19bff626 	beq	r3,r6,81128538 <__reset+0xfb108538>
81128560:	20800003 	ldbu	r2,0(r4)
81128564:	10c03fcc 	andi	r3,r2,255
81128568:	18c0201c 	xori	r3,r3,128
8112856c:	18ffe004 	addi	r3,r3,-128
81128570:	18000c26 	beq	r3,zero,811285a4 <strcmp+0xac>
81128574:	29800007 	ldb	r6,0(r5)
81128578:	19800326 	beq	r3,r6,81128588 <strcmp+0x90>
8112857c:	00001306 	br	811285cc <strcmp+0xd4>
81128580:	29800007 	ldb	r6,0(r5)
81128584:	11800b1e 	bne	r2,r6,811285b4 <strcmp+0xbc>
81128588:	21000044 	addi	r4,r4,1
8112858c:	20c00003 	ldbu	r3,0(r4)
81128590:	29400044 	addi	r5,r5,1
81128594:	18803fcc 	andi	r2,r3,255
81128598:	1080201c 	xori	r2,r2,128
8112859c:	10bfe004 	addi	r2,r2,-128
811285a0:	103ff71e 	bne	r2,zero,81128580 <__reset+0xfb108580>
811285a4:	0007883a 	mov	r3,zero
811285a8:	28800003 	ldbu	r2,0(r5)
811285ac:	1885c83a 	sub	r2,r3,r2
811285b0:	f800283a 	ret
811285b4:	28800003 	ldbu	r2,0(r5)
811285b8:	18c03fcc 	andi	r3,r3,255
811285bc:	1885c83a 	sub	r2,r3,r2
811285c0:	f800283a 	ret
811285c4:	0005883a 	mov	r2,zero
811285c8:	f800283a 	ret
811285cc:	10c03fcc 	andi	r3,r2,255
811285d0:	003ff506 	br	811285a8 <__reset+0xfb1085a8>

811285d4 <sulp>:
811285d4:	defffd04 	addi	sp,sp,-12
811285d8:	de00012e 	bgeu	sp,et,811285e0 <sulp+0xc>
811285dc:	003b68fa 	trap	3
811285e0:	dc400115 	stw	r17,4(sp)
811285e4:	3023883a 	mov	r17,r6
811285e8:	dc000015 	stw	r16,0(sp)
811285ec:	dfc00215 	stw	ra,8(sp)
811285f0:	2821883a 	mov	r16,r5
811285f4:	11278e00 	call	811278e0 <__ulp>
811285f8:	88000c26 	beq	r17,zero,8112862c <sulp+0x58>
811285fc:	841ffc2c 	andhi	r16,r16,32752
81128600:	8020d53a 	srli	r16,r16,20
81128604:	01c01ac4 	movi	r7,107
81128608:	3c21c83a 	sub	r16,r7,r16
8112860c:	0400070e 	bge	zero,r16,8112862c <sulp+0x58>
81128610:	8020953a 	slli	r16,r16,20
81128614:	01cffc34 	movhi	r7,16368
81128618:	000d883a 	mov	r6,zero
8112861c:	81cf883a 	add	r7,r16,r7
81128620:	1009883a 	mov	r4,r2
81128624:	180b883a 	mov	r5,r3
81128628:	111aefc0 	call	8111aefc <__muldf3>
8112862c:	dfc00217 	ldw	ra,8(sp)
81128630:	dc400117 	ldw	r17,4(sp)
81128634:	dc000017 	ldw	r16,0(sp)
81128638:	dec00304 	addi	sp,sp,12
8112863c:	f800283a 	ret

81128640 <_strtod_r>:
81128640:	deffe204 	addi	sp,sp,-120
81128644:	de00012e 	bgeu	sp,et,8112864c <_strtod_r+0xc>
81128648:	003b68fa 	trap	3
8112864c:	ddc01b15 	stw	r23,108(sp)
81128650:	dd001815 	stw	r20,96(sp)
81128654:	dc801615 	stw	r18,88(sp)
81128658:	dc401515 	stw	r17,84(sp)
8112865c:	dc001415 	stw	r16,80(sp)
81128660:	d9400615 	stw	r5,24(sp)
81128664:	dfc01d15 	stw	ra,116(sp)
81128668:	df001c15 	stw	fp,112(sp)
8112866c:	dd801a15 	stw	r22,104(sp)
81128670:	dd401915 	stw	r21,100(sp)
81128674:	dcc01715 	stw	r19,92(sp)
81128678:	2021883a 	mov	r16,r4
8112867c:	d8000515 	stw	zero,20(sp)
81128680:	2809883a 	mov	r4,r5
81128684:	20800003 	ldbu	r2,0(r4)
81128688:	01e044f4 	movhi	r7,33043
8112868c:	282f883a 	mov	r23,r5
81128690:	10c03fcc 	andi	r3,r2,255
81128694:	01400b44 	movi	r5,45
81128698:	39e1af04 	addi	r7,r7,-31044
8112869c:	3029883a 	mov	r20,r6
811286a0:	0025883a 	mov	r18,zero
811286a4:	0023883a 	mov	r17,zero
811286a8:	28c0ba36 	bltu	r5,r3,81128994 <_strtod_r+0x354>
811286ac:	180690ba 	slli	r3,r3,2
811286b0:	19c7883a 	add	r3,r3,r7
811286b4:	18c00017 	ldw	r3,0(r3)
811286b8:	1800683a 	jmp	r3
811286bc:	8112877c 	xorhi	r4,r16,18973
811286c0:	81128994 	ori	r4,r16,18982
811286c4:	81128994 	ori	r4,r16,18982
811286c8:	81128994 	ori	r4,r16,18982
811286cc:	81128994 	ori	r4,r16,18982
811286d0:	81128994 	ori	r4,r16,18982
811286d4:	81128994 	ori	r4,r16,18982
811286d8:	81128994 	ori	r4,r16,18982
811286dc:	81128994 	ori	r4,r16,18982
811286e0:	81128980 	call	88112898 <__reset+0x20f2898>
811286e4:	81128980 	call	88112898 <__reset+0x20f2898>
811286e8:	81128980 	call	88112898 <__reset+0x20f2898>
811286ec:	81128980 	call	88112898 <__reset+0x20f2898>
811286f0:	81128980 	call	88112898 <__reset+0x20f2898>
811286f4:	81128994 	ori	r4,r16,18982
811286f8:	81128994 	ori	r4,r16,18982
811286fc:	81128994 	ori	r4,r16,18982
81128700:	81128994 	ori	r4,r16,18982
81128704:	81128994 	ori	r4,r16,18982
81128708:	81128994 	ori	r4,r16,18982
8112870c:	81128994 	ori	r4,r16,18982
81128710:	81128994 	ori	r4,r16,18982
81128714:	81128994 	ori	r4,r16,18982
81128718:	81128994 	ori	r4,r16,18982
8112871c:	81128994 	ori	r4,r16,18982
81128720:	81128994 	ori	r4,r16,18982
81128724:	81128994 	ori	r4,r16,18982
81128728:	81128994 	ori	r4,r16,18982
8112872c:	81128994 	ori	r4,r16,18982
81128730:	81128994 	ori	r4,r16,18982
81128734:	81128994 	ori	r4,r16,18982
81128738:	81128994 	ori	r4,r16,18982
8112873c:	81128980 	call	88112898 <__reset+0x20f2898>
81128740:	81128994 	ori	r4,r16,18982
81128744:	81128994 	ori	r4,r16,18982
81128748:	81128994 	ori	r4,r16,18982
8112874c:	81128994 	ori	r4,r16,18982
81128750:	81128994 	ori	r4,r16,18982
81128754:	81128994 	ori	r4,r16,18982
81128758:	81128994 	ori	r4,r16,18982
8112875c:	81128994 	ori	r4,r16,18982
81128760:	81128994 	ori	r4,r16,18982
81128764:	81128994 	ori	r4,r16,18982
81128768:	811287d4 	ori	r4,r16,18975
8112876c:	81128994 	ori	r4,r16,18982
81128770:	81128974 	orhi	r4,r16,18981
81128774:	00801244 	movi	r2,73
81128778:	88843526 	beq	r17,r2,81129850 <_strtod_r+0x1210>
8112877c:	002b883a 	mov	r21,zero
81128780:	002d883a 	mov	r22,zero
81128784:	a0000526 	beq	r20,zero,8112879c <_strtod_r+0x15c>
81128788:	d8000715 	stw	zero,28(sp)
8112878c:	a5c00015 	stw	r23,0(r20)
81128790:	d9000717 	ldw	r4,28(sp)
81128794:	20000126 	beq	r4,zero,8112879c <_strtod_r+0x15c>
81128798:	b5a0003c 	xorhi	r22,r22,32768
8112879c:	a805883a 	mov	r2,r21
811287a0:	b007883a 	mov	r3,r22
811287a4:	dfc01d17 	ldw	ra,116(sp)
811287a8:	df001c17 	ldw	fp,112(sp)
811287ac:	ddc01b17 	ldw	r23,108(sp)
811287b0:	dd801a17 	ldw	r22,104(sp)
811287b4:	dd401917 	ldw	r21,100(sp)
811287b8:	dd001817 	ldw	r20,96(sp)
811287bc:	dcc01717 	ldw	r19,92(sp)
811287c0:	dc801617 	ldw	r18,88(sp)
811287c4:	dc401517 	ldw	r17,84(sp)
811287c8:	dc001417 	ldw	r16,80(sp)
811287cc:	dec01e04 	addi	sp,sp,120
811287d0:	f800283a 	ret
811287d4:	d8000715 	stw	zero,28(sp)
811287d8:	24c00044 	addi	r19,r4,1
811287dc:	dcc00615 	stw	r19,24(sp)
811287e0:	20800043 	ldbu	r2,1(r4)
811287e4:	10c03fcc 	andi	r3,r2,255
811287e8:	18c0201c 	xori	r3,r3,128
811287ec:	18ffe004 	addi	r3,r3,-128
811287f0:	183fe226 	beq	r3,zero,8112877c <__reset+0xfb10877c>
811287f4:	11403fcc 	andi	r5,r2,255
811287f8:	2940201c 	xori	r5,r5,128
811287fc:	297fe004 	addi	r5,r5,-128
81128800:	00c00c04 	movi	r3,48
81128804:	28c0e526 	beq	r5,r3,81128b9c <_strtod_r+0x55c>
81128808:	dcc00815 	stw	r19,32(sp)
8112880c:	0025883a 	mov	r18,zero
81128810:	10fff404 	addi	r3,r2,-48
81128814:	18c03fcc 	andi	r3,r3,255
81128818:	01000244 	movi	r4,9
8112881c:	20c37536 	bltu	r4,r3,811295f4 <_strtod_r+0xfb4>
81128820:	dd400817 	ldw	r21,32(sp)
81128824:	0027883a 	mov	r19,zero
81128828:	0039883a 	mov	fp,zero
8112882c:	002d883a 	mov	r22,zero
81128830:	01400204 	movi	r5,8
81128834:	2d805a16 	blt	r5,r22,811289a0 <_strtod_r+0x360>
81128838:	e70002a4 	muli	fp,fp,10
8112883c:	10c03fcc 	andi	r3,r2,255
81128840:	18c0201c 	xori	r3,r3,128
81128844:	18ffe004 	addi	r3,r3,-128
81128848:	e0f9883a 	add	fp,fp,r3
8112884c:	e73ff404 	addi	fp,fp,-48
81128850:	ad400044 	addi	r21,r21,1
81128854:	dd400615 	stw	r21,24(sp)
81128858:	a8800003 	ldbu	r2,0(r21)
8112885c:	b5800044 	addi	r22,r22,1
81128860:	10fff404 	addi	r3,r2,-48
81128864:	18c03fcc 	andi	r3,r3,255
81128868:	20fff22e 	bgeu	r4,r3,81128834 <__reset+0xfb108834>
8112886c:	14403fcc 	andi	r17,r2,255
81128870:	8c40201c 	xori	r17,r17,128
81128874:	8c7fe004 	addi	r17,r17,-128
81128878:	8009883a 	mov	r4,r16
8112887c:	11268600 	call	81126860 <_localeconv_r>
81128880:	11400017 	ldw	r5,0(r2)
81128884:	8009883a 	mov	r4,r16
81128888:	d9401315 	stw	r5,76(sp)
8112888c:	11268600 	call	81126860 <_localeconv_r>
81128890:	11000017 	ldw	r4,0(r2)
81128894:	111d6400 	call	8111d640 <strlen>
81128898:	d9401317 	ldw	r5,76(sp)
8112889c:	100d883a 	mov	r6,r2
811288a0:	a809883a 	mov	r4,r21
811288a4:	112e2300 	call	8112e230 <strncmp>
811288a8:	1000ce26 	beq	r2,zero,81128be4 <_strtod_r+0x5a4>
811288ac:	b013883a 	mov	r9,r22
811288b0:	000b883a 	mov	r5,zero
811288b4:	0015883a 	mov	r10,zero
811288b8:	0017883a 	mov	r11,zero
811288bc:	00801944 	movi	r2,101
811288c0:	88807826 	beq	r17,r2,81128aa4 <_strtod_r+0x464>
811288c4:	00801144 	movi	r2,69
811288c8:	88807626 	beq	r17,r2,81128aa4 <_strtod_r+0x464>
811288cc:	002b883a 	mov	r21,zero
811288d0:	48003d1e 	bne	r9,zero,811289c8 <_strtod_r+0x388>
811288d4:	2800391e 	bne	r5,zero,811289bc <_strtod_r+0x37c>
811288d8:	9000381e 	bne	r18,zero,811289bc <_strtod_r+0x37c>
811288dc:	583fa71e 	bne	r11,zero,8112877c <__reset+0xfb10877c>
811288e0:	00801384 	movi	r2,78
811288e4:	88800526 	beq	r17,r2,811288fc <_strtod_r+0x2bc>
811288e8:	147fa20e 	bge	r2,r17,81128774 <__reset+0xfb108774>
811288ec:	00801a44 	movi	r2,105
811288f0:	8883d726 	beq	r17,r2,81129850 <_strtod_r+0x1210>
811288f4:	00801b84 	movi	r2,110
811288f8:	88bfa01e 	bne	r17,r2,8112877c <__reset+0xfb10877c>
811288fc:	01604574 	movhi	r5,33045
81128900:	d9000617 	ldw	r4,24(sp)
81128904:	296bcf04 	addi	r5,r5,-20676
81128908:	01c00644 	movi	r7,25
8112890c:	00000b06 	br	8112893c <_strtod_r+0x2fc>
81128910:	21000044 	addi	r4,r4,1
81128914:	20800003 	ldbu	r2,0(r4)
81128918:	10ffefc4 	addi	r3,r2,-65
8112891c:	10803fcc 	andi	r2,r2,255
81128920:	1080201c 	xori	r2,r2,128
81128924:	18c03fcc 	andi	r3,r3,255
81128928:	10bfe004 	addi	r2,r2,-128
8112892c:	38c00136 	bltu	r7,r3,81128934 <_strtod_r+0x2f4>
81128930:	10800804 	addi	r2,r2,32
81128934:	29400044 	addi	r5,r5,1
81128938:	11bf901e 	bne	r2,r6,8112877c <__reset+0xfb10877c>
8112893c:	29800007 	ldb	r6,0(r5)
81128940:	303ff31e 	bne	r6,zero,81128910 <__reset+0xfb108910>
81128944:	20800044 	addi	r2,r4,1
81128948:	d8800615 	stw	r2,24(sp)
8112894c:	20c00047 	ldb	r3,1(r4)
81128950:	00800a04 	movi	r2,40
81128954:	18849d26 	beq	r3,r2,81129bcc <_strtod_r+0x158c>
81128958:	047ffe34 	movhi	r17,65528
8112895c:	0025883a 	mov	r18,zero
81128960:	902b883a 	mov	r21,r18
81128964:	882d883a 	mov	r22,r17
81128968:	a03f8926 	beq	r20,zero,81128790 <__reset+0xfb108790>
8112896c:	ddc00617 	ldw	r23,24(sp)
81128970:	003f8606 	br	8112878c <__reset+0xfb10878c>
81128974:	00800044 	movi	r2,1
81128978:	d8800715 	stw	r2,28(sp)
8112897c:	003f9606 	br	811287d8 <__reset+0xfb1087d8>
81128980:	21000044 	addi	r4,r4,1
81128984:	d9000615 	stw	r4,24(sp)
81128988:	20800003 	ldbu	r2,0(r4)
8112898c:	10c03fcc 	andi	r3,r2,255
81128990:	28ff462e 	bgeu	r5,r3,811286ac <__reset+0xfb1086ac>
81128994:	2027883a 	mov	r19,r4
81128998:	d8000715 	stw	zero,28(sp)
8112899c:	003f9506 	br	811287f4 <__reset+0xfb1087f4>
811289a0:	9cc002a4 	muli	r19,r19,10
811289a4:	10803fcc 	andi	r2,r2,255
811289a8:	1080201c 	xori	r2,r2,128
811289ac:	10bfe004 	addi	r2,r2,-128
811289b0:	9885883a 	add	r2,r19,r2
811289b4:	14fff404 	addi	r19,r2,-48
811289b8:	003fa506 	br	81128850 <__reset+0xfb108850>
811289bc:	002b883a 	mov	r21,zero
811289c0:	002d883a 	mov	r22,zero
811289c4:	003fe806 	br	81128968 <__reset+0xfb108968>
811289c8:	aaabc83a 	sub	r21,r21,r10
811289cc:	b000011e 	bne	r22,zero,811289d4 <_strtod_r+0x394>
811289d0:	482d883a 	mov	r22,r9
811289d4:	00800404 	movi	r2,16
811289d8:	482f883a 	mov	r23,r9
811289dc:	1240010e 	bge	r2,r9,811289e4 <_strtod_r+0x3a4>
811289e0:	102f883a 	mov	r23,r2
811289e4:	e009883a 	mov	r4,fp
811289e8:	da401315 	stw	r9,76(sp)
811289ec:	11312500 	call	81131250 <__floatunsidf>
811289f0:	1025883a 	mov	r18,r2
811289f4:	00800244 	movi	r2,9
811289f8:	1823883a 	mov	r17,r3
811289fc:	da401317 	ldw	r9,76(sp)
81128a00:	15c0160e 	bge	r2,r23,81128a5c <_strtod_r+0x41c>
81128a04:	b8bffdc4 	addi	r2,r23,-9
81128a08:	100490fa 	slli	r2,r2,3
81128a0c:	180b883a 	mov	r5,r3
81128a10:	00e04574 	movhi	r3,33045
81128a14:	18eb9a04 	addi	r3,r3,-20888
81128a18:	1885883a 	add	r2,r3,r2
81128a1c:	11800017 	ldw	r6,0(r2)
81128a20:	11c00117 	ldw	r7,4(r2)
81128a24:	9009883a 	mov	r4,r18
81128a28:	111aefc0 	call	8111aefc <__muldf3>
81128a2c:	9809883a 	mov	r4,r19
81128a30:	1025883a 	mov	r18,r2
81128a34:	1823883a 	mov	r17,r3
81128a38:	11312500 	call	81131250 <__floatunsidf>
81128a3c:	9009883a 	mov	r4,r18
81128a40:	880b883a 	mov	r5,r17
81128a44:	100d883a 	mov	r6,r2
81128a48:	180f883a 	mov	r7,r3
81128a4c:	112f3ec0 	call	8112f3ec <__adddf3>
81128a50:	da401317 	ldw	r9,76(sp)
81128a54:	1025883a 	mov	r18,r2
81128a58:	1823883a 	mov	r17,r3
81128a5c:	008003c4 	movi	r2,15
81128a60:	12407b16 	blt	r2,r9,81128c50 <_strtod_r+0x610>
81128a64:	a83fbe26 	beq	r21,zero,81128960 <__reset+0xfb108960>
81128a68:	0543670e 	bge	zero,r21,81129808 <_strtod_r+0x11c8>
81128a6c:	00c00584 	movi	r3,22
81128a70:	1d42e816 	blt	r3,r21,81129614 <_strtod_r+0xfd4>
81128a74:	a82a90fa 	slli	r21,r21,3
81128a78:	00a04574 	movhi	r2,33045
81128a7c:	10ab9a04 	addi	r2,r2,-20888
81128a80:	1545883a 	add	r2,r2,r21
81128a84:	11000017 	ldw	r4,0(r2)
81128a88:	11400117 	ldw	r5,4(r2)
81128a8c:	900d883a 	mov	r6,r18
81128a90:	880f883a 	mov	r7,r17
81128a94:	111aefc0 	call	8111aefc <__muldf3>
81128a98:	102b883a 	mov	r21,r2
81128a9c:	182d883a 	mov	r22,r3
81128aa0:	003fb106 	br	81128968 <__reset+0xfb108968>
81128aa4:	4801b526 	beq	r9,zero,8112917c <_strtod_r+0xb3c>
81128aa8:	ddc00617 	ldw	r23,24(sp)
81128aac:	00c00ac4 	movi	r3,43
81128ab0:	b8800044 	addi	r2,r23,1
81128ab4:	d8800615 	stw	r2,24(sp)
81128ab8:	b8800047 	ldb	r2,1(r23)
81128abc:	10c1e926 	beq	r2,r3,81129264 <_strtod_r+0xc24>
81128ac0:	00c00b44 	movi	r3,45
81128ac4:	10c1ec26 	beq	r2,r3,81129278 <_strtod_r+0xc38>
81128ac8:	1023883a 	mov	r17,r2
81128acc:	0019883a 	mov	r12,zero
81128ad0:	88bff404 	addi	r2,r17,-48
81128ad4:	00c00244 	movi	r3,9
81128ad8:	1881b736 	bltu	r3,r2,811291b8 <_strtod_r+0xb78>
81128adc:	00800c04 	movi	r2,48
81128ae0:	8880071e 	bne	r17,r2,81128b00 <_strtod_r+0x4c0>
81128ae4:	d8800617 	ldw	r2,24(sp)
81128ae8:	8807883a 	mov	r3,r17
81128aec:	10800044 	addi	r2,r2,1
81128af0:	d8800615 	stw	r2,24(sp)
81128af4:	14400007 	ldb	r17,0(r2)
81128af8:	10800044 	addi	r2,r2,1
81128afc:	88fffc26 	beq	r17,r3,81128af0 <__reset+0xfb108af0>
81128b00:	88bff3c4 	addi	r2,r17,-49
81128b04:	00c00204 	movi	r3,8
81128b08:	18bf7036 	bltu	r3,r2,811288cc <__reset+0xfb1088cc>
81128b0c:	db800617 	ldw	r14,24(sp)
81128b10:	88bff404 	addi	r2,r17,-48
81128b14:	03400244 	movi	r13,9
81128b18:	71c00044 	addi	r7,r14,1
81128b1c:	d9c00615 	stw	r7,24(sp)
81128b20:	74400043 	ldbu	r17,1(r14)
81128b24:	88fff404 	addi	r3,r17,-48
81128b28:	8c403fcc 	andi	r17,r17,255
81128b2c:	8c40201c 	xori	r17,r17,128
81128b30:	18c03fcc 	andi	r3,r3,255
81128b34:	8c7fe004 	addi	r17,r17,-128
81128b38:	68c00e36 	bltu	r13,r3,81128b74 <_strtod_r+0x534>
81128b3c:	71000084 	addi	r4,r14,2
81128b40:	d9000615 	stw	r4,24(sp)
81128b44:	108002a4 	muli	r2,r2,10
81128b48:	21800003 	ldbu	r6,0(r4)
81128b4c:	200f883a 	mov	r7,r4
81128b50:	1463883a 	add	r17,r2,r17
81128b54:	30fff404 	addi	r3,r6,-48
81128b58:	88bff404 	addi	r2,r17,-48
81128b5c:	34403fcc 	andi	r17,r6,255
81128b60:	8c40201c 	xori	r17,r17,128
81128b64:	18c03fcc 	andi	r3,r3,255
81128b68:	8c7fe004 	addi	r17,r17,-128
81128b6c:	21000044 	addi	r4,r4,1
81128b70:	68fff32e 	bgeu	r13,r3,81128b40 <__reset+0xfb108b40>
81128b74:	3b8fc83a 	sub	r7,r7,r14
81128b78:	00c00204 	movi	r3,8
81128b7c:	19c29716 	blt	r3,r7,811295dc <_strtod_r+0xf9c>
81128b80:	102b883a 	mov	r21,r2
81128b84:	009387c4 	movi	r2,19999
81128b88:	1540010e 	bge	r2,r21,81128b90 <_strtod_r+0x550>
81128b8c:	102b883a 	mov	r21,r2
81128b90:	603f4f26 	beq	r12,zero,811288d0 <__reset+0xfb1088d0>
81128b94:	056bc83a 	sub	r21,zero,r21
81128b98:	003f4d06 	br	811288d0 <__reset+0xfb1088d0>
81128b9c:	98800047 	ldb	r2,1(r19)
81128ba0:	00c01604 	movi	r3,88
81128ba4:	10c1de26 	beq	r2,r3,81129320 <_strtod_r+0xce0>
81128ba8:	00c01e04 	movi	r3,120
81128bac:	10c1dc26 	beq	r2,r3,81129320 <_strtod_r+0xce0>
81128bb0:	98c00044 	addi	r3,r19,1
81128bb4:	1827883a 	mov	r19,r3
81128bb8:	d8c00615 	stw	r3,24(sp)
81128bbc:	18c00044 	addi	r3,r3,1
81128bc0:	18bfffc3 	ldbu	r2,-1(r3)
81128bc4:	11003fcc 	andi	r4,r2,255
81128bc8:	2100201c 	xori	r4,r4,128
81128bcc:	213fe004 	addi	r4,r4,-128
81128bd0:	217ff826 	beq	r4,r5,81128bb4 <__reset+0xfb108bb4>
81128bd4:	203f7926 	beq	r4,zero,811289bc <__reset+0xfb1089bc>
81128bd8:	dcc00815 	stw	r19,32(sp)
81128bdc:	04800044 	movi	r18,1
81128be0:	003f0b06 	br	81128810 <__reset+0xfb108810>
81128be4:	8009883a 	mov	r4,r16
81128be8:	11268600 	call	81126860 <_localeconv_r>
81128bec:	11000017 	ldw	r4,0(r2)
81128bf0:	111d6400 	call	8111d640 <strlen>
81128bf4:	d8c00617 	ldw	r3,24(sp)
81128bf8:	1885883a 	add	r2,r3,r2
81128bfc:	d8800615 	stw	r2,24(sp)
81128c00:	14400007 	ldb	r17,0(r2)
81128c04:	b001881e 	bne	r22,zero,81129228 <_strtod_r+0xbe8>
81128c08:	00c00c04 	movi	r3,48
81128c0c:	88c3391e 	bne	r17,r3,811298f4 <_strtod_r+0x12b4>
81128c10:	10c00044 	addi	r3,r2,1
81128c14:	8809883a 	mov	r4,r17
81128c18:	d8c00615 	stw	r3,24(sp)
81128c1c:	1c400007 	ldb	r17,0(r3)
81128c20:	188bc83a 	sub	r5,r3,r2
81128c24:	18c00044 	addi	r3,r3,1
81128c28:	893ffb26 	beq	r17,r4,81128c18 <__reset+0xfb108c18>
81128c2c:	88bff3c4 	addi	r2,r17,-49
81128c30:	00c00204 	movi	r3,8
81128c34:	1882e72e 	bgeu	r3,r2,811297d4 <_strtod_r+0x1194>
81128c38:	00801944 	movi	r2,101
81128c3c:	88814d26 	beq	r17,r2,81129174 <_strtod_r+0xb34>
81128c40:	0013883a 	mov	r9,zero
81128c44:	0015883a 	mov	r10,zero
81128c48:	02c00044 	movi	r11,1
81128c4c:	003f1d06 	br	811288c4 <__reset+0xfb1088c4>
81128c50:	4defc83a 	sub	r23,r9,r23
81128c54:	bd6f883a 	add	r23,r23,r21
81128c58:	05c21e0e 	bge	zero,r23,811294d4 <_strtod_r+0xe94>
81128c5c:	b88003cc 	andi	r2,r23,15
81128c60:	10000d26 	beq	r2,zero,81128c98 <_strtod_r+0x658>
81128c64:	100490fa 	slli	r2,r2,3
81128c68:	00e04574 	movhi	r3,33045
81128c6c:	18eb9a04 	addi	r3,r3,-20888
81128c70:	1885883a 	add	r2,r3,r2
81128c74:	11000017 	ldw	r4,0(r2)
81128c78:	11400117 	ldw	r5,4(r2)
81128c7c:	900d883a 	mov	r6,r18
81128c80:	880f883a 	mov	r7,r17
81128c84:	da401315 	stw	r9,76(sp)
81128c88:	111aefc0 	call	8111aefc <__muldf3>
81128c8c:	da401317 	ldw	r9,76(sp)
81128c90:	1025883a 	mov	r18,r2
81128c94:	1823883a 	mov	r17,r3
81128c98:	023ffc04 	movi	r8,-16
81128c9c:	ba10703a 	and	r8,r23,r8
81128ca0:	40003c26 	beq	r8,zero,81128d94 <_strtod_r+0x754>
81128ca4:	00804d04 	movi	r2,308
81128ca8:	1201cd16 	blt	r2,r8,811293e0 <_strtod_r+0xda0>
81128cac:	4011d13a 	srai	r8,r8,4
81128cb0:	03000044 	movi	r12,1
81128cb4:	62037c0e 	bge	r12,r8,81129aa8 <_strtod_r+0x1468>
81128cb8:	01204574 	movhi	r4,33045
81128cbc:	212b9004 	addi	r4,r4,-20928
81128cc0:	2015883a 	mov	r10,r4
81128cc4:	0027883a 	mov	r19,zero
81128cc8:	d9000915 	stw	r4,36(sp)
81128ccc:	9005883a 	mov	r2,r18
81128cd0:	8807883a 	mov	r3,r17
81128cd4:	dc000c15 	stw	r16,48(sp)
81128cd8:	dc800e15 	stw	r18,56(sp)
81128cdc:	9821883a 	mov	r16,r19
81128ce0:	0009883a 	mov	r4,zero
81128ce4:	8827883a 	mov	r19,r17
81128ce8:	602f883a 	mov	r23,r12
81128cec:	da400a15 	stw	r9,40(sp)
81128cf0:	5025883a 	mov	r18,r10
81128cf4:	4023883a 	mov	r17,r8
81128cf8:	8980004c 	andi	r6,r17,1
81128cfc:	30000626 	beq	r6,zero,81128d18 <_strtod_r+0x6d8>
81128d00:	91800017 	ldw	r6,0(r18)
81128d04:	91c00117 	ldw	r7,4(r18)
81128d08:	1009883a 	mov	r4,r2
81128d0c:	180b883a 	mov	r5,r3
81128d10:	111aefc0 	call	8111aefc <__muldf3>
81128d14:	01000044 	movi	r4,1
81128d18:	8823d07a 	srai	r17,r17,1
81128d1c:	84000044 	addi	r16,r16,1
81128d20:	94800204 	addi	r18,r18,8
81128d24:	8dfff41e 	bne	r17,r23,81128cf8 <__reset+0xfb108cf8>
81128d28:	21003fcc 	andi	r4,r4,255
81128d2c:	9823883a 	mov	r17,r19
81128d30:	da400a17 	ldw	r9,40(sp)
81128d34:	8027883a 	mov	r19,r16
81128d38:	dc800e17 	ldw	r18,56(sp)
81128d3c:	dc000c17 	ldw	r16,48(sp)
81128d40:	2003b11e 	bne	r4,zero,81129c08 <_strtod_r+0x15c8>
81128d44:	981690fa 	slli	r11,r19,3
81128d48:	d8800917 	ldw	r2,36(sp)
81128d4c:	01ff2c34 	movhi	r7,64688
81128d50:	900d883a 	mov	r6,r18
81128d54:	12ef883a 	add	r23,r2,r11
81128d58:	b9000017 	ldw	r4,0(r23)
81128d5c:	b9400117 	ldw	r5,4(r23)
81128d60:	89cf883a 	add	r7,r17,r7
81128d64:	da401315 	stw	r9,76(sp)
81128d68:	111aefc0 	call	8111aefc <__muldf3>
81128d6c:	1025883a 	mov	r18,r2
81128d70:	011f2834 	movhi	r4,31904
81128d74:	189ffc2c 	andhi	r2,r3,32752
81128d78:	da401317 	ldw	r9,76(sp)
81128d7c:	20819836 	bltu	r4,r2,811293e0 <_strtod_r+0xda0>
81128d80:	011f2434 	movhi	r4,31888
81128d84:	2083382e 	bgeu	r4,r2,81129a68 <_strtod_r+0x1428>
81128d88:	045ffc34 	movhi	r17,32752
81128d8c:	8c7fffc4 	addi	r17,r17,-1
81128d90:	04bfffc4 	movi	r18,-1
81128d94:	d8000915 	stw	zero,36(sp)
81128d98:	d9400817 	ldw	r5,32(sp)
81128d9c:	df000015 	stw	fp,0(sp)
81128da0:	480f883a 	mov	r7,r9
81128da4:	b00d883a 	mov	r6,r22
81128da8:	8009883a 	mov	r4,r16
81128dac:	1126f7c0 	call	81126f7c <__s2b>
81128db0:	d8800815 	stw	r2,32(sp)
81128db4:	10018a26 	beq	r2,zero,811293e0 <_strtod_r+0xda0>
81128db8:	a807d7fa 	srai	r3,r21,31
81128dbc:	0545c83a 	sub	r2,zero,r21
81128dc0:	dd400a15 	stw	r21,40(sp)
81128dc4:	1886703a 	and	r3,r3,r2
81128dc8:	d8c00c15 	stw	r3,48(sp)
81128dcc:	a8013516 	blt	r21,zero,811292a4 <_strtod_r+0xc64>
81128dd0:	d9400817 	ldw	r5,32(sp)
81128dd4:	0011883a 	mov	r8,zero
81128dd8:	0027883a 	mov	r19,zero
81128ddc:	29400304 	addi	r5,r5,12
81128de0:	d9400f15 	stw	r5,60(sp)
81128de4:	402b883a 	mov	r21,r8
81128de8:	dd001215 	stw	r20,72(sp)
81128dec:	d8800817 	ldw	r2,32(sp)
81128df0:	8009883a 	mov	r4,r16
81128df4:	11400117 	ldw	r5,4(r2)
81128df8:	1126d7c0 	call	81126d7c <_Balloc>
81128dfc:	1029883a 	mov	r20,r2
81128e00:	10012d26 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128e04:	d8c00817 	ldw	r3,32(sp)
81128e08:	d9400f17 	ldw	r5,60(sp)
81128e0c:	11000304 	addi	r4,r2,12
81128e10:	19800417 	ldw	r6,16(r3)
81128e14:	31800084 	addi	r6,r6,2
81128e18:	318d883a 	add	r6,r6,r6
81128e1c:	318d883a 	add	r6,r6,r6
81128e20:	111cb4c0 	call	8111cb4c <memcpy>
81128e24:	d9000204 	addi	r4,sp,8
81128e28:	d9000015 	stw	r4,0(sp)
81128e2c:	d9c00404 	addi	r7,sp,16
81128e30:	900b883a 	mov	r5,r18
81128e34:	880d883a 	mov	r6,r17
81128e38:	8009883a 	mov	r4,r16
81128e3c:	1127a580 	call	81127a58 <__d2b>
81128e40:	d8800515 	stw	r2,20(sp)
81128e44:	dc801115 	stw	r18,68(sp)
81128e48:	dc401015 	stw	r17,64(sp)
81128e4c:	10027c26 	beq	r2,zero,81129840 <_strtod_r+0x1200>
81128e50:	01400044 	movi	r5,1
81128e54:	8009883a 	mov	r4,r16
81128e58:	11271a00 	call	811271a0 <__i2b>
81128e5c:	1027883a 	mov	r19,r2
81128e60:	10011526 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128e64:	d8800417 	ldw	r2,16(sp)
81128e68:	1000c816 	blt	r2,zero,8112918c <_strtod_r+0xb4c>
81128e6c:	d9400c17 	ldw	r5,48(sp)
81128e70:	d9000a17 	ldw	r4,40(sp)
81128e74:	28ad883a 	add	r22,r5,r2
81128e78:	d9400917 	ldw	r5,36(sp)
81128e7c:	df000217 	ldw	fp,8(sp)
81128e80:	05ff0084 	movi	r23,-1022
81128e84:	1147c83a 	sub	r3,r2,r5
81128e88:	1f07883a 	add	r3,r3,fp
81128e8c:	00800d84 	movi	r2,54
81128e90:	18ffffc4 	addi	r3,r3,-1
81128e94:	1739c83a 	sub	fp,r2,fp
81128e98:	1dc0a50e 	bge	r3,r23,81129130 <_strtod_r+0xaf0>
81128e9c:	b8efc83a 	sub	r23,r23,r3
81128ea0:	008007c4 	movi	r2,31
81128ea4:	e5f9c83a 	sub	fp,fp,r23
81128ea8:	15c0bc16 	blt	r2,r23,8112919c <_strtod_r+0xb5c>
81128eac:	00800044 	movi	r2,1
81128eb0:	15c4983a 	sll	r2,r2,r23
81128eb4:	d8000b15 	stw	zero,44(sp)
81128eb8:	d8800d15 	stw	r2,52(sp)
81128ebc:	2707883a 	add	r3,r4,fp
81128ec0:	d9000917 	ldw	r4,36(sp)
81128ec4:	b739883a 	add	fp,r22,fp
81128ec8:	20ef883a 	add	r23,r4,r3
81128ecc:	b009883a 	mov	r4,r22
81128ed0:	e580010e 	bge	fp,r22,81128ed8 <_strtod_r+0x898>
81128ed4:	e009883a 	mov	r4,fp
81128ed8:	b805883a 	mov	r2,r23
81128edc:	25c0010e 	bge	r4,r23,81128ee4 <_strtod_r+0x8a4>
81128ee0:	2005883a 	mov	r2,r4
81128ee4:	0080030e 	bge	zero,r2,81128ef4 <_strtod_r+0x8b4>
81128ee8:	e0b9c83a 	sub	fp,fp,r2
81128eec:	b8afc83a 	sub	r23,r23,r2
81128ef0:	b0adc83a 	sub	r22,r22,r2
81128ef4:	d9400c17 	ldw	r5,48(sp)
81128ef8:	28001126 	beq	r5,zero,81128f40 <_strtod_r+0x900>
81128efc:	280d883a 	mov	r6,r5
81128f00:	8009883a 	mov	r4,r16
81128f04:	980b883a 	mov	r5,r19
81128f08:	11273e40 	call	811273e4 <__pow5mult>
81128f0c:	1027883a 	mov	r19,r2
81128f10:	1000e926 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128f14:	d9800517 	ldw	r6,20(sp)
81128f18:	100b883a 	mov	r5,r2
81128f1c:	8009883a 	mov	r4,r16
81128f20:	11271e40 	call	811271e4 <__multiply>
81128f24:	1000e426 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128f28:	d9400517 	ldw	r5,20(sp)
81128f2c:	8009883a 	mov	r4,r16
81128f30:	d8801315 	stw	r2,76(sp)
81128f34:	1126e2c0 	call	81126e2c <_Bfree>
81128f38:	d8801317 	ldw	r2,76(sp)
81128f3c:	d8800515 	stw	r2,20(sp)
81128f40:	0700060e 	bge	zero,fp,81128f5c <_strtod_r+0x91c>
81128f44:	d9400517 	ldw	r5,20(sp)
81128f48:	e00d883a 	mov	r6,fp
81128f4c:	8009883a 	mov	r4,r16
81128f50:	112752c0 	call	8112752c <__lshift>
81128f54:	d8800515 	stw	r2,20(sp)
81128f58:	10023926 	beq	r2,zero,81129840 <_strtod_r+0x1200>
81128f5c:	d8800a17 	ldw	r2,40(sp)
81128f60:	10000626 	beq	r2,zero,81128f7c <_strtod_r+0x93c>
81128f64:	d9800a17 	ldw	r6,40(sp)
81128f68:	a00b883a 	mov	r5,r20
81128f6c:	8009883a 	mov	r4,r16
81128f70:	11273e40 	call	811273e4 <__pow5mult>
81128f74:	1029883a 	mov	r20,r2
81128f78:	1000cf26 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128f7c:	05c0060e 	bge	zero,r23,81128f98 <_strtod_r+0x958>
81128f80:	a00b883a 	mov	r5,r20
81128f84:	b80d883a 	mov	r6,r23
81128f88:	8009883a 	mov	r4,r16
81128f8c:	112752c0 	call	8112752c <__lshift>
81128f90:	1029883a 	mov	r20,r2
81128f94:	1000c826 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128f98:	0580060e 	bge	zero,r22,81128fb4 <_strtod_r+0x974>
81128f9c:	980b883a 	mov	r5,r19
81128fa0:	b00d883a 	mov	r6,r22
81128fa4:	8009883a 	mov	r4,r16
81128fa8:	112752c0 	call	8112752c <__lshift>
81128fac:	1027883a 	mov	r19,r2
81128fb0:	1000c126 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128fb4:	d9400517 	ldw	r5,20(sp)
81128fb8:	a00d883a 	mov	r6,r20
81128fbc:	8009883a 	mov	r4,r16
81128fc0:	11276dc0 	call	811276dc <__mdiff>
81128fc4:	102b883a 	mov	r21,r2
81128fc8:	1000bb26 	beq	r2,zero,811292b8 <_strtod_r+0xc78>
81128fcc:	10c00317 	ldw	r3,12(r2)
81128fd0:	980b883a 	mov	r5,r19
81128fd4:	10000315 	stw	zero,12(r2)
81128fd8:	1009883a 	mov	r4,r2
81128fdc:	d8c00e15 	stw	r3,56(sp)
81128fe0:	112767c0 	call	8112767c <__mcmp>
81128fe4:	10027616 	blt	r2,zero,811299c0 <_strtod_r+0x1380>
81128fe8:	10024426 	beq	r2,zero,811298fc <_strtod_r+0x12bc>
81128fec:	980b883a 	mov	r5,r19
81128ff0:	a809883a 	mov	r4,r21
81128ff4:	1127bac0 	call	81127bac <__ratio>
81128ff8:	000d883a 	mov	r6,zero
81128ffc:	01d00034 	movhi	r7,16384
81129000:	1009883a 	mov	r4,r2
81129004:	180b883a 	mov	r5,r3
81129008:	102f883a 	mov	r23,r2
8112900c:	182d883a 	mov	r22,r3
81129010:	11306f40 	call	811306f4 <__ledf2>
81129014:	00804a16 	blt	zero,r2,81129140 <_strtod_r+0xb00>
81129018:	d9400e17 	ldw	r5,56(sp)
8112901c:	28006b26 	beq	r5,zero,811291cc <_strtod_r+0xb8c>
81129020:	058ffc34 	movhi	r22,16368
81129024:	d8000b15 	stw	zero,44(sp)
81129028:	d8000d15 	stw	zero,52(sp)
8112902c:	b02f883a 	mov	r23,r22
81129030:	8f1ffc2c 	andhi	fp,r17,32752
81129034:	009ff834 	movhi	r2,32736
81129038:	e080cd26 	beq	fp,r2,81129370 <_strtod_r+0xd30>
8112903c:	d9400917 	ldw	r5,36(sp)
81129040:	28001a26 	beq	r5,zero,811290ac <_strtod_r+0xa6c>
81129044:	0081a834 	movhi	r2,1696
81129048:	17001836 	bltu	r2,fp,811290ac <_strtod_r+0xa6c>
8112904c:	d9000d17 	ldw	r4,52(sp)
81129050:	01d07834 	movhi	r7,16864
81129054:	39ffffc4 	addi	r7,r7,-1
81129058:	01bff034 	movhi	r6,65472
8112905c:	b80b883a 	mov	r5,r23
81129060:	11306f40 	call	811306f4 <__ledf2>
81129064:	00800e16 	blt	zero,r2,811290a0 <_strtod_r+0xa60>
81129068:	d9000d17 	ldw	r4,52(sp)
8112906c:	b80b883a 	mov	r5,r23
81129070:	112e5000 	call	8112e500 <__fixunsdfsi>
81129074:	10018126 	beq	r2,zero,8112967c <_strtod_r+0x103c>
81129078:	1009883a 	mov	r4,r2
8112907c:	11312500 	call	81131250 <__floatunsidf>
81129080:	d8800d15 	stw	r2,52(sp)
81129084:	182f883a 	mov	r23,r3
81129088:	d8800e17 	ldw	r2,56(sp)
8112908c:	1001791e 	bne	r2,zero,81129674 <_strtod_r+0x1034>
81129090:	ba20003c 	xorhi	r8,r23,32768
81129094:	d8c00d17 	ldw	r3,52(sp)
81129098:	402d883a 	mov	r22,r8
8112909c:	d8c00b15 	stw	r3,44(sp)
811290a0:	0081ac34 	movhi	r2,1712
811290a4:	b091883a 	add	r8,r22,r2
811290a8:	472dc83a 	sub	r22,r8,fp
811290ac:	9009883a 	mov	r4,r18
811290b0:	880b883a 	mov	r5,r17
811290b4:	11278e00 	call	811278e0 <__ulp>
811290b8:	d9000b17 	ldw	r4,44(sp)
811290bc:	b00b883a 	mov	r5,r22
811290c0:	100d883a 	mov	r6,r2
811290c4:	180f883a 	mov	r7,r3
811290c8:	111aefc0 	call	8111aefc <__muldf3>
811290cc:	900d883a 	mov	r6,r18
811290d0:	880f883a 	mov	r7,r17
811290d4:	1009883a 	mov	r4,r2
811290d8:	180b883a 	mov	r5,r3
811290dc:	112f3ec0 	call	8112f3ec <__adddf3>
811290e0:	1025883a 	mov	r18,r2
811290e4:	1823883a 	mov	r17,r3
811290e8:	182d883a 	mov	r22,r3
811290ec:	d9000917 	ldw	r4,36(sp)
811290f0:	2000021e 	bne	r4,zero,811290fc <_strtod_r+0xabc>
811290f4:	b09ffc2c 	andhi	r2,r22,32752
811290f8:	e080be26 	beq	fp,r2,811293f4 <_strtod_r+0xdb4>
811290fc:	d9400517 	ldw	r5,20(sp)
81129100:	8009883a 	mov	r4,r16
81129104:	1126e2c0 	call	81126e2c <_Bfree>
81129108:	a00b883a 	mov	r5,r20
8112910c:	8009883a 	mov	r4,r16
81129110:	1126e2c0 	call	81126e2c <_Bfree>
81129114:	980b883a 	mov	r5,r19
81129118:	8009883a 	mov	r4,r16
8112911c:	1126e2c0 	call	81126e2c <_Bfree>
81129120:	a80b883a 	mov	r5,r21
81129124:	8009883a 	mov	r4,r16
81129128:	1126e2c0 	call	81126e2c <_Bfree>
8112912c:	003f2f06 	br	81128dec <__reset+0xfb108dec>
81129130:	00c00044 	movi	r3,1
81129134:	d8000b15 	stw	zero,44(sp)
81129138:	d8c00d15 	stw	r3,52(sp)
8112913c:	003f5f06 	br	81128ebc <__reset+0xfb108ebc>
81129140:	b809883a 	mov	r4,r23
81129144:	000d883a 	mov	r6,zero
81129148:	01cff834 	movhi	r7,16352
8112914c:	b00b883a 	mov	r5,r22
81129150:	111aefc0 	call	8111aefc <__muldf3>
81129154:	d9000e17 	ldw	r4,56(sp)
81129158:	d8800d15 	stw	r2,52(sp)
8112915c:	182f883a 	mov	r23,r3
81129160:	2000181e 	bne	r4,zero,811291c4 <_strtod_r+0xb84>
81129164:	1a20003c 	xorhi	r8,r3,32768
81129168:	d8800b15 	stw	r2,44(sp)
8112916c:	402d883a 	mov	r22,r8
81129170:	003faf06 	br	81129030 <__reset+0xfb109030>
81129174:	0015883a 	mov	r10,zero
81129178:	02c00044 	movi	r11,1
8112917c:	2800011e 	bne	r5,zero,81129184 <_strtod_r+0xb44>
81129180:	903d7e26 	beq	r18,zero,8112877c <__reset+0xfb10877c>
81129184:	0013883a 	mov	r9,zero
81129188:	003e4706 	br	81128aa8 <__reset+0xfb108aa8>
8112918c:	d8c00a17 	ldw	r3,40(sp)
81129190:	dd800c17 	ldw	r22,48(sp)
81129194:	1889c83a 	sub	r4,r3,r2
81129198:	003f3706 	br	81128e78 <__reset+0xfb108e78>
8112919c:	00bef884 	movi	r2,-1054
811291a0:	05c00044 	movi	r23,1
811291a4:	10c5c83a 	sub	r2,r2,r3
811291a8:	b884983a 	sll	r2,r23,r2
811291ac:	ddc00d15 	stw	r23,52(sp)
811291b0:	d8800b15 	stw	r2,44(sp)
811291b4:	003f4106 	br	81128ebc <__reset+0xfb108ebc>
811291b8:	ddc00615 	stw	r23,24(sp)
811291bc:	002b883a 	mov	r21,zero
811291c0:	003dc306 	br	811288d0 <__reset+0xfb1088d0>
811291c4:	1811883a 	mov	r8,r3
811291c8:	003fe706 	br	81129168 <__reset+0xfb109168>
811291cc:	90002e1e 	bne	r18,zero,81129288 <_strtod_r+0xc48>
811291d0:	00c00434 	movhi	r3,16
811291d4:	18ffffc4 	addi	r3,r3,-1
811291d8:	88c4703a 	and	r2,r17,r3
811291dc:	10002c1e 	bne	r2,zero,81129290 <_strtod_r+0xc50>
811291e0:	000d883a 	mov	r6,zero
811291e4:	01cffc34 	movhi	r7,16368
811291e8:	b809883a 	mov	r4,r23
811291ec:	b00b883a 	mov	r5,r22
811291f0:	11306f40 	call	811306f4 <__ledf2>
811291f4:	10021716 	blt	r2,zero,81129a54 <_strtod_r+0x1414>
811291f8:	b809883a 	mov	r4,r23
811291fc:	b00b883a 	mov	r5,r22
81129200:	000d883a 	mov	r6,zero
81129204:	01cff834 	movhi	r7,16352
81129208:	111aefc0 	call	8111aefc <__muldf3>
8112920c:	d8800d15 	stw	r2,52(sp)
81129210:	182f883a 	mov	r23,r3
81129214:	102d883a 	mov	r22,r2
81129218:	1a20003c 	xorhi	r8,r3,32768
8112921c:	dd800b15 	stw	r22,44(sp)
81129220:	402d883a 	mov	r22,r8
81129224:	003f8206 	br	81129030 <__reset+0xfb109030>
81129228:	b013883a 	mov	r9,r22
8112922c:	000b883a 	mov	r5,zero
81129230:	0015883a 	mov	r10,zero
81129234:	893ff404 	addi	r4,r17,-48
81129238:	00800244 	movi	r2,9
8112923c:	11001036 	bltu	r2,r4,81129280 <_strtod_r+0xc40>
81129240:	28c00044 	addi	r3,r5,1
81129244:	2023883a 	mov	r17,r4
81129248:	20014d1e 	bne	r4,zero,81129780 <_strtod_r+0x1140>
8112924c:	d9800617 	ldw	r6,24(sp)
81129250:	180b883a 	mov	r5,r3
81129254:	30800044 	addi	r2,r6,1
81129258:	d8800615 	stw	r2,24(sp)
8112925c:	34400047 	ldb	r17,1(r6)
81129260:	003ff406 	br	81129234 <__reset+0xfb109234>
81129264:	0019883a 	mov	r12,zero
81129268:	b8800084 	addi	r2,r23,2
8112926c:	d8800615 	stw	r2,24(sp)
81129270:	bc400087 	ldb	r17,2(r23)
81129274:	003e1606 	br	81128ad0 <__reset+0xfb108ad0>
81129278:	03000044 	movi	r12,1
8112927c:	003ffa06 	br	81129268 <__reset+0xfb109268>
81129280:	02c00044 	movi	r11,1
81129284:	003d8d06 	br	811288bc <__reset+0xfb1088bc>
81129288:	00800044 	movi	r2,1
8112928c:	9080fe26 	beq	r18,r2,81129688 <_strtod_r+0x1048>
81129290:	d8000b15 	stw	zero,44(sp)
81129294:	05affc34 	movhi	r22,49136
81129298:	d8000d15 	stw	zero,52(sp)
8112929c:	05cffc34 	movhi	r23,16368
811292a0:	003f6306 	br	81129030 <__reset+0xfb109030>
811292a4:	d8000a15 	stw	zero,40(sp)
811292a8:	003ec906 	br	81128dd0 <__reset+0xfb108dd0>
811292ac:	d9001117 	ldw	r4,68(sp)
811292b0:	00bfffc4 	movi	r2,-1
811292b4:	2080461e 	bne	r4,r2,811293d0 <_strtod_r+0xd90>
811292b8:	dd000a15 	stw	r20,40(sp)
811292bc:	dd001217 	ldw	r20,72(sp)
811292c0:	a811883a 	mov	r8,r21
811292c4:	d8800517 	ldw	r2,20(sp)
811292c8:	00c00884 	movi	r3,34
811292cc:	80c00015 	stw	r3,0(r16)
811292d0:	002b883a 	mov	r21,zero
811292d4:	059ffc34 	movhi	r22,32752
811292d8:	100b883a 	mov	r5,r2
811292dc:	8009883a 	mov	r4,r16
811292e0:	da001315 	stw	r8,76(sp)
811292e4:	1126e2c0 	call	81126e2c <_Bfree>
811292e8:	d9400a17 	ldw	r5,40(sp)
811292ec:	8009883a 	mov	r4,r16
811292f0:	1126e2c0 	call	81126e2c <_Bfree>
811292f4:	980b883a 	mov	r5,r19
811292f8:	8009883a 	mov	r4,r16
811292fc:	1126e2c0 	call	81126e2c <_Bfree>
81129300:	d9400817 	ldw	r5,32(sp)
81129304:	8009883a 	mov	r4,r16
81129308:	1126e2c0 	call	81126e2c <_Bfree>
8112930c:	da001317 	ldw	r8,76(sp)
81129310:	8009883a 	mov	r4,r16
81129314:	400b883a 	mov	r5,r8
81129318:	1126e2c0 	call	81126e2c <_Bfree>
8112931c:	003d9206 	br	81128968 <__reset+0xfb108968>
81129320:	d8c00717 	ldw	r3,28(sp)
81129324:	d8800504 	addi	r2,sp,20
81129328:	01a04574 	movhi	r6,33045
8112932c:	31abd504 	addi	r6,r6,-20652
81129330:	d8c00115 	stw	r3,4(sp)
81129334:	d8800015 	stw	r2,0(sp)
81129338:	d9c00404 	addi	r7,sp,16
8112933c:	d9400604 	addi	r5,sp,24
81129340:	8009883a 	mov	r4,r16
81129344:	112d7940 	call	8112d794 <__gethex>
81129348:	154001cc 	andi	r21,r2,7
8112934c:	a83d9b26 	beq	r21,zero,811289bc <__reset+0xfb1089bc>
81129350:	00c00184 	movi	r3,6
81129354:	a8c0d61e 	bne	r21,r3,811296b0 <_strtod_r+0x1070>
81129358:	9cc00044 	addi	r19,r19,1
8112935c:	dcc00615 	stw	r19,24(sp)
81129360:	002b883a 	mov	r21,zero
81129364:	002d883a 	mov	r22,zero
81129368:	d8000715 	stw	zero,28(sp)
8112936c:	003d7e06 	br	81128968 <__reset+0xfb108968>
81129370:	00bf2c34 	movhi	r2,64688
81129374:	88a3883a 	add	r17,r17,r2
81129378:	9009883a 	mov	r4,r18
8112937c:	880b883a 	mov	r5,r17
81129380:	11278e00 	call	811278e0 <__ulp>
81129384:	d9000b17 	ldw	r4,44(sp)
81129388:	100d883a 	mov	r6,r2
8112938c:	180f883a 	mov	r7,r3
81129390:	b00b883a 	mov	r5,r22
81129394:	111aefc0 	call	8111aefc <__muldf3>
81129398:	900d883a 	mov	r6,r18
8112939c:	180b883a 	mov	r5,r3
811293a0:	880f883a 	mov	r7,r17
811293a4:	1009883a 	mov	r4,r2
811293a8:	112f3ec0 	call	8112f3ec <__adddf3>
811293ac:	015f2834 	movhi	r5,31904
811293b0:	1025883a 	mov	r18,r2
811293b4:	297fffc4 	addi	r5,r5,-1
811293b8:	189ffc2c 	andhi	r2,r3,32752
811293bc:	2880892e 	bgeu	r5,r2,811295e4 <_strtod_r+0xfa4>
811293c0:	d8801017 	ldw	r2,64(sp)
811293c4:	00dffc34 	movhi	r3,32752
811293c8:	18ffffc4 	addi	r3,r3,-1
811293cc:	10ffb726 	beq	r2,r3,811292ac <__reset+0xfb1092ac>
811293d0:	045ffc34 	movhi	r17,32752
811293d4:	8c7fffc4 	addi	r17,r17,-1
811293d8:	04bfffc4 	movi	r18,-1
811293dc:	003f4706 	br	811290fc <__reset+0xfb1090fc>
811293e0:	00800884 	movi	r2,34
811293e4:	80800015 	stw	r2,0(r16)
811293e8:	002b883a 	mov	r21,zero
811293ec:	059ffc34 	movhi	r22,32752
811293f0:	003d5d06 	br	81128968 <__reset+0xfb108968>
811293f4:	d9000d17 	ldw	r4,52(sp)
811293f8:	b80b883a 	mov	r5,r23
811293fc:	11310ec0 	call	811310ec <__fixdfsi>
81129400:	1009883a 	mov	r4,r2
81129404:	113116c0 	call	8113116c <__floatsidf>
81129408:	d9000d17 	ldw	r4,52(sp)
8112940c:	b80b883a 	mov	r5,r23
81129410:	100d883a 	mov	r6,r2
81129414:	180f883a 	mov	r7,r3
81129418:	11307e80 	call	811307e8 <__subdf3>
8112941c:	d9400e17 	ldw	r5,56(sp)
81129420:	1039883a 	mov	fp,r2
81129424:	182f883a 	mov	r23,r3
81129428:	2800141e 	bne	r5,zero,8112947c <_strtod_r+0xe3c>
8112942c:	9000131e 	bne	r18,zero,8112947c <_strtod_r+0xe3c>
81129430:	00800434 	movhi	r2,16
81129434:	10bfffc4 	addi	r2,r2,-1
81129438:	b0ac703a 	and	r22,r22,r2
8112943c:	b0000f1e 	bne	r22,zero,8112947c <_strtod_r+0xe3c>
81129440:	01a52834 	movhi	r6,38048
81129444:	01cff434 	movhi	r7,16336
81129448:	318d6544 	addi	r6,r6,13717
8112944c:	39ffffc4 	addi	r7,r7,-1
81129450:	e009883a 	mov	r4,fp
81129454:	180b883a 	mov	r5,r3
81129458:	11306f40 	call	811306f4 <__ledf2>
8112945c:	103f270e 	bge	r2,zero,811290fc <__reset+0xfb1090fc>
81129460:	dd000a15 	stw	r20,40(sp)
81129464:	a811883a 	mov	r8,r21
81129468:	dd001217 	ldw	r20,72(sp)
8112946c:	d8800517 	ldw	r2,20(sp)
81129470:	002b883a 	mov	r21,zero
81129474:	882d883a 	mov	r22,r17
81129478:	003f9706 	br	811292d8 <__reset+0xfb1092d8>
8112947c:	01a52834 	movhi	r6,38048
81129480:	01cff834 	movhi	r7,16352
81129484:	318d6544 	addi	r6,r6,13717
81129488:	39ffffc4 	addi	r7,r7,-1
8112948c:	e009883a 	mov	r4,fp
81129490:	b80b883a 	mov	r5,r23
81129494:	11306f40 	call	811306f4 <__ledf2>
81129498:	10000716 	blt	r2,zero,811294b8 <_strtod_r+0xe78>
8112949c:	018d6c34 	movhi	r6,13744
811294a0:	31b94d44 	addi	r6,r6,-6859
811294a4:	01cff834 	movhi	r7,16352
811294a8:	e009883a 	mov	r4,fp
811294ac:	b80b883a 	mov	r5,r23
811294b0:	11306180 	call	81130618 <__gedf2>
811294b4:	00bf110e 	bge	zero,r2,811290fc <__reset+0xfb1090fc>
811294b8:	dd000a15 	stw	r20,40(sp)
811294bc:	a811883a 	mov	r8,r21
811294c0:	dd001217 	ldw	r20,72(sp)
811294c4:	d8800517 	ldw	r2,20(sp)
811294c8:	902b883a 	mov	r21,r18
811294cc:	882d883a 	mov	r22,r17
811294d0:	003f8106 	br	811292d8 <__reset+0xfb1092d8>
811294d4:	b83e2f26 	beq	r23,zero,81128d94 <__reset+0xfb108d94>
811294d8:	05efc83a 	sub	r23,zero,r23
811294dc:	b88003cc 	andi	r2,r23,15
811294e0:	10000d26 	beq	r2,zero,81129518 <_strtod_r+0xed8>
811294e4:	100490fa 	slli	r2,r2,3
811294e8:	00e04574 	movhi	r3,33045
811294ec:	18eb9a04 	addi	r3,r3,-20888
811294f0:	1885883a 	add	r2,r3,r2
811294f4:	11800017 	ldw	r6,0(r2)
811294f8:	11c00117 	ldw	r7,4(r2)
811294fc:	9009883a 	mov	r4,r18
81129500:	880b883a 	mov	r5,r17
81129504:	da401315 	stw	r9,76(sp)
81129508:	112fca00 	call	8112fca0 <__divdf3>
8112950c:	da401317 	ldw	r9,76(sp)
81129510:	1025883a 	mov	r18,r2
81129514:	1823883a 	mov	r17,r3
81129518:	b82fd13a 	srai	r23,r23,4
8112951c:	b83e1d26 	beq	r23,zero,81128d94 <__reset+0xfb108d94>
81129520:	008007c4 	movi	r2,31
81129524:	15c02816 	blt	r2,r23,811295c8 <_strtod_r+0xf88>
81129528:	b880040c 	andi	r2,r23,16
8112952c:	10019726 	beq	r2,zero,81129b8c <_strtod_r+0x154c>
81129530:	05c1880e 	bge	zero,r23,81129b54 <_strtod_r+0x1514>
81129534:	00c01a84 	movi	r3,106
81129538:	d8c00915 	stw	r3,36(sp)
8112953c:	04e04574 	movhi	r19,33045
81129540:	9cebda04 	addi	r19,r19,-20632
81129544:	8807883a 	mov	r3,r17
81129548:	9005883a 	mov	r2,r18
8112954c:	8023883a 	mov	r17,r16
81129550:	0009883a 	mov	r4,zero
81129554:	9821883a 	mov	r16,r19
81129558:	da400a15 	stw	r9,40(sp)
8112955c:	1827883a 	mov	r19,r3
81129560:	b980004c 	andi	r6,r23,1
81129564:	30000626 	beq	r6,zero,81129580 <_strtod_r+0xf40>
81129568:	81800017 	ldw	r6,0(r16)
8112956c:	81c00117 	ldw	r7,4(r16)
81129570:	1009883a 	mov	r4,r2
81129574:	180b883a 	mov	r5,r3
81129578:	111aefc0 	call	8111aefc <__muldf3>
8112957c:	01000044 	movi	r4,1
81129580:	b82fd07a 	srai	r23,r23,1
81129584:	84000204 	addi	r16,r16,8
81129588:	b83ff51e 	bne	r23,zero,81129560 <__reset+0xfb109560>
8112958c:	21003fcc 	andi	r4,r4,255
81129590:	8821883a 	mov	r16,r17
81129594:	da400a17 	ldw	r9,40(sp)
81129598:	9823883a 	mov	r17,r19
8112959c:	2001a51e 	bne	r4,zero,81129c34 <_strtod_r+0x15f4>
811295a0:	d9000917 	ldw	r4,36(sp)
811295a4:	20016d1e 	bne	r4,zero,81129b5c <_strtod_r+0x151c>
811295a8:	000d883a 	mov	r6,zero
811295ac:	000f883a 	mov	r7,zero
811295b0:	9009883a 	mov	r4,r18
811295b4:	880b883a 	mov	r5,r17
811295b8:	da401315 	stw	r9,76(sp)
811295bc:	11305900 	call	81130590 <__eqdf2>
811295c0:	da401317 	ldw	r9,76(sp)
811295c4:	103df41e 	bne	r2,zero,81128d98 <__reset+0xfb108d98>
811295c8:	00800884 	movi	r2,34
811295cc:	80800015 	stw	r2,0(r16)
811295d0:	002b883a 	mov	r21,zero
811295d4:	002d883a 	mov	r22,zero
811295d8:	003ce306 	br	81128968 <__reset+0xfb108968>
811295dc:	055387c4 	movi	r21,19999
811295e0:	003d6b06 	br	81128b90 <__reset+0xfb108b90>
811295e4:	0440d434 	movhi	r17,848
811295e8:	1c63883a 	add	r17,r3,r17
811295ec:	882d883a 	mov	r22,r17
811295f0:	003ebe06 	br	811290ec <__reset+0xfb1090ec>
811295f4:	14403fcc 	andi	r17,r2,255
811295f8:	8c40201c 	xori	r17,r17,128
811295fc:	8c7fe004 	addi	r17,r17,-128
81129600:	dd400817 	ldw	r21,32(sp)
81129604:	0027883a 	mov	r19,zero
81129608:	0039883a 	mov	fp,zero
8112960c:	002d883a 	mov	r22,zero
81129610:	003c9906 	br	81128878 <__reset+0xfb108878>
81129614:	00c00944 	movi	r3,37
81129618:	1a47c83a 	sub	r3,r3,r9
8112961c:	1d7d8c16 	blt	r3,r21,81128c50 <__reset+0xfb108c50>
81129620:	1261c83a 	sub	r16,r2,r9
81129624:	800490fa 	slli	r2,r16,3
81129628:	04e04574 	movhi	r19,33045
8112962c:	9ceb9a04 	addi	r19,r19,-20888
81129630:	9885883a 	add	r2,r19,r2
81129634:	11000017 	ldw	r4,0(r2)
81129638:	11400117 	ldw	r5,4(r2)
8112963c:	900d883a 	mov	r6,r18
81129640:	880f883a 	mov	r7,r17
81129644:	111aefc0 	call	8111aefc <__muldf3>
81129648:	ac0dc83a 	sub	r6,r21,r16
8112964c:	300c90fa 	slli	r6,r6,3
81129650:	1009883a 	mov	r4,r2
81129654:	180b883a 	mov	r5,r3
81129658:	9985883a 	add	r2,r19,r6
8112965c:	11800017 	ldw	r6,0(r2)
81129660:	11c00117 	ldw	r7,4(r2)
81129664:	111aefc0 	call	8111aefc <__muldf3>
81129668:	102b883a 	mov	r21,r2
8112966c:	182d883a 	mov	r22,r3
81129670:	003cbd06 	br	81128968 <__reset+0xfb108968>
81129674:	b811883a 	mov	r8,r23
81129678:	003e8606 	br	81129094 <__reset+0xfb109094>
8112967c:	d8000d15 	stw	zero,52(sp)
81129680:	05cffc34 	movhi	r23,16368
81129684:	003e8006 	br	81129088 <__reset+0xfb109088>
81129688:	883f011e 	bne	r17,zero,81129290 <__reset+0xfb109290>
8112968c:	dd000a15 	stw	r20,40(sp)
81129690:	dd001217 	ldw	r20,72(sp)
81129694:	a811883a 	mov	r8,r21
81129698:	00800884 	movi	r2,34
8112969c:	80800015 	stw	r2,0(r16)
811296a0:	002b883a 	mov	r21,zero
811296a4:	d8800517 	ldw	r2,20(sp)
811296a8:	002d883a 	mov	r22,zero
811296ac:	003f0a06 	br	811292d8 <__reset+0xfb1092d8>
811296b0:	d9800517 	ldw	r6,20(sp)
811296b4:	30000826 	beq	r6,zero,811296d8 <_strtod_r+0x1098>
811296b8:	01400d44 	movi	r5,53
811296bc:	d9000204 	addi	r4,sp,8
811296c0:	d8801315 	stw	r2,76(sp)
811296c4:	1127cd40 	call	81127cd4 <__copybits>
811296c8:	d9400517 	ldw	r5,20(sp)
811296cc:	8009883a 	mov	r4,r16
811296d0:	1126e2c0 	call	81126e2c <_Bfree>
811296d4:	d8801317 	ldw	r2,76(sp)
811296d8:	00c00184 	movi	r3,6
811296dc:	1d400f36 	bltu	r3,r21,8112971c <_strtod_r+0x10dc>
811296e0:	a82a90ba 	slli	r21,r21,2
811296e4:	00e044f4 	movhi	r3,33043
811296e8:	18e5be04 	addi	r3,r3,-26888
811296ec:	a8eb883a 	add	r21,r21,r3
811296f0:	a8c00017 	ldw	r3,0(r21)
811296f4:	1800683a 	jmp	r3
811296f8:	81129774 	orhi	r4,r16,19037
811296fc:	8112974c 	andi	r4,r16,19037
81129700:	81129730 	cmpltui	r4,r16,19036
81129704:	81129714 	ori	r4,r16,19036
81129708:	8112973c 	xorhi	r4,r16,19036
8112970c:	8112974c 	andi	r4,r16,19037
81129710:	81129774 	orhi	r4,r16,19037
81129714:	045ffc34 	movhi	r17,32752
81129718:	0025883a 	mov	r18,zero
8112971c:	1080020c 	andi	r2,r2,8
81129720:	902b883a 	mov	r21,r18
81129724:	103c8f26 	beq	r2,zero,81128964 <__reset+0xfb108964>
81129728:	8da00034 	orhi	r22,r17,32768
8112972c:	003c8e06 	br	81128968 <__reset+0xfb108968>
81129730:	dc800217 	ldw	r18,8(sp)
81129734:	dc400317 	ldw	r17,12(sp)
81129738:	003ff806 	br	8112971c <__reset+0xfb10971c>
8112973c:	04600034 	movhi	r17,32768
81129740:	8c7fffc4 	addi	r17,r17,-1
81129744:	04bfffc4 	movi	r18,-1
81129748:	003ff406 	br	8112971c <__reset+0xfb10971c>
8112974c:	d8c00417 	ldw	r3,16(sp)
81129750:	dc400317 	ldw	r17,12(sp)
81129754:	013ffc34 	movhi	r4,65520
81129758:	18c10cc4 	addi	r3,r3,1075
8112975c:	1806953a 	slli	r3,r3,20
81129760:	213fffc4 	addi	r4,r4,-1
81129764:	8922703a 	and	r17,r17,r4
81129768:	dc800217 	ldw	r18,8(sp)
8112976c:	88e2b03a 	or	r17,r17,r3
81129770:	003fea06 	br	8112971c <__reset+0xfb10971c>
81129774:	0023883a 	mov	r17,zero
81129778:	0025883a 	mov	r18,zero
8112977c:	003fe706 	br	8112971c <__reset+0xfb10971c>
81129780:	01800044 	movi	r6,1
81129784:	50d5883a 	add	r10,r10,r3
81129788:	2a4b883a 	add	r5,r5,r9
8112978c:	19811a26 	beq	r3,r6,81129bf8 <_strtod_r+0x15b8>
81129790:	01800204 	movi	r6,8
81129794:	01c00404 	movi	r7,16
81129798:	4a400044 	addi	r9,r9,1
8112979c:	48bfffc4 	addi	r2,r9,-1
811297a0:	30801616 	blt	r6,r2,811297fc <_strtod_r+0x11bc>
811297a4:	e70002a4 	muli	fp,fp,10
811297a8:	497ffb1e 	bne	r9,r5,81129798 <__reset+0xfb109798>
811297ac:	d9800617 	ldw	r6,24(sp)
811297b0:	4a400044 	addi	r9,r9,1
811297b4:	00c00204 	movi	r3,8
811297b8:	19400c0e 	bge	r3,r5,811297ec <_strtod_r+0x11ac>
811297bc:	00800404 	movi	r2,16
811297c0:	000b883a 	mov	r5,zero
811297c4:	127ea316 	blt	r2,r9,81129254 <__reset+0xfb109254>
811297c8:	988002a4 	muli	r2,r19,10
811297cc:	20a7883a 	add	r19,r4,r2
811297d0:	003ea006 	br	81129254 <__reset+0xfb109254>
811297d4:	d8800617 	ldw	r2,24(sp)
811297d8:	8c7ff404 	addi	r17,r17,-48
811297dc:	2a800044 	addi	r10,r5,1
811297e0:	d8800815 	stw	r2,32(sp)
811297e4:	100d883a 	mov	r6,r2
811297e8:	02400044 	movi	r9,1
811297ec:	e08002a4 	muli	r2,fp,10
811297f0:	000b883a 	mov	r5,zero
811297f4:	88b9883a 	add	fp,r17,r2
811297f8:	003e9606 	br	81129254 <__reset+0xfb109254>
811297fc:	3a7fea16 	blt	r7,r9,811297a8 <__reset+0xfb1097a8>
81129800:	9cc002a4 	muli	r19,r19,10
81129804:	003fe806 	br	811297a8 <__reset+0xfb1097a8>
81129808:	00bffa84 	movi	r2,-22
8112980c:	a8bd1016 	blt	r21,r2,81128c50 <__reset+0xfb108c50>
81129810:	a82a90fa 	slli	r21,r21,3
81129814:	00a04574 	movhi	r2,33045
81129818:	10ab9a04 	addi	r2,r2,-20888
8112981c:	1545c83a 	sub	r2,r2,r21
81129820:	11800017 	ldw	r6,0(r2)
81129824:	11c00117 	ldw	r7,4(r2)
81129828:	9009883a 	mov	r4,r18
8112982c:	880b883a 	mov	r5,r17
81129830:	112fca00 	call	8112fca0 <__divdf3>
81129834:	102b883a 	mov	r21,r2
81129838:	182d883a 	mov	r22,r3
8112983c:	003c4a06 	br	81128968 <__reset+0xfb108968>
81129840:	dd000a15 	stw	r20,40(sp)
81129844:	a811883a 	mov	r8,r21
81129848:	dd001217 	ldw	r20,72(sp)
8112984c:	003e9e06 	br	811292c8 <__reset+0xfb1092c8>
81129850:	01604574 	movhi	r5,33045
81129854:	d9000617 	ldw	r4,24(sp)
81129858:	296bcc04 	addi	r5,r5,-20688
8112985c:	01c00644 	movi	r7,25
81129860:	00000b06 	br	81129890 <_strtod_r+0x1250>
81129864:	21000044 	addi	r4,r4,1
81129868:	20800003 	ldbu	r2,0(r4)
8112986c:	10ffefc4 	addi	r3,r2,-65
81129870:	10803fcc 	andi	r2,r2,255
81129874:	1080201c 	xori	r2,r2,128
81129878:	18c03fcc 	andi	r3,r3,255
8112987c:	10bfe004 	addi	r2,r2,-128
81129880:	38c00136 	bltu	r7,r3,81129888 <_strtod_r+0x1248>
81129884:	10800804 	addi	r2,r2,32
81129888:	29400044 	addi	r5,r5,1
8112988c:	11bbbb1e 	bne	r2,r6,8112877c <__reset+0xfb10877c>
81129890:	29800007 	ldb	r6,0(r5)
81129894:	303ff31e 	bne	r6,zero,81129864 <__reset+0xfb109864>
81129898:	01a04574 	movhi	r6,33045
8112989c:	d9000615 	stw	r4,24(sp)
811298a0:	31abcd04 	addi	r6,r6,-20684
811298a4:	200b883a 	mov	r5,r4
811298a8:	02000644 	movi	r8,25
811298ac:	00000a06 	br	811298d8 <_strtod_r+0x1298>
811298b0:	28800003 	ldbu	r2,0(r5)
811298b4:	10ffefc4 	addi	r3,r2,-65
811298b8:	10803fcc 	andi	r2,r2,255
811298bc:	1080201c 	xori	r2,r2,128
811298c0:	18c03fcc 	andi	r3,r3,255
811298c4:	10bfe004 	addi	r2,r2,-128
811298c8:	40c00136 	bltu	r8,r3,811298d0 <_strtod_r+0x1290>
811298cc:	10800804 	addi	r2,r2,32
811298d0:	31800044 	addi	r6,r6,1
811298d4:	11c0711e 	bne	r2,r7,81129a9c <_strtod_r+0x145c>
811298d8:	31c00007 	ldb	r7,0(r6)
811298dc:	29400044 	addi	r5,r5,1
811298e0:	383ff31e 	bne	r7,zero,811298b0 <__reset+0xfb1098b0>
811298e4:	d9400615 	stw	r5,24(sp)
811298e8:	045ffc34 	movhi	r17,32752
811298ec:	0025883a 	mov	r18,zero
811298f0:	003c1b06 	br	81128960 <__reset+0xfb108960>
811298f4:	000b883a 	mov	r5,zero
811298f8:	003ccc06 	br	81128c2c <__reset+0xfb108c2c>
811298fc:	d9400e17 	ldw	r5,56(sp)
81129900:	dd000a15 	stw	r20,40(sp)
81129904:	00800434 	movhi	r2,16
81129908:	a811883a 	mov	r8,r21
8112990c:	dd001217 	ldw	r20,72(sp)
81129910:	dd401117 	ldw	r21,68(sp)
81129914:	dd801017 	ldw	r22,64(sp)
81129918:	10bfffc4 	addi	r2,r2,-1
8112991c:	28005626 	beq	r5,zero,81129a78 <_strtod_r+0x1438>
81129920:	8886703a 	and	r3,r17,r2
81129924:	18807826 	beq	r3,r2,81129b08 <_strtod_r+0x14c8>
81129928:	d8c00b17 	ldw	r3,44(sp)
8112992c:	18005726 	beq	r3,zero,81129a8c <_strtod_r+0x144c>
81129930:	1c44703a 	and	r2,r3,r17
81129934:	10000f26 	beq	r2,zero,81129974 <_strtod_r+0x1334>
81129938:	d9000e17 	ldw	r4,56(sp)
8112993c:	d9800917 	ldw	r6,36(sp)
81129940:	20005e26 	beq	r4,zero,81129abc <_strtod_r+0x147c>
81129944:	9009883a 	mov	r4,r18
81129948:	880b883a 	mov	r5,r17
8112994c:	da001315 	stw	r8,76(sp)
81129950:	11285d40 	call	811285d4 <sulp>
81129954:	100d883a 	mov	r6,r2
81129958:	180f883a 	mov	r7,r3
8112995c:	9009883a 	mov	r4,r18
81129960:	880b883a 	mov	r5,r17
81129964:	112f3ec0 	call	8112f3ec <__adddf3>
81129968:	da001317 	ldw	r8,76(sp)
8112996c:	102b883a 	mov	r21,r2
81129970:	182d883a 	mov	r22,r3
81129974:	d8c00917 	ldw	r3,36(sp)
81129978:	18000f26 	beq	r3,zero,811299b8 <_strtod_r+0x1378>
8112997c:	a809883a 	mov	r4,r21
81129980:	b00b883a 	mov	r5,r22
81129984:	000d883a 	mov	r6,zero
81129988:	01ce5434 	movhi	r7,14672
8112998c:	da001315 	stw	r8,76(sp)
81129990:	111aefc0 	call	8111aefc <__muldf3>
81129994:	102b883a 	mov	r21,r2
81129998:	182d883a 	mov	r22,r3
8112999c:	da001317 	ldw	r8,76(sp)
811299a0:	1800051e 	bne	r3,zero,811299b8 <_strtod_r+0x1378>
811299a4:	d8800517 	ldw	r2,20(sp)
811299a8:	a83e4b1e 	bne	r21,zero,811292d8 <__reset+0xfb1092d8>
811299ac:	00c00884 	movi	r3,34
811299b0:	80c00015 	stw	r3,0(r16)
811299b4:	003e4806 	br	811292d8 <__reset+0xfb1092d8>
811299b8:	d8800517 	ldw	r2,20(sp)
811299bc:	003e4606 	br	811292d8 <__reset+0xfb1092d8>
811299c0:	d9000e17 	ldw	r4,56(sp)
811299c4:	dd000a15 	stw	r20,40(sp)
811299c8:	a811883a 	mov	r8,r21
811299cc:	dd001217 	ldw	r20,72(sp)
811299d0:	dd401117 	ldw	r21,68(sp)
811299d4:	dd801017 	ldw	r22,64(sp)
811299d8:	203fe61e 	bne	r4,zero,81129974 <__reset+0xfb109974>
811299dc:	903fe51e 	bne	r18,zero,81129974 <__reset+0xfb109974>
811299e0:	00800434 	movhi	r2,16
811299e4:	10bfffc4 	addi	r2,r2,-1
811299e8:	8884703a 	and	r2,r17,r2
811299ec:	103fe11e 	bne	r2,zero,81129974 <__reset+0xfb109974>
811299f0:	8ddffc2c 	andhi	r23,r17,32752
811299f4:	0081ac34 	movhi	r2,1712
811299f8:	15ffde2e 	bgeu	r2,r23,81129974 <__reset+0xfb109974>
811299fc:	40800517 	ldw	r2,20(r8)
81129a00:	1000031e 	bne	r2,zero,81129a10 <_strtod_r+0x13d0>
81129a04:	40800417 	ldw	r2,16(r8)
81129a08:	00c00044 	movi	r3,1
81129a0c:	18bfd90e 	bge	r3,r2,81129974 <__reset+0xfb109974>
81129a10:	400b883a 	mov	r5,r8
81129a14:	01800044 	movi	r6,1
81129a18:	8009883a 	mov	r4,r16
81129a1c:	112752c0 	call	8112752c <__lshift>
81129a20:	980b883a 	mov	r5,r19
81129a24:	1009883a 	mov	r4,r2
81129a28:	d8801315 	stw	r2,76(sp)
81129a2c:	112767c0 	call	8112767c <__mcmp>
81129a30:	da001317 	ldw	r8,76(sp)
81129a34:	00bfcf0e 	bge	zero,r2,81129974 <__reset+0xfb109974>
81129a38:	d8c00917 	ldw	r3,36(sp)
81129a3c:	18005c26 	beq	r3,zero,81129bb0 <_strtod_r+0x1570>
81129a40:	0081ac34 	movhi	r2,1712
81129a44:	15c05a16 	blt	r2,r23,81129bb0 <_strtod_r+0x1570>
81129a48:	0080dc34 	movhi	r2,880
81129a4c:	15ffcb16 	blt	r2,r23,8112997c <__reset+0xfb10997c>
81129a50:	003f1106 	br	81129698 <__reset+0xfb109698>
81129a54:	002d883a 	mov	r22,zero
81129a58:	022ff834 	movhi	r8,49120
81129a5c:	d8000d15 	stw	zero,52(sp)
81129a60:	05cff834 	movhi	r23,16352
81129a64:	003ded06 	br	8112921c <__reset+0xfb10921c>
81129a68:	0440d434 	movhi	r17,848
81129a6c:	1c63883a 	add	r17,r3,r17
81129a70:	d8000915 	stw	zero,36(sp)
81129a74:	003cc806 	br	81128d98 <__reset+0xfb108d98>
81129a78:	8884703a 	and	r2,r17,r2
81129a7c:	103faa1e 	bne	r2,zero,81129928 <__reset+0xfb109928>
81129a80:	903fa91e 	bne	r18,zero,81129928 <__reset+0xfb109928>
81129a84:	8ddffc2c 	andhi	r23,r17,32752
81129a88:	003feb06 	br	81129a38 <__reset+0xfb109a38>
81129a8c:	d8c00d17 	ldw	r3,52(sp)
81129a90:	1cae703a 	and	r23,r3,r18
81129a94:	b83fb726 	beq	r23,zero,81129974 <__reset+0xfb109974>
81129a98:	003fa706 	br	81129938 <__reset+0xfb109938>
81129a9c:	21000044 	addi	r4,r4,1
81129aa0:	d9000615 	stw	r4,24(sp)
81129aa4:	003f9006 	br	811298e8 <__reset+0xfb1098e8>
81129aa8:	01604574 	movhi	r5,33045
81129aac:	296b9004 	addi	r5,r5,-20928
81129ab0:	d9400915 	stw	r5,36(sp)
81129ab4:	0027883a 	mov	r19,zero
81129ab8:	003ca206 	br	81128d44 <__reset+0xfb108d44>
81129abc:	9009883a 	mov	r4,r18
81129ac0:	880b883a 	mov	r5,r17
81129ac4:	da001315 	stw	r8,76(sp)
81129ac8:	11285d40 	call	811285d4 <sulp>
81129acc:	100d883a 	mov	r6,r2
81129ad0:	180f883a 	mov	r7,r3
81129ad4:	9009883a 	mov	r4,r18
81129ad8:	880b883a 	mov	r5,r17
81129adc:	11307e80 	call	811307e8 <__subdf3>
81129ae0:	000d883a 	mov	r6,zero
81129ae4:	000f883a 	mov	r7,zero
81129ae8:	1009883a 	mov	r4,r2
81129aec:	180b883a 	mov	r5,r3
81129af0:	102b883a 	mov	r21,r2
81129af4:	182d883a 	mov	r22,r3
81129af8:	11305900 	call	81130590 <__eqdf2>
81129afc:	da001317 	ldw	r8,76(sp)
81129b00:	103ee526 	beq	r2,zero,81129698 <__reset+0xfb109698>
81129b04:	003f9b06 	br	81129974 <__reset+0xfb109974>
81129b08:	d8800917 	ldw	r2,36(sp)
81129b0c:	10002226 	beq	r2,zero,81129b98 <_strtod_r+0x1558>
81129b10:	889ffc2c 	andhi	r2,r17,32752
81129b14:	00c1a834 	movhi	r3,1696
81129b18:	18801f36 	bltu	r3,r2,81129b98 <_strtod_r+0x1558>
81129b1c:	1004d53a 	srli	r2,r2,20
81129b20:	00c01ac4 	movi	r3,107
81129b24:	1887c83a 	sub	r3,r3,r2
81129b28:	00bfffc4 	movi	r2,-1
81129b2c:	10c4983a 	sll	r2,r2,r3
81129b30:	14bf7d1e 	bne	r2,r18,81129928 <__reset+0xfb109928>
81129b34:	00dffc34 	movhi	r3,32752
81129b38:	18ffffc4 	addi	r3,r3,-1
81129b3c:	88c03526 	beq	r17,r3,81129c14 <_strtod_r+0x15d4>
81129b40:	8c5ffc2c 	andhi	r17,r17,32752
81129b44:	00800434 	movhi	r2,16
81129b48:	002b883a 	mov	r21,zero
81129b4c:	88ad883a 	add	r22,r17,r2
81129b50:	003f8806 	br	81129974 <__reset+0xfb109974>
81129b54:	01401a84 	movi	r5,106
81129b58:	d9400915 	stw	r5,36(sp)
81129b5c:	8ddffc2c 	andhi	r23,r17,32752
81129b60:	b82ed53a 	srli	r23,r23,20
81129b64:	00801ac4 	movi	r2,107
81129b68:	15c5c83a 	sub	r2,r2,r23
81129b6c:	00be8e0e 	bge	zero,r2,811295a8 <__reset+0xfb1095a8>
81129b70:	00c007c4 	movi	r3,31
81129b74:	18800a0e 	bge	r3,r2,81129ba0 <_strtod_r+0x1560>
81129b78:	00c00d04 	movi	r3,52
81129b7c:	0025883a 	mov	r18,zero
81129b80:	1880270e 	bge	r3,r2,81129c20 <_strtod_r+0x15e0>
81129b84:	0440dc34 	movhi	r17,880
81129b88:	003e8706 	br	811295a8 <__reset+0xfb1095a8>
81129b8c:	d8000915 	stw	zero,36(sp)
81129b90:	05fe6a16 	blt	zero,r23,8112953c <__reset+0xfb10953c>
81129b94:	003e8406 	br	811295a8 <__reset+0xfb1095a8>
81129b98:	00bfffc4 	movi	r2,-1
81129b9c:	003fe406 	br	81129b30 <__reset+0xfb109b30>
81129ba0:	00ffffc4 	movi	r3,-1
81129ba4:	1884983a 	sll	r2,r3,r2
81129ba8:	14a4703a 	and	r18,r2,r18
81129bac:	003e7e06 	br	811295a8 <__reset+0xfb1095a8>
81129bb0:	00bffc34 	movhi	r2,65520
81129bb4:	b8af883a 	add	r23,r23,r2
81129bb8:	057fffc4 	movi	r21,-1
81129bbc:	00800434 	movhi	r2,16
81129bc0:	1545883a 	add	r2,r2,r21
81129bc4:	b8acb03a 	or	r22,r23,r2
81129bc8:	003f6a06 	br	81129974 <__reset+0xfb109974>
81129bcc:	01604574 	movhi	r5,33045
81129bd0:	296bd004 	addi	r5,r5,-20672
81129bd4:	d9800204 	addi	r6,sp,8
81129bd8:	d9000604 	addi	r4,sp,24
81129bdc:	112dfcc0 	call	8112dfcc <__hexnan>
81129be0:	00c00144 	movi	r3,5
81129be4:	10fb5c1e 	bne	r2,r3,81128958 <__reset+0xfb108958>
81129be8:	dc400317 	ldw	r17,12(sp)
81129bec:	dc800217 	ldw	r18,8(sp)
81129bf0:	8c5ffc34 	orhi	r17,r17,32752
81129bf4:	003b5a06 	br	81128960 <__reset+0xfb108960>
81129bf8:	480b883a 	mov	r5,r9
81129bfc:	d9800617 	ldw	r6,24(sp)
81129c00:	4a400044 	addi	r9,r9,1
81129c04:	003eeb06 	br	811297b4 <__reset+0xfb1097b4>
81129c08:	1025883a 	mov	r18,r2
81129c0c:	1823883a 	mov	r17,r3
81129c10:	003c4c06 	br	81128d44 <__reset+0xfb108d44>
81129c14:	00ffffc4 	movi	r3,-1
81129c18:	10ffc91e 	bne	r2,r3,81129b40 <__reset+0xfb109b40>
81129c1c:	003da906 	br	811292c4 <__reset+0xfb1092c4>
81129c20:	10bff804 	addi	r2,r2,-32
81129c24:	00ffffc4 	movi	r3,-1
81129c28:	1884983a 	sll	r2,r3,r2
81129c2c:	1462703a 	and	r17,r2,r17
81129c30:	003e5d06 	br	811295a8 <__reset+0xfb1095a8>
81129c34:	1025883a 	mov	r18,r2
81129c38:	1823883a 	mov	r17,r3
81129c3c:	003e5806 	br	811295a0 <__reset+0xfb1095a0>

81129c40 <strtod>:
81129c40:	00a04574 	movhi	r2,33045
81129c44:	10b52904 	addi	r2,r2,-11100
81129c48:	280d883a 	mov	r6,r5
81129c4c:	200b883a 	mov	r5,r4
81129c50:	11000017 	ldw	r4,0(r2)
81129c54:	11286401 	jmpi	81128640 <_strtod_r>

81129c58 <strtof>:
81129c58:	defffb04 	addi	sp,sp,-20
81129c5c:	de00012e 	bgeu	sp,et,81129c64 <strtof+0xc>
81129c60:	003b68fa 	trap	3
81129c64:	dcc00315 	stw	r19,12(sp)
81129c68:	04e04574 	movhi	r19,33045
81129c6c:	9cf52904 	addi	r19,r19,-11100
81129c70:	280d883a 	mov	r6,r5
81129c74:	200b883a 	mov	r5,r4
81129c78:	99000017 	ldw	r4,0(r19)
81129c7c:	dfc00415 	stw	ra,16(sp)
81129c80:	dc800215 	stw	r18,8(sp)
81129c84:	dc400115 	stw	r17,4(sp)
81129c88:	dc000015 	stw	r16,0(sp)
81129c8c:	11286400 	call	81128640 <_strtod_r>
81129c90:	1009883a 	mov	r4,r2
81129c94:	180b883a 	mov	r5,r3
81129c98:	1025883a 	mov	r18,r2
81129c9c:	1823883a 	mov	r17,r3
81129ca0:	111b7340 	call	8111b734 <__truncdfsf2>
81129ca4:	000b883a 	mov	r5,zero
81129ca8:	1009883a 	mov	r4,r2
81129cac:	1021883a 	mov	r16,r2
81129cb0:	112f1f00 	call	8112f1f0 <__eqsf2>
81129cb4:	1000111e 	bne	r2,zero,81129cfc <strtof+0xa4>
81129cb8:	000d883a 	mov	r6,zero
81129cbc:	000f883a 	mov	r7,zero
81129cc0:	9009883a 	mov	r4,r18
81129cc4:	880b883a 	mov	r5,r17
81129cc8:	11305900 	call	81130590 <__eqdf2>
81129ccc:	10000b26 	beq	r2,zero,81129cfc <strtof+0xa4>
81129cd0:	98800017 	ldw	r2,0(r19)
81129cd4:	00c00884 	movi	r3,34
81129cd8:	10c00015 	stw	r3,0(r2)
81129cdc:	8005883a 	mov	r2,r16
81129ce0:	dfc00417 	ldw	ra,16(sp)
81129ce4:	dcc00317 	ldw	r19,12(sp)
81129ce8:	dc800217 	ldw	r18,8(sp)
81129cec:	dc400117 	ldw	r17,4(sp)
81129cf0:	dc000017 	ldw	r16,0(sp)
81129cf4:	dec00504 	addi	sp,sp,20
81129cf8:	f800283a 	ret
81129cfc:	015fe034 	movhi	r5,32640
81129d00:	297fffc4 	addi	r5,r5,-1
81129d04:	8009883a 	mov	r4,r16
81129d08:	112f2680 	call	8112f268 <__gesf2>
81129d0c:	0080070e 	bge	zero,r2,81129d2c <strtof+0xd4>
81129d10:	01dffc34 	movhi	r7,32752
81129d14:	39ffffc4 	addi	r7,r7,-1
81129d18:	01bfffc4 	movi	r6,-1
81129d1c:	9009883a 	mov	r4,r18
81129d20:	880b883a 	mov	r5,r17
81129d24:	11306180 	call	81130618 <__gedf2>
81129d28:	00bfe90e 	bge	zero,r2,81129cd0 <__reset+0xfb109cd0>
81129d2c:	017fe034 	movhi	r5,65408
81129d30:	297fffc4 	addi	r5,r5,-1
81129d34:	8009883a 	mov	r4,r16
81129d38:	112f3240 	call	8112f324 <__lesf2>
81129d3c:	103fe70e 	bge	r2,zero,81129cdc <__reset+0xfb109cdc>
81129d40:	01fffc34 	movhi	r7,65520
81129d44:	39ffffc4 	addi	r7,r7,-1
81129d48:	01bfffc4 	movi	r6,-1
81129d4c:	9009883a 	mov	r4,r18
81129d50:	880b883a 	mov	r5,r17
81129d54:	11306f40 	call	811306f4 <__ledf2>
81129d58:	103fdd0e 	bge	r2,zero,81129cd0 <__reset+0xfb109cd0>
81129d5c:	003fdf06 	br	81129cdc <__reset+0xfb109cdc>

81129d60 <_strtoll_r>:
81129d60:	00a04574 	movhi	r2,33045
81129d64:	defff304 	addi	sp,sp,-52
81129d68:	10b52704 	addi	r2,r2,-11108
81129d6c:	de00012e 	bgeu	sp,et,81129d74 <_strtoll_r+0x14>
81129d70:	003b68fa 	trap	3
81129d74:	dc800515 	stw	r18,20(sp)
81129d78:	14800017 	ldw	r18,0(r2)
81129d7c:	dd800915 	stw	r22,36(sp)
81129d80:	dd400815 	stw	r21,32(sp)
81129d84:	dcc00615 	stw	r19,24(sp)
81129d88:	d9000015 	stw	r4,0(sp)
81129d8c:	dfc00c15 	stw	ra,48(sp)
81129d90:	df000b15 	stw	fp,44(sp)
81129d94:	ddc00a15 	stw	r23,40(sp)
81129d98:	dd000715 	stw	r20,28(sp)
81129d9c:	dc400415 	stw	r17,16(sp)
81129da0:	dc000315 	stw	r16,12(sp)
81129da4:	282d883a 	mov	r22,r5
81129da8:	302b883a 	mov	r21,r6
81129dac:	3827883a 	mov	r19,r7
81129db0:	2809883a 	mov	r4,r5
81129db4:	24000003 	ldbu	r16,0(r4)
81129db8:	24400044 	addi	r17,r4,1
81129dbc:	2007883a 	mov	r3,r4
81129dc0:	9405883a 	add	r2,r18,r16
81129dc4:	10800043 	ldbu	r2,1(r2)
81129dc8:	8809883a 	mov	r4,r17
81129dcc:	1080020c 	andi	r2,r2,8
81129dd0:	103ff81e 	bne	r2,zero,81129db4 <__reset+0xfb109db4>
81129dd4:	00800b44 	movi	r2,45
81129dd8:	80807826 	beq	r16,r2,81129fbc <_strtoll_r+0x25c>
81129ddc:	00800ac4 	movi	r2,43
81129de0:	80807a26 	beq	r16,r2,81129fcc <_strtoll_r+0x26c>
81129de4:	0039883a 	mov	fp,zero
81129de8:	98004e26 	beq	r19,zero,81129f24 <_strtoll_r+0x1c4>
81129dec:	00800404 	movi	r2,16
81129df0:	98808226 	beq	r19,r2,81129ffc <_strtoll_r+0x29c>
81129df4:	982fd7fa 	srai	r23,r19,31
81129df8:	9829883a 	mov	r20,r19
81129dfc:	e0004f26 	beq	fp,zero,81129f3c <_strtoll_r+0x1dc>
81129e00:	0017883a 	mov	r11,zero
81129e04:	02a00034 	movhi	r10,32768
81129e08:	5809883a 	mov	r4,r11
81129e0c:	500b883a 	mov	r5,r10
81129e10:	a00d883a 	mov	r6,r20
81129e14:	b80f883a 	mov	r7,r23
81129e18:	da800215 	stw	r10,8(sp)
81129e1c:	dac00115 	stw	r11,4(sp)
81129e20:	112eafc0 	call	8112eafc <__umoddi3>
81129e24:	dac00117 	ldw	r11,4(sp)
81129e28:	da800217 	ldw	r10,8(sp)
81129e2c:	a00d883a 	mov	r6,r20
81129e30:	5809883a 	mov	r4,r11
81129e34:	500b883a 	mov	r5,r10
81129e38:	b80f883a 	mov	r7,r23
81129e3c:	d8800115 	stw	r2,4(sp)
81129e40:	112e57c0 	call	8112e57c <__udivdi3>
81129e44:	9409883a 	add	r4,r18,r16
81129e48:	21000043 	ldbu	r4,1(r4)
81129e4c:	1019883a 	mov	r12,r2
81129e50:	880b883a 	mov	r5,r17
81129e54:	2240010c 	andi	r9,r4,4
81129e58:	0015883a 	mov	r10,zero
81129e5c:	000d883a 	mov	r6,zero
81129e60:	000f883a 	mov	r7,zero
81129e64:	03400044 	movi	r13,1
81129e68:	02ffffc4 	movi	r11,-1
81129e6c:	da000117 	ldw	r8,4(sp)
81129e70:	48000d26 	beq	r9,zero,81129ea8 <_strtoll_r+0x148>
81129e74:	843ff404 	addi	r16,r16,-48
81129e78:	84c0110e 	bge	r16,r19,81129ec0 <_strtoll_r+0x160>
81129e7c:	52c00426 	beq	r10,r11,81129e90 <_strtoll_r+0x130>
81129e80:	19c00236 	bltu	r3,r7,81129e8c <_strtoll_r+0x12c>
81129e84:	38c0311e 	bne	r7,r3,81129f4c <_strtoll_r+0x1ec>
81129e88:	6180302e 	bgeu	r12,r6,81129f4c <_strtoll_r+0x1ec>
81129e8c:	02bfffc4 	movi	r10,-1
81129e90:	2c000003 	ldbu	r16,0(r5)
81129e94:	29400044 	addi	r5,r5,1
81129e98:	9409883a 	add	r4,r18,r16
81129e9c:	21000043 	ldbu	r4,1(r4)
81129ea0:	2240010c 	andi	r9,r4,4
81129ea4:	483ff31e 	bne	r9,zero,81129e74 <__reset+0xfb109e74>
81129ea8:	210000cc 	andi	r4,r4,3
81129eac:	20000426 	beq	r4,zero,81129ec0 <_strtoll_r+0x160>
81129eb0:	23403426 	beq	r4,r13,81129f84 <_strtoll_r+0x224>
81129eb4:	008015c4 	movi	r2,87
81129eb8:	80a1c83a 	sub	r16,r16,r2
81129ebc:	84ffef16 	blt	r16,r19,81129e7c <__reset+0xfb109e7c>
81129ec0:	00bfffc4 	movi	r2,-1
81129ec4:	50803426 	beq	r10,r2,81129f98 <_strtoll_r+0x238>
81129ec8:	e0000426 	beq	fp,zero,81129edc <_strtoll_r+0x17c>
81129ecc:	018dc83a 	sub	r6,zero,r6
81129ed0:	3004c03a 	cmpne	r2,r6,zero
81129ed4:	01e1c83a 	sub	r16,zero,r7
81129ed8:	808fc83a 	sub	r7,r16,r2
81129edc:	3005883a 	mov	r2,r6
81129ee0:	3807883a 	mov	r3,r7
81129ee4:	a8000326 	beq	r21,zero,81129ef4 <_strtoll_r+0x194>
81129ee8:	5000321e 	bne	r10,zero,81129fb4 <_strtoll_r+0x254>
81129eec:	b00b883a 	mov	r5,r22
81129ef0:	a9400015 	stw	r5,0(r21)
81129ef4:	dfc00c17 	ldw	ra,48(sp)
81129ef8:	df000b17 	ldw	fp,44(sp)
81129efc:	ddc00a17 	ldw	r23,40(sp)
81129f00:	dd800917 	ldw	r22,36(sp)
81129f04:	dd400817 	ldw	r21,32(sp)
81129f08:	dd000717 	ldw	r20,28(sp)
81129f0c:	dcc00617 	ldw	r19,24(sp)
81129f10:	dc800517 	ldw	r18,20(sp)
81129f14:	dc400417 	ldw	r17,16(sp)
81129f18:	dc000317 	ldw	r16,12(sp)
81129f1c:	dec00d04 	addi	sp,sp,52
81129f20:	f800283a 	ret
81129f24:	00800c04 	movi	r2,48
81129f28:	80802c26 	beq	r16,r2,81129fdc <_strtoll_r+0x27c>
81129f2c:	05000284 	movi	r20,10
81129f30:	002f883a 	mov	r23,zero
81129f34:	a027883a 	mov	r19,r20
81129f38:	e03fb11e 	bne	fp,zero,81129e00 <__reset+0xfb109e00>
81129f3c:	02a00034 	movhi	r10,32768
81129f40:	52bfffc4 	addi	r10,r10,-1
81129f44:	02ffffc4 	movi	r11,-1
81129f48:	003faf06 	br	81129e08 <__reset+0xfb109e08>
81129f4c:	33000f26 	beq	r6,r12,81129f8c <_strtoll_r+0x22c>
81129f50:	b985383a 	mul	r2,r23,r6
81129f54:	3d0f383a 	mul	r7,r7,r20
81129f58:	3508383a 	mulxuu	r4,r6,r20
81129f5c:	350d383a 	mul	r6,r6,r20
81129f60:	8013d7fa 	srai	r9,r16,31
81129f64:	388f883a 	add	r7,r7,r2
81129f68:	818d883a 	add	r6,r16,r6
81129f6c:	390f883a 	add	r7,r7,r4
81129f70:	3421803a 	cmpltu	r16,r6,r16
81129f74:	49cf883a 	add	r7,r9,r7
81129f78:	81cf883a 	add	r7,r16,r7
81129f7c:	02800044 	movi	r10,1
81129f80:	003fc306 	br	81129e90 <__reset+0xfb109e90>
81129f84:	00800dc4 	movi	r2,55
81129f88:	003fcb06 	br	81129eb8 <__reset+0xfb109eb8>
81129f8c:	38fff01e 	bne	r7,r3,81129f50 <__reset+0xfb109f50>
81129f90:	443fbe16 	blt	r8,r16,81129e8c <__reset+0xfb109e8c>
81129f94:	003fee06 	br	81129f50 <__reset+0xfb109f50>
81129f98:	e0002426 	beq	fp,zero,8112a02c <_strtoll_r+0x2cc>
81129f9c:	0005883a 	mov	r2,zero
81129fa0:	00e00034 	movhi	r3,32768
81129fa4:	d9800017 	ldw	r6,0(sp)
81129fa8:	01000884 	movi	r4,34
81129fac:	31000015 	stw	r4,0(r6)
81129fb0:	a83fd026 	beq	r21,zero,81129ef4 <__reset+0xfb109ef4>
81129fb4:	297fffc4 	addi	r5,r5,-1
81129fb8:	003fcd06 	br	81129ef0 <__reset+0xfb109ef0>
81129fbc:	1c400084 	addi	r17,r3,2
81129fc0:	1c000043 	ldbu	r16,1(r3)
81129fc4:	07000044 	movi	fp,1
81129fc8:	003f8706 	br	81129de8 <__reset+0xfb109de8>
81129fcc:	1c400084 	addi	r17,r3,2
81129fd0:	1c000043 	ldbu	r16,1(r3)
81129fd4:	0039883a 	mov	fp,zero
81129fd8:	003f8306 	br	81129de8 <__reset+0xfb109de8>
81129fdc:	88800003 	ldbu	r2,0(r17)
81129fe0:	00c01604 	movi	r3,88
81129fe4:	108037cc 	andi	r2,r2,223
81129fe8:	10c00a26 	beq	r2,r3,8112a014 <_strtoll_r+0x2b4>
81129fec:	05000204 	movi	r20,8
81129ff0:	002f883a 	mov	r23,zero
81129ff4:	a027883a 	mov	r19,r20
81129ff8:	003f8006 	br	81129dfc <__reset+0xfb109dfc>
81129ffc:	00800c04 	movi	r2,48
8112a000:	80800e1e 	bne	r16,r2,8112a03c <_strtoll_r+0x2dc>
8112a004:	88800003 	ldbu	r2,0(r17)
8112a008:	00c01604 	movi	r3,88
8112a00c:	108037cc 	andi	r2,r2,223
8112a010:	10c00a1e 	bne	r2,r3,8112a03c <_strtoll_r+0x2dc>
8112a014:	05000404 	movi	r20,16
8112a018:	8c000043 	ldbu	r16,1(r17)
8112a01c:	002f883a 	mov	r23,zero
8112a020:	8c400084 	addi	r17,r17,2
8112a024:	a027883a 	mov	r19,r20
8112a028:	003f7406 	br	81129dfc <__reset+0xfb109dfc>
8112a02c:	00e00034 	movhi	r3,32768
8112a030:	18ffffc4 	addi	r3,r3,-1
8112a034:	5005883a 	mov	r2,r10
8112a038:	003fda06 	br	81129fa4 <__reset+0xfb109fa4>
8112a03c:	9829883a 	mov	r20,r19
8112a040:	002f883a 	mov	r23,zero
8112a044:	003f6d06 	br	81129dfc <__reset+0xfb109dfc>

8112a048 <_strtoul_r>:
8112a048:	00a04574 	movhi	r2,33045
8112a04c:	defff604 	addi	sp,sp,-40
8112a050:	10b52704 	addi	r2,r2,-11108
8112a054:	de00012e 	bgeu	sp,et,8112a05c <_strtoul_r+0x14>
8112a058:	003b68fa 	trap	3
8112a05c:	dc800315 	stw	r18,12(sp)
8112a060:	14800017 	ldw	r18,0(r2)
8112a064:	dd400615 	stw	r21,24(sp)
8112a068:	dd000515 	stw	r20,20(sp)
8112a06c:	dcc00415 	stw	r19,16(sp)
8112a070:	2029883a 	mov	r20,r4
8112a074:	dfc00915 	stw	ra,36(sp)
8112a078:	ddc00815 	stw	r23,32(sp)
8112a07c:	dd800715 	stw	r22,28(sp)
8112a080:	dc400215 	stw	r17,8(sp)
8112a084:	dc000115 	stw	r16,4(sp)
8112a088:	2827883a 	mov	r19,r5
8112a08c:	382b883a 	mov	r21,r7
8112a090:	2809883a 	mov	r4,r5
8112a094:	24000003 	ldbu	r16,0(r4)
8112a098:	24400044 	addi	r17,r4,1
8112a09c:	2007883a 	mov	r3,r4
8112a0a0:	9405883a 	add	r2,r18,r16
8112a0a4:	10800043 	ldbu	r2,1(r2)
8112a0a8:	8809883a 	mov	r4,r17
8112a0ac:	1080020c 	andi	r2,r2,8
8112a0b0:	103ff81e 	bne	r2,zero,8112a094 <__reset+0xfb10a094>
8112a0b4:	00800b44 	movi	r2,45
8112a0b8:	80805326 	beq	r16,r2,8112a208 <_strtoul_r+0x1c0>
8112a0bc:	00800ac4 	movi	r2,43
8112a0c0:	80805526 	beq	r16,r2,8112a218 <_strtoul_r+0x1d0>
8112a0c4:	002f883a 	mov	r23,zero
8112a0c8:	a8000f26 	beq	r21,zero,8112a108 <_strtoul_r+0xc0>
8112a0cc:	00800404 	movi	r2,16
8112a0d0:	a8805f26 	beq	r21,r2,8112a250 <_strtoul_r+0x208>
8112a0d4:	013fffc4 	movi	r4,-1
8112a0d8:	a80b883a 	mov	r5,r21
8112a0dc:	d9800015 	stw	r6,0(sp)
8112a0e0:	112f1340 	call	8112f134 <__udivsi3>
8112a0e4:	a80b883a 	mov	r5,r21
8112a0e8:	013fffc4 	movi	r4,-1
8112a0ec:	102d883a 	mov	r22,r2
8112a0f0:	112f1980 	call	8112f198 <__umodsi3>
8112a0f4:	d9800017 	ldw	r6,0(sp)
8112a0f8:	1019883a 	mov	r12,r2
8112a0fc:	a817883a 	mov	r11,r21
8112a100:	b00f883a 	mov	r7,r22
8112a104:	00000706 	br	8112a124 <_strtoul_r+0xdc>
8112a108:	00800c04 	movi	r2,48
8112a10c:	80804626 	beq	r16,r2,8112a228 <_strtoul_r+0x1e0>
8112a110:	05400284 	movi	r21,10
8112a114:	01c666b4 	movhi	r7,6554
8112a118:	03000144 	movi	r12,5
8112a11c:	39e66644 	addi	r7,r7,-26215
8112a120:	a817883a 	mov	r11,r21
8112a124:	9407883a 	add	r3,r18,r16
8112a128:	18c00043 	ldbu	r3,1(r3)
8112a12c:	8809883a 	mov	r4,r17
8112a130:	0011883a 	mov	r8,zero
8112a134:	1940010c 	andi	r5,r3,4
8112a138:	0005883a 	mov	r2,zero
8112a13c:	02800044 	movi	r10,1
8112a140:	027fffc4 	movi	r9,-1
8112a144:	28000e26 	beq	r5,zero,8112a180 <_strtoul_r+0x138>
8112a148:	843ff404 	addi	r16,r16,-48
8112a14c:	8540120e 	bge	r16,r21,8112a198 <_strtoul_r+0x150>
8112a150:	42400526 	beq	r8,r9,8112a168 <_strtoul_r+0x120>
8112a154:	38802236 	bltu	r7,r2,8112a1e0 <_strtoul_r+0x198>
8112a158:	11c02026 	beq	r2,r7,8112a1dc <_strtoul_r+0x194>
8112a15c:	12c5383a 	mul	r2,r2,r11
8112a160:	02000044 	movi	r8,1
8112a164:	8085883a 	add	r2,r16,r2
8112a168:	24000003 	ldbu	r16,0(r4)
8112a16c:	21000044 	addi	r4,r4,1
8112a170:	9407883a 	add	r3,r18,r16
8112a174:	18c00043 	ldbu	r3,1(r3)
8112a178:	1940010c 	andi	r5,r3,4
8112a17c:	283ff21e 	bne	r5,zero,8112a148 <__reset+0xfb10a148>
8112a180:	18c000cc 	andi	r3,r3,3
8112a184:	18000426 	beq	r3,zero,8112a198 <_strtoul_r+0x150>
8112a188:	1a801726 	beq	r3,r10,8112a1e8 <_strtoul_r+0x1a0>
8112a18c:	00c015c4 	movi	r3,87
8112a190:	80e1c83a 	sub	r16,r16,r3
8112a194:	857fee16 	blt	r16,r21,8112a150 <__reset+0xfb10a150>
8112a198:	40001516 	blt	r8,zero,8112a1f0 <_strtoul_r+0x1a8>
8112a19c:	b8000126 	beq	r23,zero,8112a1a4 <_strtoul_r+0x15c>
8112a1a0:	0085c83a 	sub	r2,zero,r2
8112a1a4:	30000226 	beq	r6,zero,8112a1b0 <_strtoul_r+0x168>
8112a1a8:	4000151e 	bne	r8,zero,8112a200 <_strtoul_r+0x1b8>
8112a1ac:	34c00015 	stw	r19,0(r6)
8112a1b0:	dfc00917 	ldw	ra,36(sp)
8112a1b4:	ddc00817 	ldw	r23,32(sp)
8112a1b8:	dd800717 	ldw	r22,28(sp)
8112a1bc:	dd400617 	ldw	r21,24(sp)
8112a1c0:	dd000517 	ldw	r20,20(sp)
8112a1c4:	dcc00417 	ldw	r19,16(sp)
8112a1c8:	dc800317 	ldw	r18,12(sp)
8112a1cc:	dc400217 	ldw	r17,8(sp)
8112a1d0:	dc000117 	ldw	r16,4(sp)
8112a1d4:	dec00a04 	addi	sp,sp,40
8112a1d8:	f800283a 	ret
8112a1dc:	643fdf0e 	bge	r12,r16,8112a15c <__reset+0xfb10a15c>
8112a1e0:	023fffc4 	movi	r8,-1
8112a1e4:	003fe006 	br	8112a168 <__reset+0xfb10a168>
8112a1e8:	00c00dc4 	movi	r3,55
8112a1ec:	003fe806 	br	8112a190 <__reset+0xfb10a190>
8112a1f0:	00800884 	movi	r2,34
8112a1f4:	a0800015 	stw	r2,0(r20)
8112a1f8:	00bfffc4 	movi	r2,-1
8112a1fc:	303fec26 	beq	r6,zero,8112a1b0 <__reset+0xfb10a1b0>
8112a200:	24ffffc4 	addi	r19,r4,-1
8112a204:	003fe906 	br	8112a1ac <__reset+0xfb10a1ac>
8112a208:	1c400084 	addi	r17,r3,2
8112a20c:	1c000043 	ldbu	r16,1(r3)
8112a210:	05c00044 	movi	r23,1
8112a214:	003fac06 	br	8112a0c8 <__reset+0xfb10a0c8>
8112a218:	1c400084 	addi	r17,r3,2
8112a21c:	1c000043 	ldbu	r16,1(r3)
8112a220:	002f883a 	mov	r23,zero
8112a224:	003fa806 	br	8112a0c8 <__reset+0xfb10a0c8>
8112a228:	88800003 	ldbu	r2,0(r17)
8112a22c:	00c01604 	movi	r3,88
8112a230:	108037cc 	andi	r2,r2,223
8112a234:	10c00c26 	beq	r2,r3,8112a268 <_strtoul_r+0x220>
8112a238:	05400204 	movi	r21,8
8112a23c:	01c80034 	movhi	r7,8192
8112a240:	030001c4 	movi	r12,7
8112a244:	39ffffc4 	addi	r7,r7,-1
8112a248:	a817883a 	mov	r11,r21
8112a24c:	003fb506 	br	8112a124 <__reset+0xfb10a124>
8112a250:	00800c04 	movi	r2,48
8112a254:	80800c1e 	bne	r16,r2,8112a288 <_strtoul_r+0x240>
8112a258:	88800003 	ldbu	r2,0(r17)
8112a25c:	00c01604 	movi	r3,88
8112a260:	108037cc 	andi	r2,r2,223
8112a264:	10c0081e 	bne	r2,r3,8112a288 <_strtoul_r+0x240>
8112a268:	02c00404 	movi	r11,16
8112a26c:	05840034 	movhi	r22,4096
8112a270:	8c000043 	ldbu	r16,1(r17)
8112a274:	030003c4 	movi	r12,15
8112a278:	8c400084 	addi	r17,r17,2
8112a27c:	b5bfffc4 	addi	r22,r22,-1
8112a280:	582b883a 	mov	r21,r11
8112a284:	003f9e06 	br	8112a100 <__reset+0xfb10a100>
8112a288:	01c40034 	movhi	r7,4096
8112a28c:	030003c4 	movi	r12,15
8112a290:	39ffffc4 	addi	r7,r7,-1
8112a294:	a817883a 	mov	r11,r21
8112a298:	003fa206 	br	8112a124 <__reset+0xfb10a124>

8112a29c <strtoul>:
8112a29c:	00a04574 	movhi	r2,33045
8112a2a0:	10b52904 	addi	r2,r2,-11100
8112a2a4:	300f883a 	mov	r7,r6
8112a2a8:	280d883a 	mov	r6,r5
8112a2ac:	200b883a 	mov	r5,r4
8112a2b0:	11000017 	ldw	r4,0(r2)
8112a2b4:	112a0481 	jmpi	8112a048 <_strtoul_r>

8112a2b8 <_strtoull_r>:
8112a2b8:	00a04574 	movhi	r2,33045
8112a2bc:	defff404 	addi	sp,sp,-48
8112a2c0:	10b52704 	addi	r2,r2,-11108
8112a2c4:	de00012e 	bgeu	sp,et,8112a2cc <_strtoull_r+0x14>
8112a2c8:	003b68fa 	trap	3
8112a2cc:	dc400315 	stw	r17,12(sp)
8112a2d0:	14400017 	ldw	r17,0(r2)
8112a2d4:	dd400715 	stw	r21,28(sp)
8112a2d8:	dd000615 	stw	r20,24(sp)
8112a2dc:	dcc00515 	stw	r19,20(sp)
8112a2e0:	dc800415 	stw	r18,16(sp)
8112a2e4:	dfc00b15 	stw	ra,44(sp)
8112a2e8:	df000a15 	stw	fp,40(sp)
8112a2ec:	ddc00915 	stw	r23,36(sp)
8112a2f0:	dd800815 	stw	r22,32(sp)
8112a2f4:	dc000215 	stw	r16,8(sp)
8112a2f8:	2827883a 	mov	r19,r5
8112a2fc:	202b883a 	mov	r21,r4
8112a300:	3029883a 	mov	r20,r6
8112a304:	3825883a 	mov	r18,r7
8112a308:	2807883a 	mov	r3,r5
8112a30c:	1c000003 	ldbu	r16,0(r3)
8112a310:	1f000044 	addi	fp,r3,1
8112a314:	1809883a 	mov	r4,r3
8112a318:	8c05883a 	add	r2,r17,r16
8112a31c:	10800043 	ldbu	r2,1(r2)
8112a320:	e007883a 	mov	r3,fp
8112a324:	1080020c 	andi	r2,r2,8
8112a328:	103ff81e 	bne	r2,zero,8112a30c <__reset+0xfb10a30c>
8112a32c:	00800b44 	movi	r2,45
8112a330:	80806e26 	beq	r16,r2,8112a4ec <_strtoull_r+0x234>
8112a334:	00800ac4 	movi	r2,43
8112a338:	80807026 	beq	r16,r2,8112a4fc <_strtoull_r+0x244>
8112a33c:	002f883a 	mov	r23,zero
8112a340:	90001426 	beq	r18,zero,8112a394 <_strtoull_r+0xdc>
8112a344:	00800404 	movi	r2,16
8112a348:	90807c26 	beq	r18,r2,8112a53c <_strtoull_r+0x284>
8112a34c:	902dd7fa 	srai	r22,r18,31
8112a350:	013fffc4 	movi	r4,-1
8112a354:	200b883a 	mov	r5,r4
8112a358:	900d883a 	mov	r6,r18
8112a35c:	b00f883a 	mov	r7,r22
8112a360:	112e57c0 	call	8112e57c <__udivdi3>
8112a364:	013fffc4 	movi	r4,-1
8112a368:	900d883a 	mov	r6,r18
8112a36c:	b00f883a 	mov	r7,r22
8112a370:	200b883a 	mov	r5,r4
8112a374:	d8c00115 	stw	r3,4(sp)
8112a378:	d8800015 	stw	r2,0(sp)
8112a37c:	112eafc0 	call	8112eafc <__umoddi3>
8112a380:	101b883a 	mov	r13,r2
8112a384:	9015883a 	mov	r10,r18
8112a388:	dac00017 	ldw	r11,0(sp)
8112a38c:	da000117 	ldw	r8,4(sp)
8112a390:	00000a06 	br	8112a3bc <_strtoull_r+0x104>
8112a394:	00800c04 	movi	r2,48
8112a398:	80805c26 	beq	r16,r2,8112a50c <_strtoull_r+0x254>
8112a39c:	02800284 	movi	r10,10
8112a3a0:	02e666b4 	movhi	r11,39322
8112a3a4:	020666b4 	movhi	r8,6554
8112a3a8:	03400144 	movi	r13,5
8112a3ac:	5ae66644 	addi	r11,r11,-26215
8112a3b0:	42266644 	addi	r8,r8,-26215
8112a3b4:	002d883a 	mov	r22,zero
8112a3b8:	5025883a 	mov	r18,r10
8112a3bc:	8c0b883a 	add	r5,r17,r16
8112a3c0:	29400043 	ldbu	r5,1(r5)
8112a3c4:	e009883a 	mov	r4,fp
8112a3c8:	000f883a 	mov	r7,zero
8112a3cc:	2980010c 	andi	r6,r5,4
8112a3d0:	0005883a 	mov	r2,zero
8112a3d4:	0007883a 	mov	r3,zero
8112a3d8:	03000044 	movi	r12,1
8112a3dc:	027fffc4 	movi	r9,-1
8112a3e0:	30000d26 	beq	r6,zero,8112a418 <_strtoull_r+0x160>
8112a3e4:	843ff404 	addi	r16,r16,-48
8112a3e8:	8480110e 	bge	r16,r18,8112a430 <_strtoull_r+0x178>
8112a3ec:	3a400426 	beq	r7,r9,8112a400 <_strtoull_r+0x148>
8112a3f0:	40c00236 	bltu	r8,r3,8112a3fc <_strtoull_r+0x144>
8112a3f4:	1a00231e 	bne	r3,r8,8112a484 <_strtoull_r+0x1cc>
8112a3f8:	5880222e 	bgeu	r11,r2,8112a484 <_strtoull_r+0x1cc>
8112a3fc:	01ffffc4 	movi	r7,-1
8112a400:	24000003 	ldbu	r16,0(r4)
8112a404:	21000044 	addi	r4,r4,1
8112a408:	8c0b883a 	add	r5,r17,r16
8112a40c:	29400043 	ldbu	r5,1(r5)
8112a410:	2980010c 	andi	r6,r5,4
8112a414:	303ff31e 	bne	r6,zero,8112a3e4 <__reset+0xfb10a3e4>
8112a418:	294000cc 	andi	r5,r5,3
8112a41c:	28000426 	beq	r5,zero,8112a430 <_strtoull_r+0x178>
8112a420:	2b002626 	beq	r5,r12,8112a4bc <_strtoull_r+0x204>
8112a424:	014015c4 	movi	r5,87
8112a428:	8161c83a 	sub	r16,r16,r5
8112a42c:	84bfef16 	blt	r16,r18,8112a3ec <__reset+0xfb10a3ec>
8112a430:	38002716 	blt	r7,zero,8112a4d0 <_strtoull_r+0x218>
8112a434:	b8000426 	beq	r23,zero,8112a448 <_strtoull_r+0x190>
8112a438:	0085c83a 	sub	r2,zero,r2
8112a43c:	100ac03a 	cmpne	r5,r2,zero
8112a440:	00e1c83a 	sub	r16,zero,r3
8112a444:	8147c83a 	sub	r3,r16,r5
8112a448:	a0000226 	beq	r20,zero,8112a454 <_strtoull_r+0x19c>
8112a44c:	3800251e 	bne	r7,zero,8112a4e4 <_strtoull_r+0x22c>
8112a450:	a4c00015 	stw	r19,0(r20)
8112a454:	dfc00b17 	ldw	ra,44(sp)
8112a458:	df000a17 	ldw	fp,40(sp)
8112a45c:	ddc00917 	ldw	r23,36(sp)
8112a460:	dd800817 	ldw	r22,32(sp)
8112a464:	dd400717 	ldw	r21,28(sp)
8112a468:	dd000617 	ldw	r20,24(sp)
8112a46c:	dcc00517 	ldw	r19,20(sp)
8112a470:	dc800417 	ldw	r18,16(sp)
8112a474:	dc400317 	ldw	r17,12(sp)
8112a478:	dc000217 	ldw	r16,8(sp)
8112a47c:	dec00c04 	addi	sp,sp,48
8112a480:	f800283a 	ret
8112a484:	12c00f26 	beq	r2,r11,8112a4c4 <_strtoull_r+0x20c>
8112a488:	b08d383a 	mul	r6,r22,r2
8112a48c:	1a87383a 	mul	r3,r3,r10
8112a490:	128a383a 	mulxuu	r5,r2,r10
8112a494:	1285383a 	mul	r2,r2,r10
8112a498:	800fd7fa 	srai	r7,r16,31
8112a49c:	1987883a 	add	r3,r3,r6
8112a4a0:	8085883a 	add	r2,r16,r2
8112a4a4:	1947883a 	add	r3,r3,r5
8112a4a8:	38c7883a 	add	r3,r7,r3
8112a4ac:	1421803a 	cmpltu	r16,r2,r16
8112a4b0:	80c7883a 	add	r3,r16,r3
8112a4b4:	01c00044 	movi	r7,1
8112a4b8:	003fd106 	br	8112a400 <__reset+0xfb10a400>
8112a4bc:	01400dc4 	movi	r5,55
8112a4c0:	003fd906 	br	8112a428 <__reset+0xfb10a428>
8112a4c4:	1a3ff01e 	bne	r3,r8,8112a488 <__reset+0xfb10a488>
8112a4c8:	6c3fcc16 	blt	r13,r16,8112a3fc <__reset+0xfb10a3fc>
8112a4cc:	003fee06 	br	8112a488 <__reset+0xfb10a488>
8112a4d0:	00800884 	movi	r2,34
8112a4d4:	a8800015 	stw	r2,0(r21)
8112a4d8:	00bfffc4 	movi	r2,-1
8112a4dc:	1007883a 	mov	r3,r2
8112a4e0:	a03fdc26 	beq	r20,zero,8112a454 <__reset+0xfb10a454>
8112a4e4:	24ffffc4 	addi	r19,r4,-1
8112a4e8:	003fd906 	br	8112a450 <__reset+0xfb10a450>
8112a4ec:	27000084 	addi	fp,r4,2
8112a4f0:	24000043 	ldbu	r16,1(r4)
8112a4f4:	05c00044 	movi	r23,1
8112a4f8:	003f9106 	br	8112a340 <__reset+0xfb10a340>
8112a4fc:	27000084 	addi	fp,r4,2
8112a500:	24000043 	ldbu	r16,1(r4)
8112a504:	002f883a 	mov	r23,zero
8112a508:	003f8d06 	br	8112a340 <__reset+0xfb10a340>
8112a50c:	e0800003 	ldbu	r2,0(fp)
8112a510:	00c01604 	movi	r3,88
8112a514:	108037cc 	andi	r2,r2,223
8112a518:	10c00e26 	beq	r2,r3,8112a554 <_strtoull_r+0x29c>
8112a51c:	02800204 	movi	r10,8
8112a520:	02ffffc4 	movi	r11,-1
8112a524:	02080034 	movhi	r8,8192
8112a528:	034001c4 	movi	r13,7
8112a52c:	42d1883a 	add	r8,r8,r11
8112a530:	002d883a 	mov	r22,zero
8112a534:	5025883a 	mov	r18,r10
8112a538:	003fa006 	br	8112a3bc <__reset+0xfb10a3bc>
8112a53c:	00800c04 	movi	r2,48
8112a540:	80800e1e 	bne	r16,r2,8112a57c <_strtoull_r+0x2c4>
8112a544:	e0800003 	ldbu	r2,0(fp)
8112a548:	00c01604 	movi	r3,88
8112a54c:	108037cc 	andi	r2,r2,223
8112a550:	10c00a1e 	bne	r2,r3,8112a57c <_strtoull_r+0x2c4>
8112a554:	02800404 	movi	r10,16
8112a558:	02ffffc4 	movi	r11,-1
8112a55c:	02040034 	movhi	r8,4096
8112a560:	e4000043 	ldbu	r16,1(fp)
8112a564:	034003c4 	movi	r13,15
8112a568:	e7000084 	addi	fp,fp,2
8112a56c:	42d1883a 	add	r8,r8,r11
8112a570:	002d883a 	mov	r22,zero
8112a574:	5025883a 	mov	r18,r10
8112a578:	003f9006 	br	8112a3bc <__reset+0xfb10a3bc>
8112a57c:	02ffffc4 	movi	r11,-1
8112a580:	02040034 	movhi	r8,4096
8112a584:	034003c4 	movi	r13,15
8112a588:	42d1883a 	add	r8,r8,r11
8112a58c:	9015883a 	mov	r10,r18
8112a590:	002d883a 	mov	r22,zero
8112a594:	003f8906 	br	8112a3bc <__reset+0xfb10a3bc>

8112a598 <__ssprint_r>:
8112a598:	defff604 	addi	sp,sp,-40
8112a59c:	de00012e 	bgeu	sp,et,8112a5a4 <__ssprint_r+0xc>
8112a5a0:	003b68fa 	trap	3
8112a5a4:	30800217 	ldw	r2,8(r6)
8112a5a8:	dc800215 	stw	r18,8(sp)
8112a5ac:	dfc00915 	stw	ra,36(sp)
8112a5b0:	df000815 	stw	fp,32(sp)
8112a5b4:	ddc00715 	stw	r23,28(sp)
8112a5b8:	dd800615 	stw	r22,24(sp)
8112a5bc:	dd400515 	stw	r21,20(sp)
8112a5c0:	dd000415 	stw	r20,16(sp)
8112a5c4:	dcc00315 	stw	r19,12(sp)
8112a5c8:	dc400115 	stw	r17,4(sp)
8112a5cc:	dc000015 	stw	r16,0(sp)
8112a5d0:	3025883a 	mov	r18,r6
8112a5d4:	10005826 	beq	r2,zero,8112a738 <__ssprint_r+0x1a0>
8112a5d8:	2027883a 	mov	r19,r4
8112a5dc:	35c00017 	ldw	r23,0(r6)
8112a5e0:	29000017 	ldw	r4,0(r5)
8112a5e4:	28800217 	ldw	r2,8(r5)
8112a5e8:	2823883a 	mov	r17,r5
8112a5ec:	0039883a 	mov	fp,zero
8112a5f0:	0021883a 	mov	r16,zero
8112a5f4:	80003926 	beq	r16,zero,8112a6dc <__ssprint_r+0x144>
8112a5f8:	102b883a 	mov	r21,r2
8112a5fc:	102d883a 	mov	r22,r2
8112a600:	80803a36 	bltu	r16,r2,8112a6ec <__ssprint_r+0x154>
8112a604:	88c0030b 	ldhu	r3,12(r17)
8112a608:	1881200c 	andi	r2,r3,1152
8112a60c:	10002626 	beq	r2,zero,8112a6a8 <__ssprint_r+0x110>
8112a610:	88800517 	ldw	r2,20(r17)
8112a614:	89400417 	ldw	r5,16(r17)
8112a618:	81800044 	addi	r6,r16,1
8112a61c:	108f883a 	add	r7,r2,r2
8112a620:	3885883a 	add	r2,r7,r2
8112a624:	100ed7fa 	srli	r7,r2,31
8112a628:	216dc83a 	sub	r22,r4,r5
8112a62c:	3589883a 	add	r4,r6,r22
8112a630:	3885883a 	add	r2,r7,r2
8112a634:	102bd07a 	srai	r21,r2,1
8112a638:	a80d883a 	mov	r6,r21
8112a63c:	a900022e 	bgeu	r21,r4,8112a648 <__ssprint_r+0xb0>
8112a640:	202b883a 	mov	r21,r4
8112a644:	200d883a 	mov	r6,r4
8112a648:	18c1000c 	andi	r3,r3,1024
8112a64c:	18002a26 	beq	r3,zero,8112a6f8 <__ssprint_r+0x160>
8112a650:	300b883a 	mov	r5,r6
8112a654:	9809883a 	mov	r4,r19
8112a658:	111c3380 	call	8111c338 <_malloc_r>
8112a65c:	1029883a 	mov	r20,r2
8112a660:	10002c26 	beq	r2,zero,8112a714 <__ssprint_r+0x17c>
8112a664:	89400417 	ldw	r5,16(r17)
8112a668:	b00d883a 	mov	r6,r22
8112a66c:	1009883a 	mov	r4,r2
8112a670:	111cb4c0 	call	8111cb4c <memcpy>
8112a674:	8880030b 	ldhu	r2,12(r17)
8112a678:	00fedfc4 	movi	r3,-1153
8112a67c:	10c4703a 	and	r2,r2,r3
8112a680:	10802014 	ori	r2,r2,128
8112a684:	8880030d 	sth	r2,12(r17)
8112a688:	a589883a 	add	r4,r20,r22
8112a68c:	adadc83a 	sub	r22,r21,r22
8112a690:	8d400515 	stw	r21,20(r17)
8112a694:	8d800215 	stw	r22,8(r17)
8112a698:	8d000415 	stw	r20,16(r17)
8112a69c:	89000015 	stw	r4,0(r17)
8112a6a0:	802b883a 	mov	r21,r16
8112a6a4:	802d883a 	mov	r22,r16
8112a6a8:	b00d883a 	mov	r6,r22
8112a6ac:	e00b883a 	mov	r5,fp
8112a6b0:	1126c200 	call	81126c20 <memmove>
8112a6b4:	88800217 	ldw	r2,8(r17)
8112a6b8:	89000017 	ldw	r4,0(r17)
8112a6bc:	90c00217 	ldw	r3,8(r18)
8112a6c0:	1545c83a 	sub	r2,r2,r21
8112a6c4:	2589883a 	add	r4,r4,r22
8112a6c8:	88800215 	stw	r2,8(r17)
8112a6cc:	89000015 	stw	r4,0(r17)
8112a6d0:	1c21c83a 	sub	r16,r3,r16
8112a6d4:	94000215 	stw	r16,8(r18)
8112a6d8:	80001726 	beq	r16,zero,8112a738 <__ssprint_r+0x1a0>
8112a6dc:	bf000017 	ldw	fp,0(r23)
8112a6e0:	bc000117 	ldw	r16,4(r23)
8112a6e4:	bdc00204 	addi	r23,r23,8
8112a6e8:	003fc206 	br	8112a5f4 <__reset+0xfb10a5f4>
8112a6ec:	802b883a 	mov	r21,r16
8112a6f0:	802d883a 	mov	r22,r16
8112a6f4:	003fec06 	br	8112a6a8 <__reset+0xfb10a6a8>
8112a6f8:	9809883a 	mov	r4,r19
8112a6fc:	1127e400 	call	81127e40 <_realloc_r>
8112a700:	1029883a 	mov	r20,r2
8112a704:	103fe01e 	bne	r2,zero,8112a688 <__reset+0xfb10a688>
8112a708:	89400417 	ldw	r5,16(r17)
8112a70c:	9809883a 	mov	r4,r19
8112a710:	1125dac0 	call	81125dac <_free_r>
8112a714:	88c0030b 	ldhu	r3,12(r17)
8112a718:	00800304 	movi	r2,12
8112a71c:	98800015 	stw	r2,0(r19)
8112a720:	18c01014 	ori	r3,r3,64
8112a724:	88c0030d 	sth	r3,12(r17)
8112a728:	00bfffc4 	movi	r2,-1
8112a72c:	90000215 	stw	zero,8(r18)
8112a730:	90000115 	stw	zero,4(r18)
8112a734:	00000206 	br	8112a740 <__ssprint_r+0x1a8>
8112a738:	90000115 	stw	zero,4(r18)
8112a73c:	0005883a 	mov	r2,zero
8112a740:	dfc00917 	ldw	ra,36(sp)
8112a744:	df000817 	ldw	fp,32(sp)
8112a748:	ddc00717 	ldw	r23,28(sp)
8112a74c:	dd800617 	ldw	r22,24(sp)
8112a750:	dd400517 	ldw	r21,20(sp)
8112a754:	dd000417 	ldw	r20,16(sp)
8112a758:	dcc00317 	ldw	r19,12(sp)
8112a75c:	dc800217 	ldw	r18,8(sp)
8112a760:	dc400117 	ldw	r17,4(sp)
8112a764:	dc000017 	ldw	r16,0(sp)
8112a768:	dec00a04 	addi	sp,sp,40
8112a76c:	f800283a 	ret

8112a770 <___svfiprintf_internal_r>:
8112a770:	deffc804 	addi	sp,sp,-224
8112a774:	de00012e 	bgeu	sp,et,8112a77c <___svfiprintf_internal_r+0xc>
8112a778:	003b68fa 	trap	3
8112a77c:	2880030b 	ldhu	r2,12(r5)
8112a780:	dcc03115 	stw	r19,196(sp)
8112a784:	dfc03715 	stw	ra,220(sp)
8112a788:	df003615 	stw	fp,216(sp)
8112a78c:	ddc03515 	stw	r23,212(sp)
8112a790:	dd803415 	stw	r22,208(sp)
8112a794:	dd403315 	stw	r21,204(sp)
8112a798:	dd003215 	stw	r20,200(sp)
8112a79c:	dc803015 	stw	r18,192(sp)
8112a7a0:	dc402f15 	stw	r17,188(sp)
8112a7a4:	dc002e15 	stw	r16,184(sp)
8112a7a8:	d9402715 	stw	r5,156(sp)
8112a7ac:	d9002a15 	stw	r4,168(sp)
8112a7b0:	1080200c 	andi	r2,r2,128
8112a7b4:	d9c02315 	stw	r7,140(sp)
8112a7b8:	3027883a 	mov	r19,r6
8112a7bc:	10000226 	beq	r2,zero,8112a7c8 <___svfiprintf_internal_r+0x58>
8112a7c0:	28800417 	ldw	r2,16(r5)
8112a7c4:	10041d26 	beq	r2,zero,8112b83c <___svfiprintf_internal_r+0x10cc>
8112a7c8:	dac01a04 	addi	r11,sp,104
8112a7cc:	dac01e15 	stw	r11,120(sp)
8112a7d0:	d8801e17 	ldw	r2,120(sp)
8112a7d4:	dac019c4 	addi	r11,sp,103
8112a7d8:	dd402a17 	ldw	r21,168(sp)
8112a7dc:	ddc02717 	ldw	r23,156(sp)
8112a7e0:	05a04574 	movhi	r22,33045
8112a7e4:	05204574 	movhi	r20,33045
8112a7e8:	dac01f15 	stw	r11,124(sp)
8112a7ec:	12d7c83a 	sub	r11,r2,r11
8112a7f0:	b5abe804 	addi	r22,r22,-20576
8112a7f4:	a52be404 	addi	r20,r20,-20592
8112a7f8:	dec01a15 	stw	sp,104(sp)
8112a7fc:	d8001c15 	stw	zero,112(sp)
8112a800:	d8001b15 	stw	zero,108(sp)
8112a804:	d811883a 	mov	r8,sp
8112a808:	d8002915 	stw	zero,164(sp)
8112a80c:	d8002515 	stw	zero,148(sp)
8112a810:	dac02b15 	stw	r11,172(sp)
8112a814:	98800007 	ldb	r2,0(r19)
8112a818:	1002dd26 	beq	r2,zero,8112b390 <___svfiprintf_internal_r+0xc20>
8112a81c:	00c00944 	movi	r3,37
8112a820:	9823883a 	mov	r17,r19
8112a824:	10c0021e 	bne	r2,r3,8112a830 <___svfiprintf_internal_r+0xc0>
8112a828:	00001406 	br	8112a87c <___svfiprintf_internal_r+0x10c>
8112a82c:	10c00326 	beq	r2,r3,8112a83c <___svfiprintf_internal_r+0xcc>
8112a830:	8c400044 	addi	r17,r17,1
8112a834:	88800007 	ldb	r2,0(r17)
8112a838:	103ffc1e 	bne	r2,zero,8112a82c <__reset+0xfb10a82c>
8112a83c:	8ce1c83a 	sub	r16,r17,r19
8112a840:	80000e26 	beq	r16,zero,8112a87c <___svfiprintf_internal_r+0x10c>
8112a844:	d8c01c17 	ldw	r3,112(sp)
8112a848:	d8801b17 	ldw	r2,108(sp)
8112a84c:	44c00015 	stw	r19,0(r8)
8112a850:	1c07883a 	add	r3,r3,r16
8112a854:	10800044 	addi	r2,r2,1
8112a858:	d8c01c15 	stw	r3,112(sp)
8112a85c:	44000115 	stw	r16,4(r8)
8112a860:	d8801b15 	stw	r2,108(sp)
8112a864:	00c001c4 	movi	r3,7
8112a868:	18831e16 	blt	r3,r2,8112b4e4 <___svfiprintf_internal_r+0xd74>
8112a86c:	42000204 	addi	r8,r8,8
8112a870:	dac02517 	ldw	r11,148(sp)
8112a874:	5c17883a 	add	r11,r11,r16
8112a878:	dac02515 	stw	r11,148(sp)
8112a87c:	88800007 	ldb	r2,0(r17)
8112a880:	1002c526 	beq	r2,zero,8112b398 <___svfiprintf_internal_r+0xc28>
8112a884:	88c00047 	ldb	r3,1(r17)
8112a888:	8cc00044 	addi	r19,r17,1
8112a88c:	d8001d85 	stb	zero,118(sp)
8112a890:	0009883a 	mov	r4,zero
8112a894:	000f883a 	mov	r7,zero
8112a898:	043fffc4 	movi	r16,-1
8112a89c:	d8002415 	stw	zero,144(sp)
8112a8a0:	0025883a 	mov	r18,zero
8112a8a4:	01401604 	movi	r5,88
8112a8a8:	01800244 	movi	r6,9
8112a8ac:	02800a84 	movi	r10,42
8112a8b0:	02401b04 	movi	r9,108
8112a8b4:	9cc00044 	addi	r19,r19,1
8112a8b8:	18bff804 	addi	r2,r3,-32
8112a8bc:	2881dd36 	bltu	r5,r2,8112b034 <___svfiprintf_internal_r+0x8c4>
8112a8c0:	100490ba 	slli	r2,r2,2
8112a8c4:	02e044f4 	movhi	r11,33043
8112a8c8:	5aea3604 	addi	r11,r11,-22312
8112a8cc:	12c5883a 	add	r2,r2,r11
8112a8d0:	10800017 	ldw	r2,0(r2)
8112a8d4:	1000683a 	jmp	r2
8112a8d8:	8112aad4 	ori	r4,r16,19115
8112a8dc:	8112b034 	orhi	r4,r16,19136
8112a8e0:	8112b034 	orhi	r4,r16,19136
8112a8e4:	8112aac8 	cmpgei	r4,r16,19115
8112a8e8:	8112b034 	orhi	r4,r16,19136
8112a8ec:	8112b034 	orhi	r4,r16,19136
8112a8f0:	8112b034 	orhi	r4,r16,19136
8112a8f4:	8112b034 	orhi	r4,r16,19136
8112a8f8:	8112b034 	orhi	r4,r16,19136
8112a8fc:	8112b034 	orhi	r4,r16,19136
8112a900:	8112aa3c 	xorhi	r4,r16,19112
8112a904:	8112ac18 	cmpnei	r4,r16,19120
8112a908:	8112b034 	orhi	r4,r16,19136
8112a90c:	8112aa68 	cmpgeui	r4,r16,19113
8112a910:	8112b068 	cmpgeui	r4,r16,19137
8112a914:	8112b034 	orhi	r4,r16,19136
8112a918:	8112b05c 	xori	r4,r16,19137
8112a91c:	8112affc 	xorhi	r4,r16,19135
8112a920:	8112affc 	xorhi	r4,r16,19135
8112a924:	8112affc 	xorhi	r4,r16,19135
8112a928:	8112affc 	xorhi	r4,r16,19135
8112a92c:	8112affc 	xorhi	r4,r16,19135
8112a930:	8112affc 	xorhi	r4,r16,19135
8112a934:	8112affc 	xorhi	r4,r16,19135
8112a938:	8112affc 	xorhi	r4,r16,19135
8112a93c:	8112affc 	xorhi	r4,r16,19135
8112a940:	8112b034 	orhi	r4,r16,19136
8112a944:	8112b034 	orhi	r4,r16,19136
8112a948:	8112b034 	orhi	r4,r16,19136
8112a94c:	8112b034 	orhi	r4,r16,19136
8112a950:	8112b034 	orhi	r4,r16,19136
8112a954:	8112b034 	orhi	r4,r16,19136
8112a958:	8112b034 	orhi	r4,r16,19136
8112a95c:	8112b034 	orhi	r4,r16,19136
8112a960:	8112b034 	orhi	r4,r16,19136
8112a964:	8112b034 	orhi	r4,r16,19136
8112a968:	8112af98 	cmpnei	r4,r16,19134
8112a96c:	8112b034 	orhi	r4,r16,19136
8112a970:	8112b034 	orhi	r4,r16,19136
8112a974:	8112b034 	orhi	r4,r16,19136
8112a978:	8112b034 	orhi	r4,r16,19136
8112a97c:	8112b034 	orhi	r4,r16,19136
8112a980:	8112b034 	orhi	r4,r16,19136
8112a984:	8112b034 	orhi	r4,r16,19136
8112a988:	8112b034 	orhi	r4,r16,19136
8112a98c:	8112b034 	orhi	r4,r16,19136
8112a990:	8112b034 	orhi	r4,r16,19136
8112a994:	8112b110 	cmplti	r4,r16,19140
8112a998:	8112b034 	orhi	r4,r16,19136
8112a99c:	8112b034 	orhi	r4,r16,19136
8112a9a0:	8112b034 	orhi	r4,r16,19136
8112a9a4:	8112b034 	orhi	r4,r16,19136
8112a9a8:	8112b034 	orhi	r4,r16,19136
8112a9ac:	8112b0a8 	cmpgeui	r4,r16,19138
8112a9b0:	8112b034 	orhi	r4,r16,19136
8112a9b4:	8112b034 	orhi	r4,r16,19136
8112a9b8:	8112addc 	xori	r4,r16,19127
8112a9bc:	8112b034 	orhi	r4,r16,19136
8112a9c0:	8112b034 	orhi	r4,r16,19136
8112a9c4:	8112b034 	orhi	r4,r16,19136
8112a9c8:	8112b034 	orhi	r4,r16,19136
8112a9cc:	8112b034 	orhi	r4,r16,19136
8112a9d0:	8112b034 	orhi	r4,r16,19136
8112a9d4:	8112b034 	orhi	r4,r16,19136
8112a9d8:	8112b034 	orhi	r4,r16,19136
8112a9dc:	8112b034 	orhi	r4,r16,19136
8112a9e0:	8112b034 	orhi	r4,r16,19136
8112a9e4:	8112accc 	andi	r4,r16,19123
8112a9e8:	8112ae78 	rdprs	r4,r16,19129
8112a9ec:	8112b034 	orhi	r4,r16,19136
8112a9f0:	8112b034 	orhi	r4,r16,19136
8112a9f4:	8112b034 	orhi	r4,r16,19136
8112a9f8:	8112ae6c 	andhi	r4,r16,19129
8112a9fc:	8112ae78 	rdprs	r4,r16,19129
8112aa00:	8112b034 	orhi	r4,r16,19136
8112aa04:	8112b034 	orhi	r4,r16,19136
8112aa08:	8112ae5c 	xori	r4,r16,19129
8112aa0c:	8112b034 	orhi	r4,r16,19136
8112aa10:	8112ae20 	cmpeqi	r4,r16,19128
8112aa14:	8112ac28 	cmpgeui	r4,r16,19120
8112aa18:	8112aa74 	orhi	r4,r16,19113
8112aa1c:	8112af8c 	andi	r4,r16,19134
8112aa20:	8112b034 	orhi	r4,r16,19136
8112aa24:	8112af40 	call	88112af4 <__reset+0x20f2af4>
8112aa28:	8112b034 	orhi	r4,r16,19136
8112aa2c:	8112ab98 	cmpnei	r4,r16,19118
8112aa30:	8112b034 	orhi	r4,r16,19136
8112aa34:	8112b034 	orhi	r4,r16,19136
8112aa38:	8112aaf4 	orhi	r4,r16,19115
8112aa3c:	dac02317 	ldw	r11,140(sp)
8112aa40:	5ac00017 	ldw	r11,0(r11)
8112aa44:	dac02415 	stw	r11,144(sp)
8112aa48:	dac02317 	ldw	r11,140(sp)
8112aa4c:	58800104 	addi	r2,r11,4
8112aa50:	dac02417 	ldw	r11,144(sp)
8112aa54:	5802e90e 	bge	r11,zero,8112b5fc <___svfiprintf_internal_r+0xe8c>
8112aa58:	dac02417 	ldw	r11,144(sp)
8112aa5c:	d8802315 	stw	r2,140(sp)
8112aa60:	02d7c83a 	sub	r11,zero,r11
8112aa64:	dac02415 	stw	r11,144(sp)
8112aa68:	94800114 	ori	r18,r18,4
8112aa6c:	98c00007 	ldb	r3,0(r19)
8112aa70:	003f9006 	br	8112a8b4 <__reset+0xfb10a8b4>
8112aa74:	00800c04 	movi	r2,48
8112aa78:	dac02317 	ldw	r11,140(sp)
8112aa7c:	d8801d05 	stb	r2,116(sp)
8112aa80:	00801e04 	movi	r2,120
8112aa84:	d8801d45 	stb	r2,117(sp)
8112aa88:	d8001d85 	stb	zero,118(sp)
8112aa8c:	58c00104 	addi	r3,r11,4
8112aa90:	5f000017 	ldw	fp,0(r11)
8112aa94:	0013883a 	mov	r9,zero
8112aa98:	90800094 	ori	r2,r18,2
8112aa9c:	80032b16 	blt	r16,zero,8112b74c <___svfiprintf_internal_r+0xfdc>
8112aaa0:	00bfdfc4 	movi	r2,-129
8112aaa4:	90a4703a 	and	r18,r18,r2
8112aaa8:	d8c02315 	stw	r3,140(sp)
8112aaac:	94800094 	ori	r18,r18,2
8112aab0:	e002dc26 	beq	fp,zero,8112b624 <___svfiprintf_internal_r+0xeb4>
8112aab4:	01204574 	movhi	r4,33045
8112aab8:	212b5a04 	addi	r4,r4,-21144
8112aabc:	0015883a 	mov	r10,zero
8112aac0:	d9002915 	stw	r4,164(sp)
8112aac4:	00002306 	br	8112ab54 <___svfiprintf_internal_r+0x3e4>
8112aac8:	94800054 	ori	r18,r18,1
8112aacc:	98c00007 	ldb	r3,0(r19)
8112aad0:	003f7806 	br	8112a8b4 <__reset+0xfb10a8b4>
8112aad4:	38803fcc 	andi	r2,r7,255
8112aad8:	1080201c 	xori	r2,r2,128
8112aadc:	10bfe004 	addi	r2,r2,-128
8112aae0:	1002f31e 	bne	r2,zero,8112b6b0 <___svfiprintf_internal_r+0xf40>
8112aae4:	01000044 	movi	r4,1
8112aae8:	01c00804 	movi	r7,32
8112aaec:	98c00007 	ldb	r3,0(r19)
8112aaf0:	003f7006 	br	8112a8b4 <__reset+0xfb10a8b4>
8112aaf4:	21003fcc 	andi	r4,r4,255
8112aaf8:	2003aa1e 	bne	r4,zero,8112b9a4 <___svfiprintf_internal_r+0x1234>
8112aafc:	00a04574 	movhi	r2,33045
8112ab00:	10ab5a04 	addi	r2,r2,-21144
8112ab04:	d8802915 	stw	r2,164(sp)
8112ab08:	9080080c 	andi	r2,r18,32
8112ab0c:	1000ba26 	beq	r2,zero,8112adf8 <___svfiprintf_internal_r+0x688>
8112ab10:	dac02317 	ldw	r11,140(sp)
8112ab14:	5f000017 	ldw	fp,0(r11)
8112ab18:	5a400117 	ldw	r9,4(r11)
8112ab1c:	5ac00204 	addi	r11,r11,8
8112ab20:	dac02315 	stw	r11,140(sp)
8112ab24:	9080004c 	andi	r2,r18,1
8112ab28:	10029026 	beq	r2,zero,8112b56c <___svfiprintf_internal_r+0xdfc>
8112ab2c:	e244b03a 	or	r2,fp,r9
8112ab30:	1002d41e 	bne	r2,zero,8112b684 <___svfiprintf_internal_r+0xf14>
8112ab34:	d8001d85 	stb	zero,118(sp)
8112ab38:	80030b16 	blt	r16,zero,8112b768 <___svfiprintf_internal_r+0xff8>
8112ab3c:	00bfdfc4 	movi	r2,-129
8112ab40:	90a4703a 	and	r18,r18,r2
8112ab44:	0015883a 	mov	r10,zero
8112ab48:	80002426 	beq	r16,zero,8112abdc <___svfiprintf_internal_r+0x46c>
8112ab4c:	0039883a 	mov	fp,zero
8112ab50:	0013883a 	mov	r9,zero
8112ab54:	d9002917 	ldw	r4,164(sp)
8112ab58:	dc401a04 	addi	r17,sp,104
8112ab5c:	e08003cc 	andi	r2,fp,15
8112ab60:	4806973a 	slli	r3,r9,28
8112ab64:	2085883a 	add	r2,r4,r2
8112ab68:	e038d13a 	srli	fp,fp,4
8112ab6c:	10800003 	ldbu	r2,0(r2)
8112ab70:	4812d13a 	srli	r9,r9,4
8112ab74:	8c7fffc4 	addi	r17,r17,-1
8112ab78:	1f38b03a 	or	fp,r3,fp
8112ab7c:	88800005 	stb	r2,0(r17)
8112ab80:	e244b03a 	or	r2,fp,r9
8112ab84:	103ff51e 	bne	r2,zero,8112ab5c <__reset+0xfb10ab5c>
8112ab88:	dac01e17 	ldw	r11,120(sp)
8112ab8c:	5c57c83a 	sub	r11,r11,r17
8112ab90:	dac02115 	stw	r11,132(sp)
8112ab94:	00001406 	br	8112abe8 <___svfiprintf_internal_r+0x478>
8112ab98:	21003fcc 	andi	r4,r4,255
8112ab9c:	2003741e 	bne	r4,zero,8112b970 <___svfiprintf_internal_r+0x1200>
8112aba0:	9080080c 	andi	r2,r18,32
8112aba4:	10014526 	beq	r2,zero,8112b0bc <___svfiprintf_internal_r+0x94c>
8112aba8:	dac02317 	ldw	r11,140(sp)
8112abac:	d8001d85 	stb	zero,118(sp)
8112abb0:	58c00204 	addi	r3,r11,8
8112abb4:	5f000017 	ldw	fp,0(r11)
8112abb8:	5a400117 	ldw	r9,4(r11)
8112abbc:	8002d916 	blt	r16,zero,8112b724 <___svfiprintf_internal_r+0xfb4>
8112abc0:	013fdfc4 	movi	r4,-129
8112abc4:	e244b03a 	or	r2,fp,r9
8112abc8:	d8c02315 	stw	r3,140(sp)
8112abcc:	9124703a 	and	r18,r18,r4
8112abd0:	0015883a 	mov	r10,zero
8112abd4:	1000b91e 	bne	r2,zero,8112aebc <___svfiprintf_internal_r+0x74c>
8112abd8:	8002e61e 	bne	r16,zero,8112b774 <___svfiprintf_internal_r+0x1004>
8112abdc:	0021883a 	mov	r16,zero
8112abe0:	d8002115 	stw	zero,132(sp)
8112abe4:	dc401a04 	addi	r17,sp,104
8112abe8:	d8c02117 	ldw	r3,132(sp)
8112abec:	dc002015 	stw	r16,128(sp)
8112abf0:	80c0010e 	bge	r16,r3,8112abf8 <___svfiprintf_internal_r+0x488>
8112abf4:	d8c02015 	stw	r3,128(sp)
8112abf8:	52803fcc 	andi	r10,r10,255
8112abfc:	5280201c 	xori	r10,r10,128
8112ac00:	52bfe004 	addi	r10,r10,-128
8112ac04:	50003c26 	beq	r10,zero,8112acf8 <___svfiprintf_internal_r+0x588>
8112ac08:	dac02017 	ldw	r11,128(sp)
8112ac0c:	5ac00044 	addi	r11,r11,1
8112ac10:	dac02015 	stw	r11,128(sp)
8112ac14:	00003806 	br	8112acf8 <___svfiprintf_internal_r+0x588>
8112ac18:	01000044 	movi	r4,1
8112ac1c:	01c00ac4 	movi	r7,43
8112ac20:	98c00007 	ldb	r3,0(r19)
8112ac24:	003f2306 	br	8112a8b4 <__reset+0xfb10a8b4>
8112ac28:	21003fcc 	andi	r4,r4,255
8112ac2c:	2003481e 	bne	r4,zero,8112b950 <___svfiprintf_internal_r+0x11e0>
8112ac30:	9080080c 	andi	r2,r18,32
8112ac34:	10013b26 	beq	r2,zero,8112b124 <___svfiprintf_internal_r+0x9b4>
8112ac38:	dac02317 	ldw	r11,140(sp)
8112ac3c:	d8001d85 	stb	zero,118(sp)
8112ac40:	58800204 	addi	r2,r11,8
8112ac44:	5f000017 	ldw	fp,0(r11)
8112ac48:	5a400117 	ldw	r9,4(r11)
8112ac4c:	8002a816 	blt	r16,zero,8112b6f0 <___svfiprintf_internal_r+0xf80>
8112ac50:	013fdfc4 	movi	r4,-129
8112ac54:	e246b03a 	or	r3,fp,r9
8112ac58:	d8802315 	stw	r2,140(sp)
8112ac5c:	9124703a 	and	r18,r18,r4
8112ac60:	18013c26 	beq	r3,zero,8112b154 <___svfiprintf_internal_r+0x9e4>
8112ac64:	0015883a 	mov	r10,zero
8112ac68:	dc401a04 	addi	r17,sp,104
8112ac6c:	e006d0fa 	srli	r3,fp,3
8112ac70:	4808977a 	slli	r4,r9,29
8112ac74:	4812d0fa 	srli	r9,r9,3
8112ac78:	e70001cc 	andi	fp,fp,7
8112ac7c:	e0800c04 	addi	r2,fp,48
8112ac80:	8c7fffc4 	addi	r17,r17,-1
8112ac84:	20f8b03a 	or	fp,r4,r3
8112ac88:	88800005 	stb	r2,0(r17)
8112ac8c:	e246b03a 	or	r3,fp,r9
8112ac90:	183ff61e 	bne	r3,zero,8112ac6c <__reset+0xfb10ac6c>
8112ac94:	90c0004c 	andi	r3,r18,1
8112ac98:	1800a526 	beq	r3,zero,8112af30 <___svfiprintf_internal_r+0x7c0>
8112ac9c:	10803fcc 	andi	r2,r2,255
8112aca0:	1080201c 	xori	r2,r2,128
8112aca4:	10bfe004 	addi	r2,r2,-128
8112aca8:	00c00c04 	movi	r3,48
8112acac:	10ffb626 	beq	r2,r3,8112ab88 <__reset+0xfb10ab88>
8112acb0:	88ffffc5 	stb	r3,-1(r17)
8112acb4:	d8c01e17 	ldw	r3,120(sp)
8112acb8:	88bfffc4 	addi	r2,r17,-1
8112acbc:	1023883a 	mov	r17,r2
8112acc0:	1887c83a 	sub	r3,r3,r2
8112acc4:	d8c02115 	stw	r3,132(sp)
8112acc8:	003fc706 	br	8112abe8 <__reset+0xfb10abe8>
8112accc:	dac02317 	ldw	r11,140(sp)
8112acd0:	00c00044 	movi	r3,1
8112acd4:	d8c02015 	stw	r3,128(sp)
8112acd8:	58800017 	ldw	r2,0(r11)
8112acdc:	5ac00104 	addi	r11,r11,4
8112ace0:	d8001d85 	stb	zero,118(sp)
8112ace4:	d8801005 	stb	r2,64(sp)
8112ace8:	dac02315 	stw	r11,140(sp)
8112acec:	d8c02115 	stw	r3,132(sp)
8112acf0:	dc401004 	addi	r17,sp,64
8112acf4:	0021883a 	mov	r16,zero
8112acf8:	90c0008c 	andi	r3,r18,2
8112acfc:	d8c02215 	stw	r3,136(sp)
8112ad00:	18000326 	beq	r3,zero,8112ad10 <___svfiprintf_internal_r+0x5a0>
8112ad04:	dac02017 	ldw	r11,128(sp)
8112ad08:	5ac00084 	addi	r11,r11,2
8112ad0c:	dac02015 	stw	r11,128(sp)
8112ad10:	90c0210c 	andi	r3,r18,132
8112ad14:	d8c02615 	stw	r3,152(sp)
8112ad18:	1801131e 	bne	r3,zero,8112b168 <___svfiprintf_internal_r+0x9f8>
8112ad1c:	dac02417 	ldw	r11,144(sp)
8112ad20:	d8c02017 	ldw	r3,128(sp)
8112ad24:	58f9c83a 	sub	fp,r11,r3
8112ad28:	07010f0e 	bge	zero,fp,8112b168 <___svfiprintf_internal_r+0x9f8>
8112ad2c:	02400404 	movi	r9,16
8112ad30:	d8c01c17 	ldw	r3,112(sp)
8112ad34:	d8801b17 	ldw	r2,108(sp)
8112ad38:	4f02d60e 	bge	r9,fp,8112b894 <___svfiprintf_internal_r+0x1124>
8112ad3c:	01604574 	movhi	r5,33045
8112ad40:	296be804 	addi	r5,r5,-20576
8112ad44:	d9402815 	stw	r5,160(sp)
8112ad48:	028001c4 	movi	r10,7
8112ad4c:	00000306 	br	8112ad5c <___svfiprintf_internal_r+0x5ec>
8112ad50:	e73ffc04 	addi	fp,fp,-16
8112ad54:	42000204 	addi	r8,r8,8
8112ad58:	4f00150e 	bge	r9,fp,8112adb0 <___svfiprintf_internal_r+0x640>
8112ad5c:	18c00404 	addi	r3,r3,16
8112ad60:	10800044 	addi	r2,r2,1
8112ad64:	45800015 	stw	r22,0(r8)
8112ad68:	42400115 	stw	r9,4(r8)
8112ad6c:	d8c01c15 	stw	r3,112(sp)
8112ad70:	d8801b15 	stw	r2,108(sp)
8112ad74:	50bff60e 	bge	r10,r2,8112ad50 <__reset+0xfb10ad50>
8112ad78:	d9801a04 	addi	r6,sp,104
8112ad7c:	b80b883a 	mov	r5,r23
8112ad80:	a809883a 	mov	r4,r21
8112ad84:	da402c15 	stw	r9,176(sp)
8112ad88:	da802d15 	stw	r10,180(sp)
8112ad8c:	112a5980 	call	8112a598 <__ssprint_r>
8112ad90:	da402c17 	ldw	r9,176(sp)
8112ad94:	da802d17 	ldw	r10,180(sp)
8112ad98:	1001851e 	bne	r2,zero,8112b3b0 <___svfiprintf_internal_r+0xc40>
8112ad9c:	e73ffc04 	addi	fp,fp,-16
8112ada0:	d8c01c17 	ldw	r3,112(sp)
8112ada4:	d8801b17 	ldw	r2,108(sp)
8112ada8:	d811883a 	mov	r8,sp
8112adac:	4f3feb16 	blt	r9,fp,8112ad5c <__reset+0xfb10ad5c>
8112adb0:	dac02817 	ldw	r11,160(sp)
8112adb4:	e0c7883a 	add	r3,fp,r3
8112adb8:	10800044 	addi	r2,r2,1
8112adbc:	42c00015 	stw	r11,0(r8)
8112adc0:	47000115 	stw	fp,4(r8)
8112adc4:	d8c01c15 	stw	r3,112(sp)
8112adc8:	d8801b15 	stw	r2,108(sp)
8112adcc:	010001c4 	movi	r4,7
8112add0:	2081ee16 	blt	r4,r2,8112b58c <___svfiprintf_internal_r+0xe1c>
8112add4:	42000204 	addi	r8,r8,8
8112add8:	0000e506 	br	8112b170 <___svfiprintf_internal_r+0xa00>
8112addc:	21003fcc 	andi	r4,r4,255
8112ade0:	2002dd1e 	bne	r4,zero,8112b958 <___svfiprintf_internal_r+0x11e8>
8112ade4:	00a04574 	movhi	r2,33045
8112ade8:	10ab5504 	addi	r2,r2,-21164
8112adec:	d8802915 	stw	r2,164(sp)
8112adf0:	9080080c 	andi	r2,r18,32
8112adf4:	103f461e 	bne	r2,zero,8112ab10 <__reset+0xfb10ab10>
8112adf8:	9080040c 	andi	r2,r18,16
8112adfc:	10022e1e 	bne	r2,zero,8112b6b8 <___svfiprintf_internal_r+0xf48>
8112ae00:	9080100c 	andi	r2,r18,64
8112ae04:	dac02317 	ldw	r11,140(sp)
8112ae08:	10027326 	beq	r2,zero,8112b7d8 <___svfiprintf_internal_r+0x1068>
8112ae0c:	5f00000b 	ldhu	fp,0(r11)
8112ae10:	5ac00104 	addi	r11,r11,4
8112ae14:	0013883a 	mov	r9,zero
8112ae18:	dac02315 	stw	r11,140(sp)
8112ae1c:	003f4106 	br	8112ab24 <__reset+0xfb10ab24>
8112ae20:	21003fcc 	andi	r4,r4,255
8112ae24:	2002e11e 	bne	r4,zero,8112b9ac <___svfiprintf_internal_r+0x123c>
8112ae28:	9080080c 	andi	r2,r18,32
8112ae2c:	1002011e 	bne	r2,zero,8112b634 <___svfiprintf_internal_r+0xec4>
8112ae30:	9080040c 	andi	r2,r18,16
8112ae34:	10023e1e 	bne	r2,zero,8112b730 <___svfiprintf_internal_r+0xfc0>
8112ae38:	9480100c 	andi	r18,r18,64
8112ae3c:	90023c26 	beq	r18,zero,8112b730 <___svfiprintf_internal_r+0xfc0>
8112ae40:	dac02317 	ldw	r11,140(sp)
8112ae44:	58800017 	ldw	r2,0(r11)
8112ae48:	5ac00104 	addi	r11,r11,4
8112ae4c:	dac02315 	stw	r11,140(sp)
8112ae50:	dac02517 	ldw	r11,148(sp)
8112ae54:	12c0000d 	sth	r11,0(r2)
8112ae58:	003e6e06 	br	8112a814 <__reset+0xfb10a814>
8112ae5c:	98c00007 	ldb	r3,0(r19)
8112ae60:	1a422926 	beq	r3,r9,8112b708 <___svfiprintf_internal_r+0xf98>
8112ae64:	94800414 	ori	r18,r18,16
8112ae68:	003e9206 	br	8112a8b4 <__reset+0xfb10a8b4>
8112ae6c:	94801014 	ori	r18,r18,64
8112ae70:	98c00007 	ldb	r3,0(r19)
8112ae74:	003e8f06 	br	8112a8b4 <__reset+0xfb10a8b4>
8112ae78:	21003fcc 	andi	r4,r4,255
8112ae7c:	2002c71e 	bne	r4,zero,8112b99c <___svfiprintf_internal_r+0x122c>
8112ae80:	9080080c 	andi	r2,r18,32
8112ae84:	10004926 	beq	r2,zero,8112afac <___svfiprintf_internal_r+0x83c>
8112ae88:	dac02317 	ldw	r11,140(sp)
8112ae8c:	58800117 	ldw	r2,4(r11)
8112ae90:	5f000017 	ldw	fp,0(r11)
8112ae94:	5ac00204 	addi	r11,r11,8
8112ae98:	dac02315 	stw	r11,140(sp)
8112ae9c:	1013883a 	mov	r9,r2
8112aea0:	10004b16 	blt	r2,zero,8112afd0 <___svfiprintf_internal_r+0x860>
8112aea4:	da801d83 	ldbu	r10,118(sp)
8112aea8:	8001cb16 	blt	r16,zero,8112b5d8 <___svfiprintf_internal_r+0xe68>
8112aeac:	00ffdfc4 	movi	r3,-129
8112aeb0:	e244b03a 	or	r2,fp,r9
8112aeb4:	90e4703a 	and	r18,r18,r3
8112aeb8:	103f4726 	beq	r2,zero,8112abd8 <__reset+0xfb10abd8>
8112aebc:	48008c26 	beq	r9,zero,8112b0f0 <___svfiprintf_internal_r+0x980>
8112aec0:	dc802015 	stw	r18,128(sp)
8112aec4:	dc002115 	stw	r16,132(sp)
8112aec8:	dc401a04 	addi	r17,sp,104
8112aecc:	e021883a 	mov	r16,fp
8112aed0:	da002215 	stw	r8,136(sp)
8112aed4:	5039883a 	mov	fp,r10
8112aed8:	4825883a 	mov	r18,r9
8112aedc:	8009883a 	mov	r4,r16
8112aee0:	900b883a 	mov	r5,r18
8112aee4:	01800284 	movi	r6,10
8112aee8:	000f883a 	mov	r7,zero
8112aeec:	112eafc0 	call	8112eafc <__umoddi3>
8112aef0:	10800c04 	addi	r2,r2,48
8112aef4:	8c7fffc4 	addi	r17,r17,-1
8112aef8:	8009883a 	mov	r4,r16
8112aefc:	900b883a 	mov	r5,r18
8112af00:	88800005 	stb	r2,0(r17)
8112af04:	01800284 	movi	r6,10
8112af08:	000f883a 	mov	r7,zero
8112af0c:	112e57c0 	call	8112e57c <__udivdi3>
8112af10:	1021883a 	mov	r16,r2
8112af14:	10c4b03a 	or	r2,r2,r3
8112af18:	1825883a 	mov	r18,r3
8112af1c:	103fef1e 	bne	r2,zero,8112aedc <__reset+0xfb10aedc>
8112af20:	dc802017 	ldw	r18,128(sp)
8112af24:	dc002117 	ldw	r16,132(sp)
8112af28:	da002217 	ldw	r8,136(sp)
8112af2c:	e015883a 	mov	r10,fp
8112af30:	d8c01e17 	ldw	r3,120(sp)
8112af34:	1c47c83a 	sub	r3,r3,r17
8112af38:	d8c02115 	stw	r3,132(sp)
8112af3c:	003f2a06 	br	8112abe8 <__reset+0xfb10abe8>
8112af40:	dac02317 	ldw	r11,140(sp)
8112af44:	d8001d85 	stb	zero,118(sp)
8112af48:	5c400017 	ldw	r17,0(r11)
8112af4c:	5f000104 	addi	fp,r11,4
8112af50:	88022f26 	beq	r17,zero,8112b810 <___svfiprintf_internal_r+0x10a0>
8112af54:	80022516 	blt	r16,zero,8112b7ec <___svfiprintf_internal_r+0x107c>
8112af58:	800d883a 	mov	r6,r16
8112af5c:	000b883a 	mov	r5,zero
8112af60:	8809883a 	mov	r4,r17
8112af64:	da002c15 	stw	r8,176(sp)
8112af68:	1126b3c0 	call	81126b3c <memchr>
8112af6c:	da002c17 	ldw	r8,176(sp)
8112af70:	10026426 	beq	r2,zero,8112b904 <___svfiprintf_internal_r+0x1194>
8112af74:	1445c83a 	sub	r2,r2,r17
8112af78:	d8802115 	stw	r2,132(sp)
8112af7c:	da801d83 	ldbu	r10,118(sp)
8112af80:	df002315 	stw	fp,140(sp)
8112af84:	0021883a 	mov	r16,zero
8112af88:	003f1706 	br	8112abe8 <__reset+0xfb10abe8>
8112af8c:	94800814 	ori	r18,r18,32
8112af90:	98c00007 	ldb	r3,0(r19)
8112af94:	003e4706 	br	8112a8b4 <__reset+0xfb10a8b4>
8112af98:	21003fcc 	andi	r4,r4,255
8112af9c:	2002701e 	bne	r4,zero,8112b960 <___svfiprintf_internal_r+0x11f0>
8112afa0:	94800414 	ori	r18,r18,16
8112afa4:	9080080c 	andi	r2,r18,32
8112afa8:	103fb71e 	bne	r2,zero,8112ae88 <__reset+0xfb10ae88>
8112afac:	9080040c 	andi	r2,r18,16
8112afb0:	1001ab26 	beq	r2,zero,8112b660 <___svfiprintf_internal_r+0xef0>
8112afb4:	dac02317 	ldw	r11,140(sp)
8112afb8:	5f000017 	ldw	fp,0(r11)
8112afbc:	5ac00104 	addi	r11,r11,4
8112afc0:	dac02315 	stw	r11,140(sp)
8112afc4:	e013d7fa 	srai	r9,fp,31
8112afc8:	4805883a 	mov	r2,r9
8112afcc:	103fb50e 	bge	r2,zero,8112aea4 <__reset+0xfb10aea4>
8112afd0:	0739c83a 	sub	fp,zero,fp
8112afd4:	02800b44 	movi	r10,45
8112afd8:	e004c03a 	cmpne	r2,fp,zero
8112afdc:	0253c83a 	sub	r9,zero,r9
8112afe0:	da801d85 	stb	r10,118(sp)
8112afe4:	4893c83a 	sub	r9,r9,r2
8112afe8:	80023016 	blt	r16,zero,8112b8ac <___svfiprintf_internal_r+0x113c>
8112afec:	00bfdfc4 	movi	r2,-129
8112aff0:	90a4703a 	and	r18,r18,r2
8112aff4:	483fb21e 	bne	r9,zero,8112aec0 <__reset+0xfb10aec0>
8112aff8:	00003d06 	br	8112b0f0 <___svfiprintf_internal_r+0x980>
8112affc:	9817883a 	mov	r11,r19
8112b000:	d8002415 	stw	zero,144(sp)
8112b004:	18bff404 	addi	r2,r3,-48
8112b008:	0019883a 	mov	r12,zero
8112b00c:	58c00007 	ldb	r3,0(r11)
8112b010:	630002a4 	muli	r12,r12,10
8112b014:	9cc00044 	addi	r19,r19,1
8112b018:	9817883a 	mov	r11,r19
8112b01c:	1319883a 	add	r12,r2,r12
8112b020:	18bff404 	addi	r2,r3,-48
8112b024:	30bff92e 	bgeu	r6,r2,8112b00c <__reset+0xfb10b00c>
8112b028:	db002415 	stw	r12,144(sp)
8112b02c:	18bff804 	addi	r2,r3,-32
8112b030:	28be232e 	bgeu	r5,r2,8112a8c0 <__reset+0xfb10a8c0>
8112b034:	21003fcc 	andi	r4,r4,255
8112b038:	20024b1e 	bne	r4,zero,8112b968 <___svfiprintf_internal_r+0x11f8>
8112b03c:	1800d626 	beq	r3,zero,8112b398 <___svfiprintf_internal_r+0xc28>
8112b040:	02c00044 	movi	r11,1
8112b044:	dac02015 	stw	r11,128(sp)
8112b048:	d8c01005 	stb	r3,64(sp)
8112b04c:	d8001d85 	stb	zero,118(sp)
8112b050:	dac02115 	stw	r11,132(sp)
8112b054:	dc401004 	addi	r17,sp,64
8112b058:	003f2606 	br	8112acf4 <__reset+0xfb10acf4>
8112b05c:	94802014 	ori	r18,r18,128
8112b060:	98c00007 	ldb	r3,0(r19)
8112b064:	003e1306 	br	8112a8b4 <__reset+0xfb10a8b4>
8112b068:	98c00007 	ldb	r3,0(r19)
8112b06c:	9ac00044 	addi	r11,r19,1
8112b070:	1a822b26 	beq	r3,r10,8112b920 <___svfiprintf_internal_r+0x11b0>
8112b074:	18bff404 	addi	r2,r3,-48
8112b078:	0021883a 	mov	r16,zero
8112b07c:	30821e36 	bltu	r6,r2,8112b8f8 <___svfiprintf_internal_r+0x1188>
8112b080:	58c00007 	ldb	r3,0(r11)
8112b084:	840002a4 	muli	r16,r16,10
8112b088:	5cc00044 	addi	r19,r11,1
8112b08c:	9817883a 	mov	r11,r19
8112b090:	80a1883a 	add	r16,r16,r2
8112b094:	18bff404 	addi	r2,r3,-48
8112b098:	30bff92e 	bgeu	r6,r2,8112b080 <__reset+0xfb10b080>
8112b09c:	803e060e 	bge	r16,zero,8112a8b8 <__reset+0xfb10a8b8>
8112b0a0:	043fffc4 	movi	r16,-1
8112b0a4:	003e0406 	br	8112a8b8 <__reset+0xfb10a8b8>
8112b0a8:	21003fcc 	andi	r4,r4,255
8112b0ac:	2002371e 	bne	r4,zero,8112b98c <___svfiprintf_internal_r+0x121c>
8112b0b0:	94800414 	ori	r18,r18,16
8112b0b4:	9080080c 	andi	r2,r18,32
8112b0b8:	103ebb1e 	bne	r2,zero,8112aba8 <__reset+0xfb10aba8>
8112b0bc:	9080040c 	andi	r2,r18,16
8112b0c0:	10013b26 	beq	r2,zero,8112b5b0 <___svfiprintf_internal_r+0xe40>
8112b0c4:	dac02317 	ldw	r11,140(sp)
8112b0c8:	d8001d85 	stb	zero,118(sp)
8112b0cc:	0013883a 	mov	r9,zero
8112b0d0:	58800104 	addi	r2,r11,4
8112b0d4:	5f000017 	ldw	fp,0(r11)
8112b0d8:	80013d16 	blt	r16,zero,8112b5d0 <___svfiprintf_internal_r+0xe60>
8112b0dc:	00ffdfc4 	movi	r3,-129
8112b0e0:	d8802315 	stw	r2,140(sp)
8112b0e4:	90e4703a 	and	r18,r18,r3
8112b0e8:	0015883a 	mov	r10,zero
8112b0ec:	e03eba26 	beq	fp,zero,8112abd8 <__reset+0xfb10abd8>
8112b0f0:	00800244 	movi	r2,9
8112b0f4:	173f7236 	bltu	r2,fp,8112aec0 <__reset+0xfb10aec0>
8112b0f8:	dac02b17 	ldw	r11,172(sp)
8112b0fc:	e7000c04 	addi	fp,fp,48
8112b100:	df0019c5 	stb	fp,103(sp)
8112b104:	dac02115 	stw	r11,132(sp)
8112b108:	dc4019c4 	addi	r17,sp,103
8112b10c:	003eb606 	br	8112abe8 <__reset+0xfb10abe8>
8112b110:	21003fcc 	andi	r4,r4,255
8112b114:	20021f1e 	bne	r4,zero,8112b994 <___svfiprintf_internal_r+0x1224>
8112b118:	94800414 	ori	r18,r18,16
8112b11c:	9080080c 	andi	r2,r18,32
8112b120:	103ec51e 	bne	r2,zero,8112ac38 <__reset+0xfb10ac38>
8112b124:	9080040c 	andi	r2,r18,16
8112b128:	10016926 	beq	r2,zero,8112b6d0 <___svfiprintf_internal_r+0xf60>
8112b12c:	dac02317 	ldw	r11,140(sp)
8112b130:	d8001d85 	stb	zero,118(sp)
8112b134:	0013883a 	mov	r9,zero
8112b138:	58800104 	addi	r2,r11,4
8112b13c:	5f000017 	ldw	fp,0(r11)
8112b140:	80016b16 	blt	r16,zero,8112b6f0 <___svfiprintf_internal_r+0xf80>
8112b144:	00ffdfc4 	movi	r3,-129
8112b148:	d8802315 	stw	r2,140(sp)
8112b14c:	90e4703a 	and	r18,r18,r3
8112b150:	e03ec41e 	bne	fp,zero,8112ac64 <__reset+0xfb10ac64>
8112b154:	0015883a 	mov	r10,zero
8112b158:	8001c226 	beq	r16,zero,8112b864 <___svfiprintf_internal_r+0x10f4>
8112b15c:	0039883a 	mov	fp,zero
8112b160:	0013883a 	mov	r9,zero
8112b164:	003ec006 	br	8112ac68 <__reset+0xfb10ac68>
8112b168:	d8c01c17 	ldw	r3,112(sp)
8112b16c:	d8801b17 	ldw	r2,108(sp)
8112b170:	d9001d87 	ldb	r4,118(sp)
8112b174:	20000b26 	beq	r4,zero,8112b1a4 <___svfiprintf_internal_r+0xa34>
8112b178:	d9001d84 	addi	r4,sp,118
8112b17c:	18c00044 	addi	r3,r3,1
8112b180:	10800044 	addi	r2,r2,1
8112b184:	41000015 	stw	r4,0(r8)
8112b188:	01000044 	movi	r4,1
8112b18c:	41000115 	stw	r4,4(r8)
8112b190:	d8c01c15 	stw	r3,112(sp)
8112b194:	d8801b15 	stw	r2,108(sp)
8112b198:	010001c4 	movi	r4,7
8112b19c:	2080e116 	blt	r4,r2,8112b524 <___svfiprintf_internal_r+0xdb4>
8112b1a0:	42000204 	addi	r8,r8,8
8112b1a4:	dac02217 	ldw	r11,136(sp)
8112b1a8:	58000b26 	beq	r11,zero,8112b1d8 <___svfiprintf_internal_r+0xa68>
8112b1ac:	d9001d04 	addi	r4,sp,116
8112b1b0:	18c00084 	addi	r3,r3,2
8112b1b4:	10800044 	addi	r2,r2,1
8112b1b8:	41000015 	stw	r4,0(r8)
8112b1bc:	01000084 	movi	r4,2
8112b1c0:	41000115 	stw	r4,4(r8)
8112b1c4:	d8c01c15 	stw	r3,112(sp)
8112b1c8:	d8801b15 	stw	r2,108(sp)
8112b1cc:	010001c4 	movi	r4,7
8112b1d0:	2080dd16 	blt	r4,r2,8112b548 <___svfiprintf_internal_r+0xdd8>
8112b1d4:	42000204 	addi	r8,r8,8
8112b1d8:	dac02617 	ldw	r11,152(sp)
8112b1dc:	01002004 	movi	r4,128
8112b1e0:	59008426 	beq	r11,r4,8112b3f4 <___svfiprintf_internal_r+0xc84>
8112b1e4:	dac02117 	ldw	r11,132(sp)
8112b1e8:	82e1c83a 	sub	r16,r16,r11
8112b1ec:	0400270e 	bge	zero,r16,8112b28c <___svfiprintf_internal_r+0xb1c>
8112b1f0:	01c00404 	movi	r7,16
8112b1f4:	3c016a0e 	bge	r7,r16,8112b7a0 <___svfiprintf_internal_r+0x1030>
8112b1f8:	01604574 	movhi	r5,33045
8112b1fc:	296be404 	addi	r5,r5,-20592
8112b200:	d9402215 	stw	r5,136(sp)
8112b204:	070001c4 	movi	fp,7
8112b208:	00000306 	br	8112b218 <___svfiprintf_internal_r+0xaa8>
8112b20c:	843ffc04 	addi	r16,r16,-16
8112b210:	42000204 	addi	r8,r8,8
8112b214:	3c00130e 	bge	r7,r16,8112b264 <___svfiprintf_internal_r+0xaf4>
8112b218:	18c00404 	addi	r3,r3,16
8112b21c:	10800044 	addi	r2,r2,1
8112b220:	45000015 	stw	r20,0(r8)
8112b224:	41c00115 	stw	r7,4(r8)
8112b228:	d8c01c15 	stw	r3,112(sp)
8112b22c:	d8801b15 	stw	r2,108(sp)
8112b230:	e0bff60e 	bge	fp,r2,8112b20c <__reset+0xfb10b20c>
8112b234:	d9801a04 	addi	r6,sp,104
8112b238:	b80b883a 	mov	r5,r23
8112b23c:	a809883a 	mov	r4,r21
8112b240:	d9c02c15 	stw	r7,176(sp)
8112b244:	112a5980 	call	8112a598 <__ssprint_r>
8112b248:	d9c02c17 	ldw	r7,176(sp)
8112b24c:	1000581e 	bne	r2,zero,8112b3b0 <___svfiprintf_internal_r+0xc40>
8112b250:	843ffc04 	addi	r16,r16,-16
8112b254:	d8c01c17 	ldw	r3,112(sp)
8112b258:	d8801b17 	ldw	r2,108(sp)
8112b25c:	d811883a 	mov	r8,sp
8112b260:	3c3fed16 	blt	r7,r16,8112b218 <__reset+0xfb10b218>
8112b264:	dac02217 	ldw	r11,136(sp)
8112b268:	1c07883a 	add	r3,r3,r16
8112b26c:	10800044 	addi	r2,r2,1
8112b270:	42c00015 	stw	r11,0(r8)
8112b274:	44000115 	stw	r16,4(r8)
8112b278:	d8c01c15 	stw	r3,112(sp)
8112b27c:	d8801b15 	stw	r2,108(sp)
8112b280:	010001c4 	movi	r4,7
8112b284:	20809e16 	blt	r4,r2,8112b500 <___svfiprintf_internal_r+0xd90>
8112b288:	42000204 	addi	r8,r8,8
8112b28c:	dac02117 	ldw	r11,132(sp)
8112b290:	10800044 	addi	r2,r2,1
8112b294:	44400015 	stw	r17,0(r8)
8112b298:	58c7883a 	add	r3,r11,r3
8112b29c:	42c00115 	stw	r11,4(r8)
8112b2a0:	d8c01c15 	stw	r3,112(sp)
8112b2a4:	d8801b15 	stw	r2,108(sp)
8112b2a8:	010001c4 	movi	r4,7
8112b2ac:	20807f16 	blt	r4,r2,8112b4ac <___svfiprintf_internal_r+0xd3c>
8112b2b0:	42000204 	addi	r8,r8,8
8112b2b4:	9480010c 	andi	r18,r18,4
8112b2b8:	90002926 	beq	r18,zero,8112b360 <___svfiprintf_internal_r+0xbf0>
8112b2bc:	dac02417 	ldw	r11,144(sp)
8112b2c0:	d8802017 	ldw	r2,128(sp)
8112b2c4:	58a1c83a 	sub	r16,r11,r2
8112b2c8:	0400250e 	bge	zero,r16,8112b360 <___svfiprintf_internal_r+0xbf0>
8112b2cc:	04400404 	movi	r17,16
8112b2d0:	d8801b17 	ldw	r2,108(sp)
8112b2d4:	8c017c0e 	bge	r17,r16,8112b8c8 <___svfiprintf_internal_r+0x1158>
8112b2d8:	01604574 	movhi	r5,33045
8112b2dc:	296be804 	addi	r5,r5,-20576
8112b2e0:	d9402815 	stw	r5,160(sp)
8112b2e4:	048001c4 	movi	r18,7
8112b2e8:	00000306 	br	8112b2f8 <___svfiprintf_internal_r+0xb88>
8112b2ec:	843ffc04 	addi	r16,r16,-16
8112b2f0:	42000204 	addi	r8,r8,8
8112b2f4:	8c00110e 	bge	r17,r16,8112b33c <___svfiprintf_internal_r+0xbcc>
8112b2f8:	18c00404 	addi	r3,r3,16
8112b2fc:	10800044 	addi	r2,r2,1
8112b300:	45800015 	stw	r22,0(r8)
8112b304:	44400115 	stw	r17,4(r8)
8112b308:	d8c01c15 	stw	r3,112(sp)
8112b30c:	d8801b15 	stw	r2,108(sp)
8112b310:	90bff60e 	bge	r18,r2,8112b2ec <__reset+0xfb10b2ec>
8112b314:	d9801a04 	addi	r6,sp,104
8112b318:	b80b883a 	mov	r5,r23
8112b31c:	a809883a 	mov	r4,r21
8112b320:	112a5980 	call	8112a598 <__ssprint_r>
8112b324:	1000221e 	bne	r2,zero,8112b3b0 <___svfiprintf_internal_r+0xc40>
8112b328:	843ffc04 	addi	r16,r16,-16
8112b32c:	d8c01c17 	ldw	r3,112(sp)
8112b330:	d8801b17 	ldw	r2,108(sp)
8112b334:	d811883a 	mov	r8,sp
8112b338:	8c3fef16 	blt	r17,r16,8112b2f8 <__reset+0xfb10b2f8>
8112b33c:	dac02817 	ldw	r11,160(sp)
8112b340:	1c07883a 	add	r3,r3,r16
8112b344:	10800044 	addi	r2,r2,1
8112b348:	42c00015 	stw	r11,0(r8)
8112b34c:	44000115 	stw	r16,4(r8)
8112b350:	d8c01c15 	stw	r3,112(sp)
8112b354:	d8801b15 	stw	r2,108(sp)
8112b358:	010001c4 	movi	r4,7
8112b35c:	2080aa16 	blt	r4,r2,8112b608 <___svfiprintf_internal_r+0xe98>
8112b360:	d8802417 	ldw	r2,144(sp)
8112b364:	dac02017 	ldw	r11,128(sp)
8112b368:	12c0010e 	bge	r2,r11,8112b370 <___svfiprintf_internal_r+0xc00>
8112b36c:	5805883a 	mov	r2,r11
8112b370:	dac02517 	ldw	r11,148(sp)
8112b374:	5897883a 	add	r11,r11,r2
8112b378:	dac02515 	stw	r11,148(sp)
8112b37c:	1800531e 	bne	r3,zero,8112b4cc <___svfiprintf_internal_r+0xd5c>
8112b380:	98800007 	ldb	r2,0(r19)
8112b384:	d8001b15 	stw	zero,108(sp)
8112b388:	d811883a 	mov	r8,sp
8112b38c:	103d231e 	bne	r2,zero,8112a81c <__reset+0xfb10a81c>
8112b390:	9823883a 	mov	r17,r19
8112b394:	003d3906 	br	8112a87c <__reset+0xfb10a87c>
8112b398:	d8801c17 	ldw	r2,112(sp)
8112b39c:	10000426 	beq	r2,zero,8112b3b0 <___svfiprintf_internal_r+0xc40>
8112b3a0:	d9402717 	ldw	r5,156(sp)
8112b3a4:	d9002a17 	ldw	r4,168(sp)
8112b3a8:	d9801a04 	addi	r6,sp,104
8112b3ac:	112a5980 	call	8112a598 <__ssprint_r>
8112b3b0:	dac02717 	ldw	r11,156(sp)
8112b3b4:	d8802517 	ldw	r2,148(sp)
8112b3b8:	58c0030b 	ldhu	r3,12(r11)
8112b3bc:	18c0100c 	andi	r3,r3,64
8112b3c0:	1801381e 	bne	r3,zero,8112b8a4 <___svfiprintf_internal_r+0x1134>
8112b3c4:	dfc03717 	ldw	ra,220(sp)
8112b3c8:	df003617 	ldw	fp,216(sp)
8112b3cc:	ddc03517 	ldw	r23,212(sp)
8112b3d0:	dd803417 	ldw	r22,208(sp)
8112b3d4:	dd403317 	ldw	r21,204(sp)
8112b3d8:	dd003217 	ldw	r20,200(sp)
8112b3dc:	dcc03117 	ldw	r19,196(sp)
8112b3e0:	dc803017 	ldw	r18,192(sp)
8112b3e4:	dc402f17 	ldw	r17,188(sp)
8112b3e8:	dc002e17 	ldw	r16,184(sp)
8112b3ec:	dec03804 	addi	sp,sp,224
8112b3f0:	f800283a 	ret
8112b3f4:	dac02417 	ldw	r11,144(sp)
8112b3f8:	d9002017 	ldw	r4,128(sp)
8112b3fc:	5939c83a 	sub	fp,r11,r4
8112b400:	073f780e 	bge	zero,fp,8112b1e4 <__reset+0xfb10b1e4>
8112b404:	02400404 	movi	r9,16
8112b408:	4f01370e 	bge	r9,fp,8112b8e8 <___svfiprintf_internal_r+0x1178>
8112b40c:	02e04574 	movhi	r11,33045
8112b410:	5aebe404 	addi	r11,r11,-20592
8112b414:	dac02215 	stw	r11,136(sp)
8112b418:	028001c4 	movi	r10,7
8112b41c:	00000306 	br	8112b42c <___svfiprintf_internal_r+0xcbc>
8112b420:	e73ffc04 	addi	fp,fp,-16
8112b424:	42000204 	addi	r8,r8,8
8112b428:	4f00150e 	bge	r9,fp,8112b480 <___svfiprintf_internal_r+0xd10>
8112b42c:	18c00404 	addi	r3,r3,16
8112b430:	10800044 	addi	r2,r2,1
8112b434:	45000015 	stw	r20,0(r8)
8112b438:	42400115 	stw	r9,4(r8)
8112b43c:	d8c01c15 	stw	r3,112(sp)
8112b440:	d8801b15 	stw	r2,108(sp)
8112b444:	50bff60e 	bge	r10,r2,8112b420 <__reset+0xfb10b420>
8112b448:	d9801a04 	addi	r6,sp,104
8112b44c:	b80b883a 	mov	r5,r23
8112b450:	a809883a 	mov	r4,r21
8112b454:	da402c15 	stw	r9,176(sp)
8112b458:	da802d15 	stw	r10,180(sp)
8112b45c:	112a5980 	call	8112a598 <__ssprint_r>
8112b460:	da402c17 	ldw	r9,176(sp)
8112b464:	da802d17 	ldw	r10,180(sp)
8112b468:	103fd11e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b46c:	e73ffc04 	addi	fp,fp,-16
8112b470:	d8c01c17 	ldw	r3,112(sp)
8112b474:	d8801b17 	ldw	r2,108(sp)
8112b478:	d811883a 	mov	r8,sp
8112b47c:	4f3feb16 	blt	r9,fp,8112b42c <__reset+0xfb10b42c>
8112b480:	dac02217 	ldw	r11,136(sp)
8112b484:	1f07883a 	add	r3,r3,fp
8112b488:	10800044 	addi	r2,r2,1
8112b48c:	42c00015 	stw	r11,0(r8)
8112b490:	47000115 	stw	fp,4(r8)
8112b494:	d8c01c15 	stw	r3,112(sp)
8112b498:	d8801b15 	stw	r2,108(sp)
8112b49c:	010001c4 	movi	r4,7
8112b4a0:	2080b616 	blt	r4,r2,8112b77c <___svfiprintf_internal_r+0x100c>
8112b4a4:	42000204 	addi	r8,r8,8
8112b4a8:	003f4e06 	br	8112b1e4 <__reset+0xfb10b1e4>
8112b4ac:	d9801a04 	addi	r6,sp,104
8112b4b0:	b80b883a 	mov	r5,r23
8112b4b4:	a809883a 	mov	r4,r21
8112b4b8:	112a5980 	call	8112a598 <__ssprint_r>
8112b4bc:	103fbc1e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b4c0:	d8c01c17 	ldw	r3,112(sp)
8112b4c4:	d811883a 	mov	r8,sp
8112b4c8:	003f7a06 	br	8112b2b4 <__reset+0xfb10b2b4>
8112b4cc:	d9801a04 	addi	r6,sp,104
8112b4d0:	b80b883a 	mov	r5,r23
8112b4d4:	a809883a 	mov	r4,r21
8112b4d8:	112a5980 	call	8112a598 <__ssprint_r>
8112b4dc:	103fa826 	beq	r2,zero,8112b380 <__reset+0xfb10b380>
8112b4e0:	003fb306 	br	8112b3b0 <__reset+0xfb10b3b0>
8112b4e4:	d9801a04 	addi	r6,sp,104
8112b4e8:	b80b883a 	mov	r5,r23
8112b4ec:	a809883a 	mov	r4,r21
8112b4f0:	112a5980 	call	8112a598 <__ssprint_r>
8112b4f4:	103fae1e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b4f8:	d811883a 	mov	r8,sp
8112b4fc:	003cdc06 	br	8112a870 <__reset+0xfb10a870>
8112b500:	d9801a04 	addi	r6,sp,104
8112b504:	b80b883a 	mov	r5,r23
8112b508:	a809883a 	mov	r4,r21
8112b50c:	112a5980 	call	8112a598 <__ssprint_r>
8112b510:	103fa71e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b514:	d8c01c17 	ldw	r3,112(sp)
8112b518:	d8801b17 	ldw	r2,108(sp)
8112b51c:	d811883a 	mov	r8,sp
8112b520:	003f5a06 	br	8112b28c <__reset+0xfb10b28c>
8112b524:	d9801a04 	addi	r6,sp,104
8112b528:	b80b883a 	mov	r5,r23
8112b52c:	a809883a 	mov	r4,r21
8112b530:	112a5980 	call	8112a598 <__ssprint_r>
8112b534:	103f9e1e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b538:	d8c01c17 	ldw	r3,112(sp)
8112b53c:	d8801b17 	ldw	r2,108(sp)
8112b540:	d811883a 	mov	r8,sp
8112b544:	003f1706 	br	8112b1a4 <__reset+0xfb10b1a4>
8112b548:	d9801a04 	addi	r6,sp,104
8112b54c:	b80b883a 	mov	r5,r23
8112b550:	a809883a 	mov	r4,r21
8112b554:	112a5980 	call	8112a598 <__ssprint_r>
8112b558:	103f951e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b55c:	d8c01c17 	ldw	r3,112(sp)
8112b560:	d8801b17 	ldw	r2,108(sp)
8112b564:	d811883a 	mov	r8,sp
8112b568:	003f1b06 	br	8112b1d8 <__reset+0xfb10b1d8>
8112b56c:	d8001d85 	stb	zero,118(sp)
8112b570:	80007b16 	blt	r16,zero,8112b760 <___svfiprintf_internal_r+0xff0>
8112b574:	00ffdfc4 	movi	r3,-129
8112b578:	e244b03a 	or	r2,fp,r9
8112b57c:	90e4703a 	and	r18,r18,r3
8112b580:	103d7026 	beq	r2,zero,8112ab44 <__reset+0xfb10ab44>
8112b584:	0015883a 	mov	r10,zero
8112b588:	003d7206 	br	8112ab54 <__reset+0xfb10ab54>
8112b58c:	d9801a04 	addi	r6,sp,104
8112b590:	b80b883a 	mov	r5,r23
8112b594:	a809883a 	mov	r4,r21
8112b598:	112a5980 	call	8112a598 <__ssprint_r>
8112b59c:	103f841e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b5a0:	d8c01c17 	ldw	r3,112(sp)
8112b5a4:	d8801b17 	ldw	r2,108(sp)
8112b5a8:	d811883a 	mov	r8,sp
8112b5ac:	003ef006 	br	8112b170 <__reset+0xfb10b170>
8112b5b0:	9080100c 	andi	r2,r18,64
8112b5b4:	d8001d85 	stb	zero,118(sp)
8112b5b8:	dac02317 	ldw	r11,140(sp)
8112b5bc:	10008126 	beq	r2,zero,8112b7c4 <___svfiprintf_internal_r+0x1054>
8112b5c0:	58800104 	addi	r2,r11,4
8112b5c4:	5f00000b 	ldhu	fp,0(r11)
8112b5c8:	0013883a 	mov	r9,zero
8112b5cc:	803ec30e 	bge	r16,zero,8112b0dc <__reset+0xfb10b0dc>
8112b5d0:	d8802315 	stw	r2,140(sp)
8112b5d4:	0015883a 	mov	r10,zero
8112b5d8:	e244b03a 	or	r2,fp,r9
8112b5dc:	103e371e 	bne	r2,zero,8112aebc <__reset+0xfb10aebc>
8112b5e0:	00800044 	movi	r2,1
8112b5e4:	10803fcc 	andi	r2,r2,255
8112b5e8:	00c00044 	movi	r3,1
8112b5ec:	10c06126 	beq	r2,r3,8112b774 <___svfiprintf_internal_r+0x1004>
8112b5f0:	00c00084 	movi	r3,2
8112b5f4:	10fd5526 	beq	r2,r3,8112ab4c <__reset+0xfb10ab4c>
8112b5f8:	003ed806 	br	8112b15c <__reset+0xfb10b15c>
8112b5fc:	d8802315 	stw	r2,140(sp)
8112b600:	98c00007 	ldb	r3,0(r19)
8112b604:	003cab06 	br	8112a8b4 <__reset+0xfb10a8b4>
8112b608:	d9801a04 	addi	r6,sp,104
8112b60c:	b80b883a 	mov	r5,r23
8112b610:	a809883a 	mov	r4,r21
8112b614:	112a5980 	call	8112a598 <__ssprint_r>
8112b618:	103f651e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b61c:	d8c01c17 	ldw	r3,112(sp)
8112b620:	003f4f06 	br	8112b360 <__reset+0xfb10b360>
8112b624:	00a04574 	movhi	r2,33045
8112b628:	10ab5a04 	addi	r2,r2,-21144
8112b62c:	d8802915 	stw	r2,164(sp)
8112b630:	003d4406 	br	8112ab44 <__reset+0xfb10ab44>
8112b634:	dac02317 	ldw	r11,140(sp)
8112b638:	58800017 	ldw	r2,0(r11)
8112b63c:	dac02517 	ldw	r11,148(sp)
8112b640:	5807d7fa 	srai	r3,r11,31
8112b644:	dac02317 	ldw	r11,140(sp)
8112b648:	10c00115 	stw	r3,4(r2)
8112b64c:	5ac00104 	addi	r11,r11,4
8112b650:	dac02315 	stw	r11,140(sp)
8112b654:	dac02517 	ldw	r11,148(sp)
8112b658:	12c00015 	stw	r11,0(r2)
8112b65c:	003c6d06 	br	8112a814 <__reset+0xfb10a814>
8112b660:	9080100c 	andi	r2,r18,64
8112b664:	dac02317 	ldw	r11,140(sp)
8112b668:	103e5326 	beq	r2,zero,8112afb8 <__reset+0xfb10afb8>
8112b66c:	5f00000f 	ldh	fp,0(r11)
8112b670:	5ac00104 	addi	r11,r11,4
8112b674:	dac02315 	stw	r11,140(sp)
8112b678:	e013d7fa 	srai	r9,fp,31
8112b67c:	4805883a 	mov	r2,r9
8112b680:	003e0706 	br	8112aea0 <__reset+0xfb10aea0>
8112b684:	00800c04 	movi	r2,48
8112b688:	d8801d05 	stb	r2,116(sp)
8112b68c:	d8c01d45 	stb	r3,117(sp)
8112b690:	d8001d85 	stb	zero,118(sp)
8112b694:	90800094 	ori	r2,r18,2
8112b698:	80008f16 	blt	r16,zero,8112b8d8 <___svfiprintf_internal_r+0x1168>
8112b69c:	00bfdfc4 	movi	r2,-129
8112b6a0:	90a4703a 	and	r18,r18,r2
8112b6a4:	94800094 	ori	r18,r18,2
8112b6a8:	0015883a 	mov	r10,zero
8112b6ac:	003d2906 	br	8112ab54 <__reset+0xfb10ab54>
8112b6b0:	98c00007 	ldb	r3,0(r19)
8112b6b4:	003c7f06 	br	8112a8b4 <__reset+0xfb10a8b4>
8112b6b8:	dac02317 	ldw	r11,140(sp)
8112b6bc:	0013883a 	mov	r9,zero
8112b6c0:	5f000017 	ldw	fp,0(r11)
8112b6c4:	5ac00104 	addi	r11,r11,4
8112b6c8:	dac02315 	stw	r11,140(sp)
8112b6cc:	003d1506 	br	8112ab24 <__reset+0xfb10ab24>
8112b6d0:	9080100c 	andi	r2,r18,64
8112b6d4:	d8001d85 	stb	zero,118(sp)
8112b6d8:	dac02317 	ldw	r11,140(sp)
8112b6dc:	10003426 	beq	r2,zero,8112b7b0 <___svfiprintf_internal_r+0x1040>
8112b6e0:	58800104 	addi	r2,r11,4
8112b6e4:	5f00000b 	ldhu	fp,0(r11)
8112b6e8:	0013883a 	mov	r9,zero
8112b6ec:	803e950e 	bge	r16,zero,8112b144 <__reset+0xfb10b144>
8112b6f0:	e246b03a 	or	r3,fp,r9
8112b6f4:	d8802315 	stw	r2,140(sp)
8112b6f8:	183d5a1e 	bne	r3,zero,8112ac64 <__reset+0xfb10ac64>
8112b6fc:	0015883a 	mov	r10,zero
8112b700:	0005883a 	mov	r2,zero
8112b704:	003fb706 	br	8112b5e4 <__reset+0xfb10b5e4>
8112b708:	98c00043 	ldbu	r3,1(r19)
8112b70c:	94800814 	ori	r18,r18,32
8112b710:	9cc00044 	addi	r19,r19,1
8112b714:	18c03fcc 	andi	r3,r3,255
8112b718:	18c0201c 	xori	r3,r3,128
8112b71c:	18ffe004 	addi	r3,r3,-128
8112b720:	003c6406 	br	8112a8b4 <__reset+0xfb10a8b4>
8112b724:	d8c02315 	stw	r3,140(sp)
8112b728:	0015883a 	mov	r10,zero
8112b72c:	003faa06 	br	8112b5d8 <__reset+0xfb10b5d8>
8112b730:	dac02317 	ldw	r11,140(sp)
8112b734:	58800017 	ldw	r2,0(r11)
8112b738:	5ac00104 	addi	r11,r11,4
8112b73c:	dac02315 	stw	r11,140(sp)
8112b740:	dac02517 	ldw	r11,148(sp)
8112b744:	12c00015 	stw	r11,0(r2)
8112b748:	003c3206 	br	8112a814 <__reset+0xfb10a814>
8112b74c:	01204574 	movhi	r4,33045
8112b750:	212b5a04 	addi	r4,r4,-21144
8112b754:	d9002915 	stw	r4,164(sp)
8112b758:	d8c02315 	stw	r3,140(sp)
8112b75c:	1025883a 	mov	r18,r2
8112b760:	e244b03a 	or	r2,fp,r9
8112b764:	103f871e 	bne	r2,zero,8112b584 <__reset+0xfb10b584>
8112b768:	0015883a 	mov	r10,zero
8112b76c:	00800084 	movi	r2,2
8112b770:	003f9c06 	br	8112b5e4 <__reset+0xfb10b5e4>
8112b774:	0039883a 	mov	fp,zero
8112b778:	003e5f06 	br	8112b0f8 <__reset+0xfb10b0f8>
8112b77c:	d9801a04 	addi	r6,sp,104
8112b780:	b80b883a 	mov	r5,r23
8112b784:	a809883a 	mov	r4,r21
8112b788:	112a5980 	call	8112a598 <__ssprint_r>
8112b78c:	103f081e 	bne	r2,zero,8112b3b0 <__reset+0xfb10b3b0>
8112b790:	d8c01c17 	ldw	r3,112(sp)
8112b794:	d8801b17 	ldw	r2,108(sp)
8112b798:	d811883a 	mov	r8,sp
8112b79c:	003e9106 	br	8112b1e4 <__reset+0xfb10b1e4>
8112b7a0:	01204574 	movhi	r4,33045
8112b7a4:	212be404 	addi	r4,r4,-20592
8112b7a8:	d9002215 	stw	r4,136(sp)
8112b7ac:	003ead06 	br	8112b264 <__reset+0xfb10b264>
8112b7b0:	58800104 	addi	r2,r11,4
8112b7b4:	5f000017 	ldw	fp,0(r11)
8112b7b8:	0013883a 	mov	r9,zero
8112b7bc:	803e610e 	bge	r16,zero,8112b144 <__reset+0xfb10b144>
8112b7c0:	003fcb06 	br	8112b6f0 <__reset+0xfb10b6f0>
8112b7c4:	58800104 	addi	r2,r11,4
8112b7c8:	5f000017 	ldw	fp,0(r11)
8112b7cc:	0013883a 	mov	r9,zero
8112b7d0:	803e420e 	bge	r16,zero,8112b0dc <__reset+0xfb10b0dc>
8112b7d4:	003f7e06 	br	8112b5d0 <__reset+0xfb10b5d0>
8112b7d8:	5f000017 	ldw	fp,0(r11)
8112b7dc:	5ac00104 	addi	r11,r11,4
8112b7e0:	0013883a 	mov	r9,zero
8112b7e4:	dac02315 	stw	r11,140(sp)
8112b7e8:	003cce06 	br	8112ab24 <__reset+0xfb10ab24>
8112b7ec:	8809883a 	mov	r4,r17
8112b7f0:	da002c15 	stw	r8,176(sp)
8112b7f4:	111d6400 	call	8111d640 <strlen>
8112b7f8:	d8802115 	stw	r2,132(sp)
8112b7fc:	da801d83 	ldbu	r10,118(sp)
8112b800:	df002315 	stw	fp,140(sp)
8112b804:	0021883a 	mov	r16,zero
8112b808:	da002c17 	ldw	r8,176(sp)
8112b80c:	003cf606 	br	8112abe8 <__reset+0xfb10abe8>
8112b810:	00800184 	movi	r2,6
8112b814:	1400012e 	bgeu	r2,r16,8112b81c <___svfiprintf_internal_r+0x10ac>
8112b818:	1021883a 	mov	r16,r2
8112b81c:	dc002115 	stw	r16,132(sp)
8112b820:	8005883a 	mov	r2,r16
8112b824:	80003c16 	blt	r16,zero,8112b918 <___svfiprintf_internal_r+0x11a8>
8112b828:	04604574 	movhi	r17,33045
8112b82c:	d8802015 	stw	r2,128(sp)
8112b830:	df002315 	stw	fp,140(sp)
8112b834:	8c6b5f04 	addi	r17,r17,-21124
8112b838:	003d2e06 	br	8112acf4 <__reset+0xfb10acf4>
8112b83c:	04001004 	movi	r16,64
8112b840:	800b883a 	mov	r5,r16
8112b844:	111c3380 	call	8111c338 <_malloc_r>
8112b848:	dac02717 	ldw	r11,156(sp)
8112b84c:	58800015 	stw	r2,0(r11)
8112b850:	58800415 	stw	r2,16(r11)
8112b854:	10004826 	beq	r2,zero,8112b978 <___svfiprintf_internal_r+0x1208>
8112b858:	dac02717 	ldw	r11,156(sp)
8112b85c:	5c000515 	stw	r16,20(r11)
8112b860:	003bd906 	br	8112a7c8 <__reset+0xfb10a7c8>
8112b864:	9080004c 	andi	r2,r18,1
8112b868:	0015883a 	mov	r10,zero
8112b86c:	10000626 	beq	r2,zero,8112b888 <___svfiprintf_internal_r+0x1118>
8112b870:	dac02b17 	ldw	r11,172(sp)
8112b874:	00800c04 	movi	r2,48
8112b878:	d88019c5 	stb	r2,103(sp)
8112b87c:	dac02115 	stw	r11,132(sp)
8112b880:	dc4019c4 	addi	r17,sp,103
8112b884:	003cd806 	br	8112abe8 <__reset+0xfb10abe8>
8112b888:	d8002115 	stw	zero,132(sp)
8112b88c:	dc401a04 	addi	r17,sp,104
8112b890:	003cd506 	br	8112abe8 <__reset+0xfb10abe8>
8112b894:	01204574 	movhi	r4,33045
8112b898:	212be804 	addi	r4,r4,-20576
8112b89c:	d9002815 	stw	r4,160(sp)
8112b8a0:	003d4306 	br	8112adb0 <__reset+0xfb10adb0>
8112b8a4:	00bfffc4 	movi	r2,-1
8112b8a8:	003ec606 	br	8112b3c4 <__reset+0xfb10b3c4>
8112b8ac:	00800044 	movi	r2,1
8112b8b0:	10803fcc 	andi	r2,r2,255
8112b8b4:	00c00044 	movi	r3,1
8112b8b8:	10fd8026 	beq	r2,r3,8112aebc <__reset+0xfb10aebc>
8112b8bc:	00c00084 	movi	r3,2
8112b8c0:	10fca426 	beq	r2,r3,8112ab54 <__reset+0xfb10ab54>
8112b8c4:	003ce806 	br	8112ac68 <__reset+0xfb10ac68>
8112b8c8:	01204574 	movhi	r4,33045
8112b8cc:	212be804 	addi	r4,r4,-20576
8112b8d0:	d9002815 	stw	r4,160(sp)
8112b8d4:	003e9906 	br	8112b33c <__reset+0xfb10b33c>
8112b8d8:	1025883a 	mov	r18,r2
8112b8dc:	0015883a 	mov	r10,zero
8112b8e0:	00800084 	movi	r2,2
8112b8e4:	003ff206 	br	8112b8b0 <__reset+0xfb10b8b0>
8112b8e8:	01604574 	movhi	r5,33045
8112b8ec:	296be404 	addi	r5,r5,-20592
8112b8f0:	d9402215 	stw	r5,136(sp)
8112b8f4:	003ee206 	br	8112b480 <__reset+0xfb10b480>
8112b8f8:	5827883a 	mov	r19,r11
8112b8fc:	0021883a 	mov	r16,zero
8112b900:	003bed06 	br	8112a8b8 <__reset+0xfb10a8b8>
8112b904:	dc002115 	stw	r16,132(sp)
8112b908:	da801d83 	ldbu	r10,118(sp)
8112b90c:	df002315 	stw	fp,140(sp)
8112b910:	0021883a 	mov	r16,zero
8112b914:	003cb406 	br	8112abe8 <__reset+0xfb10abe8>
8112b918:	0005883a 	mov	r2,zero
8112b91c:	003fc206 	br	8112b828 <__reset+0xfb10b828>
8112b920:	d8802317 	ldw	r2,140(sp)
8112b924:	98c00043 	ldbu	r3,1(r19)
8112b928:	5827883a 	mov	r19,r11
8112b92c:	14000017 	ldw	r16,0(r2)
8112b930:	10800104 	addi	r2,r2,4
8112b934:	d8802315 	stw	r2,140(sp)
8112b938:	803f760e 	bge	r16,zero,8112b714 <__reset+0xfb10b714>
8112b93c:	18c03fcc 	andi	r3,r3,255
8112b940:	18c0201c 	xori	r3,r3,128
8112b944:	043fffc4 	movi	r16,-1
8112b948:	18ffe004 	addi	r3,r3,-128
8112b94c:	003bd906 	br	8112a8b4 <__reset+0xfb10a8b4>
8112b950:	d9c01d85 	stb	r7,118(sp)
8112b954:	003cb606 	br	8112ac30 <__reset+0xfb10ac30>
8112b958:	d9c01d85 	stb	r7,118(sp)
8112b95c:	003d2106 	br	8112ade4 <__reset+0xfb10ade4>
8112b960:	d9c01d85 	stb	r7,118(sp)
8112b964:	003d8e06 	br	8112afa0 <__reset+0xfb10afa0>
8112b968:	d9c01d85 	stb	r7,118(sp)
8112b96c:	003db306 	br	8112b03c <__reset+0xfb10b03c>
8112b970:	d9c01d85 	stb	r7,118(sp)
8112b974:	003c8a06 	br	8112aba0 <__reset+0xfb10aba0>
8112b978:	dac02a17 	ldw	r11,168(sp)
8112b97c:	00800304 	movi	r2,12
8112b980:	58800015 	stw	r2,0(r11)
8112b984:	00bfffc4 	movi	r2,-1
8112b988:	003e8e06 	br	8112b3c4 <__reset+0xfb10b3c4>
8112b98c:	d9c01d85 	stb	r7,118(sp)
8112b990:	003dc706 	br	8112b0b0 <__reset+0xfb10b0b0>
8112b994:	d9c01d85 	stb	r7,118(sp)
8112b998:	003ddf06 	br	8112b118 <__reset+0xfb10b118>
8112b99c:	d9c01d85 	stb	r7,118(sp)
8112b9a0:	003d3706 	br	8112ae80 <__reset+0xfb10ae80>
8112b9a4:	d9c01d85 	stb	r7,118(sp)
8112b9a8:	003c5406 	br	8112aafc <__reset+0xfb10aafc>
8112b9ac:	d9c01d85 	stb	r7,118(sp)
8112b9b0:	003d1d06 	br	8112ae28 <__reset+0xfb10ae28>

8112b9b4 <__submore>:
8112b9b4:	defffa04 	addi	sp,sp,-24
8112b9b8:	de00012e 	bgeu	sp,et,8112b9c0 <__submore+0xc>
8112b9bc:	003b68fa 	trap	3
8112b9c0:	dc000015 	stw	r16,0(sp)
8112b9c4:	2821883a 	mov	r16,r5
8112b9c8:	29400c17 	ldw	r5,48(r5)
8112b9cc:	dfc00515 	stw	ra,20(sp)
8112b9d0:	dd000415 	stw	r20,16(sp)
8112b9d4:	dcc00315 	stw	r19,12(sp)
8112b9d8:	dc800215 	stw	r18,8(sp)
8112b9dc:	dc400115 	stw	r17,4(sp)
8112b9e0:	80801004 	addi	r2,r16,64
8112b9e4:	28801726 	beq	r5,r2,8112ba44 <__submore+0x90>
8112b9e8:	84400d17 	ldw	r17,52(r16)
8112b9ec:	8c67883a 	add	r19,r17,r17
8112b9f0:	980d883a 	mov	r6,r19
8112b9f4:	1127e400 	call	81127e40 <_realloc_r>
8112b9f8:	1025883a 	mov	r18,r2
8112b9fc:	10002226 	beq	r2,zero,8112ba88 <__submore+0xd4>
8112ba00:	1469883a 	add	r20,r2,r17
8112ba04:	880d883a 	mov	r6,r17
8112ba08:	100b883a 	mov	r5,r2
8112ba0c:	a009883a 	mov	r4,r20
8112ba10:	111cb4c0 	call	8111cb4c <memcpy>
8112ba14:	0005883a 	mov	r2,zero
8112ba18:	85000015 	stw	r20,0(r16)
8112ba1c:	84800c15 	stw	r18,48(r16)
8112ba20:	84c00d15 	stw	r19,52(r16)
8112ba24:	dfc00517 	ldw	ra,20(sp)
8112ba28:	dd000417 	ldw	r20,16(sp)
8112ba2c:	dcc00317 	ldw	r19,12(sp)
8112ba30:	dc800217 	ldw	r18,8(sp)
8112ba34:	dc400117 	ldw	r17,4(sp)
8112ba38:	dc000017 	ldw	r16,0(sp)
8112ba3c:	dec00604 	addi	sp,sp,24
8112ba40:	f800283a 	ret
8112ba44:	04410004 	movi	r17,1024
8112ba48:	880b883a 	mov	r5,r17
8112ba4c:	111c3380 	call	8111c338 <_malloc_r>
8112ba50:	1007883a 	mov	r3,r2
8112ba54:	10000c26 	beq	r2,zero,8112ba88 <__submore+0xd4>
8112ba58:	80801083 	ldbu	r2,66(r16)
8112ba5c:	80c00c15 	stw	r3,48(r16)
8112ba60:	84400d15 	stw	r17,52(r16)
8112ba64:	1880ffc5 	stb	r2,1023(r3)
8112ba68:	81401043 	ldbu	r5,65(r16)
8112ba6c:	1900ff44 	addi	r4,r3,1021
8112ba70:	0005883a 	mov	r2,zero
8112ba74:	1940ff85 	stb	r5,1022(r3)
8112ba78:	81401003 	ldbu	r5,64(r16)
8112ba7c:	1940ff45 	stb	r5,1021(r3)
8112ba80:	81000015 	stw	r4,0(r16)
8112ba84:	003fe706 	br	8112ba24 <__reset+0xfb10ba24>
8112ba88:	00bfffc4 	movi	r2,-1
8112ba8c:	003fe506 	br	8112ba24 <__reset+0xfb10ba24>

8112ba90 <_ungetc_r>:
8112ba90:	00bfffc4 	movi	r2,-1
8112ba94:	28806326 	beq	r5,r2,8112bc24 <_ungetc_r+0x194>
8112ba98:	defffb04 	addi	sp,sp,-20
8112ba9c:	de00012e 	bgeu	sp,et,8112baa4 <_ungetc_r+0x14>
8112baa0:	003b68fa 	trap	3
8112baa4:	dcc00315 	stw	r19,12(sp)
8112baa8:	dc400115 	stw	r17,4(sp)
8112baac:	dc000015 	stw	r16,0(sp)
8112bab0:	dfc00415 	stw	ra,16(sp)
8112bab4:	dc800215 	stw	r18,8(sp)
8112bab8:	2023883a 	mov	r17,r4
8112babc:	3021883a 	mov	r16,r6
8112bac0:	2827883a 	mov	r19,r5
8112bac4:	20000226 	beq	r4,zero,8112bad0 <_ungetc_r+0x40>
8112bac8:	20800e17 	ldw	r2,56(r4)
8112bacc:	10002e26 	beq	r2,zero,8112bb88 <_ungetc_r+0xf8>
8112bad0:	80c0030b 	ldhu	r3,12(r16)
8112bad4:	1888000c 	andi	r2,r3,8192
8112bad8:	1000051e 	bne	r2,zero,8112baf0 <_ungetc_r+0x60>
8112badc:	81001917 	ldw	r4,100(r16)
8112bae0:	00b7ffc4 	movi	r2,-8193
8112bae4:	18c80014 	ori	r3,r3,8192
8112bae8:	2084703a 	and	r2,r4,r2
8112baec:	80801915 	stw	r2,100(r16)
8112baf0:	00bff7c4 	movi	r2,-33
8112baf4:	1884703a 	and	r2,r3,r2
8112baf8:	8080030d 	sth	r2,12(r16)
8112bafc:	1900010c 	andi	r4,r3,4
8112bb00:	2000061e 	bne	r4,zero,8112bb1c <_ungetc_r+0x8c>
8112bb04:	1900040c 	andi	r4,r3,16
8112bb08:	20001d26 	beq	r4,zero,8112bb80 <_ungetc_r+0xf0>
8112bb0c:	18c0020c 	andi	r3,r3,8
8112bb10:	1800331e 	bne	r3,zero,8112bbe0 <_ungetc_r+0x150>
8112bb14:	10800114 	ori	r2,r2,4
8112bb18:	8080030d 	sth	r2,12(r16)
8112bb1c:	80800c17 	ldw	r2,48(r16)
8112bb20:	9c803fcc 	andi	r18,r19,255
8112bb24:	10001a26 	beq	r2,zero,8112bb90 <_ungetc_r+0x100>
8112bb28:	80c00117 	ldw	r3,4(r16)
8112bb2c:	80800d17 	ldw	r2,52(r16)
8112bb30:	18800f0e 	bge	r3,r2,8112bb70 <_ungetc_r+0xe0>
8112bb34:	80c00017 	ldw	r3,0(r16)
8112bb38:	9005883a 	mov	r2,r18
8112bb3c:	193fffc4 	addi	r4,r3,-1
8112bb40:	81000015 	stw	r4,0(r16)
8112bb44:	1cffffc5 	stb	r19,-1(r3)
8112bb48:	80c00117 	ldw	r3,4(r16)
8112bb4c:	18c00044 	addi	r3,r3,1
8112bb50:	80c00115 	stw	r3,4(r16)
8112bb54:	dfc00417 	ldw	ra,16(sp)
8112bb58:	dcc00317 	ldw	r19,12(sp)
8112bb5c:	dc800217 	ldw	r18,8(sp)
8112bb60:	dc400117 	ldw	r17,4(sp)
8112bb64:	dc000017 	ldw	r16,0(sp)
8112bb68:	dec00504 	addi	sp,sp,20
8112bb6c:	f800283a 	ret
8112bb70:	800b883a 	mov	r5,r16
8112bb74:	8809883a 	mov	r4,r17
8112bb78:	112b9b40 	call	8112b9b4 <__submore>
8112bb7c:	103fed26 	beq	r2,zero,8112bb34 <__reset+0xfb10bb34>
8112bb80:	00bfffc4 	movi	r2,-1
8112bb84:	003ff306 	br	8112bb54 <__reset+0xfb10bb54>
8112bb88:	11259140 	call	81125914 <__sinit>
8112bb8c:	003fd006 	br	8112bad0 <__reset+0xfb10bad0>
8112bb90:	80c00417 	ldw	r3,16(r16)
8112bb94:	80800017 	ldw	r2,0(r16)
8112bb98:	18000326 	beq	r3,zero,8112bba8 <_ungetc_r+0x118>
8112bb9c:	1880022e 	bgeu	r3,r2,8112bba8 <_ungetc_r+0x118>
8112bba0:	10ffffc3 	ldbu	r3,-1(r2)
8112bba4:	90c01826 	beq	r18,r3,8112bc08 <_ungetc_r+0x178>
8112bba8:	81400117 	ldw	r5,4(r16)
8112bbac:	80800e15 	stw	r2,56(r16)
8112bbb0:	008000c4 	movi	r2,3
8112bbb4:	81001004 	addi	r4,r16,64
8112bbb8:	80c01084 	addi	r3,r16,66
8112bbbc:	80800d15 	stw	r2,52(r16)
8112bbc0:	00800044 	movi	r2,1
8112bbc4:	80800115 	stw	r2,4(r16)
8112bbc8:	81400f15 	stw	r5,60(r16)
8112bbcc:	81000c15 	stw	r4,48(r16)
8112bbd0:	84c01085 	stb	r19,66(r16)
8112bbd4:	80c00015 	stw	r3,0(r16)
8112bbd8:	9005883a 	mov	r2,r18
8112bbdc:	003fdd06 	br	8112bb54 <__reset+0xfb10bb54>
8112bbe0:	800b883a 	mov	r5,r16
8112bbe4:	8809883a 	mov	r4,r17
8112bbe8:	11255180 	call	81125518 <_fflush_r>
8112bbec:	103fe41e 	bne	r2,zero,8112bb80 <__reset+0xfb10bb80>
8112bbf0:	8080030b 	ldhu	r2,12(r16)
8112bbf4:	00fffdc4 	movi	r3,-9
8112bbf8:	80000215 	stw	zero,8(r16)
8112bbfc:	1884703a 	and	r2,r3,r2
8112bc00:	80000615 	stw	zero,24(r16)
8112bc04:	003fc306 	br	8112bb14 <__reset+0xfb10bb14>
8112bc08:	80c00117 	ldw	r3,4(r16)
8112bc0c:	10bfffc4 	addi	r2,r2,-1
8112bc10:	80800015 	stw	r2,0(r16)
8112bc14:	18800044 	addi	r2,r3,1
8112bc18:	80800115 	stw	r2,4(r16)
8112bc1c:	9005883a 	mov	r2,r18
8112bc20:	003fcc06 	br	8112bb54 <__reset+0xfb10bb54>
8112bc24:	00bfffc4 	movi	r2,-1
8112bc28:	f800283a 	ret

8112bc2c <ungetc>:
8112bc2c:	00a04574 	movhi	r2,33045
8112bc30:	10b52904 	addi	r2,r2,-11100
8112bc34:	280d883a 	mov	r6,r5
8112bc38:	200b883a 	mov	r5,r4
8112bc3c:	11000017 	ldw	r4,0(r2)
8112bc40:	112ba901 	jmpi	8112ba90 <_ungetc_r>

8112bc44 <__sprint_r.part.0>:
8112bc44:	defff604 	addi	sp,sp,-40
8112bc48:	de00012e 	bgeu	sp,et,8112bc50 <__sprint_r.part.0+0xc>
8112bc4c:	003b68fa 	trap	3
8112bc50:	28801917 	ldw	r2,100(r5)
8112bc54:	dd400515 	stw	r21,20(sp)
8112bc58:	dfc00915 	stw	ra,36(sp)
8112bc5c:	df000815 	stw	fp,32(sp)
8112bc60:	ddc00715 	stw	r23,28(sp)
8112bc64:	dd800615 	stw	r22,24(sp)
8112bc68:	dd000415 	stw	r20,16(sp)
8112bc6c:	dcc00315 	stw	r19,12(sp)
8112bc70:	dc800215 	stw	r18,8(sp)
8112bc74:	dc400115 	stw	r17,4(sp)
8112bc78:	dc000015 	stw	r16,0(sp)
8112bc7c:	1088000c 	andi	r2,r2,8192
8112bc80:	302b883a 	mov	r21,r6
8112bc84:	10002e26 	beq	r2,zero,8112bd40 <__sprint_r.part.0+0xfc>
8112bc88:	30800217 	ldw	r2,8(r6)
8112bc8c:	35800017 	ldw	r22,0(r6)
8112bc90:	10002926 	beq	r2,zero,8112bd38 <__sprint_r.part.0+0xf4>
8112bc94:	2827883a 	mov	r19,r5
8112bc98:	2029883a 	mov	r20,r4
8112bc9c:	b5c00104 	addi	r23,r22,4
8112bca0:	04bfffc4 	movi	r18,-1
8112bca4:	bc400017 	ldw	r17,0(r23)
8112bca8:	b4000017 	ldw	r16,0(r22)
8112bcac:	0039883a 	mov	fp,zero
8112bcb0:	8822d0ba 	srli	r17,r17,2
8112bcb4:	8800031e 	bne	r17,zero,8112bcc4 <__sprint_r.part.0+0x80>
8112bcb8:	00001806 	br	8112bd1c <__sprint_r.part.0+0xd8>
8112bcbc:	84000104 	addi	r16,r16,4
8112bcc0:	8f001526 	beq	r17,fp,8112bd18 <__sprint_r.part.0+0xd4>
8112bcc4:	81400017 	ldw	r5,0(r16)
8112bcc8:	980d883a 	mov	r6,r19
8112bccc:	a009883a 	mov	r4,r20
8112bcd0:	112d5e80 	call	8112d5e8 <_fputwc_r>
8112bcd4:	e7000044 	addi	fp,fp,1
8112bcd8:	14bff81e 	bne	r2,r18,8112bcbc <__reset+0xfb10bcbc>
8112bcdc:	9005883a 	mov	r2,r18
8112bce0:	a8000215 	stw	zero,8(r21)
8112bce4:	a8000115 	stw	zero,4(r21)
8112bce8:	dfc00917 	ldw	ra,36(sp)
8112bcec:	df000817 	ldw	fp,32(sp)
8112bcf0:	ddc00717 	ldw	r23,28(sp)
8112bcf4:	dd800617 	ldw	r22,24(sp)
8112bcf8:	dd400517 	ldw	r21,20(sp)
8112bcfc:	dd000417 	ldw	r20,16(sp)
8112bd00:	dcc00317 	ldw	r19,12(sp)
8112bd04:	dc800217 	ldw	r18,8(sp)
8112bd08:	dc400117 	ldw	r17,4(sp)
8112bd0c:	dc000017 	ldw	r16,0(sp)
8112bd10:	dec00a04 	addi	sp,sp,40
8112bd14:	f800283a 	ret
8112bd18:	a8800217 	ldw	r2,8(r21)
8112bd1c:	8c63883a 	add	r17,r17,r17
8112bd20:	8c63883a 	add	r17,r17,r17
8112bd24:	1445c83a 	sub	r2,r2,r17
8112bd28:	a8800215 	stw	r2,8(r21)
8112bd2c:	b5800204 	addi	r22,r22,8
8112bd30:	bdc00204 	addi	r23,r23,8
8112bd34:	103fdb1e 	bne	r2,zero,8112bca4 <__reset+0xfb10bca4>
8112bd38:	0005883a 	mov	r2,zero
8112bd3c:	003fe806 	br	8112bce0 <__reset+0xfb10bce0>
8112bd40:	11260c40 	call	811260c4 <__sfvwrite_r>
8112bd44:	003fe606 	br	8112bce0 <__reset+0xfb10bce0>

8112bd48 <__sprint_r>:
8112bd48:	30c00217 	ldw	r3,8(r6)
8112bd4c:	18000126 	beq	r3,zero,8112bd54 <__sprint_r+0xc>
8112bd50:	112bc441 	jmpi	8112bc44 <__sprint_r.part.0>
8112bd54:	30000115 	stw	zero,4(r6)
8112bd58:	0005883a 	mov	r2,zero
8112bd5c:	f800283a 	ret

8112bd60 <___vfiprintf_internal_r>:
8112bd60:	deffc904 	addi	sp,sp,-220
8112bd64:	de00012e 	bgeu	sp,et,8112bd6c <___vfiprintf_internal_r+0xc>
8112bd68:	003b68fa 	trap	3
8112bd6c:	df003515 	stw	fp,212(sp)
8112bd70:	dd003115 	stw	r20,196(sp)
8112bd74:	dfc03615 	stw	ra,216(sp)
8112bd78:	ddc03415 	stw	r23,208(sp)
8112bd7c:	dd803315 	stw	r22,204(sp)
8112bd80:	dd403215 	stw	r21,200(sp)
8112bd84:	dcc03015 	stw	r19,192(sp)
8112bd88:	dc802f15 	stw	r18,188(sp)
8112bd8c:	dc402e15 	stw	r17,184(sp)
8112bd90:	dc002d15 	stw	r16,180(sp)
8112bd94:	d9002015 	stw	r4,128(sp)
8112bd98:	d9c02215 	stw	r7,136(sp)
8112bd9c:	2829883a 	mov	r20,r5
8112bda0:	3039883a 	mov	fp,r6
8112bda4:	20000226 	beq	r4,zero,8112bdb0 <___vfiprintf_internal_r+0x50>
8112bda8:	20800e17 	ldw	r2,56(r4)
8112bdac:	1000cf26 	beq	r2,zero,8112c0ec <___vfiprintf_internal_r+0x38c>
8112bdb0:	a080030b 	ldhu	r2,12(r20)
8112bdb4:	10c8000c 	andi	r3,r2,8192
8112bdb8:	1800061e 	bne	r3,zero,8112bdd4 <___vfiprintf_internal_r+0x74>
8112bdbc:	a1001917 	ldw	r4,100(r20)
8112bdc0:	00f7ffc4 	movi	r3,-8193
8112bdc4:	10880014 	ori	r2,r2,8192
8112bdc8:	20c6703a 	and	r3,r4,r3
8112bdcc:	a080030d 	sth	r2,12(r20)
8112bdd0:	a0c01915 	stw	r3,100(r20)
8112bdd4:	10c0020c 	andi	r3,r2,8
8112bdd8:	1800a926 	beq	r3,zero,8112c080 <___vfiprintf_internal_r+0x320>
8112bddc:	a0c00417 	ldw	r3,16(r20)
8112bde0:	1800a726 	beq	r3,zero,8112c080 <___vfiprintf_internal_r+0x320>
8112bde4:	1080068c 	andi	r2,r2,26
8112bde8:	00c00284 	movi	r3,10
8112bdec:	10c0ac26 	beq	r2,r3,8112c0a0 <___vfiprintf_internal_r+0x340>
8112bdf0:	da801a04 	addi	r10,sp,104
8112bdf4:	da801e15 	stw	r10,120(sp)
8112bdf8:	d8801e17 	ldw	r2,120(sp)
8112bdfc:	da8019c4 	addi	r10,sp,103
8112be00:	05a04574 	movhi	r22,33045
8112be04:	05e04574 	movhi	r23,33045
8112be08:	da801f15 	stw	r10,124(sp)
8112be0c:	1295c83a 	sub	r10,r2,r10
8112be10:	b5abf004 	addi	r22,r22,-20544
8112be14:	bdebec04 	addi	r23,r23,-20560
8112be18:	dec01a15 	stw	sp,104(sp)
8112be1c:	d8001c15 	stw	zero,112(sp)
8112be20:	d8001b15 	stw	zero,108(sp)
8112be24:	d8002615 	stw	zero,152(sp)
8112be28:	d8002315 	stw	zero,140(sp)
8112be2c:	da802715 	stw	r10,156(sp)
8112be30:	d811883a 	mov	r8,sp
8112be34:	dd002115 	stw	r20,132(sp)
8112be38:	e021883a 	mov	r16,fp
8112be3c:	80800007 	ldb	r2,0(r16)
8112be40:	1003ea26 	beq	r2,zero,8112cdec <___vfiprintf_internal_r+0x108c>
8112be44:	00c00944 	movi	r3,37
8112be48:	8025883a 	mov	r18,r16
8112be4c:	10c0021e 	bne	r2,r3,8112be58 <___vfiprintf_internal_r+0xf8>
8112be50:	00001606 	br	8112beac <___vfiprintf_internal_r+0x14c>
8112be54:	10c00326 	beq	r2,r3,8112be64 <___vfiprintf_internal_r+0x104>
8112be58:	94800044 	addi	r18,r18,1
8112be5c:	90800007 	ldb	r2,0(r18)
8112be60:	103ffc1e 	bne	r2,zero,8112be54 <__reset+0xfb10be54>
8112be64:	9423c83a 	sub	r17,r18,r16
8112be68:	88001026 	beq	r17,zero,8112beac <___vfiprintf_internal_r+0x14c>
8112be6c:	d8c01c17 	ldw	r3,112(sp)
8112be70:	d8801b17 	ldw	r2,108(sp)
8112be74:	44000015 	stw	r16,0(r8)
8112be78:	88c7883a 	add	r3,r17,r3
8112be7c:	10800044 	addi	r2,r2,1
8112be80:	44400115 	stw	r17,4(r8)
8112be84:	d8c01c15 	stw	r3,112(sp)
8112be88:	d8801b15 	stw	r2,108(sp)
8112be8c:	010001c4 	movi	r4,7
8112be90:	2080760e 	bge	r4,r2,8112c06c <___vfiprintf_internal_r+0x30c>
8112be94:	1803821e 	bne	r3,zero,8112cca0 <___vfiprintf_internal_r+0xf40>
8112be98:	da802317 	ldw	r10,140(sp)
8112be9c:	d8001b15 	stw	zero,108(sp)
8112bea0:	d811883a 	mov	r8,sp
8112bea4:	5455883a 	add	r10,r10,r17
8112bea8:	da802315 	stw	r10,140(sp)
8112beac:	90800007 	ldb	r2,0(r18)
8112beb0:	10044626 	beq	r2,zero,8112cfcc <___vfiprintf_internal_r+0x126c>
8112beb4:	90c00047 	ldb	r3,1(r18)
8112beb8:	94000044 	addi	r16,r18,1
8112bebc:	d8001d85 	stb	zero,118(sp)
8112bec0:	0009883a 	mov	r4,zero
8112bec4:	000f883a 	mov	r7,zero
8112bec8:	027fffc4 	movi	r9,-1
8112becc:	0023883a 	mov	r17,zero
8112bed0:	0029883a 	mov	r20,zero
8112bed4:	01401604 	movi	r5,88
8112bed8:	01800244 	movi	r6,9
8112bedc:	03400a84 	movi	r13,42
8112bee0:	03001b04 	movi	r12,108
8112bee4:	84000044 	addi	r16,r16,1
8112bee8:	18bff804 	addi	r2,r3,-32
8112beec:	28827336 	bltu	r5,r2,8112c8bc <___vfiprintf_internal_r+0xb5c>
8112bef0:	100490ba 	slli	r2,r2,2
8112bef4:	02a044f4 	movhi	r10,33043
8112bef8:	52afc204 	addi	r10,r10,-16632
8112befc:	1285883a 	add	r2,r2,r10
8112bf00:	10800017 	ldw	r2,0(r2)
8112bf04:	1000683a 	jmp	r2
8112bf08:	8112c5f0 	cmpltui	r4,r16,19223
8112bf0c:	8112c8bc 	xorhi	r4,r16,19234
8112bf10:	8112c8bc 	xorhi	r4,r16,19234
8112bf14:	8112c610 	cmplti	r4,r16,19224
8112bf18:	8112c8bc 	xorhi	r4,r16,19234
8112bf1c:	8112c8bc 	xorhi	r4,r16,19234
8112bf20:	8112c8bc 	xorhi	r4,r16,19234
8112bf24:	8112c8bc 	xorhi	r4,r16,19234
8112bf28:	8112c8bc 	xorhi	r4,r16,19234
8112bf2c:	8112c8bc 	xorhi	r4,r16,19234
8112bf30:	8112c7f8 	rdprs	r4,r16,19231
8112bf34:	8112c814 	ori	r4,r16,19232
8112bf38:	8112c8bc 	xorhi	r4,r16,19234
8112bf3c:	8112c0fc 	xorhi	r4,r16,19203
8112bf40:	8112c824 	muli	r4,r16,19232
8112bf44:	8112c8bc 	xorhi	r4,r16,19234
8112bf48:	8112c61c 	xori	r4,r16,19224
8112bf4c:	8112c628 	cmpgeui	r4,r16,19224
8112bf50:	8112c628 	cmpgeui	r4,r16,19224
8112bf54:	8112c628 	cmpgeui	r4,r16,19224
8112bf58:	8112c628 	cmpgeui	r4,r16,19224
8112bf5c:	8112c628 	cmpgeui	r4,r16,19224
8112bf60:	8112c628 	cmpgeui	r4,r16,19224
8112bf64:	8112c628 	cmpgeui	r4,r16,19224
8112bf68:	8112c628 	cmpgeui	r4,r16,19224
8112bf6c:	8112c628 	cmpgeui	r4,r16,19224
8112bf70:	8112c8bc 	xorhi	r4,r16,19234
8112bf74:	8112c8bc 	xorhi	r4,r16,19234
8112bf78:	8112c8bc 	xorhi	r4,r16,19234
8112bf7c:	8112c8bc 	xorhi	r4,r16,19234
8112bf80:	8112c8bc 	xorhi	r4,r16,19234
8112bf84:	8112c8bc 	xorhi	r4,r16,19234
8112bf88:	8112c8bc 	xorhi	r4,r16,19234
8112bf8c:	8112c8bc 	xorhi	r4,r16,19234
8112bf90:	8112c8bc 	xorhi	r4,r16,19234
8112bf94:	8112c8bc 	xorhi	r4,r16,19234
8112bf98:	8112c654 	ori	r4,r16,19225
8112bf9c:	8112c8bc 	xorhi	r4,r16,19234
8112bfa0:	8112c8bc 	xorhi	r4,r16,19234
8112bfa4:	8112c8bc 	xorhi	r4,r16,19234
8112bfa8:	8112c8bc 	xorhi	r4,r16,19234
8112bfac:	8112c8bc 	xorhi	r4,r16,19234
8112bfb0:	8112c8bc 	xorhi	r4,r16,19234
8112bfb4:	8112c8bc 	xorhi	r4,r16,19234
8112bfb8:	8112c8bc 	xorhi	r4,r16,19234
8112bfbc:	8112c8bc 	xorhi	r4,r16,19234
8112bfc0:	8112c8bc 	xorhi	r4,r16,19234
8112bfc4:	8112c68c 	andi	r4,r16,19226
8112bfc8:	8112c8bc 	xorhi	r4,r16,19234
8112bfcc:	8112c8bc 	xorhi	r4,r16,19234
8112bfd0:	8112c8bc 	xorhi	r4,r16,19234
8112bfd4:	8112c8bc 	xorhi	r4,r16,19234
8112bfd8:	8112c8bc 	xorhi	r4,r16,19234
8112bfdc:	8112c6e4 	muli	r4,r16,19227
8112bfe0:	8112c8bc 	xorhi	r4,r16,19234
8112bfe4:	8112c8bc 	xorhi	r4,r16,19234
8112bfe8:	8112c754 	ori	r4,r16,19229
8112bfec:	8112c8bc 	xorhi	r4,r16,19234
8112bff0:	8112c8bc 	xorhi	r4,r16,19234
8112bff4:	8112c8bc 	xorhi	r4,r16,19234
8112bff8:	8112c8bc 	xorhi	r4,r16,19234
8112bffc:	8112c8bc 	xorhi	r4,r16,19234
8112c000:	8112c8bc 	xorhi	r4,r16,19234
8112c004:	8112c8bc 	xorhi	r4,r16,19234
8112c008:	8112c8bc 	xorhi	r4,r16,19234
8112c00c:	8112c8bc 	xorhi	r4,r16,19234
8112c010:	8112c8bc 	xorhi	r4,r16,19234
8112c014:	8112c500 	call	88112c50 <__reset+0x20f2c50>
8112c018:	8112c52c 	andhi	r4,r16,19220
8112c01c:	8112c8bc 	xorhi	r4,r16,19234
8112c020:	8112c8bc 	xorhi	r4,r16,19234
8112c024:	8112c8bc 	xorhi	r4,r16,19234
8112c028:	8112c864 	muli	r4,r16,19233
8112c02c:	8112c52c 	andhi	r4,r16,19220
8112c030:	8112c8bc 	xorhi	r4,r16,19234
8112c034:	8112c8bc 	xorhi	r4,r16,19234
8112c038:	8112c3c0 	call	88112c3c <__reset+0x20f2c3c>
8112c03c:	8112c8bc 	xorhi	r4,r16,19234
8112c040:	8112c3d0 	cmplti	r4,r16,19215
8112c044:	8112c40c 	andi	r4,r16,19216
8112c048:	8112c108 	cmpgei	r4,r16,19204
8112c04c:	8112c3b4 	orhi	r4,r16,19214
8112c050:	8112c8bc 	xorhi	r4,r16,19234
8112c054:	8112c790 	cmplti	r4,r16,19230
8112c058:	8112c8bc 	xorhi	r4,r16,19234
8112c05c:	8112c7e8 	cmpgeui	r4,r16,19231
8112c060:	8112c8bc 	xorhi	r4,r16,19234
8112c064:	8112c8bc 	xorhi	r4,r16,19234
8112c068:	8112c4ac 	andhi	r4,r16,19218
8112c06c:	42000204 	addi	r8,r8,8
8112c070:	da802317 	ldw	r10,140(sp)
8112c074:	5455883a 	add	r10,r10,r17
8112c078:	da802315 	stw	r10,140(sp)
8112c07c:	003f8b06 	br	8112beac <__reset+0xfb10beac>
8112c080:	d9002017 	ldw	r4,128(sp)
8112c084:	a00b883a 	mov	r5,r20
8112c088:	11238a40 	call	811238a4 <__swsetup_r>
8112c08c:	1003b11e 	bne	r2,zero,8112cf54 <___vfiprintf_internal_r+0x11f4>
8112c090:	a080030b 	ldhu	r2,12(r20)
8112c094:	00c00284 	movi	r3,10
8112c098:	1080068c 	andi	r2,r2,26
8112c09c:	10ff541e 	bne	r2,r3,8112bdf0 <__reset+0xfb10bdf0>
8112c0a0:	a080038f 	ldh	r2,14(r20)
8112c0a4:	103f5216 	blt	r2,zero,8112bdf0 <__reset+0xfb10bdf0>
8112c0a8:	d9c02217 	ldw	r7,136(sp)
8112c0ac:	d9002017 	ldw	r4,128(sp)
8112c0b0:	e00d883a 	mov	r6,fp
8112c0b4:	a00b883a 	mov	r5,r20
8112c0b8:	112d1e00 	call	8112d1e0 <__sbprintf>
8112c0bc:	dfc03617 	ldw	ra,216(sp)
8112c0c0:	df003517 	ldw	fp,212(sp)
8112c0c4:	ddc03417 	ldw	r23,208(sp)
8112c0c8:	dd803317 	ldw	r22,204(sp)
8112c0cc:	dd403217 	ldw	r21,200(sp)
8112c0d0:	dd003117 	ldw	r20,196(sp)
8112c0d4:	dcc03017 	ldw	r19,192(sp)
8112c0d8:	dc802f17 	ldw	r18,188(sp)
8112c0dc:	dc402e17 	ldw	r17,184(sp)
8112c0e0:	dc002d17 	ldw	r16,180(sp)
8112c0e4:	dec03704 	addi	sp,sp,220
8112c0e8:	f800283a 	ret
8112c0ec:	11259140 	call	81125914 <__sinit>
8112c0f0:	003f2f06 	br	8112bdb0 <__reset+0xfb10bdb0>
8112c0f4:	0463c83a 	sub	r17,zero,r17
8112c0f8:	d8802215 	stw	r2,136(sp)
8112c0fc:	a5000114 	ori	r20,r20,4
8112c100:	80c00007 	ldb	r3,0(r16)
8112c104:	003f7706 	br	8112bee4 <__reset+0xfb10bee4>
8112c108:	00800c04 	movi	r2,48
8112c10c:	da802217 	ldw	r10,136(sp)
8112c110:	d8801d05 	stb	r2,116(sp)
8112c114:	00801e04 	movi	r2,120
8112c118:	d8801d45 	stb	r2,117(sp)
8112c11c:	d8001d85 	stb	zero,118(sp)
8112c120:	50c00104 	addi	r3,r10,4
8112c124:	54800017 	ldw	r18,0(r10)
8112c128:	0027883a 	mov	r19,zero
8112c12c:	a0800094 	ori	r2,r20,2
8112c130:	48030b16 	blt	r9,zero,8112cd60 <___vfiprintf_internal_r+0x1000>
8112c134:	00bfdfc4 	movi	r2,-129
8112c138:	a096703a 	and	r11,r20,r2
8112c13c:	d8c02215 	stw	r3,136(sp)
8112c140:	5d000094 	ori	r20,r11,2
8112c144:	90032b1e 	bne	r18,zero,8112cdf4 <___vfiprintf_internal_r+0x1094>
8112c148:	00a04574 	movhi	r2,33045
8112c14c:	10ab5a04 	addi	r2,r2,-21144
8112c150:	d8802615 	stw	r2,152(sp)
8112c154:	0039883a 	mov	fp,zero
8112c158:	48017b1e 	bne	r9,zero,8112c748 <___vfiprintf_internal_r+0x9e8>
8112c15c:	0013883a 	mov	r9,zero
8112c160:	0027883a 	mov	r19,zero
8112c164:	dd401a04 	addi	r21,sp,104
8112c168:	4825883a 	mov	r18,r9
8112c16c:	4cc0010e 	bge	r9,r19,8112c174 <___vfiprintf_internal_r+0x414>
8112c170:	9825883a 	mov	r18,r19
8112c174:	e7003fcc 	andi	fp,fp,255
8112c178:	e700201c 	xori	fp,fp,128
8112c17c:	e73fe004 	addi	fp,fp,-128
8112c180:	e0000126 	beq	fp,zero,8112c188 <___vfiprintf_internal_r+0x428>
8112c184:	94800044 	addi	r18,r18,1
8112c188:	a380008c 	andi	r14,r20,2
8112c18c:	70000126 	beq	r14,zero,8112c194 <___vfiprintf_internal_r+0x434>
8112c190:	94800084 	addi	r18,r18,2
8112c194:	a700210c 	andi	fp,r20,132
8112c198:	e001df1e 	bne	fp,zero,8112c918 <___vfiprintf_internal_r+0xbb8>
8112c19c:	8c87c83a 	sub	r3,r17,r18
8112c1a0:	00c1dd0e 	bge	zero,r3,8112c918 <___vfiprintf_internal_r+0xbb8>
8112c1a4:	01c00404 	movi	r7,16
8112c1a8:	d8801c17 	ldw	r2,112(sp)
8112c1ac:	38c3ad0e 	bge	r7,r3,8112d064 <___vfiprintf_internal_r+0x1304>
8112c1b0:	02a04574 	movhi	r10,33045
8112c1b4:	52abf004 	addi	r10,r10,-20544
8112c1b8:	dc002915 	stw	r16,164(sp)
8112c1bc:	d9801b17 	ldw	r6,108(sp)
8112c1c0:	da802415 	stw	r10,144(sp)
8112c1c4:	03c001c4 	movi	r15,7
8112c1c8:	da402515 	stw	r9,148(sp)
8112c1cc:	db802815 	stw	r14,160(sp)
8112c1d0:	1821883a 	mov	r16,r3
8112c1d4:	00000506 	br	8112c1ec <___vfiprintf_internal_r+0x48c>
8112c1d8:	31400084 	addi	r5,r6,2
8112c1dc:	42000204 	addi	r8,r8,8
8112c1e0:	200d883a 	mov	r6,r4
8112c1e4:	843ffc04 	addi	r16,r16,-16
8112c1e8:	3c000d0e 	bge	r7,r16,8112c220 <___vfiprintf_internal_r+0x4c0>
8112c1ec:	10800404 	addi	r2,r2,16
8112c1f0:	31000044 	addi	r4,r6,1
8112c1f4:	45800015 	stw	r22,0(r8)
8112c1f8:	41c00115 	stw	r7,4(r8)
8112c1fc:	d8801c15 	stw	r2,112(sp)
8112c200:	d9001b15 	stw	r4,108(sp)
8112c204:	793ff40e 	bge	r15,r4,8112c1d8 <__reset+0xfb10c1d8>
8112c208:	1001b51e 	bne	r2,zero,8112c8e0 <___vfiprintf_internal_r+0xb80>
8112c20c:	843ffc04 	addi	r16,r16,-16
8112c210:	000d883a 	mov	r6,zero
8112c214:	01400044 	movi	r5,1
8112c218:	d811883a 	mov	r8,sp
8112c21c:	3c3ff316 	blt	r7,r16,8112c1ec <__reset+0xfb10c1ec>
8112c220:	8007883a 	mov	r3,r16
8112c224:	da402517 	ldw	r9,148(sp)
8112c228:	db802817 	ldw	r14,160(sp)
8112c22c:	dc002917 	ldw	r16,164(sp)
8112c230:	da802417 	ldw	r10,144(sp)
8112c234:	1885883a 	add	r2,r3,r2
8112c238:	40c00115 	stw	r3,4(r8)
8112c23c:	42800015 	stw	r10,0(r8)
8112c240:	d8801c15 	stw	r2,112(sp)
8112c244:	d9401b15 	stw	r5,108(sp)
8112c248:	00c001c4 	movi	r3,7
8112c24c:	19426016 	blt	r3,r5,8112cbd0 <___vfiprintf_internal_r+0xe70>
8112c250:	d8c01d87 	ldb	r3,118(sp)
8112c254:	42000204 	addi	r8,r8,8
8112c258:	29000044 	addi	r4,r5,1
8112c25c:	1801b31e 	bne	r3,zero,8112c92c <___vfiprintf_internal_r+0xbcc>
8112c260:	7001c026 	beq	r14,zero,8112c964 <___vfiprintf_internal_r+0xc04>
8112c264:	d8c01d04 	addi	r3,sp,116
8112c268:	10800084 	addi	r2,r2,2
8112c26c:	40c00015 	stw	r3,0(r8)
8112c270:	00c00084 	movi	r3,2
8112c274:	40c00115 	stw	r3,4(r8)
8112c278:	d8801c15 	stw	r2,112(sp)
8112c27c:	d9001b15 	stw	r4,108(sp)
8112c280:	00c001c4 	movi	r3,7
8112c284:	1902650e 	bge	r3,r4,8112cc1c <___vfiprintf_internal_r+0xebc>
8112c288:	10029a1e 	bne	r2,zero,8112ccf4 <___vfiprintf_internal_r+0xf94>
8112c28c:	00c02004 	movi	r3,128
8112c290:	01000044 	movi	r4,1
8112c294:	000b883a 	mov	r5,zero
8112c298:	d811883a 	mov	r8,sp
8112c29c:	e0c1b31e 	bne	fp,r3,8112c96c <___vfiprintf_internal_r+0xc0c>
8112c2a0:	8cb9c83a 	sub	fp,r17,r18
8112c2a4:	0701b10e 	bge	zero,fp,8112c96c <___vfiprintf_internal_r+0xc0c>
8112c2a8:	01c00404 	movi	r7,16
8112c2ac:	3f03890e 	bge	r7,fp,8112d0d4 <___vfiprintf_internal_r+0x1374>
8112c2b0:	00e04574 	movhi	r3,33045
8112c2b4:	18ebec04 	addi	r3,r3,-20560
8112c2b8:	d8c02415 	stw	r3,144(sp)
8112c2bc:	8007883a 	mov	r3,r16
8112c2c0:	034001c4 	movi	r13,7
8112c2c4:	e021883a 	mov	r16,fp
8112c2c8:	da402515 	stw	r9,148(sp)
8112c2cc:	1839883a 	mov	fp,r3
8112c2d0:	00000506 	br	8112c2e8 <___vfiprintf_internal_r+0x588>
8112c2d4:	29800084 	addi	r6,r5,2
8112c2d8:	42000204 	addi	r8,r8,8
8112c2dc:	180b883a 	mov	r5,r3
8112c2e0:	843ffc04 	addi	r16,r16,-16
8112c2e4:	3c000d0e 	bge	r7,r16,8112c31c <___vfiprintf_internal_r+0x5bc>
8112c2e8:	10800404 	addi	r2,r2,16
8112c2ec:	28c00044 	addi	r3,r5,1
8112c2f0:	45c00015 	stw	r23,0(r8)
8112c2f4:	41c00115 	stw	r7,4(r8)
8112c2f8:	d8801c15 	stw	r2,112(sp)
8112c2fc:	d8c01b15 	stw	r3,108(sp)
8112c300:	68fff40e 	bge	r13,r3,8112c2d4 <__reset+0xfb10c2d4>
8112c304:	1002241e 	bne	r2,zero,8112cb98 <___vfiprintf_internal_r+0xe38>
8112c308:	843ffc04 	addi	r16,r16,-16
8112c30c:	01800044 	movi	r6,1
8112c310:	000b883a 	mov	r5,zero
8112c314:	d811883a 	mov	r8,sp
8112c318:	3c3ff316 	blt	r7,r16,8112c2e8 <__reset+0xfb10c2e8>
8112c31c:	da402517 	ldw	r9,148(sp)
8112c320:	e007883a 	mov	r3,fp
8112c324:	8039883a 	mov	fp,r16
8112c328:	1821883a 	mov	r16,r3
8112c32c:	d8c02417 	ldw	r3,144(sp)
8112c330:	1705883a 	add	r2,r2,fp
8112c334:	47000115 	stw	fp,4(r8)
8112c338:	40c00015 	stw	r3,0(r8)
8112c33c:	d8801c15 	stw	r2,112(sp)
8112c340:	d9801b15 	stw	r6,108(sp)
8112c344:	00c001c4 	movi	r3,7
8112c348:	19827616 	blt	r3,r6,8112cd24 <___vfiprintf_internal_r+0xfc4>
8112c34c:	4cf9c83a 	sub	fp,r9,r19
8112c350:	42000204 	addi	r8,r8,8
8112c354:	31000044 	addi	r4,r6,1
8112c358:	300b883a 	mov	r5,r6
8112c35c:	07018516 	blt	zero,fp,8112c974 <___vfiprintf_internal_r+0xc14>
8112c360:	9885883a 	add	r2,r19,r2
8112c364:	45400015 	stw	r21,0(r8)
8112c368:	44c00115 	stw	r19,4(r8)
8112c36c:	d8801c15 	stw	r2,112(sp)
8112c370:	d9001b15 	stw	r4,108(sp)
8112c374:	00c001c4 	movi	r3,7
8112c378:	1901dd0e 	bge	r3,r4,8112caf0 <___vfiprintf_internal_r+0xd90>
8112c37c:	1002401e 	bne	r2,zero,8112cc80 <___vfiprintf_internal_r+0xf20>
8112c380:	d8001b15 	stw	zero,108(sp)
8112c384:	a2c0010c 	andi	r11,r20,4
8112c388:	58000226 	beq	r11,zero,8112c394 <___vfiprintf_internal_r+0x634>
8112c38c:	8ca7c83a 	sub	r19,r17,r18
8112c390:	04c2f216 	blt	zero,r19,8112cf5c <___vfiprintf_internal_r+0x11fc>
8112c394:	8c80010e 	bge	r17,r18,8112c39c <___vfiprintf_internal_r+0x63c>
8112c398:	9023883a 	mov	r17,r18
8112c39c:	da802317 	ldw	r10,140(sp)
8112c3a0:	5455883a 	add	r10,r10,r17
8112c3a4:	da802315 	stw	r10,140(sp)
8112c3a8:	d8001b15 	stw	zero,108(sp)
8112c3ac:	d811883a 	mov	r8,sp
8112c3b0:	003ea206 	br	8112be3c <__reset+0xfb10be3c>
8112c3b4:	a5000814 	ori	r20,r20,32
8112c3b8:	80c00007 	ldb	r3,0(r16)
8112c3bc:	003ec906 	br	8112bee4 <__reset+0xfb10bee4>
8112c3c0:	80c00007 	ldb	r3,0(r16)
8112c3c4:	1b030926 	beq	r3,r12,8112cfec <___vfiprintf_internal_r+0x128c>
8112c3c8:	a5000414 	ori	r20,r20,16
8112c3cc:	003ec506 	br	8112bee4 <__reset+0xfb10bee4>
8112c3d0:	21003fcc 	andi	r4,r4,255
8112c3d4:	20035e1e 	bne	r4,zero,8112d150 <___vfiprintf_internal_r+0x13f0>
8112c3d8:	a080080c 	andi	r2,r20,32
8112c3dc:	1002a526 	beq	r2,zero,8112ce74 <___vfiprintf_internal_r+0x1114>
8112c3e0:	da802217 	ldw	r10,136(sp)
8112c3e4:	50800017 	ldw	r2,0(r10)
8112c3e8:	da802317 	ldw	r10,140(sp)
8112c3ec:	5007d7fa 	srai	r3,r10,31
8112c3f0:	da802217 	ldw	r10,136(sp)
8112c3f4:	10c00115 	stw	r3,4(r2)
8112c3f8:	52800104 	addi	r10,r10,4
8112c3fc:	da802215 	stw	r10,136(sp)
8112c400:	da802317 	ldw	r10,140(sp)
8112c404:	12800015 	stw	r10,0(r2)
8112c408:	003e8c06 	br	8112be3c <__reset+0xfb10be3c>
8112c40c:	21003fcc 	andi	r4,r4,255
8112c410:	2003511e 	bne	r4,zero,8112d158 <___vfiprintf_internal_r+0x13f8>
8112c414:	a080080c 	andi	r2,r20,32
8112c418:	1000a126 	beq	r2,zero,8112c6a0 <___vfiprintf_internal_r+0x940>
8112c41c:	da802217 	ldw	r10,136(sp)
8112c420:	d8001d85 	stb	zero,118(sp)
8112c424:	50800204 	addi	r2,r10,8
8112c428:	54800017 	ldw	r18,0(r10)
8112c42c:	54c00117 	ldw	r19,4(r10)
8112c430:	4802b416 	blt	r9,zero,8112cf04 <___vfiprintf_internal_r+0x11a4>
8112c434:	013fdfc4 	movi	r4,-129
8112c438:	94c6b03a 	or	r3,r18,r19
8112c43c:	d8802215 	stw	r2,136(sp)
8112c440:	a128703a 	and	r20,r20,r4
8112c444:	1800a226 	beq	r3,zero,8112c6d0 <___vfiprintf_internal_r+0x970>
8112c448:	0039883a 	mov	fp,zero
8112c44c:	dd401a04 	addi	r21,sp,104
8112c450:	9006d0fa 	srli	r3,r18,3
8112c454:	9808977a 	slli	r4,r19,29
8112c458:	9826d0fa 	srli	r19,r19,3
8112c45c:	948001cc 	andi	r18,r18,7
8112c460:	90800c04 	addi	r2,r18,48
8112c464:	ad7fffc4 	addi	r21,r21,-1
8112c468:	20e4b03a 	or	r18,r4,r3
8112c46c:	a8800005 	stb	r2,0(r21)
8112c470:	94c6b03a 	or	r3,r18,r19
8112c474:	183ff61e 	bne	r3,zero,8112c450 <__reset+0xfb10c450>
8112c478:	a0c0004c 	andi	r3,r20,1
8112c47c:	18005926 	beq	r3,zero,8112c5e4 <___vfiprintf_internal_r+0x884>
8112c480:	10803fcc 	andi	r2,r2,255
8112c484:	1080201c 	xori	r2,r2,128
8112c488:	10bfe004 	addi	r2,r2,-128
8112c48c:	00c00c04 	movi	r3,48
8112c490:	10c05426 	beq	r2,r3,8112c5e4 <___vfiprintf_internal_r+0x884>
8112c494:	da801e17 	ldw	r10,120(sp)
8112c498:	a8bfffc4 	addi	r2,r21,-1
8112c49c:	a8ffffc5 	stb	r3,-1(r21)
8112c4a0:	50a7c83a 	sub	r19,r10,r2
8112c4a4:	102b883a 	mov	r21,r2
8112c4a8:	003f2f06 	br	8112c168 <__reset+0xfb10c168>
8112c4ac:	21003fcc 	andi	r4,r4,255
8112c4b0:	2003421e 	bne	r4,zero,8112d1bc <___vfiprintf_internal_r+0x145c>
8112c4b4:	00a04574 	movhi	r2,33045
8112c4b8:	10ab5a04 	addi	r2,r2,-21144
8112c4bc:	d8802615 	stw	r2,152(sp)
8112c4c0:	a080080c 	andi	r2,r20,32
8112c4c4:	1000aa26 	beq	r2,zero,8112c770 <___vfiprintf_internal_r+0xa10>
8112c4c8:	da802217 	ldw	r10,136(sp)
8112c4cc:	54800017 	ldw	r18,0(r10)
8112c4d0:	54c00117 	ldw	r19,4(r10)
8112c4d4:	52800204 	addi	r10,r10,8
8112c4d8:	da802215 	stw	r10,136(sp)
8112c4dc:	a080004c 	andi	r2,r20,1
8112c4e0:	1001d226 	beq	r2,zero,8112cc2c <___vfiprintf_internal_r+0xecc>
8112c4e4:	94c4b03a 	or	r2,r18,r19
8112c4e8:	1002351e 	bne	r2,zero,8112cdc0 <___vfiprintf_internal_r+0x1060>
8112c4ec:	d8001d85 	stb	zero,118(sp)
8112c4f0:	48022216 	blt	r9,zero,8112cd7c <___vfiprintf_internal_r+0x101c>
8112c4f4:	00bfdfc4 	movi	r2,-129
8112c4f8:	a0a8703a 	and	r20,r20,r2
8112c4fc:	003f1506 	br	8112c154 <__reset+0xfb10c154>
8112c500:	da802217 	ldw	r10,136(sp)
8112c504:	04800044 	movi	r18,1
8112c508:	d8001d85 	stb	zero,118(sp)
8112c50c:	50800017 	ldw	r2,0(r10)
8112c510:	52800104 	addi	r10,r10,4
8112c514:	da802215 	stw	r10,136(sp)
8112c518:	d8801005 	stb	r2,64(sp)
8112c51c:	9027883a 	mov	r19,r18
8112c520:	dd401004 	addi	r21,sp,64
8112c524:	0013883a 	mov	r9,zero
8112c528:	003f1706 	br	8112c188 <__reset+0xfb10c188>
8112c52c:	21003fcc 	andi	r4,r4,255
8112c530:	2003201e 	bne	r4,zero,8112d1b4 <___vfiprintf_internal_r+0x1454>
8112c534:	a080080c 	andi	r2,r20,32
8112c538:	10004b26 	beq	r2,zero,8112c668 <___vfiprintf_internal_r+0x908>
8112c53c:	da802217 	ldw	r10,136(sp)
8112c540:	50800117 	ldw	r2,4(r10)
8112c544:	54800017 	ldw	r18,0(r10)
8112c548:	52800204 	addi	r10,r10,8
8112c54c:	da802215 	stw	r10,136(sp)
8112c550:	1027883a 	mov	r19,r2
8112c554:	10022c16 	blt	r2,zero,8112ce08 <___vfiprintf_internal_r+0x10a8>
8112c558:	df001d83 	ldbu	fp,118(sp)
8112c55c:	48007216 	blt	r9,zero,8112c728 <___vfiprintf_internal_r+0x9c8>
8112c560:	00ffdfc4 	movi	r3,-129
8112c564:	94c4b03a 	or	r2,r18,r19
8112c568:	a0e8703a 	and	r20,r20,r3
8112c56c:	1000cc26 	beq	r2,zero,8112c8a0 <___vfiprintf_internal_r+0xb40>
8112c570:	98021026 	beq	r19,zero,8112cdb4 <___vfiprintf_internal_r+0x1054>
8112c574:	dc402415 	stw	r17,144(sp)
8112c578:	dc002515 	stw	r16,148(sp)
8112c57c:	9823883a 	mov	r17,r19
8112c580:	9021883a 	mov	r16,r18
8112c584:	dd401a04 	addi	r21,sp,104
8112c588:	4825883a 	mov	r18,r9
8112c58c:	4027883a 	mov	r19,r8
8112c590:	8009883a 	mov	r4,r16
8112c594:	880b883a 	mov	r5,r17
8112c598:	01800284 	movi	r6,10
8112c59c:	000f883a 	mov	r7,zero
8112c5a0:	112eafc0 	call	8112eafc <__umoddi3>
8112c5a4:	10800c04 	addi	r2,r2,48
8112c5a8:	ad7fffc4 	addi	r21,r21,-1
8112c5ac:	8009883a 	mov	r4,r16
8112c5b0:	880b883a 	mov	r5,r17
8112c5b4:	a8800005 	stb	r2,0(r21)
8112c5b8:	01800284 	movi	r6,10
8112c5bc:	000f883a 	mov	r7,zero
8112c5c0:	112e57c0 	call	8112e57c <__udivdi3>
8112c5c4:	1021883a 	mov	r16,r2
8112c5c8:	10c4b03a 	or	r2,r2,r3
8112c5cc:	1823883a 	mov	r17,r3
8112c5d0:	103fef1e 	bne	r2,zero,8112c590 <__reset+0xfb10c590>
8112c5d4:	dc402417 	ldw	r17,144(sp)
8112c5d8:	dc002517 	ldw	r16,148(sp)
8112c5dc:	9013883a 	mov	r9,r18
8112c5e0:	9811883a 	mov	r8,r19
8112c5e4:	da801e17 	ldw	r10,120(sp)
8112c5e8:	5567c83a 	sub	r19,r10,r21
8112c5ec:	003ede06 	br	8112c168 <__reset+0xfb10c168>
8112c5f0:	38803fcc 	andi	r2,r7,255
8112c5f4:	1080201c 	xori	r2,r2,128
8112c5f8:	10bfe004 	addi	r2,r2,-128
8112c5fc:	1002371e 	bne	r2,zero,8112cedc <___vfiprintf_internal_r+0x117c>
8112c600:	01000044 	movi	r4,1
8112c604:	01c00804 	movi	r7,32
8112c608:	80c00007 	ldb	r3,0(r16)
8112c60c:	003e3506 	br	8112bee4 <__reset+0xfb10bee4>
8112c610:	a5000054 	ori	r20,r20,1
8112c614:	80c00007 	ldb	r3,0(r16)
8112c618:	003e3206 	br	8112bee4 <__reset+0xfb10bee4>
8112c61c:	a5002014 	ori	r20,r20,128
8112c620:	80c00007 	ldb	r3,0(r16)
8112c624:	003e2f06 	br	8112bee4 <__reset+0xfb10bee4>
8112c628:	8015883a 	mov	r10,r16
8112c62c:	0023883a 	mov	r17,zero
8112c630:	18bff404 	addi	r2,r3,-48
8112c634:	50c00007 	ldb	r3,0(r10)
8112c638:	8c4002a4 	muli	r17,r17,10
8112c63c:	84000044 	addi	r16,r16,1
8112c640:	8015883a 	mov	r10,r16
8112c644:	1463883a 	add	r17,r2,r17
8112c648:	18bff404 	addi	r2,r3,-48
8112c64c:	30bff92e 	bgeu	r6,r2,8112c634 <__reset+0xfb10c634>
8112c650:	003e2506 	br	8112bee8 <__reset+0xfb10bee8>
8112c654:	21003fcc 	andi	r4,r4,255
8112c658:	2002d41e 	bne	r4,zero,8112d1ac <___vfiprintf_internal_r+0x144c>
8112c65c:	a5000414 	ori	r20,r20,16
8112c660:	a080080c 	andi	r2,r20,32
8112c664:	103fb51e 	bne	r2,zero,8112c53c <__reset+0xfb10c53c>
8112c668:	a080040c 	andi	r2,r20,16
8112c66c:	1001f826 	beq	r2,zero,8112ce50 <___vfiprintf_internal_r+0x10f0>
8112c670:	da802217 	ldw	r10,136(sp)
8112c674:	54800017 	ldw	r18,0(r10)
8112c678:	52800104 	addi	r10,r10,4
8112c67c:	da802215 	stw	r10,136(sp)
8112c680:	9027d7fa 	srai	r19,r18,31
8112c684:	9805883a 	mov	r2,r19
8112c688:	003fb206 	br	8112c554 <__reset+0xfb10c554>
8112c68c:	21003fcc 	andi	r4,r4,255
8112c690:	2002c41e 	bne	r4,zero,8112d1a4 <___vfiprintf_internal_r+0x1444>
8112c694:	a5000414 	ori	r20,r20,16
8112c698:	a080080c 	andi	r2,r20,32
8112c69c:	103f5f1e 	bne	r2,zero,8112c41c <__reset+0xfb10c41c>
8112c6a0:	a080040c 	andi	r2,r20,16
8112c6a4:	10020f26 	beq	r2,zero,8112cee4 <___vfiprintf_internal_r+0x1184>
8112c6a8:	da802217 	ldw	r10,136(sp)
8112c6ac:	d8001d85 	stb	zero,118(sp)
8112c6b0:	0027883a 	mov	r19,zero
8112c6b4:	50800104 	addi	r2,r10,4
8112c6b8:	54800017 	ldw	r18,0(r10)
8112c6bc:	48021116 	blt	r9,zero,8112cf04 <___vfiprintf_internal_r+0x11a4>
8112c6c0:	00ffdfc4 	movi	r3,-129
8112c6c4:	d8802215 	stw	r2,136(sp)
8112c6c8:	a0e8703a 	and	r20,r20,r3
8112c6cc:	903f5e1e 	bne	r18,zero,8112c448 <__reset+0xfb10c448>
8112c6d0:	0039883a 	mov	fp,zero
8112c6d4:	4802a626 	beq	r9,zero,8112d170 <___vfiprintf_internal_r+0x1410>
8112c6d8:	0025883a 	mov	r18,zero
8112c6dc:	0027883a 	mov	r19,zero
8112c6e0:	003f5a06 	br	8112c44c <__reset+0xfb10c44c>
8112c6e4:	21003fcc 	andi	r4,r4,255
8112c6e8:	20029f1e 	bne	r4,zero,8112d168 <___vfiprintf_internal_r+0x1408>
8112c6ec:	a5000414 	ori	r20,r20,16
8112c6f0:	a080080c 	andi	r2,r20,32
8112c6f4:	10005e1e 	bne	r2,zero,8112c870 <___vfiprintf_internal_r+0xb10>
8112c6f8:	a080040c 	andi	r2,r20,16
8112c6fc:	1001a21e 	bne	r2,zero,8112cd88 <___vfiprintf_internal_r+0x1028>
8112c700:	a080100c 	andi	r2,r20,64
8112c704:	d8001d85 	stb	zero,118(sp)
8112c708:	da802217 	ldw	r10,136(sp)
8112c70c:	1002231e 	bne	r2,zero,8112cf9c <___vfiprintf_internal_r+0x123c>
8112c710:	50800104 	addi	r2,r10,4
8112c714:	54800017 	ldw	r18,0(r10)
8112c718:	0027883a 	mov	r19,zero
8112c71c:	4801a00e 	bge	r9,zero,8112cda0 <___vfiprintf_internal_r+0x1040>
8112c720:	d8802215 	stw	r2,136(sp)
8112c724:	0039883a 	mov	fp,zero
8112c728:	94c4b03a 	or	r2,r18,r19
8112c72c:	103f901e 	bne	r2,zero,8112c570 <__reset+0xfb10c570>
8112c730:	00800044 	movi	r2,1
8112c734:	10803fcc 	andi	r2,r2,255
8112c738:	00c00044 	movi	r3,1
8112c73c:	10c05926 	beq	r2,r3,8112c8a4 <___vfiprintf_internal_r+0xb44>
8112c740:	00c00084 	movi	r3,2
8112c744:	10ffe41e 	bne	r2,r3,8112c6d8 <__reset+0xfb10c6d8>
8112c748:	0025883a 	mov	r18,zero
8112c74c:	0027883a 	mov	r19,zero
8112c750:	00013d06 	br	8112cc48 <___vfiprintf_internal_r+0xee8>
8112c754:	21003fcc 	andi	r4,r4,255
8112c758:	2002811e 	bne	r4,zero,8112d160 <___vfiprintf_internal_r+0x1400>
8112c75c:	00a04574 	movhi	r2,33045
8112c760:	10ab5504 	addi	r2,r2,-21164
8112c764:	d8802615 	stw	r2,152(sp)
8112c768:	a080080c 	andi	r2,r20,32
8112c76c:	103f561e 	bne	r2,zero,8112c4c8 <__reset+0xfb10c4c8>
8112c770:	a080040c 	andi	r2,r20,16
8112c774:	1001d126 	beq	r2,zero,8112cebc <___vfiprintf_internal_r+0x115c>
8112c778:	da802217 	ldw	r10,136(sp)
8112c77c:	0027883a 	mov	r19,zero
8112c780:	54800017 	ldw	r18,0(r10)
8112c784:	52800104 	addi	r10,r10,4
8112c788:	da802215 	stw	r10,136(sp)
8112c78c:	003f5306 	br	8112c4dc <__reset+0xfb10c4dc>
8112c790:	da802217 	ldw	r10,136(sp)
8112c794:	d8001d85 	stb	zero,118(sp)
8112c798:	55400017 	ldw	r21,0(r10)
8112c79c:	50c00104 	addi	r3,r10,4
8112c7a0:	a8024226 	beq	r21,zero,8112d0ac <___vfiprintf_internal_r+0x134c>
8112c7a4:	48021816 	blt	r9,zero,8112d008 <___vfiprintf_internal_r+0x12a8>
8112c7a8:	480d883a 	mov	r6,r9
8112c7ac:	000b883a 	mov	r5,zero
8112c7b0:	a809883a 	mov	r4,r21
8112c7b4:	d8c02a15 	stw	r3,168(sp)
8112c7b8:	da002b15 	stw	r8,172(sp)
8112c7bc:	da402c15 	stw	r9,176(sp)
8112c7c0:	1126b3c0 	call	81126b3c <memchr>
8112c7c4:	d8c02a17 	ldw	r3,168(sp)
8112c7c8:	da002b17 	ldw	r8,172(sp)
8112c7cc:	da402c17 	ldw	r9,176(sp)
8112c7d0:	10024826 	beq	r2,zero,8112d0f4 <___vfiprintf_internal_r+0x1394>
8112c7d4:	1567c83a 	sub	r19,r2,r21
8112c7d8:	df001d83 	ldbu	fp,118(sp)
8112c7dc:	d8c02215 	stw	r3,136(sp)
8112c7e0:	0013883a 	mov	r9,zero
8112c7e4:	003e6006 	br	8112c168 <__reset+0xfb10c168>
8112c7e8:	21003fcc 	andi	r4,r4,255
8112c7ec:	203fc026 	beq	r4,zero,8112c6f0 <__reset+0xfb10c6f0>
8112c7f0:	d9c01d85 	stb	r7,118(sp)
8112c7f4:	003fbe06 	br	8112c6f0 <__reset+0xfb10c6f0>
8112c7f8:	da802217 	ldw	r10,136(sp)
8112c7fc:	54400017 	ldw	r17,0(r10)
8112c800:	50800104 	addi	r2,r10,4
8112c804:	883e3b16 	blt	r17,zero,8112c0f4 <__reset+0xfb10c0f4>
8112c808:	d8802215 	stw	r2,136(sp)
8112c80c:	80c00007 	ldb	r3,0(r16)
8112c810:	003db406 	br	8112bee4 <__reset+0xfb10bee4>
8112c814:	01000044 	movi	r4,1
8112c818:	01c00ac4 	movi	r7,43
8112c81c:	80c00007 	ldb	r3,0(r16)
8112c820:	003db006 	br	8112bee4 <__reset+0xfb10bee4>
8112c824:	80c00007 	ldb	r3,0(r16)
8112c828:	82800044 	addi	r10,r16,1
8112c82c:	1b423c26 	beq	r3,r13,8112d120 <___vfiprintf_internal_r+0x13c0>
8112c830:	18bff404 	addi	r2,r3,-48
8112c834:	0013883a 	mov	r9,zero
8112c838:	30822b36 	bltu	r6,r2,8112d0e8 <___vfiprintf_internal_r+0x1388>
8112c83c:	50c00007 	ldb	r3,0(r10)
8112c840:	4a4002a4 	muli	r9,r9,10
8112c844:	54000044 	addi	r16,r10,1
8112c848:	8015883a 	mov	r10,r16
8112c84c:	4893883a 	add	r9,r9,r2
8112c850:	18bff404 	addi	r2,r3,-48
8112c854:	30bff92e 	bgeu	r6,r2,8112c83c <__reset+0xfb10c83c>
8112c858:	483da30e 	bge	r9,zero,8112bee8 <__reset+0xfb10bee8>
8112c85c:	027fffc4 	movi	r9,-1
8112c860:	003da106 	br	8112bee8 <__reset+0xfb10bee8>
8112c864:	a5001014 	ori	r20,r20,64
8112c868:	80c00007 	ldb	r3,0(r16)
8112c86c:	003d9d06 	br	8112bee4 <__reset+0xfb10bee4>
8112c870:	da802217 	ldw	r10,136(sp)
8112c874:	d8001d85 	stb	zero,118(sp)
8112c878:	50c00204 	addi	r3,r10,8
8112c87c:	54800017 	ldw	r18,0(r10)
8112c880:	54c00117 	ldw	r19,4(r10)
8112c884:	4801ca16 	blt	r9,zero,8112cfb0 <___vfiprintf_internal_r+0x1250>
8112c888:	013fdfc4 	movi	r4,-129
8112c88c:	94c4b03a 	or	r2,r18,r19
8112c890:	d8c02215 	stw	r3,136(sp)
8112c894:	a128703a 	and	r20,r20,r4
8112c898:	0039883a 	mov	fp,zero
8112c89c:	103f341e 	bne	r2,zero,8112c570 <__reset+0xfb10c570>
8112c8a0:	483e2e26 	beq	r9,zero,8112c15c <__reset+0xfb10c15c>
8112c8a4:	0025883a 	mov	r18,zero
8112c8a8:	94800c04 	addi	r18,r18,48
8112c8ac:	dc8019c5 	stb	r18,103(sp)
8112c8b0:	dcc02717 	ldw	r19,156(sp)
8112c8b4:	dd4019c4 	addi	r21,sp,103
8112c8b8:	003e2b06 	br	8112c168 <__reset+0xfb10c168>
8112c8bc:	21003fcc 	andi	r4,r4,255
8112c8c0:	2002361e 	bne	r4,zero,8112d19c <___vfiprintf_internal_r+0x143c>
8112c8c4:	1801c126 	beq	r3,zero,8112cfcc <___vfiprintf_internal_r+0x126c>
8112c8c8:	04800044 	movi	r18,1
8112c8cc:	d8c01005 	stb	r3,64(sp)
8112c8d0:	d8001d85 	stb	zero,118(sp)
8112c8d4:	9027883a 	mov	r19,r18
8112c8d8:	dd401004 	addi	r21,sp,64
8112c8dc:	003f1106 	br	8112c524 <__reset+0xfb10c524>
8112c8e0:	d9402117 	ldw	r5,132(sp)
8112c8e4:	d9002017 	ldw	r4,128(sp)
8112c8e8:	d9801a04 	addi	r6,sp,104
8112c8ec:	d9c02b15 	stw	r7,172(sp)
8112c8f0:	dbc02a15 	stw	r15,168(sp)
8112c8f4:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112c8f8:	d9c02b17 	ldw	r7,172(sp)
8112c8fc:	dbc02a17 	ldw	r15,168(sp)
8112c900:	10006d1e 	bne	r2,zero,8112cab8 <___vfiprintf_internal_r+0xd58>
8112c904:	d9801b17 	ldw	r6,108(sp)
8112c908:	d8801c17 	ldw	r2,112(sp)
8112c90c:	d811883a 	mov	r8,sp
8112c910:	31400044 	addi	r5,r6,1
8112c914:	003e3306 	br	8112c1e4 <__reset+0xfb10c1e4>
8112c918:	d9401b17 	ldw	r5,108(sp)
8112c91c:	d8801c17 	ldw	r2,112(sp)
8112c920:	29000044 	addi	r4,r5,1
8112c924:	d8c01d87 	ldb	r3,118(sp)
8112c928:	183e4d26 	beq	r3,zero,8112c260 <__reset+0xfb10c260>
8112c92c:	00c00044 	movi	r3,1
8112c930:	d9401d84 	addi	r5,sp,118
8112c934:	10c5883a 	add	r2,r2,r3
8112c938:	41400015 	stw	r5,0(r8)
8112c93c:	40c00115 	stw	r3,4(r8)
8112c940:	d8801c15 	stw	r2,112(sp)
8112c944:	d9001b15 	stw	r4,108(sp)
8112c948:	014001c4 	movi	r5,7
8112c94c:	2900a90e 	bge	r5,r4,8112cbf4 <___vfiprintf_internal_r+0xe94>
8112c950:	1000da1e 	bne	r2,zero,8112ccbc <___vfiprintf_internal_r+0xf5c>
8112c954:	7000ab1e 	bne	r14,zero,8112cc04 <___vfiprintf_internal_r+0xea4>
8112c958:	000b883a 	mov	r5,zero
8112c95c:	1809883a 	mov	r4,r3
8112c960:	d811883a 	mov	r8,sp
8112c964:	00c02004 	movi	r3,128
8112c968:	e0fe4d26 	beq	fp,r3,8112c2a0 <__reset+0xfb10c2a0>
8112c96c:	4cf9c83a 	sub	fp,r9,r19
8112c970:	073e7b0e 	bge	zero,fp,8112c360 <__reset+0xfb10c360>
8112c974:	01c00404 	movi	r7,16
8112c978:	3f01900e 	bge	r7,fp,8112cfbc <___vfiprintf_internal_r+0x125c>
8112c97c:	00e04574 	movhi	r3,33045
8112c980:	18ebec04 	addi	r3,r3,-20560
8112c984:	d8c02415 	stw	r3,144(sp)
8112c988:	034001c4 	movi	r13,7
8112c98c:	00000506 	br	8112c9a4 <___vfiprintf_internal_r+0xc44>
8112c990:	29000084 	addi	r4,r5,2
8112c994:	42000204 	addi	r8,r8,8
8112c998:	180b883a 	mov	r5,r3
8112c99c:	e73ffc04 	addi	fp,fp,-16
8112c9a0:	3f000d0e 	bge	r7,fp,8112c9d8 <___vfiprintf_internal_r+0xc78>
8112c9a4:	10800404 	addi	r2,r2,16
8112c9a8:	28c00044 	addi	r3,r5,1
8112c9ac:	45c00015 	stw	r23,0(r8)
8112c9b0:	41c00115 	stw	r7,4(r8)
8112c9b4:	d8801c15 	stw	r2,112(sp)
8112c9b8:	d8c01b15 	stw	r3,108(sp)
8112c9bc:	68fff40e 	bge	r13,r3,8112c990 <__reset+0xfb10c990>
8112c9c0:	1000101e 	bne	r2,zero,8112ca04 <___vfiprintf_internal_r+0xca4>
8112c9c4:	e73ffc04 	addi	fp,fp,-16
8112c9c8:	01000044 	movi	r4,1
8112c9cc:	000b883a 	mov	r5,zero
8112c9d0:	d811883a 	mov	r8,sp
8112c9d4:	3f3ff316 	blt	r7,fp,8112c9a4 <__reset+0xfb10c9a4>
8112c9d8:	da802417 	ldw	r10,144(sp)
8112c9dc:	1705883a 	add	r2,r2,fp
8112c9e0:	47000115 	stw	fp,4(r8)
8112c9e4:	42800015 	stw	r10,0(r8)
8112c9e8:	d8801c15 	stw	r2,112(sp)
8112c9ec:	d9001b15 	stw	r4,108(sp)
8112c9f0:	00c001c4 	movi	r3,7
8112c9f4:	19003616 	blt	r3,r4,8112cad0 <___vfiprintf_internal_r+0xd70>
8112c9f8:	42000204 	addi	r8,r8,8
8112c9fc:	21000044 	addi	r4,r4,1
8112ca00:	003e5706 	br	8112c360 <__reset+0xfb10c360>
8112ca04:	d9402117 	ldw	r5,132(sp)
8112ca08:	d9002017 	ldw	r4,128(sp)
8112ca0c:	d9801a04 	addi	r6,sp,104
8112ca10:	d9c02b15 	stw	r7,172(sp)
8112ca14:	db402a15 	stw	r13,168(sp)
8112ca18:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112ca1c:	d9c02b17 	ldw	r7,172(sp)
8112ca20:	db402a17 	ldw	r13,168(sp)
8112ca24:	1000241e 	bne	r2,zero,8112cab8 <___vfiprintf_internal_r+0xd58>
8112ca28:	d9401b17 	ldw	r5,108(sp)
8112ca2c:	d8801c17 	ldw	r2,112(sp)
8112ca30:	d811883a 	mov	r8,sp
8112ca34:	29000044 	addi	r4,r5,1
8112ca38:	003fd806 	br	8112c99c <__reset+0xfb10c99c>
8112ca3c:	d9401b17 	ldw	r5,108(sp)
8112ca40:	00e04574 	movhi	r3,33045
8112ca44:	18ebf004 	addi	r3,r3,-20544
8112ca48:	d8c02415 	stw	r3,144(sp)
8112ca4c:	29400044 	addi	r5,r5,1
8112ca50:	d8c02417 	ldw	r3,144(sp)
8112ca54:	14c5883a 	add	r2,r2,r19
8112ca58:	44c00115 	stw	r19,4(r8)
8112ca5c:	40c00015 	stw	r3,0(r8)
8112ca60:	d8801c15 	stw	r2,112(sp)
8112ca64:	d9401b15 	stw	r5,108(sp)
8112ca68:	00c001c4 	movi	r3,7
8112ca6c:	1940070e 	bge	r3,r5,8112ca8c <___vfiprintf_internal_r+0xd2c>
8112ca70:	103e4826 	beq	r2,zero,8112c394 <__reset+0xfb10c394>
8112ca74:	d9402117 	ldw	r5,132(sp)
8112ca78:	d9002017 	ldw	r4,128(sp)
8112ca7c:	d9801a04 	addi	r6,sp,104
8112ca80:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112ca84:	10000c1e 	bne	r2,zero,8112cab8 <___vfiprintf_internal_r+0xd58>
8112ca88:	d8801c17 	ldw	r2,112(sp)
8112ca8c:	8c80010e 	bge	r17,r18,8112ca94 <___vfiprintf_internal_r+0xd34>
8112ca90:	9023883a 	mov	r17,r18
8112ca94:	da802317 	ldw	r10,140(sp)
8112ca98:	5455883a 	add	r10,r10,r17
8112ca9c:	da802315 	stw	r10,140(sp)
8112caa0:	103e4126 	beq	r2,zero,8112c3a8 <__reset+0xfb10c3a8>
8112caa4:	d9402117 	ldw	r5,132(sp)
8112caa8:	d9002017 	ldw	r4,128(sp)
8112caac:	d9801a04 	addi	r6,sp,104
8112cab0:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cab4:	103e3c26 	beq	r2,zero,8112c3a8 <__reset+0xfb10c3a8>
8112cab8:	dd002117 	ldw	r20,132(sp)
8112cabc:	a080030b 	ldhu	r2,12(r20)
8112cac0:	1080100c 	andi	r2,r2,64
8112cac4:	1001231e 	bne	r2,zero,8112cf54 <___vfiprintf_internal_r+0x11f4>
8112cac8:	d8802317 	ldw	r2,140(sp)
8112cacc:	003d7b06 	br	8112c0bc <__reset+0xfb10c0bc>
8112cad0:	1000991e 	bne	r2,zero,8112cd38 <___vfiprintf_internal_r+0xfd8>
8112cad4:	00c00044 	movi	r3,1
8112cad8:	9805883a 	mov	r2,r19
8112cadc:	dd400015 	stw	r21,0(sp)
8112cae0:	dcc00115 	stw	r19,4(sp)
8112cae4:	dcc01c15 	stw	r19,112(sp)
8112cae8:	d8c01b15 	stw	r3,108(sp)
8112caec:	d811883a 	mov	r8,sp
8112caf0:	42000204 	addi	r8,r8,8
8112caf4:	a2c0010c 	andi	r11,r20,4
8112caf8:	583fe426 	beq	r11,zero,8112ca8c <__reset+0xfb10ca8c>
8112cafc:	8ca7c83a 	sub	r19,r17,r18
8112cb00:	04ffe20e 	bge	zero,r19,8112ca8c <__reset+0xfb10ca8c>
8112cb04:	01c00404 	movi	r7,16
8112cb08:	3cffcc0e 	bge	r7,r19,8112ca3c <__reset+0xfb10ca3c>
8112cb0c:	02a04574 	movhi	r10,33045
8112cb10:	52abf004 	addi	r10,r10,-20544
8112cb14:	d9001b17 	ldw	r4,108(sp)
8112cb18:	da802415 	stw	r10,144(sp)
8112cb1c:	382b883a 	mov	r21,r7
8112cb20:	050001c4 	movi	r20,7
8112cb24:	df002017 	ldw	fp,128(sp)
8112cb28:	00000506 	br	8112cb40 <___vfiprintf_internal_r+0xde0>
8112cb2c:	21400084 	addi	r5,r4,2
8112cb30:	42000204 	addi	r8,r8,8
8112cb34:	1809883a 	mov	r4,r3
8112cb38:	9cfffc04 	addi	r19,r19,-16
8112cb3c:	acffc40e 	bge	r21,r19,8112ca50 <__reset+0xfb10ca50>
8112cb40:	10800404 	addi	r2,r2,16
8112cb44:	20c00044 	addi	r3,r4,1
8112cb48:	45800015 	stw	r22,0(r8)
8112cb4c:	45400115 	stw	r21,4(r8)
8112cb50:	d8801c15 	stw	r2,112(sp)
8112cb54:	d8c01b15 	stw	r3,108(sp)
8112cb58:	a0fff40e 	bge	r20,r3,8112cb2c <__reset+0xfb10cb2c>
8112cb5c:	1000041e 	bne	r2,zero,8112cb70 <___vfiprintf_internal_r+0xe10>
8112cb60:	01400044 	movi	r5,1
8112cb64:	0009883a 	mov	r4,zero
8112cb68:	d811883a 	mov	r8,sp
8112cb6c:	003ff206 	br	8112cb38 <__reset+0xfb10cb38>
8112cb70:	d9402117 	ldw	r5,132(sp)
8112cb74:	d9801a04 	addi	r6,sp,104
8112cb78:	e009883a 	mov	r4,fp
8112cb7c:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cb80:	103fcd1e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cb84:	d9001b17 	ldw	r4,108(sp)
8112cb88:	d8801c17 	ldw	r2,112(sp)
8112cb8c:	d811883a 	mov	r8,sp
8112cb90:	21400044 	addi	r5,r4,1
8112cb94:	003fe806 	br	8112cb38 <__reset+0xfb10cb38>
8112cb98:	d9402117 	ldw	r5,132(sp)
8112cb9c:	d9002017 	ldw	r4,128(sp)
8112cba0:	d9801a04 	addi	r6,sp,104
8112cba4:	d9c02b15 	stw	r7,172(sp)
8112cba8:	db402a15 	stw	r13,168(sp)
8112cbac:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cbb0:	d9c02b17 	ldw	r7,172(sp)
8112cbb4:	db402a17 	ldw	r13,168(sp)
8112cbb8:	103fbf1e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cbbc:	d9401b17 	ldw	r5,108(sp)
8112cbc0:	d8801c17 	ldw	r2,112(sp)
8112cbc4:	d811883a 	mov	r8,sp
8112cbc8:	29800044 	addi	r6,r5,1
8112cbcc:	003dc406 	br	8112c2e0 <__reset+0xfb10c2e0>
8112cbd0:	1000d21e 	bne	r2,zero,8112cf1c <___vfiprintf_internal_r+0x11bc>
8112cbd4:	d8c01d87 	ldb	r3,118(sp)
8112cbd8:	18009526 	beq	r3,zero,8112ce30 <___vfiprintf_internal_r+0x10d0>
8112cbdc:	00800044 	movi	r2,1
8112cbe0:	d8c01d84 	addi	r3,sp,118
8112cbe4:	1009883a 	mov	r4,r2
8112cbe8:	d8c00015 	stw	r3,0(sp)
8112cbec:	d8800115 	stw	r2,4(sp)
8112cbf0:	d811883a 	mov	r8,sp
8112cbf4:	200b883a 	mov	r5,r4
8112cbf8:	42000204 	addi	r8,r8,8
8112cbfc:	21000044 	addi	r4,r4,1
8112cc00:	003d9706 	br	8112c260 <__reset+0xfb10c260>
8112cc04:	d9001d04 	addi	r4,sp,116
8112cc08:	00800084 	movi	r2,2
8112cc0c:	d9000015 	stw	r4,0(sp)
8112cc10:	d8800115 	stw	r2,4(sp)
8112cc14:	1809883a 	mov	r4,r3
8112cc18:	d811883a 	mov	r8,sp
8112cc1c:	200b883a 	mov	r5,r4
8112cc20:	42000204 	addi	r8,r8,8
8112cc24:	21000044 	addi	r4,r4,1
8112cc28:	003f4e06 	br	8112c964 <__reset+0xfb10c964>
8112cc2c:	d8001d85 	stb	zero,118(sp)
8112cc30:	48005016 	blt	r9,zero,8112cd74 <___vfiprintf_internal_r+0x1014>
8112cc34:	00ffdfc4 	movi	r3,-129
8112cc38:	94c4b03a 	or	r2,r18,r19
8112cc3c:	a0e8703a 	and	r20,r20,r3
8112cc40:	103d4426 	beq	r2,zero,8112c154 <__reset+0xfb10c154>
8112cc44:	0039883a 	mov	fp,zero
8112cc48:	d9002617 	ldw	r4,152(sp)
8112cc4c:	dd401a04 	addi	r21,sp,104
8112cc50:	908003cc 	andi	r2,r18,15
8112cc54:	9806973a 	slli	r3,r19,28
8112cc58:	2085883a 	add	r2,r4,r2
8112cc5c:	9024d13a 	srli	r18,r18,4
8112cc60:	10800003 	ldbu	r2,0(r2)
8112cc64:	9826d13a 	srli	r19,r19,4
8112cc68:	ad7fffc4 	addi	r21,r21,-1
8112cc6c:	1ca4b03a 	or	r18,r3,r18
8112cc70:	a8800005 	stb	r2,0(r21)
8112cc74:	94c4b03a 	or	r2,r18,r19
8112cc78:	103ff51e 	bne	r2,zero,8112cc50 <__reset+0xfb10cc50>
8112cc7c:	003e5906 	br	8112c5e4 <__reset+0xfb10c5e4>
8112cc80:	d9402117 	ldw	r5,132(sp)
8112cc84:	d9002017 	ldw	r4,128(sp)
8112cc88:	d9801a04 	addi	r6,sp,104
8112cc8c:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cc90:	103f891e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cc94:	d8801c17 	ldw	r2,112(sp)
8112cc98:	d811883a 	mov	r8,sp
8112cc9c:	003f9506 	br	8112caf4 <__reset+0xfb10caf4>
8112cca0:	d9402117 	ldw	r5,132(sp)
8112cca4:	d9002017 	ldw	r4,128(sp)
8112cca8:	d9801a04 	addi	r6,sp,104
8112ccac:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112ccb0:	103f811e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112ccb4:	d811883a 	mov	r8,sp
8112ccb8:	003ced06 	br	8112c070 <__reset+0xfb10c070>
8112ccbc:	d9402117 	ldw	r5,132(sp)
8112ccc0:	d9002017 	ldw	r4,128(sp)
8112ccc4:	d9801a04 	addi	r6,sp,104
8112ccc8:	da402c15 	stw	r9,176(sp)
8112cccc:	db802a15 	stw	r14,168(sp)
8112ccd0:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112ccd4:	da402c17 	ldw	r9,176(sp)
8112ccd8:	db802a17 	ldw	r14,168(sp)
8112ccdc:	103f761e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cce0:	d9401b17 	ldw	r5,108(sp)
8112cce4:	d8801c17 	ldw	r2,112(sp)
8112cce8:	d811883a 	mov	r8,sp
8112ccec:	29000044 	addi	r4,r5,1
8112ccf0:	003d5b06 	br	8112c260 <__reset+0xfb10c260>
8112ccf4:	d9402117 	ldw	r5,132(sp)
8112ccf8:	d9002017 	ldw	r4,128(sp)
8112ccfc:	d9801a04 	addi	r6,sp,104
8112cd00:	da402c15 	stw	r9,176(sp)
8112cd04:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cd08:	da402c17 	ldw	r9,176(sp)
8112cd0c:	103f6a1e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cd10:	d9401b17 	ldw	r5,108(sp)
8112cd14:	d8801c17 	ldw	r2,112(sp)
8112cd18:	d811883a 	mov	r8,sp
8112cd1c:	29000044 	addi	r4,r5,1
8112cd20:	003f1006 	br	8112c964 <__reset+0xfb10c964>
8112cd24:	1000c31e 	bne	r2,zero,8112d034 <___vfiprintf_internal_r+0x12d4>
8112cd28:	01000044 	movi	r4,1
8112cd2c:	000b883a 	mov	r5,zero
8112cd30:	d811883a 	mov	r8,sp
8112cd34:	003f0d06 	br	8112c96c <__reset+0xfb10c96c>
8112cd38:	d9402117 	ldw	r5,132(sp)
8112cd3c:	d9002017 	ldw	r4,128(sp)
8112cd40:	d9801a04 	addi	r6,sp,104
8112cd44:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cd48:	103f5b1e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cd4c:	d9001b17 	ldw	r4,108(sp)
8112cd50:	d8801c17 	ldw	r2,112(sp)
8112cd54:	d811883a 	mov	r8,sp
8112cd58:	21000044 	addi	r4,r4,1
8112cd5c:	003d8006 	br	8112c360 <__reset+0xfb10c360>
8112cd60:	01204574 	movhi	r4,33045
8112cd64:	212b5a04 	addi	r4,r4,-21144
8112cd68:	d9002615 	stw	r4,152(sp)
8112cd6c:	d8c02215 	stw	r3,136(sp)
8112cd70:	1029883a 	mov	r20,r2
8112cd74:	94c4b03a 	or	r2,r18,r19
8112cd78:	103fb21e 	bne	r2,zero,8112cc44 <__reset+0xfb10cc44>
8112cd7c:	0039883a 	mov	fp,zero
8112cd80:	00800084 	movi	r2,2
8112cd84:	003e6b06 	br	8112c734 <__reset+0xfb10c734>
8112cd88:	da802217 	ldw	r10,136(sp)
8112cd8c:	d8001d85 	stb	zero,118(sp)
8112cd90:	0027883a 	mov	r19,zero
8112cd94:	50800104 	addi	r2,r10,4
8112cd98:	54800017 	ldw	r18,0(r10)
8112cd9c:	483e6016 	blt	r9,zero,8112c720 <__reset+0xfb10c720>
8112cda0:	00ffdfc4 	movi	r3,-129
8112cda4:	d8802215 	stw	r2,136(sp)
8112cda8:	a0e8703a 	and	r20,r20,r3
8112cdac:	0039883a 	mov	fp,zero
8112cdb0:	903ebb26 	beq	r18,zero,8112c8a0 <__reset+0xfb10c8a0>
8112cdb4:	00800244 	movi	r2,9
8112cdb8:	14bdee36 	bltu	r2,r18,8112c574 <__reset+0xfb10c574>
8112cdbc:	003eba06 	br	8112c8a8 <__reset+0xfb10c8a8>
8112cdc0:	00800c04 	movi	r2,48
8112cdc4:	d8c01d45 	stb	r3,117(sp)
8112cdc8:	d8801d05 	stb	r2,116(sp)
8112cdcc:	d8001d85 	stb	zero,118(sp)
8112cdd0:	a0c00094 	ori	r3,r20,2
8112cdd4:	4800a916 	blt	r9,zero,8112d07c <___vfiprintf_internal_r+0x131c>
8112cdd8:	00bfdfc4 	movi	r2,-129
8112cddc:	a096703a 	and	r11,r20,r2
8112cde0:	5d000094 	ori	r20,r11,2
8112cde4:	0039883a 	mov	fp,zero
8112cde8:	003f9706 	br	8112cc48 <__reset+0xfb10cc48>
8112cdec:	8025883a 	mov	r18,r16
8112cdf0:	003c2e06 	br	8112beac <__reset+0xfb10beac>
8112cdf4:	00a04574 	movhi	r2,33045
8112cdf8:	10ab5a04 	addi	r2,r2,-21144
8112cdfc:	0039883a 	mov	fp,zero
8112ce00:	d8802615 	stw	r2,152(sp)
8112ce04:	003f9006 	br	8112cc48 <__reset+0xfb10cc48>
8112ce08:	04a5c83a 	sub	r18,zero,r18
8112ce0c:	07000b44 	movi	fp,45
8112ce10:	9004c03a 	cmpne	r2,r18,zero
8112ce14:	04e7c83a 	sub	r19,zero,r19
8112ce18:	df001d85 	stb	fp,118(sp)
8112ce1c:	98a7c83a 	sub	r19,r19,r2
8112ce20:	48009f16 	blt	r9,zero,8112d0a0 <___vfiprintf_internal_r+0x1340>
8112ce24:	00bfdfc4 	movi	r2,-129
8112ce28:	a0a8703a 	and	r20,r20,r2
8112ce2c:	003dd006 	br	8112c570 <__reset+0xfb10c570>
8112ce30:	70004c26 	beq	r14,zero,8112cf64 <___vfiprintf_internal_r+0x1204>
8112ce34:	00800084 	movi	r2,2
8112ce38:	d8c01d04 	addi	r3,sp,116
8112ce3c:	d8c00015 	stw	r3,0(sp)
8112ce40:	d8800115 	stw	r2,4(sp)
8112ce44:	01000044 	movi	r4,1
8112ce48:	d811883a 	mov	r8,sp
8112ce4c:	003f7306 	br	8112cc1c <__reset+0xfb10cc1c>
8112ce50:	a080100c 	andi	r2,r20,64
8112ce54:	da802217 	ldw	r10,136(sp)
8112ce58:	103e0626 	beq	r2,zero,8112c674 <__reset+0xfb10c674>
8112ce5c:	5480000f 	ldh	r18,0(r10)
8112ce60:	52800104 	addi	r10,r10,4
8112ce64:	da802215 	stw	r10,136(sp)
8112ce68:	9027d7fa 	srai	r19,r18,31
8112ce6c:	9805883a 	mov	r2,r19
8112ce70:	003db806 	br	8112c554 <__reset+0xfb10c554>
8112ce74:	a080040c 	andi	r2,r20,16
8112ce78:	1000091e 	bne	r2,zero,8112cea0 <___vfiprintf_internal_r+0x1140>
8112ce7c:	a2c0100c 	andi	r11,r20,64
8112ce80:	58000726 	beq	r11,zero,8112cea0 <___vfiprintf_internal_r+0x1140>
8112ce84:	da802217 	ldw	r10,136(sp)
8112ce88:	50800017 	ldw	r2,0(r10)
8112ce8c:	52800104 	addi	r10,r10,4
8112ce90:	da802215 	stw	r10,136(sp)
8112ce94:	da802317 	ldw	r10,140(sp)
8112ce98:	1280000d 	sth	r10,0(r2)
8112ce9c:	003be706 	br	8112be3c <__reset+0xfb10be3c>
8112cea0:	da802217 	ldw	r10,136(sp)
8112cea4:	50800017 	ldw	r2,0(r10)
8112cea8:	52800104 	addi	r10,r10,4
8112ceac:	da802215 	stw	r10,136(sp)
8112ceb0:	da802317 	ldw	r10,140(sp)
8112ceb4:	12800015 	stw	r10,0(r2)
8112ceb8:	003be006 	br	8112be3c <__reset+0xfb10be3c>
8112cebc:	a080100c 	andi	r2,r20,64
8112cec0:	da802217 	ldw	r10,136(sp)
8112cec4:	10003026 	beq	r2,zero,8112cf88 <___vfiprintf_internal_r+0x1228>
8112cec8:	5480000b 	ldhu	r18,0(r10)
8112cecc:	52800104 	addi	r10,r10,4
8112ced0:	0027883a 	mov	r19,zero
8112ced4:	da802215 	stw	r10,136(sp)
8112ced8:	003d8006 	br	8112c4dc <__reset+0xfb10c4dc>
8112cedc:	80c00007 	ldb	r3,0(r16)
8112cee0:	003c0006 	br	8112bee4 <__reset+0xfb10bee4>
8112cee4:	a080100c 	andi	r2,r20,64
8112cee8:	d8001d85 	stb	zero,118(sp)
8112ceec:	da802217 	ldw	r10,136(sp)
8112cef0:	1000201e 	bne	r2,zero,8112cf74 <___vfiprintf_internal_r+0x1214>
8112cef4:	50800104 	addi	r2,r10,4
8112cef8:	54800017 	ldw	r18,0(r10)
8112cefc:	0027883a 	mov	r19,zero
8112cf00:	483def0e 	bge	r9,zero,8112c6c0 <__reset+0xfb10c6c0>
8112cf04:	94c6b03a 	or	r3,r18,r19
8112cf08:	d8802215 	stw	r2,136(sp)
8112cf0c:	183d4e1e 	bne	r3,zero,8112c448 <__reset+0xfb10c448>
8112cf10:	0039883a 	mov	fp,zero
8112cf14:	0005883a 	mov	r2,zero
8112cf18:	003e0606 	br	8112c734 <__reset+0xfb10c734>
8112cf1c:	d9402117 	ldw	r5,132(sp)
8112cf20:	d9002017 	ldw	r4,128(sp)
8112cf24:	d9801a04 	addi	r6,sp,104
8112cf28:	da402c15 	stw	r9,176(sp)
8112cf2c:	db802a15 	stw	r14,168(sp)
8112cf30:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cf34:	da402c17 	ldw	r9,176(sp)
8112cf38:	db802a17 	ldw	r14,168(sp)
8112cf3c:	103ede1e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112cf40:	d9401b17 	ldw	r5,108(sp)
8112cf44:	d8801c17 	ldw	r2,112(sp)
8112cf48:	d811883a 	mov	r8,sp
8112cf4c:	29000044 	addi	r4,r5,1
8112cf50:	003e7406 	br	8112c924 <__reset+0xfb10c924>
8112cf54:	00bfffc4 	movi	r2,-1
8112cf58:	003c5806 	br	8112c0bc <__reset+0xfb10c0bc>
8112cf5c:	d811883a 	mov	r8,sp
8112cf60:	003ee806 	br	8112cb04 <__reset+0xfb10cb04>
8112cf64:	000b883a 	mov	r5,zero
8112cf68:	01000044 	movi	r4,1
8112cf6c:	d811883a 	mov	r8,sp
8112cf70:	003e7c06 	br	8112c964 <__reset+0xfb10c964>
8112cf74:	50800104 	addi	r2,r10,4
8112cf78:	5480000b 	ldhu	r18,0(r10)
8112cf7c:	0027883a 	mov	r19,zero
8112cf80:	483dcf0e 	bge	r9,zero,8112c6c0 <__reset+0xfb10c6c0>
8112cf84:	003fdf06 	br	8112cf04 <__reset+0xfb10cf04>
8112cf88:	54800017 	ldw	r18,0(r10)
8112cf8c:	52800104 	addi	r10,r10,4
8112cf90:	0027883a 	mov	r19,zero
8112cf94:	da802215 	stw	r10,136(sp)
8112cf98:	003d5006 	br	8112c4dc <__reset+0xfb10c4dc>
8112cf9c:	50800104 	addi	r2,r10,4
8112cfa0:	5480000b 	ldhu	r18,0(r10)
8112cfa4:	0027883a 	mov	r19,zero
8112cfa8:	483f7d0e 	bge	r9,zero,8112cda0 <__reset+0xfb10cda0>
8112cfac:	003ddc06 	br	8112c720 <__reset+0xfb10c720>
8112cfb0:	d8c02215 	stw	r3,136(sp)
8112cfb4:	0039883a 	mov	fp,zero
8112cfb8:	003ddb06 	br	8112c728 <__reset+0xfb10c728>
8112cfbc:	02a04574 	movhi	r10,33045
8112cfc0:	52abec04 	addi	r10,r10,-20560
8112cfc4:	da802415 	stw	r10,144(sp)
8112cfc8:	003e8306 	br	8112c9d8 <__reset+0xfb10c9d8>
8112cfcc:	d8801c17 	ldw	r2,112(sp)
8112cfd0:	dd002117 	ldw	r20,132(sp)
8112cfd4:	103eb926 	beq	r2,zero,8112cabc <__reset+0xfb10cabc>
8112cfd8:	d9002017 	ldw	r4,128(sp)
8112cfdc:	d9801a04 	addi	r6,sp,104
8112cfe0:	a00b883a 	mov	r5,r20
8112cfe4:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112cfe8:	003eb406 	br	8112cabc <__reset+0xfb10cabc>
8112cfec:	80c00043 	ldbu	r3,1(r16)
8112cff0:	a5000814 	ori	r20,r20,32
8112cff4:	84000044 	addi	r16,r16,1
8112cff8:	18c03fcc 	andi	r3,r3,255
8112cffc:	18c0201c 	xori	r3,r3,128
8112d000:	18ffe004 	addi	r3,r3,-128
8112d004:	003bb706 	br	8112bee4 <__reset+0xfb10bee4>
8112d008:	a809883a 	mov	r4,r21
8112d00c:	d8c02a15 	stw	r3,168(sp)
8112d010:	da002b15 	stw	r8,172(sp)
8112d014:	111d6400 	call	8111d640 <strlen>
8112d018:	d8c02a17 	ldw	r3,168(sp)
8112d01c:	1027883a 	mov	r19,r2
8112d020:	df001d83 	ldbu	fp,118(sp)
8112d024:	d8c02215 	stw	r3,136(sp)
8112d028:	0013883a 	mov	r9,zero
8112d02c:	da002b17 	ldw	r8,172(sp)
8112d030:	003c4d06 	br	8112c168 <__reset+0xfb10c168>
8112d034:	d9402117 	ldw	r5,132(sp)
8112d038:	d9002017 	ldw	r4,128(sp)
8112d03c:	d9801a04 	addi	r6,sp,104
8112d040:	da402c15 	stw	r9,176(sp)
8112d044:	112bc440 	call	8112bc44 <__sprint_r.part.0>
8112d048:	da402c17 	ldw	r9,176(sp)
8112d04c:	103e9a1e 	bne	r2,zero,8112cab8 <__reset+0xfb10cab8>
8112d050:	d9401b17 	ldw	r5,108(sp)
8112d054:	d8801c17 	ldw	r2,112(sp)
8112d058:	d811883a 	mov	r8,sp
8112d05c:	29000044 	addi	r4,r5,1
8112d060:	003e4206 	br	8112c96c <__reset+0xfb10c96c>
8112d064:	d9401b17 	ldw	r5,108(sp)
8112d068:	01204574 	movhi	r4,33045
8112d06c:	212bf004 	addi	r4,r4,-20544
8112d070:	d9002415 	stw	r4,144(sp)
8112d074:	29400044 	addi	r5,r5,1
8112d078:	003c6d06 	br	8112c230 <__reset+0xfb10c230>
8112d07c:	0039883a 	mov	fp,zero
8112d080:	00800084 	movi	r2,2
8112d084:	10803fcc 	andi	r2,r2,255
8112d088:	01000044 	movi	r4,1
8112d08c:	11001e26 	beq	r2,r4,8112d108 <___vfiprintf_internal_r+0x13a8>
8112d090:	01000084 	movi	r4,2
8112d094:	11001e1e 	bne	r2,r4,8112d110 <___vfiprintf_internal_r+0x13b0>
8112d098:	1829883a 	mov	r20,r3
8112d09c:	003eea06 	br	8112cc48 <__reset+0xfb10cc48>
8112d0a0:	a007883a 	mov	r3,r20
8112d0a4:	00800044 	movi	r2,1
8112d0a8:	003ff606 	br	8112d084 <__reset+0xfb10d084>
8112d0ac:	00800184 	movi	r2,6
8112d0b0:	1240012e 	bgeu	r2,r9,8112d0b8 <___vfiprintf_internal_r+0x1358>
8112d0b4:	1013883a 	mov	r9,r2
8112d0b8:	4827883a 	mov	r19,r9
8112d0bc:	4825883a 	mov	r18,r9
8112d0c0:	48001516 	blt	r9,zero,8112d118 <___vfiprintf_internal_r+0x13b8>
8112d0c4:	05604574 	movhi	r21,33045
8112d0c8:	d8c02215 	stw	r3,136(sp)
8112d0cc:	ad6b5f04 	addi	r21,r21,-21124
8112d0d0:	003d1406 	br	8112c524 <__reset+0xfb10c524>
8112d0d4:	02a04574 	movhi	r10,33045
8112d0d8:	52abec04 	addi	r10,r10,-20560
8112d0dc:	da802415 	stw	r10,144(sp)
8112d0e0:	200d883a 	mov	r6,r4
8112d0e4:	003c9106 	br	8112c32c <__reset+0xfb10c32c>
8112d0e8:	5021883a 	mov	r16,r10
8112d0ec:	0013883a 	mov	r9,zero
8112d0f0:	003b7d06 	br	8112bee8 <__reset+0xfb10bee8>
8112d0f4:	4827883a 	mov	r19,r9
8112d0f8:	df001d83 	ldbu	fp,118(sp)
8112d0fc:	d8c02215 	stw	r3,136(sp)
8112d100:	0013883a 	mov	r9,zero
8112d104:	003c1806 	br	8112c168 <__reset+0xfb10c168>
8112d108:	1829883a 	mov	r20,r3
8112d10c:	003d1806 	br	8112c570 <__reset+0xfb10c570>
8112d110:	1829883a 	mov	r20,r3
8112d114:	003ccd06 	br	8112c44c <__reset+0xfb10c44c>
8112d118:	0025883a 	mov	r18,zero
8112d11c:	003fe906 	br	8112d0c4 <__reset+0xfb10d0c4>
8112d120:	d8802217 	ldw	r2,136(sp)
8112d124:	80c00043 	ldbu	r3,1(r16)
8112d128:	5021883a 	mov	r16,r10
8112d12c:	12400017 	ldw	r9,0(r2)
8112d130:	10800104 	addi	r2,r2,4
8112d134:	d8802215 	stw	r2,136(sp)
8112d138:	483faf0e 	bge	r9,zero,8112cff8 <__reset+0xfb10cff8>
8112d13c:	18c03fcc 	andi	r3,r3,255
8112d140:	18c0201c 	xori	r3,r3,128
8112d144:	027fffc4 	movi	r9,-1
8112d148:	18ffe004 	addi	r3,r3,-128
8112d14c:	003b6506 	br	8112bee4 <__reset+0xfb10bee4>
8112d150:	d9c01d85 	stb	r7,118(sp)
8112d154:	003ca006 	br	8112c3d8 <__reset+0xfb10c3d8>
8112d158:	d9c01d85 	stb	r7,118(sp)
8112d15c:	003cad06 	br	8112c414 <__reset+0xfb10c414>
8112d160:	d9c01d85 	stb	r7,118(sp)
8112d164:	003d7d06 	br	8112c75c <__reset+0xfb10c75c>
8112d168:	d9c01d85 	stb	r7,118(sp)
8112d16c:	003d5f06 	br	8112c6ec <__reset+0xfb10c6ec>
8112d170:	a080004c 	andi	r2,r20,1
8112d174:	0039883a 	mov	fp,zero
8112d178:	10000526 	beq	r2,zero,8112d190 <___vfiprintf_internal_r+0x1430>
8112d17c:	00800c04 	movi	r2,48
8112d180:	d88019c5 	stb	r2,103(sp)
8112d184:	dcc02717 	ldw	r19,156(sp)
8112d188:	dd4019c4 	addi	r21,sp,103
8112d18c:	003bf606 	br	8112c168 <__reset+0xfb10c168>
8112d190:	0027883a 	mov	r19,zero
8112d194:	dd401a04 	addi	r21,sp,104
8112d198:	003bf306 	br	8112c168 <__reset+0xfb10c168>
8112d19c:	d9c01d85 	stb	r7,118(sp)
8112d1a0:	003dc806 	br	8112c8c4 <__reset+0xfb10c8c4>
8112d1a4:	d9c01d85 	stb	r7,118(sp)
8112d1a8:	003d3a06 	br	8112c694 <__reset+0xfb10c694>
8112d1ac:	d9c01d85 	stb	r7,118(sp)
8112d1b0:	003d2a06 	br	8112c65c <__reset+0xfb10c65c>
8112d1b4:	d9c01d85 	stb	r7,118(sp)
8112d1b8:	003cde06 	br	8112c534 <__reset+0xfb10c534>
8112d1bc:	d9c01d85 	stb	r7,118(sp)
8112d1c0:	003cbc06 	br	8112c4b4 <__reset+0xfb10c4b4>

8112d1c4 <__vfiprintf_internal>:
8112d1c4:	00a04574 	movhi	r2,33045
8112d1c8:	10b52904 	addi	r2,r2,-11100
8112d1cc:	300f883a 	mov	r7,r6
8112d1d0:	280d883a 	mov	r6,r5
8112d1d4:	200b883a 	mov	r5,r4
8112d1d8:	11000017 	ldw	r4,0(r2)
8112d1dc:	112bd601 	jmpi	8112bd60 <___vfiprintf_internal_r>

8112d1e0 <__sbprintf>:
8112d1e0:	defee204 	addi	sp,sp,-1144
8112d1e4:	de00012e 	bgeu	sp,et,8112d1ec <__sbprintf+0xc>
8112d1e8:	003b68fa 	trap	3
8112d1ec:	2880030b 	ldhu	r2,12(r5)
8112d1f0:	2ac01917 	ldw	r11,100(r5)
8112d1f4:	2a80038b 	ldhu	r10,14(r5)
8112d1f8:	2a400717 	ldw	r9,28(r5)
8112d1fc:	2a000917 	ldw	r8,36(r5)
8112d200:	00c10004 	movi	r3,1024
8112d204:	dc011a15 	stw	r16,1128(sp)
8112d208:	10bfff4c 	andi	r2,r2,65533
8112d20c:	2821883a 	mov	r16,r5
8112d210:	d8cb883a 	add	r5,sp,r3
8112d214:	dc811c15 	stw	r18,1136(sp)
8112d218:	dc411b15 	stw	r17,1132(sp)
8112d21c:	dfc11d15 	stw	ra,1140(sp)
8112d220:	2025883a 	mov	r18,r4
8112d224:	d881030d 	sth	r2,1036(sp)
8112d228:	dac11915 	stw	r11,1124(sp)
8112d22c:	da81038d 	sth	r10,1038(sp)
8112d230:	da410715 	stw	r9,1052(sp)
8112d234:	da010915 	stw	r8,1060(sp)
8112d238:	dec10015 	stw	sp,1024(sp)
8112d23c:	dec10415 	stw	sp,1040(sp)
8112d240:	d8c10215 	stw	r3,1032(sp)
8112d244:	d8c10515 	stw	r3,1044(sp)
8112d248:	d8010615 	stw	zero,1048(sp)
8112d24c:	112bd600 	call	8112bd60 <___vfiprintf_internal_r>
8112d250:	1023883a 	mov	r17,r2
8112d254:	10000416 	blt	r2,zero,8112d268 <__sbprintf+0x88>
8112d258:	d9410004 	addi	r5,sp,1024
8112d25c:	9009883a 	mov	r4,r18
8112d260:	11255180 	call	81125518 <_fflush_r>
8112d264:	10000d1e 	bne	r2,zero,8112d29c <__sbprintf+0xbc>
8112d268:	d881030b 	ldhu	r2,1036(sp)
8112d26c:	1080100c 	andi	r2,r2,64
8112d270:	10000326 	beq	r2,zero,8112d280 <__sbprintf+0xa0>
8112d274:	8080030b 	ldhu	r2,12(r16)
8112d278:	10801014 	ori	r2,r2,64
8112d27c:	8080030d 	sth	r2,12(r16)
8112d280:	8805883a 	mov	r2,r17
8112d284:	dfc11d17 	ldw	ra,1140(sp)
8112d288:	dc811c17 	ldw	r18,1136(sp)
8112d28c:	dc411b17 	ldw	r17,1132(sp)
8112d290:	dc011a17 	ldw	r16,1128(sp)
8112d294:	dec11e04 	addi	sp,sp,1144
8112d298:	f800283a 	ret
8112d29c:	047fffc4 	movi	r17,-1
8112d2a0:	003ff106 	br	8112d268 <__reset+0xfb10d268>

8112d2a4 <_calloc_r>:
8112d2a4:	298b383a 	mul	r5,r5,r6
8112d2a8:	defffe04 	addi	sp,sp,-8
8112d2ac:	de00012e 	bgeu	sp,et,8112d2b4 <_calloc_r+0x10>
8112d2b0:	003b68fa 	trap	3
8112d2b4:	dfc00115 	stw	ra,4(sp)
8112d2b8:	dc000015 	stw	r16,0(sp)
8112d2bc:	111c3380 	call	8111c338 <_malloc_r>
8112d2c0:	10002926 	beq	r2,zero,8112d368 <_calloc_r+0xc4>
8112d2c4:	11bfff17 	ldw	r6,-4(r2)
8112d2c8:	1021883a 	mov	r16,r2
8112d2cc:	00bfff04 	movi	r2,-4
8112d2d0:	308c703a 	and	r6,r6,r2
8112d2d4:	00c00904 	movi	r3,36
8112d2d8:	308d883a 	add	r6,r6,r2
8112d2dc:	19801636 	bltu	r3,r6,8112d338 <_calloc_r+0x94>
8112d2e0:	008004c4 	movi	r2,19
8112d2e4:	11800b2e 	bgeu	r2,r6,8112d314 <_calloc_r+0x70>
8112d2e8:	80000015 	stw	zero,0(r16)
8112d2ec:	80000115 	stw	zero,4(r16)
8112d2f0:	008006c4 	movi	r2,27
8112d2f4:	11801a2e 	bgeu	r2,r6,8112d360 <_calloc_r+0xbc>
8112d2f8:	80000215 	stw	zero,8(r16)
8112d2fc:	80000315 	stw	zero,12(r16)
8112d300:	30c0151e 	bne	r6,r3,8112d358 <_calloc_r+0xb4>
8112d304:	80000415 	stw	zero,16(r16)
8112d308:	80800604 	addi	r2,r16,24
8112d30c:	80000515 	stw	zero,20(r16)
8112d310:	00000106 	br	8112d318 <_calloc_r+0x74>
8112d314:	8005883a 	mov	r2,r16
8112d318:	10000015 	stw	zero,0(r2)
8112d31c:	10000115 	stw	zero,4(r2)
8112d320:	10000215 	stw	zero,8(r2)
8112d324:	8005883a 	mov	r2,r16
8112d328:	dfc00117 	ldw	ra,4(sp)
8112d32c:	dc000017 	ldw	r16,0(sp)
8112d330:	dec00204 	addi	sp,sp,8
8112d334:	f800283a 	ret
8112d338:	000b883a 	mov	r5,zero
8112d33c:	8009883a 	mov	r4,r16
8112d340:	111cc9c0 	call	8111cc9c <memset>
8112d344:	8005883a 	mov	r2,r16
8112d348:	dfc00117 	ldw	ra,4(sp)
8112d34c:	dc000017 	ldw	r16,0(sp)
8112d350:	dec00204 	addi	sp,sp,8
8112d354:	f800283a 	ret
8112d358:	80800404 	addi	r2,r16,16
8112d35c:	003fee06 	br	8112d318 <__reset+0xfb10d318>
8112d360:	80800204 	addi	r2,r16,8
8112d364:	003fec06 	br	8112d318 <__reset+0xfb10d318>
8112d368:	0005883a 	mov	r2,zero
8112d36c:	003fee06 	br	8112d328 <__reset+0xfb10d328>

8112d370 <_fclose_r>:
8112d370:	28003b26 	beq	r5,zero,8112d460 <_fclose_r+0xf0>
8112d374:	defffc04 	addi	sp,sp,-16
8112d378:	de00012e 	bgeu	sp,et,8112d380 <_fclose_r+0x10>
8112d37c:	003b68fa 	trap	3
8112d380:	dc400115 	stw	r17,4(sp)
8112d384:	dc000015 	stw	r16,0(sp)
8112d388:	dfc00315 	stw	ra,12(sp)
8112d38c:	dc800215 	stw	r18,8(sp)
8112d390:	2023883a 	mov	r17,r4
8112d394:	2821883a 	mov	r16,r5
8112d398:	20000226 	beq	r4,zero,8112d3a4 <_fclose_r+0x34>
8112d39c:	20800e17 	ldw	r2,56(r4)
8112d3a0:	10002726 	beq	r2,zero,8112d440 <_fclose_r+0xd0>
8112d3a4:	8080030f 	ldh	r2,12(r16)
8112d3a8:	1000071e 	bne	r2,zero,8112d3c8 <_fclose_r+0x58>
8112d3ac:	0005883a 	mov	r2,zero
8112d3b0:	dfc00317 	ldw	ra,12(sp)
8112d3b4:	dc800217 	ldw	r18,8(sp)
8112d3b8:	dc400117 	ldw	r17,4(sp)
8112d3bc:	dc000017 	ldw	r16,0(sp)
8112d3c0:	dec00404 	addi	sp,sp,16
8112d3c4:	f800283a 	ret
8112d3c8:	800b883a 	mov	r5,r16
8112d3cc:	8809883a 	mov	r4,r17
8112d3d0:	11252f40 	call	811252f4 <__sflush_r>
8112d3d4:	1025883a 	mov	r18,r2
8112d3d8:	80800b17 	ldw	r2,44(r16)
8112d3dc:	10000426 	beq	r2,zero,8112d3f0 <_fclose_r+0x80>
8112d3e0:	81400717 	ldw	r5,28(r16)
8112d3e4:	8809883a 	mov	r4,r17
8112d3e8:	103ee83a 	callr	r2
8112d3ec:	10001616 	blt	r2,zero,8112d448 <_fclose_r+0xd8>
8112d3f0:	8080030b 	ldhu	r2,12(r16)
8112d3f4:	1080200c 	andi	r2,r2,128
8112d3f8:	1000151e 	bne	r2,zero,8112d450 <_fclose_r+0xe0>
8112d3fc:	81400c17 	ldw	r5,48(r16)
8112d400:	28000526 	beq	r5,zero,8112d418 <_fclose_r+0xa8>
8112d404:	80801004 	addi	r2,r16,64
8112d408:	28800226 	beq	r5,r2,8112d414 <_fclose_r+0xa4>
8112d40c:	8809883a 	mov	r4,r17
8112d410:	1125dac0 	call	81125dac <_free_r>
8112d414:	80000c15 	stw	zero,48(r16)
8112d418:	81401117 	ldw	r5,68(r16)
8112d41c:	28000326 	beq	r5,zero,8112d42c <_fclose_r+0xbc>
8112d420:	8809883a 	mov	r4,r17
8112d424:	1125dac0 	call	81125dac <_free_r>
8112d428:	80001115 	stw	zero,68(r16)
8112d42c:	11259240 	call	81125924 <__sfp_lock_acquire>
8112d430:	8000030d 	sth	zero,12(r16)
8112d434:	11259280 	call	81125928 <__sfp_lock_release>
8112d438:	9005883a 	mov	r2,r18
8112d43c:	003fdc06 	br	8112d3b0 <__reset+0xfb10d3b0>
8112d440:	11259140 	call	81125914 <__sinit>
8112d444:	003fd706 	br	8112d3a4 <__reset+0xfb10d3a4>
8112d448:	04bfffc4 	movi	r18,-1
8112d44c:	003fe806 	br	8112d3f0 <__reset+0xfb10d3f0>
8112d450:	81400417 	ldw	r5,16(r16)
8112d454:	8809883a 	mov	r4,r17
8112d458:	1125dac0 	call	81125dac <_free_r>
8112d45c:	003fe706 	br	8112d3fc <__reset+0xfb10d3fc>
8112d460:	0005883a 	mov	r2,zero
8112d464:	f800283a 	ret

8112d468 <fclose>:
8112d468:	00a04574 	movhi	r2,33045
8112d46c:	10b52904 	addi	r2,r2,-11100
8112d470:	200b883a 	mov	r5,r4
8112d474:	11000017 	ldw	r4,0(r2)
8112d478:	112d3701 	jmpi	8112d370 <_fclose_r>

8112d47c <__fputwc>:
8112d47c:	defff804 	addi	sp,sp,-32
8112d480:	de00012e 	bgeu	sp,et,8112d488 <__fputwc+0xc>
8112d484:	003b68fa 	trap	3
8112d488:	dcc00415 	stw	r19,16(sp)
8112d48c:	dc800315 	stw	r18,12(sp)
8112d490:	dc000115 	stw	r16,4(sp)
8112d494:	dfc00715 	stw	ra,28(sp)
8112d498:	dd400615 	stw	r21,24(sp)
8112d49c:	dd000515 	stw	r20,20(sp)
8112d4a0:	dc400215 	stw	r17,8(sp)
8112d4a4:	2027883a 	mov	r19,r4
8112d4a8:	2825883a 	mov	r18,r5
8112d4ac:	3021883a 	mov	r16,r6
8112d4b0:	112683c0 	call	8112683c <__locale_mb_cur_max>
8112d4b4:	00c00044 	movi	r3,1
8112d4b8:	10c03e26 	beq	r2,r3,8112d5b4 <__fputwc+0x138>
8112d4bc:	81c01704 	addi	r7,r16,92
8112d4c0:	900d883a 	mov	r6,r18
8112d4c4:	d80b883a 	mov	r5,sp
8112d4c8:	9809883a 	mov	r4,r19
8112d4cc:	112e3000 	call	8112e300 <_wcrtomb_r>
8112d4d0:	1029883a 	mov	r20,r2
8112d4d4:	00bfffc4 	movi	r2,-1
8112d4d8:	a0802026 	beq	r20,r2,8112d55c <__fputwc+0xe0>
8112d4dc:	d9400003 	ldbu	r5,0(sp)
8112d4e0:	a0001c26 	beq	r20,zero,8112d554 <__fputwc+0xd8>
8112d4e4:	0023883a 	mov	r17,zero
8112d4e8:	05400284 	movi	r21,10
8112d4ec:	00000906 	br	8112d514 <__fputwc+0x98>
8112d4f0:	80800017 	ldw	r2,0(r16)
8112d4f4:	11400005 	stb	r5,0(r2)
8112d4f8:	80c00017 	ldw	r3,0(r16)
8112d4fc:	18c00044 	addi	r3,r3,1
8112d500:	80c00015 	stw	r3,0(r16)
8112d504:	8c400044 	addi	r17,r17,1
8112d508:	dc45883a 	add	r2,sp,r17
8112d50c:	8d00112e 	bgeu	r17,r20,8112d554 <__fputwc+0xd8>
8112d510:	11400003 	ldbu	r5,0(r2)
8112d514:	80c00217 	ldw	r3,8(r16)
8112d518:	18ffffc4 	addi	r3,r3,-1
8112d51c:	80c00215 	stw	r3,8(r16)
8112d520:	183ff30e 	bge	r3,zero,8112d4f0 <__reset+0xfb10d4f0>
8112d524:	80800617 	ldw	r2,24(r16)
8112d528:	18801916 	blt	r3,r2,8112d590 <__fputwc+0x114>
8112d52c:	80800017 	ldw	r2,0(r16)
8112d530:	11400005 	stb	r5,0(r2)
8112d534:	80800017 	ldw	r2,0(r16)
8112d538:	10c00003 	ldbu	r3,0(r2)
8112d53c:	10800044 	addi	r2,r2,1
8112d540:	1d402326 	beq	r3,r21,8112d5d0 <__fputwc+0x154>
8112d544:	80800015 	stw	r2,0(r16)
8112d548:	8c400044 	addi	r17,r17,1
8112d54c:	dc45883a 	add	r2,sp,r17
8112d550:	8d3fef36 	bltu	r17,r20,8112d510 <__reset+0xfb10d510>
8112d554:	9005883a 	mov	r2,r18
8112d558:	00000406 	br	8112d56c <__fputwc+0xf0>
8112d55c:	80c0030b 	ldhu	r3,12(r16)
8112d560:	a005883a 	mov	r2,r20
8112d564:	18c01014 	ori	r3,r3,64
8112d568:	80c0030d 	sth	r3,12(r16)
8112d56c:	dfc00717 	ldw	ra,28(sp)
8112d570:	dd400617 	ldw	r21,24(sp)
8112d574:	dd000517 	ldw	r20,20(sp)
8112d578:	dcc00417 	ldw	r19,16(sp)
8112d57c:	dc800317 	ldw	r18,12(sp)
8112d580:	dc400217 	ldw	r17,8(sp)
8112d584:	dc000117 	ldw	r16,4(sp)
8112d588:	dec00804 	addi	sp,sp,32
8112d58c:	f800283a 	ret
8112d590:	800d883a 	mov	r6,r16
8112d594:	29403fcc 	andi	r5,r5,255
8112d598:	9809883a 	mov	r4,r19
8112d59c:	11236dc0 	call	811236dc <__swbuf_r>
8112d5a0:	10bfffe0 	cmpeqi	r2,r2,-1
8112d5a4:	10803fcc 	andi	r2,r2,255
8112d5a8:	103fd626 	beq	r2,zero,8112d504 <__reset+0xfb10d504>
8112d5ac:	00bfffc4 	movi	r2,-1
8112d5b0:	003fee06 	br	8112d56c <__reset+0xfb10d56c>
8112d5b4:	90ffffc4 	addi	r3,r18,-1
8112d5b8:	01003f84 	movi	r4,254
8112d5bc:	20ffbf36 	bltu	r4,r3,8112d4bc <__reset+0xfb10d4bc>
8112d5c0:	900b883a 	mov	r5,r18
8112d5c4:	dc800005 	stb	r18,0(sp)
8112d5c8:	1029883a 	mov	r20,r2
8112d5cc:	003fc506 	br	8112d4e4 <__reset+0xfb10d4e4>
8112d5d0:	800d883a 	mov	r6,r16
8112d5d4:	a80b883a 	mov	r5,r21
8112d5d8:	9809883a 	mov	r4,r19
8112d5dc:	11236dc0 	call	811236dc <__swbuf_r>
8112d5e0:	10bfffe0 	cmpeqi	r2,r2,-1
8112d5e4:	003fef06 	br	8112d5a4 <__reset+0xfb10d5a4>

8112d5e8 <_fputwc_r>:
8112d5e8:	3080030b 	ldhu	r2,12(r6)
8112d5ec:	10c8000c 	andi	r3,r2,8192
8112d5f0:	1800051e 	bne	r3,zero,8112d608 <_fputwc_r+0x20>
8112d5f4:	30c01917 	ldw	r3,100(r6)
8112d5f8:	10880014 	ori	r2,r2,8192
8112d5fc:	3080030d 	sth	r2,12(r6)
8112d600:	18880014 	ori	r2,r3,8192
8112d604:	30801915 	stw	r2,100(r6)
8112d608:	112d47c1 	jmpi	8112d47c <__fputwc>

8112d60c <fputwc>:
8112d60c:	00a04574 	movhi	r2,33045
8112d610:	defffc04 	addi	sp,sp,-16
8112d614:	10b52904 	addi	r2,r2,-11100
8112d618:	de00012e 	bgeu	sp,et,8112d620 <fputwc+0x14>
8112d61c:	003b68fa 	trap	3
8112d620:	dc000115 	stw	r16,4(sp)
8112d624:	14000017 	ldw	r16,0(r2)
8112d628:	dc400215 	stw	r17,8(sp)
8112d62c:	dfc00315 	stw	ra,12(sp)
8112d630:	2023883a 	mov	r17,r4
8112d634:	80000226 	beq	r16,zero,8112d640 <fputwc+0x34>
8112d638:	80800e17 	ldw	r2,56(r16)
8112d63c:	10001026 	beq	r2,zero,8112d680 <fputwc+0x74>
8112d640:	2880030b 	ldhu	r2,12(r5)
8112d644:	10c8000c 	andi	r3,r2,8192
8112d648:	1800051e 	bne	r3,zero,8112d660 <fputwc+0x54>
8112d64c:	28c01917 	ldw	r3,100(r5)
8112d650:	10880014 	ori	r2,r2,8192
8112d654:	2880030d 	sth	r2,12(r5)
8112d658:	18880014 	ori	r2,r3,8192
8112d65c:	28801915 	stw	r2,100(r5)
8112d660:	280d883a 	mov	r6,r5
8112d664:	8009883a 	mov	r4,r16
8112d668:	880b883a 	mov	r5,r17
8112d66c:	dfc00317 	ldw	ra,12(sp)
8112d670:	dc400217 	ldw	r17,8(sp)
8112d674:	dc000117 	ldw	r16,4(sp)
8112d678:	dec00404 	addi	sp,sp,16
8112d67c:	112d47c1 	jmpi	8112d47c <__fputwc>
8112d680:	8009883a 	mov	r4,r16
8112d684:	d9400015 	stw	r5,0(sp)
8112d688:	11259140 	call	81125914 <__sinit>
8112d68c:	d9400017 	ldw	r5,0(sp)
8112d690:	003feb06 	br	8112d640 <__reset+0xfb10d640>

8112d694 <rshift>:
8112d694:	2807d17a 	srai	r3,r5,5
8112d698:	20800417 	ldw	r2,16(r4)
8112d69c:	22000504 	addi	r8,r4,20
8112d6a0:	1880250e 	bge	r3,r2,8112d738 <rshift+0xa4>
8112d6a4:	1085883a 	add	r2,r2,r2
8112d6a8:	18c7883a 	add	r3,r3,r3
8112d6ac:	1085883a 	add	r2,r2,r2
8112d6b0:	18c7883a 	add	r3,r3,r3
8112d6b4:	294007cc 	andi	r5,r5,31
8112d6b8:	4085883a 	add	r2,r8,r2
8112d6bc:	40c7883a 	add	r3,r8,r3
8112d6c0:	28002026 	beq	r5,zero,8112d744 <rshift+0xb0>
8112d6c4:	19800017 	ldw	r6,0(r3)
8112d6c8:	02c00804 	movi	r11,32
8112d6cc:	19c00104 	addi	r7,r3,4
8112d6d0:	5957c83a 	sub	r11,r11,r5
8112d6d4:	314cd83a 	srl	r6,r6,r5
8112d6d8:	38802c2e 	bgeu	r7,r2,8112d78c <rshift+0xf8>
8112d6dc:	4015883a 	mov	r10,r8
8112d6e0:	3a400017 	ldw	r9,0(r7)
8112d6e4:	52800104 	addi	r10,r10,4
8112d6e8:	39c00104 	addi	r7,r7,4
8112d6ec:	4ad2983a 	sll	r9,r9,r11
8112d6f0:	498cb03a 	or	r6,r9,r6
8112d6f4:	51bfff15 	stw	r6,-4(r10)
8112d6f8:	39bfff17 	ldw	r6,-4(r7)
8112d6fc:	314cd83a 	srl	r6,r6,r5
8112d700:	38bff736 	bltu	r7,r2,8112d6e0 <__reset+0xfb10d6e0>
8112d704:	10c7c83a 	sub	r3,r2,r3
8112d708:	18fffec4 	addi	r3,r3,-5
8112d70c:	1806d0ba 	srli	r3,r3,2
8112d710:	18c00044 	addi	r3,r3,1
8112d714:	18c7883a 	add	r3,r3,r3
8112d718:	18c7883a 	add	r3,r3,r3
8112d71c:	40c7883a 	add	r3,r8,r3
8112d720:	19800015 	stw	r6,0(r3)
8112d724:	30000126 	beq	r6,zero,8112d72c <rshift+0x98>
8112d728:	18c00104 	addi	r3,r3,4
8112d72c:	1a05c83a 	sub	r2,r3,r8
8112d730:	1005d0ba 	srai	r2,r2,2
8112d734:	00001206 	br	8112d780 <rshift+0xec>
8112d738:	20000415 	stw	zero,16(r4)
8112d73c:	20000515 	stw	zero,20(r4)
8112d740:	f800283a 	ret
8112d744:	18bffc2e 	bgeu	r3,r2,8112d738 <__reset+0xfb10d738>
8112d748:	180d883a 	mov	r6,r3
8112d74c:	400b883a 	mov	r5,r8
8112d750:	31c00017 	ldw	r7,0(r6)
8112d754:	29400104 	addi	r5,r5,4
8112d758:	31800104 	addi	r6,r6,4
8112d75c:	29ffff15 	stw	r7,-4(r5)
8112d760:	30bffb36 	bltu	r6,r2,8112d750 <__reset+0xfb10d750>
8112d764:	00c6303a 	nor	r3,zero,r3
8112d768:	1885883a 	add	r2,r3,r2
8112d76c:	1004d0ba 	srli	r2,r2,2
8112d770:	10800044 	addi	r2,r2,1
8112d774:	1085883a 	add	r2,r2,r2
8112d778:	1085883a 	add	r2,r2,r2
8112d77c:	1005d0ba 	srai	r2,r2,2
8112d780:	20800415 	stw	r2,16(r4)
8112d784:	103fed26 	beq	r2,zero,8112d73c <__reset+0xfb10d73c>
8112d788:	f800283a 	ret
8112d78c:	4007883a 	mov	r3,r8
8112d790:	003fe306 	br	8112d720 <__reset+0xfb10d720>

8112d794 <__gethex>:
8112d794:	deffeb04 	addi	sp,sp,-84
8112d798:	de00012e 	bgeu	sp,et,8112d7a0 <__gethex+0xc>
8112d79c:	003b68fa 	trap	3
8112d7a0:	dfc01415 	stw	ra,80(sp)
8112d7a4:	dd801115 	stw	r22,68(sp)
8112d7a8:	dcc00e15 	stw	r19,56(sp)
8112d7ac:	dc800d15 	stw	r18,52(sp)
8112d7b0:	2827883a 	mov	r19,r5
8112d7b4:	d9000115 	stw	r4,4(sp)
8112d7b8:	d9800015 	stw	r6,0(sp)
8112d7bc:	d9c00415 	stw	r7,16(sp)
8112d7c0:	df001315 	stw	fp,76(sp)
8112d7c4:	ddc01215 	stw	r23,72(sp)
8112d7c8:	dd401015 	stw	r21,64(sp)
8112d7cc:	dd000f15 	stw	r20,60(sp)
8112d7d0:	dc400c15 	stw	r17,48(sp)
8112d7d4:	dc000b15 	stw	r16,44(sp)
8112d7d8:	11268600 	call	81126860 <_localeconv_r>
8112d7dc:	14800017 	ldw	r18,0(r2)
8112d7e0:	9009883a 	mov	r4,r18
8112d7e4:	111d6400 	call	8111d640 <strlen>
8112d7e8:	98c00017 	ldw	r3,0(r19)
8112d7ec:	102d883a 	mov	r22,r2
8112d7f0:	9085883a 	add	r2,r18,r2
8112d7f4:	10bfffc3 	ldbu	r2,-1(r2)
8112d7f8:	19000083 	ldbu	r4,2(r3)
8112d7fc:	d8800305 	stb	r2,12(sp)
8112d800:	00800c04 	movi	r2,48
8112d804:	2081521e 	bne	r4,r2,8112dd50 <__gethex+0x5bc>
8112d808:	017fff84 	movi	r5,-2
8112d80c:	188000c4 	addi	r2,r3,3
8112d810:	28cbc83a 	sub	r5,r5,r3
8112d814:	200d883a 	mov	r6,r4
8112d818:	28a3883a 	add	r17,r5,r2
8112d81c:	102b883a 	mov	r21,r2
8112d820:	10800044 	addi	r2,r2,1
8112d824:	113fffc3 	ldbu	r4,-1(r2)
8112d828:	21bffb26 	beq	r4,r6,8112d818 <__reset+0xfb10d818>
8112d82c:	05204574 	movhi	r20,33045
8112d830:	a52bf404 	addi	r20,r20,-20528
8112d834:	a109883a 	add	r4,r20,r4
8112d838:	20800003 	ldbu	r2,0(r4)
8112d83c:	10008826 	beq	r2,zero,8112da60 <__gethex+0x2cc>
8112d840:	a8800003 	ldbu	r2,0(r21)
8112d844:	0015883a 	mov	r10,zero
8112d848:	002f883a 	mov	r23,zero
8112d84c:	a085883a 	add	r2,r20,r2
8112d850:	10800003 	ldbu	r2,0(r2)
8112d854:	a821883a 	mov	r16,r21
8112d858:	10000526 	beq	r2,zero,8112d870 <__gethex+0xdc>
8112d85c:	84000044 	addi	r16,r16,1
8112d860:	80800003 	ldbu	r2,0(r16)
8112d864:	a085883a 	add	r2,r20,r2
8112d868:	10800003 	ldbu	r2,0(r2)
8112d86c:	103ffb1e 	bne	r2,zero,8112d85c <__reset+0xfb10d85c>
8112d870:	b00d883a 	mov	r6,r22
8112d874:	900b883a 	mov	r5,r18
8112d878:	8009883a 	mov	r4,r16
8112d87c:	da800a15 	stw	r10,40(sp)
8112d880:	112e2300 	call	8112e230 <strncmp>
8112d884:	da800a17 	ldw	r10,40(sp)
8112d888:	1000031e 	bne	r2,zero,8112d898 <__gethex+0x104>
8112d88c:	b8015226 	beq	r23,zero,8112ddd8 <__gethex+0x644>
8112d890:	80800003 	ldbu	r2,0(r16)
8112d894:	00000206 	br	8112d8a0 <__gethex+0x10c>
8112d898:	80800003 	ldbu	r2,0(r16)
8112d89c:	b8011f26 	beq	r23,zero,8112dd1c <__gethex+0x588>
8112d8a0:	85efc83a 	sub	r23,r16,r23
8112d8a4:	bdef883a 	add	r23,r23,r23
8112d8a8:	bdef883a 	add	r23,r23,r23
8112d8ac:	05efc83a 	sub	r23,zero,r23
8112d8b0:	10803fcc 	andi	r2,r2,255
8112d8b4:	01001404 	movi	r4,80
8112d8b8:	11008626 	beq	r2,r4,8112dad4 <__gethex+0x340>
8112d8bc:	01001c04 	movi	r4,112
8112d8c0:	11008426 	beq	r2,r4,8112dad4 <__gethex+0x340>
8112d8c4:	8039883a 	mov	fp,r16
8112d8c8:	9c000015 	stw	r16,0(r19)
8112d8cc:	5000711e 	bne	r10,zero,8112da94 <__gethex+0x300>
8112d8d0:	e545c83a 	sub	r2,fp,r21
8112d8d4:	10bfffc4 	addi	r2,r2,-1
8112d8d8:	010001c4 	movi	r4,7
8112d8dc:	000b883a 	mov	r5,zero
8112d8e0:	2080030e 	bge	r4,r2,8112d8f0 <__gethex+0x15c>
8112d8e4:	1005d07a 	srai	r2,r2,1
8112d8e8:	29400044 	addi	r5,r5,1
8112d8ec:	20bffd16 	blt	r4,r2,8112d8e4 <__reset+0xfb10d8e4>
8112d8f0:	d9000117 	ldw	r4,4(sp)
8112d8f4:	1126d7c0 	call	81126d7c <_Balloc>
8112d8f8:	10c00504 	addi	r3,r2,20
8112d8fc:	d8c00215 	stw	r3,8(sp)
8112d900:	1021883a 	mov	r16,r2
8112d904:	af01732e 	bgeu	r21,fp,8112ded4 <__gethex+0x740>
8112d908:	dc400303 	ldbu	r17,12(sp)
8112d90c:	03400044 	movi	r13,1
8112d910:	1815883a 	mov	r10,r3
8112d914:	0013883a 	mov	r9,zero
8112d918:	0027883a 	mov	r19,zero
8112d91c:	6d9bc83a 	sub	r13,r13,r22
8112d920:	02c00804 	movi	r11,32
8112d924:	e0bfffc3 	ldbu	r2,-1(fp)
8112d928:	e3bfffc4 	addi	r14,fp,-1
8112d92c:	88803026 	beq	r17,r2,8112d9f0 <__gethex+0x25c>
8112d930:	9ac04526 	beq	r19,r11,8112da48 <__gethex+0x2b4>
8112d934:	980b883a 	mov	r5,r19
8112d938:	9cc00104 	addi	r19,r19,4
8112d93c:	e13fffc3 	ldbu	r4,-1(fp)
8112d940:	7039883a 	mov	fp,r14
8112d944:	a109883a 	add	r4,r20,r4
8112d948:	20800003 	ldbu	r2,0(r4)
8112d94c:	108003cc 	andi	r2,r2,15
8112d950:	1144983a 	sll	r2,r2,r5
8112d954:	4892b03a 	or	r9,r9,r2
8112d958:	af3ff236 	bltu	r21,fp,8112d924 <__reset+0xfb10d924>
8112d95c:	d8c00217 	ldw	r3,8(sp)
8112d960:	50800104 	addi	r2,r10,4
8112d964:	52400015 	stw	r9,0(r10)
8112d968:	10c5c83a 	sub	r2,r2,r3
8112d96c:	1005d0ba 	srai	r2,r2,2
8112d970:	4809883a 	mov	r4,r9
8112d974:	80800415 	stw	r2,16(r16)
8112d978:	1022917a 	slli	r17,r2,5
8112d97c:	11270880 	call	81127088 <__hi0bits>
8112d980:	d8c00017 	ldw	r3,0(sp)
8112d984:	8885c83a 	sub	r2,r17,r2
8112d988:	1c800017 	ldw	r18,0(r3)
8112d98c:	9080c716 	blt	r18,r2,8112dcac <__gethex+0x518>
8112d990:	1480e416 	blt	r2,r18,8112dd24 <__gethex+0x590>
8112d994:	0027883a 	mov	r19,zero
8112d998:	d8c00017 	ldw	r3,0(sp)
8112d99c:	18800217 	ldw	r2,8(r3)
8112d9a0:	15c08d16 	blt	r2,r23,8112dbd8 <__gethex+0x444>
8112d9a4:	d8c00017 	ldw	r3,0(sp)
8112d9a8:	18800117 	ldw	r2,4(r3)
8112d9ac:	b880aa0e 	bge	r23,r2,8112dc58 <__gethex+0x4c4>
8112d9b0:	15efc83a 	sub	r23,r2,r23
8112d9b4:	bc80ed16 	blt	r23,r18,8112dd6c <__gethex+0x5d8>
8112d9b8:	18c00317 	ldw	r3,12(r3)
8112d9bc:	01000084 	movi	r4,2
8112d9c0:	19014926 	beq	r3,r4,8112dee8 <__gethex+0x754>
8112d9c4:	010000c4 	movi	r4,3
8112d9c8:	19012e26 	beq	r3,r4,8112de84 <__gethex+0x6f0>
8112d9cc:	01000044 	movi	r4,1
8112d9d0:	19014826 	beq	r3,r4,8112def4 <__gethex+0x760>
8112d9d4:	d9000117 	ldw	r4,4(sp)
8112d9d8:	800b883a 	mov	r5,r16
8112d9dc:	1126e2c0 	call	81126e2c <_Bfree>
8112d9e0:	d8801517 	ldw	r2,84(sp)
8112d9e4:	10000015 	stw	zero,0(r2)
8112d9e8:	00801404 	movi	r2,80
8112d9ec:	00002b06 	br	8112da9c <__gethex+0x308>
8112d9f0:	735f883a 	add	r15,r14,r13
8112d9f4:	7d7fce36 	bltu	r15,r21,8112d930 <__reset+0xfb10d930>
8112d9f8:	7809883a 	mov	r4,r15
8112d9fc:	b00d883a 	mov	r6,r22
8112da00:	900b883a 	mov	r5,r18
8112da04:	da400515 	stw	r9,20(sp)
8112da08:	da800a15 	stw	r10,40(sp)
8112da0c:	dac00915 	stw	r11,36(sp)
8112da10:	db400815 	stw	r13,32(sp)
8112da14:	db800615 	stw	r14,24(sp)
8112da18:	dbc00715 	stw	r15,28(sp)
8112da1c:	112e2300 	call	8112e230 <strncmp>
8112da20:	da400517 	ldw	r9,20(sp)
8112da24:	da800a17 	ldw	r10,40(sp)
8112da28:	dac00917 	ldw	r11,36(sp)
8112da2c:	db400817 	ldw	r13,32(sp)
8112da30:	db800617 	ldw	r14,24(sp)
8112da34:	dbc00717 	ldw	r15,28(sp)
8112da38:	103fbd1e 	bne	r2,zero,8112d930 <__reset+0xfb10d930>
8112da3c:	7839883a 	mov	fp,r15
8112da40:	af3fb836 	bltu	r21,fp,8112d924 <__reset+0xfb10d924>
8112da44:	003fc506 	br	8112d95c <__reset+0xfb10d95c>
8112da48:	04c00104 	movi	r19,4
8112da4c:	52400015 	stw	r9,0(r10)
8112da50:	000b883a 	mov	r5,zero
8112da54:	54d5883a 	add	r10,r10,r19
8112da58:	0013883a 	mov	r9,zero
8112da5c:	003fb706 	br	8112d93c <__reset+0xfb10d93c>
8112da60:	b00d883a 	mov	r6,r22
8112da64:	900b883a 	mov	r5,r18
8112da68:	a809883a 	mov	r4,r21
8112da6c:	112e2300 	call	8112e230 <strncmp>
8112da70:	10006426 	beq	r2,zero,8112dc04 <__gethex+0x470>
8112da74:	a8800003 	ldbu	r2,0(r21)
8112da78:	a821883a 	mov	r16,r21
8112da7c:	10803fcc 	andi	r2,r2,255
8112da80:	01001404 	movi	r4,80
8112da84:	11001126 	beq	r2,r4,8112dacc <__gethex+0x338>
8112da88:	01001c04 	movi	r4,112
8112da8c:	11000f26 	beq	r2,r4,8112dacc <__gethex+0x338>
8112da90:	9c000015 	stw	r16,0(r19)
8112da94:	8800831e 	bne	r17,zero,8112dca4 <__gethex+0x510>
8112da98:	00800184 	movi	r2,6
8112da9c:	dfc01417 	ldw	ra,80(sp)
8112daa0:	df001317 	ldw	fp,76(sp)
8112daa4:	ddc01217 	ldw	r23,72(sp)
8112daa8:	dd801117 	ldw	r22,68(sp)
8112daac:	dd401017 	ldw	r21,64(sp)
8112dab0:	dd000f17 	ldw	r20,60(sp)
8112dab4:	dcc00e17 	ldw	r19,56(sp)
8112dab8:	dc800d17 	ldw	r18,52(sp)
8112dabc:	dc400c17 	ldw	r17,48(sp)
8112dac0:	dc000b17 	ldw	r16,44(sp)
8112dac4:	dec01504 	addi	sp,sp,84
8112dac8:	f800283a 	ret
8112dacc:	002f883a 	mov	r23,zero
8112dad0:	02800044 	movi	r10,1
8112dad4:	80800043 	ldbu	r2,1(r16)
8112dad8:	01400ac4 	movi	r5,43
8112dadc:	11003fcc 	andi	r4,r2,255
8112dae0:	21406e26 	beq	r4,r5,8112dc9c <__gethex+0x508>
8112dae4:	01400b44 	movi	r5,45
8112dae8:	21404226 	beq	r4,r5,8112dbf4 <__gethex+0x460>
8112daec:	81400044 	addi	r5,r16,1
8112daf0:	000d883a 	mov	r6,zero
8112daf4:	10803fcc 	andi	r2,r2,255
8112daf8:	a085883a 	add	r2,r20,r2
8112dafc:	11000003 	ldbu	r4,0(r2)
8112db00:	03000604 	movi	r12,24
8112db04:	20bfffc4 	addi	r2,r4,-1
8112db08:	10803fcc 	andi	r2,r2,255
8112db0c:	60bf6d36 	bltu	r12,r2,8112d8c4 <__reset+0xfb10d8c4>
8112db10:	2ac00043 	ldbu	r11,1(r5)
8112db14:	20803fcc 	andi	r2,r4,255
8112db18:	01204574 	movhi	r4,33045
8112db1c:	212bf404 	addi	r4,r4,-20528
8112db20:	22c9883a 	add	r4,r4,r11
8112db24:	23400003 	ldbu	r13,0(r4)
8112db28:	10bffc04 	addi	r2,r2,-16
8112db2c:	29400044 	addi	r5,r5,1
8112db30:	693fffc4 	addi	r4,r13,-1
8112db34:	21003fcc 	andi	r4,r4,255
8112db38:	6b403fcc 	andi	r13,r13,255
8112db3c:	61000b36 	bltu	r12,r4,8112db6c <__gethex+0x3d8>
8112db40:	29400044 	addi	r5,r5,1
8112db44:	29000003 	ldbu	r4,0(r5)
8112db48:	108002a4 	muli	r2,r2,10
8112db4c:	a109883a 	add	r4,r20,r4
8112db50:	22c00003 	ldbu	r11,0(r4)
8112db54:	1345883a 	add	r2,r2,r13
8112db58:	10bffc04 	addi	r2,r2,-16
8112db5c:	593fffc4 	addi	r4,r11,-1
8112db60:	21003fcc 	andi	r4,r4,255
8112db64:	5b403fcc 	andi	r13,r11,255
8112db68:	613ff52e 	bgeu	r12,r4,8112db40 <__reset+0xfb10db40>
8112db6c:	30000126 	beq	r6,zero,8112db74 <__gethex+0x3e0>
8112db70:	0085c83a 	sub	r2,zero,r2
8112db74:	8039883a 	mov	fp,r16
8112db78:	b8af883a 	add	r23,r23,r2
8112db7c:	2821883a 	mov	r16,r5
8112db80:	003f5106 	br	8112d8c8 <__reset+0xfb10d8c8>
8112db84:	80800217 	ldw	r2,8(r16)
8112db88:	e080f00e 	bge	fp,r2,8112df4c <__gethex+0x7b8>
8112db8c:	e007883a 	mov	r3,fp
8112db90:	18800144 	addi	r2,r3,5
8112db94:	1085883a 	add	r2,r2,r2
8112db98:	18c00044 	addi	r3,r3,1
8112db9c:	1085883a 	add	r2,r2,r2
8112dba0:	8085883a 	add	r2,r16,r2
8112dba4:	80c00415 	stw	r3,16(r16)
8112dba8:	01000044 	movi	r4,1
8112dbac:	11000015 	stw	r4,0(r2)
8112dbb0:	00800084 	movi	r2,2
8112dbb4:	8880d826 	beq	r17,r2,8112df18 <__gethex+0x784>
8112dbb8:	e0c0ac0e 	bge	fp,r3,8112de6c <__gethex+0x6d8>
8112dbbc:	01400044 	movi	r5,1
8112dbc0:	8009883a 	mov	r4,r16
8112dbc4:	112d6940 	call	8112d694 <rshift>
8112dbc8:	d8c00017 	ldw	r3,0(sp)
8112dbcc:	bdc00044 	addi	r23,r23,1
8112dbd0:	18800217 	ldw	r2,8(r3)
8112dbd4:	15c0a70e 	bge	r2,r23,8112de74 <__gethex+0x6e0>
8112dbd8:	d9000117 	ldw	r4,4(sp)
8112dbdc:	800b883a 	mov	r5,r16
8112dbe0:	1126e2c0 	call	81126e2c <_Bfree>
8112dbe4:	d9001517 	ldw	r4,84(sp)
8112dbe8:	008028c4 	movi	r2,163
8112dbec:	20000015 	stw	zero,0(r4)
8112dbf0:	003faa06 	br	8112da9c <__reset+0xfb10da9c>
8112dbf4:	01800044 	movi	r6,1
8112dbf8:	80800083 	ldbu	r2,2(r16)
8112dbfc:	81400084 	addi	r5,r16,2
8112dc00:	003fbc06 	br	8112daf4 <__reset+0xfb10daf4>
8112dc04:	ada1883a 	add	r16,r21,r22
8112dc08:	81000003 	ldbu	r4,0(r16)
8112dc0c:	21403fcc 	andi	r5,r4,255
8112dc10:	a145883a 	add	r2,r20,r5
8112dc14:	10800003 	ldbu	r2,0(r2)
8112dc18:	11803fcc 	andi	r6,r2,255
8112dc1c:	30004f26 	beq	r6,zero,8112dd5c <__gethex+0x5c8>
8112dc20:	00c00c04 	movi	r3,48
8112dc24:	802b883a 	mov	r21,r16
8112dc28:	28c0061e 	bne	r5,r3,8112dc44 <__gethex+0x4b0>
8112dc2c:	2809883a 	mov	r4,r5
8112dc30:	ad400044 	addi	r21,r21,1
8112dc34:	a8800003 	ldbu	r2,0(r21)
8112dc38:	113ffd26 	beq	r2,r4,8112dc30 <__reset+0xfb10dc30>
8112dc3c:	a085883a 	add	r2,r20,r2
8112dc40:	10800003 	ldbu	r2,0(r2)
8112dc44:	10803fcc 	andi	r2,r2,255
8112dc48:	1015003a 	cmpeq	r10,r2,zero
8112dc4c:	802f883a 	mov	r23,r16
8112dc50:	04400044 	movi	r17,1
8112dc54:	003eff06 	br	8112d854 <__reset+0xfb10d854>
8112dc58:	04400044 	movi	r17,1
8112dc5c:	98000926 	beq	r19,zero,8112dc84 <__gethex+0x4f0>
8112dc60:	d8c00017 	ldw	r3,0(sp)
8112dc64:	18800317 	ldw	r2,12(r3)
8112dc68:	00c00084 	movi	r3,2
8112dc6c:	10c06826 	beq	r2,r3,8112de10 <__gethex+0x67c>
8112dc70:	00c000c4 	movi	r3,3
8112dc74:	10c06a26 	beq	r2,r3,8112de20 <__gethex+0x68c>
8112dc78:	00c00044 	movi	r3,1
8112dc7c:	10c08d26 	beq	r2,r3,8112deb4 <__gethex+0x720>
8112dc80:	8c400414 	ori	r17,r17,16
8112dc84:	d9001517 	ldw	r4,84(sp)
8112dc88:	d8c00417 	ldw	r3,16(sp)
8112dc8c:	8805883a 	mov	r2,r17
8112dc90:	24000015 	stw	r16,0(r4)
8112dc94:	1dc00015 	stw	r23,0(r3)
8112dc98:	003f8006 	br	8112da9c <__reset+0xfb10da9c>
8112dc9c:	000d883a 	mov	r6,zero
8112dca0:	003fd506 	br	8112dbf8 <__reset+0xfb10dbf8>
8112dca4:	0005883a 	mov	r2,zero
8112dca8:	003f7c06 	br	8112da9c <__reset+0xfb10da9c>
8112dcac:	14a3c83a 	sub	r17,r2,r18
8112dcb0:	880b883a 	mov	r5,r17
8112dcb4:	8009883a 	mov	r4,r16
8112dcb8:	1127d4c0 	call	81127d4c <__any_on>
8112dcbc:	10002926 	beq	r2,zero,8112dd64 <__gethex+0x5d0>
8112dcc0:	897fffc4 	addi	r5,r17,-1
8112dcc4:	2807d17a 	srai	r3,r5,5
8112dcc8:	d8800217 	ldw	r2,8(sp)
8112dccc:	290007cc 	andi	r4,r5,31
8112dcd0:	18c7883a 	add	r3,r3,r3
8112dcd4:	18c7883a 	add	r3,r3,r3
8112dcd8:	04c00044 	movi	r19,1
8112dcdc:	10c7883a 	add	r3,r2,r3
8112dce0:	9908983a 	sll	r4,r19,r4
8112dce4:	18c00017 	ldw	r3,0(r3)
8112dce8:	20c6703a 	and	r3,r4,r3
8112dcec:	18000626 	beq	r3,zero,8112dd08 <__gethex+0x574>
8112dcf0:	99407b0e 	bge	r19,r5,8112dee0 <__gethex+0x74c>
8112dcf4:	897fff84 	addi	r5,r17,-2
8112dcf8:	8009883a 	mov	r4,r16
8112dcfc:	1127d4c0 	call	81127d4c <__any_on>
8112dd00:	10007726 	beq	r2,zero,8112dee0 <__gethex+0x74c>
8112dd04:	04c000c4 	movi	r19,3
8112dd08:	880b883a 	mov	r5,r17
8112dd0c:	8009883a 	mov	r4,r16
8112dd10:	112d6940 	call	8112d694 <rshift>
8112dd14:	bc6f883a 	add	r23,r23,r17
8112dd18:	003f1f06 	br	8112d998 <__reset+0xfb10d998>
8112dd1c:	002f883a 	mov	r23,zero
8112dd20:	003ee306 	br	8112d8b0 <__reset+0xfb10d8b0>
8112dd24:	d9000117 	ldw	r4,4(sp)
8112dd28:	90a3c83a 	sub	r17,r18,r2
8112dd2c:	800b883a 	mov	r5,r16
8112dd30:	880d883a 	mov	r6,r17
8112dd34:	112752c0 	call	8112752c <__lshift>
8112dd38:	10c00504 	addi	r3,r2,20
8112dd3c:	1021883a 	mov	r16,r2
8112dd40:	bc6fc83a 	sub	r23,r23,r17
8112dd44:	d8c00215 	stw	r3,8(sp)
8112dd48:	0027883a 	mov	r19,zero
8112dd4c:	003f1206 	br	8112d998 <__reset+0xfb10d998>
8112dd50:	1d400084 	addi	r21,r3,2
8112dd54:	0023883a 	mov	r17,zero
8112dd58:	003eb406 	br	8112d82c <__reset+0xfb10d82c>
8112dd5c:	2005883a 	mov	r2,r4
8112dd60:	003f4606 	br	8112da7c <__reset+0xfb10da7c>
8112dd64:	0027883a 	mov	r19,zero
8112dd68:	003fe706 	br	8112dd08 <__reset+0xfb10dd08>
8112dd6c:	bc7fffc4 	addi	r17,r23,-1
8112dd70:	9800421e 	bne	r19,zero,8112de7c <__gethex+0x6e8>
8112dd74:	88000426 	beq	r17,zero,8112dd88 <__gethex+0x5f4>
8112dd78:	880b883a 	mov	r5,r17
8112dd7c:	8009883a 	mov	r4,r16
8112dd80:	1127d4c0 	call	81127d4c <__any_on>
8112dd84:	1027883a 	mov	r19,r2
8112dd88:	8805d17a 	srai	r2,r17,5
8112dd8c:	d8c00217 	ldw	r3,8(sp)
8112dd90:	8c4007cc 	andi	r17,r17,31
8112dd94:	1085883a 	add	r2,r2,r2
8112dd98:	1085883a 	add	r2,r2,r2
8112dd9c:	1885883a 	add	r2,r3,r2
8112dda0:	00c00044 	movi	r3,1
8112dda4:	1c62983a 	sll	r17,r3,r17
8112dda8:	10800017 	ldw	r2,0(r2)
8112ddac:	8884703a 	and	r2,r17,r2
8112ddb0:	10000126 	beq	r2,zero,8112ddb8 <__gethex+0x624>
8112ddb4:	9cc00094 	ori	r19,r19,2
8112ddb8:	b80b883a 	mov	r5,r23
8112ddbc:	8009883a 	mov	r4,r16
8112ddc0:	112d6940 	call	8112d694 <rshift>
8112ddc4:	d8c00017 	ldw	r3,0(sp)
8112ddc8:	95e5c83a 	sub	r18,r18,r23
8112ddcc:	04400084 	movi	r17,2
8112ddd0:	1dc00117 	ldw	r23,4(r3)
8112ddd4:	003fa106 	br	8112dc5c <__reset+0xfb10dc5c>
8112ddd8:	85af883a 	add	r23,r16,r22
8112dddc:	b8800003 	ldbu	r2,0(r23)
8112dde0:	b821883a 	mov	r16,r23
8112dde4:	11003fcc 	andi	r4,r2,255
8112dde8:	a109883a 	add	r4,r20,r4
8112ddec:	21000003 	ldbu	r4,0(r4)
8112ddf0:	203eaa26 	beq	r4,zero,8112d89c <__reset+0xfb10d89c>
8112ddf4:	84000044 	addi	r16,r16,1
8112ddf8:	80800003 	ldbu	r2,0(r16)
8112ddfc:	11003fcc 	andi	r4,r2,255
8112de00:	a109883a 	add	r4,r20,r4
8112de04:	21000003 	ldbu	r4,0(r4)
8112de08:	203ffa1e 	bne	r4,zero,8112ddf4 <__reset+0xfb10ddf4>
8112de0c:	003ea306 	br	8112d89c <__reset+0xfb10d89c>
8112de10:	d9001617 	ldw	r4,88(sp)
8112de14:	00800044 	movi	r2,1
8112de18:	1109c83a 	sub	r4,r2,r4
8112de1c:	d9001615 	stw	r4,88(sp)
8112de20:	d8801617 	ldw	r2,88(sp)
8112de24:	103f9626 	beq	r2,zero,8112dc80 <__reset+0xfb10dc80>
8112de28:	87000417 	ldw	fp,16(r16)
8112de2c:	d9800217 	ldw	r6,8(sp)
8112de30:	013fffc4 	movi	r4,-1
8112de34:	e727883a 	add	r19,fp,fp
8112de38:	9ce7883a 	add	r19,r19,r19
8112de3c:	3005883a 	mov	r2,r6
8112de40:	34cb883a 	add	r5,r6,r19
8112de44:	00000306 	br	8112de54 <__gethex+0x6c0>
8112de48:	10000015 	stw	zero,0(r2)
8112de4c:	10800104 	addi	r2,r2,4
8112de50:	117f4c2e 	bgeu	r2,r5,8112db84 <__reset+0xfb10db84>
8112de54:	10c00017 	ldw	r3,0(r2)
8112de58:	193ffb26 	beq	r3,r4,8112de48 <__reset+0xfb10de48>
8112de5c:	18c00044 	addi	r3,r3,1
8112de60:	10c00015 	stw	r3,0(r2)
8112de64:	00800084 	movi	r2,2
8112de68:	88802b26 	beq	r17,r2,8112df18 <__gethex+0x784>
8112de6c:	948007cc 	andi	r18,r18,31
8112de70:	90002f1e 	bne	r18,zero,8112df30 <__gethex+0x79c>
8112de74:	04400844 	movi	r17,33
8112de78:	003f8206 	br	8112dc84 <__reset+0xfb10dc84>
8112de7c:	04c00044 	movi	r19,1
8112de80:	003fc106 	br	8112dd88 <__reset+0xfb10dd88>
8112de84:	d8c01617 	ldw	r3,88(sp)
8112de88:	183ed226 	beq	r3,zero,8112d9d4 <__reset+0xfb10d9d4>
8112de8c:	d8c00417 	ldw	r3,16(sp)
8112de90:	d9001517 	ldw	r4,84(sp)
8112de94:	18800015 	stw	r2,0(r3)
8112de98:	d8c00217 	ldw	r3,8(sp)
8112de9c:	00800044 	movi	r2,1
8112dea0:	80800415 	stw	r2,16(r16)
8112dea4:	18800015 	stw	r2,0(r3)
8112dea8:	24000015 	stw	r16,0(r4)
8112deac:	00801884 	movi	r2,98
8112deb0:	003efa06 	br	8112da9c <__reset+0xfb10da9c>
8112deb4:	9880008c 	andi	r2,r19,2
8112deb8:	103f7126 	beq	r2,zero,8112dc80 <__reset+0xfb10dc80>
8112debc:	d8c00217 	ldw	r3,8(sp)
8112dec0:	18800017 	ldw	r2,0(r3)
8112dec4:	9884b03a 	or	r2,r19,r2
8112dec8:	1080004c 	andi	r2,r2,1
8112decc:	103fd61e 	bne	r2,zero,8112de28 <__reset+0xfb10de28>
8112ded0:	003f6b06 	br	8112dc80 <__reset+0xfb10dc80>
8112ded4:	da800217 	ldw	r10,8(sp)
8112ded8:	0013883a 	mov	r9,zero
8112dedc:	003e9f06 	br	8112d95c <__reset+0xfb10d95c>
8112dee0:	04c00084 	movi	r19,2
8112dee4:	003f8806 	br	8112dd08 <__reset+0xfb10dd08>
8112dee8:	d9001617 	ldw	r4,88(sp)
8112deec:	203fe726 	beq	r4,zero,8112de8c <__reset+0xfb10de8c>
8112def0:	003eb806 	br	8112d9d4 <__reset+0xfb10d9d4>
8112def4:	95feb71e 	bne	r18,r23,8112d9d4 <__reset+0xfb10d9d4>
8112def8:	1cbfe40e 	bge	r3,r18,8112de8c <__reset+0xfb10de8c>
8112defc:	917fffc4 	addi	r5,r18,-1
8112df00:	8009883a 	mov	r4,r16
8112df04:	1127d4c0 	call	81127d4c <__any_on>
8112df08:	103eb226 	beq	r2,zero,8112d9d4 <__reset+0xfb10d9d4>
8112df0c:	d8c00017 	ldw	r3,0(sp)
8112df10:	18800117 	ldw	r2,4(r3)
8112df14:	003fdd06 	br	8112de8c <__reset+0xfb10de8c>
8112df18:	d8c00017 	ldw	r3,0(sp)
8112df1c:	18800017 	ldw	r2,0(r3)
8112df20:	10bfffc4 	addi	r2,r2,-1
8112df24:	90801c26 	beq	r18,r2,8112df98 <__gethex+0x804>
8112df28:	04400884 	movi	r17,34
8112df2c:	003f5506 	br	8112dc84 <__reset+0xfb10dc84>
8112df30:	34c5883a 	add	r2,r6,r19
8112df34:	113fff17 	ldw	r4,-4(r2)
8112df38:	11270880 	call	81127088 <__hi0bits>
8112df3c:	00c00804 	movi	r3,32
8112df40:	1ca5c83a 	sub	r18,r3,r18
8112df44:	14bfcb0e 	bge	r2,r18,8112de74 <__reset+0xfb10de74>
8112df48:	003f1c06 	br	8112dbbc <__reset+0xfb10dbbc>
8112df4c:	81400117 	ldw	r5,4(r16)
8112df50:	d9000117 	ldw	r4,4(sp)
8112df54:	29400044 	addi	r5,r5,1
8112df58:	1126d7c0 	call	81126d7c <_Balloc>
8112df5c:	81800417 	ldw	r6,16(r16)
8112df60:	81400304 	addi	r5,r16,12
8112df64:	11000304 	addi	r4,r2,12
8112df68:	31800084 	addi	r6,r6,2
8112df6c:	318d883a 	add	r6,r6,r6
8112df70:	318d883a 	add	r6,r6,r6
8112df74:	1029883a 	mov	r20,r2
8112df78:	111cb4c0 	call	8111cb4c <memcpy>
8112df7c:	d9000117 	ldw	r4,4(sp)
8112df80:	800b883a 	mov	r5,r16
8112df84:	a021883a 	mov	r16,r20
8112df88:	1126e2c0 	call	81126e2c <_Bfree>
8112df8c:	a0c00417 	ldw	r3,16(r20)
8112df90:	a1800504 	addi	r6,r20,20
8112df94:	003efe06 	br	8112db90 <__reset+0xfb10db90>
8112df98:	9005d17a 	srai	r2,r18,5
8112df9c:	944007cc 	andi	r17,r18,31
8112dfa0:	1085883a 	add	r2,r2,r2
8112dfa4:	1085883a 	add	r2,r2,r2
8112dfa8:	3087883a 	add	r3,r6,r2
8112dfac:	00800044 	movi	r2,1
8112dfb0:	1462983a 	sll	r17,r2,r17
8112dfb4:	18800017 	ldw	r2,0(r3)
8112dfb8:	8884703a 	and	r2,r17,r2
8112dfbc:	1022c03a 	cmpne	r17,r2,zero
8112dfc0:	00800884 	movi	r2,34
8112dfc4:	1463c83a 	sub	r17,r2,r17
8112dfc8:	003f2e06 	br	8112dc84 <__reset+0xfb10dc84>

8112dfcc <__hexnan>:
8112dfcc:	defff904 	addi	sp,sp,-28
8112dfd0:	de00012e 	bgeu	sp,et,8112dfd8 <__hexnan+0xc>
8112dfd4:	003b68fa 	trap	3
8112dfd8:	dc800215 	stw	r18,8(sp)
8112dfdc:	2c800017 	ldw	r18,0(r5)
8112dfe0:	dfc00615 	stw	ra,24(sp)
8112dfe4:	dd400515 	stw	r21,20(sp)
8112dfe8:	901fd17a 	srai	r15,r18,5
8112dfec:	dd000415 	stw	r20,16(sp)
8112dff0:	dcc00315 	stw	r19,12(sp)
8112dff4:	7bdf883a 	add	r15,r15,r15
8112dff8:	7bdf883a 	add	r15,r15,r15
8112dffc:	dc400115 	stw	r17,4(sp)
8112e000:	dc000015 	stw	r16,0(sp)
8112e004:	948007cc 	andi	r18,r18,31
8112e008:	33df883a 	add	r15,r6,r15
8112e00c:	90000126 	beq	r18,zero,8112e014 <__hexnan+0x48>
8112e010:	7bc00104 	addi	r15,r15,4
8112e014:	22000017 	ldw	r8,0(r4)
8112e018:	7affff04 	addi	r11,r15,-4
8112e01c:	03a04574 	movhi	r14,33045
8112e020:	783fff15 	stw	zero,-4(r15)
8112e024:	581b883a 	mov	r13,r11
8112e028:	580b883a 	mov	r5,r11
8112e02c:	000f883a 	mov	r7,zero
8112e030:	003f883a 	mov	ra,zero
8112e034:	0019883a 	mov	r12,zero
8112e038:	73abf404 	addi	r14,r14,-20528
8112e03c:	04400204 	movi	r17,8
8112e040:	04000804 	movi	r16,32
8112e044:	04c001c4 	movi	r19,7
8112e048:	42000044 	addi	r8,r8,1
8112e04c:	40c00003 	ldbu	r3,0(r8)
8112e050:	18001d26 	beq	r3,zero,8112e0c8 <__hexnan+0xfc>
8112e054:	70c5883a 	add	r2,r14,r3
8112e058:	10800003 	ldbu	r2,0(r2)
8112e05c:	12403fcc 	andi	r9,r2,255
8112e060:	4800301e 	bne	r9,zero,8112e124 <__hexnan+0x158>
8112e064:	80c04236 	bltu	r16,r3,8112e170 <__hexnan+0x1a4>
8112e068:	fb3ff70e 	bge	ra,r12,8112e048 <__reset+0xfb10e048>
8112e06c:	2b40112e 	bgeu	r5,r13,8112e0b4 <__hexnan+0xe8>
8112e070:	99c01016 	blt	r19,r7,8112e0b4 <__hexnan+0xe8>
8112e074:	89e9c83a 	sub	r20,r17,r7
8112e078:	a529883a 	add	r20,r20,r20
8112e07c:	2a800017 	ldw	r10,0(r5)
8112e080:	a529883a 	add	r20,r20,r20
8112e084:	852bc83a 	sub	r21,r16,r20
8112e088:	28c00104 	addi	r3,r5,4
8112e08c:	2805883a 	mov	r2,r5
8112e090:	19c00017 	ldw	r7,0(r3)
8112e094:	10800104 	addi	r2,r2,4
8112e098:	18c00104 	addi	r3,r3,4
8112e09c:	3d52983a 	sll	r9,r7,r21
8112e0a0:	4a92b03a 	or	r9,r9,r10
8112e0a4:	3d14d83a 	srl	r10,r7,r20
8112e0a8:	127fff15 	stw	r9,-4(r2)
8112e0ac:	1abfff15 	stw	r10,-4(r3)
8112e0b0:	137ff736 	bltu	r2,r13,8112e090 <__reset+0xfb10e090>
8112e0b4:	31402836 	bltu	r6,r5,8112e158 <__hexnan+0x18c>
8112e0b8:	42000044 	addi	r8,r8,1
8112e0bc:	40c00003 	ldbu	r3,0(r8)
8112e0c0:	01c00204 	movi	r7,8
8112e0c4:	183fe31e 	bne	r3,zero,8112e054 <__reset+0xfb10e054>
8112e0c8:	60002b26 	beq	r12,zero,8112e178 <__hexnan+0x1ac>
8112e0cc:	2b40022e 	bgeu	r5,r13,8112e0d8 <__hexnan+0x10c>
8112e0d0:	008001c4 	movi	r2,7
8112e0d4:	11c0430e 	bge	r2,r7,8112e1e4 <__hexnan+0x218>
8112e0d8:	3140312e 	bgeu	r6,r5,8112e1a0 <__hexnan+0x1d4>
8112e0dc:	3007883a 	mov	r3,r6
8112e0e0:	29000017 	ldw	r4,0(r5)
8112e0e4:	18800104 	addi	r2,r3,4
8112e0e8:	29400104 	addi	r5,r5,4
8112e0ec:	19000015 	stw	r4,0(r3)
8112e0f0:	1007883a 	mov	r3,r2
8112e0f4:	597ffa2e 	bgeu	r11,r5,8112e0e0 <__reset+0xfb10e0e0>
8112e0f8:	10000015 	stw	zero,0(r2)
8112e0fc:	10800104 	addi	r2,r2,4
8112e100:	58bffd2e 	bgeu	r11,r2,8112e0f8 <__reset+0xfb10e0f8>
8112e104:	78bfff17 	ldw	r2,-4(r15)
8112e108:	1000041e 	bne	r2,zero,8112e11c <__hexnan+0x150>
8112e10c:	32c02d26 	beq	r6,r11,8112e1c4 <__hexnan+0x1f8>
8112e110:	5affff04 	addi	r11,r11,-4
8112e114:	58800017 	ldw	r2,0(r11)
8112e118:	103ffc26 	beq	r2,zero,8112e10c <__reset+0xfb10e10c>
8112e11c:	00800144 	movi	r2,5
8112e120:	00001606 	br	8112e17c <__hexnan+0x1b0>
8112e124:	39c00044 	addi	r7,r7,1
8112e128:	63000044 	addi	r12,r12,1
8112e12c:	89c0040e 	bge	r17,r7,8112e140 <__hexnan+0x174>
8112e130:	317fc52e 	bgeu	r6,r5,8112e048 <__reset+0xfb10e048>
8112e134:	283fff15 	stw	zero,-4(r5)
8112e138:	01c00044 	movi	r7,1
8112e13c:	297fff04 	addi	r5,r5,-4
8112e140:	28c00017 	ldw	r3,0(r5)
8112e144:	108003cc 	andi	r2,r2,15
8112e148:	1806913a 	slli	r3,r3,4
8112e14c:	1884b03a 	or	r2,r3,r2
8112e150:	28800015 	stw	r2,0(r5)
8112e154:	003fbc06 	br	8112e048 <__reset+0xfb10e048>
8112e158:	2b7fff04 	addi	r13,r5,-4
8112e15c:	283fff15 	stw	zero,-4(r5)
8112e160:	603f883a 	mov	ra,r12
8112e164:	680b883a 	mov	r5,r13
8112e168:	000f883a 	mov	r7,zero
8112e16c:	003fb606 	br	8112e048 <__reset+0xfb10e048>
8112e170:	00800a44 	movi	r2,41
8112e174:	18801726 	beq	r3,r2,8112e1d4 <__hexnan+0x208>
8112e178:	00800104 	movi	r2,4
8112e17c:	dfc00617 	ldw	ra,24(sp)
8112e180:	dd400517 	ldw	r21,20(sp)
8112e184:	dd000417 	ldw	r20,16(sp)
8112e188:	dcc00317 	ldw	r19,12(sp)
8112e18c:	dc800217 	ldw	r18,8(sp)
8112e190:	dc400117 	ldw	r17,4(sp)
8112e194:	dc000017 	ldw	r16,0(sp)
8112e198:	dec00704 	addi	sp,sp,28
8112e19c:	f800283a 	ret
8112e1a0:	903fd826 	beq	r18,zero,8112e104 <__reset+0xfb10e104>
8112e1a4:	00c00804 	movi	r3,32
8112e1a8:	1ca5c83a 	sub	r18,r3,r18
8112e1ac:	00ffffc4 	movi	r3,-1
8112e1b0:	78bfff17 	ldw	r2,-4(r15)
8112e1b4:	1c86d83a 	srl	r3,r3,r18
8112e1b8:	1884703a 	and	r2,r3,r2
8112e1bc:	78bfff15 	stw	r2,-4(r15)
8112e1c0:	003fd106 	br	8112e108 <__reset+0xfb10e108>
8112e1c4:	00800044 	movi	r2,1
8112e1c8:	58800015 	stw	r2,0(r11)
8112e1cc:	00800144 	movi	r2,5
8112e1d0:	003fea06 	br	8112e17c <__reset+0xfb10e17c>
8112e1d4:	42000044 	addi	r8,r8,1
8112e1d8:	22000015 	stw	r8,0(r4)
8112e1dc:	603fbb1e 	bne	r12,zero,8112e0cc <__reset+0xfb10e0cc>
8112e1e0:	003fe506 	br	8112e178 <__reset+0xfb10e178>
8112e1e4:	02400204 	movi	r9,8
8112e1e8:	49d3c83a 	sub	r9,r9,r7
8112e1ec:	4a53883a 	add	r9,r9,r9
8112e1f0:	2a000017 	ldw	r8,0(r5)
8112e1f4:	4a53883a 	add	r9,r9,r9
8112e1f8:	02800804 	movi	r10,32
8112e1fc:	5255c83a 	sub	r10,r10,r9
8112e200:	28c00104 	addi	r3,r5,4
8112e204:	2805883a 	mov	r2,r5
8112e208:	19c00017 	ldw	r7,0(r3)
8112e20c:	10800104 	addi	r2,r2,4
8112e210:	18c00104 	addi	r3,r3,4
8112e214:	3a88983a 	sll	r4,r7,r10
8112e218:	2208b03a 	or	r4,r4,r8
8112e21c:	3a50d83a 	srl	r8,r7,r9
8112e220:	113fff15 	stw	r4,-4(r2)
8112e224:	1a3fff15 	stw	r8,-4(r3)
8112e228:	137ff736 	bltu	r2,r13,8112e208 <__reset+0xfb10e208>
8112e22c:	003faa06 	br	8112e0d8 <__reset+0xfb10e0d8>

8112e230 <strncmp>:
8112e230:	30003126 	beq	r6,zero,8112e2f8 <strncmp+0xc8>
8112e234:	2144b03a 	or	r2,r4,r5
8112e238:	108000cc 	andi	r2,r2,3
8112e23c:	10001e1e 	bne	r2,zero,8112e2b8 <strncmp+0x88>
8112e240:	024000c4 	movi	r9,3
8112e244:	49801c2e 	bgeu	r9,r6,8112e2b8 <strncmp+0x88>
8112e248:	20800017 	ldw	r2,0(r4)
8112e24c:	28c00017 	ldw	r3,0(r5)
8112e250:	10c0191e 	bne	r2,r3,8112e2b8 <strncmp+0x88>
8112e254:	31bfff04 	addi	r6,r6,-4
8112e258:	30002726 	beq	r6,zero,8112e2f8 <strncmp+0xc8>
8112e25c:	02ffbff4 	movhi	r11,65279
8112e260:	5affbfc4 	addi	r11,r11,-257
8112e264:	0086303a 	nor	r3,zero,r2
8112e268:	02a02074 	movhi	r10,32897
8112e26c:	12c5883a 	add	r2,r2,r11
8112e270:	52a02004 	addi	r10,r10,-32640
8112e274:	10c4703a 	and	r2,r2,r3
8112e278:	1284703a 	and	r2,r2,r10
8112e27c:	10000b26 	beq	r2,zero,8112e2ac <strncmp+0x7c>
8112e280:	00001d06 	br	8112e2f8 <strncmp+0xc8>
8112e284:	20c00017 	ldw	r3,0(r4)
8112e288:	29c00017 	ldw	r7,0(r5)
8112e28c:	1ad1883a 	add	r8,r3,r11
8112e290:	00c4303a 	nor	r2,zero,r3
8112e294:	4084703a 	and	r2,r8,r2
8112e298:	1284703a 	and	r2,r2,r10
8112e29c:	19c0061e 	bne	r3,r7,8112e2b8 <strncmp+0x88>
8112e2a0:	31bfff04 	addi	r6,r6,-4
8112e2a4:	30001426 	beq	r6,zero,8112e2f8 <strncmp+0xc8>
8112e2a8:	1000131e 	bne	r2,zero,8112e2f8 <strncmp+0xc8>
8112e2ac:	21000104 	addi	r4,r4,4
8112e2b0:	29400104 	addi	r5,r5,4
8112e2b4:	49bff336 	bltu	r9,r6,8112e284 <__reset+0xfb10e284>
8112e2b8:	28800007 	ldb	r2,0(r5)
8112e2bc:	20c00007 	ldb	r3,0(r4)
8112e2c0:	31bfffc4 	addi	r6,r6,-1
8112e2c4:	10c0081e 	bne	r2,r3,8112e2e8 <strncmp+0xb8>
8112e2c8:	30000b26 	beq	r6,zero,8112e2f8 <strncmp+0xc8>
8112e2cc:	10000a26 	beq	r2,zero,8112e2f8 <strncmp+0xc8>
8112e2d0:	21000044 	addi	r4,r4,1
8112e2d4:	29400044 	addi	r5,r5,1
8112e2d8:	20800007 	ldb	r2,0(r4)
8112e2dc:	28c00007 	ldb	r3,0(r5)
8112e2e0:	31bfffc4 	addi	r6,r6,-1
8112e2e4:	10fff826 	beq	r2,r3,8112e2c8 <__reset+0xfb10e2c8>
8112e2e8:	20800003 	ldbu	r2,0(r4)
8112e2ec:	28c00003 	ldbu	r3,0(r5)
8112e2f0:	10c5c83a 	sub	r2,r2,r3
8112e2f4:	f800283a 	ret
8112e2f8:	0005883a 	mov	r2,zero
8112e2fc:	f800283a 	ret

8112e300 <_wcrtomb_r>:
8112e300:	defff604 	addi	sp,sp,-40
8112e304:	00a04574 	movhi	r2,33045
8112e308:	de00012e 	bgeu	sp,et,8112e310 <_wcrtomb_r+0x10>
8112e30c:	003b68fa 	trap	3
8112e310:	10b52e04 	addi	r2,r2,-11080
8112e314:	dc800815 	stw	r18,32(sp)
8112e318:	dc400715 	stw	r17,28(sp)
8112e31c:	dc000615 	stw	r16,24(sp)
8112e320:	dfc00915 	stw	ra,36(sp)
8112e324:	2021883a 	mov	r16,r4
8112e328:	3823883a 	mov	r17,r7
8112e32c:	14800017 	ldw	r18,0(r2)
8112e330:	28001426 	beq	r5,zero,8112e384 <_wcrtomb_r+0x84>
8112e334:	d9400415 	stw	r5,16(sp)
8112e338:	d9800515 	stw	r6,20(sp)
8112e33c:	11268300 	call	81126830 <__locale_charset>
8112e340:	d9800517 	ldw	r6,20(sp)
8112e344:	d9400417 	ldw	r5,16(sp)
8112e348:	100f883a 	mov	r7,r2
8112e34c:	dc400015 	stw	r17,0(sp)
8112e350:	8009883a 	mov	r4,r16
8112e354:	903ee83a 	callr	r18
8112e358:	00ffffc4 	movi	r3,-1
8112e35c:	10c0031e 	bne	r2,r3,8112e36c <_wcrtomb_r+0x6c>
8112e360:	88000015 	stw	zero,0(r17)
8112e364:	00c02284 	movi	r3,138
8112e368:	80c00015 	stw	r3,0(r16)
8112e36c:	dfc00917 	ldw	ra,36(sp)
8112e370:	dc800817 	ldw	r18,32(sp)
8112e374:	dc400717 	ldw	r17,28(sp)
8112e378:	dc000617 	ldw	r16,24(sp)
8112e37c:	dec00a04 	addi	sp,sp,40
8112e380:	f800283a 	ret
8112e384:	11268300 	call	81126830 <__locale_charset>
8112e388:	100f883a 	mov	r7,r2
8112e38c:	dc400015 	stw	r17,0(sp)
8112e390:	000d883a 	mov	r6,zero
8112e394:	d9400104 	addi	r5,sp,4
8112e398:	8009883a 	mov	r4,r16
8112e39c:	903ee83a 	callr	r18
8112e3a0:	003fed06 	br	8112e358 <__reset+0xfb10e358>

8112e3a4 <wcrtomb>:
8112e3a4:	defff604 	addi	sp,sp,-40
8112e3a8:	00a04574 	movhi	r2,33045
8112e3ac:	de00012e 	bgeu	sp,et,8112e3b4 <wcrtomb+0x10>
8112e3b0:	003b68fa 	trap	3
8112e3b4:	10b52904 	addi	r2,r2,-11100
8112e3b8:	dc800615 	stw	r18,24(sp)
8112e3bc:	dc400515 	stw	r17,20(sp)
8112e3c0:	dfc00915 	stw	ra,36(sp)
8112e3c4:	dd000815 	stw	r20,32(sp)
8112e3c8:	dcc00715 	stw	r19,28(sp)
8112e3cc:	dc000415 	stw	r16,16(sp)
8112e3d0:	3025883a 	mov	r18,r6
8112e3d4:	14400017 	ldw	r17,0(r2)
8112e3d8:	20001926 	beq	r4,zero,8112e440 <wcrtomb+0x9c>
8112e3dc:	00a04574 	movhi	r2,33045
8112e3e0:	10b52e04 	addi	r2,r2,-11080
8112e3e4:	15000017 	ldw	r20,0(r2)
8112e3e8:	2021883a 	mov	r16,r4
8112e3ec:	2827883a 	mov	r19,r5
8112e3f0:	11268300 	call	81126830 <__locale_charset>
8112e3f4:	100f883a 	mov	r7,r2
8112e3f8:	dc800015 	stw	r18,0(sp)
8112e3fc:	980d883a 	mov	r6,r19
8112e400:	800b883a 	mov	r5,r16
8112e404:	8809883a 	mov	r4,r17
8112e408:	a03ee83a 	callr	r20
8112e40c:	00ffffc4 	movi	r3,-1
8112e410:	10c0031e 	bne	r2,r3,8112e420 <wcrtomb+0x7c>
8112e414:	90000015 	stw	zero,0(r18)
8112e418:	00c02284 	movi	r3,138
8112e41c:	88c00015 	stw	r3,0(r17)
8112e420:	dfc00917 	ldw	ra,36(sp)
8112e424:	dd000817 	ldw	r20,32(sp)
8112e428:	dcc00717 	ldw	r19,28(sp)
8112e42c:	dc800617 	ldw	r18,24(sp)
8112e430:	dc400517 	ldw	r17,20(sp)
8112e434:	dc000417 	ldw	r16,16(sp)
8112e438:	dec00a04 	addi	sp,sp,40
8112e43c:	f800283a 	ret
8112e440:	00a04574 	movhi	r2,33045
8112e444:	10b52e04 	addi	r2,r2,-11080
8112e448:	14000017 	ldw	r16,0(r2)
8112e44c:	11268300 	call	81126830 <__locale_charset>
8112e450:	100f883a 	mov	r7,r2
8112e454:	dc800015 	stw	r18,0(sp)
8112e458:	000d883a 	mov	r6,zero
8112e45c:	d9400104 	addi	r5,sp,4
8112e460:	8809883a 	mov	r4,r17
8112e464:	803ee83a 	callr	r16
8112e468:	003fe806 	br	8112e40c <__reset+0xfb10e40c>

8112e46c <__ascii_wctomb>:
8112e46c:	28000526 	beq	r5,zero,8112e484 <__ascii_wctomb+0x18>
8112e470:	00803fc4 	movi	r2,255
8112e474:	11800536 	bltu	r2,r6,8112e48c <__ascii_wctomb+0x20>
8112e478:	29800005 	stb	r6,0(r5)
8112e47c:	00800044 	movi	r2,1
8112e480:	f800283a 	ret
8112e484:	0005883a 	mov	r2,zero
8112e488:	f800283a 	ret
8112e48c:	00802284 	movi	r2,138
8112e490:	20800015 	stw	r2,0(r4)
8112e494:	00bfffc4 	movi	r2,-1
8112e498:	f800283a 	ret

8112e49c <_wctomb_r>:
8112e49c:	00a04574 	movhi	r2,33045
8112e4a0:	defff904 	addi	sp,sp,-28
8112e4a4:	10b52e04 	addi	r2,r2,-11080
8112e4a8:	de00012e 	bgeu	sp,et,8112e4b0 <_wctomb_r+0x14>
8112e4ac:	003b68fa 	trap	3
8112e4b0:	dfc00615 	stw	ra,24(sp)
8112e4b4:	dc400515 	stw	r17,20(sp)
8112e4b8:	dc000415 	stw	r16,16(sp)
8112e4bc:	3823883a 	mov	r17,r7
8112e4c0:	14000017 	ldw	r16,0(r2)
8112e4c4:	d9000115 	stw	r4,4(sp)
8112e4c8:	d9400215 	stw	r5,8(sp)
8112e4cc:	d9800315 	stw	r6,12(sp)
8112e4d0:	11268300 	call	81126830 <__locale_charset>
8112e4d4:	d9800317 	ldw	r6,12(sp)
8112e4d8:	d9400217 	ldw	r5,8(sp)
8112e4dc:	d9000117 	ldw	r4,4(sp)
8112e4e0:	100f883a 	mov	r7,r2
8112e4e4:	dc400015 	stw	r17,0(sp)
8112e4e8:	803ee83a 	callr	r16
8112e4ec:	dfc00617 	ldw	ra,24(sp)
8112e4f0:	dc400517 	ldw	r17,20(sp)
8112e4f4:	dc000417 	ldw	r16,16(sp)
8112e4f8:	dec00704 	addi	sp,sp,28
8112e4fc:	f800283a 	ret

8112e500 <__fixunsdfsi>:
8112e500:	defffd04 	addi	sp,sp,-12
8112e504:	000d883a 	mov	r6,zero
8112e508:	01d07834 	movhi	r7,16864
8112e50c:	de00012e 	bgeu	sp,et,8112e514 <__fixunsdfsi+0x14>
8112e510:	003b68fa 	trap	3
8112e514:	dc400115 	stw	r17,4(sp)
8112e518:	dc000015 	stw	r16,0(sp)
8112e51c:	dfc00215 	stw	ra,8(sp)
8112e520:	2023883a 	mov	r17,r4
8112e524:	2821883a 	mov	r16,r5
8112e528:	11306180 	call	81130618 <__gedf2>
8112e52c:	1000080e 	bge	r2,zero,8112e550 <__fixunsdfsi+0x50>
8112e530:	8809883a 	mov	r4,r17
8112e534:	800b883a 	mov	r5,r16
8112e538:	11310ec0 	call	811310ec <__fixdfsi>
8112e53c:	dfc00217 	ldw	ra,8(sp)
8112e540:	dc400117 	ldw	r17,4(sp)
8112e544:	dc000017 	ldw	r16,0(sp)
8112e548:	dec00304 	addi	sp,sp,12
8112e54c:	f800283a 	ret
8112e550:	000d883a 	mov	r6,zero
8112e554:	01d07834 	movhi	r7,16864
8112e558:	8809883a 	mov	r4,r17
8112e55c:	800b883a 	mov	r5,r16
8112e560:	11307e80 	call	811307e8 <__subdf3>
8112e564:	180b883a 	mov	r5,r3
8112e568:	1009883a 	mov	r4,r2
8112e56c:	11310ec0 	call	811310ec <__fixdfsi>
8112e570:	00e00034 	movhi	r3,32768
8112e574:	10c5883a 	add	r2,r2,r3
8112e578:	003ff006 	br	8112e53c <__reset+0xfb10e53c>

8112e57c <__udivdi3>:
8112e57c:	defff504 	addi	sp,sp,-44
8112e580:	de00012e 	bgeu	sp,et,8112e588 <__udivdi3+0xc>
8112e584:	003b68fa 	trap	3
8112e588:	dcc00415 	stw	r19,16(sp)
8112e58c:	dc000115 	stw	r16,4(sp)
8112e590:	dfc00a15 	stw	ra,40(sp)
8112e594:	df000915 	stw	fp,36(sp)
8112e598:	ddc00815 	stw	r23,32(sp)
8112e59c:	dd800715 	stw	r22,28(sp)
8112e5a0:	dd400615 	stw	r21,24(sp)
8112e5a4:	dd000515 	stw	r20,20(sp)
8112e5a8:	dc800315 	stw	r18,12(sp)
8112e5ac:	dc400215 	stw	r17,8(sp)
8112e5b0:	2027883a 	mov	r19,r4
8112e5b4:	2821883a 	mov	r16,r5
8112e5b8:	3800411e 	bne	r7,zero,8112e6c0 <__udivdi3+0x144>
8112e5bc:	3023883a 	mov	r17,r6
8112e5c0:	2025883a 	mov	r18,r4
8112e5c4:	2980522e 	bgeu	r5,r6,8112e710 <__udivdi3+0x194>
8112e5c8:	00bfffd4 	movui	r2,65535
8112e5cc:	282d883a 	mov	r22,r5
8112e5d0:	1180a836 	bltu	r2,r6,8112e874 <__udivdi3+0x2f8>
8112e5d4:	00803fc4 	movi	r2,255
8112e5d8:	1185803a 	cmpltu	r2,r2,r6
8112e5dc:	100490fa 	slli	r2,r2,3
8112e5e0:	3086d83a 	srl	r3,r6,r2
8112e5e4:	01204574 	movhi	r4,33045
8112e5e8:	212a6e04 	addi	r4,r4,-22088
8112e5ec:	20c7883a 	add	r3,r4,r3
8112e5f0:	18c00003 	ldbu	r3,0(r3)
8112e5f4:	1885883a 	add	r2,r3,r2
8112e5f8:	00c00804 	movi	r3,32
8112e5fc:	1887c83a 	sub	r3,r3,r2
8112e600:	18000526 	beq	r3,zero,8112e618 <__udivdi3+0x9c>
8112e604:	80e0983a 	sll	r16,r16,r3
8112e608:	9884d83a 	srl	r2,r19,r2
8112e60c:	30e2983a 	sll	r17,r6,r3
8112e610:	98e4983a 	sll	r18,r19,r3
8112e614:	142cb03a 	or	r22,r2,r16
8112e618:	882ad43a 	srli	r21,r17,16
8112e61c:	b009883a 	mov	r4,r22
8112e620:	8d3fffcc 	andi	r20,r17,65535
8112e624:	a80b883a 	mov	r5,r21
8112e628:	112f1980 	call	8112f198 <__umodsi3>
8112e62c:	b009883a 	mov	r4,r22
8112e630:	a80b883a 	mov	r5,r21
8112e634:	1027883a 	mov	r19,r2
8112e638:	112f1340 	call	8112f134 <__udivsi3>
8112e63c:	102d883a 	mov	r22,r2
8112e640:	9826943a 	slli	r19,r19,16
8112e644:	9004d43a 	srli	r2,r18,16
8112e648:	a5a1383a 	mul	r16,r20,r22
8112e64c:	14c4b03a 	or	r2,r2,r19
8112e650:	1400052e 	bgeu	r2,r16,8112e668 <__udivdi3+0xec>
8112e654:	1445883a 	add	r2,r2,r17
8112e658:	b0ffffc4 	addi	r3,r22,-1
8112e65c:	14400136 	bltu	r2,r17,8112e664 <__udivdi3+0xe8>
8112e660:	14012336 	bltu	r2,r16,8112eaf0 <__udivdi3+0x574>
8112e664:	182d883a 	mov	r22,r3
8112e668:	1421c83a 	sub	r16,r2,r16
8112e66c:	a80b883a 	mov	r5,r21
8112e670:	8009883a 	mov	r4,r16
8112e674:	112f1980 	call	8112f198 <__umodsi3>
8112e678:	1027883a 	mov	r19,r2
8112e67c:	a80b883a 	mov	r5,r21
8112e680:	8009883a 	mov	r4,r16
8112e684:	112f1340 	call	8112f134 <__udivsi3>
8112e688:	9826943a 	slli	r19,r19,16
8112e68c:	a0a9383a 	mul	r20,r20,r2
8112e690:	94bfffcc 	andi	r18,r18,65535
8112e694:	94e4b03a 	or	r18,r18,r19
8112e698:	9500052e 	bgeu	r18,r20,8112e6b0 <__udivdi3+0x134>
8112e69c:	8ca5883a 	add	r18,r17,r18
8112e6a0:	10ffffc4 	addi	r3,r2,-1
8112e6a4:	9440f136 	bltu	r18,r17,8112ea6c <__udivdi3+0x4f0>
8112e6a8:	9500f02e 	bgeu	r18,r20,8112ea6c <__udivdi3+0x4f0>
8112e6ac:	10bfff84 	addi	r2,r2,-2
8112e6b0:	b00c943a 	slli	r6,r22,16
8112e6b4:	0007883a 	mov	r3,zero
8112e6b8:	3084b03a 	or	r2,r6,r2
8112e6bc:	00005906 	br	8112e824 <__udivdi3+0x2a8>
8112e6c0:	29c05636 	bltu	r5,r7,8112e81c <__udivdi3+0x2a0>
8112e6c4:	00bfffd4 	movui	r2,65535
8112e6c8:	11c0622e 	bgeu	r2,r7,8112e854 <__udivdi3+0x2d8>
8112e6cc:	00804034 	movhi	r2,256
8112e6d0:	10bfffc4 	addi	r2,r2,-1
8112e6d4:	11c0ee36 	bltu	r2,r7,8112ea90 <__udivdi3+0x514>
8112e6d8:	00800404 	movi	r2,16
8112e6dc:	3886d83a 	srl	r3,r7,r2
8112e6e0:	01204574 	movhi	r4,33045
8112e6e4:	212a6e04 	addi	r4,r4,-22088
8112e6e8:	20c7883a 	add	r3,r4,r3
8112e6ec:	18c00003 	ldbu	r3,0(r3)
8112e6f0:	05400804 	movi	r21,32
8112e6f4:	1885883a 	add	r2,r3,r2
8112e6f8:	a8abc83a 	sub	r21,r21,r2
8112e6fc:	a800621e 	bne	r21,zero,8112e888 <__udivdi3+0x30c>
8112e700:	3c00e936 	bltu	r7,r16,8112eaa8 <__udivdi3+0x52c>
8112e704:	9985403a 	cmpgeu	r2,r19,r6
8112e708:	0007883a 	mov	r3,zero
8112e70c:	00004506 	br	8112e824 <__udivdi3+0x2a8>
8112e710:	3000041e 	bne	r6,zero,8112e724 <__udivdi3+0x1a8>
8112e714:	000b883a 	mov	r5,zero
8112e718:	01000044 	movi	r4,1
8112e71c:	112f1340 	call	8112f134 <__udivsi3>
8112e720:	1023883a 	mov	r17,r2
8112e724:	00bfffd4 	movui	r2,65535
8112e728:	14404e2e 	bgeu	r2,r17,8112e864 <__udivdi3+0x2e8>
8112e72c:	00804034 	movhi	r2,256
8112e730:	10bfffc4 	addi	r2,r2,-1
8112e734:	1440d836 	bltu	r2,r17,8112ea98 <__udivdi3+0x51c>
8112e738:	00800404 	movi	r2,16
8112e73c:	8886d83a 	srl	r3,r17,r2
8112e740:	01204574 	movhi	r4,33045
8112e744:	212a6e04 	addi	r4,r4,-22088
8112e748:	20c7883a 	add	r3,r4,r3
8112e74c:	18c00003 	ldbu	r3,0(r3)
8112e750:	1885883a 	add	r2,r3,r2
8112e754:	00c00804 	movi	r3,32
8112e758:	1887c83a 	sub	r3,r3,r2
8112e75c:	18008f1e 	bne	r3,zero,8112e99c <__udivdi3+0x420>
8112e760:	882ad43a 	srli	r21,r17,16
8112e764:	8461c83a 	sub	r16,r16,r17
8112e768:	8d3fffcc 	andi	r20,r17,65535
8112e76c:	00c00044 	movi	r3,1
8112e770:	8009883a 	mov	r4,r16
8112e774:	a80b883a 	mov	r5,r21
8112e778:	d8c00015 	stw	r3,0(sp)
8112e77c:	112f1980 	call	8112f198 <__umodsi3>
8112e780:	8009883a 	mov	r4,r16
8112e784:	a80b883a 	mov	r5,r21
8112e788:	1027883a 	mov	r19,r2
8112e78c:	112f1340 	call	8112f134 <__udivsi3>
8112e790:	9826943a 	slli	r19,r19,16
8112e794:	9008d43a 	srli	r4,r18,16
8112e798:	1521383a 	mul	r16,r2,r20
8112e79c:	102d883a 	mov	r22,r2
8112e7a0:	24c8b03a 	or	r4,r4,r19
8112e7a4:	d8c00017 	ldw	r3,0(sp)
8112e7a8:	2400052e 	bgeu	r4,r16,8112e7c0 <__udivdi3+0x244>
8112e7ac:	2449883a 	add	r4,r4,r17
8112e7b0:	b0bfffc4 	addi	r2,r22,-1
8112e7b4:	24400136 	bltu	r4,r17,8112e7bc <__udivdi3+0x240>
8112e7b8:	2400ca36 	bltu	r4,r16,8112eae4 <__udivdi3+0x568>
8112e7bc:	102d883a 	mov	r22,r2
8112e7c0:	2421c83a 	sub	r16,r4,r16
8112e7c4:	a80b883a 	mov	r5,r21
8112e7c8:	8009883a 	mov	r4,r16
8112e7cc:	d8c00015 	stw	r3,0(sp)
8112e7d0:	112f1980 	call	8112f198 <__umodsi3>
8112e7d4:	1027883a 	mov	r19,r2
8112e7d8:	a80b883a 	mov	r5,r21
8112e7dc:	8009883a 	mov	r4,r16
8112e7e0:	112f1340 	call	8112f134 <__udivsi3>
8112e7e4:	9826943a 	slli	r19,r19,16
8112e7e8:	1529383a 	mul	r20,r2,r20
8112e7ec:	94bfffcc 	andi	r18,r18,65535
8112e7f0:	94e4b03a 	or	r18,r18,r19
8112e7f4:	d8c00017 	ldw	r3,0(sp)
8112e7f8:	9500052e 	bgeu	r18,r20,8112e810 <__udivdi3+0x294>
8112e7fc:	8ca5883a 	add	r18,r17,r18
8112e800:	113fffc4 	addi	r4,r2,-1
8112e804:	94409736 	bltu	r18,r17,8112ea64 <__udivdi3+0x4e8>
8112e808:	9500962e 	bgeu	r18,r20,8112ea64 <__udivdi3+0x4e8>
8112e80c:	10bfff84 	addi	r2,r2,-2
8112e810:	b00c943a 	slli	r6,r22,16
8112e814:	3084b03a 	or	r2,r6,r2
8112e818:	00000206 	br	8112e824 <__udivdi3+0x2a8>
8112e81c:	0007883a 	mov	r3,zero
8112e820:	0005883a 	mov	r2,zero
8112e824:	dfc00a17 	ldw	ra,40(sp)
8112e828:	df000917 	ldw	fp,36(sp)
8112e82c:	ddc00817 	ldw	r23,32(sp)
8112e830:	dd800717 	ldw	r22,28(sp)
8112e834:	dd400617 	ldw	r21,24(sp)
8112e838:	dd000517 	ldw	r20,20(sp)
8112e83c:	dcc00417 	ldw	r19,16(sp)
8112e840:	dc800317 	ldw	r18,12(sp)
8112e844:	dc400217 	ldw	r17,8(sp)
8112e848:	dc000117 	ldw	r16,4(sp)
8112e84c:	dec00b04 	addi	sp,sp,44
8112e850:	f800283a 	ret
8112e854:	00803fc4 	movi	r2,255
8112e858:	11c5803a 	cmpltu	r2,r2,r7
8112e85c:	100490fa 	slli	r2,r2,3
8112e860:	003f9e06 	br	8112e6dc <__reset+0xfb10e6dc>
8112e864:	00803fc4 	movi	r2,255
8112e868:	1445803a 	cmpltu	r2,r2,r17
8112e86c:	100490fa 	slli	r2,r2,3
8112e870:	003fb206 	br	8112e73c <__reset+0xfb10e73c>
8112e874:	00804034 	movhi	r2,256
8112e878:	10bfffc4 	addi	r2,r2,-1
8112e87c:	11808836 	bltu	r2,r6,8112eaa0 <__udivdi3+0x524>
8112e880:	00800404 	movi	r2,16
8112e884:	003f5606 	br	8112e5e0 <__reset+0xfb10e5e0>
8112e888:	30aed83a 	srl	r23,r6,r2
8112e88c:	3d4e983a 	sll	r7,r7,r21
8112e890:	80acd83a 	srl	r22,r16,r2
8112e894:	9884d83a 	srl	r2,r19,r2
8112e898:	3deeb03a 	or	r23,r7,r23
8112e89c:	b824d43a 	srli	r18,r23,16
8112e8a0:	8560983a 	sll	r16,r16,r21
8112e8a4:	b009883a 	mov	r4,r22
8112e8a8:	900b883a 	mov	r5,r18
8112e8ac:	3568983a 	sll	r20,r6,r21
8112e8b0:	1420b03a 	or	r16,r2,r16
8112e8b4:	112f1980 	call	8112f198 <__umodsi3>
8112e8b8:	b009883a 	mov	r4,r22
8112e8bc:	900b883a 	mov	r5,r18
8112e8c0:	1023883a 	mov	r17,r2
8112e8c4:	112f1340 	call	8112f134 <__udivsi3>
8112e8c8:	8808943a 	slli	r4,r17,16
8112e8cc:	bf3fffcc 	andi	fp,r23,65535
8112e8d0:	8006d43a 	srli	r3,r16,16
8112e8d4:	e0a3383a 	mul	r17,fp,r2
8112e8d8:	100d883a 	mov	r6,r2
8112e8dc:	1906b03a 	or	r3,r3,r4
8112e8e0:	1c40042e 	bgeu	r3,r17,8112e8f4 <__udivdi3+0x378>
8112e8e4:	1dc7883a 	add	r3,r3,r23
8112e8e8:	10bfffc4 	addi	r2,r2,-1
8112e8ec:	1dc0752e 	bgeu	r3,r23,8112eac4 <__udivdi3+0x548>
8112e8f0:	100d883a 	mov	r6,r2
8112e8f4:	1c63c83a 	sub	r17,r3,r17
8112e8f8:	900b883a 	mov	r5,r18
8112e8fc:	8809883a 	mov	r4,r17
8112e900:	d9800015 	stw	r6,0(sp)
8112e904:	112f1980 	call	8112f198 <__umodsi3>
8112e908:	102d883a 	mov	r22,r2
8112e90c:	8809883a 	mov	r4,r17
8112e910:	900b883a 	mov	r5,r18
8112e914:	112f1340 	call	8112f134 <__udivsi3>
8112e918:	b02c943a 	slli	r22,r22,16
8112e91c:	e089383a 	mul	r4,fp,r2
8112e920:	843fffcc 	andi	r16,r16,65535
8112e924:	85a0b03a 	or	r16,r16,r22
8112e928:	d9800017 	ldw	r6,0(sp)
8112e92c:	8100042e 	bgeu	r16,r4,8112e940 <__udivdi3+0x3c4>
8112e930:	85e1883a 	add	r16,r16,r23
8112e934:	10ffffc4 	addi	r3,r2,-1
8112e938:	85c05e2e 	bgeu	r16,r23,8112eab4 <__udivdi3+0x538>
8112e93c:	1805883a 	mov	r2,r3
8112e940:	300c943a 	slli	r6,r6,16
8112e944:	a17fffcc 	andi	r5,r20,65535
8112e948:	a028d43a 	srli	r20,r20,16
8112e94c:	3084b03a 	or	r2,r6,r2
8112e950:	10ffffcc 	andi	r3,r2,65535
8112e954:	100cd43a 	srli	r6,r2,16
8112e958:	194f383a 	mul	r7,r3,r5
8112e95c:	1d07383a 	mul	r3,r3,r20
8112e960:	314b383a 	mul	r5,r6,r5
8112e964:	3810d43a 	srli	r8,r7,16
8112e968:	8121c83a 	sub	r16,r16,r4
8112e96c:	1947883a 	add	r3,r3,r5
8112e970:	40c7883a 	add	r3,r8,r3
8112e974:	350d383a 	mul	r6,r6,r20
8112e978:	1940022e 	bgeu	r3,r5,8112e984 <__udivdi3+0x408>
8112e97c:	01000074 	movhi	r4,1
8112e980:	310d883a 	add	r6,r6,r4
8112e984:	1828d43a 	srli	r20,r3,16
8112e988:	a18d883a 	add	r6,r20,r6
8112e98c:	81803e36 	bltu	r16,r6,8112ea88 <__udivdi3+0x50c>
8112e990:	81803826 	beq	r16,r6,8112ea74 <__udivdi3+0x4f8>
8112e994:	0007883a 	mov	r3,zero
8112e998:	003fa206 	br	8112e824 <__reset+0xfb10e824>
8112e99c:	88e2983a 	sll	r17,r17,r3
8112e9a0:	80a8d83a 	srl	r20,r16,r2
8112e9a4:	80e0983a 	sll	r16,r16,r3
8112e9a8:	882ad43a 	srli	r21,r17,16
8112e9ac:	9884d83a 	srl	r2,r19,r2
8112e9b0:	a009883a 	mov	r4,r20
8112e9b4:	a80b883a 	mov	r5,r21
8112e9b8:	142eb03a 	or	r23,r2,r16
8112e9bc:	98e4983a 	sll	r18,r19,r3
8112e9c0:	112f1980 	call	8112f198 <__umodsi3>
8112e9c4:	a009883a 	mov	r4,r20
8112e9c8:	a80b883a 	mov	r5,r21
8112e9cc:	1021883a 	mov	r16,r2
8112e9d0:	112f1340 	call	8112f134 <__udivsi3>
8112e9d4:	1039883a 	mov	fp,r2
8112e9d8:	8d3fffcc 	andi	r20,r17,65535
8112e9dc:	8020943a 	slli	r16,r16,16
8112e9e0:	b804d43a 	srli	r2,r23,16
8112e9e4:	a72d383a 	mul	r22,r20,fp
8112e9e8:	1404b03a 	or	r2,r2,r16
8112e9ec:	1580062e 	bgeu	r2,r22,8112ea08 <__udivdi3+0x48c>
8112e9f0:	1445883a 	add	r2,r2,r17
8112e9f4:	e0ffffc4 	addi	r3,fp,-1
8112e9f8:	14403836 	bltu	r2,r17,8112eadc <__udivdi3+0x560>
8112e9fc:	1580372e 	bgeu	r2,r22,8112eadc <__udivdi3+0x560>
8112ea00:	e73fff84 	addi	fp,fp,-2
8112ea04:	1445883a 	add	r2,r2,r17
8112ea08:	15adc83a 	sub	r22,r2,r22
8112ea0c:	a80b883a 	mov	r5,r21
8112ea10:	b009883a 	mov	r4,r22
8112ea14:	112f1980 	call	8112f198 <__umodsi3>
8112ea18:	1027883a 	mov	r19,r2
8112ea1c:	b009883a 	mov	r4,r22
8112ea20:	a80b883a 	mov	r5,r21
8112ea24:	112f1340 	call	8112f134 <__udivsi3>
8112ea28:	9826943a 	slli	r19,r19,16
8112ea2c:	a0a1383a 	mul	r16,r20,r2
8112ea30:	b93fffcc 	andi	r4,r23,65535
8112ea34:	24c8b03a 	or	r4,r4,r19
8112ea38:	2400062e 	bgeu	r4,r16,8112ea54 <__udivdi3+0x4d8>
8112ea3c:	2449883a 	add	r4,r4,r17
8112ea40:	10ffffc4 	addi	r3,r2,-1
8112ea44:	24402336 	bltu	r4,r17,8112ead4 <__udivdi3+0x558>
8112ea48:	2400222e 	bgeu	r4,r16,8112ead4 <__udivdi3+0x558>
8112ea4c:	10bfff84 	addi	r2,r2,-2
8112ea50:	2449883a 	add	r4,r4,r17
8112ea54:	e038943a 	slli	fp,fp,16
8112ea58:	2421c83a 	sub	r16,r4,r16
8112ea5c:	e086b03a 	or	r3,fp,r2
8112ea60:	003f4306 	br	8112e770 <__reset+0xfb10e770>
8112ea64:	2005883a 	mov	r2,r4
8112ea68:	003f6906 	br	8112e810 <__reset+0xfb10e810>
8112ea6c:	1805883a 	mov	r2,r3
8112ea70:	003f0f06 	br	8112e6b0 <__reset+0xfb10e6b0>
8112ea74:	1806943a 	slli	r3,r3,16
8112ea78:	9d66983a 	sll	r19,r19,r21
8112ea7c:	39ffffcc 	andi	r7,r7,65535
8112ea80:	19c7883a 	add	r3,r3,r7
8112ea84:	98ffc32e 	bgeu	r19,r3,8112e994 <__reset+0xfb10e994>
8112ea88:	10bfffc4 	addi	r2,r2,-1
8112ea8c:	003fc106 	br	8112e994 <__reset+0xfb10e994>
8112ea90:	00800604 	movi	r2,24
8112ea94:	003f1106 	br	8112e6dc <__reset+0xfb10e6dc>
8112ea98:	00800604 	movi	r2,24
8112ea9c:	003f2706 	br	8112e73c <__reset+0xfb10e73c>
8112eaa0:	00800604 	movi	r2,24
8112eaa4:	003ece06 	br	8112e5e0 <__reset+0xfb10e5e0>
8112eaa8:	0007883a 	mov	r3,zero
8112eaac:	00800044 	movi	r2,1
8112eab0:	003f5c06 	br	8112e824 <__reset+0xfb10e824>
8112eab4:	813fa12e 	bgeu	r16,r4,8112e93c <__reset+0xfb10e93c>
8112eab8:	10bfff84 	addi	r2,r2,-2
8112eabc:	85e1883a 	add	r16,r16,r23
8112eac0:	003f9f06 	br	8112e940 <__reset+0xfb10e940>
8112eac4:	1c7f8a2e 	bgeu	r3,r17,8112e8f0 <__reset+0xfb10e8f0>
8112eac8:	31bfff84 	addi	r6,r6,-2
8112eacc:	1dc7883a 	add	r3,r3,r23
8112ead0:	003f8806 	br	8112e8f4 <__reset+0xfb10e8f4>
8112ead4:	1805883a 	mov	r2,r3
8112ead8:	003fde06 	br	8112ea54 <__reset+0xfb10ea54>
8112eadc:	1839883a 	mov	fp,r3
8112eae0:	003fc906 	br	8112ea08 <__reset+0xfb10ea08>
8112eae4:	b5bfff84 	addi	r22,r22,-2
8112eae8:	2449883a 	add	r4,r4,r17
8112eaec:	003f3406 	br	8112e7c0 <__reset+0xfb10e7c0>
8112eaf0:	b5bfff84 	addi	r22,r22,-2
8112eaf4:	1445883a 	add	r2,r2,r17
8112eaf8:	003edb06 	br	8112e668 <__reset+0xfb10e668>

8112eafc <__umoddi3>:
8112eafc:	defff404 	addi	sp,sp,-48
8112eb00:	de00012e 	bgeu	sp,et,8112eb08 <__umoddi3+0xc>
8112eb04:	003b68fa 	trap	3
8112eb08:	df000a15 	stw	fp,40(sp)
8112eb0c:	dc400315 	stw	r17,12(sp)
8112eb10:	dc000215 	stw	r16,8(sp)
8112eb14:	dfc00b15 	stw	ra,44(sp)
8112eb18:	ddc00915 	stw	r23,36(sp)
8112eb1c:	dd800815 	stw	r22,32(sp)
8112eb20:	dd400715 	stw	r21,28(sp)
8112eb24:	dd000615 	stw	r20,24(sp)
8112eb28:	dcc00515 	stw	r19,20(sp)
8112eb2c:	dc800415 	stw	r18,16(sp)
8112eb30:	2021883a 	mov	r16,r4
8112eb34:	2823883a 	mov	r17,r5
8112eb38:	2839883a 	mov	fp,r5
8112eb3c:	38003c1e 	bne	r7,zero,8112ec30 <__umoddi3+0x134>
8112eb40:	3027883a 	mov	r19,r6
8112eb44:	2029883a 	mov	r20,r4
8112eb48:	2980512e 	bgeu	r5,r6,8112ec90 <__umoddi3+0x194>
8112eb4c:	00bfffd4 	movui	r2,65535
8112eb50:	11809a36 	bltu	r2,r6,8112edbc <__umoddi3+0x2c0>
8112eb54:	01003fc4 	movi	r4,255
8112eb58:	2189803a 	cmpltu	r4,r4,r6
8112eb5c:	200890fa 	slli	r4,r4,3
8112eb60:	3104d83a 	srl	r2,r6,r4
8112eb64:	00e04574 	movhi	r3,33045
8112eb68:	18ea6e04 	addi	r3,r3,-22088
8112eb6c:	1885883a 	add	r2,r3,r2
8112eb70:	10c00003 	ldbu	r3,0(r2)
8112eb74:	00800804 	movi	r2,32
8112eb78:	1909883a 	add	r4,r3,r4
8112eb7c:	1125c83a 	sub	r18,r2,r4
8112eb80:	90000526 	beq	r18,zero,8112eb98 <__umoddi3+0x9c>
8112eb84:	8ca2983a 	sll	r17,r17,r18
8112eb88:	8108d83a 	srl	r4,r16,r4
8112eb8c:	34a6983a 	sll	r19,r6,r18
8112eb90:	84a8983a 	sll	r20,r16,r18
8112eb94:	2478b03a 	or	fp,r4,r17
8112eb98:	982ed43a 	srli	r23,r19,16
8112eb9c:	e009883a 	mov	r4,fp
8112eba0:	9dbfffcc 	andi	r22,r19,65535
8112eba4:	b80b883a 	mov	r5,r23
8112eba8:	112f1980 	call	8112f198 <__umodsi3>
8112ebac:	e009883a 	mov	r4,fp
8112ebb0:	b80b883a 	mov	r5,r23
8112ebb4:	102b883a 	mov	r21,r2
8112ebb8:	112f1340 	call	8112f134 <__udivsi3>
8112ebbc:	a806943a 	slli	r3,r21,16
8112ebc0:	a008d43a 	srli	r4,r20,16
8112ebc4:	b085383a 	mul	r2,r22,r2
8112ebc8:	20c8b03a 	or	r4,r4,r3
8112ebcc:	2080032e 	bgeu	r4,r2,8112ebdc <__umoddi3+0xe0>
8112ebd0:	24c9883a 	add	r4,r4,r19
8112ebd4:	24c00136 	bltu	r4,r19,8112ebdc <__umoddi3+0xe0>
8112ebd8:	20811036 	bltu	r4,r2,8112f01c <__umoddi3+0x520>
8112ebdc:	20abc83a 	sub	r21,r4,r2
8112ebe0:	b80b883a 	mov	r5,r23
8112ebe4:	a809883a 	mov	r4,r21
8112ebe8:	112f1980 	call	8112f198 <__umodsi3>
8112ebec:	1023883a 	mov	r17,r2
8112ebf0:	b80b883a 	mov	r5,r23
8112ebf4:	a809883a 	mov	r4,r21
8112ebf8:	112f1340 	call	8112f134 <__udivsi3>
8112ebfc:	8822943a 	slli	r17,r17,16
8112ec00:	b085383a 	mul	r2,r22,r2
8112ec04:	a0ffffcc 	andi	r3,r20,65535
8112ec08:	1c46b03a 	or	r3,r3,r17
8112ec0c:	1880042e 	bgeu	r3,r2,8112ec20 <__umoddi3+0x124>
8112ec10:	1cc7883a 	add	r3,r3,r19
8112ec14:	1cc00236 	bltu	r3,r19,8112ec20 <__umoddi3+0x124>
8112ec18:	1880012e 	bgeu	r3,r2,8112ec20 <__umoddi3+0x124>
8112ec1c:	1cc7883a 	add	r3,r3,r19
8112ec20:	1885c83a 	sub	r2,r3,r2
8112ec24:	1484d83a 	srl	r2,r2,r18
8112ec28:	0007883a 	mov	r3,zero
8112ec2c:	00004f06 	br	8112ed6c <__umoddi3+0x270>
8112ec30:	29c04c36 	bltu	r5,r7,8112ed64 <__umoddi3+0x268>
8112ec34:	00bfffd4 	movui	r2,65535
8112ec38:	11c0582e 	bgeu	r2,r7,8112ed9c <__umoddi3+0x2a0>
8112ec3c:	00804034 	movhi	r2,256
8112ec40:	10bfffc4 	addi	r2,r2,-1
8112ec44:	11c0e736 	bltu	r2,r7,8112efe4 <__umoddi3+0x4e8>
8112ec48:	01000404 	movi	r4,16
8112ec4c:	3904d83a 	srl	r2,r7,r4
8112ec50:	00e04574 	movhi	r3,33045
8112ec54:	18ea6e04 	addi	r3,r3,-22088
8112ec58:	1885883a 	add	r2,r3,r2
8112ec5c:	14c00003 	ldbu	r19,0(r2)
8112ec60:	00c00804 	movi	r3,32
8112ec64:	9927883a 	add	r19,r19,r4
8112ec68:	1ce9c83a 	sub	r20,r3,r19
8112ec6c:	a000581e 	bne	r20,zero,8112edd0 <__umoddi3+0x2d4>
8112ec70:	3c400136 	bltu	r7,r17,8112ec78 <__umoddi3+0x17c>
8112ec74:	8180eb36 	bltu	r16,r6,8112f024 <__umoddi3+0x528>
8112ec78:	8185c83a 	sub	r2,r16,r6
8112ec7c:	89e3c83a 	sub	r17,r17,r7
8112ec80:	8089803a 	cmpltu	r4,r16,r2
8112ec84:	8939c83a 	sub	fp,r17,r4
8112ec88:	e007883a 	mov	r3,fp
8112ec8c:	00003706 	br	8112ed6c <__umoddi3+0x270>
8112ec90:	3000041e 	bne	r6,zero,8112eca4 <__umoddi3+0x1a8>
8112ec94:	000b883a 	mov	r5,zero
8112ec98:	01000044 	movi	r4,1
8112ec9c:	112f1340 	call	8112f134 <__udivsi3>
8112eca0:	1027883a 	mov	r19,r2
8112eca4:	00bfffd4 	movui	r2,65535
8112eca8:	14c0402e 	bgeu	r2,r19,8112edac <__umoddi3+0x2b0>
8112ecac:	00804034 	movhi	r2,256
8112ecb0:	10bfffc4 	addi	r2,r2,-1
8112ecb4:	14c0cd36 	bltu	r2,r19,8112efec <__umoddi3+0x4f0>
8112ecb8:	00800404 	movi	r2,16
8112ecbc:	9886d83a 	srl	r3,r19,r2
8112ecc0:	01204574 	movhi	r4,33045
8112ecc4:	212a6e04 	addi	r4,r4,-22088
8112ecc8:	20c7883a 	add	r3,r4,r3
8112eccc:	18c00003 	ldbu	r3,0(r3)
8112ecd0:	1887883a 	add	r3,r3,r2
8112ecd4:	00800804 	movi	r2,32
8112ecd8:	10e5c83a 	sub	r18,r2,r3
8112ecdc:	9000901e 	bne	r18,zero,8112ef20 <__umoddi3+0x424>
8112ece0:	982cd43a 	srli	r22,r19,16
8112ece4:	8ce3c83a 	sub	r17,r17,r19
8112ece8:	9d7fffcc 	andi	r21,r19,65535
8112ecec:	b00b883a 	mov	r5,r22
8112ecf0:	8809883a 	mov	r4,r17
8112ecf4:	112f1980 	call	8112f198 <__umodsi3>
8112ecf8:	8809883a 	mov	r4,r17
8112ecfc:	b00b883a 	mov	r5,r22
8112ed00:	1021883a 	mov	r16,r2
8112ed04:	112f1340 	call	8112f134 <__udivsi3>
8112ed08:	8006943a 	slli	r3,r16,16
8112ed0c:	a008d43a 	srli	r4,r20,16
8112ed10:	1545383a 	mul	r2,r2,r21
8112ed14:	20c8b03a 	or	r4,r4,r3
8112ed18:	2080042e 	bgeu	r4,r2,8112ed2c <__umoddi3+0x230>
8112ed1c:	24c9883a 	add	r4,r4,r19
8112ed20:	24c00236 	bltu	r4,r19,8112ed2c <__umoddi3+0x230>
8112ed24:	2080012e 	bgeu	r4,r2,8112ed2c <__umoddi3+0x230>
8112ed28:	24c9883a 	add	r4,r4,r19
8112ed2c:	20a1c83a 	sub	r16,r4,r2
8112ed30:	b00b883a 	mov	r5,r22
8112ed34:	8009883a 	mov	r4,r16
8112ed38:	112f1980 	call	8112f198 <__umodsi3>
8112ed3c:	1023883a 	mov	r17,r2
8112ed40:	b00b883a 	mov	r5,r22
8112ed44:	8009883a 	mov	r4,r16
8112ed48:	112f1340 	call	8112f134 <__udivsi3>
8112ed4c:	8822943a 	slli	r17,r17,16
8112ed50:	1545383a 	mul	r2,r2,r21
8112ed54:	a53fffcc 	andi	r20,r20,65535
8112ed58:	a446b03a 	or	r3,r20,r17
8112ed5c:	18bfb02e 	bgeu	r3,r2,8112ec20 <__reset+0xfb10ec20>
8112ed60:	003fab06 	br	8112ec10 <__reset+0xfb10ec10>
8112ed64:	2005883a 	mov	r2,r4
8112ed68:	2807883a 	mov	r3,r5
8112ed6c:	dfc00b17 	ldw	ra,44(sp)
8112ed70:	df000a17 	ldw	fp,40(sp)
8112ed74:	ddc00917 	ldw	r23,36(sp)
8112ed78:	dd800817 	ldw	r22,32(sp)
8112ed7c:	dd400717 	ldw	r21,28(sp)
8112ed80:	dd000617 	ldw	r20,24(sp)
8112ed84:	dcc00517 	ldw	r19,20(sp)
8112ed88:	dc800417 	ldw	r18,16(sp)
8112ed8c:	dc400317 	ldw	r17,12(sp)
8112ed90:	dc000217 	ldw	r16,8(sp)
8112ed94:	dec00c04 	addi	sp,sp,48
8112ed98:	f800283a 	ret
8112ed9c:	04c03fc4 	movi	r19,255
8112eda0:	99c9803a 	cmpltu	r4,r19,r7
8112eda4:	200890fa 	slli	r4,r4,3
8112eda8:	003fa806 	br	8112ec4c <__reset+0xfb10ec4c>
8112edac:	00803fc4 	movi	r2,255
8112edb0:	14c5803a 	cmpltu	r2,r2,r19
8112edb4:	100490fa 	slli	r2,r2,3
8112edb8:	003fc006 	br	8112ecbc <__reset+0xfb10ecbc>
8112edbc:	00804034 	movhi	r2,256
8112edc0:	10bfffc4 	addi	r2,r2,-1
8112edc4:	11808b36 	bltu	r2,r6,8112eff4 <__umoddi3+0x4f8>
8112edc8:	01000404 	movi	r4,16
8112edcc:	003f6406 	br	8112eb60 <__reset+0xfb10eb60>
8112edd0:	34c4d83a 	srl	r2,r6,r19
8112edd4:	3d0e983a 	sll	r7,r7,r20
8112edd8:	8cf8d83a 	srl	fp,r17,r19
8112eddc:	8d10983a 	sll	r8,r17,r20
8112ede0:	38aab03a 	or	r21,r7,r2
8112ede4:	a82cd43a 	srli	r22,r21,16
8112ede8:	84e2d83a 	srl	r17,r16,r19
8112edec:	e009883a 	mov	r4,fp
8112edf0:	b00b883a 	mov	r5,r22
8112edf4:	8a22b03a 	or	r17,r17,r8
8112edf8:	3524983a 	sll	r18,r6,r20
8112edfc:	112f1980 	call	8112f198 <__umodsi3>
8112ee00:	e009883a 	mov	r4,fp
8112ee04:	b00b883a 	mov	r5,r22
8112ee08:	102f883a 	mov	r23,r2
8112ee0c:	112f1340 	call	8112f134 <__udivsi3>
8112ee10:	100d883a 	mov	r6,r2
8112ee14:	b808943a 	slli	r4,r23,16
8112ee18:	aa3fffcc 	andi	r8,r21,65535
8112ee1c:	8804d43a 	srli	r2,r17,16
8112ee20:	41af383a 	mul	r23,r8,r6
8112ee24:	8520983a 	sll	r16,r16,r20
8112ee28:	1104b03a 	or	r2,r2,r4
8112ee2c:	15c0042e 	bgeu	r2,r23,8112ee40 <__umoddi3+0x344>
8112ee30:	1545883a 	add	r2,r2,r21
8112ee34:	30ffffc4 	addi	r3,r6,-1
8112ee38:	1540742e 	bgeu	r2,r21,8112f00c <__umoddi3+0x510>
8112ee3c:	180d883a 	mov	r6,r3
8112ee40:	15efc83a 	sub	r23,r2,r23
8112ee44:	b00b883a 	mov	r5,r22
8112ee48:	b809883a 	mov	r4,r23
8112ee4c:	d9800115 	stw	r6,4(sp)
8112ee50:	da000015 	stw	r8,0(sp)
8112ee54:	112f1980 	call	8112f198 <__umodsi3>
8112ee58:	b00b883a 	mov	r5,r22
8112ee5c:	b809883a 	mov	r4,r23
8112ee60:	1039883a 	mov	fp,r2
8112ee64:	112f1340 	call	8112f134 <__udivsi3>
8112ee68:	da000017 	ldw	r8,0(sp)
8112ee6c:	e038943a 	slli	fp,fp,16
8112ee70:	100b883a 	mov	r5,r2
8112ee74:	4089383a 	mul	r4,r8,r2
8112ee78:	8a3fffcc 	andi	r8,r17,65535
8112ee7c:	4710b03a 	or	r8,r8,fp
8112ee80:	d9800117 	ldw	r6,4(sp)
8112ee84:	4100042e 	bgeu	r8,r4,8112ee98 <__umoddi3+0x39c>
8112ee88:	4551883a 	add	r8,r8,r21
8112ee8c:	10bfffc4 	addi	r2,r2,-1
8112ee90:	45405a2e 	bgeu	r8,r21,8112effc <__umoddi3+0x500>
8112ee94:	100b883a 	mov	r5,r2
8112ee98:	300c943a 	slli	r6,r6,16
8112ee9c:	91ffffcc 	andi	r7,r18,65535
8112eea0:	9004d43a 	srli	r2,r18,16
8112eea4:	314cb03a 	or	r6,r6,r5
8112eea8:	317fffcc 	andi	r5,r6,65535
8112eeac:	300cd43a 	srli	r6,r6,16
8112eeb0:	29d3383a 	mul	r9,r5,r7
8112eeb4:	288b383a 	mul	r5,r5,r2
8112eeb8:	31cf383a 	mul	r7,r6,r7
8112eebc:	4806d43a 	srli	r3,r9,16
8112eec0:	4111c83a 	sub	r8,r8,r4
8112eec4:	29cb883a 	add	r5,r5,r7
8112eec8:	194b883a 	add	r5,r3,r5
8112eecc:	3085383a 	mul	r2,r6,r2
8112eed0:	29c0022e 	bgeu	r5,r7,8112eedc <__umoddi3+0x3e0>
8112eed4:	00c00074 	movhi	r3,1
8112eed8:	10c5883a 	add	r2,r2,r3
8112eedc:	2808d43a 	srli	r4,r5,16
8112eee0:	280a943a 	slli	r5,r5,16
8112eee4:	4a7fffcc 	andi	r9,r9,65535
8112eee8:	2085883a 	add	r2,r4,r2
8112eeec:	2a4b883a 	add	r5,r5,r9
8112eef0:	40803636 	bltu	r8,r2,8112efcc <__umoddi3+0x4d0>
8112eef4:	40804d26 	beq	r8,r2,8112f02c <__umoddi3+0x530>
8112eef8:	4089c83a 	sub	r4,r8,r2
8112eefc:	280f883a 	mov	r7,r5
8112ef00:	81cfc83a 	sub	r7,r16,r7
8112ef04:	81c7803a 	cmpltu	r3,r16,r7
8112ef08:	20c7c83a 	sub	r3,r4,r3
8112ef0c:	1cc4983a 	sll	r2,r3,r19
8112ef10:	3d0ed83a 	srl	r7,r7,r20
8112ef14:	1d06d83a 	srl	r3,r3,r20
8112ef18:	11c4b03a 	or	r2,r2,r7
8112ef1c:	003f9306 	br	8112ed6c <__reset+0xfb10ed6c>
8112ef20:	9ca6983a 	sll	r19,r19,r18
8112ef24:	88e8d83a 	srl	r20,r17,r3
8112ef28:	80c4d83a 	srl	r2,r16,r3
8112ef2c:	982cd43a 	srli	r22,r19,16
8112ef30:	8ca2983a 	sll	r17,r17,r18
8112ef34:	a009883a 	mov	r4,r20
8112ef38:	b00b883a 	mov	r5,r22
8112ef3c:	1478b03a 	or	fp,r2,r17
8112ef40:	112f1980 	call	8112f198 <__umodsi3>
8112ef44:	a009883a 	mov	r4,r20
8112ef48:	b00b883a 	mov	r5,r22
8112ef4c:	1023883a 	mov	r17,r2
8112ef50:	112f1340 	call	8112f134 <__udivsi3>
8112ef54:	9d7fffcc 	andi	r21,r19,65535
8112ef58:	880a943a 	slli	r5,r17,16
8112ef5c:	e008d43a 	srli	r4,fp,16
8112ef60:	a885383a 	mul	r2,r21,r2
8112ef64:	84a8983a 	sll	r20,r16,r18
8112ef68:	2148b03a 	or	r4,r4,r5
8112ef6c:	2080042e 	bgeu	r4,r2,8112ef80 <__umoddi3+0x484>
8112ef70:	24c9883a 	add	r4,r4,r19
8112ef74:	24c00236 	bltu	r4,r19,8112ef80 <__umoddi3+0x484>
8112ef78:	2080012e 	bgeu	r4,r2,8112ef80 <__umoddi3+0x484>
8112ef7c:	24c9883a 	add	r4,r4,r19
8112ef80:	20a3c83a 	sub	r17,r4,r2
8112ef84:	b00b883a 	mov	r5,r22
8112ef88:	8809883a 	mov	r4,r17
8112ef8c:	112f1980 	call	8112f198 <__umodsi3>
8112ef90:	102f883a 	mov	r23,r2
8112ef94:	8809883a 	mov	r4,r17
8112ef98:	b00b883a 	mov	r5,r22
8112ef9c:	112f1340 	call	8112f134 <__udivsi3>
8112efa0:	b82e943a 	slli	r23,r23,16
8112efa4:	a885383a 	mul	r2,r21,r2
8112efa8:	e13fffcc 	andi	r4,fp,65535
8112efac:	25c8b03a 	or	r4,r4,r23
8112efb0:	2080042e 	bgeu	r4,r2,8112efc4 <__umoddi3+0x4c8>
8112efb4:	24c9883a 	add	r4,r4,r19
8112efb8:	24c00236 	bltu	r4,r19,8112efc4 <__umoddi3+0x4c8>
8112efbc:	2080012e 	bgeu	r4,r2,8112efc4 <__umoddi3+0x4c8>
8112efc0:	24c9883a 	add	r4,r4,r19
8112efc4:	20a3c83a 	sub	r17,r4,r2
8112efc8:	003f4806 	br	8112ecec <__reset+0xfb10ecec>
8112efcc:	2c8fc83a 	sub	r7,r5,r18
8112efd0:	1545c83a 	sub	r2,r2,r21
8112efd4:	29cb803a 	cmpltu	r5,r5,r7
8112efd8:	1145c83a 	sub	r2,r2,r5
8112efdc:	4089c83a 	sub	r4,r8,r2
8112efe0:	003fc706 	br	8112ef00 <__reset+0xfb10ef00>
8112efe4:	01000604 	movi	r4,24
8112efe8:	003f1806 	br	8112ec4c <__reset+0xfb10ec4c>
8112efec:	00800604 	movi	r2,24
8112eff0:	003f3206 	br	8112ecbc <__reset+0xfb10ecbc>
8112eff4:	01000604 	movi	r4,24
8112eff8:	003ed906 	br	8112eb60 <__reset+0xfb10eb60>
8112effc:	413fa52e 	bgeu	r8,r4,8112ee94 <__reset+0xfb10ee94>
8112f000:	297fff84 	addi	r5,r5,-2
8112f004:	4551883a 	add	r8,r8,r21
8112f008:	003fa306 	br	8112ee98 <__reset+0xfb10ee98>
8112f00c:	15ff8b2e 	bgeu	r2,r23,8112ee3c <__reset+0xfb10ee3c>
8112f010:	31bfff84 	addi	r6,r6,-2
8112f014:	1545883a 	add	r2,r2,r21
8112f018:	003f8906 	br	8112ee40 <__reset+0xfb10ee40>
8112f01c:	24c9883a 	add	r4,r4,r19
8112f020:	003eee06 	br	8112ebdc <__reset+0xfb10ebdc>
8112f024:	8005883a 	mov	r2,r16
8112f028:	003f1706 	br	8112ec88 <__reset+0xfb10ec88>
8112f02c:	817fe736 	bltu	r16,r5,8112efcc <__reset+0xfb10efcc>
8112f030:	280f883a 	mov	r7,r5
8112f034:	0009883a 	mov	r4,zero
8112f038:	003fb106 	br	8112ef00 <__reset+0xfb10ef00>

8112f03c <__divsi3>:
8112f03c:	20001b16 	blt	r4,zero,8112f0ac <__divsi3+0x70>
8112f040:	000f883a 	mov	r7,zero
8112f044:	28001616 	blt	r5,zero,8112f0a0 <__divsi3+0x64>
8112f048:	200d883a 	mov	r6,r4
8112f04c:	29001a2e 	bgeu	r5,r4,8112f0b8 <__divsi3+0x7c>
8112f050:	00800804 	movi	r2,32
8112f054:	00c00044 	movi	r3,1
8112f058:	00000106 	br	8112f060 <__divsi3+0x24>
8112f05c:	10000d26 	beq	r2,zero,8112f094 <__divsi3+0x58>
8112f060:	294b883a 	add	r5,r5,r5
8112f064:	10bfffc4 	addi	r2,r2,-1
8112f068:	18c7883a 	add	r3,r3,r3
8112f06c:	293ffb36 	bltu	r5,r4,8112f05c <__reset+0xfb10f05c>
8112f070:	0005883a 	mov	r2,zero
8112f074:	18000726 	beq	r3,zero,8112f094 <__divsi3+0x58>
8112f078:	0005883a 	mov	r2,zero
8112f07c:	31400236 	bltu	r6,r5,8112f088 <__divsi3+0x4c>
8112f080:	314dc83a 	sub	r6,r6,r5
8112f084:	10c4b03a 	or	r2,r2,r3
8112f088:	1806d07a 	srli	r3,r3,1
8112f08c:	280ad07a 	srli	r5,r5,1
8112f090:	183ffa1e 	bne	r3,zero,8112f07c <__reset+0xfb10f07c>
8112f094:	38000126 	beq	r7,zero,8112f09c <__divsi3+0x60>
8112f098:	0085c83a 	sub	r2,zero,r2
8112f09c:	f800283a 	ret
8112f0a0:	014bc83a 	sub	r5,zero,r5
8112f0a4:	39c0005c 	xori	r7,r7,1
8112f0a8:	003fe706 	br	8112f048 <__reset+0xfb10f048>
8112f0ac:	0109c83a 	sub	r4,zero,r4
8112f0b0:	01c00044 	movi	r7,1
8112f0b4:	003fe306 	br	8112f044 <__reset+0xfb10f044>
8112f0b8:	00c00044 	movi	r3,1
8112f0bc:	003fee06 	br	8112f078 <__reset+0xfb10f078>

8112f0c0 <__modsi3>:
8112f0c0:	20001716 	blt	r4,zero,8112f120 <__modsi3+0x60>
8112f0c4:	000f883a 	mov	r7,zero
8112f0c8:	2005883a 	mov	r2,r4
8112f0cc:	28001216 	blt	r5,zero,8112f118 <__modsi3+0x58>
8112f0d0:	2900162e 	bgeu	r5,r4,8112f12c <__modsi3+0x6c>
8112f0d4:	01800804 	movi	r6,32
8112f0d8:	00c00044 	movi	r3,1
8112f0dc:	00000106 	br	8112f0e4 <__modsi3+0x24>
8112f0e0:	30000a26 	beq	r6,zero,8112f10c <__modsi3+0x4c>
8112f0e4:	294b883a 	add	r5,r5,r5
8112f0e8:	31bfffc4 	addi	r6,r6,-1
8112f0ec:	18c7883a 	add	r3,r3,r3
8112f0f0:	293ffb36 	bltu	r5,r4,8112f0e0 <__reset+0xfb10f0e0>
8112f0f4:	18000526 	beq	r3,zero,8112f10c <__modsi3+0x4c>
8112f0f8:	1806d07a 	srli	r3,r3,1
8112f0fc:	11400136 	bltu	r2,r5,8112f104 <__modsi3+0x44>
8112f100:	1145c83a 	sub	r2,r2,r5
8112f104:	280ad07a 	srli	r5,r5,1
8112f108:	183ffb1e 	bne	r3,zero,8112f0f8 <__reset+0xfb10f0f8>
8112f10c:	38000126 	beq	r7,zero,8112f114 <__modsi3+0x54>
8112f110:	0085c83a 	sub	r2,zero,r2
8112f114:	f800283a 	ret
8112f118:	014bc83a 	sub	r5,zero,r5
8112f11c:	003fec06 	br	8112f0d0 <__reset+0xfb10f0d0>
8112f120:	0109c83a 	sub	r4,zero,r4
8112f124:	01c00044 	movi	r7,1
8112f128:	003fe706 	br	8112f0c8 <__reset+0xfb10f0c8>
8112f12c:	00c00044 	movi	r3,1
8112f130:	003ff106 	br	8112f0f8 <__reset+0xfb10f0f8>

8112f134 <__udivsi3>:
8112f134:	200d883a 	mov	r6,r4
8112f138:	2900152e 	bgeu	r5,r4,8112f190 <__udivsi3+0x5c>
8112f13c:	28001416 	blt	r5,zero,8112f190 <__udivsi3+0x5c>
8112f140:	00800804 	movi	r2,32
8112f144:	00c00044 	movi	r3,1
8112f148:	00000206 	br	8112f154 <__udivsi3+0x20>
8112f14c:	10000e26 	beq	r2,zero,8112f188 <__udivsi3+0x54>
8112f150:	28000516 	blt	r5,zero,8112f168 <__udivsi3+0x34>
8112f154:	294b883a 	add	r5,r5,r5
8112f158:	10bfffc4 	addi	r2,r2,-1
8112f15c:	18c7883a 	add	r3,r3,r3
8112f160:	293ffa36 	bltu	r5,r4,8112f14c <__reset+0xfb10f14c>
8112f164:	18000826 	beq	r3,zero,8112f188 <__udivsi3+0x54>
8112f168:	0005883a 	mov	r2,zero
8112f16c:	31400236 	bltu	r6,r5,8112f178 <__udivsi3+0x44>
8112f170:	314dc83a 	sub	r6,r6,r5
8112f174:	10c4b03a 	or	r2,r2,r3
8112f178:	1806d07a 	srli	r3,r3,1
8112f17c:	280ad07a 	srli	r5,r5,1
8112f180:	183ffa1e 	bne	r3,zero,8112f16c <__reset+0xfb10f16c>
8112f184:	f800283a 	ret
8112f188:	0005883a 	mov	r2,zero
8112f18c:	f800283a 	ret
8112f190:	00c00044 	movi	r3,1
8112f194:	003ff406 	br	8112f168 <__reset+0xfb10f168>

8112f198 <__umodsi3>:
8112f198:	2005883a 	mov	r2,r4
8112f19c:	2900122e 	bgeu	r5,r4,8112f1e8 <__umodsi3+0x50>
8112f1a0:	28001116 	blt	r5,zero,8112f1e8 <__umodsi3+0x50>
8112f1a4:	01800804 	movi	r6,32
8112f1a8:	00c00044 	movi	r3,1
8112f1ac:	00000206 	br	8112f1b8 <__umodsi3+0x20>
8112f1b0:	30000c26 	beq	r6,zero,8112f1e4 <__umodsi3+0x4c>
8112f1b4:	28000516 	blt	r5,zero,8112f1cc <__umodsi3+0x34>
8112f1b8:	294b883a 	add	r5,r5,r5
8112f1bc:	31bfffc4 	addi	r6,r6,-1
8112f1c0:	18c7883a 	add	r3,r3,r3
8112f1c4:	293ffa36 	bltu	r5,r4,8112f1b0 <__reset+0xfb10f1b0>
8112f1c8:	18000626 	beq	r3,zero,8112f1e4 <__umodsi3+0x4c>
8112f1cc:	1806d07a 	srli	r3,r3,1
8112f1d0:	11400136 	bltu	r2,r5,8112f1d8 <__umodsi3+0x40>
8112f1d4:	1145c83a 	sub	r2,r2,r5
8112f1d8:	280ad07a 	srli	r5,r5,1
8112f1dc:	183ffb1e 	bne	r3,zero,8112f1cc <__reset+0xfb10f1cc>
8112f1e0:	f800283a 	ret
8112f1e4:	f800283a 	ret
8112f1e8:	00c00044 	movi	r3,1
8112f1ec:	003ff706 	br	8112f1cc <__reset+0xfb10f1cc>

8112f1f0 <__eqsf2>:
8112f1f0:	2006d5fa 	srli	r3,r4,23
8112f1f4:	280cd5fa 	srli	r6,r5,23
8112f1f8:	01c02034 	movhi	r7,128
8112f1fc:	39ffffc4 	addi	r7,r7,-1
8112f200:	18c03fcc 	andi	r3,r3,255
8112f204:	02003fc4 	movi	r8,255
8112f208:	3904703a 	and	r2,r7,r4
8112f20c:	31803fcc 	andi	r6,r6,255
8112f210:	394e703a 	and	r7,r7,r5
8112f214:	2008d7fa 	srli	r4,r4,31
8112f218:	280ad7fa 	srli	r5,r5,31
8112f21c:	1a000d26 	beq	r3,r8,8112f254 <__eqsf2+0x64>
8112f220:	02003fc4 	movi	r8,255
8112f224:	32000826 	beq	r6,r8,8112f248 <__eqsf2+0x58>
8112f228:	19800226 	beq	r3,r6,8112f234 <__eqsf2+0x44>
8112f22c:	00800044 	movi	r2,1
8112f230:	f800283a 	ret
8112f234:	11fffd1e 	bne	r2,r7,8112f22c <__reset+0xfb10f22c>
8112f238:	21400926 	beq	r4,r5,8112f260 <__eqsf2+0x70>
8112f23c:	183ffb1e 	bne	r3,zero,8112f22c <__reset+0xfb10f22c>
8112f240:	1004c03a 	cmpne	r2,r2,zero
8112f244:	f800283a 	ret
8112f248:	383ff726 	beq	r7,zero,8112f228 <__reset+0xfb10f228>
8112f24c:	00800044 	movi	r2,1
8112f250:	f800283a 	ret
8112f254:	103ff226 	beq	r2,zero,8112f220 <__reset+0xfb10f220>
8112f258:	00800044 	movi	r2,1
8112f25c:	f800283a 	ret
8112f260:	0005883a 	mov	r2,zero
8112f264:	f800283a 	ret

8112f268 <__gesf2>:
8112f268:	2004d5fa 	srli	r2,r4,23
8112f26c:	2806d5fa 	srli	r3,r5,23
8112f270:	01802034 	movhi	r6,128
8112f274:	31bfffc4 	addi	r6,r6,-1
8112f278:	10803fcc 	andi	r2,r2,255
8112f27c:	01c03fc4 	movi	r7,255
8112f280:	3110703a 	and	r8,r6,r4
8112f284:	18c03fcc 	andi	r3,r3,255
8112f288:	314c703a 	and	r6,r6,r5
8112f28c:	2008d7fa 	srli	r4,r4,31
8112f290:	280ad7fa 	srli	r5,r5,31
8112f294:	11c01926 	beq	r2,r7,8112f2fc <__gesf2+0x94>
8112f298:	01c03fc4 	movi	r7,255
8112f29c:	19c00f26 	beq	r3,r7,8112f2dc <__gesf2+0x74>
8112f2a0:	1000061e 	bne	r2,zero,8112f2bc <__gesf2+0x54>
8112f2a4:	400f003a 	cmpeq	r7,r8,zero
8112f2a8:	1800071e 	bne	r3,zero,8112f2c8 <__gesf2+0x60>
8112f2ac:	3000061e 	bne	r6,zero,8112f2c8 <__gesf2+0x60>
8112f2b0:	0005883a 	mov	r2,zero
8112f2b4:	40000e1e 	bne	r8,zero,8112f2f0 <__gesf2+0x88>
8112f2b8:	f800283a 	ret
8112f2bc:	18000a1e 	bne	r3,zero,8112f2e8 <__gesf2+0x80>
8112f2c0:	30000b26 	beq	r6,zero,8112f2f0 <__gesf2+0x88>
8112f2c4:	000f883a 	mov	r7,zero
8112f2c8:	29403fcc 	andi	r5,r5,255
8112f2cc:	38000726 	beq	r7,zero,8112f2ec <__gesf2+0x84>
8112f2d0:	28000826 	beq	r5,zero,8112f2f4 <__gesf2+0x8c>
8112f2d4:	00800044 	movi	r2,1
8112f2d8:	f800283a 	ret
8112f2dc:	303ff026 	beq	r6,zero,8112f2a0 <__reset+0xfb10f2a0>
8112f2e0:	00bfff84 	movi	r2,-2
8112f2e4:	f800283a 	ret
8112f2e8:	29403fcc 	andi	r5,r5,255
8112f2ec:	21400526 	beq	r4,r5,8112f304 <__gesf2+0x9c>
8112f2f0:	203ff826 	beq	r4,zero,8112f2d4 <__reset+0xfb10f2d4>
8112f2f4:	00bfffc4 	movi	r2,-1
8112f2f8:	f800283a 	ret
8112f2fc:	403fe626 	beq	r8,zero,8112f298 <__reset+0xfb10f298>
8112f300:	003ff706 	br	8112f2e0 <__reset+0xfb10f2e0>
8112f304:	18bffa16 	blt	r3,r2,8112f2f0 <__reset+0xfb10f2f0>
8112f308:	10c00216 	blt	r2,r3,8112f314 <__gesf2+0xac>
8112f30c:	323ff836 	bltu	r6,r8,8112f2f0 <__reset+0xfb10f2f0>
8112f310:	4180022e 	bgeu	r8,r6,8112f31c <__gesf2+0xb4>
8112f314:	203fef1e 	bne	r4,zero,8112f2d4 <__reset+0xfb10f2d4>
8112f318:	003ff606 	br	8112f2f4 <__reset+0xfb10f2f4>
8112f31c:	0005883a 	mov	r2,zero
8112f320:	f800283a 	ret

8112f324 <__lesf2>:
8112f324:	2004d5fa 	srli	r2,r4,23
8112f328:	280cd5fa 	srli	r6,r5,23
8112f32c:	00c02034 	movhi	r3,128
8112f330:	18ffffc4 	addi	r3,r3,-1
8112f334:	10803fcc 	andi	r2,r2,255
8112f338:	01c03fc4 	movi	r7,255
8112f33c:	1910703a 	and	r8,r3,r4
8112f340:	31803fcc 	andi	r6,r6,255
8112f344:	1946703a 	and	r3,r3,r5
8112f348:	2008d7fa 	srli	r4,r4,31
8112f34c:	280ad7fa 	srli	r5,r5,31
8112f350:	11c01b26 	beq	r2,r7,8112f3c0 <__lesf2+0x9c>
8112f354:	01c03fc4 	movi	r7,255
8112f358:	31c01126 	beq	r6,r7,8112f3a0 <__lesf2+0x7c>
8112f35c:	1000071e 	bne	r2,zero,8112f37c <__lesf2+0x58>
8112f360:	400f003a 	cmpeq	r7,r8,zero
8112f364:	21003fcc 	andi	r4,r4,255
8112f368:	3000081e 	bne	r6,zero,8112f38c <__lesf2+0x68>
8112f36c:	1800071e 	bne	r3,zero,8112f38c <__lesf2+0x68>
8112f370:	0005883a 	mov	r2,zero
8112f374:	40000f1e 	bne	r8,zero,8112f3b4 <__lesf2+0x90>
8112f378:	f800283a 	ret
8112f37c:	21003fcc 	andi	r4,r4,255
8112f380:	30000a1e 	bne	r6,zero,8112f3ac <__lesf2+0x88>
8112f384:	18000b26 	beq	r3,zero,8112f3b4 <__lesf2+0x90>
8112f388:	000f883a 	mov	r7,zero
8112f38c:	29403fcc 	andi	r5,r5,255
8112f390:	38000726 	beq	r7,zero,8112f3b0 <__lesf2+0x8c>
8112f394:	28000826 	beq	r5,zero,8112f3b8 <__lesf2+0x94>
8112f398:	00800044 	movi	r2,1
8112f39c:	f800283a 	ret
8112f3a0:	183fee26 	beq	r3,zero,8112f35c <__reset+0xfb10f35c>
8112f3a4:	00800084 	movi	r2,2
8112f3a8:	f800283a 	ret
8112f3ac:	29403fcc 	andi	r5,r5,255
8112f3b0:	21400626 	beq	r4,r5,8112f3cc <__lesf2+0xa8>
8112f3b4:	203ff826 	beq	r4,zero,8112f398 <__reset+0xfb10f398>
8112f3b8:	00bfffc4 	movi	r2,-1
8112f3bc:	f800283a 	ret
8112f3c0:	403fe426 	beq	r8,zero,8112f354 <__reset+0xfb10f354>
8112f3c4:	00800084 	movi	r2,2
8112f3c8:	f800283a 	ret
8112f3cc:	30bff916 	blt	r6,r2,8112f3b4 <__reset+0xfb10f3b4>
8112f3d0:	11800216 	blt	r2,r6,8112f3dc <__lesf2+0xb8>
8112f3d4:	1a3ff736 	bltu	r3,r8,8112f3b4 <__reset+0xfb10f3b4>
8112f3d8:	40c0022e 	bgeu	r8,r3,8112f3e4 <__lesf2+0xc0>
8112f3dc:	203fee1e 	bne	r4,zero,8112f398 <__reset+0xfb10f398>
8112f3e0:	003ff506 	br	8112f3b8 <__reset+0xfb10f3b8>
8112f3e4:	0005883a 	mov	r2,zero
8112f3e8:	f800283a 	ret

8112f3ec <__adddf3>:
8112f3ec:	02c00434 	movhi	r11,16
8112f3f0:	5affffc4 	addi	r11,r11,-1
8112f3f4:	2806d7fa 	srli	r3,r5,31
8112f3f8:	2ad4703a 	and	r10,r5,r11
8112f3fc:	3ad2703a 	and	r9,r7,r11
8112f400:	3804d53a 	srli	r2,r7,20
8112f404:	3018d77a 	srli	r12,r6,29
8112f408:	280ad53a 	srli	r5,r5,20
8112f40c:	501490fa 	slli	r10,r10,3
8112f410:	2010d77a 	srli	r8,r4,29
8112f414:	481290fa 	slli	r9,r9,3
8112f418:	380ed7fa 	srli	r7,r7,31
8112f41c:	defffb04 	addi	sp,sp,-20
8112f420:	de00012e 	bgeu	sp,et,8112f428 <__adddf3+0x3c>
8112f424:	003b68fa 	trap	3
8112f428:	dc800215 	stw	r18,8(sp)
8112f42c:	dc400115 	stw	r17,4(sp)
8112f430:	dc000015 	stw	r16,0(sp)
8112f434:	dfc00415 	stw	ra,16(sp)
8112f438:	dcc00315 	stw	r19,12(sp)
8112f43c:	1c803fcc 	andi	r18,r3,255
8112f440:	2c01ffcc 	andi	r16,r5,2047
8112f444:	5210b03a 	or	r8,r10,r8
8112f448:	202290fa 	slli	r17,r4,3
8112f44c:	1081ffcc 	andi	r2,r2,2047
8112f450:	4b12b03a 	or	r9,r9,r12
8112f454:	300c90fa 	slli	r6,r6,3
8112f458:	91c07526 	beq	r18,r7,8112f630 <__adddf3+0x244>
8112f45c:	8087c83a 	sub	r3,r16,r2
8112f460:	00c0ab0e 	bge	zero,r3,8112f710 <__adddf3+0x324>
8112f464:	10002a1e 	bne	r2,zero,8112f510 <__adddf3+0x124>
8112f468:	4984b03a 	or	r2,r9,r6
8112f46c:	1000961e 	bne	r2,zero,8112f6c8 <__adddf3+0x2dc>
8112f470:	888001cc 	andi	r2,r17,7
8112f474:	10000726 	beq	r2,zero,8112f494 <__adddf3+0xa8>
8112f478:	888003cc 	andi	r2,r17,15
8112f47c:	00c00104 	movi	r3,4
8112f480:	10c00426 	beq	r2,r3,8112f494 <__adddf3+0xa8>
8112f484:	88c7883a 	add	r3,r17,r3
8112f488:	1c63803a 	cmpltu	r17,r3,r17
8112f48c:	4451883a 	add	r8,r8,r17
8112f490:	1823883a 	mov	r17,r3
8112f494:	4080202c 	andhi	r2,r8,128
8112f498:	10005926 	beq	r2,zero,8112f600 <__adddf3+0x214>
8112f49c:	84000044 	addi	r16,r16,1
8112f4a0:	0081ffc4 	movi	r2,2047
8112f4a4:	8080ba26 	beq	r16,r2,8112f790 <__adddf3+0x3a4>
8112f4a8:	00bfe034 	movhi	r2,65408
8112f4ac:	10bfffc4 	addi	r2,r2,-1
8112f4b0:	4090703a 	and	r8,r8,r2
8112f4b4:	4004977a 	slli	r2,r8,29
8112f4b8:	4010927a 	slli	r8,r8,9
8112f4bc:	8822d0fa 	srli	r17,r17,3
8112f4c0:	8401ffcc 	andi	r16,r16,2047
8112f4c4:	4010d33a 	srli	r8,r8,12
8112f4c8:	9007883a 	mov	r3,r18
8112f4cc:	1444b03a 	or	r2,r2,r17
8112f4d0:	8401ffcc 	andi	r16,r16,2047
8112f4d4:	8020953a 	slli	r16,r16,20
8112f4d8:	18c03fcc 	andi	r3,r3,255
8112f4dc:	01000434 	movhi	r4,16
8112f4e0:	213fffc4 	addi	r4,r4,-1
8112f4e4:	180697fa 	slli	r3,r3,31
8112f4e8:	4110703a 	and	r8,r8,r4
8112f4ec:	4410b03a 	or	r8,r8,r16
8112f4f0:	40c6b03a 	or	r3,r8,r3
8112f4f4:	dfc00417 	ldw	ra,16(sp)
8112f4f8:	dcc00317 	ldw	r19,12(sp)
8112f4fc:	dc800217 	ldw	r18,8(sp)
8112f500:	dc400117 	ldw	r17,4(sp)
8112f504:	dc000017 	ldw	r16,0(sp)
8112f508:	dec00504 	addi	sp,sp,20
8112f50c:	f800283a 	ret
8112f510:	0081ffc4 	movi	r2,2047
8112f514:	80bfd626 	beq	r16,r2,8112f470 <__reset+0xfb10f470>
8112f518:	4a402034 	orhi	r9,r9,128
8112f51c:	00800e04 	movi	r2,56
8112f520:	10c09f16 	blt	r2,r3,8112f7a0 <__adddf3+0x3b4>
8112f524:	008007c4 	movi	r2,31
8112f528:	10c0c216 	blt	r2,r3,8112f834 <__adddf3+0x448>
8112f52c:	00800804 	movi	r2,32
8112f530:	10c5c83a 	sub	r2,r2,r3
8112f534:	488a983a 	sll	r5,r9,r2
8112f538:	30c8d83a 	srl	r4,r6,r3
8112f53c:	3084983a 	sll	r2,r6,r2
8112f540:	48c6d83a 	srl	r3,r9,r3
8112f544:	290cb03a 	or	r6,r5,r4
8112f548:	1004c03a 	cmpne	r2,r2,zero
8112f54c:	308cb03a 	or	r6,r6,r2
8112f550:	898dc83a 	sub	r6,r17,r6
8112f554:	89a3803a 	cmpltu	r17,r17,r6
8112f558:	40d1c83a 	sub	r8,r8,r3
8112f55c:	4451c83a 	sub	r8,r8,r17
8112f560:	3023883a 	mov	r17,r6
8112f564:	4080202c 	andhi	r2,r8,128
8112f568:	10002326 	beq	r2,zero,8112f5f8 <__adddf3+0x20c>
8112f56c:	04c02034 	movhi	r19,128
8112f570:	9cffffc4 	addi	r19,r19,-1
8112f574:	44e6703a 	and	r19,r8,r19
8112f578:	98007626 	beq	r19,zero,8112f754 <__adddf3+0x368>
8112f57c:	9809883a 	mov	r4,r19
8112f580:	111b8dc0 	call	8111b8dc <__clzsi2>
8112f584:	10fffe04 	addi	r3,r2,-8
8112f588:	010007c4 	movi	r4,31
8112f58c:	20c07716 	blt	r4,r3,8112f76c <__adddf3+0x380>
8112f590:	00800804 	movi	r2,32
8112f594:	10c5c83a 	sub	r2,r2,r3
8112f598:	8884d83a 	srl	r2,r17,r2
8112f59c:	98d0983a 	sll	r8,r19,r3
8112f5a0:	88e2983a 	sll	r17,r17,r3
8112f5a4:	1204b03a 	or	r2,r2,r8
8112f5a8:	1c007416 	blt	r3,r16,8112f77c <__adddf3+0x390>
8112f5ac:	1c21c83a 	sub	r16,r3,r16
8112f5b0:	82000044 	addi	r8,r16,1
8112f5b4:	00c007c4 	movi	r3,31
8112f5b8:	1a009116 	blt	r3,r8,8112f800 <__adddf3+0x414>
8112f5bc:	00c00804 	movi	r3,32
8112f5c0:	1a07c83a 	sub	r3,r3,r8
8112f5c4:	8a08d83a 	srl	r4,r17,r8
8112f5c8:	88e2983a 	sll	r17,r17,r3
8112f5cc:	10c6983a 	sll	r3,r2,r3
8112f5d0:	1210d83a 	srl	r8,r2,r8
8112f5d4:	8804c03a 	cmpne	r2,r17,zero
8112f5d8:	1906b03a 	or	r3,r3,r4
8112f5dc:	18a2b03a 	or	r17,r3,r2
8112f5e0:	0021883a 	mov	r16,zero
8112f5e4:	003fa206 	br	8112f470 <__reset+0xfb10f470>
8112f5e8:	1890b03a 	or	r8,r3,r2
8112f5ec:	40017d26 	beq	r8,zero,8112fbe4 <__adddf3+0x7f8>
8112f5f0:	1011883a 	mov	r8,r2
8112f5f4:	1823883a 	mov	r17,r3
8112f5f8:	888001cc 	andi	r2,r17,7
8112f5fc:	103f9e1e 	bne	r2,zero,8112f478 <__reset+0xfb10f478>
8112f600:	4004977a 	slli	r2,r8,29
8112f604:	8822d0fa 	srli	r17,r17,3
8112f608:	4010d0fa 	srli	r8,r8,3
8112f60c:	9007883a 	mov	r3,r18
8112f610:	1444b03a 	or	r2,r2,r17
8112f614:	0101ffc4 	movi	r4,2047
8112f618:	81002426 	beq	r16,r4,8112f6ac <__adddf3+0x2c0>
8112f61c:	8120703a 	and	r16,r16,r4
8112f620:	01000434 	movhi	r4,16
8112f624:	213fffc4 	addi	r4,r4,-1
8112f628:	4110703a 	and	r8,r8,r4
8112f62c:	003fa806 	br	8112f4d0 <__reset+0xfb10f4d0>
8112f630:	8089c83a 	sub	r4,r16,r2
8112f634:	01005e0e 	bge	zero,r4,8112f7b0 <__adddf3+0x3c4>
8112f638:	10002b26 	beq	r2,zero,8112f6e8 <__adddf3+0x2fc>
8112f63c:	0081ffc4 	movi	r2,2047
8112f640:	80bf8b26 	beq	r16,r2,8112f470 <__reset+0xfb10f470>
8112f644:	4a402034 	orhi	r9,r9,128
8112f648:	00800e04 	movi	r2,56
8112f64c:	1100a40e 	bge	r2,r4,8112f8e0 <__adddf3+0x4f4>
8112f650:	498cb03a 	or	r6,r9,r6
8112f654:	300ac03a 	cmpne	r5,r6,zero
8112f658:	0013883a 	mov	r9,zero
8112f65c:	2c4b883a 	add	r5,r5,r17
8112f660:	2c63803a 	cmpltu	r17,r5,r17
8112f664:	4a11883a 	add	r8,r9,r8
8112f668:	8a11883a 	add	r8,r17,r8
8112f66c:	2823883a 	mov	r17,r5
8112f670:	4080202c 	andhi	r2,r8,128
8112f674:	103fe026 	beq	r2,zero,8112f5f8 <__reset+0xfb10f5f8>
8112f678:	84000044 	addi	r16,r16,1
8112f67c:	0081ffc4 	movi	r2,2047
8112f680:	8080d226 	beq	r16,r2,8112f9cc <__adddf3+0x5e0>
8112f684:	00bfe034 	movhi	r2,65408
8112f688:	10bfffc4 	addi	r2,r2,-1
8112f68c:	4090703a 	and	r8,r8,r2
8112f690:	880ad07a 	srli	r5,r17,1
8112f694:	400897fa 	slli	r4,r8,31
8112f698:	88c0004c 	andi	r3,r17,1
8112f69c:	28e2b03a 	or	r17,r5,r3
8112f6a0:	4010d07a 	srli	r8,r8,1
8112f6a4:	2462b03a 	or	r17,r4,r17
8112f6a8:	003f7106 	br	8112f470 <__reset+0xfb10f470>
8112f6ac:	4088b03a 	or	r4,r8,r2
8112f6b0:	20014526 	beq	r4,zero,8112fbc8 <__adddf3+0x7dc>
8112f6b4:	01000434 	movhi	r4,16
8112f6b8:	42000234 	orhi	r8,r8,8
8112f6bc:	213fffc4 	addi	r4,r4,-1
8112f6c0:	4110703a 	and	r8,r8,r4
8112f6c4:	003f8206 	br	8112f4d0 <__reset+0xfb10f4d0>
8112f6c8:	18ffffc4 	addi	r3,r3,-1
8112f6cc:	1800491e 	bne	r3,zero,8112f7f4 <__adddf3+0x408>
8112f6d0:	898bc83a 	sub	r5,r17,r6
8112f6d4:	8963803a 	cmpltu	r17,r17,r5
8112f6d8:	4251c83a 	sub	r8,r8,r9
8112f6dc:	4451c83a 	sub	r8,r8,r17
8112f6e0:	2823883a 	mov	r17,r5
8112f6e4:	003f9f06 	br	8112f564 <__reset+0xfb10f564>
8112f6e8:	4984b03a 	or	r2,r9,r6
8112f6ec:	103f6026 	beq	r2,zero,8112f470 <__reset+0xfb10f470>
8112f6f0:	213fffc4 	addi	r4,r4,-1
8112f6f4:	2000931e 	bne	r4,zero,8112f944 <__adddf3+0x558>
8112f6f8:	898d883a 	add	r6,r17,r6
8112f6fc:	3463803a 	cmpltu	r17,r6,r17
8112f700:	4251883a 	add	r8,r8,r9
8112f704:	8a11883a 	add	r8,r17,r8
8112f708:	3023883a 	mov	r17,r6
8112f70c:	003fd806 	br	8112f670 <__reset+0xfb10f670>
8112f710:	1800541e 	bne	r3,zero,8112f864 <__adddf3+0x478>
8112f714:	80800044 	addi	r2,r16,1
8112f718:	1081ffcc 	andi	r2,r2,2047
8112f71c:	00c00044 	movi	r3,1
8112f720:	1880a00e 	bge	r3,r2,8112f9a4 <__adddf3+0x5b8>
8112f724:	8989c83a 	sub	r4,r17,r6
8112f728:	8905803a 	cmpltu	r2,r17,r4
8112f72c:	4267c83a 	sub	r19,r8,r9
8112f730:	98a7c83a 	sub	r19,r19,r2
8112f734:	9880202c 	andhi	r2,r19,128
8112f738:	10006326 	beq	r2,zero,8112f8c8 <__adddf3+0x4dc>
8112f73c:	3463c83a 	sub	r17,r6,r17
8112f740:	4a07c83a 	sub	r3,r9,r8
8112f744:	344d803a 	cmpltu	r6,r6,r17
8112f748:	19a7c83a 	sub	r19,r3,r6
8112f74c:	3825883a 	mov	r18,r7
8112f750:	983f8a1e 	bne	r19,zero,8112f57c <__reset+0xfb10f57c>
8112f754:	8809883a 	mov	r4,r17
8112f758:	111b8dc0 	call	8111b8dc <__clzsi2>
8112f75c:	10800804 	addi	r2,r2,32
8112f760:	10fffe04 	addi	r3,r2,-8
8112f764:	010007c4 	movi	r4,31
8112f768:	20ff890e 	bge	r4,r3,8112f590 <__reset+0xfb10f590>
8112f76c:	10bff604 	addi	r2,r2,-40
8112f770:	8884983a 	sll	r2,r17,r2
8112f774:	0023883a 	mov	r17,zero
8112f778:	1c3f8c0e 	bge	r3,r16,8112f5ac <__reset+0xfb10f5ac>
8112f77c:	023fe034 	movhi	r8,65408
8112f780:	423fffc4 	addi	r8,r8,-1
8112f784:	80e1c83a 	sub	r16,r16,r3
8112f788:	1210703a 	and	r8,r2,r8
8112f78c:	003f3806 	br	8112f470 <__reset+0xfb10f470>
8112f790:	9007883a 	mov	r3,r18
8112f794:	0011883a 	mov	r8,zero
8112f798:	0005883a 	mov	r2,zero
8112f79c:	003f4c06 	br	8112f4d0 <__reset+0xfb10f4d0>
8112f7a0:	498cb03a 	or	r6,r9,r6
8112f7a4:	300cc03a 	cmpne	r6,r6,zero
8112f7a8:	0007883a 	mov	r3,zero
8112f7ac:	003f6806 	br	8112f550 <__reset+0xfb10f550>
8112f7b0:	20009c1e 	bne	r4,zero,8112fa24 <__adddf3+0x638>
8112f7b4:	80800044 	addi	r2,r16,1
8112f7b8:	1141ffcc 	andi	r5,r2,2047
8112f7bc:	01000044 	movi	r4,1
8112f7c0:	2140670e 	bge	r4,r5,8112f960 <__adddf3+0x574>
8112f7c4:	0101ffc4 	movi	r4,2047
8112f7c8:	11007f26 	beq	r2,r4,8112f9c8 <__adddf3+0x5dc>
8112f7cc:	898d883a 	add	r6,r17,r6
8112f7d0:	4247883a 	add	r3,r8,r9
8112f7d4:	3451803a 	cmpltu	r8,r6,r17
8112f7d8:	40d1883a 	add	r8,r8,r3
8112f7dc:	402297fa 	slli	r17,r8,31
8112f7e0:	300cd07a 	srli	r6,r6,1
8112f7e4:	4010d07a 	srli	r8,r8,1
8112f7e8:	1021883a 	mov	r16,r2
8112f7ec:	89a2b03a 	or	r17,r17,r6
8112f7f0:	003f1f06 	br	8112f470 <__reset+0xfb10f470>
8112f7f4:	0081ffc4 	movi	r2,2047
8112f7f8:	80bf481e 	bne	r16,r2,8112f51c <__reset+0xfb10f51c>
8112f7fc:	003f1c06 	br	8112f470 <__reset+0xfb10f470>
8112f800:	843ff844 	addi	r16,r16,-31
8112f804:	01000804 	movi	r4,32
8112f808:	1406d83a 	srl	r3,r2,r16
8112f80c:	41005026 	beq	r8,r4,8112f950 <__adddf3+0x564>
8112f810:	01001004 	movi	r4,64
8112f814:	2211c83a 	sub	r8,r4,r8
8112f818:	1204983a 	sll	r2,r2,r8
8112f81c:	88a2b03a 	or	r17,r17,r2
8112f820:	8822c03a 	cmpne	r17,r17,zero
8112f824:	1c62b03a 	or	r17,r3,r17
8112f828:	0011883a 	mov	r8,zero
8112f82c:	0021883a 	mov	r16,zero
8112f830:	003f7106 	br	8112f5f8 <__reset+0xfb10f5f8>
8112f834:	193ff804 	addi	r4,r3,-32
8112f838:	00800804 	movi	r2,32
8112f83c:	4908d83a 	srl	r4,r9,r4
8112f840:	18804526 	beq	r3,r2,8112f958 <__adddf3+0x56c>
8112f844:	00801004 	movi	r2,64
8112f848:	10c5c83a 	sub	r2,r2,r3
8112f84c:	4886983a 	sll	r3,r9,r2
8112f850:	198cb03a 	or	r6,r3,r6
8112f854:	300cc03a 	cmpne	r6,r6,zero
8112f858:	218cb03a 	or	r6,r4,r6
8112f85c:	0007883a 	mov	r3,zero
8112f860:	003f3b06 	br	8112f550 <__reset+0xfb10f550>
8112f864:	80002a26 	beq	r16,zero,8112f910 <__adddf3+0x524>
8112f868:	0101ffc4 	movi	r4,2047
8112f86c:	11006826 	beq	r2,r4,8112fa10 <__adddf3+0x624>
8112f870:	00c7c83a 	sub	r3,zero,r3
8112f874:	42002034 	orhi	r8,r8,128
8112f878:	01000e04 	movi	r4,56
8112f87c:	20c07c16 	blt	r4,r3,8112fa70 <__adddf3+0x684>
8112f880:	010007c4 	movi	r4,31
8112f884:	20c0da16 	blt	r4,r3,8112fbf0 <__adddf3+0x804>
8112f888:	01000804 	movi	r4,32
8112f88c:	20c9c83a 	sub	r4,r4,r3
8112f890:	4114983a 	sll	r10,r8,r4
8112f894:	88cad83a 	srl	r5,r17,r3
8112f898:	8908983a 	sll	r4,r17,r4
8112f89c:	40c6d83a 	srl	r3,r8,r3
8112f8a0:	5162b03a 	or	r17,r10,r5
8112f8a4:	2008c03a 	cmpne	r4,r4,zero
8112f8a8:	8922b03a 	or	r17,r17,r4
8112f8ac:	3463c83a 	sub	r17,r6,r17
8112f8b0:	48c7c83a 	sub	r3,r9,r3
8112f8b4:	344d803a 	cmpltu	r6,r6,r17
8112f8b8:	1991c83a 	sub	r8,r3,r6
8112f8bc:	1021883a 	mov	r16,r2
8112f8c0:	3825883a 	mov	r18,r7
8112f8c4:	003f2706 	br	8112f564 <__reset+0xfb10f564>
8112f8c8:	24d0b03a 	or	r8,r4,r19
8112f8cc:	40001b1e 	bne	r8,zero,8112f93c <__adddf3+0x550>
8112f8d0:	0005883a 	mov	r2,zero
8112f8d4:	0007883a 	mov	r3,zero
8112f8d8:	0021883a 	mov	r16,zero
8112f8dc:	003f4d06 	br	8112f614 <__reset+0xfb10f614>
8112f8e0:	008007c4 	movi	r2,31
8112f8e4:	11003c16 	blt	r2,r4,8112f9d8 <__adddf3+0x5ec>
8112f8e8:	00800804 	movi	r2,32
8112f8ec:	1105c83a 	sub	r2,r2,r4
8112f8f0:	488e983a 	sll	r7,r9,r2
8112f8f4:	310ad83a 	srl	r5,r6,r4
8112f8f8:	3084983a 	sll	r2,r6,r2
8112f8fc:	4912d83a 	srl	r9,r9,r4
8112f900:	394ab03a 	or	r5,r7,r5
8112f904:	1004c03a 	cmpne	r2,r2,zero
8112f908:	288ab03a 	or	r5,r5,r2
8112f90c:	003f5306 	br	8112f65c <__reset+0xfb10f65c>
8112f910:	4448b03a 	or	r4,r8,r17
8112f914:	20003e26 	beq	r4,zero,8112fa10 <__adddf3+0x624>
8112f918:	00c6303a 	nor	r3,zero,r3
8112f91c:	18003a1e 	bne	r3,zero,8112fa08 <__adddf3+0x61c>
8112f920:	3463c83a 	sub	r17,r6,r17
8112f924:	4a07c83a 	sub	r3,r9,r8
8112f928:	344d803a 	cmpltu	r6,r6,r17
8112f92c:	1991c83a 	sub	r8,r3,r6
8112f930:	1021883a 	mov	r16,r2
8112f934:	3825883a 	mov	r18,r7
8112f938:	003f0a06 	br	8112f564 <__reset+0xfb10f564>
8112f93c:	2023883a 	mov	r17,r4
8112f940:	003f0d06 	br	8112f578 <__reset+0xfb10f578>
8112f944:	0081ffc4 	movi	r2,2047
8112f948:	80bf3f1e 	bne	r16,r2,8112f648 <__reset+0xfb10f648>
8112f94c:	003ec806 	br	8112f470 <__reset+0xfb10f470>
8112f950:	0005883a 	mov	r2,zero
8112f954:	003fb106 	br	8112f81c <__reset+0xfb10f81c>
8112f958:	0007883a 	mov	r3,zero
8112f95c:	003fbc06 	br	8112f850 <__reset+0xfb10f850>
8112f960:	4444b03a 	or	r2,r8,r17
8112f964:	8000871e 	bne	r16,zero,8112fb84 <__adddf3+0x798>
8112f968:	1000ba26 	beq	r2,zero,8112fc54 <__adddf3+0x868>
8112f96c:	4984b03a 	or	r2,r9,r6
8112f970:	103ebf26 	beq	r2,zero,8112f470 <__reset+0xfb10f470>
8112f974:	8985883a 	add	r2,r17,r6
8112f978:	4247883a 	add	r3,r8,r9
8112f97c:	1451803a 	cmpltu	r8,r2,r17
8112f980:	40d1883a 	add	r8,r8,r3
8112f984:	40c0202c 	andhi	r3,r8,128
8112f988:	1023883a 	mov	r17,r2
8112f98c:	183f1a26 	beq	r3,zero,8112f5f8 <__reset+0xfb10f5f8>
8112f990:	00bfe034 	movhi	r2,65408
8112f994:	10bfffc4 	addi	r2,r2,-1
8112f998:	2021883a 	mov	r16,r4
8112f99c:	4090703a 	and	r8,r8,r2
8112f9a0:	003eb306 	br	8112f470 <__reset+0xfb10f470>
8112f9a4:	4444b03a 	or	r2,r8,r17
8112f9a8:	8000291e 	bne	r16,zero,8112fa50 <__adddf3+0x664>
8112f9ac:	10004b1e 	bne	r2,zero,8112fadc <__adddf3+0x6f0>
8112f9b0:	4990b03a 	or	r8,r9,r6
8112f9b4:	40008b26 	beq	r8,zero,8112fbe4 <__adddf3+0x7f8>
8112f9b8:	4811883a 	mov	r8,r9
8112f9bc:	3023883a 	mov	r17,r6
8112f9c0:	3825883a 	mov	r18,r7
8112f9c4:	003eaa06 	br	8112f470 <__reset+0xfb10f470>
8112f9c8:	1021883a 	mov	r16,r2
8112f9cc:	0011883a 	mov	r8,zero
8112f9d0:	0005883a 	mov	r2,zero
8112f9d4:	003f0f06 	br	8112f614 <__reset+0xfb10f614>
8112f9d8:	217ff804 	addi	r5,r4,-32
8112f9dc:	00800804 	movi	r2,32
8112f9e0:	494ad83a 	srl	r5,r9,r5
8112f9e4:	20807d26 	beq	r4,r2,8112fbdc <__adddf3+0x7f0>
8112f9e8:	00801004 	movi	r2,64
8112f9ec:	1109c83a 	sub	r4,r2,r4
8112f9f0:	4912983a 	sll	r9,r9,r4
8112f9f4:	498cb03a 	or	r6,r9,r6
8112f9f8:	300cc03a 	cmpne	r6,r6,zero
8112f9fc:	298ab03a 	or	r5,r5,r6
8112fa00:	0013883a 	mov	r9,zero
8112fa04:	003f1506 	br	8112f65c <__reset+0xfb10f65c>
8112fa08:	0101ffc4 	movi	r4,2047
8112fa0c:	113f9a1e 	bne	r2,r4,8112f878 <__reset+0xfb10f878>
8112fa10:	4811883a 	mov	r8,r9
8112fa14:	3023883a 	mov	r17,r6
8112fa18:	1021883a 	mov	r16,r2
8112fa1c:	3825883a 	mov	r18,r7
8112fa20:	003e9306 	br	8112f470 <__reset+0xfb10f470>
8112fa24:	8000161e 	bne	r16,zero,8112fa80 <__adddf3+0x694>
8112fa28:	444ab03a 	or	r5,r8,r17
8112fa2c:	28005126 	beq	r5,zero,8112fb74 <__adddf3+0x788>
8112fa30:	0108303a 	nor	r4,zero,r4
8112fa34:	20004d1e 	bne	r4,zero,8112fb6c <__adddf3+0x780>
8112fa38:	89a3883a 	add	r17,r17,r6
8112fa3c:	4253883a 	add	r9,r8,r9
8112fa40:	898d803a 	cmpltu	r6,r17,r6
8112fa44:	3251883a 	add	r8,r6,r9
8112fa48:	1021883a 	mov	r16,r2
8112fa4c:	003f0806 	br	8112f670 <__reset+0xfb10f670>
8112fa50:	1000301e 	bne	r2,zero,8112fb14 <__adddf3+0x728>
8112fa54:	4984b03a 	or	r2,r9,r6
8112fa58:	10007126 	beq	r2,zero,8112fc20 <__adddf3+0x834>
8112fa5c:	4811883a 	mov	r8,r9
8112fa60:	3023883a 	mov	r17,r6
8112fa64:	3825883a 	mov	r18,r7
8112fa68:	0401ffc4 	movi	r16,2047
8112fa6c:	003e8006 	br	8112f470 <__reset+0xfb10f470>
8112fa70:	4462b03a 	or	r17,r8,r17
8112fa74:	8822c03a 	cmpne	r17,r17,zero
8112fa78:	0007883a 	mov	r3,zero
8112fa7c:	003f8b06 	br	8112f8ac <__reset+0xfb10f8ac>
8112fa80:	0141ffc4 	movi	r5,2047
8112fa84:	11403b26 	beq	r2,r5,8112fb74 <__adddf3+0x788>
8112fa88:	0109c83a 	sub	r4,zero,r4
8112fa8c:	42002034 	orhi	r8,r8,128
8112fa90:	01400e04 	movi	r5,56
8112fa94:	29006716 	blt	r5,r4,8112fc34 <__adddf3+0x848>
8112fa98:	014007c4 	movi	r5,31
8112fa9c:	29007016 	blt	r5,r4,8112fc60 <__adddf3+0x874>
8112faa0:	01400804 	movi	r5,32
8112faa4:	290bc83a 	sub	r5,r5,r4
8112faa8:	4154983a 	sll	r10,r8,r5
8112faac:	890ed83a 	srl	r7,r17,r4
8112fab0:	894a983a 	sll	r5,r17,r5
8112fab4:	4108d83a 	srl	r4,r8,r4
8112fab8:	51e2b03a 	or	r17,r10,r7
8112fabc:	280ac03a 	cmpne	r5,r5,zero
8112fac0:	8962b03a 	or	r17,r17,r5
8112fac4:	89a3883a 	add	r17,r17,r6
8112fac8:	2253883a 	add	r9,r4,r9
8112facc:	898d803a 	cmpltu	r6,r17,r6
8112fad0:	3251883a 	add	r8,r6,r9
8112fad4:	1021883a 	mov	r16,r2
8112fad8:	003ee506 	br	8112f670 <__reset+0xfb10f670>
8112fadc:	4984b03a 	or	r2,r9,r6
8112fae0:	103e6326 	beq	r2,zero,8112f470 <__reset+0xfb10f470>
8112fae4:	8987c83a 	sub	r3,r17,r6
8112fae8:	88c9803a 	cmpltu	r4,r17,r3
8112faec:	4245c83a 	sub	r2,r8,r9
8112faf0:	1105c83a 	sub	r2,r2,r4
8112faf4:	1100202c 	andhi	r4,r2,128
8112faf8:	203ebb26 	beq	r4,zero,8112f5e8 <__reset+0xfb10f5e8>
8112fafc:	3463c83a 	sub	r17,r6,r17
8112fb00:	4a07c83a 	sub	r3,r9,r8
8112fb04:	344d803a 	cmpltu	r6,r6,r17
8112fb08:	1991c83a 	sub	r8,r3,r6
8112fb0c:	3825883a 	mov	r18,r7
8112fb10:	003e5706 	br	8112f470 <__reset+0xfb10f470>
8112fb14:	4984b03a 	or	r2,r9,r6
8112fb18:	10002e26 	beq	r2,zero,8112fbd4 <__adddf3+0x7e8>
8112fb1c:	4004d0fa 	srli	r2,r8,3
8112fb20:	8822d0fa 	srli	r17,r17,3
8112fb24:	4010977a 	slli	r8,r8,29
8112fb28:	10c0022c 	andhi	r3,r2,8
8112fb2c:	4462b03a 	or	r17,r8,r17
8112fb30:	18000826 	beq	r3,zero,8112fb54 <__adddf3+0x768>
8112fb34:	4808d0fa 	srli	r4,r9,3
8112fb38:	20c0022c 	andhi	r3,r4,8
8112fb3c:	1800051e 	bne	r3,zero,8112fb54 <__adddf3+0x768>
8112fb40:	300cd0fa 	srli	r6,r6,3
8112fb44:	4806977a 	slli	r3,r9,29
8112fb48:	2005883a 	mov	r2,r4
8112fb4c:	3825883a 	mov	r18,r7
8112fb50:	19a2b03a 	or	r17,r3,r6
8112fb54:	8810d77a 	srli	r8,r17,29
8112fb58:	100490fa 	slli	r2,r2,3
8112fb5c:	882290fa 	slli	r17,r17,3
8112fb60:	0401ffc4 	movi	r16,2047
8112fb64:	4090b03a 	or	r8,r8,r2
8112fb68:	003e4106 	br	8112f470 <__reset+0xfb10f470>
8112fb6c:	0141ffc4 	movi	r5,2047
8112fb70:	117fc71e 	bne	r2,r5,8112fa90 <__reset+0xfb10fa90>
8112fb74:	4811883a 	mov	r8,r9
8112fb78:	3023883a 	mov	r17,r6
8112fb7c:	1021883a 	mov	r16,r2
8112fb80:	003e3b06 	br	8112f470 <__reset+0xfb10f470>
8112fb84:	10002f26 	beq	r2,zero,8112fc44 <__adddf3+0x858>
8112fb88:	4984b03a 	or	r2,r9,r6
8112fb8c:	10001126 	beq	r2,zero,8112fbd4 <__adddf3+0x7e8>
8112fb90:	4004d0fa 	srli	r2,r8,3
8112fb94:	8822d0fa 	srli	r17,r17,3
8112fb98:	4010977a 	slli	r8,r8,29
8112fb9c:	10c0022c 	andhi	r3,r2,8
8112fba0:	4462b03a 	or	r17,r8,r17
8112fba4:	183feb26 	beq	r3,zero,8112fb54 <__reset+0xfb10fb54>
8112fba8:	4808d0fa 	srli	r4,r9,3
8112fbac:	20c0022c 	andhi	r3,r4,8
8112fbb0:	183fe81e 	bne	r3,zero,8112fb54 <__reset+0xfb10fb54>
8112fbb4:	300cd0fa 	srli	r6,r6,3
8112fbb8:	4806977a 	slli	r3,r9,29
8112fbbc:	2005883a 	mov	r2,r4
8112fbc0:	19a2b03a 	or	r17,r3,r6
8112fbc4:	003fe306 	br	8112fb54 <__reset+0xfb10fb54>
8112fbc8:	0011883a 	mov	r8,zero
8112fbcc:	0005883a 	mov	r2,zero
8112fbd0:	003e3f06 	br	8112f4d0 <__reset+0xfb10f4d0>
8112fbd4:	0401ffc4 	movi	r16,2047
8112fbd8:	003e2506 	br	8112f470 <__reset+0xfb10f470>
8112fbdc:	0013883a 	mov	r9,zero
8112fbe0:	003f8406 	br	8112f9f4 <__reset+0xfb10f9f4>
8112fbe4:	0005883a 	mov	r2,zero
8112fbe8:	0007883a 	mov	r3,zero
8112fbec:	003e8906 	br	8112f614 <__reset+0xfb10f614>
8112fbf0:	197ff804 	addi	r5,r3,-32
8112fbf4:	01000804 	movi	r4,32
8112fbf8:	414ad83a 	srl	r5,r8,r5
8112fbfc:	19002426 	beq	r3,r4,8112fc90 <__adddf3+0x8a4>
8112fc00:	01001004 	movi	r4,64
8112fc04:	20c7c83a 	sub	r3,r4,r3
8112fc08:	40c6983a 	sll	r3,r8,r3
8112fc0c:	1c46b03a 	or	r3,r3,r17
8112fc10:	1806c03a 	cmpne	r3,r3,zero
8112fc14:	28e2b03a 	or	r17,r5,r3
8112fc18:	0007883a 	mov	r3,zero
8112fc1c:	003f2306 	br	8112f8ac <__reset+0xfb10f8ac>
8112fc20:	0007883a 	mov	r3,zero
8112fc24:	5811883a 	mov	r8,r11
8112fc28:	00bfffc4 	movi	r2,-1
8112fc2c:	0401ffc4 	movi	r16,2047
8112fc30:	003e7806 	br	8112f614 <__reset+0xfb10f614>
8112fc34:	4462b03a 	or	r17,r8,r17
8112fc38:	8822c03a 	cmpne	r17,r17,zero
8112fc3c:	0009883a 	mov	r4,zero
8112fc40:	003fa006 	br	8112fac4 <__reset+0xfb10fac4>
8112fc44:	4811883a 	mov	r8,r9
8112fc48:	3023883a 	mov	r17,r6
8112fc4c:	0401ffc4 	movi	r16,2047
8112fc50:	003e0706 	br	8112f470 <__reset+0xfb10f470>
8112fc54:	4811883a 	mov	r8,r9
8112fc58:	3023883a 	mov	r17,r6
8112fc5c:	003e0406 	br	8112f470 <__reset+0xfb10f470>
8112fc60:	21fff804 	addi	r7,r4,-32
8112fc64:	01400804 	movi	r5,32
8112fc68:	41ced83a 	srl	r7,r8,r7
8112fc6c:	21400a26 	beq	r4,r5,8112fc98 <__adddf3+0x8ac>
8112fc70:	01401004 	movi	r5,64
8112fc74:	2909c83a 	sub	r4,r5,r4
8112fc78:	4108983a 	sll	r4,r8,r4
8112fc7c:	2448b03a 	or	r4,r4,r17
8112fc80:	2008c03a 	cmpne	r4,r4,zero
8112fc84:	3922b03a 	or	r17,r7,r4
8112fc88:	0009883a 	mov	r4,zero
8112fc8c:	003f8d06 	br	8112fac4 <__reset+0xfb10fac4>
8112fc90:	0007883a 	mov	r3,zero
8112fc94:	003fdd06 	br	8112fc0c <__reset+0xfb10fc0c>
8112fc98:	0009883a 	mov	r4,zero
8112fc9c:	003ff706 	br	8112fc7c <__reset+0xfb10fc7c>

8112fca0 <__divdf3>:
8112fca0:	defff204 	addi	sp,sp,-56
8112fca4:	de00012e 	bgeu	sp,et,8112fcac <__divdf3+0xc>
8112fca8:	003b68fa 	trap	3
8112fcac:	dd400915 	stw	r21,36(sp)
8112fcb0:	282ad53a 	srli	r21,r5,20
8112fcb4:	dd000815 	stw	r20,32(sp)
8112fcb8:	2828d7fa 	srli	r20,r5,31
8112fcbc:	dc000415 	stw	r16,16(sp)
8112fcc0:	04000434 	movhi	r16,16
8112fcc4:	df000c15 	stw	fp,48(sp)
8112fcc8:	843fffc4 	addi	r16,r16,-1
8112fccc:	dfc00d15 	stw	ra,52(sp)
8112fcd0:	ddc00b15 	stw	r23,44(sp)
8112fcd4:	dd800a15 	stw	r22,40(sp)
8112fcd8:	dcc00715 	stw	r19,28(sp)
8112fcdc:	dc800615 	stw	r18,24(sp)
8112fce0:	dc400515 	stw	r17,20(sp)
8112fce4:	ad41ffcc 	andi	r21,r21,2047
8112fce8:	2c20703a 	and	r16,r5,r16
8112fcec:	a7003fcc 	andi	fp,r20,255
8112fcf0:	a8006126 	beq	r21,zero,8112fe78 <__divdf3+0x1d8>
8112fcf4:	0081ffc4 	movi	r2,2047
8112fcf8:	2025883a 	mov	r18,r4
8112fcfc:	a8803726 	beq	r21,r2,8112fddc <__divdf3+0x13c>
8112fd00:	80800434 	orhi	r2,r16,16
8112fd04:	100490fa 	slli	r2,r2,3
8112fd08:	2020d77a 	srli	r16,r4,29
8112fd0c:	202490fa 	slli	r18,r4,3
8112fd10:	ad7f0044 	addi	r21,r21,-1023
8112fd14:	80a0b03a 	or	r16,r16,r2
8112fd18:	0027883a 	mov	r19,zero
8112fd1c:	0013883a 	mov	r9,zero
8112fd20:	3804d53a 	srli	r2,r7,20
8112fd24:	382cd7fa 	srli	r22,r7,31
8112fd28:	04400434 	movhi	r17,16
8112fd2c:	8c7fffc4 	addi	r17,r17,-1
8112fd30:	1081ffcc 	andi	r2,r2,2047
8112fd34:	3011883a 	mov	r8,r6
8112fd38:	3c62703a 	and	r17,r7,r17
8112fd3c:	b5c03fcc 	andi	r23,r22,255
8112fd40:	10006c26 	beq	r2,zero,8112fef4 <__divdf3+0x254>
8112fd44:	00c1ffc4 	movi	r3,2047
8112fd48:	10c06426 	beq	r2,r3,8112fedc <__divdf3+0x23c>
8112fd4c:	88c00434 	orhi	r3,r17,16
8112fd50:	180690fa 	slli	r3,r3,3
8112fd54:	3022d77a 	srli	r17,r6,29
8112fd58:	301090fa 	slli	r8,r6,3
8112fd5c:	10bf0044 	addi	r2,r2,-1023
8112fd60:	88e2b03a 	or	r17,r17,r3
8112fd64:	000f883a 	mov	r7,zero
8112fd68:	a58cf03a 	xor	r6,r20,r22
8112fd6c:	3cc8b03a 	or	r4,r7,r19
8112fd70:	a8abc83a 	sub	r21,r21,r2
8112fd74:	008003c4 	movi	r2,15
8112fd78:	3007883a 	mov	r3,r6
8112fd7c:	34c03fcc 	andi	r19,r6,255
8112fd80:	11009036 	bltu	r2,r4,8112ffc4 <__divdf3+0x324>
8112fd84:	200890ba 	slli	r4,r4,2
8112fd88:	00a044f4 	movhi	r2,33043
8112fd8c:	10bf6704 	addi	r2,r2,-612
8112fd90:	2089883a 	add	r4,r4,r2
8112fd94:	20800017 	ldw	r2,0(r4)
8112fd98:	1000683a 	jmp	r2
8112fd9c:	8112ffc4 	addi	r4,r16,19455
8112fda0:	8112fe14 	ori	r4,r16,19448
8112fda4:	8112ffb4 	orhi	r4,r16,19454
8112fda8:	8112fe08 	cmpgei	r4,r16,19448
8112fdac:	8112ffb4 	orhi	r4,r16,19454
8112fdb0:	8112ff88 	cmpgei	r4,r16,19454
8112fdb4:	8112ffb4 	orhi	r4,r16,19454
8112fdb8:	8112fe08 	cmpgei	r4,r16,19448
8112fdbc:	8112fe14 	ori	r4,r16,19448
8112fdc0:	8112fe14 	ori	r4,r16,19448
8112fdc4:	8112ff88 	cmpgei	r4,r16,19454
8112fdc8:	8112fe08 	cmpgei	r4,r16,19448
8112fdcc:	8112fdf8 	rdprs	r4,r16,19447
8112fdd0:	8112fdf8 	rdprs	r4,r16,19447
8112fdd4:	8112fdf8 	rdprs	r4,r16,19447
8112fdd8:	811302a8 	cmpgeui	r4,r16,19466
8112fddc:	2404b03a 	or	r2,r4,r16
8112fde0:	1000661e 	bne	r2,zero,8112ff7c <__divdf3+0x2dc>
8112fde4:	04c00204 	movi	r19,8
8112fde8:	0021883a 	mov	r16,zero
8112fdec:	0025883a 	mov	r18,zero
8112fdf0:	02400084 	movi	r9,2
8112fdf4:	003fca06 	br	8112fd20 <__reset+0xfb10fd20>
8112fdf8:	8023883a 	mov	r17,r16
8112fdfc:	9011883a 	mov	r8,r18
8112fe00:	e02f883a 	mov	r23,fp
8112fe04:	480f883a 	mov	r7,r9
8112fe08:	00800084 	movi	r2,2
8112fe0c:	3881311e 	bne	r7,r2,811302d4 <__divdf3+0x634>
8112fe10:	b827883a 	mov	r19,r23
8112fe14:	98c0004c 	andi	r3,r19,1
8112fe18:	0081ffc4 	movi	r2,2047
8112fe1c:	000b883a 	mov	r5,zero
8112fe20:	0025883a 	mov	r18,zero
8112fe24:	1004953a 	slli	r2,r2,20
8112fe28:	18c03fcc 	andi	r3,r3,255
8112fe2c:	04400434 	movhi	r17,16
8112fe30:	8c7fffc4 	addi	r17,r17,-1
8112fe34:	180697fa 	slli	r3,r3,31
8112fe38:	2c4a703a 	and	r5,r5,r17
8112fe3c:	288ab03a 	or	r5,r5,r2
8112fe40:	28c6b03a 	or	r3,r5,r3
8112fe44:	9005883a 	mov	r2,r18
8112fe48:	dfc00d17 	ldw	ra,52(sp)
8112fe4c:	df000c17 	ldw	fp,48(sp)
8112fe50:	ddc00b17 	ldw	r23,44(sp)
8112fe54:	dd800a17 	ldw	r22,40(sp)
8112fe58:	dd400917 	ldw	r21,36(sp)
8112fe5c:	dd000817 	ldw	r20,32(sp)
8112fe60:	dcc00717 	ldw	r19,28(sp)
8112fe64:	dc800617 	ldw	r18,24(sp)
8112fe68:	dc400517 	ldw	r17,20(sp)
8112fe6c:	dc000417 	ldw	r16,16(sp)
8112fe70:	dec00e04 	addi	sp,sp,56
8112fe74:	f800283a 	ret
8112fe78:	2404b03a 	or	r2,r4,r16
8112fe7c:	2027883a 	mov	r19,r4
8112fe80:	10003926 	beq	r2,zero,8112ff68 <__divdf3+0x2c8>
8112fe84:	80012e26 	beq	r16,zero,81130340 <__divdf3+0x6a0>
8112fe88:	8009883a 	mov	r4,r16
8112fe8c:	d9800315 	stw	r6,12(sp)
8112fe90:	d9c00215 	stw	r7,8(sp)
8112fe94:	111b8dc0 	call	8111b8dc <__clzsi2>
8112fe98:	d9800317 	ldw	r6,12(sp)
8112fe9c:	d9c00217 	ldw	r7,8(sp)
8112fea0:	113ffd44 	addi	r4,r2,-11
8112fea4:	00c00704 	movi	r3,28
8112fea8:	19012116 	blt	r3,r4,81130330 <__divdf3+0x690>
8112feac:	00c00744 	movi	r3,29
8112feb0:	147ffe04 	addi	r17,r2,-8
8112feb4:	1907c83a 	sub	r3,r3,r4
8112feb8:	8460983a 	sll	r16,r16,r17
8112febc:	98c6d83a 	srl	r3,r19,r3
8112fec0:	9c64983a 	sll	r18,r19,r17
8112fec4:	1c20b03a 	or	r16,r3,r16
8112fec8:	1080fcc4 	addi	r2,r2,1011
8112fecc:	00abc83a 	sub	r21,zero,r2
8112fed0:	0027883a 	mov	r19,zero
8112fed4:	0013883a 	mov	r9,zero
8112fed8:	003f9106 	br	8112fd20 <__reset+0xfb10fd20>
8112fedc:	3446b03a 	or	r3,r6,r17
8112fee0:	18001f1e 	bne	r3,zero,8112ff60 <__divdf3+0x2c0>
8112fee4:	0023883a 	mov	r17,zero
8112fee8:	0011883a 	mov	r8,zero
8112feec:	01c00084 	movi	r7,2
8112fef0:	003f9d06 	br	8112fd68 <__reset+0xfb10fd68>
8112fef4:	3446b03a 	or	r3,r6,r17
8112fef8:	18001526 	beq	r3,zero,8112ff50 <__divdf3+0x2b0>
8112fefc:	88011b26 	beq	r17,zero,8113036c <__divdf3+0x6cc>
8112ff00:	8809883a 	mov	r4,r17
8112ff04:	d9800315 	stw	r6,12(sp)
8112ff08:	da400115 	stw	r9,4(sp)
8112ff0c:	111b8dc0 	call	8111b8dc <__clzsi2>
8112ff10:	d9800317 	ldw	r6,12(sp)
8112ff14:	da400117 	ldw	r9,4(sp)
8112ff18:	113ffd44 	addi	r4,r2,-11
8112ff1c:	00c00704 	movi	r3,28
8112ff20:	19010e16 	blt	r3,r4,8113035c <__divdf3+0x6bc>
8112ff24:	00c00744 	movi	r3,29
8112ff28:	123ffe04 	addi	r8,r2,-8
8112ff2c:	1907c83a 	sub	r3,r3,r4
8112ff30:	8a22983a 	sll	r17,r17,r8
8112ff34:	30c6d83a 	srl	r3,r6,r3
8112ff38:	3210983a 	sll	r8,r6,r8
8112ff3c:	1c62b03a 	or	r17,r3,r17
8112ff40:	1080fcc4 	addi	r2,r2,1011
8112ff44:	0085c83a 	sub	r2,zero,r2
8112ff48:	000f883a 	mov	r7,zero
8112ff4c:	003f8606 	br	8112fd68 <__reset+0xfb10fd68>
8112ff50:	0023883a 	mov	r17,zero
8112ff54:	0011883a 	mov	r8,zero
8112ff58:	01c00044 	movi	r7,1
8112ff5c:	003f8206 	br	8112fd68 <__reset+0xfb10fd68>
8112ff60:	01c000c4 	movi	r7,3
8112ff64:	003f8006 	br	8112fd68 <__reset+0xfb10fd68>
8112ff68:	04c00104 	movi	r19,4
8112ff6c:	0021883a 	mov	r16,zero
8112ff70:	0025883a 	mov	r18,zero
8112ff74:	02400044 	movi	r9,1
8112ff78:	003f6906 	br	8112fd20 <__reset+0xfb10fd20>
8112ff7c:	04c00304 	movi	r19,12
8112ff80:	024000c4 	movi	r9,3
8112ff84:	003f6606 	br	8112fd20 <__reset+0xfb10fd20>
8112ff88:	01400434 	movhi	r5,16
8112ff8c:	0007883a 	mov	r3,zero
8112ff90:	297fffc4 	addi	r5,r5,-1
8112ff94:	04bfffc4 	movi	r18,-1
8112ff98:	0081ffc4 	movi	r2,2047
8112ff9c:	003fa106 	br	8112fe24 <__reset+0xfb10fe24>
8112ffa0:	00c00044 	movi	r3,1
8112ffa4:	1887c83a 	sub	r3,r3,r2
8112ffa8:	01000e04 	movi	r4,56
8112ffac:	20c1210e 	bge	r4,r3,81130434 <__divdf3+0x794>
8112ffb0:	98c0004c 	andi	r3,r19,1
8112ffb4:	0005883a 	mov	r2,zero
8112ffb8:	000b883a 	mov	r5,zero
8112ffbc:	0025883a 	mov	r18,zero
8112ffc0:	003f9806 	br	8112fe24 <__reset+0xfb10fe24>
8112ffc4:	8c00fd36 	bltu	r17,r16,811303bc <__divdf3+0x71c>
8112ffc8:	8440fb26 	beq	r16,r17,811303b8 <__divdf3+0x718>
8112ffcc:	8007883a 	mov	r3,r16
8112ffd0:	ad7fffc4 	addi	r21,r21,-1
8112ffd4:	0021883a 	mov	r16,zero
8112ffd8:	4004d63a 	srli	r2,r8,24
8112ffdc:	8822923a 	slli	r17,r17,8
8112ffe0:	1809883a 	mov	r4,r3
8112ffe4:	402c923a 	slli	r22,r8,8
8112ffe8:	88b8b03a 	or	fp,r17,r2
8112ffec:	e028d43a 	srli	r20,fp,16
8112fff0:	d8c00015 	stw	r3,0(sp)
8112fff4:	e5ffffcc 	andi	r23,fp,65535
8112fff8:	a00b883a 	mov	r5,r20
8112fffc:	112f1340 	call	8112f134 <__udivsi3>
81130000:	d8c00017 	ldw	r3,0(sp)
81130004:	a00b883a 	mov	r5,r20
81130008:	d8800315 	stw	r2,12(sp)
8113000c:	1809883a 	mov	r4,r3
81130010:	112f1980 	call	8112f198 <__umodsi3>
81130014:	d9800317 	ldw	r6,12(sp)
81130018:	1006943a 	slli	r3,r2,16
8113001c:	9004d43a 	srli	r2,r18,16
81130020:	b9a3383a 	mul	r17,r23,r6
81130024:	10c4b03a 	or	r2,r2,r3
81130028:	1440062e 	bgeu	r2,r17,81130044 <__divdf3+0x3a4>
8113002c:	1705883a 	add	r2,r2,fp
81130030:	30ffffc4 	addi	r3,r6,-1
81130034:	1700ee36 	bltu	r2,fp,811303f0 <__divdf3+0x750>
81130038:	1440ed2e 	bgeu	r2,r17,811303f0 <__divdf3+0x750>
8113003c:	31bfff84 	addi	r6,r6,-2
81130040:	1705883a 	add	r2,r2,fp
81130044:	1463c83a 	sub	r17,r2,r17
81130048:	a00b883a 	mov	r5,r20
8113004c:	8809883a 	mov	r4,r17
81130050:	d9800315 	stw	r6,12(sp)
81130054:	112f1340 	call	8112f134 <__udivsi3>
81130058:	a00b883a 	mov	r5,r20
8113005c:	8809883a 	mov	r4,r17
81130060:	d8800215 	stw	r2,8(sp)
81130064:	112f1980 	call	8112f198 <__umodsi3>
81130068:	d9c00217 	ldw	r7,8(sp)
8113006c:	1004943a 	slli	r2,r2,16
81130070:	94bfffcc 	andi	r18,r18,65535
81130074:	b9d1383a 	mul	r8,r23,r7
81130078:	90a4b03a 	or	r18,r18,r2
8113007c:	d9800317 	ldw	r6,12(sp)
81130080:	9200062e 	bgeu	r18,r8,8113009c <__divdf3+0x3fc>
81130084:	9725883a 	add	r18,r18,fp
81130088:	38bfffc4 	addi	r2,r7,-1
8113008c:	9700d636 	bltu	r18,fp,811303e8 <__divdf3+0x748>
81130090:	9200d52e 	bgeu	r18,r8,811303e8 <__divdf3+0x748>
81130094:	39ffff84 	addi	r7,r7,-2
81130098:	9725883a 	add	r18,r18,fp
8113009c:	3004943a 	slli	r2,r6,16
811300a0:	b012d43a 	srli	r9,r22,16
811300a4:	b1bfffcc 	andi	r6,r22,65535
811300a8:	11e2b03a 	or	r17,r2,r7
811300ac:	8806d43a 	srli	r3,r17,16
811300b0:	893fffcc 	andi	r4,r17,65535
811300b4:	218b383a 	mul	r5,r4,r6
811300b8:	30c5383a 	mul	r2,r6,r3
811300bc:	2249383a 	mul	r4,r4,r9
811300c0:	280ed43a 	srli	r7,r5,16
811300c4:	9225c83a 	sub	r18,r18,r8
811300c8:	2089883a 	add	r4,r4,r2
811300cc:	3909883a 	add	r4,r7,r4
811300d0:	1a47383a 	mul	r3,r3,r9
811300d4:	2080022e 	bgeu	r4,r2,811300e0 <__divdf3+0x440>
811300d8:	00800074 	movhi	r2,1
811300dc:	1887883a 	add	r3,r3,r2
811300e0:	2004d43a 	srli	r2,r4,16
811300e4:	2008943a 	slli	r4,r4,16
811300e8:	297fffcc 	andi	r5,r5,65535
811300ec:	10c7883a 	add	r3,r2,r3
811300f0:	2149883a 	add	r4,r4,r5
811300f4:	90c0a536 	bltu	r18,r3,8113038c <__divdf3+0x6ec>
811300f8:	90c0bf26 	beq	r18,r3,811303f8 <__divdf3+0x758>
811300fc:	90c7c83a 	sub	r3,r18,r3
81130100:	810fc83a 	sub	r7,r16,r4
81130104:	81e5803a 	cmpltu	r18,r16,r7
81130108:	1ca5c83a 	sub	r18,r3,r18
8113010c:	e480c126 	beq	fp,r18,81130414 <__divdf3+0x774>
81130110:	a00b883a 	mov	r5,r20
81130114:	9009883a 	mov	r4,r18
81130118:	d9800315 	stw	r6,12(sp)
8113011c:	d9c00215 	stw	r7,8(sp)
81130120:	da400115 	stw	r9,4(sp)
81130124:	112f1340 	call	8112f134 <__udivsi3>
81130128:	a00b883a 	mov	r5,r20
8113012c:	9009883a 	mov	r4,r18
81130130:	d8800015 	stw	r2,0(sp)
81130134:	112f1980 	call	8112f198 <__umodsi3>
81130138:	d9c00217 	ldw	r7,8(sp)
8113013c:	da000017 	ldw	r8,0(sp)
81130140:	1006943a 	slli	r3,r2,16
81130144:	3804d43a 	srli	r2,r7,16
81130148:	ba21383a 	mul	r16,r23,r8
8113014c:	d9800317 	ldw	r6,12(sp)
81130150:	10c4b03a 	or	r2,r2,r3
81130154:	da400117 	ldw	r9,4(sp)
81130158:	1400062e 	bgeu	r2,r16,81130174 <__divdf3+0x4d4>
8113015c:	1705883a 	add	r2,r2,fp
81130160:	40ffffc4 	addi	r3,r8,-1
81130164:	1700ad36 	bltu	r2,fp,8113041c <__divdf3+0x77c>
81130168:	1400ac2e 	bgeu	r2,r16,8113041c <__divdf3+0x77c>
8113016c:	423fff84 	addi	r8,r8,-2
81130170:	1705883a 	add	r2,r2,fp
81130174:	1421c83a 	sub	r16,r2,r16
81130178:	a00b883a 	mov	r5,r20
8113017c:	8009883a 	mov	r4,r16
81130180:	d9800315 	stw	r6,12(sp)
81130184:	d9c00215 	stw	r7,8(sp)
81130188:	da000015 	stw	r8,0(sp)
8113018c:	da400115 	stw	r9,4(sp)
81130190:	112f1340 	call	8112f134 <__udivsi3>
81130194:	8009883a 	mov	r4,r16
81130198:	a00b883a 	mov	r5,r20
8113019c:	1025883a 	mov	r18,r2
811301a0:	112f1980 	call	8112f198 <__umodsi3>
811301a4:	d9c00217 	ldw	r7,8(sp)
811301a8:	1004943a 	slli	r2,r2,16
811301ac:	bcaf383a 	mul	r23,r23,r18
811301b0:	393fffcc 	andi	r4,r7,65535
811301b4:	2088b03a 	or	r4,r4,r2
811301b8:	d9800317 	ldw	r6,12(sp)
811301bc:	da000017 	ldw	r8,0(sp)
811301c0:	da400117 	ldw	r9,4(sp)
811301c4:	25c0062e 	bgeu	r4,r23,811301e0 <__divdf3+0x540>
811301c8:	2709883a 	add	r4,r4,fp
811301cc:	90bfffc4 	addi	r2,r18,-1
811301d0:	27009436 	bltu	r4,fp,81130424 <__divdf3+0x784>
811301d4:	25c0932e 	bgeu	r4,r23,81130424 <__divdf3+0x784>
811301d8:	94bfff84 	addi	r18,r18,-2
811301dc:	2709883a 	add	r4,r4,fp
811301e0:	4004943a 	slli	r2,r8,16
811301e4:	25efc83a 	sub	r23,r4,r23
811301e8:	1490b03a 	or	r8,r2,r18
811301ec:	4008d43a 	srli	r4,r8,16
811301f0:	40ffffcc 	andi	r3,r8,65535
811301f4:	30c5383a 	mul	r2,r6,r3
811301f8:	1a47383a 	mul	r3,r3,r9
811301fc:	310d383a 	mul	r6,r6,r4
81130200:	100ad43a 	srli	r5,r2,16
81130204:	4913383a 	mul	r9,r9,r4
81130208:	1987883a 	add	r3,r3,r6
8113020c:	28c7883a 	add	r3,r5,r3
81130210:	1980022e 	bgeu	r3,r6,8113021c <__divdf3+0x57c>
81130214:	01000074 	movhi	r4,1
81130218:	4913883a 	add	r9,r9,r4
8113021c:	1808d43a 	srli	r4,r3,16
81130220:	1806943a 	slli	r3,r3,16
81130224:	10bfffcc 	andi	r2,r2,65535
81130228:	2253883a 	add	r9,r4,r9
8113022c:	1887883a 	add	r3,r3,r2
81130230:	ba403836 	bltu	r23,r9,81130314 <__divdf3+0x674>
81130234:	ba403626 	beq	r23,r9,81130310 <__divdf3+0x670>
81130238:	42000054 	ori	r8,r8,1
8113023c:	a880ffc4 	addi	r2,r21,1023
81130240:	00bf570e 	bge	zero,r2,8112ffa0 <__reset+0xfb10ffa0>
81130244:	40c001cc 	andi	r3,r8,7
81130248:	18000726 	beq	r3,zero,81130268 <__divdf3+0x5c8>
8113024c:	40c003cc 	andi	r3,r8,15
81130250:	01000104 	movi	r4,4
81130254:	19000426 	beq	r3,r4,81130268 <__divdf3+0x5c8>
81130258:	4107883a 	add	r3,r8,r4
8113025c:	1a11803a 	cmpltu	r8,r3,r8
81130260:	8a23883a 	add	r17,r17,r8
81130264:	1811883a 	mov	r8,r3
81130268:	88c0402c 	andhi	r3,r17,256
8113026c:	18000426 	beq	r3,zero,81130280 <__divdf3+0x5e0>
81130270:	00ffc034 	movhi	r3,65280
81130274:	18ffffc4 	addi	r3,r3,-1
81130278:	a8810004 	addi	r2,r21,1024
8113027c:	88e2703a 	and	r17,r17,r3
81130280:	00c1ff84 	movi	r3,2046
81130284:	18bee316 	blt	r3,r2,8112fe14 <__reset+0xfb10fe14>
81130288:	8824977a 	slli	r18,r17,29
8113028c:	4010d0fa 	srli	r8,r8,3
81130290:	8822927a 	slli	r17,r17,9
81130294:	1081ffcc 	andi	r2,r2,2047
81130298:	9224b03a 	or	r18,r18,r8
8113029c:	880ad33a 	srli	r5,r17,12
811302a0:	98c0004c 	andi	r3,r19,1
811302a4:	003edf06 	br	8112fe24 <__reset+0xfb10fe24>
811302a8:	8080022c 	andhi	r2,r16,8
811302ac:	10001226 	beq	r2,zero,811302f8 <__divdf3+0x658>
811302b0:	8880022c 	andhi	r2,r17,8
811302b4:	1000101e 	bne	r2,zero,811302f8 <__divdf3+0x658>
811302b8:	00800434 	movhi	r2,16
811302bc:	89400234 	orhi	r5,r17,8
811302c0:	10bfffc4 	addi	r2,r2,-1
811302c4:	b007883a 	mov	r3,r22
811302c8:	288a703a 	and	r5,r5,r2
811302cc:	4025883a 	mov	r18,r8
811302d0:	003f3106 	br	8112ff98 <__reset+0xfb10ff98>
811302d4:	008000c4 	movi	r2,3
811302d8:	3880a626 	beq	r7,r2,81130574 <__divdf3+0x8d4>
811302dc:	00800044 	movi	r2,1
811302e0:	3880521e 	bne	r7,r2,8113042c <__divdf3+0x78c>
811302e4:	b807883a 	mov	r3,r23
811302e8:	0005883a 	mov	r2,zero
811302ec:	000b883a 	mov	r5,zero
811302f0:	0025883a 	mov	r18,zero
811302f4:	003ecb06 	br	8112fe24 <__reset+0xfb10fe24>
811302f8:	00800434 	movhi	r2,16
811302fc:	81400234 	orhi	r5,r16,8
81130300:	10bfffc4 	addi	r2,r2,-1
81130304:	a007883a 	mov	r3,r20
81130308:	288a703a 	and	r5,r5,r2
8113030c:	003f2206 	br	8112ff98 <__reset+0xfb10ff98>
81130310:	183fca26 	beq	r3,zero,8113023c <__reset+0xfb11023c>
81130314:	e5ef883a 	add	r23,fp,r23
81130318:	40bfffc4 	addi	r2,r8,-1
8113031c:	bf00392e 	bgeu	r23,fp,81130404 <__divdf3+0x764>
81130320:	1011883a 	mov	r8,r2
81130324:	ba7fc41e 	bne	r23,r9,81130238 <__reset+0xfb110238>
81130328:	b0ffc31e 	bne	r22,r3,81130238 <__reset+0xfb110238>
8113032c:	003fc306 	br	8113023c <__reset+0xfb11023c>
81130330:	143ff604 	addi	r16,r2,-40
81130334:	9c20983a 	sll	r16,r19,r16
81130338:	0025883a 	mov	r18,zero
8113033c:	003ee206 	br	8112fec8 <__reset+0xfb10fec8>
81130340:	d9800315 	stw	r6,12(sp)
81130344:	d9c00215 	stw	r7,8(sp)
81130348:	111b8dc0 	call	8111b8dc <__clzsi2>
8113034c:	10800804 	addi	r2,r2,32
81130350:	d9c00217 	ldw	r7,8(sp)
81130354:	d9800317 	ldw	r6,12(sp)
81130358:	003ed106 	br	8112fea0 <__reset+0xfb10fea0>
8113035c:	147ff604 	addi	r17,r2,-40
81130360:	3462983a 	sll	r17,r6,r17
81130364:	0011883a 	mov	r8,zero
81130368:	003ef506 	br	8112ff40 <__reset+0xfb10ff40>
8113036c:	3009883a 	mov	r4,r6
81130370:	d9800315 	stw	r6,12(sp)
81130374:	da400115 	stw	r9,4(sp)
81130378:	111b8dc0 	call	8111b8dc <__clzsi2>
8113037c:	10800804 	addi	r2,r2,32
81130380:	da400117 	ldw	r9,4(sp)
81130384:	d9800317 	ldw	r6,12(sp)
81130388:	003ee306 	br	8112ff18 <__reset+0xfb10ff18>
8113038c:	85a1883a 	add	r16,r16,r22
81130390:	8585803a 	cmpltu	r2,r16,r22
81130394:	1705883a 	add	r2,r2,fp
81130398:	14a5883a 	add	r18,r2,r18
8113039c:	88bfffc4 	addi	r2,r17,-1
811303a0:	e4800c2e 	bgeu	fp,r18,811303d4 <__divdf3+0x734>
811303a4:	90c03e36 	bltu	r18,r3,811304a0 <__divdf3+0x800>
811303a8:	1c806926 	beq	r3,r18,81130550 <__divdf3+0x8b0>
811303ac:	90c7c83a 	sub	r3,r18,r3
811303b0:	1023883a 	mov	r17,r2
811303b4:	003f5206 	br	81130100 <__reset+0xfb110100>
811303b8:	923f0436 	bltu	r18,r8,8112ffcc <__reset+0xfb10ffcc>
811303bc:	800897fa 	slli	r4,r16,31
811303c0:	9004d07a 	srli	r2,r18,1
811303c4:	8006d07a 	srli	r3,r16,1
811303c8:	902097fa 	slli	r16,r18,31
811303cc:	20a4b03a 	or	r18,r4,r2
811303d0:	003f0106 	br	8112ffd8 <__reset+0xfb10ffd8>
811303d4:	e4bff51e 	bne	fp,r18,811303ac <__reset+0xfb1103ac>
811303d8:	85bff22e 	bgeu	r16,r22,811303a4 <__reset+0xfb1103a4>
811303dc:	e0c7c83a 	sub	r3,fp,r3
811303e0:	1023883a 	mov	r17,r2
811303e4:	003f4606 	br	81130100 <__reset+0xfb110100>
811303e8:	100f883a 	mov	r7,r2
811303ec:	003f2b06 	br	8113009c <__reset+0xfb11009c>
811303f0:	180d883a 	mov	r6,r3
811303f4:	003f1306 	br	81130044 <__reset+0xfb110044>
811303f8:	813fe436 	bltu	r16,r4,8113038c <__reset+0xfb11038c>
811303fc:	0007883a 	mov	r3,zero
81130400:	003f3f06 	br	81130100 <__reset+0xfb110100>
81130404:	ba402c36 	bltu	r23,r9,811304b8 <__divdf3+0x818>
81130408:	4dc05426 	beq	r9,r23,8113055c <__divdf3+0x8bc>
8113040c:	1011883a 	mov	r8,r2
81130410:	003f8906 	br	81130238 <__reset+0xfb110238>
81130414:	023fffc4 	movi	r8,-1
81130418:	003f8806 	br	8113023c <__reset+0xfb11023c>
8113041c:	1811883a 	mov	r8,r3
81130420:	003f5406 	br	81130174 <__reset+0xfb110174>
81130424:	1025883a 	mov	r18,r2
81130428:	003f6d06 	br	811301e0 <__reset+0xfb1101e0>
8113042c:	b827883a 	mov	r19,r23
81130430:	003f8206 	br	8113023c <__reset+0xfb11023c>
81130434:	010007c4 	movi	r4,31
81130438:	20c02616 	blt	r4,r3,811304d4 <__divdf3+0x834>
8113043c:	00800804 	movi	r2,32
81130440:	10c5c83a 	sub	r2,r2,r3
81130444:	888a983a 	sll	r5,r17,r2
81130448:	40c8d83a 	srl	r4,r8,r3
8113044c:	4084983a 	sll	r2,r8,r2
81130450:	88e2d83a 	srl	r17,r17,r3
81130454:	2906b03a 	or	r3,r5,r4
81130458:	1004c03a 	cmpne	r2,r2,zero
8113045c:	1886b03a 	or	r3,r3,r2
81130460:	188001cc 	andi	r2,r3,7
81130464:	10000726 	beq	r2,zero,81130484 <__divdf3+0x7e4>
81130468:	188003cc 	andi	r2,r3,15
8113046c:	01000104 	movi	r4,4
81130470:	11000426 	beq	r2,r4,81130484 <__divdf3+0x7e4>
81130474:	1805883a 	mov	r2,r3
81130478:	10c00104 	addi	r3,r2,4
8113047c:	1885803a 	cmpltu	r2,r3,r2
81130480:	88a3883a 	add	r17,r17,r2
81130484:	8880202c 	andhi	r2,r17,128
81130488:	10002726 	beq	r2,zero,81130528 <__divdf3+0x888>
8113048c:	98c0004c 	andi	r3,r19,1
81130490:	00800044 	movi	r2,1
81130494:	000b883a 	mov	r5,zero
81130498:	0025883a 	mov	r18,zero
8113049c:	003e6106 	br	8112fe24 <__reset+0xfb10fe24>
811304a0:	85a1883a 	add	r16,r16,r22
811304a4:	8585803a 	cmpltu	r2,r16,r22
811304a8:	1705883a 	add	r2,r2,fp
811304ac:	14a5883a 	add	r18,r2,r18
811304b0:	8c7fff84 	addi	r17,r17,-2
811304b4:	003f1106 	br	811300fc <__reset+0xfb1100fc>
811304b8:	b589883a 	add	r4,r22,r22
811304bc:	25ad803a 	cmpltu	r22,r4,r22
811304c0:	b739883a 	add	fp,r22,fp
811304c4:	40bfff84 	addi	r2,r8,-2
811304c8:	bf2f883a 	add	r23,r23,fp
811304cc:	202d883a 	mov	r22,r4
811304d0:	003f9306 	br	81130320 <__reset+0xfb110320>
811304d4:	013ff844 	movi	r4,-31
811304d8:	2085c83a 	sub	r2,r4,r2
811304dc:	8888d83a 	srl	r4,r17,r2
811304e0:	00800804 	movi	r2,32
811304e4:	18802126 	beq	r3,r2,8113056c <__divdf3+0x8cc>
811304e8:	00801004 	movi	r2,64
811304ec:	10c5c83a 	sub	r2,r2,r3
811304f0:	8884983a 	sll	r2,r17,r2
811304f4:	1204b03a 	or	r2,r2,r8
811304f8:	1004c03a 	cmpne	r2,r2,zero
811304fc:	2084b03a 	or	r2,r4,r2
81130500:	144001cc 	andi	r17,r2,7
81130504:	88000d1e 	bne	r17,zero,8113053c <__divdf3+0x89c>
81130508:	000b883a 	mov	r5,zero
8113050c:	1024d0fa 	srli	r18,r2,3
81130510:	98c0004c 	andi	r3,r19,1
81130514:	0005883a 	mov	r2,zero
81130518:	9464b03a 	or	r18,r18,r17
8113051c:	003e4106 	br	8112fe24 <__reset+0xfb10fe24>
81130520:	1007883a 	mov	r3,r2
81130524:	0023883a 	mov	r17,zero
81130528:	880a927a 	slli	r5,r17,9
8113052c:	1805883a 	mov	r2,r3
81130530:	8822977a 	slli	r17,r17,29
81130534:	280ad33a 	srli	r5,r5,12
81130538:	003ff406 	br	8113050c <__reset+0xfb11050c>
8113053c:	10c003cc 	andi	r3,r2,15
81130540:	01000104 	movi	r4,4
81130544:	193ff626 	beq	r3,r4,81130520 <__reset+0xfb110520>
81130548:	0023883a 	mov	r17,zero
8113054c:	003fca06 	br	81130478 <__reset+0xfb110478>
81130550:	813fd336 	bltu	r16,r4,811304a0 <__reset+0xfb1104a0>
81130554:	1023883a 	mov	r17,r2
81130558:	003fa806 	br	811303fc <__reset+0xfb1103fc>
8113055c:	b0ffd636 	bltu	r22,r3,811304b8 <__reset+0xfb1104b8>
81130560:	1011883a 	mov	r8,r2
81130564:	b0ff341e 	bne	r22,r3,81130238 <__reset+0xfb110238>
81130568:	003f3406 	br	8113023c <__reset+0xfb11023c>
8113056c:	0005883a 	mov	r2,zero
81130570:	003fe006 	br	811304f4 <__reset+0xfb1104f4>
81130574:	00800434 	movhi	r2,16
81130578:	89400234 	orhi	r5,r17,8
8113057c:	10bfffc4 	addi	r2,r2,-1
81130580:	b807883a 	mov	r3,r23
81130584:	288a703a 	and	r5,r5,r2
81130588:	4025883a 	mov	r18,r8
8113058c:	003e8206 	br	8112ff98 <__reset+0xfb10ff98>

81130590 <__eqdf2>:
81130590:	2804d53a 	srli	r2,r5,20
81130594:	3806d53a 	srli	r3,r7,20
81130598:	02000434 	movhi	r8,16
8113059c:	423fffc4 	addi	r8,r8,-1
811305a0:	1081ffcc 	andi	r2,r2,2047
811305a4:	0281ffc4 	movi	r10,2047
811305a8:	2a12703a 	and	r9,r5,r8
811305ac:	18c1ffcc 	andi	r3,r3,2047
811305b0:	3a10703a 	and	r8,r7,r8
811305b4:	280ad7fa 	srli	r5,r5,31
811305b8:	380ed7fa 	srli	r7,r7,31
811305bc:	12801026 	beq	r2,r10,81130600 <__eqdf2+0x70>
811305c0:	0281ffc4 	movi	r10,2047
811305c4:	1a800a26 	beq	r3,r10,811305f0 <__eqdf2+0x60>
811305c8:	10c00226 	beq	r2,r3,811305d4 <__eqdf2+0x44>
811305cc:	00800044 	movi	r2,1
811305d0:	f800283a 	ret
811305d4:	4a3ffd1e 	bne	r9,r8,811305cc <__reset+0xfb1105cc>
811305d8:	21bffc1e 	bne	r4,r6,811305cc <__reset+0xfb1105cc>
811305dc:	29c00c26 	beq	r5,r7,81130610 <__eqdf2+0x80>
811305e0:	103ffa1e 	bne	r2,zero,811305cc <__reset+0xfb1105cc>
811305e4:	2244b03a 	or	r2,r4,r9
811305e8:	1004c03a 	cmpne	r2,r2,zero
811305ec:	f800283a 	ret
811305f0:	3214b03a 	or	r10,r6,r8
811305f4:	503ff426 	beq	r10,zero,811305c8 <__reset+0xfb1105c8>
811305f8:	00800044 	movi	r2,1
811305fc:	f800283a 	ret
81130600:	2254b03a 	or	r10,r4,r9
81130604:	503fee26 	beq	r10,zero,811305c0 <__reset+0xfb1105c0>
81130608:	00800044 	movi	r2,1
8113060c:	f800283a 	ret
81130610:	0005883a 	mov	r2,zero
81130614:	f800283a 	ret

81130618 <__gedf2>:
81130618:	2804d53a 	srli	r2,r5,20
8113061c:	3806d53a 	srli	r3,r7,20
81130620:	02000434 	movhi	r8,16
81130624:	423fffc4 	addi	r8,r8,-1
81130628:	1081ffcc 	andi	r2,r2,2047
8113062c:	0241ffc4 	movi	r9,2047
81130630:	2a14703a 	and	r10,r5,r8
81130634:	18c1ffcc 	andi	r3,r3,2047
81130638:	3a10703a 	and	r8,r7,r8
8113063c:	280ad7fa 	srli	r5,r5,31
81130640:	380ed7fa 	srli	r7,r7,31
81130644:	12401d26 	beq	r2,r9,811306bc <__gedf2+0xa4>
81130648:	0241ffc4 	movi	r9,2047
8113064c:	1a401226 	beq	r3,r9,81130698 <__gedf2+0x80>
81130650:	1000081e 	bne	r2,zero,81130674 <__gedf2+0x5c>
81130654:	2296b03a 	or	r11,r4,r10
81130658:	5813003a 	cmpeq	r9,r11,zero
8113065c:	1800091e 	bne	r3,zero,81130684 <__gedf2+0x6c>
81130660:	3218b03a 	or	r12,r6,r8
81130664:	6000071e 	bne	r12,zero,81130684 <__gedf2+0x6c>
81130668:	0005883a 	mov	r2,zero
8113066c:	5800101e 	bne	r11,zero,811306b0 <__gedf2+0x98>
81130670:	f800283a 	ret
81130674:	18000c1e 	bne	r3,zero,811306a8 <__gedf2+0x90>
81130678:	3212b03a 	or	r9,r6,r8
8113067c:	48000c26 	beq	r9,zero,811306b0 <__gedf2+0x98>
81130680:	0013883a 	mov	r9,zero
81130684:	39c03fcc 	andi	r7,r7,255
81130688:	48000826 	beq	r9,zero,811306ac <__gedf2+0x94>
8113068c:	38000926 	beq	r7,zero,811306b4 <__gedf2+0x9c>
81130690:	00800044 	movi	r2,1
81130694:	f800283a 	ret
81130698:	3212b03a 	or	r9,r6,r8
8113069c:	483fec26 	beq	r9,zero,81130650 <__reset+0xfb110650>
811306a0:	00bfff84 	movi	r2,-2
811306a4:	f800283a 	ret
811306a8:	39c03fcc 	andi	r7,r7,255
811306ac:	29c00626 	beq	r5,r7,811306c8 <__gedf2+0xb0>
811306b0:	283ff726 	beq	r5,zero,81130690 <__reset+0xfb110690>
811306b4:	00bfffc4 	movi	r2,-1
811306b8:	f800283a 	ret
811306bc:	2292b03a 	or	r9,r4,r10
811306c0:	483fe126 	beq	r9,zero,81130648 <__reset+0xfb110648>
811306c4:	003ff606 	br	811306a0 <__reset+0xfb1106a0>
811306c8:	18bff916 	blt	r3,r2,811306b0 <__reset+0xfb1106b0>
811306cc:	10c00316 	blt	r2,r3,811306dc <__gedf2+0xc4>
811306d0:	42bff736 	bltu	r8,r10,811306b0 <__reset+0xfb1106b0>
811306d4:	52000326 	beq	r10,r8,811306e4 <__gedf2+0xcc>
811306d8:	5200042e 	bgeu	r10,r8,811306ec <__gedf2+0xd4>
811306dc:	283fec1e 	bne	r5,zero,81130690 <__reset+0xfb110690>
811306e0:	003ff406 	br	811306b4 <__reset+0xfb1106b4>
811306e4:	313ff236 	bltu	r6,r4,811306b0 <__reset+0xfb1106b0>
811306e8:	21bffc36 	bltu	r4,r6,811306dc <__reset+0xfb1106dc>
811306ec:	0005883a 	mov	r2,zero
811306f0:	f800283a 	ret

811306f4 <__ledf2>:
811306f4:	2804d53a 	srli	r2,r5,20
811306f8:	3810d53a 	srli	r8,r7,20
811306fc:	00c00434 	movhi	r3,16
81130700:	18ffffc4 	addi	r3,r3,-1
81130704:	1081ffcc 	andi	r2,r2,2047
81130708:	0241ffc4 	movi	r9,2047
8113070c:	28d4703a 	and	r10,r5,r3
81130710:	4201ffcc 	andi	r8,r8,2047
81130714:	38c6703a 	and	r3,r7,r3
81130718:	280ad7fa 	srli	r5,r5,31
8113071c:	380ed7fa 	srli	r7,r7,31
81130720:	12401f26 	beq	r2,r9,811307a0 <__ledf2+0xac>
81130724:	0241ffc4 	movi	r9,2047
81130728:	42401426 	beq	r8,r9,8113077c <__ledf2+0x88>
8113072c:	1000091e 	bne	r2,zero,81130754 <__ledf2+0x60>
81130730:	2296b03a 	or	r11,r4,r10
81130734:	5813003a 	cmpeq	r9,r11,zero
81130738:	29403fcc 	andi	r5,r5,255
8113073c:	40000a1e 	bne	r8,zero,81130768 <__ledf2+0x74>
81130740:	30d8b03a 	or	r12,r6,r3
81130744:	6000081e 	bne	r12,zero,81130768 <__ledf2+0x74>
81130748:	0005883a 	mov	r2,zero
8113074c:	5800111e 	bne	r11,zero,81130794 <__ledf2+0xa0>
81130750:	f800283a 	ret
81130754:	29403fcc 	andi	r5,r5,255
81130758:	40000c1e 	bne	r8,zero,8113078c <__ledf2+0x98>
8113075c:	30d2b03a 	or	r9,r6,r3
81130760:	48000c26 	beq	r9,zero,81130794 <__ledf2+0xa0>
81130764:	0013883a 	mov	r9,zero
81130768:	39c03fcc 	andi	r7,r7,255
8113076c:	48000826 	beq	r9,zero,81130790 <__ledf2+0x9c>
81130770:	38001126 	beq	r7,zero,811307b8 <__ledf2+0xc4>
81130774:	00800044 	movi	r2,1
81130778:	f800283a 	ret
8113077c:	30d2b03a 	or	r9,r6,r3
81130780:	483fea26 	beq	r9,zero,8113072c <__reset+0xfb11072c>
81130784:	00800084 	movi	r2,2
81130788:	f800283a 	ret
8113078c:	39c03fcc 	andi	r7,r7,255
81130790:	39400726 	beq	r7,r5,811307b0 <__ledf2+0xbc>
81130794:	2800081e 	bne	r5,zero,811307b8 <__ledf2+0xc4>
81130798:	00800044 	movi	r2,1
8113079c:	f800283a 	ret
811307a0:	2292b03a 	or	r9,r4,r10
811307a4:	483fdf26 	beq	r9,zero,81130724 <__reset+0xfb110724>
811307a8:	00800084 	movi	r2,2
811307ac:	f800283a 	ret
811307b0:	4080030e 	bge	r8,r2,811307c0 <__ledf2+0xcc>
811307b4:	383fef26 	beq	r7,zero,81130774 <__reset+0xfb110774>
811307b8:	00bfffc4 	movi	r2,-1
811307bc:	f800283a 	ret
811307c0:	123feb16 	blt	r2,r8,81130770 <__reset+0xfb110770>
811307c4:	1abff336 	bltu	r3,r10,81130794 <__reset+0xfb110794>
811307c8:	50c00326 	beq	r10,r3,811307d8 <__ledf2+0xe4>
811307cc:	50c0042e 	bgeu	r10,r3,811307e0 <__ledf2+0xec>
811307d0:	283fe81e 	bne	r5,zero,81130774 <__reset+0xfb110774>
811307d4:	003ff806 	br	811307b8 <__reset+0xfb1107b8>
811307d8:	313fee36 	bltu	r6,r4,81130794 <__reset+0xfb110794>
811307dc:	21bffc36 	bltu	r4,r6,811307d0 <__reset+0xfb1107d0>
811307e0:	0005883a 	mov	r2,zero
811307e4:	f800283a 	ret

811307e8 <__subdf3>:
811307e8:	02000434 	movhi	r8,16
811307ec:	423fffc4 	addi	r8,r8,-1
811307f0:	defffb04 	addi	sp,sp,-20
811307f4:	2a14703a 	and	r10,r5,r8
811307f8:	3812d53a 	srli	r9,r7,20
811307fc:	3a10703a 	and	r8,r7,r8
81130800:	de00012e 	bgeu	sp,et,81130808 <__subdf3+0x20>
81130804:	003b68fa 	trap	3
81130808:	2006d77a 	srli	r3,r4,29
8113080c:	3004d77a 	srli	r2,r6,29
81130810:	dc000015 	stw	r16,0(sp)
81130814:	501490fa 	slli	r10,r10,3
81130818:	2820d53a 	srli	r16,r5,20
8113081c:	401090fa 	slli	r8,r8,3
81130820:	dc800215 	stw	r18,8(sp)
81130824:	dc400115 	stw	r17,4(sp)
81130828:	dfc00415 	stw	ra,16(sp)
8113082c:	202290fa 	slli	r17,r4,3
81130830:	dcc00315 	stw	r19,12(sp)
81130834:	4a41ffcc 	andi	r9,r9,2047
81130838:	0101ffc4 	movi	r4,2047
8113083c:	2824d7fa 	srli	r18,r5,31
81130840:	8401ffcc 	andi	r16,r16,2047
81130844:	50c6b03a 	or	r3,r10,r3
81130848:	380ed7fa 	srli	r7,r7,31
8113084c:	408ab03a 	or	r5,r8,r2
81130850:	300c90fa 	slli	r6,r6,3
81130854:	49009626 	beq	r9,r4,81130ab0 <__subdf3+0x2c8>
81130858:	39c0005c 	xori	r7,r7,1
8113085c:	8245c83a 	sub	r2,r16,r9
81130860:	3c807426 	beq	r7,r18,81130a34 <__subdf3+0x24c>
81130864:	0080af0e 	bge	zero,r2,81130b24 <__subdf3+0x33c>
81130868:	48002a1e 	bne	r9,zero,81130914 <__subdf3+0x12c>
8113086c:	2988b03a 	or	r4,r5,r6
81130870:	20009a1e 	bne	r4,zero,81130adc <__subdf3+0x2f4>
81130874:	888001cc 	andi	r2,r17,7
81130878:	10000726 	beq	r2,zero,81130898 <__subdf3+0xb0>
8113087c:	888003cc 	andi	r2,r17,15
81130880:	01000104 	movi	r4,4
81130884:	11000426 	beq	r2,r4,81130898 <__subdf3+0xb0>
81130888:	890b883a 	add	r5,r17,r4
8113088c:	2c63803a 	cmpltu	r17,r5,r17
81130890:	1c47883a 	add	r3,r3,r17
81130894:	2823883a 	mov	r17,r5
81130898:	1880202c 	andhi	r2,r3,128
8113089c:	10005926 	beq	r2,zero,81130a04 <__subdf3+0x21c>
811308a0:	84000044 	addi	r16,r16,1
811308a4:	0081ffc4 	movi	r2,2047
811308a8:	8080be26 	beq	r16,r2,81130ba4 <__subdf3+0x3bc>
811308ac:	017fe034 	movhi	r5,65408
811308b0:	297fffc4 	addi	r5,r5,-1
811308b4:	1946703a 	and	r3,r3,r5
811308b8:	1804977a 	slli	r2,r3,29
811308bc:	1806927a 	slli	r3,r3,9
811308c0:	8822d0fa 	srli	r17,r17,3
811308c4:	8401ffcc 	andi	r16,r16,2047
811308c8:	180ad33a 	srli	r5,r3,12
811308cc:	9100004c 	andi	r4,r18,1
811308d0:	1444b03a 	or	r2,r2,r17
811308d4:	80c1ffcc 	andi	r3,r16,2047
811308d8:	1820953a 	slli	r16,r3,20
811308dc:	20c03fcc 	andi	r3,r4,255
811308e0:	180897fa 	slli	r4,r3,31
811308e4:	00c00434 	movhi	r3,16
811308e8:	18ffffc4 	addi	r3,r3,-1
811308ec:	28c6703a 	and	r3,r5,r3
811308f0:	1c06b03a 	or	r3,r3,r16
811308f4:	1906b03a 	or	r3,r3,r4
811308f8:	dfc00417 	ldw	ra,16(sp)
811308fc:	dcc00317 	ldw	r19,12(sp)
81130900:	dc800217 	ldw	r18,8(sp)
81130904:	dc400117 	ldw	r17,4(sp)
81130908:	dc000017 	ldw	r16,0(sp)
8113090c:	dec00504 	addi	sp,sp,20
81130910:	f800283a 	ret
81130914:	0101ffc4 	movi	r4,2047
81130918:	813fd626 	beq	r16,r4,81130874 <__reset+0xfb110874>
8113091c:	29402034 	orhi	r5,r5,128
81130920:	01000e04 	movi	r4,56
81130924:	2080a316 	blt	r4,r2,81130bb4 <__subdf3+0x3cc>
81130928:	010007c4 	movi	r4,31
8113092c:	2080c616 	blt	r4,r2,81130c48 <__subdf3+0x460>
81130930:	01000804 	movi	r4,32
81130934:	2089c83a 	sub	r4,r4,r2
81130938:	2910983a 	sll	r8,r5,r4
8113093c:	308ed83a 	srl	r7,r6,r2
81130940:	3108983a 	sll	r4,r6,r4
81130944:	2884d83a 	srl	r2,r5,r2
81130948:	41ccb03a 	or	r6,r8,r7
8113094c:	2008c03a 	cmpne	r4,r4,zero
81130950:	310cb03a 	or	r6,r6,r4
81130954:	898dc83a 	sub	r6,r17,r6
81130958:	89a3803a 	cmpltu	r17,r17,r6
8113095c:	1887c83a 	sub	r3,r3,r2
81130960:	1c47c83a 	sub	r3,r3,r17
81130964:	3023883a 	mov	r17,r6
81130968:	1880202c 	andhi	r2,r3,128
8113096c:	10002326 	beq	r2,zero,811309fc <__subdf3+0x214>
81130970:	04c02034 	movhi	r19,128
81130974:	9cffffc4 	addi	r19,r19,-1
81130978:	1ce6703a 	and	r19,r3,r19
8113097c:	98007a26 	beq	r19,zero,81130b68 <__subdf3+0x380>
81130980:	9809883a 	mov	r4,r19
81130984:	111b8dc0 	call	8111b8dc <__clzsi2>
81130988:	113ffe04 	addi	r4,r2,-8
8113098c:	00c007c4 	movi	r3,31
81130990:	19007b16 	blt	r3,r4,81130b80 <__subdf3+0x398>
81130994:	00800804 	movi	r2,32
81130998:	1105c83a 	sub	r2,r2,r4
8113099c:	8884d83a 	srl	r2,r17,r2
811309a0:	9906983a 	sll	r3,r19,r4
811309a4:	8922983a 	sll	r17,r17,r4
811309a8:	10c4b03a 	or	r2,r2,r3
811309ac:	24007816 	blt	r4,r16,81130b90 <__subdf3+0x3a8>
811309b0:	2421c83a 	sub	r16,r4,r16
811309b4:	80c00044 	addi	r3,r16,1
811309b8:	010007c4 	movi	r4,31
811309bc:	20c09516 	blt	r4,r3,81130c14 <__subdf3+0x42c>
811309c0:	01400804 	movi	r5,32
811309c4:	28cbc83a 	sub	r5,r5,r3
811309c8:	88c8d83a 	srl	r4,r17,r3
811309cc:	8962983a 	sll	r17,r17,r5
811309d0:	114a983a 	sll	r5,r2,r5
811309d4:	10c6d83a 	srl	r3,r2,r3
811309d8:	8804c03a 	cmpne	r2,r17,zero
811309dc:	290ab03a 	or	r5,r5,r4
811309e0:	28a2b03a 	or	r17,r5,r2
811309e4:	0021883a 	mov	r16,zero
811309e8:	003fa206 	br	81130874 <__reset+0xfb110874>
811309ec:	2090b03a 	or	r8,r4,r2
811309f0:	40018e26 	beq	r8,zero,8113102c <__subdf3+0x844>
811309f4:	1007883a 	mov	r3,r2
811309f8:	2023883a 	mov	r17,r4
811309fc:	888001cc 	andi	r2,r17,7
81130a00:	103f9e1e 	bne	r2,zero,8113087c <__reset+0xfb11087c>
81130a04:	1804977a 	slli	r2,r3,29
81130a08:	8822d0fa 	srli	r17,r17,3
81130a0c:	1810d0fa 	srli	r8,r3,3
81130a10:	9100004c 	andi	r4,r18,1
81130a14:	1444b03a 	or	r2,r2,r17
81130a18:	00c1ffc4 	movi	r3,2047
81130a1c:	80c02826 	beq	r16,r3,81130ac0 <__subdf3+0x2d8>
81130a20:	01400434 	movhi	r5,16
81130a24:	297fffc4 	addi	r5,r5,-1
81130a28:	80e0703a 	and	r16,r16,r3
81130a2c:	414a703a 	and	r5,r8,r5
81130a30:	003fa806 	br	811308d4 <__reset+0xfb1108d4>
81130a34:	0080630e 	bge	zero,r2,81130bc4 <__subdf3+0x3dc>
81130a38:	48003026 	beq	r9,zero,81130afc <__subdf3+0x314>
81130a3c:	0101ffc4 	movi	r4,2047
81130a40:	813f8c26 	beq	r16,r4,81130874 <__reset+0xfb110874>
81130a44:	29402034 	orhi	r5,r5,128
81130a48:	01000e04 	movi	r4,56
81130a4c:	2080a90e 	bge	r4,r2,81130cf4 <__subdf3+0x50c>
81130a50:	298cb03a 	or	r6,r5,r6
81130a54:	3012c03a 	cmpne	r9,r6,zero
81130a58:	0005883a 	mov	r2,zero
81130a5c:	4c53883a 	add	r9,r9,r17
81130a60:	4c63803a 	cmpltu	r17,r9,r17
81130a64:	10c7883a 	add	r3,r2,r3
81130a68:	88c7883a 	add	r3,r17,r3
81130a6c:	4823883a 	mov	r17,r9
81130a70:	1880202c 	andhi	r2,r3,128
81130a74:	1000d026 	beq	r2,zero,81130db8 <__subdf3+0x5d0>
81130a78:	84000044 	addi	r16,r16,1
81130a7c:	0081ffc4 	movi	r2,2047
81130a80:	8080fe26 	beq	r16,r2,81130e7c <__subdf3+0x694>
81130a84:	00bfe034 	movhi	r2,65408
81130a88:	10bfffc4 	addi	r2,r2,-1
81130a8c:	1886703a 	and	r3,r3,r2
81130a90:	880ad07a 	srli	r5,r17,1
81130a94:	180497fa 	slli	r2,r3,31
81130a98:	8900004c 	andi	r4,r17,1
81130a9c:	2922b03a 	or	r17,r5,r4
81130aa0:	1806d07a 	srli	r3,r3,1
81130aa4:	1462b03a 	or	r17,r2,r17
81130aa8:	3825883a 	mov	r18,r7
81130aac:	003f7106 	br	81130874 <__reset+0xfb110874>
81130ab0:	2984b03a 	or	r2,r5,r6
81130ab4:	103f6826 	beq	r2,zero,81130858 <__reset+0xfb110858>
81130ab8:	39c03fcc 	andi	r7,r7,255
81130abc:	003f6706 	br	8113085c <__reset+0xfb11085c>
81130ac0:	4086b03a 	or	r3,r8,r2
81130ac4:	18015226 	beq	r3,zero,81131010 <__subdf3+0x828>
81130ac8:	00c00434 	movhi	r3,16
81130acc:	41400234 	orhi	r5,r8,8
81130ad0:	18ffffc4 	addi	r3,r3,-1
81130ad4:	28ca703a 	and	r5,r5,r3
81130ad8:	003f7e06 	br	811308d4 <__reset+0xfb1108d4>
81130adc:	10bfffc4 	addi	r2,r2,-1
81130ae0:	1000491e 	bne	r2,zero,81130c08 <__subdf3+0x420>
81130ae4:	898fc83a 	sub	r7,r17,r6
81130ae8:	89e3803a 	cmpltu	r17,r17,r7
81130aec:	1947c83a 	sub	r3,r3,r5
81130af0:	1c47c83a 	sub	r3,r3,r17
81130af4:	3823883a 	mov	r17,r7
81130af8:	003f9b06 	br	81130968 <__reset+0xfb110968>
81130afc:	2988b03a 	or	r4,r5,r6
81130b00:	203f5c26 	beq	r4,zero,81130874 <__reset+0xfb110874>
81130b04:	10bfffc4 	addi	r2,r2,-1
81130b08:	1000931e 	bne	r2,zero,81130d58 <__subdf3+0x570>
81130b0c:	898d883a 	add	r6,r17,r6
81130b10:	3463803a 	cmpltu	r17,r6,r17
81130b14:	1947883a 	add	r3,r3,r5
81130b18:	88c7883a 	add	r3,r17,r3
81130b1c:	3023883a 	mov	r17,r6
81130b20:	003fd306 	br	81130a70 <__reset+0xfb110a70>
81130b24:	1000541e 	bne	r2,zero,81130c78 <__subdf3+0x490>
81130b28:	80800044 	addi	r2,r16,1
81130b2c:	1081ffcc 	andi	r2,r2,2047
81130b30:	01000044 	movi	r4,1
81130b34:	2080a20e 	bge	r4,r2,81130dc0 <__subdf3+0x5d8>
81130b38:	8989c83a 	sub	r4,r17,r6
81130b3c:	8905803a 	cmpltu	r2,r17,r4
81130b40:	1967c83a 	sub	r19,r3,r5
81130b44:	98a7c83a 	sub	r19,r19,r2
81130b48:	9880202c 	andhi	r2,r19,128
81130b4c:	10006326 	beq	r2,zero,81130cdc <__subdf3+0x4f4>
81130b50:	3463c83a 	sub	r17,r6,r17
81130b54:	28c7c83a 	sub	r3,r5,r3
81130b58:	344d803a 	cmpltu	r6,r6,r17
81130b5c:	19a7c83a 	sub	r19,r3,r6
81130b60:	3825883a 	mov	r18,r7
81130b64:	983f861e 	bne	r19,zero,81130980 <__reset+0xfb110980>
81130b68:	8809883a 	mov	r4,r17
81130b6c:	111b8dc0 	call	8111b8dc <__clzsi2>
81130b70:	10800804 	addi	r2,r2,32
81130b74:	113ffe04 	addi	r4,r2,-8
81130b78:	00c007c4 	movi	r3,31
81130b7c:	193f850e 	bge	r3,r4,81130994 <__reset+0xfb110994>
81130b80:	10bff604 	addi	r2,r2,-40
81130b84:	8884983a 	sll	r2,r17,r2
81130b88:	0023883a 	mov	r17,zero
81130b8c:	243f880e 	bge	r4,r16,811309b0 <__reset+0xfb1109b0>
81130b90:	00ffe034 	movhi	r3,65408
81130b94:	18ffffc4 	addi	r3,r3,-1
81130b98:	8121c83a 	sub	r16,r16,r4
81130b9c:	10c6703a 	and	r3,r2,r3
81130ba0:	003f3406 	br	81130874 <__reset+0xfb110874>
81130ba4:	9100004c 	andi	r4,r18,1
81130ba8:	000b883a 	mov	r5,zero
81130bac:	0005883a 	mov	r2,zero
81130bb0:	003f4806 	br	811308d4 <__reset+0xfb1108d4>
81130bb4:	298cb03a 	or	r6,r5,r6
81130bb8:	300cc03a 	cmpne	r6,r6,zero
81130bbc:	0005883a 	mov	r2,zero
81130bc0:	003f6406 	br	81130954 <__reset+0xfb110954>
81130bc4:	10009a1e 	bne	r2,zero,81130e30 <__subdf3+0x648>
81130bc8:	82400044 	addi	r9,r16,1
81130bcc:	4881ffcc 	andi	r2,r9,2047
81130bd0:	02800044 	movi	r10,1
81130bd4:	5080670e 	bge	r10,r2,81130d74 <__subdf3+0x58c>
81130bd8:	0081ffc4 	movi	r2,2047
81130bdc:	4880af26 	beq	r9,r2,81130e9c <__subdf3+0x6b4>
81130be0:	898d883a 	add	r6,r17,r6
81130be4:	1945883a 	add	r2,r3,r5
81130be8:	3447803a 	cmpltu	r3,r6,r17
81130bec:	1887883a 	add	r3,r3,r2
81130bf0:	182297fa 	slli	r17,r3,31
81130bf4:	300cd07a 	srli	r6,r6,1
81130bf8:	1806d07a 	srli	r3,r3,1
81130bfc:	4821883a 	mov	r16,r9
81130c00:	89a2b03a 	or	r17,r17,r6
81130c04:	003f1b06 	br	81130874 <__reset+0xfb110874>
81130c08:	0101ffc4 	movi	r4,2047
81130c0c:	813f441e 	bne	r16,r4,81130920 <__reset+0xfb110920>
81130c10:	003f1806 	br	81130874 <__reset+0xfb110874>
81130c14:	843ff844 	addi	r16,r16,-31
81130c18:	01400804 	movi	r5,32
81130c1c:	1408d83a 	srl	r4,r2,r16
81130c20:	19405026 	beq	r3,r5,81130d64 <__subdf3+0x57c>
81130c24:	01401004 	movi	r5,64
81130c28:	28c7c83a 	sub	r3,r5,r3
81130c2c:	10c4983a 	sll	r2,r2,r3
81130c30:	88a2b03a 	or	r17,r17,r2
81130c34:	8822c03a 	cmpne	r17,r17,zero
81130c38:	2462b03a 	or	r17,r4,r17
81130c3c:	0007883a 	mov	r3,zero
81130c40:	0021883a 	mov	r16,zero
81130c44:	003f6d06 	br	811309fc <__reset+0xfb1109fc>
81130c48:	11fff804 	addi	r7,r2,-32
81130c4c:	01000804 	movi	r4,32
81130c50:	29ced83a 	srl	r7,r5,r7
81130c54:	11004526 	beq	r2,r4,81130d6c <__subdf3+0x584>
81130c58:	01001004 	movi	r4,64
81130c5c:	2089c83a 	sub	r4,r4,r2
81130c60:	2904983a 	sll	r2,r5,r4
81130c64:	118cb03a 	or	r6,r2,r6
81130c68:	300cc03a 	cmpne	r6,r6,zero
81130c6c:	398cb03a 	or	r6,r7,r6
81130c70:	0005883a 	mov	r2,zero
81130c74:	003f3706 	br	81130954 <__reset+0xfb110954>
81130c78:	80002a26 	beq	r16,zero,81130d24 <__subdf3+0x53c>
81130c7c:	0101ffc4 	movi	r4,2047
81130c80:	49006626 	beq	r9,r4,81130e1c <__subdf3+0x634>
81130c84:	0085c83a 	sub	r2,zero,r2
81130c88:	18c02034 	orhi	r3,r3,128
81130c8c:	01000e04 	movi	r4,56
81130c90:	20807e16 	blt	r4,r2,81130e8c <__subdf3+0x6a4>
81130c94:	010007c4 	movi	r4,31
81130c98:	2080e716 	blt	r4,r2,81131038 <__subdf3+0x850>
81130c9c:	01000804 	movi	r4,32
81130ca0:	2089c83a 	sub	r4,r4,r2
81130ca4:	1914983a 	sll	r10,r3,r4
81130ca8:	8890d83a 	srl	r8,r17,r2
81130cac:	8908983a 	sll	r4,r17,r4
81130cb0:	1884d83a 	srl	r2,r3,r2
81130cb4:	5222b03a 	or	r17,r10,r8
81130cb8:	2006c03a 	cmpne	r3,r4,zero
81130cbc:	88e2b03a 	or	r17,r17,r3
81130cc0:	3463c83a 	sub	r17,r6,r17
81130cc4:	2885c83a 	sub	r2,r5,r2
81130cc8:	344d803a 	cmpltu	r6,r6,r17
81130ccc:	1187c83a 	sub	r3,r2,r6
81130cd0:	4821883a 	mov	r16,r9
81130cd4:	3825883a 	mov	r18,r7
81130cd8:	003f2306 	br	81130968 <__reset+0xfb110968>
81130cdc:	24d0b03a 	or	r8,r4,r19
81130ce0:	40001b1e 	bne	r8,zero,81130d50 <__subdf3+0x568>
81130ce4:	0005883a 	mov	r2,zero
81130ce8:	0009883a 	mov	r4,zero
81130cec:	0021883a 	mov	r16,zero
81130cf0:	003f4906 	br	81130a18 <__reset+0xfb110a18>
81130cf4:	010007c4 	movi	r4,31
81130cf8:	20803a16 	blt	r4,r2,81130de4 <__subdf3+0x5fc>
81130cfc:	01000804 	movi	r4,32
81130d00:	2089c83a 	sub	r4,r4,r2
81130d04:	2912983a 	sll	r9,r5,r4
81130d08:	3090d83a 	srl	r8,r6,r2
81130d0c:	3108983a 	sll	r4,r6,r4
81130d10:	2884d83a 	srl	r2,r5,r2
81130d14:	4a12b03a 	or	r9,r9,r8
81130d18:	2008c03a 	cmpne	r4,r4,zero
81130d1c:	4912b03a 	or	r9,r9,r4
81130d20:	003f4e06 	br	81130a5c <__reset+0xfb110a5c>
81130d24:	1c48b03a 	or	r4,r3,r17
81130d28:	20003c26 	beq	r4,zero,81130e1c <__subdf3+0x634>
81130d2c:	0084303a 	nor	r2,zero,r2
81130d30:	1000381e 	bne	r2,zero,81130e14 <__subdf3+0x62c>
81130d34:	3463c83a 	sub	r17,r6,r17
81130d38:	28c5c83a 	sub	r2,r5,r3
81130d3c:	344d803a 	cmpltu	r6,r6,r17
81130d40:	1187c83a 	sub	r3,r2,r6
81130d44:	4821883a 	mov	r16,r9
81130d48:	3825883a 	mov	r18,r7
81130d4c:	003f0606 	br	81130968 <__reset+0xfb110968>
81130d50:	2023883a 	mov	r17,r4
81130d54:	003f0906 	br	8113097c <__reset+0xfb11097c>
81130d58:	0101ffc4 	movi	r4,2047
81130d5c:	813f3a1e 	bne	r16,r4,81130a48 <__reset+0xfb110a48>
81130d60:	003ec406 	br	81130874 <__reset+0xfb110874>
81130d64:	0005883a 	mov	r2,zero
81130d68:	003fb106 	br	81130c30 <__reset+0xfb110c30>
81130d6c:	0005883a 	mov	r2,zero
81130d70:	003fbc06 	br	81130c64 <__reset+0xfb110c64>
81130d74:	1c44b03a 	or	r2,r3,r17
81130d78:	80008e1e 	bne	r16,zero,81130fb4 <__subdf3+0x7cc>
81130d7c:	1000c826 	beq	r2,zero,811310a0 <__subdf3+0x8b8>
81130d80:	2984b03a 	or	r2,r5,r6
81130d84:	103ebb26 	beq	r2,zero,81130874 <__reset+0xfb110874>
81130d88:	8989883a 	add	r4,r17,r6
81130d8c:	1945883a 	add	r2,r3,r5
81130d90:	2447803a 	cmpltu	r3,r4,r17
81130d94:	1887883a 	add	r3,r3,r2
81130d98:	1880202c 	andhi	r2,r3,128
81130d9c:	2023883a 	mov	r17,r4
81130da0:	103f1626 	beq	r2,zero,811309fc <__reset+0xfb1109fc>
81130da4:	00bfe034 	movhi	r2,65408
81130da8:	10bfffc4 	addi	r2,r2,-1
81130dac:	5021883a 	mov	r16,r10
81130db0:	1886703a 	and	r3,r3,r2
81130db4:	003eaf06 	br	81130874 <__reset+0xfb110874>
81130db8:	3825883a 	mov	r18,r7
81130dbc:	003f0f06 	br	811309fc <__reset+0xfb1109fc>
81130dc0:	1c44b03a 	or	r2,r3,r17
81130dc4:	8000251e 	bne	r16,zero,81130e5c <__subdf3+0x674>
81130dc8:	1000661e 	bne	r2,zero,81130f64 <__subdf3+0x77c>
81130dcc:	2990b03a 	or	r8,r5,r6
81130dd0:	40009626 	beq	r8,zero,8113102c <__subdf3+0x844>
81130dd4:	2807883a 	mov	r3,r5
81130dd8:	3023883a 	mov	r17,r6
81130ddc:	3825883a 	mov	r18,r7
81130de0:	003ea406 	br	81130874 <__reset+0xfb110874>
81130de4:	127ff804 	addi	r9,r2,-32
81130de8:	01000804 	movi	r4,32
81130dec:	2a52d83a 	srl	r9,r5,r9
81130df0:	11008c26 	beq	r2,r4,81131024 <__subdf3+0x83c>
81130df4:	01001004 	movi	r4,64
81130df8:	2085c83a 	sub	r2,r4,r2
81130dfc:	2884983a 	sll	r2,r5,r2
81130e00:	118cb03a 	or	r6,r2,r6
81130e04:	300cc03a 	cmpne	r6,r6,zero
81130e08:	4992b03a 	or	r9,r9,r6
81130e0c:	0005883a 	mov	r2,zero
81130e10:	003f1206 	br	81130a5c <__reset+0xfb110a5c>
81130e14:	0101ffc4 	movi	r4,2047
81130e18:	493f9c1e 	bne	r9,r4,81130c8c <__reset+0xfb110c8c>
81130e1c:	2807883a 	mov	r3,r5
81130e20:	3023883a 	mov	r17,r6
81130e24:	4821883a 	mov	r16,r9
81130e28:	3825883a 	mov	r18,r7
81130e2c:	003e9106 	br	81130874 <__reset+0xfb110874>
81130e30:	80001f1e 	bne	r16,zero,81130eb0 <__subdf3+0x6c8>
81130e34:	1c48b03a 	or	r4,r3,r17
81130e38:	20005a26 	beq	r4,zero,81130fa4 <__subdf3+0x7bc>
81130e3c:	0084303a 	nor	r2,zero,r2
81130e40:	1000561e 	bne	r2,zero,81130f9c <__subdf3+0x7b4>
81130e44:	89a3883a 	add	r17,r17,r6
81130e48:	1945883a 	add	r2,r3,r5
81130e4c:	898d803a 	cmpltu	r6,r17,r6
81130e50:	3087883a 	add	r3,r6,r2
81130e54:	4821883a 	mov	r16,r9
81130e58:	003f0506 	br	81130a70 <__reset+0xfb110a70>
81130e5c:	10002b1e 	bne	r2,zero,81130f0c <__subdf3+0x724>
81130e60:	2984b03a 	or	r2,r5,r6
81130e64:	10008026 	beq	r2,zero,81131068 <__subdf3+0x880>
81130e68:	2807883a 	mov	r3,r5
81130e6c:	3023883a 	mov	r17,r6
81130e70:	3825883a 	mov	r18,r7
81130e74:	0401ffc4 	movi	r16,2047
81130e78:	003e7e06 	br	81130874 <__reset+0xfb110874>
81130e7c:	3809883a 	mov	r4,r7
81130e80:	0011883a 	mov	r8,zero
81130e84:	0005883a 	mov	r2,zero
81130e88:	003ee306 	br	81130a18 <__reset+0xfb110a18>
81130e8c:	1c62b03a 	or	r17,r3,r17
81130e90:	8822c03a 	cmpne	r17,r17,zero
81130e94:	0005883a 	mov	r2,zero
81130e98:	003f8906 	br	81130cc0 <__reset+0xfb110cc0>
81130e9c:	3809883a 	mov	r4,r7
81130ea0:	4821883a 	mov	r16,r9
81130ea4:	0011883a 	mov	r8,zero
81130ea8:	0005883a 	mov	r2,zero
81130eac:	003eda06 	br	81130a18 <__reset+0xfb110a18>
81130eb0:	0101ffc4 	movi	r4,2047
81130eb4:	49003b26 	beq	r9,r4,81130fa4 <__subdf3+0x7bc>
81130eb8:	0085c83a 	sub	r2,zero,r2
81130ebc:	18c02034 	orhi	r3,r3,128
81130ec0:	01000e04 	movi	r4,56
81130ec4:	20806e16 	blt	r4,r2,81131080 <__subdf3+0x898>
81130ec8:	010007c4 	movi	r4,31
81130ecc:	20807716 	blt	r4,r2,811310ac <__subdf3+0x8c4>
81130ed0:	01000804 	movi	r4,32
81130ed4:	2089c83a 	sub	r4,r4,r2
81130ed8:	1914983a 	sll	r10,r3,r4
81130edc:	8890d83a 	srl	r8,r17,r2
81130ee0:	8908983a 	sll	r4,r17,r4
81130ee4:	1884d83a 	srl	r2,r3,r2
81130ee8:	5222b03a 	or	r17,r10,r8
81130eec:	2006c03a 	cmpne	r3,r4,zero
81130ef0:	88e2b03a 	or	r17,r17,r3
81130ef4:	89a3883a 	add	r17,r17,r6
81130ef8:	1145883a 	add	r2,r2,r5
81130efc:	898d803a 	cmpltu	r6,r17,r6
81130f00:	3087883a 	add	r3,r6,r2
81130f04:	4821883a 	mov	r16,r9
81130f08:	003ed906 	br	81130a70 <__reset+0xfb110a70>
81130f0c:	2984b03a 	or	r2,r5,r6
81130f10:	10004226 	beq	r2,zero,8113101c <__subdf3+0x834>
81130f14:	1808d0fa 	srli	r4,r3,3
81130f18:	8822d0fa 	srli	r17,r17,3
81130f1c:	1806977a 	slli	r3,r3,29
81130f20:	2080022c 	andhi	r2,r4,8
81130f24:	1c62b03a 	or	r17,r3,r17
81130f28:	10000826 	beq	r2,zero,81130f4c <__subdf3+0x764>
81130f2c:	2812d0fa 	srli	r9,r5,3
81130f30:	4880022c 	andhi	r2,r9,8
81130f34:	1000051e 	bne	r2,zero,81130f4c <__subdf3+0x764>
81130f38:	300cd0fa 	srli	r6,r6,3
81130f3c:	2804977a 	slli	r2,r5,29
81130f40:	4809883a 	mov	r4,r9
81130f44:	3825883a 	mov	r18,r7
81130f48:	11a2b03a 	or	r17,r2,r6
81130f4c:	8806d77a 	srli	r3,r17,29
81130f50:	200890fa 	slli	r4,r4,3
81130f54:	882290fa 	slli	r17,r17,3
81130f58:	0401ffc4 	movi	r16,2047
81130f5c:	1906b03a 	or	r3,r3,r4
81130f60:	003e4406 	br	81130874 <__reset+0xfb110874>
81130f64:	2984b03a 	or	r2,r5,r6
81130f68:	103e4226 	beq	r2,zero,81130874 <__reset+0xfb110874>
81130f6c:	8989c83a 	sub	r4,r17,r6
81130f70:	8911803a 	cmpltu	r8,r17,r4
81130f74:	1945c83a 	sub	r2,r3,r5
81130f78:	1205c83a 	sub	r2,r2,r8
81130f7c:	1200202c 	andhi	r8,r2,128
81130f80:	403e9a26 	beq	r8,zero,811309ec <__reset+0xfb1109ec>
81130f84:	3463c83a 	sub	r17,r6,r17
81130f88:	28c5c83a 	sub	r2,r5,r3
81130f8c:	344d803a 	cmpltu	r6,r6,r17
81130f90:	1187c83a 	sub	r3,r2,r6
81130f94:	3825883a 	mov	r18,r7
81130f98:	003e3606 	br	81130874 <__reset+0xfb110874>
81130f9c:	0101ffc4 	movi	r4,2047
81130fa0:	493fc71e 	bne	r9,r4,81130ec0 <__reset+0xfb110ec0>
81130fa4:	2807883a 	mov	r3,r5
81130fa8:	3023883a 	mov	r17,r6
81130fac:	4821883a 	mov	r16,r9
81130fb0:	003e3006 	br	81130874 <__reset+0xfb110874>
81130fb4:	10003626 	beq	r2,zero,81131090 <__subdf3+0x8a8>
81130fb8:	2984b03a 	or	r2,r5,r6
81130fbc:	10001726 	beq	r2,zero,8113101c <__subdf3+0x834>
81130fc0:	1808d0fa 	srli	r4,r3,3
81130fc4:	8822d0fa 	srli	r17,r17,3
81130fc8:	1806977a 	slli	r3,r3,29
81130fcc:	2080022c 	andhi	r2,r4,8
81130fd0:	1c62b03a 	or	r17,r3,r17
81130fd4:	10000726 	beq	r2,zero,81130ff4 <__subdf3+0x80c>
81130fd8:	2812d0fa 	srli	r9,r5,3
81130fdc:	4880022c 	andhi	r2,r9,8
81130fe0:	1000041e 	bne	r2,zero,81130ff4 <__subdf3+0x80c>
81130fe4:	300cd0fa 	srli	r6,r6,3
81130fe8:	2804977a 	slli	r2,r5,29
81130fec:	4809883a 	mov	r4,r9
81130ff0:	11a2b03a 	or	r17,r2,r6
81130ff4:	8806d77a 	srli	r3,r17,29
81130ff8:	200890fa 	slli	r4,r4,3
81130ffc:	882290fa 	slli	r17,r17,3
81131000:	3825883a 	mov	r18,r7
81131004:	1906b03a 	or	r3,r3,r4
81131008:	0401ffc4 	movi	r16,2047
8113100c:	003e1906 	br	81130874 <__reset+0xfb110874>
81131010:	000b883a 	mov	r5,zero
81131014:	0005883a 	mov	r2,zero
81131018:	003e2e06 	br	811308d4 <__reset+0xfb1108d4>
8113101c:	0401ffc4 	movi	r16,2047
81131020:	003e1406 	br	81130874 <__reset+0xfb110874>
81131024:	0005883a 	mov	r2,zero
81131028:	003f7506 	br	81130e00 <__reset+0xfb110e00>
8113102c:	0005883a 	mov	r2,zero
81131030:	0009883a 	mov	r4,zero
81131034:	003e7806 	br	81130a18 <__reset+0xfb110a18>
81131038:	123ff804 	addi	r8,r2,-32
8113103c:	01000804 	movi	r4,32
81131040:	1a10d83a 	srl	r8,r3,r8
81131044:	11002526 	beq	r2,r4,811310dc <__subdf3+0x8f4>
81131048:	01001004 	movi	r4,64
8113104c:	2085c83a 	sub	r2,r4,r2
81131050:	1884983a 	sll	r2,r3,r2
81131054:	1444b03a 	or	r2,r2,r17
81131058:	1004c03a 	cmpne	r2,r2,zero
8113105c:	40a2b03a 	or	r17,r8,r2
81131060:	0005883a 	mov	r2,zero
81131064:	003f1606 	br	81130cc0 <__reset+0xfb110cc0>
81131068:	02000434 	movhi	r8,16
8113106c:	0009883a 	mov	r4,zero
81131070:	423fffc4 	addi	r8,r8,-1
81131074:	00bfffc4 	movi	r2,-1
81131078:	0401ffc4 	movi	r16,2047
8113107c:	003e6606 	br	81130a18 <__reset+0xfb110a18>
81131080:	1c62b03a 	or	r17,r3,r17
81131084:	8822c03a 	cmpne	r17,r17,zero
81131088:	0005883a 	mov	r2,zero
8113108c:	003f9906 	br	81130ef4 <__reset+0xfb110ef4>
81131090:	2807883a 	mov	r3,r5
81131094:	3023883a 	mov	r17,r6
81131098:	0401ffc4 	movi	r16,2047
8113109c:	003df506 	br	81130874 <__reset+0xfb110874>
811310a0:	2807883a 	mov	r3,r5
811310a4:	3023883a 	mov	r17,r6
811310a8:	003df206 	br	81130874 <__reset+0xfb110874>
811310ac:	123ff804 	addi	r8,r2,-32
811310b0:	01000804 	movi	r4,32
811310b4:	1a10d83a 	srl	r8,r3,r8
811310b8:	11000a26 	beq	r2,r4,811310e4 <__subdf3+0x8fc>
811310bc:	01001004 	movi	r4,64
811310c0:	2085c83a 	sub	r2,r4,r2
811310c4:	1884983a 	sll	r2,r3,r2
811310c8:	1444b03a 	or	r2,r2,r17
811310cc:	1004c03a 	cmpne	r2,r2,zero
811310d0:	40a2b03a 	or	r17,r8,r2
811310d4:	0005883a 	mov	r2,zero
811310d8:	003f8606 	br	81130ef4 <__reset+0xfb110ef4>
811310dc:	0005883a 	mov	r2,zero
811310e0:	003fdc06 	br	81131054 <__reset+0xfb111054>
811310e4:	0005883a 	mov	r2,zero
811310e8:	003ff706 	br	811310c8 <__reset+0xfb1110c8>

811310ec <__fixdfsi>:
811310ec:	280cd53a 	srli	r6,r5,20
811310f0:	00c00434 	movhi	r3,16
811310f4:	18ffffc4 	addi	r3,r3,-1
811310f8:	3181ffcc 	andi	r6,r6,2047
811310fc:	01c0ff84 	movi	r7,1022
81131100:	28c6703a 	and	r3,r5,r3
81131104:	280ad7fa 	srli	r5,r5,31
81131108:	3980120e 	bge	r7,r6,81131154 <__fixdfsi+0x68>
8113110c:	00810744 	movi	r2,1053
81131110:	11800c16 	blt	r2,r6,81131144 <__fixdfsi+0x58>
81131114:	00810cc4 	movi	r2,1075
81131118:	1185c83a 	sub	r2,r2,r6
8113111c:	01c007c4 	movi	r7,31
81131120:	18c00434 	orhi	r3,r3,16
81131124:	38800d16 	blt	r7,r2,8113115c <__fixdfsi+0x70>
81131128:	31befb44 	addi	r6,r6,-1043
8113112c:	2084d83a 	srl	r2,r4,r2
81131130:	1986983a 	sll	r3,r3,r6
81131134:	1884b03a 	or	r2,r3,r2
81131138:	28000726 	beq	r5,zero,81131158 <__fixdfsi+0x6c>
8113113c:	0085c83a 	sub	r2,zero,r2
81131140:	f800283a 	ret
81131144:	00a00034 	movhi	r2,32768
81131148:	10bfffc4 	addi	r2,r2,-1
8113114c:	2885883a 	add	r2,r5,r2
81131150:	f800283a 	ret
81131154:	0005883a 	mov	r2,zero
81131158:	f800283a 	ret
8113115c:	008104c4 	movi	r2,1043
81131160:	1185c83a 	sub	r2,r2,r6
81131164:	1884d83a 	srl	r2,r3,r2
81131168:	003ff306 	br	81131138 <__reset+0xfb111138>

8113116c <__floatsidf>:
8113116c:	defffd04 	addi	sp,sp,-12
81131170:	de00012e 	bgeu	sp,et,81131178 <__floatsidf+0xc>
81131174:	003b68fa 	trap	3
81131178:	dfc00215 	stw	ra,8(sp)
8113117c:	dc400115 	stw	r17,4(sp)
81131180:	dc000015 	stw	r16,0(sp)
81131184:	20002b26 	beq	r4,zero,81131234 <__floatsidf+0xc8>
81131188:	2023883a 	mov	r17,r4
8113118c:	2020d7fa 	srli	r16,r4,31
81131190:	20002d16 	blt	r4,zero,81131248 <__floatsidf+0xdc>
81131194:	8809883a 	mov	r4,r17
81131198:	111b8dc0 	call	8111b8dc <__clzsi2>
8113119c:	01410784 	movi	r5,1054
811311a0:	288bc83a 	sub	r5,r5,r2
811311a4:	01010cc4 	movi	r4,1075
811311a8:	2149c83a 	sub	r4,r4,r5
811311ac:	00c007c4 	movi	r3,31
811311b0:	1900160e 	bge	r3,r4,8113120c <__floatsidf+0xa0>
811311b4:	00c104c4 	movi	r3,1043
811311b8:	1947c83a 	sub	r3,r3,r5
811311bc:	88c6983a 	sll	r3,r17,r3
811311c0:	00800434 	movhi	r2,16
811311c4:	10bfffc4 	addi	r2,r2,-1
811311c8:	1886703a 	and	r3,r3,r2
811311cc:	2941ffcc 	andi	r5,r5,2047
811311d0:	800d883a 	mov	r6,r16
811311d4:	0005883a 	mov	r2,zero
811311d8:	280a953a 	slli	r5,r5,20
811311dc:	31803fcc 	andi	r6,r6,255
811311e0:	01000434 	movhi	r4,16
811311e4:	300c97fa 	slli	r6,r6,31
811311e8:	213fffc4 	addi	r4,r4,-1
811311ec:	1906703a 	and	r3,r3,r4
811311f0:	1946b03a 	or	r3,r3,r5
811311f4:	1986b03a 	or	r3,r3,r6
811311f8:	dfc00217 	ldw	ra,8(sp)
811311fc:	dc400117 	ldw	r17,4(sp)
81131200:	dc000017 	ldw	r16,0(sp)
81131204:	dec00304 	addi	sp,sp,12
81131208:	f800283a 	ret
8113120c:	00c002c4 	movi	r3,11
81131210:	1887c83a 	sub	r3,r3,r2
81131214:	88c6d83a 	srl	r3,r17,r3
81131218:	8904983a 	sll	r2,r17,r4
8113121c:	01000434 	movhi	r4,16
81131220:	213fffc4 	addi	r4,r4,-1
81131224:	2941ffcc 	andi	r5,r5,2047
81131228:	1906703a 	and	r3,r3,r4
8113122c:	800d883a 	mov	r6,r16
81131230:	003fe906 	br	811311d8 <__reset+0xfb1111d8>
81131234:	000d883a 	mov	r6,zero
81131238:	000b883a 	mov	r5,zero
8113123c:	0007883a 	mov	r3,zero
81131240:	0005883a 	mov	r2,zero
81131244:	003fe406 	br	811311d8 <__reset+0xfb1111d8>
81131248:	0123c83a 	sub	r17,zero,r4
8113124c:	003fd106 	br	81131194 <__reset+0xfb111194>

81131250 <__floatunsidf>:
81131250:	defffe04 	addi	sp,sp,-8
81131254:	de00012e 	bgeu	sp,et,8113125c <__floatunsidf+0xc>
81131258:	003b68fa 	trap	3
8113125c:	dc000015 	stw	r16,0(sp)
81131260:	dfc00115 	stw	ra,4(sp)
81131264:	2021883a 	mov	r16,r4
81131268:	20002226 	beq	r4,zero,811312f4 <__floatunsidf+0xa4>
8113126c:	111b8dc0 	call	8111b8dc <__clzsi2>
81131270:	01010784 	movi	r4,1054
81131274:	2089c83a 	sub	r4,r4,r2
81131278:	01810cc4 	movi	r6,1075
8113127c:	310dc83a 	sub	r6,r6,r4
81131280:	00c007c4 	movi	r3,31
81131284:	1980120e 	bge	r3,r6,811312d0 <__floatunsidf+0x80>
81131288:	00c104c4 	movi	r3,1043
8113128c:	1907c83a 	sub	r3,r3,r4
81131290:	80ca983a 	sll	r5,r16,r3
81131294:	00800434 	movhi	r2,16
81131298:	10bfffc4 	addi	r2,r2,-1
8113129c:	2101ffcc 	andi	r4,r4,2047
811312a0:	0021883a 	mov	r16,zero
811312a4:	288a703a 	and	r5,r5,r2
811312a8:	2008953a 	slli	r4,r4,20
811312ac:	00c00434 	movhi	r3,16
811312b0:	18ffffc4 	addi	r3,r3,-1
811312b4:	28c6703a 	and	r3,r5,r3
811312b8:	8005883a 	mov	r2,r16
811312bc:	1906b03a 	or	r3,r3,r4
811312c0:	dfc00117 	ldw	ra,4(sp)
811312c4:	dc000017 	ldw	r16,0(sp)
811312c8:	dec00204 	addi	sp,sp,8
811312cc:	f800283a 	ret
811312d0:	00c002c4 	movi	r3,11
811312d4:	188bc83a 	sub	r5,r3,r2
811312d8:	814ad83a 	srl	r5,r16,r5
811312dc:	00c00434 	movhi	r3,16
811312e0:	18ffffc4 	addi	r3,r3,-1
811312e4:	81a0983a 	sll	r16,r16,r6
811312e8:	2101ffcc 	andi	r4,r4,2047
811312ec:	28ca703a 	and	r5,r5,r3
811312f0:	003fed06 	br	811312a8 <__reset+0xfb1112a8>
811312f4:	0009883a 	mov	r4,zero
811312f8:	000b883a 	mov	r5,zero
811312fc:	003fea06 	br	811312a8 <__reset+0xfb1112a8>

81131300 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
81131300:	defffb04 	addi	sp,sp,-20
81131304:	de00012e 	bgeu	sp,et,8113130c <alt_busy_sleep+0xc>
81131308:	003b68fa 	trap	3
8113130c:	df000415 	stw	fp,16(sp)
81131310:	df000404 	addi	fp,sp,16
81131314:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81131318:	008000c4 	movi	r2,3
8113131c:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
81131320:	e0fffd17 	ldw	r3,-12(fp)
81131324:	008003f4 	movhi	r2,15
81131328:	10909004 	addi	r2,r2,16960
8113132c:	1887383a 	mul	r3,r3,r2
81131330:	00817db4 	movhi	r2,1526
81131334:	10b84004 	addi	r2,r2,-7936
81131338:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
8113133c:	00a00034 	movhi	r2,32768
81131340:	10bfffc4 	addi	r2,r2,-1
81131344:	10c5203a 	divu	r2,r2,r3
81131348:	e0ffff17 	ldw	r3,-4(fp)
8113134c:	1885203a 	divu	r2,r3,r2
81131350:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81131354:	e0bffe17 	ldw	r2,-8(fp)
81131358:	10002526 	beq	r2,zero,811313f0 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
8113135c:	e03ffc15 	stw	zero,-16(fp)
81131360:	00001406 	br	811313b4 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81131364:	00a00034 	movhi	r2,32768
81131368:	10bfffc4 	addi	r2,r2,-1
8113136c:	10bfffc4 	addi	r2,r2,-1
81131370:	103ffe1e 	bne	r2,zero,8113136c <__reset+0xfb11136c>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81131374:	e0fffd17 	ldw	r3,-12(fp)
81131378:	008003f4 	movhi	r2,15
8113137c:	10909004 	addi	r2,r2,16960
81131380:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81131384:	00817db4 	movhi	r2,1526
81131388:	10b84004 	addi	r2,r2,-7936
8113138c:	10c7203a 	divu	r3,r2,r3
81131390:	00a00034 	movhi	r2,32768
81131394:	10bfffc4 	addi	r2,r2,-1
81131398:	10c5203a 	divu	r2,r2,r3
8113139c:	e0ffff17 	ldw	r3,-4(fp)
811313a0:	1885c83a 	sub	r2,r3,r2
811313a4:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
811313a8:	e0bffc17 	ldw	r2,-16(fp)
811313ac:	10800044 	addi	r2,r2,1
811313b0:	e0bffc15 	stw	r2,-16(fp)
811313b4:	e0fffc17 	ldw	r3,-16(fp)
811313b8:	e0bffe17 	ldw	r2,-8(fp)
811313bc:	18bfe916 	blt	r3,r2,81131364 <__reset+0xfb111364>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
811313c0:	e0fffd17 	ldw	r3,-12(fp)
811313c4:	008003f4 	movhi	r2,15
811313c8:	10909004 	addi	r2,r2,16960
811313cc:	1887383a 	mul	r3,r3,r2
811313d0:	00817db4 	movhi	r2,1526
811313d4:	10b84004 	addi	r2,r2,-7936
811313d8:	10c7203a 	divu	r3,r2,r3
811313dc:	e0bfff17 	ldw	r2,-4(fp)
811313e0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811313e4:	10bfffc4 	addi	r2,r2,-1
811313e8:	103ffe1e 	bne	r2,zero,811313e4 <__reset+0xfb1113e4>
811313ec:	00000b06 	br	8113141c <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
811313f0:	e0fffd17 	ldw	r3,-12(fp)
811313f4:	008003f4 	movhi	r2,15
811313f8:	10909004 	addi	r2,r2,16960
811313fc:	1887383a 	mul	r3,r3,r2
81131400:	00817db4 	movhi	r2,1526
81131404:	10b84004 	addi	r2,r2,-7936
81131408:	10c7203a 	divu	r3,r2,r3
8113140c:	e0bfff17 	ldw	r2,-4(fp)
81131410:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81131414:	10bfffc4 	addi	r2,r2,-1
81131418:	00bffe16 	blt	zero,r2,81131414 <__reset+0xfb111414>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
8113141c:	0005883a 	mov	r2,zero
}
81131420:	e037883a 	mov	sp,fp
81131424:	df000017 	ldw	fp,0(sp)
81131428:	dec00104 	addi	sp,sp,4
8113142c:	f800283a 	ret

81131430 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131430:	defffe04 	addi	sp,sp,-8
81131434:	de00012e 	bgeu	sp,et,8113143c <alt_get_errno+0xc>
81131438:	003b68fa 	trap	3
8113143c:	dfc00115 	stw	ra,4(sp)
81131440:	df000015 	stw	fp,0(sp)
81131444:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131448:	d0a01017 	ldw	r2,-32704(gp)
8113144c:	10000326 	beq	r2,zero,8113145c <alt_get_errno+0x2c>
81131450:	d0a01017 	ldw	r2,-32704(gp)
81131454:	103ee83a 	callr	r2
81131458:	00000106 	br	81131460 <alt_get_errno+0x30>
8113145c:	d0a07204 	addi	r2,gp,-32312
}
81131460:	e037883a 	mov	sp,fp
81131464:	dfc00117 	ldw	ra,4(sp)
81131468:	df000017 	ldw	fp,0(sp)
8113146c:	dec00204 	addi	sp,sp,8
81131470:	f800283a 	ret

81131474 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81131474:	defffb04 	addi	sp,sp,-20
81131478:	de00012e 	bgeu	sp,et,81131480 <close+0xc>
8113147c:	003b68fa 	trap	3
81131480:	dfc00415 	stw	ra,16(sp)
81131484:	df000315 	stw	fp,12(sp)
81131488:	df000304 	addi	fp,sp,12
8113148c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81131490:	e0bfff17 	ldw	r2,-4(fp)
81131494:	10000616 	blt	r2,zero,811314b0 <close+0x3c>
81131498:	e0bfff17 	ldw	r2,-4(fp)
8113149c:	10c00324 	muli	r3,r2,12
811314a0:	00a04574 	movhi	r2,33045
811314a4:	10b01104 	addi	r2,r2,-16316
811314a8:	1885883a 	add	r2,r3,r2
811314ac:	00000106 	br	811314b4 <close+0x40>
811314b0:	0005883a 	mov	r2,zero
811314b4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
811314b8:	e0bffd17 	ldw	r2,-12(fp)
811314bc:	10001926 	beq	r2,zero,81131524 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
811314c0:	e0bffd17 	ldw	r2,-12(fp)
811314c4:	10800017 	ldw	r2,0(r2)
811314c8:	10800417 	ldw	r2,16(r2)
811314cc:	10000626 	beq	r2,zero,811314e8 <close+0x74>
811314d0:	e0bffd17 	ldw	r2,-12(fp)
811314d4:	10800017 	ldw	r2,0(r2)
811314d8:	10800417 	ldw	r2,16(r2)
811314dc:	e13ffd17 	ldw	r4,-12(fp)
811314e0:	103ee83a 	callr	r2
811314e4:	00000106 	br	811314ec <close+0x78>
811314e8:	0005883a 	mov	r2,zero
811314ec:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
811314f0:	e13fff17 	ldw	r4,-4(fp)
811314f4:	1132a580 	call	81132a58 <alt_release_fd>
    if (rval < 0)
811314f8:	e0bffe17 	ldw	r2,-8(fp)
811314fc:	1000070e 	bge	r2,zero,8113151c <close+0xa8>
    {
      ALT_ERRNO = -rval;
81131500:	11314300 	call	81131430 <alt_get_errno>
81131504:	1007883a 	mov	r3,r2
81131508:	e0bffe17 	ldw	r2,-8(fp)
8113150c:	0085c83a 	sub	r2,zero,r2
81131510:	18800015 	stw	r2,0(r3)
      return -1;
81131514:	00bfffc4 	movi	r2,-1
81131518:	00000706 	br	81131538 <close+0xc4>
    }
    return 0;
8113151c:	0005883a 	mov	r2,zero
81131520:	00000506 	br	81131538 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81131524:	11314300 	call	81131430 <alt_get_errno>
81131528:	1007883a 	mov	r3,r2
8113152c:	00801444 	movi	r2,81
81131530:	18800015 	stw	r2,0(r3)
    return -1;
81131534:	00bfffc4 	movi	r2,-1
  }
}
81131538:	e037883a 	mov	sp,fp
8113153c:	dfc00117 	ldw	ra,4(sp)
81131540:	df000017 	ldw	fp,0(sp)
81131544:	dec00204 	addi	sp,sp,8
81131548:	f800283a 	ret

8113154c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
8113154c:	deffff04 	addi	sp,sp,-4
81131550:	de00012e 	bgeu	sp,et,81131558 <alt_dcache_flush_all+0xc>
81131554:	003b68fa 	trap	3
81131558:	df000015 	stw	fp,0(sp)
8113155c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81131560:	0001883a 	nop
81131564:	e037883a 	mov	sp,fp
81131568:	df000017 	ldw	fp,0(sp)
8113156c:	dec00104 	addi	sp,sp,4
81131570:	f800283a 	ret

81131574 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81131574:	defffc04 	addi	sp,sp,-16
81131578:	de00012e 	bgeu	sp,et,81131580 <alt_dev_null_write+0xc>
8113157c:	003b68fa 	trap	3
81131580:	df000315 	stw	fp,12(sp)
81131584:	df000304 	addi	fp,sp,12
81131588:	e13ffd15 	stw	r4,-12(fp)
8113158c:	e17ffe15 	stw	r5,-8(fp)
81131590:	e1bfff15 	stw	r6,-4(fp)
  return len;
81131594:	e0bfff17 	ldw	r2,-4(fp)
}
81131598:	e037883a 	mov	sp,fp
8113159c:	df000017 	ldw	fp,0(sp)
811315a0:	dec00104 	addi	sp,sp,4
811315a4:	f800283a 	ret

811315a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811315a8:	defffe04 	addi	sp,sp,-8
811315ac:	de00012e 	bgeu	sp,et,811315b4 <alt_get_errno+0xc>
811315b0:	003b68fa 	trap	3
811315b4:	dfc00115 	stw	ra,4(sp)
811315b8:	df000015 	stw	fp,0(sp)
811315bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811315c0:	d0a01017 	ldw	r2,-32704(gp)
811315c4:	10000326 	beq	r2,zero,811315d4 <alt_get_errno+0x2c>
811315c8:	d0a01017 	ldw	r2,-32704(gp)
811315cc:	103ee83a 	callr	r2
811315d0:	00000106 	br	811315d8 <alt_get_errno+0x30>
811315d4:	d0a07204 	addi	r2,gp,-32312
}
811315d8:	e037883a 	mov	sp,fp
811315dc:	dfc00117 	ldw	ra,4(sp)
811315e0:	df000017 	ldw	fp,0(sp)
811315e4:	dec00204 	addi	sp,sp,8
811315e8:	f800283a 	ret

811315ec <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
811315ec:	defffb04 	addi	sp,sp,-20
811315f0:	de00012e 	bgeu	sp,et,811315f8 <fstat+0xc>
811315f4:	003b68fa 	trap	3
811315f8:	dfc00415 	stw	ra,16(sp)
811315fc:	df000315 	stw	fp,12(sp)
81131600:	df000304 	addi	fp,sp,12
81131604:	e13ffe15 	stw	r4,-8(fp)
81131608:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113160c:	e0bffe17 	ldw	r2,-8(fp)
81131610:	10000616 	blt	r2,zero,8113162c <fstat+0x40>
81131614:	e0bffe17 	ldw	r2,-8(fp)
81131618:	10c00324 	muli	r3,r2,12
8113161c:	00a04574 	movhi	r2,33045
81131620:	10b01104 	addi	r2,r2,-16316
81131624:	1885883a 	add	r2,r3,r2
81131628:	00000106 	br	81131630 <fstat+0x44>
8113162c:	0005883a 	mov	r2,zero
81131630:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81131634:	e0bffd17 	ldw	r2,-12(fp)
81131638:	10001026 	beq	r2,zero,8113167c <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
8113163c:	e0bffd17 	ldw	r2,-12(fp)
81131640:	10800017 	ldw	r2,0(r2)
81131644:	10800817 	ldw	r2,32(r2)
81131648:	10000726 	beq	r2,zero,81131668 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
8113164c:	e0bffd17 	ldw	r2,-12(fp)
81131650:	10800017 	ldw	r2,0(r2)
81131654:	10800817 	ldw	r2,32(r2)
81131658:	e17fff17 	ldw	r5,-4(fp)
8113165c:	e13ffd17 	ldw	r4,-12(fp)
81131660:	103ee83a 	callr	r2
81131664:	00000a06 	br	81131690 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81131668:	e0bfff17 	ldw	r2,-4(fp)
8113166c:	00c80004 	movi	r3,8192
81131670:	10c00115 	stw	r3,4(r2)
      return 0;
81131674:	0005883a 	mov	r2,zero
81131678:	00000506 	br	81131690 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8113167c:	11315a80 	call	811315a8 <alt_get_errno>
81131680:	1007883a 	mov	r3,r2
81131684:	00801444 	movi	r2,81
81131688:	18800015 	stw	r2,0(r3)
    return -1;
8113168c:	00bfffc4 	movi	r2,-1
  }
}
81131690:	e037883a 	mov	sp,fp
81131694:	dfc00117 	ldw	ra,4(sp)
81131698:	df000017 	ldw	fp,0(sp)
8113169c:	dec00204 	addi	sp,sp,8
811316a0:	f800283a 	ret

811316a4 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
811316a4:	defff004 	addi	sp,sp,-64
811316a8:	de00012e 	bgeu	sp,et,811316b0 <alt_irq_register+0xc>
811316ac:	003b68fa 	trap	3
811316b0:	df000f15 	stw	fp,60(sp)
811316b4:	df000f04 	addi	fp,sp,60
811316b8:	e13ffd15 	stw	r4,-12(fp)
811316bc:	e17ffe15 	stw	r5,-8(fp)
811316c0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
811316c4:	00bffa84 	movi	r2,-22
811316c8:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811316cc:	e0bffd17 	ldw	r2,-12(fp)
811316d0:	10800828 	cmpgeui	r2,r2,32
811316d4:	1000501e 	bne	r2,zero,81131818 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811316d8:	0005303a 	rdctl	r2,status
811316dc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811316e0:	e0fff617 	ldw	r3,-40(fp)
811316e4:	00bfff84 	movi	r2,-2
811316e8:	1884703a 	and	r2,r3,r2
811316ec:	1001703a 	wrctl	status,r2
  
  return context;
811316f0:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
811316f4:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
811316f8:	00a045b4 	movhi	r2,33046
811316fc:	109c8804 	addi	r2,r2,29216
81131700:	e0fffd17 	ldw	r3,-12(fp)
81131704:	180690fa 	slli	r3,r3,3
81131708:	10c5883a 	add	r2,r2,r3
8113170c:	e0ffff17 	ldw	r3,-4(fp)
81131710:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81131714:	00a045b4 	movhi	r2,33046
81131718:	109c8804 	addi	r2,r2,29216
8113171c:	e0fffd17 	ldw	r3,-12(fp)
81131720:	180690fa 	slli	r3,r3,3
81131724:	10c5883a 	add	r2,r2,r3
81131728:	10800104 	addi	r2,r2,4
8113172c:	e0fffe17 	ldw	r3,-8(fp)
81131730:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81131734:	e0bfff17 	ldw	r2,-4(fp)
81131738:	10001926 	beq	r2,zero,811317a0 <alt_irq_register+0xfc>
8113173c:	e0bffd17 	ldw	r2,-12(fp)
81131740:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131744:	0005303a 	rdctl	r2,status
81131748:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113174c:	e0fff717 	ldw	r3,-36(fp)
81131750:	00bfff84 	movi	r2,-2
81131754:	1884703a 	and	r2,r3,r2
81131758:	1001703a 	wrctl	status,r2
  
  return context;
8113175c:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81131760:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81131764:	00c00044 	movi	r3,1
81131768:	e0bff217 	ldw	r2,-56(fp)
8113176c:	1884983a 	sll	r2,r3,r2
81131770:	1007883a 	mov	r3,r2
81131774:	d0a07a17 	ldw	r2,-32280(gp)
81131778:	1884b03a 	or	r2,r3,r2
8113177c:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81131780:	d0a07a17 	ldw	r2,-32280(gp)
81131784:	100170fa 	wrctl	ienable,r2
81131788:	e0bff817 	ldw	r2,-32(fp)
8113178c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131790:	e0bff917 	ldw	r2,-28(fp)
81131794:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81131798:	0005883a 	mov	r2,zero
8113179c:	00001906 	br	81131804 <alt_irq_register+0x160>
811317a0:	e0bffd17 	ldw	r2,-12(fp)
811317a4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811317a8:	0005303a 	rdctl	r2,status
811317ac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811317b0:	e0fffa17 	ldw	r3,-24(fp)
811317b4:	00bfff84 	movi	r2,-2
811317b8:	1884703a 	and	r2,r3,r2
811317bc:	1001703a 	wrctl	status,r2
  
  return context;
811317c0:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811317c4:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
811317c8:	00c00044 	movi	r3,1
811317cc:	e0bff417 	ldw	r2,-48(fp)
811317d0:	1884983a 	sll	r2,r3,r2
811317d4:	0084303a 	nor	r2,zero,r2
811317d8:	1007883a 	mov	r3,r2
811317dc:	d0a07a17 	ldw	r2,-32280(gp)
811317e0:	1884703a 	and	r2,r3,r2
811317e4:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811317e8:	d0a07a17 	ldw	r2,-32280(gp)
811317ec:	100170fa 	wrctl	ienable,r2
811317f0:	e0bffb17 	ldw	r2,-20(fp)
811317f4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811317f8:	e0bffc17 	ldw	r2,-16(fp)
811317fc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81131800:	0005883a 	mov	r2,zero
81131804:	e0bff115 	stw	r2,-60(fp)
81131808:	e0bff317 	ldw	r2,-52(fp)
8113180c:	e0bff515 	stw	r2,-44(fp)
81131810:	e0bff517 	ldw	r2,-44(fp)
81131814:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81131818:	e0bff117 	ldw	r2,-60(fp)
}
8113181c:	e037883a 	mov	sp,fp
81131820:	df000017 	ldw	fp,0(sp)
81131824:	dec00104 	addi	sp,sp,4
81131828:	f800283a 	ret

8113182c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113182c:	defffe04 	addi	sp,sp,-8
81131830:	de00012e 	bgeu	sp,et,81131838 <alt_get_errno+0xc>
81131834:	003b68fa 	trap	3
81131838:	dfc00115 	stw	ra,4(sp)
8113183c:	df000015 	stw	fp,0(sp)
81131840:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131844:	d0a01017 	ldw	r2,-32704(gp)
81131848:	10000326 	beq	r2,zero,81131858 <alt_get_errno+0x2c>
8113184c:	d0a01017 	ldw	r2,-32704(gp)
81131850:	103ee83a 	callr	r2
81131854:	00000106 	br	8113185c <alt_get_errno+0x30>
81131858:	d0a07204 	addi	r2,gp,-32312
}
8113185c:	e037883a 	mov	sp,fp
81131860:	dfc00117 	ldw	ra,4(sp)
81131864:	df000017 	ldw	fp,0(sp)
81131868:	dec00204 	addi	sp,sp,8
8113186c:	f800283a 	ret

81131870 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81131870:	deffed04 	addi	sp,sp,-76
81131874:	de00012e 	bgeu	sp,et,8113187c <isatty+0xc>
81131878:	003b68fa 	trap	3
8113187c:	dfc01215 	stw	ra,72(sp)
81131880:	df001115 	stw	fp,68(sp)
81131884:	df001104 	addi	fp,sp,68
81131888:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113188c:	e0bfff17 	ldw	r2,-4(fp)
81131890:	10000616 	blt	r2,zero,811318ac <isatty+0x3c>
81131894:	e0bfff17 	ldw	r2,-4(fp)
81131898:	10c00324 	muli	r3,r2,12
8113189c:	00a04574 	movhi	r2,33045
811318a0:	10b01104 	addi	r2,r2,-16316
811318a4:	1885883a 	add	r2,r3,r2
811318a8:	00000106 	br	811318b0 <isatty+0x40>
811318ac:	0005883a 	mov	r2,zero
811318b0:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
811318b4:	e0bfef17 	ldw	r2,-68(fp)
811318b8:	10000e26 	beq	r2,zero,811318f4 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
811318bc:	e0bfef17 	ldw	r2,-68(fp)
811318c0:	10800017 	ldw	r2,0(r2)
811318c4:	10800817 	ldw	r2,32(r2)
811318c8:	1000021e 	bne	r2,zero,811318d4 <isatty+0x64>
    {
      return 1;
811318cc:	00800044 	movi	r2,1
811318d0:	00000d06 	br	81131908 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
811318d4:	e0bff004 	addi	r2,fp,-64
811318d8:	100b883a 	mov	r5,r2
811318dc:	e13fff17 	ldw	r4,-4(fp)
811318e0:	11315ec0 	call	811315ec <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
811318e4:	e0bff117 	ldw	r2,-60(fp)
811318e8:	10880020 	cmpeqi	r2,r2,8192
811318ec:	10803fcc 	andi	r2,r2,255
811318f0:	00000506 	br	81131908 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811318f4:	113182c0 	call	8113182c <alt_get_errno>
811318f8:	1007883a 	mov	r3,r2
811318fc:	00801444 	movi	r2,81
81131900:	18800015 	stw	r2,0(r3)
    return 0;
81131904:	0005883a 	mov	r2,zero
  }
}
81131908:	e037883a 	mov	sp,fp
8113190c:	dfc00117 	ldw	ra,4(sp)
81131910:	df000017 	ldw	fp,0(sp)
81131914:	dec00204 	addi	sp,sp,8
81131918:	f800283a 	ret

8113191c <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
8113191c:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81131920:	318c2404 	addi	r6,r6,12432

81131924 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81131924:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
81131928:	01c00826 	beq	zero,r7,8113194c <end_tx>

8113192c <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
8113192c:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81131930:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81131934:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
81131938:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
8113193c:	283ffb26 	beq	r5,zero,8113192c <__reset+0xfb11192c>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81131940:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81131944:	21000044 	addi	r4,r4,1
	br tx_next_char
81131948:	003ff606 	br	81131924 <__reset+0xfb111924>

8113194c <end_tx>:
end_tx:	
        ret
8113194c:	f800283a 	ret

81131950 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81131950:	defffd04 	addi	sp,sp,-12
81131954:	de00012e 	bgeu	sp,et,8113195c <alt_log_txchar+0xc>
81131958:	003b68fa 	trap	3
8113195c:	df000215 	stw	fp,8(sp)
81131960:	df000204 	addi	fp,sp,8
81131964:	e13ffe15 	stw	r4,-8(fp)
81131968:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
8113196c:	0001883a 	nop
81131970:	e0bfff17 	ldw	r2,-4(fp)
81131974:	10800104 	addi	r2,r2,4
81131978:	10800037 	ldwio	r2,0(r2)
8113197c:	10bfffec 	andhi	r2,r2,65535
81131980:	103ffb26 	beq	r2,zero,81131970 <__reset+0xfb111970>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81131984:	e0bfff17 	ldw	r2,-4(fp)
81131988:	e0fffe17 	ldw	r3,-8(fp)
8113198c:	10c00035 	stwio	r3,0(r2)
}
81131990:	0001883a 	nop
81131994:	e037883a 	mov	sp,fp
81131998:	df000017 	ldw	fp,0(sp)
8113199c:	dec00104 	addi	sp,sp,4
811319a0:	f800283a 	ret

811319a4 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
811319a4:	defffb04 	addi	sp,sp,-20
811319a8:	de00012e 	bgeu	sp,et,811319b0 <alt_log_repchar+0xc>
811319ac:	003b68fa 	trap	3
811319b0:	dfc00415 	stw	ra,16(sp)
811319b4:	df000315 	stw	fp,12(sp)
811319b8:	df000304 	addi	fp,sp,12
811319bc:	2005883a 	mov	r2,r4
811319c0:	e17ffe15 	stw	r5,-8(fp)
811319c4:	e1bfff15 	stw	r6,-4(fp)
811319c8:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
811319cc:	00000506 	br	811319e4 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
811319d0:	e0bffd07 	ldb	r2,-12(fp)
811319d4:	e0ffff17 	ldw	r3,-4(fp)
811319d8:	180b883a 	mov	r5,r3
811319dc:	1009883a 	mov	r4,r2
811319e0:	11319500 	call	81131950 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
811319e4:	e0bffe17 	ldw	r2,-8(fp)
811319e8:	10ffffc4 	addi	r3,r2,-1
811319ec:	e0fffe15 	stw	r3,-8(fp)
811319f0:	00bff716 	blt	zero,r2,811319d0 <__reset+0xfb1119d0>
    alt_log_txchar(c,(char*) base);
}
811319f4:	0001883a 	nop
811319f8:	e037883a 	mov	sp,fp
811319fc:	dfc00117 	ldw	ra,4(sp)
81131a00:	df000017 	ldw	fp,0(sp)
81131a04:	dec00204 	addi	sp,sp,8
81131a08:	f800283a 	ret

81131a0c <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81131a0c:	deffe904 	addi	sp,sp,-92
81131a10:	de00012e 	bgeu	sp,et,81131a18 <alt_log_private_printf+0xc>
81131a14:	003b68fa 	trap	3
81131a18:	dfc01615 	stw	ra,88(sp)
81131a1c:	df001515 	stw	fp,84(sp)
81131a20:	dc001415 	stw	r16,80(sp)
81131a24:	df001504 	addi	fp,sp,84
81131a28:	e13ffc15 	stw	r4,-16(fp)
81131a2c:	e17ffd15 	stw	r5,-12(fp)
81131a30:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81131a34:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
81131a38:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81131a3c:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81131a40:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81131a44:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
81131a48:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81131a4c:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81131a50:	e0bffc17 	ldw	r2,-16(fp)
81131a54:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
81131a58:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81131a5c:	00014b06 	br	81131f8c <alt_log_private_printf+0x580>
    {
    switch(state)
81131a60:	e0bfec17 	ldw	r2,-80(fp)
81131a64:	10c00060 	cmpeqi	r3,r2,1
81131a68:	18001b1e 	bne	r3,zero,81131ad8 <alt_log_private_printf+0xcc>
81131a6c:	10c000a0 	cmpeqi	r3,r2,2
81131a70:	18002d1e 	bne	r3,zero,81131b28 <alt_log_private_printf+0x11c>
81131a74:	10000126 	beq	r2,zero,81131a7c <alt_log_private_printf+0x70>
81131a78:	00014406 	br	81131f8c <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81131a7c:	e0bffb07 	ldb	r2,-20(fp)
81131a80:	10800958 	cmpnei	r2,r2,37
81131a84:	10000e1e 	bne	r2,zero,81131ac0 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81131a88:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81131a8c:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81131a90:	00800284 	movi	r2,10
81131a94:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81131a98:	00800044 	movi	r2,1
81131a9c:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81131aa0:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81131aa4:	00bfffc4 	movi	r2,-1
81131aa8:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81131aac:	00bfffc4 	movi	r2,-1
81131ab0:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81131ab4:	00800044 	movi	r2,1
81131ab8:	e0bfec15 	stw	r2,-80(fp)
81131abc:	00013306 	br	81131f8c <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81131ac0:	e0bffb07 	ldb	r2,-20(fp)
81131ac4:	e0fffd17 	ldw	r3,-12(fp)
81131ac8:	180b883a 	mov	r5,r3
81131acc:	1009883a 	mov	r4,r2
81131ad0:	11319500 	call	81131950 <alt_log_txchar>
        }
        break;
81131ad4:	00012d06 	br	81131f8c <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81131ad8:	e0bffb07 	ldb	r2,-20(fp)
81131adc:	10800c18 	cmpnei	r2,r2,48
81131ae0:	1000051e 	bne	r2,zero,81131af8 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81131ae4:	00800044 	movi	r2,1
81131ae8:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81131aec:	00800084 	movi	r2,2
81131af0:	e0bfec15 	stw	r2,-80(fp)
81131af4:	00012506 	br	81131f8c <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81131af8:	e0bffb07 	ldb	r2,-20(fp)
81131afc:	10800958 	cmpnei	r2,r2,37
81131b00:	1000071e 	bne	r2,zero,81131b20 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81131b04:	e0bffb07 	ldb	r2,-20(fp)
81131b08:	e0fffd17 	ldw	r3,-12(fp)
81131b0c:	180b883a 	mov	r5,r3
81131b10:	1009883a 	mov	r4,r2
81131b14:	11319500 	call	81131950 <alt_log_txchar>
          state = pfState_chars;
81131b18:	e03fec15 	stw	zero,-80(fp)
81131b1c:	00011b06 	br	81131f8c <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81131b20:	00800084 	movi	r2,2
81131b24:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81131b28:	e0bffb07 	ldb	r2,-20(fp)
81131b2c:	10800b98 	cmpnei	r2,r2,46
81131b30:	1000021e 	bne	r2,zero,81131b3c <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81131b34:	e03ff015 	stw	zero,-64(fp)
81131b38:	00011306 	br	81131f88 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81131b3c:	e0bffb07 	ldb	r2,-20(fp)
81131b40:	10800c10 	cmplti	r2,r2,48
81131b44:	10001a1e 	bne	r2,zero,81131bb0 <alt_log_private_printf+0x1a4>
81131b48:	e0bffb07 	ldb	r2,-20(fp)
81131b4c:	10800e88 	cmpgei	r2,r2,58
81131b50:	1000171e 	bne	r2,zero,81131bb0 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81131b54:	e0bffb03 	ldbu	r2,-20(fp)
81131b58:	10bff404 	addi	r2,r2,-48
81131b5c:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81131b60:	e0bff017 	ldw	r2,-64(fp)
81131b64:	10000c0e 	bge	r2,zero,81131b98 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81131b68:	e0bfef17 	ldw	r2,-68(fp)
81131b6c:	1000020e 	bge	r2,zero,81131b78 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81131b70:	e03fef15 	stw	zero,-68(fp)
81131b74:	00000306 	br	81131b84 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81131b78:	e0bfef17 	ldw	r2,-68(fp)
81131b7c:	108002a4 	muli	r2,r2,10
81131b80:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81131b84:	e0bffb07 	ldb	r2,-20(fp)
81131b88:	e0ffef17 	ldw	r3,-68(fp)
81131b8c:	1885883a 	add	r2,r3,r2
81131b90:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81131b94:	0000fc06 	br	81131f88 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81131b98:	e0bff017 	ldw	r2,-64(fp)
81131b9c:	10c002a4 	muli	r3,r2,10
81131ba0:	e0bffb07 	ldb	r2,-20(fp)
81131ba4:	1885883a 	add	r2,r3,r2
81131ba8:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81131bac:	0000f606 	br	81131f88 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81131bb0:	e0bffb07 	ldb	r2,-20(fp)
81131bb4:	10801b18 	cmpnei	r2,r2,108
81131bb8:	1000031e 	bne	r2,zero,81131bc8 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81131bbc:	00800044 	movi	r2,1
81131bc0:	e0bfee15 	stw	r2,-72(fp)
81131bc4:	0000f006 	br	81131f88 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81131bc8:	e0bffb07 	ldb	r2,-20(fp)
81131bcc:	10bfea04 	addi	r2,r2,-88
81131bd0:	10c00868 	cmpgeui	r3,r2,33
81131bd4:	1800eb1e 	bne	r3,zero,81131f84 <alt_log_private_printf+0x578>
81131bd8:	100690ba 	slli	r3,r2,2
81131bdc:	00a044f4 	movhi	r2,33043
81131be0:	1086fc04 	addi	r2,r2,7152
81131be4:	1885883a 	add	r2,r3,r2
81131be8:	10800017 	ldw	r2,0(r2)
81131bec:	1000683a 	jmp	r2
81131bf0:	81131eb0 	cmpltui	r4,r16,19578
81131bf4:	81131f84 	addi	r4,r16,19582
81131bf8:	81131f84 	addi	r4,r16,19582
81131bfc:	81131f84 	addi	r4,r16,19582
81131c00:	81131f84 	addi	r4,r16,19582
81131c04:	81131f84 	addi	r4,r16,19582
81131c08:	81131f84 	addi	r4,r16,19582
81131c0c:	81131f84 	addi	r4,r16,19582
81131c10:	81131f84 	addi	r4,r16,19582
81131c14:	81131f84 	addi	r4,r16,19582
81131c18:	81131f84 	addi	r4,r16,19582
81131c1c:	81131ec8 	cmpgei	r4,r16,19579
81131c20:	81131c74 	orhi	r4,r16,19569
81131c24:	81131f84 	addi	r4,r16,19582
81131c28:	81131f84 	addi	r4,r16,19582
81131c2c:	81131f84 	addi	r4,r16,19582
81131c30:	81131f84 	addi	r4,r16,19582
81131c34:	81131c74 	orhi	r4,r16,19569
81131c38:	81131f84 	addi	r4,r16,19582
81131c3c:	81131f84 	addi	r4,r16,19582
81131c40:	81131f84 	addi	r4,r16,19582
81131c44:	81131f84 	addi	r4,r16,19582
81131c48:	81131f84 	addi	r4,r16,19582
81131c4c:	81131e90 	cmplti	r4,r16,19578
81131c50:	81131f84 	addi	r4,r16,19582
81131c54:	81131f84 	addi	r4,r16,19582
81131c58:	81131f84 	addi	r4,r16,19582
81131c5c:	81131f04 	addi	r4,r16,19580
81131c60:	81131f84 	addi	r4,r16,19582
81131c64:	81131e88 	cmpgei	r4,r16,19578
81131c68:	81131f84 	addi	r4,r16,19582
81131c6c:	81131f84 	addi	r4,r16,19582
81131c70:	81131ea0 	cmpeqi	r4,r16,19578
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81131c74:	e0bfee17 	ldw	r2,-72(fp)
81131c78:	10000e26 	beq	r2,zero,81131cb4 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81131c7c:	e0bff217 	ldw	r2,-56(fp)
81131c80:	10000626 	beq	r2,zero,81131c9c <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81131c84:	e0bffe17 	ldw	r2,-8(fp)
81131c88:	10c00104 	addi	r3,r2,4
81131c8c:	e0fffe15 	stw	r3,-8(fp)
81131c90:	10800017 	ldw	r2,0(r2)
81131c94:	e0bff415 	stw	r2,-48(fp)
81131c98:	00001306 	br	81131ce8 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81131c9c:	e0bffe17 	ldw	r2,-8(fp)
81131ca0:	10c00104 	addi	r3,r2,4
81131ca4:	e0fffe15 	stw	r3,-8(fp)
81131ca8:	10800017 	ldw	r2,0(r2)
81131cac:	e0bff415 	stw	r2,-48(fp)
81131cb0:	00000d06 	br	81131ce8 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81131cb4:	e0bff217 	ldw	r2,-56(fp)
81131cb8:	10000626 	beq	r2,zero,81131cd4 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81131cbc:	e0bffe17 	ldw	r2,-8(fp)
81131cc0:	10c00104 	addi	r3,r2,4
81131cc4:	e0fffe15 	stw	r3,-8(fp)
81131cc8:	10800017 	ldw	r2,0(r2)
81131ccc:	e0bff415 	stw	r2,-48(fp)
81131cd0:	00000506 	br	81131ce8 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81131cd4:	e0bffe17 	ldw	r2,-8(fp)
81131cd8:	10c00104 	addi	r3,r2,4
81131cdc:	e0fffe15 	stw	r3,-8(fp)
81131ce0:	10800017 	ldw	r2,0(r2)
81131ce4:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81131ce8:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81131cec:	e0bff217 	ldw	r2,-56(fp)
81131cf0:	10000726 	beq	r2,zero,81131d10 <alt_log_private_printf+0x304>
81131cf4:	e0bff417 	ldw	r2,-48(fp)
81131cf8:	1000050e 	bge	r2,zero,81131d10 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81131cfc:	e0bff417 	ldw	r2,-48(fp)
81131d00:	0085c83a 	sub	r2,zero,r2
81131d04:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81131d08:	00800044 	movi	r2,1
81131d0c:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81131d10:	e0bff417 	ldw	r2,-48(fp)
81131d14:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81131d18:	00800044 	movi	r2,1
81131d1c:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81131d20:	00800044 	movi	r2,1
81131d24:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81131d28:	00000706 	br	81131d48 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81131d2c:	e0bff817 	ldw	r2,-32(fp)
81131d30:	10800044 	addi	r2,r2,1
81131d34:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81131d38:	e0bff117 	ldw	r2,-60(fp)
81131d3c:	e0fff517 	ldw	r3,-44(fp)
81131d40:	1885383a 	mul	r2,r3,r2
81131d44:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81131d48:	e0bff117 	ldw	r2,-60(fp)
81131d4c:	e0fff617 	ldw	r3,-40(fp)
81131d50:	1885203a 	divu	r2,r3,r2
81131d54:	e0bff615 	stw	r2,-40(fp)
81131d58:	e0bff617 	ldw	r2,-40(fp)
81131d5c:	103ff31e 	bne	r2,zero,81131d2c <__reset+0xfb111d2c>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81131d60:	e0ffef17 	ldw	r3,-68(fp)
81131d64:	e0bff817 	ldw	r2,-32(fp)
81131d68:	1885c83a 	sub	r2,r3,r2
81131d6c:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81131d70:	e0bfed17 	ldw	r2,-76(fp)
81131d74:	10000e26 	beq	r2,zero,81131db0 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81131d78:	e0bff717 	ldw	r2,-36(fp)
81131d7c:	10000726 	beq	r2,zero,81131d9c <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81131d80:	e0bffd17 	ldw	r2,-12(fp)
81131d84:	100b883a 	mov	r5,r2
81131d88:	01000b44 	movi	r4,45
81131d8c:	11319500 	call	81131950 <alt_log_txchar>
                    fmtBeforeDecimal--;
81131d90:	e0bfef17 	ldw	r2,-68(fp)
81131d94:	10bfffc4 	addi	r2,r2,-1
81131d98:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81131d9c:	e1bffd17 	ldw	r6,-12(fp)
81131da0:	e17fef17 	ldw	r5,-68(fp)
81131da4:	01000c04 	movi	r4,48
81131da8:	11319a40 	call	811319a4 <alt_log_repchar>
81131dac:	00003206 	br	81131e78 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81131db0:	e0bff717 	ldw	r2,-36(fp)
81131db4:	10000326 	beq	r2,zero,81131dc4 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81131db8:	e0bfef17 	ldw	r2,-68(fp)
81131dbc:	10bfffc4 	addi	r2,r2,-1
81131dc0:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81131dc4:	e1bffd17 	ldw	r6,-12(fp)
81131dc8:	e17fef17 	ldw	r5,-68(fp)
81131dcc:	01000804 	movi	r4,32
81131dd0:	11319a40 	call	811319a4 <alt_log_repchar>
                    if(sign)
81131dd4:	e0bff717 	ldw	r2,-36(fp)
81131dd8:	10002726 	beq	r2,zero,81131e78 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81131ddc:	e0bffd17 	ldw	r2,-12(fp)
81131de0:	100b883a 	mov	r5,r2
81131de4:	01000b44 	movi	r4,45
81131de8:	11319500 	call	81131950 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81131dec:	00002206 	br	81131e78 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81131df0:	e0fff417 	ldw	r3,-48(fp)
81131df4:	e0bff517 	ldw	r2,-44(fp)
81131df8:	1885203a 	divu	r2,r3,r2
81131dfc:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81131e00:	e0bff903 	ldbu	r2,-28(fp)
81131e04:	10800c04 	addi	r2,r2,48
81131e08:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81131e0c:	e0bff903 	ldbu	r2,-28(fp)
81131e10:	10800eb0 	cmpltui	r2,r2,58
81131e14:	1000081e 	bne	r2,zero,81131e38 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81131e18:	e0bff317 	ldw	r2,-52(fp)
81131e1c:	10000226 	beq	r2,zero,81131e28 <alt_log_private_printf+0x41c>
81131e20:	008001c4 	movi	r2,7
81131e24:	00000106 	br	81131e2c <alt_log_private_printf+0x420>
81131e28:	008009c4 	movi	r2,39
81131e2c:	e0fff903 	ldbu	r3,-28(fp)
81131e30:	10c5883a 	add	r2,r2,r3
81131e34:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81131e38:	e0bff903 	ldbu	r2,-28(fp)
81131e3c:	e0fffd17 	ldw	r3,-12(fp)
81131e40:	180b883a 	mov	r5,r3
81131e44:	1009883a 	mov	r4,r2
81131e48:	11319500 	call	81131950 <alt_log_txchar>

                  v = v % p;
81131e4c:	e0bff417 	ldw	r2,-48(fp)
81131e50:	e0fff517 	ldw	r3,-44(fp)
81131e54:	10c9203a 	divu	r4,r2,r3
81131e58:	e0fff517 	ldw	r3,-44(fp)
81131e5c:	20c7383a 	mul	r3,r4,r3
81131e60:	10c5c83a 	sub	r2,r2,r3
81131e64:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81131e68:	e0bff117 	ldw	r2,-60(fp)
81131e6c:	e0fff517 	ldw	r3,-44(fp)
81131e70:	1885203a 	divu	r2,r3,r2
81131e74:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81131e78:	e0bff517 	ldw	r2,-44(fp)
81131e7c:	103fdc1e 	bne	r2,zero,81131df0 <__reset+0xfb111df0>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81131e80:	e03fec15 	stw	zero,-80(fp)
              break;
81131e84:	00003f06 	br	81131f84 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81131e88:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81131e8c:	003f7906 	br	81131c74 <__reset+0xfb111c74>
            case 'o':
              fmtSigned = 0;
81131e90:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81131e94:	00800204 	movi	r2,8
81131e98:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81131e9c:	003f7506 	br	81131c74 <__reset+0xfb111c74>
            case 'x':
              fmtSigned = 0;
81131ea0:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81131ea4:	00800404 	movi	r2,16
81131ea8:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81131eac:	003f7106 	br	81131c74 <__reset+0xfb111c74>
            case 'X':
              fmtSigned = 0;
81131eb0:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81131eb4:	00800404 	movi	r2,16
81131eb8:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81131ebc:	00800044 	movi	r2,1
81131ec0:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81131ec4:	003f6b06 	br	81131c74 <__reset+0xfb111c74>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81131ec8:	e0bfef17 	ldw	r2,-68(fp)
81131ecc:	10bfffc4 	addi	r2,r2,-1
81131ed0:	e1bffd17 	ldw	r6,-12(fp)
81131ed4:	100b883a 	mov	r5,r2
81131ed8:	01000804 	movi	r4,32
81131edc:	11319a40 	call	811319a4 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81131ee0:	e0bffe17 	ldw	r2,-8(fp)
81131ee4:	10c00104 	addi	r3,r2,4
81131ee8:	e0fffe15 	stw	r3,-8(fp)
81131eec:	10800017 	ldw	r2,0(r2)
81131ef0:	e0fffd17 	ldw	r3,-12(fp)
81131ef4:	180b883a 	mov	r5,r3
81131ef8:	1009883a 	mov	r4,r2
81131efc:	11319500 	call	81131950 <alt_log_txchar>
              break;
81131f00:	00002006 	br	81131f84 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81131f04:	e0bffe17 	ldw	r2,-8(fp)
81131f08:	10c00104 	addi	r3,r2,4
81131f0c:	e0fffe15 	stw	r3,-8(fp)
81131f10:	10800017 	ldw	r2,0(r2)
81131f14:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81131f18:	e43fef17 	ldw	r16,-68(fp)
81131f1c:	e13ffa17 	ldw	r4,-24(fp)
81131f20:	111d6400 	call	8111d640 <strlen>
81131f24:	8085c83a 	sub	r2,r16,r2
81131f28:	e1bffd17 	ldw	r6,-12(fp)
81131f2c:	100b883a 	mov	r5,r2
81131f30:	01000804 	movi	r4,32
81131f34:	11319a40 	call	811319a4 <alt_log_repchar>

                while(*s)
81131f38:	00000b06 	br	81131f68 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81131f3c:	e0bffa17 	ldw	r2,-24(fp)
81131f40:	10c00044 	addi	r3,r2,1
81131f44:	e0fffa15 	stw	r3,-24(fp)
81131f48:	10800003 	ldbu	r2,0(r2)
81131f4c:	10803fcc 	andi	r2,r2,255
81131f50:	1080201c 	xori	r2,r2,128
81131f54:	10bfe004 	addi	r2,r2,-128
81131f58:	e0fffd17 	ldw	r3,-12(fp)
81131f5c:	180b883a 	mov	r5,r3
81131f60:	1009883a 	mov	r4,r2
81131f64:	11319500 	call	81131950 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81131f68:	e0bffa17 	ldw	r2,-24(fp)
81131f6c:	10800003 	ldbu	r2,0(r2)
81131f70:	10803fcc 	andi	r2,r2,255
81131f74:	1080201c 	xori	r2,r2,128
81131f78:	10bfe004 	addi	r2,r2,-128
81131f7c:	103fef1e 	bne	r2,zero,81131f3c <__reset+0xfb111f3c>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81131f80:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81131f84:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81131f88:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81131f8c:	e0bfeb17 	ldw	r2,-84(fp)
81131f90:	10c00044 	addi	r3,r2,1
81131f94:	e0ffeb15 	stw	r3,-84(fp)
81131f98:	10800003 	ldbu	r2,0(r2)
81131f9c:	e0bffb05 	stb	r2,-20(fp)
81131fa0:	e0bffb07 	ldb	r2,-20(fp)
81131fa4:	103eae1e 	bne	r2,zero,81131a60 <__reset+0xfb111a60>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81131fa8:	0001883a 	nop
81131fac:	e6ffff04 	addi	sp,fp,-4
81131fb0:	dfc00217 	ldw	ra,8(sp)
81131fb4:	df000117 	ldw	fp,4(sp)
81131fb8:	dc000017 	ldw	r16,0(sp)
81131fbc:	dec00304 	addi	sp,sp,12
81131fc0:	f800283a 	ret

81131fc4 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81131fc4:	defff904 	addi	sp,sp,-28
81131fc8:	de00012e 	bgeu	sp,et,81131fd0 <alt_log_printf_proc+0xc>
81131fcc:	003b68fa 	trap	3
81131fd0:	dfc00315 	stw	ra,12(sp)
81131fd4:	df000215 	stw	fp,8(sp)
81131fd8:	df000204 	addi	fp,sp,8
81131fdc:	e13fff15 	stw	r4,-4(fp)
81131fe0:	e1400215 	stw	r5,8(fp)
81131fe4:	e1800315 	stw	r6,12(fp)
81131fe8:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81131fec:	e0800204 	addi	r2,fp,8
81131ff0:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81131ff4:	e0bffe17 	ldw	r2,-8(fp)
81131ff8:	100d883a 	mov	r6,r2
81131ffc:	01604834 	movhi	r5,33056
81132000:	294c2404 	addi	r5,r5,12432
81132004:	e13fff17 	ldw	r4,-4(fp)
81132008:	1131a0c0 	call	81131a0c <alt_log_private_printf>
    return (0);
8113200c:	0005883a 	mov	r2,zero
}
81132010:	e037883a 	mov	sp,fp
81132014:	dfc00117 	ldw	ra,4(sp)
81132018:	df000017 	ldw	fp,0(sp)
8113201c:	dec00504 	addi	sp,sp,20
81132020:	f800283a 	ret

81132024 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81132024:	defff904 	addi	sp,sp,-28
81132028:	de00012e 	bgeu	sp,et,81132030 <altera_avalon_jtag_uart_report_log+0xc>
8113202c:	003b68fa 	trap	3
81132030:	dfc00615 	stw	ra,24(sp)
81132034:	df000515 	stw	fp,20(sp)
81132038:	dc400415 	stw	r17,16(sp)
8113203c:	dc000315 	stw	r16,12(sp)
81132040:	df000504 	addi	fp,sp,20
81132044:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81132048:	d0a07b83 	ldbu	r2,-32274(gp)
8113204c:	10803fcc 	andi	r2,r2,255
81132050:	10001426 	beq	r2,zero,811320a4 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81132054:	e0bffd17 	ldw	r2,-12(fp)
81132058:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
8113205c:	00a04574 	movhi	r2,33045
81132060:	10ac3704 	addi	r2,r2,-20260
81132064:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81132068:	e0bffb17 	ldw	r2,-20(fp)
8113206c:	10800017 	ldw	r2,0(r2)
81132070:	e1bffc17 	ldw	r6,-16(fp)
81132074:	100b883a 	mov	r5,r2
81132078:	e13ffb17 	ldw	r4,-20(fp)
8113207c:	11320c40 	call	811320c4 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81132080:	d0e08217 	ldw	r3,-32248(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81132084:	00b33374 	movhi	r2,52429
81132088:	10b33344 	addi	r2,r2,-13107
8113208c:	1888383a 	mulxuu	r4,r3,r2
81132090:	1885383a 	mul	r2,r3,r2
81132094:	1021883a 	mov	r16,r2
81132098:	2023883a 	mov	r17,r4
8113209c:	8804d0fa 	srli	r2,r17,3
811320a0:	00000106 	br	811320a8 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
811320a4:	0005883a 	mov	r2,zero
    }
}
811320a8:	e6fffe04 	addi	sp,fp,-8
811320ac:	dfc00317 	ldw	ra,12(sp)
811320b0:	df000217 	ldw	fp,8(sp)
811320b4:	dc400117 	ldw	r17,4(sp)
811320b8:	dc000017 	ldw	r16,0(sp)
811320bc:	dec00404 	addi	sp,sp,16
811320c0:	f800283a 	ret

811320c4 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
811320c4:	deffef04 	addi	sp,sp,-68
811320c8:	de00012e 	bgeu	sp,et,811320d0 <alt_log_jtag_uart_print_control_reg+0xc>
811320cc:	003b68fa 	trap	3
811320d0:	dfc01015 	stw	ra,64(sp)
811320d4:	df000f15 	stw	fp,60(sp)
811320d8:	df000f04 	addi	fp,sp,60
811320dc:	e13ffd15 	stw	r4,-12(fp)
811320e0:	e17ffe15 	stw	r5,-8(fp)
811320e4:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811320e8:	e0bffe17 	ldw	r2,-8(fp)
811320ec:	10800104 	addi	r2,r2,4
811320f0:	10800037 	ldwio	r2,0(r2)
811320f4:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
811320f8:	e0bff617 	ldw	r2,-40(fp)
811320fc:	1004d43a 	srli	r2,r2,16
81132100:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81132104:	e0bff617 	ldw	r2,-40(fp)
81132108:	1080008c 	andi	r2,r2,2
8113210c:	1004d07a 	srli	r2,r2,1
81132110:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81132114:	e0bff617 	ldw	r2,-40(fp)
81132118:	1080004c 	andi	r2,r2,1
8113211c:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81132120:	e0bff617 	ldw	r2,-40(fp)
81132124:	1080400c 	andi	r2,r2,256
81132128:	1004d23a 	srli	r2,r2,8
8113212c:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81132130:	e0bff617 	ldw	r2,-40(fp)
81132134:	1080800c 	andi	r2,r2,512
81132138:	1004d27a 	srli	r2,r2,9
8113213c:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81132140:	e0bff617 	ldw	r2,-40(fp)
81132144:	1081000c 	andi	r2,r2,1024
81132148:	1004d2ba 	srli	r2,r2,10
8113214c:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81132150:	e0bffd17 	ldw	r2,-12(fp)
81132154:	10c01017 	ldw	r3,64(r2)
81132158:	e0bffd17 	ldw	r2,-12(fp)
8113215c:	10800f17 	ldw	r2,60(r2)
81132160:	1887c83a 	sub	r3,r3,r2
81132164:	e0bff917 	ldw	r2,-28(fp)
81132168:	d8800415 	stw	r2,16(sp)
8113216c:	e0bff817 	ldw	r2,-32(fp)
81132170:	d8800315 	stw	r2,12(sp)
81132174:	e0bffa17 	ldw	r2,-24(fp)
81132178:	d8800215 	stw	r2,8(sp)
8113217c:	e0bffb17 	ldw	r2,-20(fp)
81132180:	d8800115 	stw	r2,4(sp)
81132184:	e0bffc17 	ldw	r2,-16(fp)
81132188:	d8800015 	stw	r2,0(sp)
8113218c:	e1fff717 	ldw	r7,-36(fp)
81132190:	180d883a 	mov	r6,r3
81132194:	e17fff17 	ldw	r5,-4(fp)
81132198:	01204574 	movhi	r4,33045
8113219c:	212c3a04 	addi	r4,r4,-20248
811321a0:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
811321a4:	0001883a 	nop

}
811321a8:	e037883a 	mov	sp,fp
811321ac:	dfc00117 	ldw	ra,4(sp)
811321b0:	df000017 	ldw	fp,0(sp)
811321b4:	dec00204 	addi	sp,sp,8
811321b8:	f800283a 	ret

811321bc <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
811321bc:	defffb04 	addi	sp,sp,-20
811321c0:	de00012e 	bgeu	sp,et,811321c8 <alt_log_jtag_uart_startup_info+0xc>
811321c4:	003b68fa 	trap	3
811321c8:	dfc00415 	stw	ra,16(sp)
811321cc:	df000315 	stw	fp,12(sp)
811321d0:	df000304 	addi	fp,sp,12
811321d4:	e13ffe15 	stw	r4,-8(fp)
811321d8:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
811321dc:	00a04574 	movhi	r2,33045
811321e0:	10ac4c04 	addi	r2,r2,-20176
811321e4:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
811321e8:	e1bffd17 	ldw	r6,-12(fp)
811321ec:	e17fff17 	ldw	r5,-4(fp)
811321f0:	e13ffe17 	ldw	r4,-8(fp)
811321f4:	11320c40 	call	811320c4 <alt_log_jtag_uart_print_control_reg>
     return;
811321f8:	0001883a 	nop
}
811321fc:	e037883a 	mov	sp,fp
81132200:	dfc00117 	ldw	ra,4(sp)
81132204:	df000017 	ldw	fp,0(sp)
81132208:	dec00204 	addi	sp,sp,8
8113220c:	f800283a 	ret

81132210 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
81132210:	defffb04 	addi	sp,sp,-20
81132214:	de00012e 	bgeu	sp,et,8113221c <alt_log_jtag_uart_isr_proc+0xc>
81132218:	003b68fa 	trap	3
8113221c:	dfc00415 	stw	ra,16(sp)
81132220:	df000315 	stw	fp,12(sp)
81132224:	df000304 	addi	fp,sp,12
81132228:	e13ffe15 	stw	r4,-8(fp)
8113222c:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
81132230:	d0a07bc3 	ldbu	r2,-32273(gp)
81132234:	10803fcc 	andi	r2,r2,255
81132238:	10000826 	beq	r2,zero,8113225c <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
8113223c:	00a04574 	movhi	r2,33045
81132240:	10ac5104 	addi	r2,r2,-20156
81132244:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
81132248:	e1bffd17 	ldw	r6,-12(fp)
8113224c:	e17ffe17 	ldw	r5,-8(fp)
81132250:	e13fff17 	ldw	r4,-4(fp)
81132254:	11320c40 	call	811320c4 <alt_log_jtag_uart_print_control_reg>
    }
    return;
81132258:	0001883a 	nop
8113225c:	0001883a 	nop
}
81132260:	e037883a 	mov	sp,fp
81132264:	dfc00117 	ldw	ra,4(sp)
81132268:	df000017 	ldw	fp,0(sp)
8113226c:	dec00204 	addi	sp,sp,8
81132270:	f800283a 	ret

81132274 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81132274:	defffa04 	addi	sp,sp,-24
81132278:	de00012e 	bgeu	sp,et,81132280 <alt_log_write+0xc>
8113227c:	003b68fa 	trap	3
81132280:	dfc00515 	stw	ra,20(sp)
81132284:	df000415 	stw	fp,16(sp)
81132288:	df000404 	addi	fp,sp,16
8113228c:	e13ffe15 	stw	r4,-8(fp)
81132290:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81132294:	d0a07b03 	ldbu	r2,-32276(gp)
81132298:	10803fcc 	andi	r2,r2,255
8113229c:	10004026 	beq	r2,zero,811323a0 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
811322a0:	e0bfff17 	ldw	r2,-4(fp)
811322a4:	10c00430 	cmpltui	r3,r2,16
811322a8:	1800011e 	bne	r3,zero,811322b0 <alt_log_write+0x3c>
811322ac:	008003c4 	movi	r2,15
811322b0:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
811322b4:	e0bffd17 	ldw	r2,-12(fp)
811322b8:	10800088 	cmpgei	r2,r2,2
811322bc:	10003726 	beq	r2,zero,8113239c <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
811322c0:	e0bffd17 	ldw	r2,-12(fp)
811322c4:	100d883a 	mov	r6,r2
811322c8:	e17ffe17 	ldw	r5,-8(fp)
811322cc:	012045b4 	movhi	r4,33046
811322d0:	21035a04 	addi	r4,r4,3432
811322d4:	114608c0 	call	8114608c <strncpy>
    alt_log_write_buf[length-1]='\n';
811322d8:	e0bffd17 	ldw	r2,-12(fp)
811322dc:	10ffffc4 	addi	r3,r2,-1
811322e0:	00a045b4 	movhi	r2,33046
811322e4:	10835a04 	addi	r2,r2,3432
811322e8:	10c5883a 	add	r2,r2,r3
811322ec:	00c00284 	movi	r3,10
811322f0:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
811322f4:	00a045b4 	movhi	r2,33046
811322f8:	10835a04 	addi	r2,r2,3432
811322fc:	e0fffd17 	ldw	r3,-12(fp)
81132300:	10c5883a 	add	r2,r2,r3
81132304:	00c00344 	movi	r3,13
81132308:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
8113230c:	e0bffd17 	ldw	r2,-12(fp)
81132310:	10c00044 	addi	r3,r2,1
81132314:	00a045b4 	movhi	r2,33046
81132318:	10835a04 	addi	r2,r2,3432
8113231c:	10c5883a 	add	r2,r2,r3
81132320:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81132324:	e03ffc15 	stw	zero,-16(fp)
81132328:	00001306 	br	81132378 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
8113232c:	00a045b4 	movhi	r2,33046
81132330:	10835a04 	addi	r2,r2,3432
81132334:	e0fffc17 	ldw	r3,-16(fp)
81132338:	10c5883a 	add	r2,r2,r3
8113233c:	10800003 	ldbu	r2,0(r2)
81132340:	10803fcc 	andi	r2,r2,255
81132344:	1080201c 	xori	r2,r2,128
81132348:	10bfe004 	addi	r2,r2,-128
8113234c:	10800118 	cmpnei	r2,r2,4
81132350:	1000061e 	bne	r2,zero,8113236c <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81132354:	00a045b4 	movhi	r2,33046
81132358:	10835a04 	addi	r2,r2,3432
8113235c:	e0fffc17 	ldw	r3,-16(fp)
81132360:	10c5883a 	add	r2,r2,r3
81132364:	00c01104 	movi	r3,68
81132368:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8113236c:	e0bffc17 	ldw	r2,-16(fp)
81132370:	10800044 	addi	r2,r2,1
81132374:	e0bffc15 	stw	r2,-16(fp)
81132378:	e0fffc17 	ldw	r3,-16(fp)
8113237c:	e0bffd17 	ldw	r2,-12(fp)
81132380:	18bfea16 	blt	r3,r2,8113232c <__reset+0xfb11232c>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81132384:	016045b4 	movhi	r5,33046
81132388:	29435a04 	addi	r5,r5,3432
8113238c:	01204574 	movhi	r4,33045
81132390:	212c5404 	addi	r4,r4,-20144
81132394:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
81132398:	00000106 	br	811323a0 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
8113239c:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
811323a0:	e037883a 	mov	sp,fp
811323a4:	dfc00117 	ldw	ra,4(sp)
811323a8:	df000017 	ldw	fp,0(sp)
811323ac:	dec00204 	addi	sp,sp,8
811323b0:	f800283a 	ret

811323b4 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
811323b4:	defffe04 	addi	sp,sp,-8
811323b8:	de00012e 	bgeu	sp,et,811323c0 <alt_log_system_clock+0xc>
811323bc:	003b68fa 	trap	3
811323c0:	dfc00115 	stw	ra,4(sp)
811323c4:	df000015 	stw	fp,0(sp)
811323c8:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
811323cc:	d0a07b43 	ldbu	r2,-32275(gp)
811323d0:	10803fcc 	andi	r2,r2,255
811323d4:	10000e26 	beq	r2,zero,81132410 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
811323d8:	d0a07e17 	ldw	r2,-32264(gp)
811323dc:	10800044 	addi	r2,r2,1
811323e0:	d0a07e15 	stw	r2,-32264(gp)
811323e4:	d0a08217 	ldw	r2,-32248(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
811323e8:	d0e07e17 	ldw	r3,-32264(gp)
811323ec:	10c0082e 	bgeu	r2,r3,81132410 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
811323f0:	d0207e15 	stw	zero,-32264(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
811323f4:	d0a07d17 	ldw	r2,-32268(gp)
811323f8:	10c00044 	addi	r3,r2,1
811323fc:	d0e07d15 	stw	r3,-32268(gp)
81132400:	100b883a 	mov	r5,r2
81132404:	01204574 	movhi	r4,33045
81132408:	212c5804 	addi	r4,r4,-20128
8113240c:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
        }
    }
}
81132410:	0001883a 	nop
81132414:	e037883a 	mov	sp,fp
81132418:	dfc00117 	ldw	ra,4(sp)
8113241c:	df000017 	ldw	fp,0(sp)
81132420:	dec00204 	addi	sp,sp,8
81132424:	f800283a 	ret

81132428 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132428:	defffe04 	addi	sp,sp,-8
8113242c:	de00012e 	bgeu	sp,et,81132434 <alt_get_errno+0xc>
81132430:	003b68fa 	trap	3
81132434:	dfc00115 	stw	ra,4(sp)
81132438:	df000015 	stw	fp,0(sp)
8113243c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132440:	d0a01017 	ldw	r2,-32704(gp)
81132444:	10000326 	beq	r2,zero,81132454 <alt_get_errno+0x2c>
81132448:	d0a01017 	ldw	r2,-32704(gp)
8113244c:	103ee83a 	callr	r2
81132450:	00000106 	br	81132458 <alt_get_errno+0x30>
81132454:	d0a07204 	addi	r2,gp,-32312
}
81132458:	e037883a 	mov	sp,fp
8113245c:	dfc00117 	ldw	ra,4(sp)
81132460:	df000017 	ldw	fp,0(sp)
81132464:	dec00204 	addi	sp,sp,8
81132468:	f800283a 	ret

8113246c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
8113246c:	defff904 	addi	sp,sp,-28
81132470:	de00012e 	bgeu	sp,et,81132478 <lseek+0xc>
81132474:	003b68fa 	trap	3
81132478:	dfc00615 	stw	ra,24(sp)
8113247c:	df000515 	stw	fp,20(sp)
81132480:	df000504 	addi	fp,sp,20
81132484:	e13ffd15 	stw	r4,-12(fp)
81132488:	e17ffe15 	stw	r5,-8(fp)
8113248c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81132490:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132494:	e0bffd17 	ldw	r2,-12(fp)
81132498:	10000616 	blt	r2,zero,811324b4 <lseek+0x48>
8113249c:	e0bffd17 	ldw	r2,-12(fp)
811324a0:	10c00324 	muli	r3,r2,12
811324a4:	00a04574 	movhi	r2,33045
811324a8:	10b01104 	addi	r2,r2,-16316
811324ac:	1885883a 	add	r2,r3,r2
811324b0:	00000106 	br	811324b8 <lseek+0x4c>
811324b4:	0005883a 	mov	r2,zero
811324b8:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
811324bc:	e0bffc17 	ldw	r2,-16(fp)
811324c0:	10001026 	beq	r2,zero,81132504 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
811324c4:	e0bffc17 	ldw	r2,-16(fp)
811324c8:	10800017 	ldw	r2,0(r2)
811324cc:	10800717 	ldw	r2,28(r2)
811324d0:	10000926 	beq	r2,zero,811324f8 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
811324d4:	e0bffc17 	ldw	r2,-16(fp)
811324d8:	10800017 	ldw	r2,0(r2)
811324dc:	10800717 	ldw	r2,28(r2)
811324e0:	e1bfff17 	ldw	r6,-4(fp)
811324e4:	e17ffe17 	ldw	r5,-8(fp)
811324e8:	e13ffc17 	ldw	r4,-16(fp)
811324ec:	103ee83a 	callr	r2
811324f0:	e0bffb15 	stw	r2,-20(fp)
811324f4:	00000506 	br	8113250c <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
811324f8:	00bfde84 	movi	r2,-134
811324fc:	e0bffb15 	stw	r2,-20(fp)
81132500:	00000206 	br	8113250c <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81132504:	00bfebc4 	movi	r2,-81
81132508:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
8113250c:	e0bffb17 	ldw	r2,-20(fp)
81132510:	1000070e 	bge	r2,zero,81132530 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81132514:	11324280 	call	81132428 <alt_get_errno>
81132518:	1007883a 	mov	r3,r2
8113251c:	e0bffb17 	ldw	r2,-20(fp)
81132520:	0085c83a 	sub	r2,zero,r2
81132524:	18800015 	stw	r2,0(r3)
    rc = -1;
81132528:	00bfffc4 	movi	r2,-1
8113252c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
81132530:	e0bffb17 	ldw	r2,-20(fp)
}
81132534:	e037883a 	mov	sp,fp
81132538:	dfc00117 	ldw	ra,4(sp)
8113253c:	df000017 	ldw	fp,0(sp)
81132540:	dec00204 	addi	sp,sp,8
81132544:	f800283a 	ret

81132548 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
81132548:	defff904 	addi	sp,sp,-28
8113254c:	de00012e 	bgeu	sp,et,81132554 <alt_main+0xc>
81132550:	003b68fa 	trap	3
81132554:	dfc00615 	stw	ra,24(sp)
81132558:	df000515 	stw	fp,20(sp)
8113255c:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81132560:	d0a01217 	ldw	r2,-32696(gp)
81132564:	10800058 	cmpnei	r2,r2,1
81132568:	1000031e 	bne	r2,zero,81132578 <alt_main+0x30>
8113256c:	01204574 	movhi	r4,33045
81132570:	212c5e04 	addi	r4,r4,-20104
81132574:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81132578:	0009883a 	mov	r4,zero
8113257c:	113ceec0 	call	8113ceec <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81132580:	d0a01217 	ldw	r2,-32696(gp)
81132584:	10800058 	cmpnei	r2,r2,1
81132588:	1000031e 	bne	r2,zero,81132598 <alt_main+0x50>
8113258c:	01204574 	movhi	r4,33045
81132590:	212c6c04 	addi	r4,r4,-20048
81132594:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  ALT_OS_INIT();
81132598:	1133b340 	call	81133b34 <OSInit>
8113259c:	01000044 	movi	r4,1
811325a0:	11398500 	call	81139850 <OSSemCreate>
811325a4:	d0a08515 	stw	r2,-32236(gp)
811325a8:	01000044 	movi	r4,1
811325ac:	11398500 	call	81139850 <OSSemCreate>
811325b0:	d0a08715 	stw	r2,-32228(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
811325b4:	d0a01217 	ldw	r2,-32696(gp)
811325b8:	10800058 	cmpnei	r2,r2,1
811325bc:	1000031e 	bne	r2,zero,811325cc <alt_main+0x84>
811325c0:	01204574 	movhi	r4,33045
811325c4:	212c7a04 	addi	r4,r4,-19992
811325c8:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
811325cc:	d0a07904 	addi	r2,gp,-32284
811325d0:	e0bffc15 	stw	r2,-16(fp)
811325d4:	00800044 	movi	r2,1
811325d8:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811325dc:	e0bffd0b 	ldhu	r2,-12(fp)
811325e0:	1009883a 	mov	r4,r2
811325e4:	11398500 	call	81139850 <OSSemCreate>
811325e8:	1007883a 	mov	r3,r2
811325ec:	e0bffc17 	ldw	r2,-16(fp)
811325f0:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
811325f4:	d0a01217 	ldw	r2,-32696(gp)
811325f8:	10800058 	cmpnei	r2,r2,1
811325fc:	1000031e 	bne	r2,zero,8113260c <alt_main+0xc4>
81132600:	01204574 	movhi	r4,33045
81132604:	212c8804 	addi	r4,r4,-19936
81132608:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  alt_sys_init();
8113260c:	113cf2c0 	call	8113cf2c <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
81132610:	d0a01217 	ldw	r2,-32696(gp)
81132614:	10800058 	cmpnei	r2,r2,1
81132618:	1000031e 	bne	r2,zero,81132628 <alt_main+0xe0>
8113261c:	01204574 	movhi	r4,33045
81132620:	212c9204 	addi	r4,r4,-19896
81132624:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
81132628:	d0a01217 	ldw	r2,-32696(gp)
8113262c:	10800058 	cmpnei	r2,r2,1
81132630:	1000031e 	bne	r2,zero,81132640 <alt_main+0xf8>
81132634:	01204574 	movhi	r4,33045
81132638:	212c9b04 	addi	r4,r4,-19860
8113263c:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81132640:	01a04574 	movhi	r6,33045
81132644:	31aca304 	addi	r6,r6,-19828
81132648:	01604574 	movhi	r5,33045
8113264c:	296ca804 	addi	r5,r5,-19808
81132650:	01204574 	movhi	r4,33045
81132654:	212ca804 	addi	r4,r4,-19808
81132658:	114581c0 	call	8114581c <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
8113265c:	d0a01217 	ldw	r2,-32696(gp)
81132660:	10800058 	cmpnei	r2,r2,1
81132664:	1000031e 	bne	r2,zero,81132674 <alt_main+0x12c>
81132668:	01204574 	movhi	r4,33045
8113266c:	212cac04 	addi	r4,r4,-19792
81132670:	1131fc40 	call	81131fc4 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81132674:	d0a07f17 	ldw	r2,-32260(gp)
81132678:	d0e08017 	ldw	r3,-32256(gp)
8113267c:	d1208117 	ldw	r4,-32252(gp)
81132680:	200d883a 	mov	r6,r4
81132684:	180b883a 	mov	r5,r3
81132688:	1009883a 	mov	r4,r2
8113268c:	11142140 	call	81114214 <main>
81132690:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81132694:	01000044 	movi	r4,1
81132698:	11314740 	call	81131474 <close>
  exit (result);
8113269c:	e13ffb17 	ldw	r4,-20(fp)
811326a0:	1145fd00 	call	81145fd0 <exit>

811326a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811326a4:	defffe04 	addi	sp,sp,-8
811326a8:	de00012e 	bgeu	sp,et,811326b0 <alt_get_errno+0xc>
811326ac:	003b68fa 	trap	3
811326b0:	dfc00115 	stw	ra,4(sp)
811326b4:	df000015 	stw	fp,0(sp)
811326b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811326bc:	d0a01017 	ldw	r2,-32704(gp)
811326c0:	10000326 	beq	r2,zero,811326d0 <alt_get_errno+0x2c>
811326c4:	d0a01017 	ldw	r2,-32704(gp)
811326c8:	103ee83a 	callr	r2
811326cc:	00000106 	br	811326d4 <alt_get_errno+0x30>
811326d0:	d0a07204 	addi	r2,gp,-32312
}
811326d4:	e037883a 	mov	sp,fp
811326d8:	dfc00117 	ldw	ra,4(sp)
811326dc:	df000017 	ldw	fp,0(sp)
811326e0:	dec00204 	addi	sp,sp,8
811326e4:	f800283a 	ret

811326e8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
811326e8:	defffd04 	addi	sp,sp,-12
811326ec:	de00012e 	bgeu	sp,et,811326f4 <alt_file_locked+0xc>
811326f0:	003b68fa 	trap	3
811326f4:	df000215 	stw	fp,8(sp)
811326f8:	df000204 	addi	fp,sp,8
811326fc:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
81132700:	e0bfff17 	ldw	r2,-4(fp)
81132704:	10800217 	ldw	r2,8(r2)
81132708:	10d00034 	orhi	r3,r2,16384
8113270c:	e0bfff17 	ldw	r2,-4(fp)
81132710:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81132714:	e03ffe15 	stw	zero,-8(fp)
81132718:	00001d06 	br	81132790 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
8113271c:	00a04574 	movhi	r2,33045
81132720:	10b01104 	addi	r2,r2,-16316
81132724:	e0fffe17 	ldw	r3,-8(fp)
81132728:	18c00324 	muli	r3,r3,12
8113272c:	10c5883a 	add	r2,r2,r3
81132730:	10c00017 	ldw	r3,0(r2)
81132734:	e0bfff17 	ldw	r2,-4(fp)
81132738:	10800017 	ldw	r2,0(r2)
8113273c:	1880111e 	bne	r3,r2,81132784 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81132740:	00a04574 	movhi	r2,33045
81132744:	10b01104 	addi	r2,r2,-16316
81132748:	e0fffe17 	ldw	r3,-8(fp)
8113274c:	18c00324 	muli	r3,r3,12
81132750:	10c5883a 	add	r2,r2,r3
81132754:	10800204 	addi	r2,r2,8
81132758:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
8113275c:	1000090e 	bge	r2,zero,81132784 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81132760:	e0bffe17 	ldw	r2,-8(fp)
81132764:	10c00324 	muli	r3,r2,12
81132768:	00a04574 	movhi	r2,33045
8113276c:	10b01104 	addi	r2,r2,-16316
81132770:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81132774:	e0bfff17 	ldw	r2,-4(fp)
81132778:	18800226 	beq	r3,r2,81132784 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
8113277c:	00bffcc4 	movi	r2,-13
81132780:	00000806 	br	811327a4 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81132784:	e0bffe17 	ldw	r2,-8(fp)
81132788:	10800044 	addi	r2,r2,1
8113278c:	e0bffe15 	stw	r2,-8(fp)
81132790:	d0a00f17 	ldw	r2,-32708(gp)
81132794:	1007883a 	mov	r3,r2
81132798:	e0bffe17 	ldw	r2,-8(fp)
8113279c:	18bfdf2e 	bgeu	r3,r2,8113271c <__reset+0xfb11271c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
811327a0:	0005883a 	mov	r2,zero
}
811327a4:	e037883a 	mov	sp,fp
811327a8:	df000017 	ldw	fp,0(sp)
811327ac:	dec00104 	addi	sp,sp,4
811327b0:	f800283a 	ret

811327b4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
811327b4:	defff604 	addi	sp,sp,-40
811327b8:	de00012e 	bgeu	sp,et,811327c0 <open+0xc>
811327bc:	003b68fa 	trap	3
811327c0:	dfc00915 	stw	ra,36(sp)
811327c4:	df000815 	stw	fp,32(sp)
811327c8:	df000804 	addi	fp,sp,32
811327cc:	e13ffd15 	stw	r4,-12(fp)
811327d0:	e17ffe15 	stw	r5,-8(fp)
811327d4:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
811327d8:	00bfffc4 	movi	r2,-1
811327dc:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
811327e0:	00bffb44 	movi	r2,-19
811327e4:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
811327e8:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
811327ec:	d1600d04 	addi	r5,gp,-32716
811327f0:	e13ffd17 	ldw	r4,-12(fp)
811327f4:	11451fc0 	call	811451fc <alt_find_dev>
811327f8:	e0bff815 	stw	r2,-32(fp)
811327fc:	e0bff817 	ldw	r2,-32(fp)
81132800:	1000051e 	bne	r2,zero,81132818 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81132804:	e13ffd17 	ldw	r4,-12(fp)
81132808:	11452940 	call	81145294 <alt_find_file>
8113280c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
81132810:	00800044 	movi	r2,1
81132814:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81132818:	e0bff817 	ldw	r2,-32(fp)
8113281c:	10002926 	beq	r2,zero,811328c4 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
81132820:	e13ff817 	ldw	r4,-32(fp)
81132824:	11453a40 	call	811453a4 <alt_get_fd>
81132828:	e0bff915 	stw	r2,-28(fp)
8113282c:	e0bff917 	ldw	r2,-28(fp)
81132830:	1000030e 	bge	r2,zero,81132840 <open+0x8c>
    {
      status = index;
81132834:	e0bff917 	ldw	r2,-28(fp)
81132838:	e0bffa15 	stw	r2,-24(fp)
8113283c:	00002306 	br	811328cc <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81132840:	e0bff917 	ldw	r2,-28(fp)
81132844:	10c00324 	muli	r3,r2,12
81132848:	00a04574 	movhi	r2,33045
8113284c:	10b01104 	addi	r2,r2,-16316
81132850:	1885883a 	add	r2,r3,r2
81132854:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
81132858:	e0fffe17 	ldw	r3,-8(fp)
8113285c:	00900034 	movhi	r2,16384
81132860:	10bfffc4 	addi	r2,r2,-1
81132864:	1886703a 	and	r3,r3,r2
81132868:	e0bffc17 	ldw	r2,-16(fp)
8113286c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81132870:	e0bffb17 	ldw	r2,-20(fp)
81132874:	1000051e 	bne	r2,zero,8113288c <open+0xd8>
81132878:	e13ffc17 	ldw	r4,-16(fp)
8113287c:	11326e80 	call	811326e8 <alt_file_locked>
81132880:	e0bffa15 	stw	r2,-24(fp)
81132884:	e0bffa17 	ldw	r2,-24(fp)
81132888:	10001016 	blt	r2,zero,811328cc <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
8113288c:	e0bff817 	ldw	r2,-32(fp)
81132890:	10800317 	ldw	r2,12(r2)
81132894:	10000826 	beq	r2,zero,811328b8 <open+0x104>
81132898:	e0bff817 	ldw	r2,-32(fp)
8113289c:	10800317 	ldw	r2,12(r2)
811328a0:	e1ffff17 	ldw	r7,-4(fp)
811328a4:	e1bffe17 	ldw	r6,-8(fp)
811328a8:	e17ffd17 	ldw	r5,-12(fp)
811328ac:	e13ffc17 	ldw	r4,-16(fp)
811328b0:	103ee83a 	callr	r2
811328b4:	00000106 	br	811328bc <open+0x108>
811328b8:	0005883a 	mov	r2,zero
811328bc:	e0bffa15 	stw	r2,-24(fp)
811328c0:	00000206 	br	811328cc <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
811328c4:	00bffb44 	movi	r2,-19
811328c8:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
811328cc:	e0bffa17 	ldw	r2,-24(fp)
811328d0:	1000090e 	bge	r2,zero,811328f8 <open+0x144>
  {
    alt_release_fd (index);  
811328d4:	e13ff917 	ldw	r4,-28(fp)
811328d8:	1132a580 	call	81132a58 <alt_release_fd>
    ALT_ERRNO = -status;
811328dc:	11326a40 	call	811326a4 <alt_get_errno>
811328e0:	1007883a 	mov	r3,r2
811328e4:	e0bffa17 	ldw	r2,-24(fp)
811328e8:	0085c83a 	sub	r2,zero,r2
811328ec:	18800015 	stw	r2,0(r3)
    return -1;
811328f0:	00bfffc4 	movi	r2,-1
811328f4:	00000106 	br	811328fc <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
811328f8:	e0bff917 	ldw	r2,-28(fp)
}
811328fc:	e037883a 	mov	sp,fp
81132900:	dfc00117 	ldw	ra,4(sp)
81132904:	df000017 	ldw	fp,0(sp)
81132908:	dec00204 	addi	sp,sp,8
8113290c:	f800283a 	ret

81132910 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132910:	defffe04 	addi	sp,sp,-8
81132914:	de00012e 	bgeu	sp,et,8113291c <alt_get_errno+0xc>
81132918:	003b68fa 	trap	3
8113291c:	dfc00115 	stw	ra,4(sp)
81132920:	df000015 	stw	fp,0(sp)
81132924:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132928:	d0a01017 	ldw	r2,-32704(gp)
8113292c:	10000326 	beq	r2,zero,8113293c <alt_get_errno+0x2c>
81132930:	d0a01017 	ldw	r2,-32704(gp)
81132934:	103ee83a 	callr	r2
81132938:	00000106 	br	81132940 <alt_get_errno+0x30>
8113293c:	d0a07204 	addi	r2,gp,-32312
}
81132940:	e037883a 	mov	sp,fp
81132944:	dfc00117 	ldw	ra,4(sp)
81132948:	df000017 	ldw	fp,0(sp)
8113294c:	dec00204 	addi	sp,sp,8
81132950:	f800283a 	ret

81132954 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81132954:	defff904 	addi	sp,sp,-28
81132958:	de00012e 	bgeu	sp,et,81132960 <read+0xc>
8113295c:	003b68fa 	trap	3
81132960:	dfc00615 	stw	ra,24(sp)
81132964:	df000515 	stw	fp,20(sp)
81132968:	df000504 	addi	fp,sp,20
8113296c:	e13ffd15 	stw	r4,-12(fp)
81132970:	e17ffe15 	stw	r5,-8(fp)
81132974:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132978:	e0bffd17 	ldw	r2,-12(fp)
8113297c:	10000616 	blt	r2,zero,81132998 <read+0x44>
81132980:	e0bffd17 	ldw	r2,-12(fp)
81132984:	10c00324 	muli	r3,r2,12
81132988:	00a04574 	movhi	r2,33045
8113298c:	10b01104 	addi	r2,r2,-16316
81132990:	1885883a 	add	r2,r3,r2
81132994:	00000106 	br	8113299c <read+0x48>
81132998:	0005883a 	mov	r2,zero
8113299c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
811329a0:	e0bffb17 	ldw	r2,-20(fp)
811329a4:	10002226 	beq	r2,zero,81132a30 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811329a8:	e0bffb17 	ldw	r2,-20(fp)
811329ac:	10800217 	ldw	r2,8(r2)
811329b0:	108000cc 	andi	r2,r2,3
811329b4:	10800060 	cmpeqi	r2,r2,1
811329b8:	1000181e 	bne	r2,zero,81132a1c <read+0xc8>
        (fd->dev->read))
811329bc:	e0bffb17 	ldw	r2,-20(fp)
811329c0:	10800017 	ldw	r2,0(r2)
811329c4:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811329c8:	10001426 	beq	r2,zero,81132a1c <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
811329cc:	e0bffb17 	ldw	r2,-20(fp)
811329d0:	10800017 	ldw	r2,0(r2)
811329d4:	10800517 	ldw	r2,20(r2)
811329d8:	e0ffff17 	ldw	r3,-4(fp)
811329dc:	180d883a 	mov	r6,r3
811329e0:	e17ffe17 	ldw	r5,-8(fp)
811329e4:	e13ffb17 	ldw	r4,-20(fp)
811329e8:	103ee83a 	callr	r2
811329ec:	e0bffc15 	stw	r2,-16(fp)
811329f0:	e0bffc17 	ldw	r2,-16(fp)
811329f4:	1000070e 	bge	r2,zero,81132a14 <read+0xc0>
        {
          ALT_ERRNO = -rval;
811329f8:	11329100 	call	81132910 <alt_get_errno>
811329fc:	1007883a 	mov	r3,r2
81132a00:	e0bffc17 	ldw	r2,-16(fp)
81132a04:	0085c83a 	sub	r2,zero,r2
81132a08:	18800015 	stw	r2,0(r3)
          return -1;
81132a0c:	00bfffc4 	movi	r2,-1
81132a10:	00000c06 	br	81132a44 <read+0xf0>
        }
        return rval;
81132a14:	e0bffc17 	ldw	r2,-16(fp)
81132a18:	00000a06 	br	81132a44 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81132a1c:	11329100 	call	81132910 <alt_get_errno>
81132a20:	1007883a 	mov	r3,r2
81132a24:	00800344 	movi	r2,13
81132a28:	18800015 	stw	r2,0(r3)
81132a2c:	00000406 	br	81132a40 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81132a30:	11329100 	call	81132910 <alt_get_errno>
81132a34:	1007883a 	mov	r3,r2
81132a38:	00801444 	movi	r2,81
81132a3c:	18800015 	stw	r2,0(r3)
  }
  return -1;
81132a40:	00bfffc4 	movi	r2,-1
}
81132a44:	e037883a 	mov	sp,fp
81132a48:	dfc00117 	ldw	ra,4(sp)
81132a4c:	df000017 	ldw	fp,0(sp)
81132a50:	dec00204 	addi	sp,sp,8
81132a54:	f800283a 	ret

81132a58 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
81132a58:	defffe04 	addi	sp,sp,-8
81132a5c:	de00012e 	bgeu	sp,et,81132a64 <alt_release_fd+0xc>
81132a60:	003b68fa 	trap	3
81132a64:	df000115 	stw	fp,4(sp)
81132a68:	df000104 	addi	fp,sp,4
81132a6c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81132a70:	e0bfff17 	ldw	r2,-4(fp)
81132a74:	108000d0 	cmplti	r2,r2,3
81132a78:	10000d1e 	bne	r2,zero,81132ab0 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81132a7c:	00a04574 	movhi	r2,33045
81132a80:	10b01104 	addi	r2,r2,-16316
81132a84:	e0ffff17 	ldw	r3,-4(fp)
81132a88:	18c00324 	muli	r3,r3,12
81132a8c:	10c5883a 	add	r2,r2,r3
81132a90:	10800204 	addi	r2,r2,8
81132a94:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81132a98:	00a04574 	movhi	r2,33045
81132a9c:	10b01104 	addi	r2,r2,-16316
81132aa0:	e0ffff17 	ldw	r3,-4(fp)
81132aa4:	18c00324 	muli	r3,r3,12
81132aa8:	10c5883a 	add	r2,r2,r3
81132aac:	10000015 	stw	zero,0(r2)
  }
}
81132ab0:	0001883a 	nop
81132ab4:	e037883a 	mov	sp,fp
81132ab8:	df000017 	ldw	fp,0(sp)
81132abc:	dec00104 	addi	sp,sp,4
81132ac0:	f800283a 	ret

81132ac4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81132ac4:	defff604 	addi	sp,sp,-40
81132ac8:	de00012e 	bgeu	sp,et,81132ad0 <sbrk+0xc>
81132acc:	003b68fa 	trap	3
81132ad0:	df000915 	stw	fp,36(sp)
81132ad4:	df000904 	addi	fp,sp,36
81132ad8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132adc:	0005303a 	rdctl	r2,status
81132ae0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132ae4:	e0fffe17 	ldw	r3,-8(fp)
81132ae8:	00bfff84 	movi	r2,-2
81132aec:	1884703a 	and	r2,r3,r2
81132af0:	1001703a 	wrctl	status,r2
  
  return context;
81132af4:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81132af8:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81132afc:	d0a01317 	ldw	r2,-32692(gp)
81132b00:	10c000c4 	addi	r3,r2,3
81132b04:	00bfff04 	movi	r2,-4
81132b08:	1884703a 	and	r2,r3,r2
81132b0c:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81132b10:	d0e01317 	ldw	r3,-32692(gp)
81132b14:	e0bfff17 	ldw	r2,-4(fp)
81132b18:	1887883a 	add	r3,r3,r2
81132b1c:	00a04834 	movhi	r2,33056
81132b20:	10a80004 	addi	r2,r2,-24576
81132b24:	10c0062e 	bgeu	r2,r3,81132b40 <sbrk+0x7c>
81132b28:	e0bff817 	ldw	r2,-32(fp)
81132b2c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132b30:	e0bff717 	ldw	r2,-36(fp)
81132b34:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81132b38:	00bfffc4 	movi	r2,-1
81132b3c:	00001c06 	br	81132bb0 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81132b40:	d0a01317 	ldw	r2,-32692(gp)
81132b44:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81132b48:	d0e01317 	ldw	r3,-32692(gp)
81132b4c:	e0bfff17 	ldw	r2,-4(fp)
81132b50:	1885883a 	add	r2,r3,r2
81132b54:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81132b58:	c005883a 	mov	r2,et
81132b5c:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81132b60:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81132b64:	e0bffa17 	ldw	r2,-24(fp)
81132b68:	18800c1e 	bne	r3,r2,81132b9c <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81132b6c:	d805883a 	mov	r2,sp
81132b70:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81132b74:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81132b78:	d0e01317 	ldw	r3,-32692(gp)
81132b7c:	18800136 	bltu	r3,r2,81132b84 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81132b80:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81132b84:	d0a01317 	ldw	r2,-32692(gp)
81132b88:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81132b8c:	e0bffc17 	ldw	r2,-16(fp)
81132b90:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81132b94:	e0bffc17 	ldw	r2,-16(fp)
81132b98:	1031883a 	mov	et,r2
81132b9c:	e0bff817 	ldw	r2,-32(fp)
81132ba0:	e0bffd15 	stw	r2,-12(fp)
81132ba4:	e0bffd17 	ldw	r2,-12(fp)
81132ba8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81132bac:	e0bffa17 	ldw	r2,-24(fp)
} 
81132bb0:	e037883a 	mov	sp,fp
81132bb4:	df000017 	ldw	fp,0(sp)
81132bb8:	dec00104 	addi	sp,sp,4
81132bbc:	f800283a 	ret

81132bc0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81132bc0:	defffa04 	addi	sp,sp,-24
81132bc4:	de00012e 	bgeu	sp,et,81132bcc <alt_alarm_stop+0xc>
81132bc8:	003b68fa 	trap	3
81132bcc:	df000515 	stw	fp,20(sp)
81132bd0:	df000504 	addi	fp,sp,20
81132bd4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132bd8:	0005303a 	rdctl	r2,status
81132bdc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132be0:	e0fffc17 	ldw	r3,-16(fp)
81132be4:	00bfff84 	movi	r2,-2
81132be8:	1884703a 	and	r2,r3,r2
81132bec:	1001703a 	wrctl	status,r2
  
  return context;
81132bf0:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81132bf4:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81132bf8:	e0bfff17 	ldw	r2,-4(fp)
81132bfc:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81132c00:	e0bffd17 	ldw	r2,-12(fp)
81132c04:	10800017 	ldw	r2,0(r2)
81132c08:	e0fffd17 	ldw	r3,-12(fp)
81132c0c:	18c00117 	ldw	r3,4(r3)
81132c10:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81132c14:	e0bffd17 	ldw	r2,-12(fp)
81132c18:	10800117 	ldw	r2,4(r2)
81132c1c:	e0fffd17 	ldw	r3,-12(fp)
81132c20:	18c00017 	ldw	r3,0(r3)
81132c24:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81132c28:	e0bffd17 	ldw	r2,-12(fp)
81132c2c:	e0fffd17 	ldw	r3,-12(fp)
81132c30:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81132c34:	e0bffd17 	ldw	r2,-12(fp)
81132c38:	e0fffd17 	ldw	r3,-12(fp)
81132c3c:	10c00015 	stw	r3,0(r2)
81132c40:	e0bffb17 	ldw	r2,-20(fp)
81132c44:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132c48:	e0bffe17 	ldw	r2,-8(fp)
81132c4c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81132c50:	0001883a 	nop
81132c54:	e037883a 	mov	sp,fp
81132c58:	df000017 	ldw	fp,0(sp)
81132c5c:	dec00104 	addi	sp,sp,4
81132c60:	f800283a 	ret

81132c64 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81132c64:	defffb04 	addi	sp,sp,-20
81132c68:	de00012e 	bgeu	sp,et,81132c70 <alt_tick+0xc>
81132c6c:	003b68fa 	trap	3
81132c70:	dfc00415 	stw	ra,16(sp)
81132c74:	df000315 	stw	fp,12(sp)
81132c78:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81132c7c:	d0a01417 	ldw	r2,-32688(gp)
81132c80:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81132c84:	d0a08317 	ldw	r2,-32244(gp)
81132c88:	10800044 	addi	r2,r2,1
81132c8c:	d0a08315 	stw	r2,-32244(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81132c90:	00002e06 	br	81132d4c <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81132c94:	e0bffd17 	ldw	r2,-12(fp)
81132c98:	10800017 	ldw	r2,0(r2)
81132c9c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81132ca0:	e0bffd17 	ldw	r2,-12(fp)
81132ca4:	10800403 	ldbu	r2,16(r2)
81132ca8:	10803fcc 	andi	r2,r2,255
81132cac:	10000426 	beq	r2,zero,81132cc0 <alt_tick+0x5c>
81132cb0:	d0a08317 	ldw	r2,-32244(gp)
81132cb4:	1000021e 	bne	r2,zero,81132cc0 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81132cb8:	e0bffd17 	ldw	r2,-12(fp)
81132cbc:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81132cc0:	e0bffd17 	ldw	r2,-12(fp)
81132cc4:	10800217 	ldw	r2,8(r2)
81132cc8:	d0e08317 	ldw	r3,-32244(gp)
81132ccc:	18801d36 	bltu	r3,r2,81132d44 <alt_tick+0xe0>
81132cd0:	e0bffd17 	ldw	r2,-12(fp)
81132cd4:	10800403 	ldbu	r2,16(r2)
81132cd8:	10803fcc 	andi	r2,r2,255
81132cdc:	1000191e 	bne	r2,zero,81132d44 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81132ce0:	e0bffd17 	ldw	r2,-12(fp)
81132ce4:	10800317 	ldw	r2,12(r2)
81132ce8:	e0fffd17 	ldw	r3,-12(fp)
81132cec:	18c00517 	ldw	r3,20(r3)
81132cf0:	1809883a 	mov	r4,r3
81132cf4:	103ee83a 	callr	r2
81132cf8:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81132cfc:	e0bfff17 	ldw	r2,-4(fp)
81132d00:	1000031e 	bne	r2,zero,81132d10 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81132d04:	e13ffd17 	ldw	r4,-12(fp)
81132d08:	1132bc00 	call	81132bc0 <alt_alarm_stop>
81132d0c:	00000d06 	br	81132d44 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81132d10:	e0bffd17 	ldw	r2,-12(fp)
81132d14:	10c00217 	ldw	r3,8(r2)
81132d18:	e0bfff17 	ldw	r2,-4(fp)
81132d1c:	1887883a 	add	r3,r3,r2
81132d20:	e0bffd17 	ldw	r2,-12(fp)
81132d24:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81132d28:	e0bffd17 	ldw	r2,-12(fp)
81132d2c:	10c00217 	ldw	r3,8(r2)
81132d30:	d0a08317 	ldw	r2,-32244(gp)
81132d34:	1880032e 	bgeu	r3,r2,81132d44 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81132d38:	e0bffd17 	ldw	r2,-12(fp)
81132d3c:	00c00044 	movi	r3,1
81132d40:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81132d44:	e0bffe17 	ldw	r2,-8(fp)
81132d48:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81132d4c:	e0fffd17 	ldw	r3,-12(fp)
81132d50:	d0a01404 	addi	r2,gp,-32688
81132d54:	18bfcf1e 	bne	r3,r2,81132c94 <__reset+0xfb112c94>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81132d58:	1133f940 	call	81133f94 <OSTimeTick>
}
81132d5c:	0001883a 	nop
81132d60:	e037883a 	mov	sp,fp
81132d64:	dfc00117 	ldw	ra,4(sp)
81132d68:	df000017 	ldw	fp,0(sp)
81132d6c:	dec00204 	addi	sp,sp,8
81132d70:	f800283a 	ret

81132d74 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81132d74:	defffb04 	addi	sp,sp,-20
81132d78:	de00012e 	bgeu	sp,et,81132d80 <usleep+0xc>
81132d7c:	003b68fa 	trap	3
81132d80:	dfc00415 	stw	ra,16(sp)
81132d84:	df000315 	stw	fp,12(sp)
81132d88:	df000304 	addi	fp,sp,12
81132d8c:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81132d90:	d0a08b03 	ldbu	r2,-32212(gp)
81132d94:	10803fcc 	andi	r2,r2,255
81132d98:	1000031e 	bne	r2,zero,81132da8 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81132d9c:	e13fff17 	ldw	r4,-4(fp)
81132da0:	11313000 	call	81131300 <alt_busy_sleep>
81132da4:	00003d06 	br	81132e9c <usleep+0x128>
81132da8:	d0a08217 	ldw	r2,-32248(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81132dac:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81132db0:	e0ffff17 	ldw	r3,-4(fp)
81132db4:	0090c734 	movhi	r2,17180
81132db8:	10b7a0c4 	addi	r2,r2,-8573
81132dbc:	1888383a 	mulxuu	r4,r3,r2
81132dc0:	1885383a 	mul	r2,r3,r2
81132dc4:	1013883a 	mov	r9,r2
81132dc8:	2015883a 	mov	r10,r4
81132dcc:	5006d4ba 	srli	r3,r10,18
81132dd0:	e0bffe17 	ldw	r2,-8(fp)
81132dd4:	1893383a 	mul	r9,r3,r2
81132dd8:	e0ffff17 	ldw	r3,-4(fp)
81132ddc:	0090c734 	movhi	r2,17180
81132de0:	10b7a0c4 	addi	r2,r2,-8573
81132de4:	1888383a 	mulxuu	r4,r3,r2
81132de8:	1885383a 	mul	r2,r3,r2
81132dec:	100f883a 	mov	r7,r2
81132df0:	2011883a 	mov	r8,r4
81132df4:	4004d4ba 	srli	r2,r8,18
81132df8:	010003f4 	movhi	r4,15
81132dfc:	21109004 	addi	r4,r4,16960
81132e00:	1105383a 	mul	r2,r2,r4
81132e04:	1885c83a 	sub	r2,r3,r2
81132e08:	e0fffe17 	ldw	r3,-8(fp)
81132e0c:	10c7383a 	mul	r3,r2,r3
81132e10:	0090c734 	movhi	r2,17180
81132e14:	10b7a0c4 	addi	r2,r2,-8573
81132e18:	1888383a 	mulxuu	r4,r3,r2
81132e1c:	1885383a 	mul	r2,r3,r2
81132e20:	100b883a 	mov	r5,r2
81132e24:	200d883a 	mov	r6,r4
81132e28:	3004d4ba 	srli	r2,r6,18
81132e2c:	4885883a 	add	r2,r9,r2
81132e30:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81132e34:	00000706 	br	81132e54 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81132e38:	013fffd4 	movui	r4,65535
81132e3c:	113b8500 	call	8113b850 <OSTimeDly>
    ticks -= 0xffff;
81132e40:	e0fffd17 	ldw	r3,-12(fp)
81132e44:	00bffff4 	movhi	r2,65535
81132e48:	10800044 	addi	r2,r2,1
81132e4c:	1885883a 	add	r2,r3,r2
81132e50:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81132e54:	e0bffd17 	ldw	r2,-12(fp)
81132e58:	00ffffd4 	movui	r3,65535
81132e5c:	18bff636 	bltu	r3,r2,81132e38 <__reset+0xfb112e38>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81132e60:	e0bffd17 	ldw	r2,-12(fp)
81132e64:	10bfffcc 	andi	r2,r2,65535
81132e68:	1009883a 	mov	r4,r2
81132e6c:	113b8500 	call	8113b850 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81132e70:	008003f4 	movhi	r2,15
81132e74:	10909004 	addi	r2,r2,16960
81132e78:	e0fffe17 	ldw	r3,-8(fp)
81132e7c:	10c7203a 	divu	r3,r2,r3
81132e80:	e0bfff17 	ldw	r2,-4(fp)
81132e84:	10c9203a 	divu	r4,r2,r3
81132e88:	20c7383a 	mul	r3,r4,r3
81132e8c:	10c5c83a 	sub	r2,r2,r3
81132e90:	1009883a 	mov	r4,r2
81132e94:	11313000 	call	81131300 <alt_busy_sleep>

  return 0;  
81132e98:	0005883a 	mov	r2,zero
}
81132e9c:	e037883a 	mov	sp,fp
81132ea0:	dfc00117 	ldw	ra,4(sp)
81132ea4:	df000017 	ldw	fp,0(sp)
81132ea8:	dec00204 	addi	sp,sp,8
81132eac:	f800283a 	ret

81132eb0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132eb0:	defffe04 	addi	sp,sp,-8
81132eb4:	de00012e 	bgeu	sp,et,81132ebc <alt_get_errno+0xc>
81132eb8:	003b68fa 	trap	3
81132ebc:	dfc00115 	stw	ra,4(sp)
81132ec0:	df000015 	stw	fp,0(sp)
81132ec4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81132ec8:	d0a01017 	ldw	r2,-32704(gp)
81132ecc:	10000326 	beq	r2,zero,81132edc <alt_get_errno+0x2c>
81132ed0:	d0a01017 	ldw	r2,-32704(gp)
81132ed4:	103ee83a 	callr	r2
81132ed8:	00000106 	br	81132ee0 <alt_get_errno+0x30>
81132edc:	d0a07204 	addi	r2,gp,-32312
}
81132ee0:	e037883a 	mov	sp,fp
81132ee4:	dfc00117 	ldw	ra,4(sp)
81132ee8:	df000017 	ldw	fp,0(sp)
81132eec:	dec00204 	addi	sp,sp,8
81132ef0:	f800283a 	ret

81132ef4 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81132ef4:	defff904 	addi	sp,sp,-28
81132ef8:	de00012e 	bgeu	sp,et,81132f00 <write+0xc>
81132efc:	003b68fa 	trap	3
81132f00:	dfc00615 	stw	ra,24(sp)
81132f04:	df000515 	stw	fp,20(sp)
81132f08:	df000504 	addi	fp,sp,20
81132f0c:	e13ffd15 	stw	r4,-12(fp)
81132f10:	e17ffe15 	stw	r5,-8(fp)
81132f14:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132f18:	e0bffd17 	ldw	r2,-12(fp)
81132f1c:	10000616 	blt	r2,zero,81132f38 <write+0x44>
81132f20:	e0bffd17 	ldw	r2,-12(fp)
81132f24:	10c00324 	muli	r3,r2,12
81132f28:	00a04574 	movhi	r2,33045
81132f2c:	10b01104 	addi	r2,r2,-16316
81132f30:	1885883a 	add	r2,r3,r2
81132f34:	00000106 	br	81132f3c <write+0x48>
81132f38:	0005883a 	mov	r2,zero
81132f3c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81132f40:	e0bffb17 	ldw	r2,-20(fp)
81132f44:	10002426 	beq	r2,zero,81132fd8 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81132f48:	e0bffb17 	ldw	r2,-20(fp)
81132f4c:	10800217 	ldw	r2,8(r2)
81132f50:	108000cc 	andi	r2,r2,3
81132f54:	10001b26 	beq	r2,zero,81132fc4 <write+0xd0>
81132f58:	e0bffb17 	ldw	r2,-20(fp)
81132f5c:	10800017 	ldw	r2,0(r2)
81132f60:	10800617 	ldw	r2,24(r2)
81132f64:	10001726 	beq	r2,zero,81132fc4 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81132f68:	e17fff17 	ldw	r5,-4(fp)
81132f6c:	e13ffe17 	ldw	r4,-8(fp)
81132f70:	11322740 	call	81132274 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81132f74:	e0bffb17 	ldw	r2,-20(fp)
81132f78:	10800017 	ldw	r2,0(r2)
81132f7c:	10800617 	ldw	r2,24(r2)
81132f80:	e0ffff17 	ldw	r3,-4(fp)
81132f84:	180d883a 	mov	r6,r3
81132f88:	e17ffe17 	ldw	r5,-8(fp)
81132f8c:	e13ffb17 	ldw	r4,-20(fp)
81132f90:	103ee83a 	callr	r2
81132f94:	e0bffc15 	stw	r2,-16(fp)
81132f98:	e0bffc17 	ldw	r2,-16(fp)
81132f9c:	1000070e 	bge	r2,zero,81132fbc <write+0xc8>
      {
        ALT_ERRNO = -rval;
81132fa0:	1132eb00 	call	81132eb0 <alt_get_errno>
81132fa4:	1007883a 	mov	r3,r2
81132fa8:	e0bffc17 	ldw	r2,-16(fp)
81132fac:	0085c83a 	sub	r2,zero,r2
81132fb0:	18800015 	stw	r2,0(r3)
        return -1;
81132fb4:	00bfffc4 	movi	r2,-1
81132fb8:	00000c06 	br	81132fec <write+0xf8>
      }
      return rval;
81132fbc:	e0bffc17 	ldw	r2,-16(fp)
81132fc0:	00000a06 	br	81132fec <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81132fc4:	1132eb00 	call	81132eb0 <alt_get_errno>
81132fc8:	1007883a 	mov	r3,r2
81132fcc:	00800344 	movi	r2,13
81132fd0:	18800015 	stw	r2,0(r3)
81132fd4:	00000406 	br	81132fe8 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81132fd8:	1132eb00 	call	81132eb0 <alt_get_errno>
81132fdc:	1007883a 	mov	r3,r2
81132fe0:	00801444 	movi	r2,81
81132fe4:	18800015 	stw	r2,0(r3)
  }
  return -1;
81132fe8:	00bfffc4 	movi	r2,-1
}
81132fec:	e037883a 	mov	sp,fp
81132ff0:	dfc00117 	ldw	ra,4(sp)
81132ff4:	df000017 	ldw	fp,0(sp)
81132ff8:	dec00204 	addi	sp,sp,8
81132ffc:	f800283a 	ret

81133000 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81133000:	deffde04 	addi	sp,sp,-136
81133004:	de00012e 	bgeu	sp,et,8113300c <__env_lock+0xc>
81133008:	003b68fa 	trap	3
8113300c:	dfc02115 	stw	ra,132(sp)
81133010:	df002015 	stw	fp,128(sp)
81133014:	df002004 	addi	fp,sp,128
81133018:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
8113301c:	e0bfe104 	addi	r2,fp,-124
81133020:	100b883a 	mov	r5,r2
81133024:	01003fc4 	movi	r4,255
81133028:	113b6ac0 	call	8113b6ac <OSTaskQuery>
8113302c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81133030:	e0bffe83 	ldbu	r2,-6(fp)
81133034:	10803fcc 	andi	r2,r2,255
81133038:	10001e1e 	bne	r2,zero,811330b4 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
8113303c:	e0bfed83 	ldbu	r2,-74(fp)
81133040:	10803fcc 	andi	r2,r2,255
81133044:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81133048:	d0a08517 	ldw	r2,-32236(gp)
8113304c:	e0fffc04 	addi	r3,fp,-16
81133050:	180b883a 	mov	r5,r3
81133054:	1009883a 	mov	r4,r2
81133058:	113a0180 	call	8113a018 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
8113305c:	e0bffe03 	ldbu	r2,-8(fp)
81133060:	10803fcc 	andi	r2,r2,255
81133064:	10000726 	beq	r2,zero,81133084 <__env_lock+0x84>
81133068:	d0a01617 	ldw	r2,-32680(gp)
8113306c:	e0ffe017 	ldw	r3,-128(fp)
81133070:	1880041e 	bne	r3,r2,81133084 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81133074:	d0a08417 	ldw	r2,-32240(gp)
81133078:	10800044 	addi	r2,r2,1
8113307c:	d0a08415 	stw	r2,-32240(gp)
81133080:	00000a06 	br	811330ac <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81133084:	d0a08517 	ldw	r2,-32236(gp)
81133088:	e0fffe84 	addi	r3,fp,-6
8113308c:	180d883a 	mov	r6,r3
81133090:	000b883a 	mov	r5,zero
81133094:	1009883a 	mov	r4,r2
81133098:	1139b780 	call	81139b78 <OSSemPend>
    locks  = 1;
8113309c:	00800044 	movi	r2,1
811330a0:	d0a08415 	stw	r2,-32240(gp)
    lockid = id;
811330a4:	e0bfe017 	ldw	r2,-128(fp)
811330a8:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811330ac:	0001883a 	nop
811330b0:	00000106 	br	811330b8 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811330b4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811330b8:	e037883a 	mov	sp,fp
811330bc:	dfc00117 	ldw	ra,4(sp)
811330c0:	df000017 	ldw	fp,0(sp)
811330c4:	dec00204 	addi	sp,sp,8
811330c8:	f800283a 	ret

811330cc <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
811330cc:	defffd04 	addi	sp,sp,-12
811330d0:	de00012e 	bgeu	sp,et,811330d8 <__env_unlock+0xc>
811330d4:	003b68fa 	trap	3
811330d8:	dfc00215 	stw	ra,8(sp)
811330dc:	df000115 	stw	fp,4(sp)
811330e0:	df000104 	addi	fp,sp,4
811330e4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
811330e8:	d0a08417 	ldw	r2,-32240(gp)
811330ec:	10000b26 	beq	r2,zero,8113311c <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
811330f0:	d0a08417 	ldw	r2,-32240(gp)
811330f4:	10bfffc4 	addi	r2,r2,-1
811330f8:	d0a08415 	stw	r2,-32240(gp)
811330fc:	d0a08417 	ldw	r2,-32240(gp)
81133100:	1000071e 	bne	r2,zero,81133120 <__env_unlock+0x54>
  {
    lockid = -1;
81133104:	00bfffc4 	movi	r2,-1
81133108:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
8113310c:	d0a08517 	ldw	r2,-32236(gp)
81133110:	1009883a 	mov	r4,r2
81133114:	1139f000 	call	81139f00 <OSSemPost>
81133118:	00000106 	br	81133120 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
8113311c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81133120:	e037883a 	mov	sp,fp
81133124:	dfc00117 	ldw	ra,4(sp)
81133128:	df000017 	ldw	fp,0(sp)
8113312c:	dec00204 	addi	sp,sp,8
81133130:	f800283a 	ret

81133134 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81133134:	deffda04 	addi	sp,sp,-152
81133138:	de00012e 	bgeu	sp,et,81133140 <__malloc_lock+0xc>
8113313c:	003b68fa 	trap	3
81133140:	dfc02515 	stw	ra,148(sp)
81133144:	df002415 	stw	fp,144(sp)
81133148:	df002404 	addi	fp,sp,144
8113314c:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133150:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81133154:	d0a08b03 	ldbu	r2,-32212(gp)
81133158:	10803fcc 	andi	r2,r2,255
8113315c:	10800060 	cmpeqi	r2,r2,1
81133160:	10003626 	beq	r2,zero,8113323c <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81133164:	e0bfe104 	addi	r2,fp,-124
81133168:	100b883a 	mov	r5,r2
8113316c:	01003fc4 	movi	r4,255
81133170:	113b6ac0 	call	8113b6ac <OSTaskQuery>
81133174:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81133178:	e0bffe83 	ldbu	r2,-6(fp)
8113317c:	10803fcc 	andi	r2,r2,255
81133180:	1000301e 	bne	r2,zero,81133244 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81133184:	e0bfed83 	ldbu	r2,-74(fp)
81133188:	10803fcc 	andi	r2,r2,255
8113318c:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81133190:	d0a08717 	ldw	r2,-32228(gp)
81133194:	e0fffc04 	addi	r3,fp,-16
81133198:	180b883a 	mov	r5,r3
8113319c:	1009883a 	mov	r4,r2
811331a0:	113a0180 	call	8113a018 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811331a4:	0005303a 	rdctl	r2,status
811331a8:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811331ac:	e0ffe017 	ldw	r3,-128(fp)
811331b0:	00bfff84 	movi	r2,-2
811331b4:	1884703a 	and	r2,r3,r2
811331b8:	1001703a 	wrctl	status,r2
  
  return context;
811331bc:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
811331c0:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
811331c4:	e0bffc0b 	ldhu	r2,-16(fp)
811331c8:	10bfffcc 	andi	r2,r2,65535
811331cc:	10000b1e 	bne	r2,zero,811331fc <__malloc_lock+0xc8>
811331d0:	d0a01717 	ldw	r2,-32676(gp)
811331d4:	e0ffdd17 	ldw	r3,-140(fp)
811331d8:	1880081e 	bne	r3,r2,811331fc <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
811331dc:	d0a08617 	ldw	r2,-32232(gp)
811331e0:	10800044 	addi	r2,r2,1
811331e4:	d0a08615 	stw	r2,-32232(gp)
811331e8:	e0bfdc17 	ldw	r2,-144(fp)
811331ec:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811331f0:	e0bfde17 	ldw	r2,-136(fp)
811331f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
811331f8:	00000e06 	br	81133234 <__malloc_lock+0x100>
811331fc:	e0bfdc17 	ldw	r2,-144(fp)
81133200:	e0bfdf15 	stw	r2,-132(fp)
81133204:	e0bfdf17 	ldw	r2,-132(fp)
81133208:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
8113320c:	d0a08717 	ldw	r2,-32228(gp)
81133210:	e0fffe84 	addi	r3,fp,-6
81133214:	180d883a 	mov	r6,r3
81133218:	000b883a 	mov	r5,zero
8113321c:	1009883a 	mov	r4,r2
81133220:	1139b780 	call	81139b78 <OSSemPend>
    locks  = 1;
81133224:	00800044 	movi	r2,1
81133228:	d0a08615 	stw	r2,-32232(gp)
    lockid = id;
8113322c:	e0bfdd17 	ldw	r2,-140(fp)
81133230:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81133234:	0001883a 	nop
81133238:	00000306 	br	81133248 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
8113323c:	0001883a 	nop
81133240:	00000106 	br	81133248 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81133244:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81133248:	e037883a 	mov	sp,fp
8113324c:	dfc00117 	ldw	ra,4(sp)
81133250:	df000017 	ldw	fp,0(sp)
81133254:	dec00204 	addi	sp,sp,8
81133258:	f800283a 	ret

8113325c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
8113325c:	defff804 	addi	sp,sp,-32
81133260:	de00012e 	bgeu	sp,et,81133268 <__malloc_unlock+0xc>
81133264:	003b68fa 	trap	3
81133268:	dfc00715 	stw	ra,28(sp)
8113326c:	df000615 	stw	fp,24(sp)
81133270:	df000604 	addi	fp,sp,24
81133274:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133278:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
8113327c:	d0a08b03 	ldbu	r2,-32212(gp)
81133280:	10803fcc 	andi	r2,r2,255
81133284:	10800060 	cmpeqi	r2,r2,1
81133288:	10002326 	beq	r2,zero,81133318 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113328c:	0005303a 	rdctl	r2,status
81133290:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133294:	e0fffe17 	ldw	r3,-8(fp)
81133298:	00bfff84 	movi	r2,-2
8113329c:	1884703a 	and	r2,r3,r2
811332a0:	1001703a 	wrctl	status,r2
  
  return context;
811332a4:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
811332a8:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
811332ac:	d0a08617 	ldw	r2,-32232(gp)
811332b0:	1000051e 	bne	r2,zero,811332c8 <__malloc_unlock+0x6c>
811332b4:	e0bffa17 	ldw	r2,-24(fp)
811332b8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811332bc:	e0bffb17 	ldw	r2,-20(fp)
811332c0:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
811332c4:	00001506 	br	8113331c <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
811332c8:	d0a08617 	ldw	r2,-32232(gp)
811332cc:	10bfffc4 	addi	r2,r2,-1
811332d0:	d0a08615 	stw	r2,-32232(gp)
811332d4:	d0a08617 	ldw	r2,-32232(gp)
811332d8:	10000a1e 	bne	r2,zero,81133304 <__malloc_unlock+0xa8>
  {
    lockid = -1;
811332dc:	00bfffc4 	movi	r2,-1
811332e0:	d0a01715 	stw	r2,-32676(gp)
811332e4:	e0bffa17 	ldw	r2,-24(fp)
811332e8:	e0bffc15 	stw	r2,-16(fp)
811332ec:	e0bffc17 	ldw	r2,-16(fp)
811332f0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
811332f4:	d0a08717 	ldw	r2,-32228(gp)
811332f8:	1009883a 	mov	r4,r2
811332fc:	1139f000 	call	81139f00 <OSSemPost>
81133300:	00000606 	br	8113331c <__malloc_unlock+0xc0>
81133304:	e0bffa17 	ldw	r2,-24(fp)
81133308:	e0bffd15 	stw	r2,-12(fp)
8113330c:	e0bffd17 	ldw	r2,-12(fp)
81133310:	1001703a 	wrctl	status,r2
81133314:	00000106 	br	8113331c <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81133318:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8113331c:	e037883a 	mov	sp,fp
81133320:	dfc00117 	ldw	ra,4(sp)
81133324:	df000017 	ldw	fp,0(sp)
81133328:	dec00204 	addi	sp,sp,8
8113332c:	f800283a 	ret

81133330 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81133330:	defff704 	addi	sp,sp,-36
81133334:	de00012e 	bgeu	sp,et,8113333c <OSEventNameGet+0xc>
81133338:	003b68fa 	trap	3
8113333c:	dfc00815 	stw	ra,32(sp)
81133340:	df000715 	stw	fp,28(sp)
81133344:	df000704 	addi	fp,sp,28
81133348:	e13ffd15 	stw	r4,-12(fp)
8113334c:	e17ffe15 	stw	r5,-8(fp)
81133350:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133354:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81133358:	e0bfff17 	ldw	r2,-4(fp)
8113335c:	1000021e 	bne	r2,zero,81133368 <OSEventNameGet+0x38>
        return (0);
81133360:	0005883a 	mov	r2,zero
81133364:	00003706 	br	81133444 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81133368:	e0bffd17 	ldw	r2,-12(fp)
8113336c:	1000051e 	bne	r2,zero,81133384 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81133370:	e0bfff17 	ldw	r2,-4(fp)
81133374:	00c00104 	movi	r3,4
81133378:	10c00005 	stb	r3,0(r2)
        return (0);
8113337c:	0005883a 	mov	r2,zero
81133380:	00003006 	br	81133444 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81133384:	e0bffe17 	ldw	r2,-8(fp)
81133388:	1000051e 	bne	r2,zero,811333a0 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113338c:	e0bfff17 	ldw	r2,-4(fp)
81133390:	00c00304 	movi	r3,12
81133394:	10c00005 	stb	r3,0(r2)
        return (0);
81133398:	0005883a 	mov	r2,zero
8113339c:	00002906 	br	81133444 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811333a0:	d0a09b03 	ldbu	r2,-32148(gp)
811333a4:	10803fcc 	andi	r2,r2,255
811333a8:	10000526 	beq	r2,zero,811333c0 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
811333ac:	e0bfff17 	ldw	r2,-4(fp)
811333b0:	00c00444 	movi	r3,17
811333b4:	10c00005 	stb	r3,0(r2)
        return (0);
811333b8:	0005883a 	mov	r2,zero
811333bc:	00002106 	br	81133444 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
811333c0:	e0bffd17 	ldw	r2,-12(fp)
811333c4:	10800003 	ldbu	r2,0(r2)
811333c8:	10803fcc 	andi	r2,r2,255
811333cc:	10bfffc4 	addi	r2,r2,-1
811333d0:	10800128 	cmpgeui	r2,r2,4
811333d4:	10000526 	beq	r2,zero,811333ec <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
811333d8:	e0bfff17 	ldw	r2,-4(fp)
811333dc:	00c00044 	movi	r3,1
811333e0:	10c00005 	stb	r3,0(r2)
             return (0);
811333e4:	0005883a 	mov	r2,zero
811333e8:	00001606 	br	81133444 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811333ec:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811333f0:	0005303a 	rdctl	r2,status
811333f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811333f8:	e0fffb17 	ldw	r3,-20(fp)
811333fc:	00bfff84 	movi	r2,-2
81133400:	1884703a 	and	r2,r3,r2
81133404:	1001703a 	wrctl	status,r2
  
  return context;
81133408:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
8113340c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81133410:	e0bffd17 	ldw	r2,-12(fp)
81133414:	10800444 	addi	r2,r2,17
81133418:	100b883a 	mov	r5,r2
8113341c:	e13ffe17 	ldw	r4,-8(fp)
81133420:	1134e1c0 	call	81134e1c <OS_StrCopy>
81133424:	e0bffa05 	stb	r2,-24(fp)
81133428:	e0bff917 	ldw	r2,-28(fp)
8113342c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133430:	e0bffc17 	ldw	r2,-16(fp)
81133434:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81133438:	e0bfff17 	ldw	r2,-4(fp)
8113343c:	10000005 	stb	zero,0(r2)
    return (len);
81133440:	e0bffa03 	ldbu	r2,-24(fp)
}
81133444:	e037883a 	mov	sp,fp
81133448:	dfc00117 	ldw	ra,4(sp)
8113344c:	df000017 	ldw	fp,0(sp)
81133450:	dec00204 	addi	sp,sp,8
81133454:	f800283a 	ret

81133458 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81133458:	defff604 	addi	sp,sp,-40
8113345c:	de00012e 	bgeu	sp,et,81133464 <OSEventNameSet+0xc>
81133460:	003b68fa 	trap	3
81133464:	dfc00915 	stw	ra,36(sp)
81133468:	df000815 	stw	fp,32(sp)
8113346c:	df000804 	addi	fp,sp,32
81133470:	e13ffd15 	stw	r4,-12(fp)
81133474:	e17ffe15 	stw	r5,-8(fp)
81133478:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113347c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81133480:	e0bfff17 	ldw	r2,-4(fp)
81133484:	10004026 	beq	r2,zero,81133588 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81133488:	e0bffd17 	ldw	r2,-12(fp)
8113348c:	1000041e 	bne	r2,zero,811334a0 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81133490:	e0bfff17 	ldw	r2,-4(fp)
81133494:	00c00104 	movi	r3,4
81133498:	10c00005 	stb	r3,0(r2)
        return;
8113349c:	00003b06 	br	8113358c <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811334a0:	e0bffe17 	ldw	r2,-8(fp)
811334a4:	1000041e 	bne	r2,zero,811334b8 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811334a8:	e0bfff17 	ldw	r2,-4(fp)
811334ac:	00c00304 	movi	r3,12
811334b0:	10c00005 	stb	r3,0(r2)
        return;
811334b4:	00003506 	br	8113358c <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811334b8:	d0a09b03 	ldbu	r2,-32148(gp)
811334bc:	10803fcc 	andi	r2,r2,255
811334c0:	10000426 	beq	r2,zero,811334d4 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
811334c4:	e0bfff17 	ldw	r2,-4(fp)
811334c8:	00c00484 	movi	r3,18
811334cc:	10c00005 	stb	r3,0(r2)
        return;
811334d0:	00002e06 	br	8113358c <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
811334d4:	e0bffd17 	ldw	r2,-12(fp)
811334d8:	10800003 	ldbu	r2,0(r2)
811334dc:	10803fcc 	andi	r2,r2,255
811334e0:	10bfffc4 	addi	r2,r2,-1
811334e4:	10800128 	cmpgeui	r2,r2,4
811334e8:	10000426 	beq	r2,zero,811334fc <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
811334ec:	e0bfff17 	ldw	r2,-4(fp)
811334f0:	00c00044 	movi	r3,1
811334f4:	10c00005 	stb	r3,0(r2)
             return;
811334f8:	00002406 	br	8113358c <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811334fc:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133500:	0005303a 	rdctl	r2,status
81133504:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133508:	e0fffc17 	ldw	r3,-16(fp)
8113350c:	00bfff84 	movi	r2,-2
81133510:	1884703a 	and	r2,r3,r2
81133514:	1001703a 	wrctl	status,r2
  
  return context;
81133518:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
8113351c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81133520:	e13ffe17 	ldw	r4,-8(fp)
81133524:	1134e980 	call	81134e98 <OS_StrLen>
81133528:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
8113352c:	e0bffa03 	ldbu	r2,-24(fp)
81133530:	10800830 	cmpltui	r2,r2,32
81133534:	1000081e 	bne	r2,zero,81133558 <OSEventNameSet+0x100>
81133538:	e0bff817 	ldw	r2,-32(fp)
8113353c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133540:	e0bff917 	ldw	r2,-28(fp)
81133544:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
81133548:	e0bfff17 	ldw	r2,-4(fp)
8113354c:	00c002c4 	movi	r3,11
81133550:	10c00005 	stb	r3,0(r2)
        return;
81133554:	00000d06 	br	8113358c <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
81133558:	e0bffd17 	ldw	r2,-12(fp)
8113355c:	10800444 	addi	r2,r2,17
81133560:	e17ffe17 	ldw	r5,-8(fp)
81133564:	1009883a 	mov	r4,r2
81133568:	1134e1c0 	call	81134e1c <OS_StrCopy>
8113356c:	e0bff817 	ldw	r2,-32(fp)
81133570:	e0bffb15 	stw	r2,-20(fp)
81133574:	e0bffb17 	ldw	r2,-20(fp)
81133578:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113357c:	e0bfff17 	ldw	r2,-4(fp)
81133580:	10000005 	stb	zero,0(r2)
81133584:	00000106 	br	8113358c <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81133588:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113358c:	e037883a 	mov	sp,fp
81133590:	dfc00117 	ldw	ra,4(sp)
81133594:	df000017 	ldw	fp,0(sp)
81133598:	dec00204 	addi	sp,sp,8
8113359c:	f800283a 	ret

811335a0 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
811335a0:	deffed04 	addi	sp,sp,-76
811335a4:	de00012e 	bgeu	sp,et,811335ac <OSEventPendMulti+0xc>
811335a8:	003b68fa 	trap	3
811335ac:	dfc01215 	stw	ra,72(sp)
811335b0:	df001115 	stw	fp,68(sp)
811335b4:	df001104 	addi	fp,sp,68
811335b8:	e13ffc15 	stw	r4,-16(fp)
811335bc:	e17ffd15 	stw	r5,-12(fp)
811335c0:	e1bffe15 	stw	r6,-8(fp)
811335c4:	3805883a 	mov	r2,r7
811335c8:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
811335cc:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
811335d0:	e0800217 	ldw	r2,8(fp)
811335d4:	1000021e 	bne	r2,zero,811335e0 <OSEventPendMulti+0x40>
        return (0);
811335d8:	0005883a 	mov	r2,zero
811335dc:	00015006 	br	81133b20 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
811335e0:	e0bffc17 	ldw	r2,-16(fp)
811335e4:	1000051e 	bne	r2,zero,811335fc <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
811335e8:	e0800217 	ldw	r2,8(fp)
811335ec:	00c00104 	movi	r3,4
811335f0:	10c00005 	stb	r3,0(r2)
        return (0);
811335f4:	0005883a 	mov	r2,zero
811335f8:	00014906 	br	81133b20 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
811335fc:	e0bffd17 	ldw	r2,-12(fp)
81133600:	1000051e 	bne	r2,zero,81133618 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81133604:	e0800217 	ldw	r2,8(fp)
81133608:	00c00104 	movi	r3,4
8113360c:	10c00005 	stb	r3,0(r2)
        return (0);
81133610:	0005883a 	mov	r2,zero
81133614:	00014206 	br	81133b20 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81133618:	e0bffe17 	ldw	r2,-8(fp)
8113361c:	1000051e 	bne	r2,zero,81133634 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81133620:	e0800217 	ldw	r2,8(fp)
81133624:	00c00104 	movi	r3,4
81133628:	10c00005 	stb	r3,0(r2)
        return (0);
8113362c:	0005883a 	mov	r2,zero
81133630:	00013b06 	br	81133b20 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81133634:	e0bffd17 	ldw	r2,-12(fp)
81133638:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
8113363c:	e0bffc17 	ldw	r2,-16(fp)
81133640:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81133644:	e0bfef17 	ldw	r2,-68(fp)
81133648:	10800017 	ldw	r2,0(r2)
8113364c:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81133650:	00001506 	br	811336a8 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81133654:	e0bff017 	ldw	r2,-64(fp)
81133658:	10800003 	ldbu	r2,0(r2)
8113365c:	10803fcc 	andi	r2,r2,255
81133660:	10c000a0 	cmpeqi	r3,r2,2
81133664:	1800071e 	bne	r3,zero,81133684 <OSEventPendMulti+0xe4>
81133668:	108000e0 	cmpeqi	r2,r2,3
8113366c:	1000071e 	bne	r2,zero,8113368c <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81133670:	e0800217 	ldw	r2,8(fp)
81133674:	00c00044 	movi	r3,1
81133678:	10c00005 	stb	r3,0(r2)
                 return (0);
8113367c:	0005883a 	mov	r2,zero
81133680:	00012706 	br	81133b20 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81133684:	0001883a 	nop
81133688:	00000106 	br	81133690 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8113368c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81133690:	e0bfef17 	ldw	r2,-68(fp)
81133694:	10800104 	addi	r2,r2,4
81133698:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113369c:	e0bfef17 	ldw	r2,-68(fp)
811336a0:	10800017 	ldw	r2,0(r2)
811336a4:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
811336a8:	e0bff017 	ldw	r2,-64(fp)
811336ac:	103fe91e 	bne	r2,zero,81133654 <__reset+0xfb113654>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
811336b0:	d0a09b03 	ldbu	r2,-32148(gp)
811336b4:	10803fcc 	andi	r2,r2,255
811336b8:	10000526 	beq	r2,zero,811336d0 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
811336bc:	e0800217 	ldw	r2,8(fp)
811336c0:	00c00084 	movi	r3,2
811336c4:	10c00005 	stb	r3,0(r2)
        return (0);
811336c8:	0005883a 	mov	r2,zero
811336cc:	00011406 	br	81133b20 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
811336d0:	d0a08903 	ldbu	r2,-32220(gp)
811336d4:	10803fcc 	andi	r2,r2,255
811336d8:	10000526 	beq	r2,zero,811336f0 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
811336dc:	e0800217 	ldw	r2,8(fp)
811336e0:	00c00344 	movi	r3,13
811336e4:	10c00005 	stb	r3,0(r2)
        return (0);
811336e8:	0005883a 	mov	r2,zero
811336ec:	00010c06 	br	81133b20 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811336f0:	0005303a 	rdctl	r2,status
811336f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811336f8:	e0fffb17 	ldw	r3,-20(fp)
811336fc:	00bfff84 	movi	r2,-2
81133700:	1884703a 	and	r2,r3,r2
81133704:	1001703a 	wrctl	status,r2
  
  return context;
81133708:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113370c:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81133710:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81133714:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81133718:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
8113371c:	e0bffc17 	ldw	r2,-16(fp)
81133720:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81133724:	e0bfef17 	ldw	r2,-68(fp)
81133728:	10800017 	ldw	r2,0(r2)
8113372c:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81133730:	00006406 	br	811338c4 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81133734:	e0bff017 	ldw	r2,-64(fp)
81133738:	10800003 	ldbu	r2,0(r2)
8113373c:	10803fcc 	andi	r2,r2,255
81133740:	10c000a0 	cmpeqi	r3,r2,2
81133744:	18001f1e 	bne	r3,zero,811337c4 <OSEventPendMulti+0x224>
81133748:	108000e0 	cmpeqi	r2,r2,3
8113374c:	10004c26 	beq	r2,zero,81133880 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81133750:	e0bff017 	ldw	r2,-64(fp)
81133754:	1080020b 	ldhu	r2,8(r2)
81133758:	10bfffcc 	andi	r2,r2,65535
8113375c:	10001526 	beq	r2,zero,811337b4 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81133760:	e0bff017 	ldw	r2,-64(fp)
81133764:	1080020b 	ldhu	r2,8(r2)
81133768:	10bfffc4 	addi	r2,r2,-1
8113376c:	1007883a 	mov	r3,r2
81133770:	e0bff017 	ldw	r2,-64(fp)
81133774:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81133778:	e0bffd17 	ldw	r2,-12(fp)
8113377c:	10c00104 	addi	r3,r2,4
81133780:	e0fffd15 	stw	r3,-12(fp)
81133784:	e0fff017 	ldw	r3,-64(fp)
81133788:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8113378c:	00800044 	movi	r2,1
81133790:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81133794:	e0bffe17 	ldw	r2,-8(fp)
81133798:	10c00104 	addi	r3,r2,4
8113379c:	e0fffe15 	stw	r3,-8(fp)
811337a0:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
811337a4:	e0bff18b 	ldhu	r2,-58(fp)
811337a8:	10800044 	addi	r2,r2,1
811337ac:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
811337b0:	00003e06 	br	811338ac <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
811337b4:	e0bff203 	ldbu	r2,-56(fp)
811337b8:	10800054 	ori	r2,r2,1
811337bc:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811337c0:	00003a06 	br	811338ac <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
811337c4:	e0bff017 	ldw	r2,-64(fp)
811337c8:	10800117 	ldw	r2,4(r2)
811337cc:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
811337d0:	e0bff517 	ldw	r2,-44(fp)
811337d4:	1080058b 	ldhu	r2,22(r2)
811337d8:	10bfffcc 	andi	r2,r2,65535
811337dc:	10002426 	beq	r2,zero,81133870 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
811337e0:	e0bffe17 	ldw	r2,-8(fp)
811337e4:	10c00104 	addi	r3,r2,4
811337e8:	e0fffe15 	stw	r3,-8(fp)
811337ec:	e0fff517 	ldw	r3,-44(fp)
811337f0:	18c00417 	ldw	r3,16(r3)
811337f4:	19400104 	addi	r5,r3,4
811337f8:	e13ff517 	ldw	r4,-44(fp)
811337fc:	21400415 	stw	r5,16(r4)
81133800:	18c00017 	ldw	r3,0(r3)
81133804:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81133808:	e0bff517 	ldw	r2,-44(fp)
8113380c:	10c00417 	ldw	r3,16(r2)
81133810:	e0bff517 	ldw	r2,-44(fp)
81133814:	10800217 	ldw	r2,8(r2)
81133818:	1880041e 	bne	r3,r2,8113382c <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8113381c:	e0bff517 	ldw	r2,-44(fp)
81133820:	10c00117 	ldw	r3,4(r2)
81133824:	e0bff517 	ldw	r2,-44(fp)
81133828:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8113382c:	e0bff517 	ldw	r2,-44(fp)
81133830:	1080058b 	ldhu	r2,22(r2)
81133834:	10bfffc4 	addi	r2,r2,-1
81133838:	1007883a 	mov	r3,r2
8113383c:	e0bff517 	ldw	r2,-44(fp)
81133840:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81133844:	e0bffd17 	ldw	r2,-12(fp)
81133848:	10c00104 	addi	r3,r2,4
8113384c:	e0fffd15 	stw	r3,-12(fp)
81133850:	e0fff017 	ldw	r3,-64(fp)
81133854:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
81133858:	00800044 	movi	r2,1
8113385c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81133860:	e0bff18b 	ldhu	r2,-58(fp)
81133864:	10800044 	addi	r2,r2,1
81133868:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8113386c:	00000f06 	br	811338ac <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81133870:	e0bff203 	ldbu	r2,-56(fp)
81133874:	10800114 	ori	r2,r2,4
81133878:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113387c:	00000b06 	br	811338ac <OSEventPendMulti+0x30c>
81133880:	e0bff317 	ldw	r2,-52(fp)
81133884:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133888:	e0bff417 	ldw	r2,-48(fp)
8113388c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81133890:	e0bffd17 	ldw	r2,-12(fp)
81133894:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81133898:	e0800217 	ldw	r2,8(fp)
8113389c:	00c00044 	movi	r3,1
811338a0:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
811338a4:	e0bff18b 	ldhu	r2,-58(fp)
811338a8:	00009d06 	br	81133b20 <OSEventPendMulti+0x580>
        }
        pevents++;
811338ac:	e0bfef17 	ldw	r2,-68(fp)
811338b0:	10800104 	addi	r2,r2,4
811338b4:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811338b8:	e0bfef17 	ldw	r2,-68(fp)
811338bc:	10800017 	ldw	r2,0(r2)
811338c0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811338c4:	e0bff017 	ldw	r2,-64(fp)
811338c8:	103f9a1e 	bne	r2,zero,81133734 <__reset+0xfb113734>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
811338cc:	e0bff103 	ldbu	r2,-60(fp)
811338d0:	10800058 	cmpnei	r2,r2,1
811338d4:	10000a1e 	bne	r2,zero,81133900 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
811338d8:	e0bffd17 	ldw	r2,-12(fp)
811338dc:	10000015 	stw	zero,0(r2)
811338e0:	e0bff317 	ldw	r2,-52(fp)
811338e4:	e0bff615 	stw	r2,-40(fp)
811338e8:	e0bff617 	ldw	r2,-40(fp)
811338ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
811338f0:	e0800217 	ldw	r2,8(fp)
811338f4:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
811338f8:	e0bff18b 	ldhu	r2,-58(fp)
811338fc:	00008806 	br	81133b20 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81133900:	d0a09c17 	ldw	r2,-32144(gp)
81133904:	d0e09c17 	ldw	r3,-32144(gp)
81133908:	19000c03 	ldbu	r4,48(r3)
8113390c:	e0fff203 	ldbu	r3,-56(fp)
81133910:	20c6b03a 	or	r3,r4,r3
81133914:	1809883a 	mov	r4,r3
81133918:	00ffe004 	movi	r3,-128
8113391c:	20c6b03a 	or	r3,r4,r3
81133920:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81133924:	d0a09c17 	ldw	r2,-32144(gp)
81133928:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8113392c:	d0a09c17 	ldw	r2,-32144(gp)
81133930:	e0ffff0b 	ldhu	r3,-4(fp)
81133934:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81133938:	e13ffc17 	ldw	r4,-16(fp)
8113393c:	11344c40 	call	811344c4 <OS_EventTaskWaitMulti>
81133940:	e0bff317 	ldw	r2,-52(fp)
81133944:	e0bff915 	stw	r2,-28(fp)
81133948:	e0bff917 	ldw	r2,-28(fp)
8113394c:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81133950:	1134cc80 	call	81134cc8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133954:	0005303a 	rdctl	r2,status
81133958:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113395c:	e0fff717 	ldw	r3,-36(fp)
81133960:	00bfff84 	movi	r2,-2
81133964:	1884703a 	and	r2,r3,r2
81133968:	1001703a 	wrctl	status,r2
  
  return context;
8113396c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81133970:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81133974:	d0a09c17 	ldw	r2,-32144(gp)
81133978:	10800c43 	ldbu	r2,49(r2)
8113397c:	10803fcc 	andi	r2,r2,255
81133980:	10000226 	beq	r2,zero,8113398c <OSEventPendMulti+0x3ec>
81133984:	108000a0 	cmpeqi	r2,r2,2
81133988:	10001826 	beq	r2,zero,811339ec <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113398c:	d0a09c17 	ldw	r2,-32144(gp)
81133990:	10800717 	ldw	r2,28(r2)
81133994:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81133998:	e0bff017 	ldw	r2,-64(fp)
8113399c:	10000b26 	beq	r2,zero,811339cc <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
811339a0:	e0bffd17 	ldw	r2,-12(fp)
811339a4:	10c00104 	addi	r3,r2,4
811339a8:	e0fffd15 	stw	r3,-12(fp)
811339ac:	e0fff017 	ldw	r3,-64(fp)
811339b0:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
811339b4:	e0bffd17 	ldw	r2,-12(fp)
811339b8:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
811339bc:	e0bff18b 	ldhu	r2,-58(fp)
811339c0:	10800044 	addi	r2,r2,1
811339c4:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
811339c8:	00000d06 	br	81133a00 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
811339cc:	d0a09c17 	ldw	r2,-32144(gp)
811339d0:	00c00044 	movi	r3,1
811339d4:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811339d8:	d0a09c17 	ldw	r2,-32144(gp)
811339dc:	e17ffc17 	ldw	r5,-16(fp)
811339e0:	1009883a 	mov	r4,r2
811339e4:	11346dc0 	call	811346dc <OS_EventTaskRemoveMulti>
             }
			 break;
811339e8:	00000506 	br	81133a00 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811339ec:	d0a09c17 	ldw	r2,-32144(gp)
811339f0:	e17ffc17 	ldw	r5,-16(fp)
811339f4:	1009883a 	mov	r4,r2
811339f8:	11346dc0 	call	811346dc <OS_EventTaskRemoveMulti>
             break;
811339fc:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81133a00:	d0a09c17 	ldw	r2,-32144(gp)
81133a04:	10800c43 	ldbu	r2,49(r2)
81133a08:	10803fcc 	andi	r2,r2,255
81133a0c:	10000326 	beq	r2,zero,81133a1c <OSEventPendMulti+0x47c>
81133a10:	108000a0 	cmpeqi	r2,r2,2
81133a14:	1000231e 	bne	r2,zero,81133aa4 <OSEventPendMulti+0x504>
81133a18:	00002a06 	br	81133ac4 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81133a1c:	e0bff017 	ldw	r2,-64(fp)
81133a20:	10800003 	ldbu	r2,0(r2)
81133a24:	10803fcc 	andi	r2,r2,255
81133a28:	0080100e 	bge	zero,r2,81133a6c <OSEventPendMulti+0x4cc>
81133a2c:	10c000d0 	cmplti	r3,r2,3
81133a30:	1800071e 	bne	r3,zero,81133a50 <OSEventPendMulti+0x4b0>
81133a34:	108000e0 	cmpeqi	r2,r2,3
81133a38:	10000c26 	beq	r2,zero,81133a6c <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81133a3c:	e0bffe17 	ldw	r2,-8(fp)
81133a40:	10c00104 	addi	r3,r2,4
81133a44:	e0fffe15 	stw	r3,-8(fp)
81133a48:	10000015 	stw	zero,0(r2)
                      break;
81133a4c:	00001206 	br	81133a98 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81133a50:	e0bffe17 	ldw	r2,-8(fp)
81133a54:	10c00104 	addi	r3,r2,4
81133a58:	e0fffe15 	stw	r3,-8(fp)
81133a5c:	d0e09c17 	ldw	r3,-32144(gp)
81133a60:	18c00917 	ldw	r3,36(r3)
81133a64:	10c00015 	stw	r3,0(r2)
                      break;
81133a68:	00000b06 	br	81133a98 <OSEventPendMulti+0x4f8>
81133a6c:	e0bff317 	ldw	r2,-52(fp)
81133a70:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133a74:	e0bff817 	ldw	r2,-32(fp)
81133a78:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81133a7c:	e0bffd17 	ldw	r2,-12(fp)
81133a80:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81133a84:	e0800217 	ldw	r2,8(fp)
81133a88:	00c00044 	movi	r3,1
81133a8c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81133a90:	e0bff18b 	ldhu	r2,-58(fp)
81133a94:	00002206 	br	81133b20 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81133a98:	e0800217 	ldw	r2,8(fp)
81133a9c:	10000005 	stb	zero,0(r2)
             break;
81133aa0:	00001006 	br	81133ae4 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81133aa4:	e0bffe17 	ldw	r2,-8(fp)
81133aa8:	10c00104 	addi	r3,r2,4
81133aac:	e0fffe15 	stw	r3,-8(fp)
81133ab0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81133ab4:	e0800217 	ldw	r2,8(fp)
81133ab8:	00c00384 	movi	r3,14
81133abc:	10c00005 	stb	r3,0(r2)
             break;
81133ac0:	00000806 	br	81133ae4 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81133ac4:	e0bffe17 	ldw	r2,-8(fp)
81133ac8:	10c00104 	addi	r3,r2,4
81133acc:	e0fffe15 	stw	r3,-8(fp)
81133ad0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81133ad4:	e0800217 	ldw	r2,8(fp)
81133ad8:	00c00284 	movi	r3,10
81133adc:	10c00005 	stb	r3,0(r2)
             break;
81133ae0:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81133ae4:	d0a09c17 	ldw	r2,-32144(gp)
81133ae8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81133aec:	d0a09c17 	ldw	r2,-32144(gp)
81133af0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81133af4:	d0a09c17 	ldw	r2,-32144(gp)
81133af8:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81133afc:	d0a09c17 	ldw	r2,-32144(gp)
81133b00:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81133b04:	d0a09c17 	ldw	r2,-32144(gp)
81133b08:	10000915 	stw	zero,36(r2)
81133b0c:	e0bff317 	ldw	r2,-52(fp)
81133b10:	e0bffa15 	stw	r2,-24(fp)
81133b14:	e0bffa17 	ldw	r2,-24(fp)
81133b18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81133b1c:	e0bff18b 	ldhu	r2,-58(fp)
}
81133b20:	e037883a 	mov	sp,fp
81133b24:	dfc00117 	ldw	ra,4(sp)
81133b28:	df000017 	ldw	fp,0(sp)
81133b2c:	dec00204 	addi	sp,sp,8
81133b30:	f800283a 	ret

81133b34 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81133b34:	defffe04 	addi	sp,sp,-8
81133b38:	de00012e 	bgeu	sp,et,81133b40 <OSInit+0xc>
81133b3c:	003b68fa 	trap	3
81133b40:	dfc00115 	stw	ra,4(sp)
81133b44:	df000015 	stw	fp,0(sp)
81133b48:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81133b4c:	1145e840 	call	81145e84 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81133b50:	113493c0 	call	8113493c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81133b54:	113498c0 	call	8113498c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81133b58:	1134b100 	call	81134b10 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81133b5c:	11348540 	call	81134854 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81133b60:	1136ad00 	call	81136ad0 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81133b64:	11374180 	call	81137418 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81133b68:	11396e80 	call	811396e8 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81133b6c:	1134a000 	call	81134a00 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81133b70:	1134a880 	call	81134a88 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81133b74:	113c8d80 	call	8113c8d8 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81133b78:	1145eb00 	call	81145eb0 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81133b7c:	11353ec0 	call	811353ec <OSDebugInit>
#endif
}
81133b80:	0001883a 	nop
81133b84:	e037883a 	mov	sp,fp
81133b88:	dfc00117 	ldw	ra,4(sp)
81133b8c:	df000017 	ldw	fp,0(sp)
81133b90:	dec00204 	addi	sp,sp,8
81133b94:	f800283a 	ret

81133b98 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81133b98:	deffff04 	addi	sp,sp,-4
81133b9c:	de00012e 	bgeu	sp,et,81133ba4 <OSIntEnter+0xc>
81133ba0:	003b68fa 	trap	3
81133ba4:	df000015 	stw	fp,0(sp)
81133ba8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81133bac:	d0a08b03 	ldbu	r2,-32212(gp)
81133bb0:	10803fcc 	andi	r2,r2,255
81133bb4:	10800058 	cmpnei	r2,r2,1
81133bb8:	1000071e 	bne	r2,zero,81133bd8 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81133bbc:	d0a09b03 	ldbu	r2,-32148(gp)
81133bc0:	10803fcc 	andi	r2,r2,255
81133bc4:	10803fe0 	cmpeqi	r2,r2,255
81133bc8:	1000031e 	bne	r2,zero,81133bd8 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81133bcc:	d0a09b03 	ldbu	r2,-32148(gp)
81133bd0:	10800044 	addi	r2,r2,1
81133bd4:	d0a09b05 	stb	r2,-32148(gp)
        }
    }
}
81133bd8:	0001883a 	nop
81133bdc:	e037883a 	mov	sp,fp
81133be0:	df000017 	ldw	fp,0(sp)
81133be4:	dec00104 	addi	sp,sp,4
81133be8:	f800283a 	ret

81133bec <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81133bec:	defffb04 	addi	sp,sp,-20
81133bf0:	de00012e 	bgeu	sp,et,81133bf8 <OSIntExit+0xc>
81133bf4:	003b68fa 	trap	3
81133bf8:	dfc00415 	stw	ra,16(sp)
81133bfc:	df000315 	stw	fp,12(sp)
81133c00:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81133c04:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81133c08:	d0a08b03 	ldbu	r2,-32212(gp)
81133c0c:	10803fcc 	andi	r2,r2,255
81133c10:	10800058 	cmpnei	r2,r2,1
81133c14:	10002f1e 	bne	r2,zero,81133cd4 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133c18:	0005303a 	rdctl	r2,status
81133c1c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133c20:	e0ffff17 	ldw	r3,-4(fp)
81133c24:	00bfff84 	movi	r2,-2
81133c28:	1884703a 	and	r2,r3,r2
81133c2c:	1001703a 	wrctl	status,r2
  
  return context;
81133c30:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81133c34:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81133c38:	d0a09b03 	ldbu	r2,-32148(gp)
81133c3c:	10803fcc 	andi	r2,r2,255
81133c40:	10000326 	beq	r2,zero,81133c50 <OSIntExit+0x64>
            OSIntNesting--;
81133c44:	d0a09b03 	ldbu	r2,-32148(gp)
81133c48:	10bfffc4 	addi	r2,r2,-1
81133c4c:	d0a09b05 	stb	r2,-32148(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81133c50:	d0a09b03 	ldbu	r2,-32148(gp)
81133c54:	10803fcc 	andi	r2,r2,255
81133c58:	10001a1e 	bne	r2,zero,81133cc4 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81133c5c:	d0a08903 	ldbu	r2,-32220(gp)
81133c60:	10803fcc 	andi	r2,r2,255
81133c64:	1000171e 	bne	r2,zero,81133cc4 <OSIntExit+0xd8>
                OS_SchedNew();
81133c68:	1134da00 	call	81134da0 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81133c6c:	d0e08d83 	ldbu	r3,-32202(gp)
81133c70:	d0a08dc3 	ldbu	r2,-32201(gp)
81133c74:	18c03fcc 	andi	r3,r3,255
81133c78:	10803fcc 	andi	r2,r2,255
81133c7c:	18801126 	beq	r3,r2,81133cc4 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81133c80:	d0a08d83 	ldbu	r2,-32202(gp)
81133c84:	10c03fcc 	andi	r3,r2,255
81133c88:	00a045b4 	movhi	r2,33046
81133c8c:	109b0304 	addi	r2,r2,27660
81133c90:	18c7883a 	add	r3,r3,r3
81133c94:	18c7883a 	add	r3,r3,r3
81133c98:	10c5883a 	add	r2,r2,r3
81133c9c:	10800017 	ldw	r2,0(r2)
81133ca0:	d0a09615 	stw	r2,-32168(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81133ca4:	d0a09617 	ldw	r2,-32168(gp)
81133ca8:	10c00e17 	ldw	r3,56(r2)
81133cac:	18c00044 	addi	r3,r3,1
81133cb0:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81133cb4:	d0a09017 	ldw	r2,-32192(gp)
81133cb8:	10800044 	addi	r2,r2,1
81133cbc:	d0a09015 	stw	r2,-32192(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81133cc0:	1145b440 	call	81145b44 <OSCtxSw>
81133cc4:	e0bffd17 	ldw	r2,-12(fp)
81133cc8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133ccc:	e0bffe17 	ldw	r2,-8(fp)
81133cd0:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81133cd4:	0001883a 	nop
81133cd8:	e037883a 	mov	sp,fp
81133cdc:	dfc00117 	ldw	ra,4(sp)
81133ce0:	df000017 	ldw	fp,0(sp)
81133ce4:	dec00204 	addi	sp,sp,8
81133ce8:	f800283a 	ret

81133cec <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81133cec:	defffc04 	addi	sp,sp,-16
81133cf0:	de00012e 	bgeu	sp,et,81133cf8 <OSSchedLock+0xc>
81133cf4:	003b68fa 	trap	3
81133cf8:	df000315 	stw	fp,12(sp)
81133cfc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133d00:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81133d04:	d0a08b03 	ldbu	r2,-32212(gp)
81133d08:	10803fcc 	andi	r2,r2,255
81133d0c:	10800058 	cmpnei	r2,r2,1
81133d10:	1000161e 	bne	r2,zero,81133d6c <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133d14:	0005303a 	rdctl	r2,status
81133d18:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133d1c:	e0ffff17 	ldw	r3,-4(fp)
81133d20:	00bfff84 	movi	r2,-2
81133d24:	1884703a 	and	r2,r3,r2
81133d28:	1001703a 	wrctl	status,r2
  
  return context;
81133d2c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81133d30:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81133d34:	d0a09b03 	ldbu	r2,-32148(gp)
81133d38:	10803fcc 	andi	r2,r2,255
81133d3c:	1000071e 	bne	r2,zero,81133d5c <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81133d40:	d0a08903 	ldbu	r2,-32220(gp)
81133d44:	10803fcc 	andi	r2,r2,255
81133d48:	10803fe0 	cmpeqi	r2,r2,255
81133d4c:	1000031e 	bne	r2,zero,81133d5c <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81133d50:	d0a08903 	ldbu	r2,-32220(gp)
81133d54:	10800044 	addi	r2,r2,1
81133d58:	d0a08905 	stb	r2,-32220(gp)
81133d5c:	e0bffd17 	ldw	r2,-12(fp)
81133d60:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133d64:	e0bffe17 	ldw	r2,-8(fp)
81133d68:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81133d6c:	0001883a 	nop
81133d70:	e037883a 	mov	sp,fp
81133d74:	df000017 	ldw	fp,0(sp)
81133d78:	dec00104 	addi	sp,sp,4
81133d7c:	f800283a 	ret

81133d80 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81133d80:	defff804 	addi	sp,sp,-32
81133d84:	de00012e 	bgeu	sp,et,81133d8c <OSSchedUnlock+0xc>
81133d88:	003b68fa 	trap	3
81133d8c:	dfc00715 	stw	ra,28(sp)
81133d90:	df000615 	stw	fp,24(sp)
81133d94:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81133d98:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81133d9c:	d0a08b03 	ldbu	r2,-32212(gp)
81133da0:	10803fcc 	andi	r2,r2,255
81133da4:	10800058 	cmpnei	r2,r2,1
81133da8:	1000281e 	bne	r2,zero,81133e4c <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133dac:	0005303a 	rdctl	r2,status
81133db0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133db4:	e0ffff17 	ldw	r3,-4(fp)
81133db8:	00bfff84 	movi	r2,-2
81133dbc:	1884703a 	and	r2,r3,r2
81133dc0:	1001703a 	wrctl	status,r2
  
  return context;
81133dc4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81133dc8:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81133dcc:	d0a08903 	ldbu	r2,-32220(gp)
81133dd0:	10803fcc 	andi	r2,r2,255
81133dd4:	10001926 	beq	r2,zero,81133e3c <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81133dd8:	d0a08903 	ldbu	r2,-32220(gp)
81133ddc:	10bfffc4 	addi	r2,r2,-1
81133de0:	d0a08905 	stb	r2,-32220(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81133de4:	d0a08903 	ldbu	r2,-32220(gp)
81133de8:	10803fcc 	andi	r2,r2,255
81133dec:	10000e1e 	bne	r2,zero,81133e28 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81133df0:	d0a09b03 	ldbu	r2,-32148(gp)
81133df4:	10803fcc 	andi	r2,r2,255
81133df8:	1000061e 	bne	r2,zero,81133e14 <OSSchedUnlock+0x94>
81133dfc:	e0bffa17 	ldw	r2,-24(fp)
81133e00:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133e04:	e0bffb17 	ldw	r2,-20(fp)
81133e08:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81133e0c:	1134cc80 	call	81134cc8 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81133e10:	00000e06 	br	81133e4c <OSSchedUnlock+0xcc>
81133e14:	e0bffa17 	ldw	r2,-24(fp)
81133e18:	e0bffc15 	stw	r2,-16(fp)
81133e1c:	e0bffc17 	ldw	r2,-16(fp)
81133e20:	1001703a 	wrctl	status,r2
81133e24:	00000906 	br	81133e4c <OSSchedUnlock+0xcc>
81133e28:	e0bffa17 	ldw	r2,-24(fp)
81133e2c:	e0bffd15 	stw	r2,-12(fp)
81133e30:	e0bffd17 	ldw	r2,-12(fp)
81133e34:	1001703a 	wrctl	status,r2
81133e38:	00000406 	br	81133e4c <OSSchedUnlock+0xcc>
81133e3c:	e0bffa17 	ldw	r2,-24(fp)
81133e40:	e0bffe15 	stw	r2,-8(fp)
81133e44:	e0bffe17 	ldw	r2,-8(fp)
81133e48:	1001703a 	wrctl	status,r2
81133e4c:	0001883a 	nop
81133e50:	e037883a 	mov	sp,fp
81133e54:	dfc00117 	ldw	ra,4(sp)
81133e58:	df000017 	ldw	fp,0(sp)
81133e5c:	dec00204 	addi	sp,sp,8
81133e60:	f800283a 	ret

81133e64 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81133e64:	defffe04 	addi	sp,sp,-8
81133e68:	de00012e 	bgeu	sp,et,81133e70 <OSStart+0xc>
81133e6c:	003b68fa 	trap	3
81133e70:	dfc00115 	stw	ra,4(sp)
81133e74:	df000015 	stw	fp,0(sp)
81133e78:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81133e7c:	d0a08b03 	ldbu	r2,-32212(gp)
81133e80:	10803fcc 	andi	r2,r2,255
81133e84:	10000f1e 	bne	r2,zero,81133ec4 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81133e88:	1134da00 	call	81134da0 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81133e8c:	d0a08d83 	ldbu	r2,-32202(gp)
81133e90:	d0a08dc5 	stb	r2,-32201(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81133e94:	d0a08d83 	ldbu	r2,-32202(gp)
81133e98:	10c03fcc 	andi	r3,r2,255
81133e9c:	00a045b4 	movhi	r2,33046
81133ea0:	109b0304 	addi	r2,r2,27660
81133ea4:	18c7883a 	add	r3,r3,r3
81133ea8:	18c7883a 	add	r3,r3,r3
81133eac:	10c5883a 	add	r2,r2,r3
81133eb0:	10800017 	ldw	r2,0(r2)
81133eb4:	d0a09615 	stw	r2,-32168(gp)
        OSTCBCur      = OSTCBHighRdy;
81133eb8:	d0a09617 	ldw	r2,-32168(gp)
81133ebc:	d0a09c15 	stw	r2,-32144(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81133ec0:	1145be00 	call	81145be0 <OSStartHighRdy>
    }
}
81133ec4:	0001883a 	nop
81133ec8:	e037883a 	mov	sp,fp
81133ecc:	dfc00117 	ldw	ra,4(sp)
81133ed0:	df000017 	ldw	fp,0(sp)
81133ed4:	dec00204 	addi	sp,sp,8
81133ed8:	f800283a 	ret

81133edc <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81133edc:	defff904 	addi	sp,sp,-28
81133ee0:	de00012e 	bgeu	sp,et,81133ee8 <OSStatInit+0xc>
81133ee4:	003b68fa 	trap	3
81133ee8:	dfc00615 	stw	ra,24(sp)
81133eec:	df000515 	stw	fp,20(sp)
81133ef0:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133ef4:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81133ef8:	01000084 	movi	r4,2
81133efc:	113b8500 	call	8113b850 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133f00:	0005303a 	rdctl	r2,status
81133f04:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133f08:	e0fffc17 	ldw	r3,-16(fp)
81133f0c:	00bfff84 	movi	r2,-2
81133f10:	1884703a 	and	r2,r3,r2
81133f14:	1001703a 	wrctl	status,r2
  
  return context;
81133f18:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81133f1c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81133f20:	d0208c15 	stw	zero,-32208(gp)
81133f24:	e0bffb17 	ldw	r2,-20(fp)
81133f28:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133f2c:	e0bffd17 	ldw	r2,-12(fp)
81133f30:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81133f34:	01001904 	movi	r4,100
81133f38:	113b8500 	call	8113b850 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133f3c:	0005303a 	rdctl	r2,status
81133f40:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133f44:	e0fffe17 	ldw	r3,-8(fp)
81133f48:	00bfff84 	movi	r2,-2
81133f4c:	1884703a 	and	r2,r3,r2
81133f50:	1001703a 	wrctl	status,r2
  
  return context;
81133f54:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81133f58:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81133f5c:	d0a08c17 	ldw	r2,-32208(gp)
81133f60:	d0a09215 	stw	r2,-32184(gp)
    OSStatRdy    = OS_TRUE;
81133f64:	00800044 	movi	r2,1
81133f68:	d0a0a105 	stb	r2,-32124(gp)
81133f6c:	e0bffb17 	ldw	r2,-20(fp)
81133f70:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133f74:	e0bfff17 	ldw	r2,-4(fp)
81133f78:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81133f7c:	0001883a 	nop
81133f80:	e037883a 	mov	sp,fp
81133f84:	dfc00117 	ldw	ra,4(sp)
81133f88:	df000017 	ldw	fp,0(sp)
81133f8c:	dec00204 	addi	sp,sp,8
81133f90:	f800283a 	ret

81133f94 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81133f94:	defff704 	addi	sp,sp,-36
81133f98:	de00012e 	bgeu	sp,et,81133fa0 <OSTimeTick+0xc>
81133f9c:	003b68fa 	trap	3
81133fa0:	dfc00815 	stw	ra,32(sp)
81133fa4:	df000715 	stw	fp,28(sp)
81133fa8:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81133fac:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81133fb0:	1145e300 	call	81145e30 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133fb4:	0005303a 	rdctl	r2,status
81133fb8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133fbc:	e0fffd17 	ldw	r3,-12(fp)
81133fc0:	00bfff84 	movi	r2,-2
81133fc4:	1884703a 	and	r2,r3,r2
81133fc8:	1001703a 	wrctl	status,r2
  
  return context;
81133fcc:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81133fd0:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81133fd4:	d0a09e17 	ldw	r2,-32136(gp)
81133fd8:	10800044 	addi	r2,r2,1
81133fdc:	d0a09e15 	stw	r2,-32136(gp)
81133fe0:	e0bffb17 	ldw	r2,-20(fp)
81133fe4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133fe8:	e0bfff17 	ldw	r2,-4(fp)
81133fec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81133ff0:	d0a08b03 	ldbu	r2,-32212(gp)
81133ff4:	10803fcc 	andi	r2,r2,255
81133ff8:	10800058 	cmpnei	r2,r2,1
81133ffc:	10006a1e 	bne	r2,zero,811341a8 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81134000:	d0a08f03 	ldbu	r2,-32196(gp)
81134004:	10803fcc 	andi	r2,r2,255
81134008:	10c00060 	cmpeqi	r3,r2,1
8113400c:	1800061e 	bne	r3,zero,81134028 <OSTimeTick+0x94>
81134010:	10c000a0 	cmpeqi	r3,r2,2
81134014:	1800061e 	bne	r3,zero,81134030 <OSTimeTick+0x9c>
81134018:	10000a1e 	bne	r2,zero,81134044 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
8113401c:	00800044 	movi	r2,1
81134020:	e0bffa05 	stb	r2,-24(fp)
                 break;
81134024:	00000b06 	br	81134054 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81134028:	e03ffa05 	stb	zero,-24(fp)
                 break;
8113402c:	00000906 	br	81134054 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81134030:	00800044 	movi	r2,1
81134034:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81134038:	00800044 	movi	r2,1
8113403c:	d0a08f05 	stb	r2,-32196(gp)
                 break;
81134040:	00000406 	br	81134054 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81134044:	00800044 	movi	r2,1
81134048:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
8113404c:	d0208f05 	stb	zero,-32196(gp)
                 break;
81134050:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81134054:	e0bffa03 	ldbu	r2,-24(fp)
81134058:	10005226 	beq	r2,zero,811341a4 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
8113405c:	d0a08e17 	ldw	r2,-32200(gp)
81134060:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81134064:	00004906 	br	8113418c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134068:	0005303a 	rdctl	r2,status
8113406c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134070:	e0fffc17 	ldw	r3,-16(fp)
81134074:	00bfff84 	movi	r2,-2
81134078:	1884703a 	and	r2,r3,r2
8113407c:	1001703a 	wrctl	status,r2
  
  return context;
81134080:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81134084:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81134088:	e0bff917 	ldw	r2,-28(fp)
8113408c:	10800b8b 	ldhu	r2,46(r2)
81134090:	10bfffcc 	andi	r2,r2,65535
81134094:	10003626 	beq	r2,zero,81134170 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81134098:	e0bff917 	ldw	r2,-28(fp)
8113409c:	10800b8b 	ldhu	r2,46(r2)
811340a0:	10bfffc4 	addi	r2,r2,-1
811340a4:	1007883a 	mov	r3,r2
811340a8:	e0bff917 	ldw	r2,-28(fp)
811340ac:	10c00b8d 	sth	r3,46(r2)
811340b0:	e0bff917 	ldw	r2,-28(fp)
811340b4:	10800b8b 	ldhu	r2,46(r2)
811340b8:	10bfffcc 	andi	r2,r2,65535
811340bc:	10002c1e 	bne	r2,zero,81134170 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
811340c0:	e0bff917 	ldw	r2,-28(fp)
811340c4:	10800c03 	ldbu	r2,48(r2)
811340c8:	10803fcc 	andi	r2,r2,255
811340cc:	10800dcc 	andi	r2,r2,55
811340d0:	10000b26 	beq	r2,zero,81134100 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
811340d4:	e0bff917 	ldw	r2,-28(fp)
811340d8:	10c00c03 	ldbu	r3,48(r2)
811340dc:	00bff204 	movi	r2,-56
811340e0:	1884703a 	and	r2,r3,r2
811340e4:	1007883a 	mov	r3,r2
811340e8:	e0bff917 	ldw	r2,-28(fp)
811340ec:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
811340f0:	e0bff917 	ldw	r2,-28(fp)
811340f4:	00c00044 	movi	r3,1
811340f8:	10c00c45 	stb	r3,49(r2)
811340fc:	00000206 	br	81134108 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81134100:	e0bff917 	ldw	r2,-28(fp)
81134104:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81134108:	e0bff917 	ldw	r2,-28(fp)
8113410c:	10800c03 	ldbu	r2,48(r2)
81134110:	10803fcc 	andi	r2,r2,255
81134114:	1080020c 	andi	r2,r2,8
81134118:	1000151e 	bne	r2,zero,81134170 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
8113411c:	e0bff917 	ldw	r2,-28(fp)
81134120:	10c00d83 	ldbu	r3,54(r2)
81134124:	d0a09803 	ldbu	r2,-32160(gp)
81134128:	1884b03a 	or	r2,r3,r2
8113412c:	d0a09805 	stb	r2,-32160(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81134130:	e0bff917 	ldw	r2,-28(fp)
81134134:	10800d03 	ldbu	r2,52(r2)
81134138:	10c03fcc 	andi	r3,r2,255
8113413c:	e0bff917 	ldw	r2,-28(fp)
81134140:	10800d03 	ldbu	r2,52(r2)
81134144:	11003fcc 	andi	r4,r2,255
81134148:	d0a09844 	addi	r2,gp,-32159
8113414c:	2085883a 	add	r2,r4,r2
81134150:	11000003 	ldbu	r4,0(r2)
81134154:	e0bff917 	ldw	r2,-28(fp)
81134158:	10800d43 	ldbu	r2,53(r2)
8113415c:	2084b03a 	or	r2,r4,r2
81134160:	1009883a 	mov	r4,r2
81134164:	d0a09844 	addi	r2,gp,-32159
81134168:	1885883a 	add	r2,r3,r2
8113416c:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81134170:	e0bff917 	ldw	r2,-28(fp)
81134174:	10800517 	ldw	r2,20(r2)
81134178:	e0bff915 	stw	r2,-28(fp)
8113417c:	e0bffb17 	ldw	r2,-20(fp)
81134180:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134184:	e0bffe17 	ldw	r2,-8(fp)
81134188:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113418c:	e0bff917 	ldw	r2,-28(fp)
81134190:	10800c83 	ldbu	r2,50(r2)
81134194:	10803fcc 	andi	r2,r2,255
81134198:	10800a98 	cmpnei	r2,r2,42
8113419c:	103fb21e 	bne	r2,zero,81134068 <__reset+0xfb114068>
811341a0:	00000106 	br	811341a8 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
811341a4:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
811341a8:	e037883a 	mov	sp,fp
811341ac:	dfc00117 	ldw	ra,4(sp)
811341b0:	df000017 	ldw	fp,0(sp)
811341b4:	dec00204 	addi	sp,sp,8
811341b8:	f800283a 	ret

811341bc <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
811341bc:	deffff04 	addi	sp,sp,-4
811341c0:	de00012e 	bgeu	sp,et,811341c8 <OSVersion+0xc>
811341c4:	003b68fa 	trap	3
811341c8:	df000015 	stw	fp,0(sp)
811341cc:	d839883a 	mov	fp,sp
    return (OS_VERSION);
811341d0:	00804784 	movi	r2,286
}
811341d4:	e037883a 	mov	sp,fp
811341d8:	df000017 	ldw	fp,0(sp)
811341dc:	dec00104 	addi	sp,sp,4
811341e0:	f800283a 	ret

811341e4 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
811341e4:	deffff04 	addi	sp,sp,-4
811341e8:	de00012e 	bgeu	sp,et,811341f0 <OS_Dummy+0xc>
811341ec:	003b68fa 	trap	3
811341f0:	df000015 	stw	fp,0(sp)
811341f4:	d839883a 	mov	fp,sp
}
811341f8:	0001883a 	nop
811341fc:	e037883a 	mov	sp,fp
81134200:	df000017 	ldw	fp,0(sp)
81134204:	dec00104 	addi	sp,sp,4
81134208:	f800283a 	ret

8113420c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
8113420c:	defff804 	addi	sp,sp,-32
81134210:	de00012e 	bgeu	sp,et,81134218 <OS_EventTaskRdy+0xc>
81134214:	003b68fa 	trap	3
81134218:	dfc00715 	stw	ra,28(sp)
8113421c:	df000615 	stw	fp,24(sp)
81134220:	df000604 	addi	fp,sp,24
81134224:	e13ffc15 	stw	r4,-16(fp)
81134228:	e17ffd15 	stw	r5,-12(fp)
8113422c:	3007883a 	mov	r3,r6
81134230:	3805883a 	mov	r2,r7
81134234:	e0fffe05 	stb	r3,-8(fp)
81134238:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
8113423c:	e0bffc17 	ldw	r2,-16(fp)
81134240:	10800283 	ldbu	r2,10(r2)
81134244:	10c03fcc 	andi	r3,r2,255
81134248:	00a04574 	movhi	r2,33045
8113424c:	10acb404 	addi	r2,r2,-19760
81134250:	10c5883a 	add	r2,r2,r3
81134254:	10800003 	ldbu	r2,0(r2)
81134258:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
8113425c:	e0bffa03 	ldbu	r2,-24(fp)
81134260:	e0fffc17 	ldw	r3,-16(fp)
81134264:	1885883a 	add	r2,r3,r2
81134268:	108002c4 	addi	r2,r2,11
8113426c:	10800003 	ldbu	r2,0(r2)
81134270:	10c03fcc 	andi	r3,r2,255
81134274:	00a04574 	movhi	r2,33045
81134278:	10acb404 	addi	r2,r2,-19760
8113427c:	10c5883a 	add	r2,r2,r3
81134280:	10800003 	ldbu	r2,0(r2)
81134284:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81134288:	e0bffa03 	ldbu	r2,-24(fp)
8113428c:	100490fa 	slli	r2,r2,3
81134290:	1007883a 	mov	r3,r2
81134294:	e0bffa43 	ldbu	r2,-23(fp)
81134298:	1885883a 	add	r2,r3,r2
8113429c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
811342a0:	e0fffa83 	ldbu	r3,-22(fp)
811342a4:	00a045b4 	movhi	r2,33046
811342a8:	109b0304 	addi	r2,r2,27660
811342ac:	18c7883a 	add	r3,r3,r3
811342b0:	18c7883a 	add	r3,r3,r3
811342b4:	10c5883a 	add	r2,r2,r3
811342b8:	10800017 	ldw	r2,0(r2)
811342bc:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
811342c0:	e0bffb17 	ldw	r2,-20(fp)
811342c4:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
811342c8:	e0bffb17 	ldw	r2,-20(fp)
811342cc:	e0fffd17 	ldw	r3,-12(fp)
811342d0:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
811342d4:	e0bffb17 	ldw	r2,-20(fp)
811342d8:	10800c03 	ldbu	r2,48(r2)
811342dc:	1007883a 	mov	r3,r2
811342e0:	e0bffe03 	ldbu	r2,-8(fp)
811342e4:	0084303a 	nor	r2,zero,r2
811342e8:	1884703a 	and	r2,r3,r2
811342ec:	1007883a 	mov	r3,r2
811342f0:	e0bffb17 	ldw	r2,-20(fp)
811342f4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
811342f8:	e0bffb17 	ldw	r2,-20(fp)
811342fc:	e0ffff03 	ldbu	r3,-4(fp)
81134300:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81134304:	e0bffb17 	ldw	r2,-20(fp)
81134308:	10800c03 	ldbu	r2,48(r2)
8113430c:	10803fcc 	andi	r2,r2,255
81134310:	1080020c 	andi	r2,r2,8
81134314:	1000111e 	bne	r2,zero,8113435c <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81134318:	e0bffb17 	ldw	r2,-20(fp)
8113431c:	10c00d83 	ldbu	r3,54(r2)
81134320:	d0a09803 	ldbu	r2,-32160(gp)
81134324:	1884b03a 	or	r2,r3,r2
81134328:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
8113432c:	e0fffa03 	ldbu	r3,-24(fp)
81134330:	e13ffa03 	ldbu	r4,-24(fp)
81134334:	d0a09844 	addi	r2,gp,-32159
81134338:	2085883a 	add	r2,r4,r2
8113433c:	11000003 	ldbu	r4,0(r2)
81134340:	e0bffb17 	ldw	r2,-20(fp)
81134344:	10800d43 	ldbu	r2,53(r2)
81134348:	2084b03a 	or	r2,r4,r2
8113434c:	1009883a 	mov	r4,r2
81134350:	d0a09844 	addi	r2,gp,-32159
81134354:	1885883a 	add	r2,r3,r2
81134358:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
8113435c:	e17ffc17 	ldw	r5,-16(fp)
81134360:	e13ffb17 	ldw	r4,-20(fp)
81134364:	113461c0 	call	8113461c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81134368:	e0bffb17 	ldw	r2,-20(fp)
8113436c:	10800817 	ldw	r2,32(r2)
81134370:	10000826 	beq	r2,zero,81134394 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81134374:	e0bffb17 	ldw	r2,-20(fp)
81134378:	10800817 	ldw	r2,32(r2)
8113437c:	100b883a 	mov	r5,r2
81134380:	e13ffb17 	ldw	r4,-20(fp)
81134384:	11346dc0 	call	811346dc <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81134388:	e0bffb17 	ldw	r2,-20(fp)
8113438c:	e0fffc17 	ldw	r3,-16(fp)
81134390:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81134394:	e0bffa83 	ldbu	r2,-22(fp)
}
81134398:	e037883a 	mov	sp,fp
8113439c:	dfc00117 	ldw	ra,4(sp)
811343a0:	df000017 	ldw	fp,0(sp)
811343a4:	dec00204 	addi	sp,sp,8
811343a8:	f800283a 	ret

811343ac <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
811343ac:	defffd04 	addi	sp,sp,-12
811343b0:	de00012e 	bgeu	sp,et,811343b8 <OS_EventTaskWait+0xc>
811343b4:	003b68fa 	trap	3
811343b8:	df000215 	stw	fp,8(sp)
811343bc:	df000204 	addi	fp,sp,8
811343c0:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
811343c4:	d0a09c17 	ldw	r2,-32144(gp)
811343c8:	e0ffff17 	ldw	r3,-4(fp)
811343cc:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
811343d0:	d0a09c17 	ldw	r2,-32144(gp)
811343d4:	10800d03 	ldbu	r2,52(r2)
811343d8:	10803fcc 	andi	r2,r2,255
811343dc:	d0e09c17 	ldw	r3,-32144(gp)
811343e0:	18c00d03 	ldbu	r3,52(r3)
811343e4:	18c03fcc 	andi	r3,r3,255
811343e8:	e13fff17 	ldw	r4,-4(fp)
811343ec:	20c7883a 	add	r3,r4,r3
811343f0:	18c002c4 	addi	r3,r3,11
811343f4:	19000003 	ldbu	r4,0(r3)
811343f8:	d0e09c17 	ldw	r3,-32144(gp)
811343fc:	18c00d43 	ldbu	r3,53(r3)
81134400:	20c6b03a 	or	r3,r4,r3
81134404:	1809883a 	mov	r4,r3
81134408:	e0ffff17 	ldw	r3,-4(fp)
8113440c:	1885883a 	add	r2,r3,r2
81134410:	108002c4 	addi	r2,r2,11
81134414:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81134418:	e0bfff17 	ldw	r2,-4(fp)
8113441c:	10c00283 	ldbu	r3,10(r2)
81134420:	d0a09c17 	ldw	r2,-32144(gp)
81134424:	10800d83 	ldbu	r2,54(r2)
81134428:	1884b03a 	or	r2,r3,r2
8113442c:	1007883a 	mov	r3,r2
81134430:	e0bfff17 	ldw	r2,-4(fp)
81134434:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81134438:	d0a09c17 	ldw	r2,-32144(gp)
8113443c:	10800d03 	ldbu	r2,52(r2)
81134440:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81134444:	e0fffe03 	ldbu	r3,-8(fp)
81134448:	e13ffe03 	ldbu	r4,-8(fp)
8113444c:	d0a09844 	addi	r2,gp,-32159
81134450:	2085883a 	add	r2,r4,r2
81134454:	10800003 	ldbu	r2,0(r2)
81134458:	1009883a 	mov	r4,r2
8113445c:	d0a09c17 	ldw	r2,-32144(gp)
81134460:	10800d43 	ldbu	r2,53(r2)
81134464:	0084303a 	nor	r2,zero,r2
81134468:	2084703a 	and	r2,r4,r2
8113446c:	1009883a 	mov	r4,r2
81134470:	d0a09844 	addi	r2,gp,-32159
81134474:	1885883a 	add	r2,r3,r2
81134478:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113447c:	e0fffe03 	ldbu	r3,-8(fp)
81134480:	d0a09844 	addi	r2,gp,-32159
81134484:	1885883a 	add	r2,r3,r2
81134488:	10800003 	ldbu	r2,0(r2)
8113448c:	10803fcc 	andi	r2,r2,255
81134490:	1000071e 	bne	r2,zero,811344b0 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81134494:	d0a09c17 	ldw	r2,-32144(gp)
81134498:	10800d83 	ldbu	r2,54(r2)
8113449c:	0084303a 	nor	r2,zero,r2
811344a0:	1007883a 	mov	r3,r2
811344a4:	d0a09803 	ldbu	r2,-32160(gp)
811344a8:	1884703a 	and	r2,r3,r2
811344ac:	d0a09805 	stb	r2,-32160(gp)
    }
}
811344b0:	0001883a 	nop
811344b4:	e037883a 	mov	sp,fp
811344b8:	df000017 	ldw	fp,0(sp)
811344bc:	dec00104 	addi	sp,sp,4
811344c0:	f800283a 	ret

811344c4 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
811344c4:	defffb04 	addi	sp,sp,-20
811344c8:	de00012e 	bgeu	sp,et,811344d0 <OS_EventTaskWaitMulti+0xc>
811344cc:	003b68fa 	trap	3
811344d0:	df000415 	stw	fp,16(sp)
811344d4:	df000404 	addi	fp,sp,16
811344d8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
811344dc:	d0a09c17 	ldw	r2,-32144(gp)
811344e0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
811344e4:	d0a09c17 	ldw	r2,-32144(gp)
811344e8:	e0ffff17 	ldw	r3,-4(fp)
811344ec:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
811344f0:	e0bfff17 	ldw	r2,-4(fp)
811344f4:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
811344f8:	e0bffc17 	ldw	r2,-16(fp)
811344fc:	10800017 	ldw	r2,0(r2)
81134500:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81134504:	00002006 	br	81134588 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81134508:	d0a09c17 	ldw	r2,-32144(gp)
8113450c:	10800d03 	ldbu	r2,52(r2)
81134510:	10803fcc 	andi	r2,r2,255
81134514:	d0e09c17 	ldw	r3,-32144(gp)
81134518:	18c00d03 	ldbu	r3,52(r3)
8113451c:	18c03fcc 	andi	r3,r3,255
81134520:	e13ffd17 	ldw	r4,-12(fp)
81134524:	20c7883a 	add	r3,r4,r3
81134528:	18c002c4 	addi	r3,r3,11
8113452c:	19000003 	ldbu	r4,0(r3)
81134530:	d0e09c17 	ldw	r3,-32144(gp)
81134534:	18c00d43 	ldbu	r3,53(r3)
81134538:	20c6b03a 	or	r3,r4,r3
8113453c:	1809883a 	mov	r4,r3
81134540:	e0fffd17 	ldw	r3,-12(fp)
81134544:	1885883a 	add	r2,r3,r2
81134548:	108002c4 	addi	r2,r2,11
8113454c:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81134550:	e0bffd17 	ldw	r2,-12(fp)
81134554:	10c00283 	ldbu	r3,10(r2)
81134558:	d0a09c17 	ldw	r2,-32144(gp)
8113455c:	10800d83 	ldbu	r2,54(r2)
81134560:	1884b03a 	or	r2,r3,r2
81134564:	1007883a 	mov	r3,r2
81134568:	e0bffd17 	ldw	r2,-12(fp)
8113456c:	10c00285 	stb	r3,10(r2)
        pevents++;
81134570:	e0bffc17 	ldw	r2,-16(fp)
81134574:	10800104 	addi	r2,r2,4
81134578:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113457c:	e0bffc17 	ldw	r2,-16(fp)
81134580:	10800017 	ldw	r2,0(r2)
81134584:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81134588:	e0bffd17 	ldw	r2,-12(fp)
8113458c:	103fde1e 	bne	r2,zero,81134508 <__reset+0xfb114508>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81134590:	d0a09c17 	ldw	r2,-32144(gp)
81134594:	10800d03 	ldbu	r2,52(r2)
81134598:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113459c:	e0fffe03 	ldbu	r3,-8(fp)
811345a0:	e13ffe03 	ldbu	r4,-8(fp)
811345a4:	d0a09844 	addi	r2,gp,-32159
811345a8:	2085883a 	add	r2,r4,r2
811345ac:	10800003 	ldbu	r2,0(r2)
811345b0:	1009883a 	mov	r4,r2
811345b4:	d0a09c17 	ldw	r2,-32144(gp)
811345b8:	10800d43 	ldbu	r2,53(r2)
811345bc:	0084303a 	nor	r2,zero,r2
811345c0:	2084703a 	and	r2,r4,r2
811345c4:	1009883a 	mov	r4,r2
811345c8:	d0a09844 	addi	r2,gp,-32159
811345cc:	1885883a 	add	r2,r3,r2
811345d0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811345d4:	e0fffe03 	ldbu	r3,-8(fp)
811345d8:	d0a09844 	addi	r2,gp,-32159
811345dc:	1885883a 	add	r2,r3,r2
811345e0:	10800003 	ldbu	r2,0(r2)
811345e4:	10803fcc 	andi	r2,r2,255
811345e8:	1000071e 	bne	r2,zero,81134608 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
811345ec:	d0a09c17 	ldw	r2,-32144(gp)
811345f0:	10800d83 	ldbu	r2,54(r2)
811345f4:	0084303a 	nor	r2,zero,r2
811345f8:	1007883a 	mov	r3,r2
811345fc:	d0a09803 	ldbu	r2,-32160(gp)
81134600:	1884703a 	and	r2,r3,r2
81134604:	d0a09805 	stb	r2,-32160(gp)
    }
}
81134608:	0001883a 	nop
8113460c:	e037883a 	mov	sp,fp
81134610:	df000017 	ldw	fp,0(sp)
81134614:	dec00104 	addi	sp,sp,4
81134618:	f800283a 	ret

8113461c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8113461c:	defffc04 	addi	sp,sp,-16
81134620:	de00012e 	bgeu	sp,et,81134628 <OS_EventTaskRemove+0xc>
81134624:	003b68fa 	trap	3
81134628:	df000315 	stw	fp,12(sp)
8113462c:	df000304 	addi	fp,sp,12
81134630:	e13ffe15 	stw	r4,-8(fp)
81134634:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
81134638:	e0bffe17 	ldw	r2,-8(fp)
8113463c:	10800d03 	ldbu	r2,52(r2)
81134640:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81134644:	e0bffd03 	ldbu	r2,-12(fp)
81134648:	e0fffd03 	ldbu	r3,-12(fp)
8113464c:	e13fff17 	ldw	r4,-4(fp)
81134650:	20c7883a 	add	r3,r4,r3
81134654:	18c002c4 	addi	r3,r3,11
81134658:	18c00003 	ldbu	r3,0(r3)
8113465c:	1809883a 	mov	r4,r3
81134660:	e0fffe17 	ldw	r3,-8(fp)
81134664:	18c00d43 	ldbu	r3,53(r3)
81134668:	00c6303a 	nor	r3,zero,r3
8113466c:	20c6703a 	and	r3,r4,r3
81134670:	1809883a 	mov	r4,r3
81134674:	e0ffff17 	ldw	r3,-4(fp)
81134678:	1885883a 	add	r2,r3,r2
8113467c:	108002c4 	addi	r2,r2,11
81134680:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81134684:	e0bffd03 	ldbu	r2,-12(fp)
81134688:	e0ffff17 	ldw	r3,-4(fp)
8113468c:	1885883a 	add	r2,r3,r2
81134690:	108002c4 	addi	r2,r2,11
81134694:	10800003 	ldbu	r2,0(r2)
81134698:	10803fcc 	andi	r2,r2,255
8113469c:	10000a1e 	bne	r2,zero,811346c8 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
811346a0:	e0bfff17 	ldw	r2,-4(fp)
811346a4:	10800283 	ldbu	r2,10(r2)
811346a8:	1007883a 	mov	r3,r2
811346ac:	e0bffe17 	ldw	r2,-8(fp)
811346b0:	10800d83 	ldbu	r2,54(r2)
811346b4:	0084303a 	nor	r2,zero,r2
811346b8:	1884703a 	and	r2,r3,r2
811346bc:	1007883a 	mov	r3,r2
811346c0:	e0bfff17 	ldw	r2,-4(fp)
811346c4:	10c00285 	stb	r3,10(r2)
    }
}
811346c8:	0001883a 	nop
811346cc:	e037883a 	mov	sp,fp
811346d0:	df000017 	ldw	fp,0(sp)
811346d4:	dec00104 	addi	sp,sp,4
811346d8:	f800283a 	ret

811346dc <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
811346dc:	defffa04 	addi	sp,sp,-24
811346e0:	de00012e 	bgeu	sp,et,811346e8 <OS_EventTaskRemoveMulti+0xc>
811346e4:	003b68fa 	trap	3
811346e8:	df000515 	stw	fp,20(sp)
811346ec:	df000504 	addi	fp,sp,20
811346f0:	e13ffe15 	stw	r4,-8(fp)
811346f4:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
811346f8:	e0bffe17 	ldw	r2,-8(fp)
811346fc:	10800d03 	ldbu	r2,52(r2)
81134700:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81134704:	e0bffe17 	ldw	r2,-8(fp)
81134708:	10800d83 	ldbu	r2,54(r2)
8113470c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81134710:	e0bffe17 	ldw	r2,-8(fp)
81134714:	10800d43 	ldbu	r2,53(r2)
81134718:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8113471c:	e0bfff17 	ldw	r2,-4(fp)
81134720:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
81134724:	e0bffb17 	ldw	r2,-20(fp)
81134728:	10800017 	ldw	r2,0(r2)
8113472c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81134730:	00002506 	br	811347c8 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
81134734:	e0bffd03 	ldbu	r2,-12(fp)
81134738:	e0fffd03 	ldbu	r3,-12(fp)
8113473c:	e13ffc17 	ldw	r4,-16(fp)
81134740:	20c7883a 	add	r3,r4,r3
81134744:	18c002c4 	addi	r3,r3,11
81134748:	18c00003 	ldbu	r3,0(r3)
8113474c:	1809883a 	mov	r4,r3
81134750:	e0fffd83 	ldbu	r3,-10(fp)
81134754:	00c6303a 	nor	r3,zero,r3
81134758:	20c6703a 	and	r3,r4,r3
8113475c:	1809883a 	mov	r4,r3
81134760:	e0fffc17 	ldw	r3,-16(fp)
81134764:	1885883a 	add	r2,r3,r2
81134768:	108002c4 	addi	r2,r2,11
8113476c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81134770:	e0bffd03 	ldbu	r2,-12(fp)
81134774:	e0fffc17 	ldw	r3,-16(fp)
81134778:	1885883a 	add	r2,r3,r2
8113477c:	108002c4 	addi	r2,r2,11
81134780:	10800003 	ldbu	r2,0(r2)
81134784:	10803fcc 	andi	r2,r2,255
81134788:	1000091e 	bne	r2,zero,811347b0 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113478c:	e0bffc17 	ldw	r2,-16(fp)
81134790:	10800283 	ldbu	r2,10(r2)
81134794:	1007883a 	mov	r3,r2
81134798:	e0bffd43 	ldbu	r2,-11(fp)
8113479c:	0084303a 	nor	r2,zero,r2
811347a0:	1884703a 	and	r2,r3,r2
811347a4:	1007883a 	mov	r3,r2
811347a8:	e0bffc17 	ldw	r2,-16(fp)
811347ac:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
811347b0:	e0bffb17 	ldw	r2,-20(fp)
811347b4:	10800104 	addi	r2,r2,4
811347b8:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
811347bc:	e0bffb17 	ldw	r2,-20(fp)
811347c0:	10800017 	ldw	r2,0(r2)
811347c4:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811347c8:	e0bffc17 	ldw	r2,-16(fp)
811347cc:	103fd91e 	bne	r2,zero,81134734 <__reset+0xfb114734>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
811347d0:	0001883a 	nop
811347d4:	e037883a 	mov	sp,fp
811347d8:	df000017 	ldw	fp,0(sp)
811347dc:	dec00104 	addi	sp,sp,4
811347e0:	f800283a 	ret

811347e4 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
811347e4:	defffc04 	addi	sp,sp,-16
811347e8:	de00012e 	bgeu	sp,et,811347f0 <OS_EventWaitListInit+0xc>
811347ec:	003b68fa 	trap	3
811347f0:	df000315 	stw	fp,12(sp)
811347f4:	df000304 	addi	fp,sp,12
811347f8:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
811347fc:	e0bfff17 	ldw	r2,-4(fp)
81134800:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
81134804:	e0bfff17 	ldw	r2,-4(fp)
81134808:	108002c4 	addi	r2,r2,11
8113480c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81134810:	e03ffe05 	stb	zero,-8(fp)
81134814:	00000706 	br	81134834 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81134818:	e0bffd17 	ldw	r2,-12(fp)
8113481c:	10c00044 	addi	r3,r2,1
81134820:	e0fffd15 	stw	r3,-12(fp)
81134824:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81134828:	e0bffe03 	ldbu	r2,-8(fp)
8113482c:	10800044 	addi	r2,r2,1
81134830:	e0bffe05 	stb	r2,-8(fp)
81134834:	e0bffe03 	ldbu	r2,-8(fp)
81134838:	108001b0 	cmpltui	r2,r2,6
8113483c:	103ff61e 	bne	r2,zero,81134818 <__reset+0xfb114818>
        *ptbl++ = 0;
    }
}
81134840:	0001883a 	nop
81134844:	e037883a 	mov	sp,fp
81134848:	df000017 	ldw	fp,0(sp)
8113484c:	dec00104 	addi	sp,sp,4
81134850:	f800283a 	ret

81134854 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
81134854:	defffb04 	addi	sp,sp,-20
81134858:	de00012e 	bgeu	sp,et,81134860 <OS_InitEventList+0xc>
8113485c:	003b68fa 	trap	3
81134860:	dfc00415 	stw	ra,16(sp)
81134864:	df000315 	stw	fp,12(sp)
81134868:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113486c:	01434004 	movi	r5,3328
81134870:	012045b4 	movhi	r4,33046
81134874:	21135504 	addi	r4,r4,19796
81134878:	1134bfc0 	call	81134bfc <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113487c:	00a045b4 	movhi	r2,33046
81134880:	10935504 	addi	r2,r2,19796
81134884:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81134888:	00a045b4 	movhi	r2,33046
8113488c:	10936204 	addi	r2,r2,19848
81134890:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81134894:	e03ffd0d 	sth	zero,-12(fp)
81134898:	00001306 	br	811348e8 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113489c:	e0bffe17 	ldw	r2,-8(fp)
811348a0:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
811348a4:	e0bffe17 	ldw	r2,-8(fp)
811348a8:	e0ffff17 	ldw	r3,-4(fp)
811348ac:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
811348b0:	e0bffe17 	ldw	r2,-8(fp)
811348b4:	00c00fc4 	movi	r3,63
811348b8:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
811348bc:	e0bffe17 	ldw	r2,-8(fp)
811348c0:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
811348c4:	e0bffe17 	ldw	r2,-8(fp)
811348c8:	10800d04 	addi	r2,r2,52
811348cc:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
811348d0:	e0bfff17 	ldw	r2,-4(fp)
811348d4:	10800d04 	addi	r2,r2,52
811348d8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811348dc:	e0bffd0b 	ldhu	r2,-12(fp)
811348e0:	10800044 	addi	r2,r2,1
811348e4:	e0bffd0d 	sth	r2,-12(fp)
811348e8:	e0bffd0b 	ldhu	r2,-12(fp)
811348ec:	10800ff0 	cmpltui	r2,r2,63
811348f0:	103fea1e 	bne	r2,zero,8113489c <__reset+0xfb11489c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
811348f4:	e0bffe17 	ldw	r2,-8(fp)
811348f8:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
811348fc:	e0bffe17 	ldw	r2,-8(fp)
81134900:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
81134904:	e0bffe17 	ldw	r2,-8(fp)
81134908:	00c00fc4 	movi	r3,63
8113490c:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81134910:	e0bffe17 	ldw	r2,-8(fp)
81134914:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81134918:	00a045b4 	movhi	r2,33046
8113491c:	10935504 	addi	r2,r2,19796
81134920:	d0a09a15 	stw	r2,-32152(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
81134924:	0001883a 	nop
81134928:	e037883a 	mov	sp,fp
8113492c:	dfc00117 	ldw	ra,4(sp)
81134930:	df000017 	ldw	fp,0(sp)
81134934:	dec00204 	addi	sp,sp,8
81134938:	f800283a 	ret

8113493c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8113493c:	deffff04 	addi	sp,sp,-4
81134940:	de00012e 	bgeu	sp,et,81134948 <OS_InitMisc+0xc>
81134944:	003b68fa 	trap	3
81134948:	df000015 	stw	fp,0(sp)
8113494c:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81134950:	d0209e15 	stw	zero,-32136(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81134954:	d0209b05 	stb	zero,-32148(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
81134958:	d0208905 	stb	zero,-32220(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8113495c:	d0209445 	stb	zero,-32175(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81134960:	d0208b05 	stb	zero,-32212(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81134964:	d0209015 	stw	zero,-32192(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
81134968:	d0208c15 	stw	zero,-32208(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113496c:	d020a215 	stw	zero,-32120(gp)
    OSIdleCtrMax  = 0L;
81134970:	d0209215 	stw	zero,-32184(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81134974:	d020a105 	stb	zero,-32124(gp)
#endif
}
81134978:	0001883a 	nop
8113497c:	e037883a 	mov	sp,fp
81134980:	df000017 	ldw	fp,0(sp)
81134984:	dec00104 	addi	sp,sp,4
81134988:	f800283a 	ret

8113498c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113498c:	defffd04 	addi	sp,sp,-12
81134990:	de00012e 	bgeu	sp,et,81134998 <OS_InitRdyList+0xc>
81134994:	003b68fa 	trap	3
81134998:	df000215 	stw	fp,8(sp)
8113499c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
811349a0:	d0209805 	stb	zero,-32160(gp)
    prdytbl       = &OSRdyTbl[0];
811349a4:	d0a09844 	addi	r2,gp,-32159
811349a8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811349ac:	e03ffe05 	stb	zero,-8(fp)
811349b0:	00000706 	br	811349d0 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
811349b4:	e0bfff17 	ldw	r2,-4(fp)
811349b8:	10c00044 	addi	r3,r2,1
811349bc:	e0ffff15 	stw	r3,-4(fp)
811349c0:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811349c4:	e0bffe03 	ldbu	r2,-8(fp)
811349c8:	10800044 	addi	r2,r2,1
811349cc:	e0bffe05 	stb	r2,-8(fp)
811349d0:	e0bffe03 	ldbu	r2,-8(fp)
811349d4:	108001b0 	cmpltui	r2,r2,6
811349d8:	103ff61e 	bne	r2,zero,811349b4 <__reset+0xfb1149b4>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
811349dc:	d0208dc5 	stb	zero,-32201(gp)
    OSPrioHighRdy = 0;
811349e0:	d0208d85 	stb	zero,-32202(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
811349e4:	d0209615 	stw	zero,-32168(gp)
    OSTCBCur      = (OS_TCB *)0;
811349e8:	d0209c15 	stw	zero,-32144(gp)
}
811349ec:	0001883a 	nop
811349f0:	e037883a 	mov	sp,fp
811349f4:	df000017 	ldw	fp,0(sp)
811349f8:	dec00104 	addi	sp,sp,4
811349fc:	f800283a 	ret

81134a00 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81134a00:	defff804 	addi	sp,sp,-32
81134a04:	de00012e 	bgeu	sp,et,81134a0c <OS_InitTaskIdle+0xc>
81134a08:	003b68fa 	trap	3
81134a0c:	dfc00715 	stw	ra,28(sp)
81134a10:	df000615 	stw	fp,24(sp)
81134a14:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81134a18:	008000c4 	movi	r2,3
81134a1c:	d8800415 	stw	r2,16(sp)
81134a20:	d8000315 	stw	zero,12(sp)
81134a24:	00810004 	movi	r2,1024
81134a28:	d8800215 	stw	r2,8(sp)
81134a2c:	00a045b4 	movhi	r2,33046
81134a30:	108f5504 	addi	r2,r2,15700
81134a34:	d8800115 	stw	r2,4(sp)
81134a38:	00bfffd4 	movui	r2,65535
81134a3c:	d8800015 	stw	r2,0(sp)
81134a40:	01c00a84 	movi	r7,42
81134a44:	01a045b4 	movhi	r6,33046
81134a48:	31935404 	addi	r6,r6,19792
81134a4c:	000b883a 	mov	r5,zero
81134a50:	012044f4 	movhi	r4,33043
81134a54:	2113bd04 	addi	r4,r4,20212
81134a58:	113a7300 	call	8113a730 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
81134a5c:	e1bfff04 	addi	r6,fp,-4
81134a60:	01604574 	movhi	r5,33045
81134a64:	296cf404 	addi	r5,r5,-19504
81134a68:	01000a84 	movi	r4,42
81134a6c:	113af600 	call	8113af60 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81134a70:	0001883a 	nop
81134a74:	e037883a 	mov	sp,fp
81134a78:	dfc00117 	ldw	ra,4(sp)
81134a7c:	df000017 	ldw	fp,0(sp)
81134a80:	dec00204 	addi	sp,sp,8
81134a84:	f800283a 	ret

81134a88 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81134a88:	defff804 	addi	sp,sp,-32
81134a8c:	de00012e 	bgeu	sp,et,81134a94 <OS_InitTaskStat+0xc>
81134a90:	003b68fa 	trap	3
81134a94:	dfc00715 	stw	ra,28(sp)
81134a98:	df000615 	stw	fp,24(sp)
81134a9c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81134aa0:	008000c4 	movi	r2,3
81134aa4:	d8800415 	stw	r2,16(sp)
81134aa8:	d8000315 	stw	zero,12(sp)
81134aac:	00810004 	movi	r2,1024
81134ab0:	d8800215 	stw	r2,8(sp)
81134ab4:	00a045b4 	movhi	r2,33046
81134ab8:	10889504 	addi	r2,r2,8788
81134abc:	d8800115 	stw	r2,4(sp)
81134ac0:	00bfff94 	movui	r2,65534
81134ac4:	d8800015 	stw	r2,0(sp)
81134ac8:	01c00a44 	movi	r7,41
81134acc:	01a045b4 	movhi	r6,33046
81134ad0:	318c9404 	addi	r6,r6,12880
81134ad4:	000b883a 	mov	r5,zero
81134ad8:	012044f4 	movhi	r4,33043
81134adc:	2113d604 	addi	r4,r4,20312
81134ae0:	113a7300 	call	8113a730 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
81134ae4:	e1bfff04 	addi	r6,fp,-4
81134ae8:	01604574 	movhi	r5,33045
81134aec:	296cf804 	addi	r5,r5,-19488
81134af0:	01000a44 	movi	r4,41
81134af4:	113af600 	call	8113af60 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81134af8:	0001883a 	nop
81134afc:	e037883a 	mov	sp,fp
81134b00:	dfc00117 	ldw	ra,4(sp)
81134b04:	df000017 	ldw	fp,0(sp)
81134b08:	dec00204 	addi	sp,sp,8
81134b0c:	f800283a 	ret

81134b10 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81134b10:	defffb04 	addi	sp,sp,-20
81134b14:	de00012e 	bgeu	sp,et,81134b1c <OS_InitTCBList+0xc>
81134b18:	003b68fa 	trap	3
81134b1c:	dfc00415 	stw	ra,16(sp)
81134b20:	df000315 	stw	fp,12(sp)
81134b24:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81134b28:	01446e04 	movi	r5,4536
81134b2c:	012045b4 	movhi	r4,33046
81134b30:	21169504 	addi	r4,r4,23124
81134b34:	1134bfc0 	call	81134bfc <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81134b38:	01402b04 	movi	r5,172
81134b3c:	012045b4 	movhi	r4,33046
81134b40:	211b0304 	addi	r4,r4,27660
81134b44:	1134bfc0 	call	81134bfc <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81134b48:	00a045b4 	movhi	r2,33046
81134b4c:	10969504 	addi	r2,r2,23124
81134b50:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81134b54:	00a045b4 	movhi	r2,33046
81134b58:	1096b004 	addi	r2,r2,23232
81134b5c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81134b60:	e03ffd05 	stb	zero,-12(fp)
81134b64:	00001106 	br	81134bac <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81134b68:	e0bffe17 	ldw	r2,-8(fp)
81134b6c:	e0ffff17 	ldw	r3,-4(fp)
81134b70:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81134b74:	e0bffe17 	ldw	r2,-8(fp)
81134b78:	00c00fc4 	movi	r3,63
81134b7c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81134b80:	e0bffe17 	ldw	r2,-8(fp)
81134b84:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81134b88:	e0bffe17 	ldw	r2,-8(fp)
81134b8c:	10801b04 	addi	r2,r2,108
81134b90:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81134b94:	e0bfff17 	ldw	r2,-4(fp)
81134b98:	10801b04 	addi	r2,r2,108
81134b9c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81134ba0:	e0bffd03 	ldbu	r2,-12(fp)
81134ba4:	10800044 	addi	r2,r2,1
81134ba8:	e0bffd05 	stb	r2,-12(fp)
81134bac:	e0bffd03 	ldbu	r2,-12(fp)
81134bb0:	10800a70 	cmpltui	r2,r2,41
81134bb4:	103fec1e 	bne	r2,zero,81134b68 <__reset+0xfb114b68>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81134bb8:	e0bffe17 	ldw	r2,-8(fp)
81134bbc:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81134bc0:	e0bffe17 	ldw	r2,-8(fp)
81134bc4:	00c00fc4 	movi	r3,63
81134bc8:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81134bcc:	e0bffe17 	ldw	r2,-8(fp)
81134bd0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81134bd4:	d0208e15 	stw	zero,-32200(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81134bd8:	00a045b4 	movhi	r2,33046
81134bdc:	10969504 	addi	r2,r2,23124
81134be0:	d0a09315 	stw	r2,-32180(gp)
}
81134be4:	0001883a 	nop
81134be8:	e037883a 	mov	sp,fp
81134bec:	dfc00117 	ldw	ra,4(sp)
81134bf0:	df000017 	ldw	fp,0(sp)
81134bf4:	dec00204 	addi	sp,sp,8
81134bf8:	f800283a 	ret

81134bfc <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81134bfc:	defffd04 	addi	sp,sp,-12
81134c00:	de00012e 	bgeu	sp,et,81134c08 <OS_MemClr+0xc>
81134c04:	003b68fa 	trap	3
81134c08:	df000215 	stw	fp,8(sp)
81134c0c:	df000204 	addi	fp,sp,8
81134c10:	e13ffe15 	stw	r4,-8(fp)
81134c14:	2805883a 	mov	r2,r5
81134c18:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81134c1c:	00000706 	br	81134c3c <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81134c20:	e0bffe17 	ldw	r2,-8(fp)
81134c24:	10c00044 	addi	r3,r2,1
81134c28:	e0fffe15 	stw	r3,-8(fp)
81134c2c:	10000005 	stb	zero,0(r2)
        size--;
81134c30:	e0bfff0b 	ldhu	r2,-4(fp)
81134c34:	10bfffc4 	addi	r2,r2,-1
81134c38:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81134c3c:	e0bfff0b 	ldhu	r2,-4(fp)
81134c40:	103ff71e 	bne	r2,zero,81134c20 <__reset+0xfb114c20>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81134c44:	0001883a 	nop
81134c48:	e037883a 	mov	sp,fp
81134c4c:	df000017 	ldw	fp,0(sp)
81134c50:	dec00104 	addi	sp,sp,4
81134c54:	f800283a 	ret

81134c58 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81134c58:	defffc04 	addi	sp,sp,-16
81134c5c:	de00012e 	bgeu	sp,et,81134c64 <OS_MemCopy+0xc>
81134c60:	003b68fa 	trap	3
81134c64:	df000315 	stw	fp,12(sp)
81134c68:	df000304 	addi	fp,sp,12
81134c6c:	e13ffd15 	stw	r4,-12(fp)
81134c70:	e17ffe15 	stw	r5,-8(fp)
81134c74:	3005883a 	mov	r2,r6
81134c78:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81134c7c:	00000b06 	br	81134cac <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81134c80:	e0bffd17 	ldw	r2,-12(fp)
81134c84:	10c00044 	addi	r3,r2,1
81134c88:	e0fffd15 	stw	r3,-12(fp)
81134c8c:	e0fffe17 	ldw	r3,-8(fp)
81134c90:	19000044 	addi	r4,r3,1
81134c94:	e13ffe15 	stw	r4,-8(fp)
81134c98:	18c00003 	ldbu	r3,0(r3)
81134c9c:	10c00005 	stb	r3,0(r2)
        size--;
81134ca0:	e0bfff0b 	ldhu	r2,-4(fp)
81134ca4:	10bfffc4 	addi	r2,r2,-1
81134ca8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81134cac:	e0bfff0b 	ldhu	r2,-4(fp)
81134cb0:	103ff31e 	bne	r2,zero,81134c80 <__reset+0xfb114c80>
        *pdest++ = *psrc++;
        size--;
    }
}
81134cb4:	0001883a 	nop
81134cb8:	e037883a 	mov	sp,fp
81134cbc:	df000017 	ldw	fp,0(sp)
81134cc0:	dec00104 	addi	sp,sp,4
81134cc4:	f800283a 	ret

81134cc8 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81134cc8:	defffb04 	addi	sp,sp,-20
81134ccc:	de00012e 	bgeu	sp,et,81134cd4 <OS_Sched+0xc>
81134cd0:	003b68fa 	trap	3
81134cd4:	dfc00415 	stw	ra,16(sp)
81134cd8:	df000315 	stw	fp,12(sp)
81134cdc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81134ce0:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134ce4:	0005303a 	rdctl	r2,status
81134ce8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134cec:	e0ffff17 	ldw	r3,-4(fp)
81134cf0:	00bfff84 	movi	r2,-2
81134cf4:	1884703a 	and	r2,r3,r2
81134cf8:	1001703a 	wrctl	status,r2
  
  return context;
81134cfc:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81134d00:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81134d04:	d0a09b03 	ldbu	r2,-32148(gp)
81134d08:	10803fcc 	andi	r2,r2,255
81134d0c:	10001a1e 	bne	r2,zero,81134d78 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81134d10:	d0a08903 	ldbu	r2,-32220(gp)
81134d14:	10803fcc 	andi	r2,r2,255
81134d18:	1000171e 	bne	r2,zero,81134d78 <OS_Sched+0xb0>
            OS_SchedNew();
81134d1c:	1134da00 	call	81134da0 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81134d20:	d0e08d83 	ldbu	r3,-32202(gp)
81134d24:	d0a08dc3 	ldbu	r2,-32201(gp)
81134d28:	18c03fcc 	andi	r3,r3,255
81134d2c:	10803fcc 	andi	r2,r2,255
81134d30:	18801126 	beq	r3,r2,81134d78 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81134d34:	d0a08d83 	ldbu	r2,-32202(gp)
81134d38:	10c03fcc 	andi	r3,r2,255
81134d3c:	00a045b4 	movhi	r2,33046
81134d40:	109b0304 	addi	r2,r2,27660
81134d44:	18c7883a 	add	r3,r3,r3
81134d48:	18c7883a 	add	r3,r3,r3
81134d4c:	10c5883a 	add	r2,r2,r3
81134d50:	10800017 	ldw	r2,0(r2)
81134d54:	d0a09615 	stw	r2,-32168(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81134d58:	d0a09617 	ldw	r2,-32168(gp)
81134d5c:	10c00e17 	ldw	r3,56(r2)
81134d60:	18c00044 	addi	r3,r3,1
81134d64:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81134d68:	d0a09017 	ldw	r2,-32192(gp)
81134d6c:	10800044 	addi	r2,r2,1
81134d70:	d0a09015 	stw	r2,-32192(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81134d74:	1145b440 	call	81145b44 <OSCtxSw>
81134d78:	e0bffd17 	ldw	r2,-12(fp)
81134d7c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134d80:	e0bffe17 	ldw	r2,-8(fp)
81134d84:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81134d88:	0001883a 	nop
81134d8c:	e037883a 	mov	sp,fp
81134d90:	dfc00117 	ldw	ra,4(sp)
81134d94:	df000017 	ldw	fp,0(sp)
81134d98:	dec00204 	addi	sp,sp,8
81134d9c:	f800283a 	ret

81134da0 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81134da0:	defffe04 	addi	sp,sp,-8
81134da4:	de00012e 	bgeu	sp,et,81134dac <OS_SchedNew+0xc>
81134da8:	003b68fa 	trap	3
81134dac:	df000115 	stw	fp,4(sp)
81134db0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81134db4:	d0a09803 	ldbu	r2,-32160(gp)
81134db8:	10c03fcc 	andi	r3,r2,255
81134dbc:	00a04574 	movhi	r2,33045
81134dc0:	10acb404 	addi	r2,r2,-19760
81134dc4:	10c5883a 	add	r2,r2,r3
81134dc8:	10800003 	ldbu	r2,0(r2)
81134dcc:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81134dd0:	e0bfff03 	ldbu	r2,-4(fp)
81134dd4:	100490fa 	slli	r2,r2,3
81134dd8:	1009883a 	mov	r4,r2
81134ddc:	e0ffff03 	ldbu	r3,-4(fp)
81134de0:	d0a09844 	addi	r2,gp,-32159
81134de4:	1885883a 	add	r2,r3,r2
81134de8:	10800003 	ldbu	r2,0(r2)
81134dec:	10c03fcc 	andi	r3,r2,255
81134df0:	00a04574 	movhi	r2,33045
81134df4:	10acb404 	addi	r2,r2,-19760
81134df8:	10c5883a 	add	r2,r2,r3
81134dfc:	10800003 	ldbu	r2,0(r2)
81134e00:	2085883a 	add	r2,r4,r2
81134e04:	d0a08d85 	stb	r2,-32202(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81134e08:	0001883a 	nop
81134e0c:	e037883a 	mov	sp,fp
81134e10:	df000017 	ldw	fp,0(sp)
81134e14:	dec00104 	addi	sp,sp,4
81134e18:	f800283a 	ret

81134e1c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81134e1c:	defffc04 	addi	sp,sp,-16
81134e20:	de00012e 	bgeu	sp,et,81134e28 <OS_StrCopy+0xc>
81134e24:	003b68fa 	trap	3
81134e28:	df000315 	stw	fp,12(sp)
81134e2c:	df000304 	addi	fp,sp,12
81134e30:	e13ffe15 	stw	r4,-8(fp)
81134e34:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81134e38:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81134e3c:	00000b06 	br	81134e6c <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81134e40:	e0bffe17 	ldw	r2,-8(fp)
81134e44:	10c00044 	addi	r3,r2,1
81134e48:	e0fffe15 	stw	r3,-8(fp)
81134e4c:	e0ffff17 	ldw	r3,-4(fp)
81134e50:	19000044 	addi	r4,r3,1
81134e54:	e13fff15 	stw	r4,-4(fp)
81134e58:	18c00003 	ldbu	r3,0(r3)
81134e5c:	10c00005 	stb	r3,0(r2)
        len++;
81134e60:	e0bffd03 	ldbu	r2,-12(fp)
81134e64:	10800044 	addi	r2,r2,1
81134e68:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81134e6c:	e0bfff17 	ldw	r2,-4(fp)
81134e70:	10800003 	ldbu	r2,0(r2)
81134e74:	10803fcc 	andi	r2,r2,255
81134e78:	103ff11e 	bne	r2,zero,81134e40 <__reset+0xfb114e40>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81134e7c:	e0bffe17 	ldw	r2,-8(fp)
81134e80:	10000005 	stb	zero,0(r2)
    return (len);
81134e84:	e0bffd03 	ldbu	r2,-12(fp)
}
81134e88:	e037883a 	mov	sp,fp
81134e8c:	df000017 	ldw	fp,0(sp)
81134e90:	dec00104 	addi	sp,sp,4
81134e94:	f800283a 	ret

81134e98 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81134e98:	defffd04 	addi	sp,sp,-12
81134e9c:	de00012e 	bgeu	sp,et,81134ea4 <OS_StrLen+0xc>
81134ea0:	003b68fa 	trap	3
81134ea4:	df000215 	stw	fp,8(sp)
81134ea8:	df000204 	addi	fp,sp,8
81134eac:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81134eb0:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81134eb4:	00000606 	br	81134ed0 <OS_StrLen+0x38>
        psrc++;
81134eb8:	e0bfff17 	ldw	r2,-4(fp)
81134ebc:	10800044 	addi	r2,r2,1
81134ec0:	e0bfff15 	stw	r2,-4(fp)
        len++;
81134ec4:	e0bffe03 	ldbu	r2,-8(fp)
81134ec8:	10800044 	addi	r2,r2,1
81134ecc:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81134ed0:	e0bfff17 	ldw	r2,-4(fp)
81134ed4:	10800003 	ldbu	r2,0(r2)
81134ed8:	10803fcc 	andi	r2,r2,255
81134edc:	103ff61e 	bne	r2,zero,81134eb8 <__reset+0xfb114eb8>
        psrc++;
        len++;
    }
    return (len);
81134ee0:	e0bffe03 	ldbu	r2,-8(fp)
}
81134ee4:	e037883a 	mov	sp,fp
81134ee8:	df000017 	ldw	fp,0(sp)
81134eec:	dec00104 	addi	sp,sp,4
81134ef0:	f800283a 	ret

81134ef4 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81134ef4:	defffa04 	addi	sp,sp,-24
81134ef8:	de00012e 	bgeu	sp,et,81134f00 <OS_TaskIdle+0xc>
81134efc:	003b68fa 	trap	3
81134f00:	dfc00515 	stw	ra,20(sp)
81134f04:	df000415 	stw	fp,16(sp)
81134f08:	df000404 	addi	fp,sp,16
81134f0c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134f10:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f14:	0005303a 	rdctl	r2,status
81134f18:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134f1c:	e0fffd17 	ldw	r3,-12(fp)
81134f20:	00bfff84 	movi	r2,-2
81134f24:	1884703a 	and	r2,r3,r2
81134f28:	1001703a 	wrctl	status,r2
  
  return context;
81134f2c:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81134f30:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81134f34:	d0a08c17 	ldw	r2,-32208(gp)
81134f38:	10800044 	addi	r2,r2,1
81134f3c:	d0a08c15 	stw	r2,-32208(gp)
81134f40:	e0bffc17 	ldw	r2,-16(fp)
81134f44:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134f48:	e0bffe17 	ldw	r2,-8(fp)
81134f4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81134f50:	1145ed80 	call	81145ed8 <OSTaskIdleHook>
    }
81134f54:	003fef06 	br	81134f14 <__reset+0xfb114f14>

81134f58 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81134f58:	defff804 	addi	sp,sp,-32
81134f5c:	de00012e 	bgeu	sp,et,81134f64 <OS_TaskStat+0xc>
81134f60:	003b68fa 	trap	3
81134f64:	dfc00715 	stw	ra,28(sp)
81134f68:	df000615 	stw	fp,24(sp)
81134f6c:	dc400515 	stw	r17,20(sp)
81134f70:	dc000415 	stw	r16,16(sp)
81134f74:	df000604 	addi	fp,sp,24
81134f78:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134f7c:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81134f80:	00000206 	br	81134f8c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81134f84:	01003204 	movi	r4,200
81134f88:	113b8500 	call	8113b850 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81134f8c:	d0a0a103 	ldbu	r2,-32124(gp)
81134f90:	10803fcc 	andi	r2,r2,255
81134f94:	103ffb26 	beq	r2,zero,81134f84 <__reset+0xfb114f84>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81134f98:	d0e09217 	ldw	r3,-32184(gp)
81134f9c:	00947b34 	movhi	r2,20972
81134fa0:	10a147c4 	addi	r2,r2,-31457
81134fa4:	1888383a 	mulxuu	r4,r3,r2
81134fa8:	1885383a 	mul	r2,r3,r2
81134fac:	1021883a 	mov	r16,r2
81134fb0:	2023883a 	mov	r17,r4
81134fb4:	8804d17a 	srli	r2,r17,5
81134fb8:	d0a09215 	stw	r2,-32184(gp)
    if (OSIdleCtrMax == 0L) {
81134fbc:	d0a09217 	ldw	r2,-32184(gp)
81134fc0:	1000031e 	bne	r2,zero,81134fd0 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81134fc4:	d0209405 	stb	zero,-32176(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81134fc8:	01003fc4 	movi	r4,255
81134fcc:	113b4c00 	call	8113b4c0 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134fd0:	0005303a 	rdctl	r2,status
81134fd4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134fd8:	e0fffb17 	ldw	r3,-20(fp)
81134fdc:	00bfff84 	movi	r2,-2
81134fe0:	1884703a 	and	r2,r3,r2
81134fe4:	1001703a 	wrctl	status,r2
  
  return context;
81134fe8:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81134fec:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81134ff0:	d0a08c17 	ldw	r2,-32208(gp)
81134ff4:	d0a0a215 	stw	r2,-32120(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81134ff8:	d0208c15 	stw	zero,-32208(gp)
81134ffc:	e0bffa17 	ldw	r2,-24(fp)
81135000:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135004:	e0bffc17 	ldw	r2,-16(fp)
81135008:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
8113500c:	d0e0a217 	ldw	r3,-32120(gp)
81135010:	d0a09217 	ldw	r2,-32184(gp)
81135014:	1885203a 	divu	r2,r3,r2
81135018:	1007883a 	mov	r3,r2
8113501c:	00801904 	movi	r2,100
81135020:	10c5c83a 	sub	r2,r2,r3
81135024:	d0a09405 	stb	r2,-32176(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81135028:	1145e080 	call	81145e08 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
8113502c:	113503c0 	call	8113503c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81135030:	01001904 	movi	r4,100
81135034:	113b8500 	call	8113b850 <OSTimeDly>
    }
81135038:	003fe506 	br	81134fd0 <__reset+0xfb114fd0>

8113503c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
8113503c:	defffa04 	addi	sp,sp,-24
81135040:	de00012e 	bgeu	sp,et,81135048 <OS_TaskStatStkChk+0xc>
81135044:	003b68fa 	trap	3
81135048:	dfc00515 	stw	ra,20(sp)
8113504c:	df000415 	stw	fp,16(sp)
81135050:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81135054:	e03ffc05 	stb	zero,-16(fp)
81135058:	00002406 	br	811350ec <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
8113505c:	e0bffc03 	ldbu	r2,-16(fp)
81135060:	e0fffe04 	addi	r3,fp,-8
81135064:	180b883a 	mov	r5,r3
81135068:	1009883a 	mov	r4,r2
8113506c:	113b2f80 	call	8113b2f8 <OSTaskStkChk>
81135070:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81135074:	e0bffc43 	ldbu	r2,-15(fp)
81135078:	1000191e 	bne	r2,zero,811350e0 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113507c:	e0fffc03 	ldbu	r3,-16(fp)
81135080:	00a045b4 	movhi	r2,33046
81135084:	109b0304 	addi	r2,r2,27660
81135088:	18c7883a 	add	r3,r3,r3
8113508c:	18c7883a 	add	r3,r3,r3
81135090:	10c5883a 	add	r2,r2,r3
81135094:	10800017 	ldw	r2,0(r2)
81135098:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113509c:	e0bffd17 	ldw	r2,-12(fp)
811350a0:	10000f26 	beq	r2,zero,811350e0 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
811350a4:	e0bffd17 	ldw	r2,-12(fp)
811350a8:	10800060 	cmpeqi	r2,r2,1
811350ac:	10000c1e 	bne	r2,zero,811350e0 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
811350b0:	e0bffd17 	ldw	r2,-12(fp)
811350b4:	10c00217 	ldw	r3,8(r2)
811350b8:	e0bffd17 	ldw	r2,-12(fp)
811350bc:	10800317 	ldw	r2,12(r2)
811350c0:	1085883a 	add	r2,r2,r2
811350c4:	1085883a 	add	r2,r2,r2
811350c8:	1887883a 	add	r3,r3,r2
811350cc:	e0bffd17 	ldw	r2,-12(fp)
811350d0:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
811350d4:	e0ffff17 	ldw	r3,-4(fp)
811350d8:	e0bffd17 	ldw	r2,-12(fp)
811350dc:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
811350e0:	e0bffc03 	ldbu	r2,-16(fp)
811350e4:	10800044 	addi	r2,r2,1
811350e8:	e0bffc05 	stb	r2,-16(fp)
811350ec:	e0bffc03 	ldbu	r2,-16(fp)
811350f0:	10800af0 	cmpltui	r2,r2,43
811350f4:	103fd91e 	bne	r2,zero,8113505c <__reset+0xfb11505c>
#endif
                }
            }
        }
    }
}
811350f8:	0001883a 	nop
811350fc:	e037883a 	mov	sp,fp
81135100:	dfc00117 	ldw	ra,4(sp)
81135104:	df000017 	ldw	fp,0(sp)
81135108:	dec00204 	addi	sp,sp,8
8113510c:	f800283a 	ret

81135110 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81135110:	defff204 	addi	sp,sp,-56
81135114:	de00012e 	bgeu	sp,et,8113511c <OS_TCBInit+0xc>
81135118:	003b68fa 	trap	3
8113511c:	dfc00d15 	stw	ra,52(sp)
81135120:	df000c15 	stw	fp,48(sp)
81135124:	df000c04 	addi	fp,sp,48
81135128:	e17ffc15 	stw	r5,-16(fp)
8113512c:	e1bffd15 	stw	r6,-12(fp)
81135130:	3807883a 	mov	r3,r7
81135134:	e0800417 	ldw	r2,16(fp)
81135138:	e13ffb05 	stb	r4,-20(fp)
8113513c:	e0fffe0d 	sth	r3,-8(fp)
81135140:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81135144:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135148:	0005303a 	rdctl	r2,status
8113514c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135150:	e0fffa17 	ldw	r3,-24(fp)
81135154:	00bfff84 	movi	r2,-2
81135158:	1884703a 	and	r2,r3,r2
8113515c:	1001703a 	wrctl	status,r2
  
  return context;
81135160:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81135164:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81135168:	d0a09317 	ldw	r2,-32180(gp)
8113516c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81135170:	e0bff617 	ldw	r2,-40(fp)
81135174:	10009326 	beq	r2,zero,811353c4 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81135178:	e0bff617 	ldw	r2,-40(fp)
8113517c:	10800517 	ldw	r2,20(r2)
81135180:	d0a09315 	stw	r2,-32180(gp)
81135184:	e0bff417 	ldw	r2,-48(fp)
81135188:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113518c:	e0bff817 	ldw	r2,-32(fp)
81135190:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81135194:	e0bff617 	ldw	r2,-40(fp)
81135198:	e0fffc17 	ldw	r3,-16(fp)
8113519c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
811351a0:	e0bff617 	ldw	r2,-40(fp)
811351a4:	e0fffb03 	ldbu	r3,-20(fp)
811351a8:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
811351ac:	e0bff617 	ldw	r2,-40(fp)
811351b0:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
811351b4:	e0bff617 	ldw	r2,-40(fp)
811351b8:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
811351bc:	e0bff617 	ldw	r2,-40(fp)
811351c0:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
811351c4:	e0bff617 	ldw	r2,-40(fp)
811351c8:	e0c00317 	ldw	r3,12(fp)
811351cc:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
811351d0:	e0bff617 	ldw	r2,-40(fp)
811351d4:	e0c00217 	ldw	r3,8(fp)
811351d8:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
811351dc:	e0bff617 	ldw	r2,-40(fp)
811351e0:	e0fffd17 	ldw	r3,-12(fp)
811351e4:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
811351e8:	e0bff617 	ldw	r2,-40(fp)
811351ec:	e0ffff0b 	ldhu	r3,-4(fp)
811351f0:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
811351f4:	e0bff617 	ldw	r2,-40(fp)
811351f8:	e0fffe0b 	ldhu	r3,-8(fp)
811351fc:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81135200:	e0bff617 	ldw	r2,-40(fp)
81135204:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81135208:	e0bffb03 	ldbu	r2,-20(fp)
8113520c:	1004d0fa 	srli	r2,r2,3
81135210:	1007883a 	mov	r3,r2
81135214:	e0bff617 	ldw	r2,-40(fp)
81135218:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
8113521c:	e0bffb03 	ldbu	r2,-20(fp)
81135220:	108001cc 	andi	r2,r2,7
81135224:	1007883a 	mov	r3,r2
81135228:	e0bff617 	ldw	r2,-40(fp)
8113522c:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
81135230:	e0bff617 	ldw	r2,-40(fp)
81135234:	10800d03 	ldbu	r2,52(r2)
81135238:	10803fcc 	andi	r2,r2,255
8113523c:	00c00044 	movi	r3,1
81135240:	1884983a 	sll	r2,r3,r2
81135244:	1007883a 	mov	r3,r2
81135248:	e0bff617 	ldw	r2,-40(fp)
8113524c:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81135250:	e0bff617 	ldw	r2,-40(fp)
81135254:	10800cc3 	ldbu	r2,51(r2)
81135258:	10803fcc 	andi	r2,r2,255
8113525c:	00c00044 	movi	r3,1
81135260:	1884983a 	sll	r2,r3,r2
81135264:	1007883a 	mov	r3,r2
81135268:	e0bff617 	ldw	r2,-40(fp)
8113526c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81135270:	e0bff617 	ldw	r2,-40(fp)
81135274:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81135278:	e0bff617 	ldw	r2,-40(fp)
8113527c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81135280:	e0bff617 	ldw	r2,-40(fp)
81135284:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81135288:	e0bff617 	ldw	r2,-40(fp)
8113528c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81135290:	e0bff617 	ldw	r2,-40(fp)
81135294:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81135298:	e0bff617 	ldw	r2,-40(fp)
8113529c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
811352a0:	e0bff617 	ldw	r2,-40(fp)
811352a4:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
811352a8:	e0bff617 	ldw	r2,-40(fp)
811352ac:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
811352b0:	e0bff617 	ldw	r2,-40(fp)
811352b4:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
811352b8:	e0bff617 	ldw	r2,-40(fp)
811352bc:	00c00fc4 	movi	r3,63
811352c0:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
811352c4:	e0bff617 	ldw	r2,-40(fp)
811352c8:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
811352cc:	e13ff617 	ldw	r4,-40(fp)
811352d0:	1145f000 	call	81145f00 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
811352d4:	e13ff617 	ldw	r4,-40(fp)
811352d8:	1145d880 	call	81145d88 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811352dc:	0005303a 	rdctl	r2,status
811352e0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811352e4:	e0fff517 	ldw	r3,-44(fp)
811352e8:	00bfff84 	movi	r2,-2
811352ec:	1884703a 	and	r2,r3,r2
811352f0:	1001703a 	wrctl	status,r2
  
  return context;
811352f4:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
811352f8:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
811352fc:	e0fffb03 	ldbu	r3,-20(fp)
81135300:	00a045b4 	movhi	r2,33046
81135304:	109b0304 	addi	r2,r2,27660
81135308:	18c7883a 	add	r3,r3,r3
8113530c:	18c7883a 	add	r3,r3,r3
81135310:	10c5883a 	add	r2,r2,r3
81135314:	e0fff617 	ldw	r3,-40(fp)
81135318:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
8113531c:	d0e08e17 	ldw	r3,-32200(gp)
81135320:	e0bff617 	ldw	r2,-40(fp)
81135324:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
81135328:	e0bff617 	ldw	r2,-40(fp)
8113532c:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
81135330:	d0a08e17 	ldw	r2,-32200(gp)
81135334:	10000326 	beq	r2,zero,81135344 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
81135338:	d0a08e17 	ldw	r2,-32200(gp)
8113533c:	e0fff617 	ldw	r3,-40(fp)
81135340:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
81135344:	e0bff617 	ldw	r2,-40(fp)
81135348:	d0a08e15 	stw	r2,-32200(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
8113534c:	e0bff617 	ldw	r2,-40(fp)
81135350:	10c00d83 	ldbu	r3,54(r2)
81135354:	d0a09803 	ldbu	r2,-32160(gp)
81135358:	1884b03a 	or	r2,r3,r2
8113535c:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81135360:	e0bff617 	ldw	r2,-40(fp)
81135364:	10800d03 	ldbu	r2,52(r2)
81135368:	10c03fcc 	andi	r3,r2,255
8113536c:	e0bff617 	ldw	r2,-40(fp)
81135370:	10800d03 	ldbu	r2,52(r2)
81135374:	11003fcc 	andi	r4,r2,255
81135378:	d0a09844 	addi	r2,gp,-32159
8113537c:	2085883a 	add	r2,r4,r2
81135380:	11000003 	ldbu	r4,0(r2)
81135384:	e0bff617 	ldw	r2,-40(fp)
81135388:	10800d43 	ldbu	r2,53(r2)
8113538c:	2084b03a 	or	r2,r4,r2
81135390:	1009883a 	mov	r4,r2
81135394:	d0a09844 	addi	r2,gp,-32159
81135398:	1885883a 	add	r2,r3,r2
8113539c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
811353a0:	d0a09443 	ldbu	r2,-32175(gp)
811353a4:	10800044 	addi	r2,r2,1
811353a8:	d0a09445 	stb	r2,-32175(gp)
811353ac:	e0bff417 	ldw	r2,-48(fp)
811353b0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811353b4:	e0bff717 	ldw	r2,-36(fp)
811353b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
811353bc:	0005883a 	mov	r2,zero
811353c0:	00000506 	br	811353d8 <OS_TCBInit+0x2c8>
811353c4:	e0bff417 	ldw	r2,-48(fp)
811353c8:	e0bff915 	stw	r2,-28(fp)
811353cc:	e0bff917 	ldw	r2,-28(fp)
811353d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
811353d4:	00801084 	movi	r2,66
}
811353d8:	e037883a 	mov	sp,fp
811353dc:	dfc00117 	ldw	ra,4(sp)
811353e0:	df000017 	ldw	fp,0(sp)
811353e4:	dec00204 	addi	sp,sp,8
811353e8:	f800283a 	ret

811353ec <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
811353ec:	defffe04 	addi	sp,sp,-8
811353f0:	de00012e 	bgeu	sp,et,811353f8 <OSDebugInit+0xc>
811353f4:	003b68fa 	trap	3
811353f8:	df000115 	stw	fp,4(sp)
811353fc:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81135400:	d0a01804 	addi	r2,gp,-32672
81135404:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81135408:	d0a01904 	addi	r2,gp,-32668
8113540c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81135410:	d0a01a84 	addi	r2,gp,-32662
81135414:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81135418:	d0a01b04 	addi	r2,gp,-32660
8113541c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
81135420:	d0a01a04 	addi	r2,gp,-32664
81135424:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81135428:	d0a01b84 	addi	r2,gp,-32658
8113542c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
81135430:	d0a01c04 	addi	r2,gp,-32656
81135434:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81135438:	d0a01c84 	addi	r2,gp,-32654
8113543c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81135440:	d0a01d04 	addi	r2,gp,-32652
81135444:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
81135448:	d0a01d84 	addi	r2,gp,-32650
8113544c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81135450:	d0a01e04 	addi	r2,gp,-32648
81135454:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
81135458:	d0a01e84 	addi	r2,gp,-32646
8113545c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81135460:	d0a01f04 	addi	r2,gp,-32644
81135464:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81135468:	d0a01f84 	addi	r2,gp,-32642
8113546c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81135470:	d0a02004 	addi	r2,gp,-32640
81135474:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81135478:	d0a02084 	addi	r2,gp,-32638
8113547c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81135480:	d0a02104 	addi	r2,gp,-32636
81135484:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81135488:	d0a02184 	addi	r2,gp,-32634
8113548c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81135490:	d0a02204 	addi	r2,gp,-32632
81135494:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81135498:	d0a02284 	addi	r2,gp,-32630
8113549c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
811354a0:	d0a02304 	addi	r2,gp,-32628
811354a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
811354a8:	d0a02384 	addi	r2,gp,-32626
811354ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
811354b0:	d0a02404 	addi	r2,gp,-32624
811354b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
811354b8:	d0a02484 	addi	r2,gp,-32622
811354bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
811354c0:	d0a02504 	addi	r2,gp,-32620
811354c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
811354c8:	d0a02584 	addi	r2,gp,-32618
811354cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
811354d0:	d0a02604 	addi	r2,gp,-32616
811354d4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
811354d8:	d0a02684 	addi	r2,gp,-32614
811354dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
811354e0:	d0a02704 	addi	r2,gp,-32612
811354e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
811354e8:	d0a02784 	addi	r2,gp,-32610
811354ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
811354f0:	d0a02804 	addi	r2,gp,-32608
811354f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
811354f8:	d0a02884 	addi	r2,gp,-32606
811354fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81135500:	d0a02904 	addi	r2,gp,-32604
81135504:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81135508:	d0a02984 	addi	r2,gp,-32602
8113550c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81135510:	d0a02a04 	addi	r2,gp,-32600
81135514:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81135518:	d0a02a84 	addi	r2,gp,-32598
8113551c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
81135520:	d0a02b04 	addi	r2,gp,-32596
81135524:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
81135528:	d0a02b84 	addi	r2,gp,-32594
8113552c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
81135530:	d0a02c04 	addi	r2,gp,-32592
81135534:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
81135538:	d0a02c84 	addi	r2,gp,-32590
8113553c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
81135540:	d0a02d04 	addi	r2,gp,-32588
81135544:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
81135548:	d0a02d84 	addi	r2,gp,-32586
8113554c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
81135550:	d0a02e04 	addi	r2,gp,-32584
81135554:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
81135558:	d0a02e84 	addi	r2,gp,-32582
8113555c:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81135560:	00a045b4 	movhi	r2,33046
81135564:	10852104 	addi	r2,r2,5252
81135568:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113556c:	00a045b4 	movhi	r2,33046
81135570:	10836504 	addi	r2,r2,3476
81135574:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
81135578:	d0a02f84 	addi	r2,gp,-32578
8113557c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81135580:	d0a03004 	addi	r2,gp,-32576
81135584:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81135588:	d0a03084 	addi	r2,gp,-32574
8113558c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81135590:	d0a03104 	addi	r2,gp,-32572
81135594:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81135598:	d0a03184 	addi	r2,gp,-32570
8113559c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
811355a0:	d0a03204 	addi	r2,gp,-32568
811355a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
811355a8:	d0a03284 	addi	r2,gp,-32566
811355ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
811355b0:	d0a03304 	addi	r2,gp,-32564
811355b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
811355b8:	d0a03384 	addi	r2,gp,-32562
811355bc:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
811355c0:	d0a02f04 	addi	r2,gp,-32580
811355c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
811355c8:	d0a03404 	addi	r2,gp,-32560
811355cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
811355d0:	0001883a 	nop
811355d4:	e037883a 	mov	sp,fp
811355d8:	df000017 	ldw	fp,0(sp)
811355dc:	dec00104 	addi	sp,sp,4
811355e0:	f800283a 	ret

811355e4 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
811355e4:	defff204 	addi	sp,sp,-56
811355e8:	de00012e 	bgeu	sp,et,811355f0 <OSFlagAccept+0xc>
811355ec:	003b68fa 	trap	3
811355f0:	df000d15 	stw	fp,52(sp)
811355f4:	df000d04 	addi	fp,sp,52
811355f8:	e13ffc15 	stw	r4,-16(fp)
811355fc:	2807883a 	mov	r3,r5
81135600:	3005883a 	mov	r2,r6
81135604:	e1ffff15 	stw	r7,-4(fp)
81135608:	e0fffd0d 	sth	r3,-12(fp)
8113560c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135610:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135614:	e0bfff17 	ldw	r2,-4(fp)
81135618:	1000021e 	bne	r2,zero,81135624 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113561c:	0005883a 	mov	r2,zero
81135620:	0000b006 	br	811358e4 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81135624:	e0bffc17 	ldw	r2,-16(fp)
81135628:	1000051e 	bne	r2,zero,81135640 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113562c:	e0bfff17 	ldw	r2,-4(fp)
81135630:	00c01b84 	movi	r3,110
81135634:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135638:	0005883a 	mov	r2,zero
8113563c:	0000a906 	br	811358e4 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81135640:	e0bffc17 	ldw	r2,-16(fp)
81135644:	10800003 	ldbu	r2,0(r2)
81135648:	10803fcc 	andi	r2,r2,255
8113564c:	10800160 	cmpeqi	r2,r2,5
81135650:	1000051e 	bne	r2,zero,81135668 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
81135654:	e0bfff17 	ldw	r2,-4(fp)
81135658:	00c00044 	movi	r3,1
8113565c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135660:	0005883a 	mov	r2,zero
81135664:	00009f06 	br	811358e4 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81135668:	e0fffe03 	ldbu	r3,-8(fp)
8113566c:	00bfe004 	movi	r2,-128
81135670:	1884703a 	and	r2,r3,r2
81135674:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
81135678:	e0bff503 	ldbu	r2,-44(fp)
8113567c:	10000626 	beq	r2,zero,81135698 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81135680:	e0bffe03 	ldbu	r2,-8(fp)
81135684:	10801fcc 	andi	r2,r2,127
81135688:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113568c:	00800044 	movi	r2,1
81135690:	e0bff385 	stb	r2,-50(fp)
81135694:	00000106 	br	8113569c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81135698:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113569c:	e0bfff17 	ldw	r2,-4(fp)
811356a0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811356a4:	0005303a 	rdctl	r2,status
811356a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811356ac:	e0fffb17 	ldw	r3,-20(fp)
811356b0:	00bfff84 	movi	r2,-2
811356b4:	1884703a 	and	r2,r3,r2
811356b8:	1001703a 	wrctl	status,r2
  
  return context;
811356bc:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
811356c0:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
811356c4:	e0bffe03 	ldbu	r2,-8(fp)
811356c8:	10c00060 	cmpeqi	r3,r2,1
811356cc:	18005f1e 	bne	r3,zero,8113584c <OSFlagAccept+0x268>
811356d0:	10c00088 	cmpgei	r3,r2,2
811356d4:	1800021e 	bne	r3,zero,811356e0 <OSFlagAccept+0xfc>
811356d8:	10003f26 	beq	r2,zero,811357d8 <OSFlagAccept+0x1f4>
811356dc:	00007706 	br	811358bc <OSFlagAccept+0x2d8>
811356e0:	10c000a0 	cmpeqi	r3,r2,2
811356e4:	1800031e 	bne	r3,zero,811356f4 <OSFlagAccept+0x110>
811356e8:	108000e0 	cmpeqi	r2,r2,3
811356ec:	10001e1e 	bne	r2,zero,81135768 <OSFlagAccept+0x184>
811356f0:	00007206 	br	811358bc <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811356f4:	e0bffc17 	ldw	r2,-16(fp)
811356f8:	10c0020b 	ldhu	r3,8(r2)
811356fc:	e0bffd0b 	ldhu	r2,-12(fp)
81135700:	1884703a 	and	r2,r3,r2
81135704:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81135708:	e0fff30b 	ldhu	r3,-52(fp)
8113570c:	e0bffd0b 	ldhu	r2,-12(fp)
81135710:	18800d1e 	bne	r3,r2,81135748 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135714:	e0bff383 	ldbu	r2,-50(fp)
81135718:	10800058 	cmpnei	r2,r2,1
8113571c:	10000d1e 	bne	r2,zero,81135754 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81135720:	e0bffc17 	ldw	r2,-16(fp)
81135724:	1080020b 	ldhu	r2,8(r2)
81135728:	1007883a 	mov	r3,r2
8113572c:	e0bff30b 	ldhu	r2,-52(fp)
81135730:	0084303a 	nor	r2,zero,r2
81135734:	1884703a 	and	r2,r3,r2
81135738:	1007883a 	mov	r3,r2
8113573c:	e0bffc17 	ldw	r2,-16(fp)
81135740:	10c0020d 	sth	r3,8(r2)
81135744:	00000306 	br	81135754 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81135748:	e0bfff17 	ldw	r2,-4(fp)
8113574c:	00c01c04 	movi	r3,112
81135750:	10c00005 	stb	r3,0(r2)
81135754:	e0bff417 	ldw	r2,-48(fp)
81135758:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113575c:	e0bff617 	ldw	r2,-40(fp)
81135760:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135764:	00005e06 	br	811358e0 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81135768:	e0bffc17 	ldw	r2,-16(fp)
8113576c:	10c0020b 	ldhu	r3,8(r2)
81135770:	e0bffd0b 	ldhu	r2,-12(fp)
81135774:	1884703a 	and	r2,r3,r2
81135778:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113577c:	e0bff30b 	ldhu	r2,-52(fp)
81135780:	10000d26 	beq	r2,zero,811357b8 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135784:	e0bff383 	ldbu	r2,-50(fp)
81135788:	10800058 	cmpnei	r2,r2,1
8113578c:	10000d1e 	bne	r2,zero,811357c4 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81135790:	e0bffc17 	ldw	r2,-16(fp)
81135794:	1080020b 	ldhu	r2,8(r2)
81135798:	1007883a 	mov	r3,r2
8113579c:	e0bff30b 	ldhu	r2,-52(fp)
811357a0:	0084303a 	nor	r2,zero,r2
811357a4:	1884703a 	and	r2,r3,r2
811357a8:	1007883a 	mov	r3,r2
811357ac:	e0bffc17 	ldw	r2,-16(fp)
811357b0:	10c0020d 	sth	r3,8(r2)
811357b4:	00000306 	br	811357c4 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811357b8:	e0bfff17 	ldw	r2,-4(fp)
811357bc:	00c01c04 	movi	r3,112
811357c0:	10c00005 	stb	r3,0(r2)
811357c4:	e0bff417 	ldw	r2,-48(fp)
811357c8:	e0bff715 	stw	r2,-36(fp)
811357cc:	e0bff717 	ldw	r2,-36(fp)
811357d0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811357d4:	00004206 	br	811358e0 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
811357d8:	e0bffc17 	ldw	r2,-16(fp)
811357dc:	1080020b 	ldhu	r2,8(r2)
811357e0:	0084303a 	nor	r2,zero,r2
811357e4:	1007883a 	mov	r3,r2
811357e8:	e0bffd0b 	ldhu	r2,-12(fp)
811357ec:	1884703a 	and	r2,r3,r2
811357f0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811357f4:	e0fff30b 	ldhu	r3,-52(fp)
811357f8:	e0bffd0b 	ldhu	r2,-12(fp)
811357fc:	18800b1e 	bne	r3,r2,8113582c <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135800:	e0bff383 	ldbu	r2,-50(fp)
81135804:	10800058 	cmpnei	r2,r2,1
81135808:	10000b1e 	bne	r2,zero,81135838 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113580c:	e0bffc17 	ldw	r2,-16(fp)
81135810:	10c0020b 	ldhu	r3,8(r2)
81135814:	e0bff30b 	ldhu	r2,-52(fp)
81135818:	1884b03a 	or	r2,r3,r2
8113581c:	1007883a 	mov	r3,r2
81135820:	e0bffc17 	ldw	r2,-16(fp)
81135824:	10c0020d 	sth	r3,8(r2)
81135828:	00000306 	br	81135838 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113582c:	e0bfff17 	ldw	r2,-4(fp)
81135830:	00c01c04 	movi	r3,112
81135834:	10c00005 	stb	r3,0(r2)
81135838:	e0bff417 	ldw	r2,-48(fp)
8113583c:	e0bff815 	stw	r2,-32(fp)
81135840:	e0bff817 	ldw	r2,-32(fp)
81135844:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81135848:	00002506 	br	811358e0 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113584c:	e0bffc17 	ldw	r2,-16(fp)
81135850:	1080020b 	ldhu	r2,8(r2)
81135854:	0084303a 	nor	r2,zero,r2
81135858:	1007883a 	mov	r3,r2
8113585c:	e0bffd0b 	ldhu	r2,-12(fp)
81135860:	1884703a 	and	r2,r3,r2
81135864:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81135868:	e0bff30b 	ldhu	r2,-52(fp)
8113586c:	10000b26 	beq	r2,zero,8113589c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135870:	e0bff383 	ldbu	r2,-50(fp)
81135874:	10800058 	cmpnei	r2,r2,1
81135878:	10000b1e 	bne	r2,zero,811358a8 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113587c:	e0bffc17 	ldw	r2,-16(fp)
81135880:	10c0020b 	ldhu	r3,8(r2)
81135884:	e0bff30b 	ldhu	r2,-52(fp)
81135888:	1884b03a 	or	r2,r3,r2
8113588c:	1007883a 	mov	r3,r2
81135890:	e0bffc17 	ldw	r2,-16(fp)
81135894:	10c0020d 	sth	r3,8(r2)
81135898:	00000306 	br	811358a8 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113589c:	e0bfff17 	ldw	r2,-4(fp)
811358a0:	00c01c04 	movi	r3,112
811358a4:	10c00005 	stb	r3,0(r2)
811358a8:	e0bff417 	ldw	r2,-48(fp)
811358ac:	e0bff915 	stw	r2,-28(fp)
811358b0:	e0bff917 	ldw	r2,-28(fp)
811358b4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811358b8:	00000906 	br	811358e0 <OSFlagAccept+0x2fc>
811358bc:	e0bff417 	ldw	r2,-48(fp)
811358c0:	e0bffa15 	stw	r2,-24(fp)
811358c4:	e0bffa17 	ldw	r2,-24(fp)
811358c8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
811358cc:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
811358d0:	e0bfff17 	ldw	r2,-4(fp)
811358d4:	00c01bc4 	movi	r3,111
811358d8:	10c00005 	stb	r3,0(r2)
             break;
811358dc:	0001883a 	nop
    }
    return (flags_rdy);
811358e0:	e0bff30b 	ldhu	r2,-52(fp)
}
811358e4:	e037883a 	mov	sp,fp
811358e8:	df000017 	ldw	fp,0(sp)
811358ec:	dec00104 	addi	sp,sp,4
811358f0:	f800283a 	ret

811358f4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
811358f4:	defff804 	addi	sp,sp,-32
811358f8:	de00012e 	bgeu	sp,et,81135900 <OSFlagCreate+0xc>
811358fc:	003b68fa 	trap	3
81135900:	df000715 	stw	fp,28(sp)
81135904:	df000704 	addi	fp,sp,28
81135908:	2005883a 	mov	r2,r4
8113590c:	e17fff15 	stw	r5,-4(fp)
81135910:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81135914:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81135918:	e0bfff17 	ldw	r2,-4(fp)
8113591c:	1000021e 	bne	r2,zero,81135928 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81135920:	0005883a 	mov	r2,zero
81135924:	00003306 	br	811359f4 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
81135928:	d0a09b03 	ldbu	r2,-32148(gp)
8113592c:	10803fcc 	andi	r2,r2,255
81135930:	10000526 	beq	r2,zero,81135948 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
81135934:	e0bfff17 	ldw	r2,-4(fp)
81135938:	00c00404 	movi	r3,16
8113593c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81135940:	0005883a 	mov	r2,zero
81135944:	00002b06 	br	811359f4 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135948:	0005303a 	rdctl	r2,status
8113594c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135950:	e0fffd17 	ldw	r3,-12(fp)
81135954:	00bfff84 	movi	r2,-2
81135958:	1884703a 	and	r2,r3,r2
8113595c:	1001703a 	wrctl	status,r2
  
  return context;
81135960:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81135964:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
81135968:	d0a0a017 	ldw	r2,-32128(gp)
8113596c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81135970:	e0bffb17 	ldw	r2,-20(fp)
81135974:	10001726 	beq	r2,zero,811359d4 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
81135978:	d0a0a017 	ldw	r2,-32128(gp)
8113597c:	10800117 	ldw	r2,4(r2)
81135980:	d0a0a015 	stw	r2,-32128(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81135984:	e0bffb17 	ldw	r2,-20(fp)
81135988:	00c00144 	movi	r3,5
8113598c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81135990:	e0bffb17 	ldw	r2,-20(fp)
81135994:	e0fffe0b 	ldhu	r3,-8(fp)
81135998:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113599c:	e0bffb17 	ldw	r2,-20(fp)
811359a0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
811359a4:	e0bffb17 	ldw	r2,-20(fp)
811359a8:	00c00fc4 	movi	r3,63
811359ac:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811359b0:	e0bffb17 	ldw	r2,-20(fp)
811359b4:	100002c5 	stb	zero,11(r2)
811359b8:	e0bff917 	ldw	r2,-28(fp)
811359bc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811359c0:	e0bffa17 	ldw	r2,-24(fp)
811359c4:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
811359c8:	e0bfff17 	ldw	r2,-4(fp)
811359cc:	10000005 	stb	zero,0(r2)
811359d0:	00000706 	br	811359f0 <OSFlagCreate+0xfc>
811359d4:	e0bff917 	ldw	r2,-28(fp)
811359d8:	e0bffc15 	stw	r2,-16(fp)
811359dc:	e0bffc17 	ldw	r2,-16(fp)
811359e0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
811359e4:	e0bfff17 	ldw	r2,-4(fp)
811359e8:	00c01c84 	movi	r3,114
811359ec:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
811359f0:	e0bffb17 	ldw	r2,-20(fp)
}
811359f4:	e037883a 	mov	sp,fp
811359f8:	df000017 	ldw	fp,0(sp)
811359fc:	dec00104 	addi	sp,sp,4
81135a00:	f800283a 	ret

81135a04 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
81135a04:	defff204 	addi	sp,sp,-56
81135a08:	de00012e 	bgeu	sp,et,81135a10 <OSFlagDel+0xc>
81135a0c:	003b68fa 	trap	3
81135a10:	dfc00d15 	stw	ra,52(sp)
81135a14:	df000c15 	stw	fp,48(sp)
81135a18:	df000c04 	addi	fp,sp,48
81135a1c:	e13ffd15 	stw	r4,-12(fp)
81135a20:	2805883a 	mov	r2,r5
81135a24:	e1bfff15 	stw	r6,-4(fp)
81135a28:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135a2c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135a30:	e0bfff17 	ldw	r2,-4(fp)
81135a34:	1000021e 	bne	r2,zero,81135a40 <OSFlagDel+0x3c>
        return (pgrp);
81135a38:	e0bffd17 	ldw	r2,-12(fp)
81135a3c:	00008006 	br	81135c40 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81135a40:	e0bffd17 	ldw	r2,-12(fp)
81135a44:	1000051e 	bne	r2,zero,81135a5c <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135a48:	e0bfff17 	ldw	r2,-4(fp)
81135a4c:	00c01b84 	movi	r3,110
81135a50:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81135a54:	e0bffd17 	ldw	r2,-12(fp)
81135a58:	00007906 	br	81135c40 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81135a5c:	d0a09b03 	ldbu	r2,-32148(gp)
81135a60:	10803fcc 	andi	r2,r2,255
81135a64:	10000526 	beq	r2,zero,81135a7c <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81135a68:	e0bfff17 	ldw	r2,-4(fp)
81135a6c:	00c003c4 	movi	r3,15
81135a70:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81135a74:	e0bffd17 	ldw	r2,-12(fp)
81135a78:	00007106 	br	81135c40 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
81135a7c:	e0bffd17 	ldw	r2,-12(fp)
81135a80:	10800003 	ldbu	r2,0(r2)
81135a84:	10803fcc 	andi	r2,r2,255
81135a88:	10800160 	cmpeqi	r2,r2,5
81135a8c:	1000051e 	bne	r2,zero,81135aa4 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81135a90:	e0bfff17 	ldw	r2,-4(fp)
81135a94:	00c00044 	movi	r3,1
81135a98:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81135a9c:	e0bffd17 	ldw	r2,-12(fp)
81135aa0:	00006706 	br	81135c40 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135aa4:	0005303a 	rdctl	r2,status
81135aa8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135aac:	e0fffc17 	ldw	r3,-16(fp)
81135ab0:	00bfff84 	movi	r2,-2
81135ab4:	1884703a 	and	r2,r3,r2
81135ab8:	1001703a 	wrctl	status,r2
  
  return context;
81135abc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81135ac0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81135ac4:	e0bffd17 	ldw	r2,-12(fp)
81135ac8:	10800117 	ldw	r2,4(r2)
81135acc:	10000326 	beq	r2,zero,81135adc <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81135ad0:	00800044 	movi	r2,1
81135ad4:	e0bff405 	stb	r2,-48(fp)
81135ad8:	00000106 	br	81135ae0 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81135adc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81135ae0:	e0bffe03 	ldbu	r2,-8(fp)
81135ae4:	10000326 	beq	r2,zero,81135af4 <OSFlagDel+0xf0>
81135ae8:	10800060 	cmpeqi	r2,r2,1
81135aec:	1000231e 	bne	r2,zero,81135b7c <OSFlagDel+0x178>
81135af0:	00004806 	br	81135c14 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
81135af4:	e0bff403 	ldbu	r2,-48(fp)
81135af8:	1000161e 	bne	r2,zero,81135b54 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
81135afc:	e0bffd17 	ldw	r2,-12(fp)
81135b00:	00c00fc4 	movi	r3,63
81135b04:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81135b08:	e0bffd17 	ldw	r2,-12(fp)
81135b0c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81135b10:	e0bffd17 	ldw	r2,-12(fp)
81135b14:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81135b18:	d0e0a017 	ldw	r3,-32128(gp)
81135b1c:	e0bffd17 	ldw	r2,-12(fp)
81135b20:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81135b24:	e0bffd17 	ldw	r2,-12(fp)
81135b28:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
81135b2c:	e0bffd17 	ldw	r2,-12(fp)
81135b30:	d0a0a015 	stw	r2,-32128(gp)
81135b34:	e0bff717 	ldw	r2,-36(fp)
81135b38:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135b3c:	e0bff817 	ldw	r2,-32(fp)
81135b40:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81135b44:	e0bfff17 	ldw	r2,-4(fp)
81135b48:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81135b4c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81135b50:	00003a06 	br	81135c3c <OSFlagDel+0x238>
81135b54:	e0bff717 	ldw	r2,-36(fp)
81135b58:	e0bff915 	stw	r2,-28(fp)
81135b5c:	e0bff917 	ldw	r2,-28(fp)
81135b60:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81135b64:	e0bfff17 	ldw	r2,-4(fp)
81135b68:	00c01244 	movi	r3,73
81135b6c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81135b70:	e0bffd17 	ldw	r2,-12(fp)
81135b74:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81135b78:	00003006 	br	81135c3c <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81135b7c:	e0bffd17 	ldw	r2,-12(fp)
81135b80:	10800117 	ldw	r2,4(r2)
81135b84:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81135b88:	00000606 	br	81135ba4 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81135b8c:	000b883a 	mov	r5,zero
81135b90:	e13ff517 	ldw	r4,-44(fp)
81135b94:	1136bb80 	call	81136bb8 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81135b98:	e0bff517 	ldw	r2,-44(fp)
81135b9c:	10800017 	ldw	r2,0(r2)
81135ba0:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81135ba4:	e0bff517 	ldw	r2,-44(fp)
81135ba8:	103ff81e 	bne	r2,zero,81135b8c <__reset+0xfb115b8c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81135bac:	e0bffd17 	ldw	r2,-12(fp)
81135bb0:	00c00fc4 	movi	r3,63
81135bb4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81135bb8:	e0bffd17 	ldw	r2,-12(fp)
81135bbc:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81135bc0:	e0bffd17 	ldw	r2,-12(fp)
81135bc4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81135bc8:	d0e0a017 	ldw	r3,-32128(gp)
81135bcc:	e0bffd17 	ldw	r2,-12(fp)
81135bd0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81135bd4:	e0bffd17 	ldw	r2,-12(fp)
81135bd8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81135bdc:	e0bffd17 	ldw	r2,-12(fp)
81135be0:	d0a0a015 	stw	r2,-32128(gp)
81135be4:	e0bff717 	ldw	r2,-36(fp)
81135be8:	e0bffa15 	stw	r2,-24(fp)
81135bec:	e0bffa17 	ldw	r2,-24(fp)
81135bf0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81135bf4:	e0bff403 	ldbu	r2,-48(fp)
81135bf8:	10800058 	cmpnei	r2,r2,1
81135bfc:	1000011e 	bne	r2,zero,81135c04 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81135c00:	1134cc80 	call	81134cc8 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81135c04:	e0bfff17 	ldw	r2,-4(fp)
81135c08:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81135c0c:	e03ff615 	stw	zero,-40(fp)
             break;
81135c10:	00000a06 	br	81135c3c <OSFlagDel+0x238>
81135c14:	e0bff717 	ldw	r2,-36(fp)
81135c18:	e0bffb15 	stw	r2,-20(fp)
81135c1c:	e0bffb17 	ldw	r2,-20(fp)
81135c20:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81135c24:	e0bfff17 	ldw	r2,-4(fp)
81135c28:	00c001c4 	movi	r3,7
81135c2c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81135c30:	e0bffd17 	ldw	r2,-12(fp)
81135c34:	e0bff615 	stw	r2,-40(fp)
             break;
81135c38:	0001883a 	nop
    }
    return (pgrp_return);
81135c3c:	e0bff617 	ldw	r2,-40(fp)
}
81135c40:	e037883a 	mov	sp,fp
81135c44:	dfc00117 	ldw	ra,4(sp)
81135c48:	df000017 	ldw	fp,0(sp)
81135c4c:	dec00204 	addi	sp,sp,8
81135c50:	f800283a 	ret

81135c54 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81135c54:	defff604 	addi	sp,sp,-40
81135c58:	de00012e 	bgeu	sp,et,81135c60 <OSFlagNameGet+0xc>
81135c5c:	003b68fa 	trap	3
81135c60:	dfc00915 	stw	ra,36(sp)
81135c64:	df000815 	stw	fp,32(sp)
81135c68:	df000804 	addi	fp,sp,32
81135c6c:	e13ffd15 	stw	r4,-12(fp)
81135c70:	e17ffe15 	stw	r5,-8(fp)
81135c74:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135c78:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81135c7c:	e0bfff17 	ldw	r2,-4(fp)
81135c80:	1000021e 	bne	r2,zero,81135c8c <OSFlagNameGet+0x38>
        return (0);
81135c84:	0005883a 	mov	r2,zero
81135c88:	00003906 	br	81135d70 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81135c8c:	e0bffd17 	ldw	r2,-12(fp)
81135c90:	1000051e 	bne	r2,zero,81135ca8 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135c94:	e0bfff17 	ldw	r2,-4(fp)
81135c98:	00c01b84 	movi	r3,110
81135c9c:	10c00005 	stb	r3,0(r2)
        return (0);
81135ca0:	0005883a 	mov	r2,zero
81135ca4:	00003206 	br	81135d70 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81135ca8:	e0bffe17 	ldw	r2,-8(fp)
81135cac:	1000051e 	bne	r2,zero,81135cc4 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81135cb0:	e0bfff17 	ldw	r2,-4(fp)
81135cb4:	00c00304 	movi	r3,12
81135cb8:	10c00005 	stb	r3,0(r2)
        return (0);
81135cbc:	0005883a 	mov	r2,zero
81135cc0:	00002b06 	br	81135d70 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81135cc4:	d0a09b03 	ldbu	r2,-32148(gp)
81135cc8:	10803fcc 	andi	r2,r2,255
81135ccc:	10000526 	beq	r2,zero,81135ce4 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81135cd0:	e0bfff17 	ldw	r2,-4(fp)
81135cd4:	00c00444 	movi	r3,17
81135cd8:	10c00005 	stb	r3,0(r2)
        return (0);
81135cdc:	0005883a 	mov	r2,zero
81135ce0:	00002306 	br	81135d70 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135ce4:	0005303a 	rdctl	r2,status
81135ce8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135cec:	e0fffc17 	ldw	r3,-16(fp)
81135cf0:	00bfff84 	movi	r2,-2
81135cf4:	1884703a 	and	r2,r3,r2
81135cf8:	1001703a 	wrctl	status,r2
  
  return context;
81135cfc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81135d00:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81135d04:	e0bffd17 	ldw	r2,-12(fp)
81135d08:	10800003 	ldbu	r2,0(r2)
81135d0c:	10803fcc 	andi	r2,r2,255
81135d10:	10800160 	cmpeqi	r2,r2,5
81135d14:	1000091e 	bne	r2,zero,81135d3c <OSFlagNameGet+0xe8>
81135d18:	e0bff817 	ldw	r2,-32(fp)
81135d1c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135d20:	e0bff917 	ldw	r2,-28(fp)
81135d24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81135d28:	e0bfff17 	ldw	r2,-4(fp)
81135d2c:	00c00044 	movi	r3,1
81135d30:	10c00005 	stb	r3,0(r2)
        return (0);
81135d34:	0005883a 	mov	r2,zero
81135d38:	00000d06 	br	81135d70 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81135d3c:	e0bffd17 	ldw	r2,-12(fp)
81135d40:	10800284 	addi	r2,r2,10
81135d44:	100b883a 	mov	r5,r2
81135d48:	e13ffe17 	ldw	r4,-8(fp)
81135d4c:	1134e1c0 	call	81134e1c <OS_StrCopy>
81135d50:	e0bffb05 	stb	r2,-20(fp)
81135d54:	e0bff817 	ldw	r2,-32(fp)
81135d58:	e0bffa15 	stw	r2,-24(fp)
81135d5c:	e0bffa17 	ldw	r2,-24(fp)
81135d60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81135d64:	e0bfff17 	ldw	r2,-4(fp)
81135d68:	10000005 	stb	zero,0(r2)
    return (len);
81135d6c:	e0bffb03 	ldbu	r2,-20(fp)
}
81135d70:	e037883a 	mov	sp,fp
81135d74:	dfc00117 	ldw	ra,4(sp)
81135d78:	df000017 	ldw	fp,0(sp)
81135d7c:	dec00204 	addi	sp,sp,8
81135d80:	f800283a 	ret

81135d84 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81135d84:	defff504 	addi	sp,sp,-44
81135d88:	de00012e 	bgeu	sp,et,81135d90 <OSFlagNameSet+0xc>
81135d8c:	003b68fa 	trap	3
81135d90:	dfc00a15 	stw	ra,40(sp)
81135d94:	df000915 	stw	fp,36(sp)
81135d98:	df000904 	addi	fp,sp,36
81135d9c:	e13ffd15 	stw	r4,-12(fp)
81135da0:	e17ffe15 	stw	r5,-8(fp)
81135da4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135da8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81135dac:	e0bfff17 	ldw	r2,-4(fp)
81135db0:	10004326 	beq	r2,zero,81135ec0 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81135db4:	e0bffd17 	ldw	r2,-12(fp)
81135db8:	1000041e 	bne	r2,zero,81135dcc <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135dbc:	e0bfff17 	ldw	r2,-4(fp)
81135dc0:	00c01b84 	movi	r3,110
81135dc4:	10c00005 	stb	r3,0(r2)
        return;
81135dc8:	00003e06 	br	81135ec4 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81135dcc:	e0bffe17 	ldw	r2,-8(fp)
81135dd0:	1000041e 	bne	r2,zero,81135de4 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81135dd4:	e0bfff17 	ldw	r2,-4(fp)
81135dd8:	00c00304 	movi	r3,12
81135ddc:	10c00005 	stb	r3,0(r2)
        return;
81135de0:	00003806 	br	81135ec4 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81135de4:	d0a09b03 	ldbu	r2,-32148(gp)
81135de8:	10803fcc 	andi	r2,r2,255
81135dec:	10000426 	beq	r2,zero,81135e00 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81135df0:	e0bfff17 	ldw	r2,-4(fp)
81135df4:	00c00484 	movi	r3,18
81135df8:	10c00005 	stb	r3,0(r2)
        return;
81135dfc:	00003106 	br	81135ec4 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135e00:	0005303a 	rdctl	r2,status
81135e04:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135e08:	e0fffc17 	ldw	r3,-16(fp)
81135e0c:	00bfff84 	movi	r2,-2
81135e10:	1884703a 	and	r2,r3,r2
81135e14:	1001703a 	wrctl	status,r2
  
  return context;
81135e18:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81135e1c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81135e20:	e0bffd17 	ldw	r2,-12(fp)
81135e24:	10800003 	ldbu	r2,0(r2)
81135e28:	10803fcc 	andi	r2,r2,255
81135e2c:	10800160 	cmpeqi	r2,r2,5
81135e30:	1000081e 	bne	r2,zero,81135e54 <OSFlagNameSet+0xd0>
81135e34:	e0bff717 	ldw	r2,-36(fp)
81135e38:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135e3c:	e0bff817 	ldw	r2,-32(fp)
81135e40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81135e44:	e0bfff17 	ldw	r2,-4(fp)
81135e48:	00c00044 	movi	r3,1
81135e4c:	10c00005 	stb	r3,0(r2)
        return;
81135e50:	00001c06 	br	81135ec4 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81135e54:	e13ffe17 	ldw	r4,-8(fp)
81135e58:	1134e980 	call	81134e98 <OS_StrLen>
81135e5c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81135e60:	e0bffa03 	ldbu	r2,-24(fp)
81135e64:	10800830 	cmpltui	r2,r2,32
81135e68:	1000081e 	bne	r2,zero,81135e8c <OSFlagNameSet+0x108>
81135e6c:	e0bff717 	ldw	r2,-36(fp)
81135e70:	e0bff915 	stw	r2,-28(fp)
81135e74:	e0bff917 	ldw	r2,-28(fp)
81135e78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81135e7c:	e0bfff17 	ldw	r2,-4(fp)
81135e80:	00c01cc4 	movi	r3,115
81135e84:	10c00005 	stb	r3,0(r2)
        return;
81135e88:	00000e06 	br	81135ec4 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81135e8c:	e0bffd17 	ldw	r2,-12(fp)
81135e90:	10800284 	addi	r2,r2,10
81135e94:	e17ffe17 	ldw	r5,-8(fp)
81135e98:	1009883a 	mov	r4,r2
81135e9c:	1134e1c0 	call	81134e1c <OS_StrCopy>
81135ea0:	e0bff717 	ldw	r2,-36(fp)
81135ea4:	e0bffb15 	stw	r2,-20(fp)
81135ea8:	e0bffb17 	ldw	r2,-20(fp)
81135eac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81135eb0:	e0bfff17 	ldw	r2,-4(fp)
81135eb4:	10000005 	stb	zero,0(r2)
    return;
81135eb8:	0001883a 	nop
81135ebc:	00000106 	br	81135ec4 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81135ec0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81135ec4:	e037883a 	mov	sp,fp
81135ec8:	dfc00117 	ldw	ra,4(sp)
81135ecc:	df000017 	ldw	fp,0(sp)
81135ed0:	dec00204 	addi	sp,sp,8
81135ed4:	f800283a 	ret

81135ed8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81135ed8:	deffe104 	addi	sp,sp,-124
81135edc:	de00012e 	bgeu	sp,et,81135ee4 <OSFlagPend+0xc>
81135ee0:	003b68fa 	trap	3
81135ee4:	dfc01e15 	stw	ra,120(sp)
81135ee8:	df001d15 	stw	fp,116(sp)
81135eec:	df001d04 	addi	fp,sp,116
81135ef0:	e13ffc15 	stw	r4,-16(fp)
81135ef4:	2809883a 	mov	r4,r5
81135ef8:	3007883a 	mov	r3,r6
81135efc:	3805883a 	mov	r2,r7
81135f00:	e13ffd0d 	sth	r4,-12(fp)
81135f04:	e0fffe05 	stb	r3,-8(fp)
81135f08:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135f0c:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135f10:	e0800217 	ldw	r2,8(fp)
81135f14:	1000021e 	bne	r2,zero,81135f20 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81135f18:	0005883a 	mov	r2,zero
81135f1c:	00015906 	br	81136484 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81135f20:	e0bffc17 	ldw	r2,-16(fp)
81135f24:	1000051e 	bne	r2,zero,81135f3c <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135f28:	e0800217 	ldw	r2,8(fp)
81135f2c:	00c01b84 	movi	r3,110
81135f30:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135f34:	0005883a 	mov	r2,zero
81135f38:	00015206 	br	81136484 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81135f3c:	d0a09b03 	ldbu	r2,-32148(gp)
81135f40:	10803fcc 	andi	r2,r2,255
81135f44:	10000526 	beq	r2,zero,81135f5c <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81135f48:	e0800217 	ldw	r2,8(fp)
81135f4c:	00c00084 	movi	r3,2
81135f50:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135f54:	0005883a 	mov	r2,zero
81135f58:	00014a06 	br	81136484 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81135f5c:	d0a08903 	ldbu	r2,-32220(gp)
81135f60:	10803fcc 	andi	r2,r2,255
81135f64:	10000526 	beq	r2,zero,81135f7c <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81135f68:	e0800217 	ldw	r2,8(fp)
81135f6c:	00c00344 	movi	r3,13
81135f70:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135f74:	0005883a 	mov	r2,zero
81135f78:	00014206 	br	81136484 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81135f7c:	e0bffc17 	ldw	r2,-16(fp)
81135f80:	10800003 	ldbu	r2,0(r2)
81135f84:	10803fcc 	andi	r2,r2,255
81135f88:	10800160 	cmpeqi	r2,r2,5
81135f8c:	1000051e 	bne	r2,zero,81135fa4 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81135f90:	e0800217 	ldw	r2,8(fp)
81135f94:	00c00044 	movi	r3,1
81135f98:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135f9c:	0005883a 	mov	r2,zero
81135fa0:	00013806 	br	81136484 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81135fa4:	e0fffe03 	ldbu	r3,-8(fp)
81135fa8:	00bfe004 	movi	r2,-128
81135fac:	1884703a 	and	r2,r3,r2
81135fb0:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81135fb4:	e0bfe603 	ldbu	r2,-104(fp)
81135fb8:	10000626 	beq	r2,zero,81135fd4 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
81135fbc:	e0bffe03 	ldbu	r2,-8(fp)
81135fc0:	10801fcc 	andi	r2,r2,127
81135fc4:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81135fc8:	00800044 	movi	r2,1
81135fcc:	e0bfe405 	stb	r2,-112(fp)
81135fd0:	00000106 	br	81135fd8 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81135fd4:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135fd8:	0005303a 	rdctl	r2,status
81135fdc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135fe0:	e0fff617 	ldw	r3,-40(fp)
81135fe4:	00bfff84 	movi	r2,-2
81135fe8:	1884703a 	and	r2,r3,r2
81135fec:	1001703a 	wrctl	status,r2
  
  return context;
81135ff0:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81135ff4:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81135ff8:	e0bffe03 	ldbu	r2,-8(fp)
81135ffc:	10c00060 	cmpeqi	r3,r2,1
81136000:	1800921e 	bne	r3,zero,8113624c <OSFlagPend+0x374>
81136004:	10c00088 	cmpgei	r3,r2,2
81136008:	1800021e 	bne	r3,zero,81136014 <OSFlagPend+0x13c>
8113600c:	10006126 	beq	r2,zero,81136194 <OSFlagPend+0x2bc>
81136010:	0000bb06 	br	81136300 <OSFlagPend+0x428>
81136014:	10c000a0 	cmpeqi	r3,r2,2
81136018:	1800031e 	bne	r3,zero,81136028 <OSFlagPend+0x150>
8113601c:	108000e0 	cmpeqi	r2,r2,3
81136020:	10002f1e 	bne	r2,zero,811360e0 <OSFlagPend+0x208>
81136024:	0000b606 	br	81136300 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
81136028:	e0bffc17 	ldw	r2,-16(fp)
8113602c:	10c0020b 	ldhu	r3,8(r2)
81136030:	e0bffd0b 	ldhu	r2,-12(fp)
81136034:	1884703a 	and	r2,r3,r2
81136038:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113603c:	e0ffe80b 	ldhu	r3,-96(fp)
81136040:	e0bffd0b 	ldhu	r2,-12(fp)
81136044:	1880171e 	bne	r3,r2,811360a4 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81136048:	e0bfe403 	ldbu	r2,-112(fp)
8113604c:	10800058 	cmpnei	r2,r2,1
81136050:	1000091e 	bne	r2,zero,81136078 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81136054:	e0bffc17 	ldw	r2,-16(fp)
81136058:	1080020b 	ldhu	r2,8(r2)
8113605c:	1007883a 	mov	r3,r2
81136060:	e0bfe80b 	ldhu	r2,-96(fp)
81136064:	0084303a 	nor	r2,zero,r2
81136068:	1884703a 	and	r2,r3,r2
8113606c:	1007883a 	mov	r3,r2
81136070:	e0bffc17 	ldw	r2,-16(fp)
81136074:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81136078:	d0a09c17 	ldw	r2,-32144(gp)
8113607c:	e0ffe80b 	ldhu	r3,-96(fp)
81136080:	10c00b0d 	sth	r3,44(r2)
81136084:	e0bfe517 	ldw	r2,-108(fp)
81136088:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113608c:	e0bfe717 	ldw	r2,-100(fp)
81136090:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81136094:	e0800217 	ldw	r2,8(fp)
81136098:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113609c:	e0bfe80b 	ldhu	r2,-96(fp)
811360a0:	0000f806 	br	81136484 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811360a4:	e13ffd0b 	ldhu	r4,-12(fp)
811360a8:	e17ffe03 	ldbu	r5,-8(fp)
811360ac:	e0bfff0b 	ldhu	r2,-4(fp)
811360b0:	e0fff704 	addi	r3,fp,-36
811360b4:	d8800015 	stw	r2,0(sp)
811360b8:	280f883a 	mov	r7,r5
811360bc:	200d883a 	mov	r6,r4
811360c0:	180b883a 	mov	r5,r3
811360c4:	e13ffc17 	ldw	r4,-16(fp)
811360c8:	11369680 	call	81136968 <OS_FlagBlock>
811360cc:	e0bfe517 	ldw	r2,-108(fp)
811360d0:	e0bfe915 	stw	r2,-92(fp)
811360d4:	e0bfe917 	ldw	r2,-92(fp)
811360d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811360dc:	00009206 	br	81136328 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
811360e0:	e0bffc17 	ldw	r2,-16(fp)
811360e4:	10c0020b 	ldhu	r3,8(r2)
811360e8:	e0bffd0b 	ldhu	r2,-12(fp)
811360ec:	1884703a 	and	r2,r3,r2
811360f0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
811360f4:	e0bfe80b 	ldhu	r2,-96(fp)
811360f8:	10001726 	beq	r2,zero,81136158 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811360fc:	e0bfe403 	ldbu	r2,-112(fp)
81136100:	10800058 	cmpnei	r2,r2,1
81136104:	1000091e 	bne	r2,zero,8113612c <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81136108:	e0bffc17 	ldw	r2,-16(fp)
8113610c:	1080020b 	ldhu	r2,8(r2)
81136110:	1007883a 	mov	r3,r2
81136114:	e0bfe80b 	ldhu	r2,-96(fp)
81136118:	0084303a 	nor	r2,zero,r2
8113611c:	1884703a 	and	r2,r3,r2
81136120:	1007883a 	mov	r3,r2
81136124:	e0bffc17 	ldw	r2,-16(fp)
81136128:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113612c:	d0a09c17 	ldw	r2,-32144(gp)
81136130:	e0ffe80b 	ldhu	r3,-96(fp)
81136134:	10c00b0d 	sth	r3,44(r2)
81136138:	e0bfe517 	ldw	r2,-108(fp)
8113613c:	e0bfea15 	stw	r2,-88(fp)
81136140:	e0bfea17 	ldw	r2,-88(fp)
81136144:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81136148:	e0800217 	ldw	r2,8(fp)
8113614c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81136150:	e0bfe80b 	ldhu	r2,-96(fp)
81136154:	0000cb06 	br	81136484 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81136158:	e13ffd0b 	ldhu	r4,-12(fp)
8113615c:	e17ffe03 	ldbu	r5,-8(fp)
81136160:	e0bfff0b 	ldhu	r2,-4(fp)
81136164:	e0fff704 	addi	r3,fp,-36
81136168:	d8800015 	stw	r2,0(sp)
8113616c:	280f883a 	mov	r7,r5
81136170:	200d883a 	mov	r6,r4
81136174:	180b883a 	mov	r5,r3
81136178:	e13ffc17 	ldw	r4,-16(fp)
8113617c:	11369680 	call	81136968 <OS_FlagBlock>
81136180:	e0bfe517 	ldw	r2,-108(fp)
81136184:	e0bfeb15 	stw	r2,-84(fp)
81136188:	e0bfeb17 	ldw	r2,-84(fp)
8113618c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81136190:	00006506 	br	81136328 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81136194:	e0bffc17 	ldw	r2,-16(fp)
81136198:	1080020b 	ldhu	r2,8(r2)
8113619c:	0084303a 	nor	r2,zero,r2
811361a0:	1007883a 	mov	r3,r2
811361a4:	e0bffd0b 	ldhu	r2,-12(fp)
811361a8:	1884703a 	and	r2,r3,r2
811361ac:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811361b0:	e0ffe80b 	ldhu	r3,-96(fp)
811361b4:	e0bffd0b 	ldhu	r2,-12(fp)
811361b8:	1880151e 	bne	r3,r2,81136210 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811361bc:	e0bfe403 	ldbu	r2,-112(fp)
811361c0:	10800058 	cmpnei	r2,r2,1
811361c4:	1000071e 	bne	r2,zero,811361e4 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
811361c8:	e0bffc17 	ldw	r2,-16(fp)
811361cc:	10c0020b 	ldhu	r3,8(r2)
811361d0:	e0bfe80b 	ldhu	r2,-96(fp)
811361d4:	1884b03a 	or	r2,r3,r2
811361d8:	1007883a 	mov	r3,r2
811361dc:	e0bffc17 	ldw	r2,-16(fp)
811361e0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811361e4:	d0a09c17 	ldw	r2,-32144(gp)
811361e8:	e0ffe80b 	ldhu	r3,-96(fp)
811361ec:	10c00b0d 	sth	r3,44(r2)
811361f0:	e0bfe517 	ldw	r2,-108(fp)
811361f4:	e0bfec15 	stw	r2,-80(fp)
811361f8:	e0bfec17 	ldw	r2,-80(fp)
811361fc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81136200:	e0800217 	ldw	r2,8(fp)
81136204:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81136208:	e0bfe80b 	ldhu	r2,-96(fp)
8113620c:	00009d06 	br	81136484 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81136210:	e13ffd0b 	ldhu	r4,-12(fp)
81136214:	e17ffe03 	ldbu	r5,-8(fp)
81136218:	e0bfff0b 	ldhu	r2,-4(fp)
8113621c:	e0fff704 	addi	r3,fp,-36
81136220:	d8800015 	stw	r2,0(sp)
81136224:	280f883a 	mov	r7,r5
81136228:	200d883a 	mov	r6,r4
8113622c:	180b883a 	mov	r5,r3
81136230:	e13ffc17 	ldw	r4,-16(fp)
81136234:	11369680 	call	81136968 <OS_FlagBlock>
81136238:	e0bfe517 	ldw	r2,-108(fp)
8113623c:	e0bfed15 	stw	r2,-76(fp)
81136240:	e0bfed17 	ldw	r2,-76(fp)
81136244:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81136248:	00003706 	br	81136328 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113624c:	e0bffc17 	ldw	r2,-16(fp)
81136250:	1080020b 	ldhu	r2,8(r2)
81136254:	0084303a 	nor	r2,zero,r2
81136258:	1007883a 	mov	r3,r2
8113625c:	e0bffd0b 	ldhu	r2,-12(fp)
81136260:	1884703a 	and	r2,r3,r2
81136264:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81136268:	e0bfe80b 	ldhu	r2,-96(fp)
8113626c:	10001526 	beq	r2,zero,811362c4 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81136270:	e0bfe403 	ldbu	r2,-112(fp)
81136274:	10800058 	cmpnei	r2,r2,1
81136278:	1000071e 	bne	r2,zero,81136298 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113627c:	e0bffc17 	ldw	r2,-16(fp)
81136280:	10c0020b 	ldhu	r3,8(r2)
81136284:	e0bfe80b 	ldhu	r2,-96(fp)
81136288:	1884b03a 	or	r2,r3,r2
8113628c:	1007883a 	mov	r3,r2
81136290:	e0bffc17 	ldw	r2,-16(fp)
81136294:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81136298:	d0a09c17 	ldw	r2,-32144(gp)
8113629c:	e0ffe80b 	ldhu	r3,-96(fp)
811362a0:	10c00b0d 	sth	r3,44(r2)
811362a4:	e0bfe517 	ldw	r2,-108(fp)
811362a8:	e0bfee15 	stw	r2,-72(fp)
811362ac:	e0bfee17 	ldw	r2,-72(fp)
811362b0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811362b4:	e0800217 	ldw	r2,8(fp)
811362b8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811362bc:	e0bfe80b 	ldhu	r2,-96(fp)
811362c0:	00007006 	br	81136484 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811362c4:	e13ffd0b 	ldhu	r4,-12(fp)
811362c8:	e17ffe03 	ldbu	r5,-8(fp)
811362cc:	e0bfff0b 	ldhu	r2,-4(fp)
811362d0:	e0fff704 	addi	r3,fp,-36
811362d4:	d8800015 	stw	r2,0(sp)
811362d8:	280f883a 	mov	r7,r5
811362dc:	200d883a 	mov	r6,r4
811362e0:	180b883a 	mov	r5,r3
811362e4:	e13ffc17 	ldw	r4,-16(fp)
811362e8:	11369680 	call	81136968 <OS_FlagBlock>
811362ec:	e0bfe517 	ldw	r2,-108(fp)
811362f0:	e0bfef15 	stw	r2,-68(fp)
811362f4:	e0bfef17 	ldw	r2,-68(fp)
811362f8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811362fc:	00000a06 	br	81136328 <OSFlagPend+0x450>
81136300:	e0bfe517 	ldw	r2,-108(fp)
81136304:	e0bff015 	stw	r2,-64(fp)
81136308:	e0bff017 	ldw	r2,-64(fp)
8113630c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81136310:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81136314:	e0800217 	ldw	r2,8(fp)
81136318:	00c01bc4 	movi	r3,111
8113631c:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
81136320:	e0bfe80b 	ldhu	r2,-96(fp)
81136324:	00005706 	br	81136484 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
81136328:	1134cc80 	call	81134cc8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113632c:	0005303a 	rdctl	r2,status
81136330:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136334:	e0fff117 	ldw	r3,-60(fp)
81136338:	00bfff84 	movi	r2,-2
8113633c:	1884703a 	and	r2,r3,r2
81136340:	1001703a 	wrctl	status,r2
  
  return context;
81136344:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
81136348:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113634c:	d0a09c17 	ldw	r2,-32144(gp)
81136350:	10800c43 	ldbu	r2,49(r2)
81136354:	10803fcc 	andi	r2,r2,255
81136358:	10001c26 	beq	r2,zero,811363cc <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113635c:	d0a09c17 	ldw	r2,-32144(gp)
81136360:	10800c43 	ldbu	r2,49(r2)
81136364:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81136368:	d0a09c17 	ldw	r2,-32144(gp)
8113636c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
81136370:	e0bff704 	addi	r2,fp,-36
81136374:	1009883a 	mov	r4,r2
81136378:	1136cb40 	call	81136cb4 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113637c:	d0a09c17 	ldw	r2,-32144(gp)
81136380:	10000c05 	stb	zero,48(r2)
81136384:	e0bfe517 	ldw	r2,-108(fp)
81136388:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113638c:	e0bff217 	ldw	r2,-56(fp)
81136390:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81136394:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81136398:	e0bff303 	ldbu	r2,-52(fp)
8113639c:	108000a0 	cmpeqi	r2,r2,2
811363a0:	10000426 	beq	r2,zero,811363b4 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
811363a4:	e0800217 	ldw	r2,8(fp)
811363a8:	00c00384 	movi	r3,14
811363ac:	10c00005 	stb	r3,0(r2)
                 break;
811363b0:	00000406 	br	811363c4 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
811363b4:	e0800217 	ldw	r2,8(fp)
811363b8:	00c00284 	movi	r3,10
811363bc:	10c00005 	stb	r3,0(r2)
                 break;
811363c0:	0001883a 	nop
        }
        return (flags_rdy);
811363c4:	e0bfe80b 	ldhu	r2,-96(fp)
811363c8:	00002e06 	br	81136484 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
811363cc:	d0a09c17 	ldw	r2,-32144(gp)
811363d0:	10800b0b 	ldhu	r2,44(r2)
811363d4:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
811363d8:	e0bfe403 	ldbu	r2,-112(fp)
811363dc:	10800058 	cmpnei	r2,r2,1
811363e0:	1000211e 	bne	r2,zero,81136468 <OSFlagPend+0x590>
        switch (wait_type) {
811363e4:	e0bffe03 	ldbu	r2,-8(fp)
811363e8:	10001616 	blt	r2,zero,81136444 <OSFlagPend+0x56c>
811363ec:	10c00090 	cmplti	r3,r2,2
811363f0:	18000c1e 	bne	r3,zero,81136424 <OSFlagPend+0x54c>
811363f4:	10800108 	cmpgei	r2,r2,4
811363f8:	1000121e 	bne	r2,zero,81136444 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
811363fc:	e0bffc17 	ldw	r2,-16(fp)
81136400:	1080020b 	ldhu	r2,8(r2)
81136404:	1007883a 	mov	r3,r2
81136408:	e0bfe80b 	ldhu	r2,-96(fp)
8113640c:	0084303a 	nor	r2,zero,r2
81136410:	1884703a 	and	r2,r3,r2
81136414:	1007883a 	mov	r3,r2
81136418:	e0bffc17 	ldw	r2,-16(fp)
8113641c:	10c0020d 	sth	r3,8(r2)
                 break;
81136420:	00001106 	br	81136468 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
81136424:	e0bffc17 	ldw	r2,-16(fp)
81136428:	10c0020b 	ldhu	r3,8(r2)
8113642c:	e0bfe80b 	ldhu	r2,-96(fp)
81136430:	1884b03a 	or	r2,r3,r2
81136434:	1007883a 	mov	r3,r2
81136438:	e0bffc17 	ldw	r2,-16(fp)
8113643c:	10c0020d 	sth	r3,8(r2)
                 break;
81136440:	00000906 	br	81136468 <OSFlagPend+0x590>
81136444:	e0bfe517 	ldw	r2,-108(fp)
81136448:	e0bff415 	stw	r2,-48(fp)
8113644c:	e0bff417 	ldw	r2,-48(fp)
81136450:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81136454:	e0800217 	ldw	r2,8(fp)
81136458:	00c01bc4 	movi	r3,111
8113645c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81136460:	0005883a 	mov	r2,zero
81136464:	00000706 	br	81136484 <OSFlagPend+0x5ac>
81136468:	e0bfe517 	ldw	r2,-108(fp)
8113646c:	e0bff515 	stw	r2,-44(fp)
81136470:	e0bff517 	ldw	r2,-44(fp)
81136474:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81136478:	e0800217 	ldw	r2,8(fp)
8113647c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81136480:	e0bfe80b 	ldhu	r2,-96(fp)
}
81136484:	e037883a 	mov	sp,fp
81136488:	dfc00117 	ldw	ra,4(sp)
8113648c:	df000017 	ldw	fp,0(sp)
81136490:	dec00204 	addi	sp,sp,8
81136494:	f800283a 	ret

81136498 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81136498:	defffb04 	addi	sp,sp,-20
8113649c:	de00012e 	bgeu	sp,et,811364a4 <OSFlagPendGetFlagsRdy+0xc>
811364a0:	003b68fa 	trap	3
811364a4:	df000415 	stw	fp,16(sp)
811364a8:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811364ac:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811364b0:	0005303a 	rdctl	r2,status
811364b4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811364b8:	e0fffe17 	ldw	r3,-8(fp)
811364bc:	00bfff84 	movi	r2,-2
811364c0:	1884703a 	and	r2,r3,r2
811364c4:	1001703a 	wrctl	status,r2
  
  return context;
811364c8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
811364cc:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
811364d0:	d0a09c17 	ldw	r2,-32144(gp)
811364d4:	10800b0b 	ldhu	r2,44(r2)
811364d8:	e0bffd0d 	sth	r2,-12(fp)
811364dc:	e0bffc17 	ldw	r2,-16(fp)
811364e0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811364e4:	e0bfff17 	ldw	r2,-4(fp)
811364e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
811364ec:	e0bffd0b 	ldhu	r2,-12(fp)
}
811364f0:	e037883a 	mov	sp,fp
811364f4:	df000017 	ldw	fp,0(sp)
811364f8:	dec00104 	addi	sp,sp,4
811364fc:	f800283a 	ret

81136500 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
81136500:	deffef04 	addi	sp,sp,-68
81136504:	de00012e 	bgeu	sp,et,8113650c <OSFlagPost+0xc>
81136508:	003b68fa 	trap	3
8113650c:	dfc01015 	stw	ra,64(sp)
81136510:	df000f15 	stw	fp,60(sp)
81136514:	df000f04 	addi	fp,sp,60
81136518:	e13ffc15 	stw	r4,-16(fp)
8113651c:	2807883a 	mov	r3,r5
81136520:	3005883a 	mov	r2,r6
81136524:	e1ffff15 	stw	r7,-4(fp)
81136528:	e0fffd0d 	sth	r3,-12(fp)
8113652c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
81136530:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81136534:	e0bfff17 	ldw	r2,-4(fp)
81136538:	1000021e 	bne	r2,zero,81136544 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113653c:	0005883a 	mov	r2,zero
81136540:	0000d106 	br	81136888 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
81136544:	e0bffc17 	ldw	r2,-16(fp)
81136548:	1000051e 	bne	r2,zero,81136560 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113654c:	e0bfff17 	ldw	r2,-4(fp)
81136550:	00c01b84 	movi	r3,110
81136554:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136558:	0005883a 	mov	r2,zero
8113655c:	0000ca06 	br	81136888 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81136560:	e0bffc17 	ldw	r2,-16(fp)
81136564:	10800003 	ldbu	r2,0(r2)
81136568:	10803fcc 	andi	r2,r2,255
8113656c:	10800160 	cmpeqi	r2,r2,5
81136570:	1000051e 	bne	r2,zero,81136588 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
81136574:	e0bfff17 	ldw	r2,-4(fp)
81136578:	00c00044 	movi	r3,1
8113657c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136580:	0005883a 	mov	r2,zero
81136584:	0000c006 	br	81136888 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136588:	0005303a 	rdctl	r2,status
8113658c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136590:	e0fffb17 	ldw	r3,-20(fp)
81136594:	00bfff84 	movi	r2,-2
81136598:	1884703a 	and	r2,r3,r2
8113659c:	1001703a 	wrctl	status,r2
  
  return context;
811365a0:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
811365a4:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
811365a8:	e0bffe03 	ldbu	r2,-8(fp)
811365ac:	10000326 	beq	r2,zero,811365bc <OSFlagPost+0xbc>
811365b0:	10800060 	cmpeqi	r2,r2,1
811365b4:	10000b1e 	bne	r2,zero,811365e4 <OSFlagPost+0xe4>
811365b8:	00001206 	br	81136604 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
811365bc:	e0bffc17 	ldw	r2,-16(fp)
811365c0:	1080020b 	ldhu	r2,8(r2)
811365c4:	1007883a 	mov	r3,r2
811365c8:	e0bffd0b 	ldhu	r2,-12(fp)
811365cc:	0084303a 	nor	r2,zero,r2
811365d0:	1884703a 	and	r2,r3,r2
811365d4:	1007883a 	mov	r3,r2
811365d8:	e0bffc17 	ldw	r2,-16(fp)
811365dc:	10c0020d 	sth	r3,8(r2)
             break;
811365e0:	00001106 	br	81136628 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
811365e4:	e0bffc17 	ldw	r2,-16(fp)
811365e8:	10c0020b 	ldhu	r3,8(r2)
811365ec:	e0bffd0b 	ldhu	r2,-12(fp)
811365f0:	1884b03a 	or	r2,r3,r2
811365f4:	1007883a 	mov	r3,r2
811365f8:	e0bffc17 	ldw	r2,-16(fp)
811365fc:	10c0020d 	sth	r3,8(r2)
             break;
81136600:	00000906 	br	81136628 <OSFlagPost+0x128>
81136604:	e0bff317 	ldw	r2,-52(fp)
81136608:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113660c:	e0bff417 	ldw	r2,-48(fp)
81136610:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
81136614:	e0bfff17 	ldw	r2,-4(fp)
81136618:	00c01c44 	movi	r3,113
8113661c:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
81136620:	0005883a 	mov	r2,zero
81136624:	00009806 	br	81136888 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
81136628:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113662c:	e0bffc17 	ldw	r2,-16(fp)
81136630:	10800117 	ldw	r2,4(r2)
81136634:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81136638:	00007706 	br	81136818 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113663c:	e0bff117 	ldw	r2,-60(fp)
81136640:	10800483 	ldbu	r2,18(r2)
81136644:	10803fcc 	andi	r2,r2,255
81136648:	10c00060 	cmpeqi	r3,r2,1
8113664c:	18004a1e 	bne	r3,zero,81136778 <OSFlagPost+0x278>
81136650:	10c00088 	cmpgei	r3,r2,2
81136654:	1800021e 	bne	r3,zero,81136660 <OSFlagPost+0x160>
81136658:	10002f26 	beq	r2,zero,81136718 <OSFlagPost+0x218>
8113665c:	00005b06 	br	811367cc <OSFlagPost+0x2cc>
81136660:	10c000a0 	cmpeqi	r3,r2,2
81136664:	1800031e 	bne	r3,zero,81136674 <OSFlagPost+0x174>
81136668:	108000e0 	cmpeqi	r2,r2,3
8113666c:	1000171e 	bne	r2,zero,811366cc <OSFlagPost+0x1cc>
81136670:	00005606 	br	811367cc <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136674:	e0bffc17 	ldw	r2,-16(fp)
81136678:	10c0020b 	ldhu	r3,8(r2)
8113667c:	e0bff117 	ldw	r2,-60(fp)
81136680:	1080040b 	ldhu	r2,16(r2)
81136684:	1884703a 	and	r2,r3,r2
81136688:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113668c:	e0bff117 	ldw	r2,-60(fp)
81136690:	1080040b 	ldhu	r2,16(r2)
81136694:	10ffffcc 	andi	r3,r2,65535
81136698:	e0bff60b 	ldhu	r2,-40(fp)
8113669c:	1880541e 	bne	r3,r2,811367f0 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811366a0:	e0bff60b 	ldhu	r2,-40(fp)
811366a4:	100b883a 	mov	r5,r2
811366a8:	e13ff117 	ldw	r4,-60(fp)
811366ac:	1136bb80 	call	81136bb8 <OS_FlagTaskRdy>
811366b0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811366b4:	e0bff683 	ldbu	r2,-38(fp)
811366b8:	10800058 	cmpnei	r2,r2,1
811366bc:	10004c1e 	bne	r2,zero,811367f0 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811366c0:	00800044 	movi	r2,1
811366c4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811366c8:	00004906 	br	811367f0 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811366cc:	e0bffc17 	ldw	r2,-16(fp)
811366d0:	10c0020b 	ldhu	r3,8(r2)
811366d4:	e0bff117 	ldw	r2,-60(fp)
811366d8:	1080040b 	ldhu	r2,16(r2)
811366dc:	1884703a 	and	r2,r3,r2
811366e0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
811366e4:	e0bff60b 	ldhu	r2,-40(fp)
811366e8:	10004326 	beq	r2,zero,811367f8 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811366ec:	e0bff60b 	ldhu	r2,-40(fp)
811366f0:	100b883a 	mov	r5,r2
811366f4:	e13ff117 	ldw	r4,-60(fp)
811366f8:	1136bb80 	call	81136bb8 <OS_FlagTaskRdy>
811366fc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136700:	e0bff683 	ldbu	r2,-38(fp)
81136704:	10800058 	cmpnei	r2,r2,1
81136708:	10003b1e 	bne	r2,zero,811367f8 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113670c:	00800044 	movi	r2,1
81136710:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136714:	00003806 	br	811367f8 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136718:	e0bffc17 	ldw	r2,-16(fp)
8113671c:	1080020b 	ldhu	r2,8(r2)
81136720:	0084303a 	nor	r2,zero,r2
81136724:	1007883a 	mov	r3,r2
81136728:	e0bff117 	ldw	r2,-60(fp)
8113672c:	1080040b 	ldhu	r2,16(r2)
81136730:	1884703a 	and	r2,r3,r2
81136734:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81136738:	e0bff117 	ldw	r2,-60(fp)
8113673c:	1080040b 	ldhu	r2,16(r2)
81136740:	10ffffcc 	andi	r3,r2,65535
81136744:	e0bff60b 	ldhu	r2,-40(fp)
81136748:	18802d1e 	bne	r3,r2,81136800 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113674c:	e0bff60b 	ldhu	r2,-40(fp)
81136750:	100b883a 	mov	r5,r2
81136754:	e13ff117 	ldw	r4,-60(fp)
81136758:	1136bb80 	call	81136bb8 <OS_FlagTaskRdy>
8113675c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81136760:	e0bff683 	ldbu	r2,-38(fp)
81136764:	10800058 	cmpnei	r2,r2,1
81136768:	1000251e 	bne	r2,zero,81136800 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113676c:	00800044 	movi	r2,1
81136770:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81136774:	00002206 	br	81136800 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81136778:	e0bffc17 	ldw	r2,-16(fp)
8113677c:	1080020b 	ldhu	r2,8(r2)
81136780:	0084303a 	nor	r2,zero,r2
81136784:	1007883a 	mov	r3,r2
81136788:	e0bff117 	ldw	r2,-60(fp)
8113678c:	1080040b 	ldhu	r2,16(r2)
81136790:	1884703a 	and	r2,r3,r2
81136794:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81136798:	e0bff60b 	ldhu	r2,-40(fp)
8113679c:	10001a26 	beq	r2,zero,81136808 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811367a0:	e0bff60b 	ldhu	r2,-40(fp)
811367a4:	100b883a 	mov	r5,r2
811367a8:	e13ff117 	ldw	r4,-60(fp)
811367ac:	1136bb80 	call	81136bb8 <OS_FlagTaskRdy>
811367b0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811367b4:	e0bff683 	ldbu	r2,-38(fp)
811367b8:	10800058 	cmpnei	r2,r2,1
811367bc:	1000121e 	bne	r2,zero,81136808 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811367c0:	00800044 	movi	r2,1
811367c4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811367c8:	00000f06 	br	81136808 <OSFlagPost+0x308>
811367cc:	e0bff317 	ldw	r2,-52(fp)
811367d0:	e0bff515 	stw	r2,-44(fp)
811367d4:	e0bff517 	ldw	r2,-44(fp)
811367d8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811367dc:	e0bfff17 	ldw	r2,-4(fp)
811367e0:	00c01bc4 	movi	r3,111
811367e4:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811367e8:	0005883a 	mov	r2,zero
811367ec:	00002606 	br	81136888 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811367f0:	0001883a 	nop
811367f4:	00000506 	br	8113680c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811367f8:	0001883a 	nop
811367fc:	00000306 	br	8113680c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81136800:	0001883a 	nop
81136804:	00000106 	br	8113680c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81136808:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113680c:	e0bff117 	ldw	r2,-60(fp)
81136810:	10800017 	ldw	r2,0(r2)
81136814:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81136818:	e0bff117 	ldw	r2,-60(fp)
8113681c:	103f871e 	bne	r2,zero,8113663c <__reset+0xfb11663c>
81136820:	e0bff317 	ldw	r2,-52(fp)
81136824:	e0bff715 	stw	r2,-36(fp)
81136828:	e0bff717 	ldw	r2,-36(fp)
8113682c:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
81136830:	e0bff203 	ldbu	r2,-56(fp)
81136834:	10800058 	cmpnei	r2,r2,1
81136838:	1000011e 	bne	r2,zero,81136840 <OSFlagPost+0x340>
        OS_Sched();
8113683c:	1134cc80 	call	81134cc8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136840:	0005303a 	rdctl	r2,status
81136844:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136848:	e0fffa17 	ldw	r3,-24(fp)
8113684c:	00bfff84 	movi	r2,-2
81136850:	1884703a 	and	r2,r3,r2
81136854:	1001703a 	wrctl	status,r2
  
  return context;
81136858:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113685c:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81136860:	e0bffc17 	ldw	r2,-16(fp)
81136864:	1080020b 	ldhu	r2,8(r2)
81136868:	e0bff90d 	sth	r2,-28(fp)
8113686c:	e0bff317 	ldw	r2,-52(fp)
81136870:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136874:	e0bff817 	ldw	r2,-32(fp)
81136878:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113687c:	e0bfff17 	ldw	r2,-4(fp)
81136880:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81136884:	e0bff90b 	ldhu	r2,-28(fp)
}
81136888:	e037883a 	mov	sp,fp
8113688c:	dfc00117 	ldw	ra,4(sp)
81136890:	df000017 	ldw	fp,0(sp)
81136894:	dec00204 	addi	sp,sp,8
81136898:	f800283a 	ret

8113689c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113689c:	defff904 	addi	sp,sp,-28
811368a0:	de00012e 	bgeu	sp,et,811368a8 <OSFlagQuery+0xc>
811368a4:	003b68fa 	trap	3
811368a8:	df000615 	stw	fp,24(sp)
811368ac:	df000604 	addi	fp,sp,24
811368b0:	e13ffe15 	stw	r4,-8(fp)
811368b4:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
811368b8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
811368bc:	e0bfff17 	ldw	r2,-4(fp)
811368c0:	1000021e 	bne	r2,zero,811368cc <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
811368c4:	0005883a 	mov	r2,zero
811368c8:	00002306 	br	81136958 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
811368cc:	e0bffe17 	ldw	r2,-8(fp)
811368d0:	1000051e 	bne	r2,zero,811368e8 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811368d4:	e0bfff17 	ldw	r2,-4(fp)
811368d8:	00c01b84 	movi	r3,110
811368dc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811368e0:	0005883a 	mov	r2,zero
811368e4:	00001c06 	br	81136958 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
811368e8:	e0bffe17 	ldw	r2,-8(fp)
811368ec:	10800003 	ldbu	r2,0(r2)
811368f0:	10803fcc 	andi	r2,r2,255
811368f4:	10800160 	cmpeqi	r2,r2,5
811368f8:	1000051e 	bne	r2,zero,81136910 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811368fc:	e0bfff17 	ldw	r2,-4(fp)
81136900:	00c00044 	movi	r3,1
81136904:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136908:	0005883a 	mov	r2,zero
8113690c:	00001206 	br	81136958 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136910:	0005303a 	rdctl	r2,status
81136914:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136918:	e0fffc17 	ldw	r3,-16(fp)
8113691c:	00bfff84 	movi	r2,-2
81136920:	1884703a 	and	r2,r3,r2
81136924:	1001703a 	wrctl	status,r2
  
  return context;
81136928:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113692c:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
81136930:	e0bffe17 	ldw	r2,-8(fp)
81136934:	1080020b 	ldhu	r2,8(r2)
81136938:	e0bffb0d 	sth	r2,-20(fp)
8113693c:	e0bffa17 	ldw	r2,-24(fp)
81136940:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136944:	e0bffd17 	ldw	r2,-12(fp)
81136948:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113694c:	e0bfff17 	ldw	r2,-4(fp)
81136950:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
81136954:	e0bffb0b 	ldhu	r2,-20(fp)
}
81136958:	e037883a 	mov	sp,fp
8113695c:	df000017 	ldw	fp,0(sp)
81136960:	dec00104 	addi	sp,sp,4
81136964:	f800283a 	ret

81136968 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
81136968:	defff804 	addi	sp,sp,-32
8113696c:	de00012e 	bgeu	sp,et,81136974 <OS_FlagBlock+0xc>
81136970:	003b68fa 	trap	3
81136974:	df000715 	stw	fp,28(sp)
81136978:	df000704 	addi	fp,sp,28
8113697c:	e13ffb15 	stw	r4,-20(fp)
81136980:	e17ffc15 	stw	r5,-16(fp)
81136984:	3009883a 	mov	r4,r6
81136988:	3807883a 	mov	r3,r7
8113698c:	e0800117 	ldw	r2,4(fp)
81136990:	e13ffd0d 	sth	r4,-12(fp)
81136994:	e0fffe05 	stb	r3,-8(fp)
81136998:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113699c:	d0a09c17 	ldw	r2,-32144(gp)
811369a0:	d0e09c17 	ldw	r3,-32144(gp)
811369a4:	18c00c03 	ldbu	r3,48(r3)
811369a8:	18c00814 	ori	r3,r3,32
811369ac:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
811369b0:	d0a09c17 	ldw	r2,-32144(gp)
811369b4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
811369b8:	d0a09c17 	ldw	r2,-32144(gp)
811369bc:	e0ffff0b 	ldhu	r3,-4(fp)
811369c0:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
811369c4:	d0a09c17 	ldw	r2,-32144(gp)
811369c8:	e0fffc17 	ldw	r3,-16(fp)
811369cc:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
811369d0:	e0bffc17 	ldw	r2,-16(fp)
811369d4:	e0fffd0b 	ldhu	r3,-12(fp)
811369d8:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
811369dc:	e0bffc17 	ldw	r2,-16(fp)
811369e0:	e0fffe03 	ldbu	r3,-8(fp)
811369e4:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
811369e8:	d0e09c17 	ldw	r3,-32144(gp)
811369ec:	e0bffc17 	ldw	r2,-16(fp)
811369f0:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
811369f4:	e0bffb17 	ldw	r2,-20(fp)
811369f8:	10c00117 	ldw	r3,4(r2)
811369fc:	e0bffc17 	ldw	r2,-16(fp)
81136a00:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
81136a04:	e0bffc17 	ldw	r2,-16(fp)
81136a08:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
81136a0c:	e0bffc17 	ldw	r2,-16(fp)
81136a10:	e0fffb17 	ldw	r3,-20(fp)
81136a14:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81136a18:	e0bffb17 	ldw	r2,-20(fp)
81136a1c:	10800117 	ldw	r2,4(r2)
81136a20:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
81136a24:	e0bff917 	ldw	r2,-28(fp)
81136a28:	10000326 	beq	r2,zero,81136a38 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
81136a2c:	e0bff917 	ldw	r2,-28(fp)
81136a30:	e0fffc17 	ldw	r3,-16(fp)
81136a34:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
81136a38:	e0bffb17 	ldw	r2,-20(fp)
81136a3c:	e0fffc17 	ldw	r3,-16(fp)
81136a40:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
81136a44:	d0a09c17 	ldw	r2,-32144(gp)
81136a48:	10800d03 	ldbu	r2,52(r2)
81136a4c:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81136a50:	e0fffa03 	ldbu	r3,-24(fp)
81136a54:	e13ffa03 	ldbu	r4,-24(fp)
81136a58:	d0a09844 	addi	r2,gp,-32159
81136a5c:	2085883a 	add	r2,r4,r2
81136a60:	10800003 	ldbu	r2,0(r2)
81136a64:	1009883a 	mov	r4,r2
81136a68:	d0a09c17 	ldw	r2,-32144(gp)
81136a6c:	10800d43 	ldbu	r2,53(r2)
81136a70:	0084303a 	nor	r2,zero,r2
81136a74:	2084703a 	and	r2,r4,r2
81136a78:	1009883a 	mov	r4,r2
81136a7c:	d0a09844 	addi	r2,gp,-32159
81136a80:	1885883a 	add	r2,r3,r2
81136a84:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81136a88:	e0fffa03 	ldbu	r3,-24(fp)
81136a8c:	d0a09844 	addi	r2,gp,-32159
81136a90:	1885883a 	add	r2,r3,r2
81136a94:	10800003 	ldbu	r2,0(r2)
81136a98:	10803fcc 	andi	r2,r2,255
81136a9c:	1000071e 	bne	r2,zero,81136abc <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81136aa0:	d0a09c17 	ldw	r2,-32144(gp)
81136aa4:	10800d83 	ldbu	r2,54(r2)
81136aa8:	0084303a 	nor	r2,zero,r2
81136aac:	1007883a 	mov	r3,r2
81136ab0:	d0a09803 	ldbu	r2,-32160(gp)
81136ab4:	1884703a 	and	r2,r3,r2
81136ab8:	d0a09805 	stb	r2,-32160(gp)
    }
}
81136abc:	0001883a 	nop
81136ac0:	e037883a 	mov	sp,fp
81136ac4:	df000017 	ldw	fp,0(sp)
81136ac8:	dec00104 	addi	sp,sp,4
81136acc:	f800283a 	ret

81136ad0 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81136ad0:	defffb04 	addi	sp,sp,-20
81136ad4:	de00012e 	bgeu	sp,et,81136adc <OS_FlagInit+0xc>
81136ad8:	003b68fa 	trap	3
81136adc:	dfc00415 	stw	ra,16(sp)
81136ae0:	df000315 	stw	fp,12(sp)
81136ae4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
81136ae8:	0141b804 	movi	r5,1760
81136aec:	012045b4 	movhi	r4,33046
81136af0:	21036904 	addi	r4,r4,3492
81136af4:	1134bfc0 	call	81134bfc <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
81136af8:	00a045b4 	movhi	r2,33046
81136afc:	10836904 	addi	r2,r2,3492
81136b00:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
81136b04:	00a045b4 	movhi	r2,33046
81136b08:	10837404 	addi	r2,r2,3536
81136b0c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81136b10:	e03ffd0d 	sth	zero,-12(fp)
81136b14:	00001306 	br	81136b64 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136b18:	e0bffe17 	ldw	r2,-8(fp)
81136b1c:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81136b20:	e0bffe17 	ldw	r2,-8(fp)
81136b24:	e0ffff17 	ldw	r3,-4(fp)
81136b28:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
81136b2c:	e0bffe17 	ldw	r2,-8(fp)
81136b30:	00c00fc4 	movi	r3,63
81136b34:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81136b38:	e0bffe17 	ldw	r2,-8(fp)
81136b3c:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81136b40:	e0bffe17 	ldw	r2,-8(fp)
81136b44:	10800b04 	addi	r2,r2,44
81136b48:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81136b4c:	e0bfff17 	ldw	r2,-4(fp)
81136b50:	10800b04 	addi	r2,r2,44
81136b54:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81136b58:	e0bffd0b 	ldhu	r2,-12(fp)
81136b5c:	10800044 	addi	r2,r2,1
81136b60:	e0bffd0d 	sth	r2,-12(fp)
81136b64:	e0bffd0b 	ldhu	r2,-12(fp)
81136b68:	108009f0 	cmpltui	r2,r2,39
81136b6c:	103fea1e 	bne	r2,zero,81136b18 <__reset+0xfb116b18>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136b70:	e0bffe17 	ldw	r2,-8(fp)
81136b74:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81136b78:	e0bffe17 	ldw	r2,-8(fp)
81136b7c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81136b80:	e0bffe17 	ldw	r2,-8(fp)
81136b84:	00c00fc4 	movi	r3,63
81136b88:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81136b8c:	e0bffe17 	ldw	r2,-8(fp)
81136b90:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81136b94:	00a045b4 	movhi	r2,33046
81136b98:	10836904 	addi	r2,r2,3492
81136b9c:	d0a0a015 	stw	r2,-32128(gp)
#endif
}
81136ba0:	0001883a 	nop
81136ba4:	e037883a 	mov	sp,fp
81136ba8:	dfc00117 	ldw	ra,4(sp)
81136bac:	df000017 	ldw	fp,0(sp)
81136bb0:	dec00204 	addi	sp,sp,8
81136bb4:	f800283a 	ret

81136bb8 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81136bb8:	defffa04 	addi	sp,sp,-24
81136bbc:	de00012e 	bgeu	sp,et,81136bc4 <OS_FlagTaskRdy+0xc>
81136bc0:	003b68fa 	trap	3
81136bc4:	dfc00515 	stw	ra,20(sp)
81136bc8:	df000415 	stw	fp,16(sp)
81136bcc:	df000404 	addi	fp,sp,16
81136bd0:	e13ffe15 	stw	r4,-8(fp)
81136bd4:	2805883a 	mov	r2,r5
81136bd8:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
81136bdc:	e0bffe17 	ldw	r2,-8(fp)
81136be0:	10800217 	ldw	r2,8(r2)
81136be4:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81136be8:	e0bffd17 	ldw	r2,-12(fp)
81136bec:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81136bf0:	e0bffd17 	ldw	r2,-12(fp)
81136bf4:	e0ffff0b 	ldhu	r3,-4(fp)
81136bf8:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
81136bfc:	e0bffd17 	ldw	r2,-12(fp)
81136c00:	10c00c03 	ldbu	r3,48(r2)
81136c04:	00bff7c4 	movi	r2,-33
81136c08:	1884703a 	and	r2,r3,r2
81136c0c:	1007883a 	mov	r3,r2
81136c10:	e0bffd17 	ldw	r2,-12(fp)
81136c14:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81136c18:	e0bffd17 	ldw	r2,-12(fp)
81136c1c:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81136c20:	e0bffd17 	ldw	r2,-12(fp)
81136c24:	10800c03 	ldbu	r2,48(r2)
81136c28:	10803fcc 	andi	r2,r2,255
81136c2c:	1000181e 	bne	r2,zero,81136c90 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81136c30:	e0bffd17 	ldw	r2,-12(fp)
81136c34:	10c00d83 	ldbu	r3,54(r2)
81136c38:	d0a09803 	ldbu	r2,-32160(gp)
81136c3c:	1884b03a 	or	r2,r3,r2
81136c40:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81136c44:	e0bffd17 	ldw	r2,-12(fp)
81136c48:	10800d03 	ldbu	r2,52(r2)
81136c4c:	10c03fcc 	andi	r3,r2,255
81136c50:	e0bffd17 	ldw	r2,-12(fp)
81136c54:	10800d03 	ldbu	r2,52(r2)
81136c58:	11003fcc 	andi	r4,r2,255
81136c5c:	d0a09844 	addi	r2,gp,-32159
81136c60:	2085883a 	add	r2,r4,r2
81136c64:	11000003 	ldbu	r4,0(r2)
81136c68:	e0bffd17 	ldw	r2,-12(fp)
81136c6c:	10800d43 	ldbu	r2,53(r2)
81136c70:	2084b03a 	or	r2,r4,r2
81136c74:	1009883a 	mov	r4,r2
81136c78:	d0a09844 	addi	r2,gp,-32159
81136c7c:	1885883a 	add	r2,r3,r2
81136c80:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81136c84:	00800044 	movi	r2,1
81136c88:	e0bffc05 	stb	r2,-16(fp)
81136c8c:	00000106 	br	81136c94 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81136c90:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81136c94:	e13ffe17 	ldw	r4,-8(fp)
81136c98:	1136cb40 	call	81136cb4 <OS_FlagUnlink>
    return (sched);
81136c9c:	e0bffc03 	ldbu	r2,-16(fp)
}
81136ca0:	e037883a 	mov	sp,fp
81136ca4:	dfc00117 	ldw	ra,4(sp)
81136ca8:	df000017 	ldw	fp,0(sp)
81136cac:	dec00204 	addi	sp,sp,8
81136cb0:	f800283a 	ret

81136cb4 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
81136cb4:	defffa04 	addi	sp,sp,-24
81136cb8:	de00012e 	bgeu	sp,et,81136cc0 <OS_FlagUnlink+0xc>
81136cbc:	003b68fa 	trap	3
81136cc0:	df000515 	stw	fp,20(sp)
81136cc4:	df000504 	addi	fp,sp,20
81136cc8:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
81136ccc:	e0bfff17 	ldw	r2,-4(fp)
81136cd0:	10800117 	ldw	r2,4(r2)
81136cd4:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81136cd8:	e0bfff17 	ldw	r2,-4(fp)
81136cdc:	10800017 	ldw	r2,0(r2)
81136ce0:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
81136ce4:	e0bffb17 	ldw	r2,-20(fp)
81136ce8:	10000b1e 	bne	r2,zero,81136d18 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
81136cec:	e0bfff17 	ldw	r2,-4(fp)
81136cf0:	10800317 	ldw	r2,12(r2)
81136cf4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81136cf8:	e0bffd17 	ldw	r2,-12(fp)
81136cfc:	e0fffc17 	ldw	r3,-16(fp)
81136d00:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81136d04:	e0bffc17 	ldw	r2,-16(fp)
81136d08:	10000b26 	beq	r2,zero,81136d38 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81136d0c:	e0bffc17 	ldw	r2,-16(fp)
81136d10:	10000115 	stw	zero,4(r2)
81136d14:	00000806 	br	81136d38 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81136d18:	e0bffb17 	ldw	r2,-20(fp)
81136d1c:	e0fffc17 	ldw	r3,-16(fp)
81136d20:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81136d24:	e0bffc17 	ldw	r2,-16(fp)
81136d28:	10000326 	beq	r2,zero,81136d38 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81136d2c:	e0bffc17 	ldw	r2,-16(fp)
81136d30:	e0fffb17 	ldw	r3,-20(fp)
81136d34:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81136d38:	e0bfff17 	ldw	r2,-4(fp)
81136d3c:	10800217 	ldw	r2,8(r2)
81136d40:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81136d44:	e0bffe17 	ldw	r2,-8(fp)
81136d48:	10000a15 	stw	zero,40(r2)
#endif
}
81136d4c:	0001883a 	nop
81136d50:	e037883a 	mov	sp,fp
81136d54:	df000017 	ldw	fp,0(sp)
81136d58:	dec00104 	addi	sp,sp,4
81136d5c:	f800283a 	ret

81136d60 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81136d60:	defff404 	addi	sp,sp,-48
81136d64:	de00012e 	bgeu	sp,et,81136d6c <OSMemCreate+0xc>
81136d68:	003b68fa 	trap	3
81136d6c:	df000b15 	stw	fp,44(sp)
81136d70:	df000b04 	addi	fp,sp,44
81136d74:	e13ffc15 	stw	r4,-16(fp)
81136d78:	e17ffd15 	stw	r5,-12(fp)
81136d7c:	e1bffe15 	stw	r6,-8(fp)
81136d80:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136d84:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81136d88:	e0bfff17 	ldw	r2,-4(fp)
81136d8c:	1000021e 	bne	r2,zero,81136d98 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81136d90:	0005883a 	mov	r2,zero
81136d94:	00006506 	br	81136f2c <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81136d98:	e0bffc17 	ldw	r2,-16(fp)
81136d9c:	1000051e 	bne	r2,zero,81136db4 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81136da0:	e0bfff17 	ldw	r2,-4(fp)
81136da4:	00c01884 	movi	r3,98
81136da8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136dac:	0005883a 	mov	r2,zero
81136db0:	00005e06 	br	81136f2c <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
81136db4:	e0bffc17 	ldw	r2,-16(fp)
81136db8:	108000cc 	andi	r2,r2,3
81136dbc:	10000526 	beq	r2,zero,81136dd4 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81136dc0:	e0bfff17 	ldw	r2,-4(fp)
81136dc4:	00c01884 	movi	r3,98
81136dc8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136dcc:	0005883a 	mov	r2,zero
81136dd0:	00005606 	br	81136f2c <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
81136dd4:	e0bffd17 	ldw	r2,-12(fp)
81136dd8:	108000a8 	cmpgeui	r2,r2,2
81136ddc:	1000051e 	bne	r2,zero,81136df4 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81136de0:	e0bfff17 	ldw	r2,-4(fp)
81136de4:	00c016c4 	movi	r3,91
81136de8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136dec:	0005883a 	mov	r2,zero
81136df0:	00004e06 	br	81136f2c <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
81136df4:	e0bffe17 	ldw	r2,-8(fp)
81136df8:	10800128 	cmpgeui	r2,r2,4
81136dfc:	1000051e 	bne	r2,zero,81136e14 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81136e00:	e0bfff17 	ldw	r2,-4(fp)
81136e04:	00c01704 	movi	r3,92
81136e08:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136e0c:	0005883a 	mov	r2,zero
81136e10:	00004606 	br	81136f2c <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136e14:	0005303a 	rdctl	r2,status
81136e18:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136e1c:	e0fffb17 	ldw	r3,-20(fp)
81136e20:	00bfff84 	movi	r2,-2
81136e24:	1884703a 	and	r2,r3,r2
81136e28:	1001703a 	wrctl	status,r2
  
  return context;
81136e2c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136e30:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81136e34:	d0a09517 	ldw	r2,-32172(gp)
81136e38:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81136e3c:	d0a09517 	ldw	r2,-32172(gp)
81136e40:	10000326 	beq	r2,zero,81136e50 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81136e44:	d0a09517 	ldw	r2,-32172(gp)
81136e48:	10800117 	ldw	r2,4(r2)
81136e4c:	d0a09515 	stw	r2,-32172(gp)
81136e50:	e0bff817 	ldw	r2,-32(fp)
81136e54:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136e58:	e0bff917 	ldw	r2,-28(fp)
81136e5c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81136e60:	e0bffa17 	ldw	r2,-24(fp)
81136e64:	1000051e 	bne	r2,zero,81136e7c <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81136e68:	e0bfff17 	ldw	r2,-4(fp)
81136e6c:	00c01684 	movi	r3,90
81136e70:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81136e74:	0005883a 	mov	r2,zero
81136e78:	00002c06 	br	81136f2c <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81136e7c:	e0bffc17 	ldw	r2,-16(fp)
81136e80:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81136e84:	e0fffc17 	ldw	r3,-16(fp)
81136e88:	e0bffe17 	ldw	r2,-8(fp)
81136e8c:	1885883a 	add	r2,r3,r2
81136e90:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81136e94:	e03ff715 	stw	zero,-36(fp)
81136e98:	00000c06 	br	81136ecc <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81136e9c:	e0bff617 	ldw	r2,-40(fp)
81136ea0:	e0fff517 	ldw	r3,-44(fp)
81136ea4:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81136ea8:	e0bff517 	ldw	r2,-44(fp)
81136eac:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81136eb0:	e0fff517 	ldw	r3,-44(fp)
81136eb4:	e0bffe17 	ldw	r2,-8(fp)
81136eb8:	1885883a 	add	r2,r3,r2
81136ebc:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81136ec0:	e0bff717 	ldw	r2,-36(fp)
81136ec4:	10800044 	addi	r2,r2,1
81136ec8:	e0bff715 	stw	r2,-36(fp)
81136ecc:	e0bffd17 	ldw	r2,-12(fp)
81136ed0:	10bfffc4 	addi	r2,r2,-1
81136ed4:	e0fff717 	ldw	r3,-36(fp)
81136ed8:	18bff036 	bltu	r3,r2,81136e9c <__reset+0xfb116e9c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
81136edc:	e0bff617 	ldw	r2,-40(fp)
81136ee0:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81136ee4:	e0bffa17 	ldw	r2,-24(fp)
81136ee8:	e0fffc17 	ldw	r3,-16(fp)
81136eec:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81136ef0:	e0bffa17 	ldw	r2,-24(fp)
81136ef4:	e0fffc17 	ldw	r3,-16(fp)
81136ef8:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
81136efc:	e0bffa17 	ldw	r2,-24(fp)
81136f00:	e0fffd17 	ldw	r3,-12(fp)
81136f04:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81136f08:	e0bffa17 	ldw	r2,-24(fp)
81136f0c:	e0fffd17 	ldw	r3,-12(fp)
81136f10:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81136f14:	e0bffa17 	ldw	r2,-24(fp)
81136f18:	e0fffe17 	ldw	r3,-8(fp)
81136f1c:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81136f20:	e0bfff17 	ldw	r2,-4(fp)
81136f24:	10000005 	stb	zero,0(r2)
    return (pmem);
81136f28:	e0bffa17 	ldw	r2,-24(fp)
}
81136f2c:	e037883a 	mov	sp,fp
81136f30:	df000017 	ldw	fp,0(sp)
81136f34:	dec00104 	addi	sp,sp,4
81136f38:	f800283a 	ret

81136f3c <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81136f3c:	defff804 	addi	sp,sp,-32
81136f40:	de00012e 	bgeu	sp,et,81136f48 <OSMemGet+0xc>
81136f44:	003b68fa 	trap	3
81136f48:	df000715 	stw	fp,28(sp)
81136f4c:	df000704 	addi	fp,sp,28
81136f50:	e13ffe15 	stw	r4,-8(fp)
81136f54:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136f58:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81136f5c:	e0bfff17 	ldw	r2,-4(fp)
81136f60:	1000021e 	bne	r2,zero,81136f6c <OSMemGet+0x30>
        return ((void *)0);
81136f64:	0005883a 	mov	r2,zero
81136f68:	00002e06 	br	81137024 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81136f6c:	e0bffe17 	ldw	r2,-8(fp)
81136f70:	1000051e 	bne	r2,zero,81136f88 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81136f74:	e0bfff17 	ldw	r2,-4(fp)
81136f78:	00c01804 	movi	r3,96
81136f7c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81136f80:	0005883a 	mov	r2,zero
81136f84:	00002706 	br	81137024 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136f88:	0005303a 	rdctl	r2,status
81136f8c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136f90:	e0fffd17 	ldw	r3,-12(fp)
81136f94:	00bfff84 	movi	r2,-2
81136f98:	1884703a 	and	r2,r3,r2
81136f9c:	1001703a 	wrctl	status,r2
  
  return context;
81136fa0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136fa4:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81136fa8:	e0bffe17 	ldw	r2,-8(fp)
81136fac:	10800417 	ldw	r2,16(r2)
81136fb0:	10001426 	beq	r2,zero,81137004 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81136fb4:	e0bffe17 	ldw	r2,-8(fp)
81136fb8:	10800117 	ldw	r2,4(r2)
81136fbc:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81136fc0:	e0bffb17 	ldw	r2,-20(fp)
81136fc4:	10c00017 	ldw	r3,0(r2)
81136fc8:	e0bffe17 	ldw	r2,-8(fp)
81136fcc:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81136fd0:	e0bffe17 	ldw	r2,-8(fp)
81136fd4:	10800417 	ldw	r2,16(r2)
81136fd8:	10ffffc4 	addi	r3,r2,-1
81136fdc:	e0bffe17 	ldw	r2,-8(fp)
81136fe0:	10c00415 	stw	r3,16(r2)
81136fe4:	e0bff917 	ldw	r2,-28(fp)
81136fe8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136fec:	e0bffa17 	ldw	r2,-24(fp)
81136ff0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81136ff4:	e0bfff17 	ldw	r2,-4(fp)
81136ff8:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
81136ffc:	e0bffb17 	ldw	r2,-20(fp)
81137000:	00000806 	br	81137024 <OSMemGet+0xe8>
81137004:	e0bff917 	ldw	r2,-28(fp)
81137008:	e0bffc15 	stw	r2,-16(fp)
8113700c:	e0bffc17 	ldw	r2,-16(fp)
81137010:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81137014:	e0bfff17 	ldw	r2,-4(fp)
81137018:	00c01744 	movi	r3,93
8113701c:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81137020:	0005883a 	mov	r2,zero
}
81137024:	e037883a 	mov	sp,fp
81137028:	df000017 	ldw	fp,0(sp)
8113702c:	dec00104 	addi	sp,sp,4
81137030:	f800283a 	ret

81137034 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81137034:	defff704 	addi	sp,sp,-36
81137038:	de00012e 	bgeu	sp,et,81137040 <OSMemNameGet+0xc>
8113703c:	003b68fa 	trap	3
81137040:	dfc00815 	stw	ra,32(sp)
81137044:	df000715 	stw	fp,28(sp)
81137048:	df000704 	addi	fp,sp,28
8113704c:	e13ffd15 	stw	r4,-12(fp)
81137050:	e17ffe15 	stw	r5,-8(fp)
81137054:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137058:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113705c:	e0bfff17 	ldw	r2,-4(fp)
81137060:	1000021e 	bne	r2,zero,8113706c <OSMemNameGet+0x38>
        return (0);
81137064:	0005883a 	mov	r2,zero
81137068:	00002b06 	br	81137118 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113706c:	e0bffd17 	ldw	r2,-12(fp)
81137070:	1000051e 	bne	r2,zero,81137088 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81137074:	e0bfff17 	ldw	r2,-4(fp)
81137078:	00c01804 	movi	r3,96
8113707c:	10c00005 	stb	r3,0(r2)
        return (0);
81137080:	0005883a 	mov	r2,zero
81137084:	00002406 	br	81137118 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137088:	e0bffe17 	ldw	r2,-8(fp)
8113708c:	1000051e 	bne	r2,zero,811370a4 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81137090:	e0bfff17 	ldw	r2,-4(fp)
81137094:	00c00304 	movi	r3,12
81137098:	10c00005 	stb	r3,0(r2)
        return (0);
8113709c:	0005883a 	mov	r2,zero
811370a0:	00001d06 	br	81137118 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811370a4:	d0a09b03 	ldbu	r2,-32148(gp)
811370a8:	10803fcc 	andi	r2,r2,255
811370ac:	10000526 	beq	r2,zero,811370c4 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
811370b0:	e0bfff17 	ldw	r2,-4(fp)
811370b4:	00c00444 	movi	r3,17
811370b8:	10c00005 	stb	r3,0(r2)
        return (0);
811370bc:	0005883a 	mov	r2,zero
811370c0:	00001506 	br	81137118 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811370c4:	0005303a 	rdctl	r2,status
811370c8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811370cc:	e0fffb17 	ldw	r3,-20(fp)
811370d0:	00bfff84 	movi	r2,-2
811370d4:	1884703a 	and	r2,r3,r2
811370d8:	1001703a 	wrctl	status,r2
  
  return context;
811370dc:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
811370e0:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
811370e4:	e0bffd17 	ldw	r2,-12(fp)
811370e8:	10800504 	addi	r2,r2,20
811370ec:	100b883a 	mov	r5,r2
811370f0:	e13ffe17 	ldw	r4,-8(fp)
811370f4:	1134e1c0 	call	81134e1c <OS_StrCopy>
811370f8:	e0bffa05 	stb	r2,-24(fp)
811370fc:	e0bff917 	ldw	r2,-28(fp)
81137100:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137104:	e0bffc17 	ldw	r2,-16(fp)
81137108:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113710c:	e0bfff17 	ldw	r2,-4(fp)
81137110:	10000005 	stb	zero,0(r2)
    return (len);
81137114:	e0bffa03 	ldbu	r2,-24(fp)
}
81137118:	e037883a 	mov	sp,fp
8113711c:	dfc00117 	ldw	ra,4(sp)
81137120:	df000017 	ldw	fp,0(sp)
81137124:	dec00204 	addi	sp,sp,8
81137128:	f800283a 	ret

8113712c <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113712c:	defff604 	addi	sp,sp,-40
81137130:	de00012e 	bgeu	sp,et,81137138 <OSMemNameSet+0xc>
81137134:	003b68fa 	trap	3
81137138:	dfc00915 	stw	ra,36(sp)
8113713c:	df000815 	stw	fp,32(sp)
81137140:	df000804 	addi	fp,sp,32
81137144:	e13ffd15 	stw	r4,-12(fp)
81137148:	e17ffe15 	stw	r5,-8(fp)
8113714c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137150:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137154:	e0bfff17 	ldw	r2,-4(fp)
81137158:	10003526 	beq	r2,zero,81137230 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113715c:	e0bffd17 	ldw	r2,-12(fp)
81137160:	1000041e 	bne	r2,zero,81137174 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81137164:	e0bfff17 	ldw	r2,-4(fp)
81137168:	00c01804 	movi	r3,96
8113716c:	10c00005 	stb	r3,0(r2)
        return;
81137170:	00003006 	br	81137234 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81137174:	e0bffe17 	ldw	r2,-8(fp)
81137178:	1000041e 	bne	r2,zero,8113718c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113717c:	e0bfff17 	ldw	r2,-4(fp)
81137180:	00c00304 	movi	r3,12
81137184:	10c00005 	stb	r3,0(r2)
        return;
81137188:	00002a06 	br	81137234 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113718c:	d0a09b03 	ldbu	r2,-32148(gp)
81137190:	10803fcc 	andi	r2,r2,255
81137194:	10000426 	beq	r2,zero,811371a8 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81137198:	e0bfff17 	ldw	r2,-4(fp)
8113719c:	00c00484 	movi	r3,18
811371a0:	10c00005 	stb	r3,0(r2)
        return;
811371a4:	00002306 	br	81137234 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811371a8:	0005303a 	rdctl	r2,status
811371ac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811371b0:	e0fffc17 	ldw	r3,-16(fp)
811371b4:	00bfff84 	movi	r2,-2
811371b8:	1884703a 	and	r2,r3,r2
811371bc:	1001703a 	wrctl	status,r2
  
  return context;
811371c0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811371c4:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
811371c8:	e13ffe17 	ldw	r4,-8(fp)
811371cc:	1134e980 	call	81134e98 <OS_StrLen>
811371d0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
811371d4:	e0bffa03 	ldbu	r2,-24(fp)
811371d8:	10800830 	cmpltui	r2,r2,32
811371dc:	1000081e 	bne	r2,zero,81137200 <OSMemNameSet+0xd4>
811371e0:	e0bff817 	ldw	r2,-32(fp)
811371e4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811371e8:	e0bff917 	ldw	r2,-28(fp)
811371ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
811371f0:	e0bfff17 	ldw	r2,-4(fp)
811371f4:	00c018c4 	movi	r3,99
811371f8:	10c00005 	stb	r3,0(r2)
        return;
811371fc:	00000d06 	br	81137234 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81137200:	e0bffd17 	ldw	r2,-12(fp)
81137204:	10800504 	addi	r2,r2,20
81137208:	e17ffe17 	ldw	r5,-8(fp)
8113720c:	1009883a 	mov	r4,r2
81137210:	1134e1c0 	call	81134e1c <OS_StrCopy>
81137214:	e0bff817 	ldw	r2,-32(fp)
81137218:	e0bffb15 	stw	r2,-20(fp)
8113721c:	e0bffb17 	ldw	r2,-20(fp)
81137220:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137224:	e0bfff17 	ldw	r2,-4(fp)
81137228:	10000005 	stb	zero,0(r2)
8113722c:	00000106 	br	81137234 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81137230:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81137234:	e037883a 	mov	sp,fp
81137238:	dfc00117 	ldw	ra,4(sp)
8113723c:	df000017 	ldw	fp,0(sp)
81137240:	dec00204 	addi	sp,sp,8
81137244:	f800283a 	ret

81137248 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
81137248:	defff904 	addi	sp,sp,-28
8113724c:	de00012e 	bgeu	sp,et,81137254 <OSMemPut+0xc>
81137250:	003b68fa 	trap	3
81137254:	df000615 	stw	fp,24(sp)
81137258:	df000604 	addi	fp,sp,24
8113725c:	e13ffe15 	stw	r4,-8(fp)
81137260:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137264:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81137268:	e0bffe17 	ldw	r2,-8(fp)
8113726c:	1000021e 	bne	r2,zero,81137278 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81137270:	00801804 	movi	r2,96
81137274:	00002806 	br	81137318 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
81137278:	e0bfff17 	ldw	r2,-4(fp)
8113727c:	1000021e 	bne	r2,zero,81137288 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81137280:	008017c4 	movi	r2,95
81137284:	00002406 	br	81137318 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137288:	0005303a 	rdctl	r2,status
8113728c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137290:	e0fffd17 	ldw	r3,-12(fp)
81137294:	00bfff84 	movi	r2,-2
81137298:	1884703a 	and	r2,r3,r2
8113729c:	1001703a 	wrctl	status,r2
  
  return context;
811372a0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811372a4:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
811372a8:	e0bffe17 	ldw	r2,-8(fp)
811372ac:	10c00417 	ldw	r3,16(r2)
811372b0:	e0bffe17 	ldw	r2,-8(fp)
811372b4:	10800317 	ldw	r2,12(r2)
811372b8:	18800636 	bltu	r3,r2,811372d4 <OSMemPut+0x8c>
811372bc:	e0bffa17 	ldw	r2,-24(fp)
811372c0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811372c4:	e0bffb17 	ldw	r2,-20(fp)
811372c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
811372cc:	00801784 	movi	r2,94
811372d0:	00001106 	br	81137318 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
811372d4:	e0bffe17 	ldw	r2,-8(fp)
811372d8:	10c00117 	ldw	r3,4(r2)
811372dc:	e0bfff17 	ldw	r2,-4(fp)
811372e0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
811372e4:	e0bffe17 	ldw	r2,-8(fp)
811372e8:	e0ffff17 	ldw	r3,-4(fp)
811372ec:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
811372f0:	e0bffe17 	ldw	r2,-8(fp)
811372f4:	10800417 	ldw	r2,16(r2)
811372f8:	10c00044 	addi	r3,r2,1
811372fc:	e0bffe17 	ldw	r2,-8(fp)
81137300:	10c00415 	stw	r3,16(r2)
81137304:	e0bffa17 	ldw	r2,-24(fp)
81137308:	e0bffc15 	stw	r2,-16(fp)
8113730c:	e0bffc17 	ldw	r2,-16(fp)
81137310:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81137314:	0005883a 	mov	r2,zero
}
81137318:	e037883a 	mov	sp,fp
8113731c:	df000017 	ldw	fp,0(sp)
81137320:	dec00104 	addi	sp,sp,4
81137324:	f800283a 	ret

81137328 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
81137328:	defffa04 	addi	sp,sp,-24
8113732c:	de00012e 	bgeu	sp,et,81137334 <OSMemQuery+0xc>
81137330:	003b68fa 	trap	3
81137334:	df000515 	stw	fp,20(sp)
81137338:	df000504 	addi	fp,sp,20
8113733c:	e13ffe15 	stw	r4,-8(fp)
81137340:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137344:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81137348:	e0bffe17 	ldw	r2,-8(fp)
8113734c:	1000021e 	bne	r2,zero,81137358 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81137350:	00801804 	movi	r2,96
81137354:	00002c06 	br	81137408 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
81137358:	e0bfff17 	ldw	r2,-4(fp)
8113735c:	1000021e 	bne	r2,zero,81137368 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
81137360:	00801844 	movi	r2,97
81137364:	00002806 	br	81137408 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137368:	0005303a 	rdctl	r2,status
8113736c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137370:	e0fffc17 	ldw	r3,-16(fp)
81137374:	00bfff84 	movi	r2,-2
81137378:	1884703a 	and	r2,r3,r2
8113737c:	1001703a 	wrctl	status,r2
  
  return context;
81137380:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137384:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81137388:	e0bffe17 	ldw	r2,-8(fp)
8113738c:	10c00017 	ldw	r3,0(r2)
81137390:	e0bfff17 	ldw	r2,-4(fp)
81137394:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81137398:	e0bffe17 	ldw	r2,-8(fp)
8113739c:	10c00117 	ldw	r3,4(r2)
811373a0:	e0bfff17 	ldw	r2,-4(fp)
811373a4:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
811373a8:	e0bffe17 	ldw	r2,-8(fp)
811373ac:	10c00217 	ldw	r3,8(r2)
811373b0:	e0bfff17 	ldw	r2,-4(fp)
811373b4:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
811373b8:	e0bffe17 	ldw	r2,-8(fp)
811373bc:	10c00317 	ldw	r3,12(r2)
811373c0:	e0bfff17 	ldw	r2,-4(fp)
811373c4:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
811373c8:	e0bffe17 	ldw	r2,-8(fp)
811373cc:	10c00417 	ldw	r3,16(r2)
811373d0:	e0bfff17 	ldw	r2,-4(fp)
811373d4:	10c00415 	stw	r3,16(r2)
811373d8:	e0bffb17 	ldw	r2,-20(fp)
811373dc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811373e0:	e0bffd17 	ldw	r2,-12(fp)
811373e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
811373e8:	e0bfff17 	ldw	r2,-4(fp)
811373ec:	10c00317 	ldw	r3,12(r2)
811373f0:	e0bfff17 	ldw	r2,-4(fp)
811373f4:	10800417 	ldw	r2,16(r2)
811373f8:	1887c83a 	sub	r3,r3,r2
811373fc:	e0bfff17 	ldw	r2,-4(fp)
81137400:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81137404:	0005883a 	mov	r2,zero
}
81137408:	e037883a 	mov	sp,fp
8113740c:	df000017 	ldw	fp,0(sp)
81137410:	dec00104 	addi	sp,sp,4
81137414:	f800283a 	ret

81137418 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81137418:	defffc04 	addi	sp,sp,-16
8113741c:	de00012e 	bgeu	sp,et,81137424 <OS_MemInit+0xc>
81137420:	003b68fa 	trap	3
81137424:	dfc00315 	stw	ra,12(sp)
81137428:	df000215 	stw	fp,8(sp)
8113742c:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
81137430:	01430c04 	movi	r5,3120
81137434:	012045b4 	movhi	r4,33046
81137438:	21058904 	addi	r4,r4,5668
8113743c:	1134bfc0 	call	81134bfc <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81137440:	00a045b4 	movhi	r2,33046
81137444:	10858904 	addi	r2,r2,5668
81137448:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113744c:	e03fff0d 	sth	zero,-4(fp)
81137450:	00001306 	br	811374a0 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
81137454:	e0bfff0b 	ldhu	r2,-4(fp)
81137458:	10800044 	addi	r2,r2,1
8113745c:	10c00d24 	muli	r3,r2,52
81137460:	00a045b4 	movhi	r2,33046
81137464:	10858904 	addi	r2,r2,5668
81137468:	1887883a 	add	r3,r3,r2
8113746c:	e0bffe17 	ldw	r2,-8(fp)
81137470:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
81137474:	e0bffe17 	ldw	r2,-8(fp)
81137478:	00c00fc4 	movi	r3,63
8113747c:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81137480:	e0bffe17 	ldw	r2,-8(fp)
81137484:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81137488:	e0bffe17 	ldw	r2,-8(fp)
8113748c:	10800d04 	addi	r2,r2,52
81137490:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81137494:	e0bfff0b 	ldhu	r2,-4(fp)
81137498:	10800044 	addi	r2,r2,1
8113749c:	e0bfff0d 	sth	r2,-4(fp)
811374a0:	e0bfff0b 	ldhu	r2,-4(fp)
811374a4:	10800ef0 	cmpltui	r2,r2,59
811374a8:	103fea1e 	bne	r2,zero,81137454 <__reset+0xfb117454>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
811374ac:	e0bffe17 	ldw	r2,-8(fp)
811374b0:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
811374b4:	e0bffe17 	ldw	r2,-8(fp)
811374b8:	00c00fc4 	movi	r3,63
811374bc:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
811374c0:	e0bffe17 	ldw	r2,-8(fp)
811374c4:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
811374c8:	00a045b4 	movhi	r2,33046
811374cc:	10858904 	addi	r2,r2,5668
811374d0:	d0a09515 	stw	r2,-32172(gp)
#endif
}
811374d4:	0001883a 	nop
811374d8:	e037883a 	mov	sp,fp
811374dc:	dfc00117 	ldw	ra,4(sp)
811374e0:	df000017 	ldw	fp,0(sp)
811374e4:	dec00204 	addi	sp,sp,8
811374e8:	f800283a 	ret

811374ec <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
811374ec:	defff704 	addi	sp,sp,-36
811374f0:	de00012e 	bgeu	sp,et,811374f8 <OSMutexAccept+0xc>
811374f4:	003b68fa 	trap	3
811374f8:	df000815 	stw	fp,32(sp)
811374fc:	df000804 	addi	fp,sp,32
81137500:	e13ffe15 	stw	r4,-8(fp)
81137504:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81137508:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113750c:	e0bfff17 	ldw	r2,-4(fp)
81137510:	1000021e 	bne	r2,zero,8113751c <OSMutexAccept+0x30>
        return (OS_FALSE);
81137514:	0005883a 	mov	r2,zero
81137518:	00005b06 	br	81137688 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113751c:	e0bffe17 	ldw	r2,-8(fp)
81137520:	1000051e 	bne	r2,zero,81137538 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81137524:	e0bfff17 	ldw	r2,-4(fp)
81137528:	00c00104 	movi	r3,4
8113752c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137530:	0005883a 	mov	r2,zero
81137534:	00005406 	br	81137688 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
81137538:	e0bffe17 	ldw	r2,-8(fp)
8113753c:	10800003 	ldbu	r2,0(r2)
81137540:	10803fcc 	andi	r2,r2,255
81137544:	10800120 	cmpeqi	r2,r2,4
81137548:	1000051e 	bne	r2,zero,81137560 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113754c:	e0bfff17 	ldw	r2,-4(fp)
81137550:	00c00044 	movi	r3,1
81137554:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137558:	0005883a 	mov	r2,zero
8113755c:	00004a06 	br	81137688 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
81137560:	d0a09b03 	ldbu	r2,-32148(gp)
81137564:	10803fcc 	andi	r2,r2,255
81137568:	10000526 	beq	r2,zero,81137580 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113756c:	e0bfff17 	ldw	r2,-4(fp)
81137570:	00c00084 	movi	r3,2
81137574:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81137578:	0005883a 	mov	r2,zero
8113757c:	00004206 	br	81137688 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137580:	0005303a 	rdctl	r2,status
81137584:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137588:	e0fffd17 	ldw	r3,-12(fp)
8113758c:	00bfff84 	movi	r2,-2
81137590:	1884703a 	and	r2,r3,r2
81137594:	1001703a 	wrctl	status,r2
  
  return context;
81137598:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113759c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
811375a0:	e0bffe17 	ldw	r2,-8(fp)
811375a4:	1080020b 	ldhu	r2,8(r2)
811375a8:	10bfffcc 	andi	r2,r2,65535
811375ac:	1004d23a 	srli	r2,r2,8
811375b0:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
811375b4:	e0bffe17 	ldw	r2,-8(fp)
811375b8:	1080020b 	ldhu	r2,8(r2)
811375bc:	10bfffcc 	andi	r2,r2,65535
811375c0:	10803fcc 	andi	r2,r2,255
811375c4:	10803fd8 	cmpnei	r2,r2,255
811375c8:	1000281e 	bne	r2,zero,8113766c <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
811375cc:	e0bffe17 	ldw	r2,-8(fp)
811375d0:	10c0020b 	ldhu	r3,8(r2)
811375d4:	00bfc004 	movi	r2,-256
811375d8:	1884703a 	and	r2,r3,r2
811375dc:	1007883a 	mov	r3,r2
811375e0:	e0bffe17 	ldw	r2,-8(fp)
811375e4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
811375e8:	e0bffe17 	ldw	r2,-8(fp)
811375ec:	10c0020b 	ldhu	r3,8(r2)
811375f0:	d0a09c17 	ldw	r2,-32144(gp)
811375f4:	10800c83 	ldbu	r2,50(r2)
811375f8:	10803fcc 	andi	r2,r2,255
811375fc:	1884b03a 	or	r2,r3,r2
81137600:	1007883a 	mov	r3,r2
81137604:	e0bffe17 	ldw	r2,-8(fp)
81137608:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113760c:	d0e09c17 	ldw	r3,-32144(gp)
81137610:	e0bffe17 	ldw	r2,-8(fp)
81137614:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81137618:	d0a09c17 	ldw	r2,-32144(gp)
8113761c:	10800c83 	ldbu	r2,50(r2)
81137620:	10803fcc 	andi	r2,r2,255
81137624:	e0fffa03 	ldbu	r3,-24(fp)
81137628:	18800836 	bltu	r3,r2,8113764c <OSMutexAccept+0x160>
8113762c:	e0bff817 	ldw	r2,-32(fp)
81137630:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137634:	e0bff917 	ldw	r2,-28(fp)
81137638:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113763c:	e0bfff17 	ldw	r2,-4(fp)
81137640:	00c01e04 	movi	r3,120
81137644:	10c00005 	stb	r3,0(r2)
81137648:	00000606 	br	81137664 <OSMutexAccept+0x178>
8113764c:	e0bff817 	ldw	r2,-32(fp)
81137650:	e0bffb15 	stw	r2,-20(fp)
81137654:	e0bffb17 	ldw	r2,-20(fp)
81137658:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113765c:	e0bfff17 	ldw	r2,-4(fp)
81137660:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
81137664:	00800044 	movi	r2,1
81137668:	00000706 	br	81137688 <OSMutexAccept+0x19c>
8113766c:	e0bff817 	ldw	r2,-32(fp)
81137670:	e0bffc15 	stw	r2,-16(fp)
81137674:	e0bffc17 	ldw	r2,-16(fp)
81137678:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113767c:	e0bfff17 	ldw	r2,-4(fp)
81137680:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81137684:	0005883a 	mov	r2,zero
}
81137688:	e037883a 	mov	sp,fp
8113768c:	df000017 	ldw	fp,0(sp)
81137690:	dec00104 	addi	sp,sp,4
81137694:	f800283a 	ret

81137698 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81137698:	defff604 	addi	sp,sp,-40
8113769c:	de00012e 	bgeu	sp,et,811376a4 <OSMutexCreate+0xc>
811376a0:	003b68fa 	trap	3
811376a4:	dfc00915 	stw	ra,36(sp)
811376a8:	df000815 	stw	fp,32(sp)
811376ac:	df000804 	addi	fp,sp,32
811376b0:	2005883a 	mov	r2,r4
811376b4:	e17fff15 	stw	r5,-4(fp)
811376b8:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811376bc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811376c0:	e0bfff17 	ldw	r2,-4(fp)
811376c4:	1000021e 	bne	r2,zero,811376d0 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
811376c8:	0005883a 	mov	r2,zero
811376cc:	00006106 	br	81137854 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
811376d0:	e0bffe03 	ldbu	r2,-8(fp)
811376d4:	10800ab0 	cmpltui	r2,r2,42
811376d8:	1000051e 	bne	r2,zero,811376f0 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
811376dc:	e0bfff17 	ldw	r2,-4(fp)
811376e0:	00c00a84 	movi	r3,42
811376e4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811376e8:	0005883a 	mov	r2,zero
811376ec:	00005906 	br	81137854 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811376f0:	d0a09b03 	ldbu	r2,-32148(gp)
811376f4:	10803fcc 	andi	r2,r2,255
811376f8:	10000526 	beq	r2,zero,81137710 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
811376fc:	e0bfff17 	ldw	r2,-4(fp)
81137700:	00c00404 	movi	r3,16
81137704:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81137708:	0005883a 	mov	r2,zero
8113770c:	00005106 	br	81137854 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137710:	0005303a 	rdctl	r2,status
81137714:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137718:	e0fffd17 	ldw	r3,-12(fp)
8113771c:	00bfff84 	movi	r2,-2
81137720:	1884703a 	and	r2,r3,r2
81137724:	1001703a 	wrctl	status,r2
  
  return context;
81137728:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113772c:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
81137730:	e0fffe03 	ldbu	r3,-8(fp)
81137734:	00a045b4 	movhi	r2,33046
81137738:	109b0304 	addi	r2,r2,27660
8113773c:	18c7883a 	add	r3,r3,r3
81137740:	18c7883a 	add	r3,r3,r3
81137744:	10c5883a 	add	r2,r2,r3
81137748:	10800017 	ldw	r2,0(r2)
8113774c:	10000926 	beq	r2,zero,81137774 <OSMutexCreate+0xdc>
81137750:	e0bff817 	ldw	r2,-32(fp)
81137754:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137758:	e0bff917 	ldw	r2,-28(fp)
8113775c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
81137760:	e0bfff17 	ldw	r2,-4(fp)
81137764:	00c00a04 	movi	r3,40
81137768:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113776c:	0005883a 	mov	r2,zero
81137770:	00003806 	br	81137854 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
81137774:	e0fffe03 	ldbu	r3,-8(fp)
81137778:	00a045b4 	movhi	r2,33046
8113777c:	109b0304 	addi	r2,r2,27660
81137780:	18c7883a 	add	r3,r3,r3
81137784:	18c7883a 	add	r3,r3,r3
81137788:	10c5883a 	add	r2,r2,r3
8113778c:	00c00044 	movi	r3,1
81137790:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81137794:	d0a09a17 	ldw	r2,-32152(gp)
81137798:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113779c:	e0bffb17 	ldw	r2,-20(fp)
811377a0:	1000101e 	bne	r2,zero,811377e4 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
811377a4:	e0fffe03 	ldbu	r3,-8(fp)
811377a8:	00a045b4 	movhi	r2,33046
811377ac:	109b0304 	addi	r2,r2,27660
811377b0:	18c7883a 	add	r3,r3,r3
811377b4:	18c7883a 	add	r3,r3,r3
811377b8:	10c5883a 	add	r2,r2,r3
811377bc:	10000015 	stw	zero,0(r2)
811377c0:	e0bff817 	ldw	r2,-32(fp)
811377c4:	e0bffa15 	stw	r2,-24(fp)
811377c8:	e0bffa17 	ldw	r2,-24(fp)
811377cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
811377d0:	e0bfff17 	ldw	r2,-4(fp)
811377d4:	00c00104 	movi	r3,4
811377d8:	10c00005 	stb	r3,0(r2)
        return (pevent);
811377dc:	e0bffb17 	ldw	r2,-20(fp)
811377e0:	00001c06 	br	81137854 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
811377e4:	d0a09a17 	ldw	r2,-32152(gp)
811377e8:	10800117 	ldw	r2,4(r2)
811377ec:	d0a09a15 	stw	r2,-32152(gp)
811377f0:	e0bff817 	ldw	r2,-32(fp)
811377f4:	e0bffc15 	stw	r2,-16(fp)
811377f8:	e0bffc17 	ldw	r2,-16(fp)
811377fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
81137800:	e0bffb17 	ldw	r2,-20(fp)
81137804:	00c00104 	movi	r3,4
81137808:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113780c:	e0bffe03 	ldbu	r2,-8(fp)
81137810:	1004923a 	slli	r2,r2,8
81137814:	10803fd4 	ori	r2,r2,255
81137818:	1007883a 	mov	r3,r2
8113781c:	e0bffb17 	ldw	r2,-20(fp)
81137820:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
81137824:	e0bffb17 	ldw	r2,-20(fp)
81137828:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113782c:	e0bffb17 	ldw	r2,-20(fp)
81137830:	00c00fc4 	movi	r3,63
81137834:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
81137838:	e0bffb17 	ldw	r2,-20(fp)
8113783c:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
81137840:	e13ffb17 	ldw	r4,-20(fp)
81137844:	11347e40 	call	811347e4 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
81137848:	e0bfff17 	ldw	r2,-4(fp)
8113784c:	10000005 	stb	zero,0(r2)
    return (pevent);
81137850:	e0bffb17 	ldw	r2,-20(fp)
}
81137854:	e037883a 	mov	sp,fp
81137858:	dfc00117 	ldw	ra,4(sp)
8113785c:	df000017 	ldw	fp,0(sp)
81137860:	dec00204 	addi	sp,sp,8
81137864:	f800283a 	ret

81137868 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81137868:	defff004 	addi	sp,sp,-64
8113786c:	de00012e 	bgeu	sp,et,81137874 <OSMutexDel+0xc>
81137870:	003b68fa 	trap	3
81137874:	dfc00f15 	stw	ra,60(sp)
81137878:	df000e15 	stw	fp,56(sp)
8113787c:	df000e04 	addi	fp,sp,56
81137880:	e13ffd15 	stw	r4,-12(fp)
81137884:	2805883a 	mov	r2,r5
81137888:	e1bfff15 	stw	r6,-4(fp)
8113788c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137890:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137894:	e0bfff17 	ldw	r2,-4(fp)
81137898:	1000021e 	bne	r2,zero,811378a4 <OSMutexDel+0x3c>
        return (pevent);
8113789c:	e0bffd17 	ldw	r2,-12(fp)
811378a0:	0000ad06 	br	81137b58 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811378a4:	e0bffd17 	ldw	r2,-12(fp)
811378a8:	1000051e 	bne	r2,zero,811378c0 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811378ac:	e0bfff17 	ldw	r2,-4(fp)
811378b0:	00c00104 	movi	r3,4
811378b4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811378b8:	e0bffd17 	ldw	r2,-12(fp)
811378bc:	0000a606 	br	81137b58 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811378c0:	e0bffd17 	ldw	r2,-12(fp)
811378c4:	10800003 	ldbu	r2,0(r2)
811378c8:	10803fcc 	andi	r2,r2,255
811378cc:	10800120 	cmpeqi	r2,r2,4
811378d0:	1000051e 	bne	r2,zero,811378e8 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811378d4:	e0bfff17 	ldw	r2,-4(fp)
811378d8:	00c00044 	movi	r3,1
811378dc:	10c00005 	stb	r3,0(r2)
        return (pevent);
811378e0:	e0bffd17 	ldw	r2,-12(fp)
811378e4:	00009c06 	br	81137b58 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811378e8:	d0a09b03 	ldbu	r2,-32148(gp)
811378ec:	10803fcc 	andi	r2,r2,255
811378f0:	10000526 	beq	r2,zero,81137908 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811378f4:	e0bfff17 	ldw	r2,-4(fp)
811378f8:	00c003c4 	movi	r3,15
811378fc:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137900:	e0bffd17 	ldw	r2,-12(fp)
81137904:	00009406 	br	81137b58 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137908:	0005303a 	rdctl	r2,status
8113790c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137910:	e0fffc17 	ldw	r3,-16(fp)
81137914:	00bfff84 	movi	r2,-2
81137918:	1884703a 	and	r2,r3,r2
8113791c:	1001703a 	wrctl	status,r2
  
  return context;
81137920:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137924:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
81137928:	e0bffd17 	ldw	r2,-12(fp)
8113792c:	10800283 	ldbu	r2,10(r2)
81137930:	10803fcc 	andi	r2,r2,255
81137934:	10000326 	beq	r2,zero,81137944 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81137938:	00800044 	movi	r2,1
8113793c:	e0bff205 	stb	r2,-56(fp)
81137940:	00000106 	br	81137948 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81137944:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
81137948:	e0bffe03 	ldbu	r2,-8(fp)
8113794c:	10000326 	beq	r2,zero,8113795c <OSMutexDel+0xf4>
81137950:	10800060 	cmpeqi	r2,r2,1
81137954:	10002f1e 	bne	r2,zero,81137a14 <OSMutexDel+0x1ac>
81137958:	00007406 	br	81137b2c <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113795c:	e0bff203 	ldbu	r2,-56(fp)
81137960:	1000221e 	bne	r2,zero,811379ec <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81137964:	e0bffd17 	ldw	r2,-12(fp)
81137968:	00c00fc4 	movi	r3,63
8113796c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81137970:	e0bffd17 	ldw	r2,-12(fp)
81137974:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81137978:	e0bffd17 	ldw	r2,-12(fp)
8113797c:	1080020b 	ldhu	r2,8(r2)
81137980:	10bfffcc 	andi	r2,r2,65535
81137984:	1004d23a 	srli	r2,r2,8
81137988:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113798c:	e0fff603 	ldbu	r3,-40(fp)
81137990:	00a045b4 	movhi	r2,33046
81137994:	109b0304 	addi	r2,r2,27660
81137998:	18c7883a 	add	r3,r3,r3
8113799c:	18c7883a 	add	r3,r3,r3
811379a0:	10c5883a 	add	r2,r2,r3
811379a4:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
811379a8:	e0bffd17 	ldw	r2,-12(fp)
811379ac:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
811379b0:	d0e09a17 	ldw	r3,-32152(gp)
811379b4:	e0bffd17 	ldw	r2,-12(fp)
811379b8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
811379bc:	e0bffd17 	ldw	r2,-12(fp)
811379c0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
811379c4:	e0bffd17 	ldw	r2,-12(fp)
811379c8:	d0a09a15 	stw	r2,-32152(gp)
811379cc:	e0bff417 	ldw	r2,-48(fp)
811379d0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811379d4:	e0bff517 	ldw	r2,-44(fp)
811379d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
811379dc:	e0bfff17 	ldw	r2,-4(fp)
811379e0:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
811379e4:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
811379e8:	00005a06 	br	81137b54 <OSMutexDel+0x2ec>
811379ec:	e0bff417 	ldw	r2,-48(fp)
811379f0:	e0bff715 	stw	r2,-36(fp)
811379f4:	e0bff717 	ldw	r2,-36(fp)
811379f8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
811379fc:	e0bfff17 	ldw	r2,-4(fp)
81137a00:	00c01244 	movi	r3,73
81137a04:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
81137a08:	e0bffd17 	ldw	r2,-12(fp)
81137a0c:	e0bff315 	stw	r2,-52(fp)
             }
             break;
81137a10:	00005006 	br	81137b54 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
81137a14:	e0bffd17 	ldw	r2,-12(fp)
81137a18:	1080020b 	ldhu	r2,8(r2)
81137a1c:	10bfffcc 	andi	r2,r2,65535
81137a20:	1004d23a 	srli	r2,r2,8
81137a24:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
81137a28:	e0bffd17 	ldw	r2,-12(fp)
81137a2c:	1080020b 	ldhu	r2,8(r2)
81137a30:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
81137a34:	e0bffd17 	ldw	r2,-12(fp)
81137a38:	10800117 	ldw	r2,4(r2)
81137a3c:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
81137a40:	e0bffa17 	ldw	r2,-24(fp)
81137a44:	10000f26 	beq	r2,zero,81137a84 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
81137a48:	e0bffa17 	ldw	r2,-24(fp)
81137a4c:	10800c83 	ldbu	r2,50(r2)
81137a50:	10c03fcc 	andi	r3,r2,255
81137a54:	e0bff603 	ldbu	r2,-40(fp)
81137a58:	18800a1e 	bne	r3,r2,81137a84 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
81137a5c:	e0bff903 	ldbu	r2,-28(fp)
81137a60:	100b883a 	mov	r5,r2
81137a64:	e13ffa17 	ldw	r4,-24(fp)
81137a68:	11384a40 	call	811384a4 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81137a6c:	00000506 	br	81137a84 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81137a70:	000f883a 	mov	r7,zero
81137a74:	01800404 	movi	r6,16
81137a78:	000b883a 	mov	r5,zero
81137a7c:	e13ffd17 	ldw	r4,-12(fp)
81137a80:	113420c0 	call	8113420c <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81137a84:	e0bffd17 	ldw	r2,-12(fp)
81137a88:	10800283 	ldbu	r2,10(r2)
81137a8c:	10803fcc 	andi	r2,r2,255
81137a90:	103ff71e 	bne	r2,zero,81137a70 <__reset+0xfb117a70>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81137a94:	e0bffd17 	ldw	r2,-12(fp)
81137a98:	00c00fc4 	movi	r3,63
81137a9c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81137aa0:	e0bffd17 	ldw	r2,-12(fp)
81137aa4:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81137aa8:	e0bffd17 	ldw	r2,-12(fp)
81137aac:	1080020b 	ldhu	r2,8(r2)
81137ab0:	10bfffcc 	andi	r2,r2,65535
81137ab4:	1004d23a 	srli	r2,r2,8
81137ab8:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
81137abc:	e0fff603 	ldbu	r3,-40(fp)
81137ac0:	00a045b4 	movhi	r2,33046
81137ac4:	109b0304 	addi	r2,r2,27660
81137ac8:	18c7883a 	add	r3,r3,r3
81137acc:	18c7883a 	add	r3,r3,r3
81137ad0:	10c5883a 	add	r2,r2,r3
81137ad4:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81137ad8:	e0bffd17 	ldw	r2,-12(fp)
81137adc:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
81137ae0:	d0e09a17 	ldw	r3,-32152(gp)
81137ae4:	e0bffd17 	ldw	r2,-12(fp)
81137ae8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
81137aec:	e0bffd17 	ldw	r2,-12(fp)
81137af0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
81137af4:	e0bffd17 	ldw	r2,-12(fp)
81137af8:	d0a09a15 	stw	r2,-32152(gp)
81137afc:	e0bff417 	ldw	r2,-48(fp)
81137b00:	e0bff815 	stw	r2,-32(fp)
81137b04:	e0bff817 	ldw	r2,-32(fp)
81137b08:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81137b0c:	e0bff203 	ldbu	r2,-56(fp)
81137b10:	10800058 	cmpnei	r2,r2,1
81137b14:	1000011e 	bne	r2,zero,81137b1c <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81137b18:	1134cc80 	call	81134cc8 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
81137b1c:	e0bfff17 	ldw	r2,-4(fp)
81137b20:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
81137b24:	e03ff315 	stw	zero,-52(fp)
             break;
81137b28:	00000a06 	br	81137b54 <OSMutexDel+0x2ec>
81137b2c:	e0bff417 	ldw	r2,-48(fp)
81137b30:	e0bffb15 	stw	r2,-20(fp)
81137b34:	e0bffb17 	ldw	r2,-20(fp)
81137b38:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
81137b3c:	e0bfff17 	ldw	r2,-4(fp)
81137b40:	00c001c4 	movi	r3,7
81137b44:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
81137b48:	e0bffd17 	ldw	r2,-12(fp)
81137b4c:	e0bff315 	stw	r2,-52(fp)
             break;
81137b50:	0001883a 	nop
    }
    return (pevent_return);
81137b54:	e0bff317 	ldw	r2,-52(fp)
}
81137b58:	e037883a 	mov	sp,fp
81137b5c:	dfc00117 	ldw	ra,4(sp)
81137b60:	df000017 	ldw	fp,0(sp)
81137b64:	dec00204 	addi	sp,sp,8
81137b68:	f800283a 	ret

81137b6c <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81137b6c:	deffee04 	addi	sp,sp,-72
81137b70:	de00012e 	bgeu	sp,et,81137b78 <OSMutexPend+0xc>
81137b74:	003b68fa 	trap	3
81137b78:	dfc01115 	stw	ra,68(sp)
81137b7c:	df001015 	stw	fp,64(sp)
81137b80:	df001004 	addi	fp,sp,64
81137b84:	e13ffd15 	stw	r4,-12(fp)
81137b88:	2805883a 	mov	r2,r5
81137b8c:	e1bfff15 	stw	r6,-4(fp)
81137b90:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137b94:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137b98:	e0bfff17 	ldw	r2,-4(fp)
81137b9c:	10015626 	beq	r2,zero,811380f8 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137ba0:	e0bffd17 	ldw	r2,-12(fp)
81137ba4:	1000041e 	bne	r2,zero,81137bb8 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81137ba8:	e0bfff17 	ldw	r2,-4(fp)
81137bac:	00c00104 	movi	r3,4
81137bb0:	10c00005 	stb	r3,0(r2)
        return;
81137bb4:	00015106 	br	811380fc <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81137bb8:	e0bffd17 	ldw	r2,-12(fp)
81137bbc:	10800003 	ldbu	r2,0(r2)
81137bc0:	10803fcc 	andi	r2,r2,255
81137bc4:	10800120 	cmpeqi	r2,r2,4
81137bc8:	1000041e 	bne	r2,zero,81137bdc <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81137bcc:	e0bfff17 	ldw	r2,-4(fp)
81137bd0:	00c00044 	movi	r3,1
81137bd4:	10c00005 	stb	r3,0(r2)
        return;
81137bd8:	00014806 	br	811380fc <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137bdc:	d0a09b03 	ldbu	r2,-32148(gp)
81137be0:	10803fcc 	andi	r2,r2,255
81137be4:	10000426 	beq	r2,zero,81137bf8 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81137be8:	e0bfff17 	ldw	r2,-4(fp)
81137bec:	00c00084 	movi	r3,2
81137bf0:	10c00005 	stb	r3,0(r2)
        return;
81137bf4:	00014106 	br	811380fc <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81137bf8:	d0a08903 	ldbu	r2,-32220(gp)
81137bfc:	10803fcc 	andi	r2,r2,255
81137c00:	10000426 	beq	r2,zero,81137c14 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81137c04:	e0bfff17 	ldw	r2,-4(fp)
81137c08:	00c00344 	movi	r3,13
81137c0c:	10c00005 	stb	r3,0(r2)
        return;
81137c10:	00013a06 	br	811380fc <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137c14:	0005303a 	rdctl	r2,status
81137c18:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137c1c:	e0fffc17 	ldw	r3,-16(fp)
81137c20:	00bfff84 	movi	r2,-2
81137c24:	1884703a 	and	r2,r3,r2
81137c28:	1001703a 	wrctl	status,r2
  
  return context;
81137c2c:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81137c30:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
81137c34:	e0bffd17 	ldw	r2,-12(fp)
81137c38:	1080020b 	ldhu	r2,8(r2)
81137c3c:	10bfffcc 	andi	r2,r2,65535
81137c40:	1004d23a 	srli	r2,r2,8
81137c44:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81137c48:	e0bffd17 	ldw	r2,-12(fp)
81137c4c:	1080020b 	ldhu	r2,8(r2)
81137c50:	10803fcc 	andi	r2,r2,255
81137c54:	10803fd8 	cmpnei	r2,r2,255
81137c58:	1000271e 	bne	r2,zero,81137cf8 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
81137c5c:	e0bffd17 	ldw	r2,-12(fp)
81137c60:	10c0020b 	ldhu	r3,8(r2)
81137c64:	00bfc004 	movi	r2,-256
81137c68:	1884703a 	and	r2,r3,r2
81137c6c:	1007883a 	mov	r3,r2
81137c70:	e0bffd17 	ldw	r2,-12(fp)
81137c74:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
81137c78:	e0bffd17 	ldw	r2,-12(fp)
81137c7c:	10c0020b 	ldhu	r3,8(r2)
81137c80:	d0a09c17 	ldw	r2,-32144(gp)
81137c84:	10800c83 	ldbu	r2,50(r2)
81137c88:	10803fcc 	andi	r2,r2,255
81137c8c:	1884b03a 	or	r2,r3,r2
81137c90:	1007883a 	mov	r3,r2
81137c94:	e0bffd17 	ldw	r2,-12(fp)
81137c98:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81137c9c:	d0e09c17 	ldw	r3,-32144(gp)
81137ca0:	e0bffd17 	ldw	r2,-12(fp)
81137ca4:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81137ca8:	d0a09c17 	ldw	r2,-32144(gp)
81137cac:	10800c83 	ldbu	r2,50(r2)
81137cb0:	10803fcc 	andi	r2,r2,255
81137cb4:	e0fff303 	ldbu	r3,-52(fp)
81137cb8:	18800836 	bltu	r3,r2,81137cdc <OSMutexPend+0x170>
81137cbc:	e0bff117 	ldw	r2,-60(fp)
81137cc0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137cc4:	e0bff217 	ldw	r2,-56(fp)
81137cc8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
81137ccc:	e0bfff17 	ldw	r2,-4(fp)
81137cd0:	00c01e04 	movi	r3,120
81137cd4:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
81137cd8:	00010806 	br	811380fc <OSMutexPend+0x590>
81137cdc:	e0bff117 	ldw	r2,-60(fp)
81137ce0:	e0bff415 	stw	r2,-48(fp)
81137ce4:	e0bff417 	ldw	r2,-48(fp)
81137ce8:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81137cec:	e0bfff17 	ldw	r2,-4(fp)
81137cf0:	10000005 	stb	zero,0(r2)
        }
        return;
81137cf4:	00010106 	br	811380fc <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
81137cf8:	e0bffd17 	ldw	r2,-12(fp)
81137cfc:	1080020b 	ldhu	r2,8(r2)
81137d00:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
81137d04:	e0bffd17 	ldw	r2,-12(fp)
81137d08:	10800117 	ldw	r2,4(r2)
81137d0c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81137d10:	e0bff717 	ldw	r2,-36(fp)
81137d14:	10800c83 	ldbu	r2,50(r2)
81137d18:	10803fcc 	andi	r2,r2,255
81137d1c:	e0fff303 	ldbu	r3,-52(fp)
81137d20:	1880b92e 	bgeu	r3,r2,81138008 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
81137d24:	d0a09c17 	ldw	r2,-32144(gp)
81137d28:	10800c83 	ldbu	r2,50(r2)
81137d2c:	10c03fcc 	andi	r3,r2,255
81137d30:	e0bff603 	ldbu	r2,-40(fp)
81137d34:	1880b42e 	bgeu	r3,r2,81138008 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
81137d38:	e0bff717 	ldw	r2,-36(fp)
81137d3c:	10800d03 	ldbu	r2,52(r2)
81137d40:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
81137d44:	e0fff803 	ldbu	r3,-32(fp)
81137d48:	d0a09844 	addi	r2,gp,-32159
81137d4c:	1885883a 	add	r2,r3,r2
81137d50:	10c00003 	ldbu	r3,0(r2)
81137d54:	e0bff717 	ldw	r2,-36(fp)
81137d58:	10800d43 	ldbu	r2,53(r2)
81137d5c:	1884703a 	and	r2,r3,r2
81137d60:	10803fcc 	andi	r2,r2,255
81137d64:	10001e26 	beq	r2,zero,81137de0 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
81137d68:	e0fff803 	ldbu	r3,-32(fp)
81137d6c:	e13ff803 	ldbu	r4,-32(fp)
81137d70:	d0a09844 	addi	r2,gp,-32159
81137d74:	2085883a 	add	r2,r4,r2
81137d78:	10800003 	ldbu	r2,0(r2)
81137d7c:	1009883a 	mov	r4,r2
81137d80:	e0bff717 	ldw	r2,-36(fp)
81137d84:	10800d43 	ldbu	r2,53(r2)
81137d88:	0084303a 	nor	r2,zero,r2
81137d8c:	2084703a 	and	r2,r4,r2
81137d90:	1009883a 	mov	r4,r2
81137d94:	d0a09844 	addi	r2,gp,-32159
81137d98:	1885883a 	add	r2,r3,r2
81137d9c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81137da0:	e0fff803 	ldbu	r3,-32(fp)
81137da4:	d0a09844 	addi	r2,gp,-32159
81137da8:	1885883a 	add	r2,r3,r2
81137dac:	10800003 	ldbu	r2,0(r2)
81137db0:	10803fcc 	andi	r2,r2,255
81137db4:	1000071e 	bne	r2,zero,81137dd4 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
81137db8:	e0bff717 	ldw	r2,-36(fp)
81137dbc:	10800d83 	ldbu	r2,54(r2)
81137dc0:	0084303a 	nor	r2,zero,r2
81137dc4:	1007883a 	mov	r3,r2
81137dc8:	d0a09803 	ldbu	r2,-32160(gp)
81137dcc:	1884703a 	and	r2,r3,r2
81137dd0:	d0a09805 	stb	r2,-32160(gp)
                }
                rdy = OS_TRUE;
81137dd4:	00800044 	movi	r2,1
81137dd8:	e0bff005 	stb	r2,-64(fp)
81137ddc:	00002a06 	br	81137e88 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81137de0:	e0bff717 	ldw	r2,-36(fp)
81137de4:	10800717 	ldw	r2,28(r2)
81137de8:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
81137dec:	e0bff917 	ldw	r2,-28(fp)
81137df0:	10002426 	beq	r2,zero,81137e84 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
81137df4:	e0bff717 	ldw	r2,-36(fp)
81137df8:	10800d03 	ldbu	r2,52(r2)
81137dfc:	10803fcc 	andi	r2,r2,255
81137e00:	e0fff717 	ldw	r3,-36(fp)
81137e04:	18c00d03 	ldbu	r3,52(r3)
81137e08:	18c03fcc 	andi	r3,r3,255
81137e0c:	e13ff917 	ldw	r4,-28(fp)
81137e10:	20c7883a 	add	r3,r4,r3
81137e14:	18c002c4 	addi	r3,r3,11
81137e18:	18c00003 	ldbu	r3,0(r3)
81137e1c:	1809883a 	mov	r4,r3
81137e20:	e0fff717 	ldw	r3,-36(fp)
81137e24:	18c00d43 	ldbu	r3,53(r3)
81137e28:	00c6303a 	nor	r3,zero,r3
81137e2c:	20c6703a 	and	r3,r4,r3
81137e30:	1809883a 	mov	r4,r3
81137e34:	e0fff917 	ldw	r3,-28(fp)
81137e38:	1887883a 	add	r3,r3,r2
81137e3c:	18c002c4 	addi	r3,r3,11
81137e40:	19000005 	stb	r4,0(r3)
81137e44:	e0fff917 	ldw	r3,-28(fp)
81137e48:	1885883a 	add	r2,r3,r2
81137e4c:	108002c4 	addi	r2,r2,11
81137e50:	10800003 	ldbu	r2,0(r2)
81137e54:	10803fcc 	andi	r2,r2,255
81137e58:	10000a1e 	bne	r2,zero,81137e84 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
81137e5c:	e0bff917 	ldw	r2,-28(fp)
81137e60:	10800283 	ldbu	r2,10(r2)
81137e64:	1007883a 	mov	r3,r2
81137e68:	e0bff717 	ldw	r2,-36(fp)
81137e6c:	10800d83 	ldbu	r2,54(r2)
81137e70:	0084303a 	nor	r2,zero,r2
81137e74:	1884703a 	and	r2,r3,r2
81137e78:	1007883a 	mov	r3,r2
81137e7c:	e0bff917 	ldw	r2,-28(fp)
81137e80:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81137e84:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81137e88:	e0bff717 	ldw	r2,-36(fp)
81137e8c:	e0fff303 	ldbu	r3,-52(fp)
81137e90:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81137e94:	e0bff717 	ldw	r2,-36(fp)
81137e98:	10800c83 	ldbu	r2,50(r2)
81137e9c:	10803fcc 	andi	r2,r2,255
81137ea0:	1004d0fa 	srli	r2,r2,3
81137ea4:	1007883a 	mov	r3,r2
81137ea8:	e0bff717 	ldw	r2,-36(fp)
81137eac:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81137eb0:	e0bff717 	ldw	r2,-36(fp)
81137eb4:	10800c83 	ldbu	r2,50(r2)
81137eb8:	108001cc 	andi	r2,r2,7
81137ebc:	1007883a 	mov	r3,r2
81137ec0:	e0bff717 	ldw	r2,-36(fp)
81137ec4:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81137ec8:	e0bff717 	ldw	r2,-36(fp)
81137ecc:	10800d03 	ldbu	r2,52(r2)
81137ed0:	10803fcc 	andi	r2,r2,255
81137ed4:	00c00044 	movi	r3,1
81137ed8:	1884983a 	sll	r2,r3,r2
81137edc:	1007883a 	mov	r3,r2
81137ee0:	e0bff717 	ldw	r2,-36(fp)
81137ee4:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81137ee8:	e0bff717 	ldw	r2,-36(fp)
81137eec:	10800cc3 	ldbu	r2,51(r2)
81137ef0:	10803fcc 	andi	r2,r2,255
81137ef4:	00c00044 	movi	r3,1
81137ef8:	1884983a 	sll	r2,r3,r2
81137efc:	1007883a 	mov	r3,r2
81137f00:	e0bff717 	ldw	r2,-36(fp)
81137f04:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81137f08:	e0bff003 	ldbu	r2,-64(fp)
81137f0c:	10800058 	cmpnei	r2,r2,1
81137f10:	1000161e 	bne	r2,zero,81137f6c <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81137f14:	e0bff717 	ldw	r2,-36(fp)
81137f18:	10c00d83 	ldbu	r3,54(r2)
81137f1c:	d0a09803 	ldbu	r2,-32160(gp)
81137f20:	1884b03a 	or	r2,r3,r2
81137f24:	d0a09805 	stb	r2,-32160(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81137f28:	e0bff717 	ldw	r2,-36(fp)
81137f2c:	10800d03 	ldbu	r2,52(r2)
81137f30:	10c03fcc 	andi	r3,r2,255
81137f34:	e0bff717 	ldw	r2,-36(fp)
81137f38:	10800d03 	ldbu	r2,52(r2)
81137f3c:	11003fcc 	andi	r4,r2,255
81137f40:	d0a09844 	addi	r2,gp,-32159
81137f44:	2085883a 	add	r2,r4,r2
81137f48:	11000003 	ldbu	r4,0(r2)
81137f4c:	e0bff717 	ldw	r2,-36(fp)
81137f50:	10800d43 	ldbu	r2,53(r2)
81137f54:	2084b03a 	or	r2,r4,r2
81137f58:	1009883a 	mov	r4,r2
81137f5c:	d0a09844 	addi	r2,gp,-32159
81137f60:	1885883a 	add	r2,r3,r2
81137f64:	11000005 	stb	r4,0(r2)
81137f68:	00001f06 	br	81137fe8 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81137f6c:	e0bff717 	ldw	r2,-36(fp)
81137f70:	10800717 	ldw	r2,28(r2)
81137f74:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
81137f78:	e0bff917 	ldw	r2,-28(fp)
81137f7c:	10001a26 	beq	r2,zero,81137fe8 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81137f80:	e0bff917 	ldw	r2,-28(fp)
81137f84:	10c00283 	ldbu	r3,10(r2)
81137f88:	e0bff717 	ldw	r2,-36(fp)
81137f8c:	10800d83 	ldbu	r2,54(r2)
81137f90:	1884b03a 	or	r2,r3,r2
81137f94:	1007883a 	mov	r3,r2
81137f98:	e0bff917 	ldw	r2,-28(fp)
81137f9c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81137fa0:	e0bff717 	ldw	r2,-36(fp)
81137fa4:	10800d03 	ldbu	r2,52(r2)
81137fa8:	10803fcc 	andi	r2,r2,255
81137fac:	e0fff717 	ldw	r3,-36(fp)
81137fb0:	18c00d03 	ldbu	r3,52(r3)
81137fb4:	18c03fcc 	andi	r3,r3,255
81137fb8:	e13ff917 	ldw	r4,-28(fp)
81137fbc:	20c7883a 	add	r3,r4,r3
81137fc0:	18c002c4 	addi	r3,r3,11
81137fc4:	19000003 	ldbu	r4,0(r3)
81137fc8:	e0fff717 	ldw	r3,-36(fp)
81137fcc:	18c00d43 	ldbu	r3,53(r3)
81137fd0:	20c6b03a 	or	r3,r4,r3
81137fd4:	1809883a 	mov	r4,r3
81137fd8:	e0fff917 	ldw	r3,-28(fp)
81137fdc:	1885883a 	add	r2,r3,r2
81137fe0:	108002c4 	addi	r2,r2,11
81137fe4:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81137fe8:	e0fff303 	ldbu	r3,-52(fp)
81137fec:	00a045b4 	movhi	r2,33046
81137ff0:	109b0304 	addi	r2,r2,27660
81137ff4:	18c7883a 	add	r3,r3,r3
81137ff8:	18c7883a 	add	r3,r3,r3
81137ffc:	10c5883a 	add	r2,r2,r3
81138000:	e0fff717 	ldw	r3,-36(fp)
81138004:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81138008:	d0a09c17 	ldw	r2,-32144(gp)
8113800c:	d0e09c17 	ldw	r3,-32144(gp)
81138010:	18c00c03 	ldbu	r3,48(r3)
81138014:	18c00414 	ori	r3,r3,16
81138018:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113801c:	d0a09c17 	ldw	r2,-32144(gp)
81138020:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81138024:	d0a09c17 	ldw	r2,-32144(gp)
81138028:	e0fffe0b 	ldhu	r3,-8(fp)
8113802c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81138030:	e13ffd17 	ldw	r4,-12(fp)
81138034:	11343ac0 	call	811343ac <OS_EventTaskWait>
81138038:	e0bff117 	ldw	r2,-60(fp)
8113803c:	e0bffb15 	stw	r2,-20(fp)
81138040:	e0bffb17 	ldw	r2,-20(fp)
81138044:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81138048:	1134cc80 	call	81134cc8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113804c:	0005303a 	rdctl	r2,status
81138050:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138054:	e0fff517 	ldw	r3,-44(fp)
81138058:	00bfff84 	movi	r2,-2
8113805c:	1884703a 	and	r2,r3,r2
81138060:	1001703a 	wrctl	status,r2
  
  return context;
81138064:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
81138068:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113806c:	d0a09c17 	ldw	r2,-32144(gp)
81138070:	10800c43 	ldbu	r2,49(r2)
81138074:	10803fcc 	andi	r2,r2,255
81138078:	10000326 	beq	r2,zero,81138088 <OSMutexPend+0x51c>
8113807c:	108000a0 	cmpeqi	r2,r2,2
81138080:	1000041e 	bne	r2,zero,81138094 <OSMutexPend+0x528>
81138084:	00000706 	br	811380a4 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81138088:	e0bfff17 	ldw	r2,-4(fp)
8113808c:	10000005 	stb	zero,0(r2)
             break;
81138090:	00000c06 	br	811380c4 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81138094:	e0bfff17 	ldw	r2,-4(fp)
81138098:	00c00384 	movi	r3,14
8113809c:	10c00005 	stb	r3,0(r2)
             break;
811380a0:	00000806 	br	811380c4 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
811380a4:	d0a09c17 	ldw	r2,-32144(gp)
811380a8:	e17ffd17 	ldw	r5,-12(fp)
811380ac:	1009883a 	mov	r4,r2
811380b0:	113461c0 	call	8113461c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
811380b4:	e0bfff17 	ldw	r2,-4(fp)
811380b8:	00c00284 	movi	r3,10
811380bc:	10c00005 	stb	r3,0(r2)
             break;
811380c0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
811380c4:	d0a09c17 	ldw	r2,-32144(gp)
811380c8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
811380cc:	d0a09c17 	ldw	r2,-32144(gp)
811380d0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
811380d4:	d0a09c17 	ldw	r2,-32144(gp)
811380d8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811380dc:	d0a09c17 	ldw	r2,-32144(gp)
811380e0:	10000815 	stw	zero,32(r2)
811380e4:	e0bff117 	ldw	r2,-60(fp)
811380e8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811380ec:	e0bffa17 	ldw	r2,-24(fp)
811380f0:	1001703a 	wrctl	status,r2
811380f4:	00000106 	br	811380fc <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
811380f8:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
811380fc:	e037883a 	mov	sp,fp
81138100:	dfc00117 	ldw	ra,4(sp)
81138104:	df000017 	ldw	fp,0(sp)
81138108:	dec00204 	addi	sp,sp,8
8113810c:	f800283a 	ret

81138110 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81138110:	defff604 	addi	sp,sp,-40
81138114:	de00012e 	bgeu	sp,et,8113811c <OSMutexPost+0xc>
81138118:	003b68fa 	trap	3
8113811c:	dfc00915 	stw	ra,36(sp)
81138120:	df000815 	stw	fp,32(sp)
81138124:	df000804 	addi	fp,sp,32
81138128:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113812c:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81138130:	d0a09b03 	ldbu	r2,-32148(gp)
81138134:	10803fcc 	andi	r2,r2,255
81138138:	10000226 	beq	r2,zero,81138144 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113813c:	00800144 	movi	r2,5
81138140:	00007606 	br	8113831c <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138144:	e0bfff17 	ldw	r2,-4(fp)
81138148:	1000021e 	bne	r2,zero,81138154 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113814c:	00800104 	movi	r2,4
81138150:	00007206 	br	8113831c <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
81138154:	e0bfff17 	ldw	r2,-4(fp)
81138158:	10800003 	ldbu	r2,0(r2)
8113815c:	10803fcc 	andi	r2,r2,255
81138160:	10800120 	cmpeqi	r2,r2,4
81138164:	1000021e 	bne	r2,zero,81138170 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
81138168:	00800044 	movi	r2,1
8113816c:	00006b06 	br	8113831c <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138170:	0005303a 	rdctl	r2,status
81138174:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138178:	e0fffe17 	ldw	r3,-8(fp)
8113817c:	00bfff84 	movi	r2,-2
81138180:	1884703a 	and	r2,r3,r2
81138184:	1001703a 	wrctl	status,r2
  
  return context;
81138188:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113818c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81138190:	e0bfff17 	ldw	r2,-4(fp)
81138194:	1080020b 	ldhu	r2,8(r2)
81138198:	10bfffcc 	andi	r2,r2,65535
8113819c:	1004d23a 	srli	r2,r2,8
811381a0:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
811381a4:	e0bfff17 	ldw	r2,-4(fp)
811381a8:	1080020b 	ldhu	r2,8(r2)
811381ac:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
811381b0:	e0bfff17 	ldw	r2,-4(fp)
811381b4:	10c00117 	ldw	r3,4(r2)
811381b8:	d0a09c17 	ldw	r2,-32144(gp)
811381bc:	18800626 	beq	r3,r2,811381d8 <OSMutexPost+0xc8>
811381c0:	e0bff817 	ldw	r2,-32(fp)
811381c4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811381c8:	e0bff917 	ldw	r2,-28(fp)
811381cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
811381d0:	00801904 	movi	r2,100
811381d4:	00005106 	br	8113831c <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
811381d8:	d0a09c17 	ldw	r2,-32144(gp)
811381dc:	10800c83 	ldbu	r2,50(r2)
811381e0:	10c03fcc 	andi	r3,r2,255
811381e4:	e0bffa03 	ldbu	r2,-24(fp)
811381e8:	1880051e 	bne	r3,r2,81138200 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
811381ec:	d0a09c17 	ldw	r2,-32144(gp)
811381f0:	e0fffa43 	ldbu	r3,-23(fp)
811381f4:	180b883a 	mov	r5,r3
811381f8:	1009883a 	mov	r4,r2
811381fc:	11384a40 	call	811384a4 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81138200:	e0fffa03 	ldbu	r3,-24(fp)
81138204:	00a045b4 	movhi	r2,33046
81138208:	109b0304 	addi	r2,r2,27660
8113820c:	18c7883a 	add	r3,r3,r3
81138210:	18c7883a 	add	r3,r3,r3
81138214:	10c5883a 	add	r2,r2,r3
81138218:	00c00044 	movi	r3,1
8113821c:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
81138220:	e0bfff17 	ldw	r2,-4(fp)
81138224:	10800283 	ldbu	r2,10(r2)
81138228:	10803fcc 	andi	r2,r2,255
8113822c:	10002e26 	beq	r2,zero,811382e8 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81138230:	000f883a 	mov	r7,zero
81138234:	01800404 	movi	r6,16
81138238:	000b883a 	mov	r5,zero
8113823c:	e13fff17 	ldw	r4,-4(fp)
81138240:	113420c0 	call	8113420c <OS_EventTaskRdy>
81138244:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
81138248:	e0bfff17 	ldw	r2,-4(fp)
8113824c:	10c0020b 	ldhu	r3,8(r2)
81138250:	00bfc004 	movi	r2,-256
81138254:	1884703a 	and	r2,r3,r2
81138258:	1007883a 	mov	r3,r2
8113825c:	e0bfff17 	ldw	r2,-4(fp)
81138260:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
81138264:	e0bfff17 	ldw	r2,-4(fp)
81138268:	10c0020b 	ldhu	r3,8(r2)
8113826c:	e0bffa43 	ldbu	r2,-23(fp)
81138270:	1884b03a 	or	r2,r3,r2
81138274:	1007883a 	mov	r3,r2
81138278:	e0bfff17 	ldw	r2,-4(fp)
8113827c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81138280:	e0fffa43 	ldbu	r3,-23(fp)
81138284:	00a045b4 	movhi	r2,33046
81138288:	109b0304 	addi	r2,r2,27660
8113828c:	18c7883a 	add	r3,r3,r3
81138290:	18c7883a 	add	r3,r3,r3
81138294:	10c5883a 	add	r2,r2,r3
81138298:	10c00017 	ldw	r3,0(r2)
8113829c:	e0bfff17 	ldw	r2,-4(fp)
811382a0:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
811382a4:	e0bffa43 	ldbu	r2,-23(fp)
811382a8:	e0fffa03 	ldbu	r3,-24(fp)
811382ac:	18800736 	bltu	r3,r2,811382cc <OSMutexPost+0x1bc>
811382b0:	e0bff817 	ldw	r2,-32(fp)
811382b4:	e0bffb15 	stw	r2,-20(fp)
811382b8:	e0bffb17 	ldw	r2,-20(fp)
811382bc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
811382c0:	1134cc80 	call	81134cc8 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
811382c4:	00801e04 	movi	r2,120
811382c8:	00001406 	br	8113831c <OSMutexPost+0x20c>
811382cc:	e0bff817 	ldw	r2,-32(fp)
811382d0:	e0bffc15 	stw	r2,-16(fp)
811382d4:	e0bffc17 	ldw	r2,-16(fp)
811382d8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
811382dc:	1134cc80 	call	81134cc8 <OS_Sched>
            return (OS_ERR_NONE);
811382e0:	0005883a 	mov	r2,zero
811382e4:	00000d06 	br	8113831c <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
811382e8:	e0bfff17 	ldw	r2,-4(fp)
811382ec:	1080020b 	ldhu	r2,8(r2)
811382f0:	10803fd4 	ori	r2,r2,255
811382f4:	1007883a 	mov	r3,r2
811382f8:	e0bfff17 	ldw	r2,-4(fp)
811382fc:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81138300:	e0bfff17 	ldw	r2,-4(fp)
81138304:	10000115 	stw	zero,4(r2)
81138308:	e0bff817 	ldw	r2,-32(fp)
8113830c:	e0bffd15 	stw	r2,-12(fp)
81138310:	e0bffd17 	ldw	r2,-12(fp)
81138314:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138318:	0005883a 	mov	r2,zero
}
8113831c:	e037883a 	mov	sp,fp
81138320:	dfc00117 	ldw	ra,4(sp)
81138324:	df000017 	ldw	fp,0(sp)
81138328:	dec00204 	addi	sp,sp,8
8113832c:	f800283a 	ret

81138330 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
81138330:	defff704 	addi	sp,sp,-36
81138334:	de00012e 	bgeu	sp,et,8113833c <OSMutexQuery+0xc>
81138338:	003b68fa 	trap	3
8113833c:	df000815 	stw	fp,32(sp)
81138340:	df000804 	addi	fp,sp,32
81138344:	e13ffe15 	stw	r4,-8(fp)
81138348:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113834c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81138350:	d0a09b03 	ldbu	r2,-32148(gp)
81138354:	10803fcc 	andi	r2,r2,255
81138358:	10000226 	beq	r2,zero,81138364 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113835c:	00800184 	movi	r2,6
81138360:	00004c06 	br	81138494 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138364:	e0bffe17 	ldw	r2,-8(fp)
81138368:	1000021e 	bne	r2,zero,81138374 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113836c:	00800104 	movi	r2,4
81138370:	00004806 	br	81138494 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
81138374:	e0bfff17 	ldw	r2,-4(fp)
81138378:	1000021e 	bne	r2,zero,81138384 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113837c:	00800244 	movi	r2,9
81138380:	00004406 	br	81138494 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81138384:	e0bffe17 	ldw	r2,-8(fp)
81138388:	10800003 	ldbu	r2,0(r2)
8113838c:	10803fcc 	andi	r2,r2,255
81138390:	10800120 	cmpeqi	r2,r2,4
81138394:	1000021e 	bne	r2,zero,811383a0 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81138398:	00800044 	movi	r2,1
8113839c:	00003d06 	br	81138494 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811383a0:	0005303a 	rdctl	r2,status
811383a4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811383a8:	e0fffd17 	ldw	r3,-12(fp)
811383ac:	00bfff84 	movi	r2,-2
811383b0:	1884703a 	and	r2,r3,r2
811383b4:	1001703a 	wrctl	status,r2
  
  return context;
811383b8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811383bc:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
811383c0:	e0bffe17 	ldw	r2,-8(fp)
811383c4:	1080020b 	ldhu	r2,8(r2)
811383c8:	10bfffcc 	andi	r2,r2,65535
811383cc:	1004d23a 	srli	r2,r2,8
811383d0:	1007883a 	mov	r3,r2
811383d4:	e0bfff17 	ldw	r2,-4(fp)
811383d8:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
811383dc:	e0bffe17 	ldw	r2,-8(fp)
811383e0:	1080020b 	ldhu	r2,8(r2)
811383e4:	1007883a 	mov	r3,r2
811383e8:	e0bfff17 	ldw	r2,-4(fp)
811383ec:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
811383f0:	e0bfff17 	ldw	r2,-4(fp)
811383f4:	10800203 	ldbu	r2,8(r2)
811383f8:	10803fcc 	andi	r2,r2,255
811383fc:	10803fd8 	cmpnei	r2,r2,255
81138400:	1000041e 	bne	r2,zero,81138414 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81138404:	e0bfff17 	ldw	r2,-4(fp)
81138408:	00c00044 	movi	r3,1
8113840c:	10c001c5 	stb	r3,7(r2)
81138410:	00000206 	br	8113841c <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81138414:	e0bfff17 	ldw	r2,-4(fp)
81138418:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113841c:	e0bffe17 	ldw	r2,-8(fp)
81138420:	10c00283 	ldbu	r3,10(r2)
81138424:	e0bfff17 	ldw	r2,-4(fp)
81138428:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113842c:	e0bffe17 	ldw	r2,-8(fp)
81138430:	108002c4 	addi	r2,r2,11
81138434:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
81138438:	e0bfff17 	ldw	r2,-4(fp)
8113843c:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138440:	e03ff805 	stb	zero,-32(fp)
81138444:	00000b06 	br	81138474 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
81138448:	e0bffa17 	ldw	r2,-24(fp)
8113844c:	10c00044 	addi	r3,r2,1
81138450:	e0fffa15 	stw	r3,-24(fp)
81138454:	e0fff917 	ldw	r3,-28(fp)
81138458:	19000044 	addi	r4,r3,1
8113845c:	e13ff915 	stw	r4,-28(fp)
81138460:	18c00003 	ldbu	r3,0(r3)
81138464:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138468:	e0bff803 	ldbu	r2,-32(fp)
8113846c:	10800044 	addi	r2,r2,1
81138470:	e0bff805 	stb	r2,-32(fp)
81138474:	e0bff803 	ldbu	r2,-32(fp)
81138478:	108001b0 	cmpltui	r2,r2,6
8113847c:	103ff21e 	bne	r2,zero,81138448 <__reset+0xfb118448>
81138480:	e0bffb17 	ldw	r2,-20(fp)
81138484:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138488:	e0bffc17 	ldw	r2,-16(fp)
8113848c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138490:	0005883a 	mov	r2,zero
}
81138494:	e037883a 	mov	sp,fp
81138498:	df000017 	ldw	fp,0(sp)
8113849c:	dec00104 	addi	sp,sp,4
811384a0:	f800283a 	ret

811384a4 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
811384a4:	defffc04 	addi	sp,sp,-16
811384a8:	de00012e 	bgeu	sp,et,811384b0 <OSMutex_RdyAtPrio+0xc>
811384ac:	003b68fa 	trap	3
811384b0:	df000315 	stw	fp,12(sp)
811384b4:	df000304 	addi	fp,sp,12
811384b8:	e13ffe15 	stw	r4,-8(fp)
811384bc:	2805883a 	mov	r2,r5
811384c0:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
811384c4:	e0bffe17 	ldw	r2,-8(fp)
811384c8:	10800d03 	ldbu	r2,52(r2)
811384cc:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
811384d0:	e0fffd03 	ldbu	r3,-12(fp)
811384d4:	e13ffd03 	ldbu	r4,-12(fp)
811384d8:	d0a09844 	addi	r2,gp,-32159
811384dc:	2085883a 	add	r2,r4,r2
811384e0:	10800003 	ldbu	r2,0(r2)
811384e4:	1009883a 	mov	r4,r2
811384e8:	e0bffe17 	ldw	r2,-8(fp)
811384ec:	10800d43 	ldbu	r2,53(r2)
811384f0:	0084303a 	nor	r2,zero,r2
811384f4:	2084703a 	and	r2,r4,r2
811384f8:	1009883a 	mov	r4,r2
811384fc:	d0a09844 	addi	r2,gp,-32159
81138500:	1885883a 	add	r2,r3,r2
81138504:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81138508:	e0fffd03 	ldbu	r3,-12(fp)
8113850c:	d0a09844 	addi	r2,gp,-32159
81138510:	1885883a 	add	r2,r3,r2
81138514:	10800003 	ldbu	r2,0(r2)
81138518:	10803fcc 	andi	r2,r2,255
8113851c:	1000071e 	bne	r2,zero,8113853c <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81138520:	e0bffe17 	ldw	r2,-8(fp)
81138524:	10800d83 	ldbu	r2,54(r2)
81138528:	0084303a 	nor	r2,zero,r2
8113852c:	1007883a 	mov	r3,r2
81138530:	d0a09803 	ldbu	r2,-32160(gp)
81138534:	1884703a 	and	r2,r3,r2
81138538:	d0a09805 	stb	r2,-32160(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113853c:	e0bffe17 	ldw	r2,-8(fp)
81138540:	e0ffff03 	ldbu	r3,-4(fp)
81138544:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
81138548:	e0bfff03 	ldbu	r2,-4(fp)
8113854c:	1004d0fa 	srli	r2,r2,3
81138550:	108001cc 	andi	r2,r2,7
81138554:	1007883a 	mov	r3,r2
81138558:	e0bffe17 	ldw	r2,-8(fp)
8113855c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
81138560:	e0bfff03 	ldbu	r2,-4(fp)
81138564:	108001cc 	andi	r2,r2,7
81138568:	1007883a 	mov	r3,r2
8113856c:	e0bffe17 	ldw	r2,-8(fp)
81138570:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
81138574:	e0bffe17 	ldw	r2,-8(fp)
81138578:	10800d03 	ldbu	r2,52(r2)
8113857c:	10803fcc 	andi	r2,r2,255
81138580:	00c00044 	movi	r3,1
81138584:	1884983a 	sll	r2,r3,r2
81138588:	1007883a 	mov	r3,r2
8113858c:	e0bffe17 	ldw	r2,-8(fp)
81138590:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81138594:	e0bffe17 	ldw	r2,-8(fp)
81138598:	10800cc3 	ldbu	r2,51(r2)
8113859c:	10803fcc 	andi	r2,r2,255
811385a0:	00c00044 	movi	r3,1
811385a4:	1884983a 	sll	r2,r3,r2
811385a8:	1007883a 	mov	r3,r2
811385ac:	e0bffe17 	ldw	r2,-8(fp)
811385b0:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
811385b4:	e0bffe17 	ldw	r2,-8(fp)
811385b8:	10c00d83 	ldbu	r3,54(r2)
811385bc:	d0a09803 	ldbu	r2,-32160(gp)
811385c0:	1884b03a 	or	r2,r3,r2
811385c4:	d0a09805 	stb	r2,-32160(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811385c8:	e0bffe17 	ldw	r2,-8(fp)
811385cc:	10800d03 	ldbu	r2,52(r2)
811385d0:	10c03fcc 	andi	r3,r2,255
811385d4:	e0bffe17 	ldw	r2,-8(fp)
811385d8:	10800d03 	ldbu	r2,52(r2)
811385dc:	11003fcc 	andi	r4,r2,255
811385e0:	d0a09844 	addi	r2,gp,-32159
811385e4:	2085883a 	add	r2,r4,r2
811385e8:	11000003 	ldbu	r4,0(r2)
811385ec:	e0bffe17 	ldw	r2,-8(fp)
811385f0:	10800d43 	ldbu	r2,53(r2)
811385f4:	2084b03a 	or	r2,r4,r2
811385f8:	1009883a 	mov	r4,r2
811385fc:	d0a09844 	addi	r2,gp,-32159
81138600:	1885883a 	add	r2,r3,r2
81138604:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
81138608:	e0ffff03 	ldbu	r3,-4(fp)
8113860c:	00a045b4 	movhi	r2,33046
81138610:	109b0304 	addi	r2,r2,27660
81138614:	18c7883a 	add	r3,r3,r3
81138618:	18c7883a 	add	r3,r3,r3
8113861c:	10c5883a 	add	r2,r2,r3
81138620:	e0fffe17 	ldw	r3,-8(fp)
81138624:	10c00015 	stw	r3,0(r2)
}
81138628:	0001883a 	nop
8113862c:	e037883a 	mov	sp,fp
81138630:	df000017 	ldw	fp,0(sp)
81138634:	dec00104 	addi	sp,sp,4
81138638:	f800283a 	ret

8113863c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113863c:	defff804 	addi	sp,sp,-32
81138640:	de00012e 	bgeu	sp,et,81138648 <OSQAccept+0xc>
81138644:	003b68fa 	trap	3
81138648:	df000715 	stw	fp,28(sp)
8113864c:	df000704 	addi	fp,sp,28
81138650:	e13ffe15 	stw	r4,-8(fp)
81138654:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138658:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113865c:	e0bfff17 	ldw	r2,-4(fp)
81138660:	1000021e 	bne	r2,zero,8113866c <OSQAccept+0x30>
        return ((void *)0);
81138664:	0005883a 	mov	r2,zero
81138668:	00004206 	br	81138774 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113866c:	e0bffe17 	ldw	r2,-8(fp)
81138670:	1000051e 	bne	r2,zero,81138688 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81138674:	e0bfff17 	ldw	r2,-4(fp)
81138678:	00c00104 	movi	r3,4
8113867c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138680:	0005883a 	mov	r2,zero
81138684:	00003b06 	br	81138774 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81138688:	e0bffe17 	ldw	r2,-8(fp)
8113868c:	10800003 	ldbu	r2,0(r2)
81138690:	10803fcc 	andi	r2,r2,255
81138694:	108000a0 	cmpeqi	r2,r2,2
81138698:	1000051e 	bne	r2,zero,811386b0 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113869c:	e0bfff17 	ldw	r2,-4(fp)
811386a0:	00c00044 	movi	r3,1
811386a4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811386a8:	0005883a 	mov	r2,zero
811386ac:	00003106 	br	81138774 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811386b0:	0005303a 	rdctl	r2,status
811386b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811386b8:	e0fffd17 	ldw	r3,-12(fp)
811386bc:	00bfff84 	movi	r2,-2
811386c0:	1884703a 	and	r2,r3,r2
811386c4:	1001703a 	wrctl	status,r2
  
  return context;
811386c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811386cc:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
811386d0:	e0bffe17 	ldw	r2,-8(fp)
811386d4:	10800117 	ldw	r2,4(r2)
811386d8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
811386dc:	e0bffc17 	ldw	r2,-16(fp)
811386e0:	1080058b 	ldhu	r2,22(r2)
811386e4:	10bfffcc 	andi	r2,r2,65535
811386e8:	10001926 	beq	r2,zero,81138750 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
811386ec:	e0bffc17 	ldw	r2,-16(fp)
811386f0:	10800417 	ldw	r2,16(r2)
811386f4:	11000104 	addi	r4,r2,4
811386f8:	e0fffc17 	ldw	r3,-16(fp)
811386fc:	19000415 	stw	r4,16(r3)
81138700:	10800017 	ldw	r2,0(r2)
81138704:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81138708:	e0bffc17 	ldw	r2,-16(fp)
8113870c:	1080058b 	ldhu	r2,22(r2)
81138710:	10bfffc4 	addi	r2,r2,-1
81138714:	1007883a 	mov	r3,r2
81138718:	e0bffc17 	ldw	r2,-16(fp)
8113871c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81138720:	e0bffc17 	ldw	r2,-16(fp)
81138724:	10c00417 	ldw	r3,16(r2)
81138728:	e0bffc17 	ldw	r2,-16(fp)
8113872c:	10800217 	ldw	r2,8(r2)
81138730:	1880041e 	bne	r3,r2,81138744 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
81138734:	e0bffc17 	ldw	r2,-16(fp)
81138738:	10c00117 	ldw	r3,4(r2)
8113873c:	e0bffc17 	ldw	r2,-16(fp)
81138740:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
81138744:	e0bfff17 	ldw	r2,-4(fp)
81138748:	10000005 	stb	zero,0(r2)
8113874c:	00000406 	br	81138760 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
81138750:	e0bfff17 	ldw	r2,-4(fp)
81138754:	00c007c4 	movi	r3,31
81138758:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113875c:	e03ff915 	stw	zero,-28(fp)
81138760:	e0bffa17 	ldw	r2,-24(fp)
81138764:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138768:	e0bffb17 	ldw	r2,-20(fp)
8113876c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
81138770:	e0bff917 	ldw	r2,-28(fp)
}
81138774:	e037883a 	mov	sp,fp
81138778:	df000017 	ldw	fp,0(sp)
8113877c:	dec00104 	addi	sp,sp,4
81138780:	f800283a 	ret

81138784 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81138784:	defff404 	addi	sp,sp,-48
81138788:	de00012e 	bgeu	sp,et,81138790 <OSQCreate+0xc>
8113878c:	003b68fa 	trap	3
81138790:	dfc00b15 	stw	ra,44(sp)
81138794:	df000a15 	stw	fp,40(sp)
81138798:	df000a04 	addi	fp,sp,40
8113879c:	e13ffe15 	stw	r4,-8(fp)
811387a0:	2805883a 	mov	r2,r5
811387a4:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811387a8:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
811387ac:	d0a09b03 	ldbu	r2,-32148(gp)
811387b0:	10803fcc 	andi	r2,r2,255
811387b4:	10000226 	beq	r2,zero,811387c0 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
811387b8:	0005883a 	mov	r2,zero
811387bc:	00005906 	br	81138924 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811387c0:	0005303a 	rdctl	r2,status
811387c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811387c8:	e0fffd17 	ldw	r3,-12(fp)
811387cc:	00bfff84 	movi	r2,-2
811387d0:	1884703a 	and	r2,r3,r2
811387d4:	1001703a 	wrctl	status,r2
  
  return context;
811387d8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811387dc:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
811387e0:	d0a09a17 	ldw	r2,-32152(gp)
811387e4:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
811387e8:	d0a09a17 	ldw	r2,-32152(gp)
811387ec:	10000326 	beq	r2,zero,811387fc <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811387f0:	d0a09a17 	ldw	r2,-32152(gp)
811387f4:	10800117 	ldw	r2,4(r2)
811387f8:	d0a09a15 	stw	r2,-32152(gp)
811387fc:	e0bff717 	ldw	r2,-36(fp)
81138800:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138804:	e0bff817 	ldw	r2,-32(fp)
81138808:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113880c:	e0bff617 	ldw	r2,-40(fp)
81138810:	10004326 	beq	r2,zero,81138920 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138814:	0005303a 	rdctl	r2,status
81138818:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113881c:	e0fff917 	ldw	r3,-28(fp)
81138820:	00bfff84 	movi	r2,-2
81138824:	1884703a 	and	r2,r3,r2
81138828:	1001703a 	wrctl	status,r2
  
  return context;
8113882c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
81138830:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
81138834:	d0a09717 	ldw	r2,-32164(gp)
81138838:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113883c:	e0bffb17 	ldw	r2,-20(fp)
81138840:	10002d26 	beq	r2,zero,811388f8 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
81138844:	d0a09717 	ldw	r2,-32164(gp)
81138848:	10800017 	ldw	r2,0(r2)
8113884c:	d0a09715 	stw	r2,-32164(gp)
81138850:	e0bff717 	ldw	r2,-36(fp)
81138854:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138858:	e0bffa17 	ldw	r2,-24(fp)
8113885c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
81138860:	e0bffb17 	ldw	r2,-20(fp)
81138864:	e0fffe17 	ldw	r3,-8(fp)
81138868:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113886c:	e0bfff0b 	ldhu	r2,-4(fp)
81138870:	1085883a 	add	r2,r2,r2
81138874:	1085883a 	add	r2,r2,r2
81138878:	1007883a 	mov	r3,r2
8113887c:	e0bffe17 	ldw	r2,-8(fp)
81138880:	10c7883a 	add	r3,r2,r3
81138884:	e0bffb17 	ldw	r2,-20(fp)
81138888:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113888c:	e0bffb17 	ldw	r2,-20(fp)
81138890:	e0fffe17 	ldw	r3,-8(fp)
81138894:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
81138898:	e0bffb17 	ldw	r2,-20(fp)
8113889c:	e0fffe17 	ldw	r3,-8(fp)
811388a0:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
811388a4:	e0bffb17 	ldw	r2,-20(fp)
811388a8:	e0ffff0b 	ldhu	r3,-4(fp)
811388ac:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
811388b0:	e0bffb17 	ldw	r2,-20(fp)
811388b4:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
811388b8:	e0bff617 	ldw	r2,-40(fp)
811388bc:	00c00084 	movi	r3,2
811388c0:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
811388c4:	e0bff617 	ldw	r2,-40(fp)
811388c8:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
811388cc:	e0bff617 	ldw	r2,-40(fp)
811388d0:	e0fffb17 	ldw	r3,-20(fp)
811388d4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
811388d8:	e0bff617 	ldw	r2,-40(fp)
811388dc:	00c00fc4 	movi	r3,63
811388e0:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
811388e4:	e0bff617 	ldw	r2,-40(fp)
811388e8:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
811388ec:	e13ff617 	ldw	r4,-40(fp)
811388f0:	11347e40 	call	811347e4 <OS_EventWaitListInit>
811388f4:	00000a06 	br	81138920 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
811388f8:	d0e09a17 	ldw	r3,-32152(gp)
811388fc:	e0bff617 	ldw	r2,-40(fp)
81138900:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
81138904:	e0bff617 	ldw	r2,-40(fp)
81138908:	d0a09a15 	stw	r2,-32152(gp)
8113890c:	e0bff717 	ldw	r2,-36(fp)
81138910:	e0bffc15 	stw	r2,-16(fp)
81138914:	e0bffc17 	ldw	r2,-16(fp)
81138918:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113891c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
81138920:	e0bff617 	ldw	r2,-40(fp)
}
81138924:	e037883a 	mov	sp,fp
81138928:	dfc00117 	ldw	ra,4(sp)
8113892c:	df000017 	ldw	fp,0(sp)
81138930:	dec00204 	addi	sp,sp,8
81138934:	f800283a 	ret

81138938 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81138938:	defff204 	addi	sp,sp,-56
8113893c:	de00012e 	bgeu	sp,et,81138944 <OSQDel+0xc>
81138940:	003b68fa 	trap	3
81138944:	dfc00d15 	stw	ra,52(sp)
81138948:	df000c15 	stw	fp,48(sp)
8113894c:	df000c04 	addi	fp,sp,48
81138950:	e13ffd15 	stw	r4,-12(fp)
81138954:	2805883a 	mov	r2,r5
81138958:	e1bfff15 	stw	r6,-4(fp)
8113895c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138960:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138964:	e0bfff17 	ldw	r2,-4(fp)
81138968:	1000021e 	bne	r2,zero,81138974 <OSQDel+0x3c>
        return (pevent);
8113896c:	e0bffd17 	ldw	r2,-12(fp)
81138970:	00008e06 	br	81138bac <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138974:	e0bffd17 	ldw	r2,-12(fp)
81138978:	1000051e 	bne	r2,zero,81138990 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113897c:	e0bfff17 	ldw	r2,-4(fp)
81138980:	00c00104 	movi	r3,4
81138984:	10c00005 	stb	r3,0(r2)
        return (pevent);
81138988:	e0bffd17 	ldw	r2,-12(fp)
8113898c:	00008706 	br	81138bac <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81138990:	e0bffd17 	ldw	r2,-12(fp)
81138994:	10800003 	ldbu	r2,0(r2)
81138998:	10803fcc 	andi	r2,r2,255
8113899c:	108000a0 	cmpeqi	r2,r2,2
811389a0:	1000051e 	bne	r2,zero,811389b8 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811389a4:	e0bfff17 	ldw	r2,-4(fp)
811389a8:	00c00044 	movi	r3,1
811389ac:	10c00005 	stb	r3,0(r2)
        return (pevent);
811389b0:	e0bffd17 	ldw	r2,-12(fp)
811389b4:	00007d06 	br	81138bac <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811389b8:	d0a09b03 	ldbu	r2,-32148(gp)
811389bc:	10803fcc 	andi	r2,r2,255
811389c0:	10000526 	beq	r2,zero,811389d8 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811389c4:	e0bfff17 	ldw	r2,-4(fp)
811389c8:	00c003c4 	movi	r3,15
811389cc:	10c00005 	stb	r3,0(r2)
        return (pevent);
811389d0:	e0bffd17 	ldw	r2,-12(fp)
811389d4:	00007506 	br	81138bac <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811389d8:	0005303a 	rdctl	r2,status
811389dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811389e0:	e0fffc17 	ldw	r3,-16(fp)
811389e4:	00bfff84 	movi	r2,-2
811389e8:	1884703a 	and	r2,r3,r2
811389ec:	1001703a 	wrctl	status,r2
  
  return context;
811389f0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811389f4:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
811389f8:	e0bffd17 	ldw	r2,-12(fp)
811389fc:	10800283 	ldbu	r2,10(r2)
81138a00:	10803fcc 	andi	r2,r2,255
81138a04:	10000326 	beq	r2,zero,81138a14 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81138a08:	00800044 	movi	r2,1
81138a0c:	e0bff405 	stb	r2,-48(fp)
81138a10:	00000106 	br	81138a18 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81138a14:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81138a18:	e0bffe03 	ldbu	r2,-8(fp)
81138a1c:	10000326 	beq	r2,zero,81138a2c <OSQDel+0xf4>
81138a20:	10800060 	cmpeqi	r2,r2,1
81138a24:	1000301e 	bne	r2,zero,81138ae8 <OSQDel+0x1b0>
81138a28:	00005506 	br	81138b80 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
81138a2c:	e0bff403 	ldbu	r2,-48(fp)
81138a30:	10001e1e 	bne	r2,zero,81138aac <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81138a34:	e0bffd17 	ldw	r2,-12(fp)
81138a38:	00c00fc4 	movi	r3,63
81138a3c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81138a40:	e0bffd17 	ldw	r2,-12(fp)
81138a44:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
81138a48:	e0bffd17 	ldw	r2,-12(fp)
81138a4c:	10800117 	ldw	r2,4(r2)
81138a50:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
81138a54:	d0e09717 	ldw	r3,-32164(gp)
81138a58:	e0bff817 	ldw	r2,-32(fp)
81138a5c:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
81138a60:	e0bff817 	ldw	r2,-32(fp)
81138a64:	d0a09715 	stw	r2,-32164(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81138a68:	e0bffd17 	ldw	r2,-12(fp)
81138a6c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81138a70:	d0e09a17 	ldw	r3,-32152(gp)
81138a74:	e0bffd17 	ldw	r2,-12(fp)
81138a78:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81138a7c:	e0bffd17 	ldw	r2,-12(fp)
81138a80:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81138a84:	e0bffd17 	ldw	r2,-12(fp)
81138a88:	d0a09a15 	stw	r2,-32152(gp)
81138a8c:	e0bff617 	ldw	r2,-40(fp)
81138a90:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138a94:	e0bff717 	ldw	r2,-36(fp)
81138a98:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81138a9c:	e0bfff17 	ldw	r2,-4(fp)
81138aa0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
81138aa4:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81138aa8:	00003f06 	br	81138ba8 <OSQDel+0x270>
81138aac:	e0bff617 	ldw	r2,-40(fp)
81138ab0:	e0bff915 	stw	r2,-28(fp)
81138ab4:	e0bff917 	ldw	r2,-28(fp)
81138ab8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81138abc:	e0bfff17 	ldw	r2,-4(fp)
81138ac0:	00c01244 	movi	r3,73
81138ac4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81138ac8:	e0bffd17 	ldw	r2,-12(fp)
81138acc:	e0bff515 	stw	r2,-44(fp)
             }
             break;
81138ad0:	00003506 	br	81138ba8 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
81138ad4:	000f883a 	mov	r7,zero
81138ad8:	01800104 	movi	r6,4
81138adc:	000b883a 	mov	r5,zero
81138ae0:	e13ffd17 	ldw	r4,-12(fp)
81138ae4:	113420c0 	call	8113420c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
81138ae8:	e0bffd17 	ldw	r2,-12(fp)
81138aec:	10800283 	ldbu	r2,10(r2)
81138af0:	10803fcc 	andi	r2,r2,255
81138af4:	103ff71e 	bne	r2,zero,81138ad4 <__reset+0xfb118ad4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81138af8:	e0bffd17 	ldw	r2,-12(fp)
81138afc:	00c00fc4 	movi	r3,63
81138b00:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81138b04:	e0bffd17 	ldw	r2,-12(fp)
81138b08:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
81138b0c:	e0bffd17 	ldw	r2,-12(fp)
81138b10:	10800117 	ldw	r2,4(r2)
81138b14:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
81138b18:	d0e09717 	ldw	r3,-32164(gp)
81138b1c:	e0bff817 	ldw	r2,-32(fp)
81138b20:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
81138b24:	e0bff817 	ldw	r2,-32(fp)
81138b28:	d0a09715 	stw	r2,-32164(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81138b2c:	e0bffd17 	ldw	r2,-12(fp)
81138b30:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81138b34:	d0e09a17 	ldw	r3,-32152(gp)
81138b38:	e0bffd17 	ldw	r2,-12(fp)
81138b3c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81138b40:	e0bffd17 	ldw	r2,-12(fp)
81138b44:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81138b48:	e0bffd17 	ldw	r2,-12(fp)
81138b4c:	d0a09a15 	stw	r2,-32152(gp)
81138b50:	e0bff617 	ldw	r2,-40(fp)
81138b54:	e0bffa15 	stw	r2,-24(fp)
81138b58:	e0bffa17 	ldw	r2,-24(fp)
81138b5c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81138b60:	e0bff403 	ldbu	r2,-48(fp)
81138b64:	10800058 	cmpnei	r2,r2,1
81138b68:	1000011e 	bne	r2,zero,81138b70 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81138b6c:	1134cc80 	call	81134cc8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81138b70:	e0bfff17 	ldw	r2,-4(fp)
81138b74:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
81138b78:	e03ff515 	stw	zero,-44(fp)
             break;
81138b7c:	00000a06 	br	81138ba8 <OSQDel+0x270>
81138b80:	e0bff617 	ldw	r2,-40(fp)
81138b84:	e0bffb15 	stw	r2,-20(fp)
81138b88:	e0bffb17 	ldw	r2,-20(fp)
81138b8c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81138b90:	e0bfff17 	ldw	r2,-4(fp)
81138b94:	00c001c4 	movi	r3,7
81138b98:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81138b9c:	e0bffd17 	ldw	r2,-12(fp)
81138ba0:	e0bff515 	stw	r2,-44(fp)
             break;
81138ba4:	0001883a 	nop
    }
    return (pevent_return);
81138ba8:	e0bff517 	ldw	r2,-44(fp)
}
81138bac:	e037883a 	mov	sp,fp
81138bb0:	dfc00117 	ldw	ra,4(sp)
81138bb4:	df000017 	ldw	fp,0(sp)
81138bb8:	dec00204 	addi	sp,sp,8
81138bbc:	f800283a 	ret

81138bc0 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
81138bc0:	defffa04 	addi	sp,sp,-24
81138bc4:	de00012e 	bgeu	sp,et,81138bcc <OSQFlush+0xc>
81138bc8:	003b68fa 	trap	3
81138bcc:	df000515 	stw	fp,20(sp)
81138bd0:	df000504 	addi	fp,sp,20
81138bd4:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138bd8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138bdc:	e0bfff17 	ldw	r2,-4(fp)
81138be0:	1000021e 	bne	r2,zero,81138bec <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
81138be4:	00800104 	movi	r2,4
81138be8:	00002106 	br	81138c70 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81138bec:	e0bfff17 	ldw	r2,-4(fp)
81138bf0:	10800003 	ldbu	r2,0(r2)
81138bf4:	10803fcc 	andi	r2,r2,255
81138bf8:	108000a0 	cmpeqi	r2,r2,2
81138bfc:	1000021e 	bne	r2,zero,81138c08 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
81138c00:	00800044 	movi	r2,1
81138c04:	00001a06 	br	81138c70 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138c08:	0005303a 	rdctl	r2,status
81138c0c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138c10:	e0fffd17 	ldw	r3,-12(fp)
81138c14:	00bfff84 	movi	r2,-2
81138c18:	1884703a 	and	r2,r3,r2
81138c1c:	1001703a 	wrctl	status,r2
  
  return context;
81138c20:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138c24:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
81138c28:	e0bfff17 	ldw	r2,-4(fp)
81138c2c:	10800117 	ldw	r2,4(r2)
81138c30:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
81138c34:	e0bffc17 	ldw	r2,-16(fp)
81138c38:	10c00117 	ldw	r3,4(r2)
81138c3c:	e0bffc17 	ldw	r2,-16(fp)
81138c40:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
81138c44:	e0bffc17 	ldw	r2,-16(fp)
81138c48:	10c00117 	ldw	r3,4(r2)
81138c4c:	e0bffc17 	ldw	r2,-16(fp)
81138c50:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
81138c54:	e0bffc17 	ldw	r2,-16(fp)
81138c58:	1000058d 	sth	zero,22(r2)
81138c5c:	e0bffb17 	ldw	r2,-20(fp)
81138c60:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c64:	e0bffe17 	ldw	r2,-8(fp)
81138c68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138c6c:	0005883a 	mov	r2,zero
}
81138c70:	e037883a 	mov	sp,fp
81138c74:	df000017 	ldw	fp,0(sp)
81138c78:	dec00104 	addi	sp,sp,4
81138c7c:	f800283a 	ret

81138c80 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81138c80:	defff304 	addi	sp,sp,-52
81138c84:	de00012e 	bgeu	sp,et,81138c8c <OSQPend+0xc>
81138c88:	003b68fa 	trap	3
81138c8c:	dfc00c15 	stw	ra,48(sp)
81138c90:	df000b15 	stw	fp,44(sp)
81138c94:	df000b04 	addi	fp,sp,44
81138c98:	e13ffd15 	stw	r4,-12(fp)
81138c9c:	2805883a 	mov	r2,r5
81138ca0:	e1bfff15 	stw	r6,-4(fp)
81138ca4:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138ca8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138cac:	e0bfff17 	ldw	r2,-4(fp)
81138cb0:	1000021e 	bne	r2,zero,81138cbc <OSQPend+0x3c>
        return ((void *)0);
81138cb4:	0005883a 	mov	r2,zero
81138cb8:	00009106 	br	81138f00 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81138cbc:	e0bffd17 	ldw	r2,-12(fp)
81138cc0:	1000051e 	bne	r2,zero,81138cd8 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138cc4:	e0bfff17 	ldw	r2,-4(fp)
81138cc8:	00c00104 	movi	r3,4
81138ccc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138cd0:	0005883a 	mov	r2,zero
81138cd4:	00008a06 	br	81138f00 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81138cd8:	e0bffd17 	ldw	r2,-12(fp)
81138cdc:	10800003 	ldbu	r2,0(r2)
81138ce0:	10803fcc 	andi	r2,r2,255
81138ce4:	108000a0 	cmpeqi	r2,r2,2
81138ce8:	1000051e 	bne	r2,zero,81138d00 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138cec:	e0bfff17 	ldw	r2,-4(fp)
81138cf0:	00c00044 	movi	r3,1
81138cf4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138cf8:	0005883a 	mov	r2,zero
81138cfc:	00008006 	br	81138f00 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81138d00:	d0a09b03 	ldbu	r2,-32148(gp)
81138d04:	10803fcc 	andi	r2,r2,255
81138d08:	10000526 	beq	r2,zero,81138d20 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
81138d0c:	e0bfff17 	ldw	r2,-4(fp)
81138d10:	00c00084 	movi	r3,2
81138d14:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138d18:	0005883a 	mov	r2,zero
81138d1c:	00007806 	br	81138f00 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81138d20:	d0a08903 	ldbu	r2,-32220(gp)
81138d24:	10803fcc 	andi	r2,r2,255
81138d28:	10000526 	beq	r2,zero,81138d40 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
81138d2c:	e0bfff17 	ldw	r2,-4(fp)
81138d30:	00c00344 	movi	r3,13
81138d34:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81138d38:	0005883a 	mov	r2,zero
81138d3c:	00007006 	br	81138f00 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d40:	0005303a 	rdctl	r2,status
81138d44:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d48:	e0fffc17 	ldw	r3,-16(fp)
81138d4c:	00bfff84 	movi	r2,-2
81138d50:	1884703a 	and	r2,r3,r2
81138d54:	1001703a 	wrctl	status,r2
  
  return context;
81138d58:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138d5c:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81138d60:	e0bffd17 	ldw	r2,-12(fp)
81138d64:	10800117 	ldw	r2,4(r2)
81138d68:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81138d6c:	e0bff817 	ldw	r2,-32(fp)
81138d70:	1080058b 	ldhu	r2,22(r2)
81138d74:	10bfffcc 	andi	r2,r2,65535
81138d78:	10001e26 	beq	r2,zero,81138df4 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81138d7c:	e0bff817 	ldw	r2,-32(fp)
81138d80:	10800417 	ldw	r2,16(r2)
81138d84:	11000104 	addi	r4,r2,4
81138d88:	e0fff817 	ldw	r3,-32(fp)
81138d8c:	19000415 	stw	r4,16(r3)
81138d90:	10800017 	ldw	r2,0(r2)
81138d94:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81138d98:	e0bff817 	ldw	r2,-32(fp)
81138d9c:	1080058b 	ldhu	r2,22(r2)
81138da0:	10bfffc4 	addi	r2,r2,-1
81138da4:	1007883a 	mov	r3,r2
81138da8:	e0bff817 	ldw	r2,-32(fp)
81138dac:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81138db0:	e0bff817 	ldw	r2,-32(fp)
81138db4:	10c00417 	ldw	r3,16(r2)
81138db8:	e0bff817 	ldw	r2,-32(fp)
81138dbc:	10800217 	ldw	r2,8(r2)
81138dc0:	1880041e 	bne	r3,r2,81138dd4 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
81138dc4:	e0bff817 	ldw	r2,-32(fp)
81138dc8:	10c00117 	ldw	r3,4(r2)
81138dcc:	e0bff817 	ldw	r2,-32(fp)
81138dd0:	10c00415 	stw	r3,16(r2)
81138dd4:	e0bff617 	ldw	r2,-40(fp)
81138dd8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138ddc:	e0bff717 	ldw	r2,-36(fp)
81138de0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81138de4:	e0bfff17 	ldw	r2,-4(fp)
81138de8:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
81138dec:	e0bff517 	ldw	r2,-44(fp)
81138df0:	00004306 	br	81138f00 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
81138df4:	d0a09c17 	ldw	r2,-32144(gp)
81138df8:	d0e09c17 	ldw	r3,-32144(gp)
81138dfc:	18c00c03 	ldbu	r3,48(r3)
81138e00:	18c00114 	ori	r3,r3,4
81138e04:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81138e08:	d0a09c17 	ldw	r2,-32144(gp)
81138e0c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81138e10:	d0a09c17 	ldw	r2,-32144(gp)
81138e14:	e0fffe0b 	ldhu	r3,-8(fp)
81138e18:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
81138e1c:	e13ffd17 	ldw	r4,-12(fp)
81138e20:	11343ac0 	call	811343ac <OS_EventTaskWait>
81138e24:	e0bff617 	ldw	r2,-40(fp)
81138e28:	e0bffb15 	stw	r2,-20(fp)
81138e2c:	e0bffb17 	ldw	r2,-20(fp)
81138e30:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81138e34:	1134cc80 	call	81134cc8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e38:	0005303a 	rdctl	r2,status
81138e3c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e40:	e0fff917 	ldw	r3,-28(fp)
81138e44:	00bfff84 	movi	r2,-2
81138e48:	1884703a 	and	r2,r3,r2
81138e4c:	1001703a 	wrctl	status,r2
  
  return context;
81138e50:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81138e54:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81138e58:	d0a09c17 	ldw	r2,-32144(gp)
81138e5c:	10800c43 	ldbu	r2,49(r2)
81138e60:	10803fcc 	andi	r2,r2,255
81138e64:	10000326 	beq	r2,zero,81138e74 <OSQPend+0x1f4>
81138e68:	108000a0 	cmpeqi	r2,r2,2
81138e6c:	1000071e 	bne	r2,zero,81138e8c <OSQPend+0x20c>
81138e70:	00000b06 	br	81138ea0 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81138e74:	d0a09c17 	ldw	r2,-32144(gp)
81138e78:	10800917 	ldw	r2,36(r2)
81138e7c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81138e80:	e0bfff17 	ldw	r2,-4(fp)
81138e84:	10000005 	stb	zero,0(r2)
             break;
81138e88:	00000e06 	br	81138ec4 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
81138e8c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81138e90:	e0bfff17 	ldw	r2,-4(fp)
81138e94:	00c00384 	movi	r3,14
81138e98:	10c00005 	stb	r3,0(r2)
             break;
81138e9c:	00000906 	br	81138ec4 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81138ea0:	d0a09c17 	ldw	r2,-32144(gp)
81138ea4:	e17ffd17 	ldw	r5,-12(fp)
81138ea8:	1009883a 	mov	r4,r2
81138eac:	113461c0 	call	8113461c <OS_EventTaskRemove>
             pmsg = (void *)0;
81138eb0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81138eb4:	e0bfff17 	ldw	r2,-4(fp)
81138eb8:	00c00284 	movi	r3,10
81138ebc:	10c00005 	stb	r3,0(r2)
             break;
81138ec0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81138ec4:	d0a09c17 	ldw	r2,-32144(gp)
81138ec8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81138ecc:	d0a09c17 	ldw	r2,-32144(gp)
81138ed0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81138ed4:	d0a09c17 	ldw	r2,-32144(gp)
81138ed8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81138edc:	d0a09c17 	ldw	r2,-32144(gp)
81138ee0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
81138ee4:	d0a09c17 	ldw	r2,-32144(gp)
81138ee8:	10000915 	stw	zero,36(r2)
81138eec:	e0bff617 	ldw	r2,-40(fp)
81138ef0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138ef4:	e0bffa17 	ldw	r2,-24(fp)
81138ef8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
81138efc:	e0bff517 	ldw	r2,-44(fp)
}
81138f00:	e037883a 	mov	sp,fp
81138f04:	dfc00117 	ldw	ra,4(sp)
81138f08:	df000017 	ldw	fp,0(sp)
81138f0c:	dec00204 	addi	sp,sp,8
81138f10:	f800283a 	ret

81138f14 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81138f14:	defff604 	addi	sp,sp,-40
81138f18:	de00012e 	bgeu	sp,et,81138f20 <OSQPendAbort+0xc>
81138f1c:	003b68fa 	trap	3
81138f20:	dfc00915 	stw	ra,36(sp)
81138f24:	df000815 	stw	fp,32(sp)
81138f28:	df000804 	addi	fp,sp,32
81138f2c:	e13ffd15 	stw	r4,-12(fp)
81138f30:	2805883a 	mov	r2,r5
81138f34:	e1bfff15 	stw	r6,-4(fp)
81138f38:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138f3c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138f40:	e0bfff17 	ldw	r2,-4(fp)
81138f44:	1000021e 	bne	r2,zero,81138f50 <OSQPendAbort+0x3c>
        return (0);
81138f48:	0005883a 	mov	r2,zero
81138f4c:	00004906 	br	81139074 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138f50:	e0bffd17 	ldw	r2,-12(fp)
81138f54:	1000051e 	bne	r2,zero,81138f6c <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138f58:	e0bfff17 	ldw	r2,-4(fp)
81138f5c:	00c00104 	movi	r3,4
81138f60:	10c00005 	stb	r3,0(r2)
        return (0);
81138f64:	0005883a 	mov	r2,zero
81138f68:	00004206 	br	81139074 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81138f6c:	e0bffd17 	ldw	r2,-12(fp)
81138f70:	10800003 	ldbu	r2,0(r2)
81138f74:	10803fcc 	andi	r2,r2,255
81138f78:	108000a0 	cmpeqi	r2,r2,2
81138f7c:	1000051e 	bne	r2,zero,81138f94 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138f80:	e0bfff17 	ldw	r2,-4(fp)
81138f84:	00c00044 	movi	r3,1
81138f88:	10c00005 	stb	r3,0(r2)
        return (0);
81138f8c:	0005883a 	mov	r2,zero
81138f90:	00003806 	br	81139074 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138f94:	0005303a 	rdctl	r2,status
81138f98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138f9c:	e0fffc17 	ldw	r3,-16(fp)
81138fa0:	00bfff84 	movi	r2,-2
81138fa4:	1884703a 	and	r2,r3,r2
81138fa8:	1001703a 	wrctl	status,r2
  
  return context;
81138fac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138fb0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
81138fb4:	e0bffd17 	ldw	r2,-12(fp)
81138fb8:	10800283 	ldbu	r2,10(r2)
81138fbc:	10803fcc 	andi	r2,r2,255
81138fc0:	10002526 	beq	r2,zero,81139058 <OSQPendAbort+0x144>
        nbr_tasks = 0;
81138fc4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81138fc8:	e0bffe03 	ldbu	r2,-8(fp)
81138fcc:	10800060 	cmpeqi	r2,r2,1
81138fd0:	10000e26 	beq	r2,zero,8113900c <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81138fd4:	00000806 	br	81138ff8 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81138fd8:	01c00084 	movi	r7,2
81138fdc:	01800104 	movi	r6,4
81138fe0:	000b883a 	mov	r5,zero
81138fe4:	e13ffd17 	ldw	r4,-12(fp)
81138fe8:	113420c0 	call	8113420c <OS_EventTaskRdy>
                     nbr_tasks++;
81138fec:	e0bff803 	ldbu	r2,-32(fp)
81138ff0:	10800044 	addi	r2,r2,1
81138ff4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81138ff8:	e0bffd17 	ldw	r2,-12(fp)
81138ffc:	10800283 	ldbu	r2,10(r2)
81139000:	10803fcc 	andi	r2,r2,255
81139004:	103ff41e 	bne	r2,zero,81138fd8 <__reset+0xfb118fd8>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81139008:	00000906 	br	81139030 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113900c:	01c00084 	movi	r7,2
81139010:	01800104 	movi	r6,4
81139014:	000b883a 	mov	r5,zero
81139018:	e13ffd17 	ldw	r4,-12(fp)
8113901c:	113420c0 	call	8113420c <OS_EventTaskRdy>
                 nbr_tasks++;
81139020:	e0bff803 	ldbu	r2,-32(fp)
81139024:	10800044 	addi	r2,r2,1
81139028:	e0bff805 	stb	r2,-32(fp)
                 break;
8113902c:	0001883a 	nop
81139030:	e0bff917 	ldw	r2,-28(fp)
81139034:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139038:	e0bffa17 	ldw	r2,-24(fp)
8113903c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
81139040:	1134cc80 	call	81134cc8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81139044:	e0bfff17 	ldw	r2,-4(fp)
81139048:	00c00384 	movi	r3,14
8113904c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81139050:	e0bff803 	ldbu	r2,-32(fp)
81139054:	00000706 	br	81139074 <OSQPendAbort+0x160>
81139058:	e0bff917 	ldw	r2,-28(fp)
8113905c:	e0bffb15 	stw	r2,-20(fp)
81139060:	e0bffb17 	ldw	r2,-20(fp)
81139064:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139068:	e0bfff17 	ldw	r2,-4(fp)
8113906c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81139070:	0005883a 	mov	r2,zero
}
81139074:	e037883a 	mov	sp,fp
81139078:	dfc00117 	ldw	ra,4(sp)
8113907c:	df000017 	ldw	fp,0(sp)
81139080:	dec00204 	addi	sp,sp,8
81139084:	f800283a 	ret

81139088 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
81139088:	defff604 	addi	sp,sp,-40
8113908c:	de00012e 	bgeu	sp,et,81139094 <OSQPost+0xc>
81139090:	003b68fa 	trap	3
81139094:	dfc00915 	stw	ra,36(sp)
81139098:	df000815 	stw	fp,32(sp)
8113909c:	df000804 	addi	fp,sp,32
811390a0:	e13ffe15 	stw	r4,-8(fp)
811390a4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811390a8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
811390ac:	e0bffe17 	ldw	r2,-8(fp)
811390b0:	1000021e 	bne	r2,zero,811390bc <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
811390b4:	00800104 	movi	r2,4
811390b8:	00004a06 	br	811391e4 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
811390bc:	e0bffe17 	ldw	r2,-8(fp)
811390c0:	10800003 	ldbu	r2,0(r2)
811390c4:	10803fcc 	andi	r2,r2,255
811390c8:	108000a0 	cmpeqi	r2,r2,2
811390cc:	1000021e 	bne	r2,zero,811390d8 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
811390d0:	00800044 	movi	r2,1
811390d4:	00004306 	br	811391e4 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811390d8:	0005303a 	rdctl	r2,status
811390dc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811390e0:	e0fffd17 	ldw	r3,-12(fp)
811390e4:	00bfff84 	movi	r2,-2
811390e8:	1884703a 	and	r2,r3,r2
811390ec:	1001703a 	wrctl	status,r2
  
  return context;
811390f0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811390f4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
811390f8:	e0bffe17 	ldw	r2,-8(fp)
811390fc:	10800283 	ldbu	r2,10(r2)
81139100:	10803fcc 	andi	r2,r2,255
81139104:	10000c26 	beq	r2,zero,81139138 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139108:	000f883a 	mov	r7,zero
8113910c:	01800104 	movi	r6,4
81139110:	e17fff17 	ldw	r5,-4(fp)
81139114:	e13ffe17 	ldw	r4,-8(fp)
81139118:	113420c0 	call	8113420c <OS_EventTaskRdy>
8113911c:	e0bff817 	ldw	r2,-32(fp)
81139120:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139124:	e0bff917 	ldw	r2,-28(fp)
81139128:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113912c:	1134cc80 	call	81134cc8 <OS_Sched>
        return (OS_ERR_NONE);
81139130:	0005883a 	mov	r2,zero
81139134:	00002b06 	br	811391e4 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
81139138:	e0bffe17 	ldw	r2,-8(fp)
8113913c:	10800117 	ldw	r2,4(r2)
81139140:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
81139144:	e0bffb17 	ldw	r2,-20(fp)
81139148:	10c0058b 	ldhu	r3,22(r2)
8113914c:	e0bffb17 	ldw	r2,-20(fp)
81139150:	1080050b 	ldhu	r2,20(r2)
81139154:	18ffffcc 	andi	r3,r3,65535
81139158:	10bfffcc 	andi	r2,r2,65535
8113915c:	18800636 	bltu	r3,r2,81139178 <OSQPost+0xf0>
81139160:	e0bff817 	ldw	r2,-32(fp)
81139164:	e0bffa15 	stw	r2,-24(fp)
81139168:	e0bffa17 	ldw	r2,-24(fp)
8113916c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81139170:	00800784 	movi	r2,30
81139174:	00001b06 	br	811391e4 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
81139178:	e0bffb17 	ldw	r2,-20(fp)
8113917c:	10800317 	ldw	r2,12(r2)
81139180:	11000104 	addi	r4,r2,4
81139184:	e0fffb17 	ldw	r3,-20(fp)
81139188:	19000315 	stw	r4,12(r3)
8113918c:	e0ffff17 	ldw	r3,-4(fp)
81139190:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81139194:	e0bffb17 	ldw	r2,-20(fp)
81139198:	1080058b 	ldhu	r2,22(r2)
8113919c:	10800044 	addi	r2,r2,1
811391a0:	1007883a 	mov	r3,r2
811391a4:	e0bffb17 	ldw	r2,-20(fp)
811391a8:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
811391ac:	e0bffb17 	ldw	r2,-20(fp)
811391b0:	10c00317 	ldw	r3,12(r2)
811391b4:	e0bffb17 	ldw	r2,-20(fp)
811391b8:	10800217 	ldw	r2,8(r2)
811391bc:	1880041e 	bne	r3,r2,811391d0 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
811391c0:	e0bffb17 	ldw	r2,-20(fp)
811391c4:	10c00117 	ldw	r3,4(r2)
811391c8:	e0bffb17 	ldw	r2,-20(fp)
811391cc:	10c00315 	stw	r3,12(r2)
811391d0:	e0bff817 	ldw	r2,-32(fp)
811391d4:	e0bffc15 	stw	r2,-16(fp)
811391d8:	e0bffc17 	ldw	r2,-16(fp)
811391dc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811391e0:	0005883a 	mov	r2,zero
}
811391e4:	e037883a 	mov	sp,fp
811391e8:	dfc00117 	ldw	ra,4(sp)
811391ec:	df000017 	ldw	fp,0(sp)
811391f0:	dec00204 	addi	sp,sp,8
811391f4:	f800283a 	ret

811391f8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
811391f8:	defff604 	addi	sp,sp,-40
811391fc:	de00012e 	bgeu	sp,et,81139204 <OSQPostFront+0xc>
81139200:	003b68fa 	trap	3
81139204:	dfc00915 	stw	ra,36(sp)
81139208:	df000815 	stw	fp,32(sp)
8113920c:	df000804 	addi	fp,sp,32
81139210:	e13ffe15 	stw	r4,-8(fp)
81139214:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139218:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113921c:	e0bffe17 	ldw	r2,-8(fp)
81139220:	1000021e 	bne	r2,zero,8113922c <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
81139224:	00800104 	movi	r2,4
81139228:	00004c06 	br	8113935c <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113922c:	e0bffe17 	ldw	r2,-8(fp)
81139230:	10800003 	ldbu	r2,0(r2)
81139234:	10803fcc 	andi	r2,r2,255
81139238:	108000a0 	cmpeqi	r2,r2,2
8113923c:	1000021e 	bne	r2,zero,81139248 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
81139240:	00800044 	movi	r2,1
81139244:	00004506 	br	8113935c <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139248:	0005303a 	rdctl	r2,status
8113924c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139250:	e0fffd17 	ldw	r3,-12(fp)
81139254:	00bfff84 	movi	r2,-2
81139258:	1884703a 	and	r2,r3,r2
8113925c:	1001703a 	wrctl	status,r2
  
  return context;
81139260:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139264:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
81139268:	e0bffe17 	ldw	r2,-8(fp)
8113926c:	10800283 	ldbu	r2,10(r2)
81139270:	10803fcc 	andi	r2,r2,255
81139274:	10000c26 	beq	r2,zero,811392a8 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139278:	000f883a 	mov	r7,zero
8113927c:	01800104 	movi	r6,4
81139280:	e17fff17 	ldw	r5,-4(fp)
81139284:	e13ffe17 	ldw	r4,-8(fp)
81139288:	113420c0 	call	8113420c <OS_EventTaskRdy>
8113928c:	e0bff817 	ldw	r2,-32(fp)
81139290:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139294:	e0bff917 	ldw	r2,-28(fp)
81139298:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113929c:	1134cc80 	call	81134cc8 <OS_Sched>
        return (OS_ERR_NONE);
811392a0:	0005883a 	mov	r2,zero
811392a4:	00002d06 	br	8113935c <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
811392a8:	e0bffe17 	ldw	r2,-8(fp)
811392ac:	10800117 	ldw	r2,4(r2)
811392b0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
811392b4:	e0bffb17 	ldw	r2,-20(fp)
811392b8:	10c0058b 	ldhu	r3,22(r2)
811392bc:	e0bffb17 	ldw	r2,-20(fp)
811392c0:	1080050b 	ldhu	r2,20(r2)
811392c4:	18ffffcc 	andi	r3,r3,65535
811392c8:	10bfffcc 	andi	r2,r2,65535
811392cc:	18800636 	bltu	r3,r2,811392e8 <OSQPostFront+0xf0>
811392d0:	e0bff817 	ldw	r2,-32(fp)
811392d4:	e0bffa15 	stw	r2,-24(fp)
811392d8:	e0bffa17 	ldw	r2,-24(fp)
811392dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
811392e0:	00800784 	movi	r2,30
811392e4:	00001d06 	br	8113935c <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
811392e8:	e0bffb17 	ldw	r2,-20(fp)
811392ec:	10c00417 	ldw	r3,16(r2)
811392f0:	e0bffb17 	ldw	r2,-20(fp)
811392f4:	10800117 	ldw	r2,4(r2)
811392f8:	1880041e 	bne	r3,r2,8113930c <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
811392fc:	e0bffb17 	ldw	r2,-20(fp)
81139300:	10c00217 	ldw	r3,8(r2)
81139304:	e0bffb17 	ldw	r2,-20(fp)
81139308:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113930c:	e0bffb17 	ldw	r2,-20(fp)
81139310:	10800417 	ldw	r2,16(r2)
81139314:	10ffff04 	addi	r3,r2,-4
81139318:	e0bffb17 	ldw	r2,-20(fp)
8113931c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
81139320:	e0bffb17 	ldw	r2,-20(fp)
81139324:	10800417 	ldw	r2,16(r2)
81139328:	e0ffff17 	ldw	r3,-4(fp)
8113932c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81139330:	e0bffb17 	ldw	r2,-20(fp)
81139334:	1080058b 	ldhu	r2,22(r2)
81139338:	10800044 	addi	r2,r2,1
8113933c:	1007883a 	mov	r3,r2
81139340:	e0bffb17 	ldw	r2,-20(fp)
81139344:	10c0058d 	sth	r3,22(r2)
81139348:	e0bff817 	ldw	r2,-32(fp)
8113934c:	e0bffc15 	stw	r2,-16(fp)
81139350:	e0bffc17 	ldw	r2,-16(fp)
81139354:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139358:	0005883a 	mov	r2,zero
}
8113935c:	e037883a 	mov	sp,fp
81139360:	dfc00117 	ldw	ra,4(sp)
81139364:	df000017 	ldw	fp,0(sp)
81139368:	dec00204 	addi	sp,sp,8
8113936c:	f800283a 	ret

81139370 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
81139370:	defff504 	addi	sp,sp,-44
81139374:	de00012e 	bgeu	sp,et,8113937c <OSQPostOpt+0xc>
81139378:	003b68fa 	trap	3
8113937c:	dfc00a15 	stw	ra,40(sp)
81139380:	df000915 	stw	fp,36(sp)
81139384:	df000904 	addi	fp,sp,36
81139388:	e13ffd15 	stw	r4,-12(fp)
8113938c:	e17ffe15 	stw	r5,-8(fp)
81139390:	3005883a 	mov	r2,r6
81139394:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139398:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113939c:	e0bffd17 	ldw	r2,-12(fp)
811393a0:	1000021e 	bne	r2,zero,811393ac <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
811393a4:	00800104 	movi	r2,4
811393a8:	00007106 	br	81139570 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811393ac:	e0bffd17 	ldw	r2,-12(fp)
811393b0:	10800003 	ldbu	r2,0(r2)
811393b4:	10803fcc 	andi	r2,r2,255
811393b8:	108000a0 	cmpeqi	r2,r2,2
811393bc:	1000021e 	bne	r2,zero,811393c8 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
811393c0:	00800044 	movi	r2,1
811393c4:	00006a06 	br	81139570 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811393c8:	0005303a 	rdctl	r2,status
811393cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811393d0:	e0fffc17 	ldw	r3,-16(fp)
811393d4:	00bfff84 	movi	r2,-2
811393d8:	1884703a 	and	r2,r3,r2
811393dc:	1001703a 	wrctl	status,r2
  
  return context;
811393e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811393e4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
811393e8:	e0bffd17 	ldw	r2,-12(fp)
811393ec:	10800283 	ldbu	r2,10(r2)
811393f0:	10803fcc 	andi	r2,r2,255
811393f4:	10001d26 	beq	r2,zero,8113946c <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
811393f8:	e0bfff03 	ldbu	r2,-4(fp)
811393fc:	1080004c 	andi	r2,r2,1
81139400:	10000b26 	beq	r2,zero,81139430 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81139404:	00000506 	br	8113941c <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139408:	000f883a 	mov	r7,zero
8113940c:	01800104 	movi	r6,4
81139410:	e17ffe17 	ldw	r5,-8(fp)
81139414:	e13ffd17 	ldw	r4,-12(fp)
81139418:	113420c0 	call	8113420c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113941c:	e0bffd17 	ldw	r2,-12(fp)
81139420:	10800283 	ldbu	r2,10(r2)
81139424:	10803fcc 	andi	r2,r2,255
81139428:	103ff71e 	bne	r2,zero,81139408 <__reset+0xfb119408>
8113942c:	00000506 	br	81139444 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81139430:	000f883a 	mov	r7,zero
81139434:	01800104 	movi	r6,4
81139438:	e17ffe17 	ldw	r5,-8(fp)
8113943c:	e13ffd17 	ldw	r4,-12(fp)
81139440:	113420c0 	call	8113420c <OS_EventTaskRdy>
81139444:	e0bff717 	ldw	r2,-36(fp)
81139448:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113944c:	e0bff817 	ldw	r2,-32(fp)
81139450:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
81139454:	e0bfff03 	ldbu	r2,-4(fp)
81139458:	1080010c 	andi	r2,r2,4
8113945c:	1000011e 	bne	r2,zero,81139464 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81139460:	1134cc80 	call	81134cc8 <OS_Sched>
        }
        return (OS_ERR_NONE);
81139464:	0005883a 	mov	r2,zero
81139468:	00004106 	br	81139570 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113946c:	e0bffd17 	ldw	r2,-12(fp)
81139470:	10800117 	ldw	r2,4(r2)
81139474:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81139478:	e0bffa17 	ldw	r2,-24(fp)
8113947c:	10c0058b 	ldhu	r3,22(r2)
81139480:	e0bffa17 	ldw	r2,-24(fp)
81139484:	1080050b 	ldhu	r2,20(r2)
81139488:	18ffffcc 	andi	r3,r3,65535
8113948c:	10bfffcc 	andi	r2,r2,65535
81139490:	18800636 	bltu	r3,r2,811394ac <OSQPostOpt+0x13c>
81139494:	e0bff717 	ldw	r2,-36(fp)
81139498:	e0bff915 	stw	r2,-28(fp)
8113949c:	e0bff917 	ldw	r2,-28(fp)
811394a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
811394a4:	00800784 	movi	r2,30
811394a8:	00003106 	br	81139570 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
811394ac:	e0bfff03 	ldbu	r2,-4(fp)
811394b0:	1080008c 	andi	r2,r2,2
811394b4:	10001326 	beq	r2,zero,81139504 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
811394b8:	e0bffa17 	ldw	r2,-24(fp)
811394bc:	10c00417 	ldw	r3,16(r2)
811394c0:	e0bffa17 	ldw	r2,-24(fp)
811394c4:	10800117 	ldw	r2,4(r2)
811394c8:	1880041e 	bne	r3,r2,811394dc <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
811394cc:	e0bffa17 	ldw	r2,-24(fp)
811394d0:	10c00217 	ldw	r3,8(r2)
811394d4:	e0bffa17 	ldw	r2,-24(fp)
811394d8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
811394dc:	e0bffa17 	ldw	r2,-24(fp)
811394e0:	10800417 	ldw	r2,16(r2)
811394e4:	10ffff04 	addi	r3,r2,-4
811394e8:	e0bffa17 	ldw	r2,-24(fp)
811394ec:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
811394f0:	e0bffa17 	ldw	r2,-24(fp)
811394f4:	10800417 	ldw	r2,16(r2)
811394f8:	e0fffe17 	ldw	r3,-8(fp)
811394fc:	10c00015 	stw	r3,0(r2)
81139500:	00001006 	br	81139544 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
81139504:	e0bffa17 	ldw	r2,-24(fp)
81139508:	10800317 	ldw	r2,12(r2)
8113950c:	11000104 	addi	r4,r2,4
81139510:	e0fffa17 	ldw	r3,-24(fp)
81139514:	19000315 	stw	r4,12(r3)
81139518:	e0fffe17 	ldw	r3,-8(fp)
8113951c:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
81139520:	e0bffa17 	ldw	r2,-24(fp)
81139524:	10c00317 	ldw	r3,12(r2)
81139528:	e0bffa17 	ldw	r2,-24(fp)
8113952c:	10800217 	ldw	r2,8(r2)
81139530:	1880041e 	bne	r3,r2,81139544 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
81139534:	e0bffa17 	ldw	r2,-24(fp)
81139538:	10c00117 	ldw	r3,4(r2)
8113953c:	e0bffa17 	ldw	r2,-24(fp)
81139540:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81139544:	e0bffa17 	ldw	r2,-24(fp)
81139548:	1080058b 	ldhu	r2,22(r2)
8113954c:	10800044 	addi	r2,r2,1
81139550:	1007883a 	mov	r3,r2
81139554:	e0bffa17 	ldw	r2,-24(fp)
81139558:	10c0058d 	sth	r3,22(r2)
8113955c:	e0bff717 	ldw	r2,-36(fp)
81139560:	e0bffb15 	stw	r2,-20(fp)
81139564:	e0bffb17 	ldw	r2,-20(fp)
81139568:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113956c:	0005883a 	mov	r2,zero
}
81139570:	e037883a 	mov	sp,fp
81139574:	dfc00117 	ldw	ra,4(sp)
81139578:	df000017 	ldw	fp,0(sp)
8113957c:	dec00204 	addi	sp,sp,8
81139580:	f800283a 	ret

81139584 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81139584:	defff604 	addi	sp,sp,-40
81139588:	de00012e 	bgeu	sp,et,81139590 <OSQQuery+0xc>
8113958c:	003b68fa 	trap	3
81139590:	df000915 	stw	fp,36(sp)
81139594:	df000904 	addi	fp,sp,36
81139598:	e13ffe15 	stw	r4,-8(fp)
8113959c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811395a0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
811395a4:	e0bffe17 	ldw	r2,-8(fp)
811395a8:	1000021e 	bne	r2,zero,811395b4 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
811395ac:	00800104 	movi	r2,4
811395b0:	00004906 	br	811396d8 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
811395b4:	e0bfff17 	ldw	r2,-4(fp)
811395b8:	1000021e 	bne	r2,zero,811395c4 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
811395bc:	00800244 	movi	r2,9
811395c0:	00004506 	br	811396d8 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
811395c4:	e0bffe17 	ldw	r2,-8(fp)
811395c8:	10800003 	ldbu	r2,0(r2)
811395cc:	10803fcc 	andi	r2,r2,255
811395d0:	108000a0 	cmpeqi	r2,r2,2
811395d4:	1000021e 	bne	r2,zero,811395e0 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
811395d8:	00800044 	movi	r2,1
811395dc:	00003e06 	br	811396d8 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811395e0:	0005303a 	rdctl	r2,status
811395e4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811395e8:	e0fffd17 	ldw	r3,-12(fp)
811395ec:	00bfff84 	movi	r2,-2
811395f0:	1884703a 	and	r2,r3,r2
811395f4:	1001703a 	wrctl	status,r2
  
  return context;
811395f8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811395fc:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
81139600:	e0bffe17 	ldw	r2,-8(fp)
81139604:	10c00283 	ldbu	r3,10(r2)
81139608:	e0bfff17 	ldw	r2,-4(fp)
8113960c:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
81139610:	e0bffe17 	ldw	r2,-8(fp)
81139614:	108002c4 	addi	r2,r2,11
81139618:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113961c:	e0bfff17 	ldw	r2,-4(fp)
81139620:	10800204 	addi	r2,r2,8
81139624:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139628:	e03ff705 	stb	zero,-36(fp)
8113962c:	00000b06 	br	8113965c <OSQQuery+0xd8>
        *pdest++ = *psrc++;
81139630:	e0bff917 	ldw	r2,-28(fp)
81139634:	10c00044 	addi	r3,r2,1
81139638:	e0fff915 	stw	r3,-28(fp)
8113963c:	e0fff817 	ldw	r3,-32(fp)
81139640:	19000044 	addi	r4,r3,1
81139644:	e13ff815 	stw	r4,-32(fp)
81139648:	18c00003 	ldbu	r3,0(r3)
8113964c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81139650:	e0bff703 	ldbu	r2,-36(fp)
81139654:	10800044 	addi	r2,r2,1
81139658:	e0bff705 	stb	r2,-36(fp)
8113965c:	e0bff703 	ldbu	r2,-36(fp)
81139660:	108001b0 	cmpltui	r2,r2,6
81139664:	103ff21e 	bne	r2,zero,81139630 <__reset+0xfb119630>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
81139668:	e0bffe17 	ldw	r2,-8(fp)
8113966c:	10800117 	ldw	r2,4(r2)
81139670:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81139674:	e0bffc17 	ldw	r2,-16(fp)
81139678:	1080058b 	ldhu	r2,22(r2)
8113967c:	10bfffcc 	andi	r2,r2,65535
81139680:	10000626 	beq	r2,zero,8113969c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81139684:	e0bffc17 	ldw	r2,-16(fp)
81139688:	10800417 	ldw	r2,16(r2)
8113968c:	10c00017 	ldw	r3,0(r2)
81139690:	e0bfff17 	ldw	r2,-4(fp)
81139694:	10c00015 	stw	r3,0(r2)
81139698:	00000206 	br	811396a4 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113969c:	e0bfff17 	ldw	r2,-4(fp)
811396a0:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
811396a4:	e0bffc17 	ldw	r2,-16(fp)
811396a8:	10c0058b 	ldhu	r3,22(r2)
811396ac:	e0bfff17 	ldw	r2,-4(fp)
811396b0:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
811396b4:	e0bffc17 	ldw	r2,-16(fp)
811396b8:	10c0050b 	ldhu	r3,20(r2)
811396bc:	e0bfff17 	ldw	r2,-4(fp)
811396c0:	10c0018d 	sth	r3,6(r2)
811396c4:	e0bffa17 	ldw	r2,-24(fp)
811396c8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396cc:	e0bffb17 	ldw	r2,-20(fp)
811396d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811396d4:	0005883a 	mov	r2,zero
}
811396d8:	e037883a 	mov	sp,fp
811396dc:	df000017 	ldw	fp,0(sp)
811396e0:	dec00104 	addi	sp,sp,4
811396e4:	f800283a 	ret

811396e8 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
811396e8:	defffb04 	addi	sp,sp,-20
811396ec:	de00012e 	bgeu	sp,et,811396f4 <OS_QInit+0xc>
811396f0:	003b68fa 	trap	3
811396f4:	dfc00415 	stw	ra,16(sp)
811396f8:	df000315 	stw	fp,12(sp)
811396fc:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
81139700:	0140c004 	movi	r5,768
81139704:	012045b4 	movhi	r4,33046
81139708:	210c9504 	addi	r4,r4,12884
8113970c:	1134bfc0 	call	81134bfc <OS_MemClr>
    pq1 = &OSQTbl[0];
81139710:	00a045b4 	movhi	r2,33046
81139714:	108c9504 	addi	r2,r2,12884
81139718:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113971c:	00a045b4 	movhi	r2,33046
81139720:	108c9b04 	addi	r2,r2,12908
81139724:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81139728:	e03ffd0d 	sth	zero,-12(fp)
8113972c:	00000c06 	br	81139760 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
81139730:	e0bffe17 	ldw	r2,-8(fp)
81139734:	e0ffff17 	ldw	r3,-4(fp)
81139738:	10c00015 	stw	r3,0(r2)
        pq1++;
8113973c:	e0bffe17 	ldw	r2,-8(fp)
81139740:	10800604 	addi	r2,r2,24
81139744:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
81139748:	e0bfff17 	ldw	r2,-4(fp)
8113974c:	10800604 	addi	r2,r2,24
81139750:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81139754:	e0bffd0b 	ldhu	r2,-12(fp)
81139758:	10800044 	addi	r2,r2,1
8113975c:	e0bffd0d 	sth	r2,-12(fp)
81139760:	e0bffd0b 	ldhu	r2,-12(fp)
81139764:	108007f0 	cmpltui	r2,r2,31
81139768:	103ff11e 	bne	r2,zero,81139730 <__reset+0xfb119730>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113976c:	e0bffe17 	ldw	r2,-8(fp)
81139770:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81139774:	00a045b4 	movhi	r2,33046
81139778:	108c9504 	addi	r2,r2,12884
8113977c:	d0a09715 	stw	r2,-32164(gp)
#endif
}
81139780:	0001883a 	nop
81139784:	e037883a 	mov	sp,fp
81139788:	dfc00117 	ldw	ra,4(sp)
8113978c:	df000017 	ldw	fp,0(sp)
81139790:	dec00204 	addi	sp,sp,8
81139794:	f800283a 	ret

81139798 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
81139798:	defffa04 	addi	sp,sp,-24
8113979c:	de00012e 	bgeu	sp,et,811397a4 <OSSemAccept+0xc>
811397a0:	003b68fa 	trap	3
811397a4:	df000515 	stw	fp,20(sp)
811397a8:	df000504 	addi	fp,sp,20
811397ac:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811397b0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811397b4:	e0bfff17 	ldw	r2,-4(fp)
811397b8:	1000021e 	bne	r2,zero,811397c4 <OSSemAccept+0x2c>
        return (0);
811397bc:	0005883a 	mov	r2,zero
811397c0:	00001f06 	br	81139840 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811397c4:	e0bfff17 	ldw	r2,-4(fp)
811397c8:	10800003 	ldbu	r2,0(r2)
811397cc:	10803fcc 	andi	r2,r2,255
811397d0:	108000e0 	cmpeqi	r2,r2,3
811397d4:	1000021e 	bne	r2,zero,811397e0 <OSSemAccept+0x48>
        return (0);
811397d8:	0005883a 	mov	r2,zero
811397dc:	00001806 	br	81139840 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811397e0:	0005303a 	rdctl	r2,status
811397e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811397e8:	e0fffe17 	ldw	r3,-8(fp)
811397ec:	00bfff84 	movi	r2,-2
811397f0:	1884703a 	and	r2,r3,r2
811397f4:	1001703a 	wrctl	status,r2
  
  return context;
811397f8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811397fc:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
81139800:	e0bfff17 	ldw	r2,-4(fp)
81139804:	1080020b 	ldhu	r2,8(r2)
81139808:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113980c:	e0bffd0b 	ldhu	r2,-12(fp)
81139810:	10000626 	beq	r2,zero,8113982c <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
81139814:	e0bfff17 	ldw	r2,-4(fp)
81139818:	1080020b 	ldhu	r2,8(r2)
8113981c:	10bfffc4 	addi	r2,r2,-1
81139820:	1007883a 	mov	r3,r2
81139824:	e0bfff17 	ldw	r2,-4(fp)
81139828:	10c0020d 	sth	r3,8(r2)
8113982c:	e0bffb17 	ldw	r2,-20(fp)
81139830:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139834:	e0bffc17 	ldw	r2,-16(fp)
81139838:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113983c:	e0bffd0b 	ldhu	r2,-12(fp)
}
81139840:	e037883a 	mov	sp,fp
81139844:	df000017 	ldw	fp,0(sp)
81139848:	dec00104 	addi	sp,sp,4
8113984c:	f800283a 	ret

81139850 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81139850:	defff904 	addi	sp,sp,-28
81139854:	de00012e 	bgeu	sp,et,8113985c <OSSemCreate+0xc>
81139858:	003b68fa 	trap	3
8113985c:	dfc00615 	stw	ra,24(sp)
81139860:	df000515 	stw	fp,20(sp)
81139864:	df000504 	addi	fp,sp,20
81139868:	2005883a 	mov	r2,r4
8113986c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139870:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139874:	d0a09b03 	ldbu	r2,-32148(gp)
81139878:	10803fcc 	andi	r2,r2,255
8113987c:	10000226 	beq	r2,zero,81139888 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81139880:	0005883a 	mov	r2,zero
81139884:	00002506 	br	8113991c <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139888:	0005303a 	rdctl	r2,status
8113988c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139890:	e0fffe17 	ldw	r3,-8(fp)
81139894:	00bfff84 	movi	r2,-2
81139898:	1884703a 	and	r2,r3,r2
8113989c:	1001703a 	wrctl	status,r2
  
  return context;
811398a0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811398a4:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
811398a8:	d0a09a17 	ldw	r2,-32152(gp)
811398ac:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
811398b0:	d0a09a17 	ldw	r2,-32152(gp)
811398b4:	10000326 	beq	r2,zero,811398c4 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811398b8:	d0a09a17 	ldw	r2,-32152(gp)
811398bc:	10800117 	ldw	r2,4(r2)
811398c0:	d0a09a15 	stw	r2,-32152(gp)
811398c4:	e0bffb17 	ldw	r2,-20(fp)
811398c8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811398cc:	e0bffc17 	ldw	r2,-16(fp)
811398d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
811398d4:	e0bffd17 	ldw	r2,-12(fp)
811398d8:	10000f26 	beq	r2,zero,81139918 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
811398dc:	e0bffd17 	ldw	r2,-12(fp)
811398e0:	00c000c4 	movi	r3,3
811398e4:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
811398e8:	e0bffd17 	ldw	r2,-12(fp)
811398ec:	e0ffff0b 	ldhu	r3,-4(fp)
811398f0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
811398f4:	e0bffd17 	ldw	r2,-12(fp)
811398f8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
811398fc:	e0bffd17 	ldw	r2,-12(fp)
81139900:	00c00fc4 	movi	r3,63
81139904:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
81139908:	e0bffd17 	ldw	r2,-12(fp)
8113990c:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
81139910:	e13ffd17 	ldw	r4,-12(fp)
81139914:	11347e40 	call	811347e4 <OS_EventWaitListInit>
    }
    return (pevent);
81139918:	e0bffd17 	ldw	r2,-12(fp)
}
8113991c:	e037883a 	mov	sp,fp
81139920:	dfc00117 	ldw	ra,4(sp)
81139924:	df000017 	ldw	fp,0(sp)
81139928:	dec00204 	addi	sp,sp,8
8113992c:	f800283a 	ret

81139930 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139930:	defff304 	addi	sp,sp,-52
81139934:	de00012e 	bgeu	sp,et,8113993c <OSSemDel+0xc>
81139938:	003b68fa 	trap	3
8113993c:	dfc00c15 	stw	ra,48(sp)
81139940:	df000b15 	stw	fp,44(sp)
81139944:	df000b04 	addi	fp,sp,44
81139948:	e13ffd15 	stw	r4,-12(fp)
8113994c:	2805883a 	mov	r2,r5
81139950:	e1bfff15 	stw	r6,-4(fp)
81139954:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139958:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113995c:	e0bfff17 	ldw	r2,-4(fp)
81139960:	1000021e 	bne	r2,zero,8113996c <OSSemDel+0x3c>
        return (pevent);
81139964:	e0bffd17 	ldw	r2,-12(fp)
81139968:	00007e06 	br	81139b64 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113996c:	e0bffd17 	ldw	r2,-12(fp)
81139970:	1000051e 	bne	r2,zero,81139988 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139974:	e0bfff17 	ldw	r2,-4(fp)
81139978:	00c00104 	movi	r3,4
8113997c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139980:	e0bffd17 	ldw	r2,-12(fp)
81139984:	00007706 	br	81139b64 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81139988:	e0bffd17 	ldw	r2,-12(fp)
8113998c:	10800003 	ldbu	r2,0(r2)
81139990:	10803fcc 	andi	r2,r2,255
81139994:	108000e0 	cmpeqi	r2,r2,3
81139998:	1000051e 	bne	r2,zero,811399b0 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113999c:	e0bfff17 	ldw	r2,-4(fp)
811399a0:	00c00044 	movi	r3,1
811399a4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811399a8:	e0bffd17 	ldw	r2,-12(fp)
811399ac:	00006d06 	br	81139b64 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811399b0:	d0a09b03 	ldbu	r2,-32148(gp)
811399b4:	10803fcc 	andi	r2,r2,255
811399b8:	10000526 	beq	r2,zero,811399d0 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811399bc:	e0bfff17 	ldw	r2,-4(fp)
811399c0:	00c003c4 	movi	r3,15
811399c4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811399c8:	e0bffd17 	ldw	r2,-12(fp)
811399cc:	00006506 	br	81139b64 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811399d0:	0005303a 	rdctl	r2,status
811399d4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811399d8:	e0fffc17 	ldw	r3,-16(fp)
811399dc:	00bfff84 	movi	r2,-2
811399e0:	1884703a 	and	r2,r3,r2
811399e4:	1001703a 	wrctl	status,r2
  
  return context;
811399e8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811399ec:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
811399f0:	e0bffd17 	ldw	r2,-12(fp)
811399f4:	10800283 	ldbu	r2,10(r2)
811399f8:	10803fcc 	andi	r2,r2,255
811399fc:	10000326 	beq	r2,zero,81139a0c <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81139a00:	00800044 	movi	r2,1
81139a04:	e0bff505 	stb	r2,-44(fp)
81139a08:	00000106 	br	81139a10 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81139a0c:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
81139a10:	e0bffe03 	ldbu	r2,-8(fp)
81139a14:	10000326 	beq	r2,zero,81139a24 <OSSemDel+0xf4>
81139a18:	10800060 	cmpeqi	r2,r2,1
81139a1c:	1000281e 	bne	r2,zero,81139ac0 <OSSemDel+0x190>
81139a20:	00004506 	br	81139b38 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
81139a24:	e0bff503 	ldbu	r2,-44(fp)
81139a28:	1000161e 	bne	r2,zero,81139a84 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81139a2c:	e0bffd17 	ldw	r2,-12(fp)
81139a30:	00c00fc4 	movi	r3,63
81139a34:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81139a38:	e0bffd17 	ldw	r2,-12(fp)
81139a3c:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81139a40:	e0bffd17 	ldw	r2,-12(fp)
81139a44:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81139a48:	d0e09a17 	ldw	r3,-32152(gp)
81139a4c:	e0bffd17 	ldw	r2,-12(fp)
81139a50:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81139a54:	e0bffd17 	ldw	r2,-12(fp)
81139a58:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81139a5c:	e0bffd17 	ldw	r2,-12(fp)
81139a60:	d0a09a15 	stw	r2,-32152(gp)
81139a64:	e0bff717 	ldw	r2,-36(fp)
81139a68:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139a6c:	e0bff817 	ldw	r2,-32(fp)
81139a70:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81139a74:	e0bfff17 	ldw	r2,-4(fp)
81139a78:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81139a7c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81139a80:	00003706 	br	81139b60 <OSSemDel+0x230>
81139a84:	e0bff717 	ldw	r2,-36(fp)
81139a88:	e0bff915 	stw	r2,-28(fp)
81139a8c:	e0bff917 	ldw	r2,-28(fp)
81139a90:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81139a94:	e0bfff17 	ldw	r2,-4(fp)
81139a98:	00c01244 	movi	r3,73
81139a9c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81139aa0:	e0bffd17 	ldw	r2,-12(fp)
81139aa4:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81139aa8:	00002d06 	br	81139b60 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81139aac:	000f883a 	mov	r7,zero
81139ab0:	01800044 	movi	r6,1
81139ab4:	000b883a 	mov	r5,zero
81139ab8:	e13ffd17 	ldw	r4,-12(fp)
81139abc:	113420c0 	call	8113420c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
81139ac0:	e0bffd17 	ldw	r2,-12(fp)
81139ac4:	10800283 	ldbu	r2,10(r2)
81139ac8:	10803fcc 	andi	r2,r2,255
81139acc:	103ff71e 	bne	r2,zero,81139aac <__reset+0xfb119aac>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81139ad0:	e0bffd17 	ldw	r2,-12(fp)
81139ad4:	00c00fc4 	movi	r3,63
81139ad8:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81139adc:	e0bffd17 	ldw	r2,-12(fp)
81139ae0:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81139ae4:	e0bffd17 	ldw	r2,-12(fp)
81139ae8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81139aec:	d0e09a17 	ldw	r3,-32152(gp)
81139af0:	e0bffd17 	ldw	r2,-12(fp)
81139af4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81139af8:	e0bffd17 	ldw	r2,-12(fp)
81139afc:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81139b00:	e0bffd17 	ldw	r2,-12(fp)
81139b04:	d0a09a15 	stw	r2,-32152(gp)
81139b08:	e0bff717 	ldw	r2,-36(fp)
81139b0c:	e0bffa15 	stw	r2,-24(fp)
81139b10:	e0bffa17 	ldw	r2,-24(fp)
81139b14:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81139b18:	e0bff503 	ldbu	r2,-44(fp)
81139b1c:	10800058 	cmpnei	r2,r2,1
81139b20:	1000011e 	bne	r2,zero,81139b28 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81139b24:	1134cc80 	call	81134cc8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81139b28:	e0bfff17 	ldw	r2,-4(fp)
81139b2c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81139b30:	e03ff615 	stw	zero,-40(fp)
             break;
81139b34:	00000a06 	br	81139b60 <OSSemDel+0x230>
81139b38:	e0bff717 	ldw	r2,-36(fp)
81139b3c:	e0bffb15 	stw	r2,-20(fp)
81139b40:	e0bffb17 	ldw	r2,-20(fp)
81139b44:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81139b48:	e0bfff17 	ldw	r2,-4(fp)
81139b4c:	00c001c4 	movi	r3,7
81139b50:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81139b54:	e0bffd17 	ldw	r2,-12(fp)
81139b58:	e0bff615 	stw	r2,-40(fp)
             break;
81139b5c:	0001883a 	nop
    }
    return (pevent_return);
81139b60:	e0bff617 	ldw	r2,-40(fp)
}
81139b64:	e037883a 	mov	sp,fp
81139b68:	dfc00117 	ldw	ra,4(sp)
81139b6c:	df000017 	ldw	fp,0(sp)
81139b70:	dec00204 	addi	sp,sp,8
81139b74:	f800283a 	ret

81139b78 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81139b78:	defff504 	addi	sp,sp,-44
81139b7c:	de00012e 	bgeu	sp,et,81139b84 <OSSemPend+0xc>
81139b80:	003b68fa 	trap	3
81139b84:	dfc00a15 	stw	ra,40(sp)
81139b88:	df000915 	stw	fp,36(sp)
81139b8c:	df000904 	addi	fp,sp,36
81139b90:	e13ffd15 	stw	r4,-12(fp)
81139b94:	2805883a 	mov	r2,r5
81139b98:	e1bfff15 	stw	r6,-4(fp)
81139b9c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139ba0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81139ba4:	e0bfff17 	ldw	r2,-4(fp)
81139ba8:	10007226 	beq	r2,zero,81139d74 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139bac:	e0bffd17 	ldw	r2,-12(fp)
81139bb0:	1000041e 	bne	r2,zero,81139bc4 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81139bb4:	e0bfff17 	ldw	r2,-4(fp)
81139bb8:	00c00104 	movi	r3,4
81139bbc:	10c00005 	stb	r3,0(r2)
        return;
81139bc0:	00006d06 	br	81139d78 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81139bc4:	e0bffd17 	ldw	r2,-12(fp)
81139bc8:	10800003 	ldbu	r2,0(r2)
81139bcc:	10803fcc 	andi	r2,r2,255
81139bd0:	108000e0 	cmpeqi	r2,r2,3
81139bd4:	1000041e 	bne	r2,zero,81139be8 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81139bd8:	e0bfff17 	ldw	r2,-4(fp)
81139bdc:	00c00044 	movi	r3,1
81139be0:	10c00005 	stb	r3,0(r2)
        return;
81139be4:	00006406 	br	81139d78 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81139be8:	d0a09b03 	ldbu	r2,-32148(gp)
81139bec:	10803fcc 	andi	r2,r2,255
81139bf0:	10000426 	beq	r2,zero,81139c04 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
81139bf4:	e0bfff17 	ldw	r2,-4(fp)
81139bf8:	00c00084 	movi	r3,2
81139bfc:	10c00005 	stb	r3,0(r2)
        return;
81139c00:	00005d06 	br	81139d78 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
81139c04:	d0a08903 	ldbu	r2,-32220(gp)
81139c08:	10803fcc 	andi	r2,r2,255
81139c0c:	10000426 	beq	r2,zero,81139c20 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
81139c10:	e0bfff17 	ldw	r2,-4(fp)
81139c14:	00c00344 	movi	r3,13
81139c18:	10c00005 	stb	r3,0(r2)
        return;
81139c1c:	00005606 	br	81139d78 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c20:	0005303a 	rdctl	r2,status
81139c24:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c28:	e0fffc17 	ldw	r3,-16(fp)
81139c2c:	00bfff84 	movi	r2,-2
81139c30:	1884703a 	and	r2,r3,r2
81139c34:	1001703a 	wrctl	status,r2
  
  return context;
81139c38:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139c3c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81139c40:	e0bffd17 	ldw	r2,-12(fp)
81139c44:	1080020b 	ldhu	r2,8(r2)
81139c48:	10bfffcc 	andi	r2,r2,65535
81139c4c:	10000d26 	beq	r2,zero,81139c84 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81139c50:	e0bffd17 	ldw	r2,-12(fp)
81139c54:	1080020b 	ldhu	r2,8(r2)
81139c58:	10bfffc4 	addi	r2,r2,-1
81139c5c:	1007883a 	mov	r3,r2
81139c60:	e0bffd17 	ldw	r2,-12(fp)
81139c64:	10c0020d 	sth	r3,8(r2)
81139c68:	e0bff717 	ldw	r2,-36(fp)
81139c6c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139c70:	e0bff817 	ldw	r2,-32(fp)
81139c74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81139c78:	e0bfff17 	ldw	r2,-4(fp)
81139c7c:	10000005 	stb	zero,0(r2)
        return;
81139c80:	00003d06 	br	81139d78 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81139c84:	d0a09c17 	ldw	r2,-32144(gp)
81139c88:	d0e09c17 	ldw	r3,-32144(gp)
81139c8c:	18c00c03 	ldbu	r3,48(r3)
81139c90:	18c00054 	ori	r3,r3,1
81139c94:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139c98:	d0a09c17 	ldw	r2,-32144(gp)
81139c9c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81139ca0:	d0a09c17 	ldw	r2,-32144(gp)
81139ca4:	e0fffe0b 	ldhu	r3,-8(fp)
81139ca8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81139cac:	e13ffd17 	ldw	r4,-12(fp)
81139cb0:	11343ac0 	call	811343ac <OS_EventTaskWait>
81139cb4:	e0bff717 	ldw	r2,-36(fp)
81139cb8:	e0bffb15 	stw	r2,-20(fp)
81139cbc:	e0bffb17 	ldw	r2,-20(fp)
81139cc0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81139cc4:	1134cc80 	call	81134cc8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139cc8:	0005303a 	rdctl	r2,status
81139ccc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139cd0:	e0fff917 	ldw	r3,-28(fp)
81139cd4:	00bfff84 	movi	r2,-2
81139cd8:	1884703a 	and	r2,r3,r2
81139cdc:	1001703a 	wrctl	status,r2
  
  return context;
81139ce0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81139ce4:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81139ce8:	d0a09c17 	ldw	r2,-32144(gp)
81139cec:	10800c43 	ldbu	r2,49(r2)
81139cf0:	10803fcc 	andi	r2,r2,255
81139cf4:	10000326 	beq	r2,zero,81139d04 <OSSemPend+0x18c>
81139cf8:	108000a0 	cmpeqi	r2,r2,2
81139cfc:	1000041e 	bne	r2,zero,81139d10 <OSSemPend+0x198>
81139d00:	00000706 	br	81139d20 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81139d04:	e0bfff17 	ldw	r2,-4(fp)
81139d08:	10000005 	stb	zero,0(r2)
             break;
81139d0c:	00000c06 	br	81139d40 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81139d10:	e0bfff17 	ldw	r2,-4(fp)
81139d14:	00c00384 	movi	r3,14
81139d18:	10c00005 	stb	r3,0(r2)
             break;
81139d1c:	00000806 	br	81139d40 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81139d20:	d0a09c17 	ldw	r2,-32144(gp)
81139d24:	e17ffd17 	ldw	r5,-12(fp)
81139d28:	1009883a 	mov	r4,r2
81139d2c:	113461c0 	call	8113461c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81139d30:	e0bfff17 	ldw	r2,-4(fp)
81139d34:	00c00284 	movi	r3,10
81139d38:	10c00005 	stb	r3,0(r2)
             break;
81139d3c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81139d40:	d0a09c17 	ldw	r2,-32144(gp)
81139d44:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81139d48:	d0a09c17 	ldw	r2,-32144(gp)
81139d4c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81139d50:	d0a09c17 	ldw	r2,-32144(gp)
81139d54:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81139d58:	d0a09c17 	ldw	r2,-32144(gp)
81139d5c:	10000815 	stw	zero,32(r2)
81139d60:	e0bff717 	ldw	r2,-36(fp)
81139d64:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d68:	e0bffa17 	ldw	r2,-24(fp)
81139d6c:	1001703a 	wrctl	status,r2
81139d70:	00000106 	br	81139d78 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81139d74:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81139d78:	e037883a 	mov	sp,fp
81139d7c:	dfc00117 	ldw	ra,4(sp)
81139d80:	df000017 	ldw	fp,0(sp)
81139d84:	dec00204 	addi	sp,sp,8
81139d88:	f800283a 	ret

81139d8c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139d8c:	defff604 	addi	sp,sp,-40
81139d90:	de00012e 	bgeu	sp,et,81139d98 <OSSemPendAbort+0xc>
81139d94:	003b68fa 	trap	3
81139d98:	dfc00915 	stw	ra,36(sp)
81139d9c:	df000815 	stw	fp,32(sp)
81139da0:	df000804 	addi	fp,sp,32
81139da4:	e13ffd15 	stw	r4,-12(fp)
81139da8:	2805883a 	mov	r2,r5
81139dac:	e1bfff15 	stw	r6,-4(fp)
81139db0:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139db4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81139db8:	e0bfff17 	ldw	r2,-4(fp)
81139dbc:	1000021e 	bne	r2,zero,81139dc8 <OSSemPendAbort+0x3c>
        return (0);
81139dc0:	0005883a 	mov	r2,zero
81139dc4:	00004906 	br	81139eec <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139dc8:	e0bffd17 	ldw	r2,-12(fp)
81139dcc:	1000051e 	bne	r2,zero,81139de4 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139dd0:	e0bfff17 	ldw	r2,-4(fp)
81139dd4:	00c00104 	movi	r3,4
81139dd8:	10c00005 	stb	r3,0(r2)
        return (0);
81139ddc:	0005883a 	mov	r2,zero
81139de0:	00004206 	br	81139eec <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81139de4:	e0bffd17 	ldw	r2,-12(fp)
81139de8:	10800003 	ldbu	r2,0(r2)
81139dec:	10803fcc 	andi	r2,r2,255
81139df0:	108000e0 	cmpeqi	r2,r2,3
81139df4:	1000051e 	bne	r2,zero,81139e0c <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139df8:	e0bfff17 	ldw	r2,-4(fp)
81139dfc:	00c00044 	movi	r3,1
81139e00:	10c00005 	stb	r3,0(r2)
        return (0);
81139e04:	0005883a 	mov	r2,zero
81139e08:	00003806 	br	81139eec <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139e0c:	0005303a 	rdctl	r2,status
81139e10:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139e14:	e0fffc17 	ldw	r3,-16(fp)
81139e18:	00bfff84 	movi	r2,-2
81139e1c:	1884703a 	and	r2,r3,r2
81139e20:	1001703a 	wrctl	status,r2
  
  return context;
81139e24:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139e28:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81139e2c:	e0bffd17 	ldw	r2,-12(fp)
81139e30:	10800283 	ldbu	r2,10(r2)
81139e34:	10803fcc 	andi	r2,r2,255
81139e38:	10002526 	beq	r2,zero,81139ed0 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81139e3c:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81139e40:	e0bffe03 	ldbu	r2,-8(fp)
81139e44:	10800060 	cmpeqi	r2,r2,1
81139e48:	10000e26 	beq	r2,zero,81139e84 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81139e4c:	00000806 	br	81139e70 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81139e50:	01c00084 	movi	r7,2
81139e54:	01800044 	movi	r6,1
81139e58:	000b883a 	mov	r5,zero
81139e5c:	e13ffd17 	ldw	r4,-12(fp)
81139e60:	113420c0 	call	8113420c <OS_EventTaskRdy>
                     nbr_tasks++;
81139e64:	e0bff803 	ldbu	r2,-32(fp)
81139e68:	10800044 	addi	r2,r2,1
81139e6c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81139e70:	e0bffd17 	ldw	r2,-12(fp)
81139e74:	10800283 	ldbu	r2,10(r2)
81139e78:	10803fcc 	andi	r2,r2,255
81139e7c:	103ff41e 	bne	r2,zero,81139e50 <__reset+0xfb119e50>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81139e80:	00000906 	br	81139ea8 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81139e84:	01c00084 	movi	r7,2
81139e88:	01800044 	movi	r6,1
81139e8c:	000b883a 	mov	r5,zero
81139e90:	e13ffd17 	ldw	r4,-12(fp)
81139e94:	113420c0 	call	8113420c <OS_EventTaskRdy>
                 nbr_tasks++;
81139e98:	e0bff803 	ldbu	r2,-32(fp)
81139e9c:	10800044 	addi	r2,r2,1
81139ea0:	e0bff805 	stb	r2,-32(fp)
                 break;
81139ea4:	0001883a 	nop
81139ea8:	e0bff917 	ldw	r2,-28(fp)
81139eac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139eb0:	e0bffa17 	ldw	r2,-24(fp)
81139eb4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81139eb8:	1134cc80 	call	81134cc8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81139ebc:	e0bfff17 	ldw	r2,-4(fp)
81139ec0:	00c00384 	movi	r3,14
81139ec4:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81139ec8:	e0bff803 	ldbu	r2,-32(fp)
81139ecc:	00000706 	br	81139eec <OSSemPendAbort+0x160>
81139ed0:	e0bff917 	ldw	r2,-28(fp)
81139ed4:	e0bffb15 	stw	r2,-20(fp)
81139ed8:	e0bffb17 	ldw	r2,-20(fp)
81139edc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139ee0:	e0bfff17 	ldw	r2,-4(fp)
81139ee4:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
81139ee8:	0005883a 	mov	r2,zero
}
81139eec:	e037883a 	mov	sp,fp
81139ef0:	dfc00117 	ldw	ra,4(sp)
81139ef4:	df000017 	ldw	fp,0(sp)
81139ef8:	dec00204 	addi	sp,sp,8
81139efc:	f800283a 	ret

81139f00 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81139f00:	defff804 	addi	sp,sp,-32
81139f04:	de00012e 	bgeu	sp,et,81139f0c <OSSemPost+0xc>
81139f08:	003b68fa 	trap	3
81139f0c:	dfc00715 	stw	ra,28(sp)
81139f10:	df000615 	stw	fp,24(sp)
81139f14:	df000604 	addi	fp,sp,24
81139f18:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139f1c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139f20:	e0bfff17 	ldw	r2,-4(fp)
81139f24:	1000021e 	bne	r2,zero,81139f30 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
81139f28:	00800104 	movi	r2,4
81139f2c:	00003506 	br	8113a004 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81139f30:	e0bfff17 	ldw	r2,-4(fp)
81139f34:	10800003 	ldbu	r2,0(r2)
81139f38:	10803fcc 	andi	r2,r2,255
81139f3c:	108000e0 	cmpeqi	r2,r2,3
81139f40:	1000021e 	bne	r2,zero,81139f4c <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81139f44:	00800044 	movi	r2,1
81139f48:	00002e06 	br	8113a004 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f4c:	0005303a 	rdctl	r2,status
81139f50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f54:	e0fffe17 	ldw	r3,-8(fp)
81139f58:	00bfff84 	movi	r2,-2
81139f5c:	1884703a 	and	r2,r3,r2
81139f60:	1001703a 	wrctl	status,r2
  
  return context;
81139f64:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81139f68:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81139f6c:	e0bfff17 	ldw	r2,-4(fp)
81139f70:	10800283 	ldbu	r2,10(r2)
81139f74:	10803fcc 	andi	r2,r2,255
81139f78:	10000c26 	beq	r2,zero,81139fac <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81139f7c:	000f883a 	mov	r7,zero
81139f80:	01800044 	movi	r6,1
81139f84:	000b883a 	mov	r5,zero
81139f88:	e13fff17 	ldw	r4,-4(fp)
81139f8c:	113420c0 	call	8113420c <OS_EventTaskRdy>
81139f90:	e0bffa17 	ldw	r2,-24(fp)
81139f94:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f98:	e0bffb17 	ldw	r2,-20(fp)
81139f9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81139fa0:	1134cc80 	call	81134cc8 <OS_Sched>
        return (OS_ERR_NONE);
81139fa4:	0005883a 	mov	r2,zero
81139fa8:	00001606 	br	8113a004 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81139fac:	e0bfff17 	ldw	r2,-4(fp)
81139fb0:	1080020b 	ldhu	r2,8(r2)
81139fb4:	10ffffcc 	andi	r3,r2,65535
81139fb8:	00bfffd4 	movui	r2,65535
81139fbc:	18800c26 	beq	r3,r2,81139ff0 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81139fc0:	e0bfff17 	ldw	r2,-4(fp)
81139fc4:	1080020b 	ldhu	r2,8(r2)
81139fc8:	10800044 	addi	r2,r2,1
81139fcc:	1007883a 	mov	r3,r2
81139fd0:	e0bfff17 	ldw	r2,-4(fp)
81139fd4:	10c0020d 	sth	r3,8(r2)
81139fd8:	e0bffa17 	ldw	r2,-24(fp)
81139fdc:	e0bffc15 	stw	r2,-16(fp)
81139fe0:	e0bffc17 	ldw	r2,-16(fp)
81139fe4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81139fe8:	0005883a 	mov	r2,zero
81139fec:	00000506 	br	8113a004 <OSSemPost+0x104>
81139ff0:	e0bffa17 	ldw	r2,-24(fp)
81139ff4:	e0bffd15 	stw	r2,-12(fp)
81139ff8:	e0bffd17 	ldw	r2,-12(fp)
81139ffc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113a000:	00800c84 	movi	r2,50
}
8113a004:	e037883a 	mov	sp,fp
8113a008:	dfc00117 	ldw	ra,4(sp)
8113a00c:	df000017 	ldw	fp,0(sp)
8113a010:	dec00204 	addi	sp,sp,8
8113a014:	f800283a 	ret

8113a018 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113a018:	defff704 	addi	sp,sp,-36
8113a01c:	de00012e 	bgeu	sp,et,8113a024 <OSSemQuery+0xc>
8113a020:	003b68fa 	trap	3
8113a024:	df000815 	stw	fp,32(sp)
8113a028:	df000804 	addi	fp,sp,32
8113a02c:	e13ffe15 	stw	r4,-8(fp)
8113a030:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a034:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113a038:	e0bffe17 	ldw	r2,-8(fp)
8113a03c:	1000021e 	bne	r2,zero,8113a048 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113a040:	00800104 	movi	r2,4
8113a044:	00003606 	br	8113a120 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113a048:	e0bfff17 	ldw	r2,-4(fp)
8113a04c:	1000021e 	bne	r2,zero,8113a058 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113a050:	00800244 	movi	r2,9
8113a054:	00003206 	br	8113a120 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113a058:	e0bffe17 	ldw	r2,-8(fp)
8113a05c:	10800003 	ldbu	r2,0(r2)
8113a060:	10803fcc 	andi	r2,r2,255
8113a064:	108000e0 	cmpeqi	r2,r2,3
8113a068:	1000021e 	bne	r2,zero,8113a074 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113a06c:	00800044 	movi	r2,1
8113a070:	00002b06 	br	8113a120 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a074:	0005303a 	rdctl	r2,status
8113a078:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a07c:	e0fffd17 	ldw	r3,-12(fp)
8113a080:	00bfff84 	movi	r2,-2
8113a084:	1884703a 	and	r2,r3,r2
8113a088:	1001703a 	wrctl	status,r2
  
  return context;
8113a08c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a090:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113a094:	e0bffe17 	ldw	r2,-8(fp)
8113a098:	10c00283 	ldbu	r3,10(r2)
8113a09c:	e0bfff17 	ldw	r2,-4(fp)
8113a0a0:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113a0a4:	e0bffe17 	ldw	r2,-8(fp)
8113a0a8:	108002c4 	addi	r2,r2,11
8113a0ac:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113a0b0:	e0bfff17 	ldw	r2,-4(fp)
8113a0b4:	10800084 	addi	r2,r2,2
8113a0b8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113a0bc:	e03ffa05 	stb	zero,-24(fp)
8113a0c0:	00000b06 	br	8113a0f0 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113a0c4:	e0bff917 	ldw	r2,-28(fp)
8113a0c8:	10c00044 	addi	r3,r2,1
8113a0cc:	e0fff915 	stw	r3,-28(fp)
8113a0d0:	e0fff817 	ldw	r3,-32(fp)
8113a0d4:	19000044 	addi	r4,r3,1
8113a0d8:	e13ff815 	stw	r4,-32(fp)
8113a0dc:	18c00003 	ldbu	r3,0(r3)
8113a0e0:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113a0e4:	e0bffa03 	ldbu	r2,-24(fp)
8113a0e8:	10800044 	addi	r2,r2,1
8113a0ec:	e0bffa05 	stb	r2,-24(fp)
8113a0f0:	e0bffa03 	ldbu	r2,-24(fp)
8113a0f4:	108001b0 	cmpltui	r2,r2,6
8113a0f8:	103ff21e 	bne	r2,zero,8113a0c4 <__reset+0xfb11a0c4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113a0fc:	e0bffe17 	ldw	r2,-8(fp)
8113a100:	10c0020b 	ldhu	r3,8(r2)
8113a104:	e0bfff17 	ldw	r2,-4(fp)
8113a108:	10c0000d 	sth	r3,0(r2)
8113a10c:	e0bffb17 	ldw	r2,-20(fp)
8113a110:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a114:	e0bffc17 	ldw	r2,-16(fp)
8113a118:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a11c:	0005883a 	mov	r2,zero
}
8113a120:	e037883a 	mov	sp,fp
8113a124:	df000017 	ldw	fp,0(sp)
8113a128:	dec00104 	addi	sp,sp,4
8113a12c:	f800283a 	ret

8113a130 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113a130:	defff904 	addi	sp,sp,-28
8113a134:	de00012e 	bgeu	sp,et,8113a13c <OSSemSet+0xc>
8113a138:	003b68fa 	trap	3
8113a13c:	df000615 	stw	fp,24(sp)
8113a140:	df000604 	addi	fp,sp,24
8113a144:	e13ffd15 	stw	r4,-12(fp)
8113a148:	2805883a 	mov	r2,r5
8113a14c:	e1bfff15 	stw	r6,-4(fp)
8113a150:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a154:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113a158:	e0bfff17 	ldw	r2,-4(fp)
8113a15c:	10003126 	beq	r2,zero,8113a224 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a160:	e0bffd17 	ldw	r2,-12(fp)
8113a164:	1000041e 	bne	r2,zero,8113a178 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113a168:	e0bfff17 	ldw	r2,-4(fp)
8113a16c:	00c00104 	movi	r3,4
8113a170:	10c00005 	stb	r3,0(r2)
        return;
8113a174:	00002c06 	br	8113a228 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113a178:	e0bffd17 	ldw	r2,-12(fp)
8113a17c:	10800003 	ldbu	r2,0(r2)
8113a180:	10803fcc 	andi	r2,r2,255
8113a184:	108000e0 	cmpeqi	r2,r2,3
8113a188:	1000041e 	bne	r2,zero,8113a19c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113a18c:	e0bfff17 	ldw	r2,-4(fp)
8113a190:	00c00044 	movi	r3,1
8113a194:	10c00005 	stb	r3,0(r2)
        return;
8113a198:	00002306 	br	8113a228 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a19c:	0005303a 	rdctl	r2,status
8113a1a0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a1a4:	e0fffc17 	ldw	r3,-16(fp)
8113a1a8:	00bfff84 	movi	r2,-2
8113a1ac:	1884703a 	and	r2,r3,r2
8113a1b0:	1001703a 	wrctl	status,r2
  
  return context;
8113a1b4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a1b8:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113a1bc:	e0bfff17 	ldw	r2,-4(fp)
8113a1c0:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113a1c4:	e0bffd17 	ldw	r2,-12(fp)
8113a1c8:	1080020b 	ldhu	r2,8(r2)
8113a1cc:	10bfffcc 	andi	r2,r2,65535
8113a1d0:	10000426 	beq	r2,zero,8113a1e4 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113a1d4:	e0bffd17 	ldw	r2,-12(fp)
8113a1d8:	e0fffe0b 	ldhu	r3,-8(fp)
8113a1dc:	10c0020d 	sth	r3,8(r2)
8113a1e0:	00000b06 	br	8113a210 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113a1e4:	e0bffd17 	ldw	r2,-12(fp)
8113a1e8:	10800283 	ldbu	r2,10(r2)
8113a1ec:	10803fcc 	andi	r2,r2,255
8113a1f0:	1000041e 	bne	r2,zero,8113a204 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113a1f4:	e0bffd17 	ldw	r2,-12(fp)
8113a1f8:	e0fffe0b 	ldhu	r3,-8(fp)
8113a1fc:	10c0020d 	sth	r3,8(r2)
8113a200:	00000306 	br	8113a210 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113a204:	e0bfff17 	ldw	r2,-4(fp)
8113a208:	00c01244 	movi	r3,73
8113a20c:	10c00005 	stb	r3,0(r2)
8113a210:	e0bffa17 	ldw	r2,-24(fp)
8113a214:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a218:	e0bffb17 	ldw	r2,-20(fp)
8113a21c:	1001703a 	wrctl	status,r2
8113a220:	00000106 	br	8113a228 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113a224:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113a228:	e037883a 	mov	sp,fp
8113a22c:	df000017 	ldw	fp,0(sp)
8113a230:	dec00104 	addi	sp,sp,4
8113a234:	f800283a 	ret

8113a238 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113a238:	defff104 	addi	sp,sp,-60
8113a23c:	de00012e 	bgeu	sp,et,8113a244 <OSTaskChangePrio+0xc>
8113a240:	003b68fa 	trap	3
8113a244:	dfc00e15 	stw	ra,56(sp)
8113a248:	df000d15 	stw	fp,52(sp)
8113a24c:	df000d04 	addi	fp,sp,52
8113a250:	2007883a 	mov	r3,r4
8113a254:	2805883a 	mov	r2,r5
8113a258:	e0fffe05 	stb	r3,-8(fp)
8113a25c:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113a260:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113a264:	e0bffe03 	ldbu	r2,-8(fp)
8113a268:	10800ab0 	cmpltui	r2,r2,42
8113a26c:	1000051e 	bne	r2,zero,8113a284 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113a270:	e0bffe03 	ldbu	r2,-8(fp)
8113a274:	10803fe0 	cmpeqi	r2,r2,255
8113a278:	1000021e 	bne	r2,zero,8113a284 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113a27c:	00800a84 	movi	r2,42
8113a280:	00012606 	br	8113a71c <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113a284:	e0bfff03 	ldbu	r2,-4(fp)
8113a288:	10800ab0 	cmpltui	r2,r2,42
8113a28c:	1000021e 	bne	r2,zero,8113a298 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113a290:	00800a84 	movi	r2,42
8113a294:	00012106 	br	8113a71c <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a298:	0005303a 	rdctl	r2,status
8113a29c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a2a0:	e0fffd17 	ldw	r3,-12(fp)
8113a2a4:	00bfff84 	movi	r2,-2
8113a2a8:	1884703a 	and	r2,r3,r2
8113a2ac:	1001703a 	wrctl	status,r2
  
  return context;
8113a2b0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a2b4:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113a2b8:	e0ffff03 	ldbu	r3,-4(fp)
8113a2bc:	00a045b4 	movhi	r2,33046
8113a2c0:	109b0304 	addi	r2,r2,27660
8113a2c4:	18c7883a 	add	r3,r3,r3
8113a2c8:	18c7883a 	add	r3,r3,r3
8113a2cc:	10c5883a 	add	r2,r2,r3
8113a2d0:	10800017 	ldw	r2,0(r2)
8113a2d4:	10000626 	beq	r2,zero,8113a2f0 <OSTaskChangePrio+0xb8>
8113a2d8:	e0bff517 	ldw	r2,-44(fp)
8113a2dc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a2e0:	e0bff617 	ldw	r2,-40(fp)
8113a2e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113a2e8:	00800a04 	movi	r2,40
8113a2ec:	00010b06 	br	8113a71c <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113a2f0:	e0bffe03 	ldbu	r2,-8(fp)
8113a2f4:	10803fd8 	cmpnei	r2,r2,255
8113a2f8:	1000031e 	bne	r2,zero,8113a308 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113a2fc:	d0a09c17 	ldw	r2,-32144(gp)
8113a300:	10800c83 	ldbu	r2,50(r2)
8113a304:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113a308:	e0fffe03 	ldbu	r3,-8(fp)
8113a30c:	00a045b4 	movhi	r2,33046
8113a310:	109b0304 	addi	r2,r2,27660
8113a314:	18c7883a 	add	r3,r3,r3
8113a318:	18c7883a 	add	r3,r3,r3
8113a31c:	10c5883a 	add	r2,r2,r3
8113a320:	10800017 	ldw	r2,0(r2)
8113a324:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113a328:	e0bff817 	ldw	r2,-32(fp)
8113a32c:	1000061e 	bne	r2,zero,8113a348 <OSTaskChangePrio+0x110>
8113a330:	e0bff517 	ldw	r2,-44(fp)
8113a334:	e0bff715 	stw	r2,-36(fp)
8113a338:	e0bff717 	ldw	r2,-36(fp)
8113a33c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113a340:	00800a44 	movi	r2,41
8113a344:	0000f506 	br	8113a71c <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113a348:	e0bff817 	ldw	r2,-32(fp)
8113a34c:	10800058 	cmpnei	r2,r2,1
8113a350:	1000061e 	bne	r2,zero,8113a36c <OSTaskChangePrio+0x134>
8113a354:	e0bff517 	ldw	r2,-44(fp)
8113a358:	e0bff915 	stw	r2,-28(fp)
8113a35c:	e0bff917 	ldw	r2,-28(fp)
8113a360:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113a364:	008010c4 	movi	r2,67
8113a368:	0000ec06 	br	8113a71c <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113a36c:	e0bfff03 	ldbu	r2,-4(fp)
8113a370:	1004d0fa 	srli	r2,r2,3
8113a374:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113a378:	e0bfff03 	ldbu	r2,-4(fp)
8113a37c:	108001cc 	andi	r2,r2,7
8113a380:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113a384:	e0bffb03 	ldbu	r2,-20(fp)
8113a388:	00c00044 	movi	r3,1
8113a38c:	1884983a 	sll	r2,r3,r2
8113a390:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113a394:	e0bffb43 	ldbu	r2,-19(fp)
8113a398:	00c00044 	movi	r3,1
8113a39c:	1884983a 	sll	r2,r3,r2
8113a3a0:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113a3a4:	e0fffe03 	ldbu	r3,-8(fp)
8113a3a8:	00a045b4 	movhi	r2,33046
8113a3ac:	109b0304 	addi	r2,r2,27660
8113a3b0:	18c7883a 	add	r3,r3,r3
8113a3b4:	18c7883a 	add	r3,r3,r3
8113a3b8:	10c5883a 	add	r2,r2,r3
8113a3bc:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113a3c0:	e0ffff03 	ldbu	r3,-4(fp)
8113a3c4:	00a045b4 	movhi	r2,33046
8113a3c8:	109b0304 	addi	r2,r2,27660
8113a3cc:	18c7883a 	add	r3,r3,r3
8113a3d0:	18c7883a 	add	r3,r3,r3
8113a3d4:	10c5883a 	add	r2,r2,r3
8113a3d8:	e0fff817 	ldw	r3,-32(fp)
8113a3dc:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113a3e0:	e0bff817 	ldw	r2,-32(fp)
8113a3e4:	10800d03 	ldbu	r2,52(r2)
8113a3e8:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113a3ec:	e0bff817 	ldw	r2,-32(fp)
8113a3f0:	10800d83 	ldbu	r2,54(r2)
8113a3f4:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113a3f8:	e0bff817 	ldw	r2,-32(fp)
8113a3fc:	10800d43 	ldbu	r2,53(r2)
8113a400:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113a404:	e0fffc03 	ldbu	r3,-16(fp)
8113a408:	d0a09844 	addi	r2,gp,-32159
8113a40c:	1885883a 	add	r2,r3,r2
8113a410:	10c00003 	ldbu	r3,0(r2)
8113a414:	e0bffc83 	ldbu	r2,-14(fp)
8113a418:	1884703a 	and	r2,r3,r2
8113a41c:	10803fcc 	andi	r2,r2,255
8113a420:	10002826 	beq	r2,zero,8113a4c4 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113a424:	e0fffc03 	ldbu	r3,-16(fp)
8113a428:	e13ffc03 	ldbu	r4,-16(fp)
8113a42c:	d0a09844 	addi	r2,gp,-32159
8113a430:	2085883a 	add	r2,r4,r2
8113a434:	10800003 	ldbu	r2,0(r2)
8113a438:	1009883a 	mov	r4,r2
8113a43c:	e0bffc83 	ldbu	r2,-14(fp)
8113a440:	0084303a 	nor	r2,zero,r2
8113a444:	2084703a 	and	r2,r4,r2
8113a448:	1009883a 	mov	r4,r2
8113a44c:	d0a09844 	addi	r2,gp,-32159
8113a450:	1885883a 	add	r2,r3,r2
8113a454:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113a458:	e0fffc03 	ldbu	r3,-16(fp)
8113a45c:	d0a09844 	addi	r2,gp,-32159
8113a460:	1885883a 	add	r2,r3,r2
8113a464:	10800003 	ldbu	r2,0(r2)
8113a468:	10803fcc 	andi	r2,r2,255
8113a46c:	1000061e 	bne	r2,zero,8113a488 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113a470:	e0bffc43 	ldbu	r2,-15(fp)
8113a474:	0084303a 	nor	r2,zero,r2
8113a478:	1007883a 	mov	r3,r2
8113a47c:	d0a09803 	ldbu	r2,-32160(gp)
8113a480:	1884703a 	and	r2,r3,r2
8113a484:	d0a09805 	stb	r2,-32160(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113a488:	d0e09803 	ldbu	r3,-32160(gp)
8113a48c:	e0bffb83 	ldbu	r2,-18(fp)
8113a490:	1884b03a 	or	r2,r3,r2
8113a494:	d0a09805 	stb	r2,-32160(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113a498:	e0fffb03 	ldbu	r3,-20(fp)
8113a49c:	e13ffb03 	ldbu	r4,-20(fp)
8113a4a0:	d0a09844 	addi	r2,gp,-32159
8113a4a4:	2085883a 	add	r2,r4,r2
8113a4a8:	11000003 	ldbu	r4,0(r2)
8113a4ac:	e0bffbc3 	ldbu	r2,-17(fp)
8113a4b0:	2084b03a 	or	r2,r4,r2
8113a4b4:	1009883a 	mov	r4,r2
8113a4b8:	d0a09844 	addi	r2,gp,-32159
8113a4bc:	1885883a 	add	r2,r3,r2
8113a4c0:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113a4c4:	e0bff817 	ldw	r2,-32(fp)
8113a4c8:	10800717 	ldw	r2,28(r2)
8113a4cc:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113a4d0:	e0bff317 	ldw	r2,-52(fp)
8113a4d4:	10003326 	beq	r2,zero,8113a5a4 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113a4d8:	e0bffc03 	ldbu	r2,-16(fp)
8113a4dc:	e0fffc03 	ldbu	r3,-16(fp)
8113a4e0:	e13ff317 	ldw	r4,-52(fp)
8113a4e4:	20c7883a 	add	r3,r4,r3
8113a4e8:	18c002c4 	addi	r3,r3,11
8113a4ec:	18c00003 	ldbu	r3,0(r3)
8113a4f0:	1809883a 	mov	r4,r3
8113a4f4:	e0fffc83 	ldbu	r3,-14(fp)
8113a4f8:	00c6303a 	nor	r3,zero,r3
8113a4fc:	20c6703a 	and	r3,r4,r3
8113a500:	1809883a 	mov	r4,r3
8113a504:	e0fff317 	ldw	r3,-52(fp)
8113a508:	1885883a 	add	r2,r3,r2
8113a50c:	108002c4 	addi	r2,r2,11
8113a510:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113a514:	e0bffc03 	ldbu	r2,-16(fp)
8113a518:	e0fff317 	ldw	r3,-52(fp)
8113a51c:	1885883a 	add	r2,r3,r2
8113a520:	108002c4 	addi	r2,r2,11
8113a524:	10800003 	ldbu	r2,0(r2)
8113a528:	10803fcc 	andi	r2,r2,255
8113a52c:	1000091e 	bne	r2,zero,8113a554 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113a530:	e0bff317 	ldw	r2,-52(fp)
8113a534:	10800283 	ldbu	r2,10(r2)
8113a538:	1007883a 	mov	r3,r2
8113a53c:	e0bffc43 	ldbu	r2,-15(fp)
8113a540:	0084303a 	nor	r2,zero,r2
8113a544:	1884703a 	and	r2,r3,r2
8113a548:	1007883a 	mov	r3,r2
8113a54c:	e0bff317 	ldw	r2,-52(fp)
8113a550:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113a554:	e0bff317 	ldw	r2,-52(fp)
8113a558:	10c00283 	ldbu	r3,10(r2)
8113a55c:	e0bffb83 	ldbu	r2,-18(fp)
8113a560:	1884b03a 	or	r2,r3,r2
8113a564:	1007883a 	mov	r3,r2
8113a568:	e0bff317 	ldw	r2,-52(fp)
8113a56c:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113a570:	e0bffb03 	ldbu	r2,-20(fp)
8113a574:	e0fffb03 	ldbu	r3,-20(fp)
8113a578:	e13ff317 	ldw	r4,-52(fp)
8113a57c:	20c7883a 	add	r3,r4,r3
8113a580:	18c002c4 	addi	r3,r3,11
8113a584:	19000003 	ldbu	r4,0(r3)
8113a588:	e0fffbc3 	ldbu	r3,-17(fp)
8113a58c:	20c6b03a 	or	r3,r4,r3
8113a590:	1809883a 	mov	r4,r3
8113a594:	e0fff317 	ldw	r3,-52(fp)
8113a598:	1885883a 	add	r2,r3,r2
8113a59c:	108002c4 	addi	r2,r2,11
8113a5a0:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113a5a4:	e0bff817 	ldw	r2,-32(fp)
8113a5a8:	10800817 	ldw	r2,32(r2)
8113a5ac:	10004226 	beq	r2,zero,8113a6b8 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113a5b0:	e0bff817 	ldw	r2,-32(fp)
8113a5b4:	10800817 	ldw	r2,32(r2)
8113a5b8:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113a5bc:	e0bff417 	ldw	r2,-48(fp)
8113a5c0:	10800017 	ldw	r2,0(r2)
8113a5c4:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113a5c8:	00003906 	br	8113a6b0 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113a5cc:	e0bffc03 	ldbu	r2,-16(fp)
8113a5d0:	e0fffc03 	ldbu	r3,-16(fp)
8113a5d4:	e13ff317 	ldw	r4,-52(fp)
8113a5d8:	20c7883a 	add	r3,r4,r3
8113a5dc:	18c002c4 	addi	r3,r3,11
8113a5e0:	18c00003 	ldbu	r3,0(r3)
8113a5e4:	1809883a 	mov	r4,r3
8113a5e8:	e0fffc83 	ldbu	r3,-14(fp)
8113a5ec:	00c6303a 	nor	r3,zero,r3
8113a5f0:	20c6703a 	and	r3,r4,r3
8113a5f4:	1809883a 	mov	r4,r3
8113a5f8:	e0fff317 	ldw	r3,-52(fp)
8113a5fc:	1885883a 	add	r2,r3,r2
8113a600:	108002c4 	addi	r2,r2,11
8113a604:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113a608:	e0bffc03 	ldbu	r2,-16(fp)
8113a60c:	e0fff317 	ldw	r3,-52(fp)
8113a610:	1885883a 	add	r2,r3,r2
8113a614:	108002c4 	addi	r2,r2,11
8113a618:	10800003 	ldbu	r2,0(r2)
8113a61c:	10803fcc 	andi	r2,r2,255
8113a620:	1000091e 	bne	r2,zero,8113a648 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113a624:	e0bff317 	ldw	r2,-52(fp)
8113a628:	10800283 	ldbu	r2,10(r2)
8113a62c:	1007883a 	mov	r3,r2
8113a630:	e0bffc43 	ldbu	r2,-15(fp)
8113a634:	0084303a 	nor	r2,zero,r2
8113a638:	1884703a 	and	r2,r3,r2
8113a63c:	1007883a 	mov	r3,r2
8113a640:	e0bff317 	ldw	r2,-52(fp)
8113a644:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113a648:	e0bff317 	ldw	r2,-52(fp)
8113a64c:	10c00283 	ldbu	r3,10(r2)
8113a650:	e0bffb83 	ldbu	r2,-18(fp)
8113a654:	1884b03a 	or	r2,r3,r2
8113a658:	1007883a 	mov	r3,r2
8113a65c:	e0bff317 	ldw	r2,-52(fp)
8113a660:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113a664:	e0bffb03 	ldbu	r2,-20(fp)
8113a668:	e0fffb03 	ldbu	r3,-20(fp)
8113a66c:	e13ff317 	ldw	r4,-52(fp)
8113a670:	20c7883a 	add	r3,r4,r3
8113a674:	18c002c4 	addi	r3,r3,11
8113a678:	19000003 	ldbu	r4,0(r3)
8113a67c:	e0fffbc3 	ldbu	r3,-17(fp)
8113a680:	20c6b03a 	or	r3,r4,r3
8113a684:	1809883a 	mov	r4,r3
8113a688:	e0fff317 	ldw	r3,-52(fp)
8113a68c:	1885883a 	add	r2,r3,r2
8113a690:	108002c4 	addi	r2,r2,11
8113a694:	11000005 	stb	r4,0(r2)
            pevents++;
8113a698:	e0bff417 	ldw	r2,-48(fp)
8113a69c:	10800104 	addi	r2,r2,4
8113a6a0:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113a6a4:	e0bff417 	ldw	r2,-48(fp)
8113a6a8:	10800017 	ldw	r2,0(r2)
8113a6ac:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113a6b0:	e0bff317 	ldw	r2,-52(fp)
8113a6b4:	103fc51e 	bne	r2,zero,8113a5cc <__reset+0xfb11a5cc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113a6b8:	e0bff817 	ldw	r2,-32(fp)
8113a6bc:	e0ffff03 	ldbu	r3,-4(fp)
8113a6c0:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113a6c4:	e0bff817 	ldw	r2,-32(fp)
8113a6c8:	e0fffb03 	ldbu	r3,-20(fp)
8113a6cc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113a6d0:	e0bff817 	ldw	r2,-32(fp)
8113a6d4:	e0fffb43 	ldbu	r3,-19(fp)
8113a6d8:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113a6dc:	e0bff817 	ldw	r2,-32(fp)
8113a6e0:	e0fffb83 	ldbu	r3,-18(fp)
8113a6e4:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113a6e8:	e0bff817 	ldw	r2,-32(fp)
8113a6ec:	e0fffbc3 	ldbu	r3,-17(fp)
8113a6f0:	10c00d45 	stb	r3,53(r2)
8113a6f4:	e0bff517 	ldw	r2,-44(fp)
8113a6f8:	e0bffa15 	stw	r2,-24(fp)
8113a6fc:	e0bffa17 	ldw	r2,-24(fp)
8113a700:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113a704:	d0a08b03 	ldbu	r2,-32212(gp)
8113a708:	10803fcc 	andi	r2,r2,255
8113a70c:	10800058 	cmpnei	r2,r2,1
8113a710:	1000011e 	bne	r2,zero,8113a718 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113a714:	1134cc80 	call	81134cc8 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113a718:	0005883a 	mov	r2,zero
}
8113a71c:	e037883a 	mov	sp,fp
8113a720:	dfc00117 	ldw	ra,4(sp)
8113a724:	df000017 	ldw	fp,0(sp)
8113a728:	dec00204 	addi	sp,sp,8
8113a72c:	f800283a 	ret

8113a730 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113a730:	deffec04 	addi	sp,sp,-80
8113a734:	de00012e 	bgeu	sp,et,8113a73c <OSTaskCreateExt+0xc>
8113a738:	003b68fa 	trap	3
8113a73c:	dfc01315 	stw	ra,76(sp)
8113a740:	df001215 	stw	fp,72(sp)
8113a744:	df001204 	addi	fp,sp,72
8113a748:	e13ffa15 	stw	r4,-24(fp)
8113a74c:	e17ffb15 	stw	r5,-20(fp)
8113a750:	e1bffc15 	stw	r6,-16(fp)
8113a754:	3809883a 	mov	r4,r7
8113a758:	e0c00217 	ldw	r3,8(fp)
8113a75c:	e0800617 	ldw	r2,24(fp)
8113a760:	e13ffd05 	stb	r4,-12(fp)
8113a764:	e0fffe0d 	sth	r3,-8(fp)
8113a768:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113a76c:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113a770:	e0bffd03 	ldbu	r2,-12(fp)
8113a774:	10800af0 	cmpltui	r2,r2,43
8113a778:	1000021e 	bne	r2,zero,8113a784 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113a77c:	00800a84 	movi	r2,42
8113a780:	00006106 	br	8113a908 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a784:	0005303a 	rdctl	r2,status
8113a788:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a78c:	e0fff917 	ldw	r3,-28(fp)
8113a790:	00bfff84 	movi	r2,-2
8113a794:	1884703a 	and	r2,r3,r2
8113a798:	1001703a 	wrctl	status,r2
  
  return context;
8113a79c:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a7a0:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113a7a4:	d0a09b03 	ldbu	r2,-32148(gp)
8113a7a8:	10803fcc 	andi	r2,r2,255
8113a7ac:	10000626 	beq	r2,zero,8113a7c8 <OSTaskCreateExt+0x98>
8113a7b0:	e0bff117 	ldw	r2,-60(fp)
8113a7b4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a7b8:	e0bff217 	ldw	r2,-56(fp)
8113a7bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113a7c0:	00800f04 	movi	r2,60
8113a7c4:	00005006 	br	8113a908 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113a7c8:	e0fffd03 	ldbu	r3,-12(fp)
8113a7cc:	00a045b4 	movhi	r2,33046
8113a7d0:	109b0304 	addi	r2,r2,27660
8113a7d4:	18c7883a 	add	r3,r3,r3
8113a7d8:	18c7883a 	add	r3,r3,r3
8113a7dc:	10c5883a 	add	r2,r2,r3
8113a7e0:	10800017 	ldw	r2,0(r2)
8113a7e4:	1000431e 	bne	r2,zero,8113a8f4 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113a7e8:	e0fffd03 	ldbu	r3,-12(fp)
8113a7ec:	00a045b4 	movhi	r2,33046
8113a7f0:	109b0304 	addi	r2,r2,27660
8113a7f4:	18c7883a 	add	r3,r3,r3
8113a7f8:	18c7883a 	add	r3,r3,r3
8113a7fc:	10c5883a 	add	r2,r2,r3
8113a800:	00c00044 	movi	r3,1
8113a804:	10c00015 	stw	r3,0(r2)
8113a808:	e0bff117 	ldw	r2,-60(fp)
8113a80c:	e0bff315 	stw	r2,-52(fp)
8113a810:	e0bff317 	ldw	r2,-52(fp)
8113a814:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113a818:	e0bfff0b 	ldhu	r2,-4(fp)
8113a81c:	100d883a 	mov	r6,r2
8113a820:	e1400417 	ldw	r5,16(fp)
8113a824:	e1000317 	ldw	r4,12(fp)
8113a828:	113b7d80 	call	8113b7d8 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113a82c:	e0bfff0b 	ldhu	r2,-4(fp)
8113a830:	100f883a 	mov	r7,r2
8113a834:	e1bffc17 	ldw	r6,-16(fp)
8113a838:	e17ffb17 	ldw	r5,-20(fp)
8113a83c:	e13ffa17 	ldw	r4,-24(fp)
8113a840:	1145c240 	call	81145c24 <OSTaskStkInit>
8113a844:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113a848:	e0fffd03 	ldbu	r3,-12(fp)
8113a84c:	e13ffe0b 	ldhu	r4,-8(fp)
8113a850:	e0bfff0b 	ldhu	r2,-4(fp)
8113a854:	d8800215 	stw	r2,8(sp)
8113a858:	e0800517 	ldw	r2,20(fp)
8113a85c:	d8800115 	stw	r2,4(sp)
8113a860:	e0800417 	ldw	r2,16(fp)
8113a864:	d8800015 	stw	r2,0(sp)
8113a868:	200f883a 	mov	r7,r4
8113a86c:	e1800317 	ldw	r6,12(fp)
8113a870:	e17ff517 	ldw	r5,-44(fp)
8113a874:	1809883a 	mov	r4,r3
8113a878:	11351100 	call	81135110 <OS_TCBInit>
8113a87c:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113a880:	e0bff603 	ldbu	r2,-40(fp)
8113a884:	1000061e 	bne	r2,zero,8113a8a0 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113a888:	d0a08b03 	ldbu	r2,-32212(gp)
8113a88c:	10803fcc 	andi	r2,r2,255
8113a890:	10800058 	cmpnei	r2,r2,1
8113a894:	1000151e 	bne	r2,zero,8113a8ec <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113a898:	1134cc80 	call	81134cc8 <OS_Sched>
8113a89c:	00001306 	br	8113a8ec <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8a0:	0005303a 	rdctl	r2,status
8113a8a4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8a8:	e0fff817 	ldw	r3,-32(fp)
8113a8ac:	00bfff84 	movi	r2,-2
8113a8b0:	1884703a 	and	r2,r3,r2
8113a8b4:	1001703a 	wrctl	status,r2
  
  return context;
8113a8b8:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113a8bc:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113a8c0:	e0fffd03 	ldbu	r3,-12(fp)
8113a8c4:	00a045b4 	movhi	r2,33046
8113a8c8:	109b0304 	addi	r2,r2,27660
8113a8cc:	18c7883a 	add	r3,r3,r3
8113a8d0:	18c7883a 	add	r3,r3,r3
8113a8d4:	10c5883a 	add	r2,r2,r3
8113a8d8:	10000015 	stw	zero,0(r2)
8113a8dc:	e0bff117 	ldw	r2,-60(fp)
8113a8e0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a8e4:	e0bff417 	ldw	r2,-48(fp)
8113a8e8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113a8ec:	e0bff603 	ldbu	r2,-40(fp)
8113a8f0:	00000506 	br	8113a908 <OSTaskCreateExt+0x1d8>
8113a8f4:	e0bff117 	ldw	r2,-60(fp)
8113a8f8:	e0bff715 	stw	r2,-36(fp)
8113a8fc:	e0bff717 	ldw	r2,-36(fp)
8113a900:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113a904:	00800a04 	movi	r2,40
}
8113a908:	e037883a 	mov	sp,fp
8113a90c:	dfc00117 	ldw	ra,4(sp)
8113a910:	df000017 	ldw	fp,0(sp)
8113a914:	dec00204 	addi	sp,sp,8
8113a918:	f800283a 	ret

8113a91c <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113a91c:	defff404 	addi	sp,sp,-48
8113a920:	de00012e 	bgeu	sp,et,8113a928 <OSTaskDel+0xc>
8113a924:	003b68fa 	trap	3
8113a928:	dfc00b15 	stw	ra,44(sp)
8113a92c:	df000a15 	stw	fp,40(sp)
8113a930:	df000a04 	addi	fp,sp,40
8113a934:	2005883a 	mov	r2,r4
8113a938:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113a93c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113a940:	d0a09b03 	ldbu	r2,-32148(gp)
8113a944:	10803fcc 	andi	r2,r2,255
8113a948:	10000226 	beq	r2,zero,8113a954 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113a94c:	00801004 	movi	r2,64
8113a950:	0000c006 	br	8113ac54 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113a954:	e0bfff03 	ldbu	r2,-4(fp)
8113a958:	10800a98 	cmpnei	r2,r2,42
8113a95c:	1000021e 	bne	r2,zero,8113a968 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113a960:	00800f84 	movi	r2,62
8113a964:	0000bb06 	br	8113ac54 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113a968:	e0bfff03 	ldbu	r2,-4(fp)
8113a96c:	10800ab0 	cmpltui	r2,r2,42
8113a970:	1000051e 	bne	r2,zero,8113a988 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113a974:	e0bfff03 	ldbu	r2,-4(fp)
8113a978:	10803fe0 	cmpeqi	r2,r2,255
8113a97c:	1000021e 	bne	r2,zero,8113a988 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113a980:	00800a84 	movi	r2,42
8113a984:	0000b306 	br	8113ac54 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a988:	0005303a 	rdctl	r2,status
8113a98c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a990:	e0fffe17 	ldw	r3,-8(fp)
8113a994:	00bfff84 	movi	r2,-2
8113a998:	1884703a 	and	r2,r3,r2
8113a99c:	1001703a 	wrctl	status,r2
  
  return context;
8113a9a0:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a9a4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113a9a8:	e0bfff03 	ldbu	r2,-4(fp)
8113a9ac:	10803fd8 	cmpnei	r2,r2,255
8113a9b0:	1000031e 	bne	r2,zero,8113a9c0 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113a9b4:	d0a09c17 	ldw	r2,-32144(gp)
8113a9b8:	10800c83 	ldbu	r2,50(r2)
8113a9bc:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a9c0:	e0ffff03 	ldbu	r3,-4(fp)
8113a9c4:	00a045b4 	movhi	r2,33046
8113a9c8:	109b0304 	addi	r2,r2,27660
8113a9cc:	18c7883a 	add	r3,r3,r3
8113a9d0:	18c7883a 	add	r3,r3,r3
8113a9d4:	10c5883a 	add	r2,r2,r3
8113a9d8:	10800017 	ldw	r2,0(r2)
8113a9dc:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113a9e0:	e0bff817 	ldw	r2,-32(fp)
8113a9e4:	1000061e 	bne	r2,zero,8113aa00 <OSTaskDel+0xe4>
8113a9e8:	e0bff617 	ldw	r2,-40(fp)
8113a9ec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a9f0:	e0bff717 	ldw	r2,-36(fp)
8113a9f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a9f8:	008010c4 	movi	r2,67
8113a9fc:	00009506 	br	8113ac54 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113aa00:	e0bff817 	ldw	r2,-32(fp)
8113aa04:	10800058 	cmpnei	r2,r2,1
8113aa08:	1000061e 	bne	r2,zero,8113aa24 <OSTaskDel+0x108>
8113aa0c:	e0bff617 	ldw	r2,-40(fp)
8113aa10:	e0bff915 	stw	r2,-28(fp)
8113aa14:	e0bff917 	ldw	r2,-28(fp)
8113aa18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113aa1c:	00800f44 	movi	r2,61
8113aa20:	00008c06 	br	8113ac54 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113aa24:	e0bff817 	ldw	r2,-32(fp)
8113aa28:	10800d03 	ldbu	r2,52(r2)
8113aa2c:	10c03fcc 	andi	r3,r2,255
8113aa30:	e0bff817 	ldw	r2,-32(fp)
8113aa34:	10800d03 	ldbu	r2,52(r2)
8113aa38:	11003fcc 	andi	r4,r2,255
8113aa3c:	d0a09844 	addi	r2,gp,-32159
8113aa40:	2085883a 	add	r2,r4,r2
8113aa44:	10800003 	ldbu	r2,0(r2)
8113aa48:	1009883a 	mov	r4,r2
8113aa4c:	e0bff817 	ldw	r2,-32(fp)
8113aa50:	10800d43 	ldbu	r2,53(r2)
8113aa54:	0084303a 	nor	r2,zero,r2
8113aa58:	2084703a 	and	r2,r4,r2
8113aa5c:	1009883a 	mov	r4,r2
8113aa60:	d0a09844 	addi	r2,gp,-32159
8113aa64:	1885883a 	add	r2,r3,r2
8113aa68:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113aa6c:	e0bff817 	ldw	r2,-32(fp)
8113aa70:	10800d03 	ldbu	r2,52(r2)
8113aa74:	10c03fcc 	andi	r3,r2,255
8113aa78:	d0a09844 	addi	r2,gp,-32159
8113aa7c:	1885883a 	add	r2,r3,r2
8113aa80:	10800003 	ldbu	r2,0(r2)
8113aa84:	10803fcc 	andi	r2,r2,255
8113aa88:	1000071e 	bne	r2,zero,8113aaa8 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113aa8c:	e0bff817 	ldw	r2,-32(fp)
8113aa90:	10800d83 	ldbu	r2,54(r2)
8113aa94:	0084303a 	nor	r2,zero,r2
8113aa98:	1007883a 	mov	r3,r2
8113aa9c:	d0a09803 	ldbu	r2,-32160(gp)
8113aaa0:	1884703a 	and	r2,r3,r2
8113aaa4:	d0a09805 	stb	r2,-32160(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113aaa8:	e0bff817 	ldw	r2,-32(fp)
8113aaac:	10800717 	ldw	r2,28(r2)
8113aab0:	10000526 	beq	r2,zero,8113aac8 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113aab4:	e0bff817 	ldw	r2,-32(fp)
8113aab8:	10800717 	ldw	r2,28(r2)
8113aabc:	100b883a 	mov	r5,r2
8113aac0:	e13ff817 	ldw	r4,-32(fp)
8113aac4:	113461c0 	call	8113461c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113aac8:	e0bff817 	ldw	r2,-32(fp)
8113aacc:	10800817 	ldw	r2,32(r2)
8113aad0:	10000526 	beq	r2,zero,8113aae8 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113aad4:	e0bff817 	ldw	r2,-32(fp)
8113aad8:	10800817 	ldw	r2,32(r2)
8113aadc:	100b883a 	mov	r5,r2
8113aae0:	e13ff817 	ldw	r4,-32(fp)
8113aae4:	11346dc0 	call	811346dc <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113aae8:	e0bff817 	ldw	r2,-32(fp)
8113aaec:	10800a17 	ldw	r2,40(r2)
8113aaf0:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113aaf4:	e0bffb17 	ldw	r2,-20(fp)
8113aaf8:	10000226 	beq	r2,zero,8113ab04 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113aafc:	e13ffb17 	ldw	r4,-20(fp)
8113ab00:	1136cb40 	call	81136cb4 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113ab04:	e0bff817 	ldw	r2,-32(fp)
8113ab08:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113ab0c:	e0bff817 	ldw	r2,-32(fp)
8113ab10:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113ab14:	e0bff817 	ldw	r2,-32(fp)
8113ab18:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113ab1c:	d0a08903 	ldbu	r2,-32220(gp)
8113ab20:	10803fcc 	andi	r2,r2,255
8113ab24:	10803fe0 	cmpeqi	r2,r2,255
8113ab28:	1000031e 	bne	r2,zero,8113ab38 <OSTaskDel+0x21c>
        OSLockNesting++;
8113ab2c:	d0a08903 	ldbu	r2,-32220(gp)
8113ab30:	10800044 	addi	r2,r2,1
8113ab34:	d0a08905 	stb	r2,-32220(gp)
8113ab38:	e0bff617 	ldw	r2,-40(fp)
8113ab3c:	e0bffd15 	stw	r2,-12(fp)
8113ab40:	e0bffd17 	ldw	r2,-12(fp)
8113ab44:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113ab48:	11341e40 	call	811341e4 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab4c:	0005303a 	rdctl	r2,status
8113ab50:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ab54:	e0fffa17 	ldw	r3,-24(fp)
8113ab58:	00bfff84 	movi	r2,-2
8113ab5c:	1884703a 	and	r2,r3,r2
8113ab60:	1001703a 	wrctl	status,r2
  
  return context;
8113ab64:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113ab68:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113ab6c:	d0a08903 	ldbu	r2,-32220(gp)
8113ab70:	10803fcc 	andi	r2,r2,255
8113ab74:	10000326 	beq	r2,zero,8113ab84 <OSTaskDel+0x268>
        OSLockNesting--;
8113ab78:	d0a08903 	ldbu	r2,-32220(gp)
8113ab7c:	10bfffc4 	addi	r2,r2,-1
8113ab80:	d0a08905 	stb	r2,-32220(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113ab84:	e13ff817 	ldw	r4,-32(fp)
8113ab88:	1145db40 	call	81145db4 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113ab8c:	d0a09443 	ldbu	r2,-32175(gp)
8113ab90:	10bfffc4 	addi	r2,r2,-1
8113ab94:	d0a09445 	stb	r2,-32175(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113ab98:	e0ffff03 	ldbu	r3,-4(fp)
8113ab9c:	00a045b4 	movhi	r2,33046
8113aba0:	109b0304 	addi	r2,r2,27660
8113aba4:	18c7883a 	add	r3,r3,r3
8113aba8:	18c7883a 	add	r3,r3,r3
8113abac:	10c5883a 	add	r2,r2,r3
8113abb0:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113abb4:	e0bff817 	ldw	r2,-32(fp)
8113abb8:	10800617 	ldw	r2,24(r2)
8113abbc:	1000071e 	bne	r2,zero,8113abdc <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113abc0:	e0bff817 	ldw	r2,-32(fp)
8113abc4:	10800517 	ldw	r2,20(r2)
8113abc8:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113abcc:	e0bff817 	ldw	r2,-32(fp)
8113abd0:	10800517 	ldw	r2,20(r2)
8113abd4:	d0a08e15 	stw	r2,-32200(gp)
8113abd8:	00000a06 	br	8113ac04 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113abdc:	e0bff817 	ldw	r2,-32(fp)
8113abe0:	10800617 	ldw	r2,24(r2)
8113abe4:	e0fff817 	ldw	r3,-32(fp)
8113abe8:	18c00517 	ldw	r3,20(r3)
8113abec:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113abf0:	e0bff817 	ldw	r2,-32(fp)
8113abf4:	10800517 	ldw	r2,20(r2)
8113abf8:	e0fff817 	ldw	r3,-32(fp)
8113abfc:	18c00617 	ldw	r3,24(r3)
8113ac00:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113ac04:	d0e09317 	ldw	r3,-32180(gp)
8113ac08:	e0bff817 	ldw	r2,-32(fp)
8113ac0c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113ac10:	e0bff817 	ldw	r2,-32(fp)
8113ac14:	d0a09315 	stw	r2,-32180(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113ac18:	e0bff817 	ldw	r2,-32(fp)
8113ac1c:	00c00fc4 	movi	r3,63
8113ac20:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113ac24:	e0bff817 	ldw	r2,-32(fp)
8113ac28:	10001345 	stb	zero,77(r2)
8113ac2c:	e0bff617 	ldw	r2,-40(fp)
8113ac30:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ac34:	e0bffc17 	ldw	r2,-16(fp)
8113ac38:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113ac3c:	d0a08b03 	ldbu	r2,-32212(gp)
8113ac40:	10803fcc 	andi	r2,r2,255
8113ac44:	10800058 	cmpnei	r2,r2,1
8113ac48:	1000011e 	bne	r2,zero,8113ac50 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113ac4c:	1134cc80 	call	81134cc8 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113ac50:	0005883a 	mov	r2,zero
}
8113ac54:	e037883a 	mov	sp,fp
8113ac58:	dfc00117 	ldw	ra,4(sp)
8113ac5c:	df000017 	ldw	fp,0(sp)
8113ac60:	dec00204 	addi	sp,sp,8
8113ac64:	f800283a 	ret

8113ac68 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113ac68:	defff504 	addi	sp,sp,-44
8113ac6c:	de00012e 	bgeu	sp,et,8113ac74 <OSTaskDelReq+0xc>
8113ac70:	003b68fa 	trap	3
8113ac74:	df000a15 	stw	fp,40(sp)
8113ac78:	df000a04 	addi	fp,sp,40
8113ac7c:	2005883a 	mov	r2,r4
8113ac80:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ac84:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113ac88:	e0bfff03 	ldbu	r2,-4(fp)
8113ac8c:	10800a98 	cmpnei	r2,r2,42
8113ac90:	1000021e 	bne	r2,zero,8113ac9c <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113ac94:	00800f84 	movi	r2,62
8113ac98:	00004506 	br	8113adb0 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113ac9c:	e0bfff03 	ldbu	r2,-4(fp)
8113aca0:	10800ab0 	cmpltui	r2,r2,42
8113aca4:	1000051e 	bne	r2,zero,8113acbc <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113aca8:	e0bfff03 	ldbu	r2,-4(fp)
8113acac:	10803fe0 	cmpeqi	r2,r2,255
8113acb0:	1000021e 	bne	r2,zero,8113acbc <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113acb4:	00800a84 	movi	r2,42
8113acb8:	00003d06 	br	8113adb0 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113acbc:	e0bfff03 	ldbu	r2,-4(fp)
8113acc0:	10803fd8 	cmpnei	r2,r2,255
8113acc4:	1000111e 	bne	r2,zero,8113ad0c <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113acc8:	0005303a 	rdctl	r2,status
8113accc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113acd0:	e0fff917 	ldw	r3,-28(fp)
8113acd4:	00bfff84 	movi	r2,-2
8113acd8:	1884703a 	and	r2,r3,r2
8113acdc:	1001703a 	wrctl	status,r2
  
  return context;
8113ace0:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113ace4:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113ace8:	d0a09c17 	ldw	r2,-32144(gp)
8113acec:	10800dc3 	ldbu	r2,55(r2)
8113acf0:	e0bff805 	stb	r2,-32(fp)
8113acf4:	e0bff617 	ldw	r2,-40(fp)
8113acf8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113acfc:	e0bffe17 	ldw	r2,-8(fp)
8113ad00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113ad04:	e0bff803 	ldbu	r2,-32(fp)
8113ad08:	00002906 	br	8113adb0 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ad0c:	0005303a 	rdctl	r2,status
8113ad10:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ad14:	e0fff717 	ldw	r3,-36(fp)
8113ad18:	00bfff84 	movi	r2,-2
8113ad1c:	1884703a 	and	r2,r3,r2
8113ad20:	1001703a 	wrctl	status,r2
  
  return context;
8113ad24:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113ad28:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113ad2c:	e0ffff03 	ldbu	r3,-4(fp)
8113ad30:	00a045b4 	movhi	r2,33046
8113ad34:	109b0304 	addi	r2,r2,27660
8113ad38:	18c7883a 	add	r3,r3,r3
8113ad3c:	18c7883a 	add	r3,r3,r3
8113ad40:	10c5883a 	add	r2,r2,r3
8113ad44:	10800017 	ldw	r2,0(r2)
8113ad48:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113ad4c:	e0bffb17 	ldw	r2,-20(fp)
8113ad50:	1000061e 	bne	r2,zero,8113ad6c <OSTaskDelReq+0x104>
8113ad54:	e0bff617 	ldw	r2,-40(fp)
8113ad58:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ad5c:	e0bffa17 	ldw	r2,-24(fp)
8113ad60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113ad64:	008010c4 	movi	r2,67
8113ad68:	00001106 	br	8113adb0 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113ad6c:	e0bffb17 	ldw	r2,-20(fp)
8113ad70:	10800058 	cmpnei	r2,r2,1
8113ad74:	1000061e 	bne	r2,zero,8113ad90 <OSTaskDelReq+0x128>
8113ad78:	e0bff617 	ldw	r2,-40(fp)
8113ad7c:	e0bffc15 	stw	r2,-16(fp)
8113ad80:	e0bffc17 	ldw	r2,-16(fp)
8113ad84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113ad88:	00800f44 	movi	r2,61
8113ad8c:	00000806 	br	8113adb0 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113ad90:	e0bffb17 	ldw	r2,-20(fp)
8113ad94:	00c00fc4 	movi	r3,63
8113ad98:	10c00dc5 	stb	r3,55(r2)
8113ad9c:	e0bff617 	ldw	r2,-40(fp)
8113ada0:	e0bffd15 	stw	r2,-12(fp)
8113ada4:	e0bffd17 	ldw	r2,-12(fp)
8113ada8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113adac:	0005883a 	mov	r2,zero
}
8113adb0:	e037883a 	mov	sp,fp
8113adb4:	df000017 	ldw	fp,0(sp)
8113adb8:	dec00104 	addi	sp,sp,4
8113adbc:	f800283a 	ret

8113adc0 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113adc0:	defff404 	addi	sp,sp,-48
8113adc4:	de00012e 	bgeu	sp,et,8113adcc <OSTaskNameGet+0xc>
8113adc8:	003b68fa 	trap	3
8113adcc:	dfc00b15 	stw	ra,44(sp)
8113add0:	df000a15 	stw	fp,40(sp)
8113add4:	df000a04 	addi	fp,sp,40
8113add8:	2005883a 	mov	r2,r4
8113addc:	e17ffe15 	stw	r5,-8(fp)
8113ade0:	e1bfff15 	stw	r6,-4(fp)
8113ade4:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113ade8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113adec:	e0bfff17 	ldw	r2,-4(fp)
8113adf0:	1000021e 	bne	r2,zero,8113adfc <OSTaskNameGet+0x3c>
        return (0);
8113adf4:	0005883a 	mov	r2,zero
8113adf8:	00005406 	br	8113af4c <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113adfc:	e0bffd03 	ldbu	r2,-12(fp)
8113ae00:	10800af0 	cmpltui	r2,r2,43
8113ae04:	1000081e 	bne	r2,zero,8113ae28 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113ae08:	e0bffd03 	ldbu	r2,-12(fp)
8113ae0c:	10803fe0 	cmpeqi	r2,r2,255
8113ae10:	1000051e 	bne	r2,zero,8113ae28 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113ae14:	e0bfff17 	ldw	r2,-4(fp)
8113ae18:	00c00a84 	movi	r3,42
8113ae1c:	10c00005 	stb	r3,0(r2)
            return (0);
8113ae20:	0005883a 	mov	r2,zero
8113ae24:	00004906 	br	8113af4c <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113ae28:	e0bffe17 	ldw	r2,-8(fp)
8113ae2c:	1000051e 	bne	r2,zero,8113ae44 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113ae30:	e0bfff17 	ldw	r2,-4(fp)
8113ae34:	00c00304 	movi	r3,12
8113ae38:	10c00005 	stb	r3,0(r2)
        return (0);
8113ae3c:	0005883a 	mov	r2,zero
8113ae40:	00004206 	br	8113af4c <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113ae44:	d0a09b03 	ldbu	r2,-32148(gp)
8113ae48:	10803fcc 	andi	r2,r2,255
8113ae4c:	10000526 	beq	r2,zero,8113ae64 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113ae50:	e0bfff17 	ldw	r2,-4(fp)
8113ae54:	00c00444 	movi	r3,17
8113ae58:	10c00005 	stb	r3,0(r2)
        return (0);
8113ae5c:	0005883a 	mov	r2,zero
8113ae60:	00003a06 	br	8113af4c <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ae64:	0005303a 	rdctl	r2,status
8113ae68:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ae6c:	e0fffc17 	ldw	r3,-16(fp)
8113ae70:	00bfff84 	movi	r2,-2
8113ae74:	1884703a 	and	r2,r3,r2
8113ae78:	1001703a 	wrctl	status,r2
  
  return context;
8113ae7c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ae80:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113ae84:	e0bffd03 	ldbu	r2,-12(fp)
8113ae88:	10803fd8 	cmpnei	r2,r2,255
8113ae8c:	1000031e 	bne	r2,zero,8113ae9c <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113ae90:	d0a09c17 	ldw	r2,-32144(gp)
8113ae94:	10800c83 	ldbu	r2,50(r2)
8113ae98:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113ae9c:	e0fffd03 	ldbu	r3,-12(fp)
8113aea0:	00a045b4 	movhi	r2,33046
8113aea4:	109b0304 	addi	r2,r2,27660
8113aea8:	18c7883a 	add	r3,r3,r3
8113aeac:	18c7883a 	add	r3,r3,r3
8113aeb0:	10c5883a 	add	r2,r2,r3
8113aeb4:	10800017 	ldw	r2,0(r2)
8113aeb8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113aebc:	e0bff817 	ldw	r2,-32(fp)
8113aec0:	1000091e 	bne	r2,zero,8113aee8 <OSTaskNameGet+0x128>
8113aec4:	e0bff617 	ldw	r2,-40(fp)
8113aec8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aecc:	e0bff717 	ldw	r2,-36(fp)
8113aed0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113aed4:	e0bfff17 	ldw	r2,-4(fp)
8113aed8:	00c010c4 	movi	r3,67
8113aedc:	10c00005 	stb	r3,0(r2)
        return (0);
8113aee0:	0005883a 	mov	r2,zero
8113aee4:	00001906 	br	8113af4c <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113aee8:	e0bff817 	ldw	r2,-32(fp)
8113aeec:	10800058 	cmpnei	r2,r2,1
8113aef0:	1000091e 	bne	r2,zero,8113af18 <OSTaskNameGet+0x158>
8113aef4:	e0bff617 	ldw	r2,-40(fp)
8113aef8:	e0bff915 	stw	r2,-28(fp)
8113aefc:	e0bff917 	ldw	r2,-28(fp)
8113af00:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113af04:	e0bfff17 	ldw	r2,-4(fp)
8113af08:	00c010c4 	movi	r3,67
8113af0c:	10c00005 	stb	r3,0(r2)
        return (0);
8113af10:	0005883a 	mov	r2,zero
8113af14:	00000d06 	br	8113af4c <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113af18:	e0bff817 	ldw	r2,-32(fp)
8113af1c:	10801304 	addi	r2,r2,76
8113af20:	100b883a 	mov	r5,r2
8113af24:	e13ffe17 	ldw	r4,-8(fp)
8113af28:	1134e1c0 	call	81134e1c <OS_StrCopy>
8113af2c:	e0bffb05 	stb	r2,-20(fp)
8113af30:	e0bff617 	ldw	r2,-40(fp)
8113af34:	e0bffa15 	stw	r2,-24(fp)
8113af38:	e0bffa17 	ldw	r2,-24(fp)
8113af3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113af40:	e0bfff17 	ldw	r2,-4(fp)
8113af44:	10000005 	stb	zero,0(r2)
    return (len);
8113af48:	e0bffb03 	ldbu	r2,-20(fp)
}
8113af4c:	e037883a 	mov	sp,fp
8113af50:	dfc00117 	ldw	ra,4(sp)
8113af54:	df000017 	ldw	fp,0(sp)
8113af58:	dec00204 	addi	sp,sp,8
8113af5c:	f800283a 	ret

8113af60 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113af60:	defff304 	addi	sp,sp,-52
8113af64:	de00012e 	bgeu	sp,et,8113af6c <OSTaskNameSet+0xc>
8113af68:	003b68fa 	trap	3
8113af6c:	dfc00c15 	stw	ra,48(sp)
8113af70:	df000b15 	stw	fp,44(sp)
8113af74:	df000b04 	addi	fp,sp,44
8113af78:	2005883a 	mov	r2,r4
8113af7c:	e17ffe15 	stw	r5,-8(fp)
8113af80:	e1bfff15 	stw	r6,-4(fp)
8113af84:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113af88:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113af8c:	e0bfff17 	ldw	r2,-4(fp)
8113af90:	10005c26 	beq	r2,zero,8113b104 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113af94:	e0bffd03 	ldbu	r2,-12(fp)
8113af98:	10800af0 	cmpltui	r2,r2,43
8113af9c:	1000071e 	bne	r2,zero,8113afbc <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113afa0:	e0bffd03 	ldbu	r2,-12(fp)
8113afa4:	10803fe0 	cmpeqi	r2,r2,255
8113afa8:	1000041e 	bne	r2,zero,8113afbc <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113afac:	e0bfff17 	ldw	r2,-4(fp)
8113afb0:	00c00a84 	movi	r3,42
8113afb4:	10c00005 	stb	r3,0(r2)
            return;
8113afb8:	00005306 	br	8113b108 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113afbc:	e0bffe17 	ldw	r2,-8(fp)
8113afc0:	1000041e 	bne	r2,zero,8113afd4 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113afc4:	e0bfff17 	ldw	r2,-4(fp)
8113afc8:	00c00304 	movi	r3,12
8113afcc:	10c00005 	stb	r3,0(r2)
        return;
8113afd0:	00004d06 	br	8113b108 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113afd4:	d0a09b03 	ldbu	r2,-32148(gp)
8113afd8:	10803fcc 	andi	r2,r2,255
8113afdc:	10000426 	beq	r2,zero,8113aff0 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113afe0:	e0bfff17 	ldw	r2,-4(fp)
8113afe4:	00c00484 	movi	r3,18
8113afe8:	10c00005 	stb	r3,0(r2)
        return;
8113afec:	00004606 	br	8113b108 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aff0:	0005303a 	rdctl	r2,status
8113aff4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aff8:	e0fffc17 	ldw	r3,-16(fp)
8113affc:	00bfff84 	movi	r2,-2
8113b000:	1884703a 	and	r2,r3,r2
8113b004:	1001703a 	wrctl	status,r2
  
  return context;
8113b008:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b00c:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113b010:	e0bffd03 	ldbu	r2,-12(fp)
8113b014:	10803fd8 	cmpnei	r2,r2,255
8113b018:	1000031e 	bne	r2,zero,8113b028 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113b01c:	d0a09c17 	ldw	r2,-32144(gp)
8113b020:	10800c83 	ldbu	r2,50(r2)
8113b024:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b028:	e0fffd03 	ldbu	r3,-12(fp)
8113b02c:	00a045b4 	movhi	r2,33046
8113b030:	109b0304 	addi	r2,r2,27660
8113b034:	18c7883a 	add	r3,r3,r3
8113b038:	18c7883a 	add	r3,r3,r3
8113b03c:	10c5883a 	add	r2,r2,r3
8113b040:	10800017 	ldw	r2,0(r2)
8113b044:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113b048:	e0bff717 	ldw	r2,-36(fp)
8113b04c:	1000081e 	bne	r2,zero,8113b070 <OSTaskNameSet+0x110>
8113b050:	e0bff517 	ldw	r2,-44(fp)
8113b054:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b058:	e0bff617 	ldw	r2,-40(fp)
8113b05c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113b060:	e0bfff17 	ldw	r2,-4(fp)
8113b064:	00c010c4 	movi	r3,67
8113b068:	10c00005 	stb	r3,0(r2)
        return;
8113b06c:	00002606 	br	8113b108 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113b070:	e0bff717 	ldw	r2,-36(fp)
8113b074:	10800058 	cmpnei	r2,r2,1
8113b078:	1000081e 	bne	r2,zero,8113b09c <OSTaskNameSet+0x13c>
8113b07c:	e0bff517 	ldw	r2,-44(fp)
8113b080:	e0bff815 	stw	r2,-32(fp)
8113b084:	e0bff817 	ldw	r2,-32(fp)
8113b088:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113b08c:	e0bfff17 	ldw	r2,-4(fp)
8113b090:	00c010c4 	movi	r3,67
8113b094:	10c00005 	stb	r3,0(r2)
        return;
8113b098:	00001b06 	br	8113b108 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113b09c:	e13ffe17 	ldw	r4,-8(fp)
8113b0a0:	1134e980 	call	81134e98 <OS_StrLen>
8113b0a4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113b0a8:	e0bffa03 	ldbu	r2,-24(fp)
8113b0ac:	10800830 	cmpltui	r2,r2,32
8113b0b0:	1000081e 	bne	r2,zero,8113b0d4 <OSTaskNameSet+0x174>
8113b0b4:	e0bff517 	ldw	r2,-44(fp)
8113b0b8:	e0bff915 	stw	r2,-28(fp)
8113b0bc:	e0bff917 	ldw	r2,-28(fp)
8113b0c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113b0c4:	e0bfff17 	ldw	r2,-4(fp)
8113b0c8:	00c01044 	movi	r3,65
8113b0cc:	10c00005 	stb	r3,0(r2)
        return;
8113b0d0:	00000d06 	br	8113b108 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113b0d4:	e0bff717 	ldw	r2,-36(fp)
8113b0d8:	10801304 	addi	r2,r2,76
8113b0dc:	e17ffe17 	ldw	r5,-8(fp)
8113b0e0:	1009883a 	mov	r4,r2
8113b0e4:	1134e1c0 	call	81134e1c <OS_StrCopy>
8113b0e8:	e0bff517 	ldw	r2,-44(fp)
8113b0ec:	e0bffb15 	stw	r2,-20(fp)
8113b0f0:	e0bffb17 	ldw	r2,-20(fp)
8113b0f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b0f8:	e0bfff17 	ldw	r2,-4(fp)
8113b0fc:	10000005 	stb	zero,0(r2)
8113b100:	00000106 	br	8113b108 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113b104:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113b108:	e037883a 	mov	sp,fp
8113b10c:	dfc00117 	ldw	ra,4(sp)
8113b110:	df000017 	ldw	fp,0(sp)
8113b114:	dec00204 	addi	sp,sp,8
8113b118:	f800283a 	ret

8113b11c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113b11c:	defff404 	addi	sp,sp,-48
8113b120:	de00012e 	bgeu	sp,et,8113b128 <OSTaskResume+0xc>
8113b124:	003b68fa 	trap	3
8113b128:	dfc00b15 	stw	ra,44(sp)
8113b12c:	df000a15 	stw	fp,40(sp)
8113b130:	df000a04 	addi	fp,sp,40
8113b134:	2005883a 	mov	r2,r4
8113b138:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113b13c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113b140:	e0bfff03 	ldbu	r2,-4(fp)
8113b144:	10800ab0 	cmpltui	r2,r2,42
8113b148:	1000021e 	bne	r2,zero,8113b154 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113b14c:	00800a84 	movi	r2,42
8113b150:	00006406 	br	8113b2e4 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b154:	0005303a 	rdctl	r2,status
8113b158:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b15c:	e0fffe17 	ldw	r3,-8(fp)
8113b160:	00bfff84 	movi	r2,-2
8113b164:	1884703a 	and	r2,r3,r2
8113b168:	1001703a 	wrctl	status,r2
  
  return context;
8113b16c:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b170:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113b174:	e0ffff03 	ldbu	r3,-4(fp)
8113b178:	00a045b4 	movhi	r2,33046
8113b17c:	109b0304 	addi	r2,r2,27660
8113b180:	18c7883a 	add	r3,r3,r3
8113b184:	18c7883a 	add	r3,r3,r3
8113b188:	10c5883a 	add	r2,r2,r3
8113b18c:	10800017 	ldw	r2,0(r2)
8113b190:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113b194:	e0bff817 	ldw	r2,-32(fp)
8113b198:	1000061e 	bne	r2,zero,8113b1b4 <OSTaskResume+0x98>
8113b19c:	e0bff617 	ldw	r2,-40(fp)
8113b1a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b1a4:	e0bff717 	ldw	r2,-36(fp)
8113b1a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113b1ac:	00801184 	movi	r2,70
8113b1b0:	00004c06 	br	8113b2e4 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113b1b4:	e0bff817 	ldw	r2,-32(fp)
8113b1b8:	10800058 	cmpnei	r2,r2,1
8113b1bc:	1000061e 	bne	r2,zero,8113b1d8 <OSTaskResume+0xbc>
8113b1c0:	e0bff617 	ldw	r2,-40(fp)
8113b1c4:	e0bff915 	stw	r2,-28(fp)
8113b1c8:	e0bff917 	ldw	r2,-28(fp)
8113b1cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b1d0:	008010c4 	movi	r2,67
8113b1d4:	00004306 	br	8113b2e4 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113b1d8:	e0bff817 	ldw	r2,-32(fp)
8113b1dc:	10800c03 	ldbu	r2,48(r2)
8113b1e0:	10803fcc 	andi	r2,r2,255
8113b1e4:	1080020c 	andi	r2,r2,8
8113b1e8:	10003926 	beq	r2,zero,8113b2d0 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113b1ec:	e0bff817 	ldw	r2,-32(fp)
8113b1f0:	10c00c03 	ldbu	r3,48(r2)
8113b1f4:	00bffdc4 	movi	r2,-9
8113b1f8:	1884703a 	and	r2,r3,r2
8113b1fc:	1007883a 	mov	r3,r2
8113b200:	e0bff817 	ldw	r2,-32(fp)
8113b204:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113b208:	e0bff817 	ldw	r2,-32(fp)
8113b20c:	10800c03 	ldbu	r2,48(r2)
8113b210:	10803fcc 	andi	r2,r2,255
8113b214:	1000281e 	bne	r2,zero,8113b2b8 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113b218:	e0bff817 	ldw	r2,-32(fp)
8113b21c:	10800b8b 	ldhu	r2,46(r2)
8113b220:	10bfffcc 	andi	r2,r2,65535
8113b224:	10001f1e 	bne	r2,zero,8113b2a4 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113b228:	e0bff817 	ldw	r2,-32(fp)
8113b22c:	10c00d83 	ldbu	r3,54(r2)
8113b230:	d0a09803 	ldbu	r2,-32160(gp)
8113b234:	1884b03a 	or	r2,r3,r2
8113b238:	d0a09805 	stb	r2,-32160(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b23c:	e0bff817 	ldw	r2,-32(fp)
8113b240:	10800d03 	ldbu	r2,52(r2)
8113b244:	10c03fcc 	andi	r3,r2,255
8113b248:	e0bff817 	ldw	r2,-32(fp)
8113b24c:	10800d03 	ldbu	r2,52(r2)
8113b250:	11003fcc 	andi	r4,r2,255
8113b254:	d0a09844 	addi	r2,gp,-32159
8113b258:	2085883a 	add	r2,r4,r2
8113b25c:	11000003 	ldbu	r4,0(r2)
8113b260:	e0bff817 	ldw	r2,-32(fp)
8113b264:	10800d43 	ldbu	r2,53(r2)
8113b268:	2084b03a 	or	r2,r4,r2
8113b26c:	1009883a 	mov	r4,r2
8113b270:	d0a09844 	addi	r2,gp,-32159
8113b274:	1885883a 	add	r2,r3,r2
8113b278:	11000005 	stb	r4,0(r2)
8113b27c:	e0bff617 	ldw	r2,-40(fp)
8113b280:	e0bffa15 	stw	r2,-24(fp)
8113b284:	e0bffa17 	ldw	r2,-24(fp)
8113b288:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113b28c:	d0a08b03 	ldbu	r2,-32212(gp)
8113b290:	10803fcc 	andi	r2,r2,255
8113b294:	10800058 	cmpnei	r2,r2,1
8113b298:	10000b1e 	bne	r2,zero,8113b2c8 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113b29c:	1134cc80 	call	81134cc8 <OS_Sched>
8113b2a0:	00000906 	br	8113b2c8 <OSTaskResume+0x1ac>
8113b2a4:	e0bff617 	ldw	r2,-40(fp)
8113b2a8:	e0bffb15 	stw	r2,-20(fp)
8113b2ac:	e0bffb17 	ldw	r2,-20(fp)
8113b2b0:	1001703a 	wrctl	status,r2
8113b2b4:	00000406 	br	8113b2c8 <OSTaskResume+0x1ac>
8113b2b8:	e0bff617 	ldw	r2,-40(fp)
8113b2bc:	e0bffc15 	stw	r2,-16(fp)
8113b2c0:	e0bffc17 	ldw	r2,-16(fp)
8113b2c4:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113b2c8:	0005883a 	mov	r2,zero
8113b2cc:	00000506 	br	8113b2e4 <OSTaskResume+0x1c8>
8113b2d0:	e0bff617 	ldw	r2,-40(fp)
8113b2d4:	e0bffd15 	stw	r2,-12(fp)
8113b2d8:	e0bffd17 	ldw	r2,-12(fp)
8113b2dc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113b2e0:	00801104 	movi	r2,68
}
8113b2e4:	e037883a 	mov	sp,fp
8113b2e8:	dfc00117 	ldw	ra,4(sp)
8113b2ec:	df000017 	ldw	fp,0(sp)
8113b2f0:	dec00204 	addi	sp,sp,8
8113b2f4:	f800283a 	ret

8113b2f8 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113b2f8:	defff304 	addi	sp,sp,-52
8113b2fc:	de00012e 	bgeu	sp,et,8113b304 <OSTaskStkChk+0xc>
8113b300:	003b68fa 	trap	3
8113b304:	df000c15 	stw	fp,48(sp)
8113b308:	df000c04 	addi	fp,sp,48
8113b30c:	2005883a 	mov	r2,r4
8113b310:	e17fff15 	stw	r5,-4(fp)
8113b314:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113b318:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113b31c:	e0bffe03 	ldbu	r2,-8(fp)
8113b320:	10800af0 	cmpltui	r2,r2,43
8113b324:	1000051e 	bne	r2,zero,8113b33c <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113b328:	e0bffe03 	ldbu	r2,-8(fp)
8113b32c:	10803fe0 	cmpeqi	r2,r2,255
8113b330:	1000021e 	bne	r2,zero,8113b33c <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113b334:	00800a84 	movi	r2,42
8113b338:	00005d06 	br	8113b4b0 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113b33c:	e0bfff17 	ldw	r2,-4(fp)
8113b340:	1000021e 	bne	r2,zero,8113b34c <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113b344:	00800244 	movi	r2,9
8113b348:	00005906 	br	8113b4b0 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113b34c:	e0bfff17 	ldw	r2,-4(fp)
8113b350:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113b354:	e0bfff17 	ldw	r2,-4(fp)
8113b358:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b35c:	0005303a 	rdctl	r2,status
8113b360:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b364:	e0fffd17 	ldw	r3,-12(fp)
8113b368:	00bfff84 	movi	r2,-2
8113b36c:	1884703a 	and	r2,r3,r2
8113b370:	1001703a 	wrctl	status,r2
  
  return context;
8113b374:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113b378:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113b37c:	e0bffe03 	ldbu	r2,-8(fp)
8113b380:	10803fd8 	cmpnei	r2,r2,255
8113b384:	1000031e 	bne	r2,zero,8113b394 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113b388:	d0a09c17 	ldw	r2,-32144(gp)
8113b38c:	10800c83 	ldbu	r2,50(r2)
8113b390:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b394:	e0fffe03 	ldbu	r3,-8(fp)
8113b398:	00a045b4 	movhi	r2,33046
8113b39c:	109b0304 	addi	r2,r2,27660
8113b3a0:	18c7883a 	add	r3,r3,r3
8113b3a4:	18c7883a 	add	r3,r3,r3
8113b3a8:	10c5883a 	add	r2,r2,r3
8113b3ac:	10800017 	ldw	r2,0(r2)
8113b3b0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113b3b4:	e0bff817 	ldw	r2,-32(fp)
8113b3b8:	1000061e 	bne	r2,zero,8113b3d4 <OSTaskStkChk+0xdc>
8113b3bc:	e0bff617 	ldw	r2,-40(fp)
8113b3c0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b3c4:	e0bff717 	ldw	r2,-36(fp)
8113b3c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b3cc:	008010c4 	movi	r2,67
8113b3d0:	00003706 	br	8113b4b0 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113b3d4:	e0bff817 	ldw	r2,-32(fp)
8113b3d8:	10800058 	cmpnei	r2,r2,1
8113b3dc:	1000061e 	bne	r2,zero,8113b3f8 <OSTaskStkChk+0x100>
8113b3e0:	e0bff617 	ldw	r2,-40(fp)
8113b3e4:	e0bff915 	stw	r2,-28(fp)
8113b3e8:	e0bff917 	ldw	r2,-28(fp)
8113b3ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b3f0:	008010c4 	movi	r2,67
8113b3f4:	00002e06 	br	8113b4b0 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113b3f8:	e0bff817 	ldw	r2,-32(fp)
8113b3fc:	1080040b 	ldhu	r2,16(r2)
8113b400:	10bfffcc 	andi	r2,r2,65535
8113b404:	1080004c 	andi	r2,r2,1
8113b408:	1000061e 	bne	r2,zero,8113b424 <OSTaskStkChk+0x12c>
8113b40c:	e0bff617 	ldw	r2,-40(fp)
8113b410:	e0bffa15 	stw	r2,-24(fp)
8113b414:	e0bffa17 	ldw	r2,-24(fp)
8113b418:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113b41c:	00801144 	movi	r2,69
8113b420:	00002306 	br	8113b4b0 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113b424:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113b428:	e0bff817 	ldw	r2,-32(fp)
8113b42c:	10800317 	ldw	r2,12(r2)
8113b430:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113b434:	e0bff817 	ldw	r2,-32(fp)
8113b438:	10800217 	ldw	r2,8(r2)
8113b43c:	e0bff415 	stw	r2,-48(fp)
8113b440:	e0bff617 	ldw	r2,-40(fp)
8113b444:	e0bffb15 	stw	r2,-20(fp)
8113b448:	e0bffb17 	ldw	r2,-20(fp)
8113b44c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113b450:	00000306 	br	8113b460 <OSTaskStkChk+0x168>
        nfree++;
8113b454:	e0bff517 	ldw	r2,-44(fp)
8113b458:	10800044 	addi	r2,r2,1
8113b45c:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113b460:	e0bff417 	ldw	r2,-48(fp)
8113b464:	10c00104 	addi	r3,r2,4
8113b468:	e0fff415 	stw	r3,-48(fp)
8113b46c:	10800017 	ldw	r2,0(r2)
8113b470:	103ff826 	beq	r2,zero,8113b454 <__reset+0xfb11b454>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113b474:	e0bff517 	ldw	r2,-44(fp)
8113b478:	1085883a 	add	r2,r2,r2
8113b47c:	1085883a 	add	r2,r2,r2
8113b480:	1007883a 	mov	r3,r2
8113b484:	e0bfff17 	ldw	r2,-4(fp)
8113b488:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113b48c:	e0fffc17 	ldw	r3,-16(fp)
8113b490:	e0bff517 	ldw	r2,-44(fp)
8113b494:	1885c83a 	sub	r2,r3,r2
8113b498:	1085883a 	add	r2,r2,r2
8113b49c:	1085883a 	add	r2,r2,r2
8113b4a0:	1007883a 	mov	r3,r2
8113b4a4:	e0bfff17 	ldw	r2,-4(fp)
8113b4a8:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113b4ac:	0005883a 	mov	r2,zero
}
8113b4b0:	e037883a 	mov	sp,fp
8113b4b4:	df000017 	ldw	fp,0(sp)
8113b4b8:	dec00104 	addi	sp,sp,4
8113b4bc:	f800283a 	ret

8113b4c0 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113b4c0:	defff504 	addi	sp,sp,-44
8113b4c4:	de00012e 	bgeu	sp,et,8113b4cc <OSTaskSuspend+0xc>
8113b4c8:	003b68fa 	trap	3
8113b4cc:	dfc00a15 	stw	ra,40(sp)
8113b4d0:	df000915 	stw	fp,36(sp)
8113b4d4:	df000904 	addi	fp,sp,36
8113b4d8:	2005883a 	mov	r2,r4
8113b4dc:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b4e0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113b4e4:	e0bfff03 	ldbu	r2,-4(fp)
8113b4e8:	10800a98 	cmpnei	r2,r2,42
8113b4ec:	1000021e 	bne	r2,zero,8113b4f8 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113b4f0:	008011c4 	movi	r2,71
8113b4f4:	00006806 	br	8113b698 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113b4f8:	e0bfff03 	ldbu	r2,-4(fp)
8113b4fc:	10800ab0 	cmpltui	r2,r2,42
8113b500:	1000051e 	bne	r2,zero,8113b518 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113b504:	e0bfff03 	ldbu	r2,-4(fp)
8113b508:	10803fe0 	cmpeqi	r2,r2,255
8113b50c:	1000021e 	bne	r2,zero,8113b518 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113b510:	00800a84 	movi	r2,42
8113b514:	00006006 	br	8113b698 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b518:	0005303a 	rdctl	r2,status
8113b51c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b520:	e0fffe17 	ldw	r3,-8(fp)
8113b524:	00bfff84 	movi	r2,-2
8113b528:	1884703a 	and	r2,r3,r2
8113b52c:	1001703a 	wrctl	status,r2
  
  return context;
8113b530:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113b534:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113b538:	e0bfff03 	ldbu	r2,-4(fp)
8113b53c:	10803fd8 	cmpnei	r2,r2,255
8113b540:	1000061e 	bne	r2,zero,8113b55c <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113b544:	d0a09c17 	ldw	r2,-32144(gp)
8113b548:	10800c83 	ldbu	r2,50(r2)
8113b54c:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113b550:	00800044 	movi	r2,1
8113b554:	e0bff705 	stb	r2,-36(fp)
8113b558:	00000906 	br	8113b580 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113b55c:	d0a09c17 	ldw	r2,-32144(gp)
8113b560:	10800c83 	ldbu	r2,50(r2)
8113b564:	10c03fcc 	andi	r3,r2,255
8113b568:	e0bfff03 	ldbu	r2,-4(fp)
8113b56c:	1880031e 	bne	r3,r2,8113b57c <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113b570:	00800044 	movi	r2,1
8113b574:	e0bff705 	stb	r2,-36(fp)
8113b578:	00000106 	br	8113b580 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113b57c:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b580:	e0ffff03 	ldbu	r3,-4(fp)
8113b584:	00a045b4 	movhi	r2,33046
8113b588:	109b0304 	addi	r2,r2,27660
8113b58c:	18c7883a 	add	r3,r3,r3
8113b590:	18c7883a 	add	r3,r3,r3
8113b594:	10c5883a 	add	r2,r2,r3
8113b598:	10800017 	ldw	r2,0(r2)
8113b59c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113b5a0:	e0bffa17 	ldw	r2,-24(fp)
8113b5a4:	1000061e 	bne	r2,zero,8113b5c0 <OSTaskSuspend+0x100>
8113b5a8:	e0bff817 	ldw	r2,-32(fp)
8113b5ac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b5b0:	e0bff917 	ldw	r2,-28(fp)
8113b5b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113b5b8:	00801204 	movi	r2,72
8113b5bc:	00003606 	br	8113b698 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113b5c0:	e0bffa17 	ldw	r2,-24(fp)
8113b5c4:	10800058 	cmpnei	r2,r2,1
8113b5c8:	1000061e 	bne	r2,zero,8113b5e4 <OSTaskSuspend+0x124>
8113b5cc:	e0bff817 	ldw	r2,-32(fp)
8113b5d0:	e0bffb15 	stw	r2,-20(fp)
8113b5d4:	e0bffb17 	ldw	r2,-20(fp)
8113b5d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b5dc:	008010c4 	movi	r2,67
8113b5e0:	00002d06 	br	8113b698 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113b5e4:	e0bffa17 	ldw	r2,-24(fp)
8113b5e8:	10800d03 	ldbu	r2,52(r2)
8113b5ec:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113b5f0:	e0fffd03 	ldbu	r3,-12(fp)
8113b5f4:	e13ffd03 	ldbu	r4,-12(fp)
8113b5f8:	d0a09844 	addi	r2,gp,-32159
8113b5fc:	2085883a 	add	r2,r4,r2
8113b600:	10800003 	ldbu	r2,0(r2)
8113b604:	1009883a 	mov	r4,r2
8113b608:	e0bffa17 	ldw	r2,-24(fp)
8113b60c:	10800d43 	ldbu	r2,53(r2)
8113b610:	0084303a 	nor	r2,zero,r2
8113b614:	2084703a 	and	r2,r4,r2
8113b618:	1009883a 	mov	r4,r2
8113b61c:	d0a09844 	addi	r2,gp,-32159
8113b620:	1885883a 	add	r2,r3,r2
8113b624:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113b628:	e0fffd03 	ldbu	r3,-12(fp)
8113b62c:	d0a09844 	addi	r2,gp,-32159
8113b630:	1885883a 	add	r2,r3,r2
8113b634:	10800003 	ldbu	r2,0(r2)
8113b638:	10803fcc 	andi	r2,r2,255
8113b63c:	1000071e 	bne	r2,zero,8113b65c <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113b640:	e0bffa17 	ldw	r2,-24(fp)
8113b644:	10800d83 	ldbu	r2,54(r2)
8113b648:	0084303a 	nor	r2,zero,r2
8113b64c:	1007883a 	mov	r3,r2
8113b650:	d0a09803 	ldbu	r2,-32160(gp)
8113b654:	1884703a 	and	r2,r3,r2
8113b658:	d0a09805 	stb	r2,-32160(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113b65c:	e0bffa17 	ldw	r2,-24(fp)
8113b660:	10800c03 	ldbu	r2,48(r2)
8113b664:	10800214 	ori	r2,r2,8
8113b668:	1007883a 	mov	r3,r2
8113b66c:	e0bffa17 	ldw	r2,-24(fp)
8113b670:	10c00c05 	stb	r3,48(r2)
8113b674:	e0bff817 	ldw	r2,-32(fp)
8113b678:	e0bffc15 	stw	r2,-16(fp)
8113b67c:	e0bffc17 	ldw	r2,-16(fp)
8113b680:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113b684:	e0bff703 	ldbu	r2,-36(fp)
8113b688:	10800058 	cmpnei	r2,r2,1
8113b68c:	1000011e 	bne	r2,zero,8113b694 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113b690:	1134cc80 	call	81134cc8 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113b694:	0005883a 	mov	r2,zero
}
8113b698:	e037883a 	mov	sp,fp
8113b69c:	dfc00117 	ldw	ra,4(sp)
8113b6a0:	df000017 	ldw	fp,0(sp)
8113b6a4:	dec00204 	addi	sp,sp,8
8113b6a8:	f800283a 	ret

8113b6ac <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113b6ac:	defff604 	addi	sp,sp,-40
8113b6b0:	de00012e 	bgeu	sp,et,8113b6b8 <OSTaskQuery+0xc>
8113b6b4:	003b68fa 	trap	3
8113b6b8:	dfc00915 	stw	ra,36(sp)
8113b6bc:	df000815 	stw	fp,32(sp)
8113b6c0:	df000804 	addi	fp,sp,32
8113b6c4:	2005883a 	mov	r2,r4
8113b6c8:	e17fff15 	stw	r5,-4(fp)
8113b6cc:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b6d0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113b6d4:	e0bffe03 	ldbu	r2,-8(fp)
8113b6d8:	10800af0 	cmpltui	r2,r2,43
8113b6dc:	1000051e 	bne	r2,zero,8113b6f4 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113b6e0:	e0bffe03 	ldbu	r2,-8(fp)
8113b6e4:	10803fe0 	cmpeqi	r2,r2,255
8113b6e8:	1000021e 	bne	r2,zero,8113b6f4 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113b6ec:	00800a84 	movi	r2,42
8113b6f0:	00003406 	br	8113b7c4 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113b6f4:	e0bfff17 	ldw	r2,-4(fp)
8113b6f8:	1000021e 	bne	r2,zero,8113b704 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113b6fc:	00800244 	movi	r2,9
8113b700:	00003006 	br	8113b7c4 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b704:	0005303a 	rdctl	r2,status
8113b708:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b70c:	e0fffd17 	ldw	r3,-12(fp)
8113b710:	00bfff84 	movi	r2,-2
8113b714:	1884703a 	and	r2,r3,r2
8113b718:	1001703a 	wrctl	status,r2
  
  return context;
8113b71c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b720:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113b724:	e0bffe03 	ldbu	r2,-8(fp)
8113b728:	10803fd8 	cmpnei	r2,r2,255
8113b72c:	1000031e 	bne	r2,zero,8113b73c <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113b730:	d0a09c17 	ldw	r2,-32144(gp)
8113b734:	10800c83 	ldbu	r2,50(r2)
8113b738:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113b73c:	e0fffe03 	ldbu	r3,-8(fp)
8113b740:	00a045b4 	movhi	r2,33046
8113b744:	109b0304 	addi	r2,r2,27660
8113b748:	18c7883a 	add	r3,r3,r3
8113b74c:	18c7883a 	add	r3,r3,r3
8113b750:	10c5883a 	add	r2,r2,r3
8113b754:	10800017 	ldw	r2,0(r2)
8113b758:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113b75c:	e0bffa17 	ldw	r2,-24(fp)
8113b760:	1000061e 	bne	r2,zero,8113b77c <OSTaskQuery+0xd0>
8113b764:	e0bff817 	ldw	r2,-32(fp)
8113b768:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b76c:	e0bff917 	ldw	r2,-28(fp)
8113b770:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113b774:	00800a44 	movi	r2,41
8113b778:	00001206 	br	8113b7c4 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113b77c:	e0bffa17 	ldw	r2,-24(fp)
8113b780:	10800058 	cmpnei	r2,r2,1
8113b784:	1000061e 	bne	r2,zero,8113b7a0 <OSTaskQuery+0xf4>
8113b788:	e0bff817 	ldw	r2,-32(fp)
8113b78c:	e0bffb15 	stw	r2,-20(fp)
8113b790:	e0bffb17 	ldw	r2,-20(fp)
8113b794:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113b798:	008010c4 	movi	r2,67
8113b79c:	00000906 	br	8113b7c4 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113b7a0:	01801b04 	movi	r6,108
8113b7a4:	e17ffa17 	ldw	r5,-24(fp)
8113b7a8:	e13fff17 	ldw	r4,-4(fp)
8113b7ac:	1134c580 	call	81134c58 <OS_MemCopy>
8113b7b0:	e0bff817 	ldw	r2,-32(fp)
8113b7b4:	e0bffc15 	stw	r2,-16(fp)
8113b7b8:	e0bffc17 	ldw	r2,-16(fp)
8113b7bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b7c0:	0005883a 	mov	r2,zero
}
8113b7c4:	e037883a 	mov	sp,fp
8113b7c8:	dfc00117 	ldw	ra,4(sp)
8113b7cc:	df000017 	ldw	fp,0(sp)
8113b7d0:	dec00204 	addi	sp,sp,8
8113b7d4:	f800283a 	ret

8113b7d8 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113b7d8:	defffc04 	addi	sp,sp,-16
8113b7dc:	de00012e 	bgeu	sp,et,8113b7e4 <OS_TaskStkClr+0xc>
8113b7e0:	003b68fa 	trap	3
8113b7e4:	df000315 	stw	fp,12(sp)
8113b7e8:	df000304 	addi	fp,sp,12
8113b7ec:	e13ffd15 	stw	r4,-12(fp)
8113b7f0:	e17ffe15 	stw	r5,-8(fp)
8113b7f4:	3005883a 	mov	r2,r6
8113b7f8:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113b7fc:	e0bfff0b 	ldhu	r2,-4(fp)
8113b800:	1080004c 	andi	r2,r2,1
8113b804:	10000d26 	beq	r2,zero,8113b83c <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113b808:	e0bfff0b 	ldhu	r2,-4(fp)
8113b80c:	1080008c 	andi	r2,r2,2
8113b810:	10000a26 	beq	r2,zero,8113b83c <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113b814:	00000706 	br	8113b834 <OS_TaskStkClr+0x5c>
                size--;
8113b818:	e0bffe17 	ldw	r2,-8(fp)
8113b81c:	10bfffc4 	addi	r2,r2,-1
8113b820:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113b824:	e0bffd17 	ldw	r2,-12(fp)
8113b828:	10c00104 	addi	r3,r2,4
8113b82c:	e0fffd15 	stw	r3,-12(fp)
8113b830:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113b834:	e0bffe17 	ldw	r2,-8(fp)
8113b838:	103ff71e 	bne	r2,zero,8113b818 <__reset+0xfb11b818>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113b83c:	0001883a 	nop
8113b840:	e037883a 	mov	sp,fp
8113b844:	df000017 	ldw	fp,0(sp)
8113b848:	dec00104 	addi	sp,sp,4
8113b84c:	f800283a 	ret

8113b850 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113b850:	defff904 	addi	sp,sp,-28
8113b854:	de00012e 	bgeu	sp,et,8113b85c <OSTimeDly+0xc>
8113b858:	003b68fa 	trap	3
8113b85c:	dfc00615 	stw	ra,24(sp)
8113b860:	df000515 	stw	fp,20(sp)
8113b864:	df000504 	addi	fp,sp,20
8113b868:	2005883a 	mov	r2,r4
8113b86c:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b870:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b874:	d0a09b03 	ldbu	r2,-32148(gp)
8113b878:	10803fcc 	andi	r2,r2,255
8113b87c:	1000311e 	bne	r2,zero,8113b944 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113b880:	e0bfff0b 	ldhu	r2,-4(fp)
8113b884:	10003026 	beq	r2,zero,8113b948 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b888:	0005303a 	rdctl	r2,status
8113b88c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b890:	e0fffe17 	ldw	r3,-8(fp)
8113b894:	00bfff84 	movi	r2,-2
8113b898:	1884703a 	and	r2,r3,r2
8113b89c:	1001703a 	wrctl	status,r2
  
  return context;
8113b8a0:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113b8a4:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113b8a8:	d0a09c17 	ldw	r2,-32144(gp)
8113b8ac:	10800d03 	ldbu	r2,52(r2)
8113b8b0:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113b8b4:	e0fffd03 	ldbu	r3,-12(fp)
8113b8b8:	e13ffd03 	ldbu	r4,-12(fp)
8113b8bc:	d0a09844 	addi	r2,gp,-32159
8113b8c0:	2085883a 	add	r2,r4,r2
8113b8c4:	10800003 	ldbu	r2,0(r2)
8113b8c8:	1009883a 	mov	r4,r2
8113b8cc:	d0a09c17 	ldw	r2,-32144(gp)
8113b8d0:	10800d43 	ldbu	r2,53(r2)
8113b8d4:	0084303a 	nor	r2,zero,r2
8113b8d8:	2084703a 	and	r2,r4,r2
8113b8dc:	1009883a 	mov	r4,r2
8113b8e0:	d0a09844 	addi	r2,gp,-32159
8113b8e4:	1885883a 	add	r2,r3,r2
8113b8e8:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113b8ec:	e0fffd03 	ldbu	r3,-12(fp)
8113b8f0:	d0a09844 	addi	r2,gp,-32159
8113b8f4:	1885883a 	add	r2,r3,r2
8113b8f8:	10800003 	ldbu	r2,0(r2)
8113b8fc:	10803fcc 	andi	r2,r2,255
8113b900:	1000071e 	bne	r2,zero,8113b920 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113b904:	d0a09c17 	ldw	r2,-32144(gp)
8113b908:	10800d83 	ldbu	r2,54(r2)
8113b90c:	0084303a 	nor	r2,zero,r2
8113b910:	1007883a 	mov	r3,r2
8113b914:	d0a09803 	ldbu	r2,-32160(gp)
8113b918:	1884703a 	and	r2,r3,r2
8113b91c:	d0a09805 	stb	r2,-32160(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113b920:	d0a09c17 	ldw	r2,-32144(gp)
8113b924:	e0ffff0b 	ldhu	r3,-4(fp)
8113b928:	10c00b8d 	sth	r3,46(r2)
8113b92c:	e0bffb17 	ldw	r2,-20(fp)
8113b930:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b934:	e0bffc17 	ldw	r2,-16(fp)
8113b938:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113b93c:	1134cc80 	call	81134cc8 <OS_Sched>
8113b940:	00000106 	br	8113b948 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113b944:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113b948:	e037883a 	mov	sp,fp
8113b94c:	dfc00117 	ldw	ra,4(sp)
8113b950:	df000017 	ldw	fp,0(sp)
8113b954:	dec00204 	addi	sp,sp,8
8113b958:	f800283a 	ret

8113b95c <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113b95c:	defff804 	addi	sp,sp,-32
8113b960:	de00012e 	bgeu	sp,et,8113b968 <OSTimeDlyHMSM+0xc>
8113b964:	003b68fa 	trap	3
8113b968:	dfc00715 	stw	ra,28(sp)
8113b96c:	df000615 	stw	fp,24(sp)
8113b970:	df000604 	addi	fp,sp,24
8113b974:	2015883a 	mov	r10,r4
8113b978:	2809883a 	mov	r4,r5
8113b97c:	3007883a 	mov	r3,r6
8113b980:	3805883a 	mov	r2,r7
8113b984:	e2bffc05 	stb	r10,-16(fp)
8113b988:	e13ffd05 	stb	r4,-12(fp)
8113b98c:	e0fffe05 	stb	r3,-8(fp)
8113b990:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b994:	d0a09b03 	ldbu	r2,-32148(gp)
8113b998:	10803fcc 	andi	r2,r2,255
8113b99c:	10000226 	beq	r2,zero,8113b9a8 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113b9a0:	00801544 	movi	r2,85
8113b9a4:	00004106 	br	8113baac <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113b9a8:	e0bffc03 	ldbu	r2,-16(fp)
8113b9ac:	1000081e 	bne	r2,zero,8113b9d0 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113b9b0:	e0bffd03 	ldbu	r2,-12(fp)
8113b9b4:	1000061e 	bne	r2,zero,8113b9d0 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113b9b8:	e0bffe03 	ldbu	r2,-8(fp)
8113b9bc:	1000041e 	bne	r2,zero,8113b9d0 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113b9c0:	e0bfff0b 	ldhu	r2,-4(fp)
8113b9c4:	1000021e 	bne	r2,zero,8113b9d0 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113b9c8:	00801504 	movi	r2,84
8113b9cc:	00003706 	br	8113baac <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113b9d0:	e0bffd03 	ldbu	r2,-12(fp)
8113b9d4:	10800f30 	cmpltui	r2,r2,60
8113b9d8:	1000021e 	bne	r2,zero,8113b9e4 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113b9dc:	00801444 	movi	r2,81
8113b9e0:	00003206 	br	8113baac <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113b9e4:	e0bffe03 	ldbu	r2,-8(fp)
8113b9e8:	10800f30 	cmpltui	r2,r2,60
8113b9ec:	1000021e 	bne	r2,zero,8113b9f8 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113b9f0:	00801484 	movi	r2,82
8113b9f4:	00002d06 	br	8113baac <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113b9f8:	e0bfff0b 	ldhu	r2,-4(fp)
8113b9fc:	1080fa30 	cmpltui	r2,r2,1000
8113ba00:	1000021e 	bne	r2,zero,8113ba0c <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113ba04:	008014c4 	movi	r2,83
8113ba08:	00002806 	br	8113baac <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113ba0c:	e0bffc03 	ldbu	r2,-16(fp)
8113ba10:	10c38424 	muli	r3,r2,3600
8113ba14:	e0bffd03 	ldbu	r2,-12(fp)
8113ba18:	10800f24 	muli	r2,r2,60
8113ba1c:	1887883a 	add	r3,r3,r2
8113ba20:	e0bffe03 	ldbu	r2,-8(fp)
8113ba24:	1885883a 	add	r2,r3,r2
8113ba28:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113ba2c:	e0bfff0b 	ldhu	r2,-4(fp)
8113ba30:	10c0fa24 	muli	r3,r2,1000
8113ba34:	008418b4 	movhi	r2,4194
8113ba38:	109374c4 	addi	r2,r2,19923
8113ba3c:	188a383a 	mulxuu	r5,r3,r2
8113ba40:	1885383a 	mul	r2,r3,r2
8113ba44:	1011883a 	mov	r8,r2
8113ba48:	2813883a 	mov	r9,r5
8113ba4c:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113ba50:	2085883a 	add	r2,r4,r2
8113ba54:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113ba58:	e0bffb17 	ldw	r2,-20(fp)
8113ba5c:	1004d43a 	srli	r2,r2,16
8113ba60:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113ba64:	e0bffb17 	ldw	r2,-20(fp)
8113ba68:	10bfffcc 	andi	r2,r2,65535
8113ba6c:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113ba70:	e0bffb17 	ldw	r2,-20(fp)
8113ba74:	10bfffcc 	andi	r2,r2,65535
8113ba78:	1009883a 	mov	r4,r2
8113ba7c:	113b8500 	call	8113b850 <OSTimeDly>
    while (loops > 0) {
8113ba80:	00000706 	br	8113baa0 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113ba84:	01200014 	movui	r4,32768
8113ba88:	113b8500 	call	8113b850 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113ba8c:	01200014 	movui	r4,32768
8113ba90:	113b8500 	call	8113b850 <OSTimeDly>
        loops--;
8113ba94:	e0bffa0b 	ldhu	r2,-24(fp)
8113ba98:	10bfffc4 	addi	r2,r2,-1
8113ba9c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113baa0:	e0bffa0b 	ldhu	r2,-24(fp)
8113baa4:	103ff71e 	bne	r2,zero,8113ba84 <__reset+0xfb11ba84>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113baa8:	0005883a 	mov	r2,zero
}
8113baac:	e037883a 	mov	sp,fp
8113bab0:	dfc00117 	ldw	ra,4(sp)
8113bab4:	df000017 	ldw	fp,0(sp)
8113bab8:	dec00204 	addi	sp,sp,8
8113babc:	f800283a 	ret

8113bac0 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113bac0:	defff504 	addi	sp,sp,-44
8113bac4:	de00012e 	bgeu	sp,et,8113bacc <OSTimeDlyResume+0xc>
8113bac8:	003b68fa 	trap	3
8113bacc:	dfc00a15 	stw	ra,40(sp)
8113bad0:	df000915 	stw	fp,36(sp)
8113bad4:	df000904 	addi	fp,sp,36
8113bad8:	2005883a 	mov	r2,r4
8113badc:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113bae0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113bae4:	e0bfff03 	ldbu	r2,-4(fp)
8113bae8:	10800ab0 	cmpltui	r2,r2,42
8113baec:	1000021e 	bne	r2,zero,8113baf8 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113baf0:	00800a84 	movi	r2,42
8113baf4:	00006406 	br	8113bc88 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113baf8:	0005303a 	rdctl	r2,status
8113bafc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bb00:	e0fffe17 	ldw	r3,-8(fp)
8113bb04:	00bfff84 	movi	r2,-2
8113bb08:	1884703a 	and	r2,r3,r2
8113bb0c:	1001703a 	wrctl	status,r2
  
  return context;
8113bb10:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113bb14:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113bb18:	e0ffff03 	ldbu	r3,-4(fp)
8113bb1c:	00a045b4 	movhi	r2,33046
8113bb20:	109b0304 	addi	r2,r2,27660
8113bb24:	18c7883a 	add	r3,r3,r3
8113bb28:	18c7883a 	add	r3,r3,r3
8113bb2c:	10c5883a 	add	r2,r2,r3
8113bb30:	10800017 	ldw	r2,0(r2)
8113bb34:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113bb38:	e0bff917 	ldw	r2,-28(fp)
8113bb3c:	1000061e 	bne	r2,zero,8113bb58 <OSTimeDlyResume+0x98>
8113bb40:	e0bff717 	ldw	r2,-36(fp)
8113bb44:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb48:	e0bff817 	ldw	r2,-32(fp)
8113bb4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113bb50:	008010c4 	movi	r2,67
8113bb54:	00004c06 	br	8113bc88 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113bb58:	e0bff917 	ldw	r2,-28(fp)
8113bb5c:	10800058 	cmpnei	r2,r2,1
8113bb60:	1000061e 	bne	r2,zero,8113bb7c <OSTimeDlyResume+0xbc>
8113bb64:	e0bff717 	ldw	r2,-36(fp)
8113bb68:	e0bffa15 	stw	r2,-24(fp)
8113bb6c:	e0bffa17 	ldw	r2,-24(fp)
8113bb70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113bb74:	008010c4 	movi	r2,67
8113bb78:	00004306 	br	8113bc88 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113bb7c:	e0bff917 	ldw	r2,-28(fp)
8113bb80:	10800b8b 	ldhu	r2,46(r2)
8113bb84:	10bfffcc 	andi	r2,r2,65535
8113bb88:	1000061e 	bne	r2,zero,8113bba4 <OSTimeDlyResume+0xe4>
8113bb8c:	e0bff717 	ldw	r2,-36(fp)
8113bb90:	e0bffb15 	stw	r2,-20(fp)
8113bb94:	e0bffb17 	ldw	r2,-20(fp)
8113bb98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113bb9c:	00801404 	movi	r2,80
8113bba0:	00003906 	br	8113bc88 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113bba4:	e0bff917 	ldw	r2,-28(fp)
8113bba8:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113bbac:	e0bff917 	ldw	r2,-28(fp)
8113bbb0:	10800c03 	ldbu	r2,48(r2)
8113bbb4:	10803fcc 	andi	r2,r2,255
8113bbb8:	10800dcc 	andi	r2,r2,55
8113bbbc:	10000b26 	beq	r2,zero,8113bbec <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113bbc0:	e0bff917 	ldw	r2,-28(fp)
8113bbc4:	10c00c03 	ldbu	r3,48(r2)
8113bbc8:	00bff204 	movi	r2,-56
8113bbcc:	1884703a 	and	r2,r3,r2
8113bbd0:	1007883a 	mov	r3,r2
8113bbd4:	e0bff917 	ldw	r2,-28(fp)
8113bbd8:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113bbdc:	e0bff917 	ldw	r2,-28(fp)
8113bbe0:	00c00044 	movi	r3,1
8113bbe4:	10c00c45 	stb	r3,49(r2)
8113bbe8:	00000206 	br	8113bbf4 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113bbec:	e0bff917 	ldw	r2,-28(fp)
8113bbf0:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113bbf4:	e0bff917 	ldw	r2,-28(fp)
8113bbf8:	10800c03 	ldbu	r2,48(r2)
8113bbfc:	10803fcc 	andi	r2,r2,255
8113bc00:	1080020c 	andi	r2,r2,8
8113bc04:	10001b1e 	bne	r2,zero,8113bc74 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113bc08:	e0bff917 	ldw	r2,-28(fp)
8113bc0c:	10c00d83 	ldbu	r3,54(r2)
8113bc10:	d0a09803 	ldbu	r2,-32160(gp)
8113bc14:	1884b03a 	or	r2,r3,r2
8113bc18:	d0a09805 	stb	r2,-32160(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113bc1c:	e0bff917 	ldw	r2,-28(fp)
8113bc20:	10800d03 	ldbu	r2,52(r2)
8113bc24:	10c03fcc 	andi	r3,r2,255
8113bc28:	e0bff917 	ldw	r2,-28(fp)
8113bc2c:	10800d03 	ldbu	r2,52(r2)
8113bc30:	11003fcc 	andi	r4,r2,255
8113bc34:	d0a09844 	addi	r2,gp,-32159
8113bc38:	2085883a 	add	r2,r4,r2
8113bc3c:	11000003 	ldbu	r4,0(r2)
8113bc40:	e0bff917 	ldw	r2,-28(fp)
8113bc44:	10800d43 	ldbu	r2,53(r2)
8113bc48:	2084b03a 	or	r2,r4,r2
8113bc4c:	1009883a 	mov	r4,r2
8113bc50:	d0a09844 	addi	r2,gp,-32159
8113bc54:	1885883a 	add	r2,r3,r2
8113bc58:	11000005 	stb	r4,0(r2)
8113bc5c:	e0bff717 	ldw	r2,-36(fp)
8113bc60:	e0bffc15 	stw	r2,-16(fp)
8113bc64:	e0bffc17 	ldw	r2,-16(fp)
8113bc68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113bc6c:	1134cc80 	call	81134cc8 <OS_Sched>
8113bc70:	00000406 	br	8113bc84 <OSTimeDlyResume+0x1c4>
8113bc74:	e0bff717 	ldw	r2,-36(fp)
8113bc78:	e0bffd15 	stw	r2,-12(fp)
8113bc7c:	e0bffd17 	ldw	r2,-12(fp)
8113bc80:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113bc84:	0005883a 	mov	r2,zero
}
8113bc88:	e037883a 	mov	sp,fp
8113bc8c:	dfc00117 	ldw	ra,4(sp)
8113bc90:	df000017 	ldw	fp,0(sp)
8113bc94:	dec00204 	addi	sp,sp,8
8113bc98:	f800283a 	ret

8113bc9c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113bc9c:	defffb04 	addi	sp,sp,-20
8113bca0:	de00012e 	bgeu	sp,et,8113bca8 <OSTimeGet+0xc>
8113bca4:	003b68fa 	trap	3
8113bca8:	df000415 	stw	fp,16(sp)
8113bcac:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bcb0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bcb4:	0005303a 	rdctl	r2,status
8113bcb8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bcbc:	e0fffe17 	ldw	r3,-8(fp)
8113bcc0:	00bfff84 	movi	r2,-2
8113bcc4:	1884703a 	and	r2,r3,r2
8113bcc8:	1001703a 	wrctl	status,r2
  
  return context;
8113bccc:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113bcd0:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113bcd4:	d0a09e17 	ldw	r2,-32136(gp)
8113bcd8:	e0bffd15 	stw	r2,-12(fp)
8113bcdc:	e0bffc17 	ldw	r2,-16(fp)
8113bce0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bce4:	e0bfff17 	ldw	r2,-4(fp)
8113bce8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113bcec:	e0bffd17 	ldw	r2,-12(fp)
}
8113bcf0:	e037883a 	mov	sp,fp
8113bcf4:	df000017 	ldw	fp,0(sp)
8113bcf8:	dec00104 	addi	sp,sp,4
8113bcfc:	f800283a 	ret

8113bd00 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113bd00:	defffb04 	addi	sp,sp,-20
8113bd04:	de00012e 	bgeu	sp,et,8113bd0c <OSTimeSet+0xc>
8113bd08:	003b68fa 	trap	3
8113bd0c:	df000415 	stw	fp,16(sp)
8113bd10:	df000404 	addi	fp,sp,16
8113bd14:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bd18:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bd1c:	0005303a 	rdctl	r2,status
8113bd20:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd24:	e0fffd17 	ldw	r3,-12(fp)
8113bd28:	00bfff84 	movi	r2,-2
8113bd2c:	1884703a 	and	r2,r3,r2
8113bd30:	1001703a 	wrctl	status,r2
  
  return context;
8113bd34:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113bd38:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113bd3c:	e0bfff17 	ldw	r2,-4(fp)
8113bd40:	d0a09e15 	stw	r2,-32136(gp)
8113bd44:	e0bffc17 	ldw	r2,-16(fp)
8113bd48:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd4c:	e0bffe17 	ldw	r2,-8(fp)
8113bd50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113bd54:	0001883a 	nop
8113bd58:	e037883a 	mov	sp,fp
8113bd5c:	df000017 	ldw	fp,0(sp)
8113bd60:	dec00104 	addi	sp,sp,4
8113bd64:	f800283a 	ret

8113bd68 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113bd68:	defff804 	addi	sp,sp,-32
8113bd6c:	de00012e 	bgeu	sp,et,8113bd74 <OSTmrCreate+0xc>
8113bd70:	003b68fa 	trap	3
8113bd74:	dfc00715 	stw	ra,28(sp)
8113bd78:	df000615 	stw	fp,24(sp)
8113bd7c:	df000604 	addi	fp,sp,24
8113bd80:	e13ffc15 	stw	r4,-16(fp)
8113bd84:	e17ffd15 	stw	r5,-12(fp)
8113bd88:	3005883a 	mov	r2,r6
8113bd8c:	e1ffff15 	stw	r7,-4(fp)
8113bd90:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113bd94:	e0800417 	ldw	r2,16(fp)
8113bd98:	1000021e 	bne	r2,zero,8113bda4 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113bd9c:	0005883a 	mov	r2,zero
8113bda0:	00005d06 	br	8113bf18 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113bda4:	e0bffe03 	ldbu	r2,-8(fp)
8113bda8:	10c00060 	cmpeqi	r3,r2,1
8113bdac:	1800091e 	bne	r3,zero,8113bdd4 <OSTmrCreate+0x6c>
8113bdb0:	108000a0 	cmpeqi	r2,r2,2
8113bdb4:	10000e26 	beq	r2,zero,8113bdf0 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113bdb8:	e0bffd17 	ldw	r2,-12(fp)
8113bdbc:	1000111e 	bne	r2,zero,8113be04 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113bdc0:	e0800417 	ldw	r2,16(fp)
8113bdc4:	00ffe0c4 	movi	r3,-125
8113bdc8:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113bdcc:	0005883a 	mov	r2,zero
8113bdd0:	00005106 	br	8113bf18 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113bdd4:	e0bffc17 	ldw	r2,-16(fp)
8113bdd8:	10000c1e 	bne	r2,zero,8113be0c <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113bddc:	e0800417 	ldw	r2,16(fp)
8113bde0:	00ffe084 	movi	r3,-126
8113bde4:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113bde8:	0005883a 	mov	r2,zero
8113bdec:	00004a06 	br	8113bf18 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113bdf0:	e0800417 	ldw	r2,16(fp)
8113bdf4:	00ffe104 	movi	r3,-124
8113bdf8:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113bdfc:	0005883a 	mov	r2,zero
8113be00:	00004506 	br	8113bf18 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113be04:	0001883a 	nop
8113be08:	00000106 	br	8113be10 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113be0c:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113be10:	d0a09b03 	ldbu	r2,-32148(gp)
8113be14:	10803fcc 	andi	r2,r2,255
8113be18:	10000526 	beq	r2,zero,8113be30 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113be1c:	e0800417 	ldw	r2,16(fp)
8113be20:	00ffe2c4 	movi	r3,-117
8113be24:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113be28:	0005883a 	mov	r2,zero
8113be2c:	00003a06 	br	8113bf18 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113be30:	113cd200 	call	8113cd20 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113be34:	113c7c00 	call	8113c7c0 <OSTmr_Alloc>
8113be38:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113be3c:	e0bffa17 	ldw	r2,-24(fp)
8113be40:	1000061e 	bne	r2,zero,8113be5c <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113be44:	113cd640 	call	8113cd64 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113be48:	e0800417 	ldw	r2,16(fp)
8113be4c:	00ffe184 	movi	r3,-122
8113be50:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113be54:	0005883a 	mov	r2,zero
8113be58:	00002f06 	br	8113bf18 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113be5c:	e0bffa17 	ldw	r2,-24(fp)
8113be60:	00c00044 	movi	r3,1
8113be64:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113be68:	e0bffa17 	ldw	r2,-24(fp)
8113be6c:	e0fffc17 	ldw	r3,-16(fp)
8113be70:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113be74:	e0bffa17 	ldw	r2,-24(fp)
8113be78:	e0fffd17 	ldw	r3,-12(fp)
8113be7c:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113be80:	e0bffa17 	ldw	r2,-24(fp)
8113be84:	e0fffe03 	ldbu	r3,-8(fp)
8113be88:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113be8c:	e0bffa17 	ldw	r2,-24(fp)
8113be90:	e0ffff17 	ldw	r3,-4(fp)
8113be94:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113be98:	e0bffa17 	ldw	r2,-24(fp)
8113be9c:	e0c00217 	ldw	r3,8(fp)
8113bea0:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113bea4:	e0800317 	ldw	r2,12(fp)
8113bea8:	10001726 	beq	r2,zero,8113bf08 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113beac:	e1000317 	ldw	r4,12(fp)
8113beb0:	1134e980 	call	81134e98 <OS_StrLen>
8113beb4:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113beb8:	e0bffb03 	ldbu	r2,-20(fp)
8113bebc:	10800428 	cmpgeui	r2,r2,16
8113bec0:	1000061e 	bne	r2,zero,8113bedc <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113bec4:	e0bffa17 	ldw	r2,-24(fp)
8113bec8:	10800804 	addi	r2,r2,32
8113becc:	e1400317 	ldw	r5,12(fp)
8113bed0:	1009883a 	mov	r4,r2
8113bed4:	1134e1c0 	call	81134e1c <OS_StrCopy>
8113bed8:	00000b06 	br	8113bf08 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113bedc:	e0bffa17 	ldw	r2,-24(fp)
8113bee0:	00c008c4 	movi	r3,35
8113bee4:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113bee8:	e0bffa17 	ldw	r2,-24(fp)
8113beec:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113bef0:	e0800417 	ldw	r2,16(fp)
8113bef4:	00ffe304 	movi	r3,-116
8113bef8:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113befc:	113cd640 	call	8113cd64 <OSTmr_Unlock>
            return (ptmr);
8113bf00:	e0bffa17 	ldw	r2,-24(fp)
8113bf04:	00000406 	br	8113bf18 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113bf08:	113cd640 	call	8113cd64 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113bf0c:	e0800417 	ldw	r2,16(fp)
8113bf10:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113bf14:	e0bffa17 	ldw	r2,-24(fp)
}
8113bf18:	e037883a 	mov	sp,fp
8113bf1c:	dfc00117 	ldw	ra,4(sp)
8113bf20:	df000017 	ldw	fp,0(sp)
8113bf24:	dec00204 	addi	sp,sp,8
8113bf28:	f800283a 	ret

8113bf2c <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113bf2c:	defffc04 	addi	sp,sp,-16
8113bf30:	de00012e 	bgeu	sp,et,8113bf38 <OSTmrDel+0xc>
8113bf34:	003b68fa 	trap	3
8113bf38:	dfc00315 	stw	ra,12(sp)
8113bf3c:	df000215 	stw	fp,8(sp)
8113bf40:	df000204 	addi	fp,sp,8
8113bf44:	e13ffe15 	stw	r4,-8(fp)
8113bf48:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113bf4c:	e0bfff17 	ldw	r2,-4(fp)
8113bf50:	1000021e 	bne	r2,zero,8113bf5c <OSTmrDel+0x30>
        return (OS_FALSE);
8113bf54:	0005883a 	mov	r2,zero
8113bf58:	00003f06 	br	8113c058 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113bf5c:	e0bffe17 	ldw	r2,-8(fp)
8113bf60:	1000051e 	bne	r2,zero,8113bf78 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113bf64:	e0bfff17 	ldw	r2,-4(fp)
8113bf68:	00ffe284 	movi	r3,-118
8113bf6c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bf70:	0005883a 	mov	r2,zero
8113bf74:	00003806 	br	8113c058 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113bf78:	e0bffe17 	ldw	r2,-8(fp)
8113bf7c:	10800003 	ldbu	r2,0(r2)
8113bf80:	10803fcc 	andi	r2,r2,255
8113bf84:	10801920 	cmpeqi	r2,r2,100
8113bf88:	1000051e 	bne	r2,zero,8113bfa0 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113bf8c:	e0bfff17 	ldw	r2,-4(fp)
8113bf90:	00ffe244 	movi	r3,-119
8113bf94:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bf98:	0005883a 	mov	r2,zero
8113bf9c:	00002e06 	br	8113c058 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113bfa0:	d0a09b03 	ldbu	r2,-32148(gp)
8113bfa4:	10803fcc 	andi	r2,r2,255
8113bfa8:	10000526 	beq	r2,zero,8113bfc0 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113bfac:	e0bfff17 	ldw	r2,-4(fp)
8113bfb0:	00ffe2c4 	movi	r3,-117
8113bfb4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113bfb8:	0005883a 	mov	r2,zero
8113bfbc:	00002606 	br	8113c058 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113bfc0:	113cd200 	call	8113cd20 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113bfc4:	e0bffe17 	ldw	r2,-8(fp)
8113bfc8:	10800c43 	ldbu	r2,49(r2)
8113bfcc:	10803fcc 	andi	r2,r2,255
8113bfd0:	10c000c8 	cmpgei	r3,r2,3
8113bfd4:	1800031e 	bne	r3,zero,8113bfe4 <OSTmrDel+0xb8>
8113bfd8:	00800d16 	blt	zero,r2,8113c010 <OSTmrDel+0xe4>
8113bfdc:	10001326 	beq	r2,zero,8113c02c <OSTmrDel+0x100>
8113bfe0:	00001806 	br	8113c044 <OSTmrDel+0x118>
8113bfe4:	108000e0 	cmpeqi	r2,r2,3
8113bfe8:	10001626 	beq	r2,zero,8113c044 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113bfec:	e13ffe17 	ldw	r4,-8(fp)
8113bff0:	113cc240 	call	8113cc24 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113bff4:	e13ffe17 	ldw	r4,-8(fp)
8113bff8:	113c8340 	call	8113c834 <OSTmr_Free>
             OSTmr_Unlock();
8113bffc:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c000:	e0bfff17 	ldw	r2,-4(fp)
8113c004:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113c008:	00800044 	movi	r2,1
8113c00c:	00001206 	br	8113c058 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113c010:	e13ffe17 	ldw	r4,-8(fp)
8113c014:	113c8340 	call	8113c834 <OSTmr_Free>
             OSTmr_Unlock();
8113c018:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c01c:	e0bfff17 	ldw	r2,-4(fp)
8113c020:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113c024:	00800044 	movi	r2,1
8113c028:	00000b06 	br	8113c058 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113c02c:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c030:	e0bfff17 	ldw	r2,-4(fp)
8113c034:	00ffe1c4 	movi	r3,-121
8113c038:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c03c:	0005883a 	mov	r2,zero
8113c040:	00000506 	br	8113c058 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113c044:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c048:	e0bfff17 	ldw	r2,-4(fp)
8113c04c:	00ffe344 	movi	r3,-115
8113c050:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c054:	0005883a 	mov	r2,zero
    }
}
8113c058:	e037883a 	mov	sp,fp
8113c05c:	dfc00117 	ldw	ra,4(sp)
8113c060:	df000017 	ldw	fp,0(sp)
8113c064:	dec00204 	addi	sp,sp,8
8113c068:	f800283a 	ret

8113c06c <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113c06c:	defffa04 	addi	sp,sp,-24
8113c070:	de00012e 	bgeu	sp,et,8113c078 <OSTmrNameGet+0xc>
8113c074:	003b68fa 	trap	3
8113c078:	dfc00515 	stw	ra,20(sp)
8113c07c:	df000415 	stw	fp,16(sp)
8113c080:	df000404 	addi	fp,sp,16
8113c084:	e13ffd15 	stw	r4,-12(fp)
8113c088:	e17ffe15 	stw	r5,-8(fp)
8113c08c:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113c090:	e0bfff17 	ldw	r2,-4(fp)
8113c094:	1000021e 	bne	r2,zero,8113c0a0 <OSTmrNameGet+0x34>
        return (0);
8113c098:	0005883a 	mov	r2,zero
8113c09c:	00003e06 	br	8113c198 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113c0a0:	e0bffe17 	ldw	r2,-8(fp)
8113c0a4:	1000051e 	bne	r2,zero,8113c0bc <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113c0a8:	e0bfff17 	ldw	r2,-4(fp)
8113c0ac:	00ffe204 	movi	r3,-120
8113c0b0:	10c00005 	stb	r3,0(r2)
        return (0);
8113c0b4:	0005883a 	mov	r2,zero
8113c0b8:	00003706 	br	8113c198 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113c0bc:	e0bffd17 	ldw	r2,-12(fp)
8113c0c0:	1000051e 	bne	r2,zero,8113c0d8 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113c0c4:	e0bfff17 	ldw	r2,-4(fp)
8113c0c8:	00ffe284 	movi	r3,-118
8113c0cc:	10c00005 	stb	r3,0(r2)
        return (0);
8113c0d0:	0005883a 	mov	r2,zero
8113c0d4:	00003006 	br	8113c198 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113c0d8:	e0bffd17 	ldw	r2,-12(fp)
8113c0dc:	10800003 	ldbu	r2,0(r2)
8113c0e0:	10803fcc 	andi	r2,r2,255
8113c0e4:	10801920 	cmpeqi	r2,r2,100
8113c0e8:	1000051e 	bne	r2,zero,8113c100 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c0ec:	e0bfff17 	ldw	r2,-4(fp)
8113c0f0:	00ffe244 	movi	r3,-119
8113c0f4:	10c00005 	stb	r3,0(r2)
        return (0);
8113c0f8:	0005883a 	mov	r2,zero
8113c0fc:	00002606 	br	8113c198 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113c100:	d0a09b03 	ldbu	r2,-32148(gp)
8113c104:	10803fcc 	andi	r2,r2,255
8113c108:	10000526 	beq	r2,zero,8113c120 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113c10c:	e0bfff17 	ldw	r2,-4(fp)
8113c110:	00c00444 	movi	r3,17
8113c114:	10c00005 	stb	r3,0(r2)
        return (0);
8113c118:	0005883a 	mov	r2,zero
8113c11c:	00001e06 	br	8113c198 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113c120:	113cd200 	call	8113cd20 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113c124:	e0bffd17 	ldw	r2,-12(fp)
8113c128:	10800c43 	ldbu	r2,49(r2)
8113c12c:	10803fcc 	andi	r2,r2,255
8113c130:	10000e26 	beq	r2,zero,8113c16c <OSTmrNameGet+0x100>
8113c134:	10001316 	blt	r2,zero,8113c184 <OSTmrNameGet+0x118>
8113c138:	10800108 	cmpgei	r2,r2,4
8113c13c:	1000111e 	bne	r2,zero,8113c184 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113c140:	e0bffd17 	ldw	r2,-12(fp)
8113c144:	10800804 	addi	r2,r2,32
8113c148:	100b883a 	mov	r5,r2
8113c14c:	e13ffe17 	ldw	r4,-8(fp)
8113c150:	1134e1c0 	call	81134e1c <OS_StrCopy>
8113c154:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113c158:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c15c:	e0bfff17 	ldw	r2,-4(fp)
8113c160:	10000005 	stb	zero,0(r2)
             return (len);
8113c164:	e0bffc03 	ldbu	r2,-16(fp)
8113c168:	00000b06 	br	8113c198 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113c16c:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c170:	e0bfff17 	ldw	r2,-4(fp)
8113c174:	00ffe1c4 	movi	r3,-121
8113c178:	10c00005 	stb	r3,0(r2)
             return (0);
8113c17c:	0005883a 	mov	r2,zero
8113c180:	00000506 	br	8113c198 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113c184:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c188:	e0bfff17 	ldw	r2,-4(fp)
8113c18c:	00ffe344 	movi	r3,-115
8113c190:	10c00005 	stb	r3,0(r2)
             return (0);
8113c194:	0005883a 	mov	r2,zero
    }
}
8113c198:	e037883a 	mov	sp,fp
8113c19c:	dfc00117 	ldw	ra,4(sp)
8113c1a0:	df000017 	ldw	fp,0(sp)
8113c1a4:	dec00204 	addi	sp,sp,8
8113c1a8:	f800283a 	ret

8113c1ac <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113c1ac:	defffb04 	addi	sp,sp,-20
8113c1b0:	de00012e 	bgeu	sp,et,8113c1b8 <OSTmrRemainGet+0xc>
8113c1b4:	003b68fa 	trap	3
8113c1b8:	dfc00415 	stw	ra,16(sp)
8113c1bc:	df000315 	stw	fp,12(sp)
8113c1c0:	df000304 	addi	fp,sp,12
8113c1c4:	e13ffe15 	stw	r4,-8(fp)
8113c1c8:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113c1cc:	e0bfff17 	ldw	r2,-4(fp)
8113c1d0:	1000021e 	bne	r2,zero,8113c1dc <OSTmrRemainGet+0x30>
        return (0);
8113c1d4:	0005883a 	mov	r2,zero
8113c1d8:	00005d06 	br	8113c350 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113c1dc:	e0bffe17 	ldw	r2,-8(fp)
8113c1e0:	1000051e 	bne	r2,zero,8113c1f8 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113c1e4:	e0bfff17 	ldw	r2,-4(fp)
8113c1e8:	00ffe284 	movi	r3,-118
8113c1ec:	10c00005 	stb	r3,0(r2)
        return (0);
8113c1f0:	0005883a 	mov	r2,zero
8113c1f4:	00005606 	br	8113c350 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113c1f8:	e0bffe17 	ldw	r2,-8(fp)
8113c1fc:	10800003 	ldbu	r2,0(r2)
8113c200:	10803fcc 	andi	r2,r2,255
8113c204:	10801920 	cmpeqi	r2,r2,100
8113c208:	1000051e 	bne	r2,zero,8113c220 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c20c:	e0bfff17 	ldw	r2,-4(fp)
8113c210:	00ffe244 	movi	r3,-119
8113c214:	10c00005 	stb	r3,0(r2)
        return (0);
8113c218:	0005883a 	mov	r2,zero
8113c21c:	00004c06 	br	8113c350 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113c220:	d0a09b03 	ldbu	r2,-32148(gp)
8113c224:	10803fcc 	andi	r2,r2,255
8113c228:	10000526 	beq	r2,zero,8113c240 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113c22c:	e0bfff17 	ldw	r2,-4(fp)
8113c230:	00ffe2c4 	movi	r3,-117
8113c234:	10c00005 	stb	r3,0(r2)
        return (0);
8113c238:	0005883a 	mov	r2,zero
8113c23c:	00004406 	br	8113c350 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113c240:	113cd200 	call	8113cd20 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113c244:	e0bffe17 	ldw	r2,-8(fp)
8113c248:	10800c43 	ldbu	r2,49(r2)
8113c24c:	10803fcc 	andi	r2,r2,255
8113c250:	10c00060 	cmpeqi	r3,r2,1
8113c254:	1800121e 	bne	r3,zero,8113c2a0 <OSTmrRemainGet+0xf4>
8113c258:	10c00088 	cmpgei	r3,r2,2
8113c25c:	1800021e 	bne	r3,zero,8113c268 <OSTmrRemainGet+0xbc>
8113c260:	10003026 	beq	r2,zero,8113c324 <OSTmrRemainGet+0x178>
8113c264:	00003506 	br	8113c33c <OSTmrRemainGet+0x190>
8113c268:	10c000a0 	cmpeqi	r3,r2,2
8113c26c:	1800281e 	bne	r3,zero,8113c310 <OSTmrRemainGet+0x164>
8113c270:	108000e0 	cmpeqi	r2,r2,3
8113c274:	10003126 	beq	r2,zero,8113c33c <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113c278:	e0bffe17 	ldw	r2,-8(fp)
8113c27c:	10c00517 	ldw	r3,20(r2)
8113c280:	d0a09d17 	ldw	r2,-32140(gp)
8113c284:	1885c83a 	sub	r2,r3,r2
8113c288:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113c28c:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113c290:	e0bfff17 	ldw	r2,-4(fp)
8113c294:	10000005 	stb	zero,0(r2)
             return (remain);
8113c298:	e0bffd17 	ldw	r2,-12(fp)
8113c29c:	00002c06 	br	8113c350 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113c2a0:	e0bffe17 	ldw	r2,-8(fp)
8113c2a4:	10800c03 	ldbu	r2,48(r2)
8113c2a8:	10803fcc 	andi	r2,r2,255
8113c2ac:	108000a0 	cmpeqi	r2,r2,2
8113c2b0:	10000e26 	beq	r2,zero,8113c2ec <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113c2b4:	e0bffe17 	ldw	r2,-8(fp)
8113c2b8:	10800617 	ldw	r2,24(r2)
8113c2bc:	1000041e 	bne	r2,zero,8113c2d0 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113c2c0:	e0bffe17 	ldw	r2,-8(fp)
8113c2c4:	10800717 	ldw	r2,28(r2)
8113c2c8:	e0bffd15 	stw	r2,-12(fp)
8113c2cc:	00000306 	br	8113c2dc <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113c2d0:	e0bffe17 	ldw	r2,-8(fp)
8113c2d4:	10800617 	ldw	r2,24(r2)
8113c2d8:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113c2dc:	113cd640 	call	8113cd64 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113c2e0:	e0bfff17 	ldw	r2,-4(fp)
8113c2e4:	10000005 	stb	zero,0(r2)
                      break;
8113c2e8:	00000706 	br	8113c308 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113c2ec:	e0bffe17 	ldw	r2,-8(fp)
8113c2f0:	10800617 	ldw	r2,24(r2)
8113c2f4:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113c2f8:	113cd640 	call	8113cd64 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113c2fc:	e0bfff17 	ldw	r2,-4(fp)
8113c300:	10000005 	stb	zero,0(r2)
                      break;
8113c304:	0001883a 	nop
             }
             return (remain);
8113c308:	e0bffd17 	ldw	r2,-12(fp)
8113c30c:	00001006 	br	8113c350 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113c310:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c314:	e0bfff17 	ldw	r2,-4(fp)
8113c318:	10000005 	stb	zero,0(r2)
             return (0);
8113c31c:	0005883a 	mov	r2,zero
8113c320:	00000b06 	br	8113c350 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113c324:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c328:	e0bfff17 	ldw	r2,-4(fp)
8113c32c:	00ffe1c4 	movi	r3,-121
8113c330:	10c00005 	stb	r3,0(r2)
             return (0);
8113c334:	0005883a 	mov	r2,zero
8113c338:	00000506 	br	8113c350 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113c33c:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c340:	e0bfff17 	ldw	r2,-4(fp)
8113c344:	00ffe344 	movi	r3,-115
8113c348:	10c00005 	stb	r3,0(r2)
             return (0);
8113c34c:	0005883a 	mov	r2,zero
    }
}
8113c350:	e037883a 	mov	sp,fp
8113c354:	dfc00117 	ldw	ra,4(sp)
8113c358:	df000017 	ldw	fp,0(sp)
8113c35c:	dec00204 	addi	sp,sp,8
8113c360:	f800283a 	ret

8113c364 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113c364:	defffb04 	addi	sp,sp,-20
8113c368:	de00012e 	bgeu	sp,et,8113c370 <OSTmrStateGet+0xc>
8113c36c:	003b68fa 	trap	3
8113c370:	dfc00415 	stw	ra,16(sp)
8113c374:	df000315 	stw	fp,12(sp)
8113c378:	df000304 	addi	fp,sp,12
8113c37c:	e13ffe15 	stw	r4,-8(fp)
8113c380:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113c384:	e0bfff17 	ldw	r2,-4(fp)
8113c388:	1000021e 	bne	r2,zero,8113c394 <OSTmrStateGet+0x30>
        return (0);
8113c38c:	0005883a 	mov	r2,zero
8113c390:	00002a06 	br	8113c43c <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113c394:	e0bffe17 	ldw	r2,-8(fp)
8113c398:	1000051e 	bne	r2,zero,8113c3b0 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113c39c:	e0bfff17 	ldw	r2,-4(fp)
8113c3a0:	00ffe284 	movi	r3,-118
8113c3a4:	10c00005 	stb	r3,0(r2)
        return (0);
8113c3a8:	0005883a 	mov	r2,zero
8113c3ac:	00002306 	br	8113c43c <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113c3b0:	e0bffe17 	ldw	r2,-8(fp)
8113c3b4:	10800003 	ldbu	r2,0(r2)
8113c3b8:	10803fcc 	andi	r2,r2,255
8113c3bc:	10801920 	cmpeqi	r2,r2,100
8113c3c0:	1000051e 	bne	r2,zero,8113c3d8 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c3c4:	e0bfff17 	ldw	r2,-4(fp)
8113c3c8:	00ffe244 	movi	r3,-119
8113c3cc:	10c00005 	stb	r3,0(r2)
        return (0);
8113c3d0:	0005883a 	mov	r2,zero
8113c3d4:	00001906 	br	8113c43c <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113c3d8:	d0a09b03 	ldbu	r2,-32148(gp)
8113c3dc:	10803fcc 	andi	r2,r2,255
8113c3e0:	10000526 	beq	r2,zero,8113c3f8 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113c3e4:	e0bfff17 	ldw	r2,-4(fp)
8113c3e8:	00ffe2c4 	movi	r3,-117
8113c3ec:	10c00005 	stb	r3,0(r2)
        return (0);
8113c3f0:	0005883a 	mov	r2,zero
8113c3f4:	00001106 	br	8113c43c <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113c3f8:	113cd200 	call	8113cd20 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113c3fc:	e0bffe17 	ldw	r2,-8(fp)
8113c400:	10800c43 	ldbu	r2,49(r2)
8113c404:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113c408:	e0bffd03 	ldbu	r2,-12(fp)
8113c40c:	1005883a 	mov	r2,r2
8113c410:	10800128 	cmpgeui	r2,r2,4
8113c414:	1000031e 	bne	r2,zero,8113c424 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113c418:	e0bfff17 	ldw	r2,-4(fp)
8113c41c:	10000005 	stb	zero,0(r2)
             break;
8113c420:	00000406 	br	8113c434 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c424:	e0bfff17 	ldw	r2,-4(fp)
8113c428:	00ffe344 	movi	r3,-115
8113c42c:	10c00005 	stb	r3,0(r2)
             break;
8113c430:	0001883a 	nop
    }
    OSTmr_Unlock();
8113c434:	113cd640 	call	8113cd64 <OSTmr_Unlock>
    return (state);
8113c438:	e0bffd03 	ldbu	r2,-12(fp)
}
8113c43c:	e037883a 	mov	sp,fp
8113c440:	dfc00117 	ldw	ra,4(sp)
8113c444:	df000017 	ldw	fp,0(sp)
8113c448:	dec00204 	addi	sp,sp,8
8113c44c:	f800283a 	ret

8113c450 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113c450:	defffc04 	addi	sp,sp,-16
8113c454:	de00012e 	bgeu	sp,et,8113c45c <OSTmrStart+0xc>
8113c458:	003b68fa 	trap	3
8113c45c:	dfc00315 	stw	ra,12(sp)
8113c460:	df000215 	stw	fp,8(sp)
8113c464:	df000204 	addi	fp,sp,8
8113c468:	e13ffe15 	stw	r4,-8(fp)
8113c46c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113c470:	e0bfff17 	ldw	r2,-4(fp)
8113c474:	1000021e 	bne	r2,zero,8113c480 <OSTmrStart+0x30>
        return (OS_FALSE);
8113c478:	0005883a 	mov	r2,zero
8113c47c:	00004106 	br	8113c584 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113c480:	e0bffe17 	ldw	r2,-8(fp)
8113c484:	1000051e 	bne	r2,zero,8113c49c <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113c488:	e0bfff17 	ldw	r2,-4(fp)
8113c48c:	00ffe284 	movi	r3,-118
8113c490:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c494:	0005883a 	mov	r2,zero
8113c498:	00003a06 	br	8113c584 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113c49c:	e0bffe17 	ldw	r2,-8(fp)
8113c4a0:	10800003 	ldbu	r2,0(r2)
8113c4a4:	10803fcc 	andi	r2,r2,255
8113c4a8:	10801920 	cmpeqi	r2,r2,100
8113c4ac:	1000051e 	bne	r2,zero,8113c4c4 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c4b0:	e0bfff17 	ldw	r2,-4(fp)
8113c4b4:	00ffe244 	movi	r3,-119
8113c4b8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c4bc:	0005883a 	mov	r2,zero
8113c4c0:	00003006 	br	8113c584 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113c4c4:	d0a09b03 	ldbu	r2,-32148(gp)
8113c4c8:	10803fcc 	andi	r2,r2,255
8113c4cc:	10000526 	beq	r2,zero,8113c4e4 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113c4d0:	e0bfff17 	ldw	r2,-4(fp)
8113c4d4:	00ffe2c4 	movi	r3,-117
8113c4d8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c4dc:	0005883a 	mov	r2,zero
8113c4e0:	00002806 	br	8113c584 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113c4e4:	113cd200 	call	8113cd20 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113c4e8:	e0bffe17 	ldw	r2,-8(fp)
8113c4ec:	10800c43 	ldbu	r2,49(r2)
8113c4f0:	10803fcc 	andi	r2,r2,255
8113c4f4:	10c000c8 	cmpgei	r3,r2,3
8113c4f8:	1800031e 	bne	r3,zero,8113c508 <OSTmrStart+0xb8>
8113c4fc:	00800e16 	blt	zero,r2,8113c538 <OSTmrStart+0xe8>
8113c500:	10001526 	beq	r2,zero,8113c558 <OSTmrStart+0x108>
8113c504:	00001a06 	br	8113c570 <OSTmrStart+0x120>
8113c508:	108000e0 	cmpeqi	r2,r2,3
8113c50c:	10001826 	beq	r2,zero,8113c570 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113c510:	e13ffe17 	ldw	r4,-8(fp)
8113c514:	113cc240 	call	8113cc24 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113c518:	000b883a 	mov	r5,zero
8113c51c:	e13ffe17 	ldw	r4,-8(fp)
8113c520:	113cad40 	call	8113cad4 <OSTmr_Link>
             OSTmr_Unlock();
8113c524:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c528:	e0bfff17 	ldw	r2,-4(fp)
8113c52c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113c530:	00800044 	movi	r2,1
8113c534:	00001306 	br	8113c584 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113c538:	000b883a 	mov	r5,zero
8113c53c:	e13ffe17 	ldw	r4,-8(fp)
8113c540:	113cad40 	call	8113cad4 <OSTmr_Link>
             OSTmr_Unlock();
8113c544:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113c548:	e0bfff17 	ldw	r2,-4(fp)
8113c54c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113c550:	00800044 	movi	r2,1
8113c554:	00000b06 	br	8113c584 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113c558:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c55c:	e0bfff17 	ldw	r2,-4(fp)
8113c560:	00ffe1c4 	movi	r3,-121
8113c564:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c568:	0005883a 	mov	r2,zero
8113c56c:	00000506 	br	8113c584 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113c570:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c574:	e0bfff17 	ldw	r2,-4(fp)
8113c578:	00ffe344 	movi	r3,-115
8113c57c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c580:	0005883a 	mov	r2,zero
    }
}
8113c584:	e037883a 	mov	sp,fp
8113c588:	dfc00117 	ldw	ra,4(sp)
8113c58c:	df000017 	ldw	fp,0(sp)
8113c590:	dec00204 	addi	sp,sp,8
8113c594:	f800283a 	ret

8113c598 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113c598:	defff904 	addi	sp,sp,-28
8113c59c:	de00012e 	bgeu	sp,et,8113c5a4 <OSTmrStop+0xc>
8113c5a0:	003b68fa 	trap	3
8113c5a4:	dfc00615 	stw	ra,24(sp)
8113c5a8:	df000515 	stw	fp,20(sp)
8113c5ac:	df000504 	addi	fp,sp,20
8113c5b0:	e13ffc15 	stw	r4,-16(fp)
8113c5b4:	2805883a 	mov	r2,r5
8113c5b8:	e1bffe15 	stw	r6,-8(fp)
8113c5bc:	e1ffff15 	stw	r7,-4(fp)
8113c5c0:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113c5c4:	e0bfff17 	ldw	r2,-4(fp)
8113c5c8:	1000021e 	bne	r2,zero,8113c5d4 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113c5cc:	0005883a 	mov	r2,zero
8113c5d0:	00006606 	br	8113c76c <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113c5d4:	e0bffc17 	ldw	r2,-16(fp)
8113c5d8:	1000051e 	bne	r2,zero,8113c5f0 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113c5dc:	e0bfff17 	ldw	r2,-4(fp)
8113c5e0:	00ffe284 	movi	r3,-118
8113c5e4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c5e8:	0005883a 	mov	r2,zero
8113c5ec:	00005f06 	br	8113c76c <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113c5f0:	e0bffc17 	ldw	r2,-16(fp)
8113c5f4:	10800003 	ldbu	r2,0(r2)
8113c5f8:	10803fcc 	andi	r2,r2,255
8113c5fc:	10801920 	cmpeqi	r2,r2,100
8113c600:	1000051e 	bne	r2,zero,8113c618 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113c604:	e0bfff17 	ldw	r2,-4(fp)
8113c608:	00ffe244 	movi	r3,-119
8113c60c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c610:	0005883a 	mov	r2,zero
8113c614:	00005506 	br	8113c76c <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113c618:	d0a09b03 	ldbu	r2,-32148(gp)
8113c61c:	10803fcc 	andi	r2,r2,255
8113c620:	10000526 	beq	r2,zero,8113c638 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113c624:	e0bfff17 	ldw	r2,-4(fp)
8113c628:	00ffe2c4 	movi	r3,-117
8113c62c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113c630:	0005883a 	mov	r2,zero
8113c634:	00004d06 	br	8113c76c <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113c638:	113cd200 	call	8113cd20 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113c63c:	e0bffc17 	ldw	r2,-16(fp)
8113c640:	10800c43 	ldbu	r2,49(r2)
8113c644:	10803fcc 	andi	r2,r2,255
8113c648:	10c000c8 	cmpgei	r3,r2,3
8113c64c:	1800031e 	bne	r3,zero,8113c65c <OSTmrStop+0xc4>
8113c650:	00803516 	blt	zero,r2,8113c728 <OSTmrStop+0x190>
8113c654:	10003a26 	beq	r2,zero,8113c740 <OSTmrStop+0x1a8>
8113c658:	00003f06 	br	8113c758 <OSTmrStop+0x1c0>
8113c65c:	108000e0 	cmpeqi	r2,r2,3
8113c660:	10003d26 	beq	r2,zero,8113c758 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113c664:	e13ffc17 	ldw	r4,-16(fp)
8113c668:	113cc240 	call	8113cc24 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113c66c:	e0bfff17 	ldw	r2,-4(fp)
8113c670:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113c674:	e0bffd03 	ldbu	r2,-12(fp)
8113c678:	10c000e0 	cmpeqi	r3,r2,3
8113c67c:	1800041e 	bne	r3,zero,8113c690 <OSTmrStop+0xf8>
8113c680:	10c00120 	cmpeqi	r3,r2,4
8113c684:	1800121e 	bne	r3,zero,8113c6d0 <OSTmrStop+0x138>
8113c688:	10002326 	beq	r2,zero,8113c718 <OSTmrStop+0x180>
8113c68c:	00001e06 	br	8113c708 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113c690:	e0bffc17 	ldw	r2,-16(fp)
8113c694:	10800117 	ldw	r2,4(r2)
8113c698:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113c69c:	e0bffb17 	ldw	r2,-20(fp)
8113c6a0:	10000726 	beq	r2,zero,8113c6c0 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113c6a4:	e0bffc17 	ldw	r2,-16(fp)
8113c6a8:	10c00217 	ldw	r3,8(r2)
8113c6ac:	e0bffb17 	ldw	r2,-20(fp)
8113c6b0:	180b883a 	mov	r5,r3
8113c6b4:	e13ffc17 	ldw	r4,-16(fp)
8113c6b8:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113c6bc:	00001706 	br	8113c71c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113c6c0:	e0bfff17 	ldw	r2,-4(fp)
8113c6c4:	00ffe3c4 	movi	r3,-113
8113c6c8:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113c6cc:	00001306 	br	8113c71c <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113c6d0:	e0bffc17 	ldw	r2,-16(fp)
8113c6d4:	10800117 	ldw	r2,4(r2)
8113c6d8:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113c6dc:	e0bffb17 	ldw	r2,-20(fp)
8113c6e0:	10000526 	beq	r2,zero,8113c6f8 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113c6e4:	e0bffb17 	ldw	r2,-20(fp)
8113c6e8:	e17ffe17 	ldw	r5,-8(fp)
8113c6ec:	e13ffc17 	ldw	r4,-16(fp)
8113c6f0:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113c6f4:	00000906 	br	8113c71c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113c6f8:	e0bfff17 	ldw	r2,-4(fp)
8113c6fc:	00ffe3c4 	movi	r3,-113
8113c700:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113c704:	00000506 	br	8113c71c <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113c708:	e0bfff17 	ldw	r2,-4(fp)
8113c70c:	00ffe104 	movi	r3,-124
8113c710:	10c00005 	stb	r3,0(r2)
                     break;
8113c714:	00000106 	br	8113c71c <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113c718:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113c71c:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             return (OS_TRUE);
8113c720:	00800044 	movi	r2,1
8113c724:	00001106 	br	8113c76c <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113c728:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113c72c:	e0bfff17 	ldw	r2,-4(fp)
8113c730:	00ffe384 	movi	r3,-114
8113c734:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113c738:	00800044 	movi	r2,1
8113c73c:	00000b06 	br	8113c76c <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113c740:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113c744:	e0bfff17 	ldw	r2,-4(fp)
8113c748:	00ffe1c4 	movi	r3,-121
8113c74c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c750:	0005883a 	mov	r2,zero
8113c754:	00000506 	br	8113c76c <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113c758:	113cd640 	call	8113cd64 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113c75c:	e0bfff17 	ldw	r2,-4(fp)
8113c760:	00ffe344 	movi	r3,-115
8113c764:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113c768:	0005883a 	mov	r2,zero
    }
}
8113c76c:	e037883a 	mov	sp,fp
8113c770:	dfc00117 	ldw	ra,4(sp)
8113c774:	df000017 	ldw	fp,0(sp)
8113c778:	dec00204 	addi	sp,sp,8
8113c77c:	f800283a 	ret

8113c780 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113c780:	defffd04 	addi	sp,sp,-12
8113c784:	de00012e 	bgeu	sp,et,8113c78c <OSTmrSignal+0xc>
8113c788:	003b68fa 	trap	3
8113c78c:	dfc00215 	stw	ra,8(sp)
8113c790:	df000115 	stw	fp,4(sp)
8113c794:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113c798:	d0a08a17 	ldw	r2,-32216(gp)
8113c79c:	1009883a 	mov	r4,r2
8113c7a0:	1139f000 	call	81139f00 <OSSemPost>
8113c7a4:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113c7a8:	e0bfff03 	ldbu	r2,-4(fp)
}
8113c7ac:	e037883a 	mov	sp,fp
8113c7b0:	dfc00117 	ldw	ra,4(sp)
8113c7b4:	df000017 	ldw	fp,0(sp)
8113c7b8:	dec00204 	addi	sp,sp,8
8113c7bc:	f800283a 	ret

8113c7c0 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113c7c0:	defffe04 	addi	sp,sp,-8
8113c7c4:	de00012e 	bgeu	sp,et,8113c7cc <OSTmr_Alloc+0xc>
8113c7c8:	003b68fa 	trap	3
8113c7cc:	df000115 	stw	fp,4(sp)
8113c7d0:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113c7d4:	d0a08817 	ldw	r2,-32224(gp)
8113c7d8:	1000021e 	bne	r2,zero,8113c7e4 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113c7dc:	0005883a 	mov	r2,zero
8113c7e0:	00001006 	br	8113c824 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113c7e4:	d0a08817 	ldw	r2,-32224(gp)
8113c7e8:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113c7ec:	e0bfff17 	ldw	r2,-4(fp)
8113c7f0:	10800317 	ldw	r2,12(r2)
8113c7f4:	d0a08815 	stw	r2,-32224(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113c7f8:	e0bfff17 	ldw	r2,-4(fp)
8113c7fc:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113c800:	e0bfff17 	ldw	r2,-4(fp)
8113c804:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113c808:	d0a08d0b 	ldhu	r2,-32204(gp)
8113c80c:	10800044 	addi	r2,r2,1
8113c810:	d0a08d0d 	sth	r2,-32204(gp)
    OSTmrFree--;
8113c814:	d0a0910b 	ldhu	r2,-32188(gp)
8113c818:	10bfffc4 	addi	r2,r2,-1
8113c81c:	d0a0910d 	sth	r2,-32188(gp)
    return (ptmr);
8113c820:	e0bfff17 	ldw	r2,-4(fp)
}
8113c824:	e037883a 	mov	sp,fp
8113c828:	df000017 	ldw	fp,0(sp)
8113c82c:	dec00104 	addi	sp,sp,4
8113c830:	f800283a 	ret

8113c834 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113c834:	defffe04 	addi	sp,sp,-8
8113c838:	de00012e 	bgeu	sp,et,8113c840 <OSTmr_Free+0xc>
8113c83c:	003b68fa 	trap	3
8113c840:	df000115 	stw	fp,4(sp)
8113c844:	df000104 	addi	fp,sp,4
8113c848:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113c84c:	e0bfff17 	ldw	r2,-4(fp)
8113c850:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113c854:	e0bfff17 	ldw	r2,-4(fp)
8113c858:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113c85c:	e0bfff17 	ldw	r2,-4(fp)
8113c860:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113c864:	e0bfff17 	ldw	r2,-4(fp)
8113c868:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113c86c:	e0bfff17 	ldw	r2,-4(fp)
8113c870:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113c874:	e0bfff17 	ldw	r2,-4(fp)
8113c878:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113c87c:	e0bfff17 	ldw	r2,-4(fp)
8113c880:	00c00fc4 	movi	r3,63
8113c884:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113c888:	e0bfff17 	ldw	r2,-4(fp)
8113c88c:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113c890:	e0bfff17 	ldw	r2,-4(fp)
8113c894:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113c898:	d0e08817 	ldw	r3,-32224(gp)
8113c89c:	e0bfff17 	ldw	r2,-4(fp)
8113c8a0:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113c8a4:	e0bfff17 	ldw	r2,-4(fp)
8113c8a8:	d0a08815 	stw	r2,-32224(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113c8ac:	d0a08d0b 	ldhu	r2,-32204(gp)
8113c8b0:	10bfffc4 	addi	r2,r2,-1
8113c8b4:	d0a08d0d 	sth	r2,-32204(gp)
    OSTmrFree++;
8113c8b8:	d0a0910b 	ldhu	r2,-32188(gp)
8113c8bc:	10800044 	addi	r2,r2,1
8113c8c0:	d0a0910d 	sth	r2,-32188(gp)
}
8113c8c4:	0001883a 	nop
8113c8c8:	e037883a 	mov	sp,fp
8113c8cc:	df000017 	ldw	fp,0(sp)
8113c8d0:	dec00104 	addi	sp,sp,4
8113c8d4:	f800283a 	ret

8113c8d8 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113c8d8:	defffa04 	addi	sp,sp,-24
8113c8dc:	de00012e 	bgeu	sp,et,8113c8e4 <OSTmr_Init+0xc>
8113c8e0:	003b68fa 	trap	3
8113c8e4:	dfc00515 	stw	ra,20(sp)
8113c8e8:	df000415 	stw	fp,16(sp)
8113c8ec:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113c8f0:	01406804 	movi	r5,416
8113c8f4:	012045b4 	movhi	r4,33046
8113c8f8:	21052104 	addi	r4,r4,5252
8113c8fc:	1134bfc0 	call	81134bfc <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113c900:	01400404 	movi	r5,16
8113c904:	012045b4 	movhi	r4,33046
8113c908:	21036504 	addi	r4,r4,3476
8113c90c:	1134bfc0 	call	81134bfc <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113c910:	00a045b4 	movhi	r2,33046
8113c914:	10852104 	addi	r2,r2,5252
8113c918:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113c91c:	00a045b4 	movhi	r2,33046
8113c920:	10852e04 	addi	r2,r2,5304
8113c924:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113c928:	e03ffc0d 	sth	zero,-16(fp)
8113c92c:	00001606 	br	8113c988 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113c930:	e0bffd17 	ldw	r2,-12(fp)
8113c934:	00c01904 	movi	r3,100
8113c938:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113c93c:	e0bffd17 	ldw	r2,-12(fp)
8113c940:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113c944:	e0bffd17 	ldw	r2,-12(fp)
8113c948:	e0fffe17 	ldw	r3,-8(fp)
8113c94c:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113c950:	e0bffd17 	ldw	r2,-12(fp)
8113c954:	00c00fc4 	movi	r3,63
8113c958:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113c95c:	e0bffd17 	ldw	r2,-12(fp)
8113c960:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113c964:	e0bffd17 	ldw	r2,-12(fp)
8113c968:	10800d04 	addi	r2,r2,52
8113c96c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113c970:	e0bffe17 	ldw	r2,-8(fp)
8113c974:	10800d04 	addi	r2,r2,52
8113c978:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113c97c:	e0bffc0b 	ldhu	r2,-16(fp)
8113c980:	10800044 	addi	r2,r2,1
8113c984:	e0bffc0d 	sth	r2,-16(fp)
8113c988:	e0bffc0b 	ldhu	r2,-16(fp)
8113c98c:	108001f0 	cmpltui	r2,r2,7
8113c990:	103fe71e 	bne	r2,zero,8113c930 <__reset+0xfb11c930>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113c994:	e0bffd17 	ldw	r2,-12(fp)
8113c998:	00c01904 	movi	r3,100
8113c99c:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113c9a0:	e0bffd17 	ldw	r2,-12(fp)
8113c9a4:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113c9a8:	e0bffd17 	ldw	r2,-12(fp)
8113c9ac:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113c9b0:	e0bffd17 	ldw	r2,-12(fp)
8113c9b4:	00c00fc4 	movi	r3,63
8113c9b8:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113c9bc:	e0bffd17 	ldw	r2,-12(fp)
8113c9c0:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113c9c4:	d0209d15 	stw	zero,-32140(gp)
    OSTmrUsed           = 0;
8113c9c8:	d0208d0d 	sth	zero,-32204(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113c9cc:	00800204 	movi	r2,8
8113c9d0:	d0a0910d 	sth	r2,-32188(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113c9d4:	00a045b4 	movhi	r2,33046
8113c9d8:	10852104 	addi	r2,r2,5252
8113c9dc:	d0a08815 	stw	r2,-32224(gp)
    OSTmrSem            = OSSemCreate(1);
8113c9e0:	01000044 	movi	r4,1
8113c9e4:	11398500 	call	81139850 <OSSemCreate>
8113c9e8:	d0a09f15 	stw	r2,-32132(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113c9ec:	0009883a 	mov	r4,zero
8113c9f0:	11398500 	call	81139850 <OSSemCreate>
8113c9f4:	d0a08a15 	stw	r2,-32216(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113c9f8:	d0a09f17 	ldw	r2,-32132(gp)
8113c9fc:	e0ffff04 	addi	r3,fp,-4
8113ca00:	180d883a 	mov	r6,r3
8113ca04:	01604574 	movhi	r5,33045
8113ca08:	296cfc04 	addi	r5,r5,-19472
8113ca0c:	1009883a 	mov	r4,r2
8113ca10:	11334580 	call	81133458 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113ca14:	d0a08a17 	ldw	r2,-32216(gp)
8113ca18:	e0ffff04 	addi	r3,fp,-4
8113ca1c:	180d883a 	mov	r6,r3
8113ca20:	01604574 	movhi	r5,33045
8113ca24:	296d0104 	addi	r5,r5,-19452
8113ca28:	1009883a 	mov	r4,r2
8113ca2c:	11334580 	call	81133458 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113ca30:	113ca4c0 	call	8113ca4c <OSTmr_InitTask>
}
8113ca34:	0001883a 	nop
8113ca38:	e037883a 	mov	sp,fp
8113ca3c:	dfc00117 	ldw	ra,4(sp)
8113ca40:	df000017 	ldw	fp,0(sp)
8113ca44:	dec00204 	addi	sp,sp,8
8113ca48:	f800283a 	ret

8113ca4c <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113ca4c:	defff804 	addi	sp,sp,-32
8113ca50:	de00012e 	bgeu	sp,et,8113ca58 <OSTmr_InitTask+0xc>
8113ca54:	003b68fa 	trap	3
8113ca58:	dfc00715 	stw	ra,28(sp)
8113ca5c:	df000615 	stw	fp,24(sp)
8113ca60:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113ca64:	008000c4 	movi	r2,3
8113ca68:	d8800415 	stw	r2,16(sp)
8113ca6c:	d8000315 	stw	zero,12(sp)
8113ca70:	00808004 	movi	r2,512
8113ca74:	d8800215 	stw	r2,8(sp)
8113ca78:	00a045b4 	movhi	r2,33046
8113ca7c:	108d5504 	addi	r2,r2,13652
8113ca80:	d8800115 	stw	r2,4(sp)
8113ca84:	00bfff54 	movui	r2,65533
8113ca88:	d8800015 	stw	r2,0(sp)
8113ca8c:	01c00744 	movi	r7,29
8113ca90:	01a045b4 	movhi	r6,33046
8113ca94:	318f5404 	addi	r6,r6,15696
8113ca98:	000b883a 	mov	r5,zero
8113ca9c:	01204534 	movhi	r4,33044
8113caa0:	21336804 	addi	r4,r4,-12896
8113caa4:	113a7300 	call	8113a730 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113caa8:	e1bfff04 	addi	r6,fp,-4
8113caac:	01604574 	movhi	r5,33045
8113cab0:	296d0604 	addi	r5,r5,-19432
8113cab4:	01000744 	movi	r4,29
8113cab8:	113af600 	call	8113af60 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113cabc:	0001883a 	nop
8113cac0:	e037883a 	mov	sp,fp
8113cac4:	dfc00117 	ldw	ra,4(sp)
8113cac8:	df000017 	ldw	fp,0(sp)
8113cacc:	dec00204 	addi	sp,sp,8
8113cad0:	f800283a 	ret

8113cad4 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113cad4:	defffa04 	addi	sp,sp,-24
8113cad8:	de00012e 	bgeu	sp,et,8113cae0 <OSTmr_Link+0xc>
8113cadc:	003b68fa 	trap	3
8113cae0:	df000515 	stw	fp,20(sp)
8113cae4:	df000504 	addi	fp,sp,20
8113cae8:	e13ffe15 	stw	r4,-8(fp)
8113caec:	2805883a 	mov	r2,r5
8113caf0:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113caf4:	e0bffe17 	ldw	r2,-8(fp)
8113caf8:	00c000c4 	movi	r3,3
8113cafc:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113cb00:	e0bfff03 	ldbu	r2,-4(fp)
8113cb04:	10800058 	cmpnei	r2,r2,1
8113cb08:	1000071e 	bne	r2,zero,8113cb28 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113cb0c:	e0bffe17 	ldw	r2,-8(fp)
8113cb10:	10c00717 	ldw	r3,28(r2)
8113cb14:	d0a09d17 	ldw	r2,-32140(gp)
8113cb18:	1887883a 	add	r3,r3,r2
8113cb1c:	e0bffe17 	ldw	r2,-8(fp)
8113cb20:	10c00515 	stw	r3,20(r2)
8113cb24:	00001006 	br	8113cb68 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113cb28:	e0bffe17 	ldw	r2,-8(fp)
8113cb2c:	10800617 	ldw	r2,24(r2)
8113cb30:	1000071e 	bne	r2,zero,8113cb50 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113cb34:	e0bffe17 	ldw	r2,-8(fp)
8113cb38:	10c00717 	ldw	r3,28(r2)
8113cb3c:	d0a09d17 	ldw	r2,-32140(gp)
8113cb40:	1887883a 	add	r3,r3,r2
8113cb44:	e0bffe17 	ldw	r2,-8(fp)
8113cb48:	10c00515 	stw	r3,20(r2)
8113cb4c:	00000606 	br	8113cb68 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113cb50:	e0bffe17 	ldw	r2,-8(fp)
8113cb54:	10c00617 	ldw	r3,24(r2)
8113cb58:	d0a09d17 	ldw	r2,-32140(gp)
8113cb5c:	1887883a 	add	r3,r3,r2
8113cb60:	e0bffe17 	ldw	r2,-8(fp)
8113cb64:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113cb68:	e0bffe17 	ldw	r2,-8(fp)
8113cb6c:	10800517 	ldw	r2,20(r2)
8113cb70:	1080004c 	andi	r2,r2,1
8113cb74:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113cb78:	e0bffb0b 	ldhu	r2,-20(fp)
8113cb7c:	100690fa 	slli	r3,r2,3
8113cb80:	00a045b4 	movhi	r2,33046
8113cb84:	10836504 	addi	r2,r2,3476
8113cb88:	1885883a 	add	r2,r3,r2
8113cb8c:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113cb90:	e0bffc17 	ldw	r2,-16(fp)
8113cb94:	10800017 	ldw	r2,0(r2)
8113cb98:	1000091e 	bne	r2,zero,8113cbc0 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113cb9c:	e0bffc17 	ldw	r2,-16(fp)
8113cba0:	e0fffe17 	ldw	r3,-8(fp)
8113cba4:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113cba8:	e0bffe17 	ldw	r2,-8(fp)
8113cbac:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113cbb0:	e0bffc17 	ldw	r2,-16(fp)
8113cbb4:	00c00044 	movi	r3,1
8113cbb8:	10c0010d 	sth	r3,4(r2)
8113cbbc:	00001206 	br	8113cc08 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113cbc0:	e0bffc17 	ldw	r2,-16(fp)
8113cbc4:	10800017 	ldw	r2,0(r2)
8113cbc8:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113cbcc:	e0bffc17 	ldw	r2,-16(fp)
8113cbd0:	e0fffe17 	ldw	r3,-8(fp)
8113cbd4:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113cbd8:	e0bffe17 	ldw	r2,-8(fp)
8113cbdc:	e0fffd17 	ldw	r3,-12(fp)
8113cbe0:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113cbe4:	e0bffd17 	ldw	r2,-12(fp)
8113cbe8:	e0fffe17 	ldw	r3,-8(fp)
8113cbec:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113cbf0:	e0bffc17 	ldw	r2,-16(fp)
8113cbf4:	1080010b 	ldhu	r2,4(r2)
8113cbf8:	10800044 	addi	r2,r2,1
8113cbfc:	1007883a 	mov	r3,r2
8113cc00:	e0bffc17 	ldw	r2,-16(fp)
8113cc04:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113cc08:	e0bffe17 	ldw	r2,-8(fp)
8113cc0c:	10000415 	stw	zero,16(r2)
}
8113cc10:	0001883a 	nop
8113cc14:	e037883a 	mov	sp,fp
8113cc18:	df000017 	ldw	fp,0(sp)
8113cc1c:	dec00104 	addi	sp,sp,4
8113cc20:	f800283a 	ret

8113cc24 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113cc24:	defffa04 	addi	sp,sp,-24
8113cc28:	de00012e 	bgeu	sp,et,8113cc30 <OSTmr_Unlink+0xc>
8113cc2c:	003b68fa 	trap	3
8113cc30:	df000515 	stw	fp,20(sp)
8113cc34:	df000504 	addi	fp,sp,20
8113cc38:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113cc3c:	e0bfff17 	ldw	r2,-4(fp)
8113cc40:	10800517 	ldw	r2,20(r2)
8113cc44:	1080004c 	andi	r2,r2,1
8113cc48:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113cc4c:	e0bffb0b 	ldhu	r2,-20(fp)
8113cc50:	100690fa 	slli	r3,r2,3
8113cc54:	00a045b4 	movhi	r2,33046
8113cc58:	10836504 	addi	r2,r2,3476
8113cc5c:	1885883a 	add	r2,r3,r2
8113cc60:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113cc64:	e0bffc17 	ldw	r2,-16(fp)
8113cc68:	10c00017 	ldw	r3,0(r2)
8113cc6c:	e0bfff17 	ldw	r2,-4(fp)
8113cc70:	18800b1e 	bne	r3,r2,8113cca0 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113cc74:	e0bfff17 	ldw	r2,-4(fp)
8113cc78:	10800317 	ldw	r2,12(r2)
8113cc7c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113cc80:	e0bffc17 	ldw	r2,-16(fp)
8113cc84:	e0fffd17 	ldw	r3,-12(fp)
8113cc88:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113cc8c:	e0bffd17 	ldw	r2,-12(fp)
8113cc90:	10001126 	beq	r2,zero,8113ccd8 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113cc94:	e0bffd17 	ldw	r2,-12(fp)
8113cc98:	10000415 	stw	zero,16(r2)
8113cc9c:	00000e06 	br	8113ccd8 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113cca0:	e0bfff17 	ldw	r2,-4(fp)
8113cca4:	10800417 	ldw	r2,16(r2)
8113cca8:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113ccac:	e0bfff17 	ldw	r2,-4(fp)
8113ccb0:	10800317 	ldw	r2,12(r2)
8113ccb4:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113ccb8:	e0bffd17 	ldw	r2,-12(fp)
8113ccbc:	e0fffe17 	ldw	r3,-8(fp)
8113ccc0:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113ccc4:	e0bffe17 	ldw	r2,-8(fp)
8113ccc8:	10000326 	beq	r2,zero,8113ccd8 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113cccc:	e0bffe17 	ldw	r2,-8(fp)
8113ccd0:	e0fffd17 	ldw	r3,-12(fp)
8113ccd4:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113ccd8:	e0bfff17 	ldw	r2,-4(fp)
8113ccdc:	00c00044 	movi	r3,1
8113cce0:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113cce4:	e0bfff17 	ldw	r2,-4(fp)
8113cce8:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113ccec:	e0bfff17 	ldw	r2,-4(fp)
8113ccf0:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113ccf4:	e0bffc17 	ldw	r2,-16(fp)
8113ccf8:	1080010b 	ldhu	r2,4(r2)
8113ccfc:	10bfffc4 	addi	r2,r2,-1
8113cd00:	1007883a 	mov	r3,r2
8113cd04:	e0bffc17 	ldw	r2,-16(fp)
8113cd08:	10c0010d 	sth	r3,4(r2)
}
8113cd0c:	0001883a 	nop
8113cd10:	e037883a 	mov	sp,fp
8113cd14:	df000017 	ldw	fp,0(sp)
8113cd18:	dec00104 	addi	sp,sp,4
8113cd1c:	f800283a 	ret

8113cd20 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113cd20:	defffd04 	addi	sp,sp,-12
8113cd24:	de00012e 	bgeu	sp,et,8113cd2c <OSTmr_Lock+0xc>
8113cd28:	003b68fa 	trap	3
8113cd2c:	dfc00215 	stw	ra,8(sp)
8113cd30:	df000115 	stw	fp,4(sp)
8113cd34:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113cd38:	d0a09f17 	ldw	r2,-32132(gp)
8113cd3c:	e1bfff04 	addi	r6,fp,-4
8113cd40:	000b883a 	mov	r5,zero
8113cd44:	1009883a 	mov	r4,r2
8113cd48:	1139b780 	call	81139b78 <OSSemPend>
    (void)err;
}
8113cd4c:	0001883a 	nop
8113cd50:	e037883a 	mov	sp,fp
8113cd54:	dfc00117 	ldw	ra,4(sp)
8113cd58:	df000017 	ldw	fp,0(sp)
8113cd5c:	dec00204 	addi	sp,sp,8
8113cd60:	f800283a 	ret

8113cd64 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113cd64:	defffe04 	addi	sp,sp,-8
8113cd68:	de00012e 	bgeu	sp,et,8113cd70 <OSTmr_Unlock+0xc>
8113cd6c:	003b68fa 	trap	3
8113cd70:	dfc00115 	stw	ra,4(sp)
8113cd74:	df000015 	stw	fp,0(sp)
8113cd78:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113cd7c:	d0a09f17 	ldw	r2,-32132(gp)
8113cd80:	1009883a 	mov	r4,r2
8113cd84:	1139f000 	call	81139f00 <OSSemPost>
}
8113cd88:	0001883a 	nop
8113cd8c:	e037883a 	mov	sp,fp
8113cd90:	dfc00117 	ldw	ra,4(sp)
8113cd94:	df000017 	ldw	fp,0(sp)
8113cd98:	dec00204 	addi	sp,sp,8
8113cd9c:	f800283a 	ret

8113cda0 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113cda0:	defff704 	addi	sp,sp,-36
8113cda4:	de00012e 	bgeu	sp,et,8113cdac <OSTmr_Task+0xc>
8113cda8:	003b68fa 	trap	3
8113cdac:	dfc00815 	stw	ra,32(sp)
8113cdb0:	df000715 	stw	fp,28(sp)
8113cdb4:	df000704 	addi	fp,sp,28
8113cdb8:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113cdbc:	d0a08a17 	ldw	r2,-32216(gp)
8113cdc0:	e0fffe04 	addi	r3,fp,-8
8113cdc4:	180d883a 	mov	r6,r3
8113cdc8:	000b883a 	mov	r5,zero
8113cdcc:	1009883a 	mov	r4,r2
8113cdd0:	1139b780 	call	81139b78 <OSSemPend>
        OSTmr_Lock();
8113cdd4:	113cd200 	call	8113cd20 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113cdd8:	d0a09d17 	ldw	r2,-32140(gp)
8113cddc:	10800044 	addi	r2,r2,1
8113cde0:	d0a09d15 	stw	r2,-32140(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113cde4:	d0a09d17 	ldw	r2,-32140(gp)
8113cde8:	1080004c 	andi	r2,r2,1
8113cdec:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113cdf0:	e0bffa0b 	ldhu	r2,-24(fp)
8113cdf4:	100690fa 	slli	r3,r2,3
8113cdf8:	00a045b4 	movhi	r2,33046
8113cdfc:	10836504 	addi	r2,r2,3476
8113ce00:	1885883a 	add	r2,r3,r2
8113ce04:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113ce08:	e0bffb17 	ldw	r2,-20(fp)
8113ce0c:	10800017 	ldw	r2,0(r2)
8113ce10:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113ce14:	00002206 	br	8113cea0 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113ce18:	e0bff917 	ldw	r2,-28(fp)
8113ce1c:	10800317 	ldw	r2,12(r2)
8113ce20:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113ce24:	e0bff917 	ldw	r2,-28(fp)
8113ce28:	10c00517 	ldw	r3,20(r2)
8113ce2c:	d0a09d17 	ldw	r2,-32140(gp)
8113ce30:	1880191e 	bne	r3,r2,8113ce98 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113ce34:	e0bff917 	ldw	r2,-28(fp)
8113ce38:	10800117 	ldw	r2,4(r2)
8113ce3c:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113ce40:	e0bffd17 	ldw	r2,-12(fp)
8113ce44:	10000626 	beq	r2,zero,8113ce60 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113ce48:	e0bff917 	ldw	r2,-28(fp)
8113ce4c:	10c00217 	ldw	r3,8(r2)
8113ce50:	e0bffd17 	ldw	r2,-12(fp)
8113ce54:	180b883a 	mov	r5,r3
8113ce58:	e13ff917 	ldw	r4,-28(fp)
8113ce5c:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113ce60:	e13ff917 	ldw	r4,-28(fp)
8113ce64:	113cc240 	call	8113cc24 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113ce68:	e0bff917 	ldw	r2,-28(fp)
8113ce6c:	10800c03 	ldbu	r2,48(r2)
8113ce70:	10803fcc 	andi	r2,r2,255
8113ce74:	10800098 	cmpnei	r2,r2,2
8113ce78:	1000041e 	bne	r2,zero,8113ce8c <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113ce7c:	01400044 	movi	r5,1
8113ce80:	e13ff917 	ldw	r4,-28(fp)
8113ce84:	113cad40 	call	8113cad4 <OSTmr_Link>
8113ce88:	00000306 	br	8113ce98 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113ce8c:	e0bff917 	ldw	r2,-28(fp)
8113ce90:	00c00084 	movi	r3,2
8113ce94:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113ce98:	e0bffc17 	ldw	r2,-16(fp)
8113ce9c:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113cea0:	e0bff917 	ldw	r2,-28(fp)
8113cea4:	103fdc1e 	bne	r2,zero,8113ce18 <__reset+0xfb11ce18>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113cea8:	113cd640 	call	8113cd64 <OSTmr_Unlock>
    }
8113ceac:	003fc306 	br	8113cdbc <__reset+0xfb11cdbc>

8113ceb0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113ceb0:	defffd04 	addi	sp,sp,-12
8113ceb4:	de00012e 	bgeu	sp,et,8113cebc <alt_dev_reg+0xc>
8113ceb8:	003b68fa 	trap	3
8113cebc:	dfc00215 	stw	ra,8(sp)
8113cec0:	df000115 	stw	fp,4(sp)
8113cec4:	df000104 	addi	fp,sp,4
8113cec8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113cecc:	d1600d04 	addi	r5,gp,-32716
8113ced0:	e13fff17 	ldw	r4,-4(fp)
8113ced4:	11451500 	call	81145150 <alt_dev_llist_insert>
}
8113ced8:	e037883a 	mov	sp,fp
8113cedc:	dfc00117 	ldw	ra,4(sp)
8113cee0:	df000017 	ldw	fp,0(sp)
8113cee4:	dec00204 	addi	sp,sp,8
8113cee8:	f800283a 	ret

8113ceec <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113ceec:	defffd04 	addi	sp,sp,-12
8113cef0:	de00012e 	bgeu	sp,et,8113cef8 <alt_irq_init+0xc>
8113cef4:	003b68fa 	trap	3
8113cef8:	dfc00215 	stw	ra,8(sp)
8113cefc:	df000115 	stw	fp,4(sp)
8113cf00:	df000104 	addi	fp,sp,4
8113cf04:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113cf08:	1145b180 	call	81145b18 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113cf0c:	00800044 	movi	r2,1
8113cf10:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113cf14:	0001883a 	nop
8113cf18:	e037883a 	mov	sp,fp
8113cf1c:	dfc00117 	ldw	ra,4(sp)
8113cf20:	df000017 	ldw	fp,0(sp)
8113cf24:	dec00204 	addi	sp,sp,8
8113cf28:	f800283a 	ret

8113cf2c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113cf2c:	defffe04 	addi	sp,sp,-8
8113cf30:	de00012e 	bgeu	sp,et,8113cf38 <alt_sys_init+0xc>
8113cf34:	003b68fa 	trap	3
8113cf38:	dfc00115 	stw	ra,4(sp)
8113cf3c:	df000015 	stw	fp,0(sp)
8113cf40:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113cf44:	01c0fa04 	movi	r7,1000
8113cf48:	01800304 	movi	r6,12
8113cf4c:	000b883a 	mov	r5,zero
8113cf50:	01200034 	movhi	r4,32768
8113cf54:	21022004 	addi	r4,r4,2176
8113cf58:	11422840 	call	81142284 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113cf5c:	018002c4 	movi	r6,11
8113cf60:	000b883a 	mov	r5,zero
8113cf64:	01204574 	movhi	r4,33045
8113cf68:	2130a204 	addi	r4,r4,-15736
8113cf6c:	11415700 	call	81141570 <altera_avalon_jtag_uart_init>
8113cf70:	01204574 	movhi	r4,33045
8113cf74:	21309804 	addi	r4,r4,-15776
8113cf78:	113ceb00 	call	8113ceb0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113cf7c:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113cf80:	018003c4 	movi	r6,15
8113cf84:	000b883a 	mov	r5,zero
8113cf88:	01204574 	movhi	r4,33045
8113cf8c:	2134bd04 	addi	r4,r4,-11532
8113cf90:	11424300 	call	81142430 <altera_avalon_uart_init>
8113cf94:	01204574 	movhi	r4,33045
8113cf98:	2134b304 	addi	r4,r4,-11572
8113cf9c:	113ceb00 	call	8113ceb0 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113cfa0:	00a04574 	movhi	r2,33045
8113cfa4:	10b4e704 	addi	r2,r2,-11364
8113cfa8:	10c00717 	ldw	r3,28(r2)
8113cfac:	00a04574 	movhi	r2,33045
8113cfb0:	10b4e704 	addi	r2,r2,-11364
8113cfb4:	10800817 	ldw	r2,32(r2)
8113cfb8:	100d883a 	mov	r6,r2
8113cfbc:	180b883a 	mov	r5,r3
8113cfc0:	01204574 	movhi	r4,33045
8113cfc4:	2134e704 	addi	r4,r4,-11364
8113cfc8:	1144cb80 	call	81144cb8 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113cfcc:	00a04574 	movhi	r2,33045
8113cfd0:	10b50004 	addi	r2,r2,-11264
8113cfd4:	10c00717 	ldw	r3,28(r2)
8113cfd8:	00a04574 	movhi	r2,33045
8113cfdc:	10b50004 	addi	r2,r2,-11264
8113cfe0:	10800817 	ldw	r2,32(r2)
8113cfe4:	100d883a 	mov	r6,r2
8113cfe8:	180b883a 	mov	r5,r3
8113cfec:	01204574 	movhi	r4,33045
8113cff0:	21350004 	addi	r4,r4,-11264
8113cff4:	1144cb80 	call	81144cb8 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113cff8:	01204574 	movhi	r4,33045
8113cffc:	21351904 	addi	r4,r4,-11164
8113d000:	113ceb00 	call	8113ceb0 <alt_dev_reg>
}
8113d004:	0001883a 	nop
8113d008:	e037883a 	mov	sp,fp
8113d00c:	dfc00117 	ldw	ra,4(sp)
8113d010:	df000017 	ldw	fp,0(sp)
8113d014:	dec00204 	addi	sp,sp,8
8113d018:	f800283a 	ret

8113d01c <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113d01c:	defffa04 	addi	sp,sp,-24
8113d020:	de00012e 	bgeu	sp,et,8113d028 <Write_Sector_Data+0xc>
8113d024:	003b68fa 	trap	3
8113d028:	dfc00515 	stw	ra,20(sp)
8113d02c:	df000415 	stw	fp,16(sp)
8113d030:	df000404 	addi	fp,sp,16
8113d034:	e13ffe15 	stw	r4,-8(fp)
8113d038:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113d03c:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113d040:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113d044:	10001e26 	beq	r2,zero,8113d0c0 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113d048:	00803fc4 	movi	r2,255
8113d04c:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113d050:	d0a0a917 	ldw	r2,-32092(gp)
8113d054:	e13ffe17 	ldw	r4,-8(fp)
8113d058:	e0ffff17 	ldw	r3,-4(fp)
8113d05c:	20c7883a 	add	r3,r4,r3
8113d060:	1806927a 	slli	r3,r3,9
8113d064:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113d068:	d0a0a817 	ldw	r2,-32096(gp)
8113d06c:	00c00604 	movi	r3,24
8113d070:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113d074:	d0a0a517 	ldw	r2,-32108(gp)
8113d078:	1080002b 	ldhuio	r2,0(r2)
8113d07c:	10bfffcc 	andi	r2,r2,65535
8113d080:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113d084:	e0bffd0b 	ldhu	r2,-12(fp)
8113d088:	10bfffcc 	andi	r2,r2,65535
8113d08c:	1080010c 	andi	r2,r2,4
8113d090:	103ff81e 	bne	r2,zero,8113d074 <__reset+0xfb11d074>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113d094:	e0bffd0b 	ldhu	r2,-12(fp)
8113d098:	10bfffcc 	andi	r2,r2,65535
8113d09c:	1080040c 	andi	r2,r2,16
8113d0a0:	1000071e 	bne	r2,zero,8113d0c0 <Write_Sector_Data+0xa4>
        {
            result = true;
8113d0a4:	00800044 	movi	r2,1
8113d0a8:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113d0ac:	d020ae15 	stw	zero,-32072(gp)
            current_sector_index = sector_index+partition_offset;
8113d0b0:	e0fffe17 	ldw	r3,-8(fp)
8113d0b4:	e0bfff17 	ldw	r2,-4(fp)
8113d0b8:	1885883a 	add	r2,r3,r2
8113d0bc:	d0a0af15 	stw	r2,-32068(gp)
        }
    }
    return result;
8113d0c0:	e0bffc17 	ldw	r2,-16(fp)
}
8113d0c4:	e037883a 	mov	sp,fp
8113d0c8:	dfc00117 	ldw	ra,4(sp)
8113d0cc:	df000017 	ldw	fp,0(sp)
8113d0d0:	dec00204 	addi	sp,sp,8
8113d0d4:	f800283a 	ret

8113d0d8 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113d0d8:	defffd04 	addi	sp,sp,-12
8113d0dc:	de00012e 	bgeu	sp,et,8113d0e4 <Save_Modified_Sector+0xc>
8113d0e0:	003b68fa 	trap	3
8113d0e4:	dfc00215 	stw	ra,8(sp)
8113d0e8:	df000115 	stw	fp,4(sp)
8113d0ec:	df000104 	addi	fp,sp,4
    bool result = true;
8113d0f0:	00800044 	movi	r2,1
8113d0f4:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113d0f8:	d0a0ae17 	ldw	r2,-32072(gp)
8113d0fc:	10000526 	beq	r2,zero,8113d114 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113d100:	d0a0af17 	ldw	r2,-32068(gp)
8113d104:	000b883a 	mov	r5,zero
8113d108:	1009883a 	mov	r4,r2
8113d10c:	113d01c0 	call	8113d01c <Write_Sector_Data>
8113d110:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113d114:	e0bfff17 	ldw	r2,-4(fp)
}
8113d118:	e037883a 	mov	sp,fp
8113d11c:	dfc00117 	ldw	ra,4(sp)
8113d120:	df000017 	ldw	fp,0(sp)
8113d124:	dec00204 	addi	sp,sp,8
8113d128:	f800283a 	ret

8113d12c <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113d12c:	defffa04 	addi	sp,sp,-24
8113d130:	de00012e 	bgeu	sp,et,8113d138 <Read_Sector_Data+0xc>
8113d134:	003b68fa 	trap	3
8113d138:	dfc00515 	stw	ra,20(sp)
8113d13c:	df000415 	stw	fp,16(sp)
8113d140:	df000404 	addi	fp,sp,16
8113d144:	e13ffe15 	stw	r4,-8(fp)
8113d148:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113d14c:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113d150:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113d154:	10002726 	beq	r2,zero,8113d1f4 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113d158:	00803fc4 	movi	r2,255
8113d15c:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113d160:	d0a0ae17 	ldw	r2,-32072(gp)
8113d164:	10000726 	beq	r2,zero,8113d184 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113d168:	d0a0af17 	ldw	r2,-32068(gp)
8113d16c:	000b883a 	mov	r5,zero
8113d170:	1009883a 	mov	r4,r2
8113d174:	113d01c0 	call	8113d01c <Write_Sector_Data>
8113d178:	1000021e 	bne	r2,zero,8113d184 <Read_Sector_Data+0x58>
            {
                return false;
8113d17c:	0005883a 	mov	r2,zero
8113d180:	00001d06 	br	8113d1f8 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113d184:	d0a0a917 	ldw	r2,-32092(gp)
8113d188:	e13ffe17 	ldw	r4,-8(fp)
8113d18c:	e0ffff17 	ldw	r3,-4(fp)
8113d190:	20c7883a 	add	r3,r4,r3
8113d194:	1806927a 	slli	r3,r3,9
8113d198:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113d19c:	d0a0a817 	ldw	r2,-32096(gp)
8113d1a0:	00c00444 	movi	r3,17
8113d1a4:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113d1a8:	d0a0a517 	ldw	r2,-32108(gp)
8113d1ac:	1080002b 	ldhuio	r2,0(r2)
8113d1b0:	10bfffcc 	andi	r2,r2,65535
8113d1b4:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113d1b8:	e0bffd0b 	ldhu	r2,-12(fp)
8113d1bc:	10bfffcc 	andi	r2,r2,65535
8113d1c0:	1080010c 	andi	r2,r2,4
8113d1c4:	103ff81e 	bne	r2,zero,8113d1a8 <__reset+0xfb11d1a8>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113d1c8:	e0bffd0b 	ldhu	r2,-12(fp)
8113d1cc:	10bfffcc 	andi	r2,r2,65535
8113d1d0:	1080040c 	andi	r2,r2,16
8113d1d4:	1000071e 	bne	r2,zero,8113d1f4 <Read_Sector_Data+0xc8>
		{
			result = true;
8113d1d8:	00800044 	movi	r2,1
8113d1dc:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113d1e0:	d020ae15 	stw	zero,-32072(gp)
            current_sector_index = sector_index+partition_offset;
8113d1e4:	e0fffe17 	ldw	r3,-8(fp)
8113d1e8:	e0bfff17 	ldw	r2,-4(fp)
8113d1ec:	1885883a 	add	r2,r3,r2
8113d1f0:	d0a0af15 	stw	r2,-32068(gp)
		}
	}
	return result;
8113d1f4:	e0bffc17 	ldw	r2,-16(fp)
}
8113d1f8:	e037883a 	mov	sp,fp
8113d1fc:	dfc00117 	ldw	ra,4(sp)
8113d200:	df000017 	ldw	fp,0(sp)
8113d204:	dec00204 	addi	sp,sp,8
8113d208:	f800283a 	ret

8113d20c <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113d20c:	defffb04 	addi	sp,sp,-20
8113d210:	de00012e 	bgeu	sp,et,8113d218 <get_cluster_flag+0xc>
8113d214:	003b68fa 	trap	3
8113d218:	dfc00415 	stw	ra,16(sp)
8113d21c:	df000315 	stw	fp,12(sp)
8113d220:	df000304 	addi	fp,sp,12
8113d224:	e13ffe15 	stw	r4,-8(fp)
8113d228:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113d22c:	e0bffe17 	ldw	r2,-8(fp)
8113d230:	1004d23a 	srli	r2,r2,8
8113d234:	d0e0ab17 	ldw	r3,-32084(gp)
8113d238:	10c5883a 	add	r2,r2,r3
8113d23c:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113d240:	00a045b4 	movhi	r2,33046
8113d244:	109b3304 	addi	r2,r2,27852
8113d248:	10801117 	ldw	r2,68(r2)
8113d24c:	e0fffd17 	ldw	r3,-12(fp)
8113d250:	1885883a 	add	r2,r3,r2
8113d254:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113d258:	d0a0af17 	ldw	r2,-32068(gp)
8113d25c:	e0fffd17 	ldw	r3,-12(fp)
8113d260:	18800726 	beq	r3,r2,8113d280 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113d264:	e0bffd17 	ldw	r2,-12(fp)
8113d268:	000b883a 	mov	r5,zero
8113d26c:	1009883a 	mov	r4,r2
8113d270:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113d274:	1000021e 	bne	r2,zero,8113d280 <get_cluster_flag+0x74>
        {
            return false;
8113d278:	0005883a 	mov	r2,zero
8113d27c:	00000d06 	br	8113d2b4 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113d280:	e0bffe17 	ldw	r2,-8(fp)
8113d284:	10803fcc 	andi	r2,r2,255
8113d288:	1085883a 	add	r2,r2,r2
8113d28c:	1007883a 	mov	r3,r2
8113d290:	d0a0ad17 	ldw	r2,-32076(gp)
8113d294:	10800a17 	ldw	r2,40(r2)
8113d298:	1885883a 	add	r2,r3,r2
8113d29c:	1080002b 	ldhuio	r2,0(r2)
8113d2a0:	10bfffcc 	andi	r2,r2,65535
8113d2a4:	1007883a 	mov	r3,r2
8113d2a8:	e0bfff17 	ldw	r2,-4(fp)
8113d2ac:	10c0000d 	sth	r3,0(r2)
    return true;
8113d2b0:	00800044 	movi	r2,1
}
8113d2b4:	e037883a 	mov	sp,fp
8113d2b8:	dfc00117 	ldw	ra,4(sp)
8113d2bc:	df000017 	ldw	fp,0(sp)
8113d2c0:	dec00204 	addi	sp,sp,8
8113d2c4:	f800283a 	ret

8113d2c8 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113d2c8:	defffa04 	addi	sp,sp,-24
8113d2cc:	de00012e 	bgeu	sp,et,8113d2d4 <mark_cluster+0xc>
8113d2d0:	003b68fa 	trap	3
8113d2d4:	dfc00515 	stw	ra,20(sp)
8113d2d8:	df000415 	stw	fp,16(sp)
8113d2dc:	df000404 	addi	fp,sp,16
8113d2e0:	e13ffd15 	stw	r4,-12(fp)
8113d2e4:	2805883a 	mov	r2,r5
8113d2e8:	e1bfff15 	stw	r6,-4(fp)
8113d2ec:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113d2f0:	e0bffd17 	ldw	r2,-12(fp)
8113d2f4:	1004d23a 	srli	r2,r2,8
8113d2f8:	d0e0ab17 	ldw	r3,-32084(gp)
8113d2fc:	10c5883a 	add	r2,r2,r3
8113d300:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113d304:	e0bfff17 	ldw	r2,-4(fp)
8113d308:	10000726 	beq	r2,zero,8113d328 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113d30c:	00a045b4 	movhi	r2,33046
8113d310:	109b3304 	addi	r2,r2,27852
8113d314:	10801117 	ldw	r2,68(r2)
8113d318:	e0fffc17 	ldw	r3,-16(fp)
8113d31c:	1885883a 	add	r2,r3,r2
8113d320:	e0bffc15 	stw	r2,-16(fp)
8113d324:	00000606 	br	8113d340 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113d328:	00a045b4 	movhi	r2,33046
8113d32c:	109b3304 	addi	r2,r2,27852
8113d330:	10801217 	ldw	r2,72(r2)
8113d334:	e0fffc17 	ldw	r3,-16(fp)
8113d338:	1885883a 	add	r2,r3,r2
8113d33c:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113d340:	d0a0af17 	ldw	r2,-32068(gp)
8113d344:	e0fffc17 	ldw	r3,-16(fp)
8113d348:	18800726 	beq	r3,r2,8113d368 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113d34c:	e0bffc17 	ldw	r2,-16(fp)
8113d350:	000b883a 	mov	r5,zero
8113d354:	1009883a 	mov	r4,r2
8113d358:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113d35c:	1000021e 	bne	r2,zero,8113d368 <mark_cluster+0xa0>
        {
            return false;
8113d360:	0005883a 	mov	r2,zero
8113d364:	00000d06 	br	8113d39c <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113d368:	e0bffd17 	ldw	r2,-12(fp)
8113d36c:	10803fcc 	andi	r2,r2,255
8113d370:	1085883a 	add	r2,r2,r2
8113d374:	1007883a 	mov	r3,r2
8113d378:	d0a0ad17 	ldw	r2,-32076(gp)
8113d37c:	10800a17 	ldw	r2,40(r2)
8113d380:	1885883a 	add	r2,r3,r2
8113d384:	1007883a 	mov	r3,r2
8113d388:	e0bffe0f 	ldh	r2,-8(fp)
8113d38c:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113d390:	00800044 	movi	r2,1
8113d394:	d0a0ae15 	stw	r2,-32072(gp)
    return true;
8113d398:	00800044 	movi	r2,1
}
8113d39c:	e037883a 	mov	sp,fp
8113d3a0:	dfc00117 	ldw	ra,4(sp)
8113d3a4:	df000017 	ldw	fp,0(sp)
8113d3a8:	dec00204 	addi	sp,sp,8
8113d3ac:	f800283a 	ret

8113d3b0 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113d3b0:	defff704 	addi	sp,sp,-36
8113d3b4:	de00012e 	bgeu	sp,et,8113d3bc <Check_for_Master_Boot_Record+0xc>
8113d3b8:	003b68fa 	trap	3
8113d3bc:	dfc00815 	stw	ra,32(sp)
8113d3c0:	df000715 	stw	fp,28(sp)
8113d3c4:	df000704 	addi	fp,sp,28
	bool result = false;
8113d3c8:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113d3cc:	000b883a 	mov	r5,zero
8113d3d0:	0009883a 	mov	r4,zero
8113d3d4:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113d3d8:	10005a26 	beq	r2,zero,8113d544 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113d3dc:	d0a0ad17 	ldw	r2,-32076(gp)
8113d3e0:	10800a17 	ldw	r2,40(r2)
8113d3e4:	10807f84 	addi	r2,r2,510
8113d3e8:	1080002b 	ldhuio	r2,0(r2)
8113d3ec:	10bfffcc 	andi	r2,r2,65535
8113d3f0:	10bfffcc 	andi	r2,r2,65535
8113d3f4:	10a0001c 	xori	r2,r2,32768
8113d3f8:	10a00004 	addi	r2,r2,-32768
8113d3fc:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113d400:	e0bffb17 	ldw	r2,-20(fp)
8113d404:	10ffffcc 	andi	r3,r2,65535
8113d408:	00aa9554 	movui	r2,43605
8113d40c:	18804d1e 	bne	r3,r2,8113d544 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113d410:	e03ffa15 	stw	zero,-24(fp)
8113d414:	00004806 	br	8113d538 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113d418:	e0bffa17 	ldw	r2,-24(fp)
8113d41c:	1004913a 	slli	r2,r2,4
8113d420:	10806f84 	addi	r2,r2,446
8113d424:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113d428:	d0a0ad17 	ldw	r2,-32076(gp)
8113d42c:	10c00a17 	ldw	r3,40(r2)
8113d430:	e0bffc17 	ldw	r2,-16(fp)
8113d434:	1885883a 	add	r2,r3,r2
8113d438:	10800104 	addi	r2,r2,4
8113d43c:	10800023 	ldbuio	r2,0(r2)
8113d440:	10803fcc 	andi	r2,r2,255
8113d444:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113d448:	e0bffd07 	ldb	r2,-12(fp)
8113d44c:	10800060 	cmpeqi	r2,r2,1
8113d450:	1000091e 	bne	r2,zero,8113d478 <Check_for_Master_Boot_Record+0xc8>
8113d454:	e0bffd07 	ldb	r2,-12(fp)
8113d458:	10800120 	cmpeqi	r2,r2,4
8113d45c:	1000061e 	bne	r2,zero,8113d478 <Check_for_Master_Boot_Record+0xc8>
8113d460:	e0bffd07 	ldb	r2,-12(fp)
8113d464:	108001a0 	cmpeqi	r2,r2,6
8113d468:	1000031e 	bne	r2,zero,8113d478 <Check_for_Master_Boot_Record+0xc8>
8113d46c:	e0bffd07 	ldb	r2,-12(fp)
8113d470:	10800398 	cmpnei	r2,r2,14
8113d474:	10002d1e 	bne	r2,zero,8113d52c <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113d478:	d0a0ad17 	ldw	r2,-32076(gp)
8113d47c:	10c00a17 	ldw	r3,40(r2)
8113d480:	e0bffc17 	ldw	r2,-16(fp)
8113d484:	1885883a 	add	r2,r3,r2
8113d488:	10800284 	addi	r2,r2,10
8113d48c:	1080002b 	ldhuio	r2,0(r2)
8113d490:	10bfffcc 	andi	r2,r2,65535
8113d494:	1006943a 	slli	r3,r2,16
8113d498:	d0a0ad17 	ldw	r2,-32076(gp)
8113d49c:	11000a17 	ldw	r4,40(r2)
8113d4a0:	e0bffc17 	ldw	r2,-16(fp)
8113d4a4:	2085883a 	add	r2,r4,r2
8113d4a8:	10800204 	addi	r2,r2,8
8113d4ac:	1080002b 	ldhuio	r2,0(r2)
8113d4b0:	10bfffcc 	andi	r2,r2,65535
8113d4b4:	10bfffcc 	andi	r2,r2,65535
8113d4b8:	1884b03a 	or	r2,r3,r2
8113d4bc:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113d4c0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d4c4:	10c00a17 	ldw	r3,40(r2)
8113d4c8:	e0bffc17 	ldw	r2,-16(fp)
8113d4cc:	1885883a 	add	r2,r3,r2
8113d4d0:	10800384 	addi	r2,r2,14
8113d4d4:	1080002b 	ldhuio	r2,0(r2)
8113d4d8:	10bfffcc 	andi	r2,r2,65535
8113d4dc:	1006943a 	slli	r3,r2,16
8113d4e0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d4e4:	11000a17 	ldw	r4,40(r2)
8113d4e8:	e0bffc17 	ldw	r2,-16(fp)
8113d4ec:	2085883a 	add	r2,r4,r2
8113d4f0:	10800304 	addi	r2,r2,12
8113d4f4:	1080002b 	ldhuio	r2,0(r2)
8113d4f8:	10bfffcc 	andi	r2,r2,65535
8113d4fc:	10bfffcc 	andi	r2,r2,65535
8113d500:	1884b03a 	or	r2,r3,r2
8113d504:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113d508:	e0bfff17 	ldw	r2,-4(fp)
8113d50c:	0080070e 	bge	zero,r2,8113d52c <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113d510:	00800044 	movi	r2,1
8113d514:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113d518:	e0bfff17 	ldw	r2,-4(fp)
8113d51c:	d0a0ac15 	stw	r2,-32080(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113d520:	e0bffe17 	ldw	r2,-8(fp)
8113d524:	d0a0ab15 	stw	r2,-32084(gp)
						break;
8113d528:	00000606 	br	8113d544 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113d52c:	e0bffa17 	ldw	r2,-24(fp)
8113d530:	10800044 	addi	r2,r2,1
8113d534:	e0bffa15 	stw	r2,-24(fp)
8113d538:	e0bffa17 	ldw	r2,-24(fp)
8113d53c:	10800110 	cmplti	r2,r2,4
8113d540:	103fb51e 	bne	r2,zero,8113d418 <__reset+0xfb11d418>
				}
			}
		}
	}

	return result;
8113d544:	e0bff917 	ldw	r2,-28(fp)
}
8113d548:	e037883a 	mov	sp,fp
8113d54c:	dfc00117 	ldw	ra,4(sp)
8113d550:	df000017 	ldw	fp,0(sp)
8113d554:	dec00204 	addi	sp,sp,8
8113d558:	f800283a 	ret

8113d55c <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113d55c:	defff804 	addi	sp,sp,-32
8113d560:	de00012e 	bgeu	sp,et,8113d568 <Read_File_Record_At_Offset+0xc>
8113d564:	003b68fa 	trap	3
8113d568:	dfc00715 	stw	ra,28(sp)
8113d56c:	df000615 	stw	fp,24(sp)
8113d570:	df000604 	addi	fp,sp,24
8113d574:	e13ffc15 	stw	r4,-16(fp)
8113d578:	e17ffd15 	stw	r5,-12(fp)
8113d57c:	e1bffe15 	stw	r6,-8(fp)
8113d580:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113d584:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113d588:	e0bffc17 	ldw	r2,-16(fp)
8113d58c:	108007cc 	andi	r2,r2,31
8113d590:	10008d1e 	bne	r2,zero,8113d7c8 <Read_File_Record_At_Offset+0x26c>
8113d594:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113d598:	10008b26 	beq	r2,zero,8113d7c8 <Read_File_Record_At_Offset+0x26c>
8113d59c:	d0a0a417 	ldw	r2,-32112(gp)
8113d5a0:	10008926 	beq	r2,zero,8113d7c8 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113d5a4:	e03ffb15 	stw	zero,-20(fp)
8113d5a8:	00001106 	br	8113d5f0 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113d5ac:	e0fffc17 	ldw	r3,-16(fp)
8113d5b0:	e0bffb17 	ldw	r2,-20(fp)
8113d5b4:	1885883a 	add	r2,r3,r2
8113d5b8:	1007883a 	mov	r3,r2
8113d5bc:	d0a0ad17 	ldw	r2,-32076(gp)
8113d5c0:	10800a17 	ldw	r2,40(r2)
8113d5c4:	1885883a 	add	r2,r3,r2
8113d5c8:	10800023 	ldbuio	r2,0(r2)
8113d5cc:	10803fcc 	andi	r2,r2,255
8113d5d0:	1009883a 	mov	r4,r2
8113d5d4:	e0fffd17 	ldw	r3,-12(fp)
8113d5d8:	e0bffb17 	ldw	r2,-20(fp)
8113d5dc:	1885883a 	add	r2,r3,r2
8113d5e0:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113d5e4:	e0bffb17 	ldw	r2,-20(fp)
8113d5e8:	10800044 	addi	r2,r2,1
8113d5ec:	e0bffb15 	stw	r2,-20(fp)
8113d5f0:	e0bffb17 	ldw	r2,-20(fp)
8113d5f4:	10800210 	cmplti	r2,r2,8
8113d5f8:	103fec1e 	bne	r2,zero,8113d5ac <__reset+0xfb11d5ac>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113d5fc:	e03ffb15 	stw	zero,-20(fp)
8113d600:	00001306 	br	8113d650 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113d604:	e0fffc17 	ldw	r3,-16(fp)
8113d608:	e0bffb17 	ldw	r2,-20(fp)
8113d60c:	1885883a 	add	r2,r3,r2
8113d610:	1007883a 	mov	r3,r2
8113d614:	d0a0ad17 	ldw	r2,-32076(gp)
8113d618:	10800a17 	ldw	r2,40(r2)
8113d61c:	1885883a 	add	r2,r3,r2
8113d620:	10800204 	addi	r2,r2,8
8113d624:	10800023 	ldbuio	r2,0(r2)
8113d628:	10803fcc 	andi	r2,r2,255
8113d62c:	1009883a 	mov	r4,r2
8113d630:	e0fffd17 	ldw	r3,-12(fp)
8113d634:	e0bffb17 	ldw	r2,-20(fp)
8113d638:	1885883a 	add	r2,r3,r2
8113d63c:	10800204 	addi	r2,r2,8
8113d640:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113d644:	e0bffb17 	ldw	r2,-20(fp)
8113d648:	10800044 	addi	r2,r2,1
8113d64c:	e0bffb15 	stw	r2,-20(fp)
8113d650:	e0bffb17 	ldw	r2,-20(fp)
8113d654:	108000d0 	cmplti	r2,r2,3
8113d658:	103fea1e 	bne	r2,zero,8113d604 <__reset+0xfb11d604>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113d65c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d660:	10c00a17 	ldw	r3,40(r2)
8113d664:	e0bffc17 	ldw	r2,-16(fp)
8113d668:	1885883a 	add	r2,r3,r2
8113d66c:	108002c4 	addi	r2,r2,11
8113d670:	10800023 	ldbuio	r2,0(r2)
8113d674:	10803fcc 	andi	r2,r2,255
8113d678:	1007883a 	mov	r3,r2
8113d67c:	e0bffd17 	ldw	r2,-12(fp)
8113d680:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113d684:	d0a0ad17 	ldw	r2,-32076(gp)
8113d688:	10c00a17 	ldw	r3,40(r2)
8113d68c:	e0bffc17 	ldw	r2,-16(fp)
8113d690:	1885883a 	add	r2,r3,r2
8113d694:	10800384 	addi	r2,r2,14
8113d698:	1080002b 	ldhuio	r2,0(r2)
8113d69c:	10bfffcc 	andi	r2,r2,65535
8113d6a0:	1007883a 	mov	r3,r2
8113d6a4:	e0bffd17 	ldw	r2,-12(fp)
8113d6a8:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113d6ac:	d0a0ad17 	ldw	r2,-32076(gp)
8113d6b0:	10c00a17 	ldw	r3,40(r2)
8113d6b4:	e0bffc17 	ldw	r2,-16(fp)
8113d6b8:	1885883a 	add	r2,r3,r2
8113d6bc:	10800404 	addi	r2,r2,16
8113d6c0:	1080002b 	ldhuio	r2,0(r2)
8113d6c4:	10bfffcc 	andi	r2,r2,65535
8113d6c8:	1007883a 	mov	r3,r2
8113d6cc:	e0bffd17 	ldw	r2,-12(fp)
8113d6d0:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113d6d4:	d0a0ad17 	ldw	r2,-32076(gp)
8113d6d8:	10c00a17 	ldw	r3,40(r2)
8113d6dc:	e0bffc17 	ldw	r2,-16(fp)
8113d6e0:	1885883a 	add	r2,r3,r2
8113d6e4:	10800484 	addi	r2,r2,18
8113d6e8:	1080002b 	ldhuio	r2,0(r2)
8113d6ec:	10bfffcc 	andi	r2,r2,65535
8113d6f0:	1007883a 	mov	r3,r2
8113d6f4:	e0bffd17 	ldw	r2,-12(fp)
8113d6f8:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113d6fc:	d0a0ad17 	ldw	r2,-32076(gp)
8113d700:	10c00a17 	ldw	r3,40(r2)
8113d704:	e0bffc17 	ldw	r2,-16(fp)
8113d708:	1885883a 	add	r2,r3,r2
8113d70c:	10800584 	addi	r2,r2,22
8113d710:	1080002b 	ldhuio	r2,0(r2)
8113d714:	10bfffcc 	andi	r2,r2,65535
8113d718:	1007883a 	mov	r3,r2
8113d71c:	e0bffd17 	ldw	r2,-12(fp)
8113d720:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113d724:	d0a0ad17 	ldw	r2,-32076(gp)
8113d728:	10c00a17 	ldw	r3,40(r2)
8113d72c:	e0bffc17 	ldw	r2,-16(fp)
8113d730:	1885883a 	add	r2,r3,r2
8113d734:	10800604 	addi	r2,r2,24
8113d738:	1080002b 	ldhuio	r2,0(r2)
8113d73c:	10bfffcc 	andi	r2,r2,65535
8113d740:	1007883a 	mov	r3,r2
8113d744:	e0bffd17 	ldw	r2,-12(fp)
8113d748:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113d74c:	d0a0ad17 	ldw	r2,-32076(gp)
8113d750:	10c00a17 	ldw	r3,40(r2)
8113d754:	e0bffc17 	ldw	r2,-16(fp)
8113d758:	1885883a 	add	r2,r3,r2
8113d75c:	10800684 	addi	r2,r2,26
8113d760:	1080002b 	ldhuio	r2,0(r2)
8113d764:	10bfffcc 	andi	r2,r2,65535
8113d768:	1007883a 	mov	r3,r2
8113d76c:	e0bffd17 	ldw	r2,-12(fp)
8113d770:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113d774:	d0a0ad17 	ldw	r2,-32076(gp)
8113d778:	10c00a17 	ldw	r3,40(r2)
8113d77c:	e0bffc17 	ldw	r2,-16(fp)
8113d780:	1885883a 	add	r2,r3,r2
8113d784:	10800704 	addi	r2,r2,28
8113d788:	10800037 	ldwio	r2,0(r2)
8113d78c:	1007883a 	mov	r3,r2
8113d790:	e0bffd17 	ldw	r2,-12(fp)
8113d794:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113d798:	e0bffd17 	ldw	r2,-12(fp)
8113d79c:	e0fffe17 	ldw	r3,-8(fp)
8113d7a0:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113d7a4:	e0bffd17 	ldw	r2,-12(fp)
8113d7a8:	e0ffff17 	ldw	r3,-4(fp)
8113d7ac:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113d7b0:	e0bffc17 	ldw	r2,-16(fp)
8113d7b4:	1007883a 	mov	r3,r2
8113d7b8:	e0bffd17 	ldw	r2,-12(fp)
8113d7bc:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113d7c0:	00800044 	movi	r2,1
8113d7c4:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113d7c8:	e0bffa17 	ldw	r2,-24(fp)
}
8113d7cc:	e037883a 	mov	sp,fp
8113d7d0:	dfc00117 	ldw	ra,4(sp)
8113d7d4:	df000017 	ldw	fp,0(sp)
8113d7d8:	dec00204 	addi	sp,sp,8
8113d7dc:	f800283a 	ret

8113d7e0 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113d7e0:	defff904 	addi	sp,sp,-28
8113d7e4:	de00012e 	bgeu	sp,et,8113d7ec <Write_File_Record_At_Offset+0xc>
8113d7e8:	003b68fa 	trap	3
8113d7ec:	dfc00615 	stw	ra,24(sp)
8113d7f0:	df000515 	stw	fp,20(sp)
8113d7f4:	df000504 	addi	fp,sp,20
8113d7f8:	e13ffe15 	stw	r4,-8(fp)
8113d7fc:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113d800:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113d804:	e0bffe17 	ldw	r2,-8(fp)
8113d808:	108007cc 	andi	r2,r2,31
8113d80c:	1000931e 	bne	r2,zero,8113da5c <Write_File_Record_At_Offset+0x27c>
8113d810:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113d814:	10009126 	beq	r2,zero,8113da5c <Write_File_Record_At_Offset+0x27c>
8113d818:	d0a0a417 	ldw	r2,-32112(gp)
8113d81c:	10008f26 	beq	r2,zero,8113da5c <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113d820:	e03ffc15 	stw	zero,-16(fp)
8113d824:	00001f06 	br	8113d8a4 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113d828:	e0bffc17 	ldw	r2,-16(fp)
8113d82c:	10800044 	addi	r2,r2,1
8113d830:	e0ffff17 	ldw	r3,-4(fp)
8113d834:	1885883a 	add	r2,r3,r2
8113d838:	10800003 	ldbu	r2,0(r2)
8113d83c:	10803fcc 	andi	r2,r2,255
8113d840:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113d844:	e0bffd0f 	ldh	r2,-12(fp)
8113d848:	1004923a 	slli	r2,r2,8
8113d84c:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113d850:	e0ffff17 	ldw	r3,-4(fp)
8113d854:	e0bffc17 	ldw	r2,-16(fp)
8113d858:	1885883a 	add	r2,r3,r2
8113d85c:	10800003 	ldbu	r2,0(r2)
8113d860:	10c03fcc 	andi	r3,r2,255
8113d864:	e0bffd0b 	ldhu	r2,-12(fp)
8113d868:	1884b03a 	or	r2,r3,r2
8113d86c:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113d870:	e0fffe17 	ldw	r3,-8(fp)
8113d874:	e0bffc17 	ldw	r2,-16(fp)
8113d878:	1885883a 	add	r2,r3,r2
8113d87c:	1007883a 	mov	r3,r2
8113d880:	d0a0ad17 	ldw	r2,-32076(gp)
8113d884:	10800a17 	ldw	r2,40(r2)
8113d888:	1885883a 	add	r2,r3,r2
8113d88c:	1007883a 	mov	r3,r2
8113d890:	e0bffd0f 	ldh	r2,-12(fp)
8113d894:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113d898:	e0bffc17 	ldw	r2,-16(fp)
8113d89c:	10800084 	addi	r2,r2,2
8113d8a0:	e0bffc15 	stw	r2,-16(fp)
8113d8a4:	e0bffc17 	ldw	r2,-16(fp)
8113d8a8:	10800210 	cmplti	r2,r2,8
8113d8ac:	103fde1e 	bne	r2,zero,8113d828 <__reset+0xfb11d828>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113d8b0:	e03ffc15 	stw	zero,-16(fp)
8113d8b4:	00001306 	br	8113d904 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113d8b8:	e0fffe17 	ldw	r3,-8(fp)
8113d8bc:	e0bffc17 	ldw	r2,-16(fp)
8113d8c0:	1885883a 	add	r2,r3,r2
8113d8c4:	1007883a 	mov	r3,r2
8113d8c8:	d0a0ad17 	ldw	r2,-32076(gp)
8113d8cc:	10800a17 	ldw	r2,40(r2)
8113d8d0:	1885883a 	add	r2,r3,r2
8113d8d4:	10800204 	addi	r2,r2,8
8113d8d8:	1009883a 	mov	r4,r2
8113d8dc:	e0ffff17 	ldw	r3,-4(fp)
8113d8e0:	e0bffc17 	ldw	r2,-16(fp)
8113d8e4:	1885883a 	add	r2,r3,r2
8113d8e8:	10800204 	addi	r2,r2,8
8113d8ec:	10800003 	ldbu	r2,0(r2)
8113d8f0:	10803fcc 	andi	r2,r2,255
8113d8f4:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113d8f8:	e0bffc17 	ldw	r2,-16(fp)
8113d8fc:	10800044 	addi	r2,r2,1
8113d900:	e0bffc15 	stw	r2,-16(fp)
8113d904:	e0bffc17 	ldw	r2,-16(fp)
8113d908:	108000d0 	cmplti	r2,r2,3
8113d90c:	103fea1e 	bne	r2,zero,8113d8b8 <__reset+0xfb11d8b8>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113d910:	d0a0ad17 	ldw	r2,-32076(gp)
8113d914:	10c00a17 	ldw	r3,40(r2)
8113d918:	e0bffe17 	ldw	r2,-8(fp)
8113d91c:	1885883a 	add	r2,r3,r2
8113d920:	108002c4 	addi	r2,r2,11
8113d924:	1007883a 	mov	r3,r2
8113d928:	e0bfff17 	ldw	r2,-4(fp)
8113d92c:	108002c3 	ldbu	r2,11(r2)
8113d930:	10803fcc 	andi	r2,r2,255
8113d934:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113d938:	d0a0ad17 	ldw	r2,-32076(gp)
8113d93c:	10c00a17 	ldw	r3,40(r2)
8113d940:	e0bffe17 	ldw	r2,-8(fp)
8113d944:	1885883a 	add	r2,r3,r2
8113d948:	10800384 	addi	r2,r2,14
8113d94c:	1007883a 	mov	r3,r2
8113d950:	e0bfff17 	ldw	r2,-4(fp)
8113d954:	1080030b 	ldhu	r2,12(r2)
8113d958:	10bfffcc 	andi	r2,r2,65535
8113d95c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113d960:	d0a0ad17 	ldw	r2,-32076(gp)
8113d964:	10c00a17 	ldw	r3,40(r2)
8113d968:	e0bffe17 	ldw	r2,-8(fp)
8113d96c:	1885883a 	add	r2,r3,r2
8113d970:	10800404 	addi	r2,r2,16
8113d974:	1007883a 	mov	r3,r2
8113d978:	e0bfff17 	ldw	r2,-4(fp)
8113d97c:	1080038b 	ldhu	r2,14(r2)
8113d980:	10bfffcc 	andi	r2,r2,65535
8113d984:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113d988:	d0a0ad17 	ldw	r2,-32076(gp)
8113d98c:	10c00a17 	ldw	r3,40(r2)
8113d990:	e0bffe17 	ldw	r2,-8(fp)
8113d994:	1885883a 	add	r2,r3,r2
8113d998:	10800484 	addi	r2,r2,18
8113d99c:	1007883a 	mov	r3,r2
8113d9a0:	e0bfff17 	ldw	r2,-4(fp)
8113d9a4:	1080040b 	ldhu	r2,16(r2)
8113d9a8:	10bfffcc 	andi	r2,r2,65535
8113d9ac:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113d9b0:	d0a0ad17 	ldw	r2,-32076(gp)
8113d9b4:	10c00a17 	ldw	r3,40(r2)
8113d9b8:	e0bffe17 	ldw	r2,-8(fp)
8113d9bc:	1885883a 	add	r2,r3,r2
8113d9c0:	10800584 	addi	r2,r2,22
8113d9c4:	1007883a 	mov	r3,r2
8113d9c8:	e0bfff17 	ldw	r2,-4(fp)
8113d9cc:	1080048b 	ldhu	r2,18(r2)
8113d9d0:	10bfffcc 	andi	r2,r2,65535
8113d9d4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113d9d8:	d0a0ad17 	ldw	r2,-32076(gp)
8113d9dc:	10c00a17 	ldw	r3,40(r2)
8113d9e0:	e0bffe17 	ldw	r2,-8(fp)
8113d9e4:	1885883a 	add	r2,r3,r2
8113d9e8:	10800604 	addi	r2,r2,24
8113d9ec:	1007883a 	mov	r3,r2
8113d9f0:	e0bfff17 	ldw	r2,-4(fp)
8113d9f4:	1080050b 	ldhu	r2,20(r2)
8113d9f8:	10bfffcc 	andi	r2,r2,65535
8113d9fc:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113da00:	d0a0ad17 	ldw	r2,-32076(gp)
8113da04:	10c00a17 	ldw	r3,40(r2)
8113da08:	e0bffe17 	ldw	r2,-8(fp)
8113da0c:	1885883a 	add	r2,r3,r2
8113da10:	10800684 	addi	r2,r2,26
8113da14:	1007883a 	mov	r3,r2
8113da18:	e0bfff17 	ldw	r2,-4(fp)
8113da1c:	1080058b 	ldhu	r2,22(r2)
8113da20:	10bfffcc 	andi	r2,r2,65535
8113da24:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113da28:	d0a0ad17 	ldw	r2,-32076(gp)
8113da2c:	10c00a17 	ldw	r3,40(r2)
8113da30:	e0bffe17 	ldw	r2,-8(fp)
8113da34:	1885883a 	add	r2,r3,r2
8113da38:	10800704 	addi	r2,r2,28
8113da3c:	1007883a 	mov	r3,r2
8113da40:	e0bfff17 	ldw	r2,-4(fp)
8113da44:	10800617 	ldw	r2,24(r2)
8113da48:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113da4c:	00800044 	movi	r2,1
8113da50:	d0a0ae15 	stw	r2,-32072(gp)
        result = true;
8113da54:	00800044 	movi	r2,1
8113da58:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113da5c:	e0bffb17 	ldw	r2,-20(fp)
}
8113da60:	e037883a 	mov	sp,fp
8113da64:	dfc00117 	ldw	ra,4(sp)
8113da68:	df000017 	ldw	fp,0(sp)
8113da6c:	dec00204 	addi	sp,sp,8
8113da70:	f800283a 	ret

8113da74 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113da74:	defff904 	addi	sp,sp,-28
8113da78:	de00012e 	bgeu	sp,et,8113da80 <Check_for_DOS_FAT+0xc>
8113da7c:	003b68fa 	trap	3
8113da80:	dfc00615 	stw	ra,24(sp)
8113da84:	df000515 	stw	fp,20(sp)
8113da88:	df000504 	addi	fp,sp,20
8113da8c:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113da90:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113da94:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113da98:	e17fff17 	ldw	r5,-4(fp)
8113da9c:	0009883a 	mov	r4,zero
8113daa0:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113daa4:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113daa8:	d0a0ad17 	ldw	r2,-32076(gp)
8113daac:	10800a17 	ldw	r2,40(r2)
8113dab0:	10807f84 	addi	r2,r2,510
8113dab4:	1080002b 	ldhuio	r2,0(r2)
8113dab8:	10bfffcc 	andi	r2,r2,65535
8113dabc:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113dac0:	e0bffe0f 	ldh	r2,-8(fp)
8113dac4:	10ffffcc 	andi	r3,r2,65535
8113dac8:	00aa9554 	movui	r2,43605
8113dacc:	1881841e 	bne	r3,r2,8113e0e0 <Check_for_DOS_FAT+0x66c>
8113dad0:	e0bffb17 	ldw	r2,-20(fp)
8113dad4:	10018226 	beq	r2,zero,8113e0e0 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113dad8:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113dadc:	d0a0ad17 	ldw	r2,-32076(gp)
8113dae0:	10800a17 	ldw	r2,40(r2)
8113dae4:	10800023 	ldbuio	r2,0(r2)
8113dae8:	10803fcc 	andi	r2,r2,255
8113daec:	1007883a 	mov	r3,r2
8113daf0:	00a045b4 	movhi	r2,33046
8113daf4:	109b3304 	addi	r2,r2,27852
8113daf8:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113dafc:	d0a0ad17 	ldw	r2,-32076(gp)
8113db00:	10800a17 	ldw	r2,40(r2)
8113db04:	10800044 	addi	r2,r2,1
8113db08:	10800023 	ldbuio	r2,0(r2)
8113db0c:	10803fcc 	andi	r2,r2,255
8113db10:	1007883a 	mov	r3,r2
8113db14:	00a045b4 	movhi	r2,33046
8113db18:	109b3304 	addi	r2,r2,27852
8113db1c:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113db20:	d0a0ad17 	ldw	r2,-32076(gp)
8113db24:	10800a17 	ldw	r2,40(r2)
8113db28:	10800084 	addi	r2,r2,2
8113db2c:	10800023 	ldbuio	r2,0(r2)
8113db30:	10803fcc 	andi	r2,r2,255
8113db34:	1007883a 	mov	r3,r2
8113db38:	00a045b4 	movhi	r2,33046
8113db3c:	109b3304 	addi	r2,r2,27852
8113db40:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113db44:	e03ffc15 	stw	zero,-16(fp)
8113db48:	00001106 	br	8113db90 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113db4c:	d0a0ad17 	ldw	r2,-32076(gp)
8113db50:	10c00a17 	ldw	r3,40(r2)
8113db54:	e0bffc17 	ldw	r2,-16(fp)
8113db58:	1885883a 	add	r2,r3,r2
8113db5c:	108000c4 	addi	r2,r2,3
8113db60:	10800023 	ldbuio	r2,0(r2)
8113db64:	10803fcc 	andi	r2,r2,255
8113db68:	1009883a 	mov	r4,r2
8113db6c:	00a045b4 	movhi	r2,33046
8113db70:	109b3304 	addi	r2,r2,27852
8113db74:	e0fffc17 	ldw	r3,-16(fp)
8113db78:	10c5883a 	add	r2,r2,r3
8113db7c:	108000c4 	addi	r2,r2,3
8113db80:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113db84:	e0bffc17 	ldw	r2,-16(fp)
8113db88:	10800044 	addi	r2,r2,1
8113db8c:	e0bffc15 	stw	r2,-16(fp)
8113db90:	e0bffc17 	ldw	r2,-16(fp)
8113db94:	10800210 	cmplti	r2,r2,8
8113db98:	103fec1e 	bne	r2,zero,8113db4c <__reset+0xfb11db4c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113db9c:	d0a0ad17 	ldw	r2,-32076(gp)
8113dba0:	10800a17 	ldw	r2,40(r2)
8113dba4:	10800304 	addi	r2,r2,12
8113dba8:	10800023 	ldbuio	r2,0(r2)
8113dbac:	10803fcc 	andi	r2,r2,255
8113dbb0:	1004923a 	slli	r2,r2,8
8113dbb4:	1007883a 	mov	r3,r2
8113dbb8:	d0a0ad17 	ldw	r2,-32076(gp)
8113dbbc:	10800a17 	ldw	r2,40(r2)
8113dbc0:	108002c4 	addi	r2,r2,11
8113dbc4:	10800023 	ldbuio	r2,0(r2)
8113dbc8:	10803fcc 	andi	r2,r2,255
8113dbcc:	10803fcc 	andi	r2,r2,255
8113dbd0:	1080201c 	xori	r2,r2,128
8113dbd4:	10bfe004 	addi	r2,r2,-128
8113dbd8:	1884b03a 	or	r2,r3,r2
8113dbdc:	1007883a 	mov	r3,r2
8113dbe0:	00a045b4 	movhi	r2,33046
8113dbe4:	109b3304 	addi	r2,r2,27852
8113dbe8:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113dbec:	d0a0ad17 	ldw	r2,-32076(gp)
8113dbf0:	10800a17 	ldw	r2,40(r2)
8113dbf4:	10800344 	addi	r2,r2,13
8113dbf8:	10800023 	ldbuio	r2,0(r2)
8113dbfc:	10803fcc 	andi	r2,r2,255
8113dc00:	1007883a 	mov	r3,r2
8113dc04:	00a045b4 	movhi	r2,33046
8113dc08:	109b3304 	addi	r2,r2,27852
8113dc0c:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113dc10:	d0a0ad17 	ldw	r2,-32076(gp)
8113dc14:	10800a17 	ldw	r2,40(r2)
8113dc18:	10800384 	addi	r2,r2,14
8113dc1c:	1080002b 	ldhuio	r2,0(r2)
8113dc20:	10bfffcc 	andi	r2,r2,65535
8113dc24:	1007883a 	mov	r3,r2
8113dc28:	00a045b4 	movhi	r2,33046
8113dc2c:	109b3304 	addi	r2,r2,27852
8113dc30:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113dc34:	d0a0ad17 	ldw	r2,-32076(gp)
8113dc38:	10800a17 	ldw	r2,40(r2)
8113dc3c:	10800404 	addi	r2,r2,16
8113dc40:	10800023 	ldbuio	r2,0(r2)
8113dc44:	10803fcc 	andi	r2,r2,255
8113dc48:	1007883a 	mov	r3,r2
8113dc4c:	00a045b4 	movhi	r2,33046
8113dc50:	109b3304 	addi	r2,r2,27852
8113dc54:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113dc58:	d0a0ad17 	ldw	r2,-32076(gp)
8113dc5c:	10800a17 	ldw	r2,40(r2)
8113dc60:	10800484 	addi	r2,r2,18
8113dc64:	10800023 	ldbuio	r2,0(r2)
8113dc68:	10803fcc 	andi	r2,r2,255
8113dc6c:	1004923a 	slli	r2,r2,8
8113dc70:	1007883a 	mov	r3,r2
8113dc74:	d0a0ad17 	ldw	r2,-32076(gp)
8113dc78:	10800a17 	ldw	r2,40(r2)
8113dc7c:	10800444 	addi	r2,r2,17
8113dc80:	10800023 	ldbuio	r2,0(r2)
8113dc84:	10803fcc 	andi	r2,r2,255
8113dc88:	10803fcc 	andi	r2,r2,255
8113dc8c:	1884b03a 	or	r2,r3,r2
8113dc90:	1007883a 	mov	r3,r2
8113dc94:	00a045b4 	movhi	r2,33046
8113dc98:	109b3304 	addi	r2,r2,27852
8113dc9c:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113dca0:	d0a0ad17 	ldw	r2,-32076(gp)
8113dca4:	10800a17 	ldw	r2,40(r2)
8113dca8:	10800504 	addi	r2,r2,20
8113dcac:	10800023 	ldbuio	r2,0(r2)
8113dcb0:	10803fcc 	andi	r2,r2,255
8113dcb4:	1004923a 	slli	r2,r2,8
8113dcb8:	1007883a 	mov	r3,r2
8113dcbc:	d0a0ad17 	ldw	r2,-32076(gp)
8113dcc0:	10800a17 	ldw	r2,40(r2)
8113dcc4:	108004c4 	addi	r2,r2,19
8113dcc8:	10800023 	ldbuio	r2,0(r2)
8113dccc:	10803fcc 	andi	r2,r2,255
8113dcd0:	10803fcc 	andi	r2,r2,255
8113dcd4:	1884b03a 	or	r2,r3,r2
8113dcd8:	1007883a 	mov	r3,r2
8113dcdc:	00a045b4 	movhi	r2,33046
8113dce0:	109b3304 	addi	r2,r2,27852
8113dce4:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113dce8:	d0a0ad17 	ldw	r2,-32076(gp)
8113dcec:	10800a17 	ldw	r2,40(r2)
8113dcf0:	10800544 	addi	r2,r2,21
8113dcf4:	10800023 	ldbuio	r2,0(r2)
8113dcf8:	10803fcc 	andi	r2,r2,255
8113dcfc:	1007883a 	mov	r3,r2
8113dd00:	00a045b4 	movhi	r2,33046
8113dd04:	109b3304 	addi	r2,r2,27852
8113dd08:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113dd0c:	d0a0ad17 	ldw	r2,-32076(gp)
8113dd10:	10800a17 	ldw	r2,40(r2)
8113dd14:	10800584 	addi	r2,r2,22
8113dd18:	1080002b 	ldhuio	r2,0(r2)
8113dd1c:	10bfffcc 	andi	r2,r2,65535
8113dd20:	1007883a 	mov	r3,r2
8113dd24:	00a045b4 	movhi	r2,33046
8113dd28:	109b3304 	addi	r2,r2,27852
8113dd2c:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113dd30:	d0a0ad17 	ldw	r2,-32076(gp)
8113dd34:	10800a17 	ldw	r2,40(r2)
8113dd38:	10800604 	addi	r2,r2,24
8113dd3c:	1080002b 	ldhuio	r2,0(r2)
8113dd40:	10bfffcc 	andi	r2,r2,65535
8113dd44:	1007883a 	mov	r3,r2
8113dd48:	00a045b4 	movhi	r2,33046
8113dd4c:	109b3304 	addi	r2,r2,27852
8113dd50:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113dd54:	d0a0ad17 	ldw	r2,-32076(gp)
8113dd58:	10800a17 	ldw	r2,40(r2)
8113dd5c:	10800684 	addi	r2,r2,26
8113dd60:	1080002b 	ldhuio	r2,0(r2)
8113dd64:	10bfffcc 	andi	r2,r2,65535
8113dd68:	1007883a 	mov	r3,r2
8113dd6c:	00a045b4 	movhi	r2,33046
8113dd70:	109b3304 	addi	r2,r2,27852
8113dd74:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113dd78:	d0a0ad17 	ldw	r2,-32076(gp)
8113dd7c:	10800a17 	ldw	r2,40(r2)
8113dd80:	10800704 	addi	r2,r2,28
8113dd84:	10800037 	ldwio	r2,0(r2)
8113dd88:	1007883a 	mov	r3,r2
8113dd8c:	00a045b4 	movhi	r2,33046
8113dd90:	109b3304 	addi	r2,r2,27852
8113dd94:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113dd98:	d0a0ad17 	ldw	r2,-32076(gp)
8113dd9c:	10800a17 	ldw	r2,40(r2)
8113dda0:	10800804 	addi	r2,r2,32
8113dda4:	10800037 	ldwio	r2,0(r2)
8113dda8:	1007883a 	mov	r3,r2
8113ddac:	00a045b4 	movhi	r2,33046
8113ddb0:	109b3304 	addi	r2,r2,27852
8113ddb4:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113ddb8:	d0a0ad17 	ldw	r2,-32076(gp)
8113ddbc:	10800a17 	ldw	r2,40(r2)
8113ddc0:	10800904 	addi	r2,r2,36
8113ddc4:	10800023 	ldbuio	r2,0(r2)
8113ddc8:	10803fcc 	andi	r2,r2,255
8113ddcc:	1007883a 	mov	r3,r2
8113ddd0:	00a045b4 	movhi	r2,33046
8113ddd4:	109b3304 	addi	r2,r2,27852
8113ddd8:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113dddc:	d0a0ad17 	ldw	r2,-32076(gp)
8113dde0:	10800a17 	ldw	r2,40(r2)
8113dde4:	10800944 	addi	r2,r2,37
8113dde8:	10800023 	ldbuio	r2,0(r2)
8113ddec:	10803fcc 	andi	r2,r2,255
8113ddf0:	1007883a 	mov	r3,r2
8113ddf4:	00a045b4 	movhi	r2,33046
8113ddf8:	109b3304 	addi	r2,r2,27852
8113ddfc:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113de00:	d0a0ad17 	ldw	r2,-32076(gp)
8113de04:	10800a17 	ldw	r2,40(r2)
8113de08:	10800984 	addi	r2,r2,38
8113de0c:	10800023 	ldbuio	r2,0(r2)
8113de10:	10803fcc 	andi	r2,r2,255
8113de14:	1007883a 	mov	r3,r2
8113de18:	00a045b4 	movhi	r2,33046
8113de1c:	109b3304 	addi	r2,r2,27852
8113de20:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113de24:	00a045b4 	movhi	r2,33046
8113de28:	109b3304 	addi	r2,r2,27852
8113de2c:	1080040b 	ldhu	r2,16(r2)
8113de30:	10ffffcc 	andi	r3,r2,65535
8113de34:	00a045b4 	movhi	r2,33046
8113de38:	109b3304 	addi	r2,r2,27852
8113de3c:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113de40:	00a045b4 	movhi	r2,33046
8113de44:	109b3304 	addi	r2,r2,27852
8113de48:	10c01117 	ldw	r3,68(r2)
8113de4c:	00a045b4 	movhi	r2,33046
8113de50:	109b3304 	addi	r2,r2,27852
8113de54:	1080068b 	ldhu	r2,26(r2)
8113de58:	10bfffcc 	andi	r2,r2,65535
8113de5c:	1887883a 	add	r3,r3,r2
8113de60:	00a045b4 	movhi	r2,33046
8113de64:	109b3304 	addi	r2,r2,27852
8113de68:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113de6c:	00a045b4 	movhi	r2,33046
8113de70:	109b3304 	addi	r2,r2,27852
8113de74:	10c01217 	ldw	r3,72(r2)
8113de78:	00a045b4 	movhi	r2,33046
8113de7c:	109b3304 	addi	r2,r2,27852
8113de80:	1080068b 	ldhu	r2,26(r2)
8113de84:	10bfffcc 	andi	r2,r2,65535
8113de88:	1887883a 	add	r3,r3,r2
8113de8c:	00a045b4 	movhi	r2,33046
8113de90:	109b3304 	addi	r2,r2,27852
8113de94:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113de98:	00a045b4 	movhi	r2,33046
8113de9c:	109b3304 	addi	r2,r2,27852
8113dea0:	10c01317 	ldw	r3,76(r2)
8113dea4:	00a045b4 	movhi	r2,33046
8113dea8:	109b3304 	addi	r2,r2,27852
8113deac:	1080050b 	ldhu	r2,20(r2)
8113deb0:	10bfffcc 	andi	r2,r2,65535
8113deb4:	1008917a 	slli	r4,r2,5
8113deb8:	00a045b4 	movhi	r2,33046
8113debc:	109b3304 	addi	r2,r2,27852
8113dec0:	1080030b 	ldhu	r2,12(r2)
8113dec4:	10bfffcc 	andi	r2,r2,65535
8113dec8:	2085283a 	div	r2,r4,r2
8113decc:	1887883a 	add	r3,r3,r2
8113ded0:	00a045b4 	movhi	r2,33046
8113ded4:	109b3304 	addi	r2,r2,27852
8113ded8:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113dedc:	00a045b4 	movhi	r2,33046
8113dee0:	109b3304 	addi	r2,r2,27852
8113dee4:	1080058b 	ldhu	r2,22(r2)
8113dee8:	10bfffcc 	andi	r2,r2,65535
8113deec:	10000b26 	beq	r2,zero,8113df1c <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113def0:	00a045b4 	movhi	r2,33046
8113def4:	109b3304 	addi	r2,r2,27852
8113def8:	1080058b 	ldhu	r2,22(r2)
8113defc:	10ffffcc 	andi	r3,r2,65535
8113df00:	00a045b4 	movhi	r2,33046
8113df04:	109b3304 	addi	r2,r2,27852
8113df08:	10800383 	ldbu	r2,14(r2)
8113df0c:	10803fcc 	andi	r2,r2,255
8113df10:	1885283a 	div	r2,r3,r2
8113df14:	e0bffd15 	stw	r2,-12(fp)
8113df18:	00000906 	br	8113df40 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113df1c:	00a045b4 	movhi	r2,33046
8113df20:	109b3304 	addi	r2,r2,27852
8113df24:	10c00917 	ldw	r3,36(r2)
8113df28:	00a045b4 	movhi	r2,33046
8113df2c:	109b3304 	addi	r2,r2,27852
8113df30:	10800383 	ldbu	r2,14(r2)
8113df34:	10803fcc 	andi	r2,r2,255
8113df38:	1885203a 	divu	r2,r3,r2
8113df3c:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113df40:	e0bffd17 	ldw	r2,-12(fp)
8113df44:	1083fdc8 	cmpgei	r2,r2,4087
8113df48:	1000051e 	bne	r2,zero,8113df60 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113df4c:	00a045b4 	movhi	r2,33046
8113df50:	109b3304 	addi	r2,r2,27852
8113df54:	00c00304 	movi	r3,12
8113df58:	10c01085 	stb	r3,66(r2)
8113df5c:	00000c06 	br	8113df90 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113df60:	e0bffd17 	ldw	r2,-12(fp)
8113df64:	00fffb54 	movui	r3,65517
8113df68:	18800516 	blt	r3,r2,8113df80 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113df6c:	00a045b4 	movhi	r2,33046
8113df70:	109b3304 	addi	r2,r2,27852
8113df74:	00c00404 	movi	r3,16
8113df78:	10c01085 	stb	r3,66(r2)
8113df7c:	00000406 	br	8113df90 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113df80:	00a045b4 	movhi	r2,33046
8113df84:	109b3304 	addi	r2,r2,27852
8113df88:	00c00804 	movi	r3,32
8113df8c:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113df90:	e03ffc15 	stw	zero,-16(fp)
8113df94:	00001106 	br	8113dfdc <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113df98:	d0a0ad17 	ldw	r2,-32076(gp)
8113df9c:	10c00a17 	ldw	r3,40(r2)
8113dfa0:	e0bffc17 	ldw	r2,-16(fp)
8113dfa4:	1885883a 	add	r2,r3,r2
8113dfa8:	108009c4 	addi	r2,r2,39
8113dfac:	10800023 	ldbuio	r2,0(r2)
8113dfb0:	10803fcc 	andi	r2,r2,255
8113dfb4:	1009883a 	mov	r4,r2
8113dfb8:	00a045b4 	movhi	r2,33046
8113dfbc:	109b3304 	addi	r2,r2,27852
8113dfc0:	e0fffc17 	ldw	r3,-16(fp)
8113dfc4:	10c5883a 	add	r2,r2,r3
8113dfc8:	10800ac4 	addi	r2,r2,43
8113dfcc:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113dfd0:	e0bffc17 	ldw	r2,-16(fp)
8113dfd4:	10800044 	addi	r2,r2,1
8113dfd8:	e0bffc15 	stw	r2,-16(fp)
8113dfdc:	e0bffc17 	ldw	r2,-16(fp)
8113dfe0:	10800110 	cmplti	r2,r2,4
8113dfe4:	103fec1e 	bne	r2,zero,8113df98 <__reset+0xfb11df98>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113dfe8:	e03ffc15 	stw	zero,-16(fp)
8113dfec:	00001106 	br	8113e034 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113dff0:	d0a0ad17 	ldw	r2,-32076(gp)
8113dff4:	10c00a17 	ldw	r3,40(r2)
8113dff8:	e0bffc17 	ldw	r2,-16(fp)
8113dffc:	1885883a 	add	r2,r3,r2
8113e000:	10800ac4 	addi	r2,r2,43
8113e004:	10800023 	ldbuio	r2,0(r2)
8113e008:	10803fcc 	andi	r2,r2,255
8113e00c:	1009883a 	mov	r4,r2
8113e010:	00a045b4 	movhi	r2,33046
8113e014:	109b3304 	addi	r2,r2,27852
8113e018:	e0fffc17 	ldw	r3,-16(fp)
8113e01c:	10c5883a 	add	r2,r2,r3
8113e020:	10800bc4 	addi	r2,r2,47
8113e024:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113e028:	e0bffc17 	ldw	r2,-16(fp)
8113e02c:	10800044 	addi	r2,r2,1
8113e030:	e0bffc15 	stw	r2,-16(fp)
8113e034:	e0bffc17 	ldw	r2,-16(fp)
8113e038:	108002d0 	cmplti	r2,r2,11
8113e03c:	103fec1e 	bne	r2,zero,8113dff0 <__reset+0xfb11dff0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113e040:	e03ffc15 	stw	zero,-16(fp)
8113e044:	00001106 	br	8113e08c <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113e048:	d0a0ad17 	ldw	r2,-32076(gp)
8113e04c:	10c00a17 	ldw	r3,40(r2)
8113e050:	e0bffc17 	ldw	r2,-16(fp)
8113e054:	1885883a 	add	r2,r3,r2
8113e058:	10800d84 	addi	r2,r2,54
8113e05c:	10800023 	ldbuio	r2,0(r2)
8113e060:	10803fcc 	andi	r2,r2,255
8113e064:	1009883a 	mov	r4,r2
8113e068:	00a045b4 	movhi	r2,33046
8113e06c:	109b3304 	addi	r2,r2,27852
8113e070:	e0fffc17 	ldw	r3,-16(fp)
8113e074:	10c5883a 	add	r2,r2,r3
8113e078:	10800e84 	addi	r2,r2,58
8113e07c:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113e080:	e0bffc17 	ldw	r2,-16(fp)
8113e084:	10800044 	addi	r2,r2,1
8113e088:	e0bffc15 	stw	r2,-16(fp)
8113e08c:	e0bffc17 	ldw	r2,-16(fp)
8113e090:	10800210 	cmplti	r2,r2,8
8113e094:	103fec1e 	bne	r2,zero,8113e048 <__reset+0xfb11e048>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113e098:	e03ffc15 	stw	zero,-16(fp)
8113e09c:	00000a06 	br	8113e0c8 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113e0a0:	00a045b4 	movhi	r2,33046
8113e0a4:	109b4804 	addi	r2,r2,27936
8113e0a8:	e0fffc17 	ldw	r3,-16(fp)
8113e0ac:	180691ba 	slli	r3,r3,6
8113e0b0:	10c5883a 	add	r2,r2,r3
8113e0b4:	10800f04 	addi	r2,r2,60
8113e0b8:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113e0bc:	e0bffc17 	ldw	r2,-16(fp)
8113e0c0:	10800044 	addi	r2,r2,1
8113e0c4:	e0bffc15 	stw	r2,-16(fp)
8113e0c8:	e0bffc17 	ldw	r2,-16(fp)
8113e0cc:	10800510 	cmplti	r2,r2,20
8113e0d0:	103ff31e 	bne	r2,zero,8113e0a0 <__reset+0xfb11e0a0>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113e0d4:	00800044 	movi	r2,1
8113e0d8:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113e0dc:	00000106 	br	8113e0e4 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113e0e0:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113e0e4:	e0bffb17 	ldw	r2,-20(fp)
}
8113e0e8:	e037883a 	mov	sp,fp
8113e0ec:	dfc00117 	ldw	ra,4(sp)
8113e0f0:	df000017 	ldw	fp,0(sp)
8113e0f4:	dec00204 	addi	sp,sp,8
8113e0f8:	f800283a 	ret

8113e0fc <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113e0fc:	defffc04 	addi	sp,sp,-16
8113e100:	de00012e 	bgeu	sp,et,8113e108 <Look_for_FAT16+0xc>
8113e104:	003b68fa 	trap	3
8113e108:	dfc00315 	stw	ra,12(sp)
8113e10c:	df000215 	stw	fp,8(sp)
8113e110:	df000204 	addi	fp,sp,8
	bool result = false;
8113e114:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113e118:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113e11c:	10002e26 	beq	r2,zero,8113e1d8 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113e120:	d0a0a717 	ldw	r2,-32100(gp)
8113e124:	1080000b 	ldhu	r2,0(r2)
8113e128:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113e12c:	d020ab15 	stw	zero,-32084(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113e130:	d020ac15 	stw	zero,-32080(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113e134:	e0bfff0f 	ldh	r2,-4(fp)
8113e138:	10002716 	blt	r2,zero,8113e1d8 <Look_for_FAT16+0xdc>
8113e13c:	e0bfff0b 	ldhu	r2,-4(fp)
8113e140:	10bfffcc 	andi	r2,r2,65535
8113e144:	1083000c 	andi	r2,r2,3072
8113e148:	10830020 	cmpeqi	r2,r2,3072
8113e14c:	1000221e 	bne	r2,zero,8113e1d8 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113e150:	e0bfff0b 	ldhu	r2,-4(fp)
8113e154:	10bfffcc 	andi	r2,r2,65535
8113e158:	1083000c 	andi	r2,r2,3072
8113e15c:	10810018 	cmpnei	r2,r2,1024
8113e160:	1000031e 	bne	r2,zero,8113e170 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113e164:	0009883a 	mov	r4,zero
8113e168:	113da740 	call	8113da74 <Check_for_DOS_FAT>
8113e16c:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113e170:	e0bfff0b 	ldhu	r2,-4(fp)
8113e174:	10bfffcc 	andi	r2,r2,65535
8113e178:	1083000c 	andi	r2,r2,3072
8113e17c:	1000061e 	bne	r2,zero,8113e198 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113e180:	113d3b00 	call	8113d3b0 <Check_for_Master_Boot_Record>
8113e184:	10000426 	beq	r2,zero,8113e198 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113e188:	d0a0ab17 	ldw	r2,-32084(gp)
8113e18c:	1009883a 	mov	r4,r2
8113e190:	113da740 	call	8113da74 <Check_for_DOS_FAT>
8113e194:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113e198:	e0bffe17 	ldw	r2,-8(fp)
8113e19c:	10800058 	cmpnei	r2,r2,1
8113e1a0:	10000d1e 	bne	r2,zero,8113e1d8 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113e1a4:	00a045b4 	movhi	r2,33046
8113e1a8:	109b3304 	addi	r2,r2,27852
8113e1ac:	10801083 	ldbu	r2,66(r2)
8113e1b0:	10803fcc 	andi	r2,r2,255
8113e1b4:	10800420 	cmpeqi	r2,r2,16
8113e1b8:	1000021e 	bne	r2,zero,8113e1c4 <Look_for_FAT16+0xc8>
				{
					result = false;
8113e1bc:	e03ffe15 	stw	zero,-8(fp)
8113e1c0:	00000506 	br	8113e1d8 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113e1c4:	00a045b4 	movhi	r2,33046
8113e1c8:	109b3304 	addi	r2,r2,27852
8113e1cc:	1080058b 	ldhu	r2,22(r2)
8113e1d0:	10bfffcc 	andi	r2,r2,65535
8113e1d4:	d0a0ac15 	stw	r2,-32080(gp)
				}
			}
		}
	}
	return result;
8113e1d8:	e0bffe17 	ldw	r2,-8(fp)
}
8113e1dc:	e037883a 	mov	sp,fp
8113e1e0:	dfc00117 	ldw	ra,4(sp)
8113e1e4:	df000017 	ldw	fp,0(sp)
8113e1e8:	dec00204 	addi	sp,sp,8
8113e1ec:	f800283a 	ret

8113e1f0 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113e1f0:	defffb04 	addi	sp,sp,-20
8113e1f4:	de00012e 	bgeu	sp,et,8113e1fc <filename_to_upper_case+0xc>
8113e1f8:	003b68fa 	trap	3
8113e1fc:	dfc00415 	stw	ra,16(sp)
8113e200:	df000315 	stw	fp,12(sp)
8113e204:	df000304 	addi	fp,sp,12
8113e208:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113e20c:	e13fff17 	ldw	r4,-4(fp)
8113e210:	111d6400 	call	8111d640 <strlen>
8113e214:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113e218:	e03ffd15 	stw	zero,-12(fp)
8113e21c:	00001e06 	br	8113e298 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113e220:	e0bffd17 	ldw	r2,-12(fp)
8113e224:	e0ffff17 	ldw	r3,-4(fp)
8113e228:	1885883a 	add	r2,r3,r2
8113e22c:	10800003 	ldbu	r2,0(r2)
8113e230:	10803fcc 	andi	r2,r2,255
8113e234:	1080201c 	xori	r2,r2,128
8113e238:	10bfe004 	addi	r2,r2,-128
8113e23c:	10801850 	cmplti	r2,r2,97
8113e240:	1000121e 	bne	r2,zero,8113e28c <filename_to_upper_case+0x9c>
8113e244:	e0bffd17 	ldw	r2,-12(fp)
8113e248:	e0ffff17 	ldw	r3,-4(fp)
8113e24c:	1885883a 	add	r2,r3,r2
8113e250:	10800003 	ldbu	r2,0(r2)
8113e254:	10803fcc 	andi	r2,r2,255
8113e258:	1080201c 	xori	r2,r2,128
8113e25c:	10bfe004 	addi	r2,r2,-128
8113e260:	10801ec8 	cmpgei	r2,r2,123
8113e264:	1000091e 	bne	r2,zero,8113e28c <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113e268:	e0bffd17 	ldw	r2,-12(fp)
8113e26c:	e0ffff17 	ldw	r3,-4(fp)
8113e270:	1885883a 	add	r2,r3,r2
8113e274:	e0fffd17 	ldw	r3,-12(fp)
8113e278:	e13fff17 	ldw	r4,-4(fp)
8113e27c:	20c7883a 	add	r3,r4,r3
8113e280:	18c00003 	ldbu	r3,0(r3)
8113e284:	18fff804 	addi	r3,r3,-32
8113e288:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113e28c:	e0bffd17 	ldw	r2,-12(fp)
8113e290:	10800044 	addi	r2,r2,1
8113e294:	e0bffd15 	stw	r2,-12(fp)
8113e298:	e0fffd17 	ldw	r3,-12(fp)
8113e29c:	e0bffe17 	ldw	r2,-8(fp)
8113e2a0:	18bfdf16 	blt	r3,r2,8113e220 <__reset+0xfb11e220>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113e2a4:	0001883a 	nop
8113e2a8:	e037883a 	mov	sp,fp
8113e2ac:	dfc00117 	ldw	ra,4(sp)
8113e2b0:	df000017 	ldw	fp,0(sp)
8113e2b4:	dec00204 	addi	sp,sp,8
8113e2b8:	f800283a 	ret

8113e2bc <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113e2bc:	defff804 	addi	sp,sp,-32
8113e2c0:	de00012e 	bgeu	sp,et,8113e2c8 <check_file_name_for_FAT16_compliance+0xc>
8113e2c4:	003b68fa 	trap	3
8113e2c8:	dfc00715 	stw	ra,28(sp)
8113e2cc:	df000615 	stw	fp,24(sp)
8113e2d0:	df000604 	addi	fp,sp,24
8113e2d4:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113e2d8:	e13fff17 	ldw	r4,-4(fp)
8113e2dc:	111d6400 	call	8111d640 <strlen>
8113e2e0:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8113e2e4:	00bfffc4 	movi	r2,-1
8113e2e8:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113e2ec:	00bfffc4 	movi	r2,-1
8113e2f0:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8113e2f4:	00800044 	movi	r2,1
8113e2f8:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113e2fc:	e03ffa15 	stw	zero,-24(fp)
8113e300:	00006d06 	br	8113e4b8 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8113e304:	e0bffa17 	ldw	r2,-24(fp)
8113e308:	e0ffff17 	ldw	r3,-4(fp)
8113e30c:	1885883a 	add	r2,r3,r2
8113e310:	10800003 	ldbu	r2,0(r2)
8113e314:	10803fcc 	andi	r2,r2,255
8113e318:	1080201c 	xori	r2,r2,128
8113e31c:	10bfe004 	addi	r2,r2,-128
8113e320:	10800820 	cmpeqi	r2,r2,32
8113e324:	10003e1e 	bne	r2,zero,8113e420 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113e328:	e0bffa17 	ldw	r2,-24(fp)
8113e32c:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8113e330:	e0bffb17 	ldw	r2,-20(fp)
8113e334:	1880121e 	bne	r3,r2,8113e380 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113e338:	e0bffa17 	ldw	r2,-24(fp)
8113e33c:	e0ffff17 	ldw	r3,-4(fp)
8113e340:	1885883a 	add	r2,r3,r2
8113e344:	10800003 	ldbu	r2,0(r2)
8113e348:	10803fcc 	andi	r2,r2,255
8113e34c:	1080201c 	xori	r2,r2,128
8113e350:	10bfe004 	addi	r2,r2,-128
8113e354:	10801720 	cmpeqi	r2,r2,92
8113e358:	1000311e 	bne	r2,zero,8113e420 <check_file_name_for_FAT16_compliance+0x164>
8113e35c:	e0bffa17 	ldw	r2,-24(fp)
8113e360:	e0ffff17 	ldw	r3,-4(fp)
8113e364:	1885883a 	add	r2,r3,r2
8113e368:	10800003 	ldbu	r2,0(r2)
8113e36c:	10803fcc 	andi	r2,r2,255
8113e370:	1080201c 	xori	r2,r2,128
8113e374:	10bfe004 	addi	r2,r2,-128
8113e378:	10800be0 	cmpeqi	r2,r2,47
8113e37c:	1000281e 	bne	r2,zero,8113e420 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113e380:	e0fffa17 	ldw	r3,-24(fp)
8113e384:	e0bffc17 	ldw	r2,-16(fp)
8113e388:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113e38c:	10800258 	cmpnei	r2,r2,9
8113e390:	1000091e 	bne	r2,zero,8113e3b8 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113e394:	e0bffa17 	ldw	r2,-24(fp)
8113e398:	e0ffff17 	ldw	r3,-4(fp)
8113e39c:	1885883a 	add	r2,r3,r2
8113e3a0:	10800003 	ldbu	r2,0(r2)
8113e3a4:	10803fcc 	andi	r2,r2,255
8113e3a8:	1080201c 	xori	r2,r2,128
8113e3ac:	10bfe004 	addi	r2,r2,-128
8113e3b0:	10800b98 	cmpnei	r2,r2,46
8113e3b4:	10001a1e 	bne	r2,zero,8113e420 <check_file_name_for_FAT16_compliance+0x164>
8113e3b8:	e0fffb17 	ldw	r3,-20(fp)
8113e3bc:	e0bffc17 	ldw	r2,-16(fp)
8113e3c0:	18801926 	beq	r3,r2,8113e428 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113e3c4:	e0fffa17 	ldw	r3,-24(fp)
8113e3c8:	e0bffc17 	ldw	r2,-16(fp)
8113e3cc:	1885c83a 	sub	r2,r3,r2
8113e3d0:	10800110 	cmplti	r2,r2,4
8113e3d4:	1000141e 	bne	r2,zero,8113e428 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113e3d8:	e0bffa17 	ldw	r2,-24(fp)
8113e3dc:	e0ffff17 	ldw	r3,-4(fp)
8113e3e0:	1885883a 	add	r2,r3,r2
8113e3e4:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113e3e8:	10803fcc 	andi	r2,r2,255
8113e3ec:	1080201c 	xori	r2,r2,128
8113e3f0:	10bfe004 	addi	r2,r2,-128
8113e3f4:	10801720 	cmpeqi	r2,r2,92
8113e3f8:	10000b1e 	bne	r2,zero,8113e428 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113e3fc:	e0bffa17 	ldw	r2,-24(fp)
8113e400:	e0ffff17 	ldw	r3,-4(fp)
8113e404:	1885883a 	add	r2,r3,r2
8113e408:	10800003 	ldbu	r2,0(r2)
8113e40c:	10803fcc 	andi	r2,r2,255
8113e410:	1080201c 	xori	r2,r2,128
8113e414:	10bfe004 	addi	r2,r2,-128
8113e418:	10800be0 	cmpeqi	r2,r2,47
8113e41c:	1000021e 	bne	r2,zero,8113e428 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8113e420:	e03ffd15 	stw	zero,-12(fp)
            break;
8113e424:	00002706 	br	8113e4c4 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8113e428:	e0bffa17 	ldw	r2,-24(fp)
8113e42c:	e0ffff17 	ldw	r3,-4(fp)
8113e430:	1885883a 	add	r2,r3,r2
8113e434:	10800003 	ldbu	r2,0(r2)
8113e438:	10803fcc 	andi	r2,r2,255
8113e43c:	1080201c 	xori	r2,r2,128
8113e440:	10bfe004 	addi	r2,r2,-128
8113e444:	10801720 	cmpeqi	r2,r2,92
8113e448:	1000091e 	bne	r2,zero,8113e470 <check_file_name_for_FAT16_compliance+0x1b4>
8113e44c:	e0bffa17 	ldw	r2,-24(fp)
8113e450:	e0ffff17 	ldw	r3,-4(fp)
8113e454:	1885883a 	add	r2,r3,r2
8113e458:	10800003 	ldbu	r2,0(r2)
8113e45c:	10803fcc 	andi	r2,r2,255
8113e460:	1080201c 	xori	r2,r2,128
8113e464:	10bfe004 	addi	r2,r2,-128
8113e468:	10800bd8 	cmpnei	r2,r2,47
8113e46c:	1000041e 	bne	r2,zero,8113e480 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8113e470:	e0bffa17 	ldw	r2,-24(fp)
8113e474:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113e478:	e0bffa17 	ldw	r2,-24(fp)
8113e47c:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8113e480:	e0bffa17 	ldw	r2,-24(fp)
8113e484:	e0ffff17 	ldw	r3,-4(fp)
8113e488:	1885883a 	add	r2,r3,r2
8113e48c:	10800003 	ldbu	r2,0(r2)
8113e490:	10803fcc 	andi	r2,r2,255
8113e494:	1080201c 	xori	r2,r2,128
8113e498:	10bfe004 	addi	r2,r2,-128
8113e49c:	10800b98 	cmpnei	r2,r2,46
8113e4a0:	1000021e 	bne	r2,zero,8113e4ac <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113e4a4:	e0bffa17 	ldw	r2,-24(fp)
8113e4a8:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113e4ac:	e0bffa17 	ldw	r2,-24(fp)
8113e4b0:	10800044 	addi	r2,r2,1
8113e4b4:	e0bffa15 	stw	r2,-24(fp)
8113e4b8:	e0fffa17 	ldw	r3,-24(fp)
8113e4bc:	e0bffe17 	ldw	r2,-8(fp)
8113e4c0:	18bf9016 	blt	r3,r2,8113e304 <__reset+0xfb11e304>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8113e4c4:	e0bffe17 	ldw	r2,-8(fp)
8113e4c8:	10bfffc4 	addi	r2,r2,-1
8113e4cc:	e0ffff17 	ldw	r3,-4(fp)
8113e4d0:	1885883a 	add	r2,r3,r2
8113e4d4:	10800003 	ldbu	r2,0(r2)
8113e4d8:	10803fcc 	andi	r2,r2,255
8113e4dc:	1080201c 	xori	r2,r2,128
8113e4e0:	10bfe004 	addi	r2,r2,-128
8113e4e4:	10801720 	cmpeqi	r2,r2,92
8113e4e8:	10000a1e 	bne	r2,zero,8113e514 <check_file_name_for_FAT16_compliance+0x258>
8113e4ec:	e0bffe17 	ldw	r2,-8(fp)
8113e4f0:	10bfffc4 	addi	r2,r2,-1
8113e4f4:	e0ffff17 	ldw	r3,-4(fp)
8113e4f8:	1885883a 	add	r2,r3,r2
8113e4fc:	10800003 	ldbu	r2,0(r2)
8113e500:	10803fcc 	andi	r2,r2,255
8113e504:	1080201c 	xori	r2,r2,128
8113e508:	10bfe004 	addi	r2,r2,-128
8113e50c:	10800bd8 	cmpnei	r2,r2,47
8113e510:	1000011e 	bne	r2,zero,8113e518 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8113e514:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8113e518:	e0bffd17 	ldw	r2,-12(fp)
}
8113e51c:	e037883a 	mov	sp,fp
8113e520:	dfc00117 	ldw	ra,4(sp)
8113e524:	df000017 	ldw	fp,0(sp)
8113e528:	dec00204 	addi	sp,sp,8
8113e52c:	f800283a 	ret

8113e530 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8113e530:	defffb04 	addi	sp,sp,-20
8113e534:	de00012e 	bgeu	sp,et,8113e53c <get_dir_divider_location+0xc>
8113e538:	003b68fa 	trap	3
8113e53c:	dfc00415 	stw	ra,16(sp)
8113e540:	df000315 	stw	fp,12(sp)
8113e544:	df000304 	addi	fp,sp,12
8113e548:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8113e54c:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8113e550:	e13fff17 	ldw	r4,-4(fp)
8113e554:	111d6400 	call	8111d640 <strlen>
8113e558:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8113e55c:	e03ffd15 	stw	zero,-12(fp)
8113e560:	00001506 	br	8113e5b8 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113e564:	e0bffd17 	ldw	r2,-12(fp)
8113e568:	e0ffff17 	ldw	r3,-4(fp)
8113e56c:	1885883a 	add	r2,r3,r2
8113e570:	10800003 	ldbu	r2,0(r2)
8113e574:	10803fcc 	andi	r2,r2,255
8113e578:	1080201c 	xori	r2,r2,128
8113e57c:	10bfe004 	addi	r2,r2,-128
8113e580:	10801720 	cmpeqi	r2,r2,92
8113e584:	10000f1e 	bne	r2,zero,8113e5c4 <get_dir_divider_location+0x94>
8113e588:	e0bffd17 	ldw	r2,-12(fp)
8113e58c:	e0ffff17 	ldw	r3,-4(fp)
8113e590:	1885883a 	add	r2,r3,r2
8113e594:	10800003 	ldbu	r2,0(r2)
8113e598:	10803fcc 	andi	r2,r2,255
8113e59c:	1080201c 	xori	r2,r2,128
8113e5a0:	10bfe004 	addi	r2,r2,-128
8113e5a4:	10800be0 	cmpeqi	r2,r2,47
8113e5a8:	1000061e 	bne	r2,zero,8113e5c4 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113e5ac:	e0bffd17 	ldw	r2,-12(fp)
8113e5b0:	10800044 	addi	r2,r2,1
8113e5b4:	e0bffd15 	stw	r2,-12(fp)
8113e5b8:	e0fffd17 	ldw	r3,-12(fp)
8113e5bc:	e0bffe17 	ldw	r2,-8(fp)
8113e5c0:	18bfe816 	blt	r3,r2,8113e564 <__reset+0xfb11e564>
        {
            break;
        }
    }
    
    if (index == length)
8113e5c4:	e0fffd17 	ldw	r3,-12(fp)
8113e5c8:	e0bffe17 	ldw	r2,-8(fp)
8113e5cc:	1880021e 	bne	r3,r2,8113e5d8 <get_dir_divider_location+0xa8>
    {
        index = -1;
8113e5d0:	00bfffc4 	movi	r2,-1
8113e5d4:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113e5d8:	e0bffd17 	ldw	r2,-12(fp)
}
8113e5dc:	e037883a 	mov	sp,fp
8113e5e0:	dfc00117 	ldw	ra,4(sp)
8113e5e4:	df000017 	ldw	fp,0(sp)
8113e5e8:	dec00204 	addi	sp,sp,8
8113e5ec:	f800283a 	ret

8113e5f0 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8113e5f0:	defffa04 	addi	sp,sp,-24
8113e5f4:	de00012e 	bgeu	sp,et,8113e5fc <match_file_record_to_name_ext+0xc>
8113e5f8:	003b68fa 	trap	3
8113e5fc:	df000515 	stw	fp,20(sp)
8113e600:	df000504 	addi	fp,sp,20
8113e604:	e13ffd15 	stw	r4,-12(fp)
8113e608:	e17ffe15 	stw	r5,-8(fp)
8113e60c:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8113e610:	00800044 	movi	r2,1
8113e614:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8113e618:	e03ffc15 	stw	zero,-16(fp)
8113e61c:	00004606 	br	8113e738 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8113e620:	e0fffd17 	ldw	r3,-12(fp)
8113e624:	e0bffc17 	ldw	r2,-16(fp)
8113e628:	1885883a 	add	r2,r3,r2
8113e62c:	10800003 	ldbu	r2,0(r2)
8113e630:	10803fcc 	andi	r2,r2,255
8113e634:	10801870 	cmpltui	r2,r2,97
8113e638:	1000101e 	bne	r2,zero,8113e67c <match_file_record_to_name_ext+0x8c>
8113e63c:	e0fffd17 	ldw	r3,-12(fp)
8113e640:	e0bffc17 	ldw	r2,-16(fp)
8113e644:	1885883a 	add	r2,r3,r2
8113e648:	10800003 	ldbu	r2,0(r2)
8113e64c:	10803fcc 	andi	r2,r2,255
8113e650:	10801ee8 	cmpgeui	r2,r2,123
8113e654:	1000091e 	bne	r2,zero,8113e67c <match_file_record_to_name_ext+0x8c>
8113e658:	e0fffd17 	ldw	r3,-12(fp)
8113e65c:	e0bffc17 	ldw	r2,-16(fp)
8113e660:	1885883a 	add	r2,r3,r2
8113e664:	10800003 	ldbu	r2,0(r2)
8113e668:	10bff804 	addi	r2,r2,-32
8113e66c:	10c03fcc 	andi	r3,r2,255
8113e670:	18c0201c 	xori	r3,r3,128
8113e674:	18ffe004 	addi	r3,r3,-128
8113e678:	00000706 	br	8113e698 <match_file_record_to_name_ext+0xa8>
8113e67c:	e0fffd17 	ldw	r3,-12(fp)
8113e680:	e0bffc17 	ldw	r2,-16(fp)
8113e684:	1885883a 	add	r2,r3,r2
8113e688:	10800003 	ldbu	r2,0(r2)
8113e68c:	10c03fcc 	andi	r3,r2,255
8113e690:	18c0201c 	xori	r3,r3,128
8113e694:	18ffe004 	addi	r3,r3,-128
8113e698:	e0bffc17 	ldw	r2,-16(fp)
8113e69c:	e13ffe17 	ldw	r4,-8(fp)
8113e6a0:	2085883a 	add	r2,r4,r2
8113e6a4:	10800003 	ldbu	r2,0(r2)
8113e6a8:	10803fcc 	andi	r2,r2,255
8113e6ac:	1080201c 	xori	r2,r2,128
8113e6b0:	10bfe004 	addi	r2,r2,-128
8113e6b4:	10801850 	cmplti	r2,r2,97
8113e6b8:	1000121e 	bne	r2,zero,8113e704 <match_file_record_to_name_ext+0x114>
8113e6bc:	e0bffc17 	ldw	r2,-16(fp)
8113e6c0:	e13ffe17 	ldw	r4,-8(fp)
8113e6c4:	2085883a 	add	r2,r4,r2
8113e6c8:	10800003 	ldbu	r2,0(r2)
8113e6cc:	10803fcc 	andi	r2,r2,255
8113e6d0:	1080201c 	xori	r2,r2,128
8113e6d4:	10bfe004 	addi	r2,r2,-128
8113e6d8:	10801ec8 	cmpgei	r2,r2,123
8113e6dc:	1000091e 	bne	r2,zero,8113e704 <match_file_record_to_name_ext+0x114>
8113e6e0:	e0bffc17 	ldw	r2,-16(fp)
8113e6e4:	e13ffe17 	ldw	r4,-8(fp)
8113e6e8:	2085883a 	add	r2,r4,r2
8113e6ec:	10800003 	ldbu	r2,0(r2)
8113e6f0:	10bff804 	addi	r2,r2,-32
8113e6f4:	10803fcc 	andi	r2,r2,255
8113e6f8:	1080201c 	xori	r2,r2,128
8113e6fc:	10bfe004 	addi	r2,r2,-128
8113e700:	00000706 	br	8113e720 <match_file_record_to_name_ext+0x130>
8113e704:	e0bffc17 	ldw	r2,-16(fp)
8113e708:	e13ffe17 	ldw	r4,-8(fp)
8113e70c:	2085883a 	add	r2,r4,r2
8113e710:	10800003 	ldbu	r2,0(r2)
8113e714:	10803fcc 	andi	r2,r2,255
8113e718:	1080201c 	xori	r2,r2,128
8113e71c:	10bfe004 	addi	r2,r2,-128
8113e720:	18800226 	beq	r3,r2,8113e72c <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113e724:	e03ffb15 	stw	zero,-20(fp)
			break;
8113e728:	00000606 	br	8113e744 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8113e72c:	e0bffc17 	ldw	r2,-16(fp)
8113e730:	10800044 	addi	r2,r2,1
8113e734:	e0bffc15 	stw	r2,-16(fp)
8113e738:	e0bffc17 	ldw	r2,-16(fp)
8113e73c:	10800210 	cmplti	r2,r2,8
8113e740:	103fb71e 	bne	r2,zero,8113e620 <__reset+0xfb11e620>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113e744:	e03ffc15 	stw	zero,-16(fp)
8113e748:	00004a06 	br	8113e874 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8113e74c:	e0fffd17 	ldw	r3,-12(fp)
8113e750:	e0bffc17 	ldw	r2,-16(fp)
8113e754:	1885883a 	add	r2,r3,r2
8113e758:	10800204 	addi	r2,r2,8
8113e75c:	10800003 	ldbu	r2,0(r2)
8113e760:	10803fcc 	andi	r2,r2,255
8113e764:	10801870 	cmpltui	r2,r2,97
8113e768:	1000121e 	bne	r2,zero,8113e7b4 <match_file_record_to_name_ext+0x1c4>
8113e76c:	e0fffd17 	ldw	r3,-12(fp)
8113e770:	e0bffc17 	ldw	r2,-16(fp)
8113e774:	1885883a 	add	r2,r3,r2
8113e778:	10800204 	addi	r2,r2,8
8113e77c:	10800003 	ldbu	r2,0(r2)
8113e780:	10803fcc 	andi	r2,r2,255
8113e784:	10801ee8 	cmpgeui	r2,r2,123
8113e788:	10000a1e 	bne	r2,zero,8113e7b4 <match_file_record_to_name_ext+0x1c4>
8113e78c:	e0fffd17 	ldw	r3,-12(fp)
8113e790:	e0bffc17 	ldw	r2,-16(fp)
8113e794:	1885883a 	add	r2,r3,r2
8113e798:	10800204 	addi	r2,r2,8
8113e79c:	10800003 	ldbu	r2,0(r2)
8113e7a0:	10bff804 	addi	r2,r2,-32
8113e7a4:	10c03fcc 	andi	r3,r2,255
8113e7a8:	18c0201c 	xori	r3,r3,128
8113e7ac:	18ffe004 	addi	r3,r3,-128
8113e7b0:	00000806 	br	8113e7d4 <match_file_record_to_name_ext+0x1e4>
8113e7b4:	e0fffd17 	ldw	r3,-12(fp)
8113e7b8:	e0bffc17 	ldw	r2,-16(fp)
8113e7bc:	1885883a 	add	r2,r3,r2
8113e7c0:	10800204 	addi	r2,r2,8
8113e7c4:	10800003 	ldbu	r2,0(r2)
8113e7c8:	10c03fcc 	andi	r3,r2,255
8113e7cc:	18c0201c 	xori	r3,r3,128
8113e7d0:	18ffe004 	addi	r3,r3,-128
8113e7d4:	e0bffc17 	ldw	r2,-16(fp)
8113e7d8:	e13fff17 	ldw	r4,-4(fp)
8113e7dc:	2085883a 	add	r2,r4,r2
8113e7e0:	10800003 	ldbu	r2,0(r2)
8113e7e4:	10803fcc 	andi	r2,r2,255
8113e7e8:	1080201c 	xori	r2,r2,128
8113e7ec:	10bfe004 	addi	r2,r2,-128
8113e7f0:	10801850 	cmplti	r2,r2,97
8113e7f4:	1000121e 	bne	r2,zero,8113e840 <match_file_record_to_name_ext+0x250>
8113e7f8:	e0bffc17 	ldw	r2,-16(fp)
8113e7fc:	e13fff17 	ldw	r4,-4(fp)
8113e800:	2085883a 	add	r2,r4,r2
8113e804:	10800003 	ldbu	r2,0(r2)
8113e808:	10803fcc 	andi	r2,r2,255
8113e80c:	1080201c 	xori	r2,r2,128
8113e810:	10bfe004 	addi	r2,r2,-128
8113e814:	10801ec8 	cmpgei	r2,r2,123
8113e818:	1000091e 	bne	r2,zero,8113e840 <match_file_record_to_name_ext+0x250>
8113e81c:	e0bffc17 	ldw	r2,-16(fp)
8113e820:	e13fff17 	ldw	r4,-4(fp)
8113e824:	2085883a 	add	r2,r4,r2
8113e828:	10800003 	ldbu	r2,0(r2)
8113e82c:	10bff804 	addi	r2,r2,-32
8113e830:	10803fcc 	andi	r2,r2,255
8113e834:	1080201c 	xori	r2,r2,128
8113e838:	10bfe004 	addi	r2,r2,-128
8113e83c:	00000706 	br	8113e85c <match_file_record_to_name_ext+0x26c>
8113e840:	e0bffc17 	ldw	r2,-16(fp)
8113e844:	e13fff17 	ldw	r4,-4(fp)
8113e848:	2085883a 	add	r2,r4,r2
8113e84c:	10800003 	ldbu	r2,0(r2)
8113e850:	10803fcc 	andi	r2,r2,255
8113e854:	1080201c 	xori	r2,r2,128
8113e858:	10bfe004 	addi	r2,r2,-128
8113e85c:	18800226 	beq	r3,r2,8113e868 <match_file_record_to_name_ext+0x278>
        {
            match = false;
8113e860:	e03ffb15 	stw	zero,-20(fp)
			break;
8113e864:	00000606 	br	8113e880 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113e868:	e0bffc17 	ldw	r2,-16(fp)
8113e86c:	10800044 	addi	r2,r2,1
8113e870:	e0bffc15 	stw	r2,-16(fp)
8113e874:	e0bffc17 	ldw	r2,-16(fp)
8113e878:	108000d0 	cmplti	r2,r2,3
8113e87c:	103fb31e 	bne	r2,zero,8113e74c <__reset+0xfb11e74c>
        {
            match = false;
			break;
        }
    }
	return match;
8113e880:	e0bffb17 	ldw	r2,-20(fp)
}
8113e884:	e037883a 	mov	sp,fp
8113e888:	df000017 	ldw	fp,0(sp)
8113e88c:	dec00104 	addi	sp,sp,4
8113e890:	f800283a 	ret

8113e894 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113e894:	deffe704 	addi	sp,sp,-100
8113e898:	de00012e 	bgeu	sp,et,8113e8a0 <get_home_directory_cluster_for_file+0xc>
8113e89c:	003b68fa 	trap	3
8113e8a0:	dfc01815 	stw	ra,96(sp)
8113e8a4:	df001715 	stw	fp,92(sp)
8113e8a8:	df001704 	addi	fp,sp,92
8113e8ac:	e13ffd15 	stw	r4,-12(fp)
8113e8b0:	e17ffe15 	stw	r5,-8(fp)
8113e8b4:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113e8b8:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8113e8bc:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8113e8c0:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8113e8c4:	e13ffd17 	ldw	r4,-12(fp)
8113e8c8:	113e5300 	call	8113e530 <get_dir_divider_location>
8113e8cc:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8113e8d0:	00012f06 	br	8113ed90 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113e8d4:	00800804 	movi	r2,32
8113e8d8:	e0bff905 	stb	r2,-28(fp)
8113e8dc:	00800804 	movi	r2,32
8113e8e0:	e0bff945 	stb	r2,-27(fp)
8113e8e4:	00800804 	movi	r2,32
8113e8e8:	e0bff985 	stb	r2,-26(fp)
8113e8ec:	00800804 	movi	r2,32
8113e8f0:	e0bff9c5 	stb	r2,-25(fp)
8113e8f4:	00800804 	movi	r2,32
8113e8f8:	e0bffa05 	stb	r2,-24(fp)
8113e8fc:	00800804 	movi	r2,32
8113e900:	e0bffa45 	stb	r2,-23(fp)
8113e904:	00800804 	movi	r2,32
8113e908:	e0bffa85 	stb	r2,-22(fp)
8113e90c:	00800804 	movi	r2,32
8113e910:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8113e914:	00800804 	movi	r2,32
8113e918:	e0bffb05 	stb	r2,-20(fp)
8113e91c:	00800804 	movi	r2,32
8113e920:	e0bffb45 	stb	r2,-19(fp)
8113e924:	00800804 	movi	r2,32
8113e928:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8113e92c:	00bfffc4 	movi	r2,-1
8113e930:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113e934:	e0bfea17 	ldw	r2,-88(fp)
8113e938:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113e93c:	e03fec15 	stw	zero,-80(fp)
8113e940:	00002d06 	br	8113e9f8 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113e944:	e0ffec17 	ldw	r3,-80(fp)
8113e948:	e0bfed17 	ldw	r2,-76(fp)
8113e94c:	1885883a 	add	r2,r3,r2
8113e950:	1007883a 	mov	r3,r2
8113e954:	e0bffd17 	ldw	r2,-12(fp)
8113e958:	10c5883a 	add	r2,r2,r3
8113e95c:	10800003 	ldbu	r2,0(r2)
8113e960:	10803fcc 	andi	r2,r2,255
8113e964:	1080201c 	xori	r2,r2,128
8113e968:	10bfe004 	addi	r2,r2,-128
8113e96c:	10800b98 	cmpnei	r2,r2,46
8113e970:	1000031e 	bne	r2,zero,8113e980 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113e974:	e0bfec17 	ldw	r2,-80(fp)
8113e978:	e0bfee15 	stw	r2,-72(fp)
8113e97c:	00001b06 	br	8113e9ec <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8113e980:	e0bfee17 	ldw	r2,-72(fp)
8113e984:	10000c0e 	bge	r2,zero,8113e9b8 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8113e988:	e0ffec17 	ldw	r3,-80(fp)
8113e98c:	e0bfed17 	ldw	r2,-76(fp)
8113e990:	1885883a 	add	r2,r3,r2
8113e994:	1007883a 	mov	r3,r2
8113e998:	e0bffd17 	ldw	r2,-12(fp)
8113e99c:	10c5883a 	add	r2,r2,r3
8113e9a0:	10c00003 	ldbu	r3,0(r2)
8113e9a4:	e13ff904 	addi	r4,fp,-28
8113e9a8:	e0bfec17 	ldw	r2,-80(fp)
8113e9ac:	2085883a 	add	r2,r4,r2
8113e9b0:	10c00005 	stb	r3,0(r2)
8113e9b4:	00000d06 	br	8113e9ec <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8113e9b8:	e0ffec17 	ldw	r3,-80(fp)
8113e9bc:	e0bfee17 	ldw	r2,-72(fp)
8113e9c0:	1885c83a 	sub	r2,r3,r2
8113e9c4:	e13fec17 	ldw	r4,-80(fp)
8113e9c8:	e0ffed17 	ldw	r3,-76(fp)
8113e9cc:	20c7883a 	add	r3,r4,r3
8113e9d0:	1809883a 	mov	r4,r3
8113e9d4:	e0fffd17 	ldw	r3,-12(fp)
8113e9d8:	1907883a 	add	r3,r3,r4
8113e9dc:	18c00003 	ldbu	r3,0(r3)
8113e9e0:	e13ffb04 	addi	r4,fp,-20
8113e9e4:	2085883a 	add	r2,r4,r2
8113e9e8:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113e9ec:	e0bfec17 	ldw	r2,-80(fp)
8113e9f0:	10800044 	addi	r2,r2,1
8113e9f4:	e0bfec15 	stw	r2,-80(fp)
8113e9f8:	e0ffec17 	ldw	r3,-80(fp)
8113e9fc:	e0bfeb17 	ldw	r2,-84(fp)
8113ea00:	18bfd016 	blt	r3,r2,8113e944 <__reset+0xfb11e944>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8113ea04:	e0bfea17 	ldw	r2,-88(fp)
8113ea08:	10005c1e 	bne	r2,zero,8113eb7c <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113ea0c:	00a045b4 	movhi	r2,33046
8113ea10:	109b3304 	addi	r2,r2,27852
8113ea14:	1080050b 	ldhu	r2,20(r2)
8113ea18:	10bfffcc 	andi	r2,r2,65535
8113ea1c:	1006917a 	slli	r3,r2,5
8113ea20:	00a045b4 	movhi	r2,33046
8113ea24:	109b3304 	addi	r2,r2,27852
8113ea28:	1080030b 	ldhu	r2,12(r2)
8113ea2c:	10bfffcc 	andi	r2,r2,65535
8113ea30:	1885283a 	div	r2,r3,r2
8113ea34:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113ea38:	e03ff015 	stw	zero,-64(fp)
8113ea3c:	00003b06 	br	8113eb2c <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8113ea40:	00a045b4 	movhi	r2,33046
8113ea44:	109b3304 	addi	r2,r2,27852
8113ea48:	10c01317 	ldw	r3,76(r2)
8113ea4c:	e0bff017 	ldw	r2,-64(fp)
8113ea50:	1885883a 	add	r2,r3,r2
8113ea54:	1007883a 	mov	r3,r2
8113ea58:	d0a0ab17 	ldw	r2,-32084(gp)
8113ea5c:	100b883a 	mov	r5,r2
8113ea60:	1809883a 	mov	r4,r3
8113ea64:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113ea68:	10003426 	beq	r2,zero,8113eb3c <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113ea6c:	e03ff115 	stw	zero,-60(fp)
8113ea70:	00002506 	br	8113eb08 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113ea74:	e0bff117 	ldw	r2,-60(fp)
8113ea78:	1004917a 	slli	r2,r2,5
8113ea7c:	e0fff017 	ldw	r3,-64(fp)
8113ea80:	180f883a 	mov	r7,r3
8113ea84:	000d883a 	mov	r6,zero
8113ea88:	e17fff17 	ldw	r5,-4(fp)
8113ea8c:	1009883a 	mov	r4,r2
8113ea90:	113d55c0 	call	8113d55c <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113ea94:	e0bfff17 	ldw	r2,-4(fp)
8113ea98:	10800003 	ldbu	r2,0(r2)
8113ea9c:	10803fcc 	andi	r2,r2,255
8113eaa0:	10803960 	cmpeqi	r2,r2,229
8113eaa4:	1000151e 	bne	r2,zero,8113eafc <get_home_directory_cluster_for_file+0x268>
8113eaa8:	e0bfff17 	ldw	r2,-4(fp)
8113eaac:	10800003 	ldbu	r2,0(r2)
8113eab0:	10803fcc 	andi	r2,r2,255
8113eab4:	10001126 	beq	r2,zero,8113eafc <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113eab8:	e0fffb04 	addi	r3,fp,-20
8113eabc:	e0bff904 	addi	r2,fp,-28
8113eac0:	180d883a 	mov	r6,r3
8113eac4:	100b883a 	mov	r5,r2
8113eac8:	e13fff17 	ldw	r4,-4(fp)
8113eacc:	113e5f00 	call	8113e5f0 <match_file_record_to_name_ext>
8113ead0:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8113ead4:	e0bff817 	ldw	r2,-32(fp)
8113ead8:	10000826 	beq	r2,zero,8113eafc <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8113eadc:	e0bfff17 	ldw	r2,-4(fp)
8113eae0:	1080058b 	ldhu	r2,22(r2)
8113eae4:	10bfffcc 	andi	r2,r2,65535
8113eae8:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8113eaec:	e0bfff17 	ldw	r2,-4(fp)
8113eaf0:	00c00044 	movi	r3,1
8113eaf4:	10c00a15 	stw	r3,40(r2)
                                break;
8113eaf8:	00000606 	br	8113eb14 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113eafc:	e0bff117 	ldw	r2,-60(fp)
8113eb00:	10800044 	addi	r2,r2,1
8113eb04:	e0bff115 	stw	r2,-60(fp)
8113eb08:	e0bff117 	ldw	r2,-60(fp)
8113eb0c:	10800410 	cmplti	r2,r2,16
8113eb10:	103fd81e 	bne	r2,zero,8113ea74 <__reset+0xfb11ea74>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8113eb14:	e0ffef17 	ldw	r3,-68(fp)
8113eb18:	e0bfea17 	ldw	r2,-88(fp)
8113eb1c:	1880091e 	bne	r3,r2,8113eb44 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113eb20:	e0bff017 	ldw	r2,-64(fp)
8113eb24:	10800044 	addi	r2,r2,1
8113eb28:	e0bff015 	stw	r2,-64(fp)
8113eb2c:	e0fff017 	ldw	r3,-64(fp)
8113eb30:	e0bff717 	ldw	r2,-36(fp)
8113eb34:	18bfc216 	blt	r3,r2,8113ea40 <__reset+0xfb11ea40>
8113eb38:	00000306 	br	8113eb48 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8113eb3c:	0001883a 	nop
8113eb40:	00000106 	br	8113eb48 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113eb44:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8113eb48:	e0ffef17 	ldw	r3,-68(fp)
8113eb4c:	e0bfea17 	ldw	r2,-88(fp)
8113eb50:	18800826 	beq	r3,r2,8113eb74 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113eb54:	e0bfef17 	ldw	r2,-68(fp)
8113eb58:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113eb5c:	e0ffed17 	ldw	r3,-76(fp)
8113eb60:	e0bfeb17 	ldw	r2,-84(fp)
8113eb64:	1885883a 	add	r2,r3,r2
8113eb68:	10800044 	addi	r2,r2,1
8113eb6c:	e0bfed15 	stw	r2,-76(fp)
8113eb70:	00007d06 	br	8113ed68 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113eb74:	0005883a 	mov	r2,zero
8113eb78:	00009106 	br	8113edc0 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8113eb7c:	e0bfea17 	ldw	r2,-88(fp)
8113eb80:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113eb84:	e0bff417 	ldw	r2,-48(fp)
8113eb88:	10ffff84 	addi	r3,r2,-2
8113eb8c:	00a045b4 	movhi	r2,33046
8113eb90:	109b3304 	addi	r2,r2,27852
8113eb94:	10800383 	ldbu	r2,14(r2)
8113eb98:	10803fcc 	andi	r2,r2,255
8113eb9c:	1885383a 	mul	r2,r3,r2
8113eba0:	1007883a 	mov	r3,r2
8113eba4:	00a045b4 	movhi	r2,33046
8113eba8:	109b3304 	addi	r2,r2,27852
8113ebac:	10801417 	ldw	r2,80(r2)
8113ebb0:	1885883a 	add	r2,r3,r2
8113ebb4:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113ebb8:	e03ff215 	stw	zero,-56(fp)
8113ebbc:	00003606 	br	8113ec98 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113ebc0:	e0fff217 	ldw	r3,-56(fp)
8113ebc4:	e0bff517 	ldw	r2,-44(fp)
8113ebc8:	1885883a 	add	r2,r3,r2
8113ebcc:	d0e0ab17 	ldw	r3,-32084(gp)
8113ebd0:	180b883a 	mov	r5,r3
8113ebd4:	1009883a 	mov	r4,r2
8113ebd8:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113ebdc:	10003526 	beq	r2,zero,8113ecb4 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113ebe0:	e03ff315 	stw	zero,-52(fp)
8113ebe4:	00002306 	br	8113ec74 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113ebe8:	e0bff317 	ldw	r2,-52(fp)
8113ebec:	1004917a 	slli	r2,r2,5
8113ebf0:	e0fff417 	ldw	r3,-48(fp)
8113ebf4:	e13ff217 	ldw	r4,-56(fp)
8113ebf8:	200f883a 	mov	r7,r4
8113ebfc:	180d883a 	mov	r6,r3
8113ec00:	e17fff17 	ldw	r5,-4(fp)
8113ec04:	1009883a 	mov	r4,r2
8113ec08:	113d55c0 	call	8113d55c <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113ec0c:	e0bfff17 	ldw	r2,-4(fp)
8113ec10:	10800003 	ldbu	r2,0(r2)
8113ec14:	10803fcc 	andi	r2,r2,255
8113ec18:	10803960 	cmpeqi	r2,r2,229
8113ec1c:	1000121e 	bne	r2,zero,8113ec68 <get_home_directory_cluster_for_file+0x3d4>
8113ec20:	e0bfff17 	ldw	r2,-4(fp)
8113ec24:	10800003 	ldbu	r2,0(r2)
8113ec28:	10803fcc 	andi	r2,r2,255
8113ec2c:	10000e26 	beq	r2,zero,8113ec68 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8113ec30:	e0fffb04 	addi	r3,fp,-20
8113ec34:	e0bff904 	addi	r2,fp,-28
8113ec38:	180d883a 	mov	r6,r3
8113ec3c:	100b883a 	mov	r5,r2
8113ec40:	e13fff17 	ldw	r4,-4(fp)
8113ec44:	113e5f00 	call	8113e5f0 <match_file_record_to_name_ext>
8113ec48:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8113ec4c:	e0bff617 	ldw	r2,-40(fp)
8113ec50:	10000526 	beq	r2,zero,8113ec68 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113ec54:	e0bfff17 	ldw	r2,-4(fp)
8113ec58:	1080058b 	ldhu	r2,22(r2)
8113ec5c:	10bfffcc 	andi	r2,r2,65535
8113ec60:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113ec64:	00000606 	br	8113ec80 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113ec68:	e0bff317 	ldw	r2,-52(fp)
8113ec6c:	10800044 	addi	r2,r2,1
8113ec70:	e0bff315 	stw	r2,-52(fp)
8113ec74:	e0bff317 	ldw	r2,-52(fp)
8113ec78:	10800410 	cmplti	r2,r2,16
8113ec7c:	103fda1e 	bne	r2,zero,8113ebe8 <__reset+0xfb11ebe8>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8113ec80:	e0ffef17 	ldw	r3,-68(fp)
8113ec84:	e0bfea17 	ldw	r2,-88(fp)
8113ec88:	18800c1e 	bne	r3,r2,8113ecbc <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113ec8c:	e0bff217 	ldw	r2,-56(fp)
8113ec90:	10800044 	addi	r2,r2,1
8113ec94:	e0bff215 	stw	r2,-56(fp)
8113ec98:	00a045b4 	movhi	r2,33046
8113ec9c:	109b3304 	addi	r2,r2,27852
8113eca0:	10800383 	ldbu	r2,14(r2)
8113eca4:	10803fcc 	andi	r2,r2,255
8113eca8:	e0fff217 	ldw	r3,-56(fp)
8113ecac:	18bfc416 	blt	r3,r2,8113ebc0 <__reset+0xfb11ebc0>
8113ecb0:	00000306 	br	8113ecc0 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113ecb4:	0001883a 	nop
8113ecb8:	00000106 	br	8113ecc0 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8113ecbc:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8113ecc0:	e0ffef17 	ldw	r3,-68(fp)
8113ecc4:	e0bfea17 	ldw	r2,-88(fp)
8113ecc8:	1880141e 	bne	r3,r2,8113ed1c <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8113eccc:	e0bfef17 	ldw	r2,-68(fp)
8113ecd0:	e0fffc04 	addi	r3,fp,-16
8113ecd4:	180b883a 	mov	r5,r3
8113ecd8:	1009883a 	mov	r4,r2
8113ecdc:	113d20c0 	call	8113d20c <get_cluster_flag>
8113ece0:	10000c26 	beq	r2,zero,8113ed14 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113ece4:	e0bffc0b 	ldhu	r2,-16(fp)
8113ece8:	10bfffcc 	andi	r2,r2,65535
8113ecec:	10fffe0c 	andi	r3,r2,65528
8113ecf0:	00bffe14 	movui	r2,65528
8113ecf4:	1880021e 	bne	r3,r2,8113ed00 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8113ecf8:	0005883a 	mov	r2,zero
8113ecfc:	00003006 	br	8113edc0 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8113ed00:	e0bffc0b 	ldhu	r2,-16(fp)
8113ed04:	10bfffcc 	andi	r2,r2,65535
8113ed08:	10bffe0c 	andi	r2,r2,65528
8113ed0c:	e0bfef15 	stw	r2,-68(fp)
8113ed10:	00000206 	br	8113ed1c <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8113ed14:	0005883a 	mov	r2,zero
8113ed18:	00002906 	br	8113edc0 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8113ed1c:	e0bff417 	ldw	r2,-48(fp)
8113ed20:	00fffdd4 	movui	r3,65527
8113ed24:	18800316 	blt	r3,r2,8113ed34 <get_home_directory_cluster_for_file+0x4a0>
8113ed28:	e0ffef17 	ldw	r3,-68(fp)
8113ed2c:	e0bfea17 	ldw	r2,-88(fp)
8113ed30:	18bf9426 	beq	r3,r2,8113eb84 <__reset+0xfb11eb84>
            if (new_cluster != home_dir_cluster)
8113ed34:	e0ffef17 	ldw	r3,-68(fp)
8113ed38:	e0bfea17 	ldw	r2,-88(fp)
8113ed3c:	18800826 	beq	r3,r2,8113ed60 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113ed40:	e0bfef17 	ldw	r2,-68(fp)
8113ed44:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113ed48:	e0ffed17 	ldw	r3,-76(fp)
8113ed4c:	e0bfeb17 	ldw	r2,-84(fp)
8113ed50:	1885883a 	add	r2,r3,r2
8113ed54:	10800044 	addi	r2,r2,1
8113ed58:	e0bfed15 	stw	r2,-76(fp)
8113ed5c:	00000206 	br	8113ed68 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113ed60:	0005883a 	mov	r2,zero
8113ed64:	00001606 	br	8113edc0 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8113ed68:	e0bfed17 	ldw	r2,-76(fp)
8113ed6c:	e0fffd17 	ldw	r3,-12(fp)
8113ed70:	1885883a 	add	r2,r3,r2
8113ed74:	1009883a 	mov	r4,r2
8113ed78:	113e5300 	call	8113e530 <get_dir_divider_location>
8113ed7c:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8113ed80:	e0bfeb17 	ldw	r2,-84(fp)
8113ed84:	1000020e 	bge	r2,zero,8113ed90 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8113ed88:	00800044 	movi	r2,1
8113ed8c:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8113ed90:	e0bfeb17 	ldw	r2,-84(fp)
8113ed94:	00becf16 	blt	zero,r2,8113e8d4 <__reset+0xfb11e8d4>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8113ed98:	e0bffe17 	ldw	r2,-8(fp)
8113ed9c:	e0ffea17 	ldw	r3,-88(fp)
8113eda0:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113eda4:	e0bfea17 	ldw	r2,-88(fp)
8113eda8:	1000041e 	bne	r2,zero,8113edbc <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8113edac:	e0bfff17 	ldw	r2,-4(fp)
8113edb0:	10000a15 	stw	zero,40(r2)
		result = true;
8113edb4:	00800044 	movi	r2,1
8113edb8:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8113edbc:	e0bfe917 	ldw	r2,-92(fp)
}
8113edc0:	e037883a 	mov	sp,fp
8113edc4:	dfc00117 	ldw	ra,4(sp)
8113edc8:	df000017 	ldw	fp,0(sp)
8113edcc:	dec00204 	addi	sp,sp,8
8113edd0:	f800283a 	ret

8113edd4 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8113edd4:	deffe804 	addi	sp,sp,-96
8113edd8:	de00012e 	bgeu	sp,et,8113ede0 <find_file_in_directory+0xc>
8113eddc:	003b68fa 	trap	3
8113ede0:	dfc01715 	stw	ra,92(sp)
8113ede4:	df001615 	stw	fp,88(sp)
8113ede8:	df001604 	addi	fp,sp,88
8113edec:	e13ffd15 	stw	r4,-12(fp)
8113edf0:	e17ffe15 	stw	r5,-8(fp)
8113edf4:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8113edf8:	e13ffe17 	ldw	r4,-8(fp)
8113edfc:	113e5300 	call	8113e530 <get_dir_divider_location>
8113ee00:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8113ee04:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113ee08:	00800804 	movi	r2,32
8113ee0c:	e0bff905 	stb	r2,-28(fp)
8113ee10:	00800804 	movi	r2,32
8113ee14:	e0bff945 	stb	r2,-27(fp)
8113ee18:	00800804 	movi	r2,32
8113ee1c:	e0bff985 	stb	r2,-26(fp)
8113ee20:	00800804 	movi	r2,32
8113ee24:	e0bff9c5 	stb	r2,-25(fp)
8113ee28:	00800804 	movi	r2,32
8113ee2c:	e0bffa05 	stb	r2,-24(fp)
8113ee30:	00800804 	movi	r2,32
8113ee34:	e0bffa45 	stb	r2,-23(fp)
8113ee38:	00800804 	movi	r2,32
8113ee3c:	e0bffa85 	stb	r2,-22(fp)
8113ee40:	00800804 	movi	r2,32
8113ee44:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8113ee48:	00800804 	movi	r2,32
8113ee4c:	e0bffb05 	stb	r2,-20(fp)
8113ee50:	00800804 	movi	r2,32
8113ee54:	e0bffb45 	stb	r2,-19(fp)
8113ee58:	00800804 	movi	r2,32
8113ee5c:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8113ee60:	00bfffc4 	movi	r2,-1
8113ee64:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8113ee68:	e0bffd17 	ldw	r2,-12(fp)
8113ee6c:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8113ee70:	e13ffe17 	ldw	r4,-8(fp)
8113ee74:	111d6400 	call	8111d640 <strlen>
8113ee78:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8113ee7c:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113ee80:	00000b06 	br	8113eeb0 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113ee84:	e0ffeb17 	ldw	r3,-84(fp)
8113ee88:	e0bfea17 	ldw	r2,-88(fp)
8113ee8c:	1885883a 	add	r2,r3,r2
8113ee90:	10800044 	addi	r2,r2,1
8113ee94:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113ee98:	e0bfeb17 	ldw	r2,-84(fp)
8113ee9c:	e0fffe17 	ldw	r3,-8(fp)
8113eea0:	1885883a 	add	r2,r3,r2
8113eea4:	1009883a 	mov	r4,r2
8113eea8:	113e5300 	call	8113e530 <get_dir_divider_location>
8113eeac:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113eeb0:	e0bfea17 	ldw	r2,-88(fp)
8113eeb4:	00bff316 	blt	zero,r2,8113ee84 <__reset+0xfb11ee84>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113eeb8:	e0bfeb17 	ldw	r2,-84(fp)
8113eebc:	e0bfee15 	stw	r2,-72(fp)
8113eec0:	00002706 	br	8113ef60 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113eec4:	e0bfee17 	ldw	r2,-72(fp)
8113eec8:	e0fffe17 	ldw	r3,-8(fp)
8113eecc:	1885883a 	add	r2,r3,r2
8113eed0:	10800003 	ldbu	r2,0(r2)
8113eed4:	10803fcc 	andi	r2,r2,255
8113eed8:	1080201c 	xori	r2,r2,128
8113eedc:	10bfe004 	addi	r2,r2,-128
8113eee0:	10800b98 	cmpnei	r2,r2,46
8113eee4:	1000031e 	bne	r2,zero,8113eef4 <find_file_in_directory+0x120>
        {
            ext_index = index;
8113eee8:	e0bfee17 	ldw	r2,-72(fp)
8113eeec:	e0bfec15 	stw	r2,-80(fp)
8113eef0:	00001806 	br	8113ef54 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8113eef4:	e0bfec17 	ldw	r2,-80(fp)
8113eef8:	10000b0e 	bge	r2,zero,8113ef28 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8113eefc:	e0ffee17 	ldw	r3,-72(fp)
8113ef00:	e0bfeb17 	ldw	r2,-84(fp)
8113ef04:	1885c83a 	sub	r2,r3,r2
8113ef08:	e0ffee17 	ldw	r3,-72(fp)
8113ef0c:	e13ffe17 	ldw	r4,-8(fp)
8113ef10:	20c7883a 	add	r3,r4,r3
8113ef14:	18c00003 	ldbu	r3,0(r3)
8113ef18:	e13ff904 	addi	r4,fp,-28
8113ef1c:	2085883a 	add	r2,r4,r2
8113ef20:	10c00005 	stb	r3,0(r2)
8113ef24:	00000b06 	br	8113ef54 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8113ef28:	e0ffee17 	ldw	r3,-72(fp)
8113ef2c:	e0bfec17 	ldw	r2,-80(fp)
8113ef30:	1885c83a 	sub	r2,r3,r2
8113ef34:	10bfffc4 	addi	r2,r2,-1
8113ef38:	e0ffee17 	ldw	r3,-72(fp)
8113ef3c:	e13ffe17 	ldw	r4,-8(fp)
8113ef40:	20c7883a 	add	r3,r4,r3
8113ef44:	18c00003 	ldbu	r3,0(r3)
8113ef48:	e13ffb04 	addi	r4,fp,-20
8113ef4c:	2085883a 	add	r2,r4,r2
8113ef50:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113ef54:	e0bfee17 	ldw	r2,-72(fp)
8113ef58:	10800044 	addi	r2,r2,1
8113ef5c:	e0bfee15 	stw	r2,-72(fp)
8113ef60:	e0ffee17 	ldw	r3,-72(fp)
8113ef64:	e0bff417 	ldw	r2,-48(fp)
8113ef68:	18bfd616 	blt	r3,r2,8113eec4 <__reset+0xfb11eec4>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8113ef6c:	e0bffd17 	ldw	r2,-12(fp)
8113ef70:	1000461e 	bne	r2,zero,8113f08c <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113ef74:	00a045b4 	movhi	r2,33046
8113ef78:	109b3304 	addi	r2,r2,27852
8113ef7c:	1080050b 	ldhu	r2,20(r2)
8113ef80:	10bfffcc 	andi	r2,r2,65535
8113ef84:	1006917a 	slli	r3,r2,5
8113ef88:	00a045b4 	movhi	r2,33046
8113ef8c:	109b3304 	addi	r2,r2,27852
8113ef90:	1080030b 	ldhu	r2,12(r2)
8113ef94:	10bfffcc 	andi	r2,r2,65535
8113ef98:	1885283a 	div	r2,r3,r2
8113ef9c:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113efa0:	e03ff015 	stw	zero,-64(fp)
8113efa4:	00003506 	br	8113f07c <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113efa8:	00a045b4 	movhi	r2,33046
8113efac:	109b3304 	addi	r2,r2,27852
8113efb0:	10c01317 	ldw	r3,76(r2)
8113efb4:	e0bff017 	ldw	r2,-64(fp)
8113efb8:	1885883a 	add	r2,r3,r2
8113efbc:	1007883a 	mov	r3,r2
8113efc0:	d0a0ab17 	ldw	r2,-32084(gp)
8113efc4:	100b883a 	mov	r5,r2
8113efc8:	1809883a 	mov	r4,r3
8113efcc:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113efd0:	10009626 	beq	r2,zero,8113f22c <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113efd4:	e03ff115 	stw	zero,-60(fp)
8113efd8:	00002006 	br	8113f05c <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113efdc:	e0bff117 	ldw	r2,-60(fp)
8113efe0:	1004917a 	slli	r2,r2,5
8113efe4:	e0fff017 	ldw	r3,-64(fp)
8113efe8:	180f883a 	mov	r7,r3
8113efec:	000d883a 	mov	r6,zero
8113eff0:	e17fff17 	ldw	r5,-4(fp)
8113eff4:	1009883a 	mov	r4,r2
8113eff8:	113d55c0 	call	8113d55c <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113effc:	e0bfff17 	ldw	r2,-4(fp)
8113f000:	10800003 	ldbu	r2,0(r2)
8113f004:	10803fcc 	andi	r2,r2,255
8113f008:	10803960 	cmpeqi	r2,r2,229
8113f00c:	1000101e 	bne	r2,zero,8113f050 <find_file_in_directory+0x27c>
8113f010:	e0bfff17 	ldw	r2,-4(fp)
8113f014:	10800003 	ldbu	r2,0(r2)
8113f018:	10803fcc 	andi	r2,r2,255
8113f01c:	10000c26 	beq	r2,zero,8113f050 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8113f020:	e0fffb04 	addi	r3,fp,-20
8113f024:	e0bff904 	addi	r2,fp,-28
8113f028:	180d883a 	mov	r6,r3
8113f02c:	100b883a 	mov	r5,r2
8113f030:	e13fff17 	ldw	r4,-4(fp)
8113f034:	113e5f00 	call	8113e5f0 <match_file_record_to_name_ext>
8113f038:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8113f03c:	e0bff817 	ldw	r2,-32(fp)
8113f040:	10000326 	beq	r2,zero,8113f050 <find_file_in_directory+0x27c>
                        {
                            result = true;
8113f044:	00800044 	movi	r2,1
8113f048:	e0bfef15 	stw	r2,-68(fp)
                            break;
8113f04c:	00000606 	br	8113f068 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113f050:	e0bff117 	ldw	r2,-60(fp)
8113f054:	10800044 	addi	r2,r2,1
8113f058:	e0bff115 	stw	r2,-60(fp)
8113f05c:	e0bff117 	ldw	r2,-60(fp)
8113f060:	10800410 	cmplti	r2,r2,16
8113f064:	103fdd1e 	bne	r2,zero,8113efdc <__reset+0xfb11efdc>
            }
            else
            {
                break;
            }
            if (result)
8113f068:	e0bfef17 	ldw	r2,-68(fp)
8113f06c:	1000711e 	bne	r2,zero,8113f234 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f070:	e0bff017 	ldw	r2,-64(fp)
8113f074:	10800044 	addi	r2,r2,1
8113f078:	e0bff015 	stw	r2,-64(fp)
8113f07c:	e0fff017 	ldw	r3,-64(fp)
8113f080:	e0bff717 	ldw	r2,-36(fp)
8113f084:	18bfc816 	blt	r3,r2,8113efa8 <__reset+0xfb11efa8>
8113f088:	00006b06 	br	8113f238 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113f08c:	e0bfed17 	ldw	r2,-76(fp)
8113f090:	10ffff84 	addi	r3,r2,-2
8113f094:	00a045b4 	movhi	r2,33046
8113f098:	109b3304 	addi	r2,r2,27852
8113f09c:	10800383 	ldbu	r2,14(r2)
8113f0a0:	10803fcc 	andi	r2,r2,255
8113f0a4:	1885383a 	mul	r2,r3,r2
8113f0a8:	1007883a 	mov	r3,r2
8113f0ac:	00a045b4 	movhi	r2,33046
8113f0b0:	109b3304 	addi	r2,r2,27852
8113f0b4:	10801417 	ldw	r2,80(r2)
8113f0b8:	1885883a 	add	r2,r3,r2
8113f0bc:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f0c0:	e03ff215 	stw	zero,-56(fp)
8113f0c4:	00003306 	br	8113f194 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113f0c8:	e0fff217 	ldw	r3,-56(fp)
8113f0cc:	e0bff517 	ldw	r2,-44(fp)
8113f0d0:	1885883a 	add	r2,r3,r2
8113f0d4:	d0e0ab17 	ldw	r3,-32084(gp)
8113f0d8:	180b883a 	mov	r5,r3
8113f0dc:	1009883a 	mov	r4,r2
8113f0e0:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113f0e4:	10003226 	beq	r2,zero,8113f1b0 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113f0e8:	e03ff315 	stw	zero,-52(fp)
8113f0ec:	00002106 	br	8113f174 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113f0f0:	e0bff317 	ldw	r2,-52(fp)
8113f0f4:	1004917a 	slli	r2,r2,5
8113f0f8:	e0ffed17 	ldw	r3,-76(fp)
8113f0fc:	e13ff217 	ldw	r4,-56(fp)
8113f100:	200f883a 	mov	r7,r4
8113f104:	180d883a 	mov	r6,r3
8113f108:	e17fff17 	ldw	r5,-4(fp)
8113f10c:	1009883a 	mov	r4,r2
8113f110:	113d55c0 	call	8113d55c <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113f114:	e0bfff17 	ldw	r2,-4(fp)
8113f118:	10800003 	ldbu	r2,0(r2)
8113f11c:	10803fcc 	andi	r2,r2,255
8113f120:	10803960 	cmpeqi	r2,r2,229
8113f124:	1000101e 	bne	r2,zero,8113f168 <find_file_in_directory+0x394>
8113f128:	e0bfff17 	ldw	r2,-4(fp)
8113f12c:	10800003 	ldbu	r2,0(r2)
8113f130:	10803fcc 	andi	r2,r2,255
8113f134:	10000c26 	beq	r2,zero,8113f168 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113f138:	e0fffb04 	addi	r3,fp,-20
8113f13c:	e0bff904 	addi	r2,fp,-28
8113f140:	180d883a 	mov	r6,r3
8113f144:	100b883a 	mov	r5,r2
8113f148:	e13fff17 	ldw	r4,-4(fp)
8113f14c:	113e5f00 	call	8113e5f0 <match_file_record_to_name_ext>
8113f150:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8113f154:	e0bff617 	ldw	r2,-40(fp)
8113f158:	10000326 	beq	r2,zero,8113f168 <find_file_in_directory+0x394>
                            {                               
                                result = true;
8113f15c:	00800044 	movi	r2,1
8113f160:	e0bfef15 	stw	r2,-68(fp)
                                break;
8113f164:	00000606 	br	8113f180 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113f168:	e0bff317 	ldw	r2,-52(fp)
8113f16c:	10800044 	addi	r2,r2,1
8113f170:	e0bff315 	stw	r2,-52(fp)
8113f174:	e0bff317 	ldw	r2,-52(fp)
8113f178:	10800410 	cmplti	r2,r2,16
8113f17c:	103fdc1e 	bne	r2,zero,8113f0f0 <__reset+0xfb11f0f0>
                }
                else
                {
                    break;
                }
                if (result)
8113f180:	e0bfef17 	ldw	r2,-68(fp)
8113f184:	10000c1e 	bne	r2,zero,8113f1b8 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f188:	e0bff217 	ldw	r2,-56(fp)
8113f18c:	10800044 	addi	r2,r2,1
8113f190:	e0bff215 	stw	r2,-56(fp)
8113f194:	00a045b4 	movhi	r2,33046
8113f198:	109b3304 	addi	r2,r2,27852
8113f19c:	10800383 	ldbu	r2,14(r2)
8113f1a0:	10803fcc 	andi	r2,r2,255
8113f1a4:	e0fff217 	ldw	r3,-56(fp)
8113f1a8:	18bfc716 	blt	r3,r2,8113f0c8 <__reset+0xfb11f0c8>
8113f1ac:	00000306 	br	8113f1bc <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8113f1b0:	0001883a 	nop
8113f1b4:	00000106 	br	8113f1bc <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113f1b8:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8113f1bc:	e0bfef17 	ldw	r2,-68(fp)
8113f1c0:	1000141e 	bne	r2,zero,8113f214 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8113f1c4:	e0bfed17 	ldw	r2,-76(fp)
8113f1c8:	e0fffc04 	addi	r3,fp,-16
8113f1cc:	180b883a 	mov	r5,r3
8113f1d0:	1009883a 	mov	r4,r2
8113f1d4:	113d20c0 	call	8113d20c <get_cluster_flag>
8113f1d8:	10000c26 	beq	r2,zero,8113f20c <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113f1dc:	e0bffc0b 	ldhu	r2,-16(fp)
8113f1e0:	10bfffcc 	andi	r2,r2,65535
8113f1e4:	10fffe0c 	andi	r3,r2,65528
8113f1e8:	00bffe14 	movui	r2,65528
8113f1ec:	1880021e 	bne	r3,r2,8113f1f8 <find_file_in_directory+0x424>
					{
						return false;
8113f1f0:	0005883a 	mov	r2,zero
8113f1f4:	00001106 	br	8113f23c <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113f1f8:	e0bffc0b 	ldhu	r2,-16(fp)
8113f1fc:	10bfffcc 	andi	r2,r2,65535
8113f200:	10bffe0c 	andi	r2,r2,65528
8113f204:	e0bfed15 	stw	r2,-76(fp)
8113f208:	00000206 	br	8113f214 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8113f20c:	0005883a 	mov	r2,zero
8113f210:	00000a06 	br	8113f23c <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8113f214:	e0bfed17 	ldw	r2,-76(fp)
8113f218:	00fffdd4 	movui	r3,65527
8113f21c:	18800616 	blt	r3,r2,8113f238 <find_file_in_directory+0x464>
8113f220:	e0bfef17 	ldw	r2,-68(fp)
8113f224:	103f9926 	beq	r2,zero,8113f08c <__reset+0xfb11f08c>
8113f228:	00000306 	br	8113f238 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8113f22c:	0001883a 	nop
8113f230:	00000106 	br	8113f238 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8113f234:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8113f238:	e0bfef17 	ldw	r2,-68(fp)
}
8113f23c:	e037883a 	mov	sp,fp
8113f240:	dfc00117 	ldw	ra,4(sp)
8113f244:	df000017 	ldw	fp,0(sp)
8113f248:	dec00204 	addi	sp,sp,8
8113f24c:	f800283a 	ret

8113f250 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8113f250:	defff504 	addi	sp,sp,-44
8113f254:	de00012e 	bgeu	sp,et,8113f25c <find_first_empty_cluster+0xc>
8113f258:	003b68fa 	trap	3
8113f25c:	dfc00a15 	stw	ra,40(sp)
8113f260:	df000915 	stw	fp,36(sp)
8113f264:	df000904 	addi	fp,sp,36
8113f268:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8113f26c:	00a045b4 	movhi	r2,33046
8113f270:	109b3304 	addi	r2,r2,27852
8113f274:	10801117 	ldw	r2,68(r2)
8113f278:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8113f27c:	00800084 	movi	r2,2
8113f280:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8113f284:	00bfffc4 	movi	r2,-1
8113f288:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8113f28c:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8113f290:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8113f294:	00a045b4 	movhi	r2,33046
8113f298:	109b3304 	addi	r2,r2,27852
8113f29c:	10801417 	ldw	r2,80(r2)
8113f2a0:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8113f2a4:	00a045b4 	movhi	r2,33046
8113f2a8:	109b3304 	addi	r2,r2,27852
8113f2ac:	1080058b 	ldhu	r2,22(r2)
8113f2b0:	10bfffcc 	andi	r2,r2,65535
8113f2b4:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113f2b8:	00a045b4 	movhi	r2,33046
8113f2bc:	109b3304 	addi	r2,r2,27852
8113f2c0:	10800917 	ldw	r2,36(r2)
8113f2c4:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113f2c8:	e0bffd17 	ldw	r2,-12(fp)
8113f2cc:	e0fffe17 	ldw	r3,-8(fp)
8113f2d0:	18800b2e 	bgeu	r3,r2,8113f300 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113f2d4:	e0fffd17 	ldw	r3,-12(fp)
8113f2d8:	e0bffc17 	ldw	r2,-16(fp)
8113f2dc:	1887c83a 	sub	r3,r3,r2
8113f2e0:	00a045b4 	movhi	r2,33046
8113f2e4:	109b3304 	addi	r2,r2,27852
8113f2e8:	10800383 	ldbu	r2,14(r2)
8113f2ec:	10803fcc 	andi	r2,r2,255
8113f2f0:	1885203a 	divu	r2,r3,r2
8113f2f4:	10800044 	addi	r2,r2,1
8113f2f8:	e0bffb15 	stw	r2,-20(fp)
8113f2fc:	00002a06 	br	8113f3a8 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113f300:	e0fffe17 	ldw	r3,-8(fp)
8113f304:	e0bffc17 	ldw	r2,-16(fp)
8113f308:	1887c83a 	sub	r3,r3,r2
8113f30c:	00a045b4 	movhi	r2,33046
8113f310:	109b3304 	addi	r2,r2,27852
8113f314:	10800383 	ldbu	r2,14(r2)
8113f318:	10803fcc 	andi	r2,r2,255
8113f31c:	1885203a 	divu	r2,r3,r2
8113f320:	10800044 	addi	r2,r2,1
8113f324:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113f328:	00001f06 	br	8113f3a8 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8113f32c:	e0bff717 	ldw	r2,-36(fp)
8113f330:	d0e0ab17 	ldw	r3,-32084(gp)
8113f334:	180b883a 	mov	r5,r3
8113f338:	1009883a 	mov	r4,r2
8113f33c:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113f340:	10001426 	beq	r2,zero,8113f394 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8113f344:	e0bff817 	ldw	r2,-32(fp)
8113f348:	10803fcc 	andi	r2,r2,255
8113f34c:	1085883a 	add	r2,r2,r2
8113f350:	1007883a 	mov	r3,r2
8113f354:	d0a0ad17 	ldw	r2,-32076(gp)
8113f358:	10800a17 	ldw	r2,40(r2)
8113f35c:	1885883a 	add	r2,r3,r2
8113f360:	1080002b 	ldhuio	r2,0(r2)
8113f364:	10bfffcc 	andi	r2,r2,65535
8113f368:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8113f36c:	e0bff90f 	ldh	r2,-28(fp)
8113f370:	10000726 	beq	r2,zero,8113f390 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8113f374:	e0bff817 	ldw	r2,-32(fp)
8113f378:	10800044 	addi	r2,r2,1
8113f37c:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8113f380:	e0bff817 	ldw	r2,-32(fp)
8113f384:	10803fcc 	andi	r2,r2,255
8113f388:	103fee1e 	bne	r2,zero,8113f344 <__reset+0xfb11f344>
8113f38c:	00000106 	br	8113f394 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8113f390:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8113f394:	e0bff90f 	ldh	r2,-28(fp)
8113f398:	10000926 	beq	r2,zero,8113f3c0 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8113f39c:	e0bff717 	ldw	r2,-36(fp)
8113f3a0:	10800044 	addi	r2,r2,1
8113f3a4:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113f3a8:	00a045b4 	movhi	r2,33046
8113f3ac:	109b3304 	addi	r2,r2,27852
8113f3b0:	10c01217 	ldw	r3,72(r2)
8113f3b4:	e0bff717 	ldw	r2,-36(fp)
8113f3b8:	18bfdc1e 	bne	r3,r2,8113f32c <__reset+0xfb11f32c>
8113f3bc:	00000106 	br	8113f3c4 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8113f3c0:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8113f3c4:	e0bff90f 	ldh	r2,-28(fp)
8113f3c8:	1000081e 	bne	r2,zero,8113f3ec <find_first_empty_cluster+0x19c>
8113f3cc:	e0bff90f 	ldh	r2,-28(fp)
8113f3d0:	e0fffb17 	ldw	r3,-20(fp)
8113f3d4:	18800536 	bltu	r3,r2,8113f3ec <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113f3d8:	e0bfff17 	ldw	r2,-4(fp)
8113f3dc:	e0fff817 	ldw	r3,-32(fp)
8113f3e0:	10c00015 	stw	r3,0(r2)
		result = true;
8113f3e4:	00800044 	movi	r2,1
8113f3e8:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8113f3ec:	e0bffa17 	ldw	r2,-24(fp)
}
8113f3f0:	e037883a 	mov	sp,fp
8113f3f4:	dfc00117 	ldw	ra,4(sp)
8113f3f8:	df000017 	ldw	fp,0(sp)
8113f3fc:	dec00204 	addi	sp,sp,8
8113f400:	f800283a 	ret

8113f404 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8113f404:	defff604 	addi	sp,sp,-40
8113f408:	de00012e 	bgeu	sp,et,8113f410 <find_first_empty_record_in_a_subdirectory+0xc>
8113f40c:	003b68fa 	trap	3
8113f410:	dfc00915 	stw	ra,36(sp)
8113f414:	df000815 	stw	fp,32(sp)
8113f418:	df000804 	addi	fp,sp,32
8113f41c:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8113f420:	00bfffc4 	movi	r2,-1
8113f424:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8113f428:	e0bfff17 	ldw	r2,-4(fp)
8113f42c:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113f430:	e0bff917 	ldw	r2,-28(fp)
8113f434:	10ffff84 	addi	r3,r2,-2
8113f438:	00a045b4 	movhi	r2,33046
8113f43c:	109b3304 	addi	r2,r2,27852
8113f440:	10800383 	ldbu	r2,14(r2)
8113f444:	10803fcc 	andi	r2,r2,255
8113f448:	1885383a 	mul	r2,r3,r2
8113f44c:	1007883a 	mov	r3,r2
8113f450:	00a045b4 	movhi	r2,33046
8113f454:	109b3304 	addi	r2,r2,27852
8113f458:	10801417 	ldw	r2,80(r2)
8113f45c:	1885883a 	add	r2,r3,r2
8113f460:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f464:	e03ffa15 	stw	zero,-24(fp)
8113f468:	00002c06 	br	8113f51c <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113f46c:	e0fffa17 	ldw	r3,-24(fp)
8113f470:	e0bffc17 	ldw	r2,-16(fp)
8113f474:	1885883a 	add	r2,r3,r2
8113f478:	d0e0ab17 	ldw	r3,-32084(gp)
8113f47c:	180b883a 	mov	r5,r3
8113f480:	1009883a 	mov	r4,r2
8113f484:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113f488:	10002b26 	beq	r2,zero,8113f538 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113f48c:	e03ffb15 	stw	zero,-20(fp)
8113f490:	00001c06 	br	8113f504 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113f494:	e0bffb17 	ldw	r2,-20(fp)
8113f498:	1004917a 	slli	r2,r2,5
8113f49c:	1007883a 	mov	r3,r2
8113f4a0:	d0a0ad17 	ldw	r2,-32076(gp)
8113f4a4:	10800a17 	ldw	r2,40(r2)
8113f4a8:	1885883a 	add	r2,r3,r2
8113f4ac:	10800023 	ldbuio	r2,0(r2)
8113f4b0:	10803fcc 	andi	r2,r2,255
8113f4b4:	10803fcc 	andi	r2,r2,255
8113f4b8:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8113f4bc:	e0bffd0b 	ldhu	r2,-12(fp)
8113f4c0:	10803960 	cmpeqi	r2,r2,229
8113f4c4:	1000021e 	bne	r2,zero,8113f4d0 <find_first_empty_record_in_a_subdirectory+0xcc>
8113f4c8:	e0bffd0b 	ldhu	r2,-12(fp)
8113f4cc:	10000a1e 	bne	r2,zero,8113f4f8 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8113f4d0:	e0bffa17 	ldw	r2,-24(fp)
8113f4d4:	1006913a 	slli	r3,r2,4
8113f4d8:	e0bffb17 	ldw	r2,-20(fp)
8113f4dc:	1885883a 	add	r2,r3,r2
8113f4e0:	1006943a 	slli	r3,r2,16
8113f4e4:	e0bff917 	ldw	r2,-28(fp)
8113f4e8:	1884b03a 	or	r2,r3,r2
8113f4ec:	e0bff815 	stw	r2,-32(fp)
                        return result;
8113f4f0:	e0bff817 	ldw	r2,-32(fp)
8113f4f4:	00005306 	br	8113f644 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113f4f8:	e0bffb17 	ldw	r2,-20(fp)
8113f4fc:	10800044 	addi	r2,r2,1
8113f500:	e0bffb15 	stw	r2,-20(fp)
8113f504:	e0bffb17 	ldw	r2,-20(fp)
8113f508:	10800410 	cmplti	r2,r2,16
8113f50c:	103fe11e 	bne	r2,zero,8113f494 <__reset+0xfb11f494>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f510:	e0bffa17 	ldw	r2,-24(fp)
8113f514:	10800044 	addi	r2,r2,1
8113f518:	e0bffa15 	stw	r2,-24(fp)
8113f51c:	00a045b4 	movhi	r2,33046
8113f520:	109b3304 	addi	r2,r2,27852
8113f524:	10800383 	ldbu	r2,14(r2)
8113f528:	10803fcc 	andi	r2,r2,255
8113f52c:	e0fffa17 	ldw	r3,-24(fp)
8113f530:	18bfce16 	blt	r3,r2,8113f46c <__reset+0xfb11f46c>
8113f534:	00000106 	br	8113f53c <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8113f538:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8113f53c:	e0bff817 	ldw	r2,-32(fp)
8113f540:	1000390e 	bge	r2,zero,8113f628 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113f544:	e0bff917 	ldw	r2,-28(fp)
8113f548:	e0fffd84 	addi	r3,fp,-10
8113f54c:	180b883a 	mov	r5,r3
8113f550:	1009883a 	mov	r4,r2
8113f554:	113d20c0 	call	8113d20c <get_cluster_flag>
8113f558:	10003126 	beq	r2,zero,8113f620 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113f55c:	e0bffd8b 	ldhu	r2,-10(fp)
8113f560:	10bfffcc 	andi	r2,r2,65535
8113f564:	10fffe0c 	andi	r3,r2,65528
8113f568:	00bffe14 	movui	r2,65528
8113f56c:	18802e1e 	bne	r3,r2,8113f628 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8113f570:	e0bffe04 	addi	r2,fp,-8
8113f574:	1009883a 	mov	r4,r2
8113f578:	113f2500 	call	8113f250 <find_first_empty_cluster>
8113f57c:	10002326 	beq	r2,zero,8113f60c <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113f580:	e0bff917 	ldw	r2,-28(fp)
8113f584:	e0fffe17 	ldw	r3,-8(fp)
8113f588:	18ffffcc 	andi	r3,r3,65535
8113f58c:	18e0001c 	xori	r3,r3,32768
8113f590:	18e00004 	addi	r3,r3,-32768
8113f594:	01800044 	movi	r6,1
8113f598:	180b883a 	mov	r5,r3
8113f59c:	1009883a 	mov	r4,r2
8113f5a0:	113d2c80 	call	8113d2c8 <mark_cluster>
8113f5a4:	10001926 	beq	r2,zero,8113f60c <find_first_empty_record_in_a_subdirectory+0x208>
8113f5a8:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113f5ac:	01800044 	movi	r6,1
8113f5b0:	017fffc4 	movi	r5,-1
8113f5b4:	1009883a 	mov	r4,r2
8113f5b8:	113d2c80 	call	8113d2c8 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113f5bc:	10001326 	beq	r2,zero,8113f60c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113f5c0:	e0bff917 	ldw	r2,-28(fp)
8113f5c4:	e0fffe17 	ldw	r3,-8(fp)
8113f5c8:	18ffffcc 	andi	r3,r3,65535
8113f5cc:	18e0001c 	xori	r3,r3,32768
8113f5d0:	18e00004 	addi	r3,r3,-32768
8113f5d4:	000d883a 	mov	r6,zero
8113f5d8:	180b883a 	mov	r5,r3
8113f5dc:	1009883a 	mov	r4,r2
8113f5e0:	113d2c80 	call	8113d2c8 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113f5e4:	10000926 	beq	r2,zero,8113f60c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113f5e8:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8113f5ec:	000d883a 	mov	r6,zero
8113f5f0:	017fffc4 	movi	r5,-1
8113f5f4:	1009883a 	mov	r4,r2
8113f5f8:	113d2c80 	call	8113d2c8 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113f5fc:	10000326 	beq	r2,zero,8113f60c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8113f600:	113d0d80 	call	8113d0d8 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8113f604:	e0bffe17 	ldw	r2,-8(fp)
8113f608:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8113f60c:	e0bffd8b 	ldhu	r2,-10(fp)
8113f610:	10bfffcc 	andi	r2,r2,65535
8113f614:	10bffe0c 	andi	r2,r2,65528
8113f618:	e0bff915 	stw	r2,-28(fp)
8113f61c:	00000206 	br	8113f628 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8113f620:	00bfffc4 	movi	r2,-1
8113f624:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8113f628:	e0bff917 	ldw	r2,-28(fp)
8113f62c:	00fffdd4 	movui	r3,65527
8113f630:	18800316 	blt	r3,r2,8113f640 <find_first_empty_record_in_a_subdirectory+0x23c>
8113f634:	e0bff817 	ldw	r2,-32(fp)
8113f638:	10bfffe0 	cmpeqi	r2,r2,-1
8113f63c:	103f7c1e 	bne	r2,zero,8113f430 <__reset+0xfb11f430>
    return result; 
8113f640:	e0bff817 	ldw	r2,-32(fp)
}
8113f644:	e037883a 	mov	sp,fp
8113f648:	dfc00117 	ldw	ra,4(sp)
8113f64c:	df000017 	ldw	fp,0(sp)
8113f650:	dec00204 	addi	sp,sp,8
8113f654:	f800283a 	ret

8113f658 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8113f658:	defff904 	addi	sp,sp,-28
8113f65c:	de00012e 	bgeu	sp,et,8113f664 <find_first_empty_record_in_root_directory+0xc>
8113f660:	003b68fa 	trap	3
8113f664:	dfc00615 	stw	ra,24(sp)
8113f668:	df000515 	stw	fp,20(sp)
8113f66c:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113f670:	00a045b4 	movhi	r2,33046
8113f674:	109b3304 	addi	r2,r2,27852
8113f678:	1080050b 	ldhu	r2,20(r2)
8113f67c:	10bfffcc 	andi	r2,r2,65535
8113f680:	1006917a 	slli	r3,r2,5
8113f684:	00a045b4 	movhi	r2,33046
8113f688:	109b3304 	addi	r2,r2,27852
8113f68c:	1080030b 	ldhu	r2,12(r2)
8113f690:	10bfffcc 	andi	r2,r2,65535
8113f694:	1885283a 	div	r2,r3,r2
8113f698:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8113f69c:	00bfffc4 	movi	r2,-1
8113f6a0:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f6a4:	e03ffb15 	stw	zero,-20(fp)
8113f6a8:	00002d06 	br	8113f760 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113f6ac:	00a045b4 	movhi	r2,33046
8113f6b0:	109b3304 	addi	r2,r2,27852
8113f6b4:	10c01317 	ldw	r3,76(r2)
8113f6b8:	e0bffb17 	ldw	r2,-20(fp)
8113f6bc:	1885883a 	add	r2,r3,r2
8113f6c0:	1007883a 	mov	r3,r2
8113f6c4:	d0a0ab17 	ldw	r2,-32084(gp)
8113f6c8:	100b883a 	mov	r5,r2
8113f6cc:	1809883a 	mov	r4,r3
8113f6d0:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113f6d4:	10002626 	beq	r2,zero,8113f770 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113f6d8:	e03ffc15 	stw	zero,-16(fp)
8113f6dc:	00001a06 	br	8113f748 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113f6e0:	e0bffc17 	ldw	r2,-16(fp)
8113f6e4:	1004917a 	slli	r2,r2,5
8113f6e8:	1007883a 	mov	r3,r2
8113f6ec:	d0a0ad17 	ldw	r2,-32076(gp)
8113f6f0:	10800a17 	ldw	r2,40(r2)
8113f6f4:	1885883a 	add	r2,r3,r2
8113f6f8:	10800023 	ldbuio	r2,0(r2)
8113f6fc:	10803fcc 	andi	r2,r2,255
8113f700:	10803fcc 	andi	r2,r2,255
8113f704:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8113f708:	e0bfff0b 	ldhu	r2,-4(fp)
8113f70c:	10803960 	cmpeqi	r2,r2,229
8113f710:	1000021e 	bne	r2,zero,8113f71c <find_first_empty_record_in_root_directory+0xc4>
8113f714:	e0bfff0b 	ldhu	r2,-4(fp)
8113f718:	1000081e 	bne	r2,zero,8113f73c <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8113f71c:	e0bffb17 	ldw	r2,-20(fp)
8113f720:	1006913a 	slli	r3,r2,4
8113f724:	e0bffc17 	ldw	r2,-16(fp)
8113f728:	1885883a 	add	r2,r3,r2
8113f72c:	1004943a 	slli	r2,r2,16
8113f730:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113f734:	e0bffe17 	ldw	r2,-8(fp)
8113f738:	00000f06 	br	8113f778 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113f73c:	e0bffc17 	ldw	r2,-16(fp)
8113f740:	10800044 	addi	r2,r2,1
8113f744:	e0bffc15 	stw	r2,-16(fp)
8113f748:	e0bffc17 	ldw	r2,-16(fp)
8113f74c:	10800410 	cmplti	r2,r2,16
8113f750:	103fe31e 	bne	r2,zero,8113f6e0 <__reset+0xfb11f6e0>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113f754:	e0bffb17 	ldw	r2,-20(fp)
8113f758:	10800044 	addi	r2,r2,1
8113f75c:	e0bffb15 	stw	r2,-20(fp)
8113f760:	e0fffb17 	ldw	r3,-20(fp)
8113f764:	e0bffd17 	ldw	r2,-12(fp)
8113f768:	18bfd016 	blt	r3,r2,8113f6ac <__reset+0xfb11f6ac>
8113f76c:	00000106 	br	8113f774 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8113f770:	0001883a 	nop
        }
    }
    return result;
8113f774:	e0bffe17 	ldw	r2,-8(fp)
}
8113f778:	e037883a 	mov	sp,fp
8113f77c:	dfc00117 	ldw	ra,4(sp)
8113f780:	df000017 	ldw	fp,0(sp)
8113f784:	dec00204 	addi	sp,sp,8
8113f788:	f800283a 	ret

8113f78c <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8113f78c:	defffa04 	addi	sp,sp,-24
8113f790:	de00012e 	bgeu	sp,et,8113f798 <convert_filename_to_name_extension+0xc>
8113f794:	003b68fa 	trap	3
8113f798:	df000515 	stw	fp,20(sp)
8113f79c:	df000504 	addi	fp,sp,20
8113f7a0:	e13ffd15 	stw	r4,-12(fp)
8113f7a4:	e17ffe15 	stw	r5,-8(fp)
8113f7a8:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8113f7ac:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8113f7b0:	e03ffb15 	stw	zero,-20(fp)
8113f7b4:	00002506 	br	8113f84c <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113f7b8:	e0bffc17 	ldw	r2,-16(fp)
8113f7bc:	e0fffd17 	ldw	r3,-12(fp)
8113f7c0:	1885883a 	add	r2,r3,r2
8113f7c4:	10800003 	ldbu	r2,0(r2)
8113f7c8:	10803fcc 	andi	r2,r2,255
8113f7cc:	1080201c 	xori	r2,r2,128
8113f7d0:	10bfe004 	addi	r2,r2,-128
8113f7d4:	10800ba0 	cmpeqi	r2,r2,46
8113f7d8:	1000141e 	bne	r2,zero,8113f82c <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8113f7dc:	e0bffb17 	ldw	r2,-20(fp)
8113f7e0:	e0fffe17 	ldw	r3,-8(fp)
8113f7e4:	1885883a 	add	r2,r3,r2
8113f7e8:	e0fffc17 	ldw	r3,-16(fp)
8113f7ec:	e13ffd17 	ldw	r4,-12(fp)
8113f7f0:	20c7883a 	add	r3,r4,r3
8113f7f4:	18c00003 	ldbu	r3,0(r3)
8113f7f8:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8113f7fc:	e0bffc17 	ldw	r2,-16(fp)
8113f800:	e0fffd17 	ldw	r3,-12(fp)
8113f804:	1885883a 	add	r2,r3,r2
8113f808:	10800003 	ldbu	r2,0(r2)
8113f80c:	10803fcc 	andi	r2,r2,255
8113f810:	1080201c 	xori	r2,r2,128
8113f814:	10bfe004 	addi	r2,r2,-128
8113f818:	10000926 	beq	r2,zero,8113f840 <convert_filename_to_name_extension+0xb4>
8113f81c:	e0bffc17 	ldw	r2,-16(fp)
8113f820:	10800044 	addi	r2,r2,1
8113f824:	e0bffc15 	stw	r2,-16(fp)
8113f828:	00000506 	br	8113f840 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8113f82c:	e0bffb17 	ldw	r2,-20(fp)
8113f830:	e0fffe17 	ldw	r3,-8(fp)
8113f834:	1885883a 	add	r2,r3,r2
8113f838:	00c00804 	movi	r3,32
8113f83c:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8113f840:	e0bffb17 	ldw	r2,-20(fp)
8113f844:	10800044 	addi	r2,r2,1
8113f848:	e0bffb15 	stw	r2,-20(fp)
8113f84c:	e0bffb17 	ldw	r2,-20(fp)
8113f850:	10800210 	cmplti	r2,r2,8
8113f854:	103fd81e 	bne	r2,zero,8113f7b8 <__reset+0xfb11f7b8>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8113f858:	e0bffc17 	ldw	r2,-16(fp)
8113f85c:	e0fffd17 	ldw	r3,-12(fp)
8113f860:	1885883a 	add	r2,r3,r2
8113f864:	10800003 	ldbu	r2,0(r2)
8113f868:	10803fcc 	andi	r2,r2,255
8113f86c:	1080201c 	xori	r2,r2,128
8113f870:	10bfe004 	addi	r2,r2,-128
8113f874:	10800b98 	cmpnei	r2,r2,46
8113f878:	1000031e 	bne	r2,zero,8113f888 <convert_filename_to_name_extension+0xfc>
8113f87c:	e0bffc17 	ldw	r2,-16(fp)
8113f880:	10800044 	addi	r2,r2,1
8113f884:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8113f888:	e03ffb15 	stw	zero,-20(fp)
8113f88c:	00001c06 	br	8113f900 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8113f890:	e0bffc17 	ldw	r2,-16(fp)
8113f894:	e0fffd17 	ldw	r3,-12(fp)
8113f898:	1885883a 	add	r2,r3,r2
8113f89c:	10800003 	ldbu	r2,0(r2)
8113f8a0:	10803fcc 	andi	r2,r2,255
8113f8a4:	1080201c 	xori	r2,r2,128
8113f8a8:	10bfe004 	addi	r2,r2,-128
8113f8ac:	10000c26 	beq	r2,zero,8113f8e0 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
8113f8b0:	e0bffb17 	ldw	r2,-20(fp)
8113f8b4:	e0ffff17 	ldw	r3,-4(fp)
8113f8b8:	1885883a 	add	r2,r3,r2
8113f8bc:	e0fffc17 	ldw	r3,-16(fp)
8113f8c0:	e13ffd17 	ldw	r4,-12(fp)
8113f8c4:	20c7883a 	add	r3,r4,r3
8113f8c8:	18c00003 	ldbu	r3,0(r3)
8113f8cc:	10c00005 	stb	r3,0(r2)
            local++;
8113f8d0:	e0bffc17 	ldw	r2,-16(fp)
8113f8d4:	10800044 	addi	r2,r2,1
8113f8d8:	e0bffc15 	stw	r2,-16(fp)
8113f8dc:	00000506 	br	8113f8f4 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8113f8e0:	e0bffb17 	ldw	r2,-20(fp)
8113f8e4:	e0ffff17 	ldw	r3,-4(fp)
8113f8e8:	1885883a 	add	r2,r3,r2
8113f8ec:	00c00804 	movi	r3,32
8113f8f0:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8113f8f4:	e0bffb17 	ldw	r2,-20(fp)
8113f8f8:	10800044 	addi	r2,r2,1
8113f8fc:	e0bffb15 	stw	r2,-20(fp)
8113f900:	e0bffb17 	ldw	r2,-20(fp)
8113f904:	108000d0 	cmplti	r2,r2,3
8113f908:	103fe11e 	bne	r2,zero,8113f890 <__reset+0xfb11f890>
        {
            extension[counter] = ' ';
        }
    }

}
8113f90c:	0001883a 	nop
8113f910:	e037883a 	mov	sp,fp
8113f914:	df000017 	ldw	fp,0(sp)
8113f918:	dec00104 	addi	sp,sp,4
8113f91c:	f800283a 	ret

8113f920 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8113f920:	defff504 	addi	sp,sp,-44
8113f924:	de00012e 	bgeu	sp,et,8113f92c <create_file+0xc>
8113f928:	003b68fa 	trap	3
8113f92c:	dfc00a15 	stw	ra,40(sp)
8113f930:	df000915 	stw	fp,36(sp)
8113f934:	df000904 	addi	fp,sp,36
8113f938:	e13ffd15 	stw	r4,-12(fp)
8113f93c:	e17ffe15 	stw	r5,-8(fp)
8113f940:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8113f944:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8113f948:	e0bffc04 	addi	r2,fp,-16
8113f94c:	1009883a 	mov	r4,r2
8113f950:	113f2500 	call	8113f250 <find_first_empty_cluster>
8113f954:	1000a026 	beq	r2,zero,8113fbd8 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8113f958:	e0bfff17 	ldw	r2,-4(fp)
8113f95c:	10800a17 	ldw	r2,40(r2)
8113f960:	1000031e 	bne	r2,zero,8113f970 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8113f964:	113f6580 	call	8113f658 <find_first_empty_record_in_root_directory>
8113f968:	e0bff815 	stw	r2,-32(fp)
8113f96c:	00000606 	br	8113f988 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8113f970:	e0bfff17 	ldw	r2,-4(fp)
8113f974:	1080058b 	ldhu	r2,22(r2)
8113f978:	10bfffcc 	andi	r2,r2,65535
8113f97c:	1009883a 	mov	r4,r2
8113f980:	113f4040 	call	8113f404 <find_first_empty_record_in_a_subdirectory>
8113f984:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
8113f988:	e0bff817 	ldw	r2,-32(fp)
8113f98c:	10009216 	blt	r2,zero,8113fbd8 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8113f990:	e13ffd17 	ldw	r4,-12(fp)
8113f994:	113e5300 	call	8113e530 <get_dir_divider_location>
8113f998:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
8113f99c:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8113f9a0:	00000b06 	br	8113f9d0 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8113f9a4:	e0fffa17 	ldw	r3,-24(fp)
8113f9a8:	e0bff917 	ldw	r2,-28(fp)
8113f9ac:	1885883a 	add	r2,r3,r2
8113f9b0:	10800044 	addi	r2,r2,1
8113f9b4:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
8113f9b8:	e0bffa17 	ldw	r2,-24(fp)
8113f9bc:	e0fffd17 	ldw	r3,-12(fp)
8113f9c0:	1885883a 	add	r2,r3,r2
8113f9c4:	1009883a 	mov	r4,r2
8113f9c8:	113e5300 	call	8113e530 <get_dir_divider_location>
8113f9cc:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
8113f9d0:	e0bff917 	ldw	r2,-28(fp)
8113f9d4:	00bff316 	blt	zero,r2,8113f9a4 <__reset+0xfb11f9a4>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8113f9d8:	e0bffa17 	ldw	r2,-24(fp)
8113f9dc:	e0fffd17 	ldw	r3,-12(fp)
8113f9e0:	1887883a 	add	r3,r3,r2
8113f9e4:	e13ffe17 	ldw	r4,-8(fp)
8113f9e8:	e0bffe17 	ldw	r2,-8(fp)
8113f9ec:	10800204 	addi	r2,r2,8
8113f9f0:	100d883a 	mov	r6,r2
8113f9f4:	200b883a 	mov	r5,r4
8113f9f8:	1809883a 	mov	r4,r3
8113f9fc:	113f78c0 	call	8113f78c <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8113fa00:	e0bffe17 	ldw	r2,-8(fp)
8113fa04:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8113fa08:	e0bffe17 	ldw	r2,-8(fp)
8113fa0c:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8113fa10:	e0bffe17 	ldw	r2,-8(fp)
8113fa14:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8113fa18:	e0bffe17 	ldw	r2,-8(fp)
8113fa1c:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8113fa20:	e0bffe17 	ldw	r2,-8(fp)
8113fa24:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8113fa28:	e0bffe17 	ldw	r2,-8(fp)
8113fa2c:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8113fa30:	e0bffc17 	ldw	r2,-16(fp)
8113fa34:	1007883a 	mov	r3,r2
8113fa38:	e0bffe17 	ldw	r2,-8(fp)
8113fa3c:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8113fa40:	e0bffe17 	ldw	r2,-8(fp)
8113fa44:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8113fa48:	e0fffc17 	ldw	r3,-16(fp)
8113fa4c:	e0bffe17 	ldw	r2,-8(fp)
8113fa50:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8113fa54:	e0bffe17 	ldw	r2,-8(fp)
8113fa58:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
8113fa5c:	e0bffe17 	ldw	r2,-8(fp)
8113fa60:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8113fa64:	e0bff817 	ldw	r2,-32(fp)
8113fa68:	10ffffcc 	andi	r3,r2,65535
8113fa6c:	e0bffe17 	ldw	r2,-8(fp)
8113fa70:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8113fa74:	e0bff817 	ldw	r2,-32(fp)
8113fa78:	1004d43a 	srli	r2,r2,16
8113fa7c:	1000010e 	bge	r2,zero,8113fa84 <create_file+0x164>
8113fa80:	108003c4 	addi	r2,r2,15
8113fa84:	1005d13a 	srai	r2,r2,4
8113fa88:	1007883a 	mov	r3,r2
8113fa8c:	e0bffe17 	ldw	r2,-8(fp)
8113fa90:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8113fa94:	e0bff817 	ldw	r2,-32(fp)
8113fa98:	1004d43a 	srli	r2,r2,16
8113fa9c:	1007883a 	mov	r3,r2
8113faa0:	00a00034 	movhi	r2,32768
8113faa4:	108003c4 	addi	r2,r2,15
8113faa8:	1884703a 	and	r2,r3,r2
8113faac:	1000040e 	bge	r2,zero,8113fac0 <create_file+0x1a0>
8113fab0:	10bfffc4 	addi	r2,r2,-1
8113fab4:	00fffc04 	movi	r3,-16
8113fab8:	10c4b03a 	or	r2,r2,r3
8113fabc:	10800044 	addi	r2,r2,1
8113fac0:	1004917a 	slli	r2,r2,5
8113fac4:	1007883a 	mov	r3,r2
8113fac8:	e0bffe17 	ldw	r2,-8(fp)
8113facc:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
8113fad0:	e0bfff17 	ldw	r2,-4(fp)
8113fad4:	1080058b 	ldhu	r2,22(r2)
8113fad8:	10ffffcc 	andi	r3,r2,65535
8113fadc:	e0bffe17 	ldw	r2,-8(fp)
8113fae0:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8113fae4:	e0bffe17 	ldw	r2,-8(fp)
8113fae8:	00c00044 	movi	r3,1
8113faec:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
8113faf0:	e0bffe17 	ldw	r2,-8(fp)
8113faf4:	00c00044 	movi	r3,1
8113faf8:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113fafc:	e0bffe17 	ldw	r2,-8(fp)
8113fb00:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113fb04:	1000071e 	bne	r2,zero,8113fb24 <create_file+0x204>
8113fb08:	00a045b4 	movhi	r2,33046
8113fb0c:	109b3304 	addi	r2,r2,27852
8113fb10:	10c01317 	ldw	r3,76(r2)
8113fb14:	e0bffe17 	ldw	r2,-8(fp)
8113fb18:	10800b17 	ldw	r2,44(r2)
8113fb1c:	1885883a 	add	r2,r3,r2
8113fb20:	00000f06 	br	8113fb60 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8113fb24:	00a045b4 	movhi	r2,33046
8113fb28:	109b3304 	addi	r2,r2,27852
8113fb2c:	10c01417 	ldw	r3,80(r2)
8113fb30:	e0bffe17 	ldw	r2,-8(fp)
8113fb34:	10800a17 	ldw	r2,40(r2)
8113fb38:	113fff84 	addi	r4,r2,-2
8113fb3c:	00a045b4 	movhi	r2,33046
8113fb40:	109b3304 	addi	r2,r2,27852
8113fb44:	10800383 	ldbu	r2,14(r2)
8113fb48:	10803fcc 	andi	r2,r2,255
8113fb4c:	2085383a 	mul	r2,r4,r2
8113fb50:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8113fb54:	e0bffe17 	ldw	r2,-8(fp)
8113fb58:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113fb5c:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113fb60:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8113fb64:	e0bffb17 	ldw	r2,-20(fp)
8113fb68:	d0e0ab17 	ldw	r3,-32084(gp)
8113fb6c:	180b883a 	mov	r5,r3
8113fb70:	1009883a 	mov	r4,r2
8113fb74:	113d12c0 	call	8113d12c <Read_Sector_Data>
8113fb78:	10001726 	beq	r2,zero,8113fbd8 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
8113fb7c:	e0bffe17 	ldw	r2,-8(fp)
8113fb80:	10800c0b 	ldhu	r2,48(r2)
8113fb84:	10bfffcc 	andi	r2,r2,65535
8113fb88:	10a0001c 	xori	r2,r2,32768
8113fb8c:	10a00004 	addi	r2,r2,-32768
8113fb90:	e17ffe17 	ldw	r5,-8(fp)
8113fb94:	1009883a 	mov	r4,r2
8113fb98:	113d7e00 	call	8113d7e0 <Write_File_Record_At_Offset>
8113fb9c:	10000e26 	beq	r2,zero,8113fbd8 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
8113fba0:	113d0d80 	call	8113d0d8 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8113fba4:	e0bffc17 	ldw	r2,-16(fp)
8113fba8:	01800044 	movi	r6,1
8113fbac:	017fffc4 	movi	r5,-1
8113fbb0:	1009883a 	mov	r4,r2
8113fbb4:	113d2c80 	call	8113d2c8 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
8113fbb8:	e0bffc17 	ldw	r2,-16(fp)
8113fbbc:	000d883a 	mov	r6,zero
8113fbc0:	017fffc4 	movi	r5,-1
8113fbc4:	1009883a 	mov	r4,r2
8113fbc8:	113d2c80 	call	8113d2c8 <mark_cluster>
8113fbcc:	10000226 	beq	r2,zero,8113fbd8 <create_file+0x2b8>
                    {
                        result = true;
8113fbd0:	00800044 	movi	r2,1
8113fbd4:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
8113fbd8:	e0bff717 	ldw	r2,-36(fp)
}
8113fbdc:	e037883a 	mov	sp,fp
8113fbe0:	dfc00117 	ldw	ra,4(sp)
8113fbe4:	df000017 	ldw	fp,0(sp)
8113fbe8:	dec00204 	addi	sp,sp,8
8113fbec:	f800283a 	ret

8113fbf0 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
8113fbf0:	defffb04 	addi	sp,sp,-20
8113fbf4:	de00012e 	bgeu	sp,et,8113fbfc <copy_file_record_name_to_string+0xc>
8113fbf8:	003b68fa 	trap	3
8113fbfc:	df000415 	stw	fp,16(sp)
8113fc00:	df000404 	addi	fp,sp,16
8113fc04:	e13ffe15 	stw	r4,-8(fp)
8113fc08:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
8113fc0c:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113fc10:	e03ffc15 	stw	zero,-16(fp)
8113fc14:	00001506 	br	8113fc6c <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
8113fc18:	e0fffe17 	ldw	r3,-8(fp)
8113fc1c:	e0bffc17 	ldw	r2,-16(fp)
8113fc20:	1885883a 	add	r2,r3,r2
8113fc24:	10800003 	ldbu	r2,0(r2)
8113fc28:	10803fcc 	andi	r2,r2,255
8113fc2c:	10800820 	cmpeqi	r2,r2,32
8113fc30:	10000b1e 	bne	r2,zero,8113fc60 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8113fc34:	e0bffd17 	ldw	r2,-12(fp)
8113fc38:	e0ffff17 	ldw	r3,-4(fp)
8113fc3c:	1885883a 	add	r2,r3,r2
8113fc40:	e13ffe17 	ldw	r4,-8(fp)
8113fc44:	e0fffc17 	ldw	r3,-16(fp)
8113fc48:	20c7883a 	add	r3,r4,r3
8113fc4c:	18c00003 	ldbu	r3,0(r3)
8113fc50:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8113fc54:	e0bffd17 	ldw	r2,-12(fp)
8113fc58:	10800044 	addi	r2,r2,1
8113fc5c:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113fc60:	e0bffc17 	ldw	r2,-16(fp)
8113fc64:	10800044 	addi	r2,r2,1
8113fc68:	e0bffc15 	stw	r2,-16(fp)
8113fc6c:	e0bffc17 	ldw	r2,-16(fp)
8113fc70:	10800210 	cmplti	r2,r2,8
8113fc74:	103fe81e 	bne	r2,zero,8113fc18 <__reset+0xfb11fc18>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
8113fc78:	e0bffe17 	ldw	r2,-8(fp)
8113fc7c:	10800203 	ldbu	r2,8(r2)
8113fc80:	10803fcc 	andi	r2,r2,255
8113fc84:	10800820 	cmpeqi	r2,r2,32
8113fc88:	1000241e 	bne	r2,zero,8113fd1c <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
8113fc8c:	e0bffd17 	ldw	r2,-12(fp)
8113fc90:	e0ffff17 	ldw	r3,-4(fp)
8113fc94:	1885883a 	add	r2,r3,r2
8113fc98:	00c00b84 	movi	r3,46
8113fc9c:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
8113fca0:	e0bffd17 	ldw	r2,-12(fp)
8113fca4:	10800044 	addi	r2,r2,1
8113fca8:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
8113fcac:	e03ffc15 	stw	zero,-16(fp)
8113fcb0:	00001706 	br	8113fd10 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
8113fcb4:	e0fffe17 	ldw	r3,-8(fp)
8113fcb8:	e0bffc17 	ldw	r2,-16(fp)
8113fcbc:	1885883a 	add	r2,r3,r2
8113fcc0:	10800204 	addi	r2,r2,8
8113fcc4:	10800003 	ldbu	r2,0(r2)
8113fcc8:	10803fcc 	andi	r2,r2,255
8113fccc:	10800820 	cmpeqi	r2,r2,32
8113fcd0:	10000c1e 	bne	r2,zero,8113fd04 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
8113fcd4:	e0bffd17 	ldw	r2,-12(fp)
8113fcd8:	e0ffff17 	ldw	r3,-4(fp)
8113fcdc:	1885883a 	add	r2,r3,r2
8113fce0:	e13ffe17 	ldw	r4,-8(fp)
8113fce4:	e0fffc17 	ldw	r3,-16(fp)
8113fce8:	20c7883a 	add	r3,r4,r3
8113fcec:	18c00204 	addi	r3,r3,8
8113fcf0:	18c00003 	ldbu	r3,0(r3)
8113fcf4:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
8113fcf8:	e0bffd17 	ldw	r2,-12(fp)
8113fcfc:	10800044 	addi	r2,r2,1
8113fd00:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8113fd04:	e0bffc17 	ldw	r2,-16(fp)
8113fd08:	10800044 	addi	r2,r2,1
8113fd0c:	e0bffc15 	stw	r2,-16(fp)
8113fd10:	e0bffc17 	ldw	r2,-16(fp)
8113fd14:	108000d0 	cmplti	r2,r2,3
8113fd18:	103fe61e 	bne	r2,zero,8113fcb4 <__reset+0xfb11fcb4>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8113fd1c:	e0bffd17 	ldw	r2,-12(fp)
8113fd20:	e0ffff17 	ldw	r3,-4(fp)
8113fd24:	1885883a 	add	r2,r3,r2
8113fd28:	10000005 	stb	zero,0(r2)
}
8113fd2c:	0001883a 	nop
8113fd30:	e037883a 	mov	sp,fp
8113fd34:	df000017 	ldw	fp,0(sp)
8113fd38:	dec00104 	addi	sp,sp,4
8113fd3c:	f800283a 	ret

8113fd40 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
8113fd40:	defffc04 	addi	sp,sp,-16
8113fd44:	de00012e 	bgeu	sp,et,8113fd4c <alt_up_sd_card_open_dev+0xc>
8113fd48:	003b68fa 	trap	3
8113fd4c:	dfc00315 	stw	ra,12(sp)
8113fd50:	df000215 	stw	fp,8(sp)
8113fd54:	df000204 	addi	fp,sp,8
8113fd58:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
8113fd5c:	d1600d04 	addi	r5,gp,-32716
8113fd60:	e13fff17 	ldw	r4,-4(fp)
8113fd64:	11451fc0 	call	811451fc <alt_find_dev>
8113fd68:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
8113fd6c:	e0bffe17 	ldw	r2,-8(fp)
8113fd70:	10001e26 	beq	r2,zero,8113fdec <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8113fd74:	e0bffe17 	ldw	r2,-8(fp)
8113fd78:	10800a17 	ldw	r2,40(r2)
8113fd7c:	10808d04 	addi	r2,r2,564
8113fd80:	d0a0a515 	stw	r2,-32108(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8113fd84:	e0bffe17 	ldw	r2,-8(fp)
8113fd88:	10800a17 	ldw	r2,40(r2)
8113fd8c:	10808904 	addi	r2,r2,548
8113fd90:	d0a0a615 	stw	r2,-32104(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8113fd94:	e0bffe17 	ldw	r2,-8(fp)
8113fd98:	10800a17 	ldw	r2,40(r2)
8113fd9c:	10808404 	addi	r2,r2,528
8113fda0:	d0a0a715 	stw	r2,-32100(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
8113fda4:	e0bffe17 	ldw	r2,-8(fp)
8113fda8:	10800a17 	ldw	r2,40(r2)
8113fdac:	10808c04 	addi	r2,r2,560
8113fdb0:	d0a0a815 	stw	r2,-32096(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
8113fdb4:	e0bffe17 	ldw	r2,-8(fp)
8113fdb8:	10800a17 	ldw	r2,40(r2)
8113fdbc:	10808b04 	addi	r2,r2,556
8113fdc0:	d0a0a915 	stw	r2,-32092(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
8113fdc4:	e0bffe17 	ldw	r2,-8(fp)
8113fdc8:	10800a17 	ldw	r2,40(r2)
8113fdcc:	d0a0aa15 	stw	r2,-32088(gp)
		device_pointer = dev;
8113fdd0:	e0bffe17 	ldw	r2,-8(fp)
8113fdd4:	d0a0ad15 	stw	r2,-32076(gp)
		initialized = false;
8113fdd8:	d020a315 	stw	zero,-32116(gp)
		is_sd_card_formated_as_FAT16 = false;
8113fddc:	d020a415 	stw	zero,-32112(gp)
		search_data.valid = false;
8113fde0:	00a045b4 	movhi	r2,33046
8113fde4:	109b2e04 	addi	r2,r2,27832
8113fde8:	10000415 	stw	zero,16(r2)
	}
	return dev;
8113fdec:	e0bffe17 	ldw	r2,-8(fp)
}
8113fdf0:	e037883a 	mov	sp,fp
8113fdf4:	dfc00117 	ldw	ra,4(sp)
8113fdf8:	df000017 	ldw	fp,0(sp)
8113fdfc:	dec00204 	addi	sp,sp,8
8113fe00:	f800283a 	ret

8113fe04 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8113fe04:	defffd04 	addi	sp,sp,-12
8113fe08:	de00012e 	bgeu	sp,et,8113fe10 <alt_up_sd_card_is_Present+0xc>
8113fe0c:	003b68fa 	trap	3
8113fe10:	df000215 	stw	fp,8(sp)
8113fe14:	df000204 	addi	fp,sp,8
    bool result = false;
8113fe18:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8113fe1c:	d0a0ad17 	ldw	r2,-32076(gp)
8113fe20:	10000826 	beq	r2,zero,8113fe44 <alt_up_sd_card_is_Present+0x40>
8113fe24:	d0a0a517 	ldw	r2,-32108(gp)
8113fe28:	1080002b 	ldhuio	r2,0(r2)
8113fe2c:	10bfffcc 	andi	r2,r2,65535
8113fe30:	1080008c 	andi	r2,r2,2
8113fe34:	10000326 	beq	r2,zero,8113fe44 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
8113fe38:	00800044 	movi	r2,1
8113fe3c:	e0bffe15 	stw	r2,-8(fp)
8113fe40:	00001e06 	br	8113febc <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8113fe44:	d0a0a317 	ldw	r2,-32116(gp)
8113fe48:	10800058 	cmpnei	r2,r2,1
8113fe4c:	10001b1e 	bne	r2,zero,8113febc <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
8113fe50:	d020a315 	stw	zero,-32116(gp)
		search_data.valid = false;
8113fe54:	00a045b4 	movhi	r2,33046
8113fe58:	109b2e04 	addi	r2,r2,27832
8113fe5c:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
8113fe60:	d020a415 	stw	zero,-32112(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113fe64:	e03fff15 	stw	zero,-4(fp)
8113fe68:	00001106 	br	8113feb0 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
8113fe6c:	00a045b4 	movhi	r2,33046
8113fe70:	109b4804 	addi	r2,r2,27936
8113fe74:	e0ffff17 	ldw	r3,-4(fp)
8113fe78:	180691ba 	slli	r3,r3,6
8113fe7c:	10c5883a 	add	r2,r2,r3
8113fe80:	10800f04 	addi	r2,r2,60
8113fe84:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
8113fe88:	00a045b4 	movhi	r2,33046
8113fe8c:	109b4804 	addi	r2,r2,27936
8113fe90:	e0ffff17 	ldw	r3,-4(fp)
8113fe94:	180691ba 	slli	r3,r3,6
8113fe98:	10c5883a 	add	r2,r2,r3
8113fe9c:	10800e04 	addi	r2,r2,56
8113fea0:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113fea4:	e0bfff17 	ldw	r2,-4(fp)
8113fea8:	10800044 	addi	r2,r2,1
8113feac:	e0bfff15 	stw	r2,-4(fp)
8113feb0:	e0bfff17 	ldw	r2,-4(fp)
8113feb4:	10800510 	cmplti	r2,r2,20
8113feb8:	103fec1e 	bne	r2,zero,8113fe6c <__reset+0xfb11fe6c>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
8113febc:	e0bffe17 	ldw	r2,-8(fp)
}
8113fec0:	e037883a 	mov	sp,fp
8113fec4:	df000017 	ldw	fp,0(sp)
8113fec8:	dec00104 	addi	sp,sp,4
8113fecc:	f800283a 	ret

8113fed0 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
8113fed0:	defffd04 	addi	sp,sp,-12
8113fed4:	de00012e 	bgeu	sp,et,8113fedc <alt_up_sd_card_is_FAT16+0xc>
8113fed8:	003b68fa 	trap	3
8113fedc:	dfc00215 	stw	ra,8(sp)
8113fee0:	df000115 	stw	fp,4(sp)
8113fee4:	df000104 	addi	fp,sp,4
	bool result = false;
8113fee8:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8113feec:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113fef0:	10000c26 	beq	r2,zero,8113ff24 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8113fef4:	d0a0a317 	ldw	r2,-32116(gp)
8113fef8:	1000071e 	bne	r2,zero,8113ff18 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8113fefc:	113e0fc0 	call	8113e0fc <Look_for_FAT16>
8113ff00:	d0a0a415 	stw	r2,-32112(gp)
			initialized = is_sd_card_formated_as_FAT16;
8113ff04:	d0a0a417 	ldw	r2,-32112(gp)
8113ff08:	d0a0a315 	stw	r2,-32116(gp)
			search_data.valid = false;
8113ff0c:	00a045b4 	movhi	r2,33046
8113ff10:	109b2e04 	addi	r2,r2,27832
8113ff14:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8113ff18:	d0a0a417 	ldw	r2,-32112(gp)
8113ff1c:	e0bfff15 	stw	r2,-4(fp)
8113ff20:	00000206 	br	8113ff2c <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8113ff24:	d020a315 	stw	zero,-32116(gp)
		is_sd_card_formated_as_FAT16 = false;
8113ff28:	d020a415 	stw	zero,-32112(gp)
	}

	return result;
8113ff2c:	e0bfff17 	ldw	r2,-4(fp)
}
8113ff30:	e037883a 	mov	sp,fp
8113ff34:	dfc00117 	ldw	ra,4(sp)
8113ff38:	df000017 	ldw	fp,0(sp)
8113ff3c:	dec00204 	addi	sp,sp,8
8113ff40:	f800283a 	ret

8113ff44 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8113ff44:	deffea04 	addi	sp,sp,-88
8113ff48:	de00012e 	bgeu	sp,et,8113ff50 <alt_up_sd_card_find_first+0xc>
8113ff4c:	003b68fa 	trap	3
8113ff50:	dfc01515 	stw	ra,84(sp)
8113ff54:	df001415 	stw	fp,80(sp)
8113ff58:	df001404 	addi	fp,sp,80
8113ff5c:	e13ffe15 	stw	r4,-8(fp)
8113ff60:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8113ff64:	00800084 	movi	r2,2
8113ff68:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ff6c:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
8113ff70:	10002426 	beq	r2,zero,81140004 <alt_up_sd_card_find_first+0xc0>
8113ff74:	d0a0a417 	ldw	r2,-32112(gp)
8113ff78:	10002226 	beq	r2,zero,81140004 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
8113ff7c:	e0ffee04 	addi	r3,fp,-72
8113ff80:	e0bfed04 	addi	r2,fp,-76
8113ff84:	180d883a 	mov	r6,r3
8113ff88:	100b883a 	mov	r5,r2
8113ff8c:	e13ffe17 	ldw	r4,-8(fp)
8113ff90:	113e8940 	call	8113e894 <get_home_directory_cluster_for_file>
8113ff94:	10001926 	beq	r2,zero,8113fffc <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
8113ff98:	e0bfed17 	ldw	r2,-76(fp)
8113ff9c:	1007883a 	mov	r3,r2
8113ffa0:	00a045b4 	movhi	r2,33046
8113ffa4:	109b2e04 	addi	r2,r2,27832
8113ffa8:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
8113ffac:	e0bfed17 	ldw	r2,-76(fp)
8113ffb0:	1007883a 	mov	r3,r2
8113ffb4:	00a045b4 	movhi	r2,33046
8113ffb8:	109b2e04 	addi	r2,r2,27832
8113ffbc:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
8113ffc0:	00a045b4 	movhi	r2,33046
8113ffc4:	109b2e04 	addi	r2,r2,27832
8113ffc8:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
8113ffcc:	00a045b4 	movhi	r2,33046
8113ffd0:	109b2e04 	addi	r2,r2,27832
8113ffd4:	00ffffc4 	movi	r3,-1
8113ffd8:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8113ffdc:	00a045b4 	movhi	r2,33046
8113ffe0:	109b2e04 	addi	r2,r2,27832
8113ffe4:	00c00044 	movi	r3,1
8113ffe8:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8113ffec:	e13fff17 	ldw	r4,-4(fp)
8113fff0:	114001c0 	call	8114001c <alt_up_sd_card_find_next>
8113fff4:	e0bfec0d 	sth	r2,-80(fp)
8113fff8:	00000206 	br	81140004 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8113fffc:	00800044 	movi	r2,1
81140000:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81140004:	e0bfec0b 	ldhu	r2,-80(fp)
}
81140008:	e037883a 	mov	sp,fp
8114000c:	dfc00117 	ldw	ra,4(sp)
81140010:	df000017 	ldw	fp,0(sp)
81140014:	dec00204 	addi	sp,sp,8
81140018:	f800283a 	ret

8114001c <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8114001c:	deffe404 	addi	sp,sp,-112
81140020:	de00012e 	bgeu	sp,et,81140028 <alt_up_sd_card_find_next+0xc>
81140024:	003b68fa 	trap	3
81140028:	dfc01b15 	stw	ra,108(sp)
8114002c:	df001a15 	stw	fp,104(sp)
81140030:	df001a04 	addi	fp,sp,104
81140034:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81140038:	00800084 	movi	r2,2
8114003c:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140040:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
81140044:	1000df26 	beq	r2,zero,811403c4 <alt_up_sd_card_find_next+0x3a8>
81140048:	d0a0a417 	ldw	r2,-32112(gp)
8114004c:	1000dd26 	beq	r2,zero,811403c4 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81140050:	00a045b4 	movhi	r2,33046
81140054:	109b2e04 	addi	r2,r2,27832
81140058:	10800417 	ldw	r2,16(r2)
8114005c:	1000d726 	beq	r2,zero,811403bc <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81140060:	00a045b4 	movhi	r2,33046
81140064:	109b2e04 	addi	r2,r2,27832
81140068:	10800117 	ldw	r2,4(r2)
8114006c:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81140070:	e0bfe717 	ldw	r2,-100(fp)
81140074:	1000561e 	bne	r2,zero,811401d0 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81140078:	00a045b4 	movhi	r2,33046
8114007c:	109b3304 	addi	r2,r2,27852
81140080:	1080050b 	ldhu	r2,20(r2)
81140084:	10bfffcc 	andi	r2,r2,65535
81140088:	1006917a 	slli	r3,r2,5
8114008c:	00a045b4 	movhi	r2,33046
81140090:	109b3304 	addi	r2,r2,27852
81140094:	1080030b 	ldhu	r2,12(r2)
81140098:	10bfffcc 	andi	r2,r2,65535
8114009c:	1885283a 	div	r2,r3,r2
811400a0:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811400a4:	00a045b4 	movhi	r2,33046
811400a8:	109b2e04 	addi	r2,r2,27832
811400ac:	10800217 	ldw	r2,8(r2)
811400b0:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
811400b4:	00a045b4 	movhi	r2,33046
811400b8:	109b2e04 	addi	r2,r2,27832
811400bc:	1080030b 	ldhu	r2,12(r2)
811400c0:	10bfffcc 	andi	r2,r2,65535
811400c4:	10a0001c 	xori	r2,r2,32768
811400c8:	10a00004 	addi	r2,r2,-32768
811400cc:	10800044 	addi	r2,r2,1
811400d0:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811400d4:	00003606 	br	811401b0 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811400d8:	00a045b4 	movhi	r2,33046
811400dc:	109b3304 	addi	r2,r2,27852
811400e0:	10c01317 	ldw	r3,76(r2)
811400e4:	e0bfe817 	ldw	r2,-96(fp)
811400e8:	1885883a 	add	r2,r3,r2
811400ec:	1007883a 	mov	r3,r2
811400f0:	d0a0ab17 	ldw	r2,-32084(gp)
811400f4:	100b883a 	mov	r5,r2
811400f8:	1809883a 	mov	r4,r3
811400fc:	113d12c0 	call	8113d12c <Read_Sector_Data>
81140100:	10002f26 	beq	r2,zero,811401c0 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81140104:	00002306 	br	81140194 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81140108:	e0bfe917 	ldw	r2,-92(fp)
8114010c:	1004917a 	slli	r2,r2,5
81140110:	e13fe817 	ldw	r4,-96(fp)
81140114:	e0ffef04 	addi	r3,fp,-68
81140118:	200f883a 	mov	r7,r4
8114011c:	000d883a 	mov	r6,zero
81140120:	180b883a 	mov	r5,r3
81140124:	1009883a 	mov	r4,r2
81140128:	113d55c0 	call	8113d55c <Read_File_Record_At_Offset>
8114012c:	10001626 	beq	r2,zero,81140188 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81140130:	e0bfef03 	ldbu	r2,-68(fp)
81140134:	10803fcc 	andi	r2,r2,255
81140138:	10001326 	beq	r2,zero,81140188 <alt_up_sd_card_find_next+0x16c>
8114013c:	e0bfef03 	ldbu	r2,-68(fp)
81140140:	10803fcc 	andi	r2,r2,255
81140144:	10803960 	cmpeqi	r2,r2,229
81140148:	10000f1e 	bne	r2,zero,81140188 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8114014c:	e0bfe917 	ldw	r2,-92(fp)
81140150:	1007883a 	mov	r3,r2
81140154:	00a045b4 	movhi	r2,33046
81140158:	109b2e04 	addi	r2,r2,27832
8114015c:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81140160:	e0ffe817 	ldw	r3,-96(fp)
81140164:	00a045b4 	movhi	r2,33046
81140168:	109b2e04 	addi	r2,r2,27832
8114016c:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81140170:	e0bfef04 	addi	r2,fp,-68
81140174:	e17fff17 	ldw	r5,-4(fp)
81140178:	1009883a 	mov	r4,r2
8114017c:	113fbf00 	call	8113fbf0 <copy_file_record_name_to_string>
									return 0;
81140180:	0005883a 	mov	r2,zero
81140184:	00009006 	br	811403c8 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81140188:	e0bfe917 	ldw	r2,-92(fp)
8114018c:	10800044 	addi	r2,r2,1
81140190:	e0bfe915 	stw	r2,-92(fp)
81140194:	e0bfe917 	ldw	r2,-92(fp)
81140198:	10800410 	cmplti	r2,r2,16
8114019c:	103fda1e 	bne	r2,zero,81140108 <__reset+0xfb120108>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811401a0:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811401a4:	e0bfe817 	ldw	r2,-96(fp)
811401a8:	10800044 	addi	r2,r2,1
811401ac:	e0bfe815 	stw	r2,-96(fp)
811401b0:	e0ffe817 	ldw	r3,-96(fp)
811401b4:	e0bfec17 	ldw	r2,-80(fp)
811401b8:	18bfc716 	blt	r3,r2,811400d8 <__reset+0xfb1200d8>
811401bc:	00000106 	br	811401c4 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
811401c0:	0001883a 	nop
					}
				}
				result = -1;
811401c4:	00bfffc4 	movi	r2,-1
811401c8:	e0bfe60d 	sth	r2,-104(fp)
811401cc:	00007d06 	br	811403c4 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
811401d0:	00a045b4 	movhi	r2,33046
811401d4:	109b2e04 	addi	r2,r2,27832
811401d8:	1080030b 	ldhu	r2,12(r2)
811401dc:	10bfffcc 	andi	r2,r2,65535
811401e0:	10a0001c 	xori	r2,r2,32768
811401e4:	10a00004 	addi	r2,r2,-32768
811401e8:	10800044 	addi	r2,r2,1
811401ec:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811401f0:	e0bfe717 	ldw	r2,-100(fp)
811401f4:	10ffff84 	addi	r3,r2,-2
811401f8:	00a045b4 	movhi	r2,33046
811401fc:	109b3304 	addi	r2,r2,27852
81140200:	10800383 	ldbu	r2,14(r2)
81140204:	10803fcc 	andi	r2,r2,255
81140208:	1885383a 	mul	r2,r3,r2
8114020c:	1007883a 	mov	r3,r2
81140210:	00a045b4 	movhi	r2,33046
81140214:	109b3304 	addi	r2,r2,27852
81140218:	10801417 	ldw	r2,80(r2)
8114021c:	1885883a 	add	r2,r3,r2
81140220:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81140224:	00a045b4 	movhi	r2,33046
81140228:	109b2e04 	addi	r2,r2,27832
8114022c:	10800217 	ldw	r2,8(r2)
81140230:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140234:	00003806 	br	81140318 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81140238:	e0ffeb17 	ldw	r3,-84(fp)
8114023c:	e0bfed17 	ldw	r2,-76(fp)
81140240:	1885883a 	add	r2,r3,r2
81140244:	d0e0ab17 	ldw	r3,-32084(gp)
81140248:	180b883a 	mov	r5,r3
8114024c:	1009883a 	mov	r4,r2
81140250:	113d12c0 	call	8113d12c <Read_Sector_Data>
81140254:	10003726 	beq	r2,zero,81140334 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81140258:	00002806 	br	811402fc <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8114025c:	e0bfea17 	ldw	r2,-88(fp)
81140260:	1004917a 	slli	r2,r2,5
81140264:	e13fe717 	ldw	r4,-100(fp)
81140268:	e17feb17 	ldw	r5,-84(fp)
8114026c:	e0ffef04 	addi	r3,fp,-68
81140270:	280f883a 	mov	r7,r5
81140274:	200d883a 	mov	r6,r4
81140278:	180b883a 	mov	r5,r3
8114027c:	1009883a 	mov	r4,r2
81140280:	113d55c0 	call	8113d55c <Read_File_Record_At_Offset>
81140284:	10001a26 	beq	r2,zero,811402f0 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81140288:	e0bfef03 	ldbu	r2,-68(fp)
8114028c:	10803fcc 	andi	r2,r2,255
81140290:	10001726 	beq	r2,zero,811402f0 <alt_up_sd_card_find_next+0x2d4>
81140294:	e0bfef03 	ldbu	r2,-68(fp)
81140298:	10803fcc 	andi	r2,r2,255
8114029c:	10803960 	cmpeqi	r2,r2,229
811402a0:	1000131e 	bne	r2,zero,811402f0 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811402a4:	e0ffe717 	ldw	r3,-100(fp)
811402a8:	00a045b4 	movhi	r2,33046
811402ac:	109b2e04 	addi	r2,r2,27832
811402b0:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
811402b4:	e0bfea17 	ldw	r2,-88(fp)
811402b8:	1007883a 	mov	r3,r2
811402bc:	00a045b4 	movhi	r2,33046
811402c0:	109b2e04 	addi	r2,r2,27832
811402c4:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
811402c8:	e0ffeb17 	ldw	r3,-84(fp)
811402cc:	00a045b4 	movhi	r2,33046
811402d0:	109b2e04 	addi	r2,r2,27832
811402d4:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
811402d8:	e0bfef04 	addi	r2,fp,-68
811402dc:	e17fff17 	ldw	r5,-4(fp)
811402e0:	1009883a 	mov	r4,r2
811402e4:	113fbf00 	call	8113fbf0 <copy_file_record_name_to_string>
										return 0;
811402e8:	0005883a 	mov	r2,zero
811402ec:	00003606 	br	811403c8 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
811402f0:	e0bfea17 	ldw	r2,-88(fp)
811402f4:	10800044 	addi	r2,r2,1
811402f8:	e0bfea15 	stw	r2,-88(fp)
811402fc:	e0bfea17 	ldw	r2,-88(fp)
81140300:	10800410 	cmplti	r2,r2,16
81140304:	103fd51e 	bne	r2,zero,8114025c <__reset+0xfb12025c>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81140308:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114030c:	e0bfeb17 	ldw	r2,-84(fp)
81140310:	10800044 	addi	r2,r2,1
81140314:	e0bfeb15 	stw	r2,-84(fp)
81140318:	00a045b4 	movhi	r2,33046
8114031c:	109b3304 	addi	r2,r2,27852
81140320:	10800383 	ldbu	r2,14(r2)
81140324:	10803fcc 	andi	r2,r2,255
81140328:	e0ffeb17 	ldw	r3,-84(fp)
8114032c:	18bfc216 	blt	r3,r2,81140238 <__reset+0xfb120238>
81140330:	00000106 	br	81140338 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81140334:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81140338:	00a045b4 	movhi	r2,33046
8114033c:	109b3304 	addi	r2,r2,27852
81140340:	10800383 	ldbu	r2,14(r2)
81140344:	10803fcc 	andi	r2,r2,255
81140348:	e0ffeb17 	ldw	r3,-84(fp)
8114034c:	18801716 	blt	r3,r2,811403ac <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81140350:	e0bfe717 	ldw	r2,-100(fp)
81140354:	e0ffee04 	addi	r3,fp,-72
81140358:	180b883a 	mov	r5,r3
8114035c:	1009883a 	mov	r4,r2
81140360:	113d20c0 	call	8113d20c <get_cluster_flag>
81140364:	10000f26 	beq	r2,zero,811403a4 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81140368:	e0bfee0b 	ldhu	r2,-72(fp)
8114036c:	10bfffcc 	andi	r2,r2,65535
81140370:	10fffe0c 	andi	r3,r2,65528
81140374:	00bffe14 	movui	r2,65528
81140378:	1880051e 	bne	r3,r2,81140390 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
8114037c:	00bfffc4 	movi	r2,-1
81140380:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
81140384:	00a045b4 	movhi	r2,33046
81140388:	109b2e04 	addi	r2,r2,27832
8114038c:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
81140390:	e0bfee0b 	ldhu	r2,-72(fp)
81140394:	10bfffcc 	andi	r2,r2,65535
81140398:	10bffe0c 	andi	r2,r2,65528
8114039c:	e0bfe715 	stw	r2,-100(fp)
811403a0:	00000206 	br	811403ac <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811403a4:	00bfffc4 	movi	r2,-1
811403a8:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
811403ac:	e0bfe717 	ldw	r2,-100(fp)
811403b0:	00fffdd4 	movui	r3,65527
811403b4:	18bf8e0e 	bge	r3,r2,811401f0 <__reset+0xfb1201f0>
811403b8:	00000206 	br	811403c4 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
811403bc:	008000c4 	movi	r2,3
811403c0:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
811403c4:	e0bfe60b 	ldhu	r2,-104(fp)
}
811403c8:	e037883a 	mov	sp,fp
811403cc:	dfc00117 	ldw	ra,4(sp)
811403d0:	df000017 	ldw	fp,0(sp)
811403d4:	dec00204 	addi	sp,sp,8
811403d8:	f800283a 	ret

811403dc <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
811403dc:	deffe904 	addi	sp,sp,-92
811403e0:	de00012e 	bgeu	sp,et,811403e8 <alt_up_sd_card_fopen+0xc>
811403e4:	003b68fa 	trap	3
811403e8:	dfc01615 	stw	ra,88(sp)
811403ec:	df001515 	stw	fp,84(sp)
811403f0:	df001504 	addi	fp,sp,84
811403f4:	e13ffe15 	stw	r4,-8(fp)
811403f8:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
811403fc:	00bfffc4 	movi	r2,-1
81140400:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140404:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
81140408:	1000cf26 	beq	r2,zero,81140748 <alt_up_sd_card_fopen+0x36c>
8114040c:	d0a0a417 	ldw	r2,-32112(gp)
81140410:	1000cd26 	beq	r2,zero,81140748 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81140414:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81140418:	e13ffe17 	ldw	r4,-8(fp)
8114041c:	113e1f00 	call	8113e1f0 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81140420:	e13ffe17 	ldw	r4,-8(fp)
81140424:	113e2bc0 	call	8113e2bc <check_file_name_for_FAT16_compliance>
81140428:	1000c726 	beq	r2,zero,81140748 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8114042c:	e0ffee04 	addi	r3,fp,-72
81140430:	e0bfed04 	addi	r2,fp,-76
81140434:	180d883a 	mov	r6,r3
81140438:	100b883a 	mov	r5,r2
8114043c:	e13ffe17 	ldw	r4,-8(fp)
81140440:	113e8940 	call	8113e894 <get_home_directory_cluster_for_file>
81140444:	1000021e 	bne	r2,zero,81140450 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81140448:	e0bfeb0b 	ldhu	r2,-84(fp)
8114044c:	0000bf06 	br	8114074c <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81140450:	e03fec15 	stw	zero,-80(fp)
81140454:	00000e06 	br	81140490 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81140458:	00a045b4 	movhi	r2,33046
8114045c:	109b4804 	addi	r2,r2,27936
81140460:	e0ffec17 	ldw	r3,-80(fp)
81140464:	180691ba 	slli	r3,r3,6
81140468:	10c5883a 	add	r2,r2,r3
8114046c:	10800f04 	addi	r2,r2,60
81140470:	10800017 	ldw	r2,0(r2)
81140474:	1000031e 	bne	r2,zero,81140484 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81140478:	e0bfec17 	ldw	r2,-80(fp)
8114047c:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81140480:	00000606 	br	8114049c <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81140484:	e0bfec17 	ldw	r2,-80(fp)
81140488:	10800044 	addi	r2,r2,1
8114048c:	e0bfec15 	stw	r2,-80(fp)
81140490:	e0bfec17 	ldw	r2,-80(fp)
81140494:	10800510 	cmplti	r2,r2,20
81140498:	103fef1e 	bne	r2,zero,81140458 <__reset+0xfb120458>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8114049c:	e0bfeb0f 	ldh	r2,-84(fp)
811404a0:	1000a916 	blt	r2,zero,81140748 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811404a4:	e0bfed17 	ldw	r2,-76(fp)
811404a8:	1009883a 	mov	r4,r2
811404ac:	e0bfeb0f 	ldh	r2,-84(fp)
811404b0:	100691ba 	slli	r3,r2,6
811404b4:	00a045b4 	movhi	r2,33046
811404b8:	109b4804 	addi	r2,r2,27936
811404bc:	1885883a 	add	r2,r3,r2
811404c0:	100d883a 	mov	r6,r2
811404c4:	e17ffe17 	ldw	r5,-8(fp)
811404c8:	113edd40 	call	8113edd4 <find_file_in_directory>
811404cc:	10007b26 	beq	r2,zero,811406bc <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
811404d0:	e0bfff17 	ldw	r2,-4(fp)
811404d4:	10000226 	beq	r2,zero,811404e0 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
811404d8:	00bfffc4 	movi	r2,-1
811404dc:	00009b06 	br	8114074c <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
811404e0:	e13feb0f 	ldh	r4,-84(fp)
811404e4:	e0ffeb0f 	ldh	r3,-84(fp)
811404e8:	00a045b4 	movhi	r2,33046
811404ec:	109b4804 	addi	r2,r2,27936
811404f0:	180691ba 	slli	r3,r3,6
811404f4:	10c5883a 	add	r2,r2,r3
811404f8:	10800584 	addi	r2,r2,22
811404fc:	1080000b 	ldhu	r2,0(r2)
81140500:	10ffffcc 	andi	r3,r2,65535
81140504:	00a045b4 	movhi	r2,33046
81140508:	109b4804 	addi	r2,r2,27936
8114050c:	200891ba 	slli	r4,r4,6
81140510:	1105883a 	add	r2,r2,r4
81140514:	10800704 	addi	r2,r2,28
81140518:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8114051c:	e0ffeb0f 	ldh	r3,-84(fp)
81140520:	00a045b4 	movhi	r2,33046
81140524:	109b4804 	addi	r2,r2,27936
81140528:	180691ba 	slli	r3,r3,6
8114052c:	10c5883a 	add	r2,r2,r3
81140530:	10800804 	addi	r2,r2,32
81140534:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81140538:	e0ffeb0f 	ldh	r3,-84(fp)
8114053c:	00a045b4 	movhi	r2,33046
81140540:	109b4804 	addi	r2,r2,27936
81140544:	180691ba 	slli	r3,r3,6
81140548:	10c5883a 	add	r2,r2,r3
8114054c:	10800904 	addi	r2,r2,36
81140550:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
81140554:	e0ffeb0f 	ldh	r3,-84(fp)
81140558:	00a045b4 	movhi	r2,33046
8114055c:	109b4804 	addi	r2,r2,27936
81140560:	180691ba 	slli	r3,r3,6
81140564:	10c5883a 	add	r2,r2,r3
81140568:	10800f04 	addi	r2,r2,60
8114056c:	00c00044 	movi	r3,1
81140570:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
81140574:	e0ffeb0f 	ldh	r3,-84(fp)
81140578:	00a045b4 	movhi	r2,33046
8114057c:	109b4804 	addi	r2,r2,27936
81140580:	180691ba 	slli	r3,r3,6
81140584:	10c5883a 	add	r2,r2,r3
81140588:	10800e04 	addi	r2,r2,56
8114058c:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
81140590:	e03fec15 	stw	zero,-80(fp)
81140594:	00004506 	br	811406ac <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
81140598:	e0ffeb0f 	ldh	r3,-84(fp)
8114059c:	e0bfec17 	ldw	r2,-80(fp)
811405a0:	18803f26 	beq	r3,r2,811406a0 <alt_up_sd_card_fopen+0x2c4>
811405a4:	00a045b4 	movhi	r2,33046
811405a8:	109b4804 	addi	r2,r2,27936
811405ac:	e0ffec17 	ldw	r3,-80(fp)
811405b0:	180691ba 	slli	r3,r3,6
811405b4:	10c5883a 	add	r2,r2,r3
811405b8:	10800f04 	addi	r2,r2,60
811405bc:	10800017 	ldw	r2,0(r2)
811405c0:	10800058 	cmpnei	r2,r2,1
811405c4:	1000361e 	bne	r2,zero,811406a0 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811405c8:	e0ffeb0f 	ldh	r3,-84(fp)
811405cc:	00a045b4 	movhi	r2,33046
811405d0:	109b4804 	addi	r2,r2,27936
811405d4:	180691ba 	slli	r3,r3,6
811405d8:	10c5883a 	add	r2,r2,r3
811405dc:	10800a04 	addi	r2,r2,40
811405e0:	10c00017 	ldw	r3,0(r2)
811405e4:	00a045b4 	movhi	r2,33046
811405e8:	109b4804 	addi	r2,r2,27936
811405ec:	e13fec17 	ldw	r4,-80(fp)
811405f0:	200891ba 	slli	r4,r4,6
811405f4:	1105883a 	add	r2,r2,r4
811405f8:	10800a04 	addi	r2,r2,40
811405fc:	10800017 	ldw	r2,0(r2)
81140600:	1880271e 	bne	r3,r2,811406a0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81140604:	e0ffeb0f 	ldh	r3,-84(fp)
81140608:	00a045b4 	movhi	r2,33046
8114060c:	109b4804 	addi	r2,r2,27936
81140610:	180691ba 	slli	r3,r3,6
81140614:	10c5883a 	add	r2,r2,r3
81140618:	10800b04 	addi	r2,r2,44
8114061c:	10c00017 	ldw	r3,0(r2)
81140620:	00a045b4 	movhi	r2,33046
81140624:	109b4804 	addi	r2,r2,27936
81140628:	e13fec17 	ldw	r4,-80(fp)
8114062c:	200891ba 	slli	r4,r4,6
81140630:	1105883a 	add	r2,r2,r4
81140634:	10800b04 	addi	r2,r2,44
81140638:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8114063c:	1880181e 	bne	r3,r2,811406a0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81140640:	e0ffeb0f 	ldh	r3,-84(fp)
81140644:	00a045b4 	movhi	r2,33046
81140648:	109b4804 	addi	r2,r2,27936
8114064c:	180691ba 	slli	r3,r3,6
81140650:	10c5883a 	add	r2,r2,r3
81140654:	10800c04 	addi	r2,r2,48
81140658:	1100000b 	ldhu	r4,0(r2)
8114065c:	00a045b4 	movhi	r2,33046
81140660:	109b4804 	addi	r2,r2,27936
81140664:	e0ffec17 	ldw	r3,-80(fp)
81140668:	180691ba 	slli	r3,r3,6
8114066c:	10c5883a 	add	r2,r2,r3
81140670:	10800c04 	addi	r2,r2,48
81140674:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81140678:	20ffffcc 	andi	r3,r4,65535
8114067c:	18e0001c 	xori	r3,r3,32768
81140680:	18e00004 	addi	r3,r3,-32768
81140684:	10bfffcc 	andi	r2,r2,65535
81140688:	10a0001c 	xori	r2,r2,32768
8114068c:	10a00004 	addi	r2,r2,-32768
81140690:	1880031e 	bne	r3,r2,811406a0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
81140694:	00bfff84 	movi	r2,-2
81140698:	e0bfeb0d 	sth	r2,-84(fp)
								break;
8114069c:	00002a06 	br	81140748 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811406a0:	e0bfec17 	ldw	r2,-80(fp)
811406a4:	10800044 	addi	r2,r2,1
811406a8:	e0bfec15 	stw	r2,-80(fp)
811406ac:	e0bfec17 	ldw	r2,-80(fp)
811406b0:	10800510 	cmplti	r2,r2,20
811406b4:	103fb81e 	bne	r2,zero,81140598 <__reset+0xfb120598>
811406b8:	00002306 	br	81140748 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
811406bc:	e0bfff17 	ldw	r2,-4(fp)
811406c0:	10001f26 	beq	r2,zero,81140740 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
811406c4:	e0bfeb0f 	ldh	r2,-84(fp)
811406c8:	100691ba 	slli	r3,r2,6
811406cc:	00a045b4 	movhi	r2,33046
811406d0:	109b4804 	addi	r2,r2,27936
811406d4:	1885883a 	add	r2,r3,r2
811406d8:	e0ffee04 	addi	r3,fp,-72
811406dc:	180d883a 	mov	r6,r3
811406e0:	100b883a 	mov	r5,r2
811406e4:	e13ffe17 	ldw	r4,-8(fp)
811406e8:	113f9200 	call	8113f920 <create_file>
811406ec:	10001126 	beq	r2,zero,81140734 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
811406f0:	e0ffeb0f 	ldh	r3,-84(fp)
811406f4:	00a045b4 	movhi	r2,33046
811406f8:	109b4804 	addi	r2,r2,27936
811406fc:	180691ba 	slli	r3,r3,6
81140700:	10c5883a 	add	r2,r2,r3
81140704:	10800f04 	addi	r2,r2,60
81140708:	00c00044 	movi	r3,1
8114070c:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81140710:	e0ffeb0f 	ldh	r3,-84(fp)
81140714:	00a045b4 	movhi	r2,33046
81140718:	109b4804 	addi	r2,r2,27936
8114071c:	180691ba 	slli	r3,r3,6
81140720:	10c5883a 	add	r2,r2,r3
81140724:	10800e04 	addi	r2,r2,56
81140728:	00c00044 	movi	r3,1
8114072c:	10c00015 	stw	r3,0(r2)
81140730:	00000506 	br	81140748 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81140734:	00bfffc4 	movi	r2,-1
81140738:	e0bfeb0d 	sth	r2,-84(fp)
8114073c:	00000206 	br	81140748 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81140740:	00bfffc4 	movi	r2,-1
81140744:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81140748:	e0bfeb0b 	ldhu	r2,-84(fp)
}
8114074c:	e037883a 	mov	sp,fp
81140750:	dfc00117 	ldw	ra,4(sp)
81140754:	df000017 	ldw	fp,0(sp)
81140758:	dec00204 	addi	sp,sp,8
8114075c:	f800283a 	ret

81140760 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81140760:	defffd04 	addi	sp,sp,-12
81140764:	de00012e 	bgeu	sp,et,8114076c <alt_up_sd_card_set_attributes+0xc>
81140768:	003b68fa 	trap	3
8114076c:	df000215 	stw	fp,8(sp)
81140770:	df000204 	addi	fp,sp,8
81140774:	2007883a 	mov	r3,r4
81140778:	2805883a 	mov	r2,r5
8114077c:	e0fffe0d 	sth	r3,-8(fp)
81140780:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140784:	e0bffe0f 	ldh	r2,-8(fp)
81140788:	10001416 	blt	r2,zero,811407dc <alt_up_sd_card_set_attributes+0x7c>
8114078c:	e0bffe0f 	ldh	r2,-8(fp)
81140790:	10800508 	cmpgei	r2,r2,20
81140794:	1000111e 	bne	r2,zero,811407dc <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81140798:	e0fffe0f 	ldh	r3,-8(fp)
8114079c:	00a045b4 	movhi	r2,33046
811407a0:	109b4804 	addi	r2,r2,27936
811407a4:	180691ba 	slli	r3,r3,6
811407a8:	10c5883a 	add	r2,r2,r3
811407ac:	10800f04 	addi	r2,r2,60
811407b0:	10800017 	ldw	r2,0(r2)
811407b4:	10000926 	beq	r2,zero,811407dc <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
811407b8:	e0fffe0f 	ldh	r3,-8(fp)
811407bc:	e0bfff0b 	ldhu	r2,-4(fp)
811407c0:	1009883a 	mov	r4,r2
811407c4:	00a045b4 	movhi	r2,33046
811407c8:	109b4804 	addi	r2,r2,27936
811407cc:	180691ba 	slli	r3,r3,6
811407d0:	10c5883a 	add	r2,r2,r3
811407d4:	108002c4 	addi	r2,r2,11
811407d8:	11000005 	stb	r4,0(r2)
        }
    }
}
811407dc:	0001883a 	nop
811407e0:	e037883a 	mov	sp,fp
811407e4:	df000017 	ldw	fp,0(sp)
811407e8:	dec00104 	addi	sp,sp,4
811407ec:	f800283a 	ret

811407f0 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811407f0:	defffd04 	addi	sp,sp,-12
811407f4:	de00012e 	bgeu	sp,et,811407fc <alt_up_sd_card_get_attributes+0xc>
811407f8:	003b68fa 	trap	3
811407fc:	df000215 	stw	fp,8(sp)
81140800:	df000204 	addi	fp,sp,8
81140804:	2005883a 	mov	r2,r4
81140808:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
8114080c:	00bfffc4 	movi	r2,-1
81140810:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140814:	e0bfff0f 	ldh	r2,-4(fp)
81140818:	10001416 	blt	r2,zero,8114086c <alt_up_sd_card_get_attributes+0x7c>
8114081c:	e0bfff0f 	ldh	r2,-4(fp)
81140820:	10800508 	cmpgei	r2,r2,20
81140824:	1000111e 	bne	r2,zero,8114086c <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81140828:	e0ffff0f 	ldh	r3,-4(fp)
8114082c:	00a045b4 	movhi	r2,33046
81140830:	109b4804 	addi	r2,r2,27936
81140834:	180691ba 	slli	r3,r3,6
81140838:	10c5883a 	add	r2,r2,r3
8114083c:	10800f04 	addi	r2,r2,60
81140840:	10800017 	ldw	r2,0(r2)
81140844:	10000926 	beq	r2,zero,8114086c <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81140848:	e0ffff0f 	ldh	r3,-4(fp)
8114084c:	00a045b4 	movhi	r2,33046
81140850:	109b4804 	addi	r2,r2,27936
81140854:	180691ba 	slli	r3,r3,6
81140858:	10c5883a 	add	r2,r2,r3
8114085c:	108002c4 	addi	r2,r2,11
81140860:	10800003 	ldbu	r2,0(r2)
81140864:	10803fcc 	andi	r2,r2,255
81140868:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
8114086c:	e0bffe0b 	ldhu	r2,-8(fp)
}
81140870:	e037883a 	mov	sp,fp
81140874:	df000017 	ldw	fp,0(sp)
81140878:	dec00104 	addi	sp,sp,4
8114087c:	f800283a 	ret

81140880 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81140880:	defffa04 	addi	sp,sp,-24
81140884:	de00012e 	bgeu	sp,et,8114088c <alt_up_sd_card_read+0xc>
81140888:	003b68fa 	trap	3
8114088c:	dfc00515 	stw	ra,20(sp)
81140890:	df000415 	stw	fp,16(sp)
81140894:	df000404 	addi	fp,sp,16
81140898:	2005883a 	mov	r2,r4
8114089c:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811408a0:	00bfffc4 	movi	r2,-1
811408a4:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811408a8:	e0bfff0f 	ldh	r2,-4(fp)
811408ac:	1000ce16 	blt	r2,zero,81140be8 <alt_up_sd_card_read+0x368>
811408b0:	e0bfff0f 	ldh	r2,-4(fp)
811408b4:	10800508 	cmpgei	r2,r2,20
811408b8:	1000cb1e 	bne	r2,zero,81140be8 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
811408bc:	e0ffff0f 	ldh	r3,-4(fp)
811408c0:	00a045b4 	movhi	r2,33046
811408c4:	109b4804 	addi	r2,r2,27936
811408c8:	180691ba 	slli	r3,r3,6
811408cc:	10c5883a 	add	r2,r2,r3
811408d0:	10800f04 	addi	r2,r2,60
811408d4:	10800017 	ldw	r2,0(r2)
811408d8:	1000c326 	beq	r2,zero,81140be8 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
811408dc:	e0ffff0f 	ldh	r3,-4(fp)
811408e0:	00a045b4 	movhi	r2,33046
811408e4:	109b4804 	addi	r2,r2,27936
811408e8:	180691ba 	slli	r3,r3,6
811408ec:	10c5883a 	add	r2,r2,r3
811408f0:	10800904 	addi	r2,r2,36
811408f4:	10c00017 	ldw	r3,0(r2)
811408f8:	e13fff0f 	ldh	r4,-4(fp)
811408fc:	00a045b4 	movhi	r2,33046
81140900:	109b4804 	addi	r2,r2,27936
81140904:	200891ba 	slli	r4,r4,6
81140908:	1105883a 	add	r2,r2,r4
8114090c:	10800604 	addi	r2,r2,24
81140910:	10800017 	ldw	r2,0(r2)
81140914:	1880b42e 	bgeu	r3,r2,81140be8 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140918:	00a045b4 	movhi	r2,33046
8114091c:	109b3304 	addi	r2,r2,27852
81140920:	10c01417 	ldw	r3,80(r2)
81140924:	e13fff0f 	ldh	r4,-4(fp)
81140928:	00a045b4 	movhi	r2,33046
8114092c:	109b4804 	addi	r2,r2,27936
81140930:	200891ba 	slli	r4,r4,6
81140934:	1105883a 	add	r2,r2,r4
81140938:	10800704 	addi	r2,r2,28
8114093c:	10800017 	ldw	r2,0(r2)
81140940:	113fff84 	addi	r4,r2,-2
81140944:	00a045b4 	movhi	r2,33046
81140948:	109b3304 	addi	r2,r2,27852
8114094c:	10800383 	ldbu	r2,14(r2)
81140950:	10803fcc 	andi	r2,r2,255
81140954:	2085383a 	mul	r2,r4,r2
81140958:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
8114095c:	e13fff0f 	ldh	r4,-4(fp)
81140960:	00a045b4 	movhi	r2,33046
81140964:	109b4804 	addi	r2,r2,27936
81140968:	200891ba 	slli	r4,r4,6
8114096c:	1105883a 	add	r2,r2,r4
81140970:	10800804 	addi	r2,r2,32
81140974:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140978:	1885883a 	add	r2,r3,r2
8114097c:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81140980:	e0ffff0f 	ldh	r3,-4(fp)
81140984:	00a045b4 	movhi	r2,33046
81140988:	109b4804 	addi	r2,r2,27936
8114098c:	180691ba 	slli	r3,r3,6
81140990:	10c5883a 	add	r2,r2,r3
81140994:	10800904 	addi	r2,r2,36
81140998:	10800017 	ldw	r2,0(r2)
8114099c:	10006826 	beq	r2,zero,81140b40 <alt_up_sd_card_read+0x2c0>
811409a0:	e0ffff0f 	ldh	r3,-4(fp)
811409a4:	00a045b4 	movhi	r2,33046
811409a8:	109b4804 	addi	r2,r2,27936
811409ac:	180691ba 	slli	r3,r3,6
811409b0:	10c5883a 	add	r2,r2,r3
811409b4:	10800904 	addi	r2,r2,36
811409b8:	10800017 	ldw	r2,0(r2)
811409bc:	10807fcc 	andi	r2,r2,511
811409c0:	10005f1e 	bne	r2,zero,81140b40 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
811409c4:	e0ffff0f 	ldh	r3,-4(fp)
811409c8:	00a045b4 	movhi	r2,33046
811409cc:	109b4804 	addi	r2,r2,27936
811409d0:	180691ba 	slli	r3,r3,6
811409d4:	10c5883a 	add	r2,r2,r3
811409d8:	10800804 	addi	r2,r2,32
811409dc:	10c00017 	ldw	r3,0(r2)
811409e0:	00a045b4 	movhi	r2,33046
811409e4:	109b3304 	addi	r2,r2,27852
811409e8:	10800383 	ldbu	r2,14(r2)
811409ec:	10803fcc 	andi	r2,r2,255
811409f0:	10bfffc4 	addi	r2,r2,-1
811409f4:	1880401e 	bne	r3,r2,81140af8 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811409f8:	e0ffff0f 	ldh	r3,-4(fp)
811409fc:	00a045b4 	movhi	r2,33046
81140a00:	109b4804 	addi	r2,r2,27936
81140a04:	180691ba 	slli	r3,r3,6
81140a08:	10c5883a 	add	r2,r2,r3
81140a0c:	10800704 	addi	r2,r2,28
81140a10:	10800017 	ldw	r2,0(r2)
81140a14:	e0fffe04 	addi	r3,fp,-8
81140a18:	180b883a 	mov	r5,r3
81140a1c:	1009883a 	mov	r4,r2
81140a20:	113d20c0 	call	8113d20c <get_cluster_flag>
81140a24:	10003226 	beq	r2,zero,81140af0 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81140a28:	e0bffe0b 	ldhu	r2,-8(fp)
81140a2c:	10bfffcc 	andi	r2,r2,65535
81140a30:	10fffe0c 	andi	r3,r2,65528
81140a34:	00bffe14 	movui	r2,65528
81140a38:	1880021e 	bne	r3,r2,81140a44 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81140a3c:	00bfffc4 	movi	r2,-1
81140a40:	00006a06 	br	81140bec <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81140a44:	e13fff0f 	ldh	r4,-4(fp)
81140a48:	e0bffe0b 	ldhu	r2,-8(fp)
81140a4c:	10ffffcc 	andi	r3,r2,65535
81140a50:	00a045b4 	movhi	r2,33046
81140a54:	109b4804 	addi	r2,r2,27936
81140a58:	200891ba 	slli	r4,r4,6
81140a5c:	1105883a 	add	r2,r2,r4
81140a60:	10800704 	addi	r2,r2,28
81140a64:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81140a68:	e0ffff0f 	ldh	r3,-4(fp)
81140a6c:	00a045b4 	movhi	r2,33046
81140a70:	109b4804 	addi	r2,r2,27936
81140a74:	180691ba 	slli	r3,r3,6
81140a78:	10c5883a 	add	r2,r2,r3
81140a7c:	10800804 	addi	r2,r2,32
81140a80:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140a84:	00a045b4 	movhi	r2,33046
81140a88:	109b3304 	addi	r2,r2,27852
81140a8c:	10c01417 	ldw	r3,80(r2)
81140a90:	e13fff0f 	ldh	r4,-4(fp)
81140a94:	00a045b4 	movhi	r2,33046
81140a98:	109b4804 	addi	r2,r2,27936
81140a9c:	200891ba 	slli	r4,r4,6
81140aa0:	1105883a 	add	r2,r2,r4
81140aa4:	10800704 	addi	r2,r2,28
81140aa8:	10800017 	ldw	r2,0(r2)
81140aac:	113fff84 	addi	r4,r2,-2
81140ab0:	00a045b4 	movhi	r2,33046
81140ab4:	109b3304 	addi	r2,r2,27852
81140ab8:	10800383 	ldbu	r2,14(r2)
81140abc:	10803fcc 	andi	r2,r2,255
81140ac0:	2085383a 	mul	r2,r4,r2
81140ac4:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81140ac8:	e13fff0f 	ldh	r4,-4(fp)
81140acc:	00a045b4 	movhi	r2,33046
81140ad0:	109b4804 	addi	r2,r2,27936
81140ad4:	200891ba 	slli	r4,r4,6
81140ad8:	1105883a 	add	r2,r2,r4
81140adc:	10800804 	addi	r2,r2,32
81140ae0:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140ae4:	1885883a 	add	r2,r3,r2
81140ae8:	e0bffd15 	stw	r2,-12(fp)
81140aec:	00001406 	br	81140b40 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81140af0:	00bfff84 	movi	r2,-2
81140af4:	00003d06 	br	81140bec <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81140af8:	e13fff0f 	ldh	r4,-4(fp)
81140afc:	e0ffff0f 	ldh	r3,-4(fp)
81140b00:	00a045b4 	movhi	r2,33046
81140b04:	109b4804 	addi	r2,r2,27936
81140b08:	180691ba 	slli	r3,r3,6
81140b0c:	10c5883a 	add	r2,r2,r3
81140b10:	10800804 	addi	r2,r2,32
81140b14:	10800017 	ldw	r2,0(r2)
81140b18:	10c00044 	addi	r3,r2,1
81140b1c:	00a045b4 	movhi	r2,33046
81140b20:	109b4804 	addi	r2,r2,27936
81140b24:	200891ba 	slli	r4,r4,6
81140b28:	1105883a 	add	r2,r2,r4
81140b2c:	10800804 	addi	r2,r2,32
81140b30:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81140b34:	e0bffd17 	ldw	r2,-12(fp)
81140b38:	10800044 	addi	r2,r2,1
81140b3c:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81140b40:	d0e0ab17 	ldw	r3,-32084(gp)
81140b44:	e0bffd17 	ldw	r2,-12(fp)
81140b48:	1885883a 	add	r2,r3,r2
81140b4c:	1007883a 	mov	r3,r2
81140b50:	d0a0af17 	ldw	r2,-32068(gp)
81140b54:	18800726 	beq	r3,r2,81140b74 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81140b58:	d0a0ab17 	ldw	r2,-32084(gp)
81140b5c:	100b883a 	mov	r5,r2
81140b60:	e13ffd17 	ldw	r4,-12(fp)
81140b64:	113d12c0 	call	8113d12c <Read_Sector_Data>
81140b68:	1000021e 	bne	r2,zero,81140b74 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81140b6c:	00bfff84 	movi	r2,-2
81140b70:	00001e06 	br	81140bec <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81140b74:	d0e0aa17 	ldw	r3,-32088(gp)
81140b78:	e13fff0f 	ldh	r4,-4(fp)
81140b7c:	00a045b4 	movhi	r2,33046
81140b80:	109b4804 	addi	r2,r2,27936
81140b84:	200891ba 	slli	r4,r4,6
81140b88:	1105883a 	add	r2,r2,r4
81140b8c:	10800904 	addi	r2,r2,36
81140b90:	10800017 	ldw	r2,0(r2)
81140b94:	10807fcc 	andi	r2,r2,511
81140b98:	1885883a 	add	r2,r3,r2
81140b9c:	10800023 	ldbuio	r2,0(r2)
81140ba0:	10803fcc 	andi	r2,r2,255
81140ba4:	10803fcc 	andi	r2,r2,255
81140ba8:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81140bac:	e13fff0f 	ldh	r4,-4(fp)
81140bb0:	e0ffff0f 	ldh	r3,-4(fp)
81140bb4:	00a045b4 	movhi	r2,33046
81140bb8:	109b4804 	addi	r2,r2,27936
81140bbc:	180691ba 	slli	r3,r3,6
81140bc0:	10c5883a 	add	r2,r2,r3
81140bc4:	10800904 	addi	r2,r2,36
81140bc8:	10800017 	ldw	r2,0(r2)
81140bcc:	10c00044 	addi	r3,r2,1
81140bd0:	00a045b4 	movhi	r2,33046
81140bd4:	109b4804 	addi	r2,r2,27936
81140bd8:	200891ba 	slli	r4,r4,6
81140bdc:	1105883a 	add	r2,r2,r4
81140be0:	10800904 	addi	r2,r2,36
81140be4:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81140be8:	e0bffc0b 	ldhu	r2,-16(fp)
}
81140bec:	e037883a 	mov	sp,fp
81140bf0:	dfc00117 	ldw	ra,4(sp)
81140bf4:	df000017 	ldw	fp,0(sp)
81140bf8:	dec00204 	addi	sp,sp,8
81140bfc:	f800283a 	ret

81140c00 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81140c00:	defff804 	addi	sp,sp,-32
81140c04:	de00012e 	bgeu	sp,et,81140c0c <alt_up_sd_card_write+0xc>
81140c08:	003b68fa 	trap	3
81140c0c:	dfc00715 	stw	ra,28(sp)
81140c10:	df000615 	stw	fp,24(sp)
81140c14:	df000604 	addi	fp,sp,24
81140c18:	2007883a 	mov	r3,r4
81140c1c:	2805883a 	mov	r2,r5
81140c20:	e0fffe0d 	sth	r3,-8(fp)
81140c24:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81140c28:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81140c2c:	e0bffe0f 	ldh	r2,-8(fp)
81140c30:	10017716 	blt	r2,zero,81141210 <alt_up_sd_card_write+0x610>
81140c34:	e0bffe0f 	ldh	r2,-8(fp)
81140c38:	10800508 	cmpgei	r2,r2,20
81140c3c:	1001741e 	bne	r2,zero,81141210 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81140c40:	e0fffe0f 	ldh	r3,-8(fp)
81140c44:	00a045b4 	movhi	r2,33046
81140c48:	109b4804 	addi	r2,r2,27936
81140c4c:	180691ba 	slli	r3,r3,6
81140c50:	10c5883a 	add	r2,r2,r3
81140c54:	10800f04 	addi	r2,r2,60
81140c58:	10800017 	ldw	r2,0(r2)
81140c5c:	10016c26 	beq	r2,zero,81141210 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140c60:	00a045b4 	movhi	r2,33046
81140c64:	109b3304 	addi	r2,r2,27852
81140c68:	10c01417 	ldw	r3,80(r2)
81140c6c:	e13ffe0f 	ldh	r4,-8(fp)
81140c70:	00a045b4 	movhi	r2,33046
81140c74:	109b4804 	addi	r2,r2,27936
81140c78:	200891ba 	slli	r4,r4,6
81140c7c:	1105883a 	add	r2,r2,r4
81140c80:	10800704 	addi	r2,r2,28
81140c84:	10800017 	ldw	r2,0(r2)
81140c88:	113fff84 	addi	r4,r2,-2
81140c8c:	00a045b4 	movhi	r2,33046
81140c90:	109b3304 	addi	r2,r2,27852
81140c94:	10800383 	ldbu	r2,14(r2)
81140c98:	10803fcc 	andi	r2,r2,255
81140c9c:	2085383a 	mul	r2,r4,r2
81140ca0:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81140ca4:	e13ffe0f 	ldh	r4,-8(fp)
81140ca8:	00a045b4 	movhi	r2,33046
81140cac:	109b4804 	addi	r2,r2,27936
81140cb0:	200891ba 	slli	r4,r4,6
81140cb4:	1105883a 	add	r2,r2,r4
81140cb8:	10800804 	addi	r2,r2,32
81140cbc:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140cc0:	1885883a 	add	r2,r3,r2
81140cc4:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81140cc8:	e0fffe0f 	ldh	r3,-8(fp)
81140ccc:	00a045b4 	movhi	r2,33046
81140cd0:	109b4804 	addi	r2,r2,27936
81140cd4:	180691ba 	slli	r3,r3,6
81140cd8:	10c5883a 	add	r2,r2,r3
81140cdc:	10800904 	addi	r2,r2,36
81140ce0:	10c00017 	ldw	r3,0(r2)
81140ce4:	00a045b4 	movhi	r2,33046
81140ce8:	109b3304 	addi	r2,r2,27852
81140cec:	1080030b 	ldhu	r2,12(r2)
81140cf0:	10bfffcc 	andi	r2,r2,65535
81140cf4:	1889203a 	divu	r4,r3,r2
81140cf8:	2085383a 	mul	r2,r4,r2
81140cfc:	1885c83a 	sub	r2,r3,r2
81140d00:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81140d04:	e0fffe0f 	ldh	r3,-8(fp)
81140d08:	00a045b4 	movhi	r2,33046
81140d0c:	109b4804 	addi	r2,r2,27936
81140d10:	180691ba 	slli	r3,r3,6
81140d14:	10c5883a 	add	r2,r2,r3
81140d18:	10800904 	addi	r2,r2,36
81140d1c:	10c00017 	ldw	r3,0(r2)
81140d20:	e13ffe0f 	ldh	r4,-8(fp)
81140d24:	00a045b4 	movhi	r2,33046
81140d28:	109b4804 	addi	r2,r2,27936
81140d2c:	200891ba 	slli	r4,r4,6
81140d30:	1105883a 	add	r2,r2,r4
81140d34:	10800604 	addi	r2,r2,24
81140d38:	10800017 	ldw	r2,0(r2)
81140d3c:	1880672e 	bgeu	r3,r2,81140edc <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81140d40:	e0fffe0f 	ldh	r3,-8(fp)
81140d44:	00a045b4 	movhi	r2,33046
81140d48:	109b4804 	addi	r2,r2,27936
81140d4c:	180691ba 	slli	r3,r3,6
81140d50:	10c5883a 	add	r2,r2,r3
81140d54:	10800904 	addi	r2,r2,36
81140d58:	10800017 	ldw	r2,0(r2)
81140d5c:	1000e126 	beq	r2,zero,811410e4 <alt_up_sd_card_write+0x4e4>
81140d60:	e0bffc0f 	ldh	r2,-16(fp)
81140d64:	1000df1e 	bne	r2,zero,811410e4 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81140d68:	e0fffe0f 	ldh	r3,-8(fp)
81140d6c:	00a045b4 	movhi	r2,33046
81140d70:	109b4804 	addi	r2,r2,27936
81140d74:	180691ba 	slli	r3,r3,6
81140d78:	10c5883a 	add	r2,r2,r3
81140d7c:	10800804 	addi	r2,r2,32
81140d80:	10c00017 	ldw	r3,0(r2)
81140d84:	00a045b4 	movhi	r2,33046
81140d88:	109b3304 	addi	r2,r2,27852
81140d8c:	10800383 	ldbu	r2,14(r2)
81140d90:	10803fcc 	andi	r2,r2,255
81140d94:	10bfffc4 	addi	r2,r2,-1
81140d98:	18803d1e 	bne	r3,r2,81140e90 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81140d9c:	e0fffe0f 	ldh	r3,-8(fp)
81140da0:	00a045b4 	movhi	r2,33046
81140da4:	109b4804 	addi	r2,r2,27936
81140da8:	180691ba 	slli	r3,r3,6
81140dac:	10c5883a 	add	r2,r2,r3
81140db0:	10800704 	addi	r2,r2,28
81140db4:	10800017 	ldw	r2,0(r2)
81140db8:	e0fffc84 	addi	r3,fp,-14
81140dbc:	180b883a 	mov	r5,r3
81140dc0:	1009883a 	mov	r4,r2
81140dc4:	113d20c0 	call	8113d20c <get_cluster_flag>
81140dc8:	10002f26 	beq	r2,zero,81140e88 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81140dcc:	e0bffc8b 	ldhu	r2,-14(fp)
81140dd0:	10bfffcc 	andi	r2,r2,65535
81140dd4:	10bffe28 	cmpgeui	r2,r2,65528
81140dd8:	1000c21e 	bne	r2,zero,811410e4 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81140ddc:	e13ffe0f 	ldh	r4,-8(fp)
81140de0:	e0bffc8b 	ldhu	r2,-14(fp)
81140de4:	10ffffcc 	andi	r3,r2,65535
81140de8:	00a045b4 	movhi	r2,33046
81140dec:	109b4804 	addi	r2,r2,27936
81140df0:	200891ba 	slli	r4,r4,6
81140df4:	1105883a 	add	r2,r2,r4
81140df8:	10800704 	addi	r2,r2,28
81140dfc:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81140e00:	e0fffe0f 	ldh	r3,-8(fp)
81140e04:	00a045b4 	movhi	r2,33046
81140e08:	109b4804 	addi	r2,r2,27936
81140e0c:	180691ba 	slli	r3,r3,6
81140e10:	10c5883a 	add	r2,r2,r3
81140e14:	10800804 	addi	r2,r2,32
81140e18:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140e1c:	00a045b4 	movhi	r2,33046
81140e20:	109b3304 	addi	r2,r2,27852
81140e24:	10c01417 	ldw	r3,80(r2)
81140e28:	e13ffe0f 	ldh	r4,-8(fp)
81140e2c:	00a045b4 	movhi	r2,33046
81140e30:	109b4804 	addi	r2,r2,27936
81140e34:	200891ba 	slli	r4,r4,6
81140e38:	1105883a 	add	r2,r2,r4
81140e3c:	10800704 	addi	r2,r2,28
81140e40:	10800017 	ldw	r2,0(r2)
81140e44:	113fff84 	addi	r4,r2,-2
81140e48:	00a045b4 	movhi	r2,33046
81140e4c:	109b3304 	addi	r2,r2,27852
81140e50:	10800383 	ldbu	r2,14(r2)
81140e54:	10803fcc 	andi	r2,r2,255
81140e58:	2085383a 	mul	r2,r4,r2
81140e5c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81140e60:	e13ffe0f 	ldh	r4,-8(fp)
81140e64:	00a045b4 	movhi	r2,33046
81140e68:	109b4804 	addi	r2,r2,27936
81140e6c:	200891ba 	slli	r4,r4,6
81140e70:	1105883a 	add	r2,r2,r4
81140e74:	10800804 	addi	r2,r2,32
81140e78:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81140e7c:	1885883a 	add	r2,r3,r2
81140e80:	e0bffb15 	stw	r2,-20(fp)
81140e84:	00009706 	br	811410e4 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81140e88:	0005883a 	mov	r2,zero
81140e8c:	0000e106 	br	81141214 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81140e90:	e13ffe0f 	ldh	r4,-8(fp)
81140e94:	e0fffe0f 	ldh	r3,-8(fp)
81140e98:	00a045b4 	movhi	r2,33046
81140e9c:	109b4804 	addi	r2,r2,27936
81140ea0:	180691ba 	slli	r3,r3,6
81140ea4:	10c5883a 	add	r2,r2,r3
81140ea8:	10800804 	addi	r2,r2,32
81140eac:	10800017 	ldw	r2,0(r2)
81140eb0:	10c00044 	addi	r3,r2,1
81140eb4:	00a045b4 	movhi	r2,33046
81140eb8:	109b4804 	addi	r2,r2,27936
81140ebc:	200891ba 	slli	r4,r4,6
81140ec0:	1105883a 	add	r2,r2,r4
81140ec4:	10800804 	addi	r2,r2,32
81140ec8:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81140ecc:	e0bffb17 	ldw	r2,-20(fp)
81140ed0:	10800044 	addi	r2,r2,1
81140ed4:	e0bffb15 	stw	r2,-20(fp)
81140ed8:	00008206 	br	811410e4 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81140edc:	e0fffe0f 	ldh	r3,-8(fp)
81140ee0:	00a045b4 	movhi	r2,33046
81140ee4:	109b4804 	addi	r2,r2,27936
81140ee8:	180691ba 	slli	r3,r3,6
81140eec:	10c5883a 	add	r2,r2,r3
81140ef0:	10800904 	addi	r2,r2,36
81140ef4:	10800017 	ldw	r2,0(r2)
81140ef8:	10007a26 	beq	r2,zero,811410e4 <alt_up_sd_card_write+0x4e4>
81140efc:	e0bffc0f 	ldh	r2,-16(fp)
81140f00:	1000781e 	bne	r2,zero,811410e4 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81140f04:	e0fffe0f 	ldh	r3,-8(fp)
81140f08:	00a045b4 	movhi	r2,33046
81140f0c:	109b4804 	addi	r2,r2,27936
81140f10:	180691ba 	slli	r3,r3,6
81140f14:	10c5883a 	add	r2,r2,r3
81140f18:	10800804 	addi	r2,r2,32
81140f1c:	10c00017 	ldw	r3,0(r2)
81140f20:	00a045b4 	movhi	r2,33046
81140f24:	109b3304 	addi	r2,r2,27852
81140f28:	10800383 	ldbu	r2,14(r2)
81140f2c:	10803fcc 	andi	r2,r2,255
81140f30:	10bfffc4 	addi	r2,r2,-1
81140f34:	18803e1e 	bne	r3,r2,81141030 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81140f38:	e0bffd04 	addi	r2,fp,-12
81140f3c:	1009883a 	mov	r4,r2
81140f40:	113f2500 	call	8113f250 <find_first_empty_cluster>
81140f44:	10003826 	beq	r2,zero,81141028 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81140f48:	e0fffe0f 	ldh	r3,-8(fp)
81140f4c:	00a045b4 	movhi	r2,33046
81140f50:	109b4804 	addi	r2,r2,27936
81140f54:	180691ba 	slli	r3,r3,6
81140f58:	10c5883a 	add	r2,r2,r3
81140f5c:	10800704 	addi	r2,r2,28
81140f60:	10800017 	ldw	r2,0(r2)
81140f64:	e0fffd17 	ldw	r3,-12(fp)
81140f68:	18ffffcc 	andi	r3,r3,65535
81140f6c:	18e0001c 	xori	r3,r3,32768
81140f70:	18e00004 	addi	r3,r3,-32768
81140f74:	01800044 	movi	r6,1
81140f78:	180b883a 	mov	r5,r3
81140f7c:	1009883a 	mov	r4,r2
81140f80:	113d2c80 	call	8113d2c8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81140f84:	e0bffd17 	ldw	r2,-12(fp)
81140f88:	01800044 	movi	r6,1
81140f8c:	017fffc4 	movi	r5,-1
81140f90:	1009883a 	mov	r4,r2
81140f94:	113d2c80 	call	8113d2c8 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
81140f98:	e0fffe0f 	ldh	r3,-8(fp)
81140f9c:	00a045b4 	movhi	r2,33046
81140fa0:	109b4804 	addi	r2,r2,27936
81140fa4:	180691ba 	slli	r3,r3,6
81140fa8:	10c5883a 	add	r2,r2,r3
81140fac:	10800704 	addi	r2,r2,28
81140fb0:	10800017 	ldw	r2,0(r2)
81140fb4:	e0fffd17 	ldw	r3,-12(fp)
81140fb8:	18ffffcc 	andi	r3,r3,65535
81140fbc:	18e0001c 	xori	r3,r3,32768
81140fc0:	18e00004 	addi	r3,r3,-32768
81140fc4:	000d883a 	mov	r6,zero
81140fc8:	180b883a 	mov	r5,r3
81140fcc:	1009883a 	mov	r4,r2
81140fd0:	113d2c80 	call	8113d2c8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81140fd4:	e0bffd17 	ldw	r2,-12(fp)
81140fd8:	000d883a 	mov	r6,zero
81140fdc:	017fffc4 	movi	r5,-1
81140fe0:	1009883a 	mov	r4,r2
81140fe4:	113d2c80 	call	8113d2c8 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81140fe8:	e13ffe0f 	ldh	r4,-8(fp)
81140fec:	e0fffd17 	ldw	r3,-12(fp)
81140ff0:	00a045b4 	movhi	r2,33046
81140ff4:	109b4804 	addi	r2,r2,27936
81140ff8:	200891ba 	slli	r4,r4,6
81140ffc:	1105883a 	add	r2,r2,r4
81141000:	10800704 	addi	r2,r2,28
81141004:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81141008:	e0fffe0f 	ldh	r3,-8(fp)
8114100c:	00a045b4 	movhi	r2,33046
81141010:	109b4804 	addi	r2,r2,27936
81141014:	180691ba 	slli	r3,r3,6
81141018:	10c5883a 	add	r2,r2,r3
8114101c:	10800804 	addi	r2,r2,32
81141020:	10000015 	stw	zero,0(r2)
81141024:	00001506 	br	8114107c <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81141028:	0005883a 	mov	r2,zero
8114102c:	00007906 	br	81141214 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81141030:	e13ffe0f 	ldh	r4,-8(fp)
81141034:	e0fffe0f 	ldh	r3,-8(fp)
81141038:	00a045b4 	movhi	r2,33046
8114103c:	109b4804 	addi	r2,r2,27936
81141040:	180691ba 	slli	r3,r3,6
81141044:	10c5883a 	add	r2,r2,r3
81141048:	10800904 	addi	r2,r2,36
8114104c:	10c00017 	ldw	r3,0(r2)
81141050:	00a045b4 	movhi	r2,33046
81141054:	109b3304 	addi	r2,r2,27852
81141058:	1080030b 	ldhu	r2,12(r2)
8114105c:	10bfffcc 	andi	r2,r2,65535
81141060:	1887203a 	divu	r3,r3,r2
81141064:	00a045b4 	movhi	r2,33046
81141068:	109b4804 	addi	r2,r2,27936
8114106c:	200891ba 	slli	r4,r4,6
81141070:	1105883a 	add	r2,r2,r4
81141074:	10800804 	addi	r2,r2,32
81141078:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114107c:	00a045b4 	movhi	r2,33046
81141080:	109b3304 	addi	r2,r2,27852
81141084:	10c01417 	ldw	r3,80(r2)
81141088:	e13ffe0f 	ldh	r4,-8(fp)
8114108c:	00a045b4 	movhi	r2,33046
81141090:	109b4804 	addi	r2,r2,27936
81141094:	200891ba 	slli	r4,r4,6
81141098:	1105883a 	add	r2,r2,r4
8114109c:	10800704 	addi	r2,r2,28
811410a0:	10800017 	ldw	r2,0(r2)
811410a4:	113fff84 	addi	r4,r2,-2
811410a8:	00a045b4 	movhi	r2,33046
811410ac:	109b3304 	addi	r2,r2,27852
811410b0:	10800383 	ldbu	r2,14(r2)
811410b4:	10803fcc 	andi	r2,r2,255
811410b8:	2085383a 	mul	r2,r4,r2
811410bc:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
811410c0:	e13ffe0f 	ldh	r4,-8(fp)
811410c4:	00a045b4 	movhi	r2,33046
811410c8:	109b4804 	addi	r2,r2,27936
811410cc:	200891ba 	slli	r4,r4,6
811410d0:	1105883a 	add	r2,r2,r4
811410d4:	10800804 	addi	r2,r2,32
811410d8:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811410dc:	1885883a 	add	r2,r3,r2
811410e0:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
811410e4:	d0e0ab17 	ldw	r3,-32084(gp)
811410e8:	e0bffb17 	ldw	r2,-20(fp)
811410ec:	1885883a 	add	r2,r3,r2
811410f0:	1007883a 	mov	r3,r2
811410f4:	d0a0af17 	ldw	r2,-32068(gp)
811410f8:	18800726 	beq	r3,r2,81141118 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
811410fc:	d0a0ab17 	ldw	r2,-32084(gp)
81141100:	100b883a 	mov	r5,r2
81141104:	e13ffb17 	ldw	r4,-20(fp)
81141108:	113d12c0 	call	8113d12c <Read_Sector_Data>
8114110c:	1000021e 	bne	r2,zero,81141118 <alt_up_sd_card_write+0x518>
                {
					return false;
81141110:	0005883a 	mov	r2,zero
81141114:	00003f06 	br	81141214 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81141118:	d0e0aa17 	ldw	r3,-32088(gp)
8114111c:	e0bffc0f 	ldh	r2,-16(fp)
81141120:	1885883a 	add	r2,r3,r2
81141124:	e0ffff07 	ldb	r3,-4(fp)
81141128:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8114112c:	e13ffe0f 	ldh	r4,-8(fp)
81141130:	e0fffe0f 	ldh	r3,-8(fp)
81141134:	00a045b4 	movhi	r2,33046
81141138:	109b4804 	addi	r2,r2,27936
8114113c:	180691ba 	slli	r3,r3,6
81141140:	10c5883a 	add	r2,r2,r3
81141144:	10800904 	addi	r2,r2,36
81141148:	10800017 	ldw	r2,0(r2)
8114114c:	10c00044 	addi	r3,r2,1
81141150:	00a045b4 	movhi	r2,33046
81141154:	109b4804 	addi	r2,r2,27936
81141158:	200891ba 	slli	r4,r4,6
8114115c:	1105883a 	add	r2,r2,r4
81141160:	10800904 	addi	r2,r2,36
81141164:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81141168:	e0fffe0f 	ldh	r3,-8(fp)
8114116c:	00a045b4 	movhi	r2,33046
81141170:	109b4804 	addi	r2,r2,27936
81141174:	180691ba 	slli	r3,r3,6
81141178:	10c5883a 	add	r2,r2,r3
8114117c:	10800904 	addi	r2,r2,36
81141180:	10c00017 	ldw	r3,0(r2)
81141184:	e13ffe0f 	ldh	r4,-8(fp)
81141188:	00a045b4 	movhi	r2,33046
8114118c:	109b4804 	addi	r2,r2,27936
81141190:	200891ba 	slli	r4,r4,6
81141194:	1105883a 	add	r2,r2,r4
81141198:	10800604 	addi	r2,r2,24
8114119c:	10800017 	ldw	r2,0(r2)
811411a0:	18801736 	bltu	r3,r2,81141200 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811411a4:	e13ffe0f 	ldh	r4,-8(fp)
811411a8:	e0fffe0f 	ldh	r3,-8(fp)
811411ac:	00a045b4 	movhi	r2,33046
811411b0:	109b4804 	addi	r2,r2,27936
811411b4:	180691ba 	slli	r3,r3,6
811411b8:	10c5883a 	add	r2,r2,r3
811411bc:	10800604 	addi	r2,r2,24
811411c0:	10800017 	ldw	r2,0(r2)
811411c4:	10c00044 	addi	r3,r2,1
811411c8:	00a045b4 	movhi	r2,33046
811411cc:	109b4804 	addi	r2,r2,27936
811411d0:	200891ba 	slli	r4,r4,6
811411d4:	1105883a 	add	r2,r2,r4
811411d8:	10800604 	addi	r2,r2,24
811411dc:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
811411e0:	e0fffe0f 	ldh	r3,-8(fp)
811411e4:	00a045b4 	movhi	r2,33046
811411e8:	109b4804 	addi	r2,r2,27936
811411ec:	180691ba 	slli	r3,r3,6
811411f0:	10c5883a 	add	r2,r2,r3
811411f4:	10800e04 	addi	r2,r2,56
811411f8:	00c00044 	movi	r3,1
811411fc:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81141200:	00800044 	movi	r2,1
81141204:	d0a0ae15 	stw	r2,-32072(gp)
			result = true;
81141208:	00800044 	movi	r2,1
8114120c:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81141210:	e0bffa17 	ldw	r2,-24(fp)
}
81141214:	e037883a 	mov	sp,fp
81141218:	dfc00117 	ldw	ra,4(sp)
8114121c:	df000017 	ldw	fp,0(sp)
81141220:	dec00204 	addi	sp,sp,8
81141224:	f800283a 	ret

81141228 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81141228:	defffb04 	addi	sp,sp,-20
8114122c:	de00012e 	bgeu	sp,et,81141234 <alt_up_sd_card_fclose+0xc>
81141230:	003b68fa 	trap	3
81141234:	dfc00415 	stw	ra,16(sp)
81141238:	df000315 	stw	fp,12(sp)
8114123c:	df000304 	addi	fp,sp,12
81141240:	2005883a 	mov	r2,r4
81141244:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81141248:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114124c:	113fe040 	call	8113fe04 <alt_up_sd_card_is_Present>
81141250:	10006026 	beq	r2,zero,811413d4 <alt_up_sd_card_fclose+0x1ac>
81141254:	d0a0a417 	ldw	r2,-32112(gp)
81141258:	10005e26 	beq	r2,zero,811413d4 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
8114125c:	e0ffff0f 	ldh	r3,-4(fp)
81141260:	00a045b4 	movhi	r2,33046
81141264:	109b4804 	addi	r2,r2,27936
81141268:	180691ba 	slli	r3,r3,6
8114126c:	10c5883a 	add	r2,r2,r3
81141270:	10800f04 	addi	r2,r2,60
81141274:	10800017 	ldw	r2,0(r2)
81141278:	10005626 	beq	r2,zero,811413d4 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
8114127c:	e0ffff0f 	ldh	r3,-4(fp)
81141280:	00a045b4 	movhi	r2,33046
81141284:	109b4804 	addi	r2,r2,27936
81141288:	180691ba 	slli	r3,r3,6
8114128c:	10c5883a 	add	r2,r2,r3
81141290:	10800e04 	addi	r2,r2,56
81141294:	10800017 	ldw	r2,0(r2)
81141298:	10004526 	beq	r2,zero,811413b0 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
8114129c:	e0ffff0f 	ldh	r3,-4(fp)
811412a0:	00a045b4 	movhi	r2,33046
811412a4:	109b4804 	addi	r2,r2,27936
811412a8:	180691ba 	slli	r3,r3,6
811412ac:	10c5883a 	add	r2,r2,r3
811412b0:	10800b04 	addi	r2,r2,44
811412b4:	10800017 	ldw	r2,0(r2)
811412b8:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
811412bc:	e0ffff0f 	ldh	r3,-4(fp)
811412c0:	00a045b4 	movhi	r2,33046
811412c4:	109b4804 	addi	r2,r2,27936
811412c8:	180691ba 	slli	r3,r3,6
811412cc:	10c5883a 	add	r2,r2,r3
811412d0:	10800a04 	addi	r2,r2,40
811412d4:	10800017 	ldw	r2,0(r2)
811412d8:	1000071e 	bne	r2,zero,811412f8 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
811412dc:	00a045b4 	movhi	r2,33046
811412e0:	109b3304 	addi	r2,r2,27852
811412e4:	10801317 	ldw	r2,76(r2)
811412e8:	e0fffe17 	ldw	r3,-8(fp)
811412ec:	1885883a 	add	r2,r3,r2
811412f0:	e0bffe15 	stw	r2,-8(fp)
811412f4:	00001406 	br	81141348 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811412f8:	00a045b4 	movhi	r2,33046
811412fc:	109b3304 	addi	r2,r2,27852
81141300:	10c01417 	ldw	r3,80(r2)
81141304:	e0bffe17 	ldw	r2,-8(fp)
81141308:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8114130c:	e13fff0f 	ldh	r4,-4(fp)
81141310:	00a045b4 	movhi	r2,33046
81141314:	109b4804 	addi	r2,r2,27936
81141318:	200891ba 	slli	r4,r4,6
8114131c:	1105883a 	add	r2,r2,r4
81141320:	10800a04 	addi	r2,r2,40
81141324:	10800017 	ldw	r2,0(r2)
81141328:	113fff84 	addi	r4,r2,-2
8114132c:	00a045b4 	movhi	r2,33046
81141330:	109b3304 	addi	r2,r2,27852
81141334:	10800383 	ldbu	r2,14(r2)
81141338:	10803fcc 	andi	r2,r2,255
8114133c:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81141340:	1885883a 	add	r2,r3,r2
81141344:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81141348:	e0bffe17 	ldw	r2,-8(fp)
8114134c:	d0e0ab17 	ldw	r3,-32084(gp)
81141350:	180b883a 	mov	r5,r3
81141354:	1009883a 	mov	r4,r2
81141358:	113d12c0 	call	8113d12c <Read_Sector_Data>
8114135c:	10001426 	beq	r2,zero,811413b0 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81141360:	e0ffff0f 	ldh	r3,-4(fp)
81141364:	00a045b4 	movhi	r2,33046
81141368:	109b4804 	addi	r2,r2,27936
8114136c:	180691ba 	slli	r3,r3,6
81141370:	10c5883a 	add	r2,r2,r3
81141374:	10800c04 	addi	r2,r2,48
81141378:	1080000b 	ldhu	r2,0(r2)
8114137c:	113fffcc 	andi	r4,r2,65535
81141380:	2120001c 	xori	r4,r4,32768
81141384:	21200004 	addi	r4,r4,-32768
81141388:	e0bfff0f 	ldh	r2,-4(fp)
8114138c:	100691ba 	slli	r3,r2,6
81141390:	00a045b4 	movhi	r2,33046
81141394:	109b4804 	addi	r2,r2,27936
81141398:	1885883a 	add	r2,r3,r2
8114139c:	100b883a 	mov	r5,r2
811413a0:	113d7e00 	call	8113d7e0 <Write_File_Record_At_Offset>
811413a4:	10000226 	beq	r2,zero,811413b0 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811413a8:	113d0d80 	call	8113d0d8 <Save_Modified_Sector>
811413ac:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
811413b0:	e0ffff0f 	ldh	r3,-4(fp)
811413b4:	00a045b4 	movhi	r2,33046
811413b8:	109b4804 	addi	r2,r2,27936
811413bc:	180691ba 	slli	r3,r3,6
811413c0:	10c5883a 	add	r2,r2,r3
811413c4:	10800f04 	addi	r2,r2,60
811413c8:	10000015 	stw	zero,0(r2)
			result = true;
811413cc:	00800044 	movi	r2,1
811413d0:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
811413d4:	e0bffd17 	ldw	r2,-12(fp)
}
811413d8:	e037883a 	mov	sp,fp
811413dc:	dfc00117 	ldw	ra,4(sp)
811413e0:	df000017 	ldw	fp,0(sp)
811413e4:	dec00204 	addi	sp,sp,8
811413e8:	f800283a 	ret

811413ec <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811413ec:	defffa04 	addi	sp,sp,-24
811413f0:	de00012e 	bgeu	sp,et,811413f8 <altera_avalon_jtag_uart_read_fd+0xc>
811413f4:	003b68fa 	trap	3
811413f8:	dfc00515 	stw	ra,20(sp)
811413fc:	df000415 	stw	fp,16(sp)
81141400:	df000404 	addi	fp,sp,16
81141404:	e13ffd15 	stw	r4,-12(fp)
81141408:	e17ffe15 	stw	r5,-8(fp)
8114140c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81141410:	e0bffd17 	ldw	r2,-12(fp)
81141414:	10800017 	ldw	r2,0(r2)
81141418:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8114141c:	e0bffc17 	ldw	r2,-16(fp)
81141420:	10c00a04 	addi	r3,r2,40
81141424:	e0bffd17 	ldw	r2,-12(fp)
81141428:	10800217 	ldw	r2,8(r2)
8114142c:	100f883a 	mov	r7,r2
81141430:	e1bfff17 	ldw	r6,-4(fp)
81141434:	e17ffe17 	ldw	r5,-8(fp)
81141438:	1809883a 	mov	r4,r3
8114143c:	1141c700 	call	81141c70 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81141440:	e037883a 	mov	sp,fp
81141444:	dfc00117 	ldw	ra,4(sp)
81141448:	df000017 	ldw	fp,0(sp)
8114144c:	dec00204 	addi	sp,sp,8
81141450:	f800283a 	ret

81141454 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81141454:	defffa04 	addi	sp,sp,-24
81141458:	de00012e 	bgeu	sp,et,81141460 <altera_avalon_jtag_uart_write_fd+0xc>
8114145c:	003b68fa 	trap	3
81141460:	dfc00515 	stw	ra,20(sp)
81141464:	df000415 	stw	fp,16(sp)
81141468:	df000404 	addi	fp,sp,16
8114146c:	e13ffd15 	stw	r4,-12(fp)
81141470:	e17ffe15 	stw	r5,-8(fp)
81141474:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81141478:	e0bffd17 	ldw	r2,-12(fp)
8114147c:	10800017 	ldw	r2,0(r2)
81141480:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81141484:	e0bffc17 	ldw	r2,-16(fp)
81141488:	10c00a04 	addi	r3,r2,40
8114148c:	e0bffd17 	ldw	r2,-12(fp)
81141490:	10800217 	ldw	r2,8(r2)
81141494:	100f883a 	mov	r7,r2
81141498:	e1bfff17 	ldw	r6,-4(fp)
8114149c:	e17ffe17 	ldw	r5,-8(fp)
811414a0:	1809883a 	mov	r4,r3
811414a4:	1141f340 	call	81141f34 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811414a8:	e037883a 	mov	sp,fp
811414ac:	dfc00117 	ldw	ra,4(sp)
811414b0:	df000017 	ldw	fp,0(sp)
811414b4:	dec00204 	addi	sp,sp,8
811414b8:	f800283a 	ret

811414bc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
811414bc:	defffc04 	addi	sp,sp,-16
811414c0:	de00012e 	bgeu	sp,et,811414c8 <altera_avalon_jtag_uart_close_fd+0xc>
811414c4:	003b68fa 	trap	3
811414c8:	dfc00315 	stw	ra,12(sp)
811414cc:	df000215 	stw	fp,8(sp)
811414d0:	df000204 	addi	fp,sp,8
811414d4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811414d8:	e0bfff17 	ldw	r2,-4(fp)
811414dc:	10800017 	ldw	r2,0(r2)
811414e0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
811414e4:	e0bffe17 	ldw	r2,-8(fp)
811414e8:	10c00a04 	addi	r3,r2,40
811414ec:	e0bfff17 	ldw	r2,-4(fp)
811414f0:	10800217 	ldw	r2,8(r2)
811414f4:	100b883a 	mov	r5,r2
811414f8:	1809883a 	mov	r4,r3
811414fc:	1141b080 	call	81141b08 <altera_avalon_jtag_uart_close>
}
81141500:	e037883a 	mov	sp,fp
81141504:	dfc00117 	ldw	ra,4(sp)
81141508:	df000017 	ldw	fp,0(sp)
8114150c:	dec00204 	addi	sp,sp,8
81141510:	f800283a 	ret

81141514 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81141514:	defffa04 	addi	sp,sp,-24
81141518:	de00012e 	bgeu	sp,et,81141520 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8114151c:	003b68fa 	trap	3
81141520:	dfc00515 	stw	ra,20(sp)
81141524:	df000415 	stw	fp,16(sp)
81141528:	df000404 	addi	fp,sp,16
8114152c:	e13ffd15 	stw	r4,-12(fp)
81141530:	e17ffe15 	stw	r5,-8(fp)
81141534:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81141538:	e0bffd17 	ldw	r2,-12(fp)
8114153c:	10800017 	ldw	r2,0(r2)
81141540:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81141544:	e0bffc17 	ldw	r2,-16(fp)
81141548:	10800a04 	addi	r2,r2,40
8114154c:	e1bfff17 	ldw	r6,-4(fp)
81141550:	e17ffe17 	ldw	r5,-8(fp)
81141554:	1009883a 	mov	r4,r2
81141558:	1141b780 	call	81141b78 <altera_avalon_jtag_uart_ioctl>
}
8114155c:	e037883a 	mov	sp,fp
81141560:	dfc00117 	ldw	ra,4(sp)
81141564:	df000017 	ldw	fp,0(sp)
81141568:	dec00204 	addi	sp,sp,8
8114156c:	f800283a 	ret

81141570 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81141570:	deffef04 	addi	sp,sp,-68
81141574:	de00012e 	bgeu	sp,et,8114157c <altera_avalon_jtag_uart_init+0xc>
81141578:	003b68fa 	trap	3
8114157c:	dfc01015 	stw	ra,64(sp)
81141580:	df000f15 	stw	fp,60(sp)
81141584:	dc400e15 	stw	r17,56(sp)
81141588:	dc000d15 	stw	r16,52(sp)
8114158c:	df000f04 	addi	fp,sp,60
81141590:	e13ff715 	stw	r4,-36(fp)
81141594:	e17ff815 	stw	r5,-32(fp)
81141598:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
8114159c:	e0bff717 	ldw	r2,-36(fp)
811415a0:	10800c04 	addi	r2,r2,48
811415a4:	e0bff215 	stw	r2,-56(fp)
811415a8:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811415ac:	e0bff60b 	ldhu	r2,-40(fp)
811415b0:	e0fff684 	addi	r3,fp,-38
811415b4:	180b883a 	mov	r5,r3
811415b8:	1009883a 	mov	r4,r2
811415bc:	11358f40 	call	811358f4 <OSFlagCreate>
811415c0:	1007883a 	mov	r3,r2
811415c4:	e0bff217 	ldw	r2,-56(fp)
811415c8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
811415cc:	e0bff717 	ldw	r2,-36(fp)
811415d0:	10800a04 	addi	r2,r2,40
811415d4:	e0bff315 	stw	r2,-52(fp)
811415d8:	00800044 	movi	r2,1
811415dc:	e0bff58d 	sth	r2,-42(fp)
811415e0:	e0bff58b 	ldhu	r2,-42(fp)
811415e4:	1009883a 	mov	r4,r2
811415e8:	11398500 	call	81139850 <OSSemCreate>
811415ec:	1007883a 	mov	r3,r2
811415f0:	e0bff317 	ldw	r2,-52(fp)
811415f4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
811415f8:	e0bff717 	ldw	r2,-36(fp)
811415fc:	10800b04 	addi	r2,r2,44
81141600:	e0bff415 	stw	r2,-48(fp)
81141604:	00800044 	movi	r2,1
81141608:	e0bff50d 	sth	r2,-44(fp)
8114160c:	e0bff50b 	ldhu	r2,-44(fp)
81141610:	1009883a 	mov	r4,r2
81141614:	11398500 	call	81139850 <OSSemCreate>
81141618:	1007883a 	mov	r3,r2
8114161c:	e0bff417 	ldw	r2,-48(fp)
81141620:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81141624:	e0bff717 	ldw	r2,-36(fp)
81141628:	00c00044 	movi	r3,1
8114162c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81141630:	e0bff717 	ldw	r2,-36(fp)
81141634:	10800017 	ldw	r2,0(r2)
81141638:	10800104 	addi	r2,r2,4
8114163c:	1007883a 	mov	r3,r2
81141640:	e0bff717 	ldw	r2,-36(fp)
81141644:	10800817 	ldw	r2,32(r2)
81141648:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
8114164c:	e0bff817 	ldw	r2,-32(fp)
81141650:	e0fff917 	ldw	r3,-28(fp)
81141654:	d8000015 	stw	zero,0(sp)
81141658:	e1fff717 	ldw	r7,-36(fp)
8114165c:	01a04534 	movhi	r6,33044
81141660:	3185d004 	addi	r6,r6,5952
81141664:	180b883a 	mov	r5,r3
81141668:	1009883a 	mov	r4,r2
8114166c:	11454880 	call	81145488 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81141670:	e0bff717 	ldw	r2,-36(fp)
81141674:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81141678:	e0bff717 	ldw	r2,-36(fp)
8114167c:	10800204 	addi	r2,r2,8
81141680:	d0e08217 	ldw	r3,-32248(gp)
81141684:	e1fff717 	ldw	r7,-36(fp)
81141688:	01a04534 	movhi	r6,33044
8114168c:	31867f04 	addi	r6,r6,6652
81141690:	180b883a 	mov	r5,r3
81141694:	1009883a 	mov	r4,r2
81141698:	1144fd80 	call	81144fd8 <alt_alarm_start>
8114169c:	1000040e 	bge	r2,zero,811416b0 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811416a0:	e0fff717 	ldw	r3,-36(fp)
811416a4:	00a00034 	movhi	r2,32768
811416a8:	10bfffc4 	addi	r2,r2,-1
811416ac:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
811416b0:	d0a07b83 	ldbu	r2,-32274(gp)
811416b4:	10803fcc 	andi	r2,r2,255
811416b8:	10800058 	cmpnei	r2,r2,1
811416bc:	10000f1e 	bne	r2,zero,811416fc <altera_avalon_jtag_uart_init+0x18c>
811416c0:	d0e08217 	ldw	r3,-32248(gp)
811416c4:	00b33374 	movhi	r2,52429
811416c8:	10b33344 	addi	r2,r2,-13107
811416cc:	1888383a 	mulxuu	r4,r3,r2
811416d0:	1885383a 	mul	r2,r3,r2
811416d4:	1021883a 	mov	r16,r2
811416d8:	2023883a 	mov	r17,r4
811416dc:	8804d0fa 	srli	r2,r17,3
811416e0:	e1fff717 	ldw	r7,-36(fp)
811416e4:	01a044f4 	movhi	r6,33043
811416e8:	31880904 	addi	r6,r6,8228
811416ec:	100b883a 	mov	r5,r2
811416f0:	012045b4 	movhi	r4,33046
811416f4:	21035f04 	addi	r4,r4,3452
811416f8:	1144fd80 	call	81144fd8 <alt_alarm_start>
811416fc:	d0a07c03 	ldbu	r2,-32272(gp)
81141700:	10803fcc 	andi	r2,r2,255
81141704:	10800058 	cmpnei	r2,r2,1
81141708:	1000051e 	bne	r2,zero,81141720 <altera_avalon_jtag_uart_init+0x1b0>
8114170c:	e0bff717 	ldw	r2,-36(fp)
81141710:	10800017 	ldw	r2,0(r2)
81141714:	100b883a 	mov	r5,r2
81141718:	e13ff717 	ldw	r4,-36(fp)
8114171c:	11321bc0 	call	811321bc <alt_log_jtag_uart_startup_info>
}
81141720:	0001883a 	nop
81141724:	e6fffe04 	addi	sp,fp,-8
81141728:	dfc00317 	ldw	ra,12(sp)
8114172c:	df000217 	ldw	fp,8(sp)
81141730:	dc400117 	ldw	r17,4(sp)
81141734:	dc000017 	ldw	r16,0(sp)
81141738:	dec00404 	addi	sp,sp,16
8114173c:	f800283a 	ret

81141740 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81141740:	defff204 	addi	sp,sp,-56
81141744:	de00012e 	bgeu	sp,et,8114174c <altera_avalon_jtag_uart_irq+0xc>
81141748:	003b68fa 	trap	3
8114174c:	dfc00d15 	stw	ra,52(sp)
81141750:	df000c15 	stw	fp,48(sp)
81141754:	df000c04 	addi	fp,sp,48
81141758:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
8114175c:	e0bfff17 	ldw	r2,-4(fp)
81141760:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81141764:	e0bff617 	ldw	r2,-40(fp)
81141768:	10800017 	ldw	r2,0(r2)
8114176c:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81141770:	e0bff717 	ldw	r2,-36(fp)
81141774:	e17ff617 	ldw	r5,-40(fp)
81141778:	1009883a 	mov	r4,r2
8114177c:	11322100 	call	81132210 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81141780:	e0bff717 	ldw	r2,-36(fp)
81141784:	10800104 	addi	r2,r2,4
81141788:	10800037 	ldwio	r2,0(r2)
8114178c:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81141790:	e0bff817 	ldw	r2,-32(fp)
81141794:	1080c00c 	andi	r2,r2,768
81141798:	10009126 	beq	r2,zero,811419e0 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
8114179c:	e0bff817 	ldw	r2,-32(fp)
811417a0:	1080400c 	andi	r2,r2,256
811417a4:	10004726 	beq	r2,zero,811418c4 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811417a8:	00800074 	movhi	r2,1
811417ac:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811417b0:	e0bff617 	ldw	r2,-40(fp)
811417b4:	10800d17 	ldw	r2,52(r2)
811417b8:	10800044 	addi	r2,r2,1
811417bc:	1081ffcc 	andi	r2,r2,2047
811417c0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
811417c4:	e0bff617 	ldw	r2,-40(fp)
811417c8:	10c00e17 	ldw	r3,56(r2)
811417cc:	e0bff917 	ldw	r2,-28(fp)
811417d0:	18802726 	beq	r3,r2,81141870 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
811417d4:	e0bff717 	ldw	r2,-36(fp)
811417d8:	10800037 	ldwio	r2,0(r2)
811417dc:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
811417e0:	e0bff417 	ldw	r2,-48(fp)
811417e4:	10a0000c 	andi	r2,r2,32768
811417e8:	10002326 	beq	r2,zero,81141878 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
811417ec:	e0bff617 	ldw	r2,-40(fp)
811417f0:	10800d17 	ldw	r2,52(r2)
811417f4:	e0fff417 	ldw	r3,-48(fp)
811417f8:	1809883a 	mov	r4,r3
811417fc:	e0fff617 	ldw	r3,-40(fp)
81141800:	1885883a 	add	r2,r3,r2
81141804:	10801104 	addi	r2,r2,68
81141808:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8114180c:	e0bff617 	ldw	r2,-40(fp)
81141810:	10800d17 	ldw	r2,52(r2)
81141814:	10800044 	addi	r2,r2,1
81141818:	10c1ffcc 	andi	r3,r2,2047
8114181c:	e0bff617 	ldw	r2,-40(fp)
81141820:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81141824:	e0bff617 	ldw	r2,-40(fp)
81141828:	10800c17 	ldw	r2,48(r2)
8114182c:	e0bffb15 	stw	r2,-20(fp)
81141830:	00800044 	movi	r2,1
81141834:	e0bffc0d 	sth	r2,-16(fp)
81141838:	00800044 	movi	r2,1
8114183c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81141840:	d0a08b03 	ldbu	r2,-32212(gp)
81141844:	10803fcc 	andi	r2,r2,255
81141848:	103fd926 	beq	r2,zero,811417b0 <__reset+0xfb1217b0>
  {
    OSFlagPost (group, flags, opt, &err);
8114184c:	e0bffc0b 	ldhu	r2,-16(fp)
81141850:	e0fffc83 	ldbu	r3,-14(fp)
81141854:	e13ffdc4 	addi	r4,fp,-9
81141858:	200f883a 	mov	r7,r4
8114185c:	180d883a 	mov	r6,r3
81141860:	100b883a 	mov	r5,r2
81141864:	e13ffb17 	ldw	r4,-20(fp)
81141868:	11365000 	call	81136500 <OSFlagPost>
      }
8114186c:	003fd006 	br	811417b0 <__reset+0xfb1217b0>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81141870:	0001883a 	nop
81141874:	00000106 	br	8114187c <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81141878:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
8114187c:	e0bff417 	ldw	r2,-48(fp)
81141880:	10bfffec 	andhi	r2,r2,65535
81141884:	10000f26 	beq	r2,zero,811418c4 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81141888:	e0bff617 	ldw	r2,-40(fp)
8114188c:	10c00817 	ldw	r3,32(r2)
81141890:	00bfff84 	movi	r2,-2
81141894:	1886703a 	and	r3,r3,r2
81141898:	e0bff617 	ldw	r2,-40(fp)
8114189c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811418a0:	e0bff717 	ldw	r2,-36(fp)
811418a4:	10800104 	addi	r2,r2,4
811418a8:	1007883a 	mov	r3,r2
811418ac:	e0bff617 	ldw	r2,-40(fp)
811418b0:	10800817 	ldw	r2,32(r2)
811418b4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811418b8:	e0bff717 	ldw	r2,-36(fp)
811418bc:	10800104 	addi	r2,r2,4
811418c0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811418c4:	e0bff817 	ldw	r2,-32(fp)
811418c8:	1080800c 	andi	r2,r2,512
811418cc:	103fac26 	beq	r2,zero,81141780 <__reset+0xfb121780>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
811418d0:	e0bff817 	ldw	r2,-32(fp)
811418d4:	1004d43a 	srli	r2,r2,16
811418d8:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
811418dc:	00002606 	br	81141978 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
811418e0:	e0bff717 	ldw	r2,-36(fp)
811418e4:	e0fff617 	ldw	r3,-40(fp)
811418e8:	18c01017 	ldw	r3,64(r3)
811418ec:	e13ff617 	ldw	r4,-40(fp)
811418f0:	20c7883a 	add	r3,r4,r3
811418f4:	18c21104 	addi	r3,r3,2116
811418f8:	18c00003 	ldbu	r3,0(r3)
811418fc:	18c03fcc 	andi	r3,r3,255
81141900:	18c0201c 	xori	r3,r3,128
81141904:	18ffe004 	addi	r3,r3,-128
81141908:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8114190c:	e0bff617 	ldw	r2,-40(fp)
81141910:	10801017 	ldw	r2,64(r2)
81141914:	10800044 	addi	r2,r2,1
81141918:	10c1ffcc 	andi	r3,r2,2047
8114191c:	e0bff617 	ldw	r2,-40(fp)
81141920:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81141924:	e0bff617 	ldw	r2,-40(fp)
81141928:	10800c17 	ldw	r2,48(r2)
8114192c:	e0bffa15 	stw	r2,-24(fp)
81141930:	00800084 	movi	r2,2
81141934:	e0bffd0d 	sth	r2,-12(fp)
81141938:	00800044 	movi	r2,1
8114193c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81141940:	d0a08b03 	ldbu	r2,-32212(gp)
81141944:	10803fcc 	andi	r2,r2,255
81141948:	10000826 	beq	r2,zero,8114196c <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
8114194c:	e0bffd0b 	ldhu	r2,-12(fp)
81141950:	e0fffd83 	ldbu	r3,-10(fp)
81141954:	e13ffe04 	addi	r4,fp,-8
81141958:	200f883a 	mov	r7,r4
8114195c:	180d883a 	mov	r6,r3
81141960:	100b883a 	mov	r5,r2
81141964:	e13ffa17 	ldw	r4,-24(fp)
81141968:	11365000 	call	81136500 <OSFlagPost>

        space--;
8114196c:	e0bff517 	ldw	r2,-44(fp)
81141970:	10bfffc4 	addi	r2,r2,-1
81141974:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81141978:	e0bff517 	ldw	r2,-44(fp)
8114197c:	10000526 	beq	r2,zero,81141994 <altera_avalon_jtag_uart_irq+0x254>
81141980:	e0bff617 	ldw	r2,-40(fp)
81141984:	10c01017 	ldw	r3,64(r2)
81141988:	e0bff617 	ldw	r2,-40(fp)
8114198c:	10800f17 	ldw	r2,60(r2)
81141990:	18bfd31e 	bne	r3,r2,811418e0 <__reset+0xfb1218e0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81141994:	e0bff517 	ldw	r2,-44(fp)
81141998:	103f7926 	beq	r2,zero,81141780 <__reset+0xfb121780>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8114199c:	e0bff617 	ldw	r2,-40(fp)
811419a0:	10c00817 	ldw	r3,32(r2)
811419a4:	00bfff44 	movi	r2,-3
811419a8:	1886703a 	and	r3,r3,r2
811419ac:	e0bff617 	ldw	r2,-40(fp)
811419b0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811419b4:	e0bff617 	ldw	r2,-40(fp)
811419b8:	10800017 	ldw	r2,0(r2)
811419bc:	10800104 	addi	r2,r2,4
811419c0:	1007883a 	mov	r3,r2
811419c4:	e0bff617 	ldw	r2,-40(fp)
811419c8:	10800817 	ldw	r2,32(r2)
811419cc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811419d0:	e0bff717 	ldw	r2,-36(fp)
811419d4:	10800104 	addi	r2,r2,4
811419d8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
811419dc:	003f6806 	br	81141780 <__reset+0xfb121780>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
811419e0:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
811419e4:	0001883a 	nop
811419e8:	e037883a 	mov	sp,fp
811419ec:	dfc00117 	ldw	ra,4(sp)
811419f0:	df000017 	ldw	fp,0(sp)
811419f4:	dec00204 	addi	sp,sp,8
811419f8:	f800283a 	ret

811419fc <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
811419fc:	defff904 	addi	sp,sp,-28
81141a00:	de00012e 	bgeu	sp,et,81141a08 <altera_avalon_jtag_uart_timeout+0xc>
81141a04:	003b68fa 	trap	3
81141a08:	dfc00615 	stw	ra,24(sp)
81141a0c:	df000515 	stw	fp,20(sp)
81141a10:	df000504 	addi	fp,sp,20
81141a14:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81141a18:	e0bfff17 	ldw	r2,-4(fp)
81141a1c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81141a20:	e0bffb17 	ldw	r2,-20(fp)
81141a24:	10800017 	ldw	r2,0(r2)
81141a28:	10800104 	addi	r2,r2,4
81141a2c:	10800037 	ldwio	r2,0(r2)
81141a30:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81141a34:	e0bffc17 	ldw	r2,-16(fp)
81141a38:	1081000c 	andi	r2,r2,1024
81141a3c:	10000b26 	beq	r2,zero,81141a6c <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81141a40:	e0bffb17 	ldw	r2,-20(fp)
81141a44:	10800017 	ldw	r2,0(r2)
81141a48:	10800104 	addi	r2,r2,4
81141a4c:	1007883a 	mov	r3,r2
81141a50:	e0bffb17 	ldw	r2,-20(fp)
81141a54:	10800817 	ldw	r2,32(r2)
81141a58:	10810014 	ori	r2,r2,1024
81141a5c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81141a60:	e0bffb17 	ldw	r2,-20(fp)
81141a64:	10000915 	stw	zero,36(r2)
81141a68:	00002106 	br	81141af0 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81141a6c:	e0bffb17 	ldw	r2,-20(fp)
81141a70:	10c00917 	ldw	r3,36(r2)
81141a74:	00a00034 	movhi	r2,32768
81141a78:	10bfff04 	addi	r2,r2,-4
81141a7c:	10c01c36 	bltu	r2,r3,81141af0 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81141a80:	e0bffb17 	ldw	r2,-20(fp)
81141a84:	10800917 	ldw	r2,36(r2)
81141a88:	10c00044 	addi	r3,r2,1
81141a8c:	e0bffb17 	ldw	r2,-20(fp)
81141a90:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81141a94:	e0bffb17 	ldw	r2,-20(fp)
81141a98:	10c00917 	ldw	r3,36(r2)
81141a9c:	e0bffb17 	ldw	r2,-20(fp)
81141aa0:	10800117 	ldw	r2,4(r2)
81141aa4:	18801236 	bltu	r3,r2,81141af0 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81141aa8:	e0bffb17 	ldw	r2,-20(fp)
81141aac:	10800c17 	ldw	r2,48(r2)
81141ab0:	e0bffd15 	stw	r2,-12(fp)
81141ab4:	00800104 	movi	r2,4
81141ab8:	e0bffe0d 	sth	r2,-8(fp)
81141abc:	00800044 	movi	r2,1
81141ac0:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81141ac4:	d0a08b03 	ldbu	r2,-32212(gp)
81141ac8:	10803fcc 	andi	r2,r2,255
81141acc:	10000826 	beq	r2,zero,81141af0 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81141ad0:	e0bffe0b 	ldhu	r2,-8(fp)
81141ad4:	e0fffe83 	ldbu	r3,-6(fp)
81141ad8:	e13ffec4 	addi	r4,fp,-5
81141adc:	200f883a 	mov	r7,r4
81141ae0:	180d883a 	mov	r6,r3
81141ae4:	100b883a 	mov	r5,r2
81141ae8:	e13ffd17 	ldw	r4,-12(fp)
81141aec:	11365000 	call	81136500 <OSFlagPost>
81141af0:	d0a08217 	ldw	r2,-32248(gp)
    }
  }

  return alt_ticks_per_second();
}
81141af4:	e037883a 	mov	sp,fp
81141af8:	dfc00117 	ldw	ra,4(sp)
81141afc:	df000017 	ldw	fp,0(sp)
81141b00:	dec00204 	addi	sp,sp,8
81141b04:	f800283a 	ret

81141b08 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81141b08:	defffd04 	addi	sp,sp,-12
81141b0c:	de00012e 	bgeu	sp,et,81141b14 <altera_avalon_jtag_uart_close+0xc>
81141b10:	003b68fa 	trap	3
81141b14:	df000215 	stw	fp,8(sp)
81141b18:	df000204 	addi	fp,sp,8
81141b1c:	e13ffe15 	stw	r4,-8(fp)
81141b20:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81141b24:	00000506 	br	81141b3c <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81141b28:	e0bfff17 	ldw	r2,-4(fp)
81141b2c:	1090000c 	andi	r2,r2,16384
81141b30:	10000226 	beq	r2,zero,81141b3c <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81141b34:	00bffd44 	movi	r2,-11
81141b38:	00000b06 	br	81141b68 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81141b3c:	e0bffe17 	ldw	r2,-8(fp)
81141b40:	10c01017 	ldw	r3,64(r2)
81141b44:	e0bffe17 	ldw	r2,-8(fp)
81141b48:	10800f17 	ldw	r2,60(r2)
81141b4c:	18800526 	beq	r3,r2,81141b64 <altera_avalon_jtag_uart_close+0x5c>
81141b50:	e0bffe17 	ldw	r2,-8(fp)
81141b54:	10c00917 	ldw	r3,36(r2)
81141b58:	e0bffe17 	ldw	r2,-8(fp)
81141b5c:	10800117 	ldw	r2,4(r2)
81141b60:	18bff136 	bltu	r3,r2,81141b28 <__reset+0xfb121b28>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81141b64:	0005883a 	mov	r2,zero
}
81141b68:	e037883a 	mov	sp,fp
81141b6c:	df000017 	ldw	fp,0(sp)
81141b70:	dec00104 	addi	sp,sp,4
81141b74:	f800283a 	ret

81141b78 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81141b78:	defffa04 	addi	sp,sp,-24
81141b7c:	de00012e 	bgeu	sp,et,81141b84 <altera_avalon_jtag_uart_ioctl+0xc>
81141b80:	003b68fa 	trap	3
81141b84:	df000515 	stw	fp,20(sp)
81141b88:	df000504 	addi	fp,sp,20
81141b8c:	e13ffd15 	stw	r4,-12(fp)
81141b90:	e17ffe15 	stw	r5,-8(fp)
81141b94:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81141b98:	00bff9c4 	movi	r2,-25
81141b9c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81141ba0:	e0bffe17 	ldw	r2,-8(fp)
81141ba4:	10da8060 	cmpeqi	r3,r2,27137
81141ba8:	1800031e 	bne	r3,zero,81141bb8 <altera_avalon_jtag_uart_ioctl+0x40>
81141bac:	109a80a0 	cmpeqi	r2,r2,27138
81141bb0:	1000181e 	bne	r2,zero,81141c14 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81141bb4:	00002906 	br	81141c5c <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81141bb8:	e0bffd17 	ldw	r2,-12(fp)
81141bbc:	10c00117 	ldw	r3,4(r2)
81141bc0:	00a00034 	movhi	r2,32768
81141bc4:	10bfffc4 	addi	r2,r2,-1
81141bc8:	18802126 	beq	r3,r2,81141c50 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81141bcc:	e0bfff17 	ldw	r2,-4(fp)
81141bd0:	10800017 	ldw	r2,0(r2)
81141bd4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81141bd8:	e0bffc17 	ldw	r2,-16(fp)
81141bdc:	10800090 	cmplti	r2,r2,2
81141be0:	1000061e 	bne	r2,zero,81141bfc <altera_avalon_jtag_uart_ioctl+0x84>
81141be4:	e0fffc17 	ldw	r3,-16(fp)
81141be8:	00a00034 	movhi	r2,32768
81141bec:	10bfffc4 	addi	r2,r2,-1
81141bf0:	18800226 	beq	r3,r2,81141bfc <altera_avalon_jtag_uart_ioctl+0x84>
81141bf4:	e0bffc17 	ldw	r2,-16(fp)
81141bf8:	00000206 	br	81141c04 <altera_avalon_jtag_uart_ioctl+0x8c>
81141bfc:	00a00034 	movhi	r2,32768
81141c00:	10bfff84 	addi	r2,r2,-2
81141c04:	e0fffd17 	ldw	r3,-12(fp)
81141c08:	18800115 	stw	r2,4(r3)
      rc = 0;
81141c0c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81141c10:	00000f06 	br	81141c50 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81141c14:	e0bffd17 	ldw	r2,-12(fp)
81141c18:	10c00117 	ldw	r3,4(r2)
81141c1c:	00a00034 	movhi	r2,32768
81141c20:	10bfffc4 	addi	r2,r2,-1
81141c24:	18800c26 	beq	r3,r2,81141c58 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81141c28:	e0bffd17 	ldw	r2,-12(fp)
81141c2c:	10c00917 	ldw	r3,36(r2)
81141c30:	e0bffd17 	ldw	r2,-12(fp)
81141c34:	10800117 	ldw	r2,4(r2)
81141c38:	1885803a 	cmpltu	r2,r3,r2
81141c3c:	10c03fcc 	andi	r3,r2,255
81141c40:	e0bfff17 	ldw	r2,-4(fp)
81141c44:	10c00015 	stw	r3,0(r2)
      rc = 0;
81141c48:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81141c4c:	00000206 	br	81141c58 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81141c50:	0001883a 	nop
81141c54:	00000106 	br	81141c5c <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81141c58:	0001883a 	nop

  default:
    break;
  }

  return rc;
81141c5c:	e0bffb17 	ldw	r2,-20(fp)
}
81141c60:	e037883a 	mov	sp,fp
81141c64:	df000017 	ldw	fp,0(sp)
81141c68:	dec00104 	addi	sp,sp,4
81141c6c:	f800283a 	ret

81141c70 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81141c70:	deffed04 	addi	sp,sp,-76
81141c74:	de00012e 	bgeu	sp,et,81141c7c <altera_avalon_jtag_uart_read+0xc>
81141c78:	003b68fa 	trap	3
81141c7c:	dfc01215 	stw	ra,72(sp)
81141c80:	df001115 	stw	fp,68(sp)
81141c84:	df001104 	addi	fp,sp,68
81141c88:	e13ffc15 	stw	r4,-16(fp)
81141c8c:	e17ffd15 	stw	r5,-12(fp)
81141c90:	e1bffe15 	stw	r6,-8(fp)
81141c94:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81141c98:	e0bffd17 	ldw	r2,-12(fp)
81141c9c:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81141ca0:	e0bffc17 	ldw	r2,-16(fp)
81141ca4:	10800a17 	ldw	r2,40(r2)
81141ca8:	e0bff815 	stw	r2,-32(fp)
81141cac:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81141cb0:	e0bff90b 	ldhu	r2,-28(fp)
81141cb4:	e0fffb04 	addi	r3,fp,-20
81141cb8:	180d883a 	mov	r6,r3
81141cbc:	100b883a 	mov	r5,r2
81141cc0:	e13ff817 	ldw	r4,-32(fp)
81141cc4:	1139b780 	call	81139b78 <OSSemPend>

  while (space > 0)
81141cc8:	00006106 	br	81141e50 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81141ccc:	e0bffc17 	ldw	r2,-16(fp)
81141cd0:	10800d17 	ldw	r2,52(r2)
81141cd4:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81141cd8:	e0bffc17 	ldw	r2,-16(fp)
81141cdc:	10800e17 	ldw	r2,56(r2)
81141ce0:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81141ce4:	e0fff317 	ldw	r3,-52(fp)
81141ce8:	e0bff417 	ldw	r2,-48(fp)
81141cec:	18800536 	bltu	r3,r2,81141d04 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81141cf0:	e0fff317 	ldw	r3,-52(fp)
81141cf4:	e0bff417 	ldw	r2,-48(fp)
81141cf8:	1885c83a 	sub	r2,r3,r2
81141cfc:	e0bff115 	stw	r2,-60(fp)
81141d00:	00000406 	br	81141d14 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81141d04:	00c20004 	movi	r3,2048
81141d08:	e0bff417 	ldw	r2,-48(fp)
81141d0c:	1885c83a 	sub	r2,r3,r2
81141d10:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81141d14:	e0bff117 	ldw	r2,-60(fp)
81141d18:	10001e26 	beq	r2,zero,81141d94 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81141d1c:	e0fffe17 	ldw	r3,-8(fp)
81141d20:	e0bff117 	ldw	r2,-60(fp)
81141d24:	1880022e 	bgeu	r3,r2,81141d30 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81141d28:	e0bffe17 	ldw	r2,-8(fp)
81141d2c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81141d30:	e0bffc17 	ldw	r2,-16(fp)
81141d34:	10c01104 	addi	r3,r2,68
81141d38:	e0bff417 	ldw	r2,-48(fp)
81141d3c:	1885883a 	add	r2,r3,r2
81141d40:	e1bff117 	ldw	r6,-60(fp)
81141d44:	100b883a 	mov	r5,r2
81141d48:	e13ff017 	ldw	r4,-64(fp)
81141d4c:	111cb4c0 	call	8111cb4c <memcpy>
      ptr   += n;
81141d50:	e0fff017 	ldw	r3,-64(fp)
81141d54:	e0bff117 	ldw	r2,-60(fp)
81141d58:	1885883a 	add	r2,r3,r2
81141d5c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81141d60:	e0fffe17 	ldw	r3,-8(fp)
81141d64:	e0bff117 	ldw	r2,-60(fp)
81141d68:	1885c83a 	sub	r2,r3,r2
81141d6c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81141d70:	e0fff417 	ldw	r3,-48(fp)
81141d74:	e0bff117 	ldw	r2,-60(fp)
81141d78:	1885883a 	add	r2,r3,r2
81141d7c:	10c1ffcc 	andi	r3,r2,2047
81141d80:	e0bffc17 	ldw	r2,-16(fp)
81141d84:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81141d88:	e0bffe17 	ldw	r2,-8(fp)
81141d8c:	00bfcf16 	blt	zero,r2,81141ccc <__reset+0xfb121ccc>
81141d90:	00000106 	br	81141d98 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81141d94:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81141d98:	e0fff017 	ldw	r3,-64(fp)
81141d9c:	e0bffd17 	ldw	r2,-12(fp)
81141da0:	18802e1e 	bne	r3,r2,81141e5c <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81141da4:	e0bfff17 	ldw	r2,-4(fp)
81141da8:	1090000c 	andi	r2,r2,16384
81141dac:	10002d1e 	bne	r2,zero,81141e64 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81141db0:	d0a08b03 	ldbu	r2,-32212(gp)
81141db4:	10803fcc 	andi	r2,r2,255
81141db8:	10800058 	cmpnei	r2,r2,1
81141dbc:	1000161e 	bne	r2,zero,81141e18 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81141dc0:	e0bffc17 	ldw	r2,-16(fp)
81141dc4:	10800c17 	ldw	r2,48(r2)
81141dc8:	e0bff215 	stw	r2,-56(fp)
81141dcc:	00800144 	movi	r2,5
81141dd0:	e0bff98d 	sth	r2,-26(fp)
81141dd4:	00bfe0c4 	movi	r2,-125
81141dd8:	e0bffa05 	stb	r2,-24(fp)
81141ddc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81141de0:	d0a08b03 	ldbu	r2,-32212(gp)
81141de4:	10803fcc 	andi	r2,r2,255
81141de8:	10001526 	beq	r2,zero,81141e40 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81141dec:	e0fff98b 	ldhu	r3,-26(fp)
81141df0:	e13ffa03 	ldbu	r4,-24(fp)
81141df4:	e17ffa8b 	ldhu	r5,-22(fp)
81141df8:	e0bffb44 	addi	r2,fp,-19
81141dfc:	d8800015 	stw	r2,0(sp)
81141e00:	280f883a 	mov	r7,r5
81141e04:	200d883a 	mov	r6,r4
81141e08:	180b883a 	mov	r5,r3
81141e0c:	e13ff217 	ldw	r4,-56(fp)
81141e10:	1135ed80 	call	81135ed8 <OSFlagPend>
81141e14:	00000a06 	br	81141e40 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81141e18:	0001883a 	nop
81141e1c:	e0bffc17 	ldw	r2,-16(fp)
81141e20:	10c00d17 	ldw	r3,52(r2)
81141e24:	e0bff317 	ldw	r2,-52(fp)
81141e28:	1880051e 	bne	r3,r2,81141e40 <altera_avalon_jtag_uart_read+0x1d0>
81141e2c:	e0bffc17 	ldw	r2,-16(fp)
81141e30:	10c00917 	ldw	r3,36(r2)
81141e34:	e0bffc17 	ldw	r2,-16(fp)
81141e38:	10800117 	ldw	r2,4(r2)
81141e3c:	18bff736 	bltu	r3,r2,81141e1c <__reset+0xfb121e1c>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81141e40:	e0bffc17 	ldw	r2,-16(fp)
81141e44:	10c00d17 	ldw	r3,52(r2)
81141e48:	e0bff317 	ldw	r2,-52(fp)
81141e4c:	18800726 	beq	r3,r2,81141e6c <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81141e50:	e0bffe17 	ldw	r2,-8(fp)
81141e54:	00bf9d16 	blt	zero,r2,81141ccc <__reset+0xfb121ccc>
81141e58:	00000506 	br	81141e70 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81141e5c:	0001883a 	nop
81141e60:	00000306 	br	81141e70 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81141e64:	0001883a 	nop
81141e68:	00000106 	br	81141e70 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81141e6c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81141e70:	e0bffc17 	ldw	r2,-16(fp)
81141e74:	10800a17 	ldw	r2,40(r2)
81141e78:	1009883a 	mov	r4,r2
81141e7c:	1139f000 	call	81139f00 <OSSemPost>

  if (ptr != buffer)
81141e80:	e0fff017 	ldw	r3,-64(fp)
81141e84:	e0bffd17 	ldw	r2,-12(fp)
81141e88:	18801826 	beq	r3,r2,81141eec <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141e8c:	0005303a 	rdctl	r2,status
81141e90:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141e94:	e0fff717 	ldw	r3,-36(fp)
81141e98:	00bfff84 	movi	r2,-2
81141e9c:	1884703a 	and	r2,r3,r2
81141ea0:	1001703a 	wrctl	status,r2
  
  return context;
81141ea4:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81141ea8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81141eac:	e0bffc17 	ldw	r2,-16(fp)
81141eb0:	10800817 	ldw	r2,32(r2)
81141eb4:	10c00054 	ori	r3,r2,1
81141eb8:	e0bffc17 	ldw	r2,-16(fp)
81141ebc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81141ec0:	e0bffc17 	ldw	r2,-16(fp)
81141ec4:	10800017 	ldw	r2,0(r2)
81141ec8:	10800104 	addi	r2,r2,4
81141ecc:	1007883a 	mov	r3,r2
81141ed0:	e0bffc17 	ldw	r2,-16(fp)
81141ed4:	10800817 	ldw	r2,32(r2)
81141ed8:	18800035 	stwio	r2,0(r3)
81141edc:	e0bff617 	ldw	r2,-40(fp)
81141ee0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141ee4:	e0bff517 	ldw	r2,-44(fp)
81141ee8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81141eec:	e0fff017 	ldw	r3,-64(fp)
81141ef0:	e0bffd17 	ldw	r2,-12(fp)
81141ef4:	18800426 	beq	r3,r2,81141f08 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81141ef8:	e0fff017 	ldw	r3,-64(fp)
81141efc:	e0bffd17 	ldw	r2,-12(fp)
81141f00:	1885c83a 	sub	r2,r3,r2
81141f04:	00000606 	br	81141f20 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81141f08:	e0bfff17 	ldw	r2,-4(fp)
81141f0c:	1090000c 	andi	r2,r2,16384
81141f10:	10000226 	beq	r2,zero,81141f1c <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81141f14:	00bffd44 	movi	r2,-11
81141f18:	00000106 	br	81141f20 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81141f1c:	00bffec4 	movi	r2,-5
}
81141f20:	e037883a 	mov	sp,fp
81141f24:	dfc00117 	ldw	ra,4(sp)
81141f28:	df000017 	ldw	fp,0(sp)
81141f2c:	dec00204 	addi	sp,sp,8
81141f30:	f800283a 	ret

81141f34 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81141f34:	deffed04 	addi	sp,sp,-76
81141f38:	de00012e 	bgeu	sp,et,81141f40 <altera_avalon_jtag_uart_write+0xc>
81141f3c:	003b68fa 	trap	3
81141f40:	dfc01215 	stw	ra,72(sp)
81141f44:	df001115 	stw	fp,68(sp)
81141f48:	df001104 	addi	fp,sp,68
81141f4c:	e13ffc15 	stw	r4,-16(fp)
81141f50:	e17ffd15 	stw	r5,-12(fp)
81141f54:	e1bffe15 	stw	r6,-8(fp)
81141f58:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81141f5c:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81141f60:	e0bffd17 	ldw	r2,-12(fp)
81141f64:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81141f68:	e0bffc17 	ldw	r2,-16(fp)
81141f6c:	10800b17 	ldw	r2,44(r2)
81141f70:	e0bff815 	stw	r2,-32(fp)
81141f74:	e03ff90d 	sth	zero,-28(fp)
81141f78:	e0bff90b 	ldhu	r2,-28(fp)
81141f7c:	e0fffb44 	addi	r3,fp,-19
81141f80:	180d883a 	mov	r6,r3
81141f84:	100b883a 	mov	r5,r2
81141f88:	e13ff817 	ldw	r4,-32(fp)
81141f8c:	1139b780 	call	81139b78 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81141f90:	00003706 	br	81142070 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81141f94:	e0bffc17 	ldw	r2,-16(fp)
81141f98:	10800f17 	ldw	r2,60(r2)
81141f9c:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81141fa0:	e0bffc17 	ldw	r2,-16(fp)
81141fa4:	10801017 	ldw	r2,64(r2)
81141fa8:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81141fac:	e0fff417 	ldw	r3,-48(fp)
81141fb0:	e0bff017 	ldw	r2,-64(fp)
81141fb4:	1880062e 	bgeu	r3,r2,81141fd0 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81141fb8:	e0fff017 	ldw	r3,-64(fp)
81141fbc:	e0bff417 	ldw	r2,-48(fp)
81141fc0:	1885c83a 	sub	r2,r3,r2
81141fc4:	10bfffc4 	addi	r2,r2,-1
81141fc8:	e0bff115 	stw	r2,-60(fp)
81141fcc:	00000b06 	br	81141ffc <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81141fd0:	e0bff017 	ldw	r2,-64(fp)
81141fd4:	10000526 	beq	r2,zero,81141fec <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81141fd8:	00c20004 	movi	r3,2048
81141fdc:	e0bff417 	ldw	r2,-48(fp)
81141fe0:	1885c83a 	sub	r2,r3,r2
81141fe4:	e0bff115 	stw	r2,-60(fp)
81141fe8:	00000406 	br	81141ffc <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81141fec:	00c1ffc4 	movi	r3,2047
81141ff0:	e0bff417 	ldw	r2,-48(fp)
81141ff4:	1885c83a 	sub	r2,r3,r2
81141ff8:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81141ffc:	e0bff117 	ldw	r2,-60(fp)
81142000:	10001e26 	beq	r2,zero,8114207c <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81142004:	e0fffe17 	ldw	r3,-8(fp)
81142008:	e0bff117 	ldw	r2,-60(fp)
8114200c:	1880022e 	bgeu	r3,r2,81142018 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81142010:	e0bffe17 	ldw	r2,-8(fp)
81142014:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81142018:	e0bffc17 	ldw	r2,-16(fp)
8114201c:	10c21104 	addi	r3,r2,2116
81142020:	e0bff417 	ldw	r2,-48(fp)
81142024:	1885883a 	add	r2,r3,r2
81142028:	e1bff117 	ldw	r6,-60(fp)
8114202c:	e17ffd17 	ldw	r5,-12(fp)
81142030:	1009883a 	mov	r4,r2
81142034:	111cb4c0 	call	8111cb4c <memcpy>
      ptr   += n;
81142038:	e0fffd17 	ldw	r3,-12(fp)
8114203c:	e0bff117 	ldw	r2,-60(fp)
81142040:	1885883a 	add	r2,r3,r2
81142044:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81142048:	e0fffe17 	ldw	r3,-8(fp)
8114204c:	e0bff117 	ldw	r2,-60(fp)
81142050:	1885c83a 	sub	r2,r3,r2
81142054:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81142058:	e0fff417 	ldw	r3,-48(fp)
8114205c:	e0bff117 	ldw	r2,-60(fp)
81142060:	1885883a 	add	r2,r3,r2
81142064:	10c1ffcc 	andi	r3,r2,2047
81142068:	e0bffc17 	ldw	r2,-16(fp)
8114206c:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81142070:	e0bffe17 	ldw	r2,-8(fp)
81142074:	00bfc716 	blt	zero,r2,81141f94 <__reset+0xfb121f94>
81142078:	00000106 	br	81142080 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
8114207c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142080:	0005303a 	rdctl	r2,status
81142084:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142088:	e0fff717 	ldw	r3,-36(fp)
8114208c:	00bfff84 	movi	r2,-2
81142090:	1884703a 	and	r2,r3,r2
81142094:	1001703a 	wrctl	status,r2
  
  return context;
81142098:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
8114209c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811420a0:	e0bffc17 	ldw	r2,-16(fp)
811420a4:	10800817 	ldw	r2,32(r2)
811420a8:	10c00094 	ori	r3,r2,2
811420ac:	e0bffc17 	ldw	r2,-16(fp)
811420b0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811420b4:	e0bffc17 	ldw	r2,-16(fp)
811420b8:	10800017 	ldw	r2,0(r2)
811420bc:	10800104 	addi	r2,r2,4
811420c0:	1007883a 	mov	r3,r2
811420c4:	e0bffc17 	ldw	r2,-16(fp)
811420c8:	10800817 	ldw	r2,32(r2)
811420cc:	18800035 	stwio	r2,0(r3)
811420d0:	e0bff617 	ldw	r2,-40(fp)
811420d4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811420d8:	e0bff317 	ldw	r2,-52(fp)
811420dc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
811420e0:	e0bffe17 	ldw	r2,-8(fp)
811420e4:	00802a0e 	bge	zero,r2,81142190 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
811420e8:	e0bfff17 	ldw	r2,-4(fp)
811420ec:	1090000c 	andi	r2,r2,16384
811420f0:	10002a1e 	bne	r2,zero,8114219c <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
811420f4:	d0a08b03 	ldbu	r2,-32212(gp)
811420f8:	10803fcc 	andi	r2,r2,255
811420fc:	10800058 	cmpnei	r2,r2,1
81142100:	1000161e 	bne	r2,zero,8114215c <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81142104:	e0bffc17 	ldw	r2,-16(fp)
81142108:	10800c17 	ldw	r2,48(r2)
8114210c:	e0bff515 	stw	r2,-44(fp)
81142110:	00800184 	movi	r2,6
81142114:	e0bff98d 	sth	r2,-26(fp)
81142118:	00bfe0c4 	movi	r2,-125
8114211c:	e0bffa05 	stb	r2,-24(fp)
81142120:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142124:	d0a08b03 	ldbu	r2,-32212(gp)
81142128:	10803fcc 	andi	r2,r2,255
8114212c:	10001526 	beq	r2,zero,81142184 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142130:	e0fff98b 	ldhu	r3,-26(fp)
81142134:	e13ffa03 	ldbu	r4,-24(fp)
81142138:	e17ffa8b 	ldhu	r5,-22(fp)
8114213c:	e0bffb04 	addi	r2,fp,-20
81142140:	d8800015 	stw	r2,0(sp)
81142144:	280f883a 	mov	r7,r5
81142148:	200d883a 	mov	r6,r4
8114214c:	180b883a 	mov	r5,r3
81142150:	e13ff517 	ldw	r4,-44(fp)
81142154:	1135ed80 	call	81135ed8 <OSFlagPend>
81142158:	00000a06 	br	81142184 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
8114215c:	0001883a 	nop
81142160:	e0bffc17 	ldw	r2,-16(fp)
81142164:	10c01017 	ldw	r3,64(r2)
81142168:	e0bff017 	ldw	r2,-64(fp)
8114216c:	1880051e 	bne	r3,r2,81142184 <altera_avalon_jtag_uart_write+0x250>
81142170:	e0bffc17 	ldw	r2,-16(fp)
81142174:	10c00917 	ldw	r3,36(r2)
81142178:	e0bffc17 	ldw	r2,-16(fp)
8114217c:	10800117 	ldw	r2,4(r2)
81142180:	18bff736 	bltu	r3,r2,81142160 <__reset+0xfb122160>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81142184:	e0bffc17 	ldw	r2,-16(fp)
81142188:	10800917 	ldw	r2,36(r2)
8114218c:	1000051e 	bne	r2,zero,811421a4 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81142190:	e0bffe17 	ldw	r2,-8(fp)
81142194:	00bfb616 	blt	zero,r2,81142070 <__reset+0xfb122070>
81142198:	00000306 	br	811421a8 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
8114219c:	0001883a 	nop
811421a0:	00000106 	br	811421a8 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811421a4:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811421a8:	e0bffc17 	ldw	r2,-16(fp)
811421ac:	10800b17 	ldw	r2,44(r2)
811421b0:	1009883a 	mov	r4,r2
811421b4:	1139f000 	call	81139f00 <OSSemPost>

  if (ptr != start)
811421b8:	e0fffd17 	ldw	r3,-12(fp)
811421bc:	e0bff217 	ldw	r2,-56(fp)
811421c0:	18800426 	beq	r3,r2,811421d4 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
811421c4:	e0fffd17 	ldw	r3,-12(fp)
811421c8:	e0bff217 	ldw	r2,-56(fp)
811421cc:	1885c83a 	sub	r2,r3,r2
811421d0:	00000606 	br	811421ec <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
811421d4:	e0bfff17 	ldw	r2,-4(fp)
811421d8:	1090000c 	andi	r2,r2,16384
811421dc:	10000226 	beq	r2,zero,811421e8 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
811421e0:	00bffd44 	movi	r2,-11
811421e4:	00000106 	br	811421ec <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
811421e8:	00bffec4 	movi	r2,-5
}
811421ec:	e037883a 	mov	sp,fp
811421f0:	dfc00117 	ldw	ra,4(sp)
811421f4:	df000017 	ldw	fp,0(sp)
811421f8:	dec00204 	addi	sp,sp,8
811421fc:	f800283a 	ret

81142200 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81142200:	defffa04 	addi	sp,sp,-24
81142204:	de00012e 	bgeu	sp,et,8114220c <alt_avalon_timer_sc_irq+0xc>
81142208:	003b68fa 	trap	3
8114220c:	dfc00515 	stw	ra,20(sp)
81142210:	df000415 	stw	fp,16(sp)
81142214:	df000404 	addi	fp,sp,16
81142218:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8114221c:	0007883a 	mov	r3,zero
81142220:	e0bfff17 	ldw	r2,-4(fp)
81142224:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81142228:	e0bfff17 	ldw	r2,-4(fp)
8114222c:	10800104 	addi	r2,r2,4
81142230:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81142234:	11323b40 	call	811323b4 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142238:	0005303a 	rdctl	r2,status
8114223c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142240:	e0fffd17 	ldw	r3,-12(fp)
81142244:	00bfff84 	movi	r2,-2
81142248:	1884703a 	and	r2,r3,r2
8114224c:	1001703a 	wrctl	status,r2
  
  return context;
81142250:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81142254:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81142258:	1132c640 	call	81132c64 <alt_tick>
8114225c:	e0bffc17 	ldw	r2,-16(fp)
81142260:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142264:	e0bffe17 	ldw	r2,-8(fp)
81142268:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8114226c:	0001883a 	nop
81142270:	e037883a 	mov	sp,fp
81142274:	dfc00117 	ldw	ra,4(sp)
81142278:	df000017 	ldw	fp,0(sp)
8114227c:	dec00204 	addi	sp,sp,8
81142280:	f800283a 	ret

81142284 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81142284:	defff804 	addi	sp,sp,-32
81142288:	de00012e 	bgeu	sp,et,81142290 <alt_avalon_timer_sc_init+0xc>
8114228c:	003b68fa 	trap	3
81142290:	dfc00715 	stw	ra,28(sp)
81142294:	df000615 	stw	fp,24(sp)
81142298:	df000604 	addi	fp,sp,24
8114229c:	e13ffc15 	stw	r4,-16(fp)
811422a0:	e17ffd15 	stw	r5,-12(fp)
811422a4:	e1bffe15 	stw	r6,-8(fp)
811422a8:	e1ffff15 	stw	r7,-4(fp)
811422ac:	e0bfff17 	ldw	r2,-4(fp)
811422b0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
811422b4:	d0a08217 	ldw	r2,-32248(gp)
811422b8:	1000021e 	bne	r2,zero,811422c4 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
811422bc:	e0bffb17 	ldw	r2,-20(fp)
811422c0:	d0a08215 	stw	r2,-32248(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
811422c4:	e0bffc17 	ldw	r2,-16(fp)
811422c8:	10800104 	addi	r2,r2,4
811422cc:	00c001c4 	movi	r3,7
811422d0:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
811422d4:	d8000015 	stw	zero,0(sp)
811422d8:	e1fffc17 	ldw	r7,-16(fp)
811422dc:	01a04534 	movhi	r6,33044
811422e0:	31888004 	addi	r6,r6,8704
811422e4:	e17ffe17 	ldw	r5,-8(fp)
811422e8:	e13ffd17 	ldw	r4,-12(fp)
811422ec:	11454880 	call	81145488 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
811422f0:	0001883a 	nop
811422f4:	e037883a 	mov	sp,fp
811422f8:	dfc00117 	ldw	ra,4(sp)
811422fc:	df000017 	ldw	fp,0(sp)
81142300:	dec00204 	addi	sp,sp,8
81142304:	f800283a 	ret

81142308 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81142308:	defffa04 	addi	sp,sp,-24
8114230c:	de00012e 	bgeu	sp,et,81142314 <altera_avalon_uart_read_fd+0xc>
81142310:	003b68fa 	trap	3
81142314:	dfc00515 	stw	ra,20(sp)
81142318:	df000415 	stw	fp,16(sp)
8114231c:	df000404 	addi	fp,sp,16
81142320:	e13ffd15 	stw	r4,-12(fp)
81142324:	e17ffe15 	stw	r5,-8(fp)
81142328:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114232c:	e0bffd17 	ldw	r2,-12(fp)
81142330:	10800017 	ldw	r2,0(r2)
81142334:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81142338:	e0bffc17 	ldw	r2,-16(fp)
8114233c:	10c00a04 	addi	r3,r2,40
81142340:	e0bffd17 	ldw	r2,-12(fp)
81142344:	10800217 	ldw	r2,8(r2)
81142348:	100f883a 	mov	r7,r2
8114234c:	e1bfff17 	ldw	r6,-4(fp)
81142350:	e17ffe17 	ldw	r5,-8(fp)
81142354:	1809883a 	mov	r4,r3
81142358:	11429c80 	call	811429c8 <altera_avalon_uart_read>
      fd->fd_flags);
}
8114235c:	e037883a 	mov	sp,fp
81142360:	dfc00117 	ldw	ra,4(sp)
81142364:	df000017 	ldw	fp,0(sp)
81142368:	dec00204 	addi	sp,sp,8
8114236c:	f800283a 	ret

81142370 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81142370:	defffa04 	addi	sp,sp,-24
81142374:	de00012e 	bgeu	sp,et,8114237c <altera_avalon_uart_write_fd+0xc>
81142378:	003b68fa 	trap	3
8114237c:	dfc00515 	stw	ra,20(sp)
81142380:	df000415 	stw	fp,16(sp)
81142384:	df000404 	addi	fp,sp,16
81142388:	e13ffd15 	stw	r4,-12(fp)
8114238c:	e17ffe15 	stw	r5,-8(fp)
81142390:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81142394:	e0bffd17 	ldw	r2,-12(fp)
81142398:	10800017 	ldw	r2,0(r2)
8114239c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811423a0:	e0bffc17 	ldw	r2,-16(fp)
811423a4:	10c00a04 	addi	r3,r2,40
811423a8:	e0bffd17 	ldw	r2,-12(fp)
811423ac:	10800217 	ldw	r2,8(r2)
811423b0:	100f883a 	mov	r7,r2
811423b4:	e1bfff17 	ldw	r6,-4(fp)
811423b8:	e17ffe17 	ldw	r5,-8(fp)
811423bc:	1809883a 	mov	r4,r3
811423c0:	1142c7c0 	call	81142c7c <altera_avalon_uart_write>
      fd->fd_flags);
}
811423c4:	e037883a 	mov	sp,fp
811423c8:	dfc00117 	ldw	ra,4(sp)
811423cc:	df000017 	ldw	fp,0(sp)
811423d0:	dec00204 	addi	sp,sp,8
811423d4:	f800283a 	ret

811423d8 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
811423d8:	defffc04 	addi	sp,sp,-16
811423dc:	de00012e 	bgeu	sp,et,811423e4 <altera_avalon_uart_close_fd+0xc>
811423e0:	003b68fa 	trap	3
811423e4:	dfc00315 	stw	ra,12(sp)
811423e8:	df000215 	stw	fp,8(sp)
811423ec:	df000204 	addi	fp,sp,8
811423f0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811423f4:	e0bfff17 	ldw	r2,-4(fp)
811423f8:	10800017 	ldw	r2,0(r2)
811423fc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81142400:	e0bffe17 	ldw	r2,-8(fp)
81142404:	10c00a04 	addi	r3,r2,40
81142408:	e0bfff17 	ldw	r2,-4(fp)
8114240c:	10800217 	ldw	r2,8(r2)
81142410:	100b883a 	mov	r5,r2
81142414:	1809883a 	mov	r4,r3
81142418:	11429280 	call	81142928 <altera_avalon_uart_close>
}
8114241c:	e037883a 	mov	sp,fp
81142420:	dfc00117 	ldw	ra,4(sp)
81142424:	df000017 	ldw	fp,0(sp)
81142428:	dec00204 	addi	sp,sp,8
8114242c:	f800283a 	ret

81142430 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81142430:	defff304 	addi	sp,sp,-52
81142434:	de00012e 	bgeu	sp,et,8114243c <altera_avalon_uart_init+0xc>
81142438:	003b68fa 	trap	3
8114243c:	dfc00c15 	stw	ra,48(sp)
81142440:	df000b15 	stw	fp,44(sp)
81142444:	df000b04 	addi	fp,sp,44
81142448:	e13ffd15 	stw	r4,-12(fp)
8114244c:	e17ffe15 	stw	r5,-8(fp)
81142450:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81142454:	e0bffd17 	ldw	r2,-12(fp)
81142458:	10800017 	ldw	r2,0(r2)
8114245c:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81142460:	e0bffd17 	ldw	r2,-12(fp)
81142464:	10800704 	addi	r2,r2,28
81142468:	e0bffa15 	stw	r2,-24(fp)
8114246c:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81142470:	e0bffb0b 	ldhu	r2,-20(fp)
81142474:	e0fffc84 	addi	r3,fp,-14
81142478:	180b883a 	mov	r5,r3
8114247c:	1009883a 	mov	r4,r2
81142480:	11358f40 	call	811358f4 <OSFlagCreate>
81142484:	1007883a 	mov	r3,r2
81142488:	e0bffa17 	ldw	r2,-24(fp)
8114248c:	10c00015 	stw	r3,0(r2)
  return err;
81142490:	e0bffc83 	ldbu	r2,-14(fp)
81142494:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81142498:	1000241e 	bne	r2,zero,8114252c <altera_avalon_uart_init+0xfc>
8114249c:	e0bffd17 	ldw	r2,-12(fp)
811424a0:	10800804 	addi	r2,r2,32
811424a4:	e0bff715 	stw	r2,-36(fp)
811424a8:	00800044 	movi	r2,1
811424ac:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811424b0:	e0bffb8b 	ldhu	r2,-18(fp)
811424b4:	1009883a 	mov	r4,r2
811424b8:	11398500 	call	81139850 <OSSemCreate>
811424bc:	1007883a 	mov	r3,r2
811424c0:	e0bff717 	ldw	r2,-36(fp)
811424c4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811424c8:	e0bff717 	ldw	r2,-36(fp)
811424cc:	10800017 	ldw	r2,0(r2)
811424d0:	10000226 	beq	r2,zero,811424dc <altera_avalon_uart_init+0xac>
811424d4:	0005883a 	mov	r2,zero
811424d8:	00000106 	br	811424e0 <altera_avalon_uart_init+0xb0>
811424dc:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811424e0:	1000121e 	bne	r2,zero,8114252c <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
811424e4:	e0bffd17 	ldw	r2,-12(fp)
811424e8:	10800904 	addi	r2,r2,36
811424ec:	e0bff815 	stw	r2,-32(fp)
811424f0:	00800044 	movi	r2,1
811424f4:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811424f8:	e0bffc0b 	ldhu	r2,-16(fp)
811424fc:	1009883a 	mov	r4,r2
81142500:	11398500 	call	81139850 <OSSemCreate>
81142504:	1007883a 	mov	r3,r2
81142508:	e0bff817 	ldw	r2,-32(fp)
8114250c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81142510:	e0bff817 	ldw	r2,-32(fp)
81142514:	10800017 	ldw	r2,0(r2)
81142518:	10000226 	beq	r2,zero,81142524 <altera_avalon_uart_init+0xf4>
8114251c:	0005883a 	mov	r2,zero
81142520:	00000106 	br	81142528 <altera_avalon_uart_init+0xf8>
81142524:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81142528:	10000226 	beq	r2,zero,81142534 <altera_avalon_uart_init+0x104>
8114252c:	00800044 	movi	r2,1
81142530:	00000106 	br	81142538 <altera_avalon_uart_init+0x108>
81142534:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81142538:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
8114253c:	e0bff917 	ldw	r2,-28(fp)
81142540:	10000f1e 	bne	r2,zero,81142580 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81142544:	e0bffd17 	ldw	r2,-12(fp)
81142548:	00c32004 	movi	r3,3200
8114254c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81142550:	e0bff617 	ldw	r2,-40(fp)
81142554:	10800304 	addi	r2,r2,12
81142558:	e0fffd17 	ldw	r3,-12(fp)
8114255c:	18c00117 	ldw	r3,4(r3)
81142560:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81142564:	d8000015 	stw	zero,0(sp)
81142568:	e1fffd17 	ldw	r7,-12(fp)
8114256c:	01a04534 	movhi	r6,33044
81142570:	31896604 	addi	r6,r6,9624
81142574:	e17fff17 	ldw	r5,-4(fp)
81142578:	e13ffe17 	ldw	r4,-8(fp)
8114257c:	11454880 	call	81145488 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81142580:	0001883a 	nop
81142584:	e037883a 	mov	sp,fp
81142588:	dfc00117 	ldw	ra,4(sp)
8114258c:	df000017 	ldw	fp,0(sp)
81142590:	dec00204 	addi	sp,sp,8
81142594:	f800283a 	ret

81142598 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
81142598:	defffa04 	addi	sp,sp,-24
8114259c:	de00012e 	bgeu	sp,et,811425a4 <altera_avalon_uart_irq+0xc>
811425a0:	003b68fa 	trap	3
811425a4:	dfc00515 	stw	ra,20(sp)
811425a8:	df000415 	stw	fp,16(sp)
811425ac:	df000404 	addi	fp,sp,16
811425b0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811425b4:	e0bfff17 	ldw	r2,-4(fp)
811425b8:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811425bc:	e0bffc17 	ldw	r2,-16(fp)
811425c0:	10800017 	ldw	r2,0(r2)
811425c4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811425c8:	e0bffd17 	ldw	r2,-12(fp)
811425cc:	10800204 	addi	r2,r2,8
811425d0:	10800037 	ldwio	r2,0(r2)
811425d4:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
811425d8:	e0bffd17 	ldw	r2,-12(fp)
811425dc:	10800204 	addi	r2,r2,8
811425e0:	0007883a 	mov	r3,zero
811425e4:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811425e8:	e0bffd17 	ldw	r2,-12(fp)
811425ec:	10800204 	addi	r2,r2,8
811425f0:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
811425f4:	e0bffe17 	ldw	r2,-8(fp)
811425f8:	1080200c 	andi	r2,r2,128
811425fc:	10000326 	beq	r2,zero,8114260c <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81142600:	e17ffe17 	ldw	r5,-8(fp)
81142604:	e13ffc17 	ldw	r4,-16(fp)
81142608:	114263c0 	call	8114263c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
8114260c:	e0bffe17 	ldw	r2,-8(fp)
81142610:	1081100c 	andi	r2,r2,1088
81142614:	10000326 	beq	r2,zero,81142624 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81142618:	e17ffe17 	ldw	r5,-8(fp)
8114261c:	e13ffc17 	ldw	r4,-16(fp)
81142620:	114277c0 	call	8114277c <altera_avalon_uart_txirq>
  }
  

}
81142624:	0001883a 	nop
81142628:	e037883a 	mov	sp,fp
8114262c:	dfc00117 	ldw	ra,4(sp)
81142630:	df000017 	ldw	fp,0(sp)
81142634:	dec00204 	addi	sp,sp,8
81142638:	f800283a 	ret

8114263c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8114263c:	defff904 	addi	sp,sp,-28
81142640:	de00012e 	bgeu	sp,et,81142648 <altera_avalon_uart_rxirq+0xc>
81142644:	003b68fa 	trap	3
81142648:	dfc00615 	stw	ra,24(sp)
8114264c:	df000515 	stw	fp,20(sp)
81142650:	df000504 	addi	fp,sp,20
81142654:	e13ffe15 	stw	r4,-8(fp)
81142658:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
8114265c:	e0bfff17 	ldw	r2,-4(fp)
81142660:	108000cc 	andi	r2,r2,3
81142664:	10003f1e 	bne	r2,zero,81142764 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81142668:	e0bffe17 	ldw	r2,-8(fp)
8114266c:	10c00317 	ldw	r3,12(r2)
81142670:	e0bffe17 	ldw	r2,-8(fp)
81142674:	10800217 	ldw	r2,8(r2)
81142678:	1880121e 	bne	r3,r2,811426c4 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
8114267c:	e0bffe17 	ldw	r2,-8(fp)
81142680:	10800717 	ldw	r2,28(r2)
81142684:	e0bffc15 	stw	r2,-16(fp)
81142688:	00800044 	movi	r2,1
8114268c:	e0bffd0d 	sth	r2,-12(fp)
81142690:	00800044 	movi	r2,1
81142694:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142698:	d0a08b03 	ldbu	r2,-32212(gp)
8114269c:	10803fcc 	andi	r2,r2,255
811426a0:	10000826 	beq	r2,zero,811426c4 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811426a4:	e0bffd0b 	ldhu	r2,-12(fp)
811426a8:	e0fffd83 	ldbu	r3,-10(fp)
811426ac:	e13ffdc4 	addi	r4,fp,-9
811426b0:	200f883a 	mov	r7,r4
811426b4:	180d883a 	mov	r6,r3
811426b8:	100b883a 	mov	r5,r2
811426bc:	e13ffc17 	ldw	r4,-16(fp)
811426c0:	11365000 	call	81136500 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811426c4:	e0bffe17 	ldw	r2,-8(fp)
811426c8:	10800317 	ldw	r2,12(r2)
811426cc:	10800044 	addi	r2,r2,1
811426d0:	10800fcc 	andi	r2,r2,63
811426d4:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
811426d8:	e0bffe17 	ldw	r2,-8(fp)
811426dc:	10800317 	ldw	r2,12(r2)
811426e0:	e0fffe17 	ldw	r3,-8(fp)
811426e4:	18c00017 	ldw	r3,0(r3)
811426e8:	18c00037 	ldwio	r3,0(r3)
811426ec:	1809883a 	mov	r4,r3
811426f0:	e0fffe17 	ldw	r3,-8(fp)
811426f4:	1885883a 	add	r2,r3,r2
811426f8:	10800a04 	addi	r2,r2,40
811426fc:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81142700:	e0bffe17 	ldw	r2,-8(fp)
81142704:	e0fffb17 	ldw	r3,-20(fp)
81142708:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8114270c:	e0bffe17 	ldw	r2,-8(fp)
81142710:	10800317 	ldw	r2,12(r2)
81142714:	10800044 	addi	r2,r2,1
81142718:	10800fcc 	andi	r2,r2,63
8114271c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81142720:	e0bffe17 	ldw	r2,-8(fp)
81142724:	10c00217 	ldw	r3,8(r2)
81142728:	e0bffb17 	ldw	r2,-20(fp)
8114272c:	18800e1e 	bne	r3,r2,81142768 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81142730:	e0bffe17 	ldw	r2,-8(fp)
81142734:	10c00117 	ldw	r3,4(r2)
81142738:	00bfdfc4 	movi	r2,-129
8114273c:	1886703a 	and	r3,r3,r2
81142740:	e0bffe17 	ldw	r2,-8(fp)
81142744:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81142748:	e0bffe17 	ldw	r2,-8(fp)
8114274c:	10800017 	ldw	r2,0(r2)
81142750:	10800304 	addi	r2,r2,12
81142754:	e0fffe17 	ldw	r3,-8(fp)
81142758:	18c00117 	ldw	r3,4(r3)
8114275c:	10c00035 	stwio	r3,0(r2)
81142760:	00000106 	br	81142768 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81142764:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81142768:	e037883a 	mov	sp,fp
8114276c:	dfc00117 	ldw	ra,4(sp)
81142770:	df000017 	ldw	fp,0(sp)
81142774:	dec00204 	addi	sp,sp,8
81142778:	f800283a 	ret

8114277c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8114277c:	defffa04 	addi	sp,sp,-24
81142780:	de00012e 	bgeu	sp,et,81142788 <altera_avalon_uart_txirq+0xc>
81142784:	003b68fa 	trap	3
81142788:	dfc00515 	stw	ra,20(sp)
8114278c:	df000415 	stw	fp,16(sp)
81142790:	df000404 	addi	fp,sp,16
81142794:	e13ffe15 	stw	r4,-8(fp)
81142798:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
8114279c:	e0bffe17 	ldw	r2,-8(fp)
811427a0:	10c00417 	ldw	r3,16(r2)
811427a4:	e0bffe17 	ldw	r2,-8(fp)
811427a8:	10800517 	ldw	r2,20(r2)
811427ac:	18804726 	beq	r3,r2,811428cc <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811427b0:	e0bffe17 	ldw	r2,-8(fp)
811427b4:	10800617 	ldw	r2,24(r2)
811427b8:	1080008c 	andi	r2,r2,2
811427bc:	10000326 	beq	r2,zero,811427cc <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811427c0:	e0bfff17 	ldw	r2,-4(fp)
811427c4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811427c8:	10003226 	beq	r2,zero,81142894 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
811427cc:	e0bffe17 	ldw	r2,-8(fp)
811427d0:	10c00417 	ldw	r3,16(r2)
811427d4:	e0bffe17 	ldw	r2,-8(fp)
811427d8:	10800517 	ldw	r2,20(r2)
811427dc:	10800044 	addi	r2,r2,1
811427e0:	10800fcc 	andi	r2,r2,63
811427e4:	1880121e 	bne	r3,r2,81142830 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
811427e8:	e0bffe17 	ldw	r2,-8(fp)
811427ec:	10800717 	ldw	r2,28(r2)
811427f0:	e0bffc15 	stw	r2,-16(fp)
811427f4:	00800084 	movi	r2,2
811427f8:	e0bffd0d 	sth	r2,-12(fp)
811427fc:	00800044 	movi	r2,1
81142800:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142804:	d0a08b03 	ldbu	r2,-32212(gp)
81142808:	10803fcc 	andi	r2,r2,255
8114280c:	10000826 	beq	r2,zero,81142830 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81142810:	e0bffd0b 	ldhu	r2,-12(fp)
81142814:	e0fffd83 	ldbu	r3,-10(fp)
81142818:	e13ffdc4 	addi	r4,fp,-9
8114281c:	200f883a 	mov	r7,r4
81142820:	180d883a 	mov	r6,r3
81142824:	100b883a 	mov	r5,r2
81142828:	e13ffc17 	ldw	r4,-16(fp)
8114282c:	11365000 	call	81136500 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81142830:	e0bffe17 	ldw	r2,-8(fp)
81142834:	10800017 	ldw	r2,0(r2)
81142838:	10800104 	addi	r2,r2,4
8114283c:	e0fffe17 	ldw	r3,-8(fp)
81142840:	18c00417 	ldw	r3,16(r3)
81142844:	e13ffe17 	ldw	r4,-8(fp)
81142848:	20c7883a 	add	r3,r4,r3
8114284c:	18c01a04 	addi	r3,r3,104
81142850:	18c00003 	ldbu	r3,0(r3)
81142854:	18c03fcc 	andi	r3,r3,255
81142858:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
8114285c:	e0bffe17 	ldw	r2,-8(fp)
81142860:	10800417 	ldw	r2,16(r2)
81142864:	10800044 	addi	r2,r2,1
81142868:	e0fffe17 	ldw	r3,-8(fp)
8114286c:	18800415 	stw	r2,16(r3)
81142870:	10c00fcc 	andi	r3,r2,63
81142874:	e0bffe17 	ldw	r2,-8(fp)
81142878:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
8114287c:	e0bffe17 	ldw	r2,-8(fp)
81142880:	10800117 	ldw	r2,4(r2)
81142884:	10c01014 	ori	r3,r2,64
81142888:	e0bffe17 	ldw	r2,-8(fp)
8114288c:	10c00115 	stw	r3,4(r2)
81142890:	00000e06 	br	811428cc <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81142894:	e0bffe17 	ldw	r2,-8(fp)
81142898:	10800017 	ldw	r2,0(r2)
8114289c:	10800204 	addi	r2,r2,8
811428a0:	10800037 	ldwio	r2,0(r2)
811428a4:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811428a8:	e0bfff17 	ldw	r2,-4(fp)
811428ac:	1082000c 	andi	r2,r2,2048
811428b0:	1000061e 	bne	r2,zero,811428cc <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811428b4:	e0bffe17 	ldw	r2,-8(fp)
811428b8:	10c00117 	ldw	r3,4(r2)
811428bc:	00bfefc4 	movi	r2,-65
811428c0:	1886703a 	and	r3,r3,r2
811428c4:	e0bffe17 	ldw	r2,-8(fp)
811428c8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
811428cc:	e0bffe17 	ldw	r2,-8(fp)
811428d0:	10c00417 	ldw	r3,16(r2)
811428d4:	e0bffe17 	ldw	r2,-8(fp)
811428d8:	10800517 	ldw	r2,20(r2)
811428dc:	1880061e 	bne	r3,r2,811428f8 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811428e0:	e0bffe17 	ldw	r2,-8(fp)
811428e4:	10c00117 	ldw	r3,4(r2)
811428e8:	00beefc4 	movi	r2,-1089
811428ec:	1886703a 	and	r3,r3,r2
811428f0:	e0bffe17 	ldw	r2,-8(fp)
811428f4:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811428f8:	e0bffe17 	ldw	r2,-8(fp)
811428fc:	10800017 	ldw	r2,0(r2)
81142900:	10800304 	addi	r2,r2,12
81142904:	e0fffe17 	ldw	r3,-8(fp)
81142908:	18c00117 	ldw	r3,4(r3)
8114290c:	10c00035 	stwio	r3,0(r2)
}
81142910:	0001883a 	nop
81142914:	e037883a 	mov	sp,fp
81142918:	dfc00117 	ldw	ra,4(sp)
8114291c:	df000017 	ldw	fp,0(sp)
81142920:	dec00204 	addi	sp,sp,8
81142924:	f800283a 	ret

81142928 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81142928:	defffd04 	addi	sp,sp,-12
8114292c:	de00012e 	bgeu	sp,et,81142934 <altera_avalon_uart_close+0xc>
81142930:	003b68fa 	trap	3
81142934:	df000215 	stw	fp,8(sp)
81142938:	df000204 	addi	fp,sp,8
8114293c:	e13ffe15 	stw	r4,-8(fp)
81142940:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81142944:	00000506 	br	8114295c <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81142948:	e0bfff17 	ldw	r2,-4(fp)
8114294c:	1090000c 	andi	r2,r2,16384
81142950:	10000226 	beq	r2,zero,8114295c <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81142954:	00bffd44 	movi	r2,-11
81142958:	00000606 	br	81142974 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
8114295c:	e0bffe17 	ldw	r2,-8(fp)
81142960:	10c00417 	ldw	r3,16(r2)
81142964:	e0bffe17 	ldw	r2,-8(fp)
81142968:	10800517 	ldw	r2,20(r2)
8114296c:	18bff61e 	bne	r3,r2,81142948 <__reset+0xfb122948>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81142970:	0005883a 	mov	r2,zero
}
81142974:	e037883a 	mov	sp,fp
81142978:	df000017 	ldw	fp,0(sp)
8114297c:	dec00104 	addi	sp,sp,4
81142980:	f800283a 	ret

81142984 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81142984:	defffe04 	addi	sp,sp,-8
81142988:	de00012e 	bgeu	sp,et,81142990 <alt_get_errno+0xc>
8114298c:	003b68fa 	trap	3
81142990:	dfc00115 	stw	ra,4(sp)
81142994:	df000015 	stw	fp,0(sp)
81142998:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8114299c:	d0a01017 	ldw	r2,-32704(gp)
811429a0:	10000326 	beq	r2,zero,811429b0 <alt_get_errno+0x2c>
811429a4:	d0a01017 	ldw	r2,-32704(gp)
811429a8:	103ee83a 	callr	r2
811429ac:	00000106 	br	811429b4 <alt_get_errno+0x30>
811429b0:	d0a07204 	addi	r2,gp,-32312
}
811429b4:	e037883a 	mov	sp,fp
811429b8:	dfc00117 	ldw	ra,4(sp)
811429bc:	df000017 	ldw	fp,0(sp)
811429c0:	dec00204 	addi	sp,sp,8
811429c4:	f800283a 	ret

811429c8 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
811429c8:	deffec04 	addi	sp,sp,-80
811429cc:	de00012e 	bgeu	sp,et,811429d4 <altera_avalon_uart_read+0xc>
811429d0:	003b68fa 	trap	3
811429d4:	dfc01315 	stw	ra,76(sp)
811429d8:	df001215 	stw	fp,72(sp)
811429dc:	df001204 	addi	fp,sp,72
811429e0:	e13ffc15 	stw	r4,-16(fp)
811429e4:	e17ffd15 	stw	r5,-12(fp)
811429e8:	e1bffe15 	stw	r6,-8(fp)
811429ec:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
811429f0:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
811429f4:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
811429f8:	e0bfff17 	ldw	r2,-4(fp)
811429fc:	1090000c 	andi	r2,r2,16384
81142a00:	1005003a 	cmpeq	r2,r2,zero
81142a04:	10803fcc 	andi	r2,r2,255
81142a08:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81142a0c:	e0bffc17 	ldw	r2,-16(fp)
81142a10:	10800817 	ldw	r2,32(r2)
81142a14:	e0bff815 	stw	r2,-32(fp)
81142a18:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81142a1c:	e0bff90b 	ldhu	r2,-28(fp)
81142a20:	e0fffb44 	addi	r3,fp,-19
81142a24:	180d883a 	mov	r6,r3
81142a28:	100b883a 	mov	r5,r2
81142a2c:	e13ff817 	ldw	r4,-32(fp)
81142a30:	1139b780 	call	81139b78 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81142a34:	00001306 	br	81142a84 <altera_avalon_uart_read+0xbc>
    {
      count++;
81142a38:	e0bff017 	ldw	r2,-64(fp)
81142a3c:	10800044 	addi	r2,r2,1
81142a40:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81142a44:	e0bffd17 	ldw	r2,-12(fp)
81142a48:	10c00044 	addi	r3,r2,1
81142a4c:	e0fffd15 	stw	r3,-12(fp)
81142a50:	e0fffc17 	ldw	r3,-16(fp)
81142a54:	18c00217 	ldw	r3,8(r3)
81142a58:	e13ffc17 	ldw	r4,-16(fp)
81142a5c:	20c7883a 	add	r3,r4,r3
81142a60:	18c00a04 	addi	r3,r3,40
81142a64:	18c00003 	ldbu	r3,0(r3)
81142a68:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81142a6c:	e0bffc17 	ldw	r2,-16(fp)
81142a70:	10800217 	ldw	r2,8(r2)
81142a74:	10800044 	addi	r2,r2,1
81142a78:	10c00fcc 	andi	r3,r2,63
81142a7c:	e0bffc17 	ldw	r2,-16(fp)
81142a80:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81142a84:	e0fff017 	ldw	r3,-64(fp)
81142a88:	e0bffe17 	ldw	r2,-8(fp)
81142a8c:	1880050e 	bge	r3,r2,81142aa4 <altera_avalon_uart_read+0xdc>
81142a90:	e0bffc17 	ldw	r2,-16(fp)
81142a94:	10c00217 	ldw	r3,8(r2)
81142a98:	e0bffc17 	ldw	r2,-16(fp)
81142a9c:	10800317 	ldw	r2,12(r2)
81142aa0:	18bfe51e 	bne	r3,r2,81142a38 <__reset+0xfb122a38>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81142aa4:	e0bff017 	ldw	r2,-64(fp)
81142aa8:	10003a1e 	bne	r2,zero,81142b94 <altera_avalon_uart_read+0x1cc>
81142aac:	e0bffc17 	ldw	r2,-16(fp)
81142ab0:	10c00217 	ldw	r3,8(r2)
81142ab4:	e0bffc17 	ldw	r2,-16(fp)
81142ab8:	10800317 	ldw	r2,12(r2)
81142abc:	1880351e 	bne	r3,r2,81142b94 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81142ac0:	e0bff117 	ldw	r2,-60(fp)
81142ac4:	1000071e 	bne	r2,zero,81142ae4 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81142ac8:	11429840 	call	81142984 <alt_get_errno>
81142acc:	1007883a 	mov	r3,r2
81142ad0:	008002c4 	movi	r2,11
81142ad4:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81142ad8:	00800044 	movi	r2,1
81142adc:	e0bfef05 	stb	r2,-68(fp)
        break;
81142ae0:	00003006 	br	81142ba4 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142ae4:	0005303a 	rdctl	r2,status
81142ae8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142aec:	e0fff517 	ldw	r3,-44(fp)
81142af0:	00bfff84 	movi	r2,-2
81142af4:	1884703a 	and	r2,r3,r2
81142af8:	1001703a 	wrctl	status,r2
  
  return context;
81142afc:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81142b00:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81142b04:	e0bffc17 	ldw	r2,-16(fp)
81142b08:	10800117 	ldw	r2,4(r2)
81142b0c:	10c02014 	ori	r3,r2,128
81142b10:	e0bffc17 	ldw	r2,-16(fp)
81142b14:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81142b18:	e0bffc17 	ldw	r2,-16(fp)
81142b1c:	10800017 	ldw	r2,0(r2)
81142b20:	10800304 	addi	r2,r2,12
81142b24:	e0fffc17 	ldw	r3,-16(fp)
81142b28:	18c00117 	ldw	r3,4(r3)
81142b2c:	10c00035 	stwio	r3,0(r2)
81142b30:	e0bff417 	ldw	r2,-48(fp)
81142b34:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142b38:	e0bff617 	ldw	r2,-40(fp)
81142b3c:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81142b40:	e0bffc17 	ldw	r2,-16(fp)
81142b44:	10800717 	ldw	r2,28(r2)
81142b48:	e0bff215 	stw	r2,-56(fp)
81142b4c:	00800044 	movi	r2,1
81142b50:	e0bff98d 	sth	r2,-26(fp)
81142b54:	00bfe0c4 	movi	r2,-125
81142b58:	e0bffa05 	stb	r2,-24(fp)
81142b5c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142b60:	d0a08b03 	ldbu	r2,-32212(gp)
81142b64:	10803fcc 	andi	r2,r2,255
81142b68:	10000a26 	beq	r2,zero,81142b94 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142b6c:	e0fff98b 	ldhu	r3,-26(fp)
81142b70:	e13ffa03 	ldbu	r4,-24(fp)
81142b74:	e17ffa8b 	ldhu	r5,-22(fp)
81142b78:	e0bffb04 	addi	r2,fp,-20
81142b7c:	d8800015 	stw	r2,0(sp)
81142b80:	280f883a 	mov	r7,r5
81142b84:	200d883a 	mov	r6,r4
81142b88:	180b883a 	mov	r5,r3
81142b8c:	e13ff217 	ldw	r4,-56(fp)
81142b90:	1135ed80 	call	81135ed8 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81142b94:	e0bff017 	ldw	r2,-64(fp)
81142b98:	1000021e 	bne	r2,zero,81142ba4 <altera_avalon_uart_read+0x1dc>
81142b9c:	e0bffe17 	ldw	r2,-8(fp)
81142ba0:	103fb81e 	bne	r2,zero,81142a84 <__reset+0xfb122a84>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81142ba4:	e0bffc17 	ldw	r2,-16(fp)
81142ba8:	10800817 	ldw	r2,32(r2)
81142bac:	1009883a 	mov	r4,r2
81142bb0:	1139f000 	call	81139f00 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142bb4:	0005303a 	rdctl	r2,status
81142bb8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142bbc:	e0fff717 	ldw	r3,-36(fp)
81142bc0:	00bfff84 	movi	r2,-2
81142bc4:	1884703a 	and	r2,r3,r2
81142bc8:	1001703a 	wrctl	status,r2
  
  return context;
81142bcc:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81142bd0:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81142bd4:	e0bffc17 	ldw	r2,-16(fp)
81142bd8:	10800117 	ldw	r2,4(r2)
81142bdc:	10c02014 	ori	r3,r2,128
81142be0:	e0bffc17 	ldw	r2,-16(fp)
81142be4:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81142be8:	e0bffc17 	ldw	r2,-16(fp)
81142bec:	10800017 	ldw	r2,0(r2)
81142bf0:	10800304 	addi	r2,r2,12
81142bf4:	e0fffc17 	ldw	r3,-16(fp)
81142bf8:	18c00117 	ldw	r3,4(r3)
81142bfc:	10c00035 	stwio	r3,0(r2)
81142c00:	e0bff417 	ldw	r2,-48(fp)
81142c04:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142c08:	e0bff317 	ldw	r2,-52(fp)
81142c0c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81142c10:	e0bfef03 	ldbu	r2,-68(fp)
81142c14:	10000226 	beq	r2,zero,81142c20 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81142c18:	00bffd44 	movi	r2,-11
81142c1c:	00000106 	br	81142c24 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81142c20:	e0bff017 	ldw	r2,-64(fp)
  }
}
81142c24:	e037883a 	mov	sp,fp
81142c28:	dfc00117 	ldw	ra,4(sp)
81142c2c:	df000017 	ldw	fp,0(sp)
81142c30:	dec00204 	addi	sp,sp,8
81142c34:	f800283a 	ret

81142c38 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81142c38:	defffe04 	addi	sp,sp,-8
81142c3c:	de00012e 	bgeu	sp,et,81142c44 <alt_get_errno+0xc>
81142c40:	003b68fa 	trap	3
81142c44:	dfc00115 	stw	ra,4(sp)
81142c48:	df000015 	stw	fp,0(sp)
81142c4c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81142c50:	d0a01017 	ldw	r2,-32704(gp)
81142c54:	10000326 	beq	r2,zero,81142c64 <alt_get_errno+0x2c>
81142c58:	d0a01017 	ldw	r2,-32704(gp)
81142c5c:	103ee83a 	callr	r2
81142c60:	00000106 	br	81142c68 <alt_get_errno+0x30>
81142c64:	d0a07204 	addi	r2,gp,-32312
}
81142c68:	e037883a 	mov	sp,fp
81142c6c:	dfc00117 	ldw	ra,4(sp)
81142c70:	df000017 	ldw	fp,0(sp)
81142c74:	dec00204 	addi	sp,sp,8
81142c78:	f800283a 	ret

81142c7c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81142c7c:	deffec04 	addi	sp,sp,-80
81142c80:	de00012e 	bgeu	sp,et,81142c88 <altera_avalon_uart_write+0xc>
81142c84:	003b68fa 	trap	3
81142c88:	dfc01315 	stw	ra,76(sp)
81142c8c:	df001215 	stw	fp,72(sp)
81142c90:	df001204 	addi	fp,sp,72
81142c94:	e13ffc15 	stw	r4,-16(fp)
81142c98:	e17ffd15 	stw	r5,-12(fp)
81142c9c:	e1bffe15 	stw	r6,-8(fp)
81142ca0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81142ca4:	e0bffe17 	ldw	r2,-8(fp)
81142ca8:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81142cac:	e0bfff17 	ldw	r2,-4(fp)
81142cb0:	1090000c 	andi	r2,r2,16384
81142cb4:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81142cb8:	e0bffc17 	ldw	r2,-16(fp)
81142cbc:	10800917 	ldw	r2,36(r2)
81142cc0:	e0bff815 	stw	r2,-32(fp)
81142cc4:	e03ff90d 	sth	zero,-28(fp)
81142cc8:	e0bff90b 	ldhu	r2,-28(fp)
81142ccc:	e0fffb44 	addi	r3,fp,-19
81142cd0:	180d883a 	mov	r6,r3
81142cd4:	100b883a 	mov	r5,r2
81142cd8:	e13ff817 	ldw	r4,-32(fp)
81142cdc:	1139b780 	call	81139b78 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81142ce0:	00005106 	br	81142e28 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81142ce4:	e0bffc17 	ldw	r2,-16(fp)
81142ce8:	10800517 	ldw	r2,20(r2)
81142cec:	10800044 	addi	r2,r2,1
81142cf0:	10800fcc 	andi	r2,r2,63
81142cf4:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81142cf8:	e0bffc17 	ldw	r2,-16(fp)
81142cfc:	10c00417 	ldw	r3,16(r2)
81142d00:	e0bff217 	ldw	r2,-56(fp)
81142d04:	1880371e 	bne	r3,r2,81142de4 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81142d08:	e0bff017 	ldw	r2,-64(fp)
81142d0c:	10000526 	beq	r2,zero,81142d24 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81142d10:	1142c380 	call	81142c38 <alt_get_errno>
81142d14:	1007883a 	mov	r3,r2
81142d18:	008002c4 	movi	r2,11
81142d1c:	18800015 	stw	r2,0(r3)
        break;
81142d20:	00004306 	br	81142e30 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142d24:	0005303a 	rdctl	r2,status
81142d28:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142d2c:	e0fff517 	ldw	r3,-44(fp)
81142d30:	00bfff84 	movi	r2,-2
81142d34:	1884703a 	and	r2,r3,r2
81142d38:	1001703a 	wrctl	status,r2
  
  return context;
81142d3c:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81142d40:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81142d44:	e0bffc17 	ldw	r2,-16(fp)
81142d48:	10800117 	ldw	r2,4(r2)
81142d4c:	10c11014 	ori	r3,r2,1088
81142d50:	e0bffc17 	ldw	r2,-16(fp)
81142d54:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81142d58:	e0bffc17 	ldw	r2,-16(fp)
81142d5c:	10800017 	ldw	r2,0(r2)
81142d60:	10800304 	addi	r2,r2,12
81142d64:	e0fffc17 	ldw	r3,-16(fp)
81142d68:	18c00117 	ldw	r3,4(r3)
81142d6c:	10c00035 	stwio	r3,0(r2)
81142d70:	e0bff417 	ldw	r2,-48(fp)
81142d74:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142d78:	e0bff117 	ldw	r2,-60(fp)
81142d7c:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81142d80:	e0bffc17 	ldw	r2,-16(fp)
81142d84:	10800717 	ldw	r2,28(r2)
81142d88:	e0bff315 	stw	r2,-52(fp)
81142d8c:	00800084 	movi	r2,2
81142d90:	e0bff98d 	sth	r2,-26(fp)
81142d94:	00bfe0c4 	movi	r2,-125
81142d98:	e0bffa05 	stb	r2,-24(fp)
81142d9c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142da0:	d0a08b03 	ldbu	r2,-32212(gp)
81142da4:	10803fcc 	andi	r2,r2,255
81142da8:	10000a26 	beq	r2,zero,81142dd4 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142dac:	e0fff98b 	ldhu	r3,-26(fp)
81142db0:	e13ffa03 	ldbu	r4,-24(fp)
81142db4:	e17ffa8b 	ldhu	r5,-22(fp)
81142db8:	e0bffb04 	addi	r2,fp,-20
81142dbc:	d8800015 	stw	r2,0(sp)
81142dc0:	280f883a 	mov	r7,r5
81142dc4:	200d883a 	mov	r6,r4
81142dc8:	180b883a 	mov	r5,r3
81142dcc:	e13ff317 	ldw	r4,-52(fp)
81142dd0:	1135ed80 	call	81135ed8 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81142dd4:	e0bffc17 	ldw	r2,-16(fp)
81142dd8:	10c00417 	ldw	r3,16(r2)
81142ddc:	e0bff217 	ldw	r2,-56(fp)
81142de0:	18bfe726 	beq	r3,r2,81142d80 <__reset+0xfb122d80>
      }
    }

    count--;
81142de4:	e0bfef17 	ldw	r2,-68(fp)
81142de8:	10bfffc4 	addi	r2,r2,-1
81142dec:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81142df0:	e0bffc17 	ldw	r2,-16(fp)
81142df4:	10c00517 	ldw	r3,20(r2)
81142df8:	e0bffd17 	ldw	r2,-12(fp)
81142dfc:	11000044 	addi	r4,r2,1
81142e00:	e13ffd15 	stw	r4,-12(fp)
81142e04:	10800003 	ldbu	r2,0(r2)
81142e08:	1009883a 	mov	r4,r2
81142e0c:	e0bffc17 	ldw	r2,-16(fp)
81142e10:	10c5883a 	add	r2,r2,r3
81142e14:	10801a04 	addi	r2,r2,104
81142e18:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81142e1c:	e0bffc17 	ldw	r2,-16(fp)
81142e20:	e0fff217 	ldw	r3,-56(fp)
81142e24:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81142e28:	e0bfef17 	ldw	r2,-68(fp)
81142e2c:	103fad1e 	bne	r2,zero,81142ce4 <__reset+0xfb122ce4>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81142e30:	e0bffc17 	ldw	r2,-16(fp)
81142e34:	10800917 	ldw	r2,36(r2)
81142e38:	1009883a 	mov	r4,r2
81142e3c:	1139f000 	call	81139f00 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142e40:	0005303a 	rdctl	r2,status
81142e44:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142e48:	e0fff717 	ldw	r3,-36(fp)
81142e4c:	00bfff84 	movi	r2,-2
81142e50:	1884703a 	and	r2,r3,r2
81142e54:	1001703a 	wrctl	status,r2
  
  return context;
81142e58:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81142e5c:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81142e60:	e0bffc17 	ldw	r2,-16(fp)
81142e64:	10800117 	ldw	r2,4(r2)
81142e68:	10c11014 	ori	r3,r2,1088
81142e6c:	e0bffc17 	ldw	r2,-16(fp)
81142e70:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81142e74:	e0bffc17 	ldw	r2,-16(fp)
81142e78:	10800017 	ldw	r2,0(r2)
81142e7c:	10800304 	addi	r2,r2,12
81142e80:	e0fffc17 	ldw	r3,-16(fp)
81142e84:	18c00117 	ldw	r3,4(r3)
81142e88:	10c00035 	stwio	r3,0(r2)
81142e8c:	e0bff417 	ldw	r2,-48(fp)
81142e90:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142e94:	e0bff617 	ldw	r2,-40(fp)
81142e98:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81142e9c:	e0fffe17 	ldw	r3,-8(fp)
81142ea0:	e0bfef17 	ldw	r2,-68(fp)
81142ea4:	1885c83a 	sub	r2,r3,r2
}
81142ea8:	e037883a 	mov	sp,fp
81142eac:	dfc00117 	ldw	ra,4(sp)
81142eb0:	df000017 	ldw	fp,0(sp)
81142eb4:	dec00204 	addi	sp,sp,8
81142eb8:	f800283a 	ret

81142ebc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81142ebc:	defffe04 	addi	sp,sp,-8
81142ec0:	de00012e 	bgeu	sp,et,81142ec8 <alt_get_errno+0xc>
81142ec4:	003b68fa 	trap	3
81142ec8:	dfc00115 	stw	ra,4(sp)
81142ecc:	df000015 	stw	fp,0(sp)
81142ed0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81142ed4:	d0a01017 	ldw	r2,-32704(gp)
81142ed8:	10000326 	beq	r2,zero,81142ee8 <alt_get_errno+0x2c>
81142edc:	d0a01017 	ldw	r2,-32704(gp)
81142ee0:	103ee83a 	callr	r2
81142ee4:	00000106 	br	81142eec <alt_get_errno+0x30>
81142ee8:	d0a07204 	addi	r2,gp,-32312
}
81142eec:	e037883a 	mov	sp,fp
81142ef0:	dfc00117 	ldw	ra,4(sp)
81142ef4:	df000017 	ldw	fp,0(sp)
81142ef8:	dec00204 	addi	sp,sp,8
81142efc:	f800283a 	ret

81142f00 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81142f00:	defffc04 	addi	sp,sp,-16
81142f04:	de00012e 	bgeu	sp,et,81142f0c <alt_msgdma_write_standard_descriptor+0xc>
81142f08:	003b68fa 	trap	3
81142f0c:	df000315 	stw	fp,12(sp)
81142f10:	df000304 	addi	fp,sp,12
81142f14:	e13ffd15 	stw	r4,-12(fp)
81142f18:	e17ffe15 	stw	r5,-8(fp)
81142f1c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81142f20:	e0bffd17 	ldw	r2,-12(fp)
81142f24:	10800037 	ldwio	r2,0(r2)
81142f28:	1080010c 	andi	r2,r2,4
81142f2c:	10000226 	beq	r2,zero,81142f38 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81142f30:	00bff904 	movi	r2,-28
81142f34:	00001506 	br	81142f8c <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81142f38:	e0bfff17 	ldw	r2,-4(fp)
81142f3c:	10800017 	ldw	r2,0(r2)
81142f40:	1007883a 	mov	r3,r2
81142f44:	e0bffe17 	ldw	r2,-8(fp)
81142f48:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81142f4c:	e0bffe17 	ldw	r2,-8(fp)
81142f50:	10800104 	addi	r2,r2,4
81142f54:	e0ffff17 	ldw	r3,-4(fp)
81142f58:	18c00117 	ldw	r3,4(r3)
81142f5c:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81142f60:	e0bffe17 	ldw	r2,-8(fp)
81142f64:	10800204 	addi	r2,r2,8
81142f68:	e0ffff17 	ldw	r3,-4(fp)
81142f6c:	18c00217 	ldw	r3,8(r3)
81142f70:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81142f74:	e0bffe17 	ldw	r2,-8(fp)
81142f78:	10800304 	addi	r2,r2,12
81142f7c:	e0ffff17 	ldw	r3,-4(fp)
81142f80:	18c00317 	ldw	r3,12(r3)
81142f84:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81142f88:	0005883a 	mov	r2,zero
}
81142f8c:	e037883a 	mov	sp,fp
81142f90:	df000017 	ldw	fp,0(sp)
81142f94:	dec00104 	addi	sp,sp,4
81142f98:	f800283a 	ret

81142f9c <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81142f9c:	defffc04 	addi	sp,sp,-16
81142fa0:	de00012e 	bgeu	sp,et,81142fa8 <alt_msgdma_write_extended_descriptor+0xc>
81142fa4:	003b68fa 	trap	3
81142fa8:	df000315 	stw	fp,12(sp)
81142fac:	df000304 	addi	fp,sp,12
81142fb0:	e13ffd15 	stw	r4,-12(fp)
81142fb4:	e17ffe15 	stw	r5,-8(fp)
81142fb8:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81142fbc:	e0bffd17 	ldw	r2,-12(fp)
81142fc0:	10800037 	ldwio	r2,0(r2)
81142fc4:	1080010c 	andi	r2,r2,4
81142fc8:	10000226 	beq	r2,zero,81142fd4 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81142fcc:	00bff904 	movi	r2,-28
81142fd0:	00003b06 	br	811430c0 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81142fd4:	e0bfff17 	ldw	r2,-4(fp)
81142fd8:	10800017 	ldw	r2,0(r2)
81142fdc:	1007883a 	mov	r3,r2
81142fe0:	e0bffe17 	ldw	r2,-8(fp)
81142fe4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81142fe8:	e0bffe17 	ldw	r2,-8(fp)
81142fec:	10800104 	addi	r2,r2,4
81142ff0:	e0ffff17 	ldw	r3,-4(fp)
81142ff4:	18c00117 	ldw	r3,4(r3)
81142ff8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81142ffc:	e0bffe17 	ldw	r2,-8(fp)
81143000:	10800204 	addi	r2,r2,8
81143004:	e0ffff17 	ldw	r3,-4(fp)
81143008:	18c00217 	ldw	r3,8(r3)
8114300c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81143010:	e0bffe17 	ldw	r2,-8(fp)
81143014:	10800304 	addi	r2,r2,12
81143018:	e0ffff17 	ldw	r3,-4(fp)
8114301c:	18c0030b 	ldhu	r3,12(r3)
81143020:	18ffffcc 	andi	r3,r3,65535
81143024:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81143028:	e0bffe17 	ldw	r2,-8(fp)
8114302c:	10800384 	addi	r2,r2,14
81143030:	e0ffff17 	ldw	r3,-4(fp)
81143034:	18c00383 	ldbu	r3,14(r3)
81143038:	18c03fcc 	andi	r3,r3,255
8114303c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81143040:	e0bffe17 	ldw	r2,-8(fp)
81143044:	108003c4 	addi	r2,r2,15
81143048:	e0ffff17 	ldw	r3,-4(fp)
8114304c:	18c003c3 	ldbu	r3,15(r3)
81143050:	18c03fcc 	andi	r3,r3,255
81143054:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81143058:	e0bffe17 	ldw	r2,-8(fp)
8114305c:	10800404 	addi	r2,r2,16
81143060:	e0ffff17 	ldw	r3,-4(fp)
81143064:	18c0040b 	ldhu	r3,16(r3)
81143068:	18ffffcc 	andi	r3,r3,65535
8114306c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81143070:	e0bffe17 	ldw	r2,-8(fp)
81143074:	10800484 	addi	r2,r2,18
81143078:	e0ffff17 	ldw	r3,-4(fp)
8114307c:	18c0048b 	ldhu	r3,18(r3)
81143080:	18ffffcc 	andi	r3,r3,65535
81143084:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81143088:	e0bffe17 	ldw	r2,-8(fp)
8114308c:	10800504 	addi	r2,r2,20
81143090:	0007883a 	mov	r3,zero
81143094:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81143098:	e0bffe17 	ldw	r2,-8(fp)
8114309c:	10800604 	addi	r2,r2,24
811430a0:	0007883a 	mov	r3,zero
811430a4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811430a8:	e0bffe17 	ldw	r2,-8(fp)
811430ac:	10800704 	addi	r2,r2,28
811430b0:	e0ffff17 	ldw	r3,-4(fp)
811430b4:	18c00717 	ldw	r3,28(r3)
811430b8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811430bc:	0005883a 	mov	r2,zero
}
811430c0:	e037883a 	mov	sp,fp
811430c4:	df000017 	ldw	fp,0(sp)
811430c8:	dec00104 	addi	sp,sp,4
811430cc:	f800283a 	ret

811430d0 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
811430d0:	defff804 	addi	sp,sp,-32
811430d4:	de00012e 	bgeu	sp,et,811430dc <alt_msgdma_irq+0xc>
811430d8:	003b68fa 	trap	3
811430dc:	dfc00715 	stw	ra,28(sp)
811430e0:	df000615 	stw	fp,24(sp)
811430e4:	df000604 	addi	fp,sp,24
811430e8:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
811430ec:	e0bfff17 	ldw	r2,-4(fp)
811430f0:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
811430f4:	e0bffa17 	ldw	r2,-24(fp)
811430f8:	10801783 	ldbu	r2,94(r2)
811430fc:	10803fcc 	andi	r2,r2,255
81143100:	10001126 	beq	r2,zero,81143148 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81143104:	e0bffa17 	ldw	r2,-24(fp)
81143108:	10800617 	ldw	r2,24(r2)
8114310c:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81143110:	1007883a 	mov	r3,r2
81143114:	00bffdc4 	movi	r2,-9
81143118:	1884703a 	and	r2,r3,r2
8114311c:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81143120:	e0bffa17 	ldw	r2,-24(fp)
81143124:	10800617 	ldw	r2,24(r2)
81143128:	e0fffb17 	ldw	r3,-20(fp)
8114312c:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81143130:	e0bffa17 	ldw	r2,-24(fp)
81143134:	10800617 	ldw	r2,24(r2)
81143138:	10800404 	addi	r2,r2,16
8114313c:	00c00044 	movi	r3,1
81143140:	10c00035 	stwio	r3,0(r2)
81143144:	00001106 	br	8114318c <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81143148:	e0bffa17 	ldw	r2,-24(fp)
8114314c:	10800317 	ldw	r2,12(r2)
81143150:	10800104 	addi	r2,r2,4
81143154:	10800037 	ldwio	r2,0(r2)
81143158:	1007883a 	mov	r3,r2
8114315c:	00bffbc4 	movi	r2,-17
81143160:	1884703a 	and	r2,r3,r2
81143164:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81143168:	e0bffa17 	ldw	r2,-24(fp)
8114316c:	10800317 	ldw	r2,12(r2)
81143170:	10800104 	addi	r2,r2,4
81143174:	e0fffb17 	ldw	r3,-20(fp)
81143178:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8114317c:	e0bffa17 	ldw	r2,-24(fp)
81143180:	10800317 	ldw	r2,12(r2)
81143184:	00c08004 	movi	r3,512
81143188:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
8114318c:	e0bffa17 	ldw	r2,-24(fp)
81143190:	10800b17 	ldw	r2,44(r2)
81143194:	10001226 	beq	r2,zero,811431e0 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143198:	0005303a 	rdctl	r2,status
8114319c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811431a0:	e0fffd17 	ldw	r3,-12(fp)
811431a4:	00bfff84 	movi	r2,-2
811431a8:	1884703a 	and	r2,r3,r2
811431ac:	1001703a 	wrctl	status,r2
  
  return context;
811431b0:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
811431b4:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
811431b8:	e0bffa17 	ldw	r2,-24(fp)
811431bc:	10800b17 	ldw	r2,44(r2)
811431c0:	e0fffa17 	ldw	r3,-24(fp)
811431c4:	18c00c17 	ldw	r3,48(r3)
811431c8:	1809883a 	mov	r4,r3
811431cc:	103ee83a 	callr	r2
811431d0:	e0bffc17 	ldw	r2,-16(fp)
811431d4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811431d8:	e0bffe17 	ldw	r2,-8(fp)
811431dc:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
811431e0:	e0bffa17 	ldw	r2,-24(fp)
811431e4:	10801783 	ldbu	r2,94(r2)
811431e8:	10803fcc 	andi	r2,r2,255
811431ec:	10000a26 	beq	r2,zero,81143218 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
811431f0:	e0bffa17 	ldw	r2,-24(fp)
811431f4:	10800617 	ldw	r2,24(r2)
811431f8:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
811431fc:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81143200:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81143204:	e0bffa17 	ldw	r2,-24(fp)
81143208:	10800617 	ldw	r2,24(r2)
8114320c:	e0fffb17 	ldw	r3,-20(fp)
81143210:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81143214:	00000c06 	br	81143248 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81143218:	e0bffa17 	ldw	r2,-24(fp)
8114321c:	10800317 	ldw	r2,12(r2)
81143220:	10800104 	addi	r2,r2,4
81143224:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81143228:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114322c:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81143230:	e0bffa17 	ldw	r2,-24(fp)
81143234:	10800317 	ldw	r2,12(r2)
81143238:	10800104 	addi	r2,r2,4
8114323c:	e0fffb17 	ldw	r3,-20(fp)
81143240:	10c00035 	stwio	r3,0(r2)
    }

    return;
81143244:	0001883a 	nop
}
81143248:	e037883a 	mov	sp,fp
8114324c:	dfc00117 	ldw	ra,4(sp)
81143250:	df000017 	ldw	fp,0(sp)
81143254:	dec00204 	addi	sp,sp,8
81143258:	f800283a 	ret

8114325c <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114325c:	defffb04 	addi	sp,sp,-20
81143260:	de00012e 	bgeu	sp,et,81143268 <alt_msgdma_construct_standard_descriptor+0xc>
81143264:	003b68fa 	trap	3
81143268:	df000415 	stw	fp,16(sp)
8114326c:	df000404 	addi	fp,sp,16
81143270:	e13ffc15 	stw	r4,-16(fp)
81143274:	e17ffd15 	stw	r5,-12(fp)
81143278:	e1bffe15 	stw	r6,-8(fp)
8114327c:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81143280:	e0bffc17 	ldw	r2,-16(fp)
81143284:	10c01217 	ldw	r3,72(r2)
81143288:	e0800117 	ldw	r2,4(fp)
8114328c:	18800436 	bltu	r3,r2,811432a0 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81143290:	e0bffc17 	ldw	r2,-16(fp)
81143294:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81143298:	10803fcc 	andi	r2,r2,255
8114329c:	10000226 	beq	r2,zero,811432a8 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811432a0:	00bffa84 	movi	r2,-22
811432a4:	00000e06 	br	811432e0 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811432a8:	e0bffd17 	ldw	r2,-12(fp)
811432ac:	e0fffe17 	ldw	r3,-8(fp)
811432b0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811432b4:	e0bffd17 	ldw	r2,-12(fp)
811432b8:	e0ffff17 	ldw	r3,-4(fp)
811432bc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811432c0:	e0bffd17 	ldw	r2,-12(fp)
811432c4:	e0c00117 	ldw	r3,4(fp)
811432c8:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811432cc:	e0800217 	ldw	r2,8(fp)
811432d0:	10e00034 	orhi	r3,r2,32768
811432d4:	e0bffd17 	ldw	r2,-12(fp)
811432d8:	10c00315 	stw	r3,12(r2)
    
    return 0;
811432dc:	0005883a 	mov	r2,zero
}
811432e0:	e037883a 	mov	sp,fp
811432e4:	df000017 	ldw	fp,0(sp)
811432e8:	dec00104 	addi	sp,sp,4
811432ec:	f800283a 	ret

811432f0 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
811432f0:	defff604 	addi	sp,sp,-40
811432f4:	de00012e 	bgeu	sp,et,811432fc <alt_msgdma_construct_extended_descriptor+0xc>
811432f8:	003b68fa 	trap	3
811432fc:	df000915 	stw	fp,36(sp)
81143300:	df000904 	addi	fp,sp,36
81143304:	e13ff715 	stw	r4,-36(fp)
81143308:	e17ff815 	stw	r5,-32(fp)
8114330c:	e1bff915 	stw	r6,-28(fp)
81143310:	e1fffa15 	stw	r7,-24(fp)
81143314:	e1800317 	ldw	r6,12(fp)
81143318:	e1400417 	ldw	r5,16(fp)
8114331c:	e1000517 	ldw	r4,20(fp)
81143320:	e0c00617 	ldw	r3,24(fp)
81143324:	e0800717 	ldw	r2,28(fp)
81143328:	e1bffb0d 	sth	r6,-20(fp)
8114332c:	e17ffc05 	stb	r5,-16(fp)
81143330:	e13ffd05 	stb	r4,-12(fp)
81143334:	e0fffe0d 	sth	r3,-8(fp)
81143338:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8114333c:	e0bff717 	ldw	r2,-36(fp)
81143340:	10c01217 	ldw	r3,72(r2)
81143344:	e0800117 	ldw	r2,4(fp)
81143348:	18801936 	bltu	r3,r2,811433b0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114334c:	e13ff717 	ldw	r4,-36(fp)
81143350:	20801317 	ldw	r2,76(r4)
81143354:	20c01417 	ldw	r3,80(r4)
81143358:	e13ffe0b 	ldhu	r4,-8(fp)
8114335c:	213fffcc 	andi	r4,r4,65535
81143360:	2015883a 	mov	r10,r4
81143364:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81143368:	1ac01136 	bltu	r3,r11,811433b0 <alt_msgdma_construct_extended_descriptor+0xc0>
8114336c:	58c0011e 	bne	r11,r3,81143374 <alt_msgdma_construct_extended_descriptor+0x84>
81143370:	12800f36 	bltu	r2,r10,811433b0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81143374:	e13ff717 	ldw	r4,-36(fp)
81143378:	20801317 	ldw	r2,76(r4)
8114337c:	20c01417 	ldw	r3,80(r4)
81143380:	e13fff0b 	ldhu	r4,-4(fp)
81143384:	213fffcc 	andi	r4,r4,65535
81143388:	2011883a 	mov	r8,r4
8114338c:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81143390:	1a400736 	bltu	r3,r9,811433b0 <alt_msgdma_construct_extended_descriptor+0xc0>
81143394:	48c0011e 	bne	r9,r3,8114339c <alt_msgdma_construct_extended_descriptor+0xac>
81143398:	12000536 	bltu	r2,r8,811433b0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114339c:	e0bff717 	ldw	r2,-36(fp)
811433a0:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811433a4:	10803fcc 	andi	r2,r2,255
811433a8:	10800060 	cmpeqi	r2,r2,1
811433ac:	1000021e 	bne	r2,zero,811433b8 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811433b0:	00bffa84 	movi	r2,-22
811433b4:	00002106 	br	8114343c <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
811433b8:	e0bff817 	ldw	r2,-32(fp)
811433bc:	e0fff917 	ldw	r3,-28(fp)
811433c0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
811433c4:	e0bff817 	ldw	r2,-32(fp)
811433c8:	e0fffa17 	ldw	r3,-24(fp)
811433cc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811433d0:	e0bff817 	ldw	r2,-32(fp)
811433d4:	e0c00117 	ldw	r3,4(fp)
811433d8:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
811433dc:	e0bff817 	ldw	r2,-32(fp)
811433e0:	e0fffb0b 	ldhu	r3,-20(fp)
811433e4:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
811433e8:	e0bff817 	ldw	r2,-32(fp)
811433ec:	e0fffc03 	ldbu	r3,-16(fp)
811433f0:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
811433f4:	e0bff817 	ldw	r2,-32(fp)
811433f8:	e0fffd03 	ldbu	r3,-12(fp)
811433fc:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81143400:	e0bff817 	ldw	r2,-32(fp)
81143404:	e0fffe0b 	ldhu	r3,-8(fp)
81143408:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8114340c:	e0bff817 	ldw	r2,-32(fp)
81143410:	e0ffff0b 	ldhu	r3,-4(fp)
81143414:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81143418:	e0bff817 	ldw	r2,-32(fp)
8114341c:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81143420:	e0bff817 	ldw	r2,-32(fp)
81143424:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81143428:	e0800217 	ldw	r2,8(fp)
8114342c:	10e00034 	orhi	r3,r2,32768
81143430:	e0bff817 	ldw	r2,-32(fp)
81143434:	10c00715 	stw	r3,28(r2)

  return 0 ;
81143438:	0005883a 	mov	r2,zero

}
8114343c:	e037883a 	mov	sp,fp
81143440:	df000017 	ldw	fp,0(sp)
81143444:	dec00104 	addi	sp,sp,4
81143448:	f800283a 	ret

8114344c <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114344c:	deffee04 	addi	sp,sp,-72
81143450:	de00012e 	bgeu	sp,et,81143458 <alt_msgdma_descriptor_async_transfer+0xc>
81143454:	003b68fa 	trap	3
81143458:	dfc01115 	stw	ra,68(sp)
8114345c:	df001015 	stw	fp,64(sp)
81143460:	df001004 	addi	fp,sp,64
81143464:	e13ffd15 	stw	r4,-12(fp)
81143468:	e17ffe15 	stw	r5,-8(fp)
8114346c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81143470:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81143474:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81143478:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114347c:	e0bffd17 	ldw	r2,-12(fp)
81143480:	10800317 	ldw	r2,12(r2)
81143484:	10800204 	addi	r2,r2,8
81143488:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8114348c:	10bfffcc 	andi	r2,r2,65535
81143490:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143494:	e0bffd17 	ldw	r2,-12(fp)
81143498:	10800317 	ldw	r2,12(r2)
8114349c:	10800204 	addi	r2,r2,8
811434a0:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811434a4:	1004d43a 	srli	r2,r2,16
811434a8:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811434ac:	e0bffd17 	ldw	r2,-12(fp)
811434b0:	10800917 	ldw	r2,36(r2)
811434b4:	e0fff417 	ldw	r3,-48(fp)
811434b8:	1880042e 	bgeu	r3,r2,811434cc <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811434bc:	e0bffd17 	ldw	r2,-12(fp)
811434c0:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811434c4:	e0fff317 	ldw	r3,-52(fp)
811434c8:	18800236 	bltu	r3,r2,811434d4 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
811434cc:	00bff904 	movi	r2,-28
811434d0:	0000a906 	br	81143778 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
811434d4:	e0bffd17 	ldw	r2,-12(fp)
811434d8:	10801817 	ldw	r2,96(r2)
811434dc:	e0bff615 	stw	r2,-40(fp)
811434e0:	e03ffc0d 	sth	zero,-16(fp)
811434e4:	e0bffc0b 	ldhu	r2,-16(fp)
811434e8:	e0fffc84 	addi	r3,fp,-14
811434ec:	180d883a 	mov	r6,r3
811434f0:	100b883a 	mov	r5,r2
811434f4:	e13ff617 	ldw	r4,-40(fp)
811434f8:	1139b780 	call	81139b78 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811434fc:	00800804 	movi	r2,32
81143500:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143504:	0005303a 	rdctl	r2,status
81143508:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114350c:	e0fff717 	ldw	r3,-36(fp)
81143510:	00bfff84 	movi	r2,-2
81143514:	1884703a 	and	r2,r3,r2
81143518:	1001703a 	wrctl	status,r2
  
  return context;
8114351c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81143520:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143524:	e0bffd17 	ldw	r2,-12(fp)
81143528:	10800317 	ldw	r2,12(r2)
8114352c:	10800104 	addi	r2,r2,4
81143530:	e0fff117 	ldw	r3,-60(fp)
81143534:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81143538:	e0bffd17 	ldw	r2,-12(fp)
8114353c:	10800317 	ldw	r2,12(r2)
81143540:	e0fffd17 	ldw	r3,-12(fp)
81143544:	18c00317 	ldw	r3,12(r3)
81143548:	18c00037 	ldwio	r3,0(r3)
8114354c:	10c00035 	stwio	r3,0(r2)
81143550:	e0bff217 	ldw	r2,-56(fp)
81143554:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143558:	e0bffb17 	ldw	r2,-20(fp)
8114355c:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81143560:	e0bffe17 	ldw	r2,-8(fp)
81143564:	10001e26 	beq	r2,zero,811435e0 <alt_msgdma_descriptor_async_transfer+0x194>
81143568:	e0bfff17 	ldw	r2,-4(fp)
8114356c:	10001c1e 	bne	r2,zero,811435e0 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81143570:	00001106 	br	811435b8 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81143574:	01000044 	movi	r4,1
81143578:	11313000 	call	81131300 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114357c:	e0bff00b 	ldhu	r2,-64(fp)
81143580:	1084e230 	cmpltui	r2,r2,5000
81143584:	1000091e 	bne	r2,zero,811435ac <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81143588:	01204574 	movhi	r4,33045
8114358c:	212d2e04 	addi	r4,r4,-19272
81143590:	11458a00 	call	811458a0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81143594:	e0bffd17 	ldw	r2,-12(fp)
81143598:	10801817 	ldw	r2,96(r2)
8114359c:	1009883a 	mov	r4,r2
811435a0:	1139f000 	call	81139f00 <OSSemPost>
				
                return -ETIME;
811435a4:	00bff084 	movi	r2,-62
811435a8:	00007306 	br	81143778 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811435ac:	e0bff00b 	ldhu	r2,-64(fp)
811435b0:	10800044 	addi	r2,r2,1
811435b4:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811435b8:	e0bffd17 	ldw	r2,-12(fp)
811435bc:	10c00317 	ldw	r3,12(r2)
811435c0:	e0bffd17 	ldw	r2,-12(fp)
811435c4:	10800417 	ldw	r2,16(r2)
811435c8:	e1bffe17 	ldw	r6,-8(fp)
811435cc:	100b883a 	mov	r5,r2
811435d0:	1809883a 	mov	r4,r3
811435d4:	1142f000 	call	81142f00 <alt_msgdma_write_standard_descriptor>
811435d8:	103fe61e 	bne	r2,zero,81143574 <__reset+0xfb123574>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811435dc:	00002706 	br	8114367c <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811435e0:	e0bffe17 	ldw	r2,-8(fp)
811435e4:	10001f1e 	bne	r2,zero,81143664 <alt_msgdma_descriptor_async_transfer+0x218>
811435e8:	e0bfff17 	ldw	r2,-4(fp)
811435ec:	10001d26 	beq	r2,zero,81143664 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
811435f0:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811435f4:	00001106 	br	8114363c <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811435f8:	01000044 	movi	r4,1
811435fc:	11313000 	call	81131300 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143600:	e0bff00b 	ldhu	r2,-64(fp)
81143604:	1084e230 	cmpltui	r2,r2,5000
81143608:	1000091e 	bne	r2,zero,81143630 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8114360c:	01204574 	movhi	r4,33045
81143610:	212d4404 	addi	r4,r4,-19184
81143614:	11458a00 	call	811458a0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81143618:	e0bffd17 	ldw	r2,-12(fp)
8114361c:	10801817 	ldw	r2,96(r2)
81143620:	1009883a 	mov	r4,r2
81143624:	1139f000 	call	81139f00 <OSSemPost>
				
                return -ETIME;
81143628:	00bff084 	movi	r2,-62
8114362c:	00005206 	br	81143778 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81143630:	e0bff00b 	ldhu	r2,-64(fp)
81143634:	10800044 	addi	r2,r2,1
81143638:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114363c:	e0bffd17 	ldw	r2,-12(fp)
81143640:	10c00317 	ldw	r3,12(r2)
81143644:	e0bffd17 	ldw	r2,-12(fp)
81143648:	10800417 	ldw	r2,16(r2)
8114364c:	e1bfff17 	ldw	r6,-4(fp)
81143650:	100b883a 	mov	r5,r2
81143654:	1809883a 	mov	r4,r3
81143658:	1142f9c0 	call	81142f9c <alt_msgdma_write_extended_descriptor>
8114365c:	103fe61e 	bne	r2,zero,811435f8 <__reset+0xfb1235f8>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81143660:	00000606 	br	8114367c <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81143664:	e0bffd17 	ldw	r2,-12(fp)
81143668:	10801817 	ldw	r2,96(r2)
8114366c:	1009883a 	mov	r4,r2
81143670:	1139f000 	call	81139f00 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81143674:	00bfffc4 	movi	r2,-1
81143678:	00003f06 	br	81143778 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8114367c:	e0bffd17 	ldw	r2,-12(fp)
81143680:	10800b17 	ldw	r2,44(r2)
81143684:	10001c26 	beq	r2,zero,811436f8 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81143688:	e0bffd17 	ldw	r2,-12(fp)
8114368c:	10c00d17 	ldw	r3,52(r2)
81143690:	e0bff117 	ldw	r2,-60(fp)
81143694:	1884b03a 	or	r2,r3,r2
81143698:	10800514 	ori	r2,r2,20
8114369c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811436a0:	e0fff117 	ldw	r3,-60(fp)
811436a4:	00bff7c4 	movi	r2,-33
811436a8:	1884703a 	and	r2,r3,r2
811436ac:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811436b0:	0005303a 	rdctl	r2,status
811436b4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811436b8:	e0fff917 	ldw	r3,-28(fp)
811436bc:	00bfff84 	movi	r2,-2
811436c0:	1884703a 	and	r2,r3,r2
811436c4:	1001703a 	wrctl	status,r2
  
  return context;
811436c8:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
811436cc:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811436d0:	e0bffd17 	ldw	r2,-12(fp)
811436d4:	10800317 	ldw	r2,12(r2)
811436d8:	10800104 	addi	r2,r2,4
811436dc:	e0fff117 	ldw	r3,-60(fp)
811436e0:	10c00035 	stwio	r3,0(r2)
811436e4:	e0bff217 	ldw	r2,-56(fp)
811436e8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811436ec:	e0bff517 	ldw	r2,-44(fp)
811436f0:	1001703a 	wrctl	status,r2
811436f4:	00001b06 	br	81143764 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
811436f8:	e0bffd17 	ldw	r2,-12(fp)
811436fc:	10c00d17 	ldw	r3,52(r2)
81143700:	e0bff117 	ldw	r2,-60(fp)
81143704:	1884b03a 	or	r2,r3,r2
81143708:	10800114 	ori	r2,r2,4
8114370c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81143710:	e0fff117 	ldw	r3,-60(fp)
81143714:	00bff3c4 	movi	r2,-49
81143718:	1884703a 	and	r2,r3,r2
8114371c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143720:	0005303a 	rdctl	r2,status
81143724:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143728:	e0fffa17 	ldw	r3,-24(fp)
8114372c:	00bfff84 	movi	r2,-2
81143730:	1884703a 	and	r2,r3,r2
81143734:	1001703a 	wrctl	status,r2
  
  return context;
81143738:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8114373c:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143740:	e0bffd17 	ldw	r2,-12(fp)
81143744:	10800317 	ldw	r2,12(r2)
81143748:	10800104 	addi	r2,r2,4
8114374c:	e0fff117 	ldw	r3,-60(fp)
81143750:	10c00035 	stwio	r3,0(r2)
81143754:	e0bff217 	ldw	r2,-56(fp)
81143758:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114375c:	e0bff817 	ldw	r2,-32(fp)
81143760:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81143764:	e0bffd17 	ldw	r2,-12(fp)
81143768:	10801817 	ldw	r2,96(r2)
8114376c:	1009883a 	mov	r4,r2
81143770:	1139f000 	call	81139f00 <OSSemPost>
    
    return 0;
81143774:	0005883a 	mov	r2,zero
}
81143778:	e037883a 	mov	sp,fp
8114377c:	dfc00117 	ldw	ra,4(sp)
81143780:	df000017 	ldw	fp,0(sp)
81143784:	dec00204 	addi	sp,sp,8
81143788:	f800283a 	ret

8114378c <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114378c:	deffee04 	addi	sp,sp,-72
81143790:	de00012e 	bgeu	sp,et,81143798 <alt_msgdma_descriptor_sync_transfer+0xc>
81143794:	003b68fa 	trap	3
81143798:	dfc01115 	stw	ra,68(sp)
8114379c:	df001015 	stw	fp,64(sp)
811437a0:	df001004 	addi	fp,sp,64
811437a4:	e13ffd15 	stw	r4,-12(fp)
811437a8:	e17ffe15 	stw	r5,-8(fp)
811437ac:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
811437b0:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
811437b4:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
811437b8:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
811437bc:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811437c0:	e0bffd17 	ldw	r2,-12(fp)
811437c4:	10800317 	ldw	r2,12(r2)
811437c8:	10800204 	addi	r2,r2,8
811437cc:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811437d0:	10bfffcc 	andi	r2,r2,65535
811437d4:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811437d8:	e0bffd17 	ldw	r2,-12(fp)
811437dc:	10800317 	ldw	r2,12(r2)
811437e0:	10800204 	addi	r2,r2,8
811437e4:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811437e8:	1004d43a 	srli	r2,r2,16
811437ec:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
811437f0:	00807804 	movi	r2,480
811437f4:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811437f8:	00001906 	br	81143860 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
811437fc:	01000044 	movi	r4,1
81143800:	11313000 	call	81131300 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143804:	e0bff10b 	ldhu	r2,-60(fp)
81143808:	1084e230 	cmpltui	r2,r2,5000
8114380c:	1000051e 	bne	r2,zero,81143824 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81143810:	01204574 	movhi	r4,33045
81143814:	212d5a04 	addi	r4,r4,-19096
81143818:	11458a00 	call	811458a0 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8114381c:	00bff084 	movi	r2,-62
81143820:	0000d706 	br	81143b80 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81143824:	e0bff10b 	ldhu	r2,-60(fp)
81143828:	10800044 	addi	r2,r2,1
8114382c:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143830:	e0bffd17 	ldw	r2,-12(fp)
81143834:	10800317 	ldw	r2,12(r2)
81143838:	10800204 	addi	r2,r2,8
8114383c:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81143840:	10bfffcc 	andi	r2,r2,65535
81143844:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81143848:	e0bffd17 	ldw	r2,-12(fp)
8114384c:	10800317 	ldw	r2,12(r2)
81143850:	10800204 	addi	r2,r2,8
81143854:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81143858:	1004d43a 	srli	r2,r2,16
8114385c:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81143860:	e0bffd17 	ldw	r2,-12(fp)
81143864:	10800917 	ldw	r2,36(r2)
81143868:	e0fff317 	ldw	r3,-52(fp)
8114386c:	18bfe32e 	bgeu	r3,r2,811437fc <__reset+0xfb1237fc>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81143870:	e0bffd17 	ldw	r2,-12(fp)
81143874:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81143878:	e0fff217 	ldw	r3,-56(fp)
8114387c:	18bfdf2e 	bgeu	r3,r2,811437fc <__reset+0xfb1237fc>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81143880:	e0bffd17 	ldw	r2,-12(fp)
81143884:	10801817 	ldw	r2,96(r2)
81143888:	e0bff815 	stw	r2,-32(fp)
8114388c:	e03ffc0d 	sth	zero,-16(fp)
81143890:	e0bffc0b 	ldhu	r2,-16(fp)
81143894:	e0fffc84 	addi	r3,fp,-14
81143898:	180d883a 	mov	r6,r3
8114389c:	100b883a 	mov	r5,r2
811438a0:	e13ff817 	ldw	r4,-32(fp)
811438a4:	1139b780 	call	81139b78 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811438a8:	0005303a 	rdctl	r2,status
811438ac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811438b0:	e0fffb17 	ldw	r3,-20(fp)
811438b4:	00bfff84 	movi	r2,-2
811438b8:	1884703a 	and	r2,r3,r2
811438bc:	1001703a 	wrctl	status,r2
  
  return context;
811438c0:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811438c4:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811438c8:	e0bffd17 	ldw	r2,-12(fp)
811438cc:	10800317 	ldw	r2,12(r2)
811438d0:	10800104 	addi	r2,r2,4
811438d4:	00c00804 	movi	r3,32
811438d8:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811438dc:	e0bffd17 	ldw	r2,-12(fp)
811438e0:	10800317 	ldw	r2,12(r2)
811438e4:	e0fffd17 	ldw	r3,-12(fp)
811438e8:	18c00317 	ldw	r3,12(r3)
811438ec:	18c00037 	ldwio	r3,0(r3)
811438f0:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811438f4:	e0bffe17 	ldw	r2,-8(fp)
811438f8:	10001f26 	beq	r2,zero,81143978 <alt_msgdma_descriptor_sync_transfer+0x1ec>
811438fc:	e0bfff17 	ldw	r2,-4(fp)
81143900:	10001d1e 	bne	r2,zero,81143978 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81143904:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81143908:	00001106 	br	81143950 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
8114390c:	01000044 	movi	r4,1
81143910:	11313000 	call	81131300 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143914:	e0bff10b 	ldhu	r2,-60(fp)
81143918:	1084e230 	cmpltui	r2,r2,5000
8114391c:	1000091e 	bne	r2,zero,81143944 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81143920:	01204574 	movhi	r4,33045
81143924:	212d6e04 	addi	r4,r4,-19016
81143928:	11458a00 	call	811458a0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114392c:	e0bffd17 	ldw	r2,-12(fp)
81143930:	10801817 	ldw	r2,96(r2)
81143934:	1009883a 	mov	r4,r2
81143938:	1139f000 	call	81139f00 <OSSemPost>
				
                return -ETIME;
8114393c:	00bff084 	movi	r2,-62
81143940:	00008f06 	br	81143b80 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81143944:	e0bff10b 	ldhu	r2,-60(fp)
81143948:	10800044 	addi	r2,r2,1
8114394c:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81143950:	e0bffd17 	ldw	r2,-12(fp)
81143954:	10c00317 	ldw	r3,12(r2)
81143958:	e0bffd17 	ldw	r2,-12(fp)
8114395c:	10800417 	ldw	r2,16(r2)
81143960:	e1bffe17 	ldw	r6,-8(fp)
81143964:	100b883a 	mov	r5,r2
81143968:	1809883a 	mov	r4,r3
8114396c:	1142f000 	call	81142f00 <alt_msgdma_write_standard_descriptor>
81143970:	103fe61e 	bne	r2,zero,8114390c <__reset+0xfb12390c>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81143974:	00002706 	br	81143a14 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81143978:	e0bffe17 	ldw	r2,-8(fp)
8114397c:	10001f1e 	bne	r2,zero,811439fc <alt_msgdma_descriptor_sync_transfer+0x270>
81143980:	e0bfff17 	ldw	r2,-4(fp)
81143984:	10001d26 	beq	r2,zero,811439fc <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81143988:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114398c:	00001106 	br	811439d4 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81143990:	01000044 	movi	r4,1
81143994:	11313000 	call	81131300 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143998:	e0bff10b 	ldhu	r2,-60(fp)
8114399c:	1084e230 	cmpltui	r2,r2,5000
811439a0:	1000091e 	bne	r2,zero,811439c8 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
811439a4:	01204574 	movhi	r4,33045
811439a8:	212d7f04 	addi	r4,r4,-18948
811439ac:	11458a00 	call	811458a0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811439b0:	e0bffd17 	ldw	r2,-12(fp)
811439b4:	10801817 	ldw	r2,96(r2)
811439b8:	1009883a 	mov	r4,r2
811439bc:	1139f000 	call	81139f00 <OSSemPost>
				
                return -ETIME;
811439c0:	00bff084 	movi	r2,-62
811439c4:	00006e06 	br	81143b80 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
811439c8:	e0bff10b 	ldhu	r2,-60(fp)
811439cc:	10800044 	addi	r2,r2,1
811439d0:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811439d4:	e0bffd17 	ldw	r2,-12(fp)
811439d8:	10c00317 	ldw	r3,12(r2)
811439dc:	e0bffd17 	ldw	r2,-12(fp)
811439e0:	10800417 	ldw	r2,16(r2)
811439e4:	e1bfff17 	ldw	r6,-4(fp)
811439e8:	100b883a 	mov	r5,r2
811439ec:	1809883a 	mov	r4,r3
811439f0:	1142f9c0 	call	81142f9c <alt_msgdma_write_extended_descriptor>
811439f4:	103fe61e 	bne	r2,zero,81143990 <__reset+0xfb123990>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811439f8:	00000606 	br	81143a14 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811439fc:	e0bffd17 	ldw	r2,-12(fp)
81143a00:	10801817 	ldw	r2,96(r2)
81143a04:	1009883a 	mov	r4,r2
81143a08:	1139f000 	call	81139f00 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81143a0c:	00bfffc4 	movi	r2,-1
81143a10:	00005b06 	br	81143b80 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81143a14:	e0bffd17 	ldw	r2,-12(fp)
81143a18:	10800317 	ldw	r2,12(r2)
81143a1c:	10800104 	addi	r2,r2,4
81143a20:	e0fffd17 	ldw	r3,-12(fp)
81143a24:	19000d17 	ldw	r4,52(r3)
81143a28:	00fff2c4 	movi	r3,-53
81143a2c:	20c6703a 	and	r3,r4,r3
81143a30:	18c00114 	ori	r3,r3,4
81143a34:	10c00035 	stwio	r3,0(r2)
81143a38:	e0bff517 	ldw	r2,-44(fp)
81143a3c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143a40:	e0bff717 	ldw	r2,-36(fp)
81143a44:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81143a48:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81143a4c:	e0bffd17 	ldw	r2,-12(fp)
81143a50:	10800317 	ldw	r2,12(r2)
81143a54:	10800037 	ldwio	r2,0(r2)
81143a58:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81143a5c:	00001506 	br	81143ab4 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81143a60:	01000044 	movi	r4,1
81143a64:	11313000 	call	81131300 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81143a68:	e0bff10b 	ldhu	r2,-60(fp)
81143a6c:	1084e230 	cmpltui	r2,r2,5000
81143a70:	1000091e 	bne	r2,zero,81143a98 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81143a74:	01204574 	movhi	r4,33045
81143a78:	212d9004 	addi	r4,r4,-18880
81143a7c:	11458a00 	call	811458a0 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81143a80:	e0bffd17 	ldw	r2,-12(fp)
81143a84:	10801817 	ldw	r2,96(r2)
81143a88:	1009883a 	mov	r4,r2
81143a8c:	1139f000 	call	81139f00 <OSSemPost>
			
            return -ETIME;
81143a90:	00bff084 	movi	r2,-62
81143a94:	00003a06 	br	81143b80 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81143a98:	e0bff10b 	ldhu	r2,-60(fp)
81143a9c:	10800044 	addi	r2,r2,1
81143aa0:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81143aa4:	e0bffd17 	ldw	r2,-12(fp)
81143aa8:	10800317 	ldw	r2,12(r2)
81143aac:	10800037 	ldwio	r2,0(r2)
81143ab0:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81143ab4:	e0fff017 	ldw	r3,-64(fp)
81143ab8:	e0bff617 	ldw	r2,-40(fp)
81143abc:	1884703a 	and	r2,r3,r2
81143ac0:	1000031e 	bne	r2,zero,81143ad0 <alt_msgdma_descriptor_sync_transfer+0x344>
81143ac4:	e0bff017 	ldw	r2,-64(fp)
81143ac8:	1080004c 	andi	r2,r2,1
81143acc:	103fe41e 	bne	r2,zero,81143a60 <__reset+0xfb123a60>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81143ad0:	e0fff017 	ldw	r3,-64(fp)
81143ad4:	e0bff617 	ldw	r2,-40(fp)
81143ad8:	1884703a 	and	r2,r3,r2
81143adc:	10000626 	beq	r2,zero,81143af8 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81143ae0:	e0bffd17 	ldw	r2,-12(fp)
81143ae4:	10801817 	ldw	r2,96(r2)
81143ae8:	1009883a 	mov	r4,r2
81143aec:	1139f000 	call	81139f00 <OSSemPost>
		
        return error;
81143af0:	e0bff617 	ldw	r2,-40(fp)
81143af4:	00002206 	br	81143b80 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81143af8:	e0bffd17 	ldw	r2,-12(fp)
81143afc:	10800317 	ldw	r2,12(r2)
81143b00:	10800104 	addi	r2,r2,4
81143b04:	10800037 	ldwio	r2,0(r2)
81143b08:	10800814 	ori	r2,r2,32
81143b0c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143b10:	0005303a 	rdctl	r2,status
81143b14:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143b18:	e0fffa17 	ldw	r3,-24(fp)
81143b1c:	00bfff84 	movi	r2,-2
81143b20:	1884703a 	and	r2,r3,r2
81143b24:	1001703a 	wrctl	status,r2
  
  return context;
81143b28:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81143b2c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81143b30:	e0bffd17 	ldw	r2,-12(fp)
81143b34:	10800317 	ldw	r2,12(r2)
81143b38:	10800104 	addi	r2,r2,4
81143b3c:	e0fff417 	ldw	r3,-48(fp)
81143b40:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81143b44:	e0bffd17 	ldw	r2,-12(fp)
81143b48:	10800317 	ldw	r2,12(r2)
81143b4c:	e0fffd17 	ldw	r3,-12(fp)
81143b50:	18c00317 	ldw	r3,12(r3)
81143b54:	18c00037 	ldwio	r3,0(r3)
81143b58:	10c00035 	stwio	r3,0(r2)
81143b5c:	e0bff517 	ldw	r2,-44(fp)
81143b60:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143b64:	e0bff917 	ldw	r2,-28(fp)
81143b68:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81143b6c:	e0bffd17 	ldw	r2,-12(fp)
81143b70:	10801817 	ldw	r2,96(r2)
81143b74:	1009883a 	mov	r4,r2
81143b78:	1139f000 	call	81139f00 <OSSemPost>
    
    return 0;
81143b7c:	0005883a 	mov	r2,zero

}
81143b80:	e037883a 	mov	sp,fp
81143b84:	dfc00117 	ldw	ra,4(sp)
81143b88:	df000017 	ldw	fp,0(sp)
81143b8c:	dec00204 	addi	sp,sp,8
81143b90:	f800283a 	ret

81143b94 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81143b94:	defff804 	addi	sp,sp,-32
81143b98:	de00012e 	bgeu	sp,et,81143ba0 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81143b9c:	003b68fa 	trap	3
81143ba0:	dfc00715 	stw	ra,28(sp)
81143ba4:	df000615 	stw	fp,24(sp)
81143ba8:	df000604 	addi	fp,sp,24
81143bac:	e13ffc15 	stw	r4,-16(fp)
81143bb0:	e17ffd15 	stw	r5,-12(fp)
81143bb4:	e1bffe15 	stw	r6,-8(fp)
81143bb8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81143bbc:	e0800217 	ldw	r2,8(fp)
81143bc0:	d8800115 	stw	r2,4(sp)
81143bc4:	e0bfff17 	ldw	r2,-4(fp)
81143bc8:	d8800015 	stw	r2,0(sp)
81143bcc:	e1fffe17 	ldw	r7,-8(fp)
81143bd0:	000d883a 	mov	r6,zero
81143bd4:	e17ffd17 	ldw	r5,-12(fp)
81143bd8:	e13ffc17 	ldw	r4,-16(fp)
81143bdc:	114325c0 	call	8114325c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81143be0:	e037883a 	mov	sp,fp
81143be4:	dfc00117 	ldw	ra,4(sp)
81143be8:	df000017 	ldw	fp,0(sp)
81143bec:	dec00204 	addi	sp,sp,8
81143bf0:	f800283a 	ret

81143bf4 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81143bf4:	defff804 	addi	sp,sp,-32
81143bf8:	de00012e 	bgeu	sp,et,81143c00 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81143bfc:	003b68fa 	trap	3
81143c00:	dfc00715 	stw	ra,28(sp)
81143c04:	df000615 	stw	fp,24(sp)
81143c08:	df000604 	addi	fp,sp,24
81143c0c:	e13ffc15 	stw	r4,-16(fp)
81143c10:	e17ffd15 	stw	r5,-12(fp)
81143c14:	e1bffe15 	stw	r6,-8(fp)
81143c18:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81143c1c:	e0800217 	ldw	r2,8(fp)
81143c20:	d8800115 	stw	r2,4(sp)
81143c24:	e0bfff17 	ldw	r2,-4(fp)
81143c28:	d8800015 	stw	r2,0(sp)
81143c2c:	000f883a 	mov	r7,zero
81143c30:	e1bffe17 	ldw	r6,-8(fp)
81143c34:	e17ffd17 	ldw	r5,-12(fp)
81143c38:	e13ffc17 	ldw	r4,-16(fp)
81143c3c:	114325c0 	call	8114325c <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81143c40:	e037883a 	mov	sp,fp
81143c44:	dfc00117 	ldw	ra,4(sp)
81143c48:	df000017 	ldw	fp,0(sp)
81143c4c:	dec00204 	addi	sp,sp,8
81143c50:	f800283a 	ret

81143c54 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143c54:	defff804 	addi	sp,sp,-32
81143c58:	de00012e 	bgeu	sp,et,81143c60 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81143c5c:	003b68fa 	trap	3
81143c60:	dfc00715 	stw	ra,28(sp)
81143c64:	df000615 	stw	fp,24(sp)
81143c68:	df000604 	addi	fp,sp,24
81143c6c:	e13ffc15 	stw	r4,-16(fp)
81143c70:	e17ffd15 	stw	r5,-12(fp)
81143c74:	e1bffe15 	stw	r6,-8(fp)
81143c78:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81143c7c:	e0800317 	ldw	r2,12(fp)
81143c80:	d8800115 	stw	r2,4(sp)
81143c84:	e0800217 	ldw	r2,8(fp)
81143c88:	d8800015 	stw	r2,0(sp)
81143c8c:	e1ffff17 	ldw	r7,-4(fp)
81143c90:	e1bffe17 	ldw	r6,-8(fp)
81143c94:	e17ffd17 	ldw	r5,-12(fp)
81143c98:	e13ffc17 	ldw	r4,-16(fp)
81143c9c:	114325c0 	call	8114325c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81143ca0:	e037883a 	mov	sp,fp
81143ca4:	dfc00117 	ldw	ra,4(sp)
81143ca8:	df000017 	ldw	fp,0(sp)
81143cac:	dec00204 	addi	sp,sp,8
81143cb0:	f800283a 	ret

81143cb4 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81143cb4:	defff004 	addi	sp,sp,-64
81143cb8:	de00012e 	bgeu	sp,et,81143cc0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81143cbc:	003b68fa 	trap	3
81143cc0:	dfc00f15 	stw	ra,60(sp)
81143cc4:	df000e15 	stw	fp,56(sp)
81143cc8:	df000e04 	addi	fp,sp,56
81143ccc:	e13ff915 	stw	r4,-28(fp)
81143cd0:	e17ffa15 	stw	r5,-24(fp)
81143cd4:	e1bffb15 	stw	r6,-20(fp)
81143cd8:	e1fffc15 	stw	r7,-16(fp)
81143cdc:	e1000317 	ldw	r4,12(fp)
81143ce0:	e0c00417 	ldw	r3,16(fp)
81143ce4:	e0800517 	ldw	r2,20(fp)
81143ce8:	e13ffd0d 	sth	r4,-12(fp)
81143cec:	e0fffe05 	stb	r3,-8(fp)
81143cf0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81143cf4:	e0bffd0b 	ldhu	r2,-12(fp)
81143cf8:	e0fffe03 	ldbu	r3,-8(fp)
81143cfc:	e13fff0b 	ldhu	r4,-4(fp)
81143d00:	d9000615 	stw	r4,24(sp)
81143d04:	d8000515 	stw	zero,20(sp)
81143d08:	d8c00415 	stw	r3,16(sp)
81143d0c:	d8000315 	stw	zero,12(sp)
81143d10:	d8800215 	stw	r2,8(sp)
81143d14:	e0800217 	ldw	r2,8(fp)
81143d18:	d8800115 	stw	r2,4(sp)
81143d1c:	e0bffc17 	ldw	r2,-16(fp)
81143d20:	d8800015 	stw	r2,0(sp)
81143d24:	e1fffb17 	ldw	r7,-20(fp)
81143d28:	000d883a 	mov	r6,zero
81143d2c:	e17ffa17 	ldw	r5,-24(fp)
81143d30:	e13ff917 	ldw	r4,-28(fp)
81143d34:	11432f00 	call	811432f0 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81143d38:	e037883a 	mov	sp,fp
81143d3c:	dfc00117 	ldw	ra,4(sp)
81143d40:	df000017 	ldw	fp,0(sp)
81143d44:	dec00204 	addi	sp,sp,8
81143d48:	f800283a 	ret

81143d4c <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81143d4c:	defff004 	addi	sp,sp,-64
81143d50:	de00012e 	bgeu	sp,et,81143d58 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81143d54:	003b68fa 	trap	3
81143d58:	dfc00f15 	stw	ra,60(sp)
81143d5c:	df000e15 	stw	fp,56(sp)
81143d60:	df000e04 	addi	fp,sp,56
81143d64:	e13ff915 	stw	r4,-28(fp)
81143d68:	e17ffa15 	stw	r5,-24(fp)
81143d6c:	e1bffb15 	stw	r6,-20(fp)
81143d70:	e1fffc15 	stw	r7,-16(fp)
81143d74:	e1000317 	ldw	r4,12(fp)
81143d78:	e0c00417 	ldw	r3,16(fp)
81143d7c:	e0800517 	ldw	r2,20(fp)
81143d80:	e13ffd0d 	sth	r4,-12(fp)
81143d84:	e0fffe05 	stb	r3,-8(fp)
81143d88:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81143d8c:	e0bffd0b 	ldhu	r2,-12(fp)
81143d90:	e0fffe03 	ldbu	r3,-8(fp)
81143d94:	e13fff0b 	ldhu	r4,-4(fp)
81143d98:	d8000615 	stw	zero,24(sp)
81143d9c:	d9000515 	stw	r4,20(sp)
81143da0:	d8000415 	stw	zero,16(sp)
81143da4:	d8c00315 	stw	r3,12(sp)
81143da8:	d8800215 	stw	r2,8(sp)
81143dac:	e0800217 	ldw	r2,8(fp)
81143db0:	d8800115 	stw	r2,4(sp)
81143db4:	e0bffc17 	ldw	r2,-16(fp)
81143db8:	d8800015 	stw	r2,0(sp)
81143dbc:	000f883a 	mov	r7,zero
81143dc0:	e1bffb17 	ldw	r6,-20(fp)
81143dc4:	e17ffa17 	ldw	r5,-24(fp)
81143dc8:	e13ff917 	ldw	r4,-28(fp)
81143dcc:	11432f00 	call	811432f0 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81143dd0:	e037883a 	mov	sp,fp
81143dd4:	dfc00117 	ldw	ra,4(sp)
81143dd8:	df000017 	ldw	fp,0(sp)
81143ddc:	dec00204 	addi	sp,sp,8
81143de0:	f800283a 	ret

81143de4 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81143de4:	deffee04 	addi	sp,sp,-72
81143de8:	de00012e 	bgeu	sp,et,81143df0 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81143dec:	003b68fa 	trap	3
81143df0:	dfc01115 	stw	ra,68(sp)
81143df4:	df001015 	stw	fp,64(sp)
81143df8:	df001004 	addi	fp,sp,64
81143dfc:	e13ff715 	stw	r4,-36(fp)
81143e00:	e17ff815 	stw	r5,-32(fp)
81143e04:	e1bff915 	stw	r6,-28(fp)
81143e08:	e1fffa15 	stw	r7,-24(fp)
81143e0c:	e1800417 	ldw	r6,16(fp)
81143e10:	e1400517 	ldw	r5,20(fp)
81143e14:	e1000617 	ldw	r4,24(fp)
81143e18:	e0c00717 	ldw	r3,28(fp)
81143e1c:	e0800817 	ldw	r2,32(fp)
81143e20:	e1bffb0d 	sth	r6,-20(fp)
81143e24:	e17ffc05 	stb	r5,-16(fp)
81143e28:	e13ffd05 	stb	r4,-12(fp)
81143e2c:	e0fffe0d 	sth	r3,-8(fp)
81143e30:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81143e34:	e0bffb0b 	ldhu	r2,-20(fp)
81143e38:	e0fffc03 	ldbu	r3,-16(fp)
81143e3c:	e13ffd03 	ldbu	r4,-12(fp)
81143e40:	e17ffe0b 	ldhu	r5,-8(fp)
81143e44:	e1bfff0b 	ldhu	r6,-4(fp)
81143e48:	d9800615 	stw	r6,24(sp)
81143e4c:	d9400515 	stw	r5,20(sp)
81143e50:	d9000415 	stw	r4,16(sp)
81143e54:	d8c00315 	stw	r3,12(sp)
81143e58:	d8800215 	stw	r2,8(sp)
81143e5c:	e0800317 	ldw	r2,12(fp)
81143e60:	d8800115 	stw	r2,4(sp)
81143e64:	e0800217 	ldw	r2,8(fp)
81143e68:	d8800015 	stw	r2,0(sp)
81143e6c:	e1fffa17 	ldw	r7,-24(fp)
81143e70:	e1bff917 	ldw	r6,-28(fp)
81143e74:	e17ff817 	ldw	r5,-32(fp)
81143e78:	e13ff717 	ldw	r4,-36(fp)
81143e7c:	11432f00 	call	811432f0 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81143e80:	e037883a 	mov	sp,fp
81143e84:	dfc00117 	ldw	ra,4(sp)
81143e88:	df000017 	ldw	fp,0(sp)
81143e8c:	dec00204 	addi	sp,sp,8
81143e90:	f800283a 	ret

81143e94 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143e94:	defffb04 	addi	sp,sp,-20
81143e98:	de00012e 	bgeu	sp,et,81143ea0 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81143e9c:	003b68fa 	trap	3
81143ea0:	df000415 	stw	fp,16(sp)
81143ea4:	df000404 	addi	fp,sp,16
81143ea8:	e13ffc15 	stw	r4,-16(fp)
81143eac:	e17ffd15 	stw	r5,-12(fp)
81143eb0:	e1bffe15 	stw	r6,-8(fp)
81143eb4:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81143eb8:	e0bffc17 	ldw	r2,-16(fp)
81143ebc:	10c01217 	ldw	r3,72(r2)
81143ec0:	e0800117 	ldw	r2,4(fp)
81143ec4:	18800436 	bltu	r3,r2,81143ed8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81143ec8:	e0bffc17 	ldw	r2,-16(fp)
81143ecc:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81143ed0:	10803fcc 	andi	r2,r2,255
81143ed4:	10000226 	beq	r2,zero,81143ee0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81143ed8:	00bffa84 	movi	r2,-22
81143edc:	00001406 	br	81143f30 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81143ee0:	e0bffd17 	ldw	r2,-12(fp)
81143ee4:	e0fffe17 	ldw	r3,-8(fp)
81143ee8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81143eec:	e0bffd17 	ldw	r2,-12(fp)
81143ef0:	e0ffff17 	ldw	r3,-4(fp)
81143ef4:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81143ef8:	e0bffd17 	ldw	r2,-12(fp)
81143efc:	e0c00117 	ldw	r3,4(fp)
81143f00:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81143f04:	e0fffd17 	ldw	r3,-12(fp)
81143f08:	e0bffd17 	ldw	r2,-12(fp)
81143f0c:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81143f10:	e0c00217 	ldw	r3,8(fp)
81143f14:	00900034 	movhi	r2,16384
81143f18:	10bfffc4 	addi	r2,r2,-1
81143f1c:	1884703a 	and	r2,r3,r2
81143f20:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81143f24:	e0bffd17 	ldw	r2,-12(fp)
81143f28:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81143f2c:	0005883a 	mov	r2,zero
}
81143f30:	e037883a 	mov	sp,fp
81143f34:	df000017 	ldw	fp,0(sp)
81143f38:	dec00104 	addi	sp,sp,4
81143f3c:	f800283a 	ret

81143f40 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81143f40:	defff404 	addi	sp,sp,-48
81143f44:	de00012e 	bgeu	sp,et,81143f4c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81143f48:	003b68fa 	trap	3
81143f4c:	df000b15 	stw	fp,44(sp)
81143f50:	df000b04 	addi	fp,sp,44
81143f54:	e13ff715 	stw	r4,-36(fp)
81143f58:	e17ff815 	stw	r5,-32(fp)
81143f5c:	e1bff915 	stw	r6,-28(fp)
81143f60:	e1fffa15 	stw	r7,-24(fp)
81143f64:	e1800517 	ldw	r6,20(fp)
81143f68:	e1400617 	ldw	r5,24(fp)
81143f6c:	e1000717 	ldw	r4,28(fp)
81143f70:	e0c00817 	ldw	r3,32(fp)
81143f74:	e0800917 	ldw	r2,36(fp)
81143f78:	e1bffb0d 	sth	r6,-20(fp)
81143f7c:	e17ffc05 	stb	r5,-16(fp)
81143f80:	e13ffd05 	stb	r4,-12(fp)
81143f84:	e0fffe0d 	sth	r3,-8(fp)
81143f88:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81143f8c:	e0bff717 	ldw	r2,-36(fp)
81143f90:	10c01217 	ldw	r3,72(r2)
81143f94:	e0800317 	ldw	r2,12(fp)
81143f98:	18801936 	bltu	r3,r2,81144000 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81143f9c:	e13ff717 	ldw	r4,-36(fp)
81143fa0:	20801317 	ldw	r2,76(r4)
81143fa4:	20c01417 	ldw	r3,80(r4)
81143fa8:	e13ffe0b 	ldhu	r4,-8(fp)
81143fac:	213fffcc 	andi	r4,r4,65535
81143fb0:	2015883a 	mov	r10,r4
81143fb4:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81143fb8:	1ac01136 	bltu	r3,r11,81144000 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81143fbc:	58c0011e 	bne	r11,r3,81143fc4 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81143fc0:	12800f36 	bltu	r2,r10,81144000 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81143fc4:	e13ff717 	ldw	r4,-36(fp)
81143fc8:	20801317 	ldw	r2,76(r4)
81143fcc:	20c01417 	ldw	r3,80(r4)
81143fd0:	e13fff0b 	ldhu	r4,-4(fp)
81143fd4:	213fffcc 	andi	r4,r4,65535
81143fd8:	2011883a 	mov	r8,r4
81143fdc:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81143fe0:	1a400736 	bltu	r3,r9,81144000 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81143fe4:	48c0011e 	bne	r9,r3,81143fec <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81143fe8:	12000536 	bltu	r2,r8,81144000 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81143fec:	e0bff717 	ldw	r2,-36(fp)
81143ff0:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81143ff4:	10803fcc 	andi	r2,r2,255
81143ff8:	10800060 	cmpeqi	r2,r2,1
81143ffc:	1000021e 	bne	r2,zero,81144008 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81144000:	00bffa84 	movi	r2,-22
81144004:	00003106 	br	811440cc <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81144008:	e0bff817 	ldw	r2,-32(fp)
8114400c:	e0fff917 	ldw	r3,-28(fp)
81144010:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81144014:	e0bff817 	ldw	r2,-32(fp)
81144018:	e0fffa17 	ldw	r3,-24(fp)
8114401c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81144020:	e0bff817 	ldw	r2,-32(fp)
81144024:	e0c00117 	ldw	r3,4(fp)
81144028:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114402c:	e0bff817 	ldw	r2,-32(fp)
81144030:	e0c00217 	ldw	r3,8(fp)
81144034:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81144038:	e0bff817 	ldw	r2,-32(fp)
8114403c:	e0c00317 	ldw	r3,12(fp)
81144040:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81144044:	e0bff817 	ldw	r2,-32(fp)
81144048:	e0fffb0b 	ldhu	r3,-20(fp)
8114404c:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81144050:	e0bff817 	ldw	r2,-32(fp)
81144054:	e0fffc03 	ldbu	r3,-16(fp)
81144058:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114405c:	e0bff817 	ldw	r2,-32(fp)
81144060:	e0fffd03 	ldbu	r3,-12(fp)
81144064:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81144068:	e0bff817 	ldw	r2,-32(fp)
8114406c:	e0fffe0b 	ldhu	r3,-8(fp)
81144070:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81144074:	e0bff817 	ldw	r2,-32(fp)
81144078:	e0ffff0b 	ldhu	r3,-4(fp)
8114407c:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81144080:	e0bff817 	ldw	r2,-32(fp)
81144084:	1019883a 	mov	r12,r2
81144088:	001b883a 	mov	r13,zero
8114408c:	e33ff515 	stw	r12,-44(fp)
81144090:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81144094:	e0fff517 	ldw	r3,-44(fp)
81144098:	e0bff817 	ldw	r2,-32(fp)
8114409c:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
811440a0:	e0fff617 	ldw	r3,-40(fp)
811440a4:	e0bff817 	ldw	r2,-32(fp)
811440a8:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811440ac:	e0c00417 	ldw	r3,16(fp)
811440b0:	00900034 	movhi	r2,16384
811440b4:	10bfffc4 	addi	r2,r2,-1
811440b8:	1884703a 	and	r2,r3,r2
811440bc:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
811440c0:	e0bff817 	ldw	r2,-32(fp)
811440c4:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
811440c8:	0005883a 	mov	r2,zero
}
811440cc:	e037883a 	mov	sp,fp
811440d0:	df000017 	ldw	fp,0(sp)
811440d4:	dec00104 	addi	sp,sp,4
811440d8:	f800283a 	ret

811440dc <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
811440dc:	defff804 	addi	sp,sp,-32
811440e0:	de00012e 	bgeu	sp,et,811440e8 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
811440e4:	003b68fa 	trap	3
811440e8:	dfc00715 	stw	ra,28(sp)
811440ec:	df000615 	stw	fp,24(sp)
811440f0:	df000604 	addi	fp,sp,24
811440f4:	e13ffc15 	stw	r4,-16(fp)
811440f8:	e17ffd15 	stw	r5,-12(fp)
811440fc:	e1bffe15 	stw	r6,-8(fp)
81144100:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81144104:	e0800317 	ldw	r2,12(fp)
81144108:	d8800115 	stw	r2,4(sp)
8114410c:	e0800217 	ldw	r2,8(fp)
81144110:	d8800015 	stw	r2,0(sp)
81144114:	e1ffff17 	ldw	r7,-4(fp)
81144118:	e1bffe17 	ldw	r6,-8(fp)
8114411c:	e17ffd17 	ldw	r5,-12(fp)
81144120:	e13ffc17 	ldw	r4,-16(fp)
81144124:	1143e940 	call	81143e94 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81144128:	e037883a 	mov	sp,fp
8114412c:	dfc00117 	ldw	ra,4(sp)
81144130:	df000017 	ldw	fp,0(sp)
81144134:	dec00204 	addi	sp,sp,8
81144138:	f800283a 	ret

8114413c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114413c:	defff804 	addi	sp,sp,-32
81144140:	de00012e 	bgeu	sp,et,81144148 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81144144:	003b68fa 	trap	3
81144148:	dfc00715 	stw	ra,28(sp)
8114414c:	df000615 	stw	fp,24(sp)
81144150:	df000604 	addi	fp,sp,24
81144154:	e13ffc15 	stw	r4,-16(fp)
81144158:	e17ffd15 	stw	r5,-12(fp)
8114415c:	e1bffe15 	stw	r6,-8(fp)
81144160:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81144164:	e0800217 	ldw	r2,8(fp)
81144168:	d8800115 	stw	r2,4(sp)
8114416c:	e0bfff17 	ldw	r2,-4(fp)
81144170:	d8800015 	stw	r2,0(sp)
81144174:	e1fffe17 	ldw	r7,-8(fp)
81144178:	000d883a 	mov	r6,zero
8114417c:	e17ffd17 	ldw	r5,-12(fp)
81144180:	e13ffc17 	ldw	r4,-16(fp)
81144184:	1143e940 	call	81143e94 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81144188:	e037883a 	mov	sp,fp
8114418c:	dfc00117 	ldw	ra,4(sp)
81144190:	df000017 	ldw	fp,0(sp)
81144194:	dec00204 	addi	sp,sp,8
81144198:	f800283a 	ret

8114419c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114419c:	defff804 	addi	sp,sp,-32
811441a0:	de00012e 	bgeu	sp,et,811441a8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
811441a4:	003b68fa 	trap	3
811441a8:	dfc00715 	stw	ra,28(sp)
811441ac:	df000615 	stw	fp,24(sp)
811441b0:	df000604 	addi	fp,sp,24
811441b4:	e13ffc15 	stw	r4,-16(fp)
811441b8:	e17ffd15 	stw	r5,-12(fp)
811441bc:	e1bffe15 	stw	r6,-8(fp)
811441c0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811441c4:	e0800217 	ldw	r2,8(fp)
811441c8:	d8800115 	stw	r2,4(sp)
811441cc:	e0bfff17 	ldw	r2,-4(fp)
811441d0:	d8800015 	stw	r2,0(sp)
811441d4:	000f883a 	mov	r7,zero
811441d8:	e1bffe17 	ldw	r6,-8(fp)
811441dc:	e17ffd17 	ldw	r5,-12(fp)
811441e0:	e13ffc17 	ldw	r4,-16(fp)
811441e4:	1143e940 	call	81143e94 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
811441e8:	e037883a 	mov	sp,fp
811441ec:	dfc00117 	ldw	ra,4(sp)
811441f0:	df000017 	ldw	fp,0(sp)
811441f4:	dec00204 	addi	sp,sp,8
811441f8:	f800283a 	ret

811441fc <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
811441fc:	deffee04 	addi	sp,sp,-72
81144200:	de00012e 	bgeu	sp,et,81144208 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81144204:	003b68fa 	trap	3
81144208:	dfc01115 	stw	ra,68(sp)
8114420c:	df001015 	stw	fp,64(sp)
81144210:	df001004 	addi	fp,sp,64
81144214:	e13ff915 	stw	r4,-28(fp)
81144218:	e17ffa15 	stw	r5,-24(fp)
8114421c:	e1bffb15 	stw	r6,-20(fp)
81144220:	e1fffc15 	stw	r7,-16(fp)
81144224:	e1000417 	ldw	r4,16(fp)
81144228:	e0c00517 	ldw	r3,20(fp)
8114422c:	e0800617 	ldw	r2,24(fp)
81144230:	e13ffd0d 	sth	r4,-12(fp)
81144234:	e0fffe05 	stb	r3,-8(fp)
81144238:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114423c:	e0bffd0b 	ldhu	r2,-12(fp)
81144240:	e0fffe03 	ldbu	r3,-8(fp)
81144244:	e13fff0b 	ldhu	r4,-4(fp)
81144248:	d9000815 	stw	r4,32(sp)
8114424c:	d8000715 	stw	zero,28(sp)
81144250:	d8c00615 	stw	r3,24(sp)
81144254:	d8000515 	stw	zero,20(sp)
81144258:	d8800415 	stw	r2,16(sp)
8114425c:	e0800317 	ldw	r2,12(fp)
81144260:	d8800315 	stw	r2,12(sp)
81144264:	e0800217 	ldw	r2,8(fp)
81144268:	d8800215 	stw	r2,8(sp)
8114426c:	e0bffc17 	ldw	r2,-16(fp)
81144270:	d8800115 	stw	r2,4(sp)
81144274:	e0bffb17 	ldw	r2,-20(fp)
81144278:	d8800015 	stw	r2,0(sp)
8114427c:	000f883a 	mov	r7,zero
81144280:	000d883a 	mov	r6,zero
81144284:	e17ffa17 	ldw	r5,-24(fp)
81144288:	e13ff917 	ldw	r4,-28(fp)
8114428c:	1143f400 	call	81143f40 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81144290:	e037883a 	mov	sp,fp
81144294:	dfc00117 	ldw	ra,4(sp)
81144298:	df000017 	ldw	fp,0(sp)
8114429c:	dec00204 	addi	sp,sp,8
811442a0:	f800283a 	ret

811442a4 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
811442a4:	deffee04 	addi	sp,sp,-72
811442a8:	de00012e 	bgeu	sp,et,811442b0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
811442ac:	003b68fa 	trap	3
811442b0:	dfc01115 	stw	ra,68(sp)
811442b4:	df001015 	stw	fp,64(sp)
811442b8:	df001004 	addi	fp,sp,64
811442bc:	e13ff915 	stw	r4,-28(fp)
811442c0:	e17ffa15 	stw	r5,-24(fp)
811442c4:	e1bffb15 	stw	r6,-20(fp)
811442c8:	e1fffc15 	stw	r7,-16(fp)
811442cc:	e1000417 	ldw	r4,16(fp)
811442d0:	e0c00517 	ldw	r3,20(fp)
811442d4:	e0800617 	ldw	r2,24(fp)
811442d8:	e13ffd0d 	sth	r4,-12(fp)
811442dc:	e0fffe05 	stb	r3,-8(fp)
811442e0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811442e4:	e0bffd0b 	ldhu	r2,-12(fp)
811442e8:	e0fffe03 	ldbu	r3,-8(fp)
811442ec:	e13fff0b 	ldhu	r4,-4(fp)
811442f0:	d8000815 	stw	zero,32(sp)
811442f4:	d9000715 	stw	r4,28(sp)
811442f8:	d8000615 	stw	zero,24(sp)
811442fc:	d8c00515 	stw	r3,20(sp)
81144300:	d8800415 	stw	r2,16(sp)
81144304:	e0800317 	ldw	r2,12(fp)
81144308:	d8800315 	stw	r2,12(sp)
8114430c:	e0800217 	ldw	r2,8(fp)
81144310:	d8800215 	stw	r2,8(sp)
81144314:	d8000115 	stw	zero,4(sp)
81144318:	d8000015 	stw	zero,0(sp)
8114431c:	e1fffc17 	ldw	r7,-16(fp)
81144320:	e1bffb17 	ldw	r6,-20(fp)
81144324:	e17ffa17 	ldw	r5,-24(fp)
81144328:	e13ff917 	ldw	r4,-28(fp)
8114432c:	1143f400 	call	81143f40 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81144330:	e037883a 	mov	sp,fp
81144334:	dfc00117 	ldw	ra,4(sp)
81144338:	df000017 	ldw	fp,0(sp)
8114433c:	dec00204 	addi	sp,sp,8
81144340:	f800283a 	ret

81144344 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81144344:	deffec04 	addi	sp,sp,-80
81144348:	de00012e 	bgeu	sp,et,81144350 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114434c:	003b68fa 	trap	3
81144350:	dfc01315 	stw	ra,76(sp)
81144354:	df001215 	stw	fp,72(sp)
81144358:	df001204 	addi	fp,sp,72
8114435c:	e13ff715 	stw	r4,-36(fp)
81144360:	e17ff815 	stw	r5,-32(fp)
81144364:	e1bff915 	stw	r6,-28(fp)
81144368:	e1fffa15 	stw	r7,-24(fp)
8114436c:	e1800617 	ldw	r6,24(fp)
81144370:	e1400717 	ldw	r5,28(fp)
81144374:	e1000817 	ldw	r4,32(fp)
81144378:	e0c00917 	ldw	r3,36(fp)
8114437c:	e0800a17 	ldw	r2,40(fp)
81144380:	e1bffb0d 	sth	r6,-20(fp)
81144384:	e17ffc05 	stb	r5,-16(fp)
81144388:	e13ffd05 	stb	r4,-12(fp)
8114438c:	e0fffe0d 	sth	r3,-8(fp)
81144390:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81144394:	e0bffb0b 	ldhu	r2,-20(fp)
81144398:	e0fffc03 	ldbu	r3,-16(fp)
8114439c:	e13ffd03 	ldbu	r4,-12(fp)
811443a0:	e17ffe0b 	ldhu	r5,-8(fp)
811443a4:	e1bfff0b 	ldhu	r6,-4(fp)
811443a8:	d9800815 	stw	r6,32(sp)
811443ac:	d9400715 	stw	r5,28(sp)
811443b0:	d9000615 	stw	r4,24(sp)
811443b4:	d8c00515 	stw	r3,20(sp)
811443b8:	d8800415 	stw	r2,16(sp)
811443bc:	e0800517 	ldw	r2,20(fp)
811443c0:	d8800315 	stw	r2,12(sp)
811443c4:	e0800417 	ldw	r2,16(fp)
811443c8:	d8800215 	stw	r2,8(sp)
811443cc:	e0800317 	ldw	r2,12(fp)
811443d0:	d8800115 	stw	r2,4(sp)
811443d4:	e0800217 	ldw	r2,8(fp)
811443d8:	d8800015 	stw	r2,0(sp)
811443dc:	e1fffa17 	ldw	r7,-24(fp)
811443e0:	e1bff917 	ldw	r6,-28(fp)
811443e4:	e17ff817 	ldw	r5,-32(fp)
811443e8:	e13ff717 	ldw	r4,-36(fp)
811443ec:	1143f400 	call	81143f40 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
811443f0:	e037883a 	mov	sp,fp
811443f4:	dfc00117 	ldw	ra,4(sp)
811443f8:	df000017 	ldw	fp,0(sp)
811443fc:	dec00204 	addi	sp,sp,8
81144400:	f800283a 	ret

81144404 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81144404:	defffc04 	addi	sp,sp,-16
81144408:	de00012e 	bgeu	sp,et,81144410 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114440c:	003b68fa 	trap	3
81144410:	df000315 	stw	fp,12(sp)
81144414:	df000304 	addi	fp,sp,12
81144418:	e13ffe15 	stw	r4,-8(fp)
8114441c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81144420:	e0bfff17 	ldw	r2,-4(fp)
81144424:	1000021e 	bne	r2,zero,81144430 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81144428:	00bffa84 	movi	r2,-22
8114442c:	00002f06 	br	811444ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81144430:	e0bfff17 	ldw	r2,-4(fp)
81144434:	10c00317 	ldw	r3,12(r2)
81144438:	e0bfff17 	ldw	r2,-4(fp)
8114443c:	18800226 	beq	r3,r2,81144448 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81144440:	00bffa84 	movi	r2,-22
81144444:	00002906 	br	811444ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81144448:	e0bffe17 	ldw	r2,-8(fp)
8114444c:	10800017 	ldw	r2,0(r2)
81144450:	1000051e 	bne	r2,zero,81144468 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81144454:	e0bffe17 	ldw	r2,-8(fp)
81144458:	e0ffff17 	ldw	r3,-4(fp)
8114445c:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81144460:	0005883a 	mov	r2,zero
81144464:	00002106 	br	811444ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81144468:	e0bffe17 	ldw	r2,-8(fp)
8114446c:	10c00017 	ldw	r3,0(r2)
81144470:	e0bfff17 	ldw	r2,-4(fp)
81144474:	1880021e 	bne	r3,r2,81144480 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81144478:	00bffa84 	movi	r2,-22
8114447c:	00001b06 	br	811444ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81144480:	e0bffe17 	ldw	r2,-8(fp)
81144484:	10800017 	ldw	r2,0(r2)
81144488:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114448c:	00000906 	br	811444b4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81144490:	e0bffd17 	ldw	r2,-12(fp)
81144494:	10c00317 	ldw	r3,12(r2)
81144498:	e0bfff17 	ldw	r2,-4(fp)
8114449c:	1880021e 	bne	r3,r2,811444a8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811444a0:	00bffa84 	movi	r2,-22
811444a4:	00001106 	br	811444ec <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811444a8:	e0bffd17 	ldw	r2,-12(fp)
811444ac:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
811444b0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811444b4:	e0bffd17 	ldw	r2,-12(fp)
811444b8:	10800317 	ldw	r2,12(r2)
811444bc:	e0fffe17 	ldw	r3,-8(fp)
811444c0:	18c00017 	ldw	r3,0(r3)
811444c4:	10fff21e 	bne	r2,r3,81144490 <__reset+0xfb124490>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
811444c8:	e0ffff17 	ldw	r3,-4(fp)
811444cc:	e0bffd17 	ldw	r2,-12(fp)
811444d0:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
811444d4:	e0bffe17 	ldw	r2,-8(fp)
811444d8:	10800017 	ldw	r2,0(r2)
811444dc:	1007883a 	mov	r3,r2
811444e0:	e0bfff17 	ldw	r2,-4(fp)
811444e4:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
811444e8:	0005883a 	mov	r2,zero
}
811444ec:	e037883a 	mov	sp,fp
811444f0:	df000017 	ldw	fp,0(sp)
811444f4:	dec00104 	addi	sp,sp,4
811444f8:	f800283a 	ret

811444fc <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
811444fc:	defff804 	addi	sp,sp,-32
81144500:	de00012e 	bgeu	sp,et,81144508 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81144504:	003b68fa 	trap	3
81144508:	df000715 	stw	fp,28(sp)
8114450c:	df000704 	addi	fp,sp,28
81144510:	e13ffe15 	stw	r4,-8(fp)
81144514:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81144518:	e13fff17 	ldw	r4,-4(fp)
8114451c:	2000021e 	bne	r4,zero,81144528 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81144520:	00bffa84 	movi	r2,-22
81144524:	00005906 	br	8114468c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81144528:	e13fff17 	ldw	r4,-4(fp)
8114452c:	2015883a 	mov	r10,r4
81144530:	0017883a 	mov	r11,zero
81144534:	e2bffc15 	stw	r10,-16(fp)
81144538:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114453c:	e13fff17 	ldw	r4,-4(fp)
81144540:	21400317 	ldw	r5,12(r4)
81144544:	e13ffc17 	ldw	r4,-16(fp)
81144548:	29000626 	beq	r5,r4,81144564 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114454c:	e13fff17 	ldw	r4,-4(fp)
81144550:	21400b17 	ldw	r5,44(r4)
81144554:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81144558:	29000226 	beq	r5,r4,81144564 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114455c:	00bffa84 	movi	r2,-22
81144560:	00004a06 	br	8114468c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81144564:	e13ffe17 	ldw	r4,-8(fp)
81144568:	21000017 	ldw	r4,0(r4)
8114456c:	2000051e 	bne	r4,zero,81144584 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81144570:	e0bffe17 	ldw	r2,-8(fp)
81144574:	e0ffff17 	ldw	r3,-4(fp)
81144578:	10c00015 	stw	r3,0(r2)
		return 0;
8114457c:	0005883a 	mov	r2,zero
81144580:	00004206 	br	8114468c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81144584:	e13ffe17 	ldw	r4,-8(fp)
81144588:	21400017 	ldw	r5,0(r4)
8114458c:	e13fff17 	ldw	r4,-4(fp)
81144590:	2900021e 	bne	r5,r4,8114459c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81144594:	00bffa84 	movi	r2,-22
81144598:	00003c06 	br	8114468c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
8114459c:	e13ffe17 	ldw	r4,-8(fp)
811445a0:	21000017 	ldw	r4,0(r4)
811445a4:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811445a8:	e13ffe17 	ldw	r4,-8(fp)
811445ac:	21000017 	ldw	r4,0(r4)
811445b0:	2011883a 	mov	r8,r4
811445b4:	0013883a 	mov	r9,zero
811445b8:	e23ffa15 	stw	r8,-24(fp)
811445bc:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811445c0:	00001806 	br	81144624 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
811445c4:	e13fff17 	ldw	r4,-4(fp)
811445c8:	200d883a 	mov	r6,r4
811445cc:	000f883a 	mov	r7,zero
811445d0:	e1bffc15 	stw	r6,-16(fp)
811445d4:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
811445d8:	e13ff917 	ldw	r4,-28(fp)
811445dc:	21400317 	ldw	r5,12(r4)
811445e0:	e13ffc17 	ldw	r4,-16(fp)
811445e4:	2900061e 	bne	r5,r4,81144600 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
811445e8:	e13ff917 	ldw	r4,-28(fp)
811445ec:	21400b17 	ldw	r5,44(r4)
811445f0:	e13ffd17 	ldw	r4,-12(fp)
811445f4:	2900021e 	bne	r5,r4,81144600 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811445f8:	00bffa84 	movi	r2,-22
811445fc:	00002306 	br	8114468c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81144600:	e13ff917 	ldw	r4,-28(fp)
81144604:	21000317 	ldw	r4,12(r4)
81144608:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114460c:	e13ff917 	ldw	r4,-28(fp)
81144610:	21000b17 	ldw	r4,44(r4)
81144614:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81144618:	e13ffc17 	ldw	r4,-16(fp)
8114461c:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81144620:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144624:	e13ff917 	ldw	r4,-28(fp)
81144628:	21400317 	ldw	r5,12(r4)
8114462c:	e13ffa17 	ldw	r4,-24(fp)
81144630:	29000426 	beq	r5,r4,81144644 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81144634:	e13ff917 	ldw	r4,-28(fp)
81144638:	21400b17 	ldw	r5,44(r4)
8114463c:	e13ffb17 	ldw	r4,-20(fp)
81144640:	293fe01e 	bne	r5,r4,811445c4 <__reset+0xfb1245c4>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81144644:	e13fff17 	ldw	r4,-4(fp)
81144648:	2005883a 	mov	r2,r4
8114464c:	0007883a 	mov	r3,zero
81144650:	e0bffc15 	stw	r2,-16(fp)
81144654:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81144658:	e0fffc17 	ldw	r3,-16(fp)
8114465c:	e0bff917 	ldw	r2,-28(fp)
81144660:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81144664:	e0fffd17 	ldw	r3,-12(fp)
81144668:	e0bff917 	ldw	r2,-28(fp)
8114466c:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81144670:	e0fffa17 	ldw	r3,-24(fp)
81144674:	e0bfff17 	ldw	r2,-4(fp)
81144678:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8114467c:	e0fffb17 	ldw	r3,-20(fp)
81144680:	e0bfff17 	ldw	r2,-4(fp)
81144684:	10c00b15 	stw	r3,44(r2)
	return 0;
81144688:	0005883a 	mov	r2,zero
}
8114468c:	e037883a 	mov	sp,fp
81144690:	df000017 	ldw	fp,0(sp)
81144694:	dec00104 	addi	sp,sp,4
81144698:	f800283a 	ret

8114469c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
8114469c:	defffc04 	addi	sp,sp,-16
811446a0:	de00012e 	bgeu	sp,et,811446a8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811446a4:	003b68fa 	trap	3
811446a8:	df000315 	stw	fp,12(sp)
811446ac:	df000304 	addi	fp,sp,12
811446b0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811446b4:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
811446b8:	e0bfff17 	ldw	r2,-4(fp)
811446bc:	1000021e 	bne	r2,zero,811446c8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811446c0:	00bffa84 	movi	r2,-22
811446c4:	00001906 	br	8114472c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811446c8:	e0bfff17 	ldw	r2,-4(fp)
811446cc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811446d0:	00000a06 	br	811446fc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
811446d4:	e0bffd17 	ldw	r2,-12(fp)
811446d8:	10800717 	ldw	r2,28(r2)
811446dc:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811446e0:	e0bffe17 	ldw	r2,-8(fp)
811446e4:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811446e8:	e0bffd17 	ldw	r2,-12(fp)
811446ec:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811446f0:	e0bffd17 	ldw	r2,-12(fp)
811446f4:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
811446f8:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811446fc:	e0bffd17 	ldw	r2,-12(fp)
81144700:	10c00317 	ldw	r3,12(r2)
81144704:	e0bfff17 	ldw	r2,-4(fp)
81144708:	18bff21e 	bne	r3,r2,811446d4 <__reset+0xfb1246d4>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8114470c:	e0bffd17 	ldw	r2,-12(fp)
81144710:	10800717 	ldw	r2,28(r2)
81144714:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81144718:	e0bffe17 	ldw	r2,-8(fp)
8114471c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81144720:	e0bffd17 	ldw	r2,-12(fp)
81144724:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
81144728:	0005883a 	mov	r2,zero
}
8114472c:	e037883a 	mov	sp,fp
81144730:	df000017 	ldw	fp,0(sp)
81144734:	dec00104 	addi	sp,sp,4
81144738:	f800283a 	ret

8114473c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8114473c:	defff804 	addi	sp,sp,-32
81144740:	de00012e 	bgeu	sp,et,81144748 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81144744:	003b68fa 	trap	3
81144748:	df000715 	stw	fp,28(sp)
8114474c:	df000704 	addi	fp,sp,28
81144750:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81144754:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81144758:	e13fff17 	ldw	r4,-4(fp)
8114475c:	2000021e 	bne	r4,zero,81144768 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81144760:	00bffa84 	movi	r2,-22
81144764:	00002806 	br	81144808 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81144768:	e13fff17 	ldw	r4,-4(fp)
8114476c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81144770:	e13fff17 	ldw	r4,-4(fp)
81144774:	2005883a 	mov	r2,r4
81144778:	0007883a 	mov	r3,zero
8114477c:	e0bffb15 	stw	r2,-20(fp)
81144780:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81144784:	00001006 	br	811447c8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
81144788:	e0bff917 	ldw	r2,-28(fp)
8114478c:	10800f17 	ldw	r2,60(r2)
81144790:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81144794:	e0bffa17 	ldw	r2,-24(fp)
81144798:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114479c:	e0bff917 	ldw	r2,-28(fp)
811447a0:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811447a4:	e0bff917 	ldw	r2,-28(fp)
811447a8:	10800317 	ldw	r2,12(r2)
811447ac:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811447b0:	e0bff917 	ldw	r2,-28(fp)
811447b4:	10800b17 	ldw	r2,44(r2)
811447b8:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811447bc:	e0bffd17 	ldw	r2,-12(fp)
811447c0:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811447c4:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811447c8:	e0bff917 	ldw	r2,-28(fp)
811447cc:	10c00317 	ldw	r3,12(r2)
811447d0:	e0bffb17 	ldw	r2,-20(fp)
811447d4:	18800426 	beq	r3,r2,811447e8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
811447d8:	e0bff917 	ldw	r2,-28(fp)
811447dc:	10c00b17 	ldw	r3,44(r2)
811447e0:	e0bffc17 	ldw	r2,-16(fp)
811447e4:	18bfe81e 	bne	r3,r2,81144788 <__reset+0xfb124788>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
811447e8:	e0bff917 	ldw	r2,-28(fp)
811447ec:	10800f17 	ldw	r2,60(r2)
811447f0:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811447f4:	e0bffa17 	ldw	r2,-24(fp)
811447f8:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811447fc:	e0bff917 	ldw	r2,-28(fp)
81144800:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81144804:	0005883a 	mov	r2,zero
}
81144808:	e037883a 	mov	sp,fp
8114480c:	df000017 	ldw	fp,0(sp)
81144810:	dec00104 	addi	sp,sp,4
81144814:	f800283a 	ret

81144818 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81144818:	deffeb04 	addi	sp,sp,-84
8114481c:	de00012e 	bgeu	sp,et,81144824 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81144820:	003b68fa 	trap	3
81144824:	dfc01415 	stw	ra,80(sp)
81144828:	df001315 	stw	fp,76(sp)
8114482c:	df001304 	addi	fp,sp,76
81144830:	e13ffb15 	stw	r4,-20(fp)
81144834:	e17ffc15 	stw	r5,-16(fp)
81144838:	e1bffd15 	stw	r6,-12(fp)
8114483c:	3807883a 	mov	r3,r7
81144840:	e0800217 	ldw	r2,8(fp)
81144844:	e0fffe05 	stb	r3,-8(fp)
81144848:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8114484c:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81144850:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81144854:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
81144858:	e0bffc17 	ldw	r2,-16(fp)
8114485c:	e0bff815 	stw	r2,-32(fp)
81144860:	e0bffd17 	ldw	r2,-12(fp)
81144864:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
81144868:	e0bffb17 	ldw	r2,-20(fp)
8114486c:	10801817 	ldw	r2,96(r2)
81144870:	e0bff615 	stw	r2,-40(fp)
81144874:	e03ff70d 	sth	zero,-36(fp)
81144878:	e0bff70b 	ldhu	r2,-36(fp)
8114487c:	e0fffa04 	addi	r3,fp,-24
81144880:	180d883a 	mov	r6,r3
81144884:	100b883a 	mov	r5,r2
81144888:	e13ff617 	ldw	r4,-40(fp)
8114488c:	1139b780 	call	81139b78 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
81144890:	e0bffb17 	ldw	r2,-20(fp)
81144894:	10800617 	ldw	r2,24(r2)
81144898:	10800037 	ldwio	r2,0(r2)
8114489c:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
811448a0:	e0bfed17 	ldw	r2,-76(fp)
811448a4:	1080004c 	andi	r2,r2,1
811448a8:	10000626 	beq	r2,zero,811448c4 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
811448ac:	e0bffb17 	ldw	r2,-20(fp)
811448b0:	10801817 	ldw	r2,96(r2)
811448b4:	1009883a 	mov	r4,r2
811448b8:	1139f000 	call	81139f00 <OSSemPost>
		return -EBUSY;
811448bc:	00bffc04 	movi	r2,-16
811448c0:	00009606 	br	81144b1c <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811448c4:	00800804 	movi	r2,32
811448c8:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811448cc:	0005303a 	rdctl	r2,status
811448d0:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811448d4:	e0fff217 	ldw	r3,-56(fp)
811448d8:	00bfff84 	movi	r2,-2
811448dc:	1884703a 	and	r2,r3,r2
811448e0:	1001703a 	wrctl	status,r2
  
  return context;
811448e4:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811448e8:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811448ec:	e0bffb17 	ldw	r2,-20(fp)
811448f0:	10800317 	ldw	r2,12(r2)
811448f4:	10800104 	addi	r2,r2,4
811448f8:	e0ffee17 	ldw	r3,-72(fp)
811448fc:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
81144900:	e0bffb17 	ldw	r2,-20(fp)
81144904:	10800317 	ldw	r2,12(r2)
81144908:	e0fffb17 	ldw	r3,-20(fp)
8114490c:	18c00317 	ldw	r3,12(r3)
81144910:	18c00037 	ldwio	r3,0(r3)
81144914:	10c00035 	stwio	r3,0(r2)
81144918:	e0bfef17 	ldw	r2,-68(fp)
8114491c:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144920:	e0bff017 	ldw	r2,-64(fp)
81144924:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81144928:	e0bffb17 	ldw	r2,-20(fp)
8114492c:	10800b17 	ldw	r2,44(r2)
81144930:	10002326 	beq	r2,zero,811449c0 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81144934:	e0bffb17 	ldw	r2,-20(fp)
81144938:	10c00d17 	ldw	r3,52(r2)
8114493c:	e0bfee17 	ldw	r2,-72(fp)
81144940:	1884b03a 	or	r2,r3,r2
81144944:	10800514 	ori	r2,r2,20
81144948:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8114494c:	e0ffee17 	ldw	r3,-72(fp)
81144950:	00bff7c4 	movi	r2,-33
81144954:	1884703a 	and	r2,r3,r2
81144958:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114495c:	e0bfed17 	ldw	r2,-76(fp)
81144960:	10800214 	ori	r2,r2,8
81144964:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144968:	0005303a 	rdctl	r2,status
8114496c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144970:	e0fff417 	ldw	r3,-48(fp)
81144974:	00bfff84 	movi	r2,-2
81144978:	1884703a 	and	r2,r3,r2
8114497c:	1001703a 	wrctl	status,r2
  
  return context;
81144980:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81144984:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81144988:	e0bffb17 	ldw	r2,-20(fp)
8114498c:	10800317 	ldw	r2,12(r2)
81144990:	10800104 	addi	r2,r2,4
81144994:	e0ffee17 	ldw	r3,-72(fp)
81144998:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
8114499c:	e0bffb17 	ldw	r2,-20(fp)
811449a0:	10800617 	ldw	r2,24(r2)
811449a4:	e0ffed17 	ldw	r3,-76(fp)
811449a8:	10c00035 	stwio	r3,0(r2)
811449ac:	e0bfef17 	ldw	r2,-68(fp)
811449b0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811449b4:	e0bff117 	ldw	r2,-60(fp)
811449b8:	1001703a 	wrctl	status,r2
811449bc:	00002306 	br	81144a4c <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
811449c0:	e0bffb17 	ldw	r2,-20(fp)
811449c4:	10c00d17 	ldw	r3,52(r2)
811449c8:	e0bfee17 	ldw	r2,-72(fp)
811449cc:	1884b03a 	or	r2,r3,r2
811449d0:	10800114 	ori	r2,r2,4
811449d4:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
811449d8:	e0ffee17 	ldw	r3,-72(fp)
811449dc:	00bff3c4 	movi	r2,-49
811449e0:	1884703a 	and	r2,r3,r2
811449e4:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
811449e8:	e0ffed17 	ldw	r3,-76(fp)
811449ec:	00bffdc4 	movi	r2,-9
811449f0:	1884703a 	and	r2,r3,r2
811449f4:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811449f8:	0005303a 	rdctl	r2,status
811449fc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144a00:	e0fff517 	ldw	r3,-44(fp)
81144a04:	00bfff84 	movi	r2,-2
81144a08:	1884703a 	and	r2,r3,r2
81144a0c:	1001703a 	wrctl	status,r2
  
  return context;
81144a10:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81144a14:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81144a18:	e0bffb17 	ldw	r2,-20(fp)
81144a1c:	10800317 	ldw	r2,12(r2)
81144a20:	10800104 	addi	r2,r2,4
81144a24:	e0ffee17 	ldw	r3,-72(fp)
81144a28:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81144a2c:	e0bffb17 	ldw	r2,-20(fp)
81144a30:	10800617 	ldw	r2,24(r2)
81144a34:	e0ffed17 	ldw	r3,-76(fp)
81144a38:	10c00035 	stwio	r3,0(r2)
81144a3c:	e0bfef17 	ldw	r2,-68(fp)
81144a40:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144a44:	e0bff317 	ldw	r2,-52(fp)
81144a48:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81144a4c:	e0bffb17 	ldw	r2,-20(fp)
81144a50:	10800617 	ldw	r2,24(r2)
81144a54:	10800104 	addi	r2,r2,4
81144a58:	e0fff817 	ldw	r3,-32(fp)
81144a5c:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81144a60:	e0bffb17 	ldw	r2,-20(fp)
81144a64:	10800617 	ldw	r2,24(r2)
81144a68:	10800204 	addi	r2,r2,8
81144a6c:	e0fff917 	ldw	r3,-28(fp)
81144a70:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81144a74:	e0bffe03 	ldbu	r2,-8(fp)
81144a78:	10000426 	beq	r2,zero,81144a8c <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81144a7c:	e0bfed17 	ldw	r2,-76(fp)
81144a80:	10800414 	ori	r2,r2,16
81144a84:	e0bfed15 	stw	r2,-76(fp)
81144a88:	00000406 	br	81144a9c <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81144a8c:	e0ffed17 	ldw	r3,-76(fp)
81144a90:	00bffbc4 	movi	r2,-17
81144a94:	1884703a 	and	r2,r3,r2
81144a98:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81144a9c:	e0bfff03 	ldbu	r2,-4(fp)
81144aa0:	10000e26 	beq	r2,zero,81144adc <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81144aa4:	e0bfed17 	ldw	r2,-76(fp)
81144aa8:	10800094 	ori	r2,r2,2
81144aac:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81144ab0:	e0bffb17 	ldw	r2,-20(fp)
81144ab4:	10800617 	ldw	r2,24(r2)
81144ab8:	10800304 	addi	r2,r2,12
81144abc:	10800037 	ldwio	r2,0(r2)
81144ac0:	10000a1e 	bne	r2,zero,81144aec <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81144ac4:	e0bffb17 	ldw	r2,-20(fp)
81144ac8:	10800617 	ldw	r2,24(r2)
81144acc:	10800304 	addi	r2,r2,12
81144ad0:	00c03fc4 	movi	r3,255
81144ad4:	10c00035 	stwio	r3,0(r2)
81144ad8:	00000406 	br	81144aec <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81144adc:	e0ffed17 	ldw	r3,-76(fp)
81144ae0:	00bfff44 	movi	r2,-3
81144ae4:	1884703a 	and	r2,r3,r2
81144ae8:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81144aec:	e0bfed17 	ldw	r2,-76(fp)
81144af0:	10800054 	ori	r2,r2,1
81144af4:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81144af8:	e0bffb17 	ldw	r2,-20(fp)
81144afc:	10800617 	ldw	r2,24(r2)
81144b00:	e0ffed17 	ldw	r3,-76(fp)
81144b04:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81144b08:	e0bffb17 	ldw	r2,-20(fp)
81144b0c:	10801817 	ldw	r2,96(r2)
81144b10:	1009883a 	mov	r4,r2
81144b14:	1139f000 	call	81139f00 <OSSemPost>
	 
	 return 0;
81144b18:	0005883a 	mov	r2,zero
}
81144b1c:	e037883a 	mov	sp,fp
81144b20:	dfc00117 	ldw	ra,4(sp)
81144b24:	df000017 	ldw	fp,0(sp)
81144b28:	dec00204 	addi	sp,sp,8
81144b2c:	f800283a 	ret

81144b30 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81144b30:	defff704 	addi	sp,sp,-36
81144b34:	de00012e 	bgeu	sp,et,81144b3c <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81144b38:	003b68fa 	trap	3
81144b3c:	dfc00815 	stw	ra,32(sp)
81144b40:	df000715 	stw	fp,28(sp)
81144b44:	dc400615 	stw	r17,24(sp)
81144b48:	dc000515 	stw	r16,20(sp)
81144b4c:	df000704 	addi	fp,sp,28
81144b50:	e13ffa15 	stw	r4,-24(fp)
81144b54:	e17ffb15 	stw	r5,-20(fp)
81144b58:	3007883a 	mov	r3,r6
81144b5c:	3805883a 	mov	r2,r7
81144b60:	e0fffc05 	stb	r3,-16(fp)
81144b64:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81144b68:	e13ffb17 	ldw	r4,-20(fp)
81144b6c:	114469c0 	call	8114469c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81144b70:	10000226 	beq	r2,zero,81144b7c <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81144b74:	00bffa84 	movi	r2,-22
81144b78:	00000b06 	br	81144ba8 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81144b7c:	e0bffb17 	ldw	r2,-20(fp)
81144b80:	1021883a 	mov	r16,r2
81144b84:	0023883a 	mov	r17,zero
81144b88:	e0fffc03 	ldbu	r3,-16(fp)
81144b8c:	e0bffd03 	ldbu	r2,-12(fp)
81144b90:	d8800015 	stw	r2,0(sp)
81144b94:	180f883a 	mov	r7,r3
81144b98:	800b883a 	mov	r5,r16
81144b9c:	880d883a 	mov	r6,r17
81144ba0:	e13ffa17 	ldw	r4,-24(fp)
81144ba4:	11448180 	call	81144818 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81144ba8:	e6fffe04 	addi	sp,fp,-8
81144bac:	dfc00317 	ldw	ra,12(sp)
81144bb0:	df000217 	ldw	fp,8(sp)
81144bb4:	dc400117 	ldw	r17,4(sp)
81144bb8:	dc000017 	ldw	r16,0(sp)
81144bbc:	dec00404 	addi	sp,sp,16
81144bc0:	f800283a 	ret

81144bc4 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81144bc4:	defff704 	addi	sp,sp,-36
81144bc8:	de00012e 	bgeu	sp,et,81144bd0 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81144bcc:	003b68fa 	trap	3
81144bd0:	dfc00815 	stw	ra,32(sp)
81144bd4:	df000715 	stw	fp,28(sp)
81144bd8:	dc400615 	stw	r17,24(sp)
81144bdc:	dc000515 	stw	r16,20(sp)
81144be0:	df000704 	addi	fp,sp,28
81144be4:	e13ffa15 	stw	r4,-24(fp)
81144be8:	e17ffb15 	stw	r5,-20(fp)
81144bec:	3007883a 	mov	r3,r6
81144bf0:	3805883a 	mov	r2,r7
81144bf4:	e0fffc05 	stb	r3,-16(fp)
81144bf8:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81144bfc:	e13ffb17 	ldw	r4,-20(fp)
81144c00:	114473c0 	call	8114473c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81144c04:	10000226 	beq	r2,zero,81144c10 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81144c08:	00bffa84 	movi	r2,-22
81144c0c:	00000b06 	br	81144c3c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81144c10:	e0bffb17 	ldw	r2,-20(fp)
81144c14:	1021883a 	mov	r16,r2
81144c18:	0023883a 	mov	r17,zero
81144c1c:	e0fffc03 	ldbu	r3,-16(fp)
81144c20:	e0bffd03 	ldbu	r2,-12(fp)
81144c24:	d8800015 	stw	r2,0(sp)
81144c28:	180f883a 	mov	r7,r3
81144c2c:	800b883a 	mov	r5,r16
81144c30:	880d883a 	mov	r6,r17
81144c34:	e13ffa17 	ldw	r4,-24(fp)
81144c38:	11448180 	call	81144818 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81144c3c:	e6fffe04 	addi	sp,fp,-8
81144c40:	dfc00317 	ldw	ra,12(sp)
81144c44:	df000217 	ldw	fp,8(sp)
81144c48:	dc400117 	ldw	r17,4(sp)
81144c4c:	dc000017 	ldw	r16,0(sp)
81144c50:	dec00404 	addi	sp,sp,16
81144c54:	f800283a 	ret

81144c58 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81144c58:	defffc04 	addi	sp,sp,-16
81144c5c:	de00012e 	bgeu	sp,et,81144c64 <alt_msgdma_open+0xc>
81144c60:	003b68fa 	trap	3
81144c64:	dfc00315 	stw	ra,12(sp)
81144c68:	df000215 	stw	fp,8(sp)
81144c6c:	df000204 	addi	fp,sp,8
81144c70:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81144c74:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81144c78:	d1603504 	addi	r5,gp,-32556
81144c7c:	e13fff17 	ldw	r4,-4(fp)
81144c80:	11451fc0 	call	811451fc <alt_find_dev>
81144c84:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81144c88:	e0bffe17 	ldw	r2,-8(fp)
81144c8c:	1000041e 	bne	r2,zero,81144ca0 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81144c90:	1142ebc0 	call	81142ebc <alt_get_errno>
81144c94:	1007883a 	mov	r3,r2
81144c98:	008004c4 	movi	r2,19
81144c9c:	18800015 	stw	r2,0(r3)
    }

    return dev;
81144ca0:	e0bffe17 	ldw	r2,-8(fp)
}
81144ca4:	e037883a 	mov	sp,fp
81144ca8:	dfc00117 	ldw	ra,4(sp)
81144cac:	df000017 	ldw	fp,0(sp)
81144cb0:	dec00204 	addi	sp,sp,8
81144cb4:	f800283a 	ret

81144cb8 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81144cb8:	defff604 	addi	sp,sp,-40
81144cbc:	de00012e 	bgeu	sp,et,81144cc4 <alt_msgdma_init+0xc>
81144cc0:	003b68fa 	trap	3
81144cc4:	dfc00915 	stw	ra,36(sp)
81144cc8:	df000815 	stw	fp,32(sp)
81144ccc:	df000804 	addi	fp,sp,32
81144cd0:	e13ffd15 	stw	r4,-12(fp)
81144cd4:	e17ffe15 	stw	r5,-8(fp)
81144cd8:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81144cdc:	e0bffd17 	ldw	r2,-12(fp)
81144ce0:	10801783 	ldbu	r2,94(r2)
81144ce4:	10803fcc 	andi	r2,r2,255
81144ce8:	10000b26 	beq	r2,zero,81144d18 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81144cec:	e0bffd17 	ldw	r2,-12(fp)
81144cf0:	10800617 	ldw	r2,24(r2)
81144cf4:	00c00104 	movi	r3,4
81144cf8:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81144cfc:	0001883a 	nop
81144d00:	e0bffd17 	ldw	r2,-12(fp)
81144d04:	10800617 	ldw	r2,24(r2)
81144d08:	10800037 	ldwio	r2,0(r2)
81144d0c:	1080010c 	andi	r2,r2,4
81144d10:	1005d0ba 	srai	r2,r2,2
81144d14:	103ffa1e 	bne	r2,zero,81144d00 <__reset+0xfb124d00>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81144d18:	e0bffd17 	ldw	r2,-12(fp)
81144d1c:	10800317 	ldw	r2,12(r2)
81144d20:	10800104 	addi	r2,r2,4
81144d24:	00c00084 	movi	r3,2
81144d28:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81144d2c:	0001883a 	nop
81144d30:	e0bffd17 	ldw	r2,-12(fp)
81144d34:	10800317 	ldw	r2,12(r2)
81144d38:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81144d3c:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81144d40:	103ffb1e 	bne	r2,zero,81144d30 <__reset+0xfb124d30>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81144d44:	e0bffd17 	ldw	r2,-12(fp)
81144d48:	10800317 	ldw	r2,12(r2)
81144d4c:	10800104 	addi	r2,r2,4
81144d50:	10800037 	ldwio	r2,0(r2)
81144d54:	1007883a 	mov	r3,r2
81144d58:	00bffbc4 	movi	r2,-17
81144d5c:	1884703a 	and	r2,r3,r2
81144d60:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81144d64:	e0bff917 	ldw	r2,-28(fp)
81144d68:	10800814 	ori	r2,r2,32
81144d6c:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81144d70:	e0bffd17 	ldw	r2,-12(fp)
81144d74:	10800317 	ldw	r2,12(r2)
81144d78:	10800104 	addi	r2,r2,4
81144d7c:	e0fff917 	ldw	r3,-28(fp)
81144d80:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81144d84:	e0bffd17 	ldw	r2,-12(fp)
81144d88:	10800317 	ldw	r2,12(r2)
81144d8c:	e0fffd17 	ldw	r3,-12(fp)
81144d90:	18c00317 	ldw	r3,12(r3)
81144d94:	18c00037 	ldwio	r3,0(r3)
81144d98:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81144d9c:	e0bffd17 	ldw	r2,-12(fp)
81144da0:	10801783 	ldbu	r2,94(r2)
81144da4:	10803fcc 	andi	r2,r2,255
81144da8:	10000826 	beq	r2,zero,81144dcc <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81144dac:	e0bffd17 	ldw	r2,-12(fp)
81144db0:	10800617 	ldw	r2,24(r2)
81144db4:	10800404 	addi	r2,r2,16
81144db8:	e0fffd17 	ldw	r3,-12(fp)
81144dbc:	18c00617 	ldw	r3,24(r3)
81144dc0:	18c00404 	addi	r3,r3,16
81144dc4:	18c00037 	ldwio	r3,0(r3)
81144dc8:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81144dcc:	d1603504 	addi	r5,gp,-32556
81144dd0:	e13ffd17 	ldw	r4,-12(fp)
81144dd4:	11451500 	call	81145150 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81144dd8:	e0bffd17 	ldw	r2,-12(fp)
81144ddc:	10801804 	addi	r2,r2,96
81144de0:	e0bffb15 	stw	r2,-20(fp)
81144de4:	00800044 	movi	r2,1
81144de8:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81144dec:	e0bffc0b 	ldhu	r2,-16(fp)
81144df0:	1009883a 	mov	r4,r2
81144df4:	11398500 	call	81139850 <OSSemCreate>
81144df8:	1007883a 	mov	r3,r2
81144dfc:	e0bffb17 	ldw	r2,-20(fp)
81144e00:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81144e04:	e0bffb17 	ldw	r2,-20(fp)
81144e08:	10800017 	ldw	r2,0(r2)
81144e0c:	10000226 	beq	r2,zero,81144e18 <alt_msgdma_init+0x160>
81144e10:	0005883a 	mov	r2,zero
81144e14:	00000106 	br	81144e1c <alt_msgdma_init+0x164>
81144e18:	00bfffc4 	movi	r2,-1
81144e1c:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81144e20:	e0bffa17 	ldw	r2,-24(fp)
81144e24:	1000081e 	bne	r2,zero,81144e48 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81144e28:	d8000015 	stw	zero,0(sp)
81144e2c:	e1fffd17 	ldw	r7,-12(fp)
81144e30:	01a04534 	movhi	r6,33044
81144e34:	318c3404 	addi	r6,r6,12496
81144e38:	e17fff17 	ldw	r5,-4(fp)
81144e3c:	e13ffe17 	ldw	r4,-8(fp)
81144e40:	11454880 	call	81145488 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81144e44:	00000406 	br	81144e58 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81144e48:	01204574 	movhi	r4,33045
81144e4c:	212da204 	addi	r4,r4,-18808
81144e50:	11458a00 	call	811458a0 <alt_printf>
    }
    
    return;
81144e54:	0001883a 	nop

}
81144e58:	e037883a 	mov	sp,fp
81144e5c:	dfc00117 	ldw	ra,4(sp)
81144e60:	df000017 	ldw	fp,0(sp)
81144e64:	dec00204 	addi	sp,sp,8
81144e68:	f800283a 	ret

81144e6c <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81144e6c:	defffb04 	addi	sp,sp,-20
81144e70:	de00012e 	bgeu	sp,et,81144e78 <alt_msgdma_register_callback+0xc>
81144e74:	003b68fa 	trap	3
81144e78:	df000415 	stw	fp,16(sp)
81144e7c:	df000404 	addi	fp,sp,16
81144e80:	e13ffc15 	stw	r4,-16(fp)
81144e84:	e17ffd15 	stw	r5,-12(fp)
81144e88:	e1bffe15 	stw	r6,-8(fp)
81144e8c:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81144e90:	e0bffc17 	ldw	r2,-16(fp)
81144e94:	e0fffd17 	ldw	r3,-12(fp)
81144e98:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81144e9c:	e0bffc17 	ldw	r2,-16(fp)
81144ea0:	e0ffff17 	ldw	r3,-4(fp)
81144ea4:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81144ea8:	e0bffc17 	ldw	r2,-16(fp)
81144eac:	e0fffe17 	ldw	r3,-8(fp)
81144eb0:	10c00d15 	stw	r3,52(r2)

    return ;
81144eb4:	0001883a 	nop
}
81144eb8:	e037883a 	mov	sp,fp
81144ebc:	df000017 	ldw	fp,0(sp)
81144ec0:	dec00104 	addi	sp,sp,4
81144ec4:	f800283a 	ret

81144ec8 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81144ec8:	defffc04 	addi	sp,sp,-16
81144ecc:	de00012e 	bgeu	sp,et,81144ed4 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81144ed0:	003b68fa 	trap	3
81144ed4:	dfc00315 	stw	ra,12(sp)
81144ed8:	df000215 	stw	fp,8(sp)
81144edc:	df000204 	addi	fp,sp,8
81144ee0:	e13ffe15 	stw	r4,-8(fp)
81144ee4:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81144ee8:	000d883a 	mov	r6,zero
81144eec:	e17fff17 	ldw	r5,-4(fp)
81144ef0:	e13ffe17 	ldw	r4,-8(fp)
81144ef4:	114344c0 	call	8114344c <alt_msgdma_descriptor_async_transfer>

}
81144ef8:	e037883a 	mov	sp,fp
81144efc:	dfc00117 	ldw	ra,4(sp)
81144f00:	df000017 	ldw	fp,0(sp)
81144f04:	dec00204 	addi	sp,sp,8
81144f08:	f800283a 	ret

81144f0c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81144f0c:	defffc04 	addi	sp,sp,-16
81144f10:	de00012e 	bgeu	sp,et,81144f18 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81144f14:	003b68fa 	trap	3
81144f18:	dfc00315 	stw	ra,12(sp)
81144f1c:	df000215 	stw	fp,8(sp)
81144f20:	df000204 	addi	fp,sp,8
81144f24:	e13ffe15 	stw	r4,-8(fp)
81144f28:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81144f2c:	e1bfff17 	ldw	r6,-4(fp)
81144f30:	000b883a 	mov	r5,zero
81144f34:	e13ffe17 	ldw	r4,-8(fp)
81144f38:	114344c0 	call	8114344c <alt_msgdma_descriptor_async_transfer>
}
81144f3c:	e037883a 	mov	sp,fp
81144f40:	dfc00117 	ldw	ra,4(sp)
81144f44:	df000017 	ldw	fp,0(sp)
81144f48:	dec00204 	addi	sp,sp,8
81144f4c:	f800283a 	ret

81144f50 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81144f50:	defffc04 	addi	sp,sp,-16
81144f54:	de00012e 	bgeu	sp,et,81144f5c <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81144f58:	003b68fa 	trap	3
81144f5c:	dfc00315 	stw	ra,12(sp)
81144f60:	df000215 	stw	fp,8(sp)
81144f64:	df000204 	addi	fp,sp,8
81144f68:	e13ffe15 	stw	r4,-8(fp)
81144f6c:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81144f70:	000d883a 	mov	r6,zero
81144f74:	e17fff17 	ldw	r5,-4(fp)
81144f78:	e13ffe17 	ldw	r4,-8(fp)
81144f7c:	114378c0 	call	8114378c <alt_msgdma_descriptor_sync_transfer>
}
81144f80:	e037883a 	mov	sp,fp
81144f84:	dfc00117 	ldw	ra,4(sp)
81144f88:	df000017 	ldw	fp,0(sp)
81144f8c:	dec00204 	addi	sp,sp,8
81144f90:	f800283a 	ret

81144f94 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81144f94:	defffc04 	addi	sp,sp,-16
81144f98:	de00012e 	bgeu	sp,et,81144fa0 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81144f9c:	003b68fa 	trap	3
81144fa0:	dfc00315 	stw	ra,12(sp)
81144fa4:	df000215 	stw	fp,8(sp)
81144fa8:	df000204 	addi	fp,sp,8
81144fac:	e13ffe15 	stw	r4,-8(fp)
81144fb0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81144fb4:	e1bfff17 	ldw	r6,-4(fp)
81144fb8:	000b883a 	mov	r5,zero
81144fbc:	e13ffe17 	ldw	r4,-8(fp)
81144fc0:	114378c0 	call	8114378c <alt_msgdma_descriptor_sync_transfer>
}
81144fc4:	e037883a 	mov	sp,fp
81144fc8:	dfc00117 	ldw	ra,4(sp)
81144fcc:	df000017 	ldw	fp,0(sp)
81144fd0:	dec00204 	addi	sp,sp,8
81144fd4:	f800283a 	ret

81144fd8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81144fd8:	defff504 	addi	sp,sp,-44
81144fdc:	de00012e 	bgeu	sp,et,81144fe4 <alt_alarm_start+0xc>
81144fe0:	003b68fa 	trap	3
81144fe4:	df000a15 	stw	fp,40(sp)
81144fe8:	df000a04 	addi	fp,sp,40
81144fec:	e13ffc15 	stw	r4,-16(fp)
81144ff0:	e17ffd15 	stw	r5,-12(fp)
81144ff4:	e1bffe15 	stw	r6,-8(fp)
81144ff8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81144ffc:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81145000:	d0a08217 	ldw	r2,-32248(gp)
  
  if (alt_ticks_per_second ())
81145004:	10003c26 	beq	r2,zero,811450f8 <alt_alarm_start+0x120>
  {
    if (alarm)
81145008:	e0bffc17 	ldw	r2,-16(fp)
8114500c:	10003826 	beq	r2,zero,811450f0 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81145010:	e0bffc17 	ldw	r2,-16(fp)
81145014:	e0fffe17 	ldw	r3,-8(fp)
81145018:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114501c:	e0bffc17 	ldw	r2,-16(fp)
81145020:	e0ffff17 	ldw	r3,-4(fp)
81145024:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145028:	0005303a 	rdctl	r2,status
8114502c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145030:	e0fff917 	ldw	r3,-28(fp)
81145034:	00bfff84 	movi	r2,-2
81145038:	1884703a 	and	r2,r3,r2
8114503c:	1001703a 	wrctl	status,r2
  
  return context;
81145040:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81145044:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81145048:	d0a08317 	ldw	r2,-32244(gp)
      
      current_nticks = alt_nticks();
8114504c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81145050:	e0fffd17 	ldw	r3,-12(fp)
81145054:	e0bff617 	ldw	r2,-40(fp)
81145058:	1885883a 	add	r2,r3,r2
8114505c:	10c00044 	addi	r3,r2,1
81145060:	e0bffc17 	ldw	r2,-16(fp)
81145064:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81145068:	e0bffc17 	ldw	r2,-16(fp)
8114506c:	10c00217 	ldw	r3,8(r2)
81145070:	e0bff617 	ldw	r2,-40(fp)
81145074:	1880042e 	bgeu	r3,r2,81145088 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81145078:	e0bffc17 	ldw	r2,-16(fp)
8114507c:	00c00044 	movi	r3,1
81145080:	10c00405 	stb	r3,16(r2)
81145084:	00000206 	br	81145090 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81145088:	e0bffc17 	ldw	r2,-16(fp)
8114508c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81145090:	e0bffc17 	ldw	r2,-16(fp)
81145094:	d0e01404 	addi	r3,gp,-32688
81145098:	e0fffa15 	stw	r3,-24(fp)
8114509c:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811450a0:	e0bffb17 	ldw	r2,-20(fp)
811450a4:	e0fffa17 	ldw	r3,-24(fp)
811450a8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811450ac:	e0bffa17 	ldw	r2,-24(fp)
811450b0:	10c00017 	ldw	r3,0(r2)
811450b4:	e0bffb17 	ldw	r2,-20(fp)
811450b8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811450bc:	e0bffa17 	ldw	r2,-24(fp)
811450c0:	10800017 	ldw	r2,0(r2)
811450c4:	e0fffb17 	ldw	r3,-20(fp)
811450c8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
811450cc:	e0bffa17 	ldw	r2,-24(fp)
811450d0:	e0fffb17 	ldw	r3,-20(fp)
811450d4:	10c00015 	stw	r3,0(r2)
811450d8:	e0bff817 	ldw	r2,-32(fp)
811450dc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811450e0:	e0bff717 	ldw	r2,-36(fp)
811450e4:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
811450e8:	0005883a 	mov	r2,zero
811450ec:	00000306 	br	811450fc <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
811450f0:	00bffa84 	movi	r2,-22
811450f4:	00000106 	br	811450fc <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
811450f8:	00bfde84 	movi	r2,-134
  }
}
811450fc:	e037883a 	mov	sp,fp
81145100:	df000017 	ldw	fp,0(sp)
81145104:	dec00104 	addi	sp,sp,4
81145108:	f800283a 	ret

8114510c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114510c:	defffe04 	addi	sp,sp,-8
81145110:	de00012e 	bgeu	sp,et,81145118 <alt_get_errno+0xc>
81145114:	003b68fa 	trap	3
81145118:	dfc00115 	stw	ra,4(sp)
8114511c:	df000015 	stw	fp,0(sp)
81145120:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81145124:	d0a01017 	ldw	r2,-32704(gp)
81145128:	10000326 	beq	r2,zero,81145138 <alt_get_errno+0x2c>
8114512c:	d0a01017 	ldw	r2,-32704(gp)
81145130:	103ee83a 	callr	r2
81145134:	00000106 	br	8114513c <alt_get_errno+0x30>
81145138:	d0a07204 	addi	r2,gp,-32312
}
8114513c:	e037883a 	mov	sp,fp
81145140:	dfc00117 	ldw	ra,4(sp)
81145144:	df000017 	ldw	fp,0(sp)
81145148:	dec00204 	addi	sp,sp,8
8114514c:	f800283a 	ret

81145150 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81145150:	defffa04 	addi	sp,sp,-24
81145154:	de00012e 	bgeu	sp,et,8114515c <alt_dev_llist_insert+0xc>
81145158:	003b68fa 	trap	3
8114515c:	dfc00515 	stw	ra,20(sp)
81145160:	df000415 	stw	fp,16(sp)
81145164:	df000404 	addi	fp,sp,16
81145168:	e13ffe15 	stw	r4,-8(fp)
8114516c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81145170:	e0bffe17 	ldw	r2,-8(fp)
81145174:	10000326 	beq	r2,zero,81145184 <alt_dev_llist_insert+0x34>
81145178:	e0bffe17 	ldw	r2,-8(fp)
8114517c:	10800217 	ldw	r2,8(r2)
81145180:	1000061e 	bne	r2,zero,8114519c <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81145184:	114510c0 	call	8114510c <alt_get_errno>
81145188:	1007883a 	mov	r3,r2
8114518c:	00800584 	movi	r2,22
81145190:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81145194:	00bffa84 	movi	r2,-22
81145198:	00001306 	br	811451e8 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
8114519c:	e0bffe17 	ldw	r2,-8(fp)
811451a0:	e0ffff17 	ldw	r3,-4(fp)
811451a4:	e0fffc15 	stw	r3,-16(fp)
811451a8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811451ac:	e0bffd17 	ldw	r2,-12(fp)
811451b0:	e0fffc17 	ldw	r3,-16(fp)
811451b4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811451b8:	e0bffc17 	ldw	r2,-16(fp)
811451bc:	10c00017 	ldw	r3,0(r2)
811451c0:	e0bffd17 	ldw	r2,-12(fp)
811451c4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811451c8:	e0bffc17 	ldw	r2,-16(fp)
811451cc:	10800017 	ldw	r2,0(r2)
811451d0:	e0fffd17 	ldw	r3,-12(fp)
811451d4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
811451d8:	e0bffc17 	ldw	r2,-16(fp)
811451dc:	e0fffd17 	ldw	r3,-12(fp)
811451e0:	10c00015 	stw	r3,0(r2)

  return 0;  
811451e4:	0005883a 	mov	r2,zero
}
811451e8:	e037883a 	mov	sp,fp
811451ec:	dfc00117 	ldw	ra,4(sp)
811451f0:	df000017 	ldw	fp,0(sp)
811451f4:	dec00204 	addi	sp,sp,8
811451f8:	f800283a 	ret

811451fc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
811451fc:	defffa04 	addi	sp,sp,-24
81145200:	de00012e 	bgeu	sp,et,81145208 <alt_find_dev+0xc>
81145204:	003b68fa 	trap	3
81145208:	dfc00515 	stw	ra,20(sp)
8114520c:	df000415 	stw	fp,16(sp)
81145210:	df000404 	addi	fp,sp,16
81145214:	e13ffe15 	stw	r4,-8(fp)
81145218:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114521c:	e0bfff17 	ldw	r2,-4(fp)
81145220:	10800017 	ldw	r2,0(r2)
81145224:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81145228:	e13ffe17 	ldw	r4,-8(fp)
8114522c:	111d6400 	call	8111d640 <strlen>
81145230:	10800044 	addi	r2,r2,1
81145234:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81145238:	00000d06 	br	81145270 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114523c:	e0bffc17 	ldw	r2,-16(fp)
81145240:	10800217 	ldw	r2,8(r2)
81145244:	e0fffd17 	ldw	r3,-12(fp)
81145248:	180d883a 	mov	r6,r3
8114524c:	e17ffe17 	ldw	r5,-8(fp)
81145250:	1009883a 	mov	r4,r2
81145254:	11460100 	call	81146010 <memcmp>
81145258:	1000021e 	bne	r2,zero,81145264 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114525c:	e0bffc17 	ldw	r2,-16(fp)
81145260:	00000706 	br	81145280 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81145264:	e0bffc17 	ldw	r2,-16(fp)
81145268:	10800017 	ldw	r2,0(r2)
8114526c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81145270:	e0fffc17 	ldw	r3,-16(fp)
81145274:	e0bfff17 	ldw	r2,-4(fp)
81145278:	18bff01e 	bne	r3,r2,8114523c <__reset+0xfb12523c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114527c:	0005883a 	mov	r2,zero
}
81145280:	e037883a 	mov	sp,fp
81145284:	dfc00117 	ldw	ra,4(sp)
81145288:	df000017 	ldw	fp,0(sp)
8114528c:	dec00204 	addi	sp,sp,8
81145290:	f800283a 	ret

81145294 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81145294:	defffb04 	addi	sp,sp,-20
81145298:	de00012e 	bgeu	sp,et,811452a0 <alt_find_file+0xc>
8114529c:	003b68fa 	trap	3
811452a0:	dfc00415 	stw	ra,16(sp)
811452a4:	df000315 	stw	fp,12(sp)
811452a8:	df000304 	addi	fp,sp,12
811452ac:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
811452b0:	d0a00b17 	ldw	r2,-32724(gp)
811452b4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
811452b8:	00003106 	br	81145380 <alt_find_file+0xec>
  {
    len = strlen(next->name);
811452bc:	e0bffd17 	ldw	r2,-12(fp)
811452c0:	10800217 	ldw	r2,8(r2)
811452c4:	1009883a 	mov	r4,r2
811452c8:	111d6400 	call	8111d640 <strlen>
811452cc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
811452d0:	e0bffd17 	ldw	r2,-12(fp)
811452d4:	10c00217 	ldw	r3,8(r2)
811452d8:	e0bffe17 	ldw	r2,-8(fp)
811452dc:	10bfffc4 	addi	r2,r2,-1
811452e0:	1885883a 	add	r2,r3,r2
811452e4:	10800003 	ldbu	r2,0(r2)
811452e8:	10803fcc 	andi	r2,r2,255
811452ec:	1080201c 	xori	r2,r2,128
811452f0:	10bfe004 	addi	r2,r2,-128
811452f4:	10800bd8 	cmpnei	r2,r2,47
811452f8:	1000031e 	bne	r2,zero,81145308 <alt_find_file+0x74>
    {
      len -= 1;
811452fc:	e0bffe17 	ldw	r2,-8(fp)
81145300:	10bfffc4 	addi	r2,r2,-1
81145304:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81145308:	e0bffe17 	ldw	r2,-8(fp)
8114530c:	e0ffff17 	ldw	r3,-4(fp)
81145310:	1885883a 	add	r2,r3,r2
81145314:	10800003 	ldbu	r2,0(r2)
81145318:	10803fcc 	andi	r2,r2,255
8114531c:	1080201c 	xori	r2,r2,128
81145320:	10bfe004 	addi	r2,r2,-128
81145324:	10800be0 	cmpeqi	r2,r2,47
81145328:	1000081e 	bne	r2,zero,8114534c <alt_find_file+0xb8>
8114532c:	e0bffe17 	ldw	r2,-8(fp)
81145330:	e0ffff17 	ldw	r3,-4(fp)
81145334:	1885883a 	add	r2,r3,r2
81145338:	10800003 	ldbu	r2,0(r2)
8114533c:	10803fcc 	andi	r2,r2,255
81145340:	1080201c 	xori	r2,r2,128
81145344:	10bfe004 	addi	r2,r2,-128
81145348:	10000a1e 	bne	r2,zero,81145374 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114534c:	e0bffd17 	ldw	r2,-12(fp)
81145350:	10800217 	ldw	r2,8(r2)
81145354:	e0fffe17 	ldw	r3,-8(fp)
81145358:	180d883a 	mov	r6,r3
8114535c:	e17fff17 	ldw	r5,-4(fp)
81145360:	1009883a 	mov	r4,r2
81145364:	11460100 	call	81146010 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81145368:	1000021e 	bne	r2,zero,81145374 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114536c:	e0bffd17 	ldw	r2,-12(fp)
81145370:	00000706 	br	81145390 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81145374:	e0bffd17 	ldw	r2,-12(fp)
81145378:	10800017 	ldw	r2,0(r2)
8114537c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81145380:	e0fffd17 	ldw	r3,-12(fp)
81145384:	d0a00b04 	addi	r2,gp,-32724
81145388:	18bfcc1e 	bne	r3,r2,811452bc <__reset+0xfb1252bc>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114538c:	0005883a 	mov	r2,zero
}
81145390:	e037883a 	mov	sp,fp
81145394:	dfc00117 	ldw	ra,4(sp)
81145398:	df000017 	ldw	fp,0(sp)
8114539c:	dec00204 	addi	sp,sp,8
811453a0:	f800283a 	ret

811453a4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
811453a4:	defff904 	addi	sp,sp,-28
811453a8:	de00012e 	bgeu	sp,et,811453b0 <alt_get_fd+0xc>
811453ac:	003b68fa 	trap	3
811453b0:	dfc00615 	stw	ra,24(sp)
811453b4:	df000515 	stw	fp,20(sp)
811453b8:	df000504 	addi	fp,sp,20
811453bc:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
811453c0:	00bffa04 	movi	r2,-24
811453c4:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
811453c8:	d0a07917 	ldw	r2,-32284(gp)
811453cc:	e0bffd15 	stw	r2,-12(fp)
811453d0:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811453d4:	e0bffe0b 	ldhu	r2,-8(fp)
811453d8:	e0fffe84 	addi	r3,fp,-6
811453dc:	180d883a 	mov	r6,r3
811453e0:	100b883a 	mov	r5,r2
811453e4:	e13ffd17 	ldw	r4,-12(fp)
811453e8:	1139b780 	call	81139b78 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
811453ec:	e03ffb15 	stw	zero,-20(fp)
811453f0:	00001906 	br	81145458 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
811453f4:	00a04574 	movhi	r2,33045
811453f8:	10b01104 	addi	r2,r2,-16316
811453fc:	e0fffb17 	ldw	r3,-20(fp)
81145400:	18c00324 	muli	r3,r3,12
81145404:	10c5883a 	add	r2,r2,r3
81145408:	10800017 	ldw	r2,0(r2)
8114540c:	10000f1e 	bne	r2,zero,8114544c <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81145410:	00a04574 	movhi	r2,33045
81145414:	10b01104 	addi	r2,r2,-16316
81145418:	e0fffb17 	ldw	r3,-20(fp)
8114541c:	18c00324 	muli	r3,r3,12
81145420:	10c5883a 	add	r2,r2,r3
81145424:	e0ffff17 	ldw	r3,-4(fp)
81145428:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114542c:	d0e00f17 	ldw	r3,-32708(gp)
81145430:	e0bffb17 	ldw	r2,-20(fp)
81145434:	1880020e 	bge	r3,r2,81145440 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81145438:	e0bffb17 	ldw	r2,-20(fp)
8114543c:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81145440:	e0bffb17 	ldw	r2,-20(fp)
81145444:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81145448:	00000606 	br	81145464 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114544c:	e0bffb17 	ldw	r2,-20(fp)
81145450:	10800044 	addi	r2,r2,1
81145454:	e0bffb15 	stw	r2,-20(fp)
81145458:	e0bffb17 	ldw	r2,-20(fp)
8114545c:	10800810 	cmplti	r2,r2,32
81145460:	103fe41e 	bne	r2,zero,811453f4 <__reset+0xfb1253f4>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81145464:	d0a07917 	ldw	r2,-32284(gp)
81145468:	1009883a 	mov	r4,r2
8114546c:	1139f000 	call	81139f00 <OSSemPost>

  return rc;
81145470:	e0bffc17 	ldw	r2,-16(fp)
}
81145474:	e037883a 	mov	sp,fp
81145478:	dfc00117 	ldw	ra,4(sp)
8114547c:	df000017 	ldw	fp,0(sp)
81145480:	dec00204 	addi	sp,sp,8
81145484:	f800283a 	ret

81145488 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81145488:	defff904 	addi	sp,sp,-28
8114548c:	de00012e 	bgeu	sp,et,81145494 <alt_ic_isr_register+0xc>
81145490:	003b68fa 	trap	3
81145494:	dfc00615 	stw	ra,24(sp)
81145498:	df000515 	stw	fp,20(sp)
8114549c:	df000504 	addi	fp,sp,20
811454a0:	e13ffc15 	stw	r4,-16(fp)
811454a4:	e17ffd15 	stw	r5,-12(fp)
811454a8:	e1bffe15 	stw	r6,-8(fp)
811454ac:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
811454b0:	e0800217 	ldw	r2,8(fp)
811454b4:	d8800015 	stw	r2,0(sp)
811454b8:	e1ffff17 	ldw	r7,-4(fp)
811454bc:	e1bffe17 	ldw	r6,-8(fp)
811454c0:	e17ffd17 	ldw	r5,-12(fp)
811454c4:	e13ffc17 	ldw	r4,-16(fp)
811454c8:	11456580 	call	81145658 <alt_iic_isr_register>
}  
811454cc:	e037883a 	mov	sp,fp
811454d0:	dfc00117 	ldw	ra,4(sp)
811454d4:	df000017 	ldw	fp,0(sp)
811454d8:	dec00204 	addi	sp,sp,8
811454dc:	f800283a 	ret

811454e0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
811454e0:	defff904 	addi	sp,sp,-28
811454e4:	de00012e 	bgeu	sp,et,811454ec <alt_ic_irq_enable+0xc>
811454e8:	003b68fa 	trap	3
811454ec:	df000615 	stw	fp,24(sp)
811454f0:	df000604 	addi	fp,sp,24
811454f4:	e13ffe15 	stw	r4,-8(fp)
811454f8:	e17fff15 	stw	r5,-4(fp)
811454fc:	e0bfff17 	ldw	r2,-4(fp)
81145500:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145504:	0005303a 	rdctl	r2,status
81145508:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114550c:	e0fffb17 	ldw	r3,-20(fp)
81145510:	00bfff84 	movi	r2,-2
81145514:	1884703a 	and	r2,r3,r2
81145518:	1001703a 	wrctl	status,r2
  
  return context;
8114551c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81145520:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81145524:	00c00044 	movi	r3,1
81145528:	e0bffa17 	ldw	r2,-24(fp)
8114552c:	1884983a 	sll	r2,r3,r2
81145530:	1007883a 	mov	r3,r2
81145534:	d0a07a17 	ldw	r2,-32280(gp)
81145538:	1884b03a 	or	r2,r3,r2
8114553c:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81145540:	d0a07a17 	ldw	r2,-32280(gp)
81145544:	100170fa 	wrctl	ienable,r2
81145548:	e0bffc17 	ldw	r2,-16(fp)
8114554c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145550:	e0bffd17 	ldw	r2,-12(fp)
81145554:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81145558:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114555c:	0001883a 	nop
}
81145560:	e037883a 	mov	sp,fp
81145564:	df000017 	ldw	fp,0(sp)
81145568:	dec00104 	addi	sp,sp,4
8114556c:	f800283a 	ret

81145570 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
81145570:	defff904 	addi	sp,sp,-28
81145574:	de00012e 	bgeu	sp,et,8114557c <alt_ic_irq_disable+0xc>
81145578:	003b68fa 	trap	3
8114557c:	df000615 	stw	fp,24(sp)
81145580:	df000604 	addi	fp,sp,24
81145584:	e13ffe15 	stw	r4,-8(fp)
81145588:	e17fff15 	stw	r5,-4(fp)
8114558c:	e0bfff17 	ldw	r2,-4(fp)
81145590:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145594:	0005303a 	rdctl	r2,status
81145598:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114559c:	e0fffb17 	ldw	r3,-20(fp)
811455a0:	00bfff84 	movi	r2,-2
811455a4:	1884703a 	and	r2,r3,r2
811455a8:	1001703a 	wrctl	status,r2
  
  return context;
811455ac:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811455b0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
811455b4:	00c00044 	movi	r3,1
811455b8:	e0bffa17 	ldw	r2,-24(fp)
811455bc:	1884983a 	sll	r2,r3,r2
811455c0:	0084303a 	nor	r2,zero,r2
811455c4:	1007883a 	mov	r3,r2
811455c8:	d0a07a17 	ldw	r2,-32280(gp)
811455cc:	1884703a 	and	r2,r3,r2
811455d0:	d0a07a15 	stw	r2,-32280(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811455d4:	d0a07a17 	ldw	r2,-32280(gp)
811455d8:	100170fa 	wrctl	ienable,r2
811455dc:	e0bffc17 	ldw	r2,-16(fp)
811455e0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811455e4:	e0bffd17 	ldw	r2,-12(fp)
811455e8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811455ec:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
811455f0:	0001883a 	nop
}
811455f4:	e037883a 	mov	sp,fp
811455f8:	df000017 	ldw	fp,0(sp)
811455fc:	dec00104 	addi	sp,sp,4
81145600:	f800283a 	ret

81145604 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81145604:	defffc04 	addi	sp,sp,-16
81145608:	de00012e 	bgeu	sp,et,81145610 <alt_ic_irq_enabled+0xc>
8114560c:	003b68fa 	trap	3
81145610:	df000315 	stw	fp,12(sp)
81145614:	df000304 	addi	fp,sp,12
81145618:	e13ffe15 	stw	r4,-8(fp)
8114561c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81145620:	000530fa 	rdctl	r2,ienable
81145624:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81145628:	00c00044 	movi	r3,1
8114562c:	e0bfff17 	ldw	r2,-4(fp)
81145630:	1884983a 	sll	r2,r3,r2
81145634:	1007883a 	mov	r3,r2
81145638:	e0bffd17 	ldw	r2,-12(fp)
8114563c:	1884703a 	and	r2,r3,r2
81145640:	1004c03a 	cmpne	r2,r2,zero
81145644:	10803fcc 	andi	r2,r2,255
}
81145648:	e037883a 	mov	sp,fp
8114564c:	df000017 	ldw	fp,0(sp)
81145650:	dec00104 	addi	sp,sp,4
81145654:	f800283a 	ret

81145658 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81145658:	defff504 	addi	sp,sp,-44
8114565c:	de00012e 	bgeu	sp,et,81145664 <alt_iic_isr_register+0xc>
81145660:	003b68fa 	trap	3
81145664:	dfc00a15 	stw	ra,40(sp)
81145668:	df000915 	stw	fp,36(sp)
8114566c:	df000904 	addi	fp,sp,36
81145670:	e13ffc15 	stw	r4,-16(fp)
81145674:	e17ffd15 	stw	r5,-12(fp)
81145678:	e1bffe15 	stw	r6,-8(fp)
8114567c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81145680:	00bffa84 	movi	r2,-22
81145684:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
81145688:	e0bffd17 	ldw	r2,-12(fp)
8114568c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81145690:	e0bff817 	ldw	r2,-32(fp)
81145694:	10800808 	cmpgei	r2,r2,32
81145698:	1000271e 	bne	r2,zero,81145738 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114569c:	0005303a 	rdctl	r2,status
811456a0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811456a4:	e0fffb17 	ldw	r3,-20(fp)
811456a8:	00bfff84 	movi	r2,-2
811456ac:	1884703a 	and	r2,r3,r2
811456b0:	1001703a 	wrctl	status,r2
  
  return context;
811456b4:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
811456b8:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
811456bc:	00a045b4 	movhi	r2,33046
811456c0:	109c8804 	addi	r2,r2,29216
811456c4:	e0fff817 	ldw	r3,-32(fp)
811456c8:	180690fa 	slli	r3,r3,3
811456cc:	10c5883a 	add	r2,r2,r3
811456d0:	e0fffe17 	ldw	r3,-8(fp)
811456d4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
811456d8:	00a045b4 	movhi	r2,33046
811456dc:	109c8804 	addi	r2,r2,29216
811456e0:	e0fff817 	ldw	r3,-32(fp)
811456e4:	180690fa 	slli	r3,r3,3
811456e8:	10c5883a 	add	r2,r2,r3
811456ec:	10800104 	addi	r2,r2,4
811456f0:	e0ffff17 	ldw	r3,-4(fp)
811456f4:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
811456f8:	e0bffe17 	ldw	r2,-8(fp)
811456fc:	10000526 	beq	r2,zero,81145714 <alt_iic_isr_register+0xbc>
81145700:	e0bff817 	ldw	r2,-32(fp)
81145704:	100b883a 	mov	r5,r2
81145708:	e13ffc17 	ldw	r4,-16(fp)
8114570c:	11454e00 	call	811454e0 <alt_ic_irq_enable>
81145710:	00000406 	br	81145724 <alt_iic_isr_register+0xcc>
81145714:	e0bff817 	ldw	r2,-32(fp)
81145718:	100b883a 	mov	r5,r2
8114571c:	e13ffc17 	ldw	r4,-16(fp)
81145720:	11455700 	call	81145570 <alt_ic_irq_disable>
81145724:	e0bff715 	stw	r2,-36(fp)
81145728:	e0bffa17 	ldw	r2,-24(fp)
8114572c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145730:	e0bff917 	ldw	r2,-28(fp)
81145734:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
81145738:	e0bff717 	ldw	r2,-36(fp)
}
8114573c:	e037883a 	mov	sp,fp
81145740:	dfc00117 	ldw	ra,4(sp)
81145744:	df000017 	ldw	fp,0(sp)
81145748:	dec00204 	addi	sp,sp,8
8114574c:	f800283a 	ret

81145750 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81145750:	defff904 	addi	sp,sp,-28
81145754:	de00012e 	bgeu	sp,et,8114575c <alt_open_fd+0xc>
81145758:	003b68fa 	trap	3
8114575c:	dfc00615 	stw	ra,24(sp)
81145760:	df000515 	stw	fp,20(sp)
81145764:	df000504 	addi	fp,sp,20
81145768:	e13ffc15 	stw	r4,-16(fp)
8114576c:	e17ffd15 	stw	r5,-12(fp)
81145770:	e1bffe15 	stw	r6,-8(fp)
81145774:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
81145778:	e1bfff17 	ldw	r6,-4(fp)
8114577c:	e17ffe17 	ldw	r5,-8(fp)
81145780:	e13ffd17 	ldw	r4,-12(fp)
81145784:	11327b40 	call	811327b4 <open>
81145788:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114578c:	e0bffb17 	ldw	r2,-20(fp)
81145790:	10001c16 	blt	r2,zero,81145804 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81145794:	00a04574 	movhi	r2,33045
81145798:	10b01104 	addi	r2,r2,-16316
8114579c:	e0fffb17 	ldw	r3,-20(fp)
811457a0:	18c00324 	muli	r3,r3,12
811457a4:	10c5883a 	add	r2,r2,r3
811457a8:	10c00017 	ldw	r3,0(r2)
811457ac:	e0bffc17 	ldw	r2,-16(fp)
811457b0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
811457b4:	00a04574 	movhi	r2,33045
811457b8:	10b01104 	addi	r2,r2,-16316
811457bc:	e0fffb17 	ldw	r3,-20(fp)
811457c0:	18c00324 	muli	r3,r3,12
811457c4:	10c5883a 	add	r2,r2,r3
811457c8:	10800104 	addi	r2,r2,4
811457cc:	10c00017 	ldw	r3,0(r2)
811457d0:	e0bffc17 	ldw	r2,-16(fp)
811457d4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
811457d8:	00a04574 	movhi	r2,33045
811457dc:	10b01104 	addi	r2,r2,-16316
811457e0:	e0fffb17 	ldw	r3,-20(fp)
811457e4:	18c00324 	muli	r3,r3,12
811457e8:	10c5883a 	add	r2,r2,r3
811457ec:	10800204 	addi	r2,r2,8
811457f0:	10c00017 	ldw	r3,0(r2)
811457f4:	e0bffc17 	ldw	r2,-16(fp)
811457f8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
811457fc:	e13ffb17 	ldw	r4,-20(fp)
81145800:	1132a580 	call	81132a58 <alt_release_fd>
  }
} 
81145804:	0001883a 	nop
81145808:	e037883a 	mov	sp,fp
8114580c:	dfc00117 	ldw	ra,4(sp)
81145810:	df000017 	ldw	fp,0(sp)
81145814:	dec00204 	addi	sp,sp,8
81145818:	f800283a 	ret

8114581c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114581c:	defffb04 	addi	sp,sp,-20
81145820:	de00012e 	bgeu	sp,et,81145828 <alt_io_redirect+0xc>
81145824:	003b68fa 	trap	3
81145828:	dfc00415 	stw	ra,16(sp)
8114582c:	df000315 	stw	fp,12(sp)
81145830:	df000304 	addi	fp,sp,12
81145834:	e13ffd15 	stw	r4,-12(fp)
81145838:	e17ffe15 	stw	r5,-8(fp)
8114583c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81145840:	01c07fc4 	movi	r7,511
81145844:	01800044 	movi	r6,1
81145848:	e17ffd17 	ldw	r5,-12(fp)
8114584c:	01204574 	movhi	r4,33045
81145850:	21301404 	addi	r4,r4,-16304
81145854:	11457500 	call	81145750 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
81145858:	01c07fc4 	movi	r7,511
8114585c:	000d883a 	mov	r6,zero
81145860:	e17ffe17 	ldw	r5,-8(fp)
81145864:	01204574 	movhi	r4,33045
81145868:	21301104 	addi	r4,r4,-16316
8114586c:	11457500 	call	81145750 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
81145870:	01c07fc4 	movi	r7,511
81145874:	01800044 	movi	r6,1
81145878:	e17fff17 	ldw	r5,-4(fp)
8114587c:	01204574 	movhi	r4,33045
81145880:	21301704 	addi	r4,r4,-16292
81145884:	11457500 	call	81145750 <alt_open_fd>
}  
81145888:	0001883a 	nop
8114588c:	e037883a 	mov	sp,fp
81145890:	dfc00117 	ldw	ra,4(sp)
81145894:	df000017 	ldw	fp,0(sp)
81145898:	dec00204 	addi	sp,sp,8
8114589c:	f800283a 	ret

811458a0 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
811458a0:	defff204 	addi	sp,sp,-56
811458a4:	de00012e 	bgeu	sp,et,811458ac <alt_printf+0xc>
811458a8:	003b68fa 	trap	3
811458ac:	dfc00a15 	stw	ra,40(sp)
811458b0:	df000915 	stw	fp,36(sp)
811458b4:	df000904 	addi	fp,sp,36
811458b8:	e13fff15 	stw	r4,-4(fp)
811458bc:	e1400215 	stw	r5,8(fp)
811458c0:	e1800315 	stw	r6,12(fp)
811458c4:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
811458c8:	e0800204 	addi	r2,fp,8
811458cc:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
811458d0:	e0bfff17 	ldw	r2,-4(fp)
811458d4:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
811458d8:	00006f06 	br	81145a98 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
811458dc:	e0bff807 	ldb	r2,-32(fp)
811458e0:	10800960 	cmpeqi	r2,r2,37
811458e4:	1000041e 	bne	r2,zero,811458f8 <alt_printf+0x58>
        {
            alt_putchar(c);
811458e8:	e0bff807 	ldb	r2,-32(fp)
811458ec:	1009883a 	mov	r4,r2
811458f0:	1145ad40 	call	81145ad4 <alt_putchar>
811458f4:	00006806 	br	81145a98 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
811458f8:	e0bff717 	ldw	r2,-36(fp)
811458fc:	10c00044 	addi	r3,r2,1
81145900:	e0fff715 	stw	r3,-36(fp)
81145904:	10800003 	ldbu	r2,0(r2)
81145908:	e0bff805 	stb	r2,-32(fp)
8114590c:	e0bff807 	ldb	r2,-32(fp)
81145910:	10006926 	beq	r2,zero,81145ab8 <alt_printf+0x218>
            {
                if (c == '%')
81145914:	e0bff807 	ldb	r2,-32(fp)
81145918:	10800958 	cmpnei	r2,r2,37
8114591c:	1000041e 	bne	r2,zero,81145930 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81145920:	e0bff807 	ldb	r2,-32(fp)
81145924:	1009883a 	mov	r4,r2
81145928:	1145ad40 	call	81145ad4 <alt_putchar>
8114592c:	00005a06 	br	81145a98 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81145930:	e0bff807 	ldb	r2,-32(fp)
81145934:	108018d8 	cmpnei	r2,r2,99
81145938:	1000081e 	bne	r2,zero,8114595c <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
8114593c:	e0bffe17 	ldw	r2,-8(fp)
81145940:	10c00104 	addi	r3,r2,4
81145944:	e0fffe15 	stw	r3,-8(fp)
81145948:	10800017 	ldw	r2,0(r2)
8114594c:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81145950:	e13ffd17 	ldw	r4,-12(fp)
81145954:	1145ad40 	call	81145ad4 <alt_putchar>
81145958:	00004f06 	br	81145a98 <alt_printf+0x1f8>
                }
                else if (c == 'x')
8114595c:	e0bff807 	ldb	r2,-32(fp)
81145960:	10801e18 	cmpnei	r2,r2,120
81145964:	1000341e 	bne	r2,zero,81145a38 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81145968:	e0bffe17 	ldw	r2,-8(fp)
8114596c:	10c00104 	addi	r3,r2,4
81145970:	e0fffe15 	stw	r3,-8(fp)
81145974:	10800017 	ldw	r2,0(r2)
81145978:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
8114597c:	e0bffb17 	ldw	r2,-20(fp)
81145980:	1000031e 	bne	r2,zero,81145990 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81145984:	01000c04 	movi	r4,48
81145988:	1145ad40 	call	81145ad4 <alt_putchar>
                        continue;
8114598c:	00004206 	br	81145a98 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81145990:	00800704 	movi	r2,28
81145994:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
81145998:	00000306 	br	811459a8 <alt_printf+0x108>
                        digit_shift -= 4;
8114599c:	e0bff917 	ldw	r2,-28(fp)
811459a0:	10bfff04 	addi	r2,r2,-4
811459a4:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
811459a8:	00c003c4 	movi	r3,15
811459ac:	e0bff917 	ldw	r2,-28(fp)
811459b0:	1884983a 	sll	r2,r3,r2
811459b4:	1007883a 	mov	r3,r2
811459b8:	e0bffb17 	ldw	r2,-20(fp)
811459bc:	1884703a 	and	r2,r3,r2
811459c0:	103ff626 	beq	r2,zero,8114599c <__reset+0xfb12599c>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
811459c4:	00001906 	br	81145a2c <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
811459c8:	00c003c4 	movi	r3,15
811459cc:	e0bff917 	ldw	r2,-28(fp)
811459d0:	1884983a 	sll	r2,r3,r2
811459d4:	1007883a 	mov	r3,r2
811459d8:	e0bffb17 	ldw	r2,-20(fp)
811459dc:	1886703a 	and	r3,r3,r2
811459e0:	e0bff917 	ldw	r2,-28(fp)
811459e4:	1884d83a 	srl	r2,r3,r2
811459e8:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
811459ec:	e0bffc17 	ldw	r2,-16(fp)
811459f0:	108002a8 	cmpgeui	r2,r2,10
811459f4:	1000041e 	bne	r2,zero,81145a08 <alt_printf+0x168>
                            c = '0' + digit;
811459f8:	e0bffc17 	ldw	r2,-16(fp)
811459fc:	10800c04 	addi	r2,r2,48
81145a00:	e0bff805 	stb	r2,-32(fp)
81145a04:	00000306 	br	81145a14 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81145a08:	e0bffc17 	ldw	r2,-16(fp)
81145a0c:	108015c4 	addi	r2,r2,87
81145a10:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81145a14:	e0bff807 	ldb	r2,-32(fp)
81145a18:	1009883a 	mov	r4,r2
81145a1c:	1145ad40 	call	81145ad4 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81145a20:	e0bff917 	ldw	r2,-28(fp)
81145a24:	10bfff04 	addi	r2,r2,-4
81145a28:	e0bff915 	stw	r2,-28(fp)
81145a2c:	e0bff917 	ldw	r2,-28(fp)
81145a30:	103fe50e 	bge	r2,zero,811459c8 <__reset+0xfb1259c8>
81145a34:	00001806 	br	81145a98 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81145a38:	e0bff807 	ldb	r2,-32(fp)
81145a3c:	10801cd8 	cmpnei	r2,r2,115
81145a40:	1000151e 	bne	r2,zero,81145a98 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81145a44:	e0bffe17 	ldw	r2,-8(fp)
81145a48:	10c00104 	addi	r3,r2,4
81145a4c:	e0fffe15 	stw	r3,-8(fp)
81145a50:	10800017 	ldw	r2,0(r2)
81145a54:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81145a58:	00000906 	br	81145a80 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81145a5c:	e0bffa17 	ldw	r2,-24(fp)
81145a60:	10c00044 	addi	r3,r2,1
81145a64:	e0fffa15 	stw	r3,-24(fp)
81145a68:	10800003 	ldbu	r2,0(r2)
81145a6c:	10803fcc 	andi	r2,r2,255
81145a70:	1080201c 	xori	r2,r2,128
81145a74:	10bfe004 	addi	r2,r2,-128
81145a78:	1009883a 	mov	r4,r2
81145a7c:	1145ad40 	call	81145ad4 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81145a80:	e0bffa17 	ldw	r2,-24(fp)
81145a84:	10800003 	ldbu	r2,0(r2)
81145a88:	10803fcc 	andi	r2,r2,255
81145a8c:	1080201c 	xori	r2,r2,128
81145a90:	10bfe004 	addi	r2,r2,-128
81145a94:	103ff11e 	bne	r2,zero,81145a5c <__reset+0xfb125a5c>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
81145a98:	e0bff717 	ldw	r2,-36(fp)
81145a9c:	10c00044 	addi	r3,r2,1
81145aa0:	e0fff715 	stw	r3,-36(fp)
81145aa4:	10800003 	ldbu	r2,0(r2)
81145aa8:	e0bff805 	stb	r2,-32(fp)
81145aac:	e0bff807 	ldb	r2,-32(fp)
81145ab0:	103f8a1e 	bne	r2,zero,811458dc <__reset+0xfb1258dc>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81145ab4:	00000106 	br	81145abc <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
81145ab8:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81145abc:	0001883a 	nop
81145ac0:	e037883a 	mov	sp,fp
81145ac4:	dfc00117 	ldw	ra,4(sp)
81145ac8:	df000017 	ldw	fp,0(sp)
81145acc:	dec00504 	addi	sp,sp,20
81145ad0:	f800283a 	ret

81145ad4 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81145ad4:	defffd04 	addi	sp,sp,-12
81145ad8:	de00012e 	bgeu	sp,et,81145ae0 <alt_putchar+0xc>
81145adc:	003b68fa 	trap	3
81145ae0:	dfc00215 	stw	ra,8(sp)
81145ae4:	df000115 	stw	fp,4(sp)
81145ae8:	df000104 	addi	fp,sp,4
81145aec:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
81145af0:	d0a00517 	ldw	r2,-32748(gp)
81145af4:	10800217 	ldw	r2,8(r2)
81145af8:	100b883a 	mov	r5,r2
81145afc:	e13fff17 	ldw	r4,-4(fp)
81145b00:	111cf500 	call	8111cf50 <putc>
#endif
#endif
}
81145b04:	e037883a 	mov	sp,fp
81145b08:	dfc00117 	ldw	ra,4(sp)
81145b0c:	df000017 	ldw	fp,0(sp)
81145b10:	dec00204 	addi	sp,sp,8
81145b14:	f800283a 	ret

81145b18 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81145b18:	deffff04 	addi	sp,sp,-4
81145b1c:	de00012e 	bgeu	sp,et,81145b24 <altera_nios2_gen2_irq_init+0xc>
81145b20:	003b68fa 	trap	3
81145b24:	df000015 	stw	fp,0(sp)
81145b28:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81145b2c:	000170fa 	wrctl	ienable,zero
}
81145b30:	0001883a 	nop
81145b34:	e037883a 	mov	sp,fp
81145b38:	df000017 	ldw	fp,0(sp)
81145b3c:	dec00104 	addi	sp,sp,4
81145b40:	f800283a 	ret

81145b44 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81145b44:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81145b48:	de002436 	bltu	sp,et,81145bdc <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81145b4c:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81145b50:	d1209c17 	ldw	r4,-32144(gp)

      stw ra,  0(sp)
81145b54:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81145b58:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81145b5c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81145b60:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81145b64:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81145b68:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81145b6c:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81145b70:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81145b74:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
81145b78:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81145b7c:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81145b80:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81145b84:	1145de00 	call	81145de0 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
81145b88:	d1209617 	ldw	r4,-32168(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81145b8c:	d1608d87 	ldb	r5,-32202(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81145b90:	d1209c15 	stw	r4,-32144(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81145b94:	d1608dc5 	stb	r5,-32201(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
81145b98:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81145b9c:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81145ba0:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81145ba4:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
81145ba8:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
81145bac:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
81145bb0:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
81145bb4:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
81145bb8:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
81145bbc:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
81145bc0:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
81145bc4:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
81145bc8:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81145bcc:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81145bd0:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81145bd4:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81145bd8:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81145bdc:	003da0fa 	break	3

81145be0 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81145be0:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81145be4:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81145be8:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81145bec:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81145bf0:	1145de00 	call	81145de0 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81145bf4:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81145bf8:	d4a08b05 	stb	r18,-32212(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81145bfc:	003fe206 	br	81145b88 <__reset+0xfb125b88>

81145c00 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81145c00:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81145c04:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81145c08:	10800054 	ori	r2,r2,1
      wrctl status, r2
81145c0c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81145c10:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81145c14:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81145c18:	dec00204 	addi	sp,sp,8

      callr r2
81145c1c:	103ee83a 	callr	r2

      nop
81145c20:	0001883a 	nop

81145c24 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81145c24:	defff704 	addi	sp,sp,-36
81145c28:	de00012e 	bgeu	sp,et,81145c30 <OSTaskStkInit+0xc>
81145c2c:	003b68fa 	trap	3
81145c30:	dfc00815 	stw	ra,32(sp)
81145c34:	df000715 	stw	fp,28(sp)
81145c38:	df000704 	addi	fp,sp,28
81145c3c:	e13ffc15 	stw	r4,-16(fp)
81145c40:	e17ffd15 	stw	r5,-12(fp)
81145c44:	e1bffe15 	stw	r6,-8(fp)
81145c48:	3805883a 	mov	r2,r7
81145c4c:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81145c50:	e0fffe17 	ldw	r3,-8(fp)
81145c54:	00bfff04 	movi	r2,-4
81145c58:	1884703a 	and	r2,r3,r2
81145c5c:	10bef704 	addi	r2,r2,-1060
81145c60:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81145c64:	01810904 	movi	r6,1060
81145c68:	000b883a 	mov	r5,zero
81145c6c:	e13ff917 	ldw	r4,-28(fp)
81145c70:	111cc9c0 	call	8111cc9c <memset>
81145c74:	e0bff917 	ldw	r2,-28(fp)
81145c78:	10c0bb04 	addi	r3,r2,748
81145c7c:	e0bff917 	ldw	r2,-28(fp)
81145c80:	10c00115 	stw	r3,4(r2)
81145c84:	e0bff917 	ldw	r2,-28(fp)
81145c88:	10c0d504 	addi	r3,r2,852
81145c8c:	e0bff917 	ldw	r2,-28(fp)
81145c90:	10c00215 	stw	r3,8(r2)
81145c94:	e0bff917 	ldw	r2,-28(fp)
81145c98:	10c0ef04 	addi	r3,r2,956
81145c9c:	e0bff917 	ldw	r2,-28(fp)
81145ca0:	10c00315 	stw	r3,12(r2)
81145ca4:	e0fff917 	ldw	r3,-28(fp)
81145ca8:	00a04574 	movhi	r2,33045
81145cac:	10adaa04 	addi	r2,r2,-18776
81145cb0:	18800d15 	stw	r2,52(r3)
81145cb4:	e0bff917 	ldw	r2,-28(fp)
81145cb8:	00c00044 	movi	r3,1
81145cbc:	10c02915 	stw	r3,164(r2)
81145cc0:	10002a15 	stw	zero,168(r2)
81145cc4:	e0bff917 	ldw	r2,-28(fp)
81145cc8:	00ccc384 	movi	r3,13070
81145ccc:	10c02b0d 	sth	r3,172(r2)
81145cd0:	e0bff917 	ldw	r2,-28(fp)
81145cd4:	00eaf344 	movi	r3,-21555
81145cd8:	10c02b8d 	sth	r3,174(r2)
81145cdc:	e0bff917 	ldw	r2,-28(fp)
81145ce0:	00c48d04 	movi	r3,4660
81145ce4:	10c02c0d 	sth	r3,176(r2)
81145ce8:	e0bff917 	ldw	r2,-28(fp)
81145cec:	00f99b44 	movi	r3,-6547
81145cf0:	10c02c8d 	sth	r3,178(r2)
81145cf4:	e0bff917 	ldw	r2,-28(fp)
81145cf8:	00f7bb04 	movi	r3,-8468
81145cfc:	10c02d0d 	sth	r3,180(r2)
81145d00:	e0bff917 	ldw	r2,-28(fp)
81145d04:	00c00144 	movi	r3,5
81145d08:	10c02d8d 	sth	r3,182(r2)
81145d0c:	e0bff917 	ldw	r2,-28(fp)
81145d10:	00c002c4 	movi	r3,11
81145d14:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81145d18:	e0bff917 	ldw	r2,-28(fp)
81145d1c:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81145d20:	e0bffa17 	ldw	r2,-24(fp)
81145d24:	10bff304 	addi	r2,r2,-52
81145d28:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81145d2c:	e0bffb17 	ldw	r2,-20(fp)
81145d30:	10800c04 	addi	r2,r2,48
81145d34:	e0fffc17 	ldw	r3,-16(fp)
81145d38:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81145d3c:	e0bffb17 	ldw	r2,-20(fp)
81145d40:	10800b04 	addi	r2,r2,44
81145d44:	e0fffd17 	ldw	r3,-12(fp)
81145d48:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81145d4c:	e0bffb17 	ldw	r2,-20(fp)
81145d50:	10800a04 	addi	r2,r2,40
81145d54:	e0fff917 	ldw	r3,-28(fp)
81145d58:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81145d5c:	00a04534 	movhi	r2,33044
81145d60:	10970004 	addi	r2,r2,23552
81145d64:	10c00104 	addi	r3,r2,4
81145d68:	e0bffb17 	ldw	r2,-20(fp)
81145d6c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81145d70:	e0bffb17 	ldw	r2,-20(fp)
}
81145d74:	e037883a 	mov	sp,fp
81145d78:	dfc00117 	ldw	ra,4(sp)
81145d7c:	df000017 	ldw	fp,0(sp)
81145d80:	dec00204 	addi	sp,sp,8
81145d84:	f800283a 	ret

81145d88 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
81145d88:	defffe04 	addi	sp,sp,-8
81145d8c:	de00012e 	bgeu	sp,et,81145d94 <OSTaskCreateHook+0xc>
81145d90:	003b68fa 	trap	3
81145d94:	df000115 	stw	fp,4(sp)
81145d98:	df000104 	addi	fp,sp,4
81145d9c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81145da0:	0001883a 	nop
81145da4:	e037883a 	mov	sp,fp
81145da8:	df000017 	ldw	fp,0(sp)
81145dac:	dec00104 	addi	sp,sp,4
81145db0:	f800283a 	ret

81145db4 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
81145db4:	defffe04 	addi	sp,sp,-8
81145db8:	de00012e 	bgeu	sp,et,81145dc0 <OSTaskDelHook+0xc>
81145dbc:	003b68fa 	trap	3
81145dc0:	df000115 	stw	fp,4(sp)
81145dc4:	df000104 	addi	fp,sp,4
81145dc8:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81145dcc:	0001883a 	nop
81145dd0:	e037883a 	mov	sp,fp
81145dd4:	df000017 	ldw	fp,0(sp)
81145dd8:	dec00104 	addi	sp,sp,4
81145ddc:	f800283a 	ret

81145de0 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81145de0:	deffff04 	addi	sp,sp,-4
81145de4:	de00012e 	bgeu	sp,et,81145dec <OSTaskSwHook+0xc>
81145de8:	003b68fa 	trap	3
81145dec:	df000015 	stw	fp,0(sp)
81145df0:	d839883a 	mov	fp,sp
}
81145df4:	0001883a 	nop
81145df8:	e037883a 	mov	sp,fp
81145dfc:	df000017 	ldw	fp,0(sp)
81145e00:	dec00104 	addi	sp,sp,4
81145e04:	f800283a 	ret

81145e08 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81145e08:	deffff04 	addi	sp,sp,-4
81145e0c:	de00012e 	bgeu	sp,et,81145e14 <OSTaskStatHook+0xc>
81145e10:	003b68fa 	trap	3
81145e14:	df000015 	stw	fp,0(sp)
81145e18:	d839883a 	mov	fp,sp
}
81145e1c:	0001883a 	nop
81145e20:	e037883a 	mov	sp,fp
81145e24:	df000017 	ldw	fp,0(sp)
81145e28:	dec00104 	addi	sp,sp,4
81145e2c:	f800283a 	ret

81145e30 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81145e30:	defffe04 	addi	sp,sp,-8
81145e34:	de00012e 	bgeu	sp,et,81145e3c <OSTimeTickHook+0xc>
81145e38:	003b68fa 	trap	3
81145e3c:	dfc00115 	stw	ra,4(sp)
81145e40:	df000015 	stw	fp,0(sp)
81145e44:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81145e48:	d0a0b00b 	ldhu	r2,-32064(gp)
81145e4c:	10800044 	addi	r2,r2,1
81145e50:	d0a0b00d 	sth	r2,-32064(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81145e54:	d0a0b00b 	ldhu	r2,-32064(gp)
81145e58:	10bfffcc 	andi	r2,r2,65535
81145e5c:	10807d30 	cmpltui	r2,r2,500
81145e60:	1000021e 	bne	r2,zero,81145e6c <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81145e64:	d020b00d 	sth	zero,-32064(gp)
        OSTmrSignal();
81145e68:	113c7800 	call	8113c780 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81145e6c:	0001883a 	nop
81145e70:	e037883a 	mov	sp,fp
81145e74:	dfc00117 	ldw	ra,4(sp)
81145e78:	df000017 	ldw	fp,0(sp)
81145e7c:	dec00204 	addi	sp,sp,8
81145e80:	f800283a 	ret

81145e84 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81145e84:	deffff04 	addi	sp,sp,-4
81145e88:	de00012e 	bgeu	sp,et,81145e90 <OSInitHookBegin+0xc>
81145e8c:	003b68fa 	trap	3
81145e90:	df000015 	stw	fp,0(sp)
81145e94:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81145e98:	d020b00d 	sth	zero,-32064(gp)
#endif
}
81145e9c:	0001883a 	nop
81145ea0:	e037883a 	mov	sp,fp
81145ea4:	df000017 	ldw	fp,0(sp)
81145ea8:	dec00104 	addi	sp,sp,4
81145eac:	f800283a 	ret

81145eb0 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81145eb0:	deffff04 	addi	sp,sp,-4
81145eb4:	de00012e 	bgeu	sp,et,81145ebc <OSInitHookEnd+0xc>
81145eb8:	003b68fa 	trap	3
81145ebc:	df000015 	stw	fp,0(sp)
81145ec0:	d839883a 	mov	fp,sp
}
81145ec4:	0001883a 	nop
81145ec8:	e037883a 	mov	sp,fp
81145ecc:	df000017 	ldw	fp,0(sp)
81145ed0:	dec00104 	addi	sp,sp,4
81145ed4:	f800283a 	ret

81145ed8 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
81145ed8:	deffff04 	addi	sp,sp,-4
81145edc:	de00012e 	bgeu	sp,et,81145ee4 <OSTaskIdleHook+0xc>
81145ee0:	003b68fa 	trap	3
81145ee4:	df000015 	stw	fp,0(sp)
81145ee8:	d839883a 	mov	fp,sp
}
81145eec:	0001883a 	nop
81145ef0:	e037883a 	mov	sp,fp
81145ef4:	df000017 	ldw	fp,0(sp)
81145ef8:	dec00104 	addi	sp,sp,4
81145efc:	f800283a 	ret

81145f00 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81145f00:	defffe04 	addi	sp,sp,-8
81145f04:	de00012e 	bgeu	sp,et,81145f0c <OSTCBInitHook+0xc>
81145f08:	003b68fa 	trap	3
81145f0c:	df000115 	stw	fp,4(sp)
81145f10:	df000104 	addi	fp,sp,4
81145f14:	e13fff15 	stw	r4,-4(fp)
}
81145f18:	0001883a 	nop
81145f1c:	e037883a 	mov	sp,fp
81145f20:	df000017 	ldw	fp,0(sp)
81145f24:	dec00104 	addi	sp,sp,4
81145f28:	f800283a 	ret

81145f2c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81145f2c:	defffe04 	addi	sp,sp,-8
81145f30:	de00012e 	bgeu	sp,et,81145f38 <alt_exception_cause_generated_bad_addr+0xc>
81145f34:	003b68fa 	trap	3
81145f38:	df000115 	stw	fp,4(sp)
81145f3c:	df000104 	addi	fp,sp,4
81145f40:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81145f44:	e0bfff17 	ldw	r2,-4(fp)
81145f48:	10bffe84 	addi	r2,r2,-6
81145f4c:	10c00428 	cmpgeui	r3,r2,16
81145f50:	18001a1e 	bne	r3,zero,81145fbc <alt_exception_cause_generated_bad_addr+0x90>
81145f54:	100690ba 	slli	r3,r2,2
81145f58:	00a04534 	movhi	r2,33044
81145f5c:	1097db04 	addi	r2,r2,24428
81145f60:	1885883a 	add	r2,r3,r2
81145f64:	10800017 	ldw	r2,0(r2)
81145f68:	1000683a 	jmp	r2
81145f6c:	81145fac 	andhi	r4,r16,20862
81145f70:	81145fac 	andhi	r4,r16,20862
81145f74:	81145fbc 	xorhi	r4,r16,20862
81145f78:	81145fbc 	xorhi	r4,r16,20862
81145f7c:	81145fbc 	xorhi	r4,r16,20862
81145f80:	81145fac 	andhi	r4,r16,20862
81145f84:	81145fb4 	orhi	r4,r16,20862
81145f88:	81145fbc 	xorhi	r4,r16,20862
81145f8c:	81145fac 	andhi	r4,r16,20862
81145f90:	81145fac 	andhi	r4,r16,20862
81145f94:	81145fbc 	xorhi	r4,r16,20862
81145f98:	81145fac 	andhi	r4,r16,20862
81145f9c:	81145fb4 	orhi	r4,r16,20862
81145fa0:	81145fbc 	xorhi	r4,r16,20862
81145fa4:	81145fbc 	xorhi	r4,r16,20862
81145fa8:	81145fac 	andhi	r4,r16,20862
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
81145fac:	00800044 	movi	r2,1
81145fb0:	00000306 	br	81145fc0 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
81145fb4:	0005883a 	mov	r2,zero
81145fb8:	00000106 	br	81145fc0 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
81145fbc:	0005883a 	mov	r2,zero
  }
}
81145fc0:	e037883a 	mov	sp,fp
81145fc4:	df000017 	ldw	fp,0(sp)
81145fc8:	dec00104 	addi	sp,sp,4
81145fcc:	f800283a 	ret

81145fd0 <exit>:
81145fd0:	defffe04 	addi	sp,sp,-8
81145fd4:	000b883a 	mov	r5,zero
81145fd8:	de00012e 	bgeu	sp,et,81145fe0 <exit+0x10>
81145fdc:	003b68fa 	trap	3
81145fe0:	dc000015 	stw	r16,0(sp)
81145fe4:	dfc00115 	stw	ra,4(sp)
81145fe8:	2021883a 	mov	r16,r4
81145fec:	11461780 	call	81146178 <__call_exitprocs>
81145ff0:	00a04574 	movhi	r2,33045
81145ff4:	10b52804 	addi	r2,r2,-11104
81145ff8:	11000017 	ldw	r4,0(r2)
81145ffc:	20800f17 	ldw	r2,60(r4)
81146000:	10000126 	beq	r2,zero,81146008 <exit+0x38>
81146004:	103ee83a 	callr	r2
81146008:	8009883a 	mov	r4,r16
8114600c:	11463000 	call	81146300 <_exit>

81146010 <memcmp>:
81146010:	01c000c4 	movi	r7,3
81146014:	3980192e 	bgeu	r7,r6,8114607c <memcmp+0x6c>
81146018:	2144b03a 	or	r2,r4,r5
8114601c:	11c4703a 	and	r2,r2,r7
81146020:	10000f26 	beq	r2,zero,81146060 <memcmp+0x50>
81146024:	20800003 	ldbu	r2,0(r4)
81146028:	28c00003 	ldbu	r3,0(r5)
8114602c:	10c0151e 	bne	r2,r3,81146084 <memcmp+0x74>
81146030:	31bfff84 	addi	r6,r6,-2
81146034:	01ffffc4 	movi	r7,-1
81146038:	00000406 	br	8114604c <memcmp+0x3c>
8114603c:	20800003 	ldbu	r2,0(r4)
81146040:	28c00003 	ldbu	r3,0(r5)
81146044:	31bfffc4 	addi	r6,r6,-1
81146048:	10c00e1e 	bne	r2,r3,81146084 <memcmp+0x74>
8114604c:	21000044 	addi	r4,r4,1
81146050:	29400044 	addi	r5,r5,1
81146054:	31fff91e 	bne	r6,r7,8114603c <__reset+0xfb12603c>
81146058:	0005883a 	mov	r2,zero
8114605c:	f800283a 	ret
81146060:	20c00017 	ldw	r3,0(r4)
81146064:	28800017 	ldw	r2,0(r5)
81146068:	18bfee1e 	bne	r3,r2,81146024 <__reset+0xfb126024>
8114606c:	31bfff04 	addi	r6,r6,-4
81146070:	21000104 	addi	r4,r4,4
81146074:	29400104 	addi	r5,r5,4
81146078:	39bff936 	bltu	r7,r6,81146060 <__reset+0xfb126060>
8114607c:	303fe91e 	bne	r6,zero,81146024 <__reset+0xfb126024>
81146080:	003ff506 	br	81146058 <__reset+0xfb126058>
81146084:	10c5c83a 	sub	r2,r2,r3
81146088:	f800283a 	ret

8114608c <strncpy>:
8114608c:	2906b03a 	or	r3,r5,r4
81146090:	18c000cc 	andi	r3,r3,3
81146094:	2005883a 	mov	r2,r4
81146098:	18002c1e 	bne	r3,zero,8114614c <strncpy+0xc0>
8114609c:	010000c4 	movi	r4,3
811460a0:	21802a2e 	bgeu	r4,r6,8114614c <strncpy+0xc0>
811460a4:	033fbff4 	movhi	r12,65279
811460a8:	02e02074 	movhi	r11,32897
811460ac:	633fbfc4 	addi	r12,r12,-257
811460b0:	5ae02004 	addi	r11,r11,-32640
811460b4:	100f883a 	mov	r7,r2
811460b8:	2a000017 	ldw	r8,0(r5)
811460bc:	3815883a 	mov	r10,r7
811460c0:	4313883a 	add	r9,r8,r12
811460c4:	0206303a 	nor	r3,zero,r8
811460c8:	48c6703a 	and	r3,r9,r3
811460cc:	1ac6703a 	and	r3,r3,r11
811460d0:	1800261e 	bne	r3,zero,8114616c <strncpy+0xe0>
811460d4:	39c00104 	addi	r7,r7,4
811460d8:	52000015 	stw	r8,0(r10)
811460dc:	31bfff04 	addi	r6,r6,-4
811460e0:	3811883a 	mov	r8,r7
811460e4:	29400104 	addi	r5,r5,4
811460e8:	21bff336 	bltu	r4,r6,811460b8 <__reset+0xfb1260b8>
811460ec:	30001e26 	beq	r6,zero,81146168 <strncpy+0xdc>
811460f0:	29c00003 	ldbu	r7,0(r5)
811460f4:	31bfffc4 	addi	r6,r6,-1
811460f8:	40c00044 	addi	r3,r8,1
811460fc:	41c00005 	stb	r7,0(r8)
81146100:	39c03fcc 	andi	r7,r7,255
81146104:	39c0201c 	xori	r7,r7,128
81146108:	39ffe004 	addi	r7,r7,-128
8114610c:	29400044 	addi	r5,r5,1
81146110:	38001026 	beq	r7,zero,81146154 <strncpy+0xc8>
81146114:	1811883a 	mov	r8,r3
81146118:	00000906 	br	81146140 <strncpy+0xb4>
8114611c:	29c00003 	ldbu	r7,0(r5)
81146120:	31bfffc4 	addi	r6,r6,-1
81146124:	29400044 	addi	r5,r5,1
81146128:	41c00005 	stb	r7,0(r8)
8114612c:	39c03fcc 	andi	r7,r7,255
81146130:	39c0201c 	xori	r7,r7,128
81146134:	39ffe004 	addi	r7,r7,-128
81146138:	1811883a 	mov	r8,r3
8114613c:	38000526 	beq	r7,zero,81146154 <strncpy+0xc8>
81146140:	18c00044 	addi	r3,r3,1
81146144:	303ff51e 	bne	r6,zero,8114611c <__reset+0xfb12611c>
81146148:	f800283a 	ret
8114614c:	1011883a 	mov	r8,r2
81146150:	003fe606 	br	811460ec <__reset+0xfb1260ec>
81146154:	30000726 	beq	r6,zero,81146174 <strncpy+0xe8>
81146158:	198d883a 	add	r6,r3,r6
8114615c:	18000005 	stb	zero,0(r3)
81146160:	18c00044 	addi	r3,r3,1
81146164:	19bffd1e 	bne	r3,r6,8114615c <__reset+0xfb12615c>
81146168:	f800283a 	ret
8114616c:	3811883a 	mov	r8,r7
81146170:	003fdf06 	br	811460f0 <__reset+0xfb1260f0>
81146174:	f800283a 	ret

81146178 <__call_exitprocs>:
81146178:	defff504 	addi	sp,sp,-44
8114617c:	de00012e 	bgeu	sp,et,81146184 <__call_exitprocs+0xc>
81146180:	003b68fa 	trap	3
81146184:	df000915 	stw	fp,36(sp)
81146188:	dd400615 	stw	r21,24(sp)
8114618c:	dc800315 	stw	r18,12(sp)
81146190:	dfc00a15 	stw	ra,40(sp)
81146194:	ddc00815 	stw	r23,32(sp)
81146198:	dd800715 	stw	r22,28(sp)
8114619c:	dd000515 	stw	r20,20(sp)
811461a0:	dcc00415 	stw	r19,16(sp)
811461a4:	dc400215 	stw	r17,8(sp)
811461a8:	dc000115 	stw	r16,4(sp)
811461ac:	d9000015 	stw	r4,0(sp)
811461b0:	2839883a 	mov	fp,r5
811461b4:	04800044 	movi	r18,1
811461b8:	057fffc4 	movi	r21,-1
811461bc:	00a04574 	movhi	r2,33045
811461c0:	10b52804 	addi	r2,r2,-11104
811461c4:	12000017 	ldw	r8,0(r2)
811461c8:	45005217 	ldw	r20,328(r8)
811461cc:	44c05204 	addi	r19,r8,328
811461d0:	a0001c26 	beq	r20,zero,81146244 <__call_exitprocs+0xcc>
811461d4:	a0800117 	ldw	r2,4(r20)
811461d8:	15ffffc4 	addi	r23,r2,-1
811461dc:	b8000d16 	blt	r23,zero,81146214 <__call_exitprocs+0x9c>
811461e0:	14000044 	addi	r16,r2,1
811461e4:	8421883a 	add	r16,r16,r16
811461e8:	8421883a 	add	r16,r16,r16
811461ec:	84402004 	addi	r17,r16,128
811461f0:	a463883a 	add	r17,r20,r17
811461f4:	a421883a 	add	r16,r20,r16
811461f8:	e0001e26 	beq	fp,zero,81146274 <__call_exitprocs+0xfc>
811461fc:	80804017 	ldw	r2,256(r16)
81146200:	e0801c26 	beq	fp,r2,81146274 <__call_exitprocs+0xfc>
81146204:	bdffffc4 	addi	r23,r23,-1
81146208:	843fff04 	addi	r16,r16,-4
8114620c:	8c7fff04 	addi	r17,r17,-4
81146210:	bd7ff91e 	bne	r23,r21,811461f8 <__reset+0xfb1261f8>
81146214:	00800034 	movhi	r2,0
81146218:	10800004 	addi	r2,r2,0
8114621c:	10000926 	beq	r2,zero,81146244 <__call_exitprocs+0xcc>
81146220:	a0800117 	ldw	r2,4(r20)
81146224:	1000301e 	bne	r2,zero,811462e8 <__call_exitprocs+0x170>
81146228:	a0800017 	ldw	r2,0(r20)
8114622c:	10003226 	beq	r2,zero,811462f8 <__call_exitprocs+0x180>
81146230:	a009883a 	mov	r4,r20
81146234:	98800015 	stw	r2,0(r19)
81146238:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114623c:	9d000017 	ldw	r20,0(r19)
81146240:	a03fe41e 	bne	r20,zero,811461d4 <__reset+0xfb1261d4>
81146244:	dfc00a17 	ldw	ra,40(sp)
81146248:	df000917 	ldw	fp,36(sp)
8114624c:	ddc00817 	ldw	r23,32(sp)
81146250:	dd800717 	ldw	r22,28(sp)
81146254:	dd400617 	ldw	r21,24(sp)
81146258:	dd000517 	ldw	r20,20(sp)
8114625c:	dcc00417 	ldw	r19,16(sp)
81146260:	dc800317 	ldw	r18,12(sp)
81146264:	dc400217 	ldw	r17,8(sp)
81146268:	dc000117 	ldw	r16,4(sp)
8114626c:	dec00b04 	addi	sp,sp,44
81146270:	f800283a 	ret
81146274:	a0800117 	ldw	r2,4(r20)
81146278:	80c00017 	ldw	r3,0(r16)
8114627c:	10bfffc4 	addi	r2,r2,-1
81146280:	15c01426 	beq	r2,r23,811462d4 <__call_exitprocs+0x15c>
81146284:	80000015 	stw	zero,0(r16)
81146288:	183fde26 	beq	r3,zero,81146204 <__reset+0xfb126204>
8114628c:	95c8983a 	sll	r4,r18,r23
81146290:	a0806217 	ldw	r2,392(r20)
81146294:	a5800117 	ldw	r22,4(r20)
81146298:	2084703a 	and	r2,r4,r2
8114629c:	10000b26 	beq	r2,zero,811462cc <__call_exitprocs+0x154>
811462a0:	a0806317 	ldw	r2,396(r20)
811462a4:	2088703a 	and	r4,r4,r2
811462a8:	20000c1e 	bne	r4,zero,811462dc <__call_exitprocs+0x164>
811462ac:	89400017 	ldw	r5,0(r17)
811462b0:	d9000017 	ldw	r4,0(sp)
811462b4:	183ee83a 	callr	r3
811462b8:	a0800117 	ldw	r2,4(r20)
811462bc:	15bfbf1e 	bne	r2,r22,811461bc <__reset+0xfb1261bc>
811462c0:	98800017 	ldw	r2,0(r19)
811462c4:	153fcf26 	beq	r2,r20,81146204 <__reset+0xfb126204>
811462c8:	003fbc06 	br	811461bc <__reset+0xfb1261bc>
811462cc:	183ee83a 	callr	r3
811462d0:	003ff906 	br	811462b8 <__reset+0xfb1262b8>
811462d4:	a5c00115 	stw	r23,4(r20)
811462d8:	003feb06 	br	81146288 <__reset+0xfb126288>
811462dc:	89000017 	ldw	r4,0(r17)
811462e0:	183ee83a 	callr	r3
811462e4:	003ff406 	br	811462b8 <__reset+0xfb1262b8>
811462e8:	a0800017 	ldw	r2,0(r20)
811462ec:	a027883a 	mov	r19,r20
811462f0:	1029883a 	mov	r20,r2
811462f4:	003fb606 	br	811461d0 <__reset+0xfb1261d0>
811462f8:	0005883a 	mov	r2,zero
811462fc:	003ffb06 	br	811462ec <__reset+0xfb1262ec>

81146300 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81146300:	defffc04 	addi	sp,sp,-16
81146304:	de00012e 	bgeu	sp,et,8114630c <_exit+0xc>
81146308:	003b68fa 	trap	3
8114630c:	dfc00315 	stw	ra,12(sp)
81146310:	df000215 	stw	fp,8(sp)
81146314:	df000204 	addi	fp,sp,8
81146318:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114631c:	d0a01217 	ldw	r2,-32696(gp)
81146320:	10800058 	cmpnei	r2,r2,1
81146324:	1000031e 	bne	r2,zero,81146334 <_exit+0x34>
81146328:	01204574 	movhi	r4,33045
8114632c:	212dab04 	addi	r4,r4,-18772
81146330:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
81146334:	d0a01217 	ldw	r2,-32696(gp)
81146338:	10800058 	cmpnei	r2,r2,1
8114633c:	1000041e 	bne	r2,zero,81146350 <_exit+0x50>
81146340:	e17fff17 	ldw	r5,-4(fp)
81146344:	01204574 	movhi	r4,33045
81146348:	212db604 	addi	r4,r4,-18728
8114634c:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
81146350:	d0a01217 	ldw	r2,-32696(gp)
81146354:	10800058 	cmpnei	r2,r2,1
81146358:	1000031e 	bne	r2,zero,81146368 <_exit+0x68>
8114635c:	01204574 	movhi	r4,33045
81146360:	212dc104 	addi	r4,r4,-18684
81146364:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  ALT_OS_STOP();
81146368:	d0208b05 	stb	zero,-32212(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114636c:	d0a01217 	ldw	r2,-32696(gp)
81146370:	10800058 	cmpnei	r2,r2,1
81146374:	1000031e 	bne	r2,zero,81146384 <_exit+0x84>
81146378:	01204574 	movhi	r4,33045
8114637c:	212dcb04 	addi	r4,r4,-18644
81146380:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
81146384:	e0bfff17 	ldw	r2,-4(fp)
81146388:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114638c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
81146390:	10000226 	beq	r2,zero,8114639c <_exit+0x9c>
    ALT_SIM_FAIL();
81146394:	002af070 	cmpltui	zero,zero,43969
81146398:	00000106 	br	811463a0 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114639c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
811463a0:	d0a01217 	ldw	r2,-32696(gp)
811463a4:	10800058 	cmpnei	r2,r2,1
811463a8:	1000031e 	bne	r2,zero,811463b8 <_exit+0xb8>
811463ac:	01204574 	movhi	r4,33045
811463b0:	212dd504 	addi	r4,r4,-18604
811463b4:	1131fc40 	call	81131fc4 <alt_log_printf_proc>
  while (1);
811463b8:	003fff06 	br	811463b8 <__reset+0xfb1263b8>
