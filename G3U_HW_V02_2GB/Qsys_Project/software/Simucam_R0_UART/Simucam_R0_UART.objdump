
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0004c2b0 memsz 0x00065a20 flags rwx
    LOAD off    0x0004e000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  0004e000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00045024  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000525c  81145280  81145280  00046280  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114a4dc  8114a4dc  0004b4dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00019770  8114c2d0  8114c2d0  0004d2d0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81165a40  81165a40  0004e000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  0004e000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0004e000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  0004e028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0006df18  00000000  00000000  0004fd80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016560  00000000  00000000  000bdc98  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002125d  00000000  00000000  000d41f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009090  00000000  00000000  000f5458  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c298  00000000  00000000  000fe4e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0010a780  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013164c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  00131690  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0013f501  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0013f507  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0013f513  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0013f514  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0013f515  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0013f519  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0013f51d  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0013f521  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0013f52c  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0013f536  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0013f540  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  0013f551  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     002827ef  00000000  00000000  0013f590  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
81145280 l    d  .rodata	00000000 .rodata
8114a4dc l    d  .rwdata	00000000 .rwdata
8114c2d0 l    d  .bss	00000000 .bss
81165a40 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
00000000 l    df *ABS*	00000000 data_packet.c
81104da8 l     F .text	00000050 uliDpktReadReg
81104d54 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8114c2ec l     O .bss	00000004 viCh1HoldContext
8114c2f0 l     O .bss	00000004 viCh2HoldContext
8114c2f4 l     O .bss	00000004 viCh3HoldContext
8114c2f8 l     O .bss	00000004 viCh4HoldContext
8114c2fc l     O .bss	00000004 viCh5HoldContext
8114c300 l     O .bss	00000004 viCh6HoldContext
8114c304 l     O .bss	00000004 viCh7HoldContext
8114c308 l     O .bss	00000004 viCh8HoldContext
81105d54 l     F .text	00000054 vFeebWriteReg
81105da8 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8114c30c l     O .bss	00000004 viCh1HoldContext
8114c310 l     O .bss	00000004 viCh2HoldContext
8114c314 l     O .bss	00000004 viCh3HoldContext
8114c318 l     O .bss	00000004 viCh4HoldContext
8114c31c l     O .bss	00000004 viCh5HoldContext
8114c320 l     O .bss	00000004 viCh6HoldContext
8114c324 l     O .bss	00000004 viCh7HoldContext
8114c328 l     O .bss	00000004 viCh8HoldContext
81108ac0 l     F .text	00000054 vRmapWriteReg
81108b14 l     F .text	00000050 uliRmapReadReg
81108b64 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
81109498 l     F .text	00000050 uliSpwcReadReg
81109444 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114c1f8 l     O .rwdata	00000001 ucIoValue
81109698 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
81109f88 l     F .text	0000013c msgdma_write_extended_descriptor
8110a0c4 l     F .text	00000164 msgdma_construct_extended_descriptor
8110a228 l     F .text	00000318 msgdma_descriptor_async_transfer
8110a540 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110b0bc l     F .text	00000054 vRstcWriteReg
8110b110 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114c330 l     O .bss	00000004 viHoldContext
8110c53c l     F .text	0000005c bSyncWriteReg
8110c598 l     F .text	00000058 uliSyncReadReg
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8114c340 l     O .bss	00000004 pxNFee.4257
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8114c344 l     O .bss	00000004 xRAckLocal.5052
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114c348 l     O .bss	00000004 bDmaBack.4416
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114c34c l     O .bss	00000004 xSAckLocal.5037
00000000 l    df *ABS*	00000000 parser_comm_task.c
8114c4e8 l     O .bss	0000004c PreParsedLocal.5130
8114c534 l     O .bss	00000054 xTcPusL.5129
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8114c588 l     O .bss	0000004c xPreParsedReader.5118
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8114c5d4 l     O .bss	00000054 xPusLocal.5258
8114c628 l     O .bss	00000054 xPusLocal.5292
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81147e9b l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114991d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114a4dc l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111bfc0 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
81149aea l     O .rodata	00000010 zeroes.4389
81149afa l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
81149b0a l     O .rodata	00000010 zeroes.4404
81120c38 l     F .text	000000c4 __sbprintf
81149b1a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81149b32 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
81122920 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
81124470 l     F .text	00000008 __fp_unlock
81124484 l     F .text	000001a4 __sinit.part.1
81124628 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114ad28 l     O .rwdata	00000020 lc_ctype_charset
8114ad08 l     O .rwdata	00000020 lc_message_charset
8114ad48 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
81149b70 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81127498 l     F .text	0000006c sulp
81149cb8 l     O .rodata	00000014 fpi.2737
81149ccc l     O .rodata	00000028 tinytens
81149ca4 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81149d04 l     O .rodata	00000010 blanks.4332
81149cf4 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112ab08 l     F .text	00000104 __sprint_r.part.0
81149d24 l     O .rodata	00000010 blanks.4348
81149d14 l     O .rodata	00000010 zeroes.4349
8112c0a4 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112c558 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
811302f4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81130438 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
8113046c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
811306f0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
811307e8 l       .text	00000000 tx_next_char
81130810 l       .text	00000000 end_tx
811307f0 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
811312ec l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81131568 l     F .text	00000044 alt_get_errno
811315ac l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
811317d4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8114c240 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81131d74 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114c24c l     O .rwdata	00000004 lockid
8114c430 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8114c250 l     O .rwdata	00000004 lockid
8114c438 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
81133800 l     F .text	00000050 OS_InitMisc
81133850 l     F .text	00000074 OS_InitRdyList
811339d4 l     F .text	000000ec OS_InitTCBList
81133718 l     F .text	000000e8 OS_InitEventList
811338c4 l     F .text	00000088 OS_InitTaskIdle
8113394c l     F .text	00000088 OS_InitTaskStat
81133c64 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81135a7c l     F .text	000000fc OS_FlagTaskRdy
8113582c l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
81137368 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113bbe4 l     F .text	00000044 OSTmr_Lock
8113b684 l     F .text	00000074 OSTmr_Alloc
8113bc28 l     F .text	0000003c OSTmr_Unlock
8113bae8 l     F .text	000000fc OSTmr_Unlink
8113b6f8 l     F .text	000000a4 OSTmr_Free
8113b998 l     F .text	00000150 OSTmr_Link
8113b910 l     F .text	00000088 OSTmr_InitTask
8113bc64 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113bd74 l     F .text	0000003c alt_dev_reg
8114afc4 l     O .rwdata	0000106c jtag_uart_0
8114c030 l     O .rwdata	000000d0 rs232_uart
8114c100 l     O .rwdata	00000064 dma_DDR_M1
8114c164 l     O .rwdata	00000064 dma_DDR_M2
8114c1c8 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81140604 l     F .text	000002bc altera_avalon_jtag_uart_irq
811408c0 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
811410c4 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
8114145c l     F .text	000000a4 altera_avalon_uart_irq
81141500 l     F .text	00000140 altera_avalon_uart_rxirq
81141640 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81141848 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81141afc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81141d80 l     F .text	00000044 alt_get_errno
81141dc4 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81141e60 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81141f94 l     F .text	0000018c alt_msgdma_irq
81142120 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
811421b4 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81142310 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81142650 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81142d58 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81142e04 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81143fd0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81144614 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8114c4e0 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8114c4e4 g     O .bss	00000004 alt_instruction_exception_handler
81106190 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
8114cba4 g     O .bss	00001000 vFeeTask0_stk
811162c8 g     F .text	0000004c vFailDeleteInitialization
8114c4b4 g     O .bss	00000004 aux_status_register
8114dba4 g     O .bss	00001000 vInAckHandlerTask_stk
81143d8c g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
811064d8 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110b710 g     F .text	0000004c vSyncInitIrq
81112470 g     F .text	00000284 vCheckRetransmission128
81126b1c g     F .text	0000007c _mprec_log10
8110b918 g     F .text	00000040 bSyncSetMbt
8110987c g     F .text	00000108 I2C_Read
8114c29e g     O .rwdata	00000002 OSTaskNameSize
8114c354 g     O .bss	00000004 xWaitSyncQFee
8114eba4 g     O .bss	00000260 xBuffer64
81126c10 g     F .text	0000008c __any_on
811255e4 g     F .text	0000005c _isatty_r
81149b7c g     O .rodata	00000028 __mprec_tinytens
81106480 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
8113140c g     F .text	0000015c alt_main
8111bee4 g     F .text	000000c8 _puts_r
811052c8 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
8114c440 g     O .bss	00000004 OSTmrFreeList
81165940 g     O .bss	00000100 alt_irq
81125754 g     F .text	00000068 _lseek_r
81118784 g     F .text	00000030 vChangeDefaultAutoResetSync
811362dc g     F .text	000000d4 OS_MemInit
81114e00 g     F .text	000009d4 vLoadDefaultETHConf
8110dcf4 g     F .text	0000014c bCheckInAck64
8114ee04 g     O .bss	00000150 xPus
8113abc4 g     F .text	00000068 OSTimeSet
81124828 g     F .text	000000ac __sflags
8111720c g     F .text	00000068 vCoudlNotCreateNFee2Task
811175f8 g     F .text	0000004c vCouldNotGetMutexMebPus
8112f454 g     F .text	00000088 .hidden __eqdf2
8111191c g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
81118670 g     F .text	00000034 vLoadDefaultSyncSource
8113c274 g     F .text	000001ac Check_for_Master_Boot_Record
8115fafc g     O .bss	00000010 OSTmrWheelTbl
81106578 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81142b18 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8114ef54 g     O .bss	00000010 xFeeQueueTBL3
81132464 g     F .text	00000594 OSEventPendMulti
8114c358 g     O .bss	00000004 xNfeeSchedule
81165a40 g       *ABS*	00000000 __alt_heap_start
81144c4c g     F .text	0000002c OSTaskCreateHook
811400ec g     F .text	000001c4 alt_up_sd_card_fclose
8114c35c g     O .bss	00000004 xSemCountBuffer64
8110697c g     F .text	00000088 bRmapGetIrqControl
8111bd28 g     F .text	00000044 printf
8114c32d g     O .bss	00000001 SspdConfigControl
8110bd34 g     F .text	00000054 bSyncCtrReset
8114c276 g     O .rwdata	00000002 OSMboxEn
81119214 g     F .text	000000a4 aatoh
81132a5c g     F .text	00000054 OSIntEnter
8112d1c4 g     F .text	000000a4 _wcrtomb_r
811051d4 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81116230 g     F .text	0000004c vFailReceiverCreate
8114c334 g     O .bss	00000004 xQMaskDataCtrl
81104e38 g     F .text	00000040 vFeebCh2HandleIrq
8111c44c g     F .text	00000064 __sseek
811247d8 g     F .text	00000010 __sinit
8110a9fc g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
811225a0 g     F .text	00000148 __swbuf_r
81112c48 g     F .text	00000404 bResourcesInitRTOS
81108fe4 g     F .text	000000f4 bSpwcGetLinkError
8114c286 g     O .rwdata	00000002 OSQEn
81105eb8 g     F .text	00000040 vRmapCh4HandleIrq
81125670 g     F .text	00000084 _setlocale_r
8114c360 g     O .bss	00000008 SyncTBL2
8114c1fc g     O .rwdata	00000004 LedsPainelControl
8114c6a4 g     O .bss	00000100 cDebugBuffer
81124630 g     F .text	00000070 __sfmoreglue
8112aaf0 g     F .text	00000018 ungetc
81132120 g     F .text	000000d4 __malloc_unlock
81102d7c g     F .text	00000210 DMA_MULTIPLE_TRANSFER
81144ccc g     F .text	00000028 OSTaskStatHook
81111800 g     F .text	00000088 vSendCmdQToNFeeCTRL
811186e0 g     F .text	00000030 vChangeDefaultSyncSource
8114c444 g     O .bss	00000001 OSLockNesting
8114c448 g     O .bss	00000004 OSTmrSemSignal
81117b10 g     F .text	000000f8 vNFeeStructureInit
8114c368 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
81127504 g     F .text	00001600 _strtod_r
8114c36c g     O .bss	00000004 xSemCountSenderACK
81119350 g     F .text	00000448 .hidden __divsf3
8114c4d8 g     O .bss	00000004 current_sector_modified
8114c2c4 g     O .rwdata	00000002 OSDataSize
8114c44c g     O .bss	00000001 OSRunning
811092c0 g     F .text	00000184 bSpwcInitCh
811310d4 g     F .text	00000064 alt_log_jtag_uart_isr_proc
8114ef64 g     O .bss	00001000 senderTask_stk
81107470 g     F .text	00000094 bRmapGetMemConfigStat
8114c370 g     O .bss	00000004 fp
8114ff64 g     O .bss	00000030 xNfeeScheduleTBL
8110dbac g     F .text	00000148 bCheckInAck128
81125ae4 g     F .text	0000015c memmove
81144d48 g     F .text	0000002c OSInitHookBegin
8110c1d0 g     F .text	00000074 bSyncCtrCh8OutEnable
8114c2bc g     O .rwdata	00000002 OSTmrSize
811247c0 g     F .text	00000018 _cleanup
81118bac g     F .text	00000040 siCloseFile
81105bd0 g     F .text	00000184 bFeebInitCh
81125c40 g     F .text	000000b0 _Balloc
81118710 g     F .text	00000038 vLoadDefaultAutoResetSync
81106a8c g     F .text	000000d8 bRmapSetCodecConfig
8113ecc8 g     F .text	000000cc alt_up_sd_card_is_Present
81142a58 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114c2d8 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a4 DMA_DISPATCHER_STOP
8113bf9c g     F .text	00000054 Save_Modified_Sector
81105428 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
8114c450 g     O .bss	00000004 OSIdleCtr
8114c40c g     O .bss	00000001 alt_log_write_on_flag
811094e8 g     F .text	0000003c bEnableIsoDrivers
8112f4dc g     F .text	000000dc .hidden __gtdf2
811449dc g     F .text	0000002c altera_nios2_gen2_irq_init
81144ac4 g       .text	00000000 OSStartTsk
8110ba8c g     F .text	00000070 bSyncSetNCycles
81133fd4 g     F .text	000002dc OS_TCBInit
8114c40f g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
81118330 g     F .text	00000078 vInitSimucamBasicHW
8114ff94 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110c0e8 g     F .text	00000074 bSyncCtrCh6OutEnable
81109bf8 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8114c4d0 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8114c454 g     O .bss	00000002 OSTmrUsed
8114c374 g     O .bss	00000004 xSemCountBuffer128
81103254 g     F .text	000000f8 TEMP_Read
811068d4 g     F .text	000000a8 bRmapSetIrqControl
81150f94 g     O .bss	00001000 vDataControlTask_stk
81104eb8 g     F .text	00000040 vFeebCh4HandleIrq
8114c2c2 g     O .rwdata	00000002 OSTmrWheelTblSize
81117ff8 g     F .text	0000002c cFeeSpwChannelDisable
8114c262 g     O .rwdata	00000002 OSEventSize
8114c456 g     O .bss	00000001 OSPrioHighRdy
8111aec4 g     F .text	00000064 _fstat_r
81144c78 g     F .text	0000002c OSTaskDelHook
8114c3e8 g     O .bss	00000004 errno
8110c4c4 g     F .text	0000003c uliSyncGetCtr
81122530 g     F .text	0000001c __svfscanf
8111c3c0 g     F .text	00000008 __seofread
81144aa4 g       .text	00000000 OSStartHighRdy
811179e0 g     F .text	00000070 vEvtChangeFeeControllerMode
8110cef4 g     F .text	00000968 vPrintConsoleNFee
8110ea18 g     F .text	000000c8 bSendCmdQToNFeeInst
81105f78 g     F .text	00000040 vRmapCh7HandleIrq
811395f4 g     F .text	000001ec OSTaskCreateExt
8115fad0 g     O .bss	00000011 alt_log_write_buf
811047e4 g     F .text	0000012c bDpktGetPacketConfig
81106708 g     F .text	00000050 uliRmapCh8WriteCmdAddress
811165ec g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
81129634 g     F .text	00001244 ___svfiprintf_internal_r
811104fc g     F .text	00000364 bPreParserV2
8113535c g     F .text	00000068 OSFlagPendGetFlagsRdy
8114c2a2 g     O .rwdata	00000002 OSTaskStatStkSize
811344a8 g     F .text	00000310 OSFlagAccept
81137a84 g     F .text	000000c0 OSQFlush
81137500 g     F .text	00000148 OSQAccept
8114c420 g     O .bss	00000004 alt_argv
811541f4 g       *ABS*	00000000 _gp
81115ef8 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81131c38 g     F .text	0000013c usleep
8113f2a0 g     F .text	00000384 alt_up_sd_card_fopen
81118a18 g     F .text	00000030 bSDcardIsPresent
81110860 g     F .text	00000178 vSenderComTask
8113ee08 g     F .text	000000d8 alt_up_sd_card_find_first
8111678c g     F .text	00000068 vFailSendNack
8114c4c4 g     O .bss	00000004 command_argument_register
811390fc g     F .text	000004f8 OSTaskChangePrio
81110b6c g     F .text	00000574 vPusMebInTaskConfigMode
81116f04 g     F .text	00000088 vCouldNotSendTMPusCommand
8114c43c g     O .bss	00000004 alt_heapsem
81109e90 g     F .text	00000080 bSetBoardLeds
811342b0 g     F .text	000001f8 OSDebugInit
811397e0 g     F .text	0000034c OSTaskDel
811363b0 g     F .text	000001ac OSMutexAccept
81151f94 g     O .bss	00000298 xSimMeb
81118214 g     F .text	00000040 vSetTimeCode
81143600 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8114c378 g     O .bss	00000004 xSemCountPreParsed
8114ada8 g     O .rwdata	00000180 alt_fd_list
81105378 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114af44 g     O .rwdata	0000001d alt_log_msg_alt_main
8115fb0c g     O .bss	00000580 OSFlagTbl
81106218 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81116060 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
81106618 g     F .text	00000050 uliRmapCh5WriteCmdAddress
811185c8 g     F .text	0000003c vLoadDefaultRTValue
811334e0 g     F .text	000000c0 OS_EventTaskRemove
8115222c g     O .bss	00001000 vFeeTask5_stk
8114c40e g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
8113e51c g     F .text	00000134 find_first_empty_record_in_root_directory
811440c0 g     F .text	00000098 alt_find_dev
8111ba10 g     F .text	00000150 memcpy
8112ce90 g     F .text	00000264 __hexnan
81104be0 g     F .text	00000174 bDpktInitCh
8115322c g     O .bss	00000160 xBuffer32
8114c28c g     O .rwdata	00000002 OSRdyTblSize
8116008c g     O .bss	000001a0 OSTmrTbl
81124478 g     F .text	0000000c _cleanup_r
81130030 g     F .text	000000e4 .hidden __floatsidf
81114a28 g     F .text	000001a8 vSendPusTM64
8110b888 g     F .text	0000004c ucSyncStatusErrorCode
81111888 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
811180f4 g     F .text	00000034 cFeeRMAPLogDisable
8110edd8 g     F .text	00000e00 vParserCommTask
811446e0 g     F .text	00000084 alt_io_redirect
81118088 g     F .text	00000034 cFeeRMAPEchoingDisable
8112f5b8 g     F .text	000000f4 .hidden __ltdf2
81117544 g     F .text	0000004c vFailSendPUStoMebTask
81106428 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81105654 g     F .text	000000d4 bFeebSetIrqControl
81116cfc g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
8114c37c g     O .bss	00000004 xMutexReceivedACK
81103bd0 g     F .text	000000b0 bSdmaInitM2Dma
81143a88 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81143dd0 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110bddc g     F .text	00000054 bSyncCtrErrInj
81143d30 g     F .text	0000005c alt_msgdma_register_callback
811157d4 g     F .text	00000330 vShowEthConfig
811183a8 g     F .text	00000030 bLogWriteSDCard
8111637c g     F .text	00000068 vFailSetCountSemaphorexBuffer64
8111bfac g     F .text	00000014 puts
81118c2c g     F .text	00000238 bInitSync
81144df0 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110b608 g     F .text	00000108 vSyncHandleIrq
811321f4 g     F .text	00000128 OSEventNameGet
8110503c g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8114c270 g     O .rwdata	00000002 OSFlagMax
81125870 g     F .text	000000e0 mbrtowc
8113e114 g     F .text	000001b4 find_first_empty_cluster
8110c074 g     F .text	00000074 bSyncCtrCh5OutEnable
8114c338 g     O .bss	00000001 vucN
81127270 g     F .text	00000074 __fpclassifyd
8110b7e8 g     F .text	00000054 bSyncStatusExtnIrq
8112254c g     F .text	00000054 _vfscanf_r
81136a30 g     F .text	000005a4 OSMutexPend
81126a70 g     F .text	000000ac __ratio
8113ec04 g     F .text	000000c4 alt_up_sd_card_open_dev
81116f8c g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81132ab0 g     F .text	00000100 OSIntExit
8110b958 g     F .text	00000040 bSyncSetBt
8112c088 g     F .text	0000001c __vfiprintf_internal
81117644 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
8114c2aa g     O .rwdata	00000002 OSTCBSize
81104ff8 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
8114c457 g     O .bss	00000001 OSPrioCur
81111a14 g     F .text	00000090 vMebChangeToRunning
81140b34 g     F .text	000002c4 altera_avalon_jtag_uart_read
811432c8 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111bcf0 g     F .text	00000038 _printf_r
8112dff8 g     F .text	00000064 .hidden __udivsi3
81130734 g     F .text	000000ac isatty
8114c32c g     O .bss	00000001 LedsBoardControl
8114c380 g     O .bss	00000004 xSemCountReceivedACK
8114c290 g     O .rwdata	00000002 OSStkWidth
81125640 g     F .text	00000030 iswspace
81149bcc g     O .rodata	000000c8 __mprec_tens
8114c284 g     O .rwdata	00000002 OSPtrSize
811173ac g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
811256f4 g     F .text	0000000c __locale_charset
8110bf8c g     F .text	00000074 bSyncCtrCh3OutEnable
8112e1e8 g     F .text	000000c8 .hidden __lesf2
8114c264 g     O .rwdata	00000002 OSEventTblSize
8112d3c4 g     F .text	0000007c .hidden __fixunsdfsi
81144a08 g       .text	00000000 OSCtxSw
81109984 g     F .text	00000160 I2C_MultipleRead
81131278 g     F .text	00000074 alt_log_system_clock
8114c3f4 g     O .bss	00000004 __malloc_top_pad
8114c458 g     O .bss	00000004 OSTCBList
8113b644 g     F .text	00000040 OSTmrSignal
8114c404 g     O .bss	00000004 alt_fd_list_lock
81129160 g     F .text	0000001c strtoul
8114c214 g     O .rwdata	00000004 __mb_cur_max
81125724 g     F .text	0000000c _localeconv_r
8112917c g     F .text	000002e0 _strtoull_r
8110b04c g     F .text	00000070 vRstcHoldDeviceReset
81126064 g     F .text	00000044 __i2b
81124f88 g     F .text	000004c4 __sfvwrite_r
8113d3f4 g     F .text	000000c0 get_dir_divider_location
811060c4 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
8116022c g     O .bss	00000c30 OSMemTbl
8114c45c g     O .bss	00000001 OSTickStepState
81130e88 g     F .text	00000060 alt_log_printf_proc
81104b1c g     F .text	000000c4 bDpktGetPixelDelay
8115338c g     O .bss	00001800 vReceiverUartTask_stk
8111c1b8 g     F .text	0000005c _sbrk_r
8114c384 g     O .bss	00000004 xSemTimeoutChecker
8113d0b4 g     F .text	000000cc filename_to_upper_case
8114c410 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8114c288 g     O .rwdata	00000002 OSQMax
8113f624 g     F .text	00000090 alt_up_sd_card_set_attributes
8113672c g     F .text	00000304 OSMutexDel
81160e5c g     O .bss	00001000 OSTaskStatStk
81118a48 g     F .text	00000030 bSDcardFAT16Check
81135ef8 g     F .text	000000f8 OSMemNameGet
81115d4c g     F .text	00000060 vFailCreateMutexSResources
8113c420 g     F .text	00000284 Read_File_Record_At_Offset
81154b8c g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114c268 g     O .rwdata	00000002 OSFlagEn
81126c9c g     F .text	00000068 _read_r
8114c2ae g     O .rwdata	00000002 OSTimeTickHookEn
81135b78 g     F .text	000000ac OS_FlagUnlink
81137f4c g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
8114c230 g     O .rwdata	00000004 alt_max_fd
81116aa8 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
81133b1c g     F .text	00000070 OS_MemCopy
81133b8c g     F .text	000000d8 OS_Sched
8113dc98 g     F .text	0000047c find_file_in_directory
8112c234 g     F .text	000000f8 _fclose_r
81135e00 g     F .text	000000f8 OSMemGet
81139e24 g     F .text	000001bc OSTaskNameSet
81124440 g     F .text	00000030 fflush
8114c3f0 g     O .bss	00000004 __malloc_max_sbrked_mem
8114c460 g     O .bss	00000004 OSCtxSwCtr
81144cf4 g     F .text	00000054 OSTimeTickHook
81154bcc g     O .bss	00001000 vOutAckHandlerTask_stk
81130568 g     F .text	00000188 alt_irq_register
8114c272 g     O .rwdata	00000002 OSFlagNameSize
8111a4e0 g     F .text	00000118 .hidden __extendsfdf2
811335a0 g     F .text	00000108 OS_EventTaskRemoveMulti
811170cc g     F .text	00000070 vFailCreateNFEESyncQueue
8113ed94 g     F .text	00000074 alt_up_sd_card_is_FAT16
81109714 g     F .text	00000088 I2C_TestAdress
8112e2b0 g     F .text	000008b4 .hidden __adddf3
8115fae4 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8112e0b4 g     F .text	00000078 .hidden __nesf2
81106080 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
81133388 g     F .text	00000158 OS_EventTaskWaitMulti
8114c388 g     O .bss	00000008 SyncTBL4
81126808 g     F .text	00000114 __b2d
81143000 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114c28a g     O .rwdata	00000002 OSQSize
8112d9c0 g     F .text	00000540 .hidden __umoddi3
81131330 g     F .text	000000dc lseek
81138a3c g     F .text	00000214 OSSemPend
81117590 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81106bf0 g     F .text	00000160 bRmapGetCodecStatus
811090d8 g     F .text	000000d0 bSpwcGetLinkStatus
811059b0 g     F .text	00000088 bFeebGetWindowing
8114c204 g     O .rwdata	00000004 _global_impure_ptr
8110b5bc g     F .text	0000004c bSSDisplayUpdate
8113d758 g     F .text	00000540 get_home_directory_cluster_for_file
81126d04 g     F .text	0000056c _realloc_r
8114c274 g     O .rwdata	00000002 OSLowestPrio
81165a40 g       *ABS*	00000000 __bss_end
8114451c g     F .text	000000f8 alt_iic_isr_register
81144dc4 g     F .text	0000002c OSTCBInitHook
8114c2ba g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81131b28 g     F .text	00000110 alt_tick
81106758 g     F .text	0000017c vRmapInitIrq
81115ff8 g     F .text	00000068 vFailGetMutexSenderTask
8110af6c g     F .text	0000006c vRstcSimucamReset
81149d34 g     O .rodata	00000100 __hexdig
81143b7c g     F .text	000001b4 alt_msgdma_init
8112d440 g     F .text	00000580 .hidden __udivdi3
811101e4 g     F .text	0000017c setPreAckSenderFreePos
8112c4ac g     F .text	00000024 _fputwc_r
8114c25c g     O .rwdata	00000002 OSEventEn
81149ba4 g     O .rodata	00000028 __mprec_bigtens
81125e40 g     F .text	0000010c __s2b
8114c2b6 g     O .rwdata	00000002 OSTmrCfgNameSize
81155bcc g     O .bss	00000010 xFeeQueueTBL4
8110ba18 g     F .text	00000074 bSyncSetPolarity
811126f4 g     F .text	0000028c vCheckRetransmission64
81130114 g     F .text	000000b0 .hidden __floatunsidf
8114c414 g     O .bss	00000004 alt_system_clock_in_sec
81131080 g     F .text	00000054 alt_log_jtag_uart_startup_info
81116584 g     F .text	00000068 vFailFoundBufferRetransmission
81126540 g     F .text	00000060 __mcmp
8114c4dc g     O .bss	00000004 current_sector_index
811412f4 g     F .text	00000168 altera_avalon_uart_init
81143e58 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811040ac g     F .text	00000434 bSdmaDmaM2Transfer
81118254 g     F .text	00000034 vResetTimeCode
81117fcc g     F .text	0000002c cFeeSpwChannelEnable
811247f8 g     F .text	00000018 __fp_lock_all
811178d8 g     F .text	0000004c vFailSendMsgDataCTRL
811444c8 g     F .text	00000054 alt_ic_irq_enabled
8110979c g     F .text	000000e0 I2C_Write
811062c8 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8114c464 g     O .bss	00000002 OSTmrFree
81135994 g     F .text	000000e8 OS_FlagInit
81131a84 g     F .text	000000a4 alt_alarm_stop
8111c820 g     F .text	0000001c strtol
8114c40d g     O .bss	00000001 alt_log_sys_clk_on_flag
8113adf0 g     F .text	00000140 OSTmrDel
8113c18c g     F .text	000000e8 mark_cluster
8114c298 g     O .rwdata	00000002 OSTaskIdleStkSize
8114c408 g     O .bss	00000004 alt_irq_active
8113865c g     F .text	000000b8 OSSemAccept
8111aa5c g     F .text	0000044c _fseeko_r
811134e0 g     F .text	00000260 vFillMemmoryPattern
8111c59c g     F .text	00000044 strnlen
8113610c g     F .text	000000e0 OSMemPut
81135c24 g     F .text	000001dc OSMemCreate
8114c468 g     O .bss	00000004 OSIdleCtrMax
81114bd0 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
811308d0 g     F .text	000005b8 alt_log_private_printf
8114ad80 g     O .rwdata	00000028 alt_dev_null
81142c10 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110b9d8 g     F .text	00000040 bSyncSetOst
8114c2ac g     O .rwdata	00000002 OSTicksPerSec
8114af28 g     O .rwdata	00000019 alt_log_msg_bss
8113e650 g     F .text	00000194 convert_filename_to_name_extension
81107504 g     F .text	00000c4c bRmapSetRmapMemHKArea
811109d8 g     F .text	00000194 vSimMebTask
81109ae4 g     F .text	00000094 i2c_start
81144a08 g       .text	00000000 OSIntCtxSw
81117838 g     F .text	00000054 vFailSendMsgSync
8110c000 g     F .text	00000074 bSyncCtrCh4OutEnable
811439f4 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
81130410 g     F .text	00000028 alt_dcache_flush_all
81125f4c g     F .text	00000068 __hi0bits
81106668 g     F .text	00000050 uliRmapCh6WriteCmdAddress
81118604 g     F .text	0000003c vChangeRTValue
8114c4b0 g     O .bss	00000004 is_sd_card_formated_as_FAT16
811122ec g     F .text	00000184 vCheck
81117ac0 g     F .text	00000050 vNFeeNotInUse
8112ffb0 g     F .text	00000080 .hidden __fixdfsi
81105ac0 g     F .text	00000088 bFeebStopCh
8110e510 g     F .text	0000028c vNFeeControlTask
81155bdc g     O .bss	00001000 vInitialTask_stk
8114c390 g     O .bss	00000002 usiIdCMD
8114c394 g     O .bss	00000008 SyncTBL3
8110bce0 g     F .text	00000054 bSyncCtrStart
8113e2c8 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
81128b04 g     F .text	00000018 strtod
81105b48 g     F .text	00000088 bFeebClrCh
8114c46c g     O .bss	00000004 OSTCBFreeList
811063d0 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
81138c50 g     F .text	00000174 OSSemPendAbort
81116198 g     F .text	0000004c vFailGetMacRTC
811065c8 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
81116a10 g     F .text	0000004c vFailCreateTimerRetransmisison
8111651c g     F .text	00000068 vFailGetCountSemaphorexBuffer32
81113a98 g     F .text	000002f0 bSendUART128v2
81118470 g     F .text	000000b4 vSimucamStructureInit
8114c228 g     O .rwdata	00000008 alt_dev_list
8111a98c g     F .text	0000004c _fputc_r
81131db8 g     F .text	0000010c write
8111bd6c g     F .text	000000a8 _putc_r
8114c4d4 g     O .bss	00000004 device_pointer
8114c2b0 g     O .rwdata	00000002 OSVersionNbr
8112e12c g     F .text	000000bc .hidden __gtsf2
8110fbd8 g     F .text	00000118 getPreParsedPacket
811304b0 g     F .text	000000b8 fstat
811182bc g     F .text	00000040 vChangeIdNFEEMaster
8111a960 g     F .text	0000002c fprintf
811180bc g     F .text	00000038 cFeeRMAPLogEnable
81102c6c g     F .text	00000110 DMA_SINGLE_TRANSFER
811053d0 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81116b5c g     F .text	00000068 vFailPostBlockingSemTimeoutTask
81118ef4 g     F .text	00000058 _reg_write
811182fc g     F .text	00000034 vChangeDefaultIdNFEEMaster
8112f5b8 g     F .text	000000f4 .hidden __ledf2
81105ef8 g     F .text	00000040 vRmapCh5HandleIrq
81156bdc g     O .bss	00001000 vStackMonitor_stk
81116e9c g     F .text	00000068 vCouldNotSendLog
8113b070 g     F .text	000001b8 OSTmrRemainGet
8114c258 g     O .rwdata	00000004 OSEndiannessTest
8110b160 g     F .text	00000058 v_spi_start
811262a8 g     F .text	00000148 __pow5mult
81106528 g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112ac24 g     F .text	00001464 ___vfiprintf_internal_r
8114c400 g     O .bss	00000004 __nlocale_changed
8112e05c g     F .text	00000058 .hidden __umodsi3
8110be30 g     F .text	00000074 bSyncCtrSyncOutEnable
81118a78 g     F .text	000000f8 bInitializeSDCard
8111692c g     F .text	0000004c vFailParserCommTaskCreate
81116e34 g     F .text	00000068 vCouldNotSendReset
8111c258 g     F .text	00000038 _scanf_r
811169c4 g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114c26a g     O .rwdata	00000002 OSFlagGrpSize
811119a4 g     F .text	00000070 vMebChangeToConfig
81157bdc g     O .bss	00000058 xInUseRetrans
8110b798 g     F .text	00000050 bSyncIrqFlagSync
81143060 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113b228 g     F .text	000000ec OSTmrStateGet
81165a40 g       *ABS*	00000000 end
81104f38 g     F .text	00000040 vFeebCh6HandleIrq
81113740 g     F .text	00000260 vPrintMemmoryPattern
811166bc g     F .text	00000068 vNoContentInPreParsedBuffer
8111aea8 g     F .text	0000001c fseeko
8110fcf0 g     F .text	00000168 bSendMessagePUStoMebTask
8111705c g     F .text	00000070 vFailCreateNFEEQueue
8111a810 g     F .text	0000000c _atoi_r
81141b40 g     F .text	00000240 altera_avalon_uart_write
81130814 g     F .text	00000054 alt_log_txchar
8111aa40 g     F .text	0000001c fseek
81113a08 g     F .text	00000090 vCCDChangeValues
81140434 g     F .text	000001d0 altera_avalon_jtag_uart_init
81133e1c g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81115df8 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81141148 g     F .text	00000084 alt_avalon_timer_sc_init
81105908 g     F .text	000000a8 bFeebSetWindowing
81141234 g     F .text	00000068 altera_avalon_uart_write_fd
8111a7a0 g     F .text	00000064 .hidden __clzsi2
8114129c g     F .text	00000058 altera_avalon_uart_close_fd
81157c34 g     O .bss	00000020 xMebQTBL
81140df8 g     F .text	000002cc altera_avalon_jtag_uart_write
8113b79c g     F .text	00000174 OSTmr_Init
81157c54 g     O .bss	00000348 xBuffer128
811247e8 g     F .text	00000004 __sfp_lock_acquire
8110334c g     F .text	00000048 sense_log_temp
81125a00 g     F .text	000000e4 memchr
81133ac0 g     F .text	0000005c OS_MemClr
8111ea1c g     F .text	00002200 ___vfprintf_internal_r
81144ae8 g     F .text	00000164 OSTaskStkInit
8111c290 g     F .text	00000060 _sprintf_r
8110719c g     F .text	000002d4 bRmapGetMemConfigArea
8114c39c g     O .bss	00000001 SemCount32
81124c70 g     F .text	00000318 _free_r
81144764 g     F .text	00000234 alt_printf
811149d8 g     F .text	00000050 vTimeoutCheck
81118fa4 g     F .text	000001fc _print_codec_status
81125700 g     F .text	00000010 __locale_mb_cur_max
811330d0 g     F .text	000001a0 OS_EventTaskRdy
81106a04 g     F .text	00000088 bRmapGetIrqFlags
81102bc8 g     F .text	000000a4 DMA_DISPATCHER_RESET
8114503c g     F .text	00000188 __call_exitprocs
8110e8e0 g     F .text	00000138 vPerformActionNFCRunning
8114c470 g     O .bss	00000001 OSCPUUsage
811172dc g     F .text	00000068 vCoudlNotCreateNFee4Task
8114c3fc g     O .bss	00000004 __mlocale_changed
8110e79c g     F .text	00000144 vPerformActionNFCConfig
8110bd88 g     F .text	00000054 bSyncCtrOneShot
8114c20c g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110c500 g     F .text	0000003c uliSyncReadStatus
8114c428 g     O .bss	00000004 _alt_tick_rate
81137b44 g     F .text	00000294 OSQPend
81128c24 g     F .text	000002e8 _strtoll_r
81157f9c g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8113a714 g     F .text	0000010c OSTimeDly
811110e0 g     F .text	00000720 vPusMebInTaskRunningMode
8110b75c g     F .text	0000003c vSyncIrqFlagClrSync
811263f0 g     F .text	00000150 __lshift
8110eae0 g     F .text	000002f8 vOutAckHandlerTask
81142ab8 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8114c42c g     O .bss	00000004 _alt_nticks
81131818 g     F .text	00000104 read
8113bdf0 g     F .text	000000f0 alt_sys_init
81119b9c g     F .text	0000012c .hidden __floatsisf
8110603c g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112945c g     F .text	000001d8 __ssprint_r
8111bc88 g     F .text	00000068 _open_r
81118ecc g     F .text	00000028 bTestSimucamCriticalHW
8110585c g     F .text	000000ac bFeebGetBuffersStatus
81115b04 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
8114c471 g     O .bss	00000001 OSTaskCtr
811307e0 g       .text	00000000 tx_log_str
81114988 g     F .text	00000050 siPosStr
8112d0f4 g     F .text	000000d0 strncmp
81106378 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113a820 g     F .text	00000164 OSTimeDlyHMSM
811260a8 g     F .text	00000200 __multiply
811409cc g     F .text	00000070 altera_avalon_jtag_uart_close
8110b330 g     F .text	00000058 v_spi_end
81118bec g     F .text	00000040 cGetNextChar
81144f50 g     F .text	000000ec strncpy
8114c67c g     O .bss	00000028 __malloc_current_mallinfo
8114c25e g     O .rwdata	00000002 OSEventMax
8112e0b4 g     F .text	00000078 .hidden __eqsf2
8112691c g     F .text	00000154 __d2b
81138dc4 g     F .text	00000118 OSSemPost
811050c4 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
81118640 g     F .text	00000030 vChangeDefaultRTValue
81104fb8 g     F .text	00000040 vFeebCh8HandleIrq
8114c4ac g     O .bss	00000004 initialized
81114838 g     F .text	00000100 vSendLog
81132c44 g     F .text	000000e4 OSSchedUnlock
8110b388 g     F .text	00000164 RTCC_SPI_R_MAC
8114c23c g     O .rwdata	00000004 alt_log_boot_on_flag
811402b0 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
81128f0c g     F .text	00000254 _strtoul_r
81157fdc g     O .bss	00000010 xFeeQueueTBL5
81144268 g     F .text	000000e4 alt_get_fd
8114c474 g     O .bss	00000004 OSMemFreeList
81132da0 g     F .text	000000b8 OSStatInit
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
811653d8 g     O .bss	00000014 search_data
81108dcc g     F .text	00000134 bSpwcSetLink
811301c4 g     F .text	00000130 alt_busy_sleep
81135760 g     F .text	000000cc OSFlagQuery
8110bea4 g     F .text	00000074 bSyncCtrCh1OutEnable
8114c294 g     O .rwdata	00000002 OSTaskCreateExtEn
811191a0 g     F .text	00000074 _split_codec_status
811228c4 g     F .text	0000005c _close_r
81116724 g     F .text	00000068 vCouldNotSendEthConfUART
8110df8c g     F .text	00000584 vInitialTask
81130f88 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81142fa0 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81144ed4 g     F .text	0000007c memcmp
811330a8 g     F .text	00000028 OS_Dummy
81140380 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81165a40 g       *ABS*	00000000 __alt_stack_base
811403d8 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105108 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111af28 g     F .text	000000d4 _fwrite_r
811430c0 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105218 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81122768 g     F .text	0000015c __swsetup_r
81161e5c g     O .bss	00000180 OSQTbl
81117714 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
8115fab4 g     O .bss	0000001c xConfEth
8112eb64 g     F .text	000008f0 .hidden __divdf3
811186a4 g     F .text	0000003c vChangeSyncSource
811246a0 g     F .text	00000120 __sfp
811653ec g     O .bss	00000054 boot_sector_data
811176ac g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
81109238 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
81126b98 g     F .text	00000078 __copybits
8114a900 g     O .rwdata	00000408 __malloc_av_
811247f4 g     F .text	00000004 __sinit_lock_release
8114c2d0 g     O .bss	00000004 uliInitialState
81109b78 g     F .text	00000080 i2c_stop
811192b8 g     F .text	00000064 Verif_Error
8111931c g     F .text	00000034 toInt
81115f44 g     F .text	0000004c vFailSendPreAckSenderSemaphore
8114c478 g     O .bss	00000004 OSTCBHighRdy
81119dc0 g     F .text	00000720 .hidden __muldf3
8111c364 g     F .text	0000005c __sread
81124b08 g     F .text	0000003c fread
8114c47c g     O .bss	00000004 OSQFreeList
81144158 g     F .text	00000110 alt_find_file
81144014 g     F .text	000000ac alt_dev_llist_insert
81131ff8 g     F .text	00000128 __malloc_lock
8111a930 g     F .text	00000030 _fprintf_r
81131988 g     F .text	000000fc sbrk
81117f48 g     F .text	0000002c vFeeSpwRMAPLoadDefault
811164b4 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
8111c83c g     F .text	000021e0 ___svfprintf_internal_r
81114d78 g     F .text	00000088 vTMPusTestConnection
8114c3a0 g     O .bss	00000004 xMebQ
8113231c g     F .text	00000148 OSEventNameSet
811243dc g     F .text	00000064 _fflush_r
8112c168 g     F .text	000000cc _calloc_r
8114c480 g     O .bss	00000001 OSRdyGrp
8111788c g     F .text	0000004c vFailSendMsgFeeCTRL
8110b8d4 g     F .text	00000044 ucSyncStatusCycleNumber
81106b64 g     F .text	0000008c bRmapGetCodecConfig
8113b314 g     F .text	00000148 OSTmrStart
81104ef8 g     F .text	00000040 vFeebCh5HandleIrq
8111a918 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8114c2d0 g       *ABS*	00000000 __bss_start
8111bb60 g     F .text	00000128 memset
811100a8 g     F .text	0000013c setPreParsedFreePos
8110cbcc g     F .text	00000198 vQCmdFEEinStandBy
81143b1c g     F .text	00000060 alt_msgdma_open
811187fc g     F .text	0000021c pattern_createPattern
81113360 g     F .text	00000180 main
811160c8 g     F .text	00000068 vFailGetMutexReceiverTask
81157fec g     O .bss	00001000 vNFeeControlTask_stk
811061d4 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111855c g     F .text	0000003c vChangeEPValue
81106320 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
8114c424 g     O .bss	00000004 alt_envp
81117924 g     F .text	0000004c vFailFlushQueue
8114c3ec g     O .bss	00000004 __malloc_max_total_mem
811433c0 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
81115ba8 g     F .text	0000005c ucCrc8wInit
81116a5c g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81140318 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f8c g     F .text	000002c8 POWER_Read
81109d30 g     F .text	00000160 i2c_read
8114c3a4 g     O .bss	00000008 SyncTBL5
811226e8 g     F .text	00000018 __swbuf
8114a034 g     O .rodata	00000100 OSUnMapTbl
8112e1e8 g     F .text	000000c8 .hidden __ltsf2
8113f6b4 g     F .text	00000090 alt_up_sd_card_get_attributes
811248d4 g     F .text	00000234 _fread_r
81115f90 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
81109524 g     F .text	0000003c bDisableIsoDrivers
8114c28e g     O .rwdata	00000002 OSSemEn
8113bee0 g     F .text	000000bc Write_Sector_Data
8113fac4 g     F .text	00000628 alt_up_sd_card_write
8114c3ac g     O .bss	00000004 xFeeQ
811353c4 g     F .text	0000039c OSFlagPost
8111c4b0 g     F .text	00000008 __sclose
81116d64 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112c32c g     F .text	00000014 fclose
81133270 g     F .text	00000118 OS_EventTaskWait
81116c2c g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111c5e0 g     F .text	00000240 _strtol_r
8111a5f8 g     F .text	000001a8 .hidden __truncdfsf2
81158fec g     O .bss	00000010 xFeeQueueTBL2
81133f00 g     F .text	000000d4 OS_TaskStatStkChk
81139b2c g     F .text	00000158 OSTaskDelReq
81104910 g     F .text	000000c4 bDpktGetPacketHeader
81105df8 g     F .text	00000040 vRmapCh1HandleIrq
81122b28 g     F .text	00001690 _dtoa_r
811436dc g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111b1fc g     F .text	00000814 _malloc_r
8112d330 g     F .text	00000030 __ascii_wctomb
8113655c g     F .text	000001d0 OSMutexCreate
81116bc4 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
8110de40 g     F .text	0000014c bCheckInAck32
8114c234 g     O .rwdata	00000004 alt_errno
81143208 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81132d28 g     F .text	00000078 OSStart
81108f00 g     F .text	000000e4 bSpwcGetLink
8110aa84 g     F .text	000004e8 POWER_SPI_RW
8112a878 g     F .text	000000dc __submore
81130ee8 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81131f90 g     F .text	00000068 __env_unlock
811171a4 g     F .text	00000068 vCoudlNotCreateNFee1Task
8112544c g     F .text	000000cc _fwalk
81139fe0 g     F .text	000001dc OSTaskResume
811361ec g     F .text	000000f0 OSMemQuery
8114c2a0 g     O .rwdata	00000002 OSTaskStatEn
81165a40 g       *ABS*	00000000 __alt_stack_limit
8114c2e8 g     O .bss	00000004 ECommSpwCh
81118748 g     F .text	0000003c vChangeAutoResetSync
8112599c g     F .text	00000064 _mbtowc_r
8110d85c g     F .text	00000350 vInAckHandlerTaskV2
8114c27a g     O .rwdata	00000002 OSMemMax
811380bc g     F .text	00000178 OSQPostFront
8111be14 g     F .text	000000d0 putc
8112df00 g     F .text	00000084 .hidden __divsi3
8114c481 g     O .bss	00000006 OSRdyTbl
8114c254 g     O .rwdata	00000002 OSDebugEn
8114af98 g     O .rwdata	0000002a alt_log_msg_cache
81124b44 g     F .text	0000012c _malloc_trim_r
8110891c g     F .text	000001a4 bRmapInitCh
8114c3e0 g     O .bss	00000008 xSdHandle
81119798 g     F .text	00000404 .hidden __mulsf3
8114c26c g     O .rwdata	00000002 OSFlagNodeSize
8114c2d4 g     O .bss	00000004 pnt_memory
811187b4 g     F .text	00000048 vSyncReset
8110b998 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8114c4b8 g     O .bss	00000004 status_register
8114c2b4 g     O .rwdata	00000002 OSTmrCfgMax
8110c32c g     F .text	00000074 bSyncIrqFlagClrError
811167f4 g     F .text	00000068 vFailSetPreAckSenderBuffer
811273bc g     F .text	000000dc strcmp
8114c4c0 g     O .bss	00000004 command_register
81137648 g     F .text	000001b4 OSQCreate
81139c84 g     F .text	000001a0 OSTaskNameGet
81158ffc g     O .bss	00001000 vFeeTask4_stk
81159ffc g     O .bss	00000018 xReceivedACK
81138234 g     F .text	00000214 OSQPostOpt
81132e58 g     F .text	00000228 OSTimeTick
8114c29c g     O .rwdata	00000002 OSTaskMax
81138714 g     F .text	000000e0 OSSemCreate
8114c2c0 g     O .rwdata	00000002 OSTmrWheelSize
81116ff4 g     F .text	00000068 vFailCreateScheduleQueue
81118f4c g     F .text	00000058 _reg_read
811371f4 g     F .text	00000174 OSMutexQuery
8112f454 g     F .text	00000088 .hidden __nedf2
8114c296 g     O .rwdata	00000002 OSTaskDelEn
81118524 g     F .text	00000038 vLoadDefaultEPValue
8115a014 g     O .bss	00001000 vFeeTask1_stk
8110c15c g     F .text	00000074 bSyncCtrCh7OutEnable
81138edc g     F .text	00000118 OSSemQuery
811377fc g     F .text	00000288 OSQDel
81137dd8 g     F .text	00000174 OSQPendAbort
8114c3b0 g     O .bss	00000004 xMutexPreParsed
8113bdb0 g     F .text	00000040 alt_irq_init
8113191c g     F .text	0000006c alt_release_fd
8113c0d0 g     F .text	000000bc get_cluster_flag
8110c3a0 g     F .text	00000074 bSyncIrqFlagClrBlank
81143e14 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8114af64 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111c2f0 g     F .text	00000074 sprintf
8114971c g     O .rodata	00000100 .hidden __clz_tab
8113c6a4 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
81116130 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8114c3f8 g     O .bss	00000004 _PathLocale
8110c46c g     F .text	00000058 bSyncIrqFlagBlank
8110a93c g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113b45c g     F .text	000001e8 OSTmrStop
81114938 g     F .text	00000050 usiGetIdCMD
81128b1c g     F .text	00000108 strtof
81104e78 g     F .text	00000040 vFeebCh3HandleIrq
8112e12c g     F .text	000000bc .hidden __gesf2
8111c4b8 g     F .text	0000004c strcspn
81122700 g     F .text	00000068 _write_r
8110afd8 g     F .text	00000074 vRstcReleaseDeviceReset
81116978 g     F .text	0000004c vFailInAckHandlerTaskCreate
81132bb0 g     F .text	00000094 OSSchedLock
81117274 g     F .text	00000068 vCoudlNotCreateNFee3Task
81125730 g     F .text	00000018 setlocale
81143168 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81161fdc g     O .bss	00000800 OSTmrTaskStk
8111c214 g     F .text	00000044 scanf
811174e4 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
811347b8 g     F .text	00000110 OSFlagCreate
8113c938 g     F .text	00000688 Check_for_DOS_FAT
8113e7e4 g     F .text	000002d0 create_file
811273b4 g     F .text	00000008 nanf
8114c208 g     O .rwdata	00000004 _impure_ptr
8114c4bc g     O .bss	00000004 CSD_register_w0
8114c41c g     O .bss	00000004 alt_argc
8111644c g     F .text	00000068 vFailGetCountSemaphorexBuffer128
811241b8 g     F .text	00000224 __sflush_r
811257bc g     F .text	000000b4 _mbrtowc_r
811091a8 g     F .text	00000090 bSpwcGetTimecode
8112571c g     F .text	00000008 __locale_cjk_lang
81103394 g     F .text	0000078c sense_log
8114c2e0 g     O .bss	00000004 ESdmaBufferSide
8114c266 g     O .rwdata	00000002 OSEventMultiEn
8111aa3c g     F .text	00000004 _fseek_r
8115b014 g     O .bss	00001800 vParserCommTask_stk
81115cdc g     F .text	00000070 printErrorTask
81118598 g     F .text	00000030 vChangeDefaultEPValue
81112980 g     F .text	000002c8 vCheckRetransmission32
8113ac2c g     F .text	000001c4 OSTmrCreate
81111aa4 g     F .text	000007dc vStackMonitor
8111bfdc g     F .text	000001dc __srefill_r
81109560 g     F .text	0000003c bEnableLvdsBoard
8114c3b4 g     O .bss	00000004 xMutexBuffer32
81105e38 g     F .text	00000040 vRmapCh2HandleIrq
811348c8 g     F .text	00000250 OSFlagDel
8114c488 g     O .bss	00000004 OSEventFreeList
811095d8 g     F .text	000000c0 bSetPreEmphasys
8110ca5c g     F .text	00000170 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81125950 g     F .text	0000004c __ascii_mbtowc
8110bc68 g     F .text	00000078 bSyncCtrExtnIrq
811267a4 g     F .text	00000064 __ulp
81118128 g     F .text	000000ec vNFeeControlInit
81134d9c g     F .text	000005c0 OSFlagPend
8114c2b2 g     O .rwdata	00000002 OSTmrEn
81124810 g     F .text	00000018 __fp_unlock_all
8111a9d8 g     F .text	00000064 fputc
81114080 g     F .text	000002f8 bSendUART32v2
81110360 g     F .text	0000019c setPreAckReceiverFreePos
8110bc28 g     F .text	00000040 bSyncErrInj
8114c220 g     O .rwdata	00000008 alt_fs_list
8115c814 g     O .bss	00001000 vSimMebTask_stk
8111747c g     F .text	00000068 vCoudlNotCreateMebTask
8113d180 g     F .text	00000274 check_file_name_for_FAT16_compliance
8115d814 g     O .bss	00001000 vFeeTask3_stk
8113af30 g     F .text	00000140 OSTmrNameGet
8114c7a4 g     O .bss	00000400 xSZData
8110cd64 g     F .text	00000190 vQCmdFEEinFullPattern
81133ce0 g     F .text	0000007c OS_StrCopy
8114c4c8 g     O .bss	00000004 buffer_memory
81116654 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
811183d8 g     F .text	00000098 vLogWriteNUC
8114c27c g     O .rwdata	00000002 OSMemNameSize
81103b20 g     F .text	000000b0 bSdmaInitM1Dma
8110c2b8 g     F .text	00000074 bSyncIrqEnableBlank
81144d74 g     F .text	00000028 OSInitHookEnd
81117c08 g     F .text	00000340 vUpdateMemMapFEE
811168c4 g     F .text	00000068 vFailSetPreAckReceiverBuffer
81105480 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
8114c2a8 g     O .rwdata	00000002 OSTCBPrioTblMax
81125748 g     F .text	0000000c localeconv
81117414 g     F .text	00000068 vCoudlNotCreateDataControllerTask
8114c3b8 g     O .bss	00000004 xTimerRetransmission
8110fe58 g     F .text	00000250 vReceiverUartTask
8114c418 g     O .bss	00000004 alt_log_sys_clk_count
8114c2a4 g     O .rwdata	00000002 OSTaskStatStkChkEn
81131138 g     F .text	00000140 alt_log_write
8115e814 g     O .bss	00001000 vFeeTask2_stk
8114c3bc g     O .bss	00000004 xMutexBuffer128
81104df8 g     F .text	00000040 vFeebCh1HandleIrq
81118e64 g     F .text	00000038 bStartSync
81104f78 g     F .text	00000040 vFeebCh7HandleIrq
81118e9c g     F .text	00000030 bStopSync
8114434c g     F .text	00000058 alt_ic_isr_register
8114c278 g     O .rwdata	00000002 OSMemEn
81105e78 g     F .text	00000040 vRmapCh3HandleIrq
8114c1f4 g     O .rwdata	00000004 alt_stack_limit_value
8111affc g     F .text	0000003c fwrite
8114c4cc g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8114c282 g     O .rwdata	00000002 OSMutexEn
8111777c g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8114c2d0 g       *ABS*	00000000 _edata
811411cc g     F .text	00000068 altera_avalon_uart_read_fd
81118288 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81165a40 g       *ABS*	00000000 _end
81165440 g     O .bss	00000500 active_files
8114c48c g     O .bss	00000001 OSIntNesting
811161e4 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
81118024 g     F .text	0000002c cFeeRMAPDump
8114c3c0 g     O .bss	00000004 xSemCountBuffer32
8112c340 g     F .text	0000016c __fputwc
8114c33c g     O .bss	00000004 xQMaskFeeCtrl
81117f74 g     F .text	0000002c vFeeSpwRMAPChangeConfig
811224c0 g     F .text	00000070 vfscanf
8113eab4 g     F .text	00000150 copy_file_record_name_to_string
81140a3c g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113a984 g     F .text	000001dc OSTimeDlyResume
8113cfc0 g     F .text	000000f4 Look_for_FAT16
81134c48 g     F .text	00000154 OSFlagNameSet
8114c3c4 g     O .bss	00000004 xMutexBuffer64
81106d50 g     F .text	00000160 bRmapGetCodecError
8113a1bc g     F .text	000001c8 OSTaskStkChk
81144434 g     F .text	00000094 alt_ic_irq_disable
81103c80 g     F .text	0000042c bSdmaDmaM1Transfer
8114c27e g     O .rwdata	00000002 OSMemSize
81116314 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
8111c3c8 g     F .text	00000084 __swrite
8114c210 g     O .rwdata	00000004 __malloc_trim_threshold
81125710 g     F .text	0000000c __locale_msgcharset
8115f814 g     O .bss	00000010 xFeeQueueTBL1
8114c490 g     O .bss	00000004 OSTCBCur
81116c94 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110aa40 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81144e94 g     F .text	00000040 exit
81136fd4 g     F .text	00000220 OSMutexPost
8110c414 g     F .text	00000058 bSyncIrqFlagError
8113eee0 g     F .text	000003c0 alt_up_sd_card_find_next
8114c280 g     O .rwdata	00000002 OSMemTblSize
81125518 g     F .text	000000cc _fwalk_reent
81143560 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
81119cc8 g     F .text	000000f8 .hidden __floatunsisf
811265a0 g     F .text	00000204 __mdiff
8111713c g     F .text	00000068 vCoudlNotCreateNFee0Task
811054d8 g     F .text	0000017c vFeebInitIrq
811045b8 g     F .text	0000022c bDpktSetPacketConfig
8111627c g     F .text	0000004c vFailSenderCreate
8112df84 g     F .text	00000074 .hidden __modsi3
81117344 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110bb74 g     F .text	0000003c uliSyncGetPer
81105f38 g     F .text	00000040 vRmapCh6HandleIrq
8114c3c8 g     O .bss	00000004 xMutexSenderACK
81116af4 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8114c200 g     O .rwdata	00000004 __ctype_ptr__
8111685c g     F .text	00000068 vFailSetPreParsedBuffer
8113bff0 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
811247ec g     F .text	00000004 __sfp_lock_release
81105728 g     F .text	000000ac bFeebGetIrqControl
81116dcc g     F .text	00000068 vCouldNotSendTurnOff
811329f8 g     F .text	00000064 OSInit
81109f10 g     F .text	00000078 bSetPainelLeds
81142ca8 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8114c494 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81106eb0 g     F .text	000002ec bRmapSetMemConfigArea
8113a570 g     F .text	0000012c OSTaskQuery
8110c244 g     F .text	00000074 bSyncIrqEnableError
8114c3cc g     O .bss	00000004 xMutexPus
811385ac g     F .text	000000b0 OS_QInit
811272e4 g     F .text	000000d0 __sccl
8111a804 g     F .text	0000000c atoi
8110c670 g     F .text	000003ec vFeeTask
81133d5c g     F .text	0000005c OS_StrLen
81105270 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
81115c04 g     F .text	000000d8 vDataControllerInit
81135ff0 g     F .text	0000011c OSMemNameSet
8114981c g     O .rodata	00000101 _ctype_
8110bb38 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
811163e4 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114c29a g     O .rwdata	00000002 OSTaskProfileEn
81117970 g     F .text	00000070 vEvtChangeMebMode
81142b78 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8114c3d0 g     O .bss	00000004 xTxUARTMutex
8114c498 g     O .bss	00000004 OSTime
8114c218 g     O .rwdata	00000004 __mbtowc
811417ec g     F .text	0000005c altera_avalon_uart_close
8114c49c g     O .bss	00000004 OSTmrSem
811627dc g     O .bss	00001000 OSTaskIdleStk
8111a81c g     F .text	000000fc _fopen_r
8114c350 g     O .bss	00000004 pdata
811451c4 g     F .text	000000bc _exit
81143e9c g     F .text	00000134 alt_alarm_start
81134b18 g     F .text	00000130 OSFlagNameGet
8113ab60 g     F .text	00000064 OSTimeGet
8114c2e4 g     O .bss	00000004 ESdmaChBufferId
8113f744 g     F .text	00000380 alt_up_sd_card_read
81106108 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111b038 g     F .text	000001c4 __smakebuf_r
8114c3d4 g     O .bss	00000001 SemCount64
81113d88 g     F .text	000002f8 bSendUART64v2
81105320 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8114c2c8 g     O .rwdata	00000008 alt_msgdma_list
8111c504 g     F .text	00000098 strlen
8110b27c g     F .text	000000b4 uc_spi_get_byte
8110614c g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
811177e4 g     F .text	00000054 vFailSendMsgAccessDMA
81144ca4 g     F .text	00000028 OSTaskSwHook
81131678 g     F .text	0000015c open
81108150 g     F .text	000007cc bRmapGetRmapMemHKArea
811637dc g     O .bss	00000d00 OSEventTbl
81117fa0 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8112f4dc g     F .text	000000dc .hidden __gedf2
8115f824 g     O .bss	00000020 xSenderACK
81144998 g     F .text	00000044 alt_putchar
811644dc g     O .bss	00000e58 OSTCBTbl
8112c658 g     F .text	00000838 __gethex
81138ff4 g     F .text	00000108 OSSemSet
81112280 g     F .text	0000006c vTimeoutCheckerTaskv2
81118050 g     F .text	00000038 cFeeRMAPEchoingEnable
8114c21c g     O .rwdata	00000004 __wctomb
8111304c g     F .text	00000314 vVariablesInitialization
8112ac0c g     F .text	00000018 __sprint_r
811057d4 g     F .text	00000088 bFeebGetIrqFlags
8114c2dc g     O .bss	00000004 pxDmaM2Dev
81115dac g     F .text	0000004c vFailCreateSemaphoreResources
8114c238 g     O .rwdata	00000004 alt_priority_mask
8110959c g     F .text	0000003c bDisableLvdsBoard
811387f4 g     F .text	00000248 OSSemDel
8114c4a0 g     O .bss	00000004 OSFlagFreeList
8110b1b8 g     F .text	000000c4 v_spi_send_byte
8110b4ec g     F .text	000000d0 bSSDisplayConfig
811443a4 g     F .text	00000090 alt_ic_irq_enable
8114c260 g     O .rwdata	00000002 OSEventNameSize
81120c1c g     F .text	0000001c __vfprintf_internal
8114c4a4 g     O .bss	00000001 OSStatRdy
8110bf18 g     F .text	00000074 bSyncCtrCh2OutEnable
81165334 g     O .bss	000000a4 OSTCBPrioTbl
8114188c g     F .text	00000270 altera_avalon_uart_read
8112d360 g     F .text	00000064 _wctomb_r
81131ec4 g     F .text	000000cc __env_lock
8114c2a6 g     O .rwdata	00000002 OSTaskSwHookEn
81105080 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
8112f6ac g     F .text	00000904 .hidden __subdf3
8115f844 g     O .bss	00000260 xPreParsed
8110bbb0 g     F .text	0000003c uliSyncGetOst
8114c3d5 g     O .bss	00000001 SemCount128
81105fb8 g     F .text	00000040 vRmapCh8HandleIrq
8110514c g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81114378 g     F .text	00000290 vSendEthConf
811044e0 g     F .text	000000d8 bCommInitCh
81125fb4 g     F .text	000000b0 __lo0bits
81120cfc g     F .text	000017c4 __svfscanf_r
8114c244 g     O .rwdata	00000008 alt_alarm_list
8112a954 g     F .text	0000019c _ungetc_r
8114c26e g     O .rwdata	00000002 OSFlagWidth
81105ff8 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
8112d268 g     F .text	000000c8 wcrtomb
811049d4 g     F .text	00000148 bDpktSetPixelDelay
811139a0 g     F .text	00000068 vCCDLoadDefaultValues
81130338 g     F .text	000000d8 close
8110bbec g     F .text	0000003c uliSyncGetGeneral
81117a50 g     F .text	00000070 vEvtChangeDataControllerMode
8114c434 g     O .bss	00000004 alt_envsem
81130868 g     F .text	00000068 alt_log_repchar
8114c4a8 g     O .bss	00000004 OSIdleCtrRun
81133080 g     F .text	00000028 OSVersion
8114c2b8 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113a69c g     F .text	00000078 OS_TaskStkClr
81118b70 g     F .text	0000003c siOpenFile
8110c5f0 g     F .text	00000080 vDataControlTask
8114c292 g     O .rwdata	00000002 OSTaskCreateEn
81106270 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
811066b8 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81105a38 g     F .text	00000088 bFeebStartCh
81114608 g     F .text	00000118 vSendTurnOff
81115eac g     F .text	0000004c vFailSendPreParsedSemaphore
8113d4b4 g     F .text	000002a4 match_file_record_to_name_ext
811336a8 g     F .text	00000070 OS_EventWaitListInit
8112c4d0 g     F .text	00000088 fputwc
8115faa4 g     O .bss	00000010 xFeeQueueTBL0
81115e44 g     F .text	00000068 vFailSendxSemCommInit
81144d9c g     F .text	00000028 OSTaskIdleHook
81114720 g     F .text	00000118 vSendReset
811247f0 g     F .text	00000004 __sinit_lock_acquire
81125d18 g     F .text	00000128 __multadd
8114c3d8 g     O .bss	00000008 SyncTBL1
81105190 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110b83c g     F .text	0000004c ucSyncStatusState
8113a384 g     F .text	000001ec OSTaskSuspend
81125cf0 g     F .text	00000028 _Bfree
8110bafc g     F .text	0000003c uliSyncGetMbt
81133db8 g     F .text	00000064 OS_TaskIdle
8114c2be g     O .rwdata	00000002 OSTmrTblSize
81138448 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1132a5c0 	call	81132a5c <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	10965004 	addi	r2,r2,22848
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	10965004 	addi	r2,r2,22848
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1132ab00 	call	81132ab0 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0bc17 	ldw	r2,-32016(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0bc17 	ldw	r2,-32016(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21308f04 	addi	r4,r4,-15812
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	212be604 	addi	r4,r4,-20584
81100274:	11307e00 	call	811307e0 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21308f04 	addi	r4,r4,-15812
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	212bd904 	addi	r4,r4,-20636
81100290:	11307e00 	call	811307e0 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6907d14 	ori	gp,gp,16884
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21308f04 	addi	r4,r4,-15812
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	212bca04 	addi	r4,r4,-20696
811002bc:	11307e00 	call	811307e0 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10b0b414 	ori	r2,r2,49872

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18d69014 	ori	r3,r3,23104

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21308f04 	addi	r4,r4,-15812
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	212bd104 	addi	r4,r4,-20668
811002fc:	11307e00 	call	811307e0 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	113140c0 	call	8113140c <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18f1a904 	addi	r3,r3,-14684
81100330:	00a04534 	movhi	r2,33044
81100334:	1094a004 	addi	r2,r2,21120
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05f17 	ldw	r2,-32388(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	2971a904 	addi	r5,r5,-14684
8110035c:	1009883a 	mov	r4,r2
81100360:	111a9600 	call	8111a960 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18f1a904 	addi	r3,r3,-14684
811003cc:	00a04534 	movhi	r2,33044
811003d0:	1094a904 	addi	r2,r2,21156
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a05f17 	ldw	r2,-32388(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	2971a904 	addi	r5,r5,-14684
811003f8:	1009883a 	mov	r4,r2
811003fc:	111a9600 	call	8111a960 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18f1a904 	addi	r3,r3,-14684
81100410:	00a04534 	movhi	r2,33044
81100414:	1094b504 	addi	r2,r2,21204
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a05f17 	ldw	r2,-32388(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	2971a904 	addi	r5,r5,-14684
8110043c:	1009883a 	mov	r4,r2
81100440:	111a9600 	call	8111a960 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1131c380 	call	81131c38 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110987c0 	call	8110987c <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604534 	movhi	r5,33044
811004b0:	2954bb04 	addi	r5,r5,21228
811004b4:	01204574 	movhi	r4,33045
811004b8:	2131a904 	addi	r4,r4,-14684
811004bc:	111c2f00 	call	8111c2f0 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a05f17 	ldw	r2,-32388(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	2971a904 	addi	r5,r5,-14684
811004cc:	1009883a 	mov	r4,r2
811004d0:	111a9600 	call	8111a960 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18f1a904 	addi	r3,r3,-14684
811004e0:	00a04534 	movhi	r2,33044
811004e4:	1094c004 	addi	r2,r2,21248
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	111ba100 	call	8111ba10 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a05f17 	ldw	r2,-32388(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	2971a904 	addi	r5,r5,-14684
8110050c:	1009883a 	mov	r4,r2
81100510:	111a9600 	call	8111a960 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18f1a904 	addi	r3,r3,-14684
81100544:	00a04534 	movhi	r2,33044
81100548:	1094c604 	addi	r2,r2,21272
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a05f17 	ldw	r2,-32388(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	2971a904 	addi	r5,r5,-14684
81100570:	1009883a 	mov	r4,r2
81100574:	111a9600 	call	8111a960 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18f1a904 	addi	r3,r3,-14684
81100584:	00a04534 	movhi	r2,33044
81100588:	1094cf04 	addi	r2,r2,21308
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a05f17 	ldw	r2,-32388(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	2971a904 	addi	r5,r5,-14684
811005b0:	1009883a 	mov	r4,r2
811005b4:	111a9600 	call	8111a960 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18f1a904 	addi	r3,r3,-14684
811005c0:	00a04534 	movhi	r2,33044
811005c4:	1094d704 	addi	r2,r2,21340
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a05f17 	ldw	r2,-32388(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	2971a904 	addi	r5,r5,-14684
811005ec:	1009883a 	mov	r4,r2
811005f0:	111a9600 	call	8111a960 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1131c380 	call	81131c38 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110979c0 	call	8110979c <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18f1a904 	addi	r3,r3,-14684
81100650:	00a04534 	movhi	r2,33044
81100654:	1094dd04 	addi	r2,r2,21364
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a05f17 	ldw	r2,-32388(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	2971a904 	addi	r5,r5,-14684
8110067c:	1009883a 	mov	r4,r2
81100680:	111a9600 	call	8111a960 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110987c0 	call	8110987c <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18f1a904 	addi	r3,r3,-14684
811006cc:	00a04534 	movhi	r2,33044
811006d0:	1094e304 	addi	r2,r2,21388
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	111ba100 	call	8111ba10 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a05f17 	ldw	r2,-32388(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	2971a904 	addi	r5,r5,-14684
811006f8:	1009883a 	mov	r4,r2
811006fc:	111a9600 	call	8111a960 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604534 	movhi	r5,33044
81100730:	2954ec04 	addi	r5,r5,21424
81100734:	01204574 	movhi	r4,33045
81100738:	2131a904 	addi	r4,r4,-14684
8110073c:	111c2f00 	call	8111c2f0 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a05f17 	ldw	r2,-32388(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	2971a904 	addi	r5,r5,-14684
8110074c:	1009883a 	mov	r4,r2
81100750:	111a9600 	call	8111a960 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18f1a904 	addi	r3,r3,-14684
81100764:	00a04534 	movhi	r2,33044
81100768:	1094fb04 	addi	r2,r2,21484
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a05f17 	ldw	r2,-32388(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	2971a904 	addi	r5,r5,-14684
81100790:	1009883a 	mov	r4,r2
81100794:	111a9600 	call	8111a960 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18f1a904 	addi	r3,r3,-14684
811007a4:	00a04534 	movhi	r2,33044
811007a8:	10950404 	addi	r2,r2,21520
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a05f17 	ldw	r2,-32388(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	2971a904 	addi	r5,r5,-14684
811007d0:	1009883a 	mov	r4,r2
811007d4:	111a9600 	call	8111a960 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10b1a904 	addi	r2,r2,-14684
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a05f17 	ldw	r2,-32388(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	2971a904 	addi	r5,r5,-14684
811007f8:	1009883a 	mov	r4,r2
811007fc:	111a9600 	call	8111a960 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18f1a904 	addi	r3,r3,-14684
81100840:	00a04534 	movhi	r2,33044
81100844:	10950c04 	addi	r2,r2,21552
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a05f17 	ldw	r2,-32388(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	2971a904 	addi	r5,r5,-14684
8110086c:	1009883a 	mov	r4,r2
81100870:	111a9600 	call	8111a960 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18f1a904 	addi	r3,r3,-14684
811008dc:	00a04534 	movhi	r2,33044
811008e0:	10951504 	addi	r2,r2,21588
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a05f17 	ldw	r2,-32388(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	2971a904 	addi	r5,r5,-14684
81100908:	1009883a 	mov	r4,r2
8110090c:	111a9600 	call	8111a960 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	11099840 	call	81109984 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604534 	movhi	r5,33044
81100984:	29552104 	addi	r5,r5,21636
81100988:	01204574 	movhi	r4,33045
8110098c:	2131a904 	addi	r4,r4,-14684
81100990:	111c2f00 	call	8111c2f0 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a05f17 	ldw	r2,-32388(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	2971a904 	addi	r5,r5,-14684
811009a0:	1009883a 	mov	r4,r2
811009a4:	111a9600 	call	8111a960 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18f1a904 	addi	r3,r3,-14684
811009c0:	00a04534 	movhi	r2,33044
811009c4:	10952d04 	addi	r2,r2,21684
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	111ba100 	call	8111ba10 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a05f17 	ldw	r2,-32388(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	2971a904 	addi	r5,r5,-14684
811009ec:	1009883a 	mov	r4,r2
811009f0:	111a9600 	call	8111a960 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18f1a904 	addi	r3,r3,-14684
81100a0c:	00a04534 	movhi	r2,33044
81100a10:	10953904 	addi	r2,r2,21732
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a05f17 	ldw	r2,-32388(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	2971a904 	addi	r5,r5,-14684
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111a9600 	call	8111a960 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18f1a904 	addi	r3,r3,-14684
81100a58:	00a04534 	movhi	r2,33044
81100a5c:	10954104 	addi	r2,r2,21764
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	111ba100 	call	8111ba10 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a05f17 	ldw	r2,-32388(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	2971a904 	addi	r5,r5,-14684
81100a84:	1009883a 	mov	r4,r2
81100a88:	111a9600 	call	8111a960 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18f1a904 	addi	r3,r3,-14684
81100aa4:	00a04534 	movhi	r2,33044
81100aa8:	10954b04 	addi	r2,r2,21804
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	111ba100 	call	8111ba10 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a05f17 	ldw	r2,-32388(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	2971a904 	addi	r5,r5,-14684
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111a9600 	call	8111a960 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18f1a904 	addi	r3,r3,-14684
81100af0:	00a04534 	movhi	r2,33044
81100af4:	10955604 	addi	r2,r2,21848
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	111ba100 	call	8111ba10 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a05f17 	ldw	r2,-32388(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	2971a904 	addi	r5,r5,-14684
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111a9600 	call	8111a960 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18f1a904 	addi	r3,r3,-14684
81100b3c:	00a04534 	movhi	r2,33044
81100b40:	10956204 	addi	r2,r2,21896
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a05f17 	ldw	r2,-32388(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	2971a904 	addi	r5,r5,-14684
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111a9600 	call	8111a960 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18f1a904 	addi	r3,r3,-14684
81100b88:	00a04534 	movhi	r2,33044
81100b8c:	10956804 	addi	r2,r2,21920
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a05f17 	ldw	r2,-32388(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	2971a904 	addi	r5,r5,-14684
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111a9600 	call	8111a960 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18f1a904 	addi	r3,r3,-14684
81100bd4:	00a04534 	movhi	r2,33044
81100bd8:	10957004 	addi	r2,r2,21952
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	111ba100 	call	8111ba10 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a05f17 	ldw	r2,-32388(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	2971a904 	addi	r5,r5,-14684
81100c00:	1009883a 	mov	r4,r2
81100c04:	111a9600 	call	8111a960 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18f1a904 	addi	r3,r3,-14684
81100c20:	00a04534 	movhi	r2,33044
81100c24:	10957d04 	addi	r2,r2,22004
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a05f17 	ldw	r2,-32388(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	2971a904 	addi	r5,r5,-14684
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111a9600 	call	8111a960 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18f1a904 	addi	r3,r3,-14684
81100c6c:	00a04534 	movhi	r2,33044
81100c70:	10958304 	addi	r2,r2,22028
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a05f17 	ldw	r2,-32388(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	2971a904 	addi	r5,r5,-14684
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111a9600 	call	8111a960 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18f1a904 	addi	r3,r3,-14684
81100cb8:	00a04534 	movhi	r2,33044
81100cbc:	10958804 	addi	r2,r2,22048
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a05f17 	ldw	r2,-32388(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	2971a904 	addi	r5,r5,-14684
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111a9600 	call	8111a960 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18f1a904 	addi	r3,r3,-14684
81100d04:	00a04534 	movhi	r2,33044
81100d08:	10958f04 	addi	r2,r2,22076
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	111ba100 	call	8111ba10 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a05f17 	ldw	r2,-32388(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	2971a904 	addi	r5,r5,-14684
81100d30:	1009883a 	mov	r4,r2
81100d34:	111a9600 	call	8111a960 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18f1a904 	addi	r3,r3,-14684
81100d50:	00a04534 	movhi	r2,33044
81100d54:	10959d04 	addi	r2,r2,22132
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	111ba100 	call	8111ba10 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a05f17 	ldw	r2,-32388(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	2971a904 	addi	r5,r5,-14684
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111a9600 	call	8111a960 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18f1a904 	addi	r3,r3,-14684
81100d9c:	00a04534 	movhi	r2,33044
81100da0:	1095af04 	addi	r2,r2,22204
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a05f17 	ldw	r2,-32388(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	2971a904 	addi	r5,r5,-14684
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111a9600 	call	8111a960 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18f1a904 	addi	r3,r3,-14684
81100de8:	00a04534 	movhi	r2,33044
81100dec:	1095b704 	addi	r2,r2,22236
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a05f17 	ldw	r2,-32388(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	2971a904 	addi	r5,r5,-14684
81100e14:	1009883a 	mov	r4,r2
81100e18:	111a9600 	call	8111a960 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18f1a904 	addi	r3,r3,-14684
81100e34:	00a04534 	movhi	r2,33044
81100e38:	1095c104 	addi	r2,r2,22276
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a05f17 	ldw	r2,-32388(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	2971a904 	addi	r5,r5,-14684
81100e60:	1009883a 	mov	r4,r2
81100e64:	111a9600 	call	8111a960 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18f1a904 	addi	r3,r3,-14684
81100e80:	00a04534 	movhi	r2,33044
81100e84:	1095ce04 	addi	r2,r2,22328
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a05f17 	ldw	r2,-32388(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	2971a904 	addi	r5,r5,-14684
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111a9600 	call	8111a960 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18f1a904 	addi	r3,r3,-14684
81100ecc:	00a04534 	movhi	r2,33044
81100ed0:	1095d804 	addi	r2,r2,22368
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a05f17 	ldw	r2,-32388(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	2971a904 	addi	r5,r5,-14684
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111a9600 	call	8111a960 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18f1a904 	addi	r3,r3,-14684
81100f18:	00a04534 	movhi	r2,33044
81100f1c:	1095e304 	addi	r2,r2,22412
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	111ba100 	call	8111ba10 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a05f17 	ldw	r2,-32388(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	2971a904 	addi	r5,r5,-14684
81100f44:	1009883a 	mov	r4,r2
81100f48:	111a9600 	call	8111a960 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18f1a904 	addi	r3,r3,-14684
81100f64:	00a04534 	movhi	r2,33044
81100f68:	1095f404 	addi	r2,r2,22480
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a05f17 	ldw	r2,-32388(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	2971a904 	addi	r5,r5,-14684
81100f90:	1009883a 	mov	r4,r2
81100f94:	111a9600 	call	8111a960 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18f1a904 	addi	r3,r3,-14684
81100fb0:	00a04534 	movhi	r2,33044
81100fb4:	1095ff04 	addi	r2,r2,22524
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	111ba100 	call	8111ba10 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a05f17 	ldw	r2,-32388(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	2971a904 	addi	r5,r5,-14684
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111a9600 	call	8111a960 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18f1a904 	addi	r3,r3,-14684
81100ffc:	00a04534 	movhi	r2,33044
81101000:	10960c04 	addi	r2,r2,22576
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	111ba100 	call	8111ba10 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a05f17 	ldw	r2,-32388(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	2971a904 	addi	r5,r5,-14684
81101028:	1009883a 	mov	r4,r2
8110102c:	111a9600 	call	8111a960 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18f1a904 	addi	r3,r3,-14684
81101048:	00a04534 	movhi	r2,33044
8110104c:	10961a04 	addi	r2,r2,22632
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a05f17 	ldw	r2,-32388(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	2971a904 	addi	r5,r5,-14684
81101074:	1009883a 	mov	r4,r2
81101078:	111a9600 	call	8111a960 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18f1a904 	addi	r3,r3,-14684
81101094:	00a04534 	movhi	r2,33044
81101098:	10962704 	addi	r2,r2,22684
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	111ba100 	call	8111ba10 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a05f17 	ldw	r2,-32388(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	2971a904 	addi	r5,r5,-14684
811010c0:	1009883a 	mov	r4,r2
811010c4:	111a9600 	call	8111a960 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18f1a904 	addi	r3,r3,-14684
811010e0:	00a04534 	movhi	r2,33044
811010e4:	10963404 	addi	r2,r2,22736
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a05f17 	ldw	r2,-32388(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	2971a904 	addi	r5,r5,-14684
8110110c:	1009883a 	mov	r4,r2
81101110:	111a9600 	call	8111a960 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10b1a904 	addi	r2,r2,-14684
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a05f17 	ldw	r2,-32388(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	2971a904 	addi	r5,r5,-14684
81101194:	1009883a 	mov	r4,r2
81101198:	111a9600 	call	8111a960 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18f1a904 	addi	r3,r3,-14684
811011b4:	00a04534 	movhi	r2,33044
811011b8:	10963804 	addi	r2,r2,22752
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a05f17 	ldw	r2,-32388(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	2971a904 	addi	r5,r5,-14684
811011e0:	1009883a 	mov	r4,r2
811011e4:	111a9600 	call	8111a960 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18f1a904 	addi	r3,r3,-14684
81101200:	00a04534 	movhi	r2,33044
81101204:	10964004 	addi	r2,r2,22784
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	111ba100 	call	8111ba10 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a05f17 	ldw	r2,-32388(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	2971a904 	addi	r5,r5,-14684
8110122c:	1009883a 	mov	r4,r2
81101230:	111a9600 	call	8111a960 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18f1a904 	addi	r3,r3,-14684
8110124c:	00a04534 	movhi	r2,33044
81101250:	10964e04 	addi	r2,r2,22840
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a05f17 	ldw	r2,-32388(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	2971a904 	addi	r5,r5,-14684
81101278:	1009883a 	mov	r4,r2
8110127c:	111a9600 	call	8111a960 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18f1a904 	addi	r3,r3,-14684
81101298:	00a04534 	movhi	r2,33044
8110129c:	10965604 	addi	r2,r2,22872
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a05f17 	ldw	r2,-32388(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	2971a904 	addi	r5,r5,-14684
811012c4:	1009883a 	mov	r4,r2
811012c8:	111a9600 	call	8111a960 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18f1a904 	addi	r3,r3,-14684
811012e4:	00a04534 	movhi	r2,33044
811012e8:	10965e04 	addi	r2,r2,22904
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	111ba100 	call	8111ba10 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a05f17 	ldw	r2,-32388(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	2971a904 	addi	r5,r5,-14684
81101310:	1009883a 	mov	r4,r2
81101314:	111a9600 	call	8111a960 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18f1a904 	addi	r3,r3,-14684
81101330:	00a04534 	movhi	r2,33044
81101334:	10966804 	addi	r2,r2,22944
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a05f17 	ldw	r2,-32388(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	2971a904 	addi	r5,r5,-14684
8110135c:	1009883a 	mov	r4,r2
81101360:	111a9600 	call	8111a960 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18f1a904 	addi	r3,r3,-14684
8110137c:	00a04534 	movhi	r2,33044
81101380:	10966f04 	addi	r2,r2,22972
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	111ba100 	call	8111ba10 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a05f17 	ldw	r2,-32388(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	2971a904 	addi	r5,r5,-14684
811013a8:	1009883a 	mov	r4,r2
811013ac:	111a9600 	call	8111a960 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18f1a904 	addi	r3,r3,-14684
811013c8:	00a04534 	movhi	r2,33044
811013cc:	10967904 	addi	r2,r2,23012
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a05f17 	ldw	r2,-32388(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	2971a904 	addi	r5,r5,-14684
811013f4:	1009883a 	mov	r4,r2
811013f8:	111a9600 	call	8111a960 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10b1a904 	addi	r2,r2,-14684
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a05f17 	ldw	r2,-32388(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	2971a904 	addi	r5,r5,-14684
81101420:	1009883a 	mov	r4,r2
81101424:	111a9600 	call	8111a960 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18f1a904 	addi	r3,r3,-14684
81101454:	00a04534 	movhi	r2,33044
81101458:	10968304 	addi	r2,r2,23052
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a05f17 	ldw	r2,-32388(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	2971a904 	addi	r5,r5,-14684
81101480:	1009883a 	mov	r4,r2
81101484:	111a9600 	call	8111a960 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10b1a904 	addi	r2,r2,-14684
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a05f17 	ldw	r2,-32388(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	2971a904 	addi	r5,r5,-14684
811014a8:	1009883a 	mov	r4,r2
811014ac:	111a9600 	call	8111a960 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18f1a904 	addi	r3,r3,-14684
81101538:	00a04534 	movhi	r2,33044
8110153c:	10968904 	addi	r2,r2,23076
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a05f17 	ldw	r2,-32388(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	2971a904 	addi	r5,r5,-14684
81101564:	1009883a 	mov	r4,r2
81101568:	111a9600 	call	8111a960 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18f1a904 	addi	r3,r3,-14684
811015b4:	00a04534 	movhi	r2,33044
811015b8:	10969804 	addi	r2,r2,23136
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a05f17 	ldw	r2,-32388(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	2971a904 	addi	r5,r5,-14684
811015e0:	1009883a 	mov	r4,r2
811015e4:	111a9600 	call	8111a960 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18f1a904 	addi	r3,r3,-14684
81101648:	00a04534 	movhi	r2,33044
8110164c:	1094a904 	addi	r2,r2,21156
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a05f17 	ldw	r2,-32388(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	2971a904 	addi	r5,r5,-14684
81101674:	1009883a 	mov	r4,r2
81101678:	111a9600 	call	8111a960 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604534 	movhi	r5,33044
81101694:	2956a204 	addi	r5,r5,23176
81101698:	01204574 	movhi	r4,33045
8110169c:	2131a904 	addi	r4,r4,-14684
811016a0:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a05f17 	ldw	r2,-32388(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	2971a904 	addi	r5,r5,-14684
811016b0:	1009883a 	mov	r4,r2
811016b4:	111a9600 	call	8111a960 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08e17 	ldw	r2,-32200(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10b1e904 	addi	r2,r2,-14428
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10b1e904 	addi	r2,r2,-14428
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10b1e904 	addi	r2,r2,-14428
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10b1e904 	addi	r2,r2,-14428
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10b1e904 	addi	r2,r2,-14428
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10b1e904 	addi	r2,r2,-14428
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10b1e904 	addi	r2,r2,-14428
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18f1a904 	addi	r3,r3,-14684
81101868:	00a04534 	movhi	r2,33044
8110186c:	1096a804 	addi	r2,r2,23200
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a05f17 	ldw	r2,-32388(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	2971a904 	addi	r5,r5,-14684
81101894:	1009883a 	mov	r4,r2
81101898:	111a9600 	call	8111a960 <fprintf>
8110189c:	d0a08e17 	ldw	r2,-32200(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	2971e904 	addi	r5,r5,-14428
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	111ba100 	call	8111ba10 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604534 	movhi	r5,33044
81101990:	2956ad04 	addi	r5,r5,23220
81101994:	01204574 	movhi	r4,33045
81101998:	2131a904 	addi	r4,r4,-14684
8110199c:	111c2f00 	call	8111c2f0 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a05f17 	ldw	r2,-32388(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	2971a904 	addi	r5,r5,-14684
811019ac:	1009883a 	mov	r4,r2
811019b0:	111a9600 	call	8111a960 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11304100 	call	81130410 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10b1a904 	addi	r2,r2,-14684
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a05f17 	ldw	r2,-32388(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	2971a904 	addi	r5,r5,-14684
811019e4:	1009883a 	mov	r4,r2
811019e8:	111a9600 	call	8111a960 <fprintf>
811019ec:	d0e08e17 	ldw	r3,-32200(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	1119b9c0 	call	81119b9c <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08d17 	ldw	r2,-32204(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	1119cc80 	call	81119cc8 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	11193500 	call	81119350 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604534 	movhi	r5,33044
81101a54:	2956af04 	addi	r5,r5,23228
81101a58:	01204574 	movhi	r4,33045
81101a5c:	2131a904 	addi	r4,r4,-14684
81101a60:	111c2f00 	call	8111c2f0 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a05f17 	ldw	r2,-32388(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	2971a904 	addi	r5,r5,-14684
81101a70:	1009883a 	mov	r4,r2
81101a74:	111a9600 	call	8111a960 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18f1a904 	addi	r3,r3,-14684
81101a84:	00a04534 	movhi	r2,33044
81101a88:	1096bb04 	addi	r2,r2,23276
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a05f17 	ldw	r2,-32388(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	2971a904 	addi	r5,r5,-14684
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111a9600 	call	8111a960 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10b1a904 	addi	r2,r2,-14684
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a05f17 	ldw	r2,-32388(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	2971a904 	addi	r5,r5,-14684
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111a9600 	call	8111a960 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18f1a904 	addi	r3,r3,-14684
81101b30:	00a04534 	movhi	r2,33044
81101b34:	1096c104 	addi	r2,r2,23300
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a05f17 	ldw	r2,-32388(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	2971a904 	addi	r5,r5,-14684
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111a9600 	call	8111a960 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18f1a904 	addi	r3,r3,-14684
81101bc4:	00a04534 	movhi	r2,33044
81101bc8:	1094a904 	addi	r2,r2,21156
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a05f17 	ldw	r2,-32388(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	2971a904 	addi	r5,r5,-14684
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111a9600 	call	8111a960 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604534 	movhi	r5,33044
81101c10:	2956cb04 	addi	r5,r5,23340
81101c14:	01204574 	movhi	r4,33045
81101c18:	2131a904 	addi	r4,r4,-14684
81101c1c:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a05f17 	ldw	r2,-32388(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	2971a904 	addi	r5,r5,-14684
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111a9600 	call	8111a960 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18f1a904 	addi	r3,r3,-14684
81101cd0:	00a04534 	movhi	r2,33044
81101cd4:	1096d104 	addi	r2,r2,23364
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a05f17 	ldw	r2,-32388(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	2971a904 	addi	r5,r5,-14684
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111a9600 	call	8111a960 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08e17 	ldw	r2,-32200(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10b1e904 	addi	r2,r2,-14428
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10b1e904 	addi	r2,r2,-14428
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604534 	movhi	r5,33044
81101df4:	2956d804 	addi	r5,r5,23392
81101df8:	01204574 	movhi	r4,33045
81101dfc:	2131a904 	addi	r4,r4,-14684
81101e00:	111c2f00 	call	8111c2f0 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a05f17 	ldw	r2,-32388(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	2971a904 	addi	r5,r5,-14684
81101e10:	1009883a 	mov	r4,r2
81101e14:	111a9600 	call	8111a960 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604534 	movhi	r5,33044
81101e98:	2956ad04 	addi	r5,r5,23220
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	2131a904 	addi	r4,r4,-14684
81101ea4:	111c2f00 	call	8111c2f0 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a05f17 	ldw	r2,-32388(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	2971a904 	addi	r5,r5,-14684
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111a9600 	call	8111a960 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10b1a904 	addi	r2,r2,-14684
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a05f17 	ldw	r2,-32388(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	2971a904 	addi	r5,r5,-14684
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111a9600 	call	8111a960 <fprintf>
81101ef8:	d0e08e17 	ldw	r3,-32200(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	1119b9c0 	call	81119b9c <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08d17 	ldw	r2,-32204(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	1119cc80 	call	81119cc8 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	11193500 	call	81119350 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604534 	movhi	r5,33044
81101f60:	2956e604 	addi	r5,r5,23448
81101f64:	01204574 	movhi	r4,33045
81101f68:	2131a904 	addi	r4,r4,-14684
81101f6c:	111c2f00 	call	8111c2f0 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a05f17 	ldw	r2,-32388(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	2971a904 	addi	r5,r5,-14684
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111a9600 	call	8111a960 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18f1a904 	addi	r3,r3,-14684
81101f90:	00a04534 	movhi	r2,33044
81101f94:	1096f204 	addi	r2,r2,23496
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a05f17 	ldw	r2,-32388(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	2971a904 	addi	r5,r5,-14684
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111a9600 	call	8111a960 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10b1a904 	addi	r2,r2,-14684
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a05f17 	ldw	r2,-32388(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	2971a904 	addi	r5,r5,-14684
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111a9600 	call	8111a960 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18f1a904 	addi	r3,r3,-14684
8110204c:	00a04534 	movhi	r2,33044
81102050:	1096f804 	addi	r2,r2,23520
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a05f17 	ldw	r2,-32388(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	2971a904 	addi	r5,r5,-14684
81102078:	1009883a 	mov	r4,r2
8110207c:	111a9600 	call	8111a960 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18f1a904 	addi	r3,r3,-14684
811020e0:	00a04534 	movhi	r2,33044
811020e4:	1094a904 	addi	r2,r2,21156
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a05f17 	ldw	r2,-32388(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	2971a904 	addi	r5,r5,-14684
8110210c:	1009883a 	mov	r4,r2
81102110:	111a9600 	call	8111a960 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604534 	movhi	r5,33044
8110212c:	2956a204 	addi	r5,r5,23176
81102130:	01204574 	movhi	r4,33045
81102134:	2131a904 	addi	r4,r4,-14684
81102138:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a05f17 	ldw	r2,-32388(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	2971a904 	addi	r5,r5,-14684
81102148:	1009883a 	mov	r4,r2
8110214c:	111a9600 	call	8111a960 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08e17 	ldw	r2,-32200(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18f1a904 	addi	r3,r3,-14684
811021ac:	00a04534 	movhi	r2,33044
811021b0:	10970404 	addi	r2,r2,23568
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a05f17 	ldw	r2,-32388(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	2971a904 	addi	r5,r5,-14684
811021d8:	1009883a 	mov	r4,r2
811021dc:	111a9600 	call	8111a960 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604534 	movhi	r5,33044
811021f0:	29570a04 	addi	r5,r5,23592
811021f4:	01204574 	movhi	r4,33045
811021f8:	2131a904 	addi	r4,r4,-14684
811021fc:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a05f17 	ldw	r2,-32388(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	2971a904 	addi	r5,r5,-14684
8110220c:	1009883a 	mov	r4,r2
81102210:	111a9600 	call	8111a960 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08e17 	ldw	r2,-32200(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604534 	movhi	r5,33044
81102274:	29570c04 	addi	r5,r5,23600
81102278:	01204574 	movhi	r4,33045
8110227c:	2131a904 	addi	r4,r4,-14684
81102280:	111c2f00 	call	8111c2f0 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a05f17 	ldw	r2,-32388(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	2971a904 	addi	r5,r5,-14684
81102290:	1009883a 	mov	r4,r2
81102294:	111a9600 	call	8111a960 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11304100 	call	81130410 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604534 	movhi	r5,33044
811022fc:	29570f04 	addi	r5,r5,23612
81102300:	01204574 	movhi	r4,33045
81102304:	2131a904 	addi	r4,r4,-14684
81102308:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a05f17 	ldw	r2,-32388(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	2971a904 	addi	r5,r5,-14684
81102318:	1009883a 	mov	r4,r2
8110231c:	111a9600 	call	8111a960 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08e17 	ldw	r3,-32200(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	1119b9c0 	call	81119b9c <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08d17 	ldw	r2,-32204(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	1119cc80 	call	81119cc8 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	11193500 	call	81119350 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111a4e00 	call	8111a4e0 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604534 	movhi	r5,33044
81102394:	29571204 	addi	r5,r5,23624
81102398:	01204574 	movhi	r4,33045
8110239c:	2131a904 	addi	r4,r4,-14684
811023a0:	111c2f00 	call	8111c2f0 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a05f17 	ldw	r2,-32388(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	2971a904 	addi	r5,r5,-14684
811023b0:	1009883a 	mov	r4,r2
811023b4:	111a9600 	call	8111a960 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	29571e04 	addi	r5,r5,23672
811023c8:	01204574 	movhi	r4,33045
811023cc:	2131a904 	addi	r4,r4,-14684
811023d0:	111c2f00 	call	8111c2f0 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a05f17 	ldw	r2,-32388(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	2971a904 	addi	r5,r5,-14684
811023e0:	1009883a 	mov	r4,r2
811023e4:	111a9600 	call	8111a960 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18f1a904 	addi	r3,r3,-14684
811023f4:	00a04534 	movhi	r2,33044
811023f8:	1096bb04 	addi	r2,r2,23276
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a05f17 	ldw	r2,-32388(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	2971a904 	addi	r5,r5,-14684
81102420:	1009883a 	mov	r4,r2
81102424:	111a9600 	call	8111a960 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10b1a904 	addi	r2,r2,-14684
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a05f17 	ldw	r2,-32388(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	2971a904 	addi	r5,r5,-14684
81102448:	1009883a 	mov	r4,r2
8110244c:	111a9600 	call	8111a960 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18f1a904 	addi	r3,r3,-14684
811024b8:	00a04534 	movhi	r2,33044
811024bc:	10972804 	addi	r2,r2,23712
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a05f17 	ldw	r2,-32388(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	2971a904 	addi	r5,r5,-14684
811024e4:	1009883a 	mov	r4,r2
811024e8:	111a9600 	call	8111a960 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18f1a904 	addi	r3,r3,-14684
8110254c:	00a04534 	movhi	r2,33044
81102550:	1094a904 	addi	r2,r2,21156
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	111ba100 	call	8111ba10 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a05f17 	ldw	r2,-32388(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	2971a904 	addi	r5,r5,-14684
81102578:	1009883a 	mov	r4,r2
8110257c:	111a9600 	call	8111a960 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604534 	movhi	r5,33044
81102598:	2956a204 	addi	r5,r5,23176
8110259c:	01204574 	movhi	r4,33045
811025a0:	2131a904 	addi	r4,r4,-14684
811025a4:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a05f17 	ldw	r2,-32388(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	2971a904 	addi	r5,r5,-14684
811025b4:	1009883a 	mov	r4,r2
811025b8:	111a9600 	call	8111a960 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18f1a904 	addi	r3,r3,-14684
81102610:	00a04534 	movhi	r2,33044
81102614:	10973404 	addi	r2,r2,23760
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a05f17 	ldw	r2,-32388(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	2971a904 	addi	r5,r5,-14684
8110263c:	1009883a 	mov	r4,r2
81102640:	111a9600 	call	8111a960 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604534 	movhi	r5,33044
81102654:	29570a04 	addi	r5,r5,23592
81102658:	01204574 	movhi	r4,33045
8110265c:	2131a904 	addi	r4,r4,-14684
81102660:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a05f17 	ldw	r2,-32388(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	2971a904 	addi	r5,r5,-14684
81102670:	1009883a 	mov	r4,r2
81102674:	111a9600 	call	8111a960 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08e17 	ldw	r2,-32200(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604534 	movhi	r5,33044
811026c8:	29573a04 	addi	r5,r5,23784
811026cc:	01204574 	movhi	r4,33045
811026d0:	2131a904 	addi	r4,r4,-14684
811026d4:	111c2f00 	call	8111c2f0 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a05f17 	ldw	r2,-32388(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	2971a904 	addi	r5,r5,-14684
811026e4:	1009883a 	mov	r4,r2
811026e8:	111a9600 	call	8111a960 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604534 	movhi	r5,33044
81102710:	29570c04 	addi	r5,r5,23600
81102714:	01204574 	movhi	r4,33045
81102718:	2131a904 	addi	r4,r4,-14684
8110271c:	111c2f00 	call	8111c2f0 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a05f17 	ldw	r2,-32388(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	2971a904 	addi	r5,r5,-14684
8110272c:	1009883a 	mov	r4,r2
81102730:	111a9600 	call	8111a960 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604534 	movhi	r5,33044
81102794:	29570f04 	addi	r5,r5,23612
81102798:	01204574 	movhi	r4,33045
8110279c:	2131a904 	addi	r4,r4,-14684
811027a0:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a05f17 	ldw	r2,-32388(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	2971a904 	addi	r5,r5,-14684
811027b0:	1009883a 	mov	r4,r2
811027b4:	111a9600 	call	8111a960 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08e17 	ldw	r3,-32200(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	1119b9c0 	call	81119b9c <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08d17 	ldw	r2,-32204(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	1119cc80 	call	81119cc8 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	11193500 	call	81119350 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604534 	movhi	r5,33044
8110282c:	29574204 	addi	r5,r5,23816
81102830:	01204574 	movhi	r4,33045
81102834:	2131a904 	addi	r4,r4,-14684
81102838:	111c2f00 	call	8111c2f0 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a05f17 	ldw	r2,-32388(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	2971a904 	addi	r5,r5,-14684
81102848:	1009883a 	mov	r4,r2
8110284c:	111a9600 	call	8111a960 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604534 	movhi	r5,33044
8110285c:	29574e04 	addi	r5,r5,23864
81102860:	01204574 	movhi	r4,33045
81102864:	2131a904 	addi	r4,r4,-14684
81102868:	111c2f00 	call	8111c2f0 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a05f17 	ldw	r2,-32388(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	2971a904 	addi	r5,r5,-14684
81102878:	1009883a 	mov	r4,r2
8110287c:	111a9600 	call	8111a960 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18f1a904 	addi	r3,r3,-14684
8110288c:	00a04534 	movhi	r2,33044
81102890:	1096f204 	addi	r2,r2,23496
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	111ba100 	call	8111ba10 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a05f17 	ldw	r2,-32388(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	2971a904 	addi	r5,r5,-14684
811028b8:	1009883a 	mov	r4,r2
811028bc:	111a9600 	call	8111a960 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10b1a904 	addi	r2,r2,-14684
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a05f17 	ldw	r2,-32388(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	2971a904 	addi	r5,r5,-14684
811028e0:	1009883a 	mov	r4,r2
811028e4:	111a9600 	call	8111a960 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1143b1c0 	call	81143b1c <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000e1e 	bne	r2,zero,81102ba8 <DMA_DISPATCHER_STOP+0x84>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000706 	br	81102b90 <DMA_DISPATCHER_STOP+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1131c380 	call	81131c38 <usleep>
81102b84:	00000206 	br	81102b90 <DMA_DISPATCHER_STOP+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e13fff17 	ldw	r4,-4(fp)
81102b8c:	1131c380 	call	81131c38 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b90:	e0bffd17 	ldw	r2,-12(fp)
81102b94:	10800317 	ldw	r2,12(r2)
81102b98:	10800037 	ldwio	r2,0(r2)
81102b9c:	1080080c 	andi	r2,r2,32
81102ba0:	103ff41e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba4:	00000206 	br	81102bb0 <DMA_DISPATCHER_STOP+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102ba8:	e0bffc17 	ldw	r2,-16(fp)
81102bac:	00000106 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
  }
  
  return bSuccess;
81102bb0:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb4:	e037883a 	mov	sp,fp
81102bb8:	dfc00117 	ldw	ra,4(sp)
81102bbc:	df000017 	ldw	fp,0(sp)
81102bc0:	dec00204 	addi	sp,sp,8
81102bc4:	f800283a 	ret

81102bc8 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bc8:	defffa04 	addi	sp,sp,-24
81102bcc:	de00012e 	bgeu	sp,et,81102bd4 <DMA_DISPATCHER_RESET+0xc>
81102bd0:	003b68fa 	trap	3
81102bd4:	dfc00515 	stw	ra,20(sp)
81102bd8:	df000415 	stw	fp,16(sp)
81102bdc:	df000404 	addi	fp,sp,16
81102be0:	e13ffd15 	stw	r4,-12(fp)
81102be4:	e17ffe15 	stw	r5,-8(fp)
81102be8:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bec:	00800044 	movi	r2,1
81102bf0:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf4:	e0bffd17 	ldw	r2,-12(fp)
81102bf8:	10800317 	ldw	r2,12(r2)
81102bfc:	10800104 	addi	r2,r2,4
81102c00:	00c00084 	movi	r3,2
81102c04:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c08:	e0bffe17 	ldw	r2,-8(fp)
81102c0c:	10800058 	cmpnei	r2,r2,1
81102c10:	10000e1e 	bne	r2,zero,81102c4c <DMA_DISPATCHER_RESET+0x84>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c14:	00000706 	br	81102c34 <DMA_DISPATCHER_RESET+0x6c>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c18:	e0bfff17 	ldw	r2,-4(fp)
81102c1c:	1000031e 	bne	r2,zero,81102c2c <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c20:	01000044 	movi	r4,1
81102c24:	1131c380 	call	81131c38 <usleep>
81102c28:	00000206 	br	81102c34 <DMA_DISPATCHER_RESET+0x6c>
      } else {
        usleep(WaitPeriodUs);
81102c2c:	e13fff17 	ldw	r4,-4(fp)
81102c30:	1131c380 	call	81131c38 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c34:	e0bffd17 	ldw	r2,-12(fp)
81102c38:	10800317 	ldw	r2,12(r2)
81102c3c:	10800037 	ldwio	r2,0(r2)
81102c40:	1080100c 	andi	r2,r2,64
81102c44:	103ff41e 	bne	r2,zero,81102c18 <__reset+0xfb0e2c18>
81102c48:	00000206 	br	81102c54 <DMA_DISPATCHER_RESET+0x8c>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c4c:	e0bffc17 	ldw	r2,-16(fp)
81102c50:	00000106 	br	81102c58 <DMA_DISPATCHER_RESET+0x90>
  }
  
  return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
}
81102c58:	e037883a 	mov	sp,fp
81102c5c:	dfc00117 	ldw	ra,4(sp)
81102c60:	df000017 	ldw	fp,0(sp)
81102c64:	dec00204 	addi	sp,sp,8
81102c68:	f800283a 	ret

81102c6c <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c6c:	defff604 	addi	sp,sp,-40
81102c70:	de00012e 	bgeu	sp,et,81102c78 <DMA_SINGLE_TRANSFER+0xc>
81102c74:	003b68fa 	trap	3
81102c78:	dfc00915 	stw	ra,36(sp)
81102c7c:	df000815 	stw	fp,32(sp)
81102c80:	dc000715 	stw	r16,28(sp)
81102c84:	df000804 	addi	fp,sp,32
81102c88:	e13ffb15 	stw	r4,-20(fp)
81102c8c:	e17ffc15 	stw	r5,-16(fp)
81102c90:	e1bffd15 	stw	r6,-12(fp)
81102c94:	e1fffe15 	stw	r7,-8(fp)
81102c98:	defff804 	addi	sp,sp,-32
81102c9c:	d8800204 	addi	r2,sp,8
81102ca0:	108003c4 	addi	r2,r2,15
81102ca4:	1004d13a 	srli	r2,r2,4
81102ca8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cac:	00800044 	movi	r2,1
81102cb0:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cb4:	e0fffc17 	ldw	r3,-16(fp)
81102cb8:	e13ffd17 	ldw	r4,-12(fp)
81102cbc:	e0800217 	ldw	r2,8(fp)
81102cc0:	d8800115 	stw	r2,4(sp)
81102cc4:	e0bffe17 	ldw	r2,-8(fp)
81102cc8:	d8800015 	stw	r2,0(sp)
81102ccc:	200f883a 	mov	r7,r4
81102cd0:	180d883a 	mov	r6,r3
81102cd4:	800b883a 	mov	r5,r16
81102cd8:	e13ffb17 	ldw	r4,-20(fp)
81102cdc:	1142b180 	call	81142b18 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce0:	10000326 	beq	r2,zero,81102cf0 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102ce4:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102ce8:	e0bffa17 	ldw	r2,-24(fp)
81102cec:	00001d06 	br	81102d64 <DMA_SINGLE_TRANSFER+0xf8>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf0:	800b883a 	mov	r5,r16
81102cf4:	e13ffb17 	ldw	r4,-20(fp)
81102cf8:	1143d8c0 	call	81143d8c <alt_msgdma_standard_descriptor_async_transfer>
81102cfc:	10000326 	beq	r2,zero,81102d0c <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d00:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d04:	e0bffa17 	ldw	r2,-24(fp)
81102d08:	00001606 	br	81102d64 <DMA_SINGLE_TRANSFER+0xf8>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	10800060 	cmpeqi	r2,r2,1
81102d14:	1007883a 	mov	r3,r2
81102d18:	e0800317 	ldw	r2,12(fp)
81102d1c:	10800060 	cmpeqi	r2,r2,1
81102d20:	1884703a 	and	r2,r3,r2
81102d24:	10803fcc 	andi	r2,r2,255
81102d28:	10000d26 	beq	r2,zero,81102d60 <DMA_SINGLE_TRANSFER+0xf4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d2c:	00000706 	br	81102d4c <DMA_SINGLE_TRANSFER+0xe0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d30:	e0800417 	ldw	r2,16(fp)
81102d34:	1000031e 	bne	r2,zero,81102d44 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d38:	0100fa04 	movi	r4,1000
81102d3c:	1131c380 	call	81131c38 <usleep>
81102d40:	00000206 	br	81102d4c <DMA_SINGLE_TRANSFER+0xe0>
      } else {
        usleep(WaitPeriodUs);
81102d44:	e1000417 	ldw	r4,16(fp)
81102d48:	1131c380 	call	81131c38 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d4c:	e0bffb17 	ldw	r2,-20(fp)
81102d50:	10800317 	ldw	r2,12(r2)
81102d54:	10800037 	ldwio	r2,0(r2)
81102d58:	1080004c 	andi	r2,r2,1
81102d5c:	103ff41e 	bne	r2,zero,81102d30 <__reset+0xfb0e2d30>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d60:	e0bffa17 	ldw	r2,-24(fp)
}
81102d64:	e6ffff04 	addi	sp,fp,-4
81102d68:	dfc00217 	ldw	ra,8(sp)
81102d6c:	df000117 	ldw	fp,4(sp)
81102d70:	dc000017 	ldw	r16,0(sp)
81102d74:	dec00304 	addi	sp,sp,12
81102d78:	f800283a 	ret

81102d7c <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d7c:	defff504 	addi	sp,sp,-44
81102d80:	de00012e 	bgeu	sp,et,81102d88 <DMA_MULTIPLE_TRANSFER+0xc>
81102d84:	003b68fa 	trap	3
81102d88:	dfc00a15 	stw	ra,40(sp)
81102d8c:	df000915 	stw	fp,36(sp)
81102d90:	dc000815 	stw	r16,32(sp)
81102d94:	df000904 	addi	fp,sp,36
81102d98:	e13ffb15 	stw	r4,-20(fp)
81102d9c:	e17ffc15 	stw	r5,-16(fp)
81102da0:	e1bffd15 	stw	r6,-12(fp)
81102da4:	3805883a 	mov	r2,r7
81102da8:	e0bffe05 	stb	r2,-8(fp)
81102dac:	defff804 	addi	sp,sp,-32
81102db0:	d8800204 	addi	r2,sp,8
81102db4:	108003c4 	addi	r2,r2,15
81102db8:	1004d13a 	srli	r2,r2,4
81102dbc:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dc0:	00800044 	movi	r2,1
81102dc4:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dc8:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dcc:	00002506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102dd0:	e0bffa03 	ldbu	r2,-24(fp)
81102dd4:	1085883a 	add	r2,r2,r2
81102dd8:	1085883a 	add	r2,r2,r2
81102ddc:	1007883a 	mov	r3,r2
81102de0:	e0bffc17 	ldw	r2,-16(fp)
81102de4:	10c5883a 	add	r2,r2,r3
81102de8:	10800017 	ldw	r2,0(r2)
81102dec:	1009883a 	mov	r4,r2
81102df0:	e0bffa03 	ldbu	r2,-24(fp)
81102df4:	1085883a 	add	r2,r2,r2
81102df8:	1085883a 	add	r2,r2,r2
81102dfc:	1007883a 	mov	r3,r2
81102e00:	e0bffd17 	ldw	r2,-12(fp)
81102e04:	10c5883a 	add	r2,r2,r3
81102e08:	10800017 	ldw	r2,0(r2)
81102e0c:	1007883a 	mov	r3,r2
81102e10:	e0800317 	ldw	r2,12(fp)
81102e14:	10804034 	orhi	r2,r2,256
81102e18:	d8800115 	stw	r2,4(sp)
81102e1c:	e0800217 	ldw	r2,8(fp)
81102e20:	d8800015 	stw	r2,0(sp)
81102e24:	180f883a 	mov	r7,r3
81102e28:	200d883a 	mov	r6,r4
81102e2c:	800b883a 	mov	r5,r16
81102e30:	e13ffb17 	ldw	r4,-20(fp)
81102e34:	1142b180 	call	81142b18 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e38:	10000226 	beq	r2,zero,81102e44 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e3c:	e03ff915 	stw	zero,-28(fp)
81102e40:	00000506 	br	81102e58 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e44:	800b883a 	mov	r5,r16
81102e48:	e13ffb17 	ldw	r4,-20(fp)
81102e4c:	1143d8c0 	call	81143d8c <alt_msgdma_standard_descriptor_async_transfer>
81102e50:	10000126 	beq	r2,zero,81102e58 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e54:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e58:	e0bffa03 	ldbu	r2,-24(fp)
81102e5c:	10800044 	addi	r2,r2,1
81102e60:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e64:	e0bff917 	ldw	r2,-28(fp)
81102e68:	10800060 	cmpeqi	r2,r2,1
81102e6c:	1009883a 	mov	r4,r2
81102e70:	e0fffa03 	ldbu	r3,-24(fp)
81102e74:	e0bffe03 	ldbu	r2,-8(fp)
81102e78:	10bfffc4 	addi	r2,r2,-1
81102e7c:	1884803a 	cmplt	r2,r3,r2
81102e80:	2084703a 	and	r2,r4,r2
81102e84:	10803fcc 	andi	r2,r2,255
81102e88:	103fd11e 	bne	r2,zero,81102dd0 <__reset+0xfb0e2dd0>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e8c:	e0bff917 	ldw	r2,-28(fp)
81102e90:	10800058 	cmpnei	r2,r2,1
81102e94:	1000211e 	bne	r2,zero,81102f1c <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102e98:	e0bffa03 	ldbu	r2,-24(fp)
81102e9c:	1085883a 	add	r2,r2,r2
81102ea0:	1085883a 	add	r2,r2,r2
81102ea4:	1007883a 	mov	r3,r2
81102ea8:	e0bffc17 	ldw	r2,-16(fp)
81102eac:	10c5883a 	add	r2,r2,r3
81102eb0:	10800017 	ldw	r2,0(r2)
81102eb4:	1009883a 	mov	r4,r2
81102eb8:	e0bffa03 	ldbu	r2,-24(fp)
81102ebc:	1085883a 	add	r2,r2,r2
81102ec0:	1085883a 	add	r2,r2,r2
81102ec4:	1007883a 	mov	r3,r2
81102ec8:	e0bffd17 	ldw	r2,-12(fp)
81102ecc:	10c5883a 	add	r2,r2,r3
81102ed0:	10800017 	ldw	r2,0(r2)
81102ed4:	1007883a 	mov	r3,r2
81102ed8:	e0800317 	ldw	r2,12(fp)
81102edc:	d8800115 	stw	r2,4(sp)
81102ee0:	e0800217 	ldw	r2,8(fp)
81102ee4:	d8800015 	stw	r2,0(sp)
81102ee8:	180f883a 	mov	r7,r3
81102eec:	200d883a 	mov	r6,r4
81102ef0:	800b883a 	mov	r5,r16
81102ef4:	e13ffb17 	ldw	r4,-20(fp)
81102ef8:	1142b180 	call	81142b18 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102efc:	10000226 	beq	r2,zero,81102f08 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f00:	e03ff915 	stw	zero,-28(fp)
81102f04:	00000506 	br	81102f1c <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f08:	800b883a 	mov	r5,r16
81102f0c:	e13ffb17 	ldw	r4,-20(fp)
81102f10:	1143d8c0 	call	81143d8c <alt_msgdma_standard_descriptor_async_transfer>
81102f14:	10000126 	beq	r2,zero,81102f1c <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f18:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f1c:	e0bff917 	ldw	r2,-28(fp)
81102f20:	10800060 	cmpeqi	r2,r2,1
81102f24:	1007883a 	mov	r3,r2
81102f28:	e0800417 	ldw	r2,16(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1884703a 	and	r2,r3,r2
81102f34:	10803fcc 	andi	r2,r2,255
81102f38:	10000d26 	beq	r2,zero,81102f70 <DMA_MULTIPLE_TRANSFER+0x1f4>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f3c:	00000706 	br	81102f5c <DMA_MULTIPLE_TRANSFER+0x1e0>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f40:	e0800517 	ldw	r2,20(fp)
81102f44:	1000031e 	bne	r2,zero,81102f54 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f48:	0100fa04 	movi	r4,1000
81102f4c:	1131c380 	call	81131c38 <usleep>
81102f50:	00000206 	br	81102f5c <DMA_MULTIPLE_TRANSFER+0x1e0>
      } else {
    	usleep(WaitPeriodUs);
81102f54:	e1000517 	ldw	r4,20(fp)
81102f58:	1131c380 	call	81131c38 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f5c:	e0bffb17 	ldw	r2,-20(fp)
81102f60:	10800317 	ldw	r2,12(r2)
81102f64:	10800037 	ldwio	r2,0(r2)
81102f68:	1080004c 	andi	r2,r2,1
81102f6c:	103ff41e 	bne	r2,zero,81102f40 <__reset+0xfb0e2f40>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f70:	e0bff917 	ldw	r2,-28(fp)
}
81102f74:	e6ffff04 	addi	sp,fp,-4
81102f78:	dfc00217 	ldw	ra,8(sp)
81102f7c:	df000117 	ldw	fp,4(sp)
81102f80:	dc000017 	ldw	r16,0(sp)
81102f84:	dec00304 	addi	sp,sp,12
81102f88:	f800283a 	ret

81102f8c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f8c:	deffef04 	addi	sp,sp,-68
81102f90:	de00012e 	bgeu	sp,et,81102f98 <POWER_Read+0xc>
81102f94:	003b68fa 	trap	3
81102f98:	dfc01015 	stw	ra,64(sp)
81102f9c:	df000f15 	stw	fp,60(sp)
81102fa0:	df000f04 	addi	fp,sp,60
81102fa4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fa8:	00800044 	movi	r2,1
81102fac:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fb0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fb4:	00800204 	movi	r2,8
81102fb8:	e0bffc15 	stw	r2,-16(fp)
81102fbc:	00800104 	movi	r2,4
81102fc0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fc4:	00800044 	movi	r2,1
81102fc8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fcc:	00800044 	movi	r2,1
81102fd0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fd4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fd8:	e03ff515 	stw	zero,-44(fp)
81102fdc:	00009206 	br	81103228 <POWER_Read+0x29c>
		NextChannel = 0;
81102fe0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102fe4:	e0bff517 	ldw	r2,-44(fp)
81102fe8:	10c03fcc 	andi	r3,r2,255
81102fec:	e13ffa03 	ldbu	r4,-24(fp)
81102ff0:	e0bfff17 	ldw	r2,-4(fp)
81102ff4:	d8800115 	stw	r2,4(sp)
81102ff8:	e0bff917 	ldw	r2,-28(fp)
81102ffc:	d8800015 	stw	r2,0(sp)
81103000:	e1fff817 	ldw	r7,-32(fp)
81103004:	e1bff717 	ldw	r6,-36(fp)
81103008:	200b883a 	mov	r5,r4
8110300c:	1809883a 	mov	r4,r3
81103010:	110aa840 	call	8110aa84 <POWER_SPI_RW>
81103014:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103018:	e03ff415 	stw	zero,-48(fp)
8110301c:	00007406 	br	811031f0 <POWER_Read+0x264>
			NextChannel = i + 1;
81103020:	e0bff417 	ldw	r2,-48(fp)
81103024:	10800044 	addi	r2,r2,1
81103028:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110302c:	e0bff517 	ldw	r2,-44(fp)
81103030:	10c03fcc 	andi	r3,r2,255
81103034:	e13ffa03 	ldbu	r4,-24(fp)
81103038:	e0bffe04 	addi	r2,fp,-8
8110303c:	d8800115 	stw	r2,4(sp)
81103040:	e0bff917 	ldw	r2,-28(fp)
81103044:	d8800015 	stw	r2,0(sp)
81103048:	e1fff817 	ldw	r7,-32(fp)
8110304c:	e1bff717 	ldw	r6,-36(fp)
81103050:	200b883a 	mov	r5,r4
81103054:	1809883a 	mov	r4,r3
81103058:	110aa840 	call	8110aa84 <POWER_SPI_RW>
8110305c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103060:	e0bff317 	ldw	r2,-52(fp)
81103064:	10005026 	beq	r2,zero,811031a8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103068:	e0bffe17 	ldw	r2,-8(fp)
8110306c:	1004d7ba 	srli	r2,r2,30
81103070:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103074:	e0bffe17 	ldw	r2,-8(fp)
81103078:	1004d07a 	srli	r2,r2,1
8110307c:	108001cc 	andi	r2,r2,7
81103080:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d13a 	srli	r2,r2,4
8110308c:	1080004c 	andi	r2,r2,1
81103090:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d17a 	srli	r2,r2,5
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1080004c 	andi	r2,r2,1
811030ac:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030b0:	e0bffa43 	ldbu	r2,-23(fp)
811030b4:	10000d26 	beq	r2,zero,811030ec <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030b8:	e1bff417 	ldw	r6,-48(fp)
811030bc:	01604534 	movhi	r5,33044
811030c0:	29575804 	addi	r5,r5,23904
811030c4:	01204574 	movhi	r4,33045
811030c8:	2131a904 	addi	r4,r4,-14684
811030cc:	111c2f00 	call	8111c2f0 <sprintf>
					debug(fp, cDebugBuffer);
811030d0:	d0a05f17 	ldw	r2,-32388(gp)
811030d4:	01604574 	movhi	r5,33045
811030d8:	2971a904 	addi	r5,r5,-14684
811030dc:	1009883a 	mov	r4,r2
811030e0:	111a9600 	call	8111a960 <fprintf>
#endif
					bSuccess = FALSE;
811030e4:	e03ff315 	stw	zero,-52(fp)
811030e8:	00002206 	br	81103174 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030ec:	e0fffa83 	ldbu	r3,-22(fp)
811030f0:	e0bff417 	ldw	r2,-48(fp)
811030f4:	18801026 	beq	r3,r2,81103138 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
811030f8:	e0bffa83 	ldbu	r2,-22(fp)
811030fc:	d8800015 	stw	r2,0(sp)
81103100:	e1fff417 	ldw	r7,-48(fp)
81103104:	e1bff417 	ldw	r6,-48(fp)
81103108:	01604534 	movhi	r5,33044
8110310c:	29575e04 	addi	r5,r5,23928
81103110:	01204574 	movhi	r4,33045
81103114:	2131a904 	addi	r4,r4,-14684
81103118:	111c2f00 	call	8111c2f0 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110311c:	d0a05f17 	ldw	r2,-32388(gp)
81103120:	01604574 	movhi	r5,33045
81103124:	2971a904 	addi	r5,r5,-14684
81103128:	1009883a 	mov	r4,r2
8110312c:	111a9600 	call	8111a960 <fprintf>
#endif
					bSuccess = FALSE;
81103130:	e03ff315 	stw	zero,-52(fp)
81103134:	00000f06 	br	81103174 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103138:	e0fffac3 	ldbu	r3,-21(fp)
8110313c:	e0bff817 	ldw	r2,-32(fp)
81103140:	18800c26 	beq	r3,r2,81103174 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103144:	e1bff417 	ldw	r6,-48(fp)
81103148:	01604534 	movhi	r5,33044
8110314c:	29576a04 	addi	r5,r5,23976
81103150:	01204574 	movhi	r4,33045
81103154:	2131a904 	addi	r4,r4,-14684
81103158:	111c2f00 	call	8111c2f0 <sprintf>
					debug(fp, cDebugBuffer);
8110315c:	d0a05f17 	ldw	r2,-32388(gp)
81103160:	01604574 	movhi	r5,33045
81103164:	2971a904 	addi	r5,r5,-14684
81103168:	1009883a 	mov	r4,r2
8110316c:	111a9600 	call	8111a960 <fprintf>
#endif
					bSuccess = FALSE;
81103170:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103174:	e0bff317 	ldw	r2,-52(fp)
81103178:	10001a26 	beq	r2,zero,811031e4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110317c:	e0bff617 	ldw	r2,-40(fp)
81103180:	10c00044 	addi	r3,r2,1
81103184:	e0fff615 	stw	r3,-40(fp)
81103188:	1085883a 	add	r2,r2,r2
8110318c:	1085883a 	add	r2,r2,r2
81103190:	1007883a 	mov	r3,r2
81103194:	e0bfff17 	ldw	r2,-4(fp)
81103198:	10c5883a 	add	r2,r2,r3
8110319c:	e0fffe17 	ldw	r3,-8(fp)
811031a0:	10c00015 	stw	r3,0(r2)
811031a4:	00000f06 	br	811031e4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031a8:	00e04574 	movhi	r3,33045
811031ac:	18f1a904 	addi	r3,r3,-14684
811031b0:	00a04534 	movhi	r2,33044
811031b4:	10977004 	addi	r2,r2,24000
811031b8:	1009883a 	mov	r4,r2
811031bc:	00800444 	movi	r2,17
811031c0:	100d883a 	mov	r6,r2
811031c4:	200b883a 	mov	r5,r4
811031c8:	1809883a 	mov	r4,r3
811031cc:	111ba100 	call	8111ba10 <memcpy>
				debug(fp, cDebugBuffer);
811031d0:	d0a05f17 	ldw	r2,-32388(gp)
811031d4:	01604574 	movhi	r5,33045
811031d8:	2971a904 	addi	r5,r5,-14684
811031dc:	1009883a 	mov	r4,r2
811031e0:	111a9600 	call	8111a960 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031e4:	e0bff417 	ldw	r2,-48(fp)
811031e8:	10800044 	addi	r2,r2,1
811031ec:	e0bff415 	stw	r2,-48(fp)
811031f0:	e0bff517 	ldw	r2,-44(fp)
811031f4:	1085883a 	add	r2,r2,r2
811031f8:	1085883a 	add	r2,r2,r2
811031fc:	e0fff304 	addi	r3,fp,-52
81103200:	1885883a 	add	r2,r3,r2
81103204:	10800904 	addi	r2,r2,36
81103208:	10800017 	ldw	r2,0(r2)
8110320c:	e0fff417 	ldw	r3,-48(fp)
81103210:	1880020e 	bge	r3,r2,8110321c <POWER_Read+0x290>
81103214:	e0bff317 	ldw	r2,-52(fp)
81103218:	103f811e 	bne	r2,zero,81103020 <__reset+0xfb0e3020>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110321c:	e0bff517 	ldw	r2,-44(fp)
81103220:	10800044 	addi	r2,r2,1
81103224:	e0bff515 	stw	r2,-44(fp)
81103228:	e0bff517 	ldw	r2,-44(fp)
8110322c:	10800088 	cmpgei	r2,r2,2
81103230:	1000021e 	bne	r2,zero,8110323c <POWER_Read+0x2b0>
81103234:	e0bff317 	ldw	r2,-52(fp)
81103238:	103f691e 	bne	r2,zero,81102fe0 <__reset+0xfb0e2fe0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110323c:	e0bff317 	ldw	r2,-52(fp)
}
81103240:	e037883a 	mov	sp,fp
81103244:	dfc00117 	ldw	ra,4(sp)
81103248:	df000017 	ldw	fp,0(sp)
8110324c:	dec00204 	addi	sp,sp,8
81103250:	f800283a 	ret

81103254 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103254:	defff904 	addi	sp,sp,-28
81103258:	de00012e 	bgeu	sp,et,81103260 <TEMP_Read+0xc>
8110325c:	003b68fa 	trap	3
81103260:	dfc00615 	stw	ra,24(sp)
81103264:	df000515 	stw	fp,20(sp)
81103268:	df000504 	addi	fp,sp,20
8110326c:	e13ffe15 	stw	r4,-8(fp)
81103270:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103274:	00800c04 	movi	r2,48
81103278:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110327c:	e0bffd83 	ldbu	r2,-10(fp)
81103280:	10c03fcc 	andi	r3,r2,255
81103284:	18c0201c 	xori	r3,r3,128
81103288:	18ffe004 	addi	r3,r3,-128
8110328c:	e0bffdc4 	addi	r2,fp,-9
81103290:	d8800015 	stw	r2,0(sp)
81103294:	000f883a 	mov	r7,zero
81103298:	180d883a 	mov	r6,r3
8110329c:	01600034 	movhi	r5,32768
811032a0:	29426004 	addi	r5,r5,2432
811032a4:	01200034 	movhi	r4,32768
811032a8:	21026404 	addi	r4,r4,2448
811032ac:	110987c0 	call	8110987c <I2C_Read>
811032b0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032b4:	e0bffc17 	ldw	r2,-16(fp)
811032b8:	10000226 	beq	r2,zero,811032c4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032bc:	e0bffdc3 	ldbu	r2,-9(fp)
811032c0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10001226 	beq	r2,zero,81103314 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032cc:	e0bffd83 	ldbu	r2,-10(fp)
811032d0:	10c03fcc 	andi	r3,r2,255
811032d4:	18c0201c 	xori	r3,r3,128
811032d8:	18ffe004 	addi	r3,r3,-128
811032dc:	e0bffdc4 	addi	r2,fp,-9
811032e0:	d8800015 	stw	r2,0(sp)
811032e4:	01c00044 	movi	r7,1
811032e8:	180d883a 	mov	r6,r3
811032ec:	01600034 	movhi	r5,32768
811032f0:	29426004 	addi	r5,r5,2432
811032f4:	01200034 	movhi	r4,32768
811032f8:	21026404 	addi	r4,r4,2448
811032fc:	110987c0 	call	8110987c <I2C_Read>
81103300:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103304:	e0bffc17 	ldw	r2,-16(fp)
81103308:	10000226 	beq	r2,zero,81103314 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110330c:	e0bffdc3 	ldbu	r2,-9(fp)
81103310:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000626 	beq	r2,zero,81103334 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110331c:	e0bffe17 	ldw	r2,-8(fp)
81103320:	e0fffd03 	ldbu	r3,-12(fp)
81103324:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103328:	e0bfff17 	ldw	r2,-4(fp)
8110332c:	e0fffd43 	ldbu	r3,-11(fp)
81103330:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103334:	e0bffc17 	ldw	r2,-16(fp)
}
81103338:	e037883a 	mov	sp,fp
8110333c:	dfc00117 	ldw	ra,4(sp)
81103340:	df000017 	ldw	fp,0(sp)
81103344:	dec00204 	addi	sp,sp,8
81103348:	f800283a 	ret

8110334c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110334c:	defffb04 	addi	sp,sp,-20
81103350:	de00012e 	bgeu	sp,et,81103358 <sense_log_temp+0xc>
81103354:	003b68fa 	trap	3
81103358:	dfc00415 	stw	ra,16(sp)
8110335c:	df000315 	stw	fp,12(sp)
81103360:	df000304 	addi	fp,sp,12
81103364:	e13ffe15 	stw	r4,-8(fp)
81103368:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110336c:	e17fff17 	ldw	r5,-4(fp)
81103370:	e13ffe17 	ldw	r4,-8(fp)
81103374:	11032540 	call	81103254 <TEMP_Read>
81103378:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110337c:	e0bffd17 	ldw	r2,-12(fp)
}
81103380:	e037883a 	mov	sp,fp
81103384:	dfc00117 	ldw	ra,4(sp)
81103388:	df000017 	ldw	fp,0(sp)
8110338c:	dec00204 	addi	sp,sp,8
81103390:	f800283a 	ret

81103394 <sense_log>:

void sense_log(void) {
81103394:	deff0404 	addi	sp,sp,-1008
81103398:	de00012e 	bgeu	sp,et,811033a0 <sense_log+0xc>
8110339c:	003b68fa 	trap	3
811033a0:	dfc0fb15 	stw	ra,1004(sp)
811033a4:	df00fa15 	stw	fp,1000(sp)
811033a8:	dd40f915 	stw	r21,996(sp)
811033ac:	dd00f815 	stw	r20,992(sp)
811033b0:	dcc0f715 	stw	r19,988(sp)
811033b4:	dc80f615 	stw	r18,984(sp)
811033b8:	dc40f515 	stw	r17,980(sp)
811033bc:	dc00f415 	stw	r16,976(sp)
811033c0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033c4:	00902834 	movhi	r2,16544
811033c8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033cc:	008ed174 	movhi	r2,15173
811033d0:	10a6e984 	addi	r2,r2,-25690
811033d4:	e0bf2215 	stw	r2,-888(fp)
811033d8:	008ea0f4 	movhi	r2,14979
811033dc:	10849bc4 	addi	r2,r2,4719
811033e0:	e0bf2315 	stw	r2,-884(fp)
811033e4:	008ed174 	movhi	r2,15173
811033e8:	10a6e984 	addi	r2,r2,-25690
811033ec:	e0bf2415 	stw	r2,-880(fp)
811033f0:	008ed174 	movhi	r2,15173
811033f4:	10a6e984 	addi	r2,r2,-25690
811033f8:	e0bf2515 	stw	r2,-876(fp)
811033fc:	008ed174 	movhi	r2,15173
81103400:	10a6e984 	addi	r2,r2,-25690
81103404:	e0bf2615 	stw	r2,-872(fp)
81103408:	008ed174 	movhi	r2,15173
8110340c:	10a6e984 	addi	r2,r2,-25690
81103410:	e0bf2715 	stw	r2,-868(fp)
81103414:	008ed174 	movhi	r2,15173
81103418:	10a6e984 	addi	r2,r2,-25690
8110341c:	e0bf2815 	stw	r2,-864(fp)
81103420:	008ed174 	movhi	r2,15173
81103424:	10a6e984 	addi	r2,r2,-25690
81103428:	e0bf2915 	stw	r2,-860(fp)
8110342c:	008ed174 	movhi	r2,15173
81103430:	10a6e984 	addi	r2,r2,-25690
81103434:	e0bf2a15 	stw	r2,-856(fp)
81103438:	008ed174 	movhi	r2,15173
8110343c:	10a6e984 	addi	r2,r2,-25690
81103440:	e0bf2b15 	stw	r2,-852(fp)
81103444:	008ed174 	movhi	r2,15173
81103448:	10a6e984 	addi	r2,r2,-25690
8110344c:	e0bf2c15 	stw	r2,-848(fp)
81103450:	008ed174 	movhi	r2,15173
81103454:	10a6e984 	addi	r2,r2,-25690
81103458:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110345c:	008fd9b4 	movhi	r2,16230
81103460:	10999984 	addi	r2,r2,26214
81103464:	e0bf2e15 	stw	r2,-840(fp)
81103468:	008fd9b4 	movhi	r2,16230
8110346c:	10999984 	addi	r2,r2,26214
81103470:	e0bf2f15 	stw	r2,-836(fp)
81103474:	00901034 	movhi	r2,16448
81103478:	e0bf3015 	stw	r2,-832(fp)
8110347c:	008fd9b4 	movhi	r2,16230
81103480:	10999984 	addi	r2,r2,26214
81103484:	e0bf3115 	stw	r2,-828(fp)
81103488:	008ff9b4 	movhi	r2,16358
8110348c:	10999984 	addi	r2,r2,26214
81103490:	e0bf3215 	stw	r2,-824(fp)
81103494:	00900834 	movhi	r2,16416
81103498:	e0bf3315 	stw	r2,-820(fp)
8110349c:	008ff9b4 	movhi	r2,16358
811034a0:	10999984 	addi	r2,r2,26214
811034a4:	e0bf3415 	stw	r2,-816(fp)
811034a8:	00900834 	movhi	r2,16416
811034ac:	e0bf3515 	stw	r2,-812(fp)
811034b0:	008fe374 	movhi	r2,16269
811034b4:	10b33344 	addi	r2,r2,-13107
811034b8:	e0bf3615 	stw	r2,-808(fp)
811034bc:	008fecf4 	movhi	r2,16307
811034c0:	108cccc4 	addi	r2,r2,13107
811034c4:	e0bf3715 	stw	r2,-804(fp)
811034c8:	009014f4 	movhi	r2,16467
811034cc:	108cccc4 	addi	r2,r2,13107
811034d0:	e0bf3815 	stw	r2,-800(fp)
811034d4:	00900834 	movhi	r2,16416
811034d8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034dc:	00a04534 	movhi	r2,33044
811034e0:	1097a704 	addi	r2,r2,24220
811034e4:	e0ff3a04 	addi	r3,fp,-792
811034e8:	1009883a 	mov	r4,r2
811034ec:	0080c004 	movi	r2,768
811034f0:	100d883a 	mov	r6,r2
811034f4:	200b883a 	mov	r5,r4
811034f8:	1809883a 	mov	r4,r3
811034fc:	111ba100 	call	8111ba10 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103500:	e0bf1604 	addi	r2,fp,-936
81103504:	1009883a 	mov	r4,r2
81103508:	1102f8c0 	call	81102f8c <POWER_Read>
8110350c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103510:	e0bf0f17 	ldw	r2,-964(fp)
81103514:	10016026 	beq	r2,zero,81103a98 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103518:	e03f0c15 	stw	zero,-976(fp)
8110351c:	00014c06 	br	81103a50 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103520:	e0bf0c17 	ldw	r2,-976(fp)
81103524:	1085883a 	add	r2,r2,r2
81103528:	1085883a 	add	r2,r2,r2
8110352c:	e0ff0c04 	addi	r3,fp,-976
81103530:	1885883a 	add	r2,r3,r2
81103534:	10800a04 	addi	r2,r2,40
81103538:	10800017 	ldw	r2,0(r2)
8110353c:	1004d77a 	srli	r2,r2,29
81103540:	1080004c 	andi	r2,r2,1
81103544:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103548:	e0bf0c17 	ldw	r2,-976(fp)
8110354c:	1085883a 	add	r2,r2,r2
81103550:	1085883a 	add	r2,r2,r2
81103554:	e0ff0c04 	addi	r3,fp,-976
81103558:	1885883a 	add	r2,r3,r2
8110355c:	10800a04 	addi	r2,r2,40
81103560:	10800017 	ldw	r2,0(r2)
81103564:	1004d73a 	srli	r2,r2,28
81103568:	1080004c 	andi	r2,r2,1
8110356c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103570:	e0bf0c17 	ldw	r2,-976(fp)
81103574:	1085883a 	add	r2,r2,r2
81103578:	1085883a 	add	r2,r2,r2
8110357c:	e0ff0c04 	addi	r3,fp,-976
81103580:	1885883a 	add	r2,r3,r2
81103584:	10800a04 	addi	r2,r2,40
81103588:	10800017 	ldw	r2,0(r2)
8110358c:	1006d1ba 	srli	r3,r2,6
81103590:	00801034 	movhi	r2,64
81103594:	10bfffc4 	addi	r2,r2,-1
81103598:	1884703a 	and	r2,r3,r2
8110359c:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035a0:	e0bf1117 	ldw	r2,-956(fp)
811035a4:	1000091e 	bne	r2,zero,811035cc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035a8:	e13f1217 	ldw	r4,-952(fp)
811035ac:	1119cc80 	call	81119cc8 <__floatunsisf>
811035b0:	1007883a 	mov	r3,r2
811035b4:	0152a034 	movhi	r5,19072
811035b8:	1809883a 	mov	r4,r3
811035bc:	11193500 	call	81119350 <__divsf3>
811035c0:	1007883a 	mov	r3,r2
811035c4:	e0ff0d15 	stw	r3,-972(fp)
811035c8:	00000106 	br	811035d0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035cc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035d0:	e0bf1017 	ldw	r2,-960(fp)
811035d4:	10002626 	beq	r2,zero,81103670 <sense_log+0x2dc>
811035d8:	e0bf1117 	ldw	r2,-956(fp)
811035dc:	10002426 	beq	r2,zero,81103670 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035e0:	014fc034 	movhi	r5,16128
811035e4:	e13f0e17 	ldw	r4,-968(fp)
811035e8:	11197980 	call	81119798 <__mulsf3>
811035ec:	1007883a 	mov	r3,r2
811035f0:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811035f4:	e0ff3a04 	addi	r3,fp,-792
811035f8:	e0bf0c17 	ldw	r2,-976(fp)
811035fc:	100491ba 	slli	r2,r2,6
81103600:	18a1883a 	add	r16,r3,r2
81103604:	e0bf0c17 	ldw	r2,-976(fp)
81103608:	1085883a 	add	r2,r2,r2
8110360c:	1085883a 	add	r2,r2,r2
81103610:	e0ff0c04 	addi	r3,fp,-976
81103614:	1885883a 	add	r2,r3,r2
81103618:	10800a04 	addi	r2,r2,40
8110361c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103620:	1023883a 	mov	r17,r2
81103624:	e13f1317 	ldw	r4,-948(fp)
81103628:	111a4e00 	call	8111a4e0 <__extendsfdf2>
8110362c:	1009883a 	mov	r4,r2
81103630:	180b883a 	mov	r5,r3
81103634:	d9000015 	stw	r4,0(sp)
81103638:	d9400115 	stw	r5,4(sp)
8110363c:	880f883a 	mov	r7,r17
81103640:	800d883a 	mov	r6,r16
81103644:	01604534 	movhi	r5,33044
81103648:	29577504 	addi	r5,r5,24020
8110364c:	01204574 	movhi	r4,33045
81103650:	2131a904 	addi	r4,r4,-14684
81103654:	111c2f00 	call	8111c2f0 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103658:	d0a05f17 	ldw	r2,-32388(gp)
8110365c:	01604574 	movhi	r5,33045
81103660:	2971a904 	addi	r5,r5,-14684
81103664:	1009883a 	mov	r4,r2
81103668:	111a9600 	call	8111a960 <fprintf>
8110366c:	0000f506 	br	81103a44 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103670:	e0bf1017 	ldw	r2,-960(fp)
81103674:	10006426 	beq	r2,zero,81103808 <sense_log+0x474>
81103678:	e0bf1117 	ldw	r2,-956(fp)
8110367c:	1000621e 	bne	r2,zero,81103808 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103680:	e13f0e17 	ldw	r4,-968(fp)
81103684:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81103688:	1011883a 	mov	r8,r2
8110368c:	1813883a 	mov	r9,r3
81103690:	000d883a 	mov	r6,zero
81103694:	01cff834 	movhi	r7,16352
81103698:	4009883a 	mov	r4,r8
8110369c:	480b883a 	mov	r5,r9
811036a0:	1119dc00 	call	81119dc0 <__muldf3>
811036a4:	1009883a 	mov	r4,r2
811036a8:	180b883a 	mov	r5,r3
811036ac:	2021883a 	mov	r16,r4
811036b0:	2823883a 	mov	r17,r5
811036b4:	e13f0d17 	ldw	r4,-972(fp)
811036b8:	111a4e00 	call	8111a4e0 <__extendsfdf2>
811036bc:	1009883a 	mov	r4,r2
811036c0:	180b883a 	mov	r5,r3
811036c4:	200d883a 	mov	r6,r4
811036c8:	280f883a 	mov	r7,r5
811036cc:	8009883a 	mov	r4,r16
811036d0:	880b883a 	mov	r5,r17
811036d4:	1119dc00 	call	81119dc0 <__muldf3>
811036d8:	1009883a 	mov	r4,r2
811036dc:	180b883a 	mov	r5,r3
811036e0:	2005883a 	mov	r2,r4
811036e4:	2807883a 	mov	r3,r5
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	111a5f80 	call	8111a5f8 <__truncdfsf2>
811036f4:	1007883a 	mov	r3,r2
811036f8:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811036fc:	e0bf0c17 	ldw	r2,-976(fp)
81103700:	1085883a 	add	r2,r2,r2
81103704:	1085883a 	add	r2,r2,r2
81103708:	e0ff0c04 	addi	r3,fp,-976
8110370c:	1885883a 	add	r2,r3,r2
81103710:	10801604 	addi	r2,r2,88
81103714:	10c00017 	ldw	r3,0(r2)
81103718:	180b883a 	mov	r5,r3
8110371c:	e13f0d17 	ldw	r4,-972(fp)
81103720:	11193500 	call	81119350 <__divsf3>
81103724:	1007883a 	mov	r3,r2
81103728:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110372c:	e0bf0c17 	ldw	r2,-976(fp)
81103730:	1085883a 	add	r2,r2,r2
81103734:	1085883a 	add	r2,r2,r2
81103738:	e0ff0c04 	addi	r3,fp,-976
8110373c:	1885883a 	add	r2,r3,r2
81103740:	10802204 	addi	r2,r2,136
81103744:	10c00017 	ldw	r3,0(r2)
81103748:	e17f1417 	ldw	r5,-944(fp)
8110374c:	1809883a 	mov	r4,r3
81103750:	11197980 	call	81119798 <__mulsf3>
81103754:	1007883a 	mov	r3,r2
81103758:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110375c:	e0ff3a04 	addi	r3,fp,-792
81103760:	e0bf0c17 	ldw	r2,-976(fp)
81103764:	100491ba 	slli	r2,r2,6
81103768:	18a9883a 	add	r20,r3,r2
8110376c:	e0bf0c17 	ldw	r2,-976(fp)
81103770:	1085883a 	add	r2,r2,r2
81103774:	1085883a 	add	r2,r2,r2
81103778:	e0ff0c04 	addi	r3,fp,-976
8110377c:	1885883a 	add	r2,r3,r2
81103780:	10800a04 	addi	r2,r2,40
81103784:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103788:	102b883a 	mov	r21,r2
8110378c:	e13f0d17 	ldw	r4,-972(fp)
81103790:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81103794:	1021883a 	mov	r16,r2
81103798:	1823883a 	mov	r17,r3
8110379c:	e13f1417 	ldw	r4,-944(fp)
811037a0:	111a4e00 	call	8111a4e0 <__extendsfdf2>
811037a4:	1025883a 	mov	r18,r2
811037a8:	1827883a 	mov	r19,r3
811037ac:	e13f1517 	ldw	r4,-940(fp)
811037b0:	111a4e00 	call	8111a4e0 <__extendsfdf2>
811037b4:	1009883a 	mov	r4,r2
811037b8:	180b883a 	mov	r5,r3
811037bc:	d9000415 	stw	r4,16(sp)
811037c0:	d9400515 	stw	r5,20(sp)
811037c4:	dc800215 	stw	r18,8(sp)
811037c8:	dcc00315 	stw	r19,12(sp)
811037cc:	dc000015 	stw	r16,0(sp)
811037d0:	dc400115 	stw	r17,4(sp)
811037d4:	a80f883a 	mov	r7,r21
811037d8:	a00d883a 	mov	r6,r20
811037dc:	01604534 	movhi	r5,33044
811037e0:	29577e04 	addi	r5,r5,24056
811037e4:	01204574 	movhi	r4,33045
811037e8:	2131a904 	addi	r4,r4,-14684
811037ec:	111c2f00 	call	8111c2f0 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
811037f0:	d0a05f17 	ldw	r2,-32388(gp)
811037f4:	01604574 	movhi	r5,33045
811037f8:	2971a904 	addi	r5,r5,-14684
811037fc:	1009883a 	mov	r4,r2
81103800:	111a9600 	call	8111a960 <fprintf>
81103804:	00008f06 	br	81103a44 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103808:	e0bf1017 	ldw	r2,-960(fp)
8110380c:	1000641e 	bne	r2,zero,811039a0 <sense_log+0x60c>
81103810:	e0bf1117 	ldw	r2,-956(fp)
81103814:	10006226 	beq	r2,zero,811039a0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103818:	e13f0e17 	ldw	r4,-968(fp)
8110381c:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81103820:	1011883a 	mov	r8,r2
81103824:	1813883a 	mov	r9,r3
81103828:	000d883a 	mov	r6,zero
8110382c:	01cff834 	movhi	r7,16352
81103830:	4009883a 	mov	r4,r8
81103834:	480b883a 	mov	r5,r9
81103838:	1119dc00 	call	81119dc0 <__muldf3>
8110383c:	1009883a 	mov	r4,r2
81103840:	180b883a 	mov	r5,r3
81103844:	2021883a 	mov	r16,r4
81103848:	2823883a 	mov	r17,r5
8110384c:	e13f0d17 	ldw	r4,-972(fp)
81103850:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81103854:	1009883a 	mov	r4,r2
81103858:	180b883a 	mov	r5,r3
8110385c:	200d883a 	mov	r6,r4
81103860:	280f883a 	mov	r7,r5
81103864:	8009883a 	mov	r4,r16
81103868:	880b883a 	mov	r5,r17
8110386c:	1119dc00 	call	81119dc0 <__muldf3>
81103870:	1009883a 	mov	r4,r2
81103874:	180b883a 	mov	r5,r3
81103878:	2005883a 	mov	r2,r4
8110387c:	2807883a 	mov	r3,r5
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	111a5f80 	call	8111a5f8 <__truncdfsf2>
8110388c:	1007883a 	mov	r3,r2
81103890:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
81103894:	e0bf0c17 	ldw	r2,-976(fp)
81103898:	1085883a 	add	r2,r2,r2
8110389c:	1085883a 	add	r2,r2,r2
811038a0:	e0ff0c04 	addi	r3,fp,-976
811038a4:	1885883a 	add	r2,r3,r2
811038a8:	10801604 	addi	r2,r2,88
811038ac:	10c00017 	ldw	r3,0(r2)
811038b0:	180b883a 	mov	r5,r3
811038b4:	e13f0d17 	ldw	r4,-972(fp)
811038b8:	11193500 	call	81119350 <__divsf3>
811038bc:	1007883a 	mov	r3,r2
811038c0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038c4:	e0bf0c17 	ldw	r2,-976(fp)
811038c8:	1085883a 	add	r2,r2,r2
811038cc:	1085883a 	add	r2,r2,r2
811038d0:	e0ff0c04 	addi	r3,fp,-976
811038d4:	1885883a 	add	r2,r3,r2
811038d8:	10802204 	addi	r2,r2,136
811038dc:	10c00017 	ldw	r3,0(r2)
811038e0:	e17f1417 	ldw	r5,-944(fp)
811038e4:	1809883a 	mov	r4,r3
811038e8:	11197980 	call	81119798 <__mulsf3>
811038ec:	1007883a 	mov	r3,r2
811038f0:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
811038f4:	e0ff3a04 	addi	r3,fp,-792
811038f8:	e0bf0c17 	ldw	r2,-976(fp)
811038fc:	100491ba 	slli	r2,r2,6
81103900:	18a9883a 	add	r20,r3,r2
81103904:	e0bf0c17 	ldw	r2,-976(fp)
81103908:	1085883a 	add	r2,r2,r2
8110390c:	1085883a 	add	r2,r2,r2
81103910:	e0ff0c04 	addi	r3,fp,-976
81103914:	1885883a 	add	r2,r3,r2
81103918:	10800a04 	addi	r2,r2,40
8110391c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103920:	102b883a 	mov	r21,r2
81103924:	e13f0d17 	ldw	r4,-972(fp)
81103928:	111a4e00 	call	8111a4e0 <__extendsfdf2>
8110392c:	1021883a 	mov	r16,r2
81103930:	1823883a 	mov	r17,r3
81103934:	e13f1417 	ldw	r4,-944(fp)
81103938:	111a4e00 	call	8111a4e0 <__extendsfdf2>
8110393c:	1025883a 	mov	r18,r2
81103940:	1827883a 	mov	r19,r3
81103944:	e13f1517 	ldw	r4,-940(fp)
81103948:	111a4e00 	call	8111a4e0 <__extendsfdf2>
8110394c:	1009883a 	mov	r4,r2
81103950:	180b883a 	mov	r5,r3
81103954:	d9000415 	stw	r4,16(sp)
81103958:	d9400515 	stw	r5,20(sp)
8110395c:	dc800215 	stw	r18,8(sp)
81103960:	dcc00315 	stw	r19,12(sp)
81103964:	dc000015 	stw	r16,0(sp)
81103968:	dc400115 	stw	r17,4(sp)
8110396c:	a80f883a 	mov	r7,r21
81103970:	a00d883a 	mov	r6,r20
81103974:	01604534 	movhi	r5,33044
81103978:	29578e04 	addi	r5,r5,24120
8110397c:	01204574 	movhi	r4,33045
81103980:	2131a904 	addi	r4,r4,-14684
81103984:	111c2f00 	call	8111c2f0 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103988:	d0a05f17 	ldw	r2,-32388(gp)
8110398c:	01604574 	movhi	r5,33045
81103990:	2971a904 	addi	r5,r5,-14684
81103994:	1009883a 	mov	r4,r2
81103998:	111a9600 	call	8111a960 <fprintf>
8110399c:	00002906 	br	81103a44 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039a0:	e0bf1017 	ldw	r2,-960(fp)
811039a4:	1000271e 	bne	r2,zero,81103a44 <sense_log+0x6b0>
811039a8:	e0bf1117 	ldw	r2,-956(fp)
811039ac:	1000251e 	bne	r2,zero,81103a44 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039b0:	e0bf0e17 	ldw	r2,-968(fp)
811039b4:	10a0003c 	xorhi	r2,r2,32768
811039b8:	014fc034 	movhi	r5,16128
811039bc:	1009883a 	mov	r4,r2
811039c0:	11197980 	call	81119798 <__mulsf3>
811039c4:	1007883a 	mov	r3,r2
811039c8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039cc:	e0ff3a04 	addi	r3,fp,-792
811039d0:	e0bf0c17 	ldw	r2,-976(fp)
811039d4:	100491ba 	slli	r2,r2,6
811039d8:	18a1883a 	add	r16,r3,r2
811039dc:	e0bf0c17 	ldw	r2,-976(fp)
811039e0:	1085883a 	add	r2,r2,r2
811039e4:	1085883a 	add	r2,r2,r2
811039e8:	e0ff0c04 	addi	r3,fp,-976
811039ec:	1885883a 	add	r2,r3,r2
811039f0:	10800a04 	addi	r2,r2,40
811039f4:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
811039f8:	1023883a 	mov	r17,r2
811039fc:	e13f1317 	ldw	r4,-948(fp)
81103a00:	111a4e00 	call	8111a4e0 <__extendsfdf2>
81103a04:	1009883a 	mov	r4,r2
81103a08:	180b883a 	mov	r5,r3
81103a0c:	d9000015 	stw	r4,0(sp)
81103a10:	d9400115 	stw	r5,4(sp)
81103a14:	880f883a 	mov	r7,r17
81103a18:	800d883a 	mov	r6,r16
81103a1c:	01604534 	movhi	r5,33044
81103a20:	29579e04 	addi	r5,r5,24184
81103a24:	01204574 	movhi	r4,33045
81103a28:	2131a904 	addi	r4,r4,-14684
81103a2c:	111c2f00 	call	8111c2f0 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a30:	d0a05f17 	ldw	r2,-32388(gp)
81103a34:	01604574 	movhi	r5,33045
81103a38:	2971a904 	addi	r5,r5,-14684
81103a3c:	1009883a 	mov	r4,r2
81103a40:	111a9600 	call	8111a960 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a44:	e0bf0c17 	ldw	r2,-976(fp)
81103a48:	10800044 	addi	r2,r2,1
81103a4c:	e0bf0c15 	stw	r2,-976(fp)
81103a50:	e0bf0c17 	ldw	r2,-976(fp)
81103a54:	10800308 	cmpgei	r2,r2,12
81103a58:	1000021e 	bne	r2,zero,81103a64 <sense_log+0x6d0>
81103a5c:	e0bf0f17 	ldw	r2,-964(fp)
81103a60:	103eaf1e 	bne	r2,zero,81103520 <__reset+0xfb0e3520>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a64:	00a04574 	movhi	r2,33045
81103a68:	10b1a904 	addi	r2,r2,-14684
81103a6c:	00c00344 	movi	r3,13
81103a70:	10c00005 	stb	r3,0(r2)
81103a74:	00c00284 	movi	r3,10
81103a78:	10c00045 	stb	r3,1(r2)
81103a7c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a80:	d0a05f17 	ldw	r2,-32388(gp)
81103a84:	01604574 	movhi	r5,33045
81103a88:	2971a904 	addi	r5,r5,-14684
81103a8c:	1009883a 	mov	r4,r2
81103a90:	111a9600 	call	8111a960 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103a94:	00001606 	br	81103af0 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103a98:	00a04574 	movhi	r2,33045
81103a9c:	10b1a904 	addi	r2,r2,-14684
81103aa0:	00c01144 	movi	r3,69
81103aa4:	10c00005 	stb	r3,0(r2)
81103aa8:	00c01c84 	movi	r3,114
81103aac:	10c00045 	stb	r3,1(r2)
81103ab0:	00c01c84 	movi	r3,114
81103ab4:	10c00085 	stb	r3,2(r2)
81103ab8:	00c01bc4 	movi	r3,111
81103abc:	10c000c5 	stb	r3,3(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00105 	stb	r3,4(r2)
81103ac8:	00c00344 	movi	r3,13
81103acc:	10c00145 	stb	r3,5(r2)
81103ad0:	00c00284 	movi	r3,10
81103ad4:	10c00185 	stb	r3,6(r2)
81103ad8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103adc:	d0a05f17 	ldw	r2,-32388(gp)
81103ae0:	01604574 	movhi	r5,33045
81103ae4:	2971a904 	addi	r5,r5,-14684
81103ae8:	1009883a 	mov	r4,r2
81103aec:	111a9600 	call	8111a960 <fprintf>
#endif
	}
}
81103af0:	0001883a 	nop
81103af4:	e6fffa04 	addi	sp,fp,-24
81103af8:	dfc00717 	ldw	ra,28(sp)
81103afc:	df000617 	ldw	fp,24(sp)
81103b00:	dd400517 	ldw	r21,20(sp)
81103b04:	dd000417 	ldw	r20,16(sp)
81103b08:	dcc00317 	ldw	r19,12(sp)
81103b0c:	dc800217 	ldw	r18,8(sp)
81103b10:	dc400117 	ldw	r17,4(sp)
81103b14:	dc000017 	ldw	r16,0(sp)
81103b18:	dec00804 	addi	sp,sp,32
81103b1c:	f800283a 	ret

81103b20 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b20:	defffc04 	addi	sp,sp,-16
81103b24:	de00012e 	bgeu	sp,et,81103b2c <bSdmaInitM1Dma+0xc>
81103b28:	003b68fa 	trap	3
81103b2c:	dfc00315 	stw	ra,12(sp)
81103b30:	df000215 	stw	fp,8(sp)
81103b34:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b38:	00800044 	movi	r2,1
81103b3c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b40:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b44:	01204534 	movhi	r4,33044
81103b48:	21186704 	addi	r4,r4,24988
81103b4c:	1143b1c0 	call	81143b1c <alt_msgdma_open>
81103b50:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b54:	d0a03917 	ldw	r2,-32540(gp)
81103b58:	1000021e 	bne	r2,zero,81103b64 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b5c:	e03ffe15 	stw	zero,-8(fp)
81103b60:	00001506 	br	81103bb8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	10800317 	ldw	r2,12(r2)
81103b6c:	10800104 	addi	r2,r2,4
81103b70:	00c00084 	movi	r3,2
81103b74:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b78:	00000a06 	br	81103ba4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b7c:	01000044 	movi	r4,1
81103b80:	1131c380 	call	81131c38 <usleep>
			usiCounter++;
81103b84:	e0bfff0b 	ldhu	r2,-4(fp)
81103b88:	10800044 	addi	r2,r2,1
81103b8c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103b90:	e0bfff0b 	ldhu	r2,-4(fp)
81103b94:	1084e230 	cmpltui	r2,r2,5000
81103b98:	1000021e 	bne	r2,zero,81103ba4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103b9c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103ba0:	00000506 	br	81103bb8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103ba4:	d0a03917 	ldw	r2,-32540(gp)
81103ba8:	10800317 	ldw	r2,12(r2)
81103bac:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bb0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	103ff11e 	bne	r2,zero,81103b7c <__reset+0xfb0e3b7c>
				break;
			}
		}
	}

	return bStatus;
81103bb8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bbc:	e037883a 	mov	sp,fp
81103bc0:	dfc00117 	ldw	ra,4(sp)
81103bc4:	df000017 	ldw	fp,0(sp)
81103bc8:	dec00204 	addi	sp,sp,8
81103bcc:	f800283a 	ret

81103bd0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103bd0:	defffc04 	addi	sp,sp,-16
81103bd4:	de00012e 	bgeu	sp,et,81103bdc <bSdmaInitM2Dma+0xc>
81103bd8:	003b68fa 	trap	3
81103bdc:	dfc00315 	stw	ra,12(sp)
81103be0:	df000215 	stw	fp,8(sp)
81103be4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103be8:	00800044 	movi	r2,1
81103bec:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103bf0:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103bf4:	01204534 	movhi	r4,33044
81103bf8:	21186c04 	addi	r4,r4,25008
81103bfc:	1143b1c0 	call	81143b1c <alt_msgdma_open>
81103c00:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c04:	d0a03a17 	ldw	r2,-32536(gp)
81103c08:	1000021e 	bne	r2,zero,81103c14 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c0c:	e03ffe15 	stw	zero,-8(fp)
81103c10:	00001506 	br	81103c68 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	10800317 	ldw	r2,12(r2)
81103c1c:	10800104 	addi	r2,r2,4
81103c20:	00c00084 	movi	r3,2
81103c24:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c28:	00000a06 	br	81103c54 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c2c:	01000044 	movi	r4,1
81103c30:	1131c380 	call	81131c38 <usleep>
			usiCounter++;
81103c34:	e0bfff0b 	ldhu	r2,-4(fp)
81103c38:	10800044 	addi	r2,r2,1
81103c3c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c40:	e0bfff0b 	ldhu	r2,-4(fp)
81103c44:	1084e230 	cmpltui	r2,r2,5000
81103c48:	1000021e 	bne	r2,zero,81103c54 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c4c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c50:	00000506 	br	81103c68 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c54:	d0a03a17 	ldw	r2,-32536(gp)
81103c58:	10800317 	ldw	r2,12(r2)
81103c5c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c60:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	103ff11e 	bne	r2,zero,81103c2c <__reset+0xfb0e3c2c>
				break;
			}
		}
	}

	return bStatus;
81103c68:	e0bffe17 	ldw	r2,-8(fp)
}
81103c6c:	e037883a 	mov	sp,fp
81103c70:	dfc00117 	ldw	ra,4(sp)
81103c74:	df000017 	ldw	fp,0(sp)
81103c78:	dec00204 	addi	sp,sp,8
81103c7c:	f800283a 	ret

81103c80 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c80:	deffe904 	addi	sp,sp,-92
81103c84:	de00012e 	bgeu	sp,et,81103c8c <bSdmaDmaM1Transfer+0xc>
81103c88:	003b68fa 	trap	3
81103c8c:	dfc01615 	stw	ra,88(sp)
81103c90:	df001515 	stw	fp,84(sp)
81103c94:	dc001415 	stw	r16,80(sp)
81103c98:	df001504 	addi	fp,sp,84
81103c9c:	e13ffb15 	stw	r4,-20(fp)
81103ca0:	2809883a 	mov	r4,r5
81103ca4:	3007883a 	mov	r3,r6
81103ca8:	3805883a 	mov	r2,r7
81103cac:	e13ffc0d 	sth	r4,-16(fp)
81103cb0:	e0fffd05 	stb	r3,-12(fp)
81103cb4:	e0bffe05 	stb	r2,-8(fp)
81103cb8:	defff004 	addi	sp,sp,-64
81103cbc:	d8800904 	addi	r2,sp,36
81103cc0:	108007c4 	addi	r2,r2,31
81103cc4:	1004d17a 	srli	r2,r2,5
81103cc8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103ccc:	00800044 	movi	r2,1
81103cd0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103cd4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103cd8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cdc:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103ce0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103ce4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103ce8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cec:	e0bffe03 	ldbu	r2,-8(fp)
81103cf0:	10c00228 	cmpgeui	r3,r2,8
81103cf4:	1800a41e 	bne	r3,zero,81103f88 <bSdmaDmaM1Transfer+0x308>
81103cf8:	100690ba 	slli	r3,r2,2
81103cfc:	00a04434 	movhi	r2,33040
81103d00:	108f4404 	addi	r2,r2,15632
81103d04:	1885883a 	add	r2,r3,r2
81103d08:	10800017 	ldw	r2,0(r2)
81103d0c:	1000683a 	jmp	r2
81103d10:	81103d30 	cmpltui	r4,r16,16628
81103d14:	81103d74 	orhi	r4,r16,16629
81103d18:	81103dc0 	call	881103dc <__reset+0x20f03dc>
81103d1c:	81103e0c 	andi	r4,r16,16632
81103d20:	81103e58 	cmpnei	r4,r16,16633
81103d24:	81103ea4 	muli	r4,r16,16634
81103d28:	81103ef0 	cmpltui	r4,r16,16635
81103d2c:	81103f3c 	xorhi	r4,r16,16636
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d30:	e0bffd03 	ldbu	r2,-12(fp)
81103d34:	10000326 	beq	r2,zero,81103d44 <bSdmaDmaM1Transfer+0xc4>
81103d38:	10800060 	cmpeqi	r2,r2,1
81103d3c:	1000051e 	bne	r2,zero,81103d54 <bSdmaDmaM1Transfer+0xd4>
81103d40:	00000906 	br	81103d68 <bSdmaDmaM1Transfer+0xe8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d44:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d48:	00800044 	movi	r2,1
81103d4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d50:	00000706 	br	81103d70 <bSdmaDmaM1Transfer+0xf0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d54:	00800074 	movhi	r2,1
81103d58:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d5c:	00800044 	movi	r2,1
81103d60:	e0bff715 	stw	r2,-36(fp)
			break;
81103d64:	00000206 	br	81103d70 <bSdmaDmaM1Transfer+0xf0>
		default:
			bStatus = FALSE;
81103d68:	e03ff415 	stw	zero,-48(fp)
			break;
81103d6c:	0001883a 	nop
		}
		break;
81103d70:	00008706 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d74:	e0bffd03 	ldbu	r2,-12(fp)
81103d78:	10000326 	beq	r2,zero,81103d88 <bSdmaDmaM1Transfer+0x108>
81103d7c:	10800060 	cmpeqi	r2,r2,1
81103d80:	1000061e 	bne	r2,zero,81103d9c <bSdmaDmaM1Transfer+0x11c>
81103d84:	00000b06 	br	81103db4 <bSdmaDmaM1Transfer+0x134>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d88:	00880004 	movi	r2,8192
81103d8c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d90:	00800044 	movi	r2,1
81103d94:	e0bff715 	stw	r2,-36(fp)
			break;
81103d98:	00000806 	br	81103dbc <bSdmaDmaM1Transfer+0x13c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103d9c:	00800074 	movhi	r2,1
81103da0:	10880004 	addi	r2,r2,8192
81103da4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103da8:	00800044 	movi	r2,1
81103dac:	e0bff715 	stw	r2,-36(fp)
			break;
81103db0:	00000206 	br	81103dbc <bSdmaDmaM1Transfer+0x13c>
		default:
			bStatus = FALSE;
81103db4:	e03ff415 	stw	zero,-48(fp)
			break;
81103db8:	0001883a 	nop
		}
		break;
81103dbc:	00007406 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc0:	e0bffd03 	ldbu	r2,-12(fp)
81103dc4:	10000326 	beq	r2,zero,81103dd4 <bSdmaDmaM1Transfer+0x154>
81103dc8:	10800060 	cmpeqi	r2,r2,1
81103dcc:	1000061e 	bne	r2,zero,81103de8 <bSdmaDmaM1Transfer+0x168>
81103dd0:	00000b06 	br	81103e00 <bSdmaDmaM1Transfer+0x180>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd4:	00900004 	movi	r2,16384
81103dd8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103ddc:	00800044 	movi	r2,1
81103de0:	e0bff715 	stw	r2,-36(fp)
			break;
81103de4:	00000806 	br	81103e08 <bSdmaDmaM1Transfer+0x188>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103de8:	00800074 	movhi	r2,1
81103dec:	10900004 	addi	r2,r2,16384
81103df0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df4:	00800044 	movi	r2,1
81103df8:	e0bff715 	stw	r2,-36(fp)
			break;
81103dfc:	00000206 	br	81103e08 <bSdmaDmaM1Transfer+0x188>
		default:
			bStatus = FALSE;
81103e00:	e03ff415 	stw	zero,-48(fp)
			break;
81103e04:	0001883a 	nop
		}
		break;
81103e08:	00006106 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e0c:	e0bffd03 	ldbu	r2,-12(fp)
81103e10:	10000326 	beq	r2,zero,81103e20 <bSdmaDmaM1Transfer+0x1a0>
81103e14:	10800060 	cmpeqi	r2,r2,1
81103e18:	1000061e 	bne	r2,zero,81103e34 <bSdmaDmaM1Transfer+0x1b4>
81103e1c:	00000b06 	br	81103e4c <bSdmaDmaM1Transfer+0x1cc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e20:	00980004 	movi	r2,24576
81103e24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e30:	00000806 	br	81103e54 <bSdmaDmaM1Transfer+0x1d4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e34:	00800074 	movhi	r2,1
81103e38:	10980004 	addi	r2,r2,24576
81103e3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e40:	00800044 	movi	r2,1
81103e44:	e0bff715 	stw	r2,-36(fp)
			break;
81103e48:	00000206 	br	81103e54 <bSdmaDmaM1Transfer+0x1d4>
		default:
			bStatus = FALSE;
81103e4c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e50:	0001883a 	nop
		}
		break;
81103e54:	00004e06 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e58:	e0bffd03 	ldbu	r2,-12(fp)
81103e5c:	10000326 	beq	r2,zero,81103e6c <bSdmaDmaM1Transfer+0x1ec>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	1000061e 	bne	r2,zero,81103e80 <bSdmaDmaM1Transfer+0x200>
81103e68:	00000b06 	br	81103e98 <bSdmaDmaM1Transfer+0x218>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e6c:	00a00014 	movui	r2,32768
81103e70:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e74:	00800044 	movi	r2,1
81103e78:	e0bff715 	stw	r2,-36(fp)
			break;
81103e7c:	00000806 	br	81103ea0 <bSdmaDmaM1Transfer+0x220>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e80:	008000b4 	movhi	r2,2
81103e84:	10a00004 	addi	r2,r2,-32768
81103e88:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e8c:	00800044 	movi	r2,1
81103e90:	e0bff715 	stw	r2,-36(fp)
			break;
81103e94:	00000206 	br	81103ea0 <bSdmaDmaM1Transfer+0x220>
		default:
			bStatus = FALSE;
81103e98:	e03ff415 	stw	zero,-48(fp)
			break;
81103e9c:	0001883a 	nop
		}
		break;
81103ea0:	00003b06 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea4:	e0bffd03 	ldbu	r2,-12(fp)
81103ea8:	10000326 	beq	r2,zero,81103eb8 <bSdmaDmaM1Transfer+0x238>
81103eac:	10800060 	cmpeqi	r2,r2,1
81103eb0:	1000061e 	bne	r2,zero,81103ecc <bSdmaDmaM1Transfer+0x24c>
81103eb4:	00000b06 	br	81103ee4 <bSdmaDmaM1Transfer+0x264>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103eb8:	00a80014 	movui	r2,40960
81103ebc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103ec0:	00800044 	movi	r2,1
81103ec4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec8:	00000806 	br	81103eec <bSdmaDmaM1Transfer+0x26c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ecc:	008000b4 	movhi	r2,2
81103ed0:	10a80004 	addi	r2,r2,-24576
81103ed4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ed8:	00800044 	movi	r2,1
81103edc:	e0bff715 	stw	r2,-36(fp)
			break;
81103ee0:	00000206 	br	81103eec <bSdmaDmaM1Transfer+0x26c>
		default:
			bStatus = FALSE;
81103ee4:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee8:	0001883a 	nop
		}
		break;
81103eec:	00002806 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ef0:	e0bffd03 	ldbu	r2,-12(fp)
81103ef4:	10000326 	beq	r2,zero,81103f04 <bSdmaDmaM1Transfer+0x284>
81103ef8:	10800060 	cmpeqi	r2,r2,1
81103efc:	1000061e 	bne	r2,zero,81103f18 <bSdmaDmaM1Transfer+0x298>
81103f00:	00000b06 	br	81103f30 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f04:	00b00014 	movui	r2,49152
81103f08:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f0c:	00800044 	movi	r2,1
81103f10:	e0bff715 	stw	r2,-36(fp)
			break;
81103f14:	00000806 	br	81103f38 <bSdmaDmaM1Transfer+0x2b8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f18:	008000b4 	movhi	r2,2
81103f1c:	10b00004 	addi	r2,r2,-16384
81103f20:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f24:	00800044 	movi	r2,1
81103f28:	e0bff715 	stw	r2,-36(fp)
			break;
81103f2c:	00000206 	br	81103f38 <bSdmaDmaM1Transfer+0x2b8>
		default:
			bStatus = FALSE;
81103f30:	e03ff415 	stw	zero,-48(fp)
			break;
81103f34:	0001883a 	nop
		}
		break;
81103f38:	00001506 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f3c:	e0bffd03 	ldbu	r2,-12(fp)
81103f40:	10000326 	beq	r2,zero,81103f50 <bSdmaDmaM1Transfer+0x2d0>
81103f44:	10800060 	cmpeqi	r2,r2,1
81103f48:	1000061e 	bne	r2,zero,81103f64 <bSdmaDmaM1Transfer+0x2e4>
81103f4c:	00000b06 	br	81103f7c <bSdmaDmaM1Transfer+0x2fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f50:	00b80014 	movui	r2,57344
81103f54:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f58:	00800044 	movi	r2,1
81103f5c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f60:	00000806 	br	81103f84 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f64:	008000b4 	movhi	r2,2
81103f68:	10b80004 	addi	r2,r2,-8192
81103f6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f70:	00800044 	movi	r2,1
81103f74:	e0bff715 	stw	r2,-36(fp)
			break;
81103f78:	00000206 	br	81103f84 <bSdmaDmaM1Transfer+0x304>
		default:
			bStatus = FALSE;
81103f7c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f80:	0001883a 	nop
		}
		break;
81103f84:	00000206 	br	81103f90 <bSdmaDmaM1Transfer+0x310>
	default:
		bStatus = FALSE;
81103f88:	e03ff415 	stw	zero,-48(fp)
		break;
81103f8c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f90:	e0bffb17 	ldw	r2,-20(fp)
81103f94:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f98:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f9c:	e0bff417 	ldw	r2,-48(fp)
81103fa0:	10003b26 	beq	r2,zero,81104090 <bSdmaDmaM1Transfer+0x410>
		if (pxDmaM1Dev == NULL) {
81103fa4:	d0a03917 	ldw	r2,-32540(gp)
81103fa8:	1000021e 	bne	r2,zero,81103fb4 <bSdmaDmaM1Transfer+0x334>
			bStatus = FALSE;
81103fac:	e03ff415 	stw	zero,-48(fp)
81103fb0:	00003706 	br	81104090 <bSdmaDmaM1Transfer+0x410>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fb4:	e03ff50d 	sth	zero,-44(fp)
81103fb8:	00003206 	br	81104084 <bSdmaDmaM1Transfer+0x404>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fbc:	01000044 	movi	r4,1
81103fc0:	11301c40 	call	811301c4 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fc4:	d0a03917 	ldw	r2,-32540(gp)
81103fc8:	10800317 	ldw	r2,12(r2)
81103fcc:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fd0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fd4:	103ff91e 	bne	r2,zero,81103fbc <__reset+0xfb0e3fbc>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fd8:	d2203917 	ldw	r8,-32540(gp)
81103fdc:	e17ff817 	ldw	r5,-32(fp)
81103fe0:	e1bff617 	ldw	r6,-40(fp)
81103fe4:	e0bff917 	ldw	r2,-28(fp)
81103fe8:	e0fff717 	ldw	r3,-36(fp)
81103fec:	01000044 	movi	r4,1
81103ff0:	d9000815 	stw	r4,32(sp)
81103ff4:	01000044 	movi	r4,1
81103ff8:	d9000715 	stw	r4,28(sp)
81103ffc:	01000044 	movi	r4,1
81104000:	d9000615 	stw	r4,24(sp)
81104004:	01000044 	movi	r4,1
81104008:	d9000515 	stw	r4,20(sp)
8110400c:	01000044 	movi	r4,1
81104010:	d9000415 	stw	r4,16(sp)
81104014:	d8c00315 	stw	r3,12(sp)
81104018:	d8800215 	stw	r2,8(sp)
8110401c:	e0bffa17 	ldw	r2,-24(fp)
81104020:	d8800115 	stw	r2,4(sp)
81104024:	00802204 	movi	r2,136
81104028:	d8800015 	stw	r2,0(sp)
8110402c:	300f883a 	mov	r7,r6
81104030:	280d883a 	mov	r6,r5
81104034:	800b883a 	mov	r5,r16
81104038:	4009883a 	mov	r4,r8
8110403c:	110a93c0 	call	8110a93c <iMsgdmaConstructExtendedMmToMmDescriptor>
81104040:	10000226 	beq	r2,zero,8110404c <bSdmaDmaM1Transfer+0x3cc>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104044:	e03ff415 	stw	zero,-48(fp)
					break;
81104048:	00001106 	br	81104090 <bSdmaDmaM1Transfer+0x410>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110404c:	d0a03917 	ldw	r2,-32540(gp)
81104050:	800b883a 	mov	r5,r16
81104054:	1009883a 	mov	r4,r2
81104058:	110aa400 	call	8110aa40 <iMsgdmaExtendedDescriptorSyncTransfer>
8110405c:	10000226 	beq	r2,zero,81104068 <bSdmaDmaM1Transfer+0x3e8>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104060:	e03ff415 	stw	zero,-48(fp)
						break;
81104064:	00000a06 	br	81104090 <bSdmaDmaM1Transfer+0x410>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104068:	e0bff817 	ldw	r2,-32(fp)
8110406c:	10802204 	addi	r2,r2,136
81104070:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104074:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104078:	e0bff50b 	ldhu	r2,-44(fp)
8110407c:	10800044 	addi	r2,r2,1
81104080:	e0bff50d 	sth	r2,-44(fp)
81104084:	e0fff50b 	ldhu	r3,-44(fp)
81104088:	e0bffc0b 	ldhu	r2,-16(fp)
8110408c:	18bfcd36 	bltu	r3,r2,81103fc4 <__reset+0xfb0e3fc4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104090:	e0bff417 	ldw	r2,-48(fp)
}
81104094:	e6ffff04 	addi	sp,fp,-4
81104098:	dfc00217 	ldw	ra,8(sp)
8110409c:	df000117 	ldw	fp,4(sp)
811040a0:	dc000017 	ldw	r16,0(sp)
811040a4:	dec00304 	addi	sp,sp,12
811040a8:	f800283a 	ret

811040ac <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
811040ac:	deffe904 	addi	sp,sp,-92
811040b0:	de00012e 	bgeu	sp,et,811040b8 <bSdmaDmaM2Transfer+0xc>
811040b4:	003b68fa 	trap	3
811040b8:	dfc01615 	stw	ra,88(sp)
811040bc:	df001515 	stw	fp,84(sp)
811040c0:	dc001415 	stw	r16,80(sp)
811040c4:	df001504 	addi	fp,sp,84
811040c8:	e13ffb15 	stw	r4,-20(fp)
811040cc:	2809883a 	mov	r4,r5
811040d0:	3007883a 	mov	r3,r6
811040d4:	3805883a 	mov	r2,r7
811040d8:	e13ffc0d 	sth	r4,-16(fp)
811040dc:	e0fffd05 	stb	r3,-12(fp)
811040e0:	e0bffe05 	stb	r2,-8(fp)
811040e4:	defff004 	addi	sp,sp,-64
811040e8:	d8800904 	addi	r2,sp,36
811040ec:	108007c4 	addi	r2,r2,31
811040f0:	1004d17a 	srli	r2,r2,5
811040f4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040f8:	00800044 	movi	r2,1
811040fc:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81104100:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104104:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81104108:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
8110410c:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104110:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104114:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104118:	e0bffe03 	ldbu	r2,-8(fp)
8110411c:	10c00228 	cmpgeui	r3,r2,8
81104120:	1800a41e 	bne	r3,zero,811043b4 <bSdmaDmaM2Transfer+0x308>
81104124:	100690ba 	slli	r3,r2,2
81104128:	00a04434 	movhi	r2,33040
8110412c:	10904f04 	addi	r2,r2,16700
81104130:	1885883a 	add	r2,r3,r2
81104134:	10800017 	ldw	r2,0(r2)
81104138:	1000683a 	jmp	r2
8110413c:	8110415c 	xori	r4,r16,16645
81104140:	811041a0 	cmpeqi	r4,r16,16646
81104144:	811041ec 	andhi	r4,r16,16647
81104148:	81104238 	rdprs	r4,r16,16648
8110414c:	81104284 	addi	r4,r16,16650
81104150:	811042d0 	cmplti	r4,r16,16651
81104154:	8110431c 	xori	r4,r16,16652
81104158:	81104368 	cmpgeui	r4,r16,16653
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110415c:	e0bffd03 	ldbu	r2,-12(fp)
81104160:	10000326 	beq	r2,zero,81104170 <bSdmaDmaM2Transfer+0xc4>
81104164:	10800060 	cmpeqi	r2,r2,1
81104168:	1000051e 	bne	r2,zero,81104180 <bSdmaDmaM2Transfer+0xd4>
8110416c:	00000906 	br	81104194 <bSdmaDmaM2Transfer+0xe8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81104170:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104174:	00800044 	movi	r2,1
81104178:	e0bff715 	stw	r2,-36(fp)
			break;
8110417c:	00000706 	br	8110419c <bSdmaDmaM2Transfer+0xf0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81104180:	00800074 	movhi	r2,1
81104184:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104188:	00800044 	movi	r2,1
8110418c:	e0bff715 	stw	r2,-36(fp)
			break;
81104190:	00000206 	br	8110419c <bSdmaDmaM2Transfer+0xf0>
		default:
			bStatus = FALSE;
81104194:	e03ff415 	stw	zero,-48(fp)
			break;
81104198:	0001883a 	nop
		}
		break;
8110419c:	00008706 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811041a0:	e0bffd03 	ldbu	r2,-12(fp)
811041a4:	10000326 	beq	r2,zero,811041b4 <bSdmaDmaM2Transfer+0x108>
811041a8:	10800060 	cmpeqi	r2,r2,1
811041ac:	1000061e 	bne	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x11c>
811041b0:	00000b06 	br	811041e0 <bSdmaDmaM2Transfer+0x134>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
811041b4:	00880004 	movi	r2,8192
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000806 	br	811041e8 <bSdmaDmaM2Transfer+0x13c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041c8:	00800074 	movhi	r2,1
811041cc:	10880004 	addi	r2,r2,8192
811041d0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041d4:	00800044 	movi	r2,1
811041d8:	e0bff715 	stw	r2,-36(fp)
			break;
811041dc:	00000206 	br	811041e8 <bSdmaDmaM2Transfer+0x13c>
		default:
			bStatus = FALSE;
811041e0:	e03ff415 	stw	zero,-48(fp)
			break;
811041e4:	0001883a 	nop
		}
		break;
811041e8:	00007406 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041ec:	e0bffd03 	ldbu	r2,-12(fp)
811041f0:	10000326 	beq	r2,zero,81104200 <bSdmaDmaM2Transfer+0x154>
811041f4:	10800060 	cmpeqi	r2,r2,1
811041f8:	1000061e 	bne	r2,zero,81104214 <bSdmaDmaM2Transfer+0x168>
811041fc:	00000b06 	br	8110422c <bSdmaDmaM2Transfer+0x180>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104200:	00900004 	movi	r2,16384
81104204:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104208:	00800044 	movi	r2,1
8110420c:	e0bff715 	stw	r2,-36(fp)
			break;
81104210:	00000806 	br	81104234 <bSdmaDmaM2Transfer+0x188>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104214:	00800074 	movhi	r2,1
81104218:	10900004 	addi	r2,r2,16384
8110421c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104220:	00800044 	movi	r2,1
81104224:	e0bff715 	stw	r2,-36(fp)
			break;
81104228:	00000206 	br	81104234 <bSdmaDmaM2Transfer+0x188>
		default:
			bStatus = FALSE;
8110422c:	e03ff415 	stw	zero,-48(fp)
			break;
81104230:	0001883a 	nop
		}
		break;
81104234:	00006106 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81104238:	e0bffd03 	ldbu	r2,-12(fp)
8110423c:	10000326 	beq	r2,zero,8110424c <bSdmaDmaM2Transfer+0x1a0>
81104240:	10800060 	cmpeqi	r2,r2,1
81104244:	1000061e 	bne	r2,zero,81104260 <bSdmaDmaM2Transfer+0x1b4>
81104248:	00000b06 	br	81104278 <bSdmaDmaM2Transfer+0x1cc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110424c:	00980004 	movi	r2,24576
81104250:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104254:	00800044 	movi	r2,1
81104258:	e0bff715 	stw	r2,-36(fp)
			break;
8110425c:	00000806 	br	81104280 <bSdmaDmaM2Transfer+0x1d4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104260:	00800074 	movhi	r2,1
81104264:	10980004 	addi	r2,r2,24576
81104268:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8110426c:	00800044 	movi	r2,1
81104270:	e0bff715 	stw	r2,-36(fp)
			break;
81104274:	00000206 	br	81104280 <bSdmaDmaM2Transfer+0x1d4>
		default:
			bStatus = FALSE;
81104278:	e03ff415 	stw	zero,-48(fp)
			break;
8110427c:	0001883a 	nop
		}
		break;
81104280:	00004e06 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104284:	e0bffd03 	ldbu	r2,-12(fp)
81104288:	10000326 	beq	r2,zero,81104298 <bSdmaDmaM2Transfer+0x1ec>
8110428c:	10800060 	cmpeqi	r2,r2,1
81104290:	1000061e 	bne	r2,zero,811042ac <bSdmaDmaM2Transfer+0x200>
81104294:	00000b06 	br	811042c4 <bSdmaDmaM2Transfer+0x218>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104298:	00a00014 	movui	r2,32768
8110429c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811042a0:	00800044 	movi	r2,1
811042a4:	e0bff715 	stw	r2,-36(fp)
			break;
811042a8:	00000806 	br	811042cc <bSdmaDmaM2Transfer+0x220>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
811042ac:	008000b4 	movhi	r2,2
811042b0:	10a00004 	addi	r2,r2,-32768
811042b4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
811042b8:	00800044 	movi	r2,1
811042bc:	e0bff715 	stw	r2,-36(fp)
			break;
811042c0:	00000206 	br	811042cc <bSdmaDmaM2Transfer+0x220>
		default:
			bStatus = FALSE;
811042c4:	e03ff415 	stw	zero,-48(fp)
			break;
811042c8:	0001883a 	nop
		}
		break;
811042cc:	00003b06 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042d0:	e0bffd03 	ldbu	r2,-12(fp)
811042d4:	10000326 	beq	r2,zero,811042e4 <bSdmaDmaM2Transfer+0x238>
811042d8:	10800060 	cmpeqi	r2,r2,1
811042dc:	1000061e 	bne	r2,zero,811042f8 <bSdmaDmaM2Transfer+0x24c>
811042e0:	00000b06 	br	81104310 <bSdmaDmaM2Transfer+0x264>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042e4:	00a80014 	movui	r2,40960
811042e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042ec:	00800044 	movi	r2,1
811042f0:	e0bff715 	stw	r2,-36(fp)
			break;
811042f4:	00000806 	br	81104318 <bSdmaDmaM2Transfer+0x26c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042f8:	008000b4 	movhi	r2,2
811042fc:	10a80004 	addi	r2,r2,-24576
81104300:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104304:	00800044 	movi	r2,1
81104308:	e0bff715 	stw	r2,-36(fp)
			break;
8110430c:	00000206 	br	81104318 <bSdmaDmaM2Transfer+0x26c>
		default:
			bStatus = FALSE;
81104310:	e03ff415 	stw	zero,-48(fp)
			break;
81104314:	0001883a 	nop
		}
		break;
81104318:	00002806 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
8110431c:	e0bffd03 	ldbu	r2,-12(fp)
81104320:	10000326 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x284>
81104324:	10800060 	cmpeqi	r2,r2,1
81104328:	1000061e 	bne	r2,zero,81104344 <bSdmaDmaM2Transfer+0x298>
8110432c:	00000b06 	br	8110435c <bSdmaDmaM2Transfer+0x2b0>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104330:	00b00014 	movui	r2,49152
81104334:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104338:	00800044 	movi	r2,1
8110433c:	e0bff715 	stw	r2,-36(fp)
			break;
81104340:	00000806 	br	81104364 <bSdmaDmaM2Transfer+0x2b8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104344:	008000b4 	movhi	r2,2
81104348:	10b00004 	addi	r2,r2,-16384
8110434c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104350:	00800044 	movi	r2,1
81104354:	e0bff715 	stw	r2,-36(fp)
			break;
81104358:	00000206 	br	81104364 <bSdmaDmaM2Transfer+0x2b8>
		default:
			bStatus = FALSE;
8110435c:	e03ff415 	stw	zero,-48(fp)
			break;
81104360:	0001883a 	nop
		}
		break;
81104364:	00001506 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81104368:	e0bffd03 	ldbu	r2,-12(fp)
8110436c:	10000326 	beq	r2,zero,8110437c <bSdmaDmaM2Transfer+0x2d0>
81104370:	10800060 	cmpeqi	r2,r2,1
81104374:	1000061e 	bne	r2,zero,81104390 <bSdmaDmaM2Transfer+0x2e4>
81104378:	00000b06 	br	811043a8 <bSdmaDmaM2Transfer+0x2fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110437c:	00b80014 	movui	r2,57344
81104380:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104384:	00800044 	movi	r2,1
81104388:	e0bff715 	stw	r2,-36(fp)
			break;
8110438c:	00000806 	br	811043b0 <bSdmaDmaM2Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104390:	008000b4 	movhi	r2,2
81104394:	10b80004 	addi	r2,r2,-8192
81104398:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
8110439c:	00800044 	movi	r2,1
811043a0:	e0bff715 	stw	r2,-36(fp)
			break;
811043a4:	00000206 	br	811043b0 <bSdmaDmaM2Transfer+0x304>
		default:
			bStatus = FALSE;
811043a8:	e03ff415 	stw	zero,-48(fp)
			break;
811043ac:	0001883a 	nop
		}
		break;
811043b0:	00000206 	br	811043bc <bSdmaDmaM2Transfer+0x310>
	default:
		bStatus = FALSE;
811043b4:	e03ff415 	stw	zero,-48(fp)
		break;
811043b8:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
811043bc:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
811043c0:	00a00034 	movhi	r2,32768
811043c4:	1885883a 	add	r2,r3,r2
811043c8:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811043cc:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043d0:	e0bff417 	ldw	r2,-48(fp)
811043d4:	10003b26 	beq	r2,zero,811044c4 <bSdmaDmaM2Transfer+0x418>
		if (pxDmaM2Dev == NULL) {
811043d8:	d0a03a17 	ldw	r2,-32536(gp)
811043dc:	1000021e 	bne	r2,zero,811043e8 <bSdmaDmaM2Transfer+0x33c>
			bStatus = FALSE;
811043e0:	e03ff415 	stw	zero,-48(fp)
811043e4:	00003706 	br	811044c4 <bSdmaDmaM2Transfer+0x418>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043e8:	e03ff50d 	sth	zero,-44(fp)
811043ec:	00003206 	br	811044b8 <bSdmaDmaM2Transfer+0x40c>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043f0:	01000044 	movi	r4,1
811043f4:	11301c40 	call	811301c4 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043f8:	d0a03a17 	ldw	r2,-32536(gp)
811043fc:	10800317 	ldw	r2,12(r2)
81104400:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104404:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104408:	103ff91e 	bne	r2,zero,811043f0 <__reset+0xfb0e43f0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
8110440c:	d2203a17 	ldw	r8,-32536(gp)
81104410:	e17ff817 	ldw	r5,-32(fp)
81104414:	e1bff617 	ldw	r6,-40(fp)
81104418:	e0bff917 	ldw	r2,-28(fp)
8110441c:	e0fff717 	ldw	r3,-36(fp)
81104420:	01000044 	movi	r4,1
81104424:	d9000815 	stw	r4,32(sp)
81104428:	01000044 	movi	r4,1
8110442c:	d9000715 	stw	r4,28(sp)
81104430:	01000044 	movi	r4,1
81104434:	d9000615 	stw	r4,24(sp)
81104438:	01000044 	movi	r4,1
8110443c:	d9000515 	stw	r4,20(sp)
81104440:	01000044 	movi	r4,1
81104444:	d9000415 	stw	r4,16(sp)
81104448:	d8c00315 	stw	r3,12(sp)
8110444c:	d8800215 	stw	r2,8(sp)
81104450:	e0bffa17 	ldw	r2,-24(fp)
81104454:	d8800115 	stw	r2,4(sp)
81104458:	00802204 	movi	r2,136
8110445c:	d8800015 	stw	r2,0(sp)
81104460:	300f883a 	mov	r7,r6
81104464:	280d883a 	mov	r6,r5
81104468:	800b883a 	mov	r5,r16
8110446c:	4009883a 	mov	r4,r8
81104470:	110a93c0 	call	8110a93c <iMsgdmaConstructExtendedMmToMmDescriptor>
81104474:	10000226 	beq	r2,zero,81104480 <bSdmaDmaM2Transfer+0x3d4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104478:	e03ff415 	stw	zero,-48(fp)
					break;
8110447c:	00001106 	br	811044c4 <bSdmaDmaM2Transfer+0x418>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104480:	d0a03a17 	ldw	r2,-32536(gp)
81104484:	800b883a 	mov	r5,r16
81104488:	1009883a 	mov	r4,r2
8110448c:	110aa400 	call	8110aa40 <iMsgdmaExtendedDescriptorSyncTransfer>
81104490:	10000226 	beq	r2,zero,8110449c <bSdmaDmaM2Transfer+0x3f0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104494:	e03ff415 	stw	zero,-48(fp)
						break;
81104498:	00000a06 	br	811044c4 <bSdmaDmaM2Transfer+0x418>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110449c:	e0bff817 	ldw	r2,-32(fp)
811044a0:	10802204 	addi	r2,r2,136
811044a4:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044a8:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811044ac:	e0bff50b 	ldhu	r2,-44(fp)
811044b0:	10800044 	addi	r2,r2,1
811044b4:	e0bff50d 	sth	r2,-44(fp)
811044b8:	e0fff50b 	ldhu	r3,-44(fp)
811044bc:	e0bffc0b 	ldhu	r2,-16(fp)
811044c0:	18bfcd36 	bltu	r3,r2,811043f8 <__reset+0xfb0e43f8>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
811044c4:	e0bff417 	ldw	r2,-48(fp)
}
811044c8:	e6ffff04 	addi	sp,fp,-4
811044cc:	dfc00217 	ldw	ra,8(sp)
811044d0:	df000117 	ldw	fp,4(sp)
811044d4:	dc000017 	ldw	r16,0(sp)
811044d8:	dec00304 	addi	sp,sp,12
811044dc:	f800283a 	ret

811044e0 <bCommInitCh>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811044e0:	defffb04 	addi	sp,sp,-20
811044e4:	de00012e 	bgeu	sp,et,811044ec <bCommInitCh+0xc>
811044e8:	003b68fa 	trap	3
811044ec:	dfc00415 	stw	ra,16(sp)
811044f0:	df000315 	stw	fp,12(sp)
811044f4:	df000304 	addi	fp,sp,12
811044f8:	e13ffe15 	stw	r4,-8(fp)
811044fc:	2805883a 	mov	r2,r5
81104500:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104504:	e03ffd15 	stw	zero,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104508:	e0bffe17 	ldw	r2,-8(fp)
8110450c:	10805604 	addi	r2,r2,344
81104510:	e0ffff03 	ldbu	r3,-4(fp)
81104514:	180b883a 	mov	r5,r3
81104518:	1009883a 	mov	r4,r2
8110451c:	11092c00 	call	811092c0 <bSpwcInitCh>
81104520:	1000011e 	bne	r2,zero,81104528 <bCommInitCh+0x48>
		bStatus = FALSE;
81104524:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
81104528:	e0bfff03 	ldbu	r2,-4(fp)
8110452c:	1009883a 	mov	r4,r2
81104530:	11054d80 	call	811054d8 <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104534:	e0bffe17 	ldw	r2,-8(fp)
81104538:	10800904 	addi	r2,r2,36
8110453c:	e0ffff03 	ldbu	r3,-4(fp)
81104540:	180b883a 	mov	r5,r3
81104544:	1009883a 	mov	r4,r2
81104548:	1105bd00 	call	81105bd0 <bFeebInitCh>
8110454c:	1000011e 	bne	r2,zero,81104554 <bCommInitCh+0x74>
		bStatus = FALSE;
81104550:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104554:	e0bffe17 	ldw	r2,-8(fp)
81104558:	10801004 	addi	r2,r2,64
8110455c:	e0ffff03 	ldbu	r3,-4(fp)
81104560:	180b883a 	mov	r5,r3
81104564:	1009883a 	mov	r4,r2
81104568:	110891c0 	call	8110891c <bRmapInitCh>
8110456c:	1000011e 	bne	r2,zero,81104574 <bCommInitCh+0x94>
		bStatus = FALSE;
81104570:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104574:	e0bfff03 	ldbu	r2,-4(fp)
81104578:	1009883a 	mov	r4,r2
8110457c:	11067580 	call	81106758 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81104580:	e0bffe17 	ldw	r2,-8(fp)
81104584:	10800104 	addi	r2,r2,4
81104588:	e0ffff03 	ldbu	r3,-4(fp)
8110458c:	180b883a 	mov	r5,r3
81104590:	1009883a 	mov	r4,r2
81104594:	1104be00 	call	81104be0 <bDpktInitCh>
81104598:	1000011e 	bne	r2,zero,811045a0 <bCommInitCh+0xc0>
		bStatus = FALSE;
8110459c:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
811045a0:	e0bffd17 	ldw	r2,-12(fp)
}
811045a4:	e037883a 	mov	sp,fp
811045a8:	dfc00117 	ldw	ra,4(sp)
811045ac:	df000017 	ldw	fp,0(sp)
811045b0:	dec00204 	addi	sp,sp,8
811045b4:	f800283a 	ret

811045b8 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
811045b8:	defffb04 	addi	sp,sp,-20
811045bc:	de00012e 	bgeu	sp,et,811045c4 <bDpktSetPacketConfig+0xc>
811045c0:	003b68fa 	trap	3
811045c4:	dfc00415 	stw	ra,16(sp)
811045c8:	df000315 	stw	fp,12(sp)
811045cc:	df000304 	addi	fp,sp,12
811045d0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811045d4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811045d8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811045dc:	e0bfff17 	ldw	r2,-4(fp)
811045e0:	10007a26 	beq	r2,zero,811047cc <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811045e4:	e0bfff17 	ldw	r2,-4(fp)
811045e8:	10800017 	ldw	r2,0(r2)
811045ec:	01400204 	movi	r5,8
811045f0:	1009883a 	mov	r4,r2
811045f4:	1104da80 	call	81104da8 <uliDpktReadReg>
811045f8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
811045fc:	e0bffe17 	ldw	r2,-8(fp)
81104600:	10bfffec 	andhi	r2,r2,65535
81104604:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104608:	e0bfff17 	ldw	r2,-4(fp)
8110460c:	1080010b 	ldhu	r2,4(r2)
81104610:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104614:	e0fffe17 	ldw	r3,-8(fp)
81104618:	1884b03a 	or	r2,r3,r2
8110461c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104620:	e0bffe17 	ldw	r2,-8(fp)
81104624:	10bfffcc 	andi	r2,r2,65535
81104628:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
8110462c:	e0bfff17 	ldw	r2,-4(fp)
81104630:	1080018b 	ldhu	r2,6(r2)
81104634:	10bfffcc 	andi	r2,r2,65535
81104638:	1004943a 	slli	r2,r2,16
8110463c:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104640:	e0bffe17 	ldw	r2,-8(fp)
81104644:	10c4b03a 	or	r2,r2,r3
81104648:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
8110464c:	e0bfff17 	ldw	r2,-4(fp)
81104650:	10800017 	ldw	r2,0(r2)
81104654:	e1bffe17 	ldw	r6,-8(fp)
81104658:	01400204 	movi	r5,8
8110465c:	1009883a 	mov	r4,r2
81104660:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104664:	e0bfff17 	ldw	r2,-4(fp)
81104668:	10800017 	ldw	r2,0(r2)
8110466c:	01400244 	movi	r5,9
81104670:	1009883a 	mov	r4,r2
81104674:	1104da80 	call	81104da8 <uliDpktReadReg>
81104678:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
8110467c:	e0bffe17 	ldw	r2,-8(fp)
81104680:	10bfffec 	andhi	r2,r2,65535
81104684:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
81104688:	e0bfff17 	ldw	r2,-4(fp)
8110468c:	1080020b 	ldhu	r2,8(r2)
81104690:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104694:	e0fffe17 	ldw	r3,-8(fp)
81104698:	1884b03a 	or	r2,r3,r2
8110469c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
811046a0:	e0bffe17 	ldw	r2,-8(fp)
811046a4:	10bfffcc 	andi	r2,r2,65535
811046a8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
811046ac:	e0bfff17 	ldw	r2,-4(fp)
811046b0:	1080028b 	ldhu	r2,10(r2)
										<< 16));
811046b4:	10bfffcc 	andi	r2,r2,65535
811046b8:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
811046bc:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
811046c0:	e0bffe17 	ldw	r2,-8(fp)
811046c4:	10c4b03a 	or	r2,r2,r3
811046c8:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
811046cc:	e0bfff17 	ldw	r2,-4(fp)
811046d0:	10800017 	ldw	r2,0(r2)
811046d4:	e1bffe17 	ldw	r6,-8(fp)
811046d8:	01400244 	movi	r5,9
811046dc:	1009883a 	mov	r4,r2
811046e0:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811046e4:	e0bfff17 	ldw	r2,-4(fp)
811046e8:	10800017 	ldw	r2,0(r2)
811046ec:	01400284 	movi	r5,10
811046f0:	1009883a 	mov	r4,r2
811046f4:	1104da80 	call	81104da8 <uliDpktReadReg>
811046f8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
811046fc:	e0bffe17 	ldw	r2,-8(fp)
81104700:	10bfffec 	andhi	r2,r2,65535
81104704:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104708:	e0bfff17 	ldw	r2,-4(fp)
8110470c:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104710:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104714:	e0fffe17 	ldw	r3,-8(fp)
81104718:	1884b03a 	or	r2,r3,r2
8110471c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104720:	e0bfff17 	ldw	r2,-4(fp)
81104724:	10800017 	ldw	r2,0(r2)
81104728:	e1bffe17 	ldw	r6,-8(fp)
8110472c:	01400284 	movi	r5,10
81104730:	1009883a 	mov	r4,r2
81104734:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104738:	e0bfff17 	ldw	r2,-4(fp)
8110473c:	10800017 	ldw	r2,0(r2)
81104740:	014002c4 	movi	r5,11
81104744:	1009883a 	mov	r4,r2
81104748:	1104da80 	call	81104da8 <uliDpktReadReg>
8110474c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104750:	e0fffe17 	ldw	r3,-8(fp)
81104754:	00bfc004 	movi	r2,-256
81104758:	1884703a 	and	r2,r3,r2
8110475c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104760:	e0bfff17 	ldw	r2,-4(fp)
81104764:	10800383 	ldbu	r2,14(r2)
81104768:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
8110476c:	e0fffe17 	ldw	r3,-8(fp)
81104770:	1884b03a 	or	r2,r3,r2
81104774:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81104778:	e0fffe17 	ldw	r3,-8(fp)
8110477c:	00bffff4 	movhi	r2,65535
81104780:	10803fc4 	addi	r2,r2,255
81104784:	1884703a 	and	r2,r3,r2
81104788:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
8110478c:	e0bfff17 	ldw	r2,-4(fp)
81104790:	108003c3 	ldbu	r2,15(r2)
81104794:	10803fcc 	andi	r2,r2,255
81104798:	1004923a 	slli	r2,r2,8
8110479c:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
811047a0:	e0fffe17 	ldw	r3,-8(fp)
811047a4:	1884b03a 	or	r2,r3,r2
811047a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
811047ac:	e0bfff17 	ldw	r2,-4(fp)
811047b0:	10800017 	ldw	r2,0(r2)
811047b4:	e1bffe17 	ldw	r6,-8(fp)
811047b8:	014002c4 	movi	r5,11
811047bc:	1009883a 	mov	r4,r2
811047c0:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
811047c4:	00800044 	movi	r2,1
811047c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811047cc:	e0bffd17 	ldw	r2,-12(fp)
}
811047d0:	e037883a 	mov	sp,fp
811047d4:	dfc00117 	ldw	ra,4(sp)
811047d8:	df000017 	ldw	fp,0(sp)
811047dc:	dec00204 	addi	sp,sp,8
811047e0:	f800283a 	ret

811047e4 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
811047e4:	defffb04 	addi	sp,sp,-20
811047e8:	de00012e 	bgeu	sp,et,811047f0 <bDpktGetPacketConfig+0xc>
811047ec:	003b68fa 	trap	3
811047f0:	dfc00415 	stw	ra,16(sp)
811047f4:	df000315 	stw	fp,12(sp)
811047f8:	df000304 	addi	fp,sp,12
811047fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104800:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104804:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104808:	e0bfff17 	ldw	r2,-4(fp)
8110480c:	10003a26 	beq	r2,zero,811048f8 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104810:	e0bfff17 	ldw	r2,-4(fp)
81104814:	10800017 	ldw	r2,0(r2)
81104818:	01400204 	movi	r5,8
8110481c:	1009883a 	mov	r4,r2
81104820:	1104da80 	call	81104da8 <uliDpktReadReg>
81104824:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104828:	e0bffe17 	ldw	r2,-8(fp)
8110482c:	1007883a 	mov	r3,r2
81104830:	e0bfff17 	ldw	r2,-4(fp)
81104834:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104838:	e0bffe17 	ldw	r2,-8(fp)
8110483c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104840:	1007883a 	mov	r3,r2
81104844:	e0bfff17 	ldw	r2,-4(fp)
81104848:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110484c:	e0bfff17 	ldw	r2,-4(fp)
81104850:	10800017 	ldw	r2,0(r2)
81104854:	01400244 	movi	r5,9
81104858:	1009883a 	mov	r4,r2
8110485c:	1104da80 	call	81104da8 <uliDpktReadReg>
81104860:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104864:	e0bffe17 	ldw	r2,-8(fp)
81104868:	1007883a 	mov	r3,r2
8110486c:	e0bfff17 	ldw	r2,-4(fp)
81104870:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104874:	e0bffe17 	ldw	r2,-8(fp)
81104878:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
8110487c:	1007883a 	mov	r3,r2
81104880:	e0bfff17 	ldw	r2,-4(fp)
81104884:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104888:	e0bfff17 	ldw	r2,-4(fp)
8110488c:	10800017 	ldw	r2,0(r2)
81104890:	01400284 	movi	r5,10
81104894:	1009883a 	mov	r4,r2
81104898:	1104da80 	call	81104da8 <uliDpktReadReg>
8110489c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
811048a0:	e0bffe17 	ldw	r2,-8(fp)
811048a4:	1007883a 	mov	r3,r2
811048a8:	e0bfff17 	ldw	r2,-4(fp)
811048ac:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048b0:	e0bfff17 	ldw	r2,-4(fp)
811048b4:	10800017 	ldw	r2,0(r2)
811048b8:	014002c4 	movi	r5,11
811048bc:	1009883a 	mov	r4,r2
811048c0:	1104da80 	call	81104da8 <uliDpktReadReg>
811048c4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
811048c8:	e0bffe17 	ldw	r2,-8(fp)
811048cc:	1007883a 	mov	r3,r2
811048d0:	e0bfff17 	ldw	r2,-4(fp)
811048d4:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
811048d8:	e0bffe17 	ldw	r2,-8(fp)
811048dc:	10bfc00c 	andi	r2,r2,65280
811048e0:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
811048e4:	1007883a 	mov	r3,r2
811048e8:	e0bfff17 	ldw	r2,-4(fp)
811048ec:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
811048f0:	00800044 	movi	r2,1
811048f4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811048f8:	e0bffd17 	ldw	r2,-12(fp)
}
811048fc:	e037883a 	mov	sp,fp
81104900:	dfc00117 	ldw	ra,4(sp)
81104904:	df000017 	ldw	fp,0(sp)
81104908:	dec00204 	addi	sp,sp,8
8110490c:	f800283a 	ret

81104910 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104910:	defffb04 	addi	sp,sp,-20
81104914:	de00012e 	bgeu	sp,et,8110491c <bDpktGetPacketHeader+0xc>
81104918:	003b68fa 	trap	3
8110491c:	dfc00415 	stw	ra,16(sp)
81104920:	df000315 	stw	fp,12(sp)
81104924:	df000304 	addi	fp,sp,12
81104928:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110492c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104930:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104934:	e0bfff17 	ldw	r2,-4(fp)
81104938:	10002026 	beq	r2,zero,811049bc <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110493c:	e0bfff17 	ldw	r2,-4(fp)
81104940:	10800017 	ldw	r2,0(r2)
81104944:	01400304 	movi	r5,12
81104948:	1009883a 	mov	r4,r2
8110494c:	1104da80 	call	81104da8 <uliDpktReadReg>
81104950:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104954:	e0bffe17 	ldw	r2,-8(fp)
81104958:	1007883a 	mov	r3,r2
8110495c:	e0bfff17 	ldw	r2,-4(fp)
81104960:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104964:	e0bffe17 	ldw	r2,-8(fp)
81104968:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
8110496c:	1007883a 	mov	r3,r2
81104970:	e0bfff17 	ldw	r2,-4(fp)
81104974:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104978:	e0bfff17 	ldw	r2,-4(fp)
8110497c:	10800017 	ldw	r2,0(r2)
81104980:	01400344 	movi	r5,13
81104984:	1009883a 	mov	r4,r2
81104988:	1104da80 	call	81104da8 <uliDpktReadReg>
8110498c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104990:	e0bffe17 	ldw	r2,-8(fp)
81104994:	1007883a 	mov	r3,r2
81104998:	e0bfff17 	ldw	r2,-4(fp)
8110499c:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
811049a0:	e0bffe17 	ldw	r2,-8(fp)
811049a4:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
811049a8:	1007883a 	mov	r3,r2
811049ac:	e0bfff17 	ldw	r2,-4(fp)
811049b0:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
811049b4:	00800044 	movi	r2,1
811049b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811049bc:	e0bffd17 	ldw	r2,-12(fp)
}
811049c0:	e037883a 	mov	sp,fp
811049c4:	dfc00117 	ldw	ra,4(sp)
811049c8:	df000017 	ldw	fp,0(sp)
811049cc:	dec00204 	addi	sp,sp,8
811049d0:	f800283a 	ret

811049d4 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
811049d4:	defffb04 	addi	sp,sp,-20
811049d8:	de00012e 	bgeu	sp,et,811049e0 <bDpktSetPixelDelay+0xc>
811049dc:	003b68fa 	trap	3
811049e0:	dfc00415 	stw	ra,16(sp)
811049e4:	df000315 	stw	fp,12(sp)
811049e8:	df000304 	addi	fp,sp,12
811049ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811049f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811049f8:	e0bfff17 	ldw	r2,-4(fp)
811049fc:	10004126 	beq	r2,zero,81104b04 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a00:	e0bfff17 	ldw	r2,-4(fp)
81104a04:	10800017 	ldw	r2,0(r2)
81104a08:	01400384 	movi	r5,14
81104a0c:	1009883a 	mov	r4,r2
81104a10:	1104da80 	call	81104da8 <uliDpktReadReg>
81104a14:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104a18:	e0bffe17 	ldw	r2,-8(fp)
81104a1c:	10bfffec 	andhi	r2,r2,65535
81104a20:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104a24:	e0bfff17 	ldw	r2,-4(fp)
81104a28:	1080060b 	ldhu	r2,24(r2)
81104a2c:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104a30:	e0fffe17 	ldw	r3,-8(fp)
81104a34:	1884b03a 	or	r2,r3,r2
81104a38:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104a3c:	e0bfff17 	ldw	r2,-4(fp)
81104a40:	10800017 	ldw	r2,0(r2)
81104a44:	e1bffe17 	ldw	r6,-8(fp)
81104a48:	01400384 	movi	r5,14
81104a4c:	1009883a 	mov	r4,r2
81104a50:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a54:	e0bfff17 	ldw	r2,-4(fp)
81104a58:	10800017 	ldw	r2,0(r2)
81104a5c:	014003c4 	movi	r5,15
81104a60:	1009883a 	mov	r4,r2
81104a64:	1104da80 	call	81104da8 <uliDpktReadReg>
81104a68:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104a6c:	e0bffe17 	ldw	r2,-8(fp)
81104a70:	10bfffec 	andhi	r2,r2,65535
81104a74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104a78:	e0bfff17 	ldw	r2,-4(fp)
81104a7c:	1080068b 	ldhu	r2,26(r2)
81104a80:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104a84:	e0fffe17 	ldw	r3,-8(fp)
81104a88:	1884b03a 	or	r2,r3,r2
81104a8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104a90:	e0bfff17 	ldw	r2,-4(fp)
81104a94:	10800017 	ldw	r2,0(r2)
81104a98:	e1bffe17 	ldw	r6,-8(fp)
81104a9c:	014003c4 	movi	r5,15
81104aa0:	1009883a 	mov	r4,r2
81104aa4:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104aa8:	e0bfff17 	ldw	r2,-4(fp)
81104aac:	10800017 	ldw	r2,0(r2)
81104ab0:	01400404 	movi	r5,16
81104ab4:	1009883a 	mov	r4,r2
81104ab8:	1104da80 	call	81104da8 <uliDpktReadReg>
81104abc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ac0:	e0bffe17 	ldw	r2,-8(fp)
81104ac4:	10bfffec 	andhi	r2,r2,65535
81104ac8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	1080070b 	ldhu	r2,28(r2)
81104ad4:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104ad8:	e0fffe17 	ldw	r3,-8(fp)
81104adc:	1884b03a 	or	r2,r3,r2
81104ae0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104ae4:	e0bfff17 	ldw	r2,-4(fp)
81104ae8:	10800017 	ldw	r2,0(r2)
81104aec:	e1bffe17 	ldw	r6,-8(fp)
81104af0:	01400404 	movi	r5,16
81104af4:	1009883a 	mov	r4,r2
81104af8:	1104d540 	call	81104d54 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104afc:	00800044 	movi	r2,1
81104b00:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b04:	e0bffd17 	ldw	r2,-12(fp)
}
81104b08:	e037883a 	mov	sp,fp
81104b0c:	dfc00117 	ldw	ra,4(sp)
81104b10:	df000017 	ldw	fp,0(sp)
81104b14:	dec00204 	addi	sp,sp,8
81104b18:	f800283a 	ret

81104b1c <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104b1c:	defffb04 	addi	sp,sp,-20
81104b20:	de00012e 	bgeu	sp,et,81104b28 <bDpktGetPixelDelay+0xc>
81104b24:	003b68fa 	trap	3
81104b28:	dfc00415 	stw	ra,16(sp)
81104b2c:	df000315 	stw	fp,12(sp)
81104b30:	df000304 	addi	fp,sp,12
81104b34:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b38:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b3c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b40:	e0bfff17 	ldw	r2,-4(fp)
81104b44:	10002026 	beq	r2,zero,81104bc8 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b48:	e0bfff17 	ldw	r2,-4(fp)
81104b4c:	10800017 	ldw	r2,0(r2)
81104b50:	01400384 	movi	r5,14
81104b54:	1009883a 	mov	r4,r2
81104b58:	1104da80 	call	81104da8 <uliDpktReadReg>
81104b5c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104b60:	e0bffe17 	ldw	r2,-8(fp)
81104b64:	1007883a 	mov	r3,r2
81104b68:	e0bfff17 	ldw	r2,-4(fp)
81104b6c:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b70:	e0bfff17 	ldw	r2,-4(fp)
81104b74:	10800017 	ldw	r2,0(r2)
81104b78:	014003c4 	movi	r5,15
81104b7c:	1009883a 	mov	r4,r2
81104b80:	1104da80 	call	81104da8 <uliDpktReadReg>
81104b84:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104b88:	e0bffe17 	ldw	r2,-8(fp)
81104b8c:	1007883a 	mov	r3,r2
81104b90:	e0bfff17 	ldw	r2,-4(fp)
81104b94:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b98:	e0bfff17 	ldw	r2,-4(fp)
81104b9c:	10800017 	ldw	r2,0(r2)
81104ba0:	01400404 	movi	r5,16
81104ba4:	1009883a 	mov	r4,r2
81104ba8:	1104da80 	call	81104da8 <uliDpktReadReg>
81104bac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104bb0:	e0bffe17 	ldw	r2,-8(fp)
81104bb4:	1007883a 	mov	r3,r2
81104bb8:	e0bfff17 	ldw	r2,-4(fp)
81104bbc:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104bc0:	00800044 	movi	r2,1
81104bc4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104bc8:	e0bffd17 	ldw	r2,-12(fp)
}
81104bcc:	e037883a 	mov	sp,fp
81104bd0:	dfc00117 	ldw	ra,4(sp)
81104bd4:	df000017 	ldw	fp,0(sp)
81104bd8:	dec00204 	addi	sp,sp,8
81104bdc:	f800283a 	ret

81104be0 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104be0:	defffb04 	addi	sp,sp,-20
81104be4:	de00012e 	bgeu	sp,et,81104bec <bDpktInitCh+0xc>
81104be8:	003b68fa 	trap	3
81104bec:	dfc00415 	stw	ra,16(sp)
81104bf0:	df000315 	stw	fp,12(sp)
81104bf4:	df000304 	addi	fp,sp,12
81104bf8:	e13ffe15 	stw	r4,-8(fp)
81104bfc:	2805883a 	mov	r2,r5
81104c00:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104c04:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104c08:	e0bffe17 	ldw	r2,-8(fp)
81104c0c:	10004b26 	beq	r2,zero,81104d3c <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104c10:	00800044 	movi	r2,1
81104c14:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104c18:	e0bfff03 	ldbu	r2,-4(fp)
81104c1c:	10c00228 	cmpgeui	r3,r2,8
81104c20:	1800361e 	bne	r3,zero,81104cfc <bDpktInitCh+0x11c>
81104c24:	100690ba 	slli	r3,r2,2
81104c28:	00a04434 	movhi	r2,33040
81104c2c:	10930f04 	addi	r2,r2,19516
81104c30:	1885883a 	add	r2,r3,r2
81104c34:	10800017 	ldw	r2,0(r2)
81104c38:	1000683a 	jmp	r2
81104c3c:	81104c5c 	xori	r4,r16,16689
81104c40:	81104c70 	cmpltui	r4,r16,16689
81104c44:	81104c84 	addi	r4,r16,16690
81104c48:	81104c98 	cmpnei	r4,r16,16690
81104c4c:	81104cac 	andhi	r4,r16,16690
81104c50:	81104cc0 	call	881104cc <__reset+0x20f04cc>
81104c54:	81104cd4 	ori	r4,r16,16691
81104c58:	81104ce8 	cmpgeui	r4,r16,16691
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104c5c:	e0fffe17 	ldw	r3,-8(fp)
81104c60:	00a04834 	movhi	r2,33056
81104c64:	108b0004 	addi	r2,r2,11264
81104c68:	18800015 	stw	r2,0(r3)
			break;
81104c6c:	00002506 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104c70:	e0fffe17 	ldw	r3,-8(fp)
81104c74:	00a04834 	movhi	r2,33056
81104c78:	108a0004 	addi	r2,r2,10240
81104c7c:	18800015 	stw	r2,0(r3)
			break;
81104c80:	00002006 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104c84:	e0fffe17 	ldw	r3,-8(fp)
81104c88:	00a04834 	movhi	r2,33056
81104c8c:	10890004 	addi	r2,r2,9216
81104c90:	18800015 	stw	r2,0(r3)
			break;
81104c94:	00001b06 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104c98:	e0fffe17 	ldw	r3,-8(fp)
81104c9c:	00a04834 	movhi	r2,33056
81104ca0:	10880004 	addi	r2,r2,8192
81104ca4:	18800015 	stw	r2,0(r3)
			break;
81104ca8:	00001606 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104cac:	e0fffe17 	ldw	r3,-8(fp)
81104cb0:	00a04834 	movhi	r2,33056
81104cb4:	10870004 	addi	r2,r2,7168
81104cb8:	18800015 	stw	r2,0(r3)
			break;
81104cbc:	00001106 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104cc0:	e0fffe17 	ldw	r3,-8(fp)
81104cc4:	00a04834 	movhi	r2,33056
81104cc8:	10860004 	addi	r2,r2,6144
81104ccc:	18800015 	stw	r2,0(r3)
			break;
81104cd0:	00000c06 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104cd4:	e0fffe17 	ldw	r3,-8(fp)
81104cd8:	00a04834 	movhi	r2,33056
81104cdc:	10850004 	addi	r2,r2,5120
81104ce0:	18800015 	stw	r2,0(r3)
			break;
81104ce4:	00000706 	br	81104d04 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104ce8:	e0fffe17 	ldw	r3,-8(fp)
81104cec:	00a04834 	movhi	r2,33056
81104cf0:	10840004 	addi	r2,r2,4096
81104cf4:	18800015 	stw	r2,0(r3)
			break;
81104cf8:	00000206 	br	81104d04 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104cfc:	e03ffd15 	stw	zero,-12(fp)
			break;
81104d00:	0001883a 	nop
		}

		if (bStatus) {
81104d04:	e0bffd17 	ldw	r2,-12(fp)
81104d08:	10000c26 	beq	r2,zero,81104d3c <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104d0c:	e13ffe17 	ldw	r4,-8(fp)
81104d10:	11047e40 	call	811047e4 <bDpktGetPacketConfig>
81104d14:	1000011e 	bne	r2,zero,81104d1c <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104d18:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104d1c:	e13ffe17 	ldw	r4,-8(fp)
81104d20:	11049100 	call	81104910 <bDpktGetPacketHeader>
81104d24:	1000011e 	bne	r2,zero,81104d2c <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104d28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104d2c:	e13ffe17 	ldw	r4,-8(fp)
81104d30:	1104b1c0 	call	81104b1c <bDpktGetPixelDelay>
81104d34:	1000011e 	bne	r2,zero,81104d3c <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104d38:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104d3c:	e0bffd17 	ldw	r2,-12(fp)
}
81104d40:	e037883a 	mov	sp,fp
81104d44:	dfc00117 	ldw	ra,4(sp)
81104d48:	df000017 	ldw	fp,0(sp)
81104d4c:	dec00204 	addi	sp,sp,8
81104d50:	f800283a 	ret

81104d54 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104d54:	defffc04 	addi	sp,sp,-16
81104d58:	de00012e 	bgeu	sp,et,81104d60 <vDpktWriteReg+0xc>
81104d5c:	003b68fa 	trap	3
81104d60:	df000315 	stw	fp,12(sp)
81104d64:	df000304 	addi	fp,sp,12
81104d68:	e13ffd15 	stw	r4,-12(fp)
81104d6c:	e17ffe15 	stw	r5,-8(fp)
81104d70:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104d74:	e0bffe17 	ldw	r2,-8(fp)
81104d78:	1085883a 	add	r2,r2,r2
81104d7c:	1085883a 	add	r2,r2,r2
81104d80:	1007883a 	mov	r3,r2
81104d84:	e0bffd17 	ldw	r2,-12(fp)
81104d88:	10c5883a 	add	r2,r2,r3
81104d8c:	e0ffff17 	ldw	r3,-4(fp)
81104d90:	10c00015 	stw	r3,0(r2)
}
81104d94:	0001883a 	nop
81104d98:	e037883a 	mov	sp,fp
81104d9c:	df000017 	ldw	fp,0(sp)
81104da0:	dec00104 	addi	sp,sp,4
81104da4:	f800283a 	ret

81104da8 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104da8:	defffc04 	addi	sp,sp,-16
81104dac:	de00012e 	bgeu	sp,et,81104db4 <uliDpktReadReg+0xc>
81104db0:	003b68fa 	trap	3
81104db4:	df000315 	stw	fp,12(sp)
81104db8:	df000304 	addi	fp,sp,12
81104dbc:	e13ffe15 	stw	r4,-8(fp)
81104dc0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104dc4:	e0bfff17 	ldw	r2,-4(fp)
81104dc8:	1085883a 	add	r2,r2,r2
81104dcc:	1085883a 	add	r2,r2,r2
81104dd0:	1007883a 	mov	r3,r2
81104dd4:	e0bffe17 	ldw	r2,-8(fp)
81104dd8:	10c5883a 	add	r2,r2,r3
81104ddc:	10800017 	ldw	r2,0(r2)
81104de0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104de4:	e0bffd17 	ldw	r2,-12(fp)
}
81104de8:	e037883a 	mov	sp,fp
81104dec:	df000017 	ldw	fp,0(sp)
81104df0:	dec00104 	addi	sp,sp,4
81104df4:	f800283a 	ret

81104df8 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104df8:	defffc04 	addi	sp,sp,-16
81104dfc:	de00012e 	bgeu	sp,et,81104e04 <vFeebCh1HandleIrq+0xc>
81104e00:	003b68fa 	trap	3
81104e04:	dfc00315 	stw	ra,12(sp)
81104e08:	df000215 	stw	fp,8(sp)
81104e0c:	df000204 	addi	fp,sp,8
81104e10:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104e14:	e0bfff17 	ldw	r2,-4(fp)
81104e18:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh1IrqFlagClrBufferEmpty();
81104e1c:	1104ff80 	call	81104ff8 <vFeebCh1IrqFlagClrBufferEmpty>
}
81104e20:	0001883a 	nop
81104e24:	e037883a 	mov	sp,fp
81104e28:	dfc00117 	ldw	ra,4(sp)
81104e2c:	df000017 	ldw	fp,0(sp)
81104e30:	dec00204 	addi	sp,sp,8
81104e34:	f800283a 	ret

81104e38 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81104e38:	defffc04 	addi	sp,sp,-16
81104e3c:	de00012e 	bgeu	sp,et,81104e44 <vFeebCh2HandleIrq+0xc>
81104e40:	003b68fa 	trap	3
81104e44:	dfc00315 	stw	ra,12(sp)
81104e48:	df000215 	stw	fp,8(sp)
81104e4c:	df000204 	addi	fp,sp,8
81104e50:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104e54:	e0bfff17 	ldw	r2,-4(fp)
81104e58:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh2IrqFlagClrBufferEmpty();
81104e5c:	110503c0 	call	8110503c <vFeebCh2IrqFlagClrBufferEmpty>
}
81104e60:	0001883a 	nop
81104e64:	e037883a 	mov	sp,fp
81104e68:	dfc00117 	ldw	ra,4(sp)
81104e6c:	df000017 	ldw	fp,0(sp)
81104e70:	dec00204 	addi	sp,sp,8
81104e74:	f800283a 	ret

81104e78 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81104e78:	defffc04 	addi	sp,sp,-16
81104e7c:	de00012e 	bgeu	sp,et,81104e84 <vFeebCh3HandleIrq+0xc>
81104e80:	003b68fa 	trap	3
81104e84:	dfc00315 	stw	ra,12(sp)
81104e88:	df000215 	stw	fp,8(sp)
81104e8c:	df000204 	addi	fp,sp,8
81104e90:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104e94:	e0bfff17 	ldw	r2,-4(fp)
81104e98:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh3IrqFlagClrBufferEmpty();
81104e9c:	11050800 	call	81105080 <vFeebCh3IrqFlagClrBufferEmpty>
}
81104ea0:	0001883a 	nop
81104ea4:	e037883a 	mov	sp,fp
81104ea8:	dfc00117 	ldw	ra,4(sp)
81104eac:	df000017 	ldw	fp,0(sp)
81104eb0:	dec00204 	addi	sp,sp,8
81104eb4:	f800283a 	ret

81104eb8 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81104eb8:	defffc04 	addi	sp,sp,-16
81104ebc:	de00012e 	bgeu	sp,et,81104ec4 <vFeebCh4HandleIrq+0xc>
81104ec0:	003b68fa 	trap	3
81104ec4:	dfc00315 	stw	ra,12(sp)
81104ec8:	df000215 	stw	fp,8(sp)
81104ecc:	df000204 	addi	fp,sp,8
81104ed0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ed4:	e0bfff17 	ldw	r2,-4(fp)
81104ed8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh4IrqFlagClrBufferEmpty();
81104edc:	11050c40 	call	811050c4 <vFeebCh4IrqFlagClrBufferEmpty>
}
81104ee0:	0001883a 	nop
81104ee4:	e037883a 	mov	sp,fp
81104ee8:	dfc00117 	ldw	ra,4(sp)
81104eec:	df000017 	ldw	fp,0(sp)
81104ef0:	dec00204 	addi	sp,sp,8
81104ef4:	f800283a 	ret

81104ef8 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81104ef8:	defffc04 	addi	sp,sp,-16
81104efc:	de00012e 	bgeu	sp,et,81104f04 <vFeebCh5HandleIrq+0xc>
81104f00:	003b68fa 	trap	3
81104f04:	dfc00315 	stw	ra,12(sp)
81104f08:	df000215 	stw	fp,8(sp)
81104f0c:	df000204 	addi	fp,sp,8
81104f10:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104f14:	e0bfff17 	ldw	r2,-4(fp)
81104f18:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh5IrqFlagClrBufferEmpty();
81104f1c:	11051080 	call	81105108 <vFeebCh5IrqFlagClrBufferEmpty>
}
81104f20:	0001883a 	nop
81104f24:	e037883a 	mov	sp,fp
81104f28:	dfc00117 	ldw	ra,4(sp)
81104f2c:	df000017 	ldw	fp,0(sp)
81104f30:	dec00204 	addi	sp,sp,8
81104f34:	f800283a 	ret

81104f38 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81104f38:	defffc04 	addi	sp,sp,-16
81104f3c:	de00012e 	bgeu	sp,et,81104f44 <vFeebCh6HandleIrq+0xc>
81104f40:	003b68fa 	trap	3
81104f44:	dfc00315 	stw	ra,12(sp)
81104f48:	df000215 	stw	fp,8(sp)
81104f4c:	df000204 	addi	fp,sp,8
81104f50:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104f54:	e0bfff17 	ldw	r2,-4(fp)
81104f58:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vFeebCh6IrqFlagClrBufferEmpty();
81104f5c:	110514c0 	call	8110514c <vFeebCh6IrqFlagClrBufferEmpty>
}
81104f60:	0001883a 	nop
81104f64:	e037883a 	mov	sp,fp
81104f68:	dfc00117 	ldw	ra,4(sp)
81104f6c:	df000017 	ldw	fp,0(sp)
81104f70:	dec00204 	addi	sp,sp,8
81104f74:	f800283a 	ret

81104f78 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81104f78:	defffc04 	addi	sp,sp,-16
81104f7c:	de00012e 	bgeu	sp,et,81104f84 <vFeebCh7HandleIrq+0xc>
81104f80:	003b68fa 	trap	3
81104f84:	dfc00315 	stw	ra,12(sp)
81104f88:	df000215 	stw	fp,8(sp)
81104f8c:	df000204 	addi	fp,sp,8
81104f90:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104f94:	e0bfff17 	ldw	r2,-4(fp)
81104f98:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh7IrqFlagClrBufferEmpty();
81104f9c:	11051900 	call	81105190 <vFeebCh7IrqFlagClrBufferEmpty>
}
81104fa0:	0001883a 	nop
81104fa4:	e037883a 	mov	sp,fp
81104fa8:	dfc00117 	ldw	ra,4(sp)
81104fac:	df000017 	ldw	fp,0(sp)
81104fb0:	dec00204 	addi	sp,sp,8
81104fb4:	f800283a 	ret

81104fb8 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81104fb8:	defffc04 	addi	sp,sp,-16
81104fbc:	de00012e 	bgeu	sp,et,81104fc4 <vFeebCh8HandleIrq+0xc>
81104fc0:	003b68fa 	trap	3
81104fc4:	dfc00315 	stw	ra,12(sp)
81104fc8:	df000215 	stw	fp,8(sp)
81104fcc:	df000204 	addi	fp,sp,8
81104fd0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104fd4:	e0bfff17 	ldw	r2,-4(fp)
81104fd8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vFeebCh8IrqFlagClrBufferEmpty();
81104fdc:	11051d40 	call	811051d4 <vFeebCh8IrqFlagClrBufferEmpty>
}
81104fe0:	0001883a 	nop
81104fe4:	e037883a 	mov	sp,fp
81104fe8:	dfc00117 	ldw	ra,4(sp)
81104fec:	df000017 	ldw	fp,0(sp)
81104ff0:	dec00204 	addi	sp,sp,8
81104ff4:	f800283a 	ret

81104ff8 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81104ff8:	defffe04 	addi	sp,sp,-8
81104ffc:	de00012e 	bgeu	sp,et,81105004 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105000:	003b68fa 	trap	3
81105004:	dfc00115 	stw	ra,4(sp)
81105008:	df000015 	stw	fp,0(sp)
8110500c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105010:	01804004 	movi	r6,256
81105014:	014004c4 	movi	r5,19
81105018:	01204834 	movhi	r4,33056
8110501c:	210b0004 	addi	r4,r4,11264
81105020:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105024:	0001883a 	nop
81105028:	e037883a 	mov	sp,fp
8110502c:	dfc00117 	ldw	ra,4(sp)
81105030:	df000017 	ldw	fp,0(sp)
81105034:	dec00204 	addi	sp,sp,8
81105038:	f800283a 	ret

8110503c <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
8110503c:	defffe04 	addi	sp,sp,-8
81105040:	de00012e 	bgeu	sp,et,81105048 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105044:	003b68fa 	trap	3
81105048:	dfc00115 	stw	ra,4(sp)
8110504c:	df000015 	stw	fp,0(sp)
81105050:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105054:	01804004 	movi	r6,256
81105058:	014004c4 	movi	r5,19
8110505c:	01204834 	movhi	r4,33056
81105060:	210a0004 	addi	r4,r4,10240
81105064:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105068:	0001883a 	nop
8110506c:	e037883a 	mov	sp,fp
81105070:	dfc00117 	ldw	ra,4(sp)
81105074:	df000017 	ldw	fp,0(sp)
81105078:	dec00204 	addi	sp,sp,8
8110507c:	f800283a 	ret

81105080 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81105080:	defffe04 	addi	sp,sp,-8
81105084:	de00012e 	bgeu	sp,et,8110508c <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81105088:	003b68fa 	trap	3
8110508c:	dfc00115 	stw	ra,4(sp)
81105090:	df000015 	stw	fp,0(sp)
81105094:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105098:	01804004 	movi	r6,256
8110509c:	014004c4 	movi	r5,19
811050a0:	01204834 	movhi	r4,33056
811050a4:	21090004 	addi	r4,r4,9216
811050a8:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811050ac:	0001883a 	nop
811050b0:	e037883a 	mov	sp,fp
811050b4:	dfc00117 	ldw	ra,4(sp)
811050b8:	df000017 	ldw	fp,0(sp)
811050bc:	dec00204 	addi	sp,sp,8
811050c0:	f800283a 	ret

811050c4 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
811050c4:	defffe04 	addi	sp,sp,-8
811050c8:	de00012e 	bgeu	sp,et,811050d0 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
811050cc:	003b68fa 	trap	3
811050d0:	dfc00115 	stw	ra,4(sp)
811050d4:	df000015 	stw	fp,0(sp)
811050d8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811050dc:	01804004 	movi	r6,256
811050e0:	014004c4 	movi	r5,19
811050e4:	01204834 	movhi	r4,33056
811050e8:	21080004 	addi	r4,r4,8192
811050ec:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811050f0:	0001883a 	nop
811050f4:	e037883a 	mov	sp,fp
811050f8:	dfc00117 	ldw	ra,4(sp)
811050fc:	df000017 	ldw	fp,0(sp)
81105100:	dec00204 	addi	sp,sp,8
81105104:	f800283a 	ret

81105108 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105108:	defffe04 	addi	sp,sp,-8
8110510c:	de00012e 	bgeu	sp,et,81105114 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105110:	003b68fa 	trap	3
81105114:	dfc00115 	stw	ra,4(sp)
81105118:	df000015 	stw	fp,0(sp)
8110511c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105120:	01804004 	movi	r6,256
81105124:	014004c4 	movi	r5,19
81105128:	01204834 	movhi	r4,33056
8110512c:	21070004 	addi	r4,r4,7168
81105130:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105134:	0001883a 	nop
81105138:	e037883a 	mov	sp,fp
8110513c:	dfc00117 	ldw	ra,4(sp)
81105140:	df000017 	ldw	fp,0(sp)
81105144:	dec00204 	addi	sp,sp,8
81105148:	f800283a 	ret

8110514c <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
8110514c:	defffe04 	addi	sp,sp,-8
81105150:	de00012e 	bgeu	sp,et,81105158 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81105154:	003b68fa 	trap	3
81105158:	dfc00115 	stw	ra,4(sp)
8110515c:	df000015 	stw	fp,0(sp)
81105160:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105164:	01804004 	movi	r6,256
81105168:	014004c4 	movi	r5,19
8110516c:	01204834 	movhi	r4,33056
81105170:	21060004 	addi	r4,r4,6144
81105174:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105178:	0001883a 	nop
8110517c:	e037883a 	mov	sp,fp
81105180:	dfc00117 	ldw	ra,4(sp)
81105184:	df000017 	ldw	fp,0(sp)
81105188:	dec00204 	addi	sp,sp,8
8110518c:	f800283a 	ret

81105190 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105190:	defffe04 	addi	sp,sp,-8
81105194:	de00012e 	bgeu	sp,et,8110519c <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105198:	003b68fa 	trap	3
8110519c:	dfc00115 	stw	ra,4(sp)
811051a0:	df000015 	stw	fp,0(sp)
811051a4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811051a8:	01804004 	movi	r6,256
811051ac:	014004c4 	movi	r5,19
811051b0:	01204834 	movhi	r4,33056
811051b4:	21050004 	addi	r4,r4,5120
811051b8:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811051bc:	0001883a 	nop
811051c0:	e037883a 	mov	sp,fp
811051c4:	dfc00117 	ldw	ra,4(sp)
811051c8:	df000017 	ldw	fp,0(sp)
811051cc:	dec00204 	addi	sp,sp,8
811051d0:	f800283a 	ret

811051d4 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
811051d4:	defffe04 	addi	sp,sp,-8
811051d8:	de00012e 	bgeu	sp,et,811051e0 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
811051dc:	003b68fa 	trap	3
811051e0:	dfc00115 	stw	ra,4(sp)
811051e4:	df000015 	stw	fp,0(sp)
811051e8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811051ec:	01804004 	movi	r6,256
811051f0:	014004c4 	movi	r5,19
811051f4:	01204834 	movhi	r4,33056
811051f8:	21040004 	addi	r4,r4,4096
811051fc:	1105d540 	call	81105d54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105200:	0001883a 	nop
81105204:	e037883a 	mov	sp,fp
81105208:	dfc00117 	ldw	ra,4(sp)
8110520c:	df000017 	ldw	fp,0(sp)
81105210:	dec00204 	addi	sp,sp,8
81105214:	f800283a 	ret

81105218 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105218:	defffd04 	addi	sp,sp,-12
8110521c:	de00012e 	bgeu	sp,et,81105224 <bFeebCh1IrqFlagBufferEmpty+0xc>
81105220:	003b68fa 	trap	3
81105224:	dfc00215 	stw	ra,8(sp)
81105228:	df000115 	stw	fp,4(sp)
8110522c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105230:	01400484 	movi	r5,18
81105234:	01204834 	movhi	r4,33056
81105238:	210b0004 	addi	r4,r4,11264
8110523c:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105240:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105244:	10000326 	beq	r2,zero,81105254 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105248:	00800044 	movi	r2,1
8110524c:	e0bfff15 	stw	r2,-4(fp)
81105250:	00000106 	br	81105258 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105254:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105258:	e0bfff17 	ldw	r2,-4(fp)
}
8110525c:	e037883a 	mov	sp,fp
81105260:	dfc00117 	ldw	ra,4(sp)
81105264:	df000017 	ldw	fp,0(sp)
81105268:	dec00204 	addi	sp,sp,8
8110526c:	f800283a 	ret

81105270 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81105270:	defffd04 	addi	sp,sp,-12
81105274:	de00012e 	bgeu	sp,et,8110527c <bFeebCh2IrqFlagBufferEmpty+0xc>
81105278:	003b68fa 	trap	3
8110527c:	dfc00215 	stw	ra,8(sp)
81105280:	df000115 	stw	fp,4(sp)
81105284:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105288:	01400484 	movi	r5,18
8110528c:	01204834 	movhi	r4,33056
81105290:	210a0004 	addi	r4,r4,10240
81105294:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105298:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110529c:	10000326 	beq	r2,zero,811052ac <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811052a0:	00800044 	movi	r2,1
811052a4:	e0bfff15 	stw	r2,-4(fp)
811052a8:	00000106 	br	811052b0 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811052ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811052b0:	e0bfff17 	ldw	r2,-4(fp)
}
811052b4:	e037883a 	mov	sp,fp
811052b8:	dfc00117 	ldw	ra,4(sp)
811052bc:	df000017 	ldw	fp,0(sp)
811052c0:	dec00204 	addi	sp,sp,8
811052c4:	f800283a 	ret

811052c8 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
811052c8:	defffd04 	addi	sp,sp,-12
811052cc:	de00012e 	bgeu	sp,et,811052d4 <bFeebCh3IrqFlagBufferEmpty+0xc>
811052d0:	003b68fa 	trap	3
811052d4:	dfc00215 	stw	ra,8(sp)
811052d8:	df000115 	stw	fp,4(sp)
811052dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811052e0:	01400484 	movi	r5,18
811052e4:	01204834 	movhi	r4,33056
811052e8:	21090004 	addi	r4,r4,9216
811052ec:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811052f0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811052f4:	10000326 	beq	r2,zero,81105304 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811052f8:	00800044 	movi	r2,1
811052fc:	e0bfff15 	stw	r2,-4(fp)
81105300:	00000106 	br	81105308 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105304:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105308:	e0bfff17 	ldw	r2,-4(fp)
}
8110530c:	e037883a 	mov	sp,fp
81105310:	dfc00117 	ldw	ra,4(sp)
81105314:	df000017 	ldw	fp,0(sp)
81105318:	dec00204 	addi	sp,sp,8
8110531c:	f800283a 	ret

81105320 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105320:	defffd04 	addi	sp,sp,-12
81105324:	de00012e 	bgeu	sp,et,8110532c <bFeebCh4IrqFlagBufferEmpty+0xc>
81105328:	003b68fa 	trap	3
8110532c:	dfc00215 	stw	ra,8(sp)
81105330:	df000115 	stw	fp,4(sp)
81105334:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105338:	01400484 	movi	r5,18
8110533c:	01204834 	movhi	r4,33056
81105340:	21080004 	addi	r4,r4,8192
81105344:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105348:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110534c:	10000326 	beq	r2,zero,8110535c <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105350:	00800044 	movi	r2,1
81105354:	e0bfff15 	stw	r2,-4(fp)
81105358:	00000106 	br	81105360 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110535c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105360:	e0bfff17 	ldw	r2,-4(fp)
}
81105364:	e037883a 	mov	sp,fp
81105368:	dfc00117 	ldw	ra,4(sp)
8110536c:	df000017 	ldw	fp,0(sp)
81105370:	dec00204 	addi	sp,sp,8
81105374:	f800283a 	ret

81105378 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81105378:	defffd04 	addi	sp,sp,-12
8110537c:	de00012e 	bgeu	sp,et,81105384 <bFeebCh5IrqFlagBufferEmpty+0xc>
81105380:	003b68fa 	trap	3
81105384:	dfc00215 	stw	ra,8(sp)
81105388:	df000115 	stw	fp,4(sp)
8110538c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105390:	01400484 	movi	r5,18
81105394:	01204834 	movhi	r4,33056
81105398:	21070004 	addi	r4,r4,7168
8110539c:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811053a0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811053a4:	10000326 	beq	r2,zero,811053b4 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811053a8:	00800044 	movi	r2,1
811053ac:	e0bfff15 	stw	r2,-4(fp)
811053b0:	00000106 	br	811053b8 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811053b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811053b8:	e0bfff17 	ldw	r2,-4(fp)
}
811053bc:	e037883a 	mov	sp,fp
811053c0:	dfc00117 	ldw	ra,4(sp)
811053c4:	df000017 	ldw	fp,0(sp)
811053c8:	dec00204 	addi	sp,sp,8
811053cc:	f800283a 	ret

811053d0 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
811053d0:	defffd04 	addi	sp,sp,-12
811053d4:	de00012e 	bgeu	sp,et,811053dc <bFeebCh6IrqFlagBufferEmpty+0xc>
811053d8:	003b68fa 	trap	3
811053dc:	dfc00215 	stw	ra,8(sp)
811053e0:	df000115 	stw	fp,4(sp)
811053e4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811053e8:	01400484 	movi	r5,18
811053ec:	01204834 	movhi	r4,33056
811053f0:	21060004 	addi	r4,r4,6144
811053f4:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811053f8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811053fc:	10000326 	beq	r2,zero,8110540c <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105400:	00800044 	movi	r2,1
81105404:	e0bfff15 	stw	r2,-4(fp)
81105408:	00000106 	br	81105410 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110540c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105410:	e0bfff17 	ldw	r2,-4(fp)
}
81105414:	e037883a 	mov	sp,fp
81105418:	dfc00117 	ldw	ra,4(sp)
8110541c:	df000017 	ldw	fp,0(sp)
81105420:	dec00204 	addi	sp,sp,8
81105424:	f800283a 	ret

81105428 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81105428:	defffd04 	addi	sp,sp,-12
8110542c:	de00012e 	bgeu	sp,et,81105434 <bFeebCh7IrqFlagBufferEmpty+0xc>
81105430:	003b68fa 	trap	3
81105434:	dfc00215 	stw	ra,8(sp)
81105438:	df000115 	stw	fp,4(sp)
8110543c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105440:	01400484 	movi	r5,18
81105444:	01204834 	movhi	r4,33056
81105448:	21050004 	addi	r4,r4,5120
8110544c:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105450:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105454:	10000326 	beq	r2,zero,81105464 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105458:	00800044 	movi	r2,1
8110545c:	e0bfff15 	stw	r2,-4(fp)
81105460:	00000106 	br	81105468 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105464:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105468:	e0bfff17 	ldw	r2,-4(fp)
}
8110546c:	e037883a 	mov	sp,fp
81105470:	dfc00117 	ldw	ra,4(sp)
81105474:	df000017 	ldw	fp,0(sp)
81105478:	dec00204 	addi	sp,sp,8
8110547c:	f800283a 	ret

81105480 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105480:	defffd04 	addi	sp,sp,-12
81105484:	de00012e 	bgeu	sp,et,8110548c <bFeebCh8IrqFlagBufferEmpty+0xc>
81105488:	003b68fa 	trap	3
8110548c:	dfc00215 	stw	ra,8(sp)
81105490:	df000115 	stw	fp,4(sp)
81105494:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105498:	01400484 	movi	r5,18
8110549c:	01204834 	movhi	r4,33056
811054a0:	21040004 	addi	r4,r4,4096
811054a4:	1105da80 	call	81105da8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811054a8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811054ac:	10000326 	beq	r2,zero,811054bc <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811054b0:	00800044 	movi	r2,1
811054b4:	e0bfff15 	stw	r2,-4(fp)
811054b8:	00000106 	br	811054c0 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811054bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811054c0:	e0bfff17 	ldw	r2,-4(fp)
}
811054c4:	e037883a 	mov	sp,fp
811054c8:	dfc00117 	ldw	ra,4(sp)
811054cc:	df000017 	ldw	fp,0(sp)
811054d0:	dec00204 	addi	sp,sp,8
811054d4:	f800283a 	ret

811054d8 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
811054d8:	defffc04 	addi	sp,sp,-16
811054dc:	de00012e 	bgeu	sp,et,811054e4 <vFeebInitIrq+0xc>
811054e0:	003b68fa 	trap	3
811054e4:	dfc00315 	stw	ra,12(sp)
811054e8:	df000215 	stw	fp,8(sp)
811054ec:	df000204 	addi	fp,sp,8
811054f0:	2005883a 	mov	r2,r4
811054f4:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
811054f8:	e0bfff03 	ldbu	r2,-4(fp)
811054fc:	10c00228 	cmpgeui	r3,r2,8
81105500:	18004e1e 	bne	r3,zero,8110563c <vFeebInitIrq+0x164>
81105504:	100690ba 	slli	r3,r2,2
81105508:	00a04434 	movhi	r2,33040
8110550c:	10954704 	addi	r2,r2,21788
81105510:	1885883a 	add	r2,r3,r2
81105514:	10800017 	ldw	r2,0(r2)
81105518:	1000683a 	jmp	r2
8110551c:	8110553c 	xorhi	r4,r16,16724
81105520:	8110555c 	xori	r4,r16,16725
81105524:	8110557c 	xorhi	r4,r16,16725
81105528:	8110559c 	xori	r4,r16,16726
8110552c:	811055bc 	xorhi	r4,r16,16726
81105530:	811055dc 	xori	r4,r16,16727
81105534:	811055fc 	xorhi	r4,r16,16727
81105538:	8110561c 	xori	r4,r16,16728
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8110553c:	d0a03e04 	addi	r2,gp,-32520
81105540:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105544:	01a04434 	movhi	r6,33040
81105548:	31937e04 	addi	r6,r6,19960
8110554c:	e17ffe17 	ldw	r5,-8(fp)
81105550:	01000584 	movi	r4,22
81105554:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81105558:	00003806 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
8110555c:	d0a03f04 	addi	r2,gp,-32516
81105560:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81105564:	01a04434 	movhi	r6,33040
81105568:	31938e04 	addi	r6,r6,20024
8110556c:	e17ffe17 	ldw	r5,-8(fp)
81105570:	01000504 	movi	r4,20
81105574:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81105578:	00003006 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
8110557c:	d0a04004 	addi	r2,gp,-32512
81105580:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81105584:	01a04434 	movhi	r6,33040
81105588:	31939e04 	addi	r6,r6,20088
8110558c:	e17ffe17 	ldw	r5,-8(fp)
81105590:	01000484 	movi	r4,18
81105594:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105598:	00002806 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
8110559c:	d0a04104 	addi	r2,gp,-32508
811055a0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
811055a4:	01a04434 	movhi	r6,33040
811055a8:	3193ae04 	addi	r6,r6,20152
811055ac:	e17ffe17 	ldw	r5,-8(fp)
811055b0:	01000404 	movi	r4,16
811055b4:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
811055b8:	00002006 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811055bc:	d0a04204 	addi	r2,gp,-32504
811055c0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
811055c4:	01a04434 	movhi	r6,33040
811055c8:	3193be04 	addi	r6,r6,20216
811055cc:	e17ffe17 	ldw	r5,-8(fp)
811055d0:	01000204 	movi	r4,8
811055d4:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
811055d8:	00001806 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
811055dc:	d0a04304 	addi	r2,gp,-32500
811055e0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
811055e4:	01a04434 	movhi	r6,33040
811055e8:	3193ce04 	addi	r6,r6,20280
811055ec:	e17ffe17 	ldw	r5,-8(fp)
811055f0:	01000184 	movi	r4,6
811055f4:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
811055f8:	00001006 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
811055fc:	d0a04404 	addi	r2,gp,-32496
81105600:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81105604:	01a04434 	movhi	r6,33040
81105608:	3193de04 	addi	r6,r6,20344
8110560c:	e17ffe17 	ldw	r5,-8(fp)
81105610:	01000144 	movi	r4,5
81105614:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81105618:	00000806 	br	8110563c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110561c:	d0a04504 	addi	r2,gp,-32492
81105620:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81105624:	01a04434 	movhi	r6,33040
81105628:	3193ee04 	addi	r6,r6,20408
8110562c:	e17ffe17 	ldw	r5,-8(fp)
81105630:	01000084 	movi	r4,2
81105634:	11305680 	call	81130568 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81105638:	0001883a 	nop
	}
}
8110563c:	0001883a 	nop
81105640:	e037883a 	mov	sp,fp
81105644:	dfc00117 	ldw	ra,4(sp)
81105648:	df000017 	ldw	fp,0(sp)
8110564c:	dec00204 	addi	sp,sp,8
81105650:	f800283a 	ret

81105654 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81105654:	defffb04 	addi	sp,sp,-20
81105658:	de00012e 	bgeu	sp,et,81105660 <bFeebSetIrqControl+0xc>
8110565c:	003b68fa 	trap	3
81105660:	dfc00415 	stw	ra,16(sp)
81105664:	df000315 	stw	fp,12(sp)
81105668:	df000304 	addi	fp,sp,12
8110566c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105670:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105674:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105678:	e0bfff17 	ldw	r2,-4(fp)
8110567c:	10002426 	beq	r2,zero,81105710 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105680:	e0bfff17 	ldw	r2,-4(fp)
81105684:	10800017 	ldw	r2,0(r2)
81105688:	01400444 	movi	r5,17
8110568c:	1009883a 	mov	r4,r2
81105690:	1105da80 	call	81105da8 <uliFeebReadReg>
81105694:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81105698:	e0bfff17 	ldw	r2,-4(fp)
8110569c:	10800217 	ldw	r2,8(r2)
811056a0:	10000426 	beq	r2,zero,811056b4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811056a4:	e0bffe17 	ldw	r2,-8(fp)
811056a8:	10808014 	ori	r2,r2,512
811056ac:	e0bffe15 	stw	r2,-8(fp)
811056b0:	00000406 	br	811056c4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
811056b4:	e0fffe17 	ldw	r3,-8(fp)
811056b8:	00bf7fc4 	movi	r2,-513
811056bc:	1884703a 	and	r2,r3,r2
811056c0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
811056c4:	e0bfff17 	ldw	r2,-4(fp)
811056c8:	10800317 	ldw	r2,12(r2)
811056cc:	10000426 	beq	r2,zero,811056e0 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
811056d0:	e0bffe17 	ldw	r2,-8(fp)
811056d4:	10804014 	ori	r2,r2,256
811056d8:	e0bffe15 	stw	r2,-8(fp)
811056dc:	00000406 	br	811056f0 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
811056e0:	e0fffe17 	ldw	r3,-8(fp)
811056e4:	00bfbfc4 	movi	r2,-257
811056e8:	1884703a 	and	r2,r3,r2
811056ec:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
811056f0:	e0bfff17 	ldw	r2,-4(fp)
811056f4:	10800017 	ldw	r2,0(r2)
811056f8:	e1bffe17 	ldw	r6,-8(fp)
811056fc:	01400444 	movi	r5,17
81105700:	1009883a 	mov	r4,r2
81105704:	1105d540 	call	81105d54 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81105708:	00800044 	movi	r2,1
8110570c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105710:	e0bffd17 	ldw	r2,-12(fp)
}
81105714:	e037883a 	mov	sp,fp
81105718:	dfc00117 	ldw	ra,4(sp)
8110571c:	df000017 	ldw	fp,0(sp)
81105720:	dec00204 	addi	sp,sp,8
81105724:	f800283a 	ret

81105728 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81105728:	defffb04 	addi	sp,sp,-20
8110572c:	de00012e 	bgeu	sp,et,81105734 <bFeebGetIrqControl+0xc>
81105730:	003b68fa 	trap	3
81105734:	dfc00415 	stw	ra,16(sp)
81105738:	df000315 	stw	fp,12(sp)
8110573c:	df000304 	addi	fp,sp,12
81105740:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105744:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105748:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110574c:	e0bfff17 	ldw	r2,-4(fp)
81105750:	10001a26 	beq	r2,zero,811057bc <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105754:	e0bfff17 	ldw	r2,-4(fp)
81105758:	10800017 	ldw	r2,0(r2)
8110575c:	01400444 	movi	r5,17
81105760:	1009883a 	mov	r4,r2
81105764:	1105da80 	call	81105da8 <uliFeebReadReg>
81105768:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
8110576c:	e0bffe17 	ldw	r2,-8(fp)
81105770:	1080800c 	andi	r2,r2,512
81105774:	10000426 	beq	r2,zero,81105788 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81105778:	e0bfff17 	ldw	r2,-4(fp)
8110577c:	00c00044 	movi	r3,1
81105780:	10c00215 	stw	r3,8(r2)
81105784:	00000206 	br	81105790 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81105788:	e0bfff17 	ldw	r2,-4(fp)
8110578c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81105790:	e0bffe17 	ldw	r2,-8(fp)
81105794:	1080400c 	andi	r2,r2,256
81105798:	10000426 	beq	r2,zero,811057ac <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110579c:	e0bfff17 	ldw	r2,-4(fp)
811057a0:	00c00044 	movi	r3,1
811057a4:	10c00315 	stw	r3,12(r2)
811057a8:	00000206 	br	811057b4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811057ac:	e0bfff17 	ldw	r2,-4(fp)
811057b0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
811057b4:	00800044 	movi	r2,1
811057b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811057bc:	e0bffd17 	ldw	r2,-12(fp)
}
811057c0:	e037883a 	mov	sp,fp
811057c4:	dfc00117 	ldw	ra,4(sp)
811057c8:	df000017 	ldw	fp,0(sp)
811057cc:	dec00204 	addi	sp,sp,8
811057d0:	f800283a 	ret

811057d4 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
811057d4:	defffb04 	addi	sp,sp,-20
811057d8:	de00012e 	bgeu	sp,et,811057e0 <bFeebGetIrqFlags+0xc>
811057dc:	003b68fa 	trap	3
811057e0:	dfc00415 	stw	ra,16(sp)
811057e4:	df000315 	stw	fp,12(sp)
811057e8:	df000304 	addi	fp,sp,12
811057ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811057f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811057f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811057f8:	e0bfff17 	ldw	r2,-4(fp)
811057fc:	10001126 	beq	r2,zero,81105844 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105800:	e0bfff17 	ldw	r2,-4(fp)
81105804:	10800017 	ldw	r2,0(r2)
81105808:	01400484 	movi	r5,18
8110580c:	1009883a 	mov	r4,r2
81105810:	1105da80 	call	81105da8 <uliFeebReadReg>
81105814:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105818:	e0bffe17 	ldw	r2,-8(fp)
8110581c:	1080400c 	andi	r2,r2,256
81105820:	10000426 	beq	r2,zero,81105834 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81105824:	e0bfff17 	ldw	r2,-4(fp)
81105828:	00c00044 	movi	r3,1
8110582c:	10c00415 	stw	r3,16(r2)
81105830:	00000206 	br	8110583c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81105834:	e0bfff17 	ldw	r2,-4(fp)
81105838:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
8110583c:	00800044 	movi	r2,1
81105840:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105844:	e0bffd17 	ldw	r2,-12(fp)
}
81105848:	e037883a 	mov	sp,fp
8110584c:	dfc00117 	ldw	ra,4(sp)
81105850:	df000017 	ldw	fp,0(sp)
81105854:	dec00204 	addi	sp,sp,8
81105858:	f800283a 	ret

8110585c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110585c:	defffb04 	addi	sp,sp,-20
81105860:	de00012e 	bgeu	sp,et,81105868 <bFeebGetBuffersStatus+0xc>
81105864:	003b68fa 	trap	3
81105868:	dfc00415 	stw	ra,16(sp)
8110586c:	df000315 	stw	fp,12(sp)
81105870:	df000304 	addi	fp,sp,12
81105874:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105878:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110587c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105880:	e0bfff17 	ldw	r2,-4(fp)
81105884:	10001a26 	beq	r2,zero,811058f0 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105888:	e0bfff17 	ldw	r2,-4(fp)
8110588c:	10800017 	ldw	r2,0(r2)
81105890:	014000c4 	movi	r5,3
81105894:	1009883a 	mov	r4,r2
81105898:	1105da80 	call	81105da8 <uliFeebReadReg>
8110589c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811058a0:	e0bffe17 	ldw	r2,-8(fp)
811058a4:	1080008c 	andi	r2,r2,2
811058a8:	10000426 	beq	r2,zero,811058bc <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811058ac:	e0bfff17 	ldw	r2,-4(fp)
811058b0:	00c00044 	movi	r3,1
811058b4:	10c00515 	stw	r3,20(r2)
811058b8:	00000206 	br	811058c4 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811058bc:	e0bfff17 	ldw	r2,-4(fp)
811058c0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811058c4:	e0bffe17 	ldw	r2,-8(fp)
811058c8:	1080004c 	andi	r2,r2,1
811058cc:	10000426 	beq	r2,zero,811058e0 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
811058d0:	e0bfff17 	ldw	r2,-4(fp)
811058d4:	00c00044 	movi	r3,1
811058d8:	10c00615 	stw	r3,24(r2)
811058dc:	00000206 	br	811058e8 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
811058e0:	e0bfff17 	ldw	r2,-4(fp)
811058e4:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
811058e8:	00800044 	movi	r2,1
811058ec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811058f0:	e0bffd17 	ldw	r2,-12(fp)
}
811058f4:	e037883a 	mov	sp,fp
811058f8:	dfc00117 	ldw	ra,4(sp)
811058fc:	df000017 	ldw	fp,0(sp)
81105900:	dec00204 	addi	sp,sp,8
81105904:	f800283a 	ret

81105908 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81105908:	defffb04 	addi	sp,sp,-20
8110590c:	de00012e 	bgeu	sp,et,81105914 <bFeebSetWindowing+0xc>
81105910:	003b68fa 	trap	3
81105914:	dfc00415 	stw	ra,16(sp)
81105918:	df000315 	stw	fp,12(sp)
8110591c:	df000304 	addi	fp,sp,12
81105920:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105924:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105928:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110592c:	e0bfff17 	ldw	r2,-4(fp)
81105930:	10001926 	beq	r2,zero,81105998 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105934:	e0bfff17 	ldw	r2,-4(fp)
81105938:	10800017 	ldw	r2,0(r2)
8110593c:	01400084 	movi	r5,2
81105940:	1009883a 	mov	r4,r2
81105944:	1105da80 	call	81105da8 <uliFeebReadReg>
81105948:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
8110594c:	e0bfff17 	ldw	r2,-4(fp)
81105950:	10800117 	ldw	r2,4(r2)
81105954:	10000426 	beq	r2,zero,81105968 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81105958:	e0bffe17 	ldw	r2,-8(fp)
8110595c:	10800214 	ori	r2,r2,8
81105960:	e0bffe15 	stw	r2,-8(fp)
81105964:	00000406 	br	81105978 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81105968:	e0fffe17 	ldw	r3,-8(fp)
8110596c:	00bffdc4 	movi	r2,-9
81105970:	1884703a 	and	r2,r3,r2
81105974:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105978:	e0bfff17 	ldw	r2,-4(fp)
8110597c:	10800017 	ldw	r2,0(r2)
81105980:	e1bffe17 	ldw	r6,-8(fp)
81105984:	01400084 	movi	r5,2
81105988:	1009883a 	mov	r4,r2
8110598c:	1105d540 	call	81105d54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105990:	00800044 	movi	r2,1
81105994:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105998:	e0bffd17 	ldw	r2,-12(fp)
}
8110599c:	e037883a 	mov	sp,fp
811059a0:	dfc00117 	ldw	ra,4(sp)
811059a4:	df000017 	ldw	fp,0(sp)
811059a8:	dec00204 	addi	sp,sp,8
811059ac:	f800283a 	ret

811059b0 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
811059b0:	defffb04 	addi	sp,sp,-20
811059b4:	de00012e 	bgeu	sp,et,811059bc <bFeebGetWindowing+0xc>
811059b8:	003b68fa 	trap	3
811059bc:	dfc00415 	stw	ra,16(sp)
811059c0:	df000315 	stw	fp,12(sp)
811059c4:	df000304 	addi	fp,sp,12
811059c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811059cc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811059d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811059d4:	e0bfff17 	ldw	r2,-4(fp)
811059d8:	10001126 	beq	r2,zero,81105a20 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811059dc:	e0bfff17 	ldw	r2,-4(fp)
811059e0:	10800017 	ldw	r2,0(r2)
811059e4:	01400084 	movi	r5,2
811059e8:	1009883a 	mov	r4,r2
811059ec:	1105da80 	call	81105da8 <uliFeebReadReg>
811059f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
811059f4:	e0bffe17 	ldw	r2,-8(fp)
811059f8:	1080020c 	andi	r2,r2,8
811059fc:	10000426 	beq	r2,zero,81105a10 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81105a00:	e0bfff17 	ldw	r2,-4(fp)
81105a04:	00c00044 	movi	r3,1
81105a08:	10c00115 	stw	r3,4(r2)
81105a0c:	00000206 	br	81105a18 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105a10:	e0bfff17 	ldw	r2,-4(fp)
81105a14:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81105a18:	00800044 	movi	r2,1
81105a1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105a20:	e0bffd17 	ldw	r2,-12(fp)
}
81105a24:	e037883a 	mov	sp,fp
81105a28:	dfc00117 	ldw	ra,4(sp)
81105a2c:	df000017 	ldw	fp,0(sp)
81105a30:	dec00204 	addi	sp,sp,8
81105a34:	f800283a 	ret

81105a38 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81105a38:	defffb04 	addi	sp,sp,-20
81105a3c:	de00012e 	bgeu	sp,et,81105a44 <bFeebStartCh+0xc>
81105a40:	003b68fa 	trap	3
81105a44:	dfc00415 	stw	ra,16(sp)
81105a48:	df000315 	stw	fp,12(sp)
81105a4c:	df000304 	addi	fp,sp,12
81105a50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105a54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105a58:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105a5c:	e0bfff17 	ldw	r2,-4(fp)
81105a60:	10001126 	beq	r2,zero,81105aa8 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105a64:	e0bfff17 	ldw	r2,-4(fp)
81105a68:	10800017 	ldw	r2,0(r2)
81105a6c:	01400084 	movi	r5,2
81105a70:	1009883a 	mov	r4,r2
81105a74:	1105da80 	call	81105da8 <uliFeebReadReg>
81105a78:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81105a7c:	e0bffe17 	ldw	r2,-8(fp)
81105a80:	10800114 	ori	r2,r2,4
81105a84:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105a88:	e0bfff17 	ldw	r2,-4(fp)
81105a8c:	10800017 	ldw	r2,0(r2)
81105a90:	e1bffe17 	ldw	r6,-8(fp)
81105a94:	01400084 	movi	r5,2
81105a98:	1009883a 	mov	r4,r2
81105a9c:	1105d540 	call	81105d54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105aa0:	00800044 	movi	r2,1
81105aa4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105aa8:	e0bffd17 	ldw	r2,-12(fp)
}
81105aac:	e037883a 	mov	sp,fp
81105ab0:	dfc00117 	ldw	ra,4(sp)
81105ab4:	df000017 	ldw	fp,0(sp)
81105ab8:	dec00204 	addi	sp,sp,8
81105abc:	f800283a 	ret

81105ac0 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81105ac0:	defffb04 	addi	sp,sp,-20
81105ac4:	de00012e 	bgeu	sp,et,81105acc <bFeebStopCh+0xc>
81105ac8:	003b68fa 	trap	3
81105acc:	dfc00415 	stw	ra,16(sp)
81105ad0:	df000315 	stw	fp,12(sp)
81105ad4:	df000304 	addi	fp,sp,12
81105ad8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105adc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ae0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105ae4:	e0bfff17 	ldw	r2,-4(fp)
81105ae8:	10001126 	beq	r2,zero,81105b30 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105aec:	e0bfff17 	ldw	r2,-4(fp)
81105af0:	10800017 	ldw	r2,0(r2)
81105af4:	01400084 	movi	r5,2
81105af8:	1009883a 	mov	r4,r2
81105afc:	1105da80 	call	81105da8 <uliFeebReadReg>
81105b00:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81105b04:	e0bffe17 	ldw	r2,-8(fp)
81105b08:	10800094 	ori	r2,r2,2
81105b0c:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105b10:	e0bfff17 	ldw	r2,-4(fp)
81105b14:	10800017 	ldw	r2,0(r2)
81105b18:	e1bffe17 	ldw	r6,-8(fp)
81105b1c:	01400084 	movi	r5,2
81105b20:	1009883a 	mov	r4,r2
81105b24:	1105d540 	call	81105d54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105b28:	00800044 	movi	r2,1
81105b2c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b30:	e0bffd17 	ldw	r2,-12(fp)
}
81105b34:	e037883a 	mov	sp,fp
81105b38:	dfc00117 	ldw	ra,4(sp)
81105b3c:	df000017 	ldw	fp,0(sp)
81105b40:	dec00204 	addi	sp,sp,8
81105b44:	f800283a 	ret

81105b48 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81105b48:	defffb04 	addi	sp,sp,-20
81105b4c:	de00012e 	bgeu	sp,et,81105b54 <bFeebClrCh+0xc>
81105b50:	003b68fa 	trap	3
81105b54:	dfc00415 	stw	ra,16(sp)
81105b58:	df000315 	stw	fp,12(sp)
81105b5c:	df000304 	addi	fp,sp,12
81105b60:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105b64:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105b68:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105b6c:	e0bfff17 	ldw	r2,-4(fp)
81105b70:	10001126 	beq	r2,zero,81105bb8 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105b74:	e0bfff17 	ldw	r2,-4(fp)
81105b78:	10800017 	ldw	r2,0(r2)
81105b7c:	01400084 	movi	r5,2
81105b80:	1009883a 	mov	r4,r2
81105b84:	1105da80 	call	81105da8 <uliFeebReadReg>
81105b88:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81105b8c:	e0bffe17 	ldw	r2,-8(fp)
81105b90:	10800054 	ori	r2,r2,1
81105b94:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105b98:	e0bfff17 	ldw	r2,-4(fp)
81105b9c:	10800017 	ldw	r2,0(r2)
81105ba0:	e1bffe17 	ldw	r6,-8(fp)
81105ba4:	01400084 	movi	r5,2
81105ba8:	1009883a 	mov	r4,r2
81105bac:	1105d540 	call	81105d54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105bb0:	00800044 	movi	r2,1
81105bb4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105bb8:	e0bffd17 	ldw	r2,-12(fp)
}
81105bbc:	e037883a 	mov	sp,fp
81105bc0:	dfc00117 	ldw	ra,4(sp)
81105bc4:	df000017 	ldw	fp,0(sp)
81105bc8:	dec00204 	addi	sp,sp,8
81105bcc:	f800283a 	ret

81105bd0 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81105bd0:	defffb04 	addi	sp,sp,-20
81105bd4:	de00012e 	bgeu	sp,et,81105bdc <bFeebInitCh+0xc>
81105bd8:	003b68fa 	trap	3
81105bdc:	dfc00415 	stw	ra,16(sp)
81105be0:	df000315 	stw	fp,12(sp)
81105be4:	df000304 	addi	fp,sp,12
81105be8:	e13ffe15 	stw	r4,-8(fp)
81105bec:	2805883a 	mov	r2,r5
81105bf0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105bf4:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81105bf8:	e0bffe17 	ldw	r2,-8(fp)
81105bfc:	10004f26 	beq	r2,zero,81105d3c <bFeebInitCh+0x16c>
		bStatus = TRUE;
81105c00:	00800044 	movi	r2,1
81105c04:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105c08:	e0bfff03 	ldbu	r2,-4(fp)
81105c0c:	10c00228 	cmpgeui	r3,r2,8
81105c10:	1800361e 	bne	r3,zero,81105cec <bFeebInitCh+0x11c>
81105c14:	100690ba 	slli	r3,r2,2
81105c18:	00a04434 	movhi	r2,33040
81105c1c:	10970b04 	addi	r2,r2,23596
81105c20:	1885883a 	add	r2,r3,r2
81105c24:	10800017 	ldw	r2,0(r2)
81105c28:	1000683a 	jmp	r2
81105c2c:	81105c4c 	andi	r4,r16,16753
81105c30:	81105c60 	cmpeqi	r4,r16,16753
81105c34:	81105c74 	orhi	r4,r16,16753
81105c38:	81105c88 	cmpgei	r4,r16,16754
81105c3c:	81105c9c 	xori	r4,r16,16754
81105c40:	81105cb0 	cmpltui	r4,r16,16754
81105c44:	81105cc4 	addi	r4,r16,16755
81105c48:	81105cd8 	cmpnei	r4,r16,16755
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105c4c:	e0fffe17 	ldw	r3,-8(fp)
81105c50:	00a04834 	movhi	r2,33056
81105c54:	108b0004 	addi	r2,r2,11264
81105c58:	18800015 	stw	r2,0(r3)
			break;
81105c5c:	00002506 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105c60:	e0fffe17 	ldw	r3,-8(fp)
81105c64:	00a04834 	movhi	r2,33056
81105c68:	108a0004 	addi	r2,r2,10240
81105c6c:	18800015 	stw	r2,0(r3)
			break;
81105c70:	00002006 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105c74:	e0fffe17 	ldw	r3,-8(fp)
81105c78:	00a04834 	movhi	r2,33056
81105c7c:	10890004 	addi	r2,r2,9216
81105c80:	18800015 	stw	r2,0(r3)
			break;
81105c84:	00001b06 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81105c88:	e0fffe17 	ldw	r3,-8(fp)
81105c8c:	00a04834 	movhi	r2,33056
81105c90:	10880004 	addi	r2,r2,8192
81105c94:	18800015 	stw	r2,0(r3)
			break;
81105c98:	00001606 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81105c9c:	e0fffe17 	ldw	r3,-8(fp)
81105ca0:	00a04834 	movhi	r2,33056
81105ca4:	10870004 	addi	r2,r2,7168
81105ca8:	18800015 	stw	r2,0(r3)
			break;
81105cac:	00001106 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81105cb0:	e0fffe17 	ldw	r3,-8(fp)
81105cb4:	00a04834 	movhi	r2,33056
81105cb8:	10860004 	addi	r2,r2,6144
81105cbc:	18800015 	stw	r2,0(r3)
			break;
81105cc0:	00000c06 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81105cc4:	e0fffe17 	ldw	r3,-8(fp)
81105cc8:	00a04834 	movhi	r2,33056
81105ccc:	10850004 	addi	r2,r2,5120
81105cd0:	18800015 	stw	r2,0(r3)
			break;
81105cd4:	00000706 	br	81105cf4 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81105cd8:	e0fffe17 	ldw	r3,-8(fp)
81105cdc:	00a04834 	movhi	r2,33056
81105ce0:	10840004 	addi	r2,r2,4096
81105ce4:	18800015 	stw	r2,0(r3)
			break;
81105ce8:	00000206 	br	81105cf4 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81105cec:	e03ffd15 	stw	zero,-12(fp)
			break;
81105cf0:	0001883a 	nop
		}

		if (bStatus) {
81105cf4:	e0bffd17 	ldw	r2,-12(fp)
81105cf8:	10001026 	beq	r2,zero,81105d3c <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81105cfc:	e13ffe17 	ldw	r4,-8(fp)
81105d00:	11057280 	call	81105728 <bFeebGetIrqControl>
81105d04:	1000011e 	bne	r2,zero,81105d0c <bFeebInitCh+0x13c>
				bStatus = FALSE;
81105d08:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81105d0c:	e13ffe17 	ldw	r4,-8(fp)
81105d10:	11057d40 	call	811057d4 <bFeebGetIrqFlags>
81105d14:	1000011e 	bne	r2,zero,81105d1c <bFeebInitCh+0x14c>
				bStatus = FALSE;
81105d18:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81105d1c:	e13ffe17 	ldw	r4,-8(fp)
81105d20:	110585c0 	call	8110585c <bFeebGetBuffersStatus>
81105d24:	1000011e 	bne	r2,zero,81105d2c <bFeebInitCh+0x15c>
				bStatus = FALSE;
81105d28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81105d2c:	e13ffe17 	ldw	r4,-8(fp)
81105d30:	11059b00 	call	811059b0 <bFeebGetWindowing>
81105d34:	1000011e 	bne	r2,zero,81105d3c <bFeebInitCh+0x16c>
				bStatus = FALSE;
81105d38:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81105d3c:	e0bffd17 	ldw	r2,-12(fp)
}
81105d40:	e037883a 	mov	sp,fp
81105d44:	dfc00117 	ldw	ra,4(sp)
81105d48:	df000017 	ldw	fp,0(sp)
81105d4c:	dec00204 	addi	sp,sp,8
81105d50:	f800283a 	ret

81105d54 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81105d54:	defffc04 	addi	sp,sp,-16
81105d58:	de00012e 	bgeu	sp,et,81105d60 <vFeebWriteReg+0xc>
81105d5c:	003b68fa 	trap	3
81105d60:	df000315 	stw	fp,12(sp)
81105d64:	df000304 	addi	fp,sp,12
81105d68:	e13ffd15 	stw	r4,-12(fp)
81105d6c:	e17ffe15 	stw	r5,-8(fp)
81105d70:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81105d74:	e0bffe17 	ldw	r2,-8(fp)
81105d78:	1085883a 	add	r2,r2,r2
81105d7c:	1085883a 	add	r2,r2,r2
81105d80:	1007883a 	mov	r3,r2
81105d84:	e0bffd17 	ldw	r2,-12(fp)
81105d88:	10c5883a 	add	r2,r2,r3
81105d8c:	e0ffff17 	ldw	r3,-4(fp)
81105d90:	10c00015 	stw	r3,0(r2)
}
81105d94:	0001883a 	nop
81105d98:	e037883a 	mov	sp,fp
81105d9c:	df000017 	ldw	fp,0(sp)
81105da0:	dec00104 	addi	sp,sp,4
81105da4:	f800283a 	ret

81105da8 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105da8:	defffc04 	addi	sp,sp,-16
81105dac:	de00012e 	bgeu	sp,et,81105db4 <uliFeebReadReg+0xc>
81105db0:	003b68fa 	trap	3
81105db4:	df000315 	stw	fp,12(sp)
81105db8:	df000304 	addi	fp,sp,12
81105dbc:	e13ffe15 	stw	r4,-8(fp)
81105dc0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105dc4:	e0bfff17 	ldw	r2,-4(fp)
81105dc8:	1085883a 	add	r2,r2,r2
81105dcc:	1085883a 	add	r2,r2,r2
81105dd0:	1007883a 	mov	r3,r2
81105dd4:	e0bffe17 	ldw	r2,-8(fp)
81105dd8:	10c5883a 	add	r2,r2,r3
81105ddc:	10800017 	ldw	r2,0(r2)
81105de0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105de4:	e0bffd17 	ldw	r2,-12(fp)
}
81105de8:	e037883a 	mov	sp,fp
81105dec:	df000017 	ldw	fp,0(sp)
81105df0:	dec00104 	addi	sp,sp,4
81105df4:	f800283a 	ret

81105df8 <vRmapCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRmapCh1HandleIrq(void* pvContext) {
81105df8:	defffc04 	addi	sp,sp,-16
81105dfc:	de00012e 	bgeu	sp,et,81105e04 <vRmapCh1HandleIrq+0xc>
81105e00:	003b68fa 	trap	3
81105e04:	dfc00315 	stw	ra,12(sp)
81105e08:	df000215 	stw	fp,8(sp)
81105e0c:	df000204 	addi	fp,sp,8
81105e10:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105e14:	e0bfff17 	ldw	r2,-4(fp)
81105e18:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh1IrqFlagClrWriteCmd();
81105e1c:	1105ff80 	call	81105ff8 <vRmapCh1IrqFlagClrWriteCmd>
}
81105e20:	0001883a 	nop
81105e24:	e037883a 	mov	sp,fp
81105e28:	dfc00117 	ldw	ra,4(sp)
81105e2c:	df000017 	ldw	fp,0(sp)
81105e30:	dec00204 	addi	sp,sp,8
81105e34:	f800283a 	ret

81105e38 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81105e38:	defffc04 	addi	sp,sp,-16
81105e3c:	de00012e 	bgeu	sp,et,81105e44 <vRmapCh2HandleIrq+0xc>
81105e40:	003b68fa 	trap	3
81105e44:	dfc00315 	stw	ra,12(sp)
81105e48:	df000215 	stw	fp,8(sp)
81105e4c:	df000204 	addi	fp,sp,8
81105e50:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105e54:	e0bfff17 	ldw	r2,-4(fp)
81105e58:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81105e5c:	110603c0 	call	8110603c <vRmapCh2IrqFlagClrWriteCmd>
}
81105e60:	0001883a 	nop
81105e64:	e037883a 	mov	sp,fp
81105e68:	dfc00117 	ldw	ra,4(sp)
81105e6c:	df000017 	ldw	fp,0(sp)
81105e70:	dec00204 	addi	sp,sp,8
81105e74:	f800283a 	ret

81105e78 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81105e78:	defffc04 	addi	sp,sp,-16
81105e7c:	de00012e 	bgeu	sp,et,81105e84 <vRmapCh3HandleIrq+0xc>
81105e80:	003b68fa 	trap	3
81105e84:	dfc00315 	stw	ra,12(sp)
81105e88:	df000215 	stw	fp,8(sp)
81105e8c:	df000204 	addi	fp,sp,8
81105e90:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105e94:	e0bfff17 	ldw	r2,-4(fp)
81105e98:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81105e9c:	11060800 	call	81106080 <vRmapCh3IrqFlagClrWriteCmd>
}
81105ea0:	0001883a 	nop
81105ea4:	e037883a 	mov	sp,fp
81105ea8:	dfc00117 	ldw	ra,4(sp)
81105eac:	df000017 	ldw	fp,0(sp)
81105eb0:	dec00204 	addi	sp,sp,8
81105eb4:	f800283a 	ret

81105eb8 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81105eb8:	defffc04 	addi	sp,sp,-16
81105ebc:	de00012e 	bgeu	sp,et,81105ec4 <vRmapCh4HandleIrq+0xc>
81105ec0:	003b68fa 	trap	3
81105ec4:	dfc00315 	stw	ra,12(sp)
81105ec8:	df000215 	stw	fp,8(sp)
81105ecc:	df000204 	addi	fp,sp,8
81105ed0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105ed4:	e0bfff17 	ldw	r2,-4(fp)
81105ed8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81105edc:	11060c40 	call	811060c4 <vRmapCh4IrqFlagClrWriteCmd>
}
81105ee0:	0001883a 	nop
81105ee4:	e037883a 	mov	sp,fp
81105ee8:	dfc00117 	ldw	ra,4(sp)
81105eec:	df000017 	ldw	fp,0(sp)
81105ef0:	dec00204 	addi	sp,sp,8
81105ef4:	f800283a 	ret

81105ef8 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81105ef8:	defffc04 	addi	sp,sp,-16
81105efc:	de00012e 	bgeu	sp,et,81105f04 <vRmapCh5HandleIrq+0xc>
81105f00:	003b68fa 	trap	3
81105f04:	dfc00315 	stw	ra,12(sp)
81105f08:	df000215 	stw	fp,8(sp)
81105f0c:	df000204 	addi	fp,sp,8
81105f10:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105f14:	e0bfff17 	ldw	r2,-4(fp)
81105f18:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81105f1c:	11061080 	call	81106108 <vRmapCh5IrqFlagClrWriteCmd>
}
81105f20:	0001883a 	nop
81105f24:	e037883a 	mov	sp,fp
81105f28:	dfc00117 	ldw	ra,4(sp)
81105f2c:	df000017 	ldw	fp,0(sp)
81105f30:	dec00204 	addi	sp,sp,8
81105f34:	f800283a 	ret

81105f38 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81105f38:	defffc04 	addi	sp,sp,-16
81105f3c:	de00012e 	bgeu	sp,et,81105f44 <vRmapCh6HandleIrq+0xc>
81105f40:	003b68fa 	trap	3
81105f44:	dfc00315 	stw	ra,12(sp)
81105f48:	df000215 	stw	fp,8(sp)
81105f4c:	df000204 	addi	fp,sp,8
81105f50:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105f54:	e0bfff17 	ldw	r2,-4(fp)
81105f58:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81105f5c:	110614c0 	call	8110614c <vRmapCh6IrqFlagClrWriteCmd>
}
81105f60:	0001883a 	nop
81105f64:	e037883a 	mov	sp,fp
81105f68:	dfc00117 	ldw	ra,4(sp)
81105f6c:	df000017 	ldw	fp,0(sp)
81105f70:	dec00204 	addi	sp,sp,8
81105f74:	f800283a 	ret

81105f78 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81105f78:	defffc04 	addi	sp,sp,-16
81105f7c:	de00012e 	bgeu	sp,et,81105f84 <vRmapCh7HandleIrq+0xc>
81105f80:	003b68fa 	trap	3
81105f84:	dfc00315 	stw	ra,12(sp)
81105f88:	df000215 	stw	fp,8(sp)
81105f8c:	df000204 	addi	fp,sp,8
81105f90:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105f94:	e0bfff17 	ldw	r2,-4(fp)
81105f98:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81105f9c:	11061900 	call	81106190 <vRmapCh7IrqFlagClrWriteCmd>
}
81105fa0:	0001883a 	nop
81105fa4:	e037883a 	mov	sp,fp
81105fa8:	dfc00117 	ldw	ra,4(sp)
81105fac:	df000017 	ldw	fp,0(sp)
81105fb0:	dec00204 	addi	sp,sp,8
81105fb4:	f800283a 	ret

81105fb8 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81105fb8:	defffc04 	addi	sp,sp,-16
81105fbc:	de00012e 	bgeu	sp,et,81105fc4 <vRmapCh8HandleIrq+0xc>
81105fc0:	003b68fa 	trap	3
81105fc4:	dfc00315 	stw	ra,12(sp)
81105fc8:	df000215 	stw	fp,8(sp)
81105fcc:	df000204 	addi	fp,sp,8
81105fd0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105fd4:	e0bfff17 	ldw	r2,-4(fp)
81105fd8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81105fdc:	11061d40 	call	811061d4 <vRmapCh8IrqFlagClrWriteCmd>
}
81105fe0:	0001883a 	nop
81105fe4:	e037883a 	mov	sp,fp
81105fe8:	dfc00117 	ldw	ra,4(sp)
81105fec:	df000017 	ldw	fp,0(sp)
81105ff0:	dec00204 	addi	sp,sp,8
81105ff4:	f800283a 	ret

81105ff8 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81105ff8:	defffe04 	addi	sp,sp,-8
81105ffc:	de00012e 	bgeu	sp,et,81106004 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106000:	003b68fa 	trap	3
81106004:	dfc00115 	stw	ra,4(sp)
81106008:	df000015 	stw	fp,0(sp)
8110600c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106010:	01800044 	movi	r6,1
81106014:	014004c4 	movi	r5,19
81106018:	01204834 	movhi	r4,33056
8110601c:	210b0004 	addi	r4,r4,11264
81106020:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106024:	0001883a 	nop
81106028:	e037883a 	mov	sp,fp
8110602c:	dfc00117 	ldw	ra,4(sp)
81106030:	df000017 	ldw	fp,0(sp)
81106034:	dec00204 	addi	sp,sp,8
81106038:	f800283a 	ret

8110603c <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
8110603c:	defffe04 	addi	sp,sp,-8
81106040:	de00012e 	bgeu	sp,et,81106048 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106044:	003b68fa 	trap	3
81106048:	dfc00115 	stw	ra,4(sp)
8110604c:	df000015 	stw	fp,0(sp)
81106050:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106054:	01800044 	movi	r6,1
81106058:	014004c4 	movi	r5,19
8110605c:	01204834 	movhi	r4,33056
81106060:	210a0004 	addi	r4,r4,10240
81106064:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106068:	0001883a 	nop
8110606c:	e037883a 	mov	sp,fp
81106070:	dfc00117 	ldw	ra,4(sp)
81106074:	df000017 	ldw	fp,0(sp)
81106078:	dec00204 	addi	sp,sp,8
8110607c:	f800283a 	ret

81106080 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106080:	defffe04 	addi	sp,sp,-8
81106084:	de00012e 	bgeu	sp,et,8110608c <vRmapCh3IrqFlagClrWriteCmd+0xc>
81106088:	003b68fa 	trap	3
8110608c:	dfc00115 	stw	ra,4(sp)
81106090:	df000015 	stw	fp,0(sp)
81106094:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106098:	01800044 	movi	r6,1
8110609c:	014004c4 	movi	r5,19
811060a0:	01204834 	movhi	r4,33056
811060a4:	21090004 	addi	r4,r4,9216
811060a8:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811060ac:	0001883a 	nop
811060b0:	e037883a 	mov	sp,fp
811060b4:	dfc00117 	ldw	ra,4(sp)
811060b8:	df000017 	ldw	fp,0(sp)
811060bc:	dec00204 	addi	sp,sp,8
811060c0:	f800283a 	ret

811060c4 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
811060c4:	defffe04 	addi	sp,sp,-8
811060c8:	de00012e 	bgeu	sp,et,811060d0 <vRmapCh4IrqFlagClrWriteCmd+0xc>
811060cc:	003b68fa 	trap	3
811060d0:	dfc00115 	stw	ra,4(sp)
811060d4:	df000015 	stw	fp,0(sp)
811060d8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811060dc:	01800044 	movi	r6,1
811060e0:	014004c4 	movi	r5,19
811060e4:	01204834 	movhi	r4,33056
811060e8:	21080004 	addi	r4,r4,8192
811060ec:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811060f0:	0001883a 	nop
811060f4:	e037883a 	mov	sp,fp
811060f8:	dfc00117 	ldw	ra,4(sp)
811060fc:	df000017 	ldw	fp,0(sp)
81106100:	dec00204 	addi	sp,sp,8
81106104:	f800283a 	ret

81106108 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81106108:	defffe04 	addi	sp,sp,-8
8110610c:	de00012e 	bgeu	sp,et,81106114 <vRmapCh5IrqFlagClrWriteCmd+0xc>
81106110:	003b68fa 	trap	3
81106114:	dfc00115 	stw	ra,4(sp)
81106118:	df000015 	stw	fp,0(sp)
8110611c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106120:	01800044 	movi	r6,1
81106124:	014004c4 	movi	r5,19
81106128:	01204834 	movhi	r4,33056
8110612c:	21070004 	addi	r4,r4,7168
81106130:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106134:	0001883a 	nop
81106138:	e037883a 	mov	sp,fp
8110613c:	dfc00117 	ldw	ra,4(sp)
81106140:	df000017 	ldw	fp,0(sp)
81106144:	dec00204 	addi	sp,sp,8
81106148:	f800283a 	ret

8110614c <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
8110614c:	defffe04 	addi	sp,sp,-8
81106150:	de00012e 	bgeu	sp,et,81106158 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81106154:	003b68fa 	trap	3
81106158:	dfc00115 	stw	ra,4(sp)
8110615c:	df000015 	stw	fp,0(sp)
81106160:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106164:	01800044 	movi	r6,1
81106168:	014004c4 	movi	r5,19
8110616c:	01204834 	movhi	r4,33056
81106170:	21060004 	addi	r4,r4,6144
81106174:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106178:	0001883a 	nop
8110617c:	e037883a 	mov	sp,fp
81106180:	dfc00117 	ldw	ra,4(sp)
81106184:	df000017 	ldw	fp,0(sp)
81106188:	dec00204 	addi	sp,sp,8
8110618c:	f800283a 	ret

81106190 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81106190:	defffe04 	addi	sp,sp,-8
81106194:	de00012e 	bgeu	sp,et,8110619c <vRmapCh7IrqFlagClrWriteCmd+0xc>
81106198:	003b68fa 	trap	3
8110619c:	dfc00115 	stw	ra,4(sp)
811061a0:	df000015 	stw	fp,0(sp)
811061a4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811061a8:	01800044 	movi	r6,1
811061ac:	014004c4 	movi	r5,19
811061b0:	01204834 	movhi	r4,33056
811061b4:	21050004 	addi	r4,r4,5120
811061b8:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811061bc:	0001883a 	nop
811061c0:	e037883a 	mov	sp,fp
811061c4:	dfc00117 	ldw	ra,4(sp)
811061c8:	df000017 	ldw	fp,0(sp)
811061cc:	dec00204 	addi	sp,sp,8
811061d0:	f800283a 	ret

811061d4 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
811061d4:	defffe04 	addi	sp,sp,-8
811061d8:	de00012e 	bgeu	sp,et,811061e0 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811061dc:	003b68fa 	trap	3
811061e0:	dfc00115 	stw	ra,4(sp)
811061e4:	df000015 	stw	fp,0(sp)
811061e8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811061ec:	01800044 	movi	r6,1
811061f0:	014004c4 	movi	r5,19
811061f4:	01204834 	movhi	r4,33056
811061f8:	21040004 	addi	r4,r4,4096
811061fc:	1108ac00 	call	81108ac0 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106200:	0001883a 	nop
81106204:	e037883a 	mov	sp,fp
81106208:	dfc00117 	ldw	ra,4(sp)
8110620c:	df000017 	ldw	fp,0(sp)
81106210:	dec00204 	addi	sp,sp,8
81106214:	f800283a 	ret

81106218 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
81106218:	defffd04 	addi	sp,sp,-12
8110621c:	de00012e 	bgeu	sp,et,81106224 <bRmapCh1IrqFlagWriteCmd+0xc>
81106220:	003b68fa 	trap	3
81106224:	dfc00215 	stw	ra,8(sp)
81106228:	df000115 	stw	fp,4(sp)
8110622c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106230:	01400484 	movi	r5,18
81106234:	01204834 	movhi	r4,33056
81106238:	210b0004 	addi	r4,r4,11264
8110623c:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106240:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106244:	10000326 	beq	r2,zero,81106254 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106248:	00800044 	movi	r2,1
8110624c:	e0bfff15 	stw	r2,-4(fp)
81106250:	00000106 	br	81106258 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106254:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106258:	e0bfff17 	ldw	r2,-4(fp)
}
8110625c:	e037883a 	mov	sp,fp
81106260:	dfc00117 	ldw	ra,4(sp)
81106264:	df000017 	ldw	fp,0(sp)
81106268:	dec00204 	addi	sp,sp,8
8110626c:	f800283a 	ret

81106270 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81106270:	defffd04 	addi	sp,sp,-12
81106274:	de00012e 	bgeu	sp,et,8110627c <bRmapCh2IrqFlagWriteCmd+0xc>
81106278:	003b68fa 	trap	3
8110627c:	dfc00215 	stw	ra,8(sp)
81106280:	df000115 	stw	fp,4(sp)
81106284:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106288:	01400484 	movi	r5,18
8110628c:	01204834 	movhi	r4,33056
81106290:	210a0004 	addi	r4,r4,10240
81106294:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106298:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110629c:	10000326 	beq	r2,zero,811062ac <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811062a0:	00800044 	movi	r2,1
811062a4:	e0bfff15 	stw	r2,-4(fp)
811062a8:	00000106 	br	811062b0 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811062ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811062b0:	e0bfff17 	ldw	r2,-4(fp)
}
811062b4:	e037883a 	mov	sp,fp
811062b8:	dfc00117 	ldw	ra,4(sp)
811062bc:	df000017 	ldw	fp,0(sp)
811062c0:	dec00204 	addi	sp,sp,8
811062c4:	f800283a 	ret

811062c8 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
811062c8:	defffd04 	addi	sp,sp,-12
811062cc:	de00012e 	bgeu	sp,et,811062d4 <bRmapCh3IrqFlagWriteCmd+0xc>
811062d0:	003b68fa 	trap	3
811062d4:	dfc00215 	stw	ra,8(sp)
811062d8:	df000115 	stw	fp,4(sp)
811062dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811062e0:	01400484 	movi	r5,18
811062e4:	01204834 	movhi	r4,33056
811062e8:	21090004 	addi	r4,r4,9216
811062ec:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811062f0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811062f4:	10000326 	beq	r2,zero,81106304 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811062f8:	00800044 	movi	r2,1
811062fc:	e0bfff15 	stw	r2,-4(fp)
81106300:	00000106 	br	81106308 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106304:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106308:	e0bfff17 	ldw	r2,-4(fp)
}
8110630c:	e037883a 	mov	sp,fp
81106310:	dfc00117 	ldw	ra,4(sp)
81106314:	df000017 	ldw	fp,0(sp)
81106318:	dec00204 	addi	sp,sp,8
8110631c:	f800283a 	ret

81106320 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
81106320:	defffd04 	addi	sp,sp,-12
81106324:	de00012e 	bgeu	sp,et,8110632c <bRmapCh4IrqFlagWriteCmd+0xc>
81106328:	003b68fa 	trap	3
8110632c:	dfc00215 	stw	ra,8(sp)
81106330:	df000115 	stw	fp,4(sp)
81106334:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106338:	01400484 	movi	r5,18
8110633c:	01204834 	movhi	r4,33056
81106340:	21080004 	addi	r4,r4,8192
81106344:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106348:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110634c:	10000326 	beq	r2,zero,8110635c <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106350:	00800044 	movi	r2,1
81106354:	e0bfff15 	stw	r2,-4(fp)
81106358:	00000106 	br	81106360 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110635c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106360:	e0bfff17 	ldw	r2,-4(fp)
}
81106364:	e037883a 	mov	sp,fp
81106368:	dfc00117 	ldw	ra,4(sp)
8110636c:	df000017 	ldw	fp,0(sp)
81106370:	dec00204 	addi	sp,sp,8
81106374:	f800283a 	ret

81106378 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81106378:	defffd04 	addi	sp,sp,-12
8110637c:	de00012e 	bgeu	sp,et,81106384 <bRmapCh5IrqFlagWriteCmd+0xc>
81106380:	003b68fa 	trap	3
81106384:	dfc00215 	stw	ra,8(sp)
81106388:	df000115 	stw	fp,4(sp)
8110638c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106390:	01400484 	movi	r5,18
81106394:	01204834 	movhi	r4,33056
81106398:	21070004 	addi	r4,r4,7168
8110639c:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811063a0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811063a4:	10000326 	beq	r2,zero,811063b4 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811063a8:	00800044 	movi	r2,1
811063ac:	e0bfff15 	stw	r2,-4(fp)
811063b0:	00000106 	br	811063b8 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811063b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811063b8:	e0bfff17 	ldw	r2,-4(fp)
}
811063bc:	e037883a 	mov	sp,fp
811063c0:	dfc00117 	ldw	ra,4(sp)
811063c4:	df000017 	ldw	fp,0(sp)
811063c8:	dec00204 	addi	sp,sp,8
811063cc:	f800283a 	ret

811063d0 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
811063d0:	defffd04 	addi	sp,sp,-12
811063d4:	de00012e 	bgeu	sp,et,811063dc <bRmapCh6IrqFlagWriteCmd+0xc>
811063d8:	003b68fa 	trap	3
811063dc:	dfc00215 	stw	ra,8(sp)
811063e0:	df000115 	stw	fp,4(sp)
811063e4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811063e8:	01400484 	movi	r5,18
811063ec:	01204834 	movhi	r4,33056
811063f0:	21060004 	addi	r4,r4,6144
811063f4:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811063f8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811063fc:	10000326 	beq	r2,zero,8110640c <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106400:	00800044 	movi	r2,1
81106404:	e0bfff15 	stw	r2,-4(fp)
81106408:	00000106 	br	81106410 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110640c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106410:	e0bfff17 	ldw	r2,-4(fp)
}
81106414:	e037883a 	mov	sp,fp
81106418:	dfc00117 	ldw	ra,4(sp)
8110641c:	df000017 	ldw	fp,0(sp)
81106420:	dec00204 	addi	sp,sp,8
81106424:	f800283a 	ret

81106428 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
81106428:	defffd04 	addi	sp,sp,-12
8110642c:	de00012e 	bgeu	sp,et,81106434 <bRmapCh7IrqFlagWriteCmd+0xc>
81106430:	003b68fa 	trap	3
81106434:	dfc00215 	stw	ra,8(sp)
81106438:	df000115 	stw	fp,4(sp)
8110643c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106440:	01400484 	movi	r5,18
81106444:	01204834 	movhi	r4,33056
81106448:	21050004 	addi	r4,r4,5120
8110644c:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106450:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106454:	10000326 	beq	r2,zero,81106464 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106458:	00800044 	movi	r2,1
8110645c:	e0bfff15 	stw	r2,-4(fp)
81106460:	00000106 	br	81106468 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106464:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106468:	e0bfff17 	ldw	r2,-4(fp)
}
8110646c:	e037883a 	mov	sp,fp
81106470:	dfc00117 	ldw	ra,4(sp)
81106474:	df000017 	ldw	fp,0(sp)
81106478:	dec00204 	addi	sp,sp,8
8110647c:	f800283a 	ret

81106480 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81106480:	defffd04 	addi	sp,sp,-12
81106484:	de00012e 	bgeu	sp,et,8110648c <bRmapCh8IrqFlagWriteCmd+0xc>
81106488:	003b68fa 	trap	3
8110648c:	dfc00215 	stw	ra,8(sp)
81106490:	df000115 	stw	fp,4(sp)
81106494:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106498:	01400484 	movi	r5,18
8110649c:	01204834 	movhi	r4,33056
811064a0:	21040004 	addi	r4,r4,4096
811064a4:	1108b140 	call	81108b14 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811064a8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811064ac:	10000326 	beq	r2,zero,811064bc <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811064b0:	00800044 	movi	r2,1
811064b4:	e0bfff15 	stw	r2,-4(fp)
811064b8:	00000106 	br	811064c0 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811064bc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811064c0:	e0bfff17 	ldw	r2,-4(fp)
}
811064c4:	e037883a 	mov	sp,fp
811064c8:	dfc00117 	ldw	ra,4(sp)
811064cc:	df000017 	ldw	fp,0(sp)
811064d0:	dec00204 	addi	sp,sp,8
811064d4:	f800283a 	ret

811064d8 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
811064d8:	defffd04 	addi	sp,sp,-12
811064dc:	de00012e 	bgeu	sp,et,811064e4 <uliRmapCh1WriteCmdAddress+0xc>
811064e0:	003b68fa 	trap	3
811064e4:	dfc00215 	stw	ra,8(sp)
811064e8:	df000115 	stw	fp,4(sp)
811064ec:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811064f0:	01400184 	movi	r5,6
811064f4:	01204834 	movhi	r4,33056
811064f8:	210b0004 	addi	r4,r4,11264
811064fc:	1108b140 	call	81108b14 <uliRmapReadReg>
81106500:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106504:	e13fff17 	ldw	r4,-4(fp)
81106508:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
8110650c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106510:	e0bfff17 	ldw	r2,-4(fp)
}
81106514:	e037883a 	mov	sp,fp
81106518:	dfc00117 	ldw	ra,4(sp)
8110651c:	df000017 	ldw	fp,0(sp)
81106520:	dec00204 	addi	sp,sp,8
81106524:	f800283a 	ret

81106528 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
81106528:	defffd04 	addi	sp,sp,-12
8110652c:	de00012e 	bgeu	sp,et,81106534 <uliRmapCh2WriteCmdAddress+0xc>
81106530:	003b68fa 	trap	3
81106534:	dfc00215 	stw	ra,8(sp)
81106538:	df000115 	stw	fp,4(sp)
8110653c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106540:	01400184 	movi	r5,6
81106544:	01204834 	movhi	r4,33056
81106548:	210a0004 	addi	r4,r4,10240
8110654c:	1108b140 	call	81108b14 <uliRmapReadReg>
81106550:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106554:	e13fff17 	ldw	r4,-4(fp)
81106558:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
8110655c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106560:	e0bfff17 	ldw	r2,-4(fp)
}
81106564:	e037883a 	mov	sp,fp
81106568:	dfc00117 	ldw	ra,4(sp)
8110656c:	df000017 	ldw	fp,0(sp)
81106570:	dec00204 	addi	sp,sp,8
81106574:	f800283a 	ret

81106578 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81106578:	defffd04 	addi	sp,sp,-12
8110657c:	de00012e 	bgeu	sp,et,81106584 <uliRmapCh3WriteCmdAddress+0xc>
81106580:	003b68fa 	trap	3
81106584:	dfc00215 	stw	ra,8(sp)
81106588:	df000115 	stw	fp,4(sp)
8110658c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106590:	01400184 	movi	r5,6
81106594:	01204834 	movhi	r4,33056
81106598:	21090004 	addi	r4,r4,9216
8110659c:	1108b140 	call	81108b14 <uliRmapReadReg>
811065a0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811065a4:	e13fff17 	ldw	r4,-4(fp)
811065a8:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
811065ac:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811065b0:	e0bfff17 	ldw	r2,-4(fp)
}
811065b4:	e037883a 	mov	sp,fp
811065b8:	dfc00117 	ldw	ra,4(sp)
811065bc:	df000017 	ldw	fp,0(sp)
811065c0:	dec00204 	addi	sp,sp,8
811065c4:	f800283a 	ret

811065c8 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
811065c8:	defffd04 	addi	sp,sp,-12
811065cc:	de00012e 	bgeu	sp,et,811065d4 <uliRmapCh4WriteCmdAddress+0xc>
811065d0:	003b68fa 	trap	3
811065d4:	dfc00215 	stw	ra,8(sp)
811065d8:	df000115 	stw	fp,4(sp)
811065dc:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811065e0:	01400184 	movi	r5,6
811065e4:	01204834 	movhi	r4,33056
811065e8:	21080004 	addi	r4,r4,8192
811065ec:	1108b140 	call	81108b14 <uliRmapReadReg>
811065f0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811065f4:	e13fff17 	ldw	r4,-4(fp)
811065f8:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
811065fc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106600:	e0bfff17 	ldw	r2,-4(fp)
}
81106604:	e037883a 	mov	sp,fp
81106608:	dfc00117 	ldw	ra,4(sp)
8110660c:	df000017 	ldw	fp,0(sp)
81106610:	dec00204 	addi	sp,sp,8
81106614:	f800283a 	ret

81106618 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
81106618:	defffd04 	addi	sp,sp,-12
8110661c:	de00012e 	bgeu	sp,et,81106624 <uliRmapCh5WriteCmdAddress+0xc>
81106620:	003b68fa 	trap	3
81106624:	dfc00215 	stw	ra,8(sp)
81106628:	df000115 	stw	fp,4(sp)
8110662c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106630:	01400184 	movi	r5,6
81106634:	01204834 	movhi	r4,33056
81106638:	21070004 	addi	r4,r4,7168
8110663c:	1108b140 	call	81108b14 <uliRmapReadReg>
81106640:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106644:	e13fff17 	ldw	r4,-4(fp)
81106648:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
8110664c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106650:	e0bfff17 	ldw	r2,-4(fp)
}
81106654:	e037883a 	mov	sp,fp
81106658:	dfc00117 	ldw	ra,4(sp)
8110665c:	df000017 	ldw	fp,0(sp)
81106660:	dec00204 	addi	sp,sp,8
81106664:	f800283a 	ret

81106668 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81106668:	defffd04 	addi	sp,sp,-12
8110666c:	de00012e 	bgeu	sp,et,81106674 <uliRmapCh6WriteCmdAddress+0xc>
81106670:	003b68fa 	trap	3
81106674:	dfc00215 	stw	ra,8(sp)
81106678:	df000115 	stw	fp,4(sp)
8110667c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106680:	01400184 	movi	r5,6
81106684:	01204834 	movhi	r4,33056
81106688:	21060004 	addi	r4,r4,6144
8110668c:	1108b140 	call	81108b14 <uliRmapReadReg>
81106690:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106694:	e13fff17 	ldw	r4,-4(fp)
81106698:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
8110669c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811066a0:	e0bfff17 	ldw	r2,-4(fp)
}
811066a4:	e037883a 	mov	sp,fp
811066a8:	dfc00117 	ldw	ra,4(sp)
811066ac:	df000017 	ldw	fp,0(sp)
811066b0:	dec00204 	addi	sp,sp,8
811066b4:	f800283a 	ret

811066b8 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
811066b8:	defffd04 	addi	sp,sp,-12
811066bc:	de00012e 	bgeu	sp,et,811066c4 <uliRmapCh7WriteCmdAddress+0xc>
811066c0:	003b68fa 	trap	3
811066c4:	dfc00215 	stw	ra,8(sp)
811066c8:	df000115 	stw	fp,4(sp)
811066cc:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811066d0:	01400184 	movi	r5,6
811066d4:	01204834 	movhi	r4,33056
811066d8:	21050004 	addi	r4,r4,5120
811066dc:	1108b140 	call	81108b14 <uliRmapReadReg>
811066e0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811066e4:	e13fff17 	ldw	r4,-4(fp)
811066e8:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
811066ec:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811066f0:	e0bfff17 	ldw	r2,-4(fp)
}
811066f4:	e037883a 	mov	sp,fp
811066f8:	dfc00117 	ldw	ra,4(sp)
811066fc:	df000017 	ldw	fp,0(sp)
81106700:	dec00204 	addi	sp,sp,8
81106704:	f800283a 	ret

81106708 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81106708:	defffd04 	addi	sp,sp,-12
8110670c:	de00012e 	bgeu	sp,et,81106714 <uliRmapCh8WriteCmdAddress+0xc>
81106710:	003b68fa 	trap	3
81106714:	dfc00215 	stw	ra,8(sp)
81106718:	df000115 	stw	fp,4(sp)
8110671c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106720:	01400184 	movi	r5,6
81106724:	01204834 	movhi	r4,33056
81106728:	21040004 	addi	r4,r4,4096
8110672c:	1108b140 	call	81108b14 <uliRmapReadReg>
81106730:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106734:	e13fff17 	ldw	r4,-4(fp)
81106738:	1108b640 	call	81108b64 <uliConvRmapCfgAddr>
8110673c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106740:	e0bfff17 	ldw	r2,-4(fp)
}
81106744:	e037883a 	mov	sp,fp
81106748:	dfc00117 	ldw	ra,4(sp)
8110674c:	df000017 	ldw	fp,0(sp)
81106750:	dec00204 	addi	sp,sp,8
81106754:	f800283a 	ret

81106758 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81106758:	defffc04 	addi	sp,sp,-16
8110675c:	de00012e 	bgeu	sp,et,81106764 <vRmapInitIrq+0xc>
81106760:	003b68fa 	trap	3
81106764:	dfc00315 	stw	ra,12(sp)
81106768:	df000215 	stw	fp,8(sp)
8110676c:	df000204 	addi	fp,sp,8
81106770:	2005883a 	mov	r2,r4
81106774:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106778:	e0bfff03 	ldbu	r2,-4(fp)
8110677c:	10c00228 	cmpgeui	r3,r2,8
81106780:	18004e1e 	bne	r3,zero,811068bc <vRmapInitIrq+0x164>
81106784:	100690ba 	slli	r3,r2,2
81106788:	00a04434 	movhi	r2,33040
8110678c:	1099e704 	addi	r2,r2,26524
81106790:	1885883a 	add	r2,r3,r2
81106794:	10800017 	ldw	r2,0(r2)
81106798:	1000683a 	jmp	r2
8110679c:	811067bc 	xorhi	r4,r16,16798
811067a0:	811067dc 	xori	r4,r16,16799
811067a4:	811067fc 	xorhi	r4,r16,16799
811067a8:	8110681c 	xori	r4,r16,16800
811067ac:	8110683c 	xorhi	r4,r16,16800
811067b0:	8110685c 	xori	r4,r16,16801
811067b4:	8110687c 	xorhi	r4,r16,16801
811067b8:	8110689c 	xori	r4,r16,16802
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811067bc:	d0a04604 	addi	r2,gp,-32488
811067c0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
811067c4:	01a04434 	movhi	r6,33040
811067c8:	31977e04 	addi	r6,r6,24056
811067cc:	e17ffe17 	ldw	r5,-8(fp)
811067d0:	010005c4 	movi	r4,23
811067d4:	11305680 	call	81130568 <alt_irq_register>
		break;
811067d8:	00003806 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811067dc:	d0a04704 	addi	r2,gp,-32484
811067e0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811067e4:	01a04434 	movhi	r6,33040
811067e8:	31978e04 	addi	r6,r6,24120
811067ec:	e17ffe17 	ldw	r5,-8(fp)
811067f0:	01000544 	movi	r4,21
811067f4:	11305680 	call	81130568 <alt_irq_register>
		break;
811067f8:	00003006 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811067fc:	d0a04804 	addi	r2,gp,-32480
81106800:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81106804:	01a04434 	movhi	r6,33040
81106808:	31979e04 	addi	r6,r6,24184
8110680c:	e17ffe17 	ldw	r5,-8(fp)
81106810:	010004c4 	movi	r4,19
81106814:	11305680 	call	81130568 <alt_irq_register>
		break;
81106818:	00002806 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
8110681c:	d0a04904 	addi	r2,gp,-32476
81106820:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81106824:	01a04434 	movhi	r6,33040
81106828:	3197ae04 	addi	r6,r6,24248
8110682c:	e17ffe17 	ldw	r5,-8(fp)
81106830:	01000444 	movi	r4,17
81106834:	11305680 	call	81130568 <alt_irq_register>
		break;
81106838:	00002006 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
8110683c:	d0a04a04 	addi	r2,gp,-32472
81106840:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81106844:	01a04434 	movhi	r6,33040
81106848:	3197be04 	addi	r6,r6,24312
8110684c:	e17ffe17 	ldw	r5,-8(fp)
81106850:	01000244 	movi	r4,9
81106854:	11305680 	call	81130568 <alt_irq_register>
		break;
81106858:	00001806 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110685c:	d0a04b04 	addi	r2,gp,-32468
81106860:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81106864:	01a04434 	movhi	r6,33040
81106868:	3197ce04 	addi	r6,r6,24376
8110686c:	e17ffe17 	ldw	r5,-8(fp)
81106870:	010001c4 	movi	r4,7
81106874:	11305680 	call	81130568 <alt_irq_register>
		break;
81106878:	00001006 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110687c:	d0a04c04 	addi	r2,gp,-32464
81106880:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81106884:	01a04434 	movhi	r6,33040
81106888:	3197de04 	addi	r6,r6,24440
8110688c:	e17ffe17 	ldw	r5,-8(fp)
81106890:	01000104 	movi	r4,4
81106894:	11305680 	call	81130568 <alt_irq_register>
		break;
81106898:	00000806 	br	811068bc <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110689c:	d0a04d04 	addi	r2,gp,-32460
811068a0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
811068a4:	01a04434 	movhi	r6,33040
811068a8:	3197ee04 	addi	r6,r6,24504
811068ac:	e17ffe17 	ldw	r5,-8(fp)
811068b0:	010000c4 	movi	r4,3
811068b4:	11305680 	call	81130568 <alt_irq_register>
		break;
811068b8:	0001883a 	nop
	}
}
811068bc:	0001883a 	nop
811068c0:	e037883a 	mov	sp,fp
811068c4:	dfc00117 	ldw	ra,4(sp)
811068c8:	df000017 	ldw	fp,0(sp)
811068cc:	dec00204 	addi	sp,sp,8
811068d0:	f800283a 	ret

811068d4 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
811068d4:	defffb04 	addi	sp,sp,-20
811068d8:	de00012e 	bgeu	sp,et,811068e0 <bRmapSetIrqControl+0xc>
811068dc:	003b68fa 	trap	3
811068e0:	dfc00415 	stw	ra,16(sp)
811068e4:	df000315 	stw	fp,12(sp)
811068e8:	df000304 	addi	fp,sp,12
811068ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811068f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811068f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811068f8:	e0bfff17 	ldw	r2,-4(fp)
811068fc:	10001926 	beq	r2,zero,81106964 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106900:	e0bfff17 	ldw	r2,-4(fp)
81106904:	10800017 	ldw	r2,0(r2)
81106908:	01400444 	movi	r5,17
8110690c:	1009883a 	mov	r4,r2
81106910:	1108b140 	call	81108b14 <uliRmapReadReg>
81106914:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81106918:	e0bfff17 	ldw	r2,-4(fp)
8110691c:	10801017 	ldw	r2,64(r2)
81106920:	10000426 	beq	r2,zero,81106934 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81106924:	e0bffe17 	ldw	r2,-8(fp)
81106928:	10800054 	ori	r2,r2,1
8110692c:	e0bffe15 	stw	r2,-8(fp)
81106930:	00000406 	br	81106944 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81106934:	e0fffe17 	ldw	r3,-8(fp)
81106938:	00bfff84 	movi	r2,-2
8110693c:	1884703a 	and	r2,r3,r2
81106940:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106944:	e0bfff17 	ldw	r2,-4(fp)
81106948:	10800017 	ldw	r2,0(r2)
8110694c:	e1bffe17 	ldw	r6,-8(fp)
81106950:	01400444 	movi	r5,17
81106954:	1009883a 	mov	r4,r2
81106958:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
8110695c:	00800044 	movi	r2,1
81106960:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106964:	e0bffd17 	ldw	r2,-12(fp)
}
81106968:	e037883a 	mov	sp,fp
8110696c:	dfc00117 	ldw	ra,4(sp)
81106970:	df000017 	ldw	fp,0(sp)
81106974:	dec00204 	addi	sp,sp,8
81106978:	f800283a 	ret

8110697c <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
8110697c:	defffb04 	addi	sp,sp,-20
81106980:	de00012e 	bgeu	sp,et,81106988 <bRmapGetIrqControl+0xc>
81106984:	003b68fa 	trap	3
81106988:	dfc00415 	stw	ra,16(sp)
8110698c:	df000315 	stw	fp,12(sp)
81106990:	df000304 	addi	fp,sp,12
81106994:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106998:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110699c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811069a0:	e0bfff17 	ldw	r2,-4(fp)
811069a4:	10001126 	beq	r2,zero,811069ec <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811069a8:	e0bfff17 	ldw	r2,-4(fp)
811069ac:	10800017 	ldw	r2,0(r2)
811069b0:	01400444 	movi	r5,17
811069b4:	1009883a 	mov	r4,r2
811069b8:	1108b140 	call	81108b14 <uliRmapReadReg>
811069bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
811069c0:	e0bffe17 	ldw	r2,-8(fp)
811069c4:	1080004c 	andi	r2,r2,1
811069c8:	10000426 	beq	r2,zero,811069dc <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
811069cc:	e0bfff17 	ldw	r2,-4(fp)
811069d0:	00c00044 	movi	r3,1
811069d4:	10c01015 	stw	r3,64(r2)
811069d8:	00000206 	br	811069e4 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811069dc:	e0bfff17 	ldw	r2,-4(fp)
811069e0:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811069e4:	00800044 	movi	r2,1
811069e8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811069ec:	e0bffd17 	ldw	r2,-12(fp)
}
811069f0:	e037883a 	mov	sp,fp
811069f4:	dfc00117 	ldw	ra,4(sp)
811069f8:	df000017 	ldw	fp,0(sp)
811069fc:	dec00204 	addi	sp,sp,8
81106a00:	f800283a 	ret

81106a04 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81106a04:	defffb04 	addi	sp,sp,-20
81106a08:	de00012e 	bgeu	sp,et,81106a10 <bRmapGetIrqFlags+0xc>
81106a0c:	003b68fa 	trap	3
81106a10:	dfc00415 	stw	ra,16(sp)
81106a14:	df000315 	stw	fp,12(sp)
81106a18:	df000304 	addi	fp,sp,12
81106a1c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a20:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a24:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106a28:	e0bfff17 	ldw	r2,-4(fp)
81106a2c:	10001126 	beq	r2,zero,81106a74 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106a30:	e0bfff17 	ldw	r2,-4(fp)
81106a34:	10800017 	ldw	r2,0(r2)
81106a38:	01400484 	movi	r5,18
81106a3c:	1009883a 	mov	r4,r2
81106a40:	1108b140 	call	81108b14 <uliRmapReadReg>
81106a44:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106a48:	e0bffe17 	ldw	r2,-8(fp)
81106a4c:	1080004c 	andi	r2,r2,1
81106a50:	10000426 	beq	r2,zero,81106a64 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81106a54:	e0bfff17 	ldw	r2,-4(fp)
81106a58:	00c00044 	movi	r3,1
81106a5c:	10c01115 	stw	r3,68(r2)
81106a60:	00000206 	br	81106a6c <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81106a64:	e0bfff17 	ldw	r2,-4(fp)
81106a68:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81106a6c:	00800044 	movi	r2,1
81106a70:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a74:	e0bffd17 	ldw	r2,-12(fp)
}
81106a78:	e037883a 	mov	sp,fp
81106a7c:	dfc00117 	ldw	ra,4(sp)
81106a80:	df000017 	ldw	fp,0(sp)
81106a84:	dec00204 	addi	sp,sp,8
81106a88:	f800283a 	ret

81106a8c <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81106a8c:	defffb04 	addi	sp,sp,-20
81106a90:	de00012e 	bgeu	sp,et,81106a98 <bRmapSetCodecConfig+0xc>
81106a94:	003b68fa 	trap	3
81106a98:	dfc00415 	stw	ra,16(sp)
81106a9c:	df000315 	stw	fp,12(sp)
81106aa0:	df000304 	addi	fp,sp,12
81106aa4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106aa8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106aac:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106ab0:	e0bfff17 	ldw	r2,-4(fp)
81106ab4:	10002526 	beq	r2,zero,81106b4c <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106ab8:	e0bfff17 	ldw	r2,-4(fp)
81106abc:	10800017 	ldw	r2,0(r2)
81106ac0:	01400104 	movi	r5,4
81106ac4:	1009883a 	mov	r4,r2
81106ac8:	1108b140 	call	81108b14 <uliRmapReadReg>
81106acc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81106ad0:	e0fffe17 	ldw	r3,-8(fp)
81106ad4:	00bfc004 	movi	r2,-256
81106ad8:	1884703a 	and	r2,r3,r2
81106adc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81106ae0:	e0bfff17 	ldw	r2,-4(fp)
81106ae4:	10800143 	ldbu	r2,5(r2)
81106ae8:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81106aec:	e0fffe17 	ldw	r3,-8(fp)
81106af0:	1884b03a 	or	r2,r3,r2
81106af4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81106af8:	e0fffe17 	ldw	r3,-8(fp)
81106afc:	00bffff4 	movhi	r2,65535
81106b00:	10803fc4 	addi	r2,r2,255
81106b04:	1884703a 	and	r2,r3,r2
81106b08:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81106b0c:	e0bfff17 	ldw	r2,-4(fp)
81106b10:	10800103 	ldbu	r2,4(r2)
81106b14:	10803fcc 	andi	r2,r2,255
81106b18:	1004923a 	slli	r2,r2,8
81106b1c:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81106b20:	e0fffe17 	ldw	r3,-8(fp)
81106b24:	1884b03a 	or	r2,r3,r2
81106b28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81106b2c:	e0bfff17 	ldw	r2,-4(fp)
81106b30:	10800017 	ldw	r2,0(r2)
81106b34:	e1bffe17 	ldw	r6,-8(fp)
81106b38:	01400104 	movi	r5,4
81106b3c:	1009883a 	mov	r4,r2
81106b40:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81106b44:	00800044 	movi	r2,1
81106b48:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106b4c:	e0bffd17 	ldw	r2,-12(fp)
}
81106b50:	e037883a 	mov	sp,fp
81106b54:	dfc00117 	ldw	ra,4(sp)
81106b58:	df000017 	ldw	fp,0(sp)
81106b5c:	dec00204 	addi	sp,sp,8
81106b60:	f800283a 	ret

81106b64 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81106b64:	defffb04 	addi	sp,sp,-20
81106b68:	de00012e 	bgeu	sp,et,81106b70 <bRmapGetCodecConfig+0xc>
81106b6c:	003b68fa 	trap	3
81106b70:	dfc00415 	stw	ra,16(sp)
81106b74:	df000315 	stw	fp,12(sp)
81106b78:	df000304 	addi	fp,sp,12
81106b7c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106b80:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106b84:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106b88:	e0bfff17 	ldw	r2,-4(fp)
81106b8c:	10001226 	beq	r2,zero,81106bd8 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106b90:	e0bfff17 	ldw	r2,-4(fp)
81106b94:	10800017 	ldw	r2,0(r2)
81106b98:	01400104 	movi	r5,4
81106b9c:	1009883a 	mov	r4,r2
81106ba0:	1108b140 	call	81108b14 <uliRmapReadReg>
81106ba4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81106ba8:	e0bffe17 	ldw	r2,-8(fp)
81106bac:	1007883a 	mov	r3,r2
81106bb0:	e0bfff17 	ldw	r2,-4(fp)
81106bb4:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81106bb8:	e0bffe17 	ldw	r2,-8(fp)
81106bbc:	10bfc00c 	andi	r2,r2,65280
81106bc0:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81106bc4:	1007883a 	mov	r3,r2
81106bc8:	e0bfff17 	ldw	r2,-4(fp)
81106bcc:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81106bd0:	00800044 	movi	r2,1
81106bd4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106bd8:	e0bffd17 	ldw	r2,-12(fp)
}
81106bdc:	e037883a 	mov	sp,fp
81106be0:	dfc00117 	ldw	ra,4(sp)
81106be4:	df000017 	ldw	fp,0(sp)
81106be8:	dec00204 	addi	sp,sp,8
81106bec:	f800283a 	ret

81106bf0 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81106bf0:	defffb04 	addi	sp,sp,-20
81106bf4:	de00012e 	bgeu	sp,et,81106bfc <bRmapGetCodecStatus+0xc>
81106bf8:	003b68fa 	trap	3
81106bfc:	dfc00415 	stw	ra,16(sp)
81106c00:	df000315 	stw	fp,12(sp)
81106c04:	df000304 	addi	fp,sp,12
81106c08:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106c0c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106c10:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106c14:	e0bfff17 	ldw	r2,-4(fp)
81106c18:	10004726 	beq	r2,zero,81106d38 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106c1c:	e0bfff17 	ldw	r2,-4(fp)
81106c20:	10800017 	ldw	r2,0(r2)
81106c24:	01400144 	movi	r5,5
81106c28:	1009883a 	mov	r4,r2
81106c2c:	1108b140 	call	81108b14 <uliRmapReadReg>
81106c30:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81106c34:	e0bffe17 	ldw	r2,-8(fp)
81106c38:	1080004c 	andi	r2,r2,1
81106c3c:	10000426 	beq	r2,zero,81106c50 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81106c40:	e0bfff17 	ldw	r2,-4(fp)
81106c44:	00c00044 	movi	r3,1
81106c48:	10c00215 	stw	r3,8(r2)
81106c4c:	00000206 	br	81106c58 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106c50:	e0bfff17 	ldw	r2,-4(fp)
81106c54:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81106c58:	e0bffe17 	ldw	r2,-8(fp)
81106c5c:	1080008c 	andi	r2,r2,2
81106c60:	10000426 	beq	r2,zero,81106c74 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81106c64:	e0bfff17 	ldw	r2,-4(fp)
81106c68:	00c00044 	movi	r3,1
81106c6c:	10c00315 	stw	r3,12(r2)
81106c70:	00000206 	br	81106c7c <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81106c74:	e0bfff17 	ldw	r2,-4(fp)
81106c78:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81106c7c:	e0bffe17 	ldw	r2,-8(fp)
81106c80:	1080010c 	andi	r2,r2,4
81106c84:	10000426 	beq	r2,zero,81106c98 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81106c88:	e0bfff17 	ldw	r2,-4(fp)
81106c8c:	00c00044 	movi	r3,1
81106c90:	10c00415 	stw	r3,16(r2)
81106c94:	00000206 	br	81106ca0 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81106c98:	e0bfff17 	ldw	r2,-4(fp)
81106c9c:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81106ca0:	e0bffe17 	ldw	r2,-8(fp)
81106ca4:	1080020c 	andi	r2,r2,8
81106ca8:	10000426 	beq	r2,zero,81106cbc <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81106cac:	e0bfff17 	ldw	r2,-4(fp)
81106cb0:	00c00044 	movi	r3,1
81106cb4:	10c00515 	stw	r3,20(r2)
81106cb8:	00000206 	br	81106cc4 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81106cbc:	e0bfff17 	ldw	r2,-4(fp)
81106cc0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81106cc4:	e0bffe17 	ldw	r2,-8(fp)
81106cc8:	1080040c 	andi	r2,r2,16
81106ccc:	10000426 	beq	r2,zero,81106ce0 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81106cd0:	e0bfff17 	ldw	r2,-4(fp)
81106cd4:	00c00044 	movi	r3,1
81106cd8:	10c00615 	stw	r3,24(r2)
81106cdc:	00000206 	br	81106ce8 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81106ce0:	e0bfff17 	ldw	r2,-4(fp)
81106ce4:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81106ce8:	e0bffe17 	ldw	r2,-8(fp)
81106cec:	1080080c 	andi	r2,r2,32
81106cf0:	10000426 	beq	r2,zero,81106d04 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81106cf4:	e0bfff17 	ldw	r2,-4(fp)
81106cf8:	00c00044 	movi	r3,1
81106cfc:	10c00715 	stw	r3,28(r2)
81106d00:	00000206 	br	81106d0c <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81106d04:	e0bfff17 	ldw	r2,-4(fp)
81106d08:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81106d0c:	e0bffe17 	ldw	r2,-8(fp)
81106d10:	1080100c 	andi	r2,r2,64
81106d14:	10000426 	beq	r2,zero,81106d28 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81106d18:	e0bfff17 	ldw	r2,-4(fp)
81106d1c:	00c00044 	movi	r3,1
81106d20:	10c00815 	stw	r3,32(r2)
81106d24:	00000206 	br	81106d30 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81106d28:	e0bfff17 	ldw	r2,-4(fp)
81106d2c:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81106d30:	00800044 	movi	r2,1
81106d34:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106d38:	e0bffd17 	ldw	r2,-12(fp)
}
81106d3c:	e037883a 	mov	sp,fp
81106d40:	dfc00117 	ldw	ra,4(sp)
81106d44:	df000017 	ldw	fp,0(sp)
81106d48:	dec00204 	addi	sp,sp,8
81106d4c:	f800283a 	ret

81106d50 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81106d50:	defffb04 	addi	sp,sp,-20
81106d54:	de00012e 	bgeu	sp,et,81106d5c <bRmapGetCodecError+0xc>
81106d58:	003b68fa 	trap	3
81106d5c:	dfc00415 	stw	ra,16(sp)
81106d60:	df000315 	stw	fp,12(sp)
81106d64:	df000304 	addi	fp,sp,12
81106d68:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106d6c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106d70:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106d74:	e0bfff17 	ldw	r2,-4(fp)
81106d78:	10004726 	beq	r2,zero,81106e98 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106d7c:	e0bfff17 	ldw	r2,-4(fp)
81106d80:	10800017 	ldw	r2,0(r2)
81106d84:	01400144 	movi	r5,5
81106d88:	1009883a 	mov	r4,r2
81106d8c:	1108b140 	call	81108b14 <uliRmapReadReg>
81106d90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81106d94:	e0bffe17 	ldw	r2,-8(fp)
81106d98:	1080006c 	andhi	r2,r2,1
81106d9c:	10000426 	beq	r2,zero,81106db0 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81106da0:	e0bfff17 	ldw	r2,-4(fp)
81106da4:	00c00044 	movi	r3,1
81106da8:	10c00915 	stw	r3,36(r2)
81106dac:	00000206 	br	81106db8 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81106db0:	e0bfff17 	ldw	r2,-4(fp)
81106db4:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81106db8:	e0bffe17 	ldw	r2,-8(fp)
81106dbc:	108000ac 	andhi	r2,r2,2
81106dc0:	10000426 	beq	r2,zero,81106dd4 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81106dc4:	e0bfff17 	ldw	r2,-4(fp)
81106dc8:	00c00044 	movi	r3,1
81106dcc:	10c00a15 	stw	r3,40(r2)
81106dd0:	00000206 	br	81106ddc <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81106dd4:	e0bfff17 	ldw	r2,-4(fp)
81106dd8:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81106ddc:	e0bffe17 	ldw	r2,-8(fp)
81106de0:	1080012c 	andhi	r2,r2,4
81106de4:	10000426 	beq	r2,zero,81106df8 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81106de8:	e0bfff17 	ldw	r2,-4(fp)
81106dec:	00c00044 	movi	r3,1
81106df0:	10c00b15 	stw	r3,44(r2)
81106df4:	00000206 	br	81106e00 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81106df8:	e0bfff17 	ldw	r2,-4(fp)
81106dfc:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81106e00:	e0bffe17 	ldw	r2,-8(fp)
81106e04:	1080022c 	andhi	r2,r2,8
81106e08:	10000426 	beq	r2,zero,81106e1c <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81106e0c:	e0bfff17 	ldw	r2,-4(fp)
81106e10:	00c00044 	movi	r3,1
81106e14:	10c00c15 	stw	r3,48(r2)
81106e18:	00000206 	br	81106e24 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81106e1c:	e0bfff17 	ldw	r2,-4(fp)
81106e20:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81106e24:	e0bffe17 	ldw	r2,-8(fp)
81106e28:	1080042c 	andhi	r2,r2,16
81106e2c:	10000426 	beq	r2,zero,81106e40 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81106e30:	e0bfff17 	ldw	r2,-4(fp)
81106e34:	00c00044 	movi	r3,1
81106e38:	10c00d15 	stw	r3,52(r2)
81106e3c:	00000206 	br	81106e48 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81106e40:	e0bfff17 	ldw	r2,-4(fp)
81106e44:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81106e48:	e0bffe17 	ldw	r2,-8(fp)
81106e4c:	1080082c 	andhi	r2,r2,32
81106e50:	10000426 	beq	r2,zero,81106e64 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81106e54:	e0bfff17 	ldw	r2,-4(fp)
81106e58:	00c00044 	movi	r3,1
81106e5c:	10c00e15 	stw	r3,56(r2)
81106e60:	00000206 	br	81106e6c <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81106e64:	e0bfff17 	ldw	r2,-4(fp)
81106e68:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81106e6c:	e0bffe17 	ldw	r2,-8(fp)
81106e70:	1080102c 	andhi	r2,r2,64
81106e74:	10000426 	beq	r2,zero,81106e88 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81106e78:	e0bfff17 	ldw	r2,-4(fp)
81106e7c:	00c00044 	movi	r3,1
81106e80:	10c00f15 	stw	r3,60(r2)
81106e84:	00000206 	br	81106e90 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81106e88:	e0bfff17 	ldw	r2,-4(fp)
81106e8c:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81106e90:	00800044 	movi	r2,1
81106e94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106e98:	e0bffd17 	ldw	r2,-12(fp)
}
81106e9c:	e037883a 	mov	sp,fp
81106ea0:	dfc00117 	ldw	ra,4(sp)
81106ea4:	df000017 	ldw	fp,0(sp)
81106ea8:	dec00204 	addi	sp,sp,8
81106eac:	f800283a 	ret

81106eb0 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81106eb0:	defffb04 	addi	sp,sp,-20
81106eb4:	de00012e 	bgeu	sp,et,81106ebc <bRmapSetMemConfigArea+0xc>
81106eb8:	003b68fa 	trap	3
81106ebc:	dfc00415 	stw	ra,16(sp)
81106ec0:	df000315 	stw	fp,12(sp)
81106ec4:	df000304 	addi	fp,sp,12
81106ec8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106ecc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106ed0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106ed4:	e0bfff17 	ldw	r2,-4(fp)
81106ed8:	1000aa26 	beq	r2,zero,81107184 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81106edc:	e0bfff17 	ldw	r2,-4(fp)
81106ee0:	10801217 	ldw	r2,72(r2)
81106ee4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106ee8:	e0bfff17 	ldw	r2,-4(fp)
81106eec:	10800017 	ldw	r2,0(r2)
81106ef0:	e1bffe17 	ldw	r6,-8(fp)
81106ef4:	01401004 	movi	r5,64
81106ef8:	1009883a 	mov	r4,r2
81106efc:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81106f00:	e0bfff17 	ldw	r2,-4(fp)
81106f04:	10801317 	ldw	r2,76(r2)
81106f08:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f0c:	e0bfff17 	ldw	r2,-4(fp)
81106f10:	10800017 	ldw	r2,0(r2)
81106f14:	e1bffe17 	ldw	r6,-8(fp)
81106f18:	01401044 	movi	r5,65
81106f1c:	1009883a 	mov	r4,r2
81106f20:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81106f24:	e0bfff17 	ldw	r2,-4(fp)
81106f28:	10801417 	ldw	r2,80(r2)
81106f2c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f30:	e0bfff17 	ldw	r2,-4(fp)
81106f34:	10800017 	ldw	r2,0(r2)
81106f38:	e1bffe17 	ldw	r6,-8(fp)
81106f3c:	01401084 	movi	r5,66
81106f40:	1009883a 	mov	r4,r2
81106f44:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81106f48:	e0bfff17 	ldw	r2,-4(fp)
81106f4c:	10801517 	ldw	r2,84(r2)
81106f50:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f54:	e0bfff17 	ldw	r2,-4(fp)
81106f58:	10800017 	ldw	r2,0(r2)
81106f5c:	e1bffe17 	ldw	r6,-8(fp)
81106f60:	014010c4 	movi	r5,67
81106f64:	1009883a 	mov	r4,r2
81106f68:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81106f6c:	e0bfff17 	ldw	r2,-4(fp)
81106f70:	10802217 	ldw	r2,136(r2)
81106f74:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f78:	e0bfff17 	ldw	r2,-4(fp)
81106f7c:	10800017 	ldw	r2,0(r2)
81106f80:	e1bffe17 	ldw	r6,-8(fp)
81106f84:	01401104 	movi	r5,68
81106f88:	1009883a 	mov	r4,r2
81106f8c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81106f90:	e0bfff17 	ldw	r2,-4(fp)
81106f94:	10801717 	ldw	r2,92(r2)
81106f98:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106f9c:	e0bfff17 	ldw	r2,-4(fp)
81106fa0:	10800017 	ldw	r2,0(r2)
81106fa4:	e1bffe17 	ldw	r6,-8(fp)
81106fa8:	01401144 	movi	r5,69
81106fac:	1009883a 	mov	r4,r2
81106fb0:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81106fb4:	e0bfff17 	ldw	r2,-4(fp)
81106fb8:	10801817 	ldw	r2,96(r2)
81106fbc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106fc0:	e0bfff17 	ldw	r2,-4(fp)
81106fc4:	10800017 	ldw	r2,0(r2)
81106fc8:	e1bffe17 	ldw	r6,-8(fp)
81106fcc:	01401184 	movi	r5,70
81106fd0:	1009883a 	mov	r4,r2
81106fd4:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81106fd8:	e0bfff17 	ldw	r2,-4(fp)
81106fdc:	10801917 	ldw	r2,100(r2)
81106fe0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106fe4:	e0bfff17 	ldw	r2,-4(fp)
81106fe8:	10800017 	ldw	r2,0(r2)
81106fec:	e1bffe17 	ldw	r6,-8(fp)
81106ff0:	014011c4 	movi	r5,71
81106ff4:	1009883a 	mov	r4,r2
81106ff8:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81106ffc:	e0bfff17 	ldw	r2,-4(fp)
81107000:	10801a17 	ldw	r2,104(r2)
81107004:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107008:	e0bfff17 	ldw	r2,-4(fp)
8110700c:	10800017 	ldw	r2,0(r2)
81107010:	e1bffe17 	ldw	r6,-8(fp)
81107014:	01401204 	movi	r5,72
81107018:	1009883a 	mov	r4,r2
8110701c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107020:	e0bfff17 	ldw	r2,-4(fp)
81107024:	10801b17 	ldw	r2,108(r2)
81107028:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110702c:	e0bfff17 	ldw	r2,-4(fp)
81107030:	10800017 	ldw	r2,0(r2)
81107034:	e1bffe17 	ldw	r6,-8(fp)
81107038:	01401244 	movi	r5,73
8110703c:	1009883a 	mov	r4,r2
81107040:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107044:	e0bfff17 	ldw	r2,-4(fp)
81107048:	10800017 	ldw	r2,0(r2)
8110704c:	01401284 	movi	r5,74
81107050:	1009883a 	mov	r4,r2
81107054:	1108b140 	call	81108b14 <uliRmapReadReg>
81107058:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
8110705c:	e0bfff17 	ldw	r2,-4(fp)
81107060:	10801c17 	ldw	r2,112(r2)
81107064:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107068:	e0bfff17 	ldw	r2,-4(fp)
8110706c:	10800017 	ldw	r2,0(r2)
81107070:	e1bffe17 	ldw	r6,-8(fp)
81107074:	01401284 	movi	r5,74
81107078:	1009883a 	mov	r4,r2
8110707c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107080:	e0bfff17 	ldw	r2,-4(fp)
81107084:	10801d17 	ldw	r2,116(r2)
81107088:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110708c:	e0bfff17 	ldw	r2,-4(fp)
81107090:	10800017 	ldw	r2,0(r2)
81107094:	e1bffe17 	ldw	r6,-8(fp)
81107098:	014012c4 	movi	r5,75
8110709c:	1009883a 	mov	r4,r2
811070a0:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
811070a4:	e0bfff17 	ldw	r2,-4(fp)
811070a8:	10801e17 	ldw	r2,120(r2)
811070ac:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
811070b0:	e0bfff17 	ldw	r2,-4(fp)
811070b4:	10800017 	ldw	r2,0(r2)
811070b8:	e1bffe17 	ldw	r6,-8(fp)
811070bc:	01401304 	movi	r5,76
811070c0:	1009883a 	mov	r4,r2
811070c4:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
811070c8:	e0bfff17 	ldw	r2,-4(fp)
811070cc:	10801f17 	ldw	r2,124(r2)
811070d0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
811070d4:	e0bfff17 	ldw	r2,-4(fp)
811070d8:	10800017 	ldw	r2,0(r2)
811070dc:	e1bffe17 	ldw	r6,-8(fp)
811070e0:	01401344 	movi	r5,77
811070e4:	1009883a 	mov	r4,r2
811070e8:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
811070ec:	e0bfff17 	ldw	r2,-4(fp)
811070f0:	10802017 	ldw	r2,128(r2)
811070f4:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811070f8:	e0bfff17 	ldw	r2,-4(fp)
811070fc:	10800017 	ldw	r2,0(r2)
81107100:	e1bffe17 	ldw	r6,-8(fp)
81107104:	01401384 	movi	r5,78
81107108:	1009883a 	mov	r4,r2
8110710c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107110:	e0bfff17 	ldw	r2,-4(fp)
81107114:	10802217 	ldw	r2,136(r2)
81107118:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110711c:	e0bfff17 	ldw	r2,-4(fp)
81107120:	10800017 	ldw	r2,0(r2)
81107124:	e1bffe17 	ldw	r6,-8(fp)
81107128:	014013c4 	movi	r5,79
8110712c:	1009883a 	mov	r4,r2
81107130:	1108ac00 	call	81108ac0 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107134:	e0bfff17 	ldw	r2,-4(fp)
81107138:	10802217 	ldw	r2,136(r2)
8110713c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81107140:	e0bfff17 	ldw	r2,-4(fp)
81107144:	10800017 	ldw	r2,0(r2)
81107148:	e1bffe17 	ldw	r6,-8(fp)
8110714c:	01401404 	movi	r5,80
81107150:	1009883a 	mov	r4,r2
81107154:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81107158:	e0bfff17 	ldw	r2,-4(fp)
8110715c:	10802317 	ldw	r2,140(r2)
81107160:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81107164:	e0bfff17 	ldw	r2,-4(fp)
81107168:	10800017 	ldw	r2,0(r2)
8110716c:	e1bffe17 	ldw	r6,-8(fp)
81107170:	01401444 	movi	r5,81
81107174:	1009883a 	mov	r4,r2
81107178:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
8110717c:	00800044 	movi	r2,1
81107180:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107184:	e0bffd17 	ldw	r2,-12(fp)
}
81107188:	e037883a 	mov	sp,fp
8110718c:	dfc00117 	ldw	ra,4(sp)
81107190:	df000017 	ldw	fp,0(sp)
81107194:	dec00204 	addi	sp,sp,8
81107198:	f800283a 	ret

8110719c <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
8110719c:	defffb04 	addi	sp,sp,-20
811071a0:	de00012e 	bgeu	sp,et,811071a8 <bRmapGetMemConfigArea+0xc>
811071a4:	003b68fa 	trap	3
811071a8:	dfc00415 	stw	ra,16(sp)
811071ac:	df000315 	stw	fp,12(sp)
811071b0:	df000304 	addi	fp,sp,12
811071b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811071b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811071bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811071c0:	e0bfff17 	ldw	r2,-4(fp)
811071c4:	1000a426 	beq	r2,zero,81107458 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811071c8:	e0bfff17 	ldw	r2,-4(fp)
811071cc:	10800017 	ldw	r2,0(r2)
811071d0:	01401004 	movi	r5,64
811071d4:	1009883a 	mov	r4,r2
811071d8:	1108b140 	call	81108b14 <uliRmapReadReg>
811071dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811071e0:	e0bfff17 	ldw	r2,-4(fp)
811071e4:	e0fffe17 	ldw	r3,-8(fp)
811071e8:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811071ec:	e0bfff17 	ldw	r2,-4(fp)
811071f0:	10800017 	ldw	r2,0(r2)
811071f4:	01401044 	movi	r5,65
811071f8:	1009883a 	mov	r4,r2
811071fc:	1108b140 	call	81108b14 <uliRmapReadReg>
81107200:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
81107204:	e0bfff17 	ldw	r2,-4(fp)
81107208:	e0fffe17 	ldw	r3,-8(fp)
8110720c:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107210:	e0bfff17 	ldw	r2,-4(fp)
81107214:	10800017 	ldw	r2,0(r2)
81107218:	01401084 	movi	r5,66
8110721c:	1009883a 	mov	r4,r2
81107220:	1108b140 	call	81108b14 <uliRmapReadReg>
81107224:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
81107228:	e0bfff17 	ldw	r2,-4(fp)
8110722c:	e0fffe17 	ldw	r3,-8(fp)
81107230:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107234:	e0bfff17 	ldw	r2,-4(fp)
81107238:	10800017 	ldw	r2,0(r2)
8110723c:	014010c4 	movi	r5,67
81107240:	1009883a 	mov	r4,r2
81107244:	1108b140 	call	81108b14 <uliRmapReadReg>
81107248:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
8110724c:	e0bfff17 	ldw	r2,-4(fp)
81107250:	e0fffe17 	ldw	r3,-8(fp)
81107254:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107258:	e0bfff17 	ldw	r2,-4(fp)
8110725c:	10800017 	ldw	r2,0(r2)
81107260:	01401104 	movi	r5,68
81107264:	1009883a 	mov	r4,r2
81107268:	1108b140 	call	81108b14 <uliRmapReadReg>
8110726c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107270:	e0bfff17 	ldw	r2,-4(fp)
81107274:	e0fffe17 	ldw	r3,-8(fp)
81107278:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110727c:	e0bfff17 	ldw	r2,-4(fp)
81107280:	10800017 	ldw	r2,0(r2)
81107284:	01401144 	movi	r5,69
81107288:	1009883a 	mov	r4,r2
8110728c:	1108b140 	call	81108b14 <uliRmapReadReg>
81107290:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81107294:	e0bfff17 	ldw	r2,-4(fp)
81107298:	e0fffe17 	ldw	r3,-8(fp)
8110729c:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811072a0:	e0bfff17 	ldw	r2,-4(fp)
811072a4:	10800017 	ldw	r2,0(r2)
811072a8:	01401184 	movi	r5,70
811072ac:	1009883a 	mov	r4,r2
811072b0:	1108b140 	call	81108b14 <uliRmapReadReg>
811072b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
811072b8:	e0bfff17 	ldw	r2,-4(fp)
811072bc:	e0fffe17 	ldw	r3,-8(fp)
811072c0:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811072c4:	e0bfff17 	ldw	r2,-4(fp)
811072c8:	10800017 	ldw	r2,0(r2)
811072cc:	014011c4 	movi	r5,71
811072d0:	1009883a 	mov	r4,r2
811072d4:	1108b140 	call	81108b14 <uliRmapReadReg>
811072d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811072dc:	e0bfff17 	ldw	r2,-4(fp)
811072e0:	e0fffe17 	ldw	r3,-8(fp)
811072e4:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811072e8:	e0bfff17 	ldw	r2,-4(fp)
811072ec:	10800017 	ldw	r2,0(r2)
811072f0:	01401204 	movi	r5,72
811072f4:	1009883a 	mov	r4,r2
811072f8:	1108b140 	call	81108b14 <uliRmapReadReg>
811072fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
81107300:	e0bfff17 	ldw	r2,-4(fp)
81107304:	e0fffe17 	ldw	r3,-8(fp)
81107308:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110730c:	e0bfff17 	ldw	r2,-4(fp)
81107310:	10800017 	ldw	r2,0(r2)
81107314:	01401244 	movi	r5,73
81107318:	1009883a 	mov	r4,r2
8110731c:	1108b140 	call	81108b14 <uliRmapReadReg>
81107320:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
81107324:	e0bfff17 	ldw	r2,-4(fp)
81107328:	e0fffe17 	ldw	r3,-8(fp)
8110732c:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107330:	e0bfff17 	ldw	r2,-4(fp)
81107334:	10800017 	ldw	r2,0(r2)
81107338:	01401284 	movi	r5,74
8110733c:	1009883a 	mov	r4,r2
81107340:	1108b140 	call	81108b14 <uliRmapReadReg>
81107344:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81107348:	e0bfff17 	ldw	r2,-4(fp)
8110734c:	e0fffe17 	ldw	r3,-8(fp)
81107350:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107354:	e0bfff17 	ldw	r2,-4(fp)
81107358:	10800017 	ldw	r2,0(r2)
8110735c:	014012c4 	movi	r5,75
81107360:	1009883a 	mov	r4,r2
81107364:	1108b140 	call	81108b14 <uliRmapReadReg>
81107368:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
8110736c:	e0bfff17 	ldw	r2,-4(fp)
81107370:	e0fffe17 	ldw	r3,-8(fp)
81107374:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107378:	e0bfff17 	ldw	r2,-4(fp)
8110737c:	10800017 	ldw	r2,0(r2)
81107380:	01401304 	movi	r5,76
81107384:	1009883a 	mov	r4,r2
81107388:	1108b140 	call	81108b14 <uliRmapReadReg>
8110738c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81107390:	e0bfff17 	ldw	r2,-4(fp)
81107394:	e0fffe17 	ldw	r3,-8(fp)
81107398:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110739c:	e0bfff17 	ldw	r2,-4(fp)
811073a0:	10800017 	ldw	r2,0(r2)
811073a4:	01401344 	movi	r5,77
811073a8:	1009883a 	mov	r4,r2
811073ac:	1108b140 	call	81108b14 <uliRmapReadReg>
811073b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
811073b4:	e0bfff17 	ldw	r2,-4(fp)
811073b8:	e0fffe17 	ldw	r3,-8(fp)
811073bc:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073c0:	e0bfff17 	ldw	r2,-4(fp)
811073c4:	10800017 	ldw	r2,0(r2)
811073c8:	01401384 	movi	r5,78
811073cc:	1009883a 	mov	r4,r2
811073d0:	1108b140 	call	81108b14 <uliRmapReadReg>
811073d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
811073d8:	e0bfff17 	ldw	r2,-4(fp)
811073dc:	e0fffe17 	ldw	r3,-8(fp)
811073e0:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073e4:	e0bfff17 	ldw	r2,-4(fp)
811073e8:	10800017 	ldw	r2,0(r2)
811073ec:	014013c4 	movi	r5,79
811073f0:	1009883a 	mov	r4,r2
811073f4:	1108b140 	call	81108b14 <uliRmapReadReg>
811073f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811073fc:	e0bfff17 	ldw	r2,-4(fp)
81107400:	e0fffe17 	ldw	r3,-8(fp)
81107404:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107408:	e0bfff17 	ldw	r2,-4(fp)
8110740c:	10800017 	ldw	r2,0(r2)
81107410:	01401404 	movi	r5,80
81107414:	1009883a 	mov	r4,r2
81107418:	1108b140 	call	81108b14 <uliRmapReadReg>
8110741c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107420:	e0bfff17 	ldw	r2,-4(fp)
81107424:	e0fffe17 	ldw	r3,-8(fp)
81107428:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110742c:	e0bfff17 	ldw	r2,-4(fp)
81107430:	10800017 	ldw	r2,0(r2)
81107434:	01401444 	movi	r5,81
81107438:	1009883a 	mov	r4,r2
8110743c:	1108b140 	call	81108b14 <uliRmapReadReg>
81107440:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81107444:	e0bfff17 	ldw	r2,-4(fp)
81107448:	e0fffe17 	ldw	r3,-8(fp)
8110744c:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81107450:	00800044 	movi	r2,1
81107454:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107458:	e0bffd17 	ldw	r2,-12(fp)
}
8110745c:	e037883a 	mov	sp,fp
81107460:	dfc00117 	ldw	ra,4(sp)
81107464:	df000017 	ldw	fp,0(sp)
81107468:	dec00204 	addi	sp,sp,8
8110746c:	f800283a 	ret

81107470 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81107470:	defffb04 	addi	sp,sp,-20
81107474:	de00012e 	bgeu	sp,et,8110747c <bRmapGetMemConfigStat+0xc>
81107478:	003b68fa 	trap	3
8110747c:	dfc00415 	stw	ra,16(sp)
81107480:	df000315 	stw	fp,12(sp)
81107484:	df000304 	addi	fp,sp,12
81107488:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110748c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107490:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107494:	e0bfff17 	ldw	r2,-4(fp)
81107498:	10001426 	beq	r2,zero,811074ec <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110749c:	e0bfff17 	ldw	r2,-4(fp)
811074a0:	10800017 	ldw	r2,0(r2)
811074a4:	014001c4 	movi	r5,7
811074a8:	1009883a 	mov	r4,r2
811074ac:	1108b140 	call	81108b14 <uliRmapReadReg>
811074b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
811074b4:	e0bfff17 	ldw	r2,-4(fp)
811074b8:	e0fffe17 	ldw	r3,-8(fp)
811074bc:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811074c0:	e0bfff17 	ldw	r2,-4(fp)
811074c4:	10800017 	ldw	r2,0(r2)
811074c8:	01400184 	movi	r5,6
811074cc:	1009883a 	mov	r4,r2
811074d0:	1108b140 	call	81108b14 <uliRmapReadReg>
811074d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
811074d8:	e0bfff17 	ldw	r2,-4(fp)
811074dc:	e0fffe17 	ldw	r3,-8(fp)
811074e0:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811074e4:	00800044 	movi	r2,1
811074e8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811074ec:	e0bffd17 	ldw	r2,-12(fp)
}
811074f0:	e037883a 	mov	sp,fp
811074f4:	dfc00117 	ldw	ra,4(sp)
811074f8:	df000017 	ldw	fp,0(sp)
811074fc:	dec00204 	addi	sp,sp,8
81107500:	f800283a 	ret

81107504 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81107504:	defffb04 	addi	sp,sp,-20
81107508:	de00012e 	bgeu	sp,et,81107510 <bRmapSetRmapMemHKArea+0xc>
8110750c:	003b68fa 	trap	3
81107510:	dfc00415 	stw	ra,16(sp)
81107514:	df000315 	stw	fp,12(sp)
81107518:	df000304 	addi	fp,sp,12
8110751c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107520:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107524:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107528:	e0bfff17 	ldw	r2,-4(fp)
8110752c:	10030226 	beq	r2,zero,81108138 <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107530:	e0bfff17 	ldw	r2,-4(fp)
81107534:	10800017 	ldw	r2,0(r2)
81107538:	01402804 	movi	r5,160
8110753c:	1009883a 	mov	r4,r2
81107540:	1108b140 	call	81108b14 <uliRmapReadReg>
81107544:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81107548:	e0bffe17 	ldw	r2,-8(fp)
8110754c:	10bfffec 	andhi	r2,r2,65535
81107550:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81107554:	e0bfff17 	ldw	r2,-4(fp)
81107558:	1080260b 	ldhu	r2,152(r2)
8110755c:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81107560:	e0fffe17 	ldw	r3,-8(fp)
81107564:	1884b03a 	or	r2,r3,r2
81107568:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
8110756c:	e0bffe17 	ldw	r2,-8(fp)
81107570:	10bfffcc 	andi	r2,r2,65535
81107574:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81107578:	e0bfff17 	ldw	r2,-4(fp)
8110757c:	10800017 	ldw	r2,0(r2)
81107580:	e1bffe17 	ldw	r6,-8(fp)
81107584:	01402804 	movi	r5,160
81107588:	1009883a 	mov	r4,r2
8110758c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107590:	e0bfff17 	ldw	r2,-4(fp)
81107594:	10800017 	ldw	r2,0(r2)
81107598:	01402844 	movi	r5,161
8110759c:	1009883a 	mov	r4,r2
811075a0:	1108b140 	call	81108b14 <uliRmapReadReg>
811075a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
811075a8:	e0bffe17 	ldw	r2,-8(fp)
811075ac:	10bfffec 	andhi	r2,r2,65535
811075b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
811075b4:	e0bfff17 	ldw	r2,-4(fp)
811075b8:	1080270b 	ldhu	r2,156(r2)
811075bc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811075c0:	e0fffe17 	ldw	r3,-8(fp)
811075c4:	1884b03a 	or	r2,r3,r2
811075c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811075cc:	e0bffe17 	ldw	r2,-8(fp)
811075d0:	10bfffcc 	andi	r2,r2,65535
811075d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811075d8:	e0bfff17 	ldw	r2,-4(fp)
811075dc:	10800017 	ldw	r2,0(r2)
811075e0:	e1bffe17 	ldw	r6,-8(fp)
811075e4:	01402844 	movi	r5,161
811075e8:	1009883a 	mov	r4,r2
811075ec:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075f0:	e0bfff17 	ldw	r2,-4(fp)
811075f4:	10800017 	ldw	r2,0(r2)
811075f8:	01402884 	movi	r5,162
811075fc:	1009883a 	mov	r4,r2
81107600:	1108b140 	call	81108b14 <uliRmapReadReg>
81107604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81107608:	e0bffe17 	ldw	r2,-8(fp)
8110760c:	10bfffec 	andhi	r2,r2,65535
81107610:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81107614:	e0bfff17 	ldw	r2,-4(fp)
81107618:	1080280b 	ldhu	r2,160(r2)
8110761c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81107620:	e0fffe17 	ldw	r3,-8(fp)
81107624:	1884b03a 	or	r2,r3,r2
81107628:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
8110762c:	e0bffe17 	ldw	r2,-8(fp)
81107630:	10bfffcc 	andi	r2,r2,65535
81107634:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81107638:	e0bfff17 	ldw	r2,-4(fp)
8110763c:	10800017 	ldw	r2,0(r2)
81107640:	e1bffe17 	ldw	r6,-8(fp)
81107644:	01402884 	movi	r5,162
81107648:	1009883a 	mov	r4,r2
8110764c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107650:	e0bfff17 	ldw	r2,-4(fp)
81107654:	10800017 	ldw	r2,0(r2)
81107658:	014028c4 	movi	r5,163
8110765c:	1009883a 	mov	r4,r2
81107660:	1108b140 	call	81108b14 <uliRmapReadReg>
81107664:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81107668:	e0bffe17 	ldw	r2,-8(fp)
8110766c:	10bfffec 	andhi	r2,r2,65535
81107670:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81107674:	e0bfff17 	ldw	r2,-4(fp)
81107678:	1080290b 	ldhu	r2,164(r2)
8110767c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81107680:	e0fffe17 	ldw	r3,-8(fp)
81107684:	1884b03a 	or	r2,r3,r2
81107688:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
8110768c:	e0bffe17 	ldw	r2,-8(fp)
81107690:	10bfffcc 	andi	r2,r2,65535
81107694:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81107698:	e0bfff17 	ldw	r2,-4(fp)
8110769c:	10800017 	ldw	r2,0(r2)
811076a0:	e1bffe17 	ldw	r6,-8(fp)
811076a4:	014028c4 	movi	r5,163
811076a8:	1009883a 	mov	r4,r2
811076ac:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076b0:	e0bfff17 	ldw	r2,-4(fp)
811076b4:	10800017 	ldw	r2,0(r2)
811076b8:	01402904 	movi	r5,164
811076bc:	1009883a 	mov	r4,r2
811076c0:	1108b140 	call	81108b14 <uliRmapReadReg>
811076c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
811076c8:	e0bffe17 	ldw	r2,-8(fp)
811076cc:	10bfffec 	andhi	r2,r2,65535
811076d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
811076d4:	e0bfff17 	ldw	r2,-4(fp)
811076d8:	10802a0b 	ldhu	r2,168(r2)
811076dc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
811076e0:	e0fffe17 	ldw	r3,-8(fp)
811076e4:	1884b03a 	or	r2,r3,r2
811076e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
811076ec:	e0bffe17 	ldw	r2,-8(fp)
811076f0:	10bfffcc 	andi	r2,r2,65535
811076f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
811076f8:	e0bfff17 	ldw	r2,-4(fp)
811076fc:	10800017 	ldw	r2,0(r2)
81107700:	e1bffe17 	ldw	r6,-8(fp)
81107704:	01402904 	movi	r5,164
81107708:	1009883a 	mov	r4,r2
8110770c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107710:	e0bfff17 	ldw	r2,-4(fp)
81107714:	10800017 	ldw	r2,0(r2)
81107718:	01402944 	movi	r5,165
8110771c:	1009883a 	mov	r4,r2
81107720:	1108b140 	call	81108b14 <uliRmapReadReg>
81107724:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81107728:	e0bffe17 	ldw	r2,-8(fp)
8110772c:	10bfffec 	andhi	r2,r2,65535
81107730:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81107734:	e0bfff17 	ldw	r2,-4(fp)
81107738:	10802b0b 	ldhu	r2,172(r2)
8110773c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81107740:	e0fffe17 	ldw	r3,-8(fp)
81107744:	1884b03a 	or	r2,r3,r2
81107748:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
8110774c:	e0bffe17 	ldw	r2,-8(fp)
81107750:	10bfffcc 	andi	r2,r2,65535
81107754:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81107758:	e0bfff17 	ldw	r2,-4(fp)
8110775c:	10800017 	ldw	r2,0(r2)
81107760:	e1bffe17 	ldw	r6,-8(fp)
81107764:	01402944 	movi	r5,165
81107768:	1009883a 	mov	r4,r2
8110776c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107770:	e0bfff17 	ldw	r2,-4(fp)
81107774:	10800017 	ldw	r2,0(r2)
81107778:	01402984 	movi	r5,166
8110777c:	1009883a 	mov	r4,r2
81107780:	1108b140 	call	81108b14 <uliRmapReadReg>
81107784:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81107788:	e0bffe17 	ldw	r2,-8(fp)
8110778c:	10bfffec 	andhi	r2,r2,65535
81107790:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81107794:	e0bfff17 	ldw	r2,-4(fp)
81107798:	10802c0b 	ldhu	r2,176(r2)
8110779c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
811077a0:	e0fffe17 	ldw	r3,-8(fp)
811077a4:	1884b03a 	or	r2,r3,r2
811077a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
811077ac:	e0bffe17 	ldw	r2,-8(fp)
811077b0:	10bfffcc 	andi	r2,r2,65535
811077b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
811077b8:	e0bfff17 	ldw	r2,-4(fp)
811077bc:	10800017 	ldw	r2,0(r2)
811077c0:	e1bffe17 	ldw	r6,-8(fp)
811077c4:	01402984 	movi	r5,166
811077c8:	1009883a 	mov	r4,r2
811077cc:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077d0:	e0bfff17 	ldw	r2,-4(fp)
811077d4:	10800017 	ldw	r2,0(r2)
811077d8:	014029c4 	movi	r5,167
811077dc:	1009883a 	mov	r4,r2
811077e0:	1108b140 	call	81108b14 <uliRmapReadReg>
811077e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
811077e8:	e0bffe17 	ldw	r2,-8(fp)
811077ec:	10bfffec 	andhi	r2,r2,65535
811077f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
811077f4:	e0bfff17 	ldw	r2,-4(fp)
811077f8:	10802d0b 	ldhu	r2,180(r2)
811077fc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81107800:	e0fffe17 	ldw	r3,-8(fp)
81107804:	1884b03a 	or	r2,r3,r2
81107808:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
8110780c:	e0bffe17 	ldw	r2,-8(fp)
81107810:	10bfffcc 	andi	r2,r2,65535
81107814:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81107818:	e0bfff17 	ldw	r2,-4(fp)
8110781c:	10800017 	ldw	r2,0(r2)
81107820:	e1bffe17 	ldw	r6,-8(fp)
81107824:	014029c4 	movi	r5,167
81107828:	1009883a 	mov	r4,r2
8110782c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107830:	e0bfff17 	ldw	r2,-4(fp)
81107834:	10800017 	ldw	r2,0(r2)
81107838:	01402a04 	movi	r5,168
8110783c:	1009883a 	mov	r4,r2
81107840:	1108b140 	call	81108b14 <uliRmapReadReg>
81107844:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81107848:	e0bffe17 	ldw	r2,-8(fp)
8110784c:	10bfffec 	andhi	r2,r2,65535
81107850:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81107854:	e0bfff17 	ldw	r2,-4(fp)
81107858:	10802e0b 	ldhu	r2,184(r2)
8110785c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81107860:	e0fffe17 	ldw	r3,-8(fp)
81107864:	1884b03a 	or	r2,r3,r2
81107868:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
8110786c:	e0bffe17 	ldw	r2,-8(fp)
81107870:	10bfffcc 	andi	r2,r2,65535
81107874:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81107878:	e0bfff17 	ldw	r2,-4(fp)
8110787c:	10800017 	ldw	r2,0(r2)
81107880:	e1bffe17 	ldw	r6,-8(fp)
81107884:	01402a04 	movi	r5,168
81107888:	1009883a 	mov	r4,r2
8110788c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107890:	e0bfff17 	ldw	r2,-4(fp)
81107894:	10800017 	ldw	r2,0(r2)
81107898:	01402a44 	movi	r5,169
8110789c:	1009883a 	mov	r4,r2
811078a0:	1108b140 	call	81108b14 <uliRmapReadReg>
811078a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
811078a8:	e0bffe17 	ldw	r2,-8(fp)
811078ac:	10bfffec 	andhi	r2,r2,65535
811078b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
811078b4:	e0bfff17 	ldw	r2,-4(fp)
811078b8:	10802f0b 	ldhu	r2,188(r2)
811078bc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811078c0:	e0fffe17 	ldw	r3,-8(fp)
811078c4:	1884b03a 	or	r2,r3,r2
811078c8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811078cc:	e0bffe17 	ldw	r2,-8(fp)
811078d0:	10bfffcc 	andi	r2,r2,65535
811078d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
811078d8:	e0bfff17 	ldw	r2,-4(fp)
811078dc:	10800017 	ldw	r2,0(r2)
811078e0:	e1bffe17 	ldw	r6,-8(fp)
811078e4:	01402a44 	movi	r5,169
811078e8:	1009883a 	mov	r4,r2
811078ec:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078f0:	e0bfff17 	ldw	r2,-4(fp)
811078f4:	10800017 	ldw	r2,0(r2)
811078f8:	01402a84 	movi	r5,170
811078fc:	1009883a 	mov	r4,r2
81107900:	1108b140 	call	81108b14 <uliRmapReadReg>
81107904:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81107908:	e0bffe17 	ldw	r2,-8(fp)
8110790c:	10bfffec 	andhi	r2,r2,65535
81107910:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81107914:	e0bfff17 	ldw	r2,-4(fp)
81107918:	1080300b 	ldhu	r2,192(r2)
8110791c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81107920:	e0fffe17 	ldw	r3,-8(fp)
81107924:	1884b03a 	or	r2,r3,r2
81107928:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
8110792c:	e0bffe17 	ldw	r2,-8(fp)
81107930:	10bfffcc 	andi	r2,r2,65535
81107934:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81107938:	e0bfff17 	ldw	r2,-4(fp)
8110793c:	10800017 	ldw	r2,0(r2)
81107940:	e1bffe17 	ldw	r6,-8(fp)
81107944:	01402a84 	movi	r5,170
81107948:	1009883a 	mov	r4,r2
8110794c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107950:	e0bfff17 	ldw	r2,-4(fp)
81107954:	10800017 	ldw	r2,0(r2)
81107958:	01402ac4 	movi	r5,171
8110795c:	1009883a 	mov	r4,r2
81107960:	1108b140 	call	81108b14 <uliRmapReadReg>
81107964:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81107968:	e0bffe17 	ldw	r2,-8(fp)
8110796c:	10bfffec 	andhi	r2,r2,65535
81107970:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81107974:	e0bfff17 	ldw	r2,-4(fp)
81107978:	1080310b 	ldhu	r2,196(r2)
8110797c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81107980:	e0fffe17 	ldw	r3,-8(fp)
81107984:	1884b03a 	or	r2,r3,r2
81107988:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
8110798c:	e0bffe17 	ldw	r2,-8(fp)
81107990:	10bfffcc 	andi	r2,r2,65535
81107994:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81107998:	e0bfff17 	ldw	r2,-4(fp)
8110799c:	10800017 	ldw	r2,0(r2)
811079a0:	e1bffe17 	ldw	r6,-8(fp)
811079a4:	01402ac4 	movi	r5,171
811079a8:	1009883a 	mov	r4,r2
811079ac:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079b0:	e0bfff17 	ldw	r2,-4(fp)
811079b4:	10800017 	ldw	r2,0(r2)
811079b8:	01402b04 	movi	r5,172
811079bc:	1009883a 	mov	r4,r2
811079c0:	1108b140 	call	81108b14 <uliRmapReadReg>
811079c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
811079c8:	e0bffe17 	ldw	r2,-8(fp)
811079cc:	10bfffec 	andhi	r2,r2,65535
811079d0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
811079d4:	e0bfff17 	ldw	r2,-4(fp)
811079d8:	1080320b 	ldhu	r2,200(r2)
811079dc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
811079e0:	e0fffe17 	ldw	r3,-8(fp)
811079e4:	1884b03a 	or	r2,r3,r2
811079e8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
811079ec:	e0bffe17 	ldw	r2,-8(fp)
811079f0:	10bfffcc 	andi	r2,r2,65535
811079f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
811079f8:	e0bfff17 	ldw	r2,-4(fp)
811079fc:	10800017 	ldw	r2,0(r2)
81107a00:	e1bffe17 	ldw	r6,-8(fp)
81107a04:	01402b04 	movi	r5,172
81107a08:	1009883a 	mov	r4,r2
81107a0c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a10:	e0bfff17 	ldw	r2,-4(fp)
81107a14:	10800017 	ldw	r2,0(r2)
81107a18:	01402b44 	movi	r5,173
81107a1c:	1009883a 	mov	r4,r2
81107a20:	1108b140 	call	81108b14 <uliRmapReadReg>
81107a24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81107a28:	e0bffe17 	ldw	r2,-8(fp)
81107a2c:	10bfffec 	andhi	r2,r2,65535
81107a30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81107a34:	e0bfff17 	ldw	r2,-4(fp)
81107a38:	1080330b 	ldhu	r2,204(r2)
81107a3c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81107a40:	e0fffe17 	ldw	r3,-8(fp)
81107a44:	1884b03a 	or	r2,r3,r2
81107a48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81107a4c:	e0bffe17 	ldw	r2,-8(fp)
81107a50:	10bfffcc 	andi	r2,r2,65535
81107a54:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81107a58:	e0bfff17 	ldw	r2,-4(fp)
81107a5c:	10800017 	ldw	r2,0(r2)
81107a60:	e1bffe17 	ldw	r6,-8(fp)
81107a64:	01402b44 	movi	r5,173
81107a68:	1009883a 	mov	r4,r2
81107a6c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a70:	e0bfff17 	ldw	r2,-4(fp)
81107a74:	10800017 	ldw	r2,0(r2)
81107a78:	01402b84 	movi	r5,174
81107a7c:	1009883a 	mov	r4,r2
81107a80:	1108b140 	call	81108b14 <uliRmapReadReg>
81107a84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81107a88:	e0bffe17 	ldw	r2,-8(fp)
81107a8c:	10bfffec 	andhi	r2,r2,65535
81107a90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81107a94:	e0bfff17 	ldw	r2,-4(fp)
81107a98:	1080340b 	ldhu	r2,208(r2)
81107a9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81107aa0:	e0fffe17 	ldw	r3,-8(fp)
81107aa4:	1884b03a 	or	r2,r3,r2
81107aa8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81107aac:	e0bffe17 	ldw	r2,-8(fp)
81107ab0:	10bfffcc 	andi	r2,r2,65535
81107ab4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81107ab8:	e0bfff17 	ldw	r2,-4(fp)
81107abc:	10800017 	ldw	r2,0(r2)
81107ac0:	e1bffe17 	ldw	r6,-8(fp)
81107ac4:	01402b84 	movi	r5,174
81107ac8:	1009883a 	mov	r4,r2
81107acc:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ad0:	e0bfff17 	ldw	r2,-4(fp)
81107ad4:	10800017 	ldw	r2,0(r2)
81107ad8:	01402bc4 	movi	r5,175
81107adc:	1009883a 	mov	r4,r2
81107ae0:	1108b140 	call	81108b14 <uliRmapReadReg>
81107ae4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81107ae8:	e0bffe17 	ldw	r2,-8(fp)
81107aec:	10bfffec 	andhi	r2,r2,65535
81107af0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81107af4:	e0bfff17 	ldw	r2,-4(fp)
81107af8:	1080350b 	ldhu	r2,212(r2)
81107afc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81107b00:	e0fffe17 	ldw	r3,-8(fp)
81107b04:	1884b03a 	or	r2,r3,r2
81107b08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81107b0c:	e0bffe17 	ldw	r2,-8(fp)
81107b10:	10bfffcc 	andi	r2,r2,65535
81107b14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81107b18:	e0bfff17 	ldw	r2,-4(fp)
81107b1c:	10800017 	ldw	r2,0(r2)
81107b20:	e1bffe17 	ldw	r6,-8(fp)
81107b24:	01402bc4 	movi	r5,175
81107b28:	1009883a 	mov	r4,r2
81107b2c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b30:	e0bfff17 	ldw	r2,-4(fp)
81107b34:	10800017 	ldw	r2,0(r2)
81107b38:	01402c04 	movi	r5,176
81107b3c:	1009883a 	mov	r4,r2
81107b40:	1108b140 	call	81108b14 <uliRmapReadReg>
81107b44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81107b48:	e0bffe17 	ldw	r2,-8(fp)
81107b4c:	10bfffec 	andhi	r2,r2,65535
81107b50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81107b54:	e0bfff17 	ldw	r2,-4(fp)
81107b58:	1080360b 	ldhu	r2,216(r2)
81107b5c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81107b60:	e0fffe17 	ldw	r3,-8(fp)
81107b64:	1884b03a 	or	r2,r3,r2
81107b68:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81107b6c:	e0bffe17 	ldw	r2,-8(fp)
81107b70:	10bfffcc 	andi	r2,r2,65535
81107b74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81107b78:	e0bfff17 	ldw	r2,-4(fp)
81107b7c:	10800017 	ldw	r2,0(r2)
81107b80:	e1bffe17 	ldw	r6,-8(fp)
81107b84:	01402c04 	movi	r5,176
81107b88:	1009883a 	mov	r4,r2
81107b8c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b90:	e0bfff17 	ldw	r2,-4(fp)
81107b94:	10800017 	ldw	r2,0(r2)
81107b98:	01402c44 	movi	r5,177
81107b9c:	1009883a 	mov	r4,r2
81107ba0:	1108b140 	call	81108b14 <uliRmapReadReg>
81107ba4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81107ba8:	e0bffe17 	ldw	r2,-8(fp)
81107bac:	10bfffec 	andhi	r2,r2,65535
81107bb0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81107bb4:	e0bfff17 	ldw	r2,-4(fp)
81107bb8:	1080370b 	ldhu	r2,220(r2)
81107bbc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81107bc0:	e0fffe17 	ldw	r3,-8(fp)
81107bc4:	1884b03a 	or	r2,r3,r2
81107bc8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81107bcc:	e0bffe17 	ldw	r2,-8(fp)
81107bd0:	10bfffcc 	andi	r2,r2,65535
81107bd4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81107bd8:	e0bfff17 	ldw	r2,-4(fp)
81107bdc:	10800017 	ldw	r2,0(r2)
81107be0:	e1bffe17 	ldw	r6,-8(fp)
81107be4:	01402c44 	movi	r5,177
81107be8:	1009883a 	mov	r4,r2
81107bec:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bf0:	e0bfff17 	ldw	r2,-4(fp)
81107bf4:	10800017 	ldw	r2,0(r2)
81107bf8:	01402c84 	movi	r5,178
81107bfc:	1009883a 	mov	r4,r2
81107c00:	1108b140 	call	81108b14 <uliRmapReadReg>
81107c04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81107c08:	e0bffe17 	ldw	r2,-8(fp)
81107c0c:	10bfffec 	andhi	r2,r2,65535
81107c10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81107c14:	e0bfff17 	ldw	r2,-4(fp)
81107c18:	1080380b 	ldhu	r2,224(r2)
81107c1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81107c20:	e0fffe17 	ldw	r3,-8(fp)
81107c24:	1884b03a 	or	r2,r3,r2
81107c28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81107c2c:	e0bffe17 	ldw	r2,-8(fp)
81107c30:	10bfffcc 	andi	r2,r2,65535
81107c34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81107c38:	e0bfff17 	ldw	r2,-4(fp)
81107c3c:	10800017 	ldw	r2,0(r2)
81107c40:	e1bffe17 	ldw	r6,-8(fp)
81107c44:	01402c84 	movi	r5,178
81107c48:	1009883a 	mov	r4,r2
81107c4c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c50:	e0bfff17 	ldw	r2,-4(fp)
81107c54:	10800017 	ldw	r2,0(r2)
81107c58:	01402cc4 	movi	r5,179
81107c5c:	1009883a 	mov	r4,r2
81107c60:	1108b140 	call	81108b14 <uliRmapReadReg>
81107c64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81107c68:	e0bffe17 	ldw	r2,-8(fp)
81107c6c:	10bfffec 	andhi	r2,r2,65535
81107c70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81107c74:	e0bfff17 	ldw	r2,-4(fp)
81107c78:	1080390b 	ldhu	r2,228(r2)
81107c7c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81107c80:	e0fffe17 	ldw	r3,-8(fp)
81107c84:	1884b03a 	or	r2,r3,r2
81107c88:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81107c8c:	e0bffe17 	ldw	r2,-8(fp)
81107c90:	10bfffcc 	andi	r2,r2,65535
81107c94:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81107c98:	e0bfff17 	ldw	r2,-4(fp)
81107c9c:	10800017 	ldw	r2,0(r2)
81107ca0:	e1bffe17 	ldw	r6,-8(fp)
81107ca4:	01402cc4 	movi	r5,179
81107ca8:	1009883a 	mov	r4,r2
81107cac:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107cb0:	e0bfff17 	ldw	r2,-4(fp)
81107cb4:	10800017 	ldw	r2,0(r2)
81107cb8:	01402d04 	movi	r5,180
81107cbc:	1009883a 	mov	r4,r2
81107cc0:	1108b140 	call	81108b14 <uliRmapReadReg>
81107cc4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81107cc8:	e0bffe17 	ldw	r2,-8(fp)
81107ccc:	10bfffec 	andhi	r2,r2,65535
81107cd0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81107cd4:	e0bfff17 	ldw	r2,-4(fp)
81107cd8:	10803a0b 	ldhu	r2,232(r2)
81107cdc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81107ce0:	e0fffe17 	ldw	r3,-8(fp)
81107ce4:	1884b03a 	or	r2,r3,r2
81107ce8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81107cec:	e0bffe17 	ldw	r2,-8(fp)
81107cf0:	10bfffcc 	andi	r2,r2,65535
81107cf4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81107cf8:	e0bfff17 	ldw	r2,-4(fp)
81107cfc:	10800017 	ldw	r2,0(r2)
81107d00:	e1bffe17 	ldw	r6,-8(fp)
81107d04:	01402d04 	movi	r5,180
81107d08:	1009883a 	mov	r4,r2
81107d0c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d10:	e0bfff17 	ldw	r2,-4(fp)
81107d14:	10800017 	ldw	r2,0(r2)
81107d18:	01402d44 	movi	r5,181
81107d1c:	1009883a 	mov	r4,r2
81107d20:	1108b140 	call	81108b14 <uliRmapReadReg>
81107d24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81107d28:	e0bffe17 	ldw	r2,-8(fp)
81107d2c:	10bfffec 	andhi	r2,r2,65535
81107d30:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81107d34:	e0bfff17 	ldw	r2,-4(fp)
81107d38:	10803b0b 	ldhu	r2,236(r2)
81107d3c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81107d40:	e0fffe17 	ldw	r3,-8(fp)
81107d44:	1884b03a 	or	r2,r3,r2
81107d48:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81107d4c:	e0bffe17 	ldw	r2,-8(fp)
81107d50:	10bfffcc 	andi	r2,r2,65535
81107d54:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81107d58:	e0bfff17 	ldw	r2,-4(fp)
81107d5c:	10800017 	ldw	r2,0(r2)
81107d60:	e1bffe17 	ldw	r6,-8(fp)
81107d64:	01402d44 	movi	r5,181
81107d68:	1009883a 	mov	r4,r2
81107d6c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d70:	e0bfff17 	ldw	r2,-4(fp)
81107d74:	10800017 	ldw	r2,0(r2)
81107d78:	01402d84 	movi	r5,182
81107d7c:	1009883a 	mov	r4,r2
81107d80:	1108b140 	call	81108b14 <uliRmapReadReg>
81107d84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81107d88:	e0bffe17 	ldw	r2,-8(fp)
81107d8c:	10bfffec 	andhi	r2,r2,65535
81107d90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81107d94:	e0bfff17 	ldw	r2,-4(fp)
81107d98:	10803c0b 	ldhu	r2,240(r2)
81107d9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81107da0:	e0fffe17 	ldw	r3,-8(fp)
81107da4:	1884b03a 	or	r2,r3,r2
81107da8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81107dac:	e0bffe17 	ldw	r2,-8(fp)
81107db0:	10bfffcc 	andi	r2,r2,65535
81107db4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81107db8:	e0bfff17 	ldw	r2,-4(fp)
81107dbc:	10800017 	ldw	r2,0(r2)
81107dc0:	e1bffe17 	ldw	r6,-8(fp)
81107dc4:	01402d84 	movi	r5,182
81107dc8:	1009883a 	mov	r4,r2
81107dcc:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107dd0:	e0bfff17 	ldw	r2,-4(fp)
81107dd4:	10800017 	ldw	r2,0(r2)
81107dd8:	01402dc4 	movi	r5,183
81107ddc:	1009883a 	mov	r4,r2
81107de0:	1108b140 	call	81108b14 <uliRmapReadReg>
81107de4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81107de8:	e0bffe17 	ldw	r2,-8(fp)
81107dec:	10bfffec 	andhi	r2,r2,65535
81107df0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81107df4:	e0bfff17 	ldw	r2,-4(fp)
81107df8:	10803d0b 	ldhu	r2,244(r2)
81107dfc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81107e00:	e0fffe17 	ldw	r3,-8(fp)
81107e04:	1884b03a 	or	r2,r3,r2
81107e08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81107e0c:	e0bffe17 	ldw	r2,-8(fp)
81107e10:	10bfffcc 	andi	r2,r2,65535
81107e14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81107e18:	e0bfff17 	ldw	r2,-4(fp)
81107e1c:	10800017 	ldw	r2,0(r2)
81107e20:	e1bffe17 	ldw	r6,-8(fp)
81107e24:	01402dc4 	movi	r5,183
81107e28:	1009883a 	mov	r4,r2
81107e2c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e30:	e0bfff17 	ldw	r2,-4(fp)
81107e34:	10800017 	ldw	r2,0(r2)
81107e38:	01402e04 	movi	r5,184
81107e3c:	1009883a 	mov	r4,r2
81107e40:	1108b140 	call	81108b14 <uliRmapReadReg>
81107e44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81107e48:	e0bffe17 	ldw	r2,-8(fp)
81107e4c:	10bfffec 	andhi	r2,r2,65535
81107e50:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81107e54:	e0bfff17 	ldw	r2,-4(fp)
81107e58:	10803e0b 	ldhu	r2,248(r2)
81107e5c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81107e60:	e0fffe17 	ldw	r3,-8(fp)
81107e64:	1884b03a 	or	r2,r3,r2
81107e68:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81107e6c:	e0bffe17 	ldw	r2,-8(fp)
81107e70:	10bfffcc 	andi	r2,r2,65535
81107e74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81107e78:	e0bfff17 	ldw	r2,-4(fp)
81107e7c:	10800017 	ldw	r2,0(r2)
81107e80:	e1bffe17 	ldw	r6,-8(fp)
81107e84:	01402e04 	movi	r5,184
81107e88:	1009883a 	mov	r4,r2
81107e8c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e90:	e0bfff17 	ldw	r2,-4(fp)
81107e94:	10800017 	ldw	r2,0(r2)
81107e98:	01402e44 	movi	r5,185
81107e9c:	1009883a 	mov	r4,r2
81107ea0:	1108b140 	call	81108b14 <uliRmapReadReg>
81107ea4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81107ea8:	e0bffe17 	ldw	r2,-8(fp)
81107eac:	10bfffec 	andhi	r2,r2,65535
81107eb0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81107eb4:	e0bfff17 	ldw	r2,-4(fp)
81107eb8:	10803f0b 	ldhu	r2,252(r2)
81107ebc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81107ec0:	e0fffe17 	ldw	r3,-8(fp)
81107ec4:	1884b03a 	or	r2,r3,r2
81107ec8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81107ecc:	e0bffe17 	ldw	r2,-8(fp)
81107ed0:	10bfffcc 	andi	r2,r2,65535
81107ed4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81107ed8:	e0bfff17 	ldw	r2,-4(fp)
81107edc:	10800017 	ldw	r2,0(r2)
81107ee0:	e1bffe17 	ldw	r6,-8(fp)
81107ee4:	01402e44 	movi	r5,185
81107ee8:	1009883a 	mov	r4,r2
81107eec:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ef0:	e0bfff17 	ldw	r2,-4(fp)
81107ef4:	10800017 	ldw	r2,0(r2)
81107ef8:	01402e84 	movi	r5,186
81107efc:	1009883a 	mov	r4,r2
81107f00:	1108b140 	call	81108b14 <uliRmapReadReg>
81107f04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81107f08:	e0bffe17 	ldw	r2,-8(fp)
81107f0c:	10bfffec 	andhi	r2,r2,65535
81107f10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81107f14:	e0bfff17 	ldw	r2,-4(fp)
81107f18:	1080400b 	ldhu	r2,256(r2)
81107f1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81107f20:	e0fffe17 	ldw	r3,-8(fp)
81107f24:	1884b03a 	or	r2,r3,r2
81107f28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81107f2c:	e0bffe17 	ldw	r2,-8(fp)
81107f30:	10bfffcc 	andi	r2,r2,65535
81107f34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81107f38:	e0bfff17 	ldw	r2,-4(fp)
81107f3c:	10800017 	ldw	r2,0(r2)
81107f40:	e1bffe17 	ldw	r6,-8(fp)
81107f44:	01402e84 	movi	r5,186
81107f48:	1009883a 	mov	r4,r2
81107f4c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f50:	e0bfff17 	ldw	r2,-4(fp)
81107f54:	10800017 	ldw	r2,0(r2)
81107f58:	01402ec4 	movi	r5,187
81107f5c:	1009883a 	mov	r4,r2
81107f60:	1108b140 	call	81108b14 <uliRmapReadReg>
81107f64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81107f68:	e0bffe17 	ldw	r2,-8(fp)
81107f6c:	10bfffec 	andhi	r2,r2,65535
81107f70:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81107f74:	e0bfff17 	ldw	r2,-4(fp)
81107f78:	1080410b 	ldhu	r2,260(r2)
81107f7c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81107f80:	e0fffe17 	ldw	r3,-8(fp)
81107f84:	1884b03a 	or	r2,r3,r2
81107f88:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81107f8c:	e0bffe17 	ldw	r2,-8(fp)
81107f90:	10bfffcc 	andi	r2,r2,65535
81107f94:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81107f98:	e0bfff17 	ldw	r2,-4(fp)
81107f9c:	10800017 	ldw	r2,0(r2)
81107fa0:	e1bffe17 	ldw	r6,-8(fp)
81107fa4:	01402ec4 	movi	r5,187
81107fa8:	1009883a 	mov	r4,r2
81107fac:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fb0:	e0bfff17 	ldw	r2,-4(fp)
81107fb4:	10800017 	ldw	r2,0(r2)
81107fb8:	01402f04 	movi	r5,188
81107fbc:	1009883a 	mov	r4,r2
81107fc0:	1108b140 	call	81108b14 <uliRmapReadReg>
81107fc4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81107fc8:	e0bffe17 	ldw	r2,-8(fp)
81107fcc:	10bfffec 	andhi	r2,r2,65535
81107fd0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81107fd4:	e0bfff17 	ldw	r2,-4(fp)
81107fd8:	1080420b 	ldhu	r2,264(r2)
81107fdc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81107fe0:	e0fffe17 	ldw	r3,-8(fp)
81107fe4:	1884b03a 	or	r2,r3,r2
81107fe8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81107fec:	e0bffe17 	ldw	r2,-8(fp)
81107ff0:	10bfffcc 	andi	r2,r2,65535
81107ff4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81107ff8:	e0bfff17 	ldw	r2,-4(fp)
81107ffc:	10800017 	ldw	r2,0(r2)
81108000:	e1bffe17 	ldw	r6,-8(fp)
81108004:	01402f04 	movi	r5,188
81108008:	1009883a 	mov	r4,r2
8110800c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108010:	e0bfff17 	ldw	r2,-4(fp)
81108014:	10800017 	ldw	r2,0(r2)
81108018:	01402f44 	movi	r5,189
8110801c:	1009883a 	mov	r4,r2
81108020:	1108b140 	call	81108b14 <uliRmapReadReg>
81108024:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81108028:	e0bffe17 	ldw	r2,-8(fp)
8110802c:	10bfffec 	andhi	r2,r2,65535
81108030:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81108034:	e0bfff17 	ldw	r2,-4(fp)
81108038:	1080430b 	ldhu	r2,268(r2)
8110803c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81108040:	e0fffe17 	ldw	r3,-8(fp)
81108044:	1884b03a 	or	r2,r3,r2
81108048:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
8110804c:	e0bffe17 	ldw	r2,-8(fp)
81108050:	10bfffcc 	andi	r2,r2,65535
81108054:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81108058:	e0bfff17 	ldw	r2,-4(fp)
8110805c:	10800017 	ldw	r2,0(r2)
81108060:	e1bffe17 	ldw	r6,-8(fp)
81108064:	01402f44 	movi	r5,189
81108068:	1009883a 	mov	r4,r2
8110806c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108070:	e0bfff17 	ldw	r2,-4(fp)
81108074:	10800017 	ldw	r2,0(r2)
81108078:	01402f84 	movi	r5,190
8110807c:	1009883a 	mov	r4,r2
81108080:	1108b140 	call	81108b14 <uliRmapReadReg>
81108084:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81108088:	e0bffe17 	ldw	r2,-8(fp)
8110808c:	10bfffec 	andhi	r2,r2,65535
81108090:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81108094:	e0bfff17 	ldw	r2,-4(fp)
81108098:	1080440b 	ldhu	r2,272(r2)
8110809c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
811080a0:	e0fffe17 	ldw	r3,-8(fp)
811080a4:	1884b03a 	or	r2,r3,r2
811080a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
811080ac:	e0bffe17 	ldw	r2,-8(fp)
811080b0:	10bfffcc 	andi	r2,r2,65535
811080b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	10800017 	ldw	r2,0(r2)
811080c0:	e1bffe17 	ldw	r6,-8(fp)
811080c4:	01402f84 	movi	r5,190
811080c8:	1009883a 	mov	r4,r2
811080cc:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080d0:	e0bfff17 	ldw	r2,-4(fp)
811080d4:	10800017 	ldw	r2,0(r2)
811080d8:	01402fc4 	movi	r5,191
811080dc:	1009883a 	mov	r4,r2
811080e0:	1108b140 	call	81108b14 <uliRmapReadReg>
811080e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811080e8:	e0bffe17 	ldw	r2,-8(fp)
811080ec:	10bfffec 	andhi	r2,r2,65535
811080f0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811080f4:	e0bfff17 	ldw	r2,-4(fp)
811080f8:	1080450b 	ldhu	r2,276(r2)
811080fc:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81108100:	e0fffe17 	ldw	r3,-8(fp)
81108104:	1884b03a 	or	r2,r3,r2
81108108:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
8110810c:	e0bffe17 	ldw	r2,-8(fp)
81108110:	10bfffcc 	andi	r2,r2,65535
81108114:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10800017 	ldw	r2,0(r2)
81108120:	e1bffe17 	ldw	r6,-8(fp)
81108124:	01402fc4 	movi	r5,191
81108128:	1009883a 	mov	r4,r2
8110812c:	1108ac00 	call	81108ac0 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108130:	00800044 	movi	r2,1
81108134:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108138:	e0bffd17 	ldw	r2,-12(fp)
}
8110813c:	e037883a 	mov	sp,fp
81108140:	dfc00117 	ldw	ra,4(sp)
81108144:	df000017 	ldw	fp,0(sp)
81108148:	dec00204 	addi	sp,sp,8
8110814c:	f800283a 	ret

81108150 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108150:	defffb04 	addi	sp,sp,-20
81108154:	de00012e 	bgeu	sp,et,8110815c <bRmapGetRmapMemHKArea+0xc>
81108158:	003b68fa 	trap	3
8110815c:	dfc00415 	stw	ra,16(sp)
81108160:	df000315 	stw	fp,12(sp)
81108164:	df000304 	addi	fp,sp,12
81108168:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110816c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108170:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108174:	e0bfff17 	ldw	r2,-4(fp)
81108178:	1001e226 	beq	r2,zero,81108904 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110817c:	e0bfff17 	ldw	r2,-4(fp)
81108180:	10800017 	ldw	r2,0(r2)
81108184:	01402804 	movi	r5,160
81108188:	1009883a 	mov	r4,r2
8110818c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108190:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81108194:	e0bffe17 	ldw	r2,-8(fp)
81108198:	1007883a 	mov	r3,r2
8110819c:	e0bfff17 	ldw	r2,-4(fp)
811081a0:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
811081a4:	e0bffe17 	ldw	r2,-8(fp)
811081a8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
811081ac:	1007883a 	mov	r3,r2
811081b0:	e0bfff17 	ldw	r2,-4(fp)
811081b4:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081b8:	e0bfff17 	ldw	r2,-4(fp)
811081bc:	10800017 	ldw	r2,0(r2)
811081c0:	01402844 	movi	r5,161
811081c4:	1009883a 	mov	r4,r2
811081c8:	1108b140 	call	81108b14 <uliRmapReadReg>
811081cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
811081d0:	e0bffe17 	ldw	r2,-8(fp)
811081d4:	1007883a 	mov	r3,r2
811081d8:	e0bfff17 	ldw	r2,-4(fp)
811081dc:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811081e0:	e0bffe17 	ldw	r2,-8(fp)
811081e4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811081e8:	1007883a 	mov	r3,r2
811081ec:	e0bfff17 	ldw	r2,-4(fp)
811081f0:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081f4:	e0bfff17 	ldw	r2,-4(fp)
811081f8:	10800017 	ldw	r2,0(r2)
811081fc:	01402884 	movi	r5,162
81108200:	1009883a 	mov	r4,r2
81108204:	1108b140 	call	81108b14 <uliRmapReadReg>
81108208:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
8110820c:	e0bffe17 	ldw	r2,-8(fp)
81108210:	1007883a 	mov	r3,r2
81108214:	e0bfff17 	ldw	r2,-4(fp)
81108218:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
8110821c:	e0bffe17 	ldw	r2,-8(fp)
81108220:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
81108224:	1007883a 	mov	r3,r2
81108228:	e0bfff17 	ldw	r2,-4(fp)
8110822c:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108230:	e0bfff17 	ldw	r2,-4(fp)
81108234:	10800017 	ldw	r2,0(r2)
81108238:	014028c4 	movi	r5,163
8110823c:	1009883a 	mov	r4,r2
81108240:	1108b140 	call	81108b14 <uliRmapReadReg>
81108244:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81108248:	e0bffe17 	ldw	r2,-8(fp)
8110824c:	1007883a 	mov	r3,r2
81108250:	e0bfff17 	ldw	r2,-4(fp)
81108254:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81108258:	e0bffe17 	ldw	r2,-8(fp)
8110825c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81108260:	1007883a 	mov	r3,r2
81108264:	e0bfff17 	ldw	r2,-4(fp)
81108268:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110826c:	e0bfff17 	ldw	r2,-4(fp)
81108270:	10800017 	ldw	r2,0(r2)
81108274:	01402904 	movi	r5,164
81108278:	1009883a 	mov	r4,r2
8110827c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108280:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81108284:	e0bffe17 	ldw	r2,-8(fp)
81108288:	1007883a 	mov	r3,r2
8110828c:	e0bfff17 	ldw	r2,-4(fp)
81108290:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81108294:	e0bffe17 	ldw	r2,-8(fp)
81108298:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
8110829c:	1007883a 	mov	r3,r2
811082a0:	e0bfff17 	ldw	r2,-4(fp)
811082a4:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082a8:	e0bfff17 	ldw	r2,-4(fp)
811082ac:	10800017 	ldw	r2,0(r2)
811082b0:	01402944 	movi	r5,165
811082b4:	1009883a 	mov	r4,r2
811082b8:	1108b140 	call	81108b14 <uliRmapReadReg>
811082bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
811082c0:	e0bffe17 	ldw	r2,-8(fp)
811082c4:	1007883a 	mov	r3,r2
811082c8:	e0bfff17 	ldw	r2,-4(fp)
811082cc:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
811082d0:	e0bffe17 	ldw	r2,-8(fp)
811082d4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
811082d8:	1007883a 	mov	r3,r2
811082dc:	e0bfff17 	ldw	r2,-4(fp)
811082e0:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082e4:	e0bfff17 	ldw	r2,-4(fp)
811082e8:	10800017 	ldw	r2,0(r2)
811082ec:	01402984 	movi	r5,166
811082f0:	1009883a 	mov	r4,r2
811082f4:	1108b140 	call	81108b14 <uliRmapReadReg>
811082f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811082fc:	e0bffe17 	ldw	r2,-8(fp)
81108300:	1007883a 	mov	r3,r2
81108304:	e0bfff17 	ldw	r2,-4(fp)
81108308:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
8110830c:	e0bffe17 	ldw	r2,-8(fp)
81108310:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
81108314:	1007883a 	mov	r3,r2
81108318:	e0bfff17 	ldw	r2,-4(fp)
8110831c:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108320:	e0bfff17 	ldw	r2,-4(fp)
81108324:	10800017 	ldw	r2,0(r2)
81108328:	014029c4 	movi	r5,167
8110832c:	1009883a 	mov	r4,r2
81108330:	1108b140 	call	81108b14 <uliRmapReadReg>
81108334:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
81108338:	e0bffe17 	ldw	r2,-8(fp)
8110833c:	1007883a 	mov	r3,r2
81108340:	e0bfff17 	ldw	r2,-4(fp)
81108344:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81108348:	e0bffe17 	ldw	r2,-8(fp)
8110834c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81108350:	1007883a 	mov	r3,r2
81108354:	e0bfff17 	ldw	r2,-4(fp)
81108358:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	10800017 	ldw	r2,0(r2)
81108364:	01402a04 	movi	r5,168
81108368:	1009883a 	mov	r4,r2
8110836c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108370:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81108374:	e0bffe17 	ldw	r2,-8(fp)
81108378:	1007883a 	mov	r3,r2
8110837c:	e0bfff17 	ldw	r2,-4(fp)
81108380:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81108384:	e0bffe17 	ldw	r2,-8(fp)
81108388:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
8110838c:	1007883a 	mov	r3,r2
81108390:	e0bfff17 	ldw	r2,-4(fp)
81108394:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	10800017 	ldw	r2,0(r2)
811083a0:	01402a44 	movi	r5,169
811083a4:	1009883a 	mov	r4,r2
811083a8:	1108b140 	call	81108b14 <uliRmapReadReg>
811083ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
811083b0:	e0bffe17 	ldw	r2,-8(fp)
811083b4:	1007883a 	mov	r3,r2
811083b8:	e0bfff17 	ldw	r2,-4(fp)
811083bc:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
811083c0:	e0bffe17 	ldw	r2,-8(fp)
811083c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
811083c8:	1007883a 	mov	r3,r2
811083cc:	e0bfff17 	ldw	r2,-4(fp)
811083d0:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083d4:	e0bfff17 	ldw	r2,-4(fp)
811083d8:	10800017 	ldw	r2,0(r2)
811083dc:	01402a84 	movi	r5,170
811083e0:	1009883a 	mov	r4,r2
811083e4:	1108b140 	call	81108b14 <uliRmapReadReg>
811083e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811083ec:	e0bffe17 	ldw	r2,-8(fp)
811083f0:	1007883a 	mov	r3,r2
811083f4:	e0bfff17 	ldw	r2,-4(fp)
811083f8:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811083fc:	e0bffe17 	ldw	r2,-8(fp)
81108400:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
81108404:	1007883a 	mov	r3,r2
81108408:	e0bfff17 	ldw	r2,-4(fp)
8110840c:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108410:	e0bfff17 	ldw	r2,-4(fp)
81108414:	10800017 	ldw	r2,0(r2)
81108418:	01402ac4 	movi	r5,171
8110841c:	1009883a 	mov	r4,r2
81108420:	1108b140 	call	81108b14 <uliRmapReadReg>
81108424:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81108428:	e0bffe17 	ldw	r2,-8(fp)
8110842c:	1007883a 	mov	r3,r2
81108430:	e0bfff17 	ldw	r2,-4(fp)
81108434:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81108438:	e0bffe17 	ldw	r2,-8(fp)
8110843c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81108440:	1007883a 	mov	r3,r2
81108444:	e0bfff17 	ldw	r2,-4(fp)
81108448:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110844c:	e0bfff17 	ldw	r2,-4(fp)
81108450:	10800017 	ldw	r2,0(r2)
81108454:	01402b04 	movi	r5,172
81108458:	1009883a 	mov	r4,r2
8110845c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108460:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81108464:	e0bffe17 	ldw	r2,-8(fp)
81108468:	1007883a 	mov	r3,r2
8110846c:	e0bfff17 	ldw	r2,-4(fp)
81108470:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81108474:	e0bffe17 	ldw	r2,-8(fp)
81108478:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
8110847c:	1007883a 	mov	r3,r2
81108480:	e0bfff17 	ldw	r2,-4(fp)
81108484:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108488:	e0bfff17 	ldw	r2,-4(fp)
8110848c:	10800017 	ldw	r2,0(r2)
81108490:	01402b44 	movi	r5,173
81108494:	1009883a 	mov	r4,r2
81108498:	1108b140 	call	81108b14 <uliRmapReadReg>
8110849c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
811084a0:	e0bffe17 	ldw	r2,-8(fp)
811084a4:	1007883a 	mov	r3,r2
811084a8:	e0bfff17 	ldw	r2,-4(fp)
811084ac:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
811084b0:	e0bffe17 	ldw	r2,-8(fp)
811084b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
811084b8:	1007883a 	mov	r3,r2
811084bc:	e0bfff17 	ldw	r2,-4(fp)
811084c0:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084c4:	e0bfff17 	ldw	r2,-4(fp)
811084c8:	10800017 	ldw	r2,0(r2)
811084cc:	01402b84 	movi	r5,174
811084d0:	1009883a 	mov	r4,r2
811084d4:	1108b140 	call	81108b14 <uliRmapReadReg>
811084d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811084dc:	e0bffe17 	ldw	r2,-8(fp)
811084e0:	1007883a 	mov	r3,r2
811084e4:	e0bfff17 	ldw	r2,-4(fp)
811084e8:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811084ec:	e0bffe17 	ldw	r2,-8(fp)
811084f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811084f4:	1007883a 	mov	r3,r2
811084f8:	e0bfff17 	ldw	r2,-4(fp)
811084fc:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108500:	e0bfff17 	ldw	r2,-4(fp)
81108504:	10800017 	ldw	r2,0(r2)
81108508:	01402bc4 	movi	r5,175
8110850c:	1009883a 	mov	r4,r2
81108510:	1108b140 	call	81108b14 <uliRmapReadReg>
81108514:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81108518:	e0bffe17 	ldw	r2,-8(fp)
8110851c:	1007883a 	mov	r3,r2
81108520:	e0bfff17 	ldw	r2,-4(fp)
81108524:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81108528:	e0bffe17 	ldw	r2,-8(fp)
8110852c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81108530:	1007883a 	mov	r3,r2
81108534:	e0bfff17 	ldw	r2,-4(fp)
81108538:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110853c:	e0bfff17 	ldw	r2,-4(fp)
81108540:	10800017 	ldw	r2,0(r2)
81108544:	01402c04 	movi	r5,176
81108548:	1009883a 	mov	r4,r2
8110854c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108550:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81108554:	e0bffe17 	ldw	r2,-8(fp)
81108558:	1007883a 	mov	r3,r2
8110855c:	e0bfff17 	ldw	r2,-4(fp)
81108560:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81108564:	e0bffe17 	ldw	r2,-8(fp)
81108568:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
8110856c:	1007883a 	mov	r3,r2
81108570:	e0bfff17 	ldw	r2,-4(fp)
81108574:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108578:	e0bfff17 	ldw	r2,-4(fp)
8110857c:	10800017 	ldw	r2,0(r2)
81108580:	01402c44 	movi	r5,177
81108584:	1009883a 	mov	r4,r2
81108588:	1108b140 	call	81108b14 <uliRmapReadReg>
8110858c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81108590:	e0bffe17 	ldw	r2,-8(fp)
81108594:	1007883a 	mov	r3,r2
81108598:	e0bfff17 	ldw	r2,-4(fp)
8110859c:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
811085a0:	e0bffe17 	ldw	r2,-8(fp)
811085a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
811085a8:	1007883a 	mov	r3,r2
811085ac:	e0bfff17 	ldw	r2,-4(fp)
811085b0:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085b4:	e0bfff17 	ldw	r2,-4(fp)
811085b8:	10800017 	ldw	r2,0(r2)
811085bc:	01402c84 	movi	r5,178
811085c0:	1009883a 	mov	r4,r2
811085c4:	1108b140 	call	81108b14 <uliRmapReadReg>
811085c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
811085cc:	e0bffe17 	ldw	r2,-8(fp)
811085d0:	1007883a 	mov	r3,r2
811085d4:	e0bfff17 	ldw	r2,-4(fp)
811085d8:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811085dc:	e0bffe17 	ldw	r2,-8(fp)
811085e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811085e4:	1007883a 	mov	r3,r2
811085e8:	e0bfff17 	ldw	r2,-4(fp)
811085ec:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	10800017 	ldw	r2,0(r2)
811085f8:	01402cc4 	movi	r5,179
811085fc:	1009883a 	mov	r4,r2
81108600:	1108b140 	call	81108b14 <uliRmapReadReg>
81108604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81108608:	e0bffe17 	ldw	r2,-8(fp)
8110860c:	1007883a 	mov	r3,r2
81108610:	e0bfff17 	ldw	r2,-4(fp)
81108614:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81108618:	e0bffe17 	ldw	r2,-8(fp)
8110861c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81108620:	1007883a 	mov	r3,r2
81108624:	e0bfff17 	ldw	r2,-4(fp)
81108628:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110862c:	e0bfff17 	ldw	r2,-4(fp)
81108630:	10800017 	ldw	r2,0(r2)
81108634:	01402d04 	movi	r5,180
81108638:	1009883a 	mov	r4,r2
8110863c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108640:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81108644:	e0bffe17 	ldw	r2,-8(fp)
81108648:	1007883a 	mov	r3,r2
8110864c:	e0bfff17 	ldw	r2,-4(fp)
81108650:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81108654:	e0bffe17 	ldw	r2,-8(fp)
81108658:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
8110865c:	1007883a 	mov	r3,r2
81108660:	e0bfff17 	ldw	r2,-4(fp)
81108664:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108668:	e0bfff17 	ldw	r2,-4(fp)
8110866c:	10800017 	ldw	r2,0(r2)
81108670:	01402d44 	movi	r5,181
81108674:	1009883a 	mov	r4,r2
81108678:	1108b140 	call	81108b14 <uliRmapReadReg>
8110867c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81108680:	e0bffe17 	ldw	r2,-8(fp)
81108684:	1007883a 	mov	r3,r2
81108688:	e0bfff17 	ldw	r2,-4(fp)
8110868c:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81108690:	e0bffe17 	ldw	r2,-8(fp)
81108694:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81108698:	1007883a 	mov	r3,r2
8110869c:	e0bfff17 	ldw	r2,-4(fp)
811086a0:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086a4:	e0bfff17 	ldw	r2,-4(fp)
811086a8:	10800017 	ldw	r2,0(r2)
811086ac:	01402d84 	movi	r5,182
811086b0:	1009883a 	mov	r4,r2
811086b4:	1108b140 	call	81108b14 <uliRmapReadReg>
811086b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
811086bc:	e0bffe17 	ldw	r2,-8(fp)
811086c0:	1007883a 	mov	r3,r2
811086c4:	e0bfff17 	ldw	r2,-4(fp)
811086c8:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
811086cc:	e0bffe17 	ldw	r2,-8(fp)
811086d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
811086d4:	1007883a 	mov	r3,r2
811086d8:	e0bfff17 	ldw	r2,-4(fp)
811086dc:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086e0:	e0bfff17 	ldw	r2,-4(fp)
811086e4:	10800017 	ldw	r2,0(r2)
811086e8:	01402dc4 	movi	r5,183
811086ec:	1009883a 	mov	r4,r2
811086f0:	1108b140 	call	81108b14 <uliRmapReadReg>
811086f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
811086f8:	e0bffe17 	ldw	r2,-8(fp)
811086fc:	1007883a 	mov	r3,r2
81108700:	e0bfff17 	ldw	r2,-4(fp)
81108704:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81108708:	e0bffe17 	ldw	r2,-8(fp)
8110870c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81108710:	1007883a 	mov	r3,r2
81108714:	e0bfff17 	ldw	r2,-4(fp)
81108718:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110871c:	e0bfff17 	ldw	r2,-4(fp)
81108720:	10800017 	ldw	r2,0(r2)
81108724:	01402e04 	movi	r5,184
81108728:	1009883a 	mov	r4,r2
8110872c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108730:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81108734:	e0bffe17 	ldw	r2,-8(fp)
81108738:	1007883a 	mov	r3,r2
8110873c:	e0bfff17 	ldw	r2,-4(fp)
81108740:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81108744:	e0bffe17 	ldw	r2,-8(fp)
81108748:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
8110874c:	1007883a 	mov	r3,r2
81108750:	e0bfff17 	ldw	r2,-4(fp)
81108754:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108758:	e0bfff17 	ldw	r2,-4(fp)
8110875c:	10800017 	ldw	r2,0(r2)
81108760:	01402e44 	movi	r5,185
81108764:	1009883a 	mov	r4,r2
81108768:	1108b140 	call	81108b14 <uliRmapReadReg>
8110876c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81108770:	e0bffe17 	ldw	r2,-8(fp)
81108774:	1007883a 	mov	r3,r2
81108778:	e0bfff17 	ldw	r2,-4(fp)
8110877c:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81108780:	e0bffe17 	ldw	r2,-8(fp)
81108784:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81108788:	1007883a 	mov	r3,r2
8110878c:	e0bfff17 	ldw	r2,-4(fp)
81108790:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	10800017 	ldw	r2,0(r2)
8110879c:	01402e84 	movi	r5,186
811087a0:	1009883a 	mov	r4,r2
811087a4:	1108b140 	call	81108b14 <uliRmapReadReg>
811087a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
811087ac:	e0bffe17 	ldw	r2,-8(fp)
811087b0:	1007883a 	mov	r3,r2
811087b4:	e0bfff17 	ldw	r2,-4(fp)
811087b8:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
811087bc:	e0bffe17 	ldw	r2,-8(fp)
811087c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
811087c4:	1007883a 	mov	r3,r2
811087c8:	e0bfff17 	ldw	r2,-4(fp)
811087cc:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087d0:	e0bfff17 	ldw	r2,-4(fp)
811087d4:	10800017 	ldw	r2,0(r2)
811087d8:	01402ec4 	movi	r5,187
811087dc:	1009883a 	mov	r4,r2
811087e0:	1108b140 	call	81108b14 <uliRmapReadReg>
811087e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
811087e8:	e0bffe17 	ldw	r2,-8(fp)
811087ec:	1007883a 	mov	r3,r2
811087f0:	e0bfff17 	ldw	r2,-4(fp)
811087f4:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
811087f8:	e0bffe17 	ldw	r2,-8(fp)
811087fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81108800:	1007883a 	mov	r3,r2
81108804:	e0bfff17 	ldw	r2,-4(fp)
81108808:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110880c:	e0bfff17 	ldw	r2,-4(fp)
81108810:	10800017 	ldw	r2,0(r2)
81108814:	01402f04 	movi	r5,188
81108818:	1009883a 	mov	r4,r2
8110881c:	1108b140 	call	81108b14 <uliRmapReadReg>
81108820:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81108824:	e0bffe17 	ldw	r2,-8(fp)
81108828:	1007883a 	mov	r3,r2
8110882c:	e0bfff17 	ldw	r2,-4(fp)
81108830:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81108834:	e0bffe17 	ldw	r2,-8(fp)
81108838:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
8110883c:	1007883a 	mov	r3,r2
81108840:	e0bfff17 	ldw	r2,-4(fp)
81108844:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108848:	e0bfff17 	ldw	r2,-4(fp)
8110884c:	10800017 	ldw	r2,0(r2)
81108850:	01402f44 	movi	r5,189
81108854:	1009883a 	mov	r4,r2
81108858:	1108b140 	call	81108b14 <uliRmapReadReg>
8110885c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81108860:	e0bffe17 	ldw	r2,-8(fp)
81108864:	1007883a 	mov	r3,r2
81108868:	e0bfff17 	ldw	r2,-4(fp)
8110886c:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81108870:	e0bffe17 	ldw	r2,-8(fp)
81108874:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81108878:	1007883a 	mov	r3,r2
8110887c:	e0bfff17 	ldw	r2,-4(fp)
81108880:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108884:	e0bfff17 	ldw	r2,-4(fp)
81108888:	10800017 	ldw	r2,0(r2)
8110888c:	01402f84 	movi	r5,190
81108890:	1009883a 	mov	r4,r2
81108894:	1108b140 	call	81108b14 <uliRmapReadReg>
81108898:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
8110889c:	e0bffe17 	ldw	r2,-8(fp)
811088a0:	1007883a 	mov	r3,r2
811088a4:	e0bfff17 	ldw	r2,-4(fp)
811088a8:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
811088ac:	e0bffe17 	ldw	r2,-8(fp)
811088b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
811088b4:	1007883a 	mov	r3,r2
811088b8:	e0bfff17 	ldw	r2,-4(fp)
811088bc:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088c0:	e0bfff17 	ldw	r2,-4(fp)
811088c4:	10800017 	ldw	r2,0(r2)
811088c8:	01402fc4 	movi	r5,191
811088cc:	1009883a 	mov	r4,r2
811088d0:	1108b140 	call	81108b14 <uliRmapReadReg>
811088d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
811088d8:	e0bffe17 	ldw	r2,-8(fp)
811088dc:	1007883a 	mov	r3,r2
811088e0:	e0bfff17 	ldw	r2,-4(fp)
811088e4:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
811088e8:	e0bffe17 	ldw	r2,-8(fp)
811088ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
811088f0:	1007883a 	mov	r3,r2
811088f4:	e0bfff17 	ldw	r2,-4(fp)
811088f8:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
811088fc:	00800044 	movi	r2,1
81108900:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108904:	e0bffd17 	ldw	r2,-12(fp)
}
81108908:	e037883a 	mov	sp,fp
8110890c:	dfc00117 	ldw	ra,4(sp)
81108910:	df000017 	ldw	fp,0(sp)
81108914:	dec00204 	addi	sp,sp,8
81108918:	f800283a 	ret

8110891c <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
8110891c:	defffb04 	addi	sp,sp,-20
81108920:	de00012e 	bgeu	sp,et,81108928 <bRmapInitCh+0xc>
81108924:	003b68fa 	trap	3
81108928:	dfc00415 	stw	ra,16(sp)
8110892c:	df000315 	stw	fp,12(sp)
81108930:	df000304 	addi	fp,sp,12
81108934:	e13ffe15 	stw	r4,-8(fp)
81108938:	2805883a 	mov	r2,r5
8110893c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81108940:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81108944:	e0bffe17 	ldw	r2,-8(fp)
81108948:	10005726 	beq	r2,zero,81108aa8 <bRmapInitCh+0x18c>
		bStatus = TRUE;
8110894c:	00800044 	movi	r2,1
81108950:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81108954:	e0bfff03 	ldbu	r2,-4(fp)
81108958:	10c00228 	cmpgeui	r3,r2,8
8110895c:	1800361e 	bne	r3,zero,81108a38 <bRmapInitCh+0x11c>
81108960:	100690ba 	slli	r3,r2,2
81108964:	00a04474 	movhi	r2,33041
81108968:	10a25e04 	addi	r2,r2,-30344
8110896c:	1885883a 	add	r2,r3,r2
81108970:	10800017 	ldw	r2,0(r2)
81108974:	1000683a 	jmp	r2
81108978:	81108998 	cmpnei	r4,r16,16934
8110897c:	811089ac 	andhi	r4,r16,16934
81108980:	811089c0 	call	8811089c <__reset+0x20f089c>
81108984:	811089d4 	ori	r4,r16,16935
81108988:	811089e8 	cmpgeui	r4,r16,16935
8110898c:	811089fc 	xorhi	r4,r16,16935
81108990:	81108a10 	cmplti	r4,r16,16936
81108994:	81108a24 	muli	r4,r16,16936
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81108998:	e0fffe17 	ldw	r3,-8(fp)
8110899c:	00a04834 	movhi	r2,33056
811089a0:	108b0004 	addi	r2,r2,11264
811089a4:	18800015 	stw	r2,0(r3)
			break;
811089a8:	00002506 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811089ac:	e0fffe17 	ldw	r3,-8(fp)
811089b0:	00a04834 	movhi	r2,33056
811089b4:	108a0004 	addi	r2,r2,10240
811089b8:	18800015 	stw	r2,0(r3)
			break;
811089bc:	00002006 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811089c0:	e0fffe17 	ldw	r3,-8(fp)
811089c4:	00a04834 	movhi	r2,33056
811089c8:	10890004 	addi	r2,r2,9216
811089cc:	18800015 	stw	r2,0(r3)
			break;
811089d0:	00001b06 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811089d4:	e0fffe17 	ldw	r3,-8(fp)
811089d8:	00a04834 	movhi	r2,33056
811089dc:	10880004 	addi	r2,r2,8192
811089e0:	18800015 	stw	r2,0(r3)
			break;
811089e4:	00001606 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811089e8:	e0fffe17 	ldw	r3,-8(fp)
811089ec:	00a04834 	movhi	r2,33056
811089f0:	10870004 	addi	r2,r2,7168
811089f4:	18800015 	stw	r2,0(r3)
			break;
811089f8:	00001106 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811089fc:	e0fffe17 	ldw	r3,-8(fp)
81108a00:	00a04834 	movhi	r2,33056
81108a04:	10860004 	addi	r2,r2,6144
81108a08:	18800015 	stw	r2,0(r3)
			break;
81108a0c:	00000c06 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81108a10:	e0fffe17 	ldw	r3,-8(fp)
81108a14:	00a04834 	movhi	r2,33056
81108a18:	10850004 	addi	r2,r2,5120
81108a1c:	18800015 	stw	r2,0(r3)
			break;
81108a20:	00000706 	br	81108a40 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81108a24:	e0fffe17 	ldw	r3,-8(fp)
81108a28:	00a04834 	movhi	r2,33056
81108a2c:	10840004 	addi	r2,r2,4096
81108a30:	18800015 	stw	r2,0(r3)
			break;
81108a34:	00000206 	br	81108a40 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81108a38:	e03ffd15 	stw	zero,-12(fp)
			break;
81108a3c:	0001883a 	nop
		}

		if (bStatus) {
81108a40:	e0bffd17 	ldw	r2,-12(fp)
81108a44:	10001826 	beq	r2,zero,81108aa8 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81108a48:	e13ffe17 	ldw	r4,-8(fp)
81108a4c:	110697c0 	call	8110697c <bRmapGetIrqControl>
81108a50:	1000011e 	bne	r2,zero,81108a58 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81108a54:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81108a58:	e13ffe17 	ldw	r4,-8(fp)
81108a5c:	1106b640 	call	81106b64 <bRmapGetCodecConfig>
81108a60:	1000011e 	bne	r2,zero,81108a68 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81108a64:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81108a68:	e13ffe17 	ldw	r4,-8(fp)
81108a6c:	1106bf00 	call	81106bf0 <bRmapGetCodecStatus>
81108a70:	1000011e 	bne	r2,zero,81108a78 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81108a74:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81108a78:	e13ffe17 	ldw	r4,-8(fp)
81108a7c:	110719c0 	call	8110719c <bRmapGetMemConfigArea>
81108a80:	1000011e 	bne	r2,zero,81108a88 <bRmapInitCh+0x16c>
				bStatus = FALSE;
81108a84:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81108a88:	e13ffe17 	ldw	r4,-8(fp)
81108a8c:	11074700 	call	81107470 <bRmapGetMemConfigStat>
81108a90:	1000011e 	bne	r2,zero,81108a98 <bRmapInitCh+0x17c>
				bStatus = FALSE;
81108a94:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81108a98:	e13ffe17 	ldw	r4,-8(fp)
81108a9c:	11081500 	call	81108150 <bRmapGetRmapMemHKArea>
81108aa0:	1000011e 	bne	r2,zero,81108aa8 <bRmapInitCh+0x18c>
				bStatus = FALSE;
81108aa4:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108aa8:	e0bffd17 	ldw	r2,-12(fp)
}
81108aac:	e037883a 	mov	sp,fp
81108ab0:	dfc00117 	ldw	ra,4(sp)
81108ab4:	df000017 	ldw	fp,0(sp)
81108ab8:	dec00204 	addi	sp,sp,8
81108abc:	f800283a 	ret

81108ac0 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108ac0:	defffc04 	addi	sp,sp,-16
81108ac4:	de00012e 	bgeu	sp,et,81108acc <vRmapWriteReg+0xc>
81108ac8:	003b68fa 	trap	3
81108acc:	df000315 	stw	fp,12(sp)
81108ad0:	df000304 	addi	fp,sp,12
81108ad4:	e13ffd15 	stw	r4,-12(fp)
81108ad8:	e17ffe15 	stw	r5,-8(fp)
81108adc:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108ae0:	e0bffe17 	ldw	r2,-8(fp)
81108ae4:	1085883a 	add	r2,r2,r2
81108ae8:	1085883a 	add	r2,r2,r2
81108aec:	1007883a 	mov	r3,r2
81108af0:	e0bffd17 	ldw	r2,-12(fp)
81108af4:	10c5883a 	add	r2,r2,r3
81108af8:	e0ffff17 	ldw	r3,-4(fp)
81108afc:	10c00015 	stw	r3,0(r2)
}
81108b00:	0001883a 	nop
81108b04:	e037883a 	mov	sp,fp
81108b08:	df000017 	ldw	fp,0(sp)
81108b0c:	dec00104 	addi	sp,sp,4
81108b10:	f800283a 	ret

81108b14 <uliRmapReadReg>:

static alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81108b14:	defffc04 	addi	sp,sp,-16
81108b18:	de00012e 	bgeu	sp,et,81108b20 <uliRmapReadReg+0xc>
81108b1c:	003b68fa 	trap	3
81108b20:	df000315 	stw	fp,12(sp)
81108b24:	df000304 	addi	fp,sp,12
81108b28:	e13ffe15 	stw	r4,-8(fp)
81108b2c:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81108b30:	e0bfff17 	ldw	r2,-4(fp)
81108b34:	1085883a 	add	r2,r2,r2
81108b38:	1085883a 	add	r2,r2,r2
81108b3c:	1007883a 	mov	r3,r2
81108b40:	e0bffe17 	ldw	r2,-8(fp)
81108b44:	10c5883a 	add	r2,r2,r3
81108b48:	10800017 	ldw	r2,0(r2)
81108b4c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81108b50:	e0bffd17 	ldw	r2,-12(fp)
}
81108b54:	e037883a 	mov	sp,fp
81108b58:	df000017 	ldw	fp,0(sp)
81108b5c:	dec00104 	addi	sp,sp,4
81108b60:	f800283a 	ret

81108b64 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81108b64:	defffd04 	addi	sp,sp,-12
81108b68:	de00012e 	bgeu	sp,et,81108b70 <uliConvRmapCfgAddr+0xc>
81108b6c:	003b68fa 	trap	3
81108b70:	df000215 	stw	fp,8(sp)
81108b74:	df000204 	addi	fp,sp,8
81108b78:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81108b7c:	e0bfff17 	ldw	r2,-4(fp)
81108b80:	10801368 	cmpgeui	r2,r2,77
81108b84:	10008a1e 	bne	r2,zero,81108db0 <uliConvRmapCfgAddr+0x24c>
81108b88:	e0bfff17 	ldw	r2,-4(fp)
81108b8c:	100690ba 	slli	r3,r2,2
81108b90:	00a04474 	movhi	r2,33041
81108b94:	10a2e904 	addi	r2,r2,-29788
81108b98:	1885883a 	add	r2,r3,r2
81108b9c:	10800017 	ldw	r2,0(r2)
81108ba0:	1000683a 	jmp	r2
81108ba4:	81108cd8 	cmpnei	r4,r16,16947
81108ba8:	81108db0 	cmpltui	r4,r16,16950
81108bac:	81108db0 	cmpltui	r4,r16,16950
81108bb0:	81108db0 	cmpltui	r4,r16,16950
81108bb4:	81108ce4 	muli	r4,r16,16947
81108bb8:	81108db0 	cmpltui	r4,r16,16950
81108bbc:	81108db0 	cmpltui	r4,r16,16950
81108bc0:	81108db0 	cmpltui	r4,r16,16950
81108bc4:	81108cf0 	cmpltui	r4,r16,16947
81108bc8:	81108db0 	cmpltui	r4,r16,16950
81108bcc:	81108db0 	cmpltui	r4,r16,16950
81108bd0:	81108db0 	cmpltui	r4,r16,16950
81108bd4:	81108cfc 	xorhi	r4,r16,16947
81108bd8:	81108db0 	cmpltui	r4,r16,16950
81108bdc:	81108db0 	cmpltui	r4,r16,16950
81108be0:	81108db0 	cmpltui	r4,r16,16950
81108be4:	81108d08 	cmpgei	r4,r16,16948
81108be8:	81108db0 	cmpltui	r4,r16,16950
81108bec:	81108db0 	cmpltui	r4,r16,16950
81108bf0:	81108db0 	cmpltui	r4,r16,16950
81108bf4:	81108d14 	ori	r4,r16,16948
81108bf8:	81108db0 	cmpltui	r4,r16,16950
81108bfc:	81108db0 	cmpltui	r4,r16,16950
81108c00:	81108db0 	cmpltui	r4,r16,16950
81108c04:	81108d20 	cmpeqi	r4,r16,16948
81108c08:	81108db0 	cmpltui	r4,r16,16950
81108c0c:	81108db0 	cmpltui	r4,r16,16950
81108c10:	81108db0 	cmpltui	r4,r16,16950
81108c14:	81108d2c 	andhi	r4,r16,16948
81108c18:	81108db0 	cmpltui	r4,r16,16950
81108c1c:	81108db0 	cmpltui	r4,r16,16950
81108c20:	81108db0 	cmpltui	r4,r16,16950
81108c24:	81108d38 	rdprs	r4,r16,16948
81108c28:	81108db0 	cmpltui	r4,r16,16950
81108c2c:	81108db0 	cmpltui	r4,r16,16950
81108c30:	81108db0 	cmpltui	r4,r16,16950
81108c34:	81108d44 	addi	r4,r16,16949
81108c38:	81108db0 	cmpltui	r4,r16,16950
81108c3c:	81108db0 	cmpltui	r4,r16,16950
81108c40:	81108db0 	cmpltui	r4,r16,16950
81108c44:	81108d50 	cmplti	r4,r16,16949
81108c48:	81108db0 	cmpltui	r4,r16,16950
81108c4c:	81108db0 	cmpltui	r4,r16,16950
81108c50:	81108db0 	cmpltui	r4,r16,16950
81108c54:	81108d5c 	xori	r4,r16,16949
81108c58:	81108db0 	cmpltui	r4,r16,16950
81108c5c:	81108db0 	cmpltui	r4,r16,16950
81108c60:	81108db0 	cmpltui	r4,r16,16950
81108c64:	81108db0 	cmpltui	r4,r16,16950
81108c68:	81108db0 	cmpltui	r4,r16,16950
81108c6c:	81108db0 	cmpltui	r4,r16,16950
81108c70:	81108db0 	cmpltui	r4,r16,16950
81108c74:	81108db0 	cmpltui	r4,r16,16950
81108c78:	81108db0 	cmpltui	r4,r16,16950
81108c7c:	81108db0 	cmpltui	r4,r16,16950
81108c80:	81108db0 	cmpltui	r4,r16,16950
81108c84:	81108d68 	cmpgeui	r4,r16,16949
81108c88:	81108db0 	cmpltui	r4,r16,16950
81108c8c:	81108db0 	cmpltui	r4,r16,16950
81108c90:	81108db0 	cmpltui	r4,r16,16950
81108c94:	81108d74 	orhi	r4,r16,16949
81108c98:	81108db0 	cmpltui	r4,r16,16950
81108c9c:	81108db0 	cmpltui	r4,r16,16950
81108ca0:	81108db0 	cmpltui	r4,r16,16950
81108ca4:	81108d80 	call	881108d8 <__reset+0x20f08d8>
81108ca8:	81108db0 	cmpltui	r4,r16,16950
81108cac:	81108db0 	cmpltui	r4,r16,16950
81108cb0:	81108db0 	cmpltui	r4,r16,16950
81108cb4:	81108d8c 	andi	r4,r16,16950
81108cb8:	81108db0 	cmpltui	r4,r16,16950
81108cbc:	81108db0 	cmpltui	r4,r16,16950
81108cc0:	81108db0 	cmpltui	r4,r16,16950
81108cc4:	81108d98 	cmpnei	r4,r16,16950
81108cc8:	81108db0 	cmpltui	r4,r16,16950
81108ccc:	81108db0 	cmpltui	r4,r16,16950
81108cd0:	81108db0 	cmpltui	r4,r16,16950
81108cd4:	81108da4 	muli	r4,r16,16950
	case 0x00000000:
		uliValue = 0x00000040;
81108cd8:	00801004 	movi	r2,64
81108cdc:	e0bffe15 	stw	r2,-8(fp)
		break;
81108ce0:	00003506 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81108ce4:	00801044 	movi	r2,65
81108ce8:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cec:	00003206 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81108cf0:	00801084 	movi	r2,66
81108cf4:	e0bffe15 	stw	r2,-8(fp)
		break;
81108cf8:	00002f06 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81108cfc:	008010c4 	movi	r2,67
81108d00:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d04:	00002c06 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
81108d08:	00801104 	movi	r2,68
81108d0c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d10:	00002906 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
81108d14:	00801144 	movi	r2,69
81108d18:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d1c:	00002606 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
81108d20:	00801184 	movi	r2,70
81108d24:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d28:	00002306 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
81108d2c:	008011c4 	movi	r2,71
81108d30:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d34:	00002006 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
81108d38:	00801204 	movi	r2,72
81108d3c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d40:	00001d06 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81108d44:	00801244 	movi	r2,73
81108d48:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d4c:	00001a06 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
81108d50:	00801284 	movi	r2,74
81108d54:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d58:	00001706 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
81108d5c:	008012c4 	movi	r2,75
81108d60:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d64:	00001406 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
81108d68:	00801304 	movi	r2,76
81108d6c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d70:	00001106 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
81108d74:	00801344 	movi	r2,77
81108d78:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d7c:	00000e06 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
81108d80:	00801384 	movi	r2,78
81108d84:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d88:	00000b06 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
81108d8c:	008013c4 	movi	r2,79
81108d90:	e0bffe15 	stw	r2,-8(fp)
		break;
81108d94:	00000806 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
81108d98:	00801404 	movi	r2,80
81108d9c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108da0:	00000506 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
81108da4:	00801444 	movi	r2,81
81108da8:	e0bffe15 	stw	r2,-8(fp)
		break;
81108dac:	00000206 	br	81108db8 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81108db0:	e03ffe15 	stw	zero,-8(fp)
		break;
81108db4:	0001883a 	nop
	}

	return uliValue;
81108db8:	e0bffe17 	ldw	r2,-8(fp)
}
81108dbc:	e037883a 	mov	sp,fp
81108dc0:	df000017 	ldw	fp,0(sp)
81108dc4:	dec00104 	addi	sp,sp,4
81108dc8:	f800283a 	ret

81108dcc <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81108dcc:	defffb04 	addi	sp,sp,-20
81108dd0:	de00012e 	bgeu	sp,et,81108dd8 <bSpwcSetLink+0xc>
81108dd4:	003b68fa 	trap	3
81108dd8:	dfc00415 	stw	ra,16(sp)
81108ddc:	df000315 	stw	fp,12(sp)
81108de0:	df000304 	addi	fp,sp,12
81108de4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108de8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108dec:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108df0:	e0bfff17 	ldw	r2,-4(fp)
81108df4:	10003c26 	beq	r2,zero,81108ee8 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108df8:	e0bfff17 	ldw	r2,-4(fp)
81108dfc:	10800017 	ldw	r2,0(r2)
81108e00:	000b883a 	mov	r5,zero
81108e04:	1009883a 	mov	r4,r2
81108e08:	11094980 	call	81109498 <uliSpwcReadReg>
81108e0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81108e10:	e0bfff17 	ldw	r2,-4(fp)
81108e14:	10800117 	ldw	r2,4(r2)
81108e18:	10000426 	beq	r2,zero,81108e2c <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
81108e1c:	e0bffe17 	ldw	r2,-8(fp)
81108e20:	10800114 	ori	r2,r2,4
81108e24:	e0bffe15 	stw	r2,-8(fp)
81108e28:	00000406 	br	81108e3c <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
81108e2c:	e0fffe17 	ldw	r3,-8(fp)
81108e30:	00bffec4 	movi	r2,-5
81108e34:	1884703a 	and	r2,r3,r2
81108e38:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
81108e3c:	e0bfff17 	ldw	r2,-4(fp)
81108e40:	10800217 	ldw	r2,8(r2)
81108e44:	10000426 	beq	r2,zero,81108e58 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
81108e48:	e0bffe17 	ldw	r2,-8(fp)
81108e4c:	10800094 	ori	r2,r2,2
81108e50:	e0bffe15 	stw	r2,-8(fp)
81108e54:	00000406 	br	81108e68 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
81108e58:	e0fffe17 	ldw	r3,-8(fp)
81108e5c:	00bfff44 	movi	r2,-3
81108e60:	1884703a 	and	r2,r3,r2
81108e64:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81108e68:	e0bfff17 	ldw	r2,-4(fp)
81108e6c:	10800317 	ldw	r2,12(r2)
81108e70:	10000426 	beq	r2,zero,81108e84 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
81108e74:	e0bffe17 	ldw	r2,-8(fp)
81108e78:	10800054 	ori	r2,r2,1
81108e7c:	e0bffe15 	stw	r2,-8(fp)
81108e80:	00000406 	br	81108e94 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
81108e84:	e0fffe17 	ldw	r3,-8(fp)
81108e88:	00bfff84 	movi	r2,-2
81108e8c:	1884703a 	and	r2,r3,r2
81108e90:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
81108e94:	e0fffe17 	ldw	r3,-8(fp)
81108e98:	00804034 	movhi	r2,256
81108e9c:	10bfffc4 	addi	r2,r2,-1
81108ea0:	1884703a 	and	r2,r3,r2
81108ea4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
81108ea8:	e0bfff17 	ldw	r2,-4(fp)
81108eac:	10800403 	ldbu	r2,16(r2)
81108eb0:	10803fcc 	andi	r2,r2,255
81108eb4:	1004963a 	slli	r2,r2,24
81108eb8:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81108ebc:	e0bffe17 	ldw	r2,-8(fp)
81108ec0:	10c4b03a 	or	r2,r2,r3
81108ec4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
81108ec8:	e0bfff17 	ldw	r2,-4(fp)
81108ecc:	10800017 	ldw	r2,0(r2)
81108ed0:	e1bffe17 	ldw	r6,-8(fp)
81108ed4:	000b883a 	mov	r5,zero
81108ed8:	1009883a 	mov	r4,r2
81108edc:	11094440 	call	81109444 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81108ee0:	00800044 	movi	r2,1
81108ee4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108ee8:	e0bffd17 	ldw	r2,-12(fp)
}
81108eec:	e037883a 	mov	sp,fp
81108ef0:	dfc00117 	ldw	ra,4(sp)
81108ef4:	df000017 	ldw	fp,0(sp)
81108ef8:	dec00204 	addi	sp,sp,8
81108efc:	f800283a 	ret

81108f00 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81108f00:	defffb04 	addi	sp,sp,-20
81108f04:	de00012e 	bgeu	sp,et,81108f0c <bSpwcGetLink+0xc>
81108f08:	003b68fa 	trap	3
81108f0c:	dfc00415 	stw	ra,16(sp)
81108f10:	df000315 	stw	fp,12(sp)
81108f14:	df000304 	addi	fp,sp,12
81108f18:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108f1c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108f20:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108f24:	e0bfff17 	ldw	r2,-4(fp)
81108f28:	10002826 	beq	r2,zero,81108fcc <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108f2c:	e0bfff17 	ldw	r2,-4(fp)
81108f30:	10800017 	ldw	r2,0(r2)
81108f34:	000b883a 	mov	r5,zero
81108f38:	1009883a 	mov	r4,r2
81108f3c:	11094980 	call	81109498 <uliSpwcReadReg>
81108f40:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
81108f44:	e0bffe17 	ldw	r2,-8(fp)
81108f48:	1080010c 	andi	r2,r2,4
81108f4c:	10000426 	beq	r2,zero,81108f60 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
81108f50:	e0bfff17 	ldw	r2,-4(fp)
81108f54:	00c00044 	movi	r3,1
81108f58:	10c00115 	stw	r3,4(r2)
81108f5c:	00000206 	br	81108f68 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
81108f60:	e0bfff17 	ldw	r2,-4(fp)
81108f64:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
81108f68:	e0bffe17 	ldw	r2,-8(fp)
81108f6c:	1080008c 	andi	r2,r2,2
81108f70:	10000426 	beq	r2,zero,81108f84 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
81108f74:	e0bfff17 	ldw	r2,-4(fp)
81108f78:	00c00044 	movi	r3,1
81108f7c:	10c00215 	stw	r3,8(r2)
81108f80:	00000206 	br	81108f8c <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
81108f84:	e0bfff17 	ldw	r2,-4(fp)
81108f88:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
81108f8c:	e0bffe17 	ldw	r2,-8(fp)
81108f90:	1080004c 	andi	r2,r2,1
81108f94:	10000426 	beq	r2,zero,81108fa8 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81108f98:	e0bfff17 	ldw	r2,-4(fp)
81108f9c:	00c00044 	movi	r3,1
81108fa0:	10c00315 	stw	r3,12(r2)
81108fa4:	00000206 	br	81108fb0 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81108fa8:	e0bfff17 	ldw	r2,-4(fp)
81108fac:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81108fb0:	e0bffe17 	ldw	r2,-8(fp)
81108fb4:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
81108fb8:	1007883a 	mov	r3,r2
81108fbc:	e0bfff17 	ldw	r2,-4(fp)
81108fc0:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
81108fc4:	00800044 	movi	r2,1
81108fc8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108fcc:	e0bffd17 	ldw	r2,-12(fp)
}
81108fd0:	e037883a 	mov	sp,fp
81108fd4:	dfc00117 	ldw	ra,4(sp)
81108fd8:	df000017 	ldw	fp,0(sp)
81108fdc:	dec00204 	addi	sp,sp,8
81108fe0:	f800283a 	ret

81108fe4 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
81108fe4:	defffb04 	addi	sp,sp,-20
81108fe8:	de00012e 	bgeu	sp,et,81108ff0 <bSpwcGetLinkError+0xc>
81108fec:	003b68fa 	trap	3
81108ff0:	dfc00415 	stw	ra,16(sp)
81108ff4:	df000315 	stw	fp,12(sp)
81108ff8:	df000304 	addi	fp,sp,12
81108ffc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109000:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109004:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109008:	e0bfff17 	ldw	r2,-4(fp)
8110900c:	10002c26 	beq	r2,zero,811090c0 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109010:	e0bfff17 	ldw	r2,-4(fp)
81109014:	10800017 	ldw	r2,0(r2)
81109018:	000b883a 	mov	r5,zero
8110901c:	1009883a 	mov	r4,r2
81109020:	11094980 	call	81109498 <uliSpwcReadReg>
81109024:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
81109028:	e0bffe17 	ldw	r2,-8(fp)
8110902c:	1080006c 	andhi	r2,r2,1
81109030:	10000426 	beq	r2,zero,81109044 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
81109034:	e0bfff17 	ldw	r2,-4(fp)
81109038:	00c00044 	movi	r3,1
8110903c:	10c00515 	stw	r3,20(r2)
81109040:	00000206 	br	8110904c <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
81109044:	e0bfff17 	ldw	r2,-4(fp)
81109048:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110904c:	e0bffe17 	ldw	r2,-8(fp)
81109050:	108000ac 	andhi	r2,r2,2
81109054:	10000426 	beq	r2,zero,81109068 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
81109058:	e0bfff17 	ldw	r2,-4(fp)
8110905c:	00c00044 	movi	r3,1
81109060:	10c00615 	stw	r3,24(r2)
81109064:	00000206 	br	81109070 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
81109068:	e0bfff17 	ldw	r2,-4(fp)
8110906c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
81109070:	e0bffe17 	ldw	r2,-8(fp)
81109074:	1080012c 	andhi	r2,r2,4
81109078:	10000426 	beq	r2,zero,8110908c <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110907c:	e0bfff17 	ldw	r2,-4(fp)
81109080:	00c00044 	movi	r3,1
81109084:	10c00715 	stw	r3,28(r2)
81109088:	00000206 	br	81109094 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110908c:	e0bfff17 	ldw	r2,-4(fp)
81109090:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
81109094:	e0bffe17 	ldw	r2,-8(fp)
81109098:	1080022c 	andhi	r2,r2,8
8110909c:	10000426 	beq	r2,zero,811090b0 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
811090a0:	e0bfff17 	ldw	r2,-4(fp)
811090a4:	00c00044 	movi	r3,1
811090a8:	10c00815 	stw	r3,32(r2)
811090ac:	00000206 	br	811090b8 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
811090b0:	e0bfff17 	ldw	r2,-4(fp)
811090b4:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
811090b8:	00800044 	movi	r2,1
811090bc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811090c0:	e0bffd17 	ldw	r2,-12(fp)
}
811090c4:	e037883a 	mov	sp,fp
811090c8:	dfc00117 	ldw	ra,4(sp)
811090cc:	df000017 	ldw	fp,0(sp)
811090d0:	dec00204 	addi	sp,sp,8
811090d4:	f800283a 	ret

811090d8 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
811090d8:	defffb04 	addi	sp,sp,-20
811090dc:	de00012e 	bgeu	sp,et,811090e4 <bSpwcGetLinkStatus+0xc>
811090e0:	003b68fa 	trap	3
811090e4:	dfc00415 	stw	ra,16(sp)
811090e8:	df000315 	stw	fp,12(sp)
811090ec:	df000304 	addi	fp,sp,12
811090f0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811090f4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811090f8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811090fc:	e0bfff17 	ldw	r2,-4(fp)
81109100:	10002326 	beq	r2,zero,81109190 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109104:	e0bfff17 	ldw	r2,-4(fp)
81109108:	10800017 	ldw	r2,0(r2)
8110910c:	000b883a 	mov	r5,zero
81109110:	1009883a 	mov	r4,r2
81109114:	11094980 	call	81109498 <uliSpwcReadReg>
81109118:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110911c:	e0bffe17 	ldw	r2,-8(fp)
81109120:	1081000c 	andi	r2,r2,1024
81109124:	10000426 	beq	r2,zero,81109138 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
81109128:	e0bfff17 	ldw	r2,-4(fp)
8110912c:	00c00044 	movi	r3,1
81109130:	10c00915 	stw	r3,36(r2)
81109134:	00000206 	br	81109140 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
81109138:	e0bfff17 	ldw	r2,-4(fp)
8110913c:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
81109140:	e0bffe17 	ldw	r2,-8(fp)
81109144:	1080800c 	andi	r2,r2,512
81109148:	10000426 	beq	r2,zero,8110915c <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110914c:	e0bfff17 	ldw	r2,-4(fp)
81109150:	00c00044 	movi	r3,1
81109154:	10c00a15 	stw	r3,40(r2)
81109158:	00000206 	br	81109164 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110915c:	e0bfff17 	ldw	r2,-4(fp)
81109160:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
81109164:	e0bffe17 	ldw	r2,-8(fp)
81109168:	1080400c 	andi	r2,r2,256
8110916c:	10000426 	beq	r2,zero,81109180 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81109170:	e0bfff17 	ldw	r2,-4(fp)
81109174:	00c00044 	movi	r3,1
81109178:	10c00b15 	stw	r3,44(r2)
8110917c:	00000206 	br	81109188 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81109180:	e0bfff17 	ldw	r2,-4(fp)
81109184:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
81109188:	00800044 	movi	r2,1
8110918c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109190:	e0bffd17 	ldw	r2,-12(fp)
}
81109194:	e037883a 	mov	sp,fp
81109198:	dfc00117 	ldw	ra,4(sp)
8110919c:	df000017 	ldw	fp,0(sp)
811091a0:	dec00204 	addi	sp,sp,8
811091a4:	f800283a 	ret

811091a8 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
811091a8:	defffb04 	addi	sp,sp,-20
811091ac:	de00012e 	bgeu	sp,et,811091b4 <bSpwcGetTimecode+0xc>
811091b0:	003b68fa 	trap	3
811091b4:	dfc00415 	stw	ra,16(sp)
811091b8:	df000315 	stw	fp,12(sp)
811091bc:	df000304 	addi	fp,sp,12
811091c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811091c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811091c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811091cc:	e0bfff17 	ldw	r2,-4(fp)
811091d0:	10001326 	beq	r2,zero,81109220 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811091d4:	e0bfff17 	ldw	r2,-4(fp)
811091d8:	10800017 	ldw	r2,0(r2)
811091dc:	01400044 	movi	r5,1
811091e0:	1009883a 	mov	r4,r2
811091e4:	11094980 	call	81109498 <uliSpwcReadReg>
811091e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
811091ec:	e0bffe17 	ldw	r2,-8(fp)
811091f0:	1080300c 	andi	r2,r2,192
811091f4:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
811091f8:	1007883a 	mov	r3,r2
811091fc:	e0bfff17 	ldw	r2,-4(fp)
81109200:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
81109204:	e0bffe17 	ldw	r2,-8(fp)
81109208:	10800fcc 	andi	r2,r2,63
8110920c:	1007883a 	mov	r3,r2
81109210:	e0bfff17 	ldw	r2,-4(fp)
81109214:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
81109218:	00800044 	movi	r2,1
8110921c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109220:	e0bffd17 	ldw	r2,-12(fp)
}
81109224:	e037883a 	mov	sp,fp
81109228:	dfc00117 	ldw	ra,4(sp)
8110922c:	df000017 	ldw	fp,0(sp)
81109230:	dec00204 	addi	sp,sp,8
81109234:	f800283a 	ret

81109238 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
81109238:	defffb04 	addi	sp,sp,-20
8110923c:	de00012e 	bgeu	sp,et,81109244 <bSpwcClearTimecode+0xc>
81109240:	003b68fa 	trap	3
81109244:	dfc00415 	stw	ra,16(sp)
81109248:	df000315 	stw	fp,12(sp)
8110924c:	df000304 	addi	fp,sp,12
81109250:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109254:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109258:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110925c:	e0bfff17 	ldw	r2,-4(fp)
81109260:	10001126 	beq	r2,zero,811092a8 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109264:	e0bfff17 	ldw	r2,-4(fp)
81109268:	10800017 	ldw	r2,0(r2)
8110926c:	01400044 	movi	r5,1
81109270:	1009883a 	mov	r4,r2
81109274:	11094980 	call	81109498 <uliSpwcReadReg>
81109278:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110927c:	e0bffe17 	ldw	r2,-8(fp)
81109280:	10804014 	ori	r2,r2,256
81109284:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
81109288:	e0bfff17 	ldw	r2,-4(fp)
8110928c:	10800017 	ldw	r2,0(r2)
81109290:	e1bffe17 	ldw	r6,-8(fp)
81109294:	01400044 	movi	r5,1
81109298:	1009883a 	mov	r4,r2
8110929c:	11094440 	call	81109444 <vSpwcWriteReg>
		bStatus = TRUE;
811092a0:	00800044 	movi	r2,1
811092a4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811092a8:	e0bffd17 	ldw	r2,-12(fp)
}
811092ac:	e037883a 	mov	sp,fp
811092b0:	dfc00117 	ldw	ra,4(sp)
811092b4:	df000017 	ldw	fp,0(sp)
811092b8:	dec00204 	addi	sp,sp,8
811092bc:	f800283a 	ret

811092c0 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
811092c0:	defffb04 	addi	sp,sp,-20
811092c4:	de00012e 	bgeu	sp,et,811092cc <bSpwcInitCh+0xc>
811092c8:	003b68fa 	trap	3
811092cc:	dfc00415 	stw	ra,16(sp)
811092d0:	df000315 	stw	fp,12(sp)
811092d4:	df000304 	addi	fp,sp,12
811092d8:	e13ffe15 	stw	r4,-8(fp)
811092dc:	2805883a 	mov	r2,r5
811092e0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811092e4:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
811092e8:	e0bffe17 	ldw	r2,-8(fp)
811092ec:	10004f26 	beq	r2,zero,8110942c <bSpwcInitCh+0x16c>
		bStatus = TRUE;
811092f0:	00800044 	movi	r2,1
811092f4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811092f8:	e0bfff03 	ldbu	r2,-4(fp)
811092fc:	10c00228 	cmpgeui	r3,r2,8
81109300:	1800361e 	bne	r3,zero,811093dc <bSpwcInitCh+0x11c>
81109304:	100690ba 	slli	r3,r2,2
81109308:	00a04474 	movhi	r2,33041
8110930c:	10a4c704 	addi	r2,r2,-27876
81109310:	1885883a 	add	r2,r3,r2
81109314:	10800017 	ldw	r2,0(r2)
81109318:	1000683a 	jmp	r2
8110931c:	8110933c 	xorhi	r4,r16,16972
81109320:	81109350 	cmplti	r4,r16,16973
81109324:	81109364 	muli	r4,r16,16973
81109328:	81109378 	rdprs	r4,r16,16973
8110932c:	8110938c 	andi	r4,r16,16974
81109330:	811093a0 	cmpeqi	r4,r16,16974
81109334:	811093b4 	orhi	r4,r16,16974
81109338:	811093c8 	cmpgei	r4,r16,16975
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110933c:	e0fffe17 	ldw	r3,-8(fp)
81109340:	00a04834 	movhi	r2,33056
81109344:	108b0004 	addi	r2,r2,11264
81109348:	18800015 	stw	r2,0(r3)
			break;
8110934c:	00002506 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109350:	e0fffe17 	ldw	r3,-8(fp)
81109354:	00a04834 	movhi	r2,33056
81109358:	108a0004 	addi	r2,r2,10240
8110935c:	18800015 	stw	r2,0(r3)
			break;
81109360:	00002006 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109364:	e0fffe17 	ldw	r3,-8(fp)
81109368:	00a04834 	movhi	r2,33056
8110936c:	10890004 	addi	r2,r2,9216
81109370:	18800015 	stw	r2,0(r3)
			break;
81109374:	00001b06 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109378:	e0fffe17 	ldw	r3,-8(fp)
8110937c:	00a04834 	movhi	r2,33056
81109380:	10880004 	addi	r2,r2,8192
81109384:	18800015 	stw	r2,0(r3)
			break;
81109388:	00001606 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110938c:	e0fffe17 	ldw	r3,-8(fp)
81109390:	00a04834 	movhi	r2,33056
81109394:	10870004 	addi	r2,r2,7168
81109398:	18800015 	stw	r2,0(r3)
			break;
8110939c:	00001106 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811093a0:	e0fffe17 	ldw	r3,-8(fp)
811093a4:	00a04834 	movhi	r2,33056
811093a8:	10860004 	addi	r2,r2,6144
811093ac:	18800015 	stw	r2,0(r3)
			break;
811093b0:	00000c06 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811093b4:	e0fffe17 	ldw	r3,-8(fp)
811093b8:	00a04834 	movhi	r2,33056
811093bc:	10850004 	addi	r2,r2,5120
811093c0:	18800015 	stw	r2,0(r3)
			break;
811093c4:	00000706 	br	811093e4 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811093c8:	e0fffe17 	ldw	r3,-8(fp)
811093cc:	00a04834 	movhi	r2,33056
811093d0:	10840004 	addi	r2,r2,4096
811093d4:	18800015 	stw	r2,0(r3)
			break;
811093d8:	00000206 	br	811093e4 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
811093dc:	e03ffd15 	stw	zero,-12(fp)
			break;
811093e0:	0001883a 	nop
		}

		if (bStatus) {
811093e4:	e0bffd17 	ldw	r2,-12(fp)
811093e8:	10001026 	beq	r2,zero,8110942c <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
811093ec:	e13ffe17 	ldw	r4,-8(fp)
811093f0:	1108f000 	call	81108f00 <bSpwcGetLink>
811093f4:	1000011e 	bne	r2,zero,811093fc <bSpwcInitCh+0x13c>
				bStatus = FALSE;
811093f8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
811093fc:	e13ffe17 	ldw	r4,-8(fp)
81109400:	1108fe40 	call	81108fe4 <bSpwcGetLinkError>
81109404:	1000011e 	bne	r2,zero,8110940c <bSpwcInitCh+0x14c>
				bStatus = FALSE;
81109408:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110940c:	e13ffe17 	ldw	r4,-8(fp)
81109410:	11090d80 	call	811090d8 <bSpwcGetLinkStatus>
81109414:	1000011e 	bne	r2,zero,8110941c <bSpwcInitCh+0x15c>
				bStatus = FALSE;
81109418:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110941c:	e13ffe17 	ldw	r4,-8(fp)
81109420:	11091a80 	call	811091a8 <bSpwcGetTimecode>
81109424:	1000011e 	bne	r2,zero,8110942c <bSpwcInitCh+0x16c>
				bStatus = FALSE;
81109428:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110942c:	e0bffd17 	ldw	r2,-12(fp)
}
81109430:	e037883a 	mov	sp,fp
81109434:	dfc00117 	ldw	ra,4(sp)
81109438:	df000017 	ldw	fp,0(sp)
8110943c:	dec00204 	addi	sp,sp,8
81109440:	f800283a 	ret

81109444 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109444:	defffc04 	addi	sp,sp,-16
81109448:	de00012e 	bgeu	sp,et,81109450 <vSpwcWriteReg+0xc>
8110944c:	003b68fa 	trap	3
81109450:	df000315 	stw	fp,12(sp)
81109454:	df000304 	addi	fp,sp,12
81109458:	e13ffd15 	stw	r4,-12(fp)
8110945c:	e17ffe15 	stw	r5,-8(fp)
81109460:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109464:	e0bffe17 	ldw	r2,-8(fp)
81109468:	1085883a 	add	r2,r2,r2
8110946c:	1085883a 	add	r2,r2,r2
81109470:	1007883a 	mov	r3,r2
81109474:	e0bffd17 	ldw	r2,-12(fp)
81109478:	10c5883a 	add	r2,r2,r3
8110947c:	e0ffff17 	ldw	r3,-4(fp)
81109480:	10c00015 	stw	r3,0(r2)
}
81109484:	0001883a 	nop
81109488:	e037883a 	mov	sp,fp
8110948c:	df000017 	ldw	fp,0(sp)
81109490:	dec00104 	addi	sp,sp,4
81109494:	f800283a 	ret

81109498 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109498:	defffc04 	addi	sp,sp,-16
8110949c:	de00012e 	bgeu	sp,et,811094a4 <uliSpwcReadReg+0xc>
811094a0:	003b68fa 	trap	3
811094a4:	df000315 	stw	fp,12(sp)
811094a8:	df000304 	addi	fp,sp,12
811094ac:	e13ffe15 	stw	r4,-8(fp)
811094b0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811094b4:	e0bfff17 	ldw	r2,-4(fp)
811094b8:	1085883a 	add	r2,r2,r2
811094bc:	1085883a 	add	r2,r2,r2
811094c0:	1007883a 	mov	r3,r2
811094c4:	e0bffe17 	ldw	r2,-8(fp)
811094c8:	10c5883a 	add	r2,r2,r3
811094cc:	10800017 	ldw	r2,0(r2)
811094d0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811094d4:	e0bffd17 	ldw	r2,-12(fp)
}
811094d8:	e037883a 	mov	sp,fp
811094dc:	df000017 	ldw	fp,0(sp)
811094e0:	dec00104 	addi	sp,sp,4
811094e4:	f800283a 	ret

811094e8 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
811094e8:	defffe04 	addi	sp,sp,-8
811094ec:	de00012e 	bgeu	sp,et,811094f4 <bEnableIsoDrivers+0xc>
811094f0:	003b68fa 	trap	3
811094f4:	dfc00115 	stw	ra,4(sp)
811094f8:	df000015 	stw	fp,0(sp)
811094fc:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
81109500:	01400204 	movi	r5,8
81109504:	01000044 	movi	r4,1
81109508:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
  return  TRUE;
8110950c:	00800044 	movi	r2,1
}
81109510:	e037883a 	mov	sp,fp
81109514:	dfc00117 	ldw	ra,4(sp)
81109518:	df000017 	ldw	fp,0(sp)
8110951c:	dec00204 	addi	sp,sp,8
81109520:	f800283a 	ret

81109524 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
81109524:	defffe04 	addi	sp,sp,-8
81109528:	de00012e 	bgeu	sp,et,81109530 <bDisableIsoDrivers+0xc>
8110952c:	003b68fa 	trap	3
81109530:	dfc00115 	stw	ra,4(sp)
81109534:	df000015 	stw	fp,0(sp)
81109538:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110953c:	01400204 	movi	r5,8
81109540:	0009883a 	mov	r4,zero
81109544:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
  return  TRUE;
81109548:	00800044 	movi	r2,1
}
8110954c:	e037883a 	mov	sp,fp
81109550:	dfc00117 	ldw	ra,4(sp)
81109554:	df000017 	ldw	fp,0(sp)
81109558:	dec00204 	addi	sp,sp,8
8110955c:	f800283a 	ret

81109560 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
81109560:	defffe04 	addi	sp,sp,-8
81109564:	de00012e 	bgeu	sp,et,8110956c <bEnableLvdsBoard+0xc>
81109568:	003b68fa 	trap	3
8110956c:	dfc00115 	stw	ra,4(sp)
81109570:	df000015 	stw	fp,0(sp)
81109574:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
81109578:	01400104 	movi	r5,4
8110957c:	01000044 	movi	r4,1
81109580:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
  return  TRUE;
81109584:	00800044 	movi	r2,1
}
81109588:	e037883a 	mov	sp,fp
8110958c:	dfc00117 	ldw	ra,4(sp)
81109590:	df000017 	ldw	fp,0(sp)
81109594:	dec00204 	addi	sp,sp,8
81109598:	f800283a 	ret

8110959c <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110959c:	defffe04 	addi	sp,sp,-8
811095a0:	de00012e 	bgeu	sp,et,811095a8 <bDisableLvdsBoard+0xc>
811095a4:	003b68fa 	trap	3
811095a8:	dfc00115 	stw	ra,4(sp)
811095ac:	df000015 	stw	fp,0(sp)
811095b0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
811095b4:	01400104 	movi	r5,4
811095b8:	0009883a 	mov	r4,zero
811095bc:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
  return  TRUE;
811095c0:	00800044 	movi	r2,1
}
811095c4:	e037883a 	mov	sp,fp
811095c8:	dfc00117 	ldw	ra,4(sp)
811095cc:	df000017 	ldw	fp,0(sp)
811095d0:	dec00204 	addi	sp,sp,8
811095d4:	f800283a 	ret

811095d8 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
811095d8:	defffd04 	addi	sp,sp,-12
811095dc:	de00012e 	bgeu	sp,et,811095e4 <bSetPreEmphasys+0xc>
811095e0:	003b68fa 	trap	3
811095e4:	dfc00215 	stw	ra,8(sp)
811095e8:	df000115 	stw	fp,4(sp)
811095ec:	df000104 	addi	fp,sp,4
811095f0:	2005883a 	mov	r2,r4
811095f4:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
811095f8:	e0bfff03 	ldbu	r2,-4(fp)
811095fc:	10c00060 	cmpeqi	r3,r2,1
81109600:	18000d1e 	bne	r3,zero,81109638 <bSetPreEmphasys+0x60>
81109604:	10c00088 	cmpgei	r3,r2,2
81109608:	1800021e 	bne	r3,zero,81109614 <bSetPreEmphasys+0x3c>
8110960c:	10000626 	beq	r2,zero,81109628 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81109610:	00001b06 	br	81109680 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
81109614:	10c000a0 	cmpeqi	r3,r2,2
81109618:	18000e1e 	bne	r3,zero,81109654 <bSetPreEmphasys+0x7c>
8110961c:	108000e0 	cmpeqi	r2,r2,3
81109620:	1000131e 	bne	r2,zero,81109670 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81109624:	00001606 	br	81109680 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81109628:	014000c4 	movi	r5,3
8110962c:	0009883a 	mov	r4,zero
81109630:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
      break;
81109634:	00001206 	br	81109680 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
81109638:	01400084 	movi	r5,2
8110963c:	0009883a 	mov	r4,zero
81109640:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
81109644:	01400044 	movi	r5,1
81109648:	01000044 	movi	r4,1
8110964c:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
      break;
81109650:	00000b06 	br	81109680 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
81109654:	01400044 	movi	r5,1
81109658:	0009883a 	mov	r4,zero
8110965c:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
81109660:	01400084 	movi	r5,2
81109664:	01000044 	movi	r4,1
81109668:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
      break;
8110966c:	00000406 	br	81109680 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81109670:	014000c4 	movi	r5,3
81109674:	01000044 	movi	r4,1
81109678:	11096980 	call	81109698 <bCtrlIoLvdsDrive>
      break;
8110967c:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
81109680:	00800044 	movi	r2,1
}
81109684:	e037883a 	mov	sp,fp
81109688:	dfc00117 	ldw	ra,4(sp)
8110968c:	df000017 	ldw	fp,0(sp)
81109690:	dec00204 	addi	sp,sp,8
81109694:	f800283a 	ret

81109698 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
81109698:	defffd04 	addi	sp,sp,-12
8110969c:	de00012e 	bgeu	sp,et,811096a4 <bCtrlIoLvdsDrive+0xc>
811096a0:	003b68fa 	trap	3
811096a4:	df000215 	stw	fp,8(sp)
811096a8:	df000204 	addi	fp,sp,8
811096ac:	e13ffe15 	stw	r4,-8(fp)
811096b0:	2805883a 	mov	r2,r5
811096b4:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
811096b8:	e0bffe17 	ldw	r2,-8(fp)
811096bc:	1000071e 	bne	r2,zero,811096dc <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
811096c0:	e0bfff03 	ldbu	r2,-4(fp)
811096c4:	0084303a 	nor	r2,zero,r2
811096c8:	1007883a 	mov	r3,r2
811096cc:	d0a00103 	ldbu	r2,-32764(gp)
811096d0:	1884703a 	and	r2,r3,r2
811096d4:	d0a00105 	stb	r2,-32764(gp)
811096d8:	00000406 	br	811096ec <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
811096dc:	d0e00103 	ldbu	r3,-32764(gp)
811096e0:	e0bfff03 	ldbu	r2,-4(fp)
811096e4:	1884b03a 	or	r2,r3,r2
811096e8:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
811096ec:	d0a00103 	ldbu	r2,-32764(gp)
811096f0:	10c03fcc 	andi	r3,r2,255
811096f4:	00a00034 	movhi	r2,32768
811096f8:	10822804 	addi	r2,r2,2208
811096fc:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81109700:	00800044 	movi	r2,1
}
81109704:	e037883a 	mov	sp,fp
81109708:	df000017 	ldw	fp,0(sp)
8110970c:	dec00104 	addi	sp,sp,4
81109710:	f800283a 	ret

81109714 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
81109714:	defffa04 	addi	sp,sp,-24
81109718:	de00012e 	bgeu	sp,et,81109720 <I2C_TestAdress+0xc>
8110971c:	003b68fa 	trap	3
81109720:	dfc00515 	stw	ra,20(sp)
81109724:	df000415 	stw	fp,16(sp)
81109728:	df000404 	addi	fp,sp,16
8110972c:	e13ffd15 	stw	r4,-12(fp)
81109730:	e17ffe15 	stw	r5,-8(fp)
81109734:	3005883a 	mov	r2,r6
81109738:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110973c:	00800044 	movi	r2,1
81109740:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109744:	e17ffe17 	ldw	r5,-8(fp)
81109748:	e13ffd17 	ldw	r4,-12(fp)
8110974c:	1109ae40 	call	81109ae4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109750:	e0bfff03 	ldbu	r2,-4(fp)
81109754:	10803fcc 	andi	r2,r2,255
81109758:	100d883a 	mov	r6,r2
8110975c:	e17ffe17 	ldw	r5,-8(fp)
81109760:	e13ffd17 	ldw	r4,-12(fp)
81109764:	1109bf80 	call	81109bf8 <i2c_write>
81109768:	1000011e 	bne	r2,zero,81109770 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110976c:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109770:	e17ffe17 	ldw	r5,-8(fp)
81109774:	e13ffd17 	ldw	r4,-12(fp)
81109778:	1109b780 	call	81109b78 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110977c:	0106d604 	movi	r4,7000
81109780:	1131c380 	call	81131c38 <usleep>
    
    return bSuccess;
81109784:	e0bffc17 	ldw	r2,-16(fp)

}
81109788:	e037883a 	mov	sp,fp
8110978c:	dfc00117 	ldw	ra,4(sp)
81109790:	df000017 	ldw	fp,0(sp)
81109794:	dec00204 	addi	sp,sp,8
81109798:	f800283a 	ret

8110979c <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110979c:	defff804 	addi	sp,sp,-32
811097a0:	de00012e 	bgeu	sp,et,811097a8 <I2C_Write+0xc>
811097a4:	003b68fa 	trap	3
811097a8:	dfc00715 	stw	ra,28(sp)
811097ac:	df000615 	stw	fp,24(sp)
811097b0:	df000604 	addi	fp,sp,24
811097b4:	e13ffb15 	stw	r4,-20(fp)
811097b8:	e17ffc15 	stw	r5,-16(fp)
811097bc:	3009883a 	mov	r4,r6
811097c0:	3807883a 	mov	r3,r7
811097c4:	e0800217 	ldw	r2,8(fp)
811097c8:	e13ffd05 	stb	r4,-12(fp)
811097cc:	e0fffe05 	stb	r3,-8(fp)
811097d0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
811097d4:	00800044 	movi	r2,1
811097d8:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811097dc:	e17ffc17 	ldw	r5,-16(fp)
811097e0:	e13ffb17 	ldw	r4,-20(fp)
811097e4:	1109ae40 	call	81109ae4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811097e8:	e0bffd03 	ldbu	r2,-12(fp)
811097ec:	10803fcc 	andi	r2,r2,255
811097f0:	100d883a 	mov	r6,r2
811097f4:	e17ffc17 	ldw	r5,-16(fp)
811097f8:	e13ffb17 	ldw	r4,-20(fp)
811097fc:	1109bf80 	call	81109bf8 <i2c_write>
81109800:	1000011e 	bne	r2,zero,81109808 <I2C_Write+0x6c>
        bSuccess = FALSE;
81109804:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109808:	e0bffa17 	ldw	r2,-24(fp)
8110980c:	10000726 	beq	r2,zero,8110982c <I2C_Write+0x90>
81109810:	e0bffe03 	ldbu	r2,-8(fp)
81109814:	100d883a 	mov	r6,r2
81109818:	e17ffc17 	ldw	r5,-16(fp)
8110981c:	e13ffb17 	ldw	r4,-20(fp)
81109820:	1109bf80 	call	81109bf8 <i2c_write>
81109824:	1000011e 	bne	r2,zero,8110982c <I2C_Write+0x90>
        bSuccess = FALSE;
81109828:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110982c:	e0bffa17 	ldw	r2,-24(fp)
81109830:	10000726 	beq	r2,zero,81109850 <I2C_Write+0xb4>
81109834:	e0bfff03 	ldbu	r2,-4(fp)
81109838:	100d883a 	mov	r6,r2
8110983c:	e17ffc17 	ldw	r5,-16(fp)
81109840:	e13ffb17 	ldw	r4,-20(fp)
81109844:	1109bf80 	call	81109bf8 <i2c_write>
81109848:	1000011e 	bne	r2,zero,81109850 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110984c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109850:	e17ffc17 	ldw	r5,-16(fp)
81109854:	e13ffb17 	ldw	r4,-20(fp)
81109858:	1109b780 	call	81109b78 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110985c:	0106d604 	movi	r4,7000
81109860:	1131c380 	call	81131c38 <usleep>
    
    return bSuccess;
81109864:	e0bffa17 	ldw	r2,-24(fp)

}
81109868:	e037883a 	mov	sp,fp
8110986c:	dfc00117 	ldw	ra,4(sp)
81109870:	df000017 	ldw	fp,0(sp)
81109874:	dec00204 	addi	sp,sp,8
81109878:	f800283a 	ret

8110987c <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110987c:	defff904 	addi	sp,sp,-28
81109880:	de00012e 	bgeu	sp,et,81109888 <I2C_Read+0xc>
81109884:	003b68fa 	trap	3
81109888:	dfc00615 	stw	ra,24(sp)
8110988c:	df000515 	stw	fp,20(sp)
81109890:	df000504 	addi	fp,sp,20
81109894:	e13ffc15 	stw	r4,-16(fp)
81109898:	e17ffd15 	stw	r5,-12(fp)
8110989c:	3007883a 	mov	r3,r6
811098a0:	3805883a 	mov	r2,r7
811098a4:	e0fffe05 	stb	r3,-8(fp)
811098a8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
811098ac:	00800044 	movi	r2,1
811098b0:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811098b4:	e17ffd17 	ldw	r5,-12(fp)
811098b8:	e13ffc17 	ldw	r4,-16(fp)
811098bc:	1109ae40 	call	81109ae4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811098c0:	e0bffe03 	ldbu	r2,-8(fp)
811098c4:	10803fcc 	andi	r2,r2,255
811098c8:	100d883a 	mov	r6,r2
811098cc:	e17ffd17 	ldw	r5,-12(fp)
811098d0:	e13ffc17 	ldw	r4,-16(fp)
811098d4:	1109bf80 	call	81109bf8 <i2c_write>
811098d8:	1000011e 	bne	r2,zero,811098e0 <I2C_Read+0x64>
        bSuccess = FALSE;
811098dc:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
811098e0:	e0bffb17 	ldw	r2,-20(fp)
811098e4:	10000726 	beq	r2,zero,81109904 <I2C_Read+0x88>
811098e8:	e0bfff03 	ldbu	r2,-4(fp)
811098ec:	100d883a 	mov	r6,r2
811098f0:	e17ffd17 	ldw	r5,-12(fp)
811098f4:	e13ffc17 	ldw	r4,-16(fp)
811098f8:	1109bf80 	call	81109bf8 <i2c_write>
811098fc:	1000011e 	bne	r2,zero,81109904 <I2C_Read+0x88>
        bSuccess = FALSE;
81109900:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81109904:	e17ffd17 	ldw	r5,-12(fp)
81109908:	e13ffc17 	ldw	r4,-16(fp)
8110990c:	1109ae40 	call	81109ae4 <i2c_start>
    DeviceAddr |= 1; // Read
81109910:	e0bffe03 	ldbu	r2,-8(fp)
81109914:	10800054 	ori	r2,r2,1
81109918:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110991c:	e0bffb17 	ldw	r2,-20(fp)
81109920:	10000826 	beq	r2,zero,81109944 <I2C_Read+0xc8>
81109924:	e0bffe03 	ldbu	r2,-8(fp)
81109928:	10803fcc 	andi	r2,r2,255
8110992c:	100d883a 	mov	r6,r2
81109930:	e17ffd17 	ldw	r5,-12(fp)
81109934:	e13ffc17 	ldw	r4,-16(fp)
81109938:	1109bf80 	call	81109bf8 <i2c_write>
8110993c:	1000011e 	bne	r2,zero,81109944 <I2C_Read+0xc8>
        bSuccess = FALSE;
81109940:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109944:	e0bffb17 	ldw	r2,-20(fp)
81109948:	10000526 	beq	r2,zero,81109960 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110994c:	000f883a 	mov	r7,zero
81109950:	e1800217 	ldw	r6,8(fp)
81109954:	e17ffd17 	ldw	r5,-12(fp)
81109958:	e13ffc17 	ldw	r4,-16(fp)
8110995c:	1109d300 	call	81109d30 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81109960:	e17ffd17 	ldw	r5,-12(fp)
81109964:	e13ffc17 	ldw	r4,-16(fp)
81109968:	1109b780 	call	81109b78 <i2c_stop>
    
    return bSuccess;
8110996c:	e0bffb17 	ldw	r2,-20(fp)
}
81109970:	e037883a 	mov	sp,fp
81109974:	dfc00117 	ldw	ra,4(sp)
81109978:	df000017 	ldw	fp,0(sp)
8110997c:	dec00204 	addi	sp,sp,8
81109980:	f800283a 	ret

81109984 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81109984:	defff604 	addi	sp,sp,-40
81109988:	de00012e 	bgeu	sp,et,81109990 <I2C_MultipleRead+0xc>
8110998c:	003b68fa 	trap	3
81109990:	dfc00915 	stw	ra,36(sp)
81109994:	df000815 	stw	fp,32(sp)
81109998:	df000804 	addi	fp,sp,32
8110999c:	e13ffb15 	stw	r4,-20(fp)
811099a0:	e17ffc15 	stw	r5,-16(fp)
811099a4:	3007883a 	mov	r3,r6
811099a8:	e1fffe15 	stw	r7,-8(fp)
811099ac:	e0800217 	ldw	r2,8(fp)
811099b0:	e0fffd05 	stb	r3,-12(fp)
811099b4:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
811099b8:	00800044 	movi	r2,1
811099bc:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
811099c0:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
811099c4:	e17ffc17 	ldw	r5,-16(fp)
811099c8:	e13ffb17 	ldw	r4,-20(fp)
811099cc:	1109ae40 	call	81109ae4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
811099d0:	e0bffd03 	ldbu	r2,-12(fp)
811099d4:	10803fcc 	andi	r2,r2,255
811099d8:	100d883a 	mov	r6,r2
811099dc:	e17ffc17 	ldw	r5,-16(fp)
811099e0:	e13ffb17 	ldw	r4,-20(fp)
811099e4:	1109bf80 	call	81109bf8 <i2c_write>
811099e8:	1000011e 	bne	r2,zero,811099f0 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
811099ec:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
811099f0:	e0bff917 	ldw	r2,-28(fp)
811099f4:	10000726 	beq	r2,zero,81109a14 <I2C_MultipleRead+0x90>
811099f8:	e0bffa03 	ldbu	r2,-24(fp)
811099fc:	100d883a 	mov	r6,r2
81109a00:	e17ffc17 	ldw	r5,-16(fp)
81109a04:	e13ffb17 	ldw	r4,-20(fp)
81109a08:	1109bf80 	call	81109bf8 <i2c_write>
81109a0c:	1000011e 	bne	r2,zero,81109a14 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81109a10:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81109a14:	e0bff917 	ldw	r2,-28(fp)
81109a18:	10000326 	beq	r2,zero,81109a28 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81109a1c:	e17ffc17 	ldw	r5,-16(fp)
81109a20:	e13ffb17 	ldw	r4,-20(fp)
81109a24:	1109ae40 	call	81109ae4 <i2c_start>
    DeviceAddr |= 1; // Read
81109a28:	e0bffd03 	ldbu	r2,-12(fp)
81109a2c:	10800054 	ori	r2,r2,1
81109a30:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109a34:	e0bff917 	ldw	r2,-28(fp)
81109a38:	10000826 	beq	r2,zero,81109a5c <I2C_MultipleRead+0xd8>
81109a3c:	e0bffd03 	ldbu	r2,-12(fp)
81109a40:	10803fcc 	andi	r2,r2,255
81109a44:	100d883a 	mov	r6,r2
81109a48:	e17ffc17 	ldw	r5,-16(fp)
81109a4c:	e13ffb17 	ldw	r4,-20(fp)
81109a50:	1109bf80 	call	81109bf8 <i2c_write>
81109a54:	1000011e 	bne	r2,zero,81109a5c <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81109a58:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109a5c:	e0bff917 	ldw	r2,-28(fp)
81109a60:	10001726 	beq	r2,zero,81109ac0 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81109a64:	e03ff815 	stw	zero,-32(fp)
81109a68:	00001006 	br	81109aac <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81109a6c:	e0bff817 	ldw	r2,-32(fp)
81109a70:	e0fffe17 	ldw	r3,-8(fp)
81109a74:	1889883a 	add	r4,r3,r2
81109a78:	e0bfff0b 	ldhu	r2,-4(fp)
81109a7c:	10ffffc4 	addi	r3,r2,-1
81109a80:	e0bff817 	ldw	r2,-32(fp)
81109a84:	1884c03a 	cmpne	r2,r3,r2
81109a88:	10803fcc 	andi	r2,r2,255
81109a8c:	100f883a 	mov	r7,r2
81109a90:	200d883a 	mov	r6,r4
81109a94:	e17ffc17 	ldw	r5,-16(fp)
81109a98:	e13ffb17 	ldw	r4,-20(fp)
81109a9c:	1109d300 	call	81109d30 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81109aa0:	e0bff817 	ldw	r2,-32(fp)
81109aa4:	10800044 	addi	r2,r2,1
81109aa8:	e0bff815 	stw	r2,-32(fp)
81109aac:	e0bfff0b 	ldhu	r2,-4(fp)
81109ab0:	e0fff817 	ldw	r3,-32(fp)
81109ab4:	1880020e 	bge	r3,r2,81109ac0 <I2C_MultipleRead+0x13c>
81109ab8:	e0bff917 	ldw	r2,-28(fp)
81109abc:	103feb1e 	bne	r2,zero,81109a6c <__reset+0xfb0e9a6c>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81109ac0:	e17ffc17 	ldw	r5,-16(fp)
81109ac4:	e13ffb17 	ldw	r4,-20(fp)
81109ac8:	1109b780 	call	81109b78 <i2c_stop>
    
    return bSuccess;    
81109acc:	e0bff917 	ldw	r2,-28(fp)
    
}
81109ad0:	e037883a 	mov	sp,fp
81109ad4:	dfc00117 	ldw	ra,4(sp)
81109ad8:	df000017 	ldw	fp,0(sp)
81109adc:	dec00204 	addi	sp,sp,8
81109ae0:	f800283a 	ret

81109ae4 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81109ae4:	defffc04 	addi	sp,sp,-16
81109ae8:	de00012e 	bgeu	sp,et,81109af0 <i2c_start+0xc>
81109aec:	003b68fa 	trap	3
81109af0:	dfc00315 	stw	ra,12(sp)
81109af4:	df000215 	stw	fp,8(sp)
81109af8:	df000204 	addi	fp,sp,8
81109afc:	e13ffe15 	stw	r4,-8(fp)
81109b00:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81109b04:	e0bfff17 	ldw	r2,-4(fp)
81109b08:	10800104 	addi	r2,r2,4
81109b0c:	1007883a 	mov	r3,r2
81109b10:	00800044 	movi	r2,1
81109b14:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81109b18:	e0bfff17 	ldw	r2,-4(fp)
81109b1c:	00c00044 	movi	r3,1
81109b20:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81109b24:	e0bffe17 	ldw	r2,-8(fp)
81109b28:	00c00044 	movi	r3,1
81109b2c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109b30:	01000044 	movi	r4,1
81109b34:	1131c380 	call	81131c38 <usleep>
     
    SDA_LOW(data_base); // data low
81109b38:	e0bfff17 	ldw	r2,-4(fp)
81109b3c:	0007883a 	mov	r3,zero
81109b40:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81109b44:	01000044 	movi	r4,1
81109b48:	1131c380 	call	81131c38 <usleep>
    SCL_LOW(clk_base); // clock low
81109b4c:	e0bffe17 	ldw	r2,-8(fp)
81109b50:	0007883a 	mov	r3,zero
81109b54:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109b58:	01000044 	movi	r4,1
81109b5c:	1131c380 	call	81131c38 <usleep>
}
81109b60:	0001883a 	nop
81109b64:	e037883a 	mov	sp,fp
81109b68:	dfc00117 	ldw	ra,4(sp)
81109b6c:	df000017 	ldw	fp,0(sp)
81109b70:	dec00204 	addi	sp,sp,8
81109b74:	f800283a 	ret

81109b78 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81109b78:	defffc04 	addi	sp,sp,-16
81109b7c:	de00012e 	bgeu	sp,et,81109b84 <i2c_stop+0xc>
81109b80:	003b68fa 	trap	3
81109b84:	dfc00315 	stw	ra,12(sp)
81109b88:	df000215 	stw	fp,8(sp)
81109b8c:	df000204 	addi	fp,sp,8
81109b90:	e13ffe15 	stw	r4,-8(fp)
81109b94:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81109b98:	e0bfff17 	ldw	r2,-4(fp)
81109b9c:	10800104 	addi	r2,r2,4
81109ba0:	1007883a 	mov	r3,r2
81109ba4:	00800044 	movi	r2,1
81109ba8:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81109bac:	e0bfff17 	ldw	r2,-4(fp)
81109bb0:	0007883a 	mov	r3,zero
81109bb4:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81109bb8:	e0bffe17 	ldw	r2,-8(fp)
81109bbc:	00c00044 	movi	r3,1
81109bc0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81109bc4:	01000044 	movi	r4,1
81109bc8:	1131c380 	call	81131c38 <usleep>
    SDA_HIGH(data_base); // data high
81109bcc:	e0bfff17 	ldw	r2,-4(fp)
81109bd0:	00c00044 	movi	r3,1
81109bd4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81109bd8:	01000044 	movi	r4,1
81109bdc:	1131c380 	call	81131c38 <usleep>
    

    
}
81109be0:	0001883a 	nop
81109be4:	e037883a 	mov	sp,fp
81109be8:	dfc00117 	ldw	ra,4(sp)
81109bec:	df000017 	ldw	fp,0(sp)
81109bf0:	dec00204 	addi	sp,sp,8
81109bf4:	f800283a 	ret

81109bf8 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81109bf8:	defff804 	addi	sp,sp,-32
81109bfc:	de00012e 	bgeu	sp,et,81109c04 <i2c_write+0xc>
81109c00:	003b68fa 	trap	3
81109c04:	dfc00715 	stw	ra,28(sp)
81109c08:	df000615 	stw	fp,24(sp)
81109c0c:	df000604 	addi	fp,sp,24
81109c10:	e13ffd15 	stw	r4,-12(fp)
81109c14:	e17ffe15 	stw	r5,-8(fp)
81109c18:	3005883a 	mov	r2,r6
81109c1c:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81109c20:	00bfe004 	movi	r2,-128
81109c24:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81109c28:	e0bffe17 	ldw	r2,-8(fp)
81109c2c:	10800104 	addi	r2,r2,4
81109c30:	1007883a 	mov	r3,r2
81109c34:	00800044 	movi	r2,1
81109c38:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
81109c3c:	e03ffb15 	stw	zero,-20(fp)
81109c40:	00001f06 	br	81109cc0 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
81109c44:	e0bffd17 	ldw	r2,-12(fp)
81109c48:	0007883a 	mov	r3,zero
81109c4c:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
81109c50:	e0ffff03 	ldbu	r3,-4(fp)
81109c54:	e0bffa03 	ldbu	r2,-24(fp)
81109c58:	1884703a 	and	r2,r3,r2
81109c5c:	10803fcc 	andi	r2,r2,255
81109c60:	10000426 	beq	r2,zero,81109c74 <i2c_write+0x7c>
            SDA_HIGH(data_base);
81109c64:	e0bffe17 	ldw	r2,-8(fp)
81109c68:	00c00044 	movi	r3,1
81109c6c:	10c00035 	stwio	r3,0(r2)
81109c70:	00000306 	br	81109c80 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
81109c74:	e0bffe17 	ldw	r2,-8(fp)
81109c78:	0007883a 	mov	r3,zero
81109c7c:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81109c80:	e0bffa03 	ldbu	r2,-24(fp)
81109c84:	1004d07a 	srli	r2,r2,1
81109c88:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81109c8c:	e0bffd17 	ldw	r2,-12(fp)
81109c90:	00c00044 	movi	r3,1
81109c94:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109c98:	01000044 	movi	r4,1
81109c9c:	1131c380 	call	81131c38 <usleep>
        SCL_LOW(clk_base);
81109ca0:	e0bffd17 	ldw	r2,-12(fp)
81109ca4:	0007883a 	mov	r3,zero
81109ca8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109cac:	01000044 	movi	r4,1
81109cb0:	1131c380 	call	81131c38 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
81109cb4:	e0bffb17 	ldw	r2,-20(fp)
81109cb8:	10800044 	addi	r2,r2,1
81109cbc:	e0bffb15 	stw	r2,-20(fp)
81109cc0:	e0bffb17 	ldw	r2,-20(fp)
81109cc4:	10800210 	cmplti	r2,r2,8
81109cc8:	103fde1e 	bne	r2,zero,81109c44 <__reset+0xfb0e9c44>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81109ccc:	e0bffe17 	ldw	r2,-8(fp)
81109cd0:	10800104 	addi	r2,r2,4
81109cd4:	0007883a 	mov	r3,zero
81109cd8:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81109cdc:	e0bffd17 	ldw	r2,-12(fp)
81109ce0:	00c00044 	movi	r3,1
81109ce4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81109ce8:	01000044 	movi	r4,1
81109cec:	1131c380 	call	81131c38 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81109cf0:	e0bffe17 	ldw	r2,-8(fp)
81109cf4:	10800037 	ldwio	r2,0(r2)
81109cf8:	1005003a 	cmpeq	r2,r2,zero
81109cfc:	10803fcc 	andi	r2,r2,255
81109d00:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
81109d04:	e0bffd17 	ldw	r2,-12(fp)
81109d08:	0007883a 	mov	r3,zero
81109d0c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109d10:	01000044 	movi	r4,1
81109d14:	1131c380 	call	81131c38 <usleep>
    return bAck;
81109d18:	e0bffc17 	ldw	r2,-16(fp)
}    
81109d1c:	e037883a 	mov	sp,fp
81109d20:	dfc00117 	ldw	ra,4(sp)
81109d24:	df000017 	ldw	fp,0(sp)
81109d28:	dec00204 	addi	sp,sp,8
81109d2c:	f800283a 	ret

81109d30 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
81109d30:	defff804 	addi	sp,sp,-32
81109d34:	de00012e 	bgeu	sp,et,81109d3c <i2c_read+0xc>
81109d38:	003b68fa 	trap	3
81109d3c:	dfc00715 	stw	ra,28(sp)
81109d40:	df000615 	stw	fp,24(sp)
81109d44:	df000604 	addi	fp,sp,24
81109d48:	e13ffc15 	stw	r4,-16(fp)
81109d4c:	e17ffd15 	stw	r5,-12(fp)
81109d50:	e1bffe15 	stw	r6,-8(fp)
81109d54:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
81109d58:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
81109d5c:	e0bffd17 	ldw	r2,-12(fp)
81109d60:	10800104 	addi	r2,r2,4
81109d64:	0007883a 	mov	r3,zero
81109d68:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81109d6c:	e0bffc17 	ldw	r2,-16(fp)
81109d70:	0007883a 	mov	r3,zero
81109d74:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109d78:	01000044 	movi	r4,1
81109d7c:	1131c380 	call	81131c38 <usleep>

    for(i=0;i<8;i++){
81109d80:	e03ffb15 	stw	zero,-20(fp)
81109d84:	00001606 	br	81109de0 <i2c_read+0xb0>
        Data <<= 1;
81109d88:	e0bffa03 	ldbu	r2,-24(fp)
81109d8c:	1085883a 	add	r2,r2,r2
81109d90:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
81109d94:	e0bffc17 	ldw	r2,-16(fp)
81109d98:	00c00044 	movi	r3,1
81109d9c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109da0:	01000044 	movi	r4,1
81109da4:	1131c380 	call	81131c38 <usleep>
        if (SDA_READ(data_base))  // read data   
81109da8:	e0bffd17 	ldw	r2,-12(fp)
81109dac:	10800037 	ldwio	r2,0(r2)
81109db0:	10000326 	beq	r2,zero,81109dc0 <i2c_read+0x90>
            Data |= 0x01;
81109db4:	e0bffa03 	ldbu	r2,-24(fp)
81109db8:	10800054 	ori	r2,r2,1
81109dbc:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81109dc0:	e0bffc17 	ldw	r2,-16(fp)
81109dc4:	0007883a 	mov	r3,zero
81109dc8:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109dcc:	01000044 	movi	r4,1
81109dd0:	1131c380 	call	81131c38 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
81109dd4:	e0bffb17 	ldw	r2,-20(fp)
81109dd8:	10800044 	addi	r2,r2,1
81109ddc:	e0bffb15 	stw	r2,-20(fp)
81109de0:	e0bffb17 	ldw	r2,-20(fp)
81109de4:	10800210 	cmplti	r2,r2,8
81109de8:	103fe71e 	bne	r2,zero,81109d88 <__reset+0xfb0e9d88>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
81109dec:	e0bffc17 	ldw	r2,-16(fp)
81109df0:	0007883a 	mov	r3,zero
81109df4:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
81109df8:	e0bffd17 	ldw	r2,-12(fp)
81109dfc:	10800104 	addi	r2,r2,4
81109e00:	1007883a 	mov	r3,r2
81109e04:	00800044 	movi	r2,1
81109e08:	18800035 	stwio	r2,0(r3)
    if (bAck)
81109e0c:	e0bfff17 	ldw	r2,-4(fp)
81109e10:	10000426 	beq	r2,zero,81109e24 <i2c_read+0xf4>
        SDA_LOW(data_base);
81109e14:	e0bffd17 	ldw	r2,-12(fp)
81109e18:	0007883a 	mov	r3,zero
81109e1c:	10c00035 	stwio	r3,0(r2)
81109e20:	00000306 	br	81109e30 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
81109e24:	e0bffd17 	ldw	r2,-12(fp)
81109e28:	00c00044 	movi	r3,1
81109e2c:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
81109e30:	e0bffc17 	ldw	r2,-16(fp)
81109e34:	00c00044 	movi	r3,1
81109e38:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
81109e3c:	01000044 	movi	r4,1
81109e40:	1131c380 	call	81131c38 <usleep>
    SCL_LOW(clk_base); // clock low
81109e44:	e0bffc17 	ldw	r2,-16(fp)
81109e48:	0007883a 	mov	r3,zero
81109e4c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109e50:	01000044 	movi	r4,1
81109e54:	1131c380 	call	81131c38 <usleep>
    SDA_LOW(data_base);  // data low
81109e58:	e0bffd17 	ldw	r2,-12(fp)
81109e5c:	0007883a 	mov	r3,zero
81109e60:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
81109e64:	01000044 	movi	r4,1
81109e68:	1131c380 	call	81131c38 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
81109e6c:	e0bffe17 	ldw	r2,-8(fp)
81109e70:	e0fffa03 	ldbu	r3,-24(fp)
81109e74:	10c00005 	stb	r3,0(r2)
}
81109e78:	0001883a 	nop
81109e7c:	e037883a 	mov	sp,fp
81109e80:	dfc00117 	ldw	ra,4(sp)
81109e84:	df000017 	ldw	fp,0(sp)
81109e88:	dec00204 	addi	sp,sp,8
81109e8c:	f800283a 	ret

81109e90 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
81109e90:	defffd04 	addi	sp,sp,-12
81109e94:	de00012e 	bgeu	sp,et,81109e9c <bSetBoardLeds+0xc>
81109e98:	003b68fa 	trap	3
81109e9c:	df000215 	stw	fp,8(sp)
81109ea0:	df000204 	addi	fp,sp,8
81109ea4:	e13ffe15 	stw	r4,-8(fp)
81109ea8:	2805883a 	mov	r2,r5
81109eac:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
81109eb0:	e0bffe17 	ldw	r2,-8(fp)
81109eb4:	10800058 	cmpnei	r2,r2,1
81109eb8:	1000071e 	bne	r2,zero,81109ed8 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
81109ebc:	e0bfff03 	ldbu	r2,-4(fp)
81109ec0:	0084303a 	nor	r2,zero,r2
81109ec4:	1007883a 	mov	r3,r2
81109ec8:	d0a04e03 	ldbu	r2,-32456(gp)
81109ecc:	1884703a 	and	r2,r3,r2
81109ed0:	d0a04e05 	stb	r2,-32456(gp)
81109ed4:	00000406 	br	81109ee8 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
81109ed8:	d0e04e03 	ldbu	r3,-32456(gp)
81109edc:	e0bfff03 	ldbu	r2,-4(fp)
81109ee0:	1884b03a 	or	r2,r3,r2
81109ee4:	d0a04e05 	stb	r2,-32456(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
81109ee8:	d0a04e03 	ldbu	r2,-32456(gp)
81109eec:	10c03fcc 	andi	r3,r2,255
81109ef0:	00a00034 	movhi	r2,32768
81109ef4:	10827404 	addi	r2,r2,2512
81109ef8:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81109efc:	00800044 	movi	r2,1
}
81109f00:	e037883a 	mov	sp,fp
81109f04:	df000017 	ldw	fp,0(sp)
81109f08:	dec00104 	addi	sp,sp,4
81109f0c:	f800283a 	ret

81109f10 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
81109f10:	defffd04 	addi	sp,sp,-12
81109f14:	de00012e 	bgeu	sp,et,81109f1c <bSetPainelLeds+0xc>
81109f18:	003b68fa 	trap	3
81109f1c:	df000215 	stw	fp,8(sp)
81109f20:	df000204 	addi	fp,sp,8
81109f24:	e13ffe15 	stw	r4,-8(fp)
81109f28:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
81109f2c:	e0bffe17 	ldw	r2,-8(fp)
81109f30:	10800058 	cmpnei	r2,r2,1
81109f34:	1000051e 	bne	r2,zero,81109f4c <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
81109f38:	d0e00217 	ldw	r3,-32760(gp)
81109f3c:	e0bfff17 	ldw	r2,-4(fp)
81109f40:	1884b03a 	or	r2,r3,r2
81109f44:	d0a00215 	stw	r2,-32760(gp)
81109f48:	00000506 	br	81109f60 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
81109f4c:	e0bfff17 	ldw	r2,-4(fp)
81109f50:	0086303a 	nor	r3,zero,r2
81109f54:	d0a00217 	ldw	r2,-32760(gp)
81109f58:	1884703a 	and	r2,r3,r2
81109f5c:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
81109f60:	d0a00217 	ldw	r2,-32760(gp)
81109f64:	1007883a 	mov	r3,r2
81109f68:	00a00034 	movhi	r2,32768
81109f6c:	10824004 	addi	r2,r2,2304
81109f70:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81109f74:	00800044 	movi	r2,1
}
81109f78:	e037883a 	mov	sp,fp
81109f7c:	df000017 	ldw	fp,0(sp)
81109f80:	dec00104 	addi	sp,sp,4
81109f84:	f800283a 	ret

81109f88 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
81109f88:	defffc04 	addi	sp,sp,-16
81109f8c:	de00012e 	bgeu	sp,et,81109f94 <msgdma_write_extended_descriptor+0xc>
81109f90:	003b68fa 	trap	3
81109f94:	df000315 	stw	fp,12(sp)
81109f98:	df000304 	addi	fp,sp,12
81109f9c:	e13ffd15 	stw	r4,-12(fp)
81109fa0:	e17ffe15 	stw	r5,-8(fp)
81109fa4:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
81109fa8:	e0bffd17 	ldw	r2,-12(fp)
81109fac:	10800037 	ldwio	r2,0(r2)
81109fb0:	1080010c 	andi	r2,r2,4
81109fb4:	10000226 	beq	r2,zero,81109fc0 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
81109fb8:	00bff904 	movi	r2,-28
81109fbc:	00003d06 	br	8110a0b4 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
81109fc0:	e0bfff17 	ldw	r2,-4(fp)
81109fc4:	10800017 	ldw	r2,0(r2)
81109fc8:	1007883a 	mov	r3,r2
81109fcc:	e0bffe17 	ldw	r2,-8(fp)
81109fd0:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
81109fd4:	e0bffe17 	ldw	r2,-8(fp)
81109fd8:	10800104 	addi	r2,r2,4
81109fdc:	e0ffff17 	ldw	r3,-4(fp)
81109fe0:	18c00117 	ldw	r3,4(r3)
81109fe4:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
81109fe8:	e0bffe17 	ldw	r2,-8(fp)
81109fec:	10800204 	addi	r2,r2,8
81109ff0:	e0ffff17 	ldw	r3,-4(fp)
81109ff4:	18c00217 	ldw	r3,8(r3)
81109ff8:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
81109ffc:	e0bffe17 	ldw	r2,-8(fp)
8110a000:	10800304 	addi	r2,r2,12
8110a004:	e0ffff17 	ldw	r3,-4(fp)
8110a008:	18c0030b 	ldhu	r3,12(r3)
8110a00c:	18ffffcc 	andi	r3,r3,65535
8110a010:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110a014:	e0bffe17 	ldw	r2,-8(fp)
8110a018:	10800384 	addi	r2,r2,14
8110a01c:	e0ffff17 	ldw	r3,-4(fp)
8110a020:	18c00383 	ldbu	r3,14(r3)
8110a024:	18c03fcc 	andi	r3,r3,255
8110a028:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110a02c:	e0bffe17 	ldw	r2,-8(fp)
8110a030:	108003c4 	addi	r2,r2,15
8110a034:	e0ffff17 	ldw	r3,-4(fp)
8110a038:	18c003c3 	ldbu	r3,15(r3)
8110a03c:	18c03fcc 	andi	r3,r3,255
8110a040:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110a044:	e0bffe17 	ldw	r2,-8(fp)
8110a048:	10800404 	addi	r2,r2,16
8110a04c:	e0ffff17 	ldw	r3,-4(fp)
8110a050:	18c0040b 	ldhu	r3,16(r3)
8110a054:	18ffffcc 	andi	r3,r3,65535
8110a058:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110a05c:	e0bffe17 	ldw	r2,-8(fp)
8110a060:	10800484 	addi	r2,r2,18
8110a064:	e0ffff17 	ldw	r3,-4(fp)
8110a068:	18c0048b 	ldhu	r3,18(r3)
8110a06c:	18ffffcc 	andi	r3,r3,65535
8110a070:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110a074:	e0bffe17 	ldw	r2,-8(fp)
8110a078:	10800504 	addi	r2,r2,20
8110a07c:	e0ffff17 	ldw	r3,-4(fp)
8110a080:	18c00517 	ldw	r3,20(r3)
8110a084:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110a088:	e0bffe17 	ldw	r2,-8(fp)
8110a08c:	10800604 	addi	r2,r2,24
8110a090:	e0ffff17 	ldw	r3,-4(fp)
8110a094:	18c00617 	ldw	r3,24(r3)
8110a098:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110a09c:	e0bffe17 	ldw	r2,-8(fp)
8110a0a0:	10800704 	addi	r2,r2,28
8110a0a4:	e0ffff17 	ldw	r3,-4(fp)
8110a0a8:	18c00717 	ldw	r3,28(r3)
8110a0ac:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110a0b0:	0005883a 	mov	r2,zero
}
8110a0b4:	e037883a 	mov	sp,fp
8110a0b8:	df000017 	ldw	fp,0(sp)
8110a0bc:	dec00104 	addi	sp,sp,4
8110a0c0:	f800283a 	ret

8110a0c4 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110a0c4:	defff604 	addi	sp,sp,-40
8110a0c8:	de00012e 	bgeu	sp,et,8110a0d0 <msgdma_construct_extended_descriptor+0xc>
8110a0cc:	003b68fa 	trap	3
8110a0d0:	df000915 	stw	fp,36(sp)
8110a0d4:	df000904 	addi	fp,sp,36
8110a0d8:	e13ff715 	stw	r4,-36(fp)
8110a0dc:	e17ff815 	stw	r5,-32(fp)
8110a0e0:	e1bff915 	stw	r6,-28(fp)
8110a0e4:	e1fffa15 	stw	r7,-24(fp)
8110a0e8:	e1800517 	ldw	r6,20(fp)
8110a0ec:	e1400617 	ldw	r5,24(fp)
8110a0f0:	e1000717 	ldw	r4,28(fp)
8110a0f4:	e0c00817 	ldw	r3,32(fp)
8110a0f8:	e0800917 	ldw	r2,36(fp)
8110a0fc:	e1bffb0d 	sth	r6,-20(fp)
8110a100:	e17ffc05 	stb	r5,-16(fp)
8110a104:	e13ffd05 	stb	r4,-12(fp)
8110a108:	e0fffe0d 	sth	r3,-8(fp)
8110a10c:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110a110:	e0bff717 	ldw	r2,-36(fp)
8110a114:	10c01217 	ldw	r3,72(r2)
8110a118:	e0800117 	ldw	r2,4(fp)
8110a11c:	18801936 	bltu	r3,r2,8110a184 <msgdma_construct_extended_descriptor+0xc0>
8110a120:	e13ff717 	ldw	r4,-36(fp)
8110a124:	20801317 	ldw	r2,76(r4)
8110a128:	20c01417 	ldw	r3,80(r4)
8110a12c:	e13ffe0b 	ldhu	r4,-8(fp)
8110a130:	213fffcc 	andi	r4,r4,65535
8110a134:	2015883a 	mov	r10,r4
8110a138:	0017883a 	mov	r11,zero
8110a13c:	1ac01136 	bltu	r3,r11,8110a184 <msgdma_construct_extended_descriptor+0xc0>
8110a140:	58c0011e 	bne	r11,r3,8110a148 <msgdma_construct_extended_descriptor+0x84>
8110a144:	12800f36 	bltu	r2,r10,8110a184 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110a148:	e13ff717 	ldw	r4,-36(fp)
8110a14c:	20801317 	ldw	r2,76(r4)
8110a150:	20c01417 	ldw	r3,80(r4)
8110a154:	e13fff0b 	ldhu	r4,-4(fp)
8110a158:	213fffcc 	andi	r4,r4,65535
8110a15c:	2011883a 	mov	r8,r4
8110a160:	0013883a 	mov	r9,zero
8110a164:	1a400736 	bltu	r3,r9,8110a184 <msgdma_construct_extended_descriptor+0xc0>
8110a168:	48c0011e 	bne	r9,r3,8110a170 <msgdma_construct_extended_descriptor+0xac>
8110a16c:	12000536 	bltu	r2,r8,8110a184 <msgdma_construct_extended_descriptor+0xc0>
8110a170:	e0bff717 	ldw	r2,-36(fp)
8110a174:	10801703 	ldbu	r2,92(r2)
8110a178:	10803fcc 	andi	r2,r2,255
8110a17c:	10800060 	cmpeqi	r2,r2,1
8110a180:	1000021e 	bne	r2,zero,8110a18c <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110a184:	00bffa84 	movi	r2,-22
8110a188:	00002306 	br	8110a218 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110a18c:	e0bff817 	ldw	r2,-32(fp)
8110a190:	e0fff917 	ldw	r3,-28(fp)
8110a194:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110a198:	e0bff817 	ldw	r2,-32(fp)
8110a19c:	e0fffa17 	ldw	r3,-24(fp)
8110a1a0:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110a1a4:	e0bff817 	ldw	r2,-32(fp)
8110a1a8:	e0c00117 	ldw	r3,4(fp)
8110a1ac:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110a1b0:	e0bff817 	ldw	r2,-32(fp)
8110a1b4:	e0fffb0b 	ldhu	r3,-20(fp)
8110a1b8:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110a1bc:	e0bff817 	ldw	r2,-32(fp)
8110a1c0:	e0fffc03 	ldbu	r3,-16(fp)
8110a1c4:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110a1c8:	e0bff817 	ldw	r2,-32(fp)
8110a1cc:	e0fffd03 	ldbu	r3,-12(fp)
8110a1d0:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110a1d4:	e0bff817 	ldw	r2,-32(fp)
8110a1d8:	e0fffe0b 	ldhu	r3,-8(fp)
8110a1dc:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110a1e0:	e0bff817 	ldw	r2,-32(fp)
8110a1e4:	e0ffff0b 	ldhu	r3,-4(fp)
8110a1e8:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110a1ec:	e0bff817 	ldw	r2,-32(fp)
8110a1f0:	e0c00317 	ldw	r3,12(fp)
8110a1f4:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110a1f8:	e0bff817 	ldw	r2,-32(fp)
8110a1fc:	e0c00417 	ldw	r3,16(fp)
8110a200:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110a204:	e0800217 	ldw	r2,8(fp)
8110a208:	10e00034 	orhi	r3,r2,32768
8110a20c:	e0bff817 	ldw	r2,-32(fp)
8110a210:	10c00715 	stw	r3,28(r2)

	return 0;
8110a214:	0005883a 	mov	r2,zero

}
8110a218:	e037883a 	mov	sp,fp
8110a21c:	df000017 	ldw	fp,0(sp)
8110a220:	dec00104 	addi	sp,sp,4
8110a224:	f800283a 	ret

8110a228 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a228:	deffee04 	addi	sp,sp,-72
8110a22c:	de00012e 	bgeu	sp,et,8110a234 <msgdma_descriptor_async_transfer+0xc>
8110a230:	003b68fa 	trap	3
8110a234:	dfc01115 	stw	ra,68(sp)
8110a238:	df001015 	stw	fp,64(sp)
8110a23c:	df001004 	addi	fp,sp,64
8110a240:	e13ffd15 	stw	r4,-12(fp)
8110a244:	e17ffe15 	stw	r5,-8(fp)
8110a248:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a24c:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110a250:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110a254:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a258:	e0bffd17 	ldw	r2,-12(fp)
8110a25c:	10800317 	ldw	r2,12(r2)
8110a260:	10800204 	addi	r2,r2,8
8110a264:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a268:	10bfffcc 	andi	r2,r2,65535
8110a26c:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a270:	e0bffd17 	ldw	r2,-12(fp)
8110a274:	10800317 	ldw	r2,12(r2)
8110a278:	10800204 	addi	r2,r2,8
8110a27c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a280:	1004d43a 	srli	r2,r2,16
8110a284:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a288:	e0bffd17 	ldw	r2,-12(fp)
8110a28c:	10800917 	ldw	r2,36(r2)
8110a290:	e0fff417 	ldw	r3,-48(fp)
8110a294:	1880042e 	bgeu	r3,r2,8110a2a8 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a298:	e0bffd17 	ldw	r2,-12(fp)
8110a29c:	10800917 	ldw	r2,36(r2)
8110a2a0:	e0fff317 	ldw	r3,-52(fp)
8110a2a4:	18800236 	bltu	r3,r2,8110a2b0 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110a2a8:	00bff904 	movi	r2,-28
8110a2ac:	00009f06 	br	8110a52c <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a2b0:	e0bffd17 	ldw	r2,-12(fp)
8110a2b4:	10801817 	ldw	r2,96(r2)
8110a2b8:	e0bff615 	stw	r2,-40(fp)
8110a2bc:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110a2c0:	e0bffc0b 	ldhu	r2,-16(fp)
8110a2c4:	e0fffc84 	addi	r3,fp,-14
8110a2c8:	180d883a 	mov	r6,r3
8110a2cc:	100b883a 	mov	r5,r2
8110a2d0:	e13ff617 	ldw	r4,-40(fp)
8110a2d4:	1138a3c0 	call	81138a3c <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110a2d8:	00800804 	movi	r2,32
8110a2dc:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a2e0:	0005303a 	rdctl	r2,status
8110a2e4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a2e8:	e0fff717 	ldw	r3,-36(fp)
8110a2ec:	00bfff84 	movi	r2,-2
8110a2f0:	1884703a 	and	r2,r3,r2
8110a2f4:	1001703a 	wrctl	status,r2
  
  return context;
8110a2f8:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a2fc:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a300:	e0bffd17 	ldw	r2,-12(fp)
8110a304:	10800317 	ldw	r2,12(r2)
8110a308:	10800104 	addi	r2,r2,4
8110a30c:	e0fff117 	ldw	r3,-60(fp)
8110a310:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a314:	e0bffd17 	ldw	r2,-12(fp)
8110a318:	10800317 	ldw	r2,12(r2)
8110a31c:	e0fffd17 	ldw	r3,-12(fp)
8110a320:	18c00317 	ldw	r3,12(r3)
8110a324:	18c00037 	ldwio	r3,0(r3)
8110a328:	10c00035 	stwio	r3,0(r2)
8110a32c:	e0bff217 	ldw	r2,-56(fp)
8110a330:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a334:	e0bffb17 	ldw	r2,-20(fp)
8110a338:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110a33c:	e0bffe17 	ldw	r2,-8(fp)
8110a340:	10001026 	beq	r2,zero,8110a384 <msgdma_descriptor_async_transfer+0x15c>
8110a344:	e0bfff17 	ldw	r2,-4(fp)
8110a348:	10000e1e 	bne	r2,zero,8110a384 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110a34c:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a350:	d0a05f17 	ldw	r2,-32388(gp)
8110a354:	100f883a 	mov	r7,r2
8110a358:	01800784 	movi	r6,30
8110a35c:	01400044 	movi	r5,1
8110a360:	01204534 	movhi	r4,33044
8110a364:	21187104 	addi	r4,r4,25028
8110a368:	111affc0 	call	8111affc <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a36c:	e0bffd17 	ldw	r2,-12(fp)
8110a370:	10801817 	ldw	r2,96(r2)
8110a374:	1009883a 	mov	r4,r2
8110a378:	1138dc40 	call	81138dc4 <OSSemPost>

		return -ETIME;
8110a37c:	00bff084 	movi	r2,-62
8110a380:	00006a06 	br	8110a52c <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a384:	e0bffe17 	ldw	r2,-8(fp)
8110a388:	1000231e 	bne	r2,zero,8110a418 <msgdma_descriptor_async_transfer+0x1f0>
8110a38c:	e0bfff17 	ldw	r2,-4(fp)
8110a390:	10002126 	beq	r2,zero,8110a418 <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110a394:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a398:	00001506 	br	8110a3f0 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a39c:	01000044 	movi	r4,1
8110a3a0:	11301c40 	call	811301c4 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a3a4:	e0bff00b 	ldhu	r2,-64(fp)
8110a3a8:	1084e230 	cmpltui	r2,r2,5000
8110a3ac:	10000d1e 	bne	r2,zero,8110a3e4 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a3b0:	d0a05f17 	ldw	r2,-32388(gp)
8110a3b4:	100f883a 	mov	r7,r2
8110a3b8:	01801544 	movi	r6,85
8110a3bc:	01400044 	movi	r5,1
8110a3c0:	01204534 	movhi	r4,33044
8110a3c4:	21187904 	addi	r4,r4,25060
8110a3c8:	111affc0 	call	8111affc <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a3cc:	e0bffd17 	ldw	r2,-12(fp)
8110a3d0:	10801817 	ldw	r2,96(r2)
8110a3d4:	1009883a 	mov	r4,r2
8110a3d8:	1138dc40 	call	81138dc4 <OSSemPost>

				return -ETIME;
8110a3dc:	00bff084 	movi	r2,-62
8110a3e0:	00005206 	br	8110a52c <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110a3e4:	e0bff00b 	ldhu	r2,-64(fp)
8110a3e8:	10800044 	addi	r2,r2,1
8110a3ec:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a3f0:	e0bffd17 	ldw	r2,-12(fp)
8110a3f4:	10c00317 	ldw	r3,12(r2)
8110a3f8:	e0bffd17 	ldw	r2,-12(fp)
8110a3fc:	10800417 	ldw	r2,16(r2)
8110a400:	e1bfff17 	ldw	r6,-4(fp)
8110a404:	100b883a 	mov	r5,r2
8110a408:	1809883a 	mov	r4,r3
8110a40c:	1109f880 	call	81109f88 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a410:	103fe21e 	bne	r2,zero,8110a39c <__reset+0xfb0ea39c>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a414:	00000606 	br	8110a430 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a418:	e0bffd17 	ldw	r2,-12(fp)
8110a41c:	10801817 	ldw	r2,96(r2)
8110a420:	1009883a 	mov	r4,r2
8110a424:	1138dc40 	call	81138dc4 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a428:	00bfffc4 	movi	r2,-1
8110a42c:	00003f06 	br	8110a52c <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110a430:	e0bffd17 	ldw	r2,-12(fp)
8110a434:	10800b17 	ldw	r2,44(r2)
8110a438:	10001c26 	beq	r2,zero,8110a4ac <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110a43c:	e0bffd17 	ldw	r2,-12(fp)
8110a440:	10c00d17 	ldw	r3,52(r2)
8110a444:	e0bff117 	ldw	r2,-60(fp)
8110a448:	1884b03a 	or	r2,r3,r2
8110a44c:	10800514 	ori	r2,r2,20
8110a450:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110a454:	e0fff117 	ldw	r3,-60(fp)
8110a458:	00bff7c4 	movi	r2,-33
8110a45c:	1884703a 	and	r2,r3,r2
8110a460:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a464:	0005303a 	rdctl	r2,status
8110a468:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a46c:	e0fff917 	ldw	r3,-28(fp)
8110a470:	00bfff84 	movi	r2,-2
8110a474:	1884703a 	and	r2,r3,r2
8110a478:	1001703a 	wrctl	status,r2
  
  return context;
8110a47c:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a480:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a484:	e0bffd17 	ldw	r2,-12(fp)
8110a488:	10800317 	ldw	r2,12(r2)
8110a48c:	10800104 	addi	r2,r2,4
8110a490:	e0fff117 	ldw	r3,-60(fp)
8110a494:	10c00035 	stwio	r3,0(r2)
8110a498:	e0bff217 	ldw	r2,-56(fp)
8110a49c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a4a0:	e0bff517 	ldw	r2,-44(fp)
8110a4a4:	1001703a 	wrctl	status,r2
8110a4a8:	00001b06 	br	8110a518 <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110a4ac:	e0bffd17 	ldw	r2,-12(fp)
8110a4b0:	10c00d17 	ldw	r3,52(r2)
8110a4b4:	e0bff117 	ldw	r2,-60(fp)
8110a4b8:	1884b03a 	or	r2,r3,r2
8110a4bc:	10800114 	ori	r2,r2,4
8110a4c0:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110a4c4:	e0fff117 	ldw	r3,-60(fp)
8110a4c8:	00bff3c4 	movi	r2,-49
8110a4cc:	1884703a 	and	r2,r3,r2
8110a4d0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a4d4:	0005303a 	rdctl	r2,status
8110a4d8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a4dc:	e0fffa17 	ldw	r3,-24(fp)
8110a4e0:	00bfff84 	movi	r2,-2
8110a4e4:	1884703a 	and	r2,r3,r2
8110a4e8:	1001703a 	wrctl	status,r2
  
  return context;
8110a4ec:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a4f0:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a4f4:	e0bffd17 	ldw	r2,-12(fp)
8110a4f8:	10800317 	ldw	r2,12(r2)
8110a4fc:	10800104 	addi	r2,r2,4
8110a500:	e0fff117 	ldw	r3,-60(fp)
8110a504:	10c00035 	stwio	r3,0(r2)
8110a508:	e0bff217 	ldw	r2,-56(fp)
8110a50c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a510:	e0bff817 	ldw	r2,-32(fp)
8110a514:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a518:	e0bffd17 	ldw	r2,-12(fp)
8110a51c:	10801817 	ldw	r2,96(r2)
8110a520:	1009883a 	mov	r4,r2
8110a524:	1138dc40 	call	81138dc4 <OSSemPost>

	return 0;
8110a528:	0005883a 	mov	r2,zero
}
8110a52c:	e037883a 	mov	sp,fp
8110a530:	dfc00117 	ldw	ra,4(sp)
8110a534:	df000017 	ldw	fp,0(sp)
8110a538:	dec00204 	addi	sp,sp,8
8110a53c:	f800283a 	ret

8110a540 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a540:	deffee04 	addi	sp,sp,-72
8110a544:	de00012e 	bgeu	sp,et,8110a54c <msgdma_descriptor_sync_transfer+0xc>
8110a548:	003b68fa 	trap	3
8110a54c:	dfc01115 	stw	ra,68(sp)
8110a550:	df001015 	stw	fp,64(sp)
8110a554:	df001004 	addi	fp,sp,64
8110a558:	e13ffd15 	stw	r4,-12(fp)
8110a55c:	e17ffe15 	stw	r5,-8(fp)
8110a560:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a564:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110a568:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110a56c:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110a570:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a574:	e0bffd17 	ldw	r2,-12(fp)
8110a578:	10800317 	ldw	r2,12(r2)
8110a57c:	10800204 	addi	r2,r2,8
8110a580:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a584:	10bfffcc 	andi	r2,r2,65535
8110a588:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a58c:	e0bffd17 	ldw	r2,-12(fp)
8110a590:	10800317 	ldw	r2,12(r2)
8110a594:	10800204 	addi	r2,r2,8
8110a598:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a59c:	1004d43a 	srli	r2,r2,16
8110a5a0:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110a5a4:	00807804 	movi	r2,480
8110a5a8:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a5ac:	00001d06 	br	8110a624 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110a5b0:	01000044 	movi	r4,1
8110a5b4:	11301c40 	call	811301c4 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a5b8:	e0bff10b 	ldhu	r2,-60(fp)
8110a5bc:	1084e230 	cmpltui	r2,r2,5000
8110a5c0:	1000091e 	bne	r2,zero,8110a5e8 <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a5c4:	d0a05f17 	ldw	r2,-32388(gp)
8110a5c8:	100f883a 	mov	r7,r2
8110a5cc:	01801304 	movi	r6,76
8110a5d0:	01400044 	movi	r5,1
8110a5d4:	01204534 	movhi	r4,33044
8110a5d8:	21188f04 	addi	r4,r4,25148
8110a5dc:	111affc0 	call	8111affc <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110a5e0:	00bff084 	movi	r2,-62
8110a5e4:	0000d006 	br	8110a928 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a5e8:	e0bff10b 	ldhu	r2,-60(fp)
8110a5ec:	10800044 	addi	r2,r2,1
8110a5f0:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a5f4:	e0bffd17 	ldw	r2,-12(fp)
8110a5f8:	10800317 	ldw	r2,12(r2)
8110a5fc:	10800204 	addi	r2,r2,8
8110a600:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110a604:	10bfffcc 	andi	r2,r2,65535
8110a608:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a60c:	e0bffd17 	ldw	r2,-12(fp)
8110a610:	10800317 	ldw	r2,12(r2)
8110a614:	10800204 	addi	r2,r2,8
8110a618:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110a61c:	1004d43a 	srli	r2,r2,16
8110a620:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a624:	e0bffd17 	ldw	r2,-12(fp)
8110a628:	10800917 	ldw	r2,36(r2)
8110a62c:	e0fff317 	ldw	r3,-52(fp)
8110a630:	18bfdf2e 	bgeu	r3,r2,8110a5b0 <__reset+0xfb0ea5b0>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a634:	e0bffd17 	ldw	r2,-12(fp)
8110a638:	10800917 	ldw	r2,36(r2)
8110a63c:	e0fff217 	ldw	r3,-56(fp)
8110a640:	18bfdb2e 	bgeu	r3,r2,8110a5b0 <__reset+0xfb0ea5b0>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a644:	e0bffd17 	ldw	r2,-12(fp)
8110a648:	10801817 	ldw	r2,96(r2)
8110a64c:	e0bff815 	stw	r2,-32(fp)
8110a650:	e03ffc0d 	sth	zero,-16(fp)
8110a654:	e0bffc0b 	ldhu	r2,-16(fp)
8110a658:	e0fffc84 	addi	r3,fp,-14
8110a65c:	180d883a 	mov	r6,r3
8110a660:	100b883a 	mov	r5,r2
8110a664:	e13ff817 	ldw	r4,-32(fp)
8110a668:	1138a3c0 	call	81138a3c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a66c:	0005303a 	rdctl	r2,status
8110a670:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a674:	e0fffb17 	ldw	r3,-20(fp)
8110a678:	00bfff84 	movi	r2,-2
8110a67c:	1884703a 	and	r2,r3,r2
8110a680:	1001703a 	wrctl	status,r2
  
  return context;
8110a684:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a688:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a68c:	e0bffd17 	ldw	r2,-12(fp)
8110a690:	10800317 	ldw	r2,12(r2)
8110a694:	10800104 	addi	r2,r2,4
8110a698:	00c00804 	movi	r3,32
8110a69c:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a6a0:	e0bffd17 	ldw	r2,-12(fp)
8110a6a4:	10800317 	ldw	r2,12(r2)
8110a6a8:	e0fffd17 	ldw	r3,-12(fp)
8110a6ac:	18c00317 	ldw	r3,12(r3)
8110a6b0:	18c00037 	ldwio	r3,0(r3)
8110a6b4:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110a6b8:	e0bffe17 	ldw	r2,-8(fp)
8110a6bc:	10001026 	beq	r2,zero,8110a700 <msgdma_descriptor_sync_transfer+0x1c0>
8110a6c0:	e0bfff17 	ldw	r2,-4(fp)
8110a6c4:	10000e1e 	bne	r2,zero,8110a700 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110a6c8:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a6cc:	d0a05f17 	ldw	r2,-32388(gp)
8110a6d0:	100f883a 	mov	r7,r2
8110a6d4:	01800784 	movi	r6,30
8110a6d8:	01400044 	movi	r5,1
8110a6dc:	01204534 	movhi	r4,33044
8110a6e0:	21187104 	addi	r4,r4,25028
8110a6e4:	111affc0 	call	8111affc <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a6e8:	e0bffd17 	ldw	r2,-12(fp)
8110a6ec:	10801817 	ldw	r2,96(r2)
8110a6f0:	1009883a 	mov	r4,r2
8110a6f4:	1138dc40 	call	81138dc4 <OSSemPost>

		return -ETIME;
8110a6f8:	00bff084 	movi	r2,-62
8110a6fc:	00008a06 	br	8110a928 <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a700:	e0bffe17 	ldw	r2,-8(fp)
8110a704:	1000231e 	bne	r2,zero,8110a794 <msgdma_descriptor_sync_transfer+0x254>
8110a708:	e0bfff17 	ldw	r2,-4(fp)
8110a70c:	10002126 	beq	r2,zero,8110a794 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110a710:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a714:	00001506 	br	8110a76c <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a718:	01000044 	movi	r4,1
8110a71c:	11301c40 	call	811301c4 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a720:	e0bff10b 	ldhu	r2,-60(fp)
8110a724:	1084e230 	cmpltui	r2,r2,5000
8110a728:	10000d1e 	bne	r2,zero,8110a760 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a72c:	d0a05f17 	ldw	r2,-32388(gp)
8110a730:	100f883a 	mov	r7,r2
8110a734:	01801004 	movi	r6,64
8110a738:	01400044 	movi	r5,1
8110a73c:	01204534 	movhi	r4,33044
8110a740:	2118a304 	addi	r4,r4,25228
8110a744:	111affc0 	call	8111affc <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a748:	e0bffd17 	ldw	r2,-12(fp)
8110a74c:	10801817 	ldw	r2,96(r2)
8110a750:	1009883a 	mov	r4,r2
8110a754:	1138dc40 	call	81138dc4 <OSSemPost>

				return -ETIME;
8110a758:	00bff084 	movi	r2,-62
8110a75c:	00007206 	br	8110a928 <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110a760:	e0bff10b 	ldhu	r2,-60(fp)
8110a764:	10800044 	addi	r2,r2,1
8110a768:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a76c:	e0bffd17 	ldw	r2,-12(fp)
8110a770:	10c00317 	ldw	r3,12(r2)
8110a774:	e0bffd17 	ldw	r2,-12(fp)
8110a778:	10800417 	ldw	r2,16(r2)
8110a77c:	e1bfff17 	ldw	r6,-4(fp)
8110a780:	100b883a 	mov	r5,r2
8110a784:	1809883a 	mov	r4,r3
8110a788:	1109f880 	call	81109f88 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a78c:	103fe21e 	bne	r2,zero,8110a718 <__reset+0xfb0ea718>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a790:	00000606 	br	8110a7ac <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a794:	e0bffd17 	ldw	r2,-12(fp)
8110a798:	10801817 	ldw	r2,96(r2)
8110a79c:	1009883a 	mov	r4,r2
8110a7a0:	1138dc40 	call	81138dc4 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a7a4:	00bfffc4 	movi	r2,-1
8110a7a8:	00005f06 	br	8110a928 <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110a7ac:	e0bffd17 	ldw	r2,-12(fp)
8110a7b0:	10800317 	ldw	r2,12(r2)
8110a7b4:	10800104 	addi	r2,r2,4
8110a7b8:	e0fffd17 	ldw	r3,-12(fp)
8110a7bc:	19000d17 	ldw	r4,52(r3)
8110a7c0:	00fff2c4 	movi	r3,-53
8110a7c4:	20c6703a 	and	r3,r4,r3
8110a7c8:	18c00114 	ori	r3,r3,4
8110a7cc:	10c00035 	stwio	r3,0(r2)
8110a7d0:	e0bff517 	ldw	r2,-44(fp)
8110a7d4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a7d8:	e0bff717 	ldw	r2,-36(fp)
8110a7dc:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110a7e0:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110a7e4:	e0bffd17 	ldw	r2,-12(fp)
8110a7e8:	10800317 	ldw	r2,12(r2)
8110a7ec:	10800037 	ldwio	r2,0(r2)
8110a7f0:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110a7f4:	00001906 	br	8110a85c <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110a7f8:	01000044 	movi	r4,1
8110a7fc:	11301c40 	call	811301c4 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a800:	e0bff10b 	ldhu	r2,-60(fp)
8110a804:	1084e230 	cmpltui	r2,r2,5000
8110a808:	10000d1e 	bne	r2,zero,8110a840 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a80c:	d0a05f17 	ldw	r2,-32388(gp)
8110a810:	100f883a 	mov	r7,r2
8110a814:	01801184 	movi	r6,70
8110a818:	01400044 	movi	r5,1
8110a81c:	01204534 	movhi	r4,33044
8110a820:	2118b404 	addi	r4,r4,25296
8110a824:	111affc0 	call	8111affc <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110a828:	e0bffd17 	ldw	r2,-12(fp)
8110a82c:	10801817 	ldw	r2,96(r2)
8110a830:	1009883a 	mov	r4,r2
8110a834:	1138dc40 	call	81138dc4 <OSSemPost>

			return -ETIME;
8110a838:	00bff084 	movi	r2,-62
8110a83c:	00003a06 	br	8110a928 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a840:	e0bff10b 	ldhu	r2,-60(fp)
8110a844:	10800044 	addi	r2,r2,1
8110a848:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110a84c:	e0bffd17 	ldw	r2,-12(fp)
8110a850:	10800317 	ldw	r2,12(r2)
8110a854:	10800037 	ldwio	r2,0(r2)
8110a858:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110a85c:	e0fff017 	ldw	r3,-64(fp)
8110a860:	e0bff617 	ldw	r2,-40(fp)
8110a864:	1884703a 	and	r2,r3,r2
8110a868:	1000031e 	bne	r2,zero,8110a878 <msgdma_descriptor_sync_transfer+0x338>
8110a86c:	e0bff017 	ldw	r2,-64(fp)
8110a870:	1080004c 	andi	r2,r2,1
8110a874:	103fe01e 	bne	r2,zero,8110a7f8 <__reset+0xfb0ea7f8>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110a878:	e0fff017 	ldw	r3,-64(fp)
8110a87c:	e0bff617 	ldw	r2,-40(fp)
8110a880:	1884703a 	and	r2,r3,r2
8110a884:	10000626 	beq	r2,zero,8110a8a0 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a888:	e0bffd17 	ldw	r2,-12(fp)
8110a88c:	10801817 	ldw	r2,96(r2)
8110a890:	1009883a 	mov	r4,r2
8110a894:	1138dc40 	call	81138dc4 <OSSemPost>

		return error;
8110a898:	e0bff617 	ldw	r2,-40(fp)
8110a89c:	00002206 	br	8110a928 <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110a8a0:	e0bffd17 	ldw	r2,-12(fp)
8110a8a4:	10800317 	ldw	r2,12(r2)
8110a8a8:	10800104 	addi	r2,r2,4
8110a8ac:	10800037 	ldwio	r2,0(r2)
8110a8b0:	10800814 	ori	r2,r2,32
8110a8b4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a8b8:	0005303a 	rdctl	r2,status
8110a8bc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a8c0:	e0fffa17 	ldw	r3,-24(fp)
8110a8c4:	00bfff84 	movi	r2,-2
8110a8c8:	1884703a 	and	r2,r3,r2
8110a8cc:	1001703a 	wrctl	status,r2
  
  return context;
8110a8d0:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a8d4:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a8d8:	e0bffd17 	ldw	r2,-12(fp)
8110a8dc:	10800317 	ldw	r2,12(r2)
8110a8e0:	10800104 	addi	r2,r2,4
8110a8e4:	e0fff417 	ldw	r3,-48(fp)
8110a8e8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a8ec:	e0bffd17 	ldw	r2,-12(fp)
8110a8f0:	10800317 	ldw	r2,12(r2)
8110a8f4:	e0fffd17 	ldw	r3,-12(fp)
8110a8f8:	18c00317 	ldw	r3,12(r3)
8110a8fc:	18c00037 	ldwio	r3,0(r3)
8110a900:	10c00035 	stwio	r3,0(r2)
8110a904:	e0bff517 	ldw	r2,-44(fp)
8110a908:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a90c:	e0bff917 	ldw	r2,-28(fp)
8110a910:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a914:	e0bffd17 	ldw	r2,-12(fp)
8110a918:	10801817 	ldw	r2,96(r2)
8110a91c:	1009883a 	mov	r4,r2
8110a920:	1138dc40 	call	81138dc4 <OSSemPost>

	return 0;
8110a924:	0005883a 	mov	r2,zero

}
8110a928:	e037883a 	mov	sp,fp
8110a92c:	dfc00117 	ldw	ra,4(sp)
8110a930:	df000017 	ldw	fp,0(sp)
8110a934:	dec00204 	addi	sp,sp,8
8110a938:	f800283a 	ret

8110a93c <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110a93c:	deffec04 	addi	sp,sp,-80
8110a940:	de00012e 	bgeu	sp,et,8110a948 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110a944:	003b68fa 	trap	3
8110a948:	dfc01315 	stw	ra,76(sp)
8110a94c:	df001215 	stw	fp,72(sp)
8110a950:	df001204 	addi	fp,sp,72
8110a954:	e13ff715 	stw	r4,-36(fp)
8110a958:	e17ff815 	stw	r5,-32(fp)
8110a95c:	e1bff915 	stw	r6,-28(fp)
8110a960:	e1fffa15 	stw	r7,-24(fp)
8110a964:	e1800617 	ldw	r6,24(fp)
8110a968:	e1400717 	ldw	r5,28(fp)
8110a96c:	e1000817 	ldw	r4,32(fp)
8110a970:	e0c00917 	ldw	r3,36(fp)
8110a974:	e0800a17 	ldw	r2,40(fp)
8110a978:	e1bffb0d 	sth	r6,-20(fp)
8110a97c:	e17ffc05 	stb	r5,-16(fp)
8110a980:	e13ffd05 	stb	r4,-12(fp)
8110a984:	e0fffe0d 	sth	r3,-8(fp)
8110a988:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110a98c:	e0bffb0b 	ldhu	r2,-20(fp)
8110a990:	e0fffc03 	ldbu	r3,-16(fp)
8110a994:	e13ffd03 	ldbu	r4,-12(fp)
8110a998:	e17ffe0b 	ldhu	r5,-8(fp)
8110a99c:	e1bfff0b 	ldhu	r6,-4(fp)
8110a9a0:	d9800815 	stw	r6,32(sp)
8110a9a4:	d9400715 	stw	r5,28(sp)
8110a9a8:	d9000615 	stw	r4,24(sp)
8110a9ac:	d8c00515 	stw	r3,20(sp)
8110a9b0:	d8800415 	stw	r2,16(sp)
8110a9b4:	e0800517 	ldw	r2,20(fp)
8110a9b8:	d8800315 	stw	r2,12(sp)
8110a9bc:	e0800417 	ldw	r2,16(fp)
8110a9c0:	d8800215 	stw	r2,8(sp)
8110a9c4:	e0800317 	ldw	r2,12(fp)
8110a9c8:	d8800115 	stw	r2,4(sp)
8110a9cc:	e0800217 	ldw	r2,8(fp)
8110a9d0:	d8800015 	stw	r2,0(sp)
8110a9d4:	e1fffa17 	ldw	r7,-24(fp)
8110a9d8:	e1bff917 	ldw	r6,-28(fp)
8110a9dc:	e17ff817 	ldw	r5,-32(fp)
8110a9e0:	e13ff717 	ldw	r4,-36(fp)
8110a9e4:	110a0c40 	call	8110a0c4 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110a9e8:	e037883a 	mov	sp,fp
8110a9ec:	dfc00117 	ldw	ra,4(sp)
8110a9f0:	df000017 	ldw	fp,0(sp)
8110a9f4:	dec00204 	addi	sp,sp,8
8110a9f8:	f800283a 	ret

8110a9fc <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110a9fc:	defffc04 	addi	sp,sp,-16
8110aa00:	de00012e 	bgeu	sp,et,8110aa08 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110aa04:	003b68fa 	trap	3
8110aa08:	dfc00315 	stw	ra,12(sp)
8110aa0c:	df000215 	stw	fp,8(sp)
8110aa10:	df000204 	addi	fp,sp,8
8110aa14:	e13ffe15 	stw	r4,-8(fp)
8110aa18:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110aa1c:	e1bfff17 	ldw	r6,-4(fp)
8110aa20:	000b883a 	mov	r5,zero
8110aa24:	e13ffe17 	ldw	r4,-8(fp)
8110aa28:	110a2280 	call	8110a228 <msgdma_descriptor_async_transfer>
}
8110aa2c:	e037883a 	mov	sp,fp
8110aa30:	dfc00117 	ldw	ra,4(sp)
8110aa34:	df000017 	ldw	fp,0(sp)
8110aa38:	dec00204 	addi	sp,sp,8
8110aa3c:	f800283a 	ret

8110aa40 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110aa40:	defffc04 	addi	sp,sp,-16
8110aa44:	de00012e 	bgeu	sp,et,8110aa4c <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110aa48:	003b68fa 	trap	3
8110aa4c:	dfc00315 	stw	ra,12(sp)
8110aa50:	df000215 	stw	fp,8(sp)
8110aa54:	df000204 	addi	fp,sp,8
8110aa58:	e13ffe15 	stw	r4,-8(fp)
8110aa5c:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110aa60:	e1bfff17 	ldw	r6,-4(fp)
8110aa64:	000b883a 	mov	r5,zero
8110aa68:	e13ffe17 	ldw	r4,-8(fp)
8110aa6c:	110a5400 	call	8110a540 <msgdma_descriptor_sync_transfer>
}
8110aa70:	e037883a 	mov	sp,fp
8110aa74:	dfc00117 	ldw	ra,4(sp)
8110aa78:	df000017 	ldw	fp,0(sp)
8110aa7c:	dec00204 	addi	sp,sp,8
8110aa80:	f800283a 	ret

8110aa84 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110aa84:	defff204 	addi	sp,sp,-56
8110aa88:	de00012e 	bgeu	sp,et,8110aa90 <POWER_SPI_RW+0xc>
8110aa8c:	003b68fa 	trap	3
8110aa90:	dfc00d15 	stw	ra,52(sp)
8110aa94:	df000c15 	stw	fp,48(sp)
8110aa98:	df000c04 	addi	fp,sp,48
8110aa9c:	2007883a 	mov	r3,r4
8110aaa0:	2805883a 	mov	r2,r5
8110aaa4:	e1bffe15 	stw	r6,-8(fp)
8110aaa8:	e1ffff15 	stw	r7,-4(fp)
8110aaac:	e0fffc05 	stb	r3,-16(fp)
8110aab0:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110aab4:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110aab8:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110aabc:	008003f4 	movhi	r2,15
8110aac0:	10909004 	addi	r2,r2,16960
8110aac4:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110aac8:	00bfe004 	movi	r2,-128
8110aacc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110aad0:	e0bffe17 	ldw	r2,-8(fp)
8110aad4:	10000226 	beq	r2,zero,8110aae0 <POWER_SPI_RW+0x5c>
8110aad8:	00800804 	movi	r2,32
8110aadc:	00000106 	br	8110aae4 <POWER_SPI_RW+0x60>
8110aae0:	0005883a 	mov	r2,zero
8110aae4:	e0fff403 	ldbu	r3,-48(fp)
8110aae8:	10c4b03a 	or	r2,r2,r3
8110aaec:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110aaf0:	e0800217 	ldw	r2,8(fp)
8110aaf4:	10000226 	beq	r2,zero,8110ab00 <POWER_SPI_RW+0x7c>
8110aaf8:	00800404 	movi	r2,16
8110aafc:	00000106 	br	8110ab04 <POWER_SPI_RW+0x80>
8110ab00:	0005883a 	mov	r2,zero
8110ab04:	e0fff403 	ldbu	r3,-48(fp)
8110ab08:	10c4b03a 	or	r2,r2,r3
8110ab0c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110ab10:	e0bfff17 	ldw	r2,-4(fp)
8110ab14:	10000226 	beq	r2,zero,8110ab20 <POWER_SPI_RW+0x9c>
8110ab18:	00800204 	movi	r2,8
8110ab1c:	00000106 	br	8110ab24 <POWER_SPI_RW+0xa0>
8110ab20:	0005883a 	mov	r2,zero
8110ab24:	e0fff403 	ldbu	r3,-48(fp)
8110ab28:	10c4b03a 	or	r2,r2,r3
8110ab2c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110ab30:	e0bffd03 	ldbu	r2,-12(fp)
8110ab34:	108001cc 	andi	r2,r2,7
8110ab38:	1007883a 	mov	r3,r2
8110ab3c:	e0bff403 	ldbu	r2,-48(fp)
8110ab40:	1884b03a 	or	r2,r3,r2
8110ab44:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110ab48:	0007883a 	mov	r3,zero
8110ab4c:	00a00034 	movhi	r2,32768
8110ab50:	10824404 	addi	r2,r2,2320
8110ab54:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110ab58:	0007883a 	mov	r3,zero
8110ab5c:	00a00034 	movhi	r2,32768
8110ab60:	10824c04 	addi	r2,r2,2352
8110ab64:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110ab68:	e0bffc03 	ldbu	r2,-16(fp)
8110ab6c:	1000021e 	bne	r2,zero,8110ab78 <POWER_SPI_RW+0xf4>
8110ab70:	00c00084 	movi	r3,2
8110ab74:	00000106 	br	8110ab7c <POWER_SPI_RW+0xf8>
8110ab78:	00c00044 	movi	r3,1
8110ab7c:	00a00034 	movhi	r2,32768
8110ab80:	10824804 	addi	r2,r2,2336
8110ab84:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110ab88:	010003c4 	movi	r4,15
8110ab8c:	1131c380 	call	81131c38 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ab90:	00000306 	br	8110aba0 <POWER_SPI_RW+0x11c>
		nWait++;
8110ab94:	e0bff817 	ldw	r2,-32(fp)
8110ab98:	10800044 	addi	r2,r2,1
8110ab9c:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110aba0:	00a00034 	movhi	r2,32768
8110aba4:	10825404 	addi	r2,r2,2384
8110aba8:	10800037 	ldwio	r2,0(r2)
8110abac:	1080004c 	andi	r2,r2,1
8110abb0:	10000326 	beq	r2,zero,8110abc0 <POWER_SPI_RW+0x13c>
8110abb4:	e0fff817 	ldw	r3,-32(fp)
8110abb8:	e0bffa17 	ldw	r2,-24(fp)
8110abbc:	18bff516 	blt	r3,r2,8110ab94 <__reset+0xfb0eab94>
		nWait++;
	}

	if (SPI_SDO) {
8110abc0:	00a00034 	movhi	r2,32768
8110abc4:	10825404 	addi	r2,r2,2384
8110abc8:	10800037 	ldwio	r2,0(r2)
8110abcc:	1080004c 	andi	r2,r2,1
8110abd0:	10000626 	beq	r2,zero,8110abec <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110abd4:	00c000c4 	movi	r3,3
8110abd8:	00a00034 	movhi	r2,32768
8110abdc:	10824804 	addi	r2,r2,2336
8110abe0:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110abe4:	0005883a 	mov	r2,zero
8110abe8:	0000db06 	br	8110af58 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110abec:	e03ff715 	stw	zero,-36(fp)
8110abf0:	00002406 	br	8110ac84 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110abf4:	e0bff403 	ldbu	r2,-48(fp)
8110abf8:	10803fcc 	andi	r2,r2,255
8110abfc:	1004d1fa 	srli	r2,r2,7
8110ac00:	10c03fcc 	andi	r3,r2,255
8110ac04:	00a00034 	movhi	r2,32768
8110ac08:	10825004 	addi	r2,r2,2368
8110ac0c:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110ac10:	e0bff403 	ldbu	r2,-48(fp)
8110ac14:	1085883a 	add	r2,r2,r2
8110ac18:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110ac1c:	e0bff517 	ldw	r2,-44(fp)
8110ac20:	1085883a 	add	r2,r2,r2
8110ac24:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110ac28:	00a00034 	movhi	r2,32768
8110ac2c:	10825404 	addi	r2,r2,2384
8110ac30:	10800037 	ldwio	r2,0(r2)
8110ac34:	1080004c 	andi	r2,r2,1
8110ac38:	1007883a 	mov	r3,r2
8110ac3c:	e0bff517 	ldw	r2,-44(fp)
8110ac40:	10c4b03a 	or	r2,r2,r3
8110ac44:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ac48:	00c00044 	movi	r3,1
8110ac4c:	00a00034 	movhi	r2,32768
8110ac50:	10824c04 	addi	r2,r2,2352
8110ac54:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ac58:	010003c4 	movi	r4,15
8110ac5c:	1131c380 	call	81131c38 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ac60:	0007883a 	mov	r3,zero
8110ac64:	00a00034 	movhi	r2,32768
8110ac68:	10824c04 	addi	r2,r2,2352
8110ac6c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ac70:	010003c4 	movi	r4,15
8110ac74:	1131c380 	call	81131c38 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110ac78:	e0bff717 	ldw	r2,-36(fp)
8110ac7c:	10800044 	addi	r2,r2,1
8110ac80:	e0bff715 	stw	r2,-36(fp)
8110ac84:	e0bff717 	ldw	r2,-36(fp)
8110ac88:	10800090 	cmplti	r2,r2,2
8110ac8c:	103fd91e 	bne	r2,zero,8110abf4 <__reset+0xfb0eabf4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110ac90:	e03ff715 	stw	zero,-36(fp)
8110ac94:	00002406 	br	8110ad28 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110ac98:	e0bff403 	ldbu	r2,-48(fp)
8110ac9c:	10803fcc 	andi	r2,r2,255
8110aca0:	1004d1fa 	srli	r2,r2,7
8110aca4:	10c03fcc 	andi	r3,r2,255
8110aca8:	00a00034 	movhi	r2,32768
8110acac:	10825004 	addi	r2,r2,2368
8110acb0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110acb4:	e0bff403 	ldbu	r2,-48(fp)
8110acb8:	1085883a 	add	r2,r2,r2
8110acbc:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110acc0:	e0bff517 	ldw	r2,-44(fp)
8110acc4:	1085883a 	add	r2,r2,r2
8110acc8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110accc:	00a00034 	movhi	r2,32768
8110acd0:	10825404 	addi	r2,r2,2384
8110acd4:	10800037 	ldwio	r2,0(r2)
8110acd8:	1080004c 	andi	r2,r2,1
8110acdc:	1007883a 	mov	r3,r2
8110ace0:	e0bff517 	ldw	r2,-44(fp)
8110ace4:	10c4b03a 	or	r2,r2,r3
8110ace8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110acec:	00c00044 	movi	r3,1
8110acf0:	00a00034 	movhi	r2,32768
8110acf4:	10824c04 	addi	r2,r2,2352
8110acf8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110acfc:	010003c4 	movi	r4,15
8110ad00:	1131c380 	call	81131c38 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ad04:	0007883a 	mov	r3,zero
8110ad08:	00a00034 	movhi	r2,32768
8110ad0c:	10824c04 	addi	r2,r2,2352
8110ad10:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ad14:	010003c4 	movi	r4,15
8110ad18:	1131c380 	call	81131c38 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110ad1c:	e0bff717 	ldw	r2,-36(fp)
8110ad20:	10800044 	addi	r2,r2,1
8110ad24:	e0bff715 	stw	r2,-36(fp)
8110ad28:	e0bff717 	ldw	r2,-36(fp)
8110ad2c:	10800210 	cmplti	r2,r2,8
8110ad30:	103fd91e 	bne	r2,zero,8110ac98 <__reset+0xfb0eac98>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110ad34:	e03ff715 	stw	zero,-36(fp)
8110ad38:	00001a06 	br	8110ada4 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110ad3c:	e0bff517 	ldw	r2,-44(fp)
8110ad40:	1085883a 	add	r2,r2,r2
8110ad44:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110ad48:	00a00034 	movhi	r2,32768
8110ad4c:	10825404 	addi	r2,r2,2384
8110ad50:	10800037 	ldwio	r2,0(r2)
8110ad54:	1080004c 	andi	r2,r2,1
8110ad58:	1007883a 	mov	r3,r2
8110ad5c:	e0bff517 	ldw	r2,-44(fp)
8110ad60:	10c4b03a 	or	r2,r2,r3
8110ad64:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ad68:	00c00044 	movi	r3,1
8110ad6c:	00a00034 	movhi	r2,32768
8110ad70:	10824c04 	addi	r2,r2,2352
8110ad74:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ad78:	010003c4 	movi	r4,15
8110ad7c:	1131c380 	call	81131c38 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ad80:	0007883a 	mov	r3,zero
8110ad84:	00a00034 	movhi	r2,32768
8110ad88:	10824c04 	addi	r2,r2,2352
8110ad8c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ad90:	010003c4 	movi	r4,15
8110ad94:	1131c380 	call	81131c38 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110ad98:	e0bff717 	ldw	r2,-36(fp)
8110ad9c:	10800044 	addi	r2,r2,1
8110ada0:	e0bff715 	stw	r2,-36(fp)
8110ada4:	e0bff717 	ldw	r2,-36(fp)
8110ada8:	10800210 	cmplti	r2,r2,8
8110adac:	103fe31e 	bne	r2,zero,8110ad3c <__reset+0xfb0ead3c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110adb0:	e03ff715 	stw	zero,-36(fp)
8110adb4:	00001a06 	br	8110ae20 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110adb8:	e0bff517 	ldw	r2,-44(fp)
8110adbc:	1085883a 	add	r2,r2,r2
8110adc0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110adc4:	00a00034 	movhi	r2,32768
8110adc8:	10825404 	addi	r2,r2,2384
8110adcc:	10800037 	ldwio	r2,0(r2)
8110add0:	1080004c 	andi	r2,r2,1
8110add4:	1007883a 	mov	r3,r2
8110add8:	e0bff517 	ldw	r2,-44(fp)
8110addc:	10c4b03a 	or	r2,r2,r3
8110ade0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ade4:	00c00044 	movi	r3,1
8110ade8:	00a00034 	movhi	r2,32768
8110adec:	10824c04 	addi	r2,r2,2352
8110adf0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110adf4:	010003c4 	movi	r4,15
8110adf8:	1131c380 	call	81131c38 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110adfc:	0007883a 	mov	r3,zero
8110ae00:	00a00034 	movhi	r2,32768
8110ae04:	10824c04 	addi	r2,r2,2352
8110ae08:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae0c:	010003c4 	movi	r4,15
8110ae10:	1131c380 	call	81131c38 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110ae14:	e0bff717 	ldw	r2,-36(fp)
8110ae18:	10800044 	addi	r2,r2,1
8110ae1c:	e0bff715 	stw	r2,-36(fp)
8110ae20:	e0bff717 	ldw	r2,-36(fp)
8110ae24:	10800210 	cmplti	r2,r2,8
8110ae28:	103fe31e 	bne	r2,zero,8110adb8 <__reset+0xfb0eadb8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110ae2c:	e03ff715 	stw	zero,-36(fp)
8110ae30:	00001a06 	br	8110ae9c <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110ae34:	e0bff517 	ldw	r2,-44(fp)
8110ae38:	1085883a 	add	r2,r2,r2
8110ae3c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110ae40:	00a00034 	movhi	r2,32768
8110ae44:	10825404 	addi	r2,r2,2384
8110ae48:	10800037 	ldwio	r2,0(r2)
8110ae4c:	1080004c 	andi	r2,r2,1
8110ae50:	1007883a 	mov	r3,r2
8110ae54:	e0bff517 	ldw	r2,-44(fp)
8110ae58:	10c4b03a 	or	r2,r2,r3
8110ae5c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110ae60:	00c00044 	movi	r3,1
8110ae64:	00a00034 	movhi	r2,32768
8110ae68:	10824c04 	addi	r2,r2,2352
8110ae6c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae70:	010003c4 	movi	r4,15
8110ae74:	1131c380 	call	81131c38 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110ae78:	0007883a 	mov	r3,zero
8110ae7c:	00a00034 	movhi	r2,32768
8110ae80:	10824c04 	addi	r2,r2,2352
8110ae84:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110ae88:	010003c4 	movi	r4,15
8110ae8c:	1131c380 	call	81131c38 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110ae90:	e0bff717 	ldw	r2,-36(fp)
8110ae94:	10800044 	addi	r2,r2,1
8110ae98:	e0bff715 	stw	r2,-36(fp)
8110ae9c:	e0bff717 	ldw	r2,-36(fp)
8110aea0:	10800190 	cmplti	r2,r2,6
8110aea4:	103fe31e 	bne	r2,zero,8110ae34 <__reset+0xfb0eae34>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110aea8:	00c00044 	movi	r3,1
8110aeac:	00a00034 	movhi	r2,32768
8110aeb0:	10824c04 	addi	r2,r2,2352
8110aeb4:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110aeb8:	010003c4 	movi	r4,15
8110aebc:	1131c380 	call	81131c38 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110aec0:	00c000c4 	movi	r3,3
8110aec4:	00a00034 	movhi	r2,32768
8110aec8:	10824804 	addi	r2,r2,2336
8110aecc:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110aed0:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110aed4:	00800044 	movi	r2,1
8110aed8:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110aedc:	e03ff715 	stw	zero,-36(fp)
8110aee0:	00000d06 	br	8110af18 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110aee4:	e0fff517 	ldw	r3,-44(fp)
8110aee8:	e0bff617 	ldw	r2,-40(fp)
8110aeec:	1884703a 	and	r2,r3,r2
8110aef0:	1000031e 	bne	r2,zero,8110af00 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110aef4:	e0bff917 	ldw	r2,-28(fp)
8110aef8:	10800044 	addi	r2,r2,1
8110aefc:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110af00:	e0bff617 	ldw	r2,-40(fp)
8110af04:	1085883a 	add	r2,r2,r2
8110af08:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110af0c:	e0bff717 	ldw	r2,-36(fp)
8110af10:	10800044 	addi	r2,r2,1
8110af14:	e0bff715 	stw	r2,-36(fp)
8110af18:	e0bff717 	ldw	r2,-36(fp)
8110af1c:	10800810 	cmplti	r2,r2,32
8110af20:	103ff01e 	bne	r2,zero,8110aee4 <__reset+0xfb0eaee4>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110af24:	e0bff917 	ldw	r2,-28(fp)
8110af28:	1080004c 	andi	r2,r2,1
8110af2c:	1005003a 	cmpeq	r2,r2,zero
8110af30:	10803fcc 	andi	r2,r2,255
8110af34:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110af38:	e0bffb17 	ldw	r2,-20(fp)
8110af3c:	1000021e 	bne	r2,zero,8110af48 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110af40:	0005883a 	mov	r2,zero
8110af44:	00000406 	br	8110af58 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110af48:	e0800317 	ldw	r2,12(fp)
8110af4c:	e0fff517 	ldw	r3,-44(fp)
8110af50:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110af54:	e0bffb17 	ldw	r2,-20(fp)
}
8110af58:	e037883a 	mov	sp,fp
8110af5c:	dfc00117 	ldw	ra,4(sp)
8110af60:	df000017 	ldw	fp,0(sp)
8110af64:	dec00204 	addi	sp,sp,8
8110af68:	f800283a 	ret

8110af6c <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110af6c:	defffc04 	addi	sp,sp,-16
8110af70:	de00012e 	bgeu	sp,et,8110af78 <vRstcSimucamReset+0xc>
8110af74:	003b68fa 	trap	3
8110af78:	dfc00315 	stw	ra,12(sp)
8110af7c:	df000215 	stw	fp,8(sp)
8110af80:	df000204 	addi	fp,sp,8
8110af84:	2005883a 	mov	r2,r4
8110af88:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110af8c:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110af90:	e0bfff0b 	ldhu	r2,-4(fp)
8110af94:	e0fffe17 	ldw	r3,-8(fp)
8110af98:	1884b03a 	or	r2,r3,r2
8110af9c:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110afa0:	e0bffe17 	ldw	r2,-8(fp)
8110afa4:	10800074 	orhi	r2,r2,1
8110afa8:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110afac:	e1bffe17 	ldw	r6,-8(fp)
8110afb0:	000b883a 	mov	r5,zero
8110afb4:	01200034 	movhi	r4,32768
8110afb8:	21020004 	addi	r4,r4,2048
8110afbc:	110b0bc0 	call	8110b0bc <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110afc0:	0001883a 	nop
8110afc4:	e037883a 	mov	sp,fp
8110afc8:	dfc00117 	ldw	ra,4(sp)
8110afcc:	df000017 	ldw	fp,0(sp)
8110afd0:	dec00204 	addi	sp,sp,8
8110afd4:	f800283a 	ret

8110afd8 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110afd8:	defffc04 	addi	sp,sp,-16
8110afdc:	de00012e 	bgeu	sp,et,8110afe4 <vRstcReleaseDeviceReset+0xc>
8110afe0:	003b68fa 	trap	3
8110afe4:	dfc00315 	stw	ra,12(sp)
8110afe8:	df000215 	stw	fp,8(sp)
8110afec:	df000204 	addi	fp,sp,8
8110aff0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110aff4:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110aff8:	01400044 	movi	r5,1
8110affc:	01200034 	movhi	r4,32768
8110b000:	21020004 	addi	r4,r4,2048
8110b004:	110b1100 	call	8110b110 <uliRstReadReg>
8110b008:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110b00c:	e0bfff17 	ldw	r2,-4(fp)
8110b010:	0084303a 	nor	r2,zero,r2
8110b014:	e0fffe17 	ldw	r3,-8(fp)
8110b018:	1884703a 	and	r2,r3,r2
8110b01c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b020:	e1bffe17 	ldw	r6,-8(fp)
8110b024:	01400044 	movi	r5,1
8110b028:	01200034 	movhi	r4,32768
8110b02c:	21020004 	addi	r4,r4,2048
8110b030:	110b0bc0 	call	8110b0bc <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b034:	0001883a 	nop
8110b038:	e037883a 	mov	sp,fp
8110b03c:	dfc00117 	ldw	ra,4(sp)
8110b040:	df000017 	ldw	fp,0(sp)
8110b044:	dec00204 	addi	sp,sp,8
8110b048:	f800283a 	ret

8110b04c <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110b04c:	defffc04 	addi	sp,sp,-16
8110b050:	de00012e 	bgeu	sp,et,8110b058 <vRstcHoldDeviceReset+0xc>
8110b054:	003b68fa 	trap	3
8110b058:	dfc00315 	stw	ra,12(sp)
8110b05c:	df000215 	stw	fp,8(sp)
8110b060:	df000204 	addi	fp,sp,8
8110b064:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b068:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b06c:	01400044 	movi	r5,1
8110b070:	01200034 	movhi	r4,32768
8110b074:	21020004 	addi	r4,r4,2048
8110b078:	110b1100 	call	8110b110 <uliRstReadReg>
8110b07c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110b080:	e0fffe17 	ldw	r3,-8(fp)
8110b084:	e0bfff17 	ldw	r2,-4(fp)
8110b088:	1884b03a 	or	r2,r3,r2
8110b08c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b090:	e1bffe17 	ldw	r6,-8(fp)
8110b094:	01400044 	movi	r5,1
8110b098:	01200034 	movhi	r4,32768
8110b09c:	21020004 	addi	r4,r4,2048
8110b0a0:	110b0bc0 	call	8110b0bc <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b0a4:	0001883a 	nop
8110b0a8:	e037883a 	mov	sp,fp
8110b0ac:	dfc00117 	ldw	ra,4(sp)
8110b0b0:	df000017 	ldw	fp,0(sp)
8110b0b4:	dec00204 	addi	sp,sp,8
8110b0b8:	f800283a 	ret

8110b0bc <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110b0bc:	defffc04 	addi	sp,sp,-16
8110b0c0:	de00012e 	bgeu	sp,et,8110b0c8 <vRstcWriteReg+0xc>
8110b0c4:	003b68fa 	trap	3
8110b0c8:	df000315 	stw	fp,12(sp)
8110b0cc:	df000304 	addi	fp,sp,12
8110b0d0:	e13ffd15 	stw	r4,-12(fp)
8110b0d4:	e17ffe15 	stw	r5,-8(fp)
8110b0d8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110b0dc:	e0bffe17 	ldw	r2,-8(fp)
8110b0e0:	1085883a 	add	r2,r2,r2
8110b0e4:	1085883a 	add	r2,r2,r2
8110b0e8:	1007883a 	mov	r3,r2
8110b0ec:	e0bffd17 	ldw	r2,-12(fp)
8110b0f0:	10c5883a 	add	r2,r2,r3
8110b0f4:	e0ffff17 	ldw	r3,-4(fp)
8110b0f8:	10c00015 	stw	r3,0(r2)
}
8110b0fc:	0001883a 	nop
8110b100:	e037883a 	mov	sp,fp
8110b104:	df000017 	ldw	fp,0(sp)
8110b108:	dec00104 	addi	sp,sp,4
8110b10c:	f800283a 	ret

8110b110 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110b110:	defffc04 	addi	sp,sp,-16
8110b114:	de00012e 	bgeu	sp,et,8110b11c <uliRstReadReg+0xc>
8110b118:	003b68fa 	trap	3
8110b11c:	df000315 	stw	fp,12(sp)
8110b120:	df000304 	addi	fp,sp,12
8110b124:	e13ffe15 	stw	r4,-8(fp)
8110b128:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110b12c:	e0bfff17 	ldw	r2,-4(fp)
8110b130:	1085883a 	add	r2,r2,r2
8110b134:	1085883a 	add	r2,r2,r2
8110b138:	1007883a 	mov	r3,r2
8110b13c:	e0bffe17 	ldw	r2,-8(fp)
8110b140:	10c5883a 	add	r2,r2,r3
8110b144:	10800017 	ldw	r2,0(r2)
8110b148:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110b14c:	e0bffd17 	ldw	r2,-12(fp)
}
8110b150:	e037883a 	mov	sp,fp
8110b154:	df000017 	ldw	fp,0(sp)
8110b158:	dec00104 	addi	sp,sp,4
8110b15c:	f800283a 	ret

8110b160 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110b160:	defffe04 	addi	sp,sp,-8
8110b164:	de00012e 	bgeu	sp,et,8110b16c <v_spi_start+0xc>
8110b168:	003b68fa 	trap	3
8110b16c:	dfc00115 	stw	ra,4(sp)
8110b170:	df000015 	stw	fp,0(sp)
8110b174:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110b178:	0007883a 	mov	r3,zero
8110b17c:	00a00034 	movhi	r2,32768
8110b180:	10823004 	addi	r2,r2,2240
8110b184:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110b188:	0007883a 	mov	r3,zero
8110b18c:	00a00034 	movhi	r2,32768
8110b190:	10822c04 	addi	r2,r2,2224
8110b194:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b198:	01002584 	movi	r4,150
8110b19c:	1131c380 	call	81131c38 <usleep>
}
8110b1a0:	0001883a 	nop
8110b1a4:	e037883a 	mov	sp,fp
8110b1a8:	dfc00117 	ldw	ra,4(sp)
8110b1ac:	df000017 	ldw	fp,0(sp)
8110b1b0:	dec00204 	addi	sp,sp,8
8110b1b4:	f800283a 	ret

8110b1b8 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110b1b8:	defffc04 	addi	sp,sp,-16
8110b1bc:	de00012e 	bgeu	sp,et,8110b1c4 <v_spi_send_byte+0xc>
8110b1c0:	003b68fa 	trap	3
8110b1c4:	dfc00315 	stw	ra,12(sp)
8110b1c8:	df000215 	stw	fp,8(sp)
8110b1cc:	df000204 	addi	fp,sp,8
8110b1d0:	2005883a 	mov	r2,r4
8110b1d4:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110b1d8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110b1dc:	00bfe004 	movi	r2,-128
8110b1e0:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110b1e4:	e03ffe05 	stb	zero,-8(fp)
8110b1e8:	00001b06 	br	8110b258 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110b1ec:	e0ffff03 	ldbu	r3,-4(fp)
8110b1f0:	e0bffe43 	ldbu	r2,-7(fp)
8110b1f4:	1884703a 	and	r2,r3,r2
8110b1f8:	10803fcc 	andi	r2,r2,255
8110b1fc:	1004c03a 	cmpne	r2,r2,zero
8110b200:	10c03fcc 	andi	r3,r2,255
8110b204:	00a00034 	movhi	r2,32768
8110b208:	10823404 	addi	r2,r2,2256
8110b20c:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110b210:	e0bffe43 	ldbu	r2,-7(fp)
8110b214:	1004d07a 	srli	r2,r2,1
8110b218:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b21c:	00c00044 	movi	r3,1
8110b220:	00a00034 	movhi	r2,32768
8110b224:	10823004 	addi	r2,r2,2240
8110b228:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b22c:	01002584 	movi	r4,150
8110b230:	1131c380 	call	81131c38 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b234:	0007883a 	mov	r3,zero
8110b238:	00a00034 	movhi	r2,32768
8110b23c:	10823004 	addi	r2,r2,2240
8110b240:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b244:	01002584 	movi	r4,150
8110b248:	1131c380 	call	81131c38 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110b24c:	e0bffe03 	ldbu	r2,-8(fp)
8110b250:	10800044 	addi	r2,r2,1
8110b254:	e0bffe05 	stb	r2,-8(fp)
8110b258:	e0bffe03 	ldbu	r2,-8(fp)
8110b25c:	10800230 	cmpltui	r2,r2,8
8110b260:	103fe21e 	bne	r2,zero,8110b1ec <__reset+0xfb0eb1ec>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110b264:	0001883a 	nop
8110b268:	e037883a 	mov	sp,fp
8110b26c:	dfc00117 	ldw	ra,4(sp)
8110b270:	df000017 	ldw	fp,0(sp)
8110b274:	dec00204 	addi	sp,sp,8
8110b278:	f800283a 	ret

8110b27c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110b27c:	defffd04 	addi	sp,sp,-12
8110b280:	de00012e 	bgeu	sp,et,8110b288 <uc_spi_get_byte+0xc>
8110b284:	003b68fa 	trap	3
8110b288:	dfc00215 	stw	ra,8(sp)
8110b28c:	df000115 	stw	fp,4(sp)
8110b290:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110b294:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110b298:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110b29c:	e03fff05 	stb	zero,-4(fp)
8110b2a0:	00001a06 	br	8110b30c <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110b2a4:	e0bfff43 	ldbu	r2,-3(fp)
8110b2a8:	1085883a 	add	r2,r2,r2
8110b2ac:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110b2b0:	00a00034 	movhi	r2,32768
8110b2b4:	10823804 	addi	r2,r2,2272
8110b2b8:	10800037 	ldwio	r2,0(r2)
8110b2bc:	1080004c 	andi	r2,r2,1
8110b2c0:	1007883a 	mov	r3,r2
8110b2c4:	e0bfff43 	ldbu	r2,-3(fp)
8110b2c8:	1884b03a 	or	r2,r3,r2
8110b2cc:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b2d0:	00c00044 	movi	r3,1
8110b2d4:	00a00034 	movhi	r2,32768
8110b2d8:	10823004 	addi	r2,r2,2240
8110b2dc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b2e0:	01002584 	movi	r4,150
8110b2e4:	1131c380 	call	81131c38 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b2e8:	0007883a 	mov	r3,zero
8110b2ec:	00a00034 	movhi	r2,32768
8110b2f0:	10823004 	addi	r2,r2,2240
8110b2f4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b2f8:	01002584 	movi	r4,150
8110b2fc:	1131c380 	call	81131c38 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110b300:	e0bfff03 	ldbu	r2,-4(fp)
8110b304:	10800044 	addi	r2,r2,1
8110b308:	e0bfff05 	stb	r2,-4(fp)
8110b30c:	e0bfff03 	ldbu	r2,-4(fp)
8110b310:	10800230 	cmpltui	r2,r2,8
8110b314:	103fe31e 	bne	r2,zero,8110b2a4 <__reset+0xfb0eb2a4>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110b318:	e0bfff43 	ldbu	r2,-3(fp)
}
8110b31c:	e037883a 	mov	sp,fp
8110b320:	dfc00117 	ldw	ra,4(sp)
8110b324:	df000017 	ldw	fp,0(sp)
8110b328:	dec00204 	addi	sp,sp,8
8110b32c:	f800283a 	ret

8110b330 <v_spi_end>:

void v_spi_end(void){
8110b330:	defffe04 	addi	sp,sp,-8
8110b334:	de00012e 	bgeu	sp,et,8110b33c <v_spi_end+0xc>
8110b338:	003b68fa 	trap	3
8110b33c:	dfc00115 	stw	ra,4(sp)
8110b340:	df000015 	stw	fp,0(sp)
8110b344:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110b348:	0007883a 	mov	r3,zero
8110b34c:	00a00034 	movhi	r2,32768
8110b350:	10823004 	addi	r2,r2,2240
8110b354:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b358:	01002584 	movi	r4,150
8110b35c:	1131c380 	call	81131c38 <usleep>
    SPI_CS_N(1);
8110b360:	00c00044 	movi	r3,1
8110b364:	00a00034 	movhi	r2,32768
8110b368:	10822c04 	addi	r2,r2,2224
8110b36c:	10c00035 	stwio	r3,0(r2)
}
8110b370:	0001883a 	nop
8110b374:	e037883a 	mov	sp,fp
8110b378:	dfc00117 	ldw	ra,4(sp)
8110b37c:	df000017 	ldw	fp,0(sp)
8110b380:	dec00204 	addi	sp,sp,8
8110b384:	f800283a 	ret

8110b388 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110b388:	defff604 	addi	sp,sp,-40
8110b38c:	de00012e 	bgeu	sp,et,8110b394 <RTCC_SPI_R_MAC+0xc>
8110b390:	003b68fa 	trap	3
8110b394:	dfc00915 	stw	ra,36(sp)
8110b398:	df000815 	stw	fp,32(sp)
8110b39c:	df000804 	addi	fp,sp,32
8110b3a0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b3a4:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110b3a8:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110b3ac:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110b3b0:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110b3b4:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110b3b8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110b3bc:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110b3c0:	00800084 	movi	r2,2
8110b3c4:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110b3c8:	00800cc4 	movi	r2,51
8110b3cc:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110b3d0:	110b1600 	call	8110b160 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110b3d4:	e0bffec3 	ldbu	r2,-5(fp)
8110b3d8:	1009883a 	mov	r4,r2
8110b3dc:	110b1b80 	call	8110b1b8 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110b3e0:	e0bffe83 	ldbu	r2,-6(fp)
8110b3e4:	1009883a 	mov	r4,r2
8110b3e8:	110b1b80 	call	8110b1b8 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110b3ec:	110b27c0 	call	8110b27c <uc_spi_get_byte>
8110b3f0:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110b3f4:	110b27c0 	call	8110b27c <uc_spi_get_byte>
8110b3f8:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110b3fc:	110b27c0 	call	8110b27c <uc_spi_get_byte>
8110b400:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110b404:	110b27c0 	call	8110b27c <uc_spi_get_byte>
8110b408:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110b40c:	110b27c0 	call	8110b27c <uc_spi_get_byte>
8110b410:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110b414:	110b27c0 	call	8110b27c <uc_spi_get_byte>
8110b418:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110b41c:	110b3300 	call	8110b330 <v_spi_end>

    bSuccess = TRUE;
8110b420:	00800044 	movi	r2,1
8110b424:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110b428:	e0bfff17 	ldw	r2,-4(fp)
8110b42c:	e0fffd03 	ldbu	r3,-12(fp)
8110b430:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110b434:	e0bfff17 	ldw	r2,-4(fp)
8110b438:	10800044 	addi	r2,r2,1
8110b43c:	e0fffd43 	ldbu	r3,-11(fp)
8110b440:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110b444:	e0bfff17 	ldw	r2,-4(fp)
8110b448:	10800084 	addi	r2,r2,2
8110b44c:	e0fffd83 	ldbu	r3,-10(fp)
8110b450:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110b454:	e0bfff17 	ldw	r2,-4(fp)
8110b458:	108000c4 	addi	r2,r2,3
8110b45c:	e0fffdc3 	ldbu	r3,-9(fp)
8110b460:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110b464:	e0bfff17 	ldw	r2,-4(fp)
8110b468:	10800104 	addi	r2,r2,4
8110b46c:	e0fffe03 	ldbu	r3,-8(fp)
8110b470:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110b474:	e0bfff17 	ldw	r2,-4(fp)
8110b478:	10800144 	addi	r2,r2,5
8110b47c:	e0fffe43 	ldbu	r3,-7(fp)
8110b480:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110b484:	e1bffd03 	ldbu	r6,-12(fp)
8110b488:	e1fffd43 	ldbu	r7,-11(fp)
8110b48c:	e0bffd83 	ldbu	r2,-10(fp)
8110b490:	e0fffdc3 	ldbu	r3,-9(fp)
8110b494:	e13ffe03 	ldbu	r4,-8(fp)
8110b498:	e17ffe43 	ldbu	r5,-7(fp)
8110b49c:	d9400315 	stw	r5,12(sp)
8110b4a0:	d9000215 	stw	r4,8(sp)
8110b4a4:	d8c00115 	stw	r3,4(sp)
8110b4a8:	d8800015 	stw	r2,0(sp)
8110b4ac:	01604534 	movhi	r5,33044
8110b4b0:	2958c604 	addi	r5,r5,25368
8110b4b4:	01204574 	movhi	r4,33045
8110b4b8:	2131a904 	addi	r4,r4,-14684
8110b4bc:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
8110b4c0:	d0a05f17 	ldw	r2,-32388(gp)
8110b4c4:	01604574 	movhi	r5,33045
8110b4c8:	2971a904 	addi	r5,r5,-14684
8110b4cc:	1009883a 	mov	r4,r2
8110b4d0:	111a9600 	call	8111a960 <fprintf>
#endif

    return bSuccess;
8110b4d4:	e0bffc17 	ldw	r2,-16(fp)
}
8110b4d8:	e037883a 	mov	sp,fp
8110b4dc:	dfc00117 	ldw	ra,4(sp)
8110b4e0:	df000017 	ldw	fp,0(sp)
8110b4e4:	dec00204 	addi	sp,sp,8
8110b4e8:	f800283a 	ret

8110b4ec <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110b4ec:	defffd04 	addi	sp,sp,-12
8110b4f0:	de00012e 	bgeu	sp,et,8110b4f8 <bSSDisplayConfig+0xc>
8110b4f4:	003b68fa 	trap	3
8110b4f8:	df000215 	stw	fp,8(sp)
8110b4fc:	df000204 	addi	fp,sp,8
8110b500:	2005883a 	mov	r2,r4
8110b504:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110b508:	e0bfff03 	ldbu	r2,-4(fp)
8110b50c:	10c00168 	cmpgeui	r3,r2,5
8110b510:	18001c1e 	bne	r3,zero,8110b584 <bSSDisplayConfig+0x98>
8110b514:	100690ba 	slli	r3,r2,2
8110b518:	00a04474 	movhi	r2,33041
8110b51c:	10ad4b04 	addi	r2,r2,-19156
8110b520:	1885883a 	add	r2,r3,r2
8110b524:	10800017 	ldw	r2,0(r2)
8110b528:	1000683a 	jmp	r2
8110b52c:	8110b540 	call	88110b54 <__reset+0x20f0b54>
8110b530:	8110b54c 	andi	r4,r16,17109
8110b534:	8110b558 	cmpnei	r4,r16,17109
8110b538:	8110b56c 	andhi	r4,r16,17109
8110b53c:	8110b57c 	xorhi	r4,r16,17109
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110b540:	00800cc4 	movi	r2,51
8110b544:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b548:	00001006 	br	8110b58c <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110b54c:	00801544 	movi	r2,85
8110b550:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b554:	00000d06 	br	8110b58c <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110b558:	d0e04e43 	ldbu	r3,-32455(gp)
8110b55c:	00bff744 	movi	r2,-35
8110b560:	1884703a 	and	r2,r3,r2
8110b564:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b568:	00000806 	br	8110b58c <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110b56c:	d0a04e43 	ldbu	r2,-32455(gp)
8110b570:	10800894 	ori	r2,r2,34
8110b574:	d0a04e45 	stb	r2,-32455(gp)
	    break;
8110b578:	00000406 	br	8110b58c <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110b57c:	d0204e45 	stb	zero,-32455(gp)
	    break;
8110b580:	00000206 	br	8110b58c <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110b584:	0005883a 	mov	r2,zero
8110b588:	00000806 	br	8110b5ac <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b58c:	00a00034 	movhi	r2,32768
8110b590:	10828404 	addi	r2,r2,2576
8110b594:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110b598:	d0a04e43 	ldbu	r2,-32455(gp)
8110b59c:	10c03fcc 	andi	r3,r2,255
8110b5a0:	e0bffe17 	ldw	r2,-8(fp)
8110b5a4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b5a8:	00800044 	movi	r2,1
}
8110b5ac:	e037883a 	mov	sp,fp
8110b5b0:	df000017 	ldw	fp,0(sp)
8110b5b4:	dec00104 	addi	sp,sp,4
8110b5b8:	f800283a 	ret

8110b5bc <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110b5bc:	defffd04 	addi	sp,sp,-12
8110b5c0:	de00012e 	bgeu	sp,et,8110b5c8 <bSSDisplayUpdate+0xc>
8110b5c4:	003b68fa 	trap	3
8110b5c8:	df000215 	stw	fp,8(sp)
8110b5cc:	df000204 	addi	fp,sp,8
8110b5d0:	2005883a 	mov	r2,r4
8110b5d4:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b5d8:	00a00034 	movhi	r2,32768
8110b5dc:	10828404 	addi	r2,r2,2576
8110b5e0:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110b5e4:	e0bffe17 	ldw	r2,-8(fp)
8110b5e8:	10800104 	addi	r2,r2,4
8110b5ec:	e0ffff03 	ldbu	r3,-4(fp)
8110b5f0:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b5f4:	00800044 	movi	r2,1
}
8110b5f8:	e037883a 	mov	sp,fp
8110b5fc:	df000017 	ldw	fp,0(sp)
8110b600:	dec00104 	addi	sp,sp,4
8110b604:	f800283a 	ret

8110b608 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110b608:	defff904 	addi	sp,sp,-28
8110b60c:	de00012e 	bgeu	sp,et,8110b614 <vSyncHandleIrq+0xc>
8110b610:	003b68fa 	trap	3
8110b614:	dfc00615 	stw	ra,24(sp)
8110b618:	df000515 	stw	fp,20(sp)
8110b61c:	df000504 	addi	fp,sp,20
8110b620:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;


	uiCmdtoSend.ucByte[2] = M_FEE_SYNC;
8110b624:	00bfe004 	movi	r2,-128
8110b628:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110b62c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 0;
8110b630:	e03ffe05 	stb	zero,-8(fp)
	// Cast pvContext to viHoldContext's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110b634:	e0bfff17 	ldw	r2,-4(fp)
8110b638:	e0bffc15 	stw	r2,-16(fp)
	// Use pvContext value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b63c:	e03ffb05 	stb	zero,-20(fp)
8110b640:	00001f06 	br	8110b6c0 <vSyncHandleIrq+0xb8>

		if ( xSimMeb.xFeeControl.xNfee[ucIL].xControl.bWatingSync == TRUE ) {
8110b644:	e0fffb03 	ldbu	r3,-20(fp)
8110b648:	00a04574 	movhi	r2,33045
8110b64c:	1087e504 	addi	r2,r2,8084
8110b650:	18c09224 	muli	r3,r3,584
8110b654:	10c5883a 	add	r2,r2,r3
8110b658:	10803604 	addi	r2,r2,216
8110b65c:	10800017 	ldw	r2,0(r2)
8110b660:	10800058 	cmpnei	r2,r2,1
8110b664:	1000131e 	bne	r2,zero,8110b6b4 <vSyncHandleIrq+0xac>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110b668:	e0bffb03 	ldbu	r2,-20(fp)
8110b66c:	10800444 	addi	r2,r2,17
8110b670:	e0bffec5 	stb	r2,-5(fp)

			error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110b674:	e0bffb03 	ldbu	r2,-20(fp)
8110b678:	1085883a 	add	r2,r2,r2
8110b67c:	1087883a 	add	r3,r2,r2
8110b680:	d0a05804 	addi	r2,gp,-32416
8110b684:	1885883a 	add	r2,r3,r2
8110b688:	10800017 	ldw	r2,0(r2)
8110b68c:	e0fffe17 	ldw	r3,-8(fp)
8110b690:	180b883a 	mov	r5,r3
8110b694:	1009883a 	mov	r4,r2
8110b698:	1137f4c0 	call	81137f4c <OSQPost>
8110b69c:	e0bffd05 	stb	r2,-12(fp)
			if ( error_codel != OS_ERR_NONE ) {
8110b6a0:	e0bffd03 	ldbu	r2,-12(fp)
8110b6a4:	10000326 	beq	r2,zero,8110b6b4 <vSyncHandleIrq+0xac>
				vFailSendMsgSync( ucIL );
8110b6a8:	e0bffb03 	ldbu	r2,-20(fp)
8110b6ac:	1009883a 	mov	r4,r2
8110b6b0:	11178380 	call	81117838 <vFailSendMsgSync>
	// Use pvContext value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110b6b4:	e0bffb03 	ldbu	r2,-20(fp)
8110b6b8:	10800044 	addi	r2,r2,1
8110b6bc:	e0bffb05 	stb	r2,-20(fp)
8110b6c0:	e0bffb03 	ldbu	r2,-20(fp)
8110b6c4:	103fdf26 	beq	r2,zero,8110b644 <__reset+0xfb0eb644>
				vFailSendMsgSync( ucIL );
			}
		}
	}

	vucN += 1;
8110b6c8:	d0a05103 	ldbu	r2,-32444(gp)
8110b6cc:	10800044 	addi	r2,r2,1
8110b6d0:	d0a05105 	stb	r2,-32444(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync N=%hu \n", vucN);
8110b6d4:	d0a05f17 	ldw	r2,-32388(gp)
8110b6d8:	d0e05103 	ldbu	r3,-32444(gp)
8110b6dc:	18c03fcc 	andi	r3,r3,255
8110b6e0:	180d883a 	mov	r6,r3
8110b6e4:	01604534 	movhi	r5,33044
8110b6e8:	2958d504 	addi	r5,r5,25428
8110b6ec:	1009883a 	mov	r4,r2
8110b6f0:	111a9600 	call	8111a960 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110b6f4:	110b75c0 	call	8110b75c <vSyncIrqFlagClrSync>

}
8110b6f8:	0001883a 	nop
8110b6fc:	e037883a 	mov	sp,fp
8110b700:	dfc00117 	ldw	ra,4(sp)
8110b704:	df000017 	ldw	fp,0(sp)
8110b708:	dec00204 	addi	sp,sp,8
8110b70c:	f800283a 	ret

8110b710 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110b710:	defffd04 	addi	sp,sp,-12
8110b714:	de00012e 	bgeu	sp,et,8110b71c <vSyncInitIrq+0xc>
8110b718:	003b68fa 	trap	3
8110b71c:	dfc00215 	stw	ra,8(sp)
8110b720:	df000115 	stw	fp,4(sp)
8110b724:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110b728:	d0a04f04 	addi	r2,gp,-32452
8110b72c:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110b730:	01a04474 	movhi	r6,33041
8110b734:	31ad8204 	addi	r6,r6,-18936
8110b738:	e17fff17 	ldw	r5,-4(fp)
8110b73c:	01000284 	movi	r4,10
8110b740:	11305680 	call	81130568 <alt_irq_register>
}
8110b744:	0001883a 	nop
8110b748:	e037883a 	mov	sp,fp
8110b74c:	dfc00117 	ldw	ra,4(sp)
8110b750:	df000017 	ldw	fp,0(sp)
8110b754:	dec00204 	addi	sp,sp,8
8110b758:	f800283a 	ret

8110b75c <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110b75c:	defffe04 	addi	sp,sp,-8
8110b760:	de00012e 	bgeu	sp,et,8110b768 <vSyncIrqFlagClrSync+0xc>
8110b764:	003b68fa 	trap	3
8110b768:	dfc00115 	stw	ra,4(sp)
8110b76c:	df000015 	stw	fp,0(sp)
8110b770:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110b774:	01400044 	movi	r5,1
8110b778:	010002c4 	movi	r4,11
8110b77c:	110c53c0 	call	8110c53c <bSyncWriteReg>
}
8110b780:	0001883a 	nop
8110b784:	e037883a 	mov	sp,fp
8110b788:	dfc00117 	ldw	ra,4(sp)
8110b78c:	df000017 	ldw	fp,0(sp)
8110b790:	dec00204 	addi	sp,sp,8
8110b794:	f800283a 	ret

8110b798 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110b798:	defffd04 	addi	sp,sp,-12
8110b79c:	de00012e 	bgeu	sp,et,8110b7a4 <bSyncIrqFlagSync+0xc>
8110b7a0:	003b68fa 	trap	3
8110b7a4:	dfc00215 	stw	ra,8(sp)
8110b7a8:	df000115 	stw	fp,4(sp)
8110b7ac:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110b7b0:	01000304 	movi	r4,12
8110b7b4:	110c5980 	call	8110c598 <uliSyncReadReg>
8110b7b8:	1080004c 	andi	r2,r2,1
8110b7bc:	10000326 	beq	r2,zero,8110b7cc <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110b7c0:	00800044 	movi	r2,1
8110b7c4:	e0bfff15 	stw	r2,-4(fp)
8110b7c8:	00000106 	br	8110b7d0 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110b7cc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110b7d0:	e0bfff17 	ldw	r2,-4(fp)
}
8110b7d4:	e037883a 	mov	sp,fp
8110b7d8:	dfc00117 	ldw	ra,4(sp)
8110b7dc:	df000017 	ldw	fp,0(sp)
8110b7e0:	dec00204 	addi	sp,sp,8
8110b7e4:	f800283a 	ret

8110b7e8 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110b7e8:	defffc04 	addi	sp,sp,-16
8110b7ec:	de00012e 	bgeu	sp,et,8110b7f4 <bSyncStatusExtnIrq+0xc>
8110b7f0:	003b68fa 	trap	3
8110b7f4:	dfc00315 	stw	ra,12(sp)
8110b7f8:	df000215 	stw	fp,8(sp)
8110b7fc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b800:	0009883a 	mov	r4,zero
8110b804:	110c5980 	call	8110c598 <uliSyncReadReg>
8110b808:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110b80c:	e0bfff17 	ldw	r2,-4(fp)
8110b810:	1000030e 	bge	r2,zero,8110b820 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110b814:	00800044 	movi	r2,1
8110b818:	e0bffe15 	stw	r2,-8(fp)
8110b81c:	00000106 	br	8110b824 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110b820:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110b824:	e0bffe17 	ldw	r2,-8(fp)
}
8110b828:	e037883a 	mov	sp,fp
8110b82c:	dfc00117 	ldw	ra,4(sp)
8110b830:	df000017 	ldw	fp,0(sp)
8110b834:	dec00204 	addi	sp,sp,8
8110b838:	f800283a 	ret

8110b83c <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110b83c:	defffc04 	addi	sp,sp,-16
8110b840:	de00012e 	bgeu	sp,et,8110b848 <ucSyncStatusState+0xc>
8110b844:	003b68fa 	trap	3
8110b848:	dfc00315 	stw	ra,12(sp)
8110b84c:	df000215 	stw	fp,8(sp)
8110b850:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b854:	0009883a 	mov	r4,zero
8110b858:	110c5980 	call	8110c598 <uliSyncReadReg>
8110b85c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110b860:	e0bffe17 	ldw	r2,-8(fp)
8110b864:	10803fec 	andhi	r2,r2,255
8110b868:	1004d43a 	srli	r2,r2,16
8110b86c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110b870:	e0bfff03 	ldbu	r2,-4(fp)
}
8110b874:	e037883a 	mov	sp,fp
8110b878:	dfc00117 	ldw	ra,4(sp)
8110b87c:	df000017 	ldw	fp,0(sp)
8110b880:	dec00204 	addi	sp,sp,8
8110b884:	f800283a 	ret

8110b888 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110b888:	defffc04 	addi	sp,sp,-16
8110b88c:	de00012e 	bgeu	sp,et,8110b894 <ucSyncStatusErrorCode+0xc>
8110b890:	003b68fa 	trap	3
8110b894:	dfc00315 	stw	ra,12(sp)
8110b898:	df000215 	stw	fp,8(sp)
8110b89c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b8a0:	0009883a 	mov	r4,zero
8110b8a4:	110c5980 	call	8110c598 <uliSyncReadReg>
8110b8a8:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110b8ac:	e0bffe17 	ldw	r2,-8(fp)
8110b8b0:	10bfc00c 	andi	r2,r2,65280
8110b8b4:	1004d23a 	srli	r2,r2,8
8110b8b8:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110b8bc:	e0bfff03 	ldbu	r2,-4(fp)
}
8110b8c0:	e037883a 	mov	sp,fp
8110b8c4:	dfc00117 	ldw	ra,4(sp)
8110b8c8:	df000017 	ldw	fp,0(sp)
8110b8cc:	dec00204 	addi	sp,sp,8
8110b8d0:	f800283a 	ret

8110b8d4 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110b8d4:	defffc04 	addi	sp,sp,-16
8110b8d8:	de00012e 	bgeu	sp,et,8110b8e0 <ucSyncStatusCycleNumber+0xc>
8110b8dc:	003b68fa 	trap	3
8110b8e0:	dfc00315 	stw	ra,12(sp)
8110b8e4:	df000215 	stw	fp,8(sp)
8110b8e8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110b8ec:	0009883a 	mov	r4,zero
8110b8f0:	110c5980 	call	8110c598 <uliSyncReadReg>
8110b8f4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110b8f8:	e0bffe17 	ldw	r2,-8(fp)
8110b8fc:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110b900:	e0bfff03 	ldbu	r2,-4(fp)
}
8110b904:	e037883a 	mov	sp,fp
8110b908:	dfc00117 	ldw	ra,4(sp)
8110b90c:	df000017 	ldw	fp,0(sp)
8110b910:	dec00204 	addi	sp,sp,8
8110b914:	f800283a 	ret

8110b918 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110b918:	defffd04 	addi	sp,sp,-12
8110b91c:	de00012e 	bgeu	sp,et,8110b924 <bSyncSetMbt+0xc>
8110b920:	003b68fa 	trap	3
8110b924:	dfc00215 	stw	ra,8(sp)
8110b928:	df000115 	stw	fp,4(sp)
8110b92c:	df000104 	addi	fp,sp,4
8110b930:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110b934:	e17fff17 	ldw	r5,-4(fp)
8110b938:	01000104 	movi	r4,4
8110b93c:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110b940:	00800044 	movi	r2,1
}
8110b944:	e037883a 	mov	sp,fp
8110b948:	dfc00117 	ldw	ra,4(sp)
8110b94c:	df000017 	ldw	fp,0(sp)
8110b950:	dec00204 	addi	sp,sp,8
8110b954:	f800283a 	ret

8110b958 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110b958:	defffd04 	addi	sp,sp,-12
8110b95c:	de00012e 	bgeu	sp,et,8110b964 <bSyncSetBt+0xc>
8110b960:	003b68fa 	trap	3
8110b964:	dfc00215 	stw	ra,8(sp)
8110b968:	df000115 	stw	fp,4(sp)
8110b96c:	df000104 	addi	fp,sp,4
8110b970:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110b974:	e17fff17 	ldw	r5,-4(fp)
8110b978:	01000144 	movi	r4,5
8110b97c:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110b980:	00800044 	movi	r2,1
}
8110b984:	e037883a 	mov	sp,fp
8110b988:	dfc00117 	ldw	ra,4(sp)
8110b98c:	df000017 	ldw	fp,0(sp)
8110b990:	dec00204 	addi	sp,sp,8
8110b994:	f800283a 	ret

8110b998 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110b998:	defffd04 	addi	sp,sp,-12
8110b99c:	de00012e 	bgeu	sp,et,8110b9a4 <bSyncSetPer+0xc>
8110b9a0:	003b68fa 	trap	3
8110b9a4:	dfc00215 	stw	ra,8(sp)
8110b9a8:	df000115 	stw	fp,4(sp)
8110b9ac:	df000104 	addi	fp,sp,4
8110b9b0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110b9b4:	e17fff17 	ldw	r5,-4(fp)
8110b9b8:	01000184 	movi	r4,6
8110b9bc:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110b9c0:	00800044 	movi	r2,1
}
8110b9c4:	e037883a 	mov	sp,fp
8110b9c8:	dfc00117 	ldw	ra,4(sp)
8110b9cc:	df000017 	ldw	fp,0(sp)
8110b9d0:	dec00204 	addi	sp,sp,8
8110b9d4:	f800283a 	ret

8110b9d8 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110b9d8:	defffd04 	addi	sp,sp,-12
8110b9dc:	de00012e 	bgeu	sp,et,8110b9e4 <bSyncSetOst+0xc>
8110b9e0:	003b68fa 	trap	3
8110b9e4:	dfc00215 	stw	ra,8(sp)
8110b9e8:	df000115 	stw	fp,4(sp)
8110b9ec:	df000104 	addi	fp,sp,4
8110b9f0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110b9f4:	e17fff17 	ldw	r5,-4(fp)
8110b9f8:	010001c4 	movi	r4,7
8110b9fc:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110ba00:	00800044 	movi	r2,1
}
8110ba04:	e037883a 	mov	sp,fp
8110ba08:	dfc00117 	ldw	ra,4(sp)
8110ba0c:	df000017 	ldw	fp,0(sp)
8110ba10:	dec00204 	addi	sp,sp,8
8110ba14:	f800283a 	ret

8110ba18 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110ba18:	defffc04 	addi	sp,sp,-16
8110ba1c:	de00012e 	bgeu	sp,et,8110ba24 <bSyncSetPolarity+0xc>
8110ba20:	003b68fa 	trap	3
8110ba24:	dfc00315 	stw	ra,12(sp)
8110ba28:	df000215 	stw	fp,8(sp)
8110ba2c:	df000204 	addi	fp,sp,8
8110ba30:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ba34:	01000204 	movi	r4,8
8110ba38:	110c5980 	call	8110c598 <uliSyncReadReg>
8110ba3c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ba40:	e0bfff17 	ldw	r2,-4(fp)
8110ba44:	1000051e 	bne	r2,zero,8110ba5c <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ba48:	e0fffe17 	ldw	r3,-8(fp)
8110ba4c:	00bfbfc4 	movi	r2,-257
8110ba50:	1884703a 	and	r2,r3,r2
8110ba54:	e0bffe15 	stw	r2,-8(fp)
8110ba58:	00000306 	br	8110ba68 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110ba5c:	e0bffe17 	ldw	r2,-8(fp)
8110ba60:	10804014 	ori	r2,r2,256
8110ba64:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ba68:	e17ffe17 	ldw	r5,-8(fp)
8110ba6c:	01000204 	movi	r4,8
8110ba70:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110ba74:	00800044 	movi	r2,1
}
8110ba78:	e037883a 	mov	sp,fp
8110ba7c:	dfc00117 	ldw	ra,4(sp)
8110ba80:	df000017 	ldw	fp,0(sp)
8110ba84:	dec00204 	addi	sp,sp,8
8110ba88:	f800283a 	ret

8110ba8c <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110ba8c:	defffc04 	addi	sp,sp,-16
8110ba90:	de00012e 	bgeu	sp,et,8110ba98 <bSyncSetNCycles+0xc>
8110ba94:	003b68fa 	trap	3
8110ba98:	dfc00315 	stw	ra,12(sp)
8110ba9c:	df000215 	stw	fp,8(sp)
8110baa0:	df000204 	addi	fp,sp,8
8110baa4:	2005883a 	mov	r2,r4
8110baa8:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110baac:	01000204 	movi	r4,8
8110bab0:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bab4:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110bab8:	e0fffe17 	ldw	r3,-8(fp)
8110babc:	00bfc004 	movi	r2,-256
8110bac0:	1884703a 	and	r2,r3,r2
8110bac4:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110bac8:	e0bfff03 	ldbu	r2,-4(fp)
8110bacc:	e0fffe17 	ldw	r3,-8(fp)
8110bad0:	1884b03a 	or	r2,r3,r2
8110bad4:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110bad8:	e17ffe17 	ldw	r5,-8(fp)
8110badc:	01000204 	movi	r4,8
8110bae0:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bae4:	00800044 	movi	r2,1
}
8110bae8:	e037883a 	mov	sp,fp
8110baec:	dfc00117 	ldw	ra,4(sp)
8110baf0:	df000017 	ldw	fp,0(sp)
8110baf4:	dec00204 	addi	sp,sp,8
8110baf8:	f800283a 	ret

8110bafc <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110bafc:	defffd04 	addi	sp,sp,-12
8110bb00:	de00012e 	bgeu	sp,et,8110bb08 <uliSyncGetMbt+0xc>
8110bb04:	003b68fa 	trap	3
8110bb08:	dfc00215 	stw	ra,8(sp)
8110bb0c:	df000115 	stw	fp,4(sp)
8110bb10:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110bb14:	01000104 	movi	r4,4
8110bb18:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bb1c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bb20:	e0bfff17 	ldw	r2,-4(fp)
}
8110bb24:	e037883a 	mov	sp,fp
8110bb28:	dfc00117 	ldw	ra,4(sp)
8110bb2c:	df000017 	ldw	fp,0(sp)
8110bb30:	dec00204 	addi	sp,sp,8
8110bb34:	f800283a 	ret

8110bb38 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110bb38:	defffd04 	addi	sp,sp,-12
8110bb3c:	de00012e 	bgeu	sp,et,8110bb44 <uliSyncGetBt+0xc>
8110bb40:	003b68fa 	trap	3
8110bb44:	dfc00215 	stw	ra,8(sp)
8110bb48:	df000115 	stw	fp,4(sp)
8110bb4c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110bb50:	01000144 	movi	r4,5
8110bb54:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bb58:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bb5c:	e0bfff17 	ldw	r2,-4(fp)
}
8110bb60:	e037883a 	mov	sp,fp
8110bb64:	dfc00117 	ldw	ra,4(sp)
8110bb68:	df000017 	ldw	fp,0(sp)
8110bb6c:	dec00204 	addi	sp,sp,8
8110bb70:	f800283a 	ret

8110bb74 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110bb74:	defffd04 	addi	sp,sp,-12
8110bb78:	de00012e 	bgeu	sp,et,8110bb80 <uliSyncGetPer+0xc>
8110bb7c:	003b68fa 	trap	3
8110bb80:	dfc00215 	stw	ra,8(sp)
8110bb84:	df000115 	stw	fp,4(sp)
8110bb88:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110bb8c:	01000184 	movi	r4,6
8110bb90:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bb94:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bb98:	e0bfff17 	ldw	r2,-4(fp)
}
8110bb9c:	e037883a 	mov	sp,fp
8110bba0:	dfc00117 	ldw	ra,4(sp)
8110bba4:	df000017 	ldw	fp,0(sp)
8110bba8:	dec00204 	addi	sp,sp,8
8110bbac:	f800283a 	ret

8110bbb0 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110bbb0:	defffd04 	addi	sp,sp,-12
8110bbb4:	de00012e 	bgeu	sp,et,8110bbbc <uliSyncGetOst+0xc>
8110bbb8:	003b68fa 	trap	3
8110bbbc:	dfc00215 	stw	ra,8(sp)
8110bbc0:	df000115 	stw	fp,4(sp)
8110bbc4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110bbc8:	010001c4 	movi	r4,7
8110bbcc:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bbd0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bbd4:	e0bfff17 	ldw	r2,-4(fp)
}
8110bbd8:	e037883a 	mov	sp,fp
8110bbdc:	dfc00117 	ldw	ra,4(sp)
8110bbe0:	df000017 	ldw	fp,0(sp)
8110bbe4:	dec00204 	addi	sp,sp,8
8110bbe8:	f800283a 	ret

8110bbec <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110bbec:	defffd04 	addi	sp,sp,-12
8110bbf0:	de00012e 	bgeu	sp,et,8110bbf8 <uliSyncGetGeneral+0xc>
8110bbf4:	003b68fa 	trap	3
8110bbf8:	dfc00215 	stw	ra,8(sp)
8110bbfc:	df000115 	stw	fp,4(sp)
8110bc00:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bc04:	01000204 	movi	r4,8
8110bc08:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bc0c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bc10:	e0bfff17 	ldw	r2,-4(fp)
}
8110bc14:	e037883a 	mov	sp,fp
8110bc18:	dfc00117 	ldw	ra,4(sp)
8110bc1c:	df000017 	ldw	fp,0(sp)
8110bc20:	dec00204 	addi	sp,sp,8
8110bc24:	f800283a 	ret

8110bc28 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110bc28:	defffd04 	addi	sp,sp,-12
8110bc2c:	de00012e 	bgeu	sp,et,8110bc34 <bSyncErrInj+0xc>
8110bc30:	003b68fa 	trap	3
8110bc34:	dfc00215 	stw	ra,8(sp)
8110bc38:	df000115 	stw	fp,4(sp)
8110bc3c:	df000104 	addi	fp,sp,4
8110bc40:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110bc44:	e17fff17 	ldw	r5,-4(fp)
8110bc48:	01000244 	movi	r4,9
8110bc4c:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bc50:	00800044 	movi	r2,1
}
8110bc54:	e037883a 	mov	sp,fp
8110bc58:	dfc00117 	ldw	ra,4(sp)
8110bc5c:	df000017 	ldw	fp,0(sp)
8110bc60:	dec00204 	addi	sp,sp,8
8110bc64:	f800283a 	ret

8110bc68 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110bc68:	defffc04 	addi	sp,sp,-16
8110bc6c:	de00012e 	bgeu	sp,et,8110bc74 <bSyncCtrExtnIrq+0xc>
8110bc70:	003b68fa 	trap	3
8110bc74:	dfc00315 	stw	ra,12(sp)
8110bc78:	df000215 	stw	fp,8(sp)
8110bc7c:	df000204 	addi	fp,sp,8
8110bc80:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bc84:	01000284 	movi	r4,10
8110bc88:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bc8c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bc90:	e0bfff17 	ldw	r2,-4(fp)
8110bc94:	1000061e 	bne	r2,zero,8110bcb0 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110bc98:	e0fffe17 	ldw	r3,-8(fp)
8110bc9c:	00a00034 	movhi	r2,32768
8110bca0:	10bfffc4 	addi	r2,r2,-1
8110bca4:	1884703a 	and	r2,r3,r2
8110bca8:	e0bffe15 	stw	r2,-8(fp)
8110bcac:	00000306 	br	8110bcbc <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110bcb0:	e0bffe17 	ldw	r2,-8(fp)
8110bcb4:	10a00034 	orhi	r2,r2,32768
8110bcb8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bcbc:	e17ffe17 	ldw	r5,-8(fp)
8110bcc0:	01000284 	movi	r4,10
8110bcc4:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bcc8:	00800044 	movi	r2,1
}
8110bccc:	e037883a 	mov	sp,fp
8110bcd0:	dfc00117 	ldw	ra,4(sp)
8110bcd4:	df000017 	ldw	fp,0(sp)
8110bcd8:	dec00204 	addi	sp,sp,8
8110bcdc:	f800283a 	ret

8110bce0 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110bce0:	defffd04 	addi	sp,sp,-12
8110bce4:	de00012e 	bgeu	sp,et,8110bcec <bSyncCtrStart+0xc>
8110bce8:	003b68fa 	trap	3
8110bcec:	dfc00215 	stw	ra,8(sp)
8110bcf0:	df000115 	stw	fp,4(sp)
8110bcf4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bcf8:	01000284 	movi	r4,10
8110bcfc:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bd00:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110bd04:	e0bfff17 	ldw	r2,-4(fp)
8110bd08:	10800234 	orhi	r2,r2,8
8110bd0c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bd10:	e17fff17 	ldw	r5,-4(fp)
8110bd14:	01000284 	movi	r4,10
8110bd18:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bd1c:	00800044 	movi	r2,1
}
8110bd20:	e037883a 	mov	sp,fp
8110bd24:	dfc00117 	ldw	ra,4(sp)
8110bd28:	df000017 	ldw	fp,0(sp)
8110bd2c:	dec00204 	addi	sp,sp,8
8110bd30:	f800283a 	ret

8110bd34 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110bd34:	defffd04 	addi	sp,sp,-12
8110bd38:	de00012e 	bgeu	sp,et,8110bd40 <bSyncCtrReset+0xc>
8110bd3c:	003b68fa 	trap	3
8110bd40:	dfc00215 	stw	ra,8(sp)
8110bd44:	df000115 	stw	fp,4(sp)
8110bd48:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bd4c:	01000284 	movi	r4,10
8110bd50:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bd54:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110bd58:	e0bfff17 	ldw	r2,-4(fp)
8110bd5c:	10800134 	orhi	r2,r2,4
8110bd60:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bd64:	e17fff17 	ldw	r5,-4(fp)
8110bd68:	01000284 	movi	r4,10
8110bd6c:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bd70:	00800044 	movi	r2,1
}
8110bd74:	e037883a 	mov	sp,fp
8110bd78:	dfc00117 	ldw	ra,4(sp)
8110bd7c:	df000017 	ldw	fp,0(sp)
8110bd80:	dec00204 	addi	sp,sp,8
8110bd84:	f800283a 	ret

8110bd88 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110bd88:	defffd04 	addi	sp,sp,-12
8110bd8c:	de00012e 	bgeu	sp,et,8110bd94 <bSyncCtrOneShot+0xc>
8110bd90:	003b68fa 	trap	3
8110bd94:	dfc00215 	stw	ra,8(sp)
8110bd98:	df000115 	stw	fp,4(sp)
8110bd9c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bda0:	01000284 	movi	r4,10
8110bda4:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bda8:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110bdac:	e0bfff17 	ldw	r2,-4(fp)
8110bdb0:	108000b4 	orhi	r2,r2,2
8110bdb4:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bdb8:	e17fff17 	ldw	r5,-4(fp)
8110bdbc:	01000284 	movi	r4,10
8110bdc0:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bdc4:	00800044 	movi	r2,1
}
8110bdc8:	e037883a 	mov	sp,fp
8110bdcc:	dfc00117 	ldw	ra,4(sp)
8110bdd0:	df000017 	ldw	fp,0(sp)
8110bdd4:	dec00204 	addi	sp,sp,8
8110bdd8:	f800283a 	ret

8110bddc <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110bddc:	defffd04 	addi	sp,sp,-12
8110bde0:	de00012e 	bgeu	sp,et,8110bde8 <bSyncCtrErrInj+0xc>
8110bde4:	003b68fa 	trap	3
8110bde8:	dfc00215 	stw	ra,8(sp)
8110bdec:	df000115 	stw	fp,4(sp)
8110bdf0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bdf4:	01000284 	movi	r4,10
8110bdf8:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bdfc:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110be00:	e0bfff17 	ldw	r2,-4(fp)
8110be04:	10800074 	orhi	r2,r2,1
8110be08:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110be0c:	e17fff17 	ldw	r5,-4(fp)
8110be10:	01000284 	movi	r4,10
8110be14:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110be18:	00800044 	movi	r2,1
}
8110be1c:	e037883a 	mov	sp,fp
8110be20:	dfc00117 	ldw	ra,4(sp)
8110be24:	df000017 	ldw	fp,0(sp)
8110be28:	dec00204 	addi	sp,sp,8
8110be2c:	f800283a 	ret

8110be30 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110be30:	defffc04 	addi	sp,sp,-16
8110be34:	de00012e 	bgeu	sp,et,8110be3c <bSyncCtrSyncOutEnable+0xc>
8110be38:	003b68fa 	trap	3
8110be3c:	dfc00315 	stw	ra,12(sp)
8110be40:	df000215 	stw	fp,8(sp)
8110be44:	df000204 	addi	fp,sp,8
8110be48:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110be4c:	01000284 	movi	r4,10
8110be50:	110c5980 	call	8110c598 <uliSyncReadReg>
8110be54:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110be58:	e0bfff17 	ldw	r2,-4(fp)
8110be5c:	1000051e 	bne	r2,zero,8110be74 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110be60:	e0fffe17 	ldw	r3,-8(fp)
8110be64:	00bfbfc4 	movi	r2,-257
8110be68:	1884703a 	and	r2,r3,r2
8110be6c:	e0bffe15 	stw	r2,-8(fp)
8110be70:	00000306 	br	8110be80 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110be74:	e0bffe17 	ldw	r2,-8(fp)
8110be78:	10804014 	ori	r2,r2,256
8110be7c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110be80:	e17ffe17 	ldw	r5,-8(fp)
8110be84:	01000284 	movi	r4,10
8110be88:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110be8c:	00800044 	movi	r2,1
}
8110be90:	e037883a 	mov	sp,fp
8110be94:	dfc00117 	ldw	ra,4(sp)
8110be98:	df000017 	ldw	fp,0(sp)
8110be9c:	dec00204 	addi	sp,sp,8
8110bea0:	f800283a 	ret

8110bea4 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110bea4:	defffc04 	addi	sp,sp,-16
8110bea8:	de00012e 	bgeu	sp,et,8110beb0 <bSyncCtrCh1OutEnable+0xc>
8110beac:	003b68fa 	trap	3
8110beb0:	dfc00315 	stw	ra,12(sp)
8110beb4:	df000215 	stw	fp,8(sp)
8110beb8:	df000204 	addi	fp,sp,8
8110bebc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bec0:	01000284 	movi	r4,10
8110bec4:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bec8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110becc:	e0bfff17 	ldw	r2,-4(fp)
8110bed0:	1000051e 	bne	r2,zero,8110bee8 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110bed4:	e0fffe17 	ldw	r3,-8(fp)
8110bed8:	00bfff84 	movi	r2,-2
8110bedc:	1884703a 	and	r2,r3,r2
8110bee0:	e0bffe15 	stw	r2,-8(fp)
8110bee4:	00000306 	br	8110bef4 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110bee8:	e0bffe17 	ldw	r2,-8(fp)
8110beec:	10800054 	ori	r2,r2,1
8110bef0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bef4:	e17ffe17 	ldw	r5,-8(fp)
8110bef8:	01000284 	movi	r4,10
8110befc:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bf00:	00800044 	movi	r2,1
}
8110bf04:	e037883a 	mov	sp,fp
8110bf08:	dfc00117 	ldw	ra,4(sp)
8110bf0c:	df000017 	ldw	fp,0(sp)
8110bf10:	dec00204 	addi	sp,sp,8
8110bf14:	f800283a 	ret

8110bf18 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110bf18:	defffc04 	addi	sp,sp,-16
8110bf1c:	de00012e 	bgeu	sp,et,8110bf24 <bSyncCtrCh2OutEnable+0xc>
8110bf20:	003b68fa 	trap	3
8110bf24:	dfc00315 	stw	ra,12(sp)
8110bf28:	df000215 	stw	fp,8(sp)
8110bf2c:	df000204 	addi	fp,sp,8
8110bf30:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bf34:	01000284 	movi	r4,10
8110bf38:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bf3c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bf40:	e0bfff17 	ldw	r2,-4(fp)
8110bf44:	1000051e 	bne	r2,zero,8110bf5c <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110bf48:	e0fffe17 	ldw	r3,-8(fp)
8110bf4c:	00bfff44 	movi	r2,-3
8110bf50:	1884703a 	and	r2,r3,r2
8110bf54:	e0bffe15 	stw	r2,-8(fp)
8110bf58:	00000306 	br	8110bf68 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110bf5c:	e0bffe17 	ldw	r2,-8(fp)
8110bf60:	10800094 	ori	r2,r2,2
8110bf64:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bf68:	e17ffe17 	ldw	r5,-8(fp)
8110bf6c:	01000284 	movi	r4,10
8110bf70:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bf74:	00800044 	movi	r2,1
}
8110bf78:	e037883a 	mov	sp,fp
8110bf7c:	dfc00117 	ldw	ra,4(sp)
8110bf80:	df000017 	ldw	fp,0(sp)
8110bf84:	dec00204 	addi	sp,sp,8
8110bf88:	f800283a 	ret

8110bf8c <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110bf8c:	defffc04 	addi	sp,sp,-16
8110bf90:	de00012e 	bgeu	sp,et,8110bf98 <bSyncCtrCh3OutEnable+0xc>
8110bf94:	003b68fa 	trap	3
8110bf98:	dfc00315 	stw	ra,12(sp)
8110bf9c:	df000215 	stw	fp,8(sp)
8110bfa0:	df000204 	addi	fp,sp,8
8110bfa4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110bfa8:	01000284 	movi	r4,10
8110bfac:	110c5980 	call	8110c598 <uliSyncReadReg>
8110bfb0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110bfb4:	e0bfff17 	ldw	r2,-4(fp)
8110bfb8:	1000051e 	bne	r2,zero,8110bfd0 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110bfbc:	e0fffe17 	ldw	r3,-8(fp)
8110bfc0:	00bffec4 	movi	r2,-5
8110bfc4:	1884703a 	and	r2,r3,r2
8110bfc8:	e0bffe15 	stw	r2,-8(fp)
8110bfcc:	00000306 	br	8110bfdc <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110bfd0:	e0bffe17 	ldw	r2,-8(fp)
8110bfd4:	10800114 	ori	r2,r2,4
8110bfd8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110bfdc:	e17ffe17 	ldw	r5,-8(fp)
8110bfe0:	01000284 	movi	r4,10
8110bfe4:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110bfe8:	00800044 	movi	r2,1
}
8110bfec:	e037883a 	mov	sp,fp
8110bff0:	dfc00117 	ldw	ra,4(sp)
8110bff4:	df000017 	ldw	fp,0(sp)
8110bff8:	dec00204 	addi	sp,sp,8
8110bffc:	f800283a 	ret

8110c000 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110c000:	defffc04 	addi	sp,sp,-16
8110c004:	de00012e 	bgeu	sp,et,8110c00c <bSyncCtrCh4OutEnable+0xc>
8110c008:	003b68fa 	trap	3
8110c00c:	dfc00315 	stw	ra,12(sp)
8110c010:	df000215 	stw	fp,8(sp)
8110c014:	df000204 	addi	fp,sp,8
8110c018:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c01c:	01000284 	movi	r4,10
8110c020:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c024:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c028:	e0bfff17 	ldw	r2,-4(fp)
8110c02c:	1000051e 	bne	r2,zero,8110c044 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110c030:	e0fffe17 	ldw	r3,-8(fp)
8110c034:	00bffdc4 	movi	r2,-9
8110c038:	1884703a 	and	r2,r3,r2
8110c03c:	e0bffe15 	stw	r2,-8(fp)
8110c040:	00000306 	br	8110c050 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110c044:	e0bffe17 	ldw	r2,-8(fp)
8110c048:	10800214 	ori	r2,r2,8
8110c04c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c050:	e17ffe17 	ldw	r5,-8(fp)
8110c054:	01000284 	movi	r4,10
8110c058:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c05c:	00800044 	movi	r2,1
}
8110c060:	e037883a 	mov	sp,fp
8110c064:	dfc00117 	ldw	ra,4(sp)
8110c068:	df000017 	ldw	fp,0(sp)
8110c06c:	dec00204 	addi	sp,sp,8
8110c070:	f800283a 	ret

8110c074 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110c074:	defffc04 	addi	sp,sp,-16
8110c078:	de00012e 	bgeu	sp,et,8110c080 <bSyncCtrCh5OutEnable+0xc>
8110c07c:	003b68fa 	trap	3
8110c080:	dfc00315 	stw	ra,12(sp)
8110c084:	df000215 	stw	fp,8(sp)
8110c088:	df000204 	addi	fp,sp,8
8110c08c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c090:	01000284 	movi	r4,10
8110c094:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c098:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c09c:	e0bfff17 	ldw	r2,-4(fp)
8110c0a0:	1000051e 	bne	r2,zero,8110c0b8 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110c0a4:	e0fffe17 	ldw	r3,-8(fp)
8110c0a8:	00bffbc4 	movi	r2,-17
8110c0ac:	1884703a 	and	r2,r3,r2
8110c0b0:	e0bffe15 	stw	r2,-8(fp)
8110c0b4:	00000306 	br	8110c0c4 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110c0b8:	e0bffe17 	ldw	r2,-8(fp)
8110c0bc:	10800414 	ori	r2,r2,16
8110c0c0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c0c4:	e17ffe17 	ldw	r5,-8(fp)
8110c0c8:	01000284 	movi	r4,10
8110c0cc:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c0d0:	00800044 	movi	r2,1
}
8110c0d4:	e037883a 	mov	sp,fp
8110c0d8:	dfc00117 	ldw	ra,4(sp)
8110c0dc:	df000017 	ldw	fp,0(sp)
8110c0e0:	dec00204 	addi	sp,sp,8
8110c0e4:	f800283a 	ret

8110c0e8 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110c0e8:	defffc04 	addi	sp,sp,-16
8110c0ec:	de00012e 	bgeu	sp,et,8110c0f4 <bSyncCtrCh6OutEnable+0xc>
8110c0f0:	003b68fa 	trap	3
8110c0f4:	dfc00315 	stw	ra,12(sp)
8110c0f8:	df000215 	stw	fp,8(sp)
8110c0fc:	df000204 	addi	fp,sp,8
8110c100:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c104:	01000284 	movi	r4,10
8110c108:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c10c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c110:	e0bfff17 	ldw	r2,-4(fp)
8110c114:	1000051e 	bne	r2,zero,8110c12c <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110c118:	e0fffe17 	ldw	r3,-8(fp)
8110c11c:	00bff7c4 	movi	r2,-33
8110c120:	1884703a 	and	r2,r3,r2
8110c124:	e0bffe15 	stw	r2,-8(fp)
8110c128:	00000306 	br	8110c138 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110c12c:	e0bffe17 	ldw	r2,-8(fp)
8110c130:	10800814 	ori	r2,r2,32
8110c134:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c138:	e17ffe17 	ldw	r5,-8(fp)
8110c13c:	01000284 	movi	r4,10
8110c140:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c144:	00800044 	movi	r2,1
}
8110c148:	e037883a 	mov	sp,fp
8110c14c:	dfc00117 	ldw	ra,4(sp)
8110c150:	df000017 	ldw	fp,0(sp)
8110c154:	dec00204 	addi	sp,sp,8
8110c158:	f800283a 	ret

8110c15c <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110c15c:	defffc04 	addi	sp,sp,-16
8110c160:	de00012e 	bgeu	sp,et,8110c168 <bSyncCtrCh7OutEnable+0xc>
8110c164:	003b68fa 	trap	3
8110c168:	dfc00315 	stw	ra,12(sp)
8110c16c:	df000215 	stw	fp,8(sp)
8110c170:	df000204 	addi	fp,sp,8
8110c174:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c178:	01000284 	movi	r4,10
8110c17c:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c180:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c184:	e0bfff17 	ldw	r2,-4(fp)
8110c188:	1000051e 	bne	r2,zero,8110c1a0 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110c18c:	e0fffe17 	ldw	r3,-8(fp)
8110c190:	00bfefc4 	movi	r2,-65
8110c194:	1884703a 	and	r2,r3,r2
8110c198:	e0bffe15 	stw	r2,-8(fp)
8110c19c:	00000306 	br	8110c1ac <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110c1a0:	e0bffe17 	ldw	r2,-8(fp)
8110c1a4:	10801014 	ori	r2,r2,64
8110c1a8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c1ac:	e17ffe17 	ldw	r5,-8(fp)
8110c1b0:	01000284 	movi	r4,10
8110c1b4:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c1b8:	00800044 	movi	r2,1
}
8110c1bc:	e037883a 	mov	sp,fp
8110c1c0:	dfc00117 	ldw	ra,4(sp)
8110c1c4:	df000017 	ldw	fp,0(sp)
8110c1c8:	dec00204 	addi	sp,sp,8
8110c1cc:	f800283a 	ret

8110c1d0 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110c1d0:	defffc04 	addi	sp,sp,-16
8110c1d4:	de00012e 	bgeu	sp,et,8110c1dc <bSyncCtrCh8OutEnable+0xc>
8110c1d8:	003b68fa 	trap	3
8110c1dc:	dfc00315 	stw	ra,12(sp)
8110c1e0:	df000215 	stw	fp,8(sp)
8110c1e4:	df000204 	addi	fp,sp,8
8110c1e8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c1ec:	01000284 	movi	r4,10
8110c1f0:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c1f4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c1f8:	e0bfff17 	ldw	r2,-4(fp)
8110c1fc:	1000051e 	bne	r2,zero,8110c214 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110c200:	e0fffe17 	ldw	r3,-8(fp)
8110c204:	00bfdfc4 	movi	r2,-129
8110c208:	1884703a 	and	r2,r3,r2
8110c20c:	e0bffe15 	stw	r2,-8(fp)
8110c210:	00000306 	br	8110c220 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110c214:	e0bffe17 	ldw	r2,-8(fp)
8110c218:	10802014 	ori	r2,r2,128
8110c21c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c220:	e17ffe17 	ldw	r5,-8(fp)
8110c224:	01000284 	movi	r4,10
8110c228:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c22c:	00800044 	movi	r2,1
}
8110c230:	e037883a 	mov	sp,fp
8110c234:	dfc00117 	ldw	ra,4(sp)
8110c238:	df000017 	ldw	fp,0(sp)
8110c23c:	dec00204 	addi	sp,sp,8
8110c240:	f800283a 	ret

8110c244 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110c244:	defffc04 	addi	sp,sp,-16
8110c248:	de00012e 	bgeu	sp,et,8110c250 <bSyncIrqEnableError+0xc>
8110c24c:	003b68fa 	trap	3
8110c250:	dfc00315 	stw	ra,12(sp)
8110c254:	df000215 	stw	fp,8(sp)
8110c258:	df000204 	addi	fp,sp,8
8110c25c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c260:	01000044 	movi	r4,1
8110c264:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c268:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c26c:	e0bfff17 	ldw	r2,-4(fp)
8110c270:	1000051e 	bne	r2,zero,8110c288 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110c274:	e0fffe17 	ldw	r3,-8(fp)
8110c278:	00bfff44 	movi	r2,-3
8110c27c:	1884703a 	and	r2,r3,r2
8110c280:	e0bffe15 	stw	r2,-8(fp)
8110c284:	00000306 	br	8110c294 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110c288:	e0bffe17 	ldw	r2,-8(fp)
8110c28c:	10800094 	ori	r2,r2,2
8110c290:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c294:	e17ffe17 	ldw	r5,-8(fp)
8110c298:	01000044 	movi	r4,1
8110c29c:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c2a0:	00800044 	movi	r2,1
}
8110c2a4:	e037883a 	mov	sp,fp
8110c2a8:	dfc00117 	ldw	ra,4(sp)
8110c2ac:	df000017 	ldw	fp,0(sp)
8110c2b0:	dec00204 	addi	sp,sp,8
8110c2b4:	f800283a 	ret

8110c2b8 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110c2b8:	defffc04 	addi	sp,sp,-16
8110c2bc:	de00012e 	bgeu	sp,et,8110c2c4 <bSyncIrqEnableBlank+0xc>
8110c2c0:	003b68fa 	trap	3
8110c2c4:	dfc00315 	stw	ra,12(sp)
8110c2c8:	df000215 	stw	fp,8(sp)
8110c2cc:	df000204 	addi	fp,sp,8
8110c2d0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c2d4:	01000044 	movi	r4,1
8110c2d8:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c2dc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c2e0:	e0bfff17 	ldw	r2,-4(fp)
8110c2e4:	1000051e 	bne	r2,zero,8110c2fc <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110c2e8:	e0fffe17 	ldw	r3,-8(fp)
8110c2ec:	00bfff84 	movi	r2,-2
8110c2f0:	1884703a 	and	r2,r3,r2
8110c2f4:	e0bffe15 	stw	r2,-8(fp)
8110c2f8:	00000306 	br	8110c308 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110c2fc:	e0bffe17 	ldw	r2,-8(fp)
8110c300:	10800054 	ori	r2,r2,1
8110c304:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c308:	e17ffe17 	ldw	r5,-8(fp)
8110c30c:	01000044 	movi	r4,1
8110c310:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c314:	00800044 	movi	r2,1
}
8110c318:	e037883a 	mov	sp,fp
8110c31c:	dfc00117 	ldw	ra,4(sp)
8110c320:	df000017 	ldw	fp,0(sp)
8110c324:	dec00204 	addi	sp,sp,8
8110c328:	f800283a 	ret

8110c32c <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110c32c:	defffc04 	addi	sp,sp,-16
8110c330:	de00012e 	bgeu	sp,et,8110c338 <bSyncIrqFlagClrError+0xc>
8110c334:	003b68fa 	trap	3
8110c338:	dfc00315 	stw	ra,12(sp)
8110c33c:	df000215 	stw	fp,8(sp)
8110c340:	df000204 	addi	fp,sp,8
8110c344:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c348:	01000084 	movi	r4,2
8110c34c:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c350:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c354:	e0bfff17 	ldw	r2,-4(fp)
8110c358:	1000051e 	bne	r2,zero,8110c370 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c35c:	e0fffe17 	ldw	r3,-8(fp)
8110c360:	00bfff44 	movi	r2,-3
8110c364:	1884703a 	and	r2,r3,r2
8110c368:	e0bffe15 	stw	r2,-8(fp)
8110c36c:	00000306 	br	8110c37c <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c370:	e0bffe17 	ldw	r2,-8(fp)
8110c374:	10800094 	ori	r2,r2,2
8110c378:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c37c:	e17ffe17 	ldw	r5,-8(fp)
8110c380:	01000084 	movi	r4,2
8110c384:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c388:	00800044 	movi	r2,1
}
8110c38c:	e037883a 	mov	sp,fp
8110c390:	dfc00117 	ldw	ra,4(sp)
8110c394:	df000017 	ldw	fp,0(sp)
8110c398:	dec00204 	addi	sp,sp,8
8110c39c:	f800283a 	ret

8110c3a0 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110c3a0:	defffc04 	addi	sp,sp,-16
8110c3a4:	de00012e 	bgeu	sp,et,8110c3ac <bSyncIrqFlagClrBlank+0xc>
8110c3a8:	003b68fa 	trap	3
8110c3ac:	dfc00315 	stw	ra,12(sp)
8110c3b0:	df000215 	stw	fp,8(sp)
8110c3b4:	df000204 	addi	fp,sp,8
8110c3b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c3bc:	01000084 	movi	r4,2
8110c3c0:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c3c4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c3c8:	e0bfff17 	ldw	r2,-4(fp)
8110c3cc:	1000051e 	bne	r2,zero,8110c3e4 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c3d0:	e0fffe17 	ldw	r3,-8(fp)
8110c3d4:	00bfff84 	movi	r2,-2
8110c3d8:	1884703a 	and	r2,r3,r2
8110c3dc:	e0bffe15 	stw	r2,-8(fp)
8110c3e0:	00000306 	br	8110c3f0 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c3e4:	e0bffe17 	ldw	r2,-8(fp)
8110c3e8:	10800054 	ori	r2,r2,1
8110c3ec:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c3f0:	e17ffe17 	ldw	r5,-8(fp)
8110c3f4:	01000084 	movi	r4,2
8110c3f8:	110c53c0 	call	8110c53c <bSyncWriteReg>
	return TRUE;
8110c3fc:	00800044 	movi	r2,1
}
8110c400:	e037883a 	mov	sp,fp
8110c404:	dfc00117 	ldw	ra,4(sp)
8110c408:	df000017 	ldw	fp,0(sp)
8110c40c:	dec00204 	addi	sp,sp,8
8110c410:	f800283a 	ret

8110c414 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110c414:	defffc04 	addi	sp,sp,-16
8110c418:	de00012e 	bgeu	sp,et,8110c420 <bSyncIrqFlagError+0xc>
8110c41c:	003b68fa 	trap	3
8110c420:	dfc00315 	stw	ra,12(sp)
8110c424:	df000215 	stw	fp,8(sp)
8110c428:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c42c:	010000c4 	movi	r4,3
8110c430:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c434:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110c438:	e0bfff17 	ldw	r2,-4(fp)
8110c43c:	1080008c 	andi	r2,r2,2
8110c440:	10000326 	beq	r2,zero,8110c450 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110c444:	00800044 	movi	r2,1
8110c448:	e0bffe15 	stw	r2,-8(fp)
8110c44c:	00000106 	br	8110c454 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110c450:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c454:	e0bffe17 	ldw	r2,-8(fp)
}
8110c458:	e037883a 	mov	sp,fp
8110c45c:	dfc00117 	ldw	ra,4(sp)
8110c460:	df000017 	ldw	fp,0(sp)
8110c464:	dec00204 	addi	sp,sp,8
8110c468:	f800283a 	ret

8110c46c <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110c46c:	defffc04 	addi	sp,sp,-16
8110c470:	de00012e 	bgeu	sp,et,8110c478 <bSyncIrqFlagBlank+0xc>
8110c474:	003b68fa 	trap	3
8110c478:	dfc00315 	stw	ra,12(sp)
8110c47c:	df000215 	stw	fp,8(sp)
8110c480:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c484:	010000c4 	movi	r4,3
8110c488:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c48c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110c490:	e0bfff17 	ldw	r2,-4(fp)
8110c494:	1080004c 	andi	r2,r2,1
8110c498:	10000326 	beq	r2,zero,8110c4a8 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110c49c:	00800044 	movi	r2,1
8110c4a0:	e0bffe15 	stw	r2,-8(fp)
8110c4a4:	00000106 	br	8110c4ac <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110c4a8:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c4ac:	e0bffe17 	ldw	r2,-8(fp)
}
8110c4b0:	e037883a 	mov	sp,fp
8110c4b4:	dfc00117 	ldw	ra,4(sp)
8110c4b8:	df000017 	ldw	fp,0(sp)
8110c4bc:	dec00204 	addi	sp,sp,8
8110c4c0:	f800283a 	ret

8110c4c4 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110c4c4:	defffd04 	addi	sp,sp,-12
8110c4c8:	de00012e 	bgeu	sp,et,8110c4d0 <uliSyncGetCtr+0xc>
8110c4cc:	003b68fa 	trap	3
8110c4d0:	dfc00215 	stw	ra,8(sp)
8110c4d4:	df000115 	stw	fp,4(sp)
8110c4d8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c4dc:	01000284 	movi	r4,10
8110c4e0:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c4e4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c4e8:	e0bfff17 	ldw	r2,-4(fp)
}
8110c4ec:	e037883a 	mov	sp,fp
8110c4f0:	dfc00117 	ldw	ra,4(sp)
8110c4f4:	df000017 	ldw	fp,0(sp)
8110c4f8:	dec00204 	addi	sp,sp,8
8110c4fc:	f800283a 	ret

8110c500 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110c500:	defffd04 	addi	sp,sp,-12
8110c504:	de00012e 	bgeu	sp,et,8110c50c <uliSyncReadStatus+0xc>
8110c508:	003b68fa 	trap	3
8110c50c:	dfc00215 	stw	ra,8(sp)
8110c510:	df000115 	stw	fp,4(sp)
8110c514:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c518:	0009883a 	mov	r4,zero
8110c51c:	110c5980 	call	8110c598 <uliSyncReadReg>
8110c520:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110c524:	e0bfff17 	ldw	r2,-4(fp)
}
8110c528:	e037883a 	mov	sp,fp
8110c52c:	dfc00117 	ldw	ra,4(sp)
8110c530:	df000017 	ldw	fp,0(sp)
8110c534:	dec00204 	addi	sp,sp,8
8110c538:	f800283a 	ret

8110c53c <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
static bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110c53c:	defffc04 	addi	sp,sp,-16
8110c540:	de00012e 	bgeu	sp,et,8110c548 <bSyncWriteReg+0xc>
8110c544:	003b68fa 	trap	3
8110c548:	df000315 	stw	fp,12(sp)
8110c54c:	df000304 	addi	fp,sp,12
8110c550:	e13ffe15 	stw	r4,-8(fp)
8110c554:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c558:	00a00034 	movhi	r2,32768
8110c55c:	10810004 	addi	r2,r2,1024
8110c560:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110c564:	e0bffe17 	ldw	r2,-8(fp)
8110c568:	1085883a 	add	r2,r2,r2
8110c56c:	1085883a 	add	r2,r2,r2
8110c570:	1007883a 	mov	r3,r2
8110c574:	e0bffd17 	ldw	r2,-12(fp)
8110c578:	10c5883a 	add	r2,r2,r3
8110c57c:	e0ffff17 	ldw	r3,-4(fp)
8110c580:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110c584:	00800044 	movi	r2,1
}
8110c588:	e037883a 	mov	sp,fp
8110c58c:	df000017 	ldw	fp,0(sp)
8110c590:	dec00104 	addi	sp,sp,4
8110c594:	f800283a 	ret

8110c598 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
static alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110c598:	defffc04 	addi	sp,sp,-16
8110c59c:	de00012e 	bgeu	sp,et,8110c5a4 <uliSyncReadReg+0xc>
8110c5a0:	003b68fa 	trap	3
8110c5a4:	df000315 	stw	fp,12(sp)
8110c5a8:	df000304 	addi	fp,sp,12
8110c5ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c5b0:	00a00034 	movhi	r2,32768
8110c5b4:	10810004 	addi	r2,r2,1024
8110c5b8:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110c5bc:	e0bfff17 	ldw	r2,-4(fp)
8110c5c0:	1085883a 	add	r2,r2,r2
8110c5c4:	1085883a 	add	r2,r2,r2
8110c5c8:	1007883a 	mov	r3,r2
8110c5cc:	e0bffd17 	ldw	r2,-12(fp)
8110c5d0:	10c5883a 	add	r2,r2,r3
8110c5d4:	10800017 	ldw	r2,0(r2)
8110c5d8:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110c5dc:	e0bffe17 	ldw	r2,-8(fp)
}
8110c5e0:	e037883a 	mov	sp,fp
8110c5e4:	df000017 	ldw	fp,0(sp)
8110c5e8:	dec00104 	addi	sp,sp,4
8110c5ec:	f800283a 	ret

8110c5f0 <vDataControlTask>:


#include "data_control_task.h"


void vDataControlTask(void *task_data) {
8110c5f0:	defff804 	addi	sp,sp,-32
8110c5f4:	de00012e 	bgeu	sp,et,8110c5fc <vDataControlTask+0xc>
8110c5f8:	003b68fa 	trap	3
8110c5fc:	dfc00715 	stw	ra,28(sp)
8110c600:	df000615 	stw	fp,24(sp)
8110c604:	df000604 	addi	fp,sp,24
8110c608:	e13ffd15 	stw	r4,-12(fp)
	bool bCmdSent;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110c60c:	e0bffd17 	ldw	r2,-12(fp)
8110c610:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110c614:	d0a05f17 	ldw	r2,-32388(gp)
8110c618:	100f883a 	mov	r7,r2
8110c61c:	01800804 	movi	r6,32
8110c620:	01400044 	movi	r5,1
8110c624:	01204534 	movhi	r4,33044
8110c628:	2118d904 	addi	r4,r4,25444
8110c62c:	111affc0 	call	8111affc <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110c630:	e0bffa17 	ldw	r2,-24(fp)
8110c634:	00c00044 	movi	r3,1
8110c638:	10c00515 	stw	r3,20(r2)
	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110c63c:	e0bffc04 	addi	r2,fp,-16
8110c640:	100d883a 	mov	r6,r2
8110c644:	000b883a 	mov	r5,zero
8110c648:	01204574 	movhi	r4,33045
8110c64c:	2112e304 	addi	r4,r4,19340
8110c650:	1137b440 	call	81137b44 <OSQPend>
8110c654:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0);; /*todo:Tirar depois do debug*/
8110c658:	000f883a 	mov	r7,zero
8110c65c:	01800144 	movi	r6,5
8110c660:	000b883a 	mov	r5,zero
8110c664:	0009883a 	mov	r4,zero
8110c668:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
	}
8110c66c:	003ff306 	br	8110c63c <__reset+0xfb0ec63c>

8110c670 <vFeeTask>:

#include "fee_task.h"



void vFeeTask(void *task_data) {
8110c670:	defffa04 	addi	sp,sp,-24
8110c674:	de00012e 	bgeu	sp,et,8110c67c <vFeeTask+0xc>
8110c678:	003b68fa 	trap	3
8110c67c:	dfc00515 	stw	ra,20(sp)
8110c680:	df000415 	stw	fp,16(sp)
8110c684:	df000404 	addi	fp,sp,16
8110c688:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110c68c:	e03ffc15 	stw	zero,-16(fp)
	static TNFee *pxNFee;
	INT8U error_code;
	tQMask uiCmdFEE;


	pxNFee = ( TNFee * ) task_data;
8110c690:	e0bfff17 	ldw	r2,-4(fp)
8110c694:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110c698:	d0e05f17 	ldw	r3,-32388(gp)
8110c69c:	d0a05317 	ldw	r2,-32436(gp)
8110c6a0:	10800003 	ldbu	r2,0(r2)
8110c6a4:	10803fcc 	andi	r2,r2,255
8110c6a8:	100d883a 	mov	r6,r2
8110c6ac:	01604534 	movhi	r5,33044
8110c6b0:	2958e204 	addi	r5,r5,25480
8110c6b4:	1809883a 	mov	r4,r3
8110c6b8:	111a9600 	call	8111a960 <fprintf>
		//debug(fp,"NFEE Task. (Task on)\n");
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110c6bc:	d0a05317 	ldw	r2,-32436(gp)
8110c6c0:	1009883a 	mov	r4,r2
8110c6c4:	110cef40 	call	8110cef4 <vPrintConsoleNFee>



	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110c6c8:	d0a05317 	ldw	r2,-32436(gp)
8110c6cc:	10802917 	ldw	r2,164(r2)
8110c6d0:	10c00328 	cmpgeui	r3,r2,12
8110c6d4:	1800cc1e 	bne	r3,zero,8110ca08 <vFeeTask+0x398>
8110c6d8:	100690ba 	slli	r3,r2,2
8110c6dc:	00a04474 	movhi	r2,33041
8110c6e0:	10b1bc04 	addi	r2,r2,-14608
8110c6e4:	1885883a 	add	r2,r3,r2
8110c6e8:	10800017 	ldw	r2,0(r2)
8110c6ec:	1000683a 	jmp	r2
8110c6f0:	8110c720 	cmpeqi	r4,r16,17180
8110c6f4:	8110c7b0 	cmpltui	r4,r16,17182
8110c6f8:	8110c80c 	andi	r4,r16,17184
8110c6fc:	8110c8a0 	cmpeqi	r4,r16,17186
8110c700:	8110c958 	cmpnei	r4,r16,17189
8110c704:	8110c730 	cmpltui	r4,r16,17180
8110c708:	8110c81c 	xori	r4,r16,17184
8110c70c:	8110c8fc 	xorhi	r4,r16,17187
8110c710:	8110ca08 	cmpgei	r4,r16,17192
8110c714:	8110ca3c 	xorhi	r4,r16,17192
8110c718:	8110ca3c 	xorhi	r4,r16,17192
8110c71c:	8110c9b4 	orhi	r4,r16,17190
			case sFeeInit:

				pxNFee->xControl.eMode = sToFeeConfig;
8110c720:	d0a05317 	ldw	r2,-32436(gp)
8110c724:	00c00144 	movi	r3,5
8110c728:	10c02915 	stw	r3,164(r2)

				break;
8110c72c:	0000ca06 	br	8110ca58 <vFeeTask+0x3e8>
			case sToFeeConfig: /* Transition */

				/* Desabilitar interrupes do buffer duplo */
				/* Limpar interrupes, zerar buffer duplo */

				pxNFee->xControl.bSimulating = FALSE;
8110c730:	d0a05317 	ldw	r2,-32436(gp)
8110c734:	10002615 	stw	zero,152(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110c738:	d0a05317 	ldw	r2,-32436(gp)
8110c73c:	10002215 	stw	zero,136(r2)

				/* Disable the link SPW */
				//todo: tratar retorno
				bSpwcGetLink(&pxNFee->xChannel.xSpacewire);
8110c740:	d0a05317 	ldw	r2,-32436(gp)
8110c744:	10808504 	addi	r2,r2,532
8110c748:	1009883a 	mov	r4,r2
8110c74c:	1108f000 	call	81108f00 <bSpwcGetLink>
				pxNFee->xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
8110c750:	d0a05317 	ldw	r2,-32436(gp)
8110c754:	10008715 	stw	zero,540(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
8110c758:	d0a05317 	ldw	r2,-32436(gp)
8110c75c:	10008615 	stw	zero,536(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
8110c760:	d0a05317 	ldw	r2,-32436(gp)
8110c764:	00c00044 	movi	r3,1
8110c768:	10c08815 	stw	r3,544(r2)
				bSpwcSetLink(&pxNFee->xChannel.xSpacewire);
8110c76c:	d0a05317 	ldw	r2,-32436(gp)
8110c770:	10808504 	addi	r2,r2,532
8110c774:	1009883a 	mov	r4,r2
8110c778:	1108dcc0 	call	81108dcc <bSpwcSetLink>

				//todo:Back
				//bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);

				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Going to Config mode\n", pxNFee->ucId);
8110c77c:	d0e05f17 	ldw	r3,-32388(gp)
8110c780:	d0a05317 	ldw	r2,-32436(gp)
8110c784:	10800003 	ldbu	r2,0(r2)
8110c788:	10803fcc 	andi	r2,r2,255
8110c78c:	100d883a 	mov	r6,r2
8110c790:	01604534 	movhi	r5,33044
8110c794:	2958e904 	addi	r5,r5,25508
8110c798:	1809883a 	mov	r4,r3
8110c79c:	111a9600 	call	8111a960 <fprintf>
				#endif

				pxNFee->xControl.eMode = sFeeConfig;
8110c7a0:	d0a05317 	ldw	r2,-32436(gp)
8110c7a4:	00c00044 	movi	r3,1
8110c7a8:	10c02915 	stw	r3,164(r2)


				break;
8110c7ac:	0000aa06 	br	8110ca58 <vFeeTask+0x3e8>
			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c7b0:	d0a05317 	ldw	r2,-32436(gp)
8110c7b4:	10800003 	ldbu	r2,0(r2)
8110c7b8:	10803fcc 	andi	r2,r2,255
8110c7bc:	1085883a 	add	r2,r2,r2
8110c7c0:	1087883a 	add	r3,r2,r2
8110c7c4:	d0a06e04 	addi	r2,gp,-32328
8110c7c8:	1885883a 	add	r2,r3,r2
8110c7cc:	10800017 	ldw	r2,0(r2)
8110c7d0:	e0fffd04 	addi	r3,fp,-12
8110c7d4:	180d883a 	mov	r6,r3
8110c7d8:	000b883a 	mov	r5,zero
8110c7dc:	1009883a 	mov	r4,r2
8110c7e0:	1137b440 	call	81137b44 <OSQPend>
8110c7e4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c7e8:	e0bffd03 	ldbu	r2,-12(fp)
8110c7ec:	10803fcc 	andi	r2,r2,255
8110c7f0:	1000941e 	bne	r2,zero,8110ca44 <vFeeTask+0x3d4>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110c7f4:	d0a05317 	ldw	r2,-32436(gp)
8110c7f8:	e0fffe17 	ldw	r3,-8(fp)
8110c7fc:	180b883a 	mov	r5,r3
8110c800:	1009883a 	mov	r4,r2
8110c804:	110ca5c0 	call	8110ca5c <vQCmdFEEinConfig>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
8110c808:	00008e06 	br	8110ca44 <vFeeTask+0x3d4>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110c80c:	d0a05317 	ldw	r2,-32436(gp)
8110c810:	00c00184 	movi	r3,6
8110c814:	10c02915 	stw	r3,164(r2)
				break;
8110c818:	00008f06 	br	8110ca58 <vFeeTask+0x3e8>
				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
			case sToFeeStandBy: /* Transition */

				pxNFee->xControl.bSimulating = TRUE;
8110c81c:	d0a05317 	ldw	r2,-32436(gp)
8110c820:	00c00044 	movi	r3,1
8110c824:	10c02615 	stw	r3,152(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110c828:	d0a05317 	ldw	r2,-32436(gp)
8110c82c:	10002215 	stw	zero,136(r2)
				/* Limpar interrupes, zerar buffer duplo */


				/* Enable link SPW the link SPW */
				bSpwcGetLink(&pxNFee->xChannel.xSpacewire);
8110c830:	d0a05317 	ldw	r2,-32436(gp)
8110c834:	10808504 	addi	r2,r2,532
8110c838:	1009883a 	mov	r4,r2
8110c83c:	1108f000 	call	81108f00 <bSpwcGetLink>
				pxNFee->xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
8110c840:	d0a05317 	ldw	r2,-32436(gp)
8110c844:	10008715 	stw	zero,540(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
8110c848:	d0a05317 	ldw	r2,-32436(gp)
8110c84c:	00c00044 	movi	r3,1
8110c850:	10c08615 	stw	r3,536(r2)
				pxNFee->xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
8110c854:	d0a05317 	ldw	r2,-32436(gp)
8110c858:	10008815 	stw	zero,544(r2)
				bSpwcSetLink(&pxNFee->xChannel.xSpacewire);
8110c85c:	d0a05317 	ldw	r2,-32436(gp)
8110c860:	10808504 	addi	r2,r2,532
8110c864:	1009883a 	mov	r4,r2
8110c868:	1108dcc0 	call	81108dcc <bSpwcSetLink>


				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Going to Standby mode\n", pxNFee->ucId);
8110c86c:	d0e05f17 	ldw	r3,-32388(gp)
8110c870:	d0a05317 	ldw	r2,-32436(gp)
8110c874:	10800003 	ldbu	r2,0(r2)
8110c878:	10803fcc 	andi	r2,r2,255
8110c87c:	100d883a 	mov	r6,r2
8110c880:	01604534 	movhi	r5,33044
8110c884:	2958f304 	addi	r5,r5,25548
8110c888:	1809883a 	mov	r4,r3
8110c88c:	111a9600 	call	8111a960 <fprintf>
				#endif
				pxNFee->xControl.eMode = sFeeStandBy;
8110c890:	d0a05317 	ldw	r2,-32436(gp)
8110c894:	00c000c4 	movi	r3,3
8110c898:	10c02915 	stw	r3,164(r2)
				break;
8110c89c:	00006e06 	br	8110ca58 <vFeeTask+0x3e8>
			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c8a0:	d0a05317 	ldw	r2,-32436(gp)
8110c8a4:	10800003 	ldbu	r2,0(r2)
8110c8a8:	10803fcc 	andi	r2,r2,255
8110c8ac:	1085883a 	add	r2,r2,r2
8110c8b0:	1087883a 	add	r3,r2,r2
8110c8b4:	d0a06e04 	addi	r2,gp,-32328
8110c8b8:	1885883a 	add	r2,r3,r2
8110c8bc:	10800017 	ldw	r2,0(r2)
8110c8c0:	e0fffd04 	addi	r3,fp,-12
8110c8c4:	180d883a 	mov	r6,r3
8110c8c8:	000b883a 	mov	r5,zero
8110c8cc:	1009883a 	mov	r4,r2
8110c8d0:	1137b440 	call	81137b44 <OSQPend>
8110c8d4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c8d8:	e0bffd03 	ldbu	r2,-12(fp)
8110c8dc:	10803fcc 	andi	r2,r2,255
8110c8e0:	10005a1e 	bne	r2,zero,8110ca4c <vFeeTask+0x3dc>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110c8e4:	d0a05317 	ldw	r2,-32436(gp)
8110c8e8:	e0fffe17 	ldw	r3,-8(fp)
8110c8ec:	180b883a 	mov	r5,r3
8110c8f0:	1009883a 	mov	r4,r2
8110c8f4:	110cbcc0 	call	8110cbcc <vQCmdFEEinStandBy>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
8110c8f8:	00005406 	br	8110ca4c <vFeeTask+0x3dc>
				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
			case sToTestFullPattern: /* Transition */

				pxNFee->xControl.bUsingDMA = TRUE;
8110c8fc:	d0a05317 	ldw	r2,-32436(gp)
8110c900:	00c00044 	movi	r3,1
8110c904:	10c02215 	stw	r3,136(r2)

				if (pxNFee->xControl.bWatingSync==TRUE)
8110c908:	d0a05317 	ldw	r2,-32436(gp)
8110c90c:	10802717 	ldw	r2,156(r2)
8110c910:	10800058 	cmpnei	r2,r2,1
8110c914:	1000031e 	bne	r2,zero,8110c924 <vFeeTask+0x2b4>
					pxNFee->xControl.eMode = sFeeWaitingSync;
8110c918:	d0a05317 	ldw	r2,-32436(gp)
8110c91c:	00c002c4 	movi	r3,11
8110c920:	10c02915 	stw	r3,164(r2)
				/* Esperar QUEUE para DMA
				 * PEGAR MUTEX DMA */


				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Going to FULL Image Pattern mode\n", pxNFee->ucId);
8110c924:	d0e05f17 	ldw	r3,-32388(gp)
8110c928:	d0a05317 	ldw	r2,-32436(gp)
8110c92c:	10800003 	ldbu	r2,0(r2)
8110c930:	10803fcc 	andi	r2,r2,255
8110c934:	100d883a 	mov	r6,r2
8110c938:	01604534 	movhi	r5,33044
8110c93c:	2958fd04 	addi	r5,r5,25588
8110c940:	1809883a 	mov	r4,r3
8110c944:	111a9600 	call	8111a960 <fprintf>
				#endif
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110c948:	d0a05317 	ldw	r2,-32436(gp)
8110c94c:	00c00104 	movi	r3,4
8110c950:	10c02915 	stw	r3,164(r2)
				break;
8110c954:	00004006 	br	8110ca58 <vFeeTask+0x3e8>
			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c958:	d0a05317 	ldw	r2,-32436(gp)
8110c95c:	10800003 	ldbu	r2,0(r2)
8110c960:	10803fcc 	andi	r2,r2,255
8110c964:	1085883a 	add	r2,r2,r2
8110c968:	1087883a 	add	r3,r2,r2
8110c96c:	d0a06e04 	addi	r2,gp,-32328
8110c970:	1885883a 	add	r2,r3,r2
8110c974:	10800017 	ldw	r2,0(r2)
8110c978:	e0fffd04 	addi	r3,fp,-12
8110c97c:	180d883a 	mov	r6,r3
8110c980:	000b883a 	mov	r5,zero
8110c984:	1009883a 	mov	r4,r2
8110c988:	1137b440 	call	81137b44 <OSQPend>
8110c98c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c990:	e0bffd03 	ldbu	r2,-12(fp)
8110c994:	10803fcc 	andi	r2,r2,255
8110c998:	10002e1e 	bne	r2,zero,8110ca54 <vFeeTask+0x3e4>

					vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110c99c:	d0a05317 	ldw	r2,-32436(gp)
8110c9a0:	e0fffe17 	ldw	r3,-8(fp)
8110c9a4:	180b883a 	mov	r5,r3
8110c9a8:	1009883a 	mov	r4,r2
8110c9ac:	110cd640 	call	8110cd64 <vQCmdFEEinFullPattern>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
8110c9b0:	00002806 	br	8110ca54 <vFeeTask+0x3e4>

			case sFeeWaitingSync:

				pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110c9b4:	d0a05317 	ldw	r2,-32436(gp)
8110c9b8:	d0e05317 	ldw	r3,-32436(gp)
8110c9bc:	18c02a17 	ldw	r3,168(r3)
8110c9c0:	10c02915 	stw	r3,164(r2)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xWaitSyncQFee[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c9c4:	d0a05317 	ldw	r2,-32436(gp)
8110c9c8:	10800003 	ldbu	r2,0(r2)
8110c9cc:	10803fcc 	andi	r2,r2,255
8110c9d0:	1085883a 	add	r2,r2,r2
8110c9d4:	1087883a 	add	r3,r2,r2
8110c9d8:	d0a05804 	addi	r2,gp,-32416
8110c9dc:	1885883a 	add	r2,r3,r2
8110c9e0:	10800017 	ldw	r2,0(r2)
8110c9e4:	e0fffd04 	addi	r3,fp,-12
8110c9e8:	180d883a 	mov	r6,r3
8110c9ec:	000b883a 	mov	r5,zero
8110c9f0:	1009883a 	mov	r4,r2
8110c9f4:	1137b440 	call	81137b44 <OSQPend>
8110c9f8:	e0bffe15 	stw	r2,-8(fp)
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				pxNFee->xControl.bWatingSync = FALSE;
8110c9fc:	d0a05317 	ldw	r2,-32436(gp)
8110ca00:	10002715 	stw	zero,156(r2)
				break;
8110ca04:	00001406 	br	8110ca58 <vFeeTask+0x3e8>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110ca08:	d0a05317 	ldw	r2,-32436(gp)
8110ca0c:	00c00144 	movi	r3,5
8110ca10:	10c02915 	stw	r3,164(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110ca14:	d0e05f17 	ldw	r3,-32388(gp)
8110ca18:	d0a05317 	ldw	r2,-32436(gp)
8110ca1c:	10800003 	ldbu	r2,0(r2)
8110ca20:	10803fcc 	andi	r2,r2,255
8110ca24:	100d883a 	mov	r6,r2
8110ca28:	01604534 	movhi	r5,33044
8110ca2c:	29590a04 	addi	r5,r5,25640
8110ca30:	1809883a 	mov	r4,r3
8110ca34:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110ca38:	00000706 	br	8110ca58 <vFeeTask+0x3e8>
				break;
			case sSIMFeeStandBy:

				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
8110ca3c:	0001883a 	nop
8110ca40:	003f2106 	br	8110c6c8 <__reset+0xfb0ec6c8>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
8110ca44:	0001883a 	nop
8110ca48:	003f1f06 	br	8110c6c8 <__reset+0xfb0ec6c8>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
8110ca4c:	0001883a 	nop
8110ca50:	003f1d06 	br	8110c6c8 <__reset+0xfb0ec6c8>
				} else {

					/* todo: Criar funo de tratamento de erro*/
				}

				break;
8110ca54:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110ca58:	003f1b06 	br	8110c6c8 <__reset+0xfb0ec6c8>

8110ca5c <vQCmdFEEinConfig>:


}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110ca5c:	defffb04 	addi	sp,sp,-20
8110ca60:	de00012e 	bgeu	sp,et,8110ca68 <vQCmdFEEinConfig+0xc>
8110ca64:	003b68fa 	trap	3
8110ca68:	dfc00415 	stw	ra,16(sp)
8110ca6c:	df000315 	stw	fp,12(sp)
8110ca70:	df000304 	addi	fp,sp,12
8110ca74:	e13ffe15 	stw	r4,-8(fp)
8110ca78:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110ca7c:	e0bfff17 	ldw	r2,-4(fp)
8110ca80:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110ca84:	e0bffdc3 	ldbu	r2,-9(fp)
8110ca88:	10c03fcc 	andi	r3,r2,255
8110ca8c:	e0bffe17 	ldw	r2,-8(fp)
8110ca90:	10800003 	ldbu	r2,0(r2)
8110ca94:	10803fcc 	andi	r2,r2,255
8110ca98:	10800444 	addi	r2,r2,17
8110ca9c:	1880451e 	bne	r3,r2,8110cbb4 <vQCmdFEEinConfig+0x158>

		switch (uiCmdFEEL.ucByte[2]) {
8110caa0:	e0bffd83 	ldbu	r2,-10(fp)
8110caa4:	10803fcc 	andi	r2,r2,255
8110caa8:	10c00220 	cmpeqi	r3,r2,8
8110caac:	18002c1e 	bne	r3,zero,8110cb60 <vQCmdFEEinConfig+0x104>
8110cab0:	10c00248 	cmpgei	r3,r2,9
8110cab4:	1800071e 	bne	r3,zero,8110cad4 <vQCmdFEEinConfig+0x78>
8110cab8:	10c000a0 	cmpeqi	r3,r2,2
8110cabc:	18003c1e 	bne	r3,zero,8110cbb0 <vQCmdFEEinConfig+0x154>
8110cac0:	10c00120 	cmpeqi	r3,r2,4
8110cac4:	1800131e 	bne	r3,zero,8110cb14 <vQCmdFEEinConfig+0xb8>
8110cac8:	10800060 	cmpeqi	r2,r2,1
8110cacc:	1000071e 	bne	r2,zero,8110caec <vQCmdFEEinConfig+0x90>
8110cad0:	00002d06 	br	8110cb88 <vQCmdFEEinConfig+0x12c>
8110cad4:	10c02920 	cmpeqi	r3,r2,164
8110cad8:	1800181e 	bne	r3,zero,8110cb3c <vQCmdFEEinConfig+0xe0>
8110cadc:	10c02a20 	cmpeqi	r3,r2,168
8110cae0:	18001f1e 	bne	r3,zero,8110cb60 <vQCmdFEEinConfig+0x104>
8110cae4:	10802860 	cmpeqi	r2,r2,161
8110cae8:	10002726 	beq	r2,zero,8110cb88 <vQCmdFEEinConfig+0x12c>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110caec:	d0e05f17 	ldw	r3,-32388(gp)
8110caf0:	e0bffe17 	ldw	r2,-8(fp)
8110caf4:	10800003 	ldbu	r2,0(r2)
8110caf8:	10803fcc 	andi	r2,r2,255
8110cafc:	100d883a 	mov	r6,r2
8110cb00:	01604534 	movhi	r5,33044
8110cb04:	29591504 	addi	r5,r5,25684
8110cb08:	1809883a 	mov	r4,r3
8110cb0c:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110cb10:	00002806 	br	8110cbb4 <vQCmdFEEinConfig+0x158>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110cb14:	e0bffe17 	ldw	r2,-8(fp)
8110cb18:	00c00044 	movi	r3,1
8110cb1c:	10c02715 	stw	r3,156(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110cb20:	e0bffe17 	ldw	r2,-8(fp)
8110cb24:	00c002c4 	movi	r3,11
8110cb28:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110cb2c:	e0bffe17 	ldw	r2,-8(fp)
8110cb30:	00c00184 	movi	r3,6
8110cb34:	10c02a15 	stw	r3,168(r2)
				break;
8110cb38:	00001e06 	br	8110cbb4 <vQCmdFEEinConfig+0x158>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110cb3c:	e0bffe17 	ldw	r2,-8(fp)
8110cb40:	10002715 	stw	zero,156(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110cb44:	e0bffe17 	ldw	r2,-8(fp)
8110cb48:	00c00184 	movi	r3,6
8110cb4c:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110cb50:	e0bffe17 	ldw	r2,-8(fp)
8110cb54:	00c00184 	movi	r3,6
8110cb58:	10c02a15 	stw	r3,168(r2)
				break;				
8110cb5c:	00001506 	br	8110cbb4 <vQCmdFEEinConfig+0x158>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110cb60:	d0e05f17 	ldw	r3,-32388(gp)
8110cb64:	e0bffe17 	ldw	r2,-8(fp)
8110cb68:	10800003 	ldbu	r2,0(r2)
8110cb6c:	10803fcc 	andi	r2,r2,255
8110cb70:	100d883a 	mov	r6,r2
8110cb74:	01604534 	movhi	r5,33044
8110cb78:	29592004 	addi	r5,r5,25728
8110cb7c:	1809883a 	mov	r4,r3
8110cb80:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;											
8110cb84:	00000b06 	br	8110cbb4 <vQCmdFEEinConfig+0x158>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110cb88:	d0e05f17 	ldw	r3,-32388(gp)
8110cb8c:	e0bffe17 	ldw	r2,-8(fp)
8110cb90:	10800003 	ldbu	r2,0(r2)
8110cb94:	10803fcc 	andi	r2,r2,255
8110cb98:	100d883a 	mov	r6,r2
8110cb9c:	01604534 	movhi	r5,33044
8110cba0:	29593104 	addi	r5,r5,25796
8110cba4:	1809883a 	mov	r4,r3
8110cba8:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110cbac:	00000106 	br	8110cbb4 <vQCmdFEEinConfig+0x158>
				break;
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110cbb0:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110cbb4:	0001883a 	nop
8110cbb8:	e037883a 	mov	sp,fp
8110cbbc:	dfc00117 	ldw	ra,4(sp)
8110cbc0:	df000017 	ldw	fp,0(sp)
8110cbc4:	dec00204 	addi	sp,sp,8
8110cbc8:	f800283a 	ret

8110cbcc <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110cbcc:	defffb04 	addi	sp,sp,-20
8110cbd0:	de00012e 	bgeu	sp,et,8110cbd8 <vQCmdFEEinStandBy+0xc>
8110cbd4:	003b68fa 	trap	3
8110cbd8:	dfc00415 	stw	ra,16(sp)
8110cbdc:	df000315 	stw	fp,12(sp)
8110cbe0:	df000304 	addi	fp,sp,12
8110cbe4:	e13ffe15 	stw	r4,-8(fp)
8110cbe8:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110cbec:	e0bfff17 	ldw	r2,-4(fp)
8110cbf0:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110cbf4:	e0bffdc3 	ldbu	r2,-9(fp)
8110cbf8:	10c03fcc 	andi	r3,r2,255
8110cbfc:	e0bffe17 	ldw	r2,-8(fp)
8110cc00:	10800003 	ldbu	r2,0(r2)
8110cc04:	10803fcc 	andi	r2,r2,255
8110cc08:	10800444 	addi	r2,r2,17
8110cc0c:	18804f1e 	bne	r3,r2,8110cd4c <vQCmdFEEinStandBy+0x180>

		switch (uiCmdFEEL.ucByte[2]) {
8110cc10:	e0bffd83 	ldbu	r2,-10(fp)
8110cc14:	10803fcc 	andi	r2,r2,255
8110cc18:	10c00220 	cmpeqi	r3,r2,8
8110cc1c:	18002d1e 	bne	r3,zero,8110ccd4 <vQCmdFEEinStandBy+0x108>
8110cc20:	10c00248 	cmpgei	r3,r2,9
8110cc24:	1800071e 	bne	r3,zero,8110cc44 <vQCmdFEEinStandBy+0x78>
8110cc28:	10c000a0 	cmpeqi	r3,r2,2
8110cc2c:	1800461e 	bne	r3,zero,8110cd48 <vQCmdFEEinStandBy+0x17c>
8110cc30:	10c00120 	cmpeqi	r3,r2,4
8110cc34:	18001d1e 	bne	r3,zero,8110ccac <vQCmdFEEinStandBy+0xe0>
8110cc38:	10800060 	cmpeqi	r2,r2,1
8110cc3c:	1000081e 	bne	r2,zero,8110cc60 <vQCmdFEEinStandBy+0x94>
8110cc40:	00003706 	br	8110cd20 <vQCmdFEEinStandBy+0x154>
8110cc44:	10c02920 	cmpeqi	r3,r2,164
8110cc48:	1800181e 	bne	r3,zero,8110ccac <vQCmdFEEinStandBy+0xe0>
8110cc4c:	10c02a20 	cmpeqi	r3,r2,168
8110cc50:	18002a1e 	bne	r3,zero,8110ccfc <vQCmdFEEinStandBy+0x130>
8110cc54:	10802860 	cmpeqi	r2,r2,161
8110cc58:	10000b1e 	bne	r2,zero,8110cc88 <vQCmdFEEinStandBy+0xbc>
8110cc5c:	00003006 	br	8110cd20 <vQCmdFEEinStandBy+0x154>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110cc60:	e0bffe17 	ldw	r2,-8(fp)
8110cc64:	00c00044 	movi	r3,1
8110cc68:	10c02715 	stw	r3,156(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110cc6c:	e0bffe17 	ldw	r2,-8(fp)
8110cc70:	00c002c4 	movi	r3,11
8110cc74:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110cc78:	e0bffe17 	ldw	r2,-8(fp)
8110cc7c:	00c00144 	movi	r3,5
8110cc80:	10c02a15 	stw	r3,168(r2)
				break;
8110cc84:	00003106 	br	8110cd4c <vQCmdFEEinStandBy+0x180>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110cc88:	e0bffe17 	ldw	r2,-8(fp)
8110cc8c:	10002715 	stw	zero,156(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110cc90:	e0bffe17 	ldw	r2,-8(fp)
8110cc94:	00c00144 	movi	r3,5
8110cc98:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110cc9c:	e0bffe17 	ldw	r2,-8(fp)
8110cca0:	00c00144 	movi	r3,5
8110cca4:	10c02a15 	stw	r3,168(r2)
				break;				
8110cca8:	00002806 	br	8110cd4c <vQCmdFEEinStandBy+0x180>
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110ccac:	d0e05f17 	ldw	r3,-32388(gp)
8110ccb0:	e0bffe17 	ldw	r2,-8(fp)
8110ccb4:	10800003 	ldbu	r2,0(r2)
8110ccb8:	10803fcc 	andi	r2,r2,255
8110ccbc:	100d883a 	mov	r6,r2
8110ccc0:	01604534 	movhi	r5,33044
8110ccc4:	29594204 	addi	r5,r5,25864
8110ccc8:	1809883a 	mov	r4,r3
8110cccc:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110ccd0:	00001e06 	br	8110cd4c <vQCmdFEEinStandBy+0x180>
			case M_FEE_FULL_PATTERN:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110ccd4:	e0bffe17 	ldw	r2,-8(fp)
8110ccd8:	00c00044 	movi	r3,1
8110ccdc:	10c02715 	stw	r3,156(r2)
				pxNFeeP->xControl.eMode = sToTestFullPattern;
8110cce0:	e0bffe17 	ldw	r2,-8(fp)
8110cce4:	00c001c4 	movi	r3,7
8110cce8:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToTestFullPattern;
8110ccec:	e0bffe17 	ldw	r2,-8(fp)
8110ccf0:	00c001c4 	movi	r3,7
8110ccf4:	10c02a15 	stw	r3,168(r2)
				break;
8110ccf8:	00001406 	br	8110cd4c <vQCmdFEEinStandBy+0x180>
			case M_FEE_FULL_PATTERN_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ccfc:	e0bffe17 	ldw	r2,-8(fp)
8110cd00:	10002715 	stw	zero,156(r2)
				pxNFeeP->xControl.eMode = sToTestFullPattern;
8110cd04:	e0bffe17 	ldw	r2,-8(fp)
8110cd08:	00c001c4 	movi	r3,7
8110cd0c:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToTestFullPattern;
8110cd10:	e0bffe17 	ldw	r2,-8(fp)
8110cd14:	00c001c4 	movi	r3,7
8110cd18:	10c02a15 	stw	r3,168(r2)
				break;				
8110cd1c:	00000b06 	br	8110cd4c <vQCmdFEEinStandBy+0x180>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110cd20:	d0e05f17 	ldw	r3,-32388(gp)
8110cd24:	e0bffe17 	ldw	r2,-8(fp)
8110cd28:	10800003 	ldbu	r2,0(r2)
8110cd2c:	10803fcc 	andi	r2,r2,255
8110cd30:	100d883a 	mov	r6,r2
8110cd34:	01604534 	movhi	r5,33044
8110cd38:	29593104 	addi	r5,r5,25796
8110cd3c:	1809883a 	mov	r4,r3
8110cd40:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110cd44:	00000106 	br	8110cd4c <vQCmdFEEinStandBy+0x180>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110cd48:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110cd4c:	0001883a 	nop
8110cd50:	e037883a 	mov	sp,fp
8110cd54:	dfc00117 	ldw	ra,4(sp)
8110cd58:	df000017 	ldw	fp,0(sp)
8110cd5c:	dec00204 	addi	sp,sp,8
8110cd60:	f800283a 	ret

8110cd64 <vQCmdFEEinFullPattern>:

void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110cd64:	defffb04 	addi	sp,sp,-20
8110cd68:	de00012e 	bgeu	sp,et,8110cd70 <vQCmdFEEinFullPattern+0xc>
8110cd6c:	003b68fa 	trap	3
8110cd70:	dfc00415 	stw	ra,16(sp)
8110cd74:	df000315 	stw	fp,12(sp)
8110cd78:	df000304 	addi	fp,sp,12
8110cd7c:	e13ffe15 	stw	r4,-8(fp)
8110cd80:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110cd84:	e0bfff17 	ldw	r2,-4(fp)
8110cd88:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110cd8c:	e0bffdc3 	ldbu	r2,-9(fp)
8110cd90:	10c03fcc 	andi	r3,r2,255
8110cd94:	e0bffe17 	ldw	r2,-8(fp)
8110cd98:	10800003 	ldbu	r2,0(r2)
8110cd9c:	10803fcc 	andi	r2,r2,255
8110cda0:	10800444 	addi	r2,r2,17
8110cda4:	18804d1e 	bne	r3,r2,8110cedc <vQCmdFEEinFullPattern+0x178>

		switch (uiCmdFEEL.ucByte[2]) {
8110cda8:	e0bffd83 	ldbu	r2,-10(fp)
8110cdac:	10803fcc 	andi	r2,r2,255
8110cdb0:	10c00120 	cmpeqi	r3,r2,4
8110cdb4:	1800211e 	bne	r3,zero,8110ce3c <vQCmdFEEinFullPattern+0xd8>
8110cdb8:	10c00148 	cmpgei	r3,r2,5
8110cdbc:	1800051e 	bne	r3,zero,8110cdd4 <vQCmdFEEinFullPattern+0x70>
8110cdc0:	10c00060 	cmpeqi	r3,r2,1
8110cdc4:	18000a1e 	bne	r3,zero,8110cdf0 <vQCmdFEEinFullPattern+0x8c>
8110cdc8:	108000a0 	cmpeqi	r2,r2,2
8110cdcc:	1000421e 	bne	r2,zero,8110ced8 <vQCmdFEEinFullPattern+0x174>
8110cdd0:	00003706 	br	8110ceb0 <vQCmdFEEinFullPattern+0x14c>
8110cdd4:	10c02860 	cmpeqi	r3,r2,161
8110cdd8:	18000f1e 	bne	r3,zero,8110ce18 <vQCmdFEEinFullPattern+0xb4>
8110cddc:	10c02920 	cmpeqi	r3,r2,164
8110cde0:	1800201e 	bne	r3,zero,8110ce64 <vQCmdFEEinFullPattern+0x100>
8110cde4:	10800220 	cmpeqi	r2,r2,8
8110cde8:	1000271e 	bne	r2,zero,8110ce88 <vQCmdFEEinFullPattern+0x124>
8110cdec:	00003006 	br	8110ceb0 <vQCmdFEEinFullPattern+0x14c>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110cdf0:	e0bffe17 	ldw	r2,-8(fp)
8110cdf4:	00c00044 	movi	r3,1
8110cdf8:	10c02715 	stw	r3,156(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110cdfc:	e0bffe17 	ldw	r2,-8(fp)
8110ce00:	00c002c4 	movi	r3,11
8110ce04:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ce08:	e0bffe17 	ldw	r2,-8(fp)
8110ce0c:	00c00144 	movi	r3,5
8110ce10:	10c02a15 	stw	r3,168(r2)
				break;
8110ce14:	00003106 	br	8110cedc <vQCmdFEEinFullPattern+0x178>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ce18:	e0bffe17 	ldw	r2,-8(fp)
8110ce1c:	10002715 	stw	zero,156(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110ce20:	e0bffe17 	ldw	r2,-8(fp)
8110ce24:	00c00144 	movi	r3,5
8110ce28:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ce2c:	e0bffe17 	ldw	r2,-8(fp)
8110ce30:	00c00144 	movi	r3,5
8110ce34:	10c02a15 	stw	r3,168(r2)
				break;				
8110ce38:	00002806 	br	8110cedc <vQCmdFEEinFullPattern+0x178>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110ce3c:	e0bffe17 	ldw	r2,-8(fp)
8110ce40:	00c00044 	movi	r3,1
8110ce44:	10c02715 	stw	r3,156(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110ce48:	e0bffe17 	ldw	r2,-8(fp)
8110ce4c:	00c002c4 	movi	r3,11
8110ce50:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110ce54:	e0bffe17 	ldw	r2,-8(fp)
8110ce58:	00c00184 	movi	r3,6
8110ce5c:	10c02a15 	stw	r3,168(r2)
				break;
8110ce60:	00001e06 	br	8110cedc <vQCmdFEEinFullPattern+0x178>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ce64:	e0bffe17 	ldw	r2,-8(fp)
8110ce68:	10002715 	stw	zero,156(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110ce6c:	e0bffe17 	ldw	r2,-8(fp)
8110ce70:	00c00184 	movi	r3,6
8110ce74:	10c02915 	stw	r3,164(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110ce78:	e0bffe17 	ldw	r2,-8(fp)
8110ce7c:	00c00184 	movi	r3,6
8110ce80:	10c02a15 	stw	r3,168(r2)
				break;				
8110ce84:	00001506 	br	8110cedc <vQCmdFEEinFullPattern+0x178>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110ce88:	d0e05f17 	ldw	r3,-32388(gp)
8110ce8c:	e0bffe17 	ldw	r2,-8(fp)
8110ce90:	10800003 	ldbu	r2,0(r2)
8110ce94:	10803fcc 	andi	r2,r2,255
8110ce98:	100d883a 	mov	r6,r2
8110ce9c:	01604534 	movhi	r5,33044
8110cea0:	29594d04 	addi	r5,r5,25908
8110cea4:	1809883a 	mov	r4,r3
8110cea8:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110ceac:	00000b06 	br	8110cedc <vQCmdFEEinFullPattern+0x178>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110ceb0:	d0e05f17 	ldw	r3,-32388(gp)
8110ceb4:	e0bffe17 	ldw	r2,-8(fp)
8110ceb8:	10800003 	ldbu	r2,0(r2)
8110cebc:	10803fcc 	andi	r2,r2,255
8110cec0:	100d883a 	mov	r6,r2
8110cec4:	01604534 	movhi	r5,33044
8110cec8:	29593104 	addi	r5,r5,25796
8110cecc:	1809883a 	mov	r4,r3
8110ced0:	111a9600 	call	8111a960 <fprintf>
				#endif
				break;
8110ced4:	00000106 	br	8110cedc <vQCmdFEEinFullPattern+0x178>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110ced8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110cedc:	0001883a 	nop
8110cee0:	e037883a 	mov	sp,fp
8110cee4:	dfc00117 	ldw	ra,4(sp)
8110cee8:	df000017 	ldw	fp,0(sp)
8110ceec:	dec00204 	addi	sp,sp,8
8110cef0:	f800283a 	ret

8110cef4 <vPrintConsoleNFee>:



#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110cef4:	defffa04 	addi	sp,sp,-24
8110cef8:	de00012e 	bgeu	sp,et,8110cf00 <vPrintConsoleNFee+0xc>
8110cefc:	003b68fa 	trap	3
8110cf00:	dfc00515 	stw	ra,20(sp)
8110cf04:	df000415 	stw	fp,16(sp)
8110cf08:	df000404 	addi	fp,sp,16
8110cf0c:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110cf10:	e0bfff17 	ldw	r2,-4(fp)
8110cf14:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110cf18:	d0e05f17 	ldw	r3,-32388(gp)
8110cf1c:	e0bffe17 	ldw	r2,-8(fp)
8110cf20:	10800003 	ldbu	r2,0(r2)
8110cf24:	10803fcc 	andi	r2,r2,255
8110cf28:	100d883a 	mov	r6,r2
8110cf2c:	01604534 	movhi	r5,33044
8110cf30:	29595b04 	addi	r5,r5,25964
8110cf34:	1809883a 	mov	r4,r3
8110cf38:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110cf3c:	d0a05f17 	ldw	r2,-32388(gp)
8110cf40:	100b883a 	mov	r5,r2
8110cf44:	01000284 	movi	r4,10
8110cf48:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110cf4c:	d0e05f17 	ldw	r3,-32388(gp)
8110cf50:	e0bffe17 	ldw	r2,-8(fp)
8110cf54:	10800003 	ldbu	r2,0(r2)
8110cf58:	10803fcc 	andi	r2,r2,255
8110cf5c:	100d883a 	mov	r6,r2
8110cf60:	01604534 	movhi	r5,33044
8110cf64:	29597004 	addi	r5,r5,26048
8110cf68:	1809883a 	mov	r4,r3
8110cf6c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110cf70:	d0e05f17 	ldw	r3,-32388(gp)
8110cf74:	e0bffe17 	ldw	r2,-8(fp)
8110cf78:	10802c0b 	ldhu	r2,176(r2)
8110cf7c:	10bfffcc 	andi	r2,r2,65535
8110cf80:	100d883a 	mov	r6,r2
8110cf84:	01604534 	movhi	r5,33044
8110cf88:	29597604 	addi	r5,r5,26072
8110cf8c:	1809883a 	mov	r4,r3
8110cf90:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110cf94:	d0e05f17 	ldw	r3,-32388(gp)
8110cf98:	e0bffe17 	ldw	r2,-8(fp)
8110cf9c:	10802c8b 	ldhu	r2,178(r2)
8110cfa0:	10bfffcc 	andi	r2,r2,65535
8110cfa4:	100d883a 	mov	r6,r2
8110cfa8:	01604534 	movhi	r5,33044
8110cfac:	29597b04 	addi	r5,r5,26092
8110cfb0:	1809883a 	mov	r4,r3
8110cfb4:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110cfb8:	d0e05f17 	ldw	r3,-32388(gp)
8110cfbc:	e0bffe17 	ldw	r2,-8(fp)
8110cfc0:	10802d0b 	ldhu	r2,180(r2)
8110cfc4:	10bfffcc 	andi	r2,r2,65535
8110cfc8:	100d883a 	mov	r6,r2
8110cfcc:	01604534 	movhi	r5,33044
8110cfd0:	29598104 	addi	r5,r5,26116
8110cfd4:	1809883a 	mov	r4,r3
8110cfd8:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110cfdc:	d0e05f17 	ldw	r3,-32388(gp)
8110cfe0:	e0bffe17 	ldw	r2,-8(fp)
8110cfe4:	10802d8b 	ldhu	r2,182(r2)
8110cfe8:	10bfffcc 	andi	r2,r2,65535
8110cfec:	100d883a 	mov	r6,r2
8110cff0:	01604534 	movhi	r5,33044
8110cff4:	29598504 	addi	r5,r5,26132
8110cff8:	1809883a 	mov	r4,r3
8110cffc:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110d000:	d0e05f17 	ldw	r3,-32388(gp)
8110d004:	e0bffe17 	ldw	r2,-8(fp)
8110d008:	10802e0b 	ldhu	r2,184(r2)
8110d00c:	10bfffcc 	andi	r2,r2,65535
8110d010:	100d883a 	mov	r6,r2
8110d014:	01604534 	movhi	r5,33044
8110d018:	29598b04 	addi	r5,r5,26156
8110d01c:	1809883a 	mov	r4,r3
8110d020:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110d024:	d0a05f17 	ldw	r2,-32388(gp)
8110d028:	100b883a 	mov	r5,r2
8110d02c:	01000284 	movi	r4,10
8110d030:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110d034:	d0e05f17 	ldw	r3,-32388(gp)
8110d038:	e0bffe17 	ldw	r2,-8(fp)
8110d03c:	10800003 	ldbu	r2,0(r2)
8110d040:	10803fcc 	andi	r2,r2,255
8110d044:	100d883a 	mov	r6,r2
8110d048:	01604534 	movhi	r5,33044
8110d04c:	29599004 	addi	r5,r5,26176
8110d050:	1809883a 	mov	r4,r3
8110d054:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110d058:	d0e05f17 	ldw	r3,-32388(gp)
8110d05c:	e0bffe17 	ldw	r2,-8(fp)
8110d060:	10802917 	ldw	r2,164(r2)
8110d064:	100d883a 	mov	r6,r2
8110d068:	01604534 	movhi	r5,33044
8110d06c:	29599604 	addi	r5,r5,26200
8110d070:	1809883a 	mov	r4,r3
8110d074:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110d078:	d0e05f17 	ldw	r3,-32388(gp)
8110d07c:	e0bffe17 	ldw	r2,-8(fp)
8110d080:	10802117 	ldw	r2,132(r2)
8110d084:	100d883a 	mov	r6,r2
8110d088:	01604534 	movhi	r5,33044
8110d08c:	29599c04 	addi	r5,r5,26224
8110d090:	1809883a 	mov	r4,r3
8110d094:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110d098:	d0e05f17 	ldw	r3,-32388(gp)
8110d09c:	e0bffe17 	ldw	r2,-8(fp)
8110d0a0:	10802217 	ldw	r2,136(r2)
8110d0a4:	100d883a 	mov	r6,r2
8110d0a8:	01604534 	movhi	r5,33044
8110d0ac:	2959a304 	addi	r5,r5,26252
8110d0b0:	1809883a 	mov	r4,r3
8110d0b4:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110d0b8:	d0e05f17 	ldw	r3,-32388(gp)
8110d0bc:	e0bffe17 	ldw	r2,-8(fp)
8110d0c0:	10802317 	ldw	r2,140(r2)
8110d0c4:	100d883a 	mov	r6,r2
8110d0c8:	01604534 	movhi	r5,33044
8110d0cc:	2959aa04 	addi	r5,r5,26280
8110d0d0:	1809883a 	mov	r4,r3
8110d0d4:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110d0d8:	d0e05f17 	ldw	r3,-32388(gp)
8110d0dc:	e0bffe17 	ldw	r2,-8(fp)
8110d0e0:	10802417 	ldw	r2,144(r2)
8110d0e4:	100d883a 	mov	r6,r2
8110d0e8:	01604534 	movhi	r5,33044
8110d0ec:	2959b104 	addi	r5,r5,26308
8110d0f0:	1809883a 	mov	r4,r3
8110d0f4:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110d0f8:	d0e05f17 	ldw	r3,-32388(gp)
8110d0fc:	e0bffe17 	ldw	r2,-8(fp)
8110d100:	10802517 	ldw	r2,148(r2)
8110d104:	100d883a 	mov	r6,r2
8110d108:	01604534 	movhi	r5,33044
8110d10c:	2959b804 	addi	r5,r5,26336
8110d110:	1809883a 	mov	r4,r3
8110d114:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110d118:	d1205f17 	ldw	r4,-32388(gp)
8110d11c:	e0bffe17 	ldw	r2,-8(fp)
8110d120:	10802803 	ldbu	r2,160(r2)
8110d124:	11403fcc 	andi	r5,r2,255
8110d128:	e0bffe17 	ldw	r2,-8(fp)
8110d12c:	10802843 	ldbu	r2,161(r2)
8110d130:	11803fcc 	andi	r6,r2,255
8110d134:	e0bffe17 	ldw	r2,-8(fp)
8110d138:	10802883 	ldbu	r2,162(r2)
8110d13c:	10803fcc 	andi	r2,r2,255
8110d140:	e0fffe17 	ldw	r3,-8(fp)
8110d144:	18c028c3 	ldbu	r3,163(r3)
8110d148:	18c03fcc 	andi	r3,r3,255
8110d14c:	d8c00115 	stw	r3,4(sp)
8110d150:	d8800015 	stw	r2,0(sp)
8110d154:	300f883a 	mov	r7,r6
8110d158:	280d883a 	mov	r6,r5
8110d15c:	01604534 	movhi	r5,33044
8110d160:	2959bf04 	addi	r5,r5,26364
8110d164:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110d168:	d0e05f17 	ldw	r3,-32388(gp)
8110d16c:	e0bffe17 	ldw	r2,-8(fp)
8110d170:	10802b17 	ldw	r2,172(r2)
8110d174:	100d883a 	mov	r6,r2
8110d178:	01604534 	movhi	r5,33044
8110d17c:	2959cc04 	addi	r5,r5,26416
8110d180:	1809883a 	mov	r4,r3
8110d184:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n\n");
8110d188:	d0a05f17 	ldw	r2,-32388(gp)
8110d18c:	100f883a 	mov	r7,r2
8110d190:	01800084 	movi	r6,2
8110d194:	01400044 	movi	r5,1
8110d198:	01204534 	movhi	r4,33044
8110d19c:	2119d204 	addi	r4,r4,26440
8110d1a0:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110d1a4:	d0e05f17 	ldw	r3,-32388(gp)
8110d1a8:	e0bffe17 	ldw	r2,-8(fp)
8110d1ac:	10800003 	ldbu	r2,0(r2)
8110d1b0:	10803fcc 	andi	r2,r2,255
8110d1b4:	100d883a 	mov	r6,r2
8110d1b8:	01604534 	movhi	r5,33044
8110d1bc:	2959d304 	addi	r5,r5,26444
8110d1c0:	1809883a 	mov	r4,r3
8110d1c4:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    General Info: \n");
8110d1c8:	d0a05f17 	ldw	r2,-32388(gp)
8110d1cc:	100f883a 	mov	r7,r2
8110d1d0:	018004c4 	movi	r6,19
8110d1d4:	01400044 	movi	r5,1
8110d1d8:	01204534 	movhi	r4,33044
8110d1dc:	2119d904 	addi	r4,r4,26468
8110d1e0:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110d1e4:	d0e05f17 	ldw	r3,-32388(gp)
8110d1e8:	e0bffe17 	ldw	r2,-8(fp)
8110d1ec:	10800117 	ldw	r2,4(r2)
8110d1f0:	100d883a 	mov	r6,r2
8110d1f4:	01604534 	movhi	r5,33044
8110d1f8:	2959de04 	addi	r5,r5,26488
8110d1fc:	1809883a 	mov	r4,r3
8110d200:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110d204:	d0e05f17 	ldw	r3,-32388(gp)
8110d208:	e0bffe17 	ldw	r2,-8(fp)
8110d20c:	10800217 	ldw	r2,8(r2)
8110d210:	100d883a 	mov	r6,r2
8110d214:	01604534 	movhi	r5,33044
8110d218:	2959e604 	addi	r5,r5,26520
8110d21c:	1809883a 	mov	r4,r3
8110d220:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110d224:	d0e05f17 	ldw	r3,-32388(gp)
8110d228:	e0bffe17 	ldw	r2,-8(fp)
8110d22c:	10800317 	ldw	r2,12(r2)
8110d230:	100d883a 	mov	r6,r2
8110d234:	01604534 	movhi	r5,33044
8110d238:	2959ee04 	addi	r5,r5,26552
8110d23c:	1809883a 	mov	r4,r3
8110d240:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110d244:	d0a05f17 	ldw	r2,-32388(gp)
8110d248:	100f883a 	mov	r7,r2
8110d24c:	01800644 	movi	r6,25
8110d250:	01400044 	movi	r5,1
8110d254:	01204534 	movhi	r4,33044
8110d258:	2119f504 	addi	r4,r4,26580
8110d25c:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110d260:	d0e05f17 	ldw	r3,-32388(gp)
8110d264:	e0bffe17 	ldw	r2,-8(fp)
8110d268:	10800517 	ldw	r2,20(r2)
8110d26c:	100d883a 	mov	r6,r2
8110d270:	01604534 	movhi	r5,33044
8110d274:	2959fc04 	addi	r5,r5,26608
8110d278:	1809883a 	mov	r4,r3
8110d27c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110d280:	d0e05f17 	ldw	r3,-32388(gp)
8110d284:	e0bffe17 	ldw	r2,-8(fp)
8110d288:	10800417 	ldw	r2,16(r2)
8110d28c:	100d883a 	mov	r6,r2
8110d290:	01604534 	movhi	r5,33044
8110d294:	295a0404 	addi	r5,r5,26640
8110d298:	1809883a 	mov	r4,r3
8110d29c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110d2a0:	d0e05f17 	ldw	r3,-32388(gp)
8110d2a4:	e0bffe17 	ldw	r2,-8(fp)
8110d2a8:	10800603 	ldbu	r2,24(r2)
8110d2ac:	10803fcc 	andi	r2,r2,255
8110d2b0:	100d883a 	mov	r6,r2
8110d2b4:	01604534 	movhi	r5,33044
8110d2b8:	295a0c04 	addi	r5,r5,26672
8110d2bc:	1809883a 	mov	r4,r3
8110d2c0:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110d2c4:	d2205f17 	ldw	r8,-32388(gp)
8110d2c8:	e13ffe17 	ldw	r4,-8(fp)
8110d2cc:	20800717 	ldw	r2,28(r4)
8110d2d0:	20c00817 	ldw	r3,32(r4)
8110d2d4:	100d883a 	mov	r6,r2
8110d2d8:	180f883a 	mov	r7,r3
8110d2dc:	01604534 	movhi	r5,33044
8110d2e0:	295a1404 	addi	r5,r5,26704
8110d2e4:	4009883a 	mov	r4,r8
8110d2e8:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110d2ec:	d0a05f17 	ldw	r2,-32388(gp)
8110d2f0:	100b883a 	mov	r5,r2
8110d2f4:	01000284 	movi	r4,10
8110d2f8:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8110d2fc:	d0e05f17 	ldw	r3,-32388(gp)
8110d300:	e0bffe17 	ldw	r2,-8(fp)
8110d304:	10800003 	ldbu	r2,0(r2)
8110d308:	10803fcc 	andi	r2,r2,255
8110d30c:	100f883a 	mov	r7,r2
8110d310:	000d883a 	mov	r6,zero
8110d314:	01604534 	movhi	r5,33044
8110d318:	295a1c04 	addi	r5,r5,26736
8110d31c:	1809883a 	mov	r4,r3
8110d320:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Left side \n");
8110d324:	d0a05f17 	ldw	r2,-32388(gp)
8110d328:	100f883a 	mov	r7,r2
8110d32c:	018004c4 	movi	r6,19
8110d330:	01400044 	movi	r5,1
8110d334:	01204534 	movhi	r4,33044
8110d338:	211a2604 	addi	r4,r4,26776
8110d33c:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
8110d340:	d0e05f17 	ldw	r3,-32388(gp)
8110d344:	e0bffe17 	ldw	r2,-8(fp)
8110d348:	10800917 	ldw	r2,36(r2)
8110d34c:	100d883a 	mov	r6,r2
8110d350:	01604534 	movhi	r5,33044
8110d354:	295a2b04 	addi	r5,r5,26796
8110d358:	1809883a 	mov	r4,r3
8110d35c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
8110d360:	d0e05f17 	ldw	r3,-32388(gp)
8110d364:	e0bffe17 	ldw	r2,-8(fp)
8110d368:	10800a17 	ldw	r2,40(r2)
8110d36c:	100d883a 	mov	r6,r2
8110d370:	01604534 	movhi	r5,33044
8110d374:	295a3404 	addi	r5,r5,26832
8110d378:	1809883a 	mov	r4,r3
8110d37c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
8110d380:	d0e05f17 	ldw	r3,-32388(gp)
8110d384:	e0bffe17 	ldw	r2,-8(fp)
8110d388:	10800b17 	ldw	r2,44(r2)
8110d38c:	100d883a 	mov	r6,r2
8110d390:	01604534 	movhi	r5,33044
8110d394:	295a3f04 	addi	r5,r5,26876
8110d398:	1809883a 	mov	r4,r3
8110d39c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Right side \n");
8110d3a0:	d0a05f17 	ldw	r2,-32388(gp)
8110d3a4:	100f883a 	mov	r7,r2
8110d3a8:	01800504 	movi	r6,20
8110d3ac:	01400044 	movi	r5,1
8110d3b0:	01204534 	movhi	r4,33044
8110d3b4:	211a4b04 	addi	r4,r4,26924
8110d3b8:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8110d3bc:	d0e05f17 	ldw	r3,-32388(gp)
8110d3c0:	e0bffe17 	ldw	r2,-8(fp)
8110d3c4:	10800c17 	ldw	r2,48(r2)
8110d3c8:	100d883a 	mov	r6,r2
8110d3cc:	01604534 	movhi	r5,33044
8110d3d0:	295a2b04 	addi	r5,r5,26796
8110d3d4:	1809883a 	mov	r4,r3
8110d3d8:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8110d3dc:	d0e05f17 	ldw	r3,-32388(gp)
8110d3e0:	e0bffe17 	ldw	r2,-8(fp)
8110d3e4:	10800d17 	ldw	r2,52(r2)
8110d3e8:	100d883a 	mov	r6,r2
8110d3ec:	01604534 	movhi	r5,33044
8110d3f0:	295a3404 	addi	r5,r5,26832
8110d3f4:	1809883a 	mov	r4,r3
8110d3f8:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8110d3fc:	d0e05f17 	ldw	r3,-32388(gp)
8110d400:	e0bffe17 	ldw	r2,-8(fp)
8110d404:	10800e17 	ldw	r2,56(r2)
8110d408:	100d883a 	mov	r6,r2
8110d40c:	01604534 	movhi	r5,33044
8110d410:	295a3f04 	addi	r5,r5,26876
8110d414:	1809883a 	mov	r4,r3
8110d418:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110d41c:	d0a05f17 	ldw	r2,-32388(gp)
8110d420:	100b883a 	mov	r5,r2
8110d424:	01000284 	movi	r4,10
8110d428:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8110d42c:	d0e05f17 	ldw	r3,-32388(gp)
8110d430:	e0bffe17 	ldw	r2,-8(fp)
8110d434:	10800003 	ldbu	r2,0(r2)
8110d438:	10803fcc 	andi	r2,r2,255
8110d43c:	100f883a 	mov	r7,r2
8110d440:	01800044 	movi	r6,1
8110d444:	01604534 	movhi	r5,33044
8110d448:	295a1c04 	addi	r5,r5,26736
8110d44c:	1809883a 	mov	r4,r3
8110d450:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Left side \n");
8110d454:	d0a05f17 	ldw	r2,-32388(gp)
8110d458:	100f883a 	mov	r7,r2
8110d45c:	018004c4 	movi	r6,19
8110d460:	01400044 	movi	r5,1
8110d464:	01204534 	movhi	r4,33044
8110d468:	211a2604 	addi	r4,r4,26776
8110d46c:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
8110d470:	d0e05f17 	ldw	r3,-32388(gp)
8110d474:	e0bffe17 	ldw	r2,-8(fp)
8110d478:	10800f17 	ldw	r2,60(r2)
8110d47c:	100d883a 	mov	r6,r2
8110d480:	01604534 	movhi	r5,33044
8110d484:	295a2b04 	addi	r5,r5,26796
8110d488:	1809883a 	mov	r4,r3
8110d48c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
8110d490:	d0e05f17 	ldw	r3,-32388(gp)
8110d494:	e0bffe17 	ldw	r2,-8(fp)
8110d498:	10801017 	ldw	r2,64(r2)
8110d49c:	100d883a 	mov	r6,r2
8110d4a0:	01604534 	movhi	r5,33044
8110d4a4:	295a3404 	addi	r5,r5,26832
8110d4a8:	1809883a 	mov	r4,r3
8110d4ac:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
8110d4b0:	d0e05f17 	ldw	r3,-32388(gp)
8110d4b4:	e0bffe17 	ldw	r2,-8(fp)
8110d4b8:	10801117 	ldw	r2,68(r2)
8110d4bc:	100d883a 	mov	r6,r2
8110d4c0:	01604534 	movhi	r5,33044
8110d4c4:	295a3f04 	addi	r5,r5,26876
8110d4c8:	1809883a 	mov	r4,r3
8110d4cc:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Right side \n");
8110d4d0:	d0a05f17 	ldw	r2,-32388(gp)
8110d4d4:	100f883a 	mov	r7,r2
8110d4d8:	01800504 	movi	r6,20
8110d4dc:	01400044 	movi	r5,1
8110d4e0:	01204534 	movhi	r4,33044
8110d4e4:	211a4b04 	addi	r4,r4,26924
8110d4e8:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8110d4ec:	d0e05f17 	ldw	r3,-32388(gp)
8110d4f0:	e0bffe17 	ldw	r2,-8(fp)
8110d4f4:	10801217 	ldw	r2,72(r2)
8110d4f8:	100d883a 	mov	r6,r2
8110d4fc:	01604534 	movhi	r5,33044
8110d500:	295a2b04 	addi	r5,r5,26796
8110d504:	1809883a 	mov	r4,r3
8110d508:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8110d50c:	d0e05f17 	ldw	r3,-32388(gp)
8110d510:	e0bffe17 	ldw	r2,-8(fp)
8110d514:	10801317 	ldw	r2,76(r2)
8110d518:	100d883a 	mov	r6,r2
8110d51c:	01604534 	movhi	r5,33044
8110d520:	295a3404 	addi	r5,r5,26832
8110d524:	1809883a 	mov	r4,r3
8110d528:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8110d52c:	d0e05f17 	ldw	r3,-32388(gp)
8110d530:	e0bffe17 	ldw	r2,-8(fp)
8110d534:	10801417 	ldw	r2,80(r2)
8110d538:	100d883a 	mov	r6,r2
8110d53c:	01604534 	movhi	r5,33044
8110d540:	295a3f04 	addi	r5,r5,26876
8110d544:	1809883a 	mov	r4,r3
8110d548:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110d54c:	d0a05f17 	ldw	r2,-32388(gp)
8110d550:	100b883a 	mov	r5,r2
8110d554:	01000284 	movi	r4,10
8110d558:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8110d55c:	d0e05f17 	ldw	r3,-32388(gp)
8110d560:	e0bffe17 	ldw	r2,-8(fp)
8110d564:	10800003 	ldbu	r2,0(r2)
8110d568:	10803fcc 	andi	r2,r2,255
8110d56c:	100f883a 	mov	r7,r2
8110d570:	01800084 	movi	r6,2
8110d574:	01604534 	movhi	r5,33044
8110d578:	295a1c04 	addi	r5,r5,26736
8110d57c:	1809883a 	mov	r4,r3
8110d580:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Left side \n");
8110d584:	d0a05f17 	ldw	r2,-32388(gp)
8110d588:	100f883a 	mov	r7,r2
8110d58c:	018004c4 	movi	r6,19
8110d590:	01400044 	movi	r5,1
8110d594:	01204534 	movhi	r4,33044
8110d598:	211a2604 	addi	r4,r4,26776
8110d59c:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
8110d5a0:	d0e05f17 	ldw	r3,-32388(gp)
8110d5a4:	e0bffe17 	ldw	r2,-8(fp)
8110d5a8:	10801517 	ldw	r2,84(r2)
8110d5ac:	100d883a 	mov	r6,r2
8110d5b0:	01604534 	movhi	r5,33044
8110d5b4:	295a2b04 	addi	r5,r5,26796
8110d5b8:	1809883a 	mov	r4,r3
8110d5bc:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
8110d5c0:	d0e05f17 	ldw	r3,-32388(gp)
8110d5c4:	e0bffe17 	ldw	r2,-8(fp)
8110d5c8:	10801617 	ldw	r2,88(r2)
8110d5cc:	100d883a 	mov	r6,r2
8110d5d0:	01604534 	movhi	r5,33044
8110d5d4:	295a3404 	addi	r5,r5,26832
8110d5d8:	1809883a 	mov	r4,r3
8110d5dc:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
8110d5e0:	d0e05f17 	ldw	r3,-32388(gp)
8110d5e4:	e0bffe17 	ldw	r2,-8(fp)
8110d5e8:	10801717 	ldw	r2,92(r2)
8110d5ec:	100d883a 	mov	r6,r2
8110d5f0:	01604534 	movhi	r5,33044
8110d5f4:	295a3f04 	addi	r5,r5,26876
8110d5f8:	1809883a 	mov	r4,r3
8110d5fc:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Right side \n");
8110d600:	d0a05f17 	ldw	r2,-32388(gp)
8110d604:	100f883a 	mov	r7,r2
8110d608:	01800504 	movi	r6,20
8110d60c:	01400044 	movi	r5,1
8110d610:	01204534 	movhi	r4,33044
8110d614:	211a4b04 	addi	r4,r4,26924
8110d618:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8110d61c:	d0e05f17 	ldw	r3,-32388(gp)
8110d620:	e0bffe17 	ldw	r2,-8(fp)
8110d624:	10801817 	ldw	r2,96(r2)
8110d628:	100d883a 	mov	r6,r2
8110d62c:	01604534 	movhi	r5,33044
8110d630:	295a2b04 	addi	r5,r5,26796
8110d634:	1809883a 	mov	r4,r3
8110d638:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8110d63c:	d0e05f17 	ldw	r3,-32388(gp)
8110d640:	e0bffe17 	ldw	r2,-8(fp)
8110d644:	10801917 	ldw	r2,100(r2)
8110d648:	100d883a 	mov	r6,r2
8110d64c:	01604534 	movhi	r5,33044
8110d650:	295a3404 	addi	r5,r5,26832
8110d654:	1809883a 	mov	r4,r3
8110d658:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8110d65c:	d0e05f17 	ldw	r3,-32388(gp)
8110d660:	e0bffe17 	ldw	r2,-8(fp)
8110d664:	10801a17 	ldw	r2,104(r2)
8110d668:	100d883a 	mov	r6,r2
8110d66c:	01604534 	movhi	r5,33044
8110d670:	295a3f04 	addi	r5,r5,26876
8110d674:	1809883a 	mov	r4,r3
8110d678:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110d67c:	d0a05f17 	ldw	r2,-32388(gp)
8110d680:	100b883a 	mov	r5,r2
8110d684:	01000284 	movi	r4,10
8110d688:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8110d68c:	d0e05f17 	ldw	r3,-32388(gp)
8110d690:	e0bffe17 	ldw	r2,-8(fp)
8110d694:	10800003 	ldbu	r2,0(r2)
8110d698:	10803fcc 	andi	r2,r2,255
8110d69c:	100f883a 	mov	r7,r2
8110d6a0:	018000c4 	movi	r6,3
8110d6a4:	01604534 	movhi	r5,33044
8110d6a8:	295a1c04 	addi	r5,r5,26736
8110d6ac:	1809883a 	mov	r4,r3
8110d6b0:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Left side \n");
8110d6b4:	d0a05f17 	ldw	r2,-32388(gp)
8110d6b8:	100f883a 	mov	r7,r2
8110d6bc:	018004c4 	movi	r6,19
8110d6c0:	01400044 	movi	r5,1
8110d6c4:	01204534 	movhi	r4,33044
8110d6c8:	211a2604 	addi	r4,r4,26776
8110d6cc:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
8110d6d0:	d0e05f17 	ldw	r3,-32388(gp)
8110d6d4:	e0bffe17 	ldw	r2,-8(fp)
8110d6d8:	10801b17 	ldw	r2,108(r2)
8110d6dc:	100d883a 	mov	r6,r2
8110d6e0:	01604534 	movhi	r5,33044
8110d6e4:	295a2b04 	addi	r5,r5,26796
8110d6e8:	1809883a 	mov	r4,r3
8110d6ec:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
8110d6f0:	d0e05f17 	ldw	r3,-32388(gp)
8110d6f4:	e0bffe17 	ldw	r2,-8(fp)
8110d6f8:	10801c17 	ldw	r2,112(r2)
8110d6fc:	100d883a 	mov	r6,r2
8110d700:	01604534 	movhi	r5,33044
8110d704:	295a3404 	addi	r5,r5,26832
8110d708:	1809883a 	mov	r4,r3
8110d70c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
8110d710:	d0e05f17 	ldw	r3,-32388(gp)
8110d714:	e0bffe17 	ldw	r2,-8(fp)
8110d718:	10801d17 	ldw	r2,116(r2)
8110d71c:	100d883a 	mov	r6,r2
8110d720:	01604534 	movhi	r5,33044
8110d724:	295a3f04 	addi	r5,r5,26876
8110d728:	1809883a 	mov	r4,r3
8110d72c:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"        Right side \n");
8110d730:	d0a05f17 	ldw	r2,-32388(gp)
8110d734:	100f883a 	mov	r7,r2
8110d738:	01800504 	movi	r6,20
8110d73c:	01400044 	movi	r5,1
8110d740:	01204534 	movhi	r4,33044
8110d744:	211a4b04 	addi	r4,r4,26924
8110d748:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8110d74c:	d0e05f17 	ldw	r3,-32388(gp)
8110d750:	e0bffe17 	ldw	r2,-8(fp)
8110d754:	10801e17 	ldw	r2,120(r2)
8110d758:	100d883a 	mov	r6,r2
8110d75c:	01604534 	movhi	r5,33044
8110d760:	295a2b04 	addi	r5,r5,26796
8110d764:	1809883a 	mov	r4,r3
8110d768:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8110d76c:	d0e05f17 	ldw	r3,-32388(gp)
8110d770:	e0bffe17 	ldw	r2,-8(fp)
8110d774:	10801f17 	ldw	r2,124(r2)
8110d778:	100d883a 	mov	r6,r2
8110d77c:	01604534 	movhi	r5,33044
8110d780:	295a3404 	addi	r5,r5,26832
8110d784:	1809883a 	mov	r4,r3
8110d788:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8110d78c:	d0e05f17 	ldw	r3,-32388(gp)
8110d790:	e0bffe17 	ldw	r2,-8(fp)
8110d794:	10802017 	ldw	r2,128(r2)
8110d798:	100d883a 	mov	r6,r2
8110d79c:	01604534 	movhi	r5,33044
8110d7a0:	295a3f04 	addi	r5,r5,26876
8110d7a4:	1809883a 	mov	r4,r3
8110d7a8:	111a9600 	call	8111a960 <fprintf>
		fprintf(fp,"\n");
8110d7ac:	d0a05f17 	ldw	r2,-32388(gp)
8110d7b0:	100b883a 	mov	r5,r2
8110d7b4:	01000284 	movi	r4,10
8110d7b8:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"==============================================================================\n");
8110d7bc:	d0a05f17 	ldw	r2,-32388(gp)
8110d7c0:	100f883a 	mov	r7,r2
8110d7c4:	018013c4 	movi	r6,79
8110d7c8:	01400044 	movi	r5,1
8110d7cc:	01204534 	movhi	r4,33044
8110d7d0:	211a5104 	addi	r4,r4,26948
8110d7d4:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"==============================================================================\n");
8110d7d8:	d0a05f17 	ldw	r2,-32388(gp)
8110d7dc:	100f883a 	mov	r7,r2
8110d7e0:	018013c4 	movi	r6,79
8110d7e4:	01400044 	movi	r5,1
8110d7e8:	01204534 	movhi	r4,33044
8110d7ec:	211a5104 	addi	r4,r4,26948
8110d7f0:	111affc0 	call	8111affc <fwrite>
		fprintf(fp,"\n");
8110d7f4:	d0a05f17 	ldw	r2,-32388(gp)
8110d7f8:	100b883a 	mov	r5,r2
8110d7fc:	01000284 	movi	r4,10
8110d800:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"\n");
8110d804:	d0a05f17 	ldw	r2,-32388(gp)
8110d808:	100b883a 	mov	r5,r2
8110d80c:	01000284 	movi	r4,10
8110d810:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"\n");
8110d814:	d0a05f17 	ldw	r2,-32388(gp)
8110d818:	100b883a 	mov	r5,r2
8110d81c:	01000284 	movi	r4,10
8110d820:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"\n");
8110d824:	d0a05f17 	ldw	r2,-32388(gp)
8110d828:	100b883a 	mov	r5,r2
8110d82c:	01000284 	movi	r4,10
8110d830:	111a9d80 	call	8111a9d8 <fputc>
		fprintf(fp,"\n");
8110d834:	d0a05f17 	ldw	r2,-32388(gp)
8110d838:	100b883a 	mov	r5,r2
8110d83c:	01000284 	movi	r4,10
8110d840:	111a9d80 	call	8111a9d8 <fputc>
	}
8110d844:	0001883a 	nop
8110d848:	e037883a 	mov	sp,fp
8110d84c:	dfc00117 	ldw	ra,4(sp)
8110d850:	df000017 	ldw	fp,0(sp)
8110d854:	dec00204 	addi	sp,sp,8
8110d858:	f800283a 	ret

8110d85c <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110d85c:	defff604 	addi	sp,sp,-40
8110d860:	de00012e 	bgeu	sp,et,8110d868 <vInAckHandlerTaskV2+0xc>
8110d864:	003b68fa 	trap	3
8110d868:	dfc00915 	stw	ra,36(sp)
8110d86c:	df000815 	stw	fp,32(sp)
8110d870:	df000804 	addi	fp,sp,32
8110d874:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110d878:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110d87c:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110d880:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110d884:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110d888:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110d88c:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110d890:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
8110d894:	d0a05f17 	ldw	r2,-32388(gp)
8110d898:	100f883a 	mov	r7,r2
8110d89c:	018007c4 	movi	r6,31
8110d8a0:	01400044 	movi	r5,1
8110d8a4:	01204534 	movhi	r4,33044
8110d8a8:	211a6504 	addi	r4,r4,27028
8110d8ac:	111affc0 	call	8111affc <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8110d8b0:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110d8b4:	e0bff917 	ldw	r2,-28(fp)
8110d8b8:	10c00060 	cmpeqi	r3,r2,1
8110d8bc:	1800071e 	bne	r3,zero,8110d8dc <vInAckHandlerTaskV2+0x80>
8110d8c0:	0080032e 	bgeu	zero,r2,8110d8d0 <vInAckHandlerTaskV2+0x74>
8110d8c4:	108000a0 	cmpeqi	r2,r2,2
8110d8c8:	10004a1e 	bne	r2,zero,8110d9f4 <vInAckHandlerTaskV2+0x198>
8110d8cc:	0000ac06 	br	8110db80 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110d8d0:	00800044 	movi	r2,1
8110d8d4:	e0bff915 	stw	r2,-28(fp)
				break;
8110d8d8:	0000b306 	br	8110dba8 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110d8dc:	00800044 	movi	r2,1
8110d8e0:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110d8e4:	d0a06317 	ldw	r2,-32372(gp)
8110d8e8:	e0fffe04 	addi	r3,fp,-8
8110d8ec:	180d883a 	mov	r6,r3
8110d8f0:	000b883a 	mov	r5,zero
8110d8f4:	1009883a 	mov	r4,r2
8110d8f8:	1138a3c0 	call	81138a3c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110d8fc:	e0bffe03 	ldbu	r2,-8(fp)
8110d900:	10803fcc 	andi	r2,r2,255
8110d904:	1000391e 	bne	r2,zero,8110d9ec <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110d908:	d0a06217 	ldw	r2,-32376(gp)
8110d90c:	e0fffe04 	addi	r3,fp,-8
8110d910:	180d883a 	mov	r6,r3
8110d914:	000b883a 	mov	r5,zero
8110d918:	1009883a 	mov	r4,r2
8110d91c:	1136a300 	call	81136a30 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110d920:	e0bffe03 	ldbu	r2,-8(fp)
8110d924:	10803fcc 	andi	r2,r2,255
8110d928:	10002b1e 	bne	r2,zero,8110d9d8 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110d92c:	e03ffa45 	stb	zero,-23(fp)
8110d930:	00002206 	br	8110d9bc <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110d934:	e0fffa43 	ldbu	r3,-23(fp)
8110d938:	00a045b4 	movhi	r2,33046
8110d93c:	10a7ff04 	addi	r2,r2,-24580
8110d940:	18c7883a 	add	r3,r3,r3
8110d944:	18c7883a 	add	r3,r3,r3
8110d948:	10c5883a 	add	r2,r2,r3
8110d94c:	10800003 	ldbu	r2,0(r2)
8110d950:	10803fcc 	andi	r2,r2,255
8110d954:	1080201c 	xori	r2,r2,128
8110d958:	10bfe004 	addi	r2,r2,-128
8110d95c:	10001426 	beq	r2,zero,8110d9b0 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110d960:	e0fffa43 	ldbu	r3,-23(fp)
8110d964:	00a045b4 	movhi	r2,33046
8110d968:	10a7ff04 	addi	r2,r2,-24580
8110d96c:	18c7883a 	add	r3,r3,r3
8110d970:	18c7883a 	add	r3,r3,r3
8110d974:	10c5883a 	add	r2,r2,r3
8110d978:	10c0000b 	ldhu	r3,0(r2)
8110d97c:	d0e0540d 	sth	r3,-32432(gp)
8110d980:	1080008b 	ldhu	r2,2(r2)
8110d984:	d0a0548d 	sth	r2,-32430(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110d988:	e0fffa43 	ldbu	r3,-23(fp)
8110d98c:	00a045b4 	movhi	r2,33046
8110d990:	10a7ff04 	addi	r2,r2,-24580
8110d994:	18c7883a 	add	r3,r3,r3
8110d998:	18c7883a 	add	r3,r3,r3
8110d99c:	10c5883a 	add	r2,r2,r3
8110d9a0:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110d9a4:	00800084 	movi	r2,2
8110d9a8:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110d9ac:	00000606 	br	8110d9c8 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110d9b0:	e0bffa43 	ldbu	r2,-23(fp)
8110d9b4:	10800044 	addi	r2,r2,1
8110d9b8:	e0bffa45 	stb	r2,-23(fp)
8110d9bc:	e0bffa43 	ldbu	r2,-23(fp)
8110d9c0:	108001b0 	cmpltui	r2,r2,6
8110d9c4:	103fdb1e 	bne	r2,zero,8110d934 <__reset+0xfb0ed934>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110d9c8:	d0a06217 	ldw	r2,-32376(gp)
8110d9cc:	1009883a 	mov	r4,r2
8110d9d0:	1136fd40 	call	81136fd4 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110d9d4:	00007406 	br	8110dba8 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110d9d8:	d0a06317 	ldw	r2,-32372(gp)
8110d9dc:	1009883a 	mov	r4,r2
8110d9e0:	1138dc40 	call	81138dc4 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110d9e4:	11160c80 	call	811160c8 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110d9e8:	00006f06 	br	8110dba8 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110d9ec:	11160600 	call	81116060 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110d9f0:	00006d06 	br	8110dba8 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110d9f4:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110d9f8:	d0a06a03 	ldbu	r2,-32344(gp)
8110d9fc:	10803fcc 	andi	r2,r2,255
8110da00:	10800218 	cmpnei	r2,r2,8
8110da04:	1000021e 	bne	r2,zero,8110da10 <vInAckHandlerTaskV2+0x1b4>
8110da08:	00c00104 	movi	r3,4
8110da0c:	00000106 	br	8110da14 <vInAckHandlerTaskV2+0x1b8>
8110da10:	0007883a 	mov	r3,zero
8110da14:	d0a07803 	ldbu	r2,-32288(gp)
8110da18:	10803fcc 	andi	r2,r2,255
8110da1c:	10800218 	cmpnei	r2,r2,8
8110da20:	1000021e 	bne	r2,zero,8110da2c <vInAckHandlerTaskV2+0x1d0>
8110da24:	00800084 	movi	r2,2
8110da28:	00000106 	br	8110da30 <vInAckHandlerTaskV2+0x1d4>
8110da2c:	0005883a 	mov	r2,zero
8110da30:	1884b03a 	or	r2,r3,r2
8110da34:	1007883a 	mov	r3,r2
8110da38:	d0a07843 	ldbu	r2,-32287(gp)
8110da3c:	10803fcc 	andi	r2,r2,255
8110da40:	108001a0 	cmpeqi	r2,r2,6
8110da44:	1884b03a 	or	r2,r3,r2
8110da48:	1007883a 	mov	r3,r2
8110da4c:	e0bffa83 	ldbu	r2,-22(fp)
8110da50:	1884b03a 	or	r2,r3,r2
8110da54:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110da58:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110da5c:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110da60:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110da64:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110da68:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110da6c:	e0bffa03 	ldbu	r2,-24(fp)
8110da70:	10800044 	addi	r2,r2,1
8110da74:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110da78:	e0bffa83 	ldbu	r2,-22(fp)
8110da7c:	1080004c 	andi	r2,r2,1
8110da80:	10803fcc 	andi	r2,r2,255
8110da84:	1000061e 	bne	r2,zero,8110daa0 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110da88:	e0bffd04 	addi	r2,fp,-12
8110da8c:	100b883a 	mov	r5,r2
8110da90:	d1205404 	addi	r4,gp,-32432
8110da94:	110dbac0 	call	8110dbac <bCheckInAck128>
8110da98:	e0bff815 	stw	r2,-32(fp)
8110da9c:	00000206 	br	8110daa8 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8110daa0:	00800044 	movi	r2,1
8110daa4:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110daa8:	e0bffa83 	ldbu	r2,-22(fp)
8110daac:	1080008c 	andi	r2,r2,2
8110dab0:	10803fcc 	andi	r2,r2,255
8110dab4:	1000081e 	bne	r2,zero,8110dad8 <vInAckHandlerTaskV2+0x27c>
8110dab8:	e0bff817 	ldw	r2,-32(fp)
8110dabc:	1000061e 	bne	r2,zero,8110dad8 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110dac0:	e0bffc04 	addi	r2,fp,-16
8110dac4:	100b883a 	mov	r5,r2
8110dac8:	d1205404 	addi	r4,gp,-32432
8110dacc:	110dcf40 	call	8110dcf4 <bCheckInAck64>
8110dad0:	e0bff815 	stw	r2,-32(fp)
8110dad4:	00000206 	br	8110dae0 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
8110dad8:	00800044 	movi	r2,1
8110dadc:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110dae0:	e0bffa83 	ldbu	r2,-22(fp)
8110dae4:	1080010c 	andi	r2,r2,4
8110dae8:	10803fcc 	andi	r2,r2,255
8110daec:	1000081e 	bne	r2,zero,8110db10 <vInAckHandlerTaskV2+0x2b4>
8110daf0:	e0bff817 	ldw	r2,-32(fp)
8110daf4:	1000061e 	bne	r2,zero,8110db10 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110daf8:	e0bffb04 	addi	r2,fp,-20
8110dafc:	100b883a 	mov	r5,r2
8110db00:	d1205404 	addi	r4,gp,-32432
8110db04:	110de400 	call	8110de40 <bCheckInAck32>
8110db08:	e0bff815 	stw	r2,-32(fp)
8110db0c:	00000206 	br	8110db18 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8110db10:	00800044 	movi	r2,1
8110db14:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110db18:	e0bffa03 	ldbu	r2,-24(fp)
8110db1c:	10c00044 	addi	r3,r2,1
8110db20:	e0fffa05 	stb	r3,-24(fp)
8110db24:	10803fcc 	andi	r2,r2,255
8110db28:	10800ca8 	cmpgeui	r2,r2,50
8110db2c:	10000e1e 	bne	r2,zero,8110db68 <vInAckHandlerTaskV2+0x30c>
8110db30:	e0bff817 	ldw	r2,-32(fp)
8110db34:	10000c1e 	bne	r2,zero,8110db68 <vInAckHandlerTaskV2+0x30c>
8110db38:	e0bffb17 	ldw	r2,-20(fp)
8110db3c:	1005003a 	cmpeq	r2,r2,zero
8110db40:	1007883a 	mov	r3,r2
8110db44:	e0bffc17 	ldw	r2,-16(fp)
8110db48:	1005003a 	cmpeq	r2,r2,zero
8110db4c:	1884b03a 	or	r2,r3,r2
8110db50:	10c03fcc 	andi	r3,r2,255
8110db54:	e0bffd17 	ldw	r2,-12(fp)
8110db58:	1005003a 	cmpeq	r2,r2,zero
8110db5c:	10803fcc 	andi	r2,r2,255
8110db60:	1884b03a 	or	r2,r3,r2
8110db64:	103fc11e 	bne	r2,zero,8110da6c <__reset+0xfb0eda6c>
                
                if (bFound == FALSE) {
8110db68:	e0bff817 	ldw	r2,-32(fp)
8110db6c:	1000011e 	bne	r2,zero,8110db74 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110db70:	11165840 	call	81116584 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110db74:	00800044 	movi	r2,1
8110db78:	e0bff915 	stw	r2,-28(fp)
				break;
8110db7c:	00000a06 	br	8110dba8 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
8110db80:	d0a05f17 	ldw	r2,-32388(gp)
8110db84:	100f883a 	mov	r7,r2
8110db88:	01801144 	movi	r6,69
8110db8c:	01400044 	movi	r5,1
8110db90:	01204534 	movhi	r4,33044
8110db94:	211a6d04 	addi	r4,r4,27060
8110db98:	111affc0 	call	8111affc <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
8110db9c:	00800044 	movi	r2,1
8110dba0:	e0bff915 	stw	r2,-28(fp)
				break;
8110dba4:	0001883a 	nop
		}
	}
8110dba8:	003f4206 	br	8110d8b4 <__reset+0xfb0ed8b4>

8110dbac <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
8110dbac:	defffa04 	addi	sp,sp,-24
8110dbb0:	de00012e 	bgeu	sp,et,8110dbb8 <bCheckInAck128+0xc>
8110dbb4:	003b68fa 	trap	3
8110dbb8:	dfc00515 	stw	ra,20(sp)
8110dbbc:	df000415 	stw	fp,16(sp)
8110dbc0:	df000404 	addi	fp,sp,16
8110dbc4:	e13ffe15 	stw	r4,-8(fp)
8110dbc8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110dbcc:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110dbd0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110dbd4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110dbd8:	e0bfff17 	ldw	r2,-4(fp)
8110dbdc:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8110dbe0:	d0a07217 	ldw	r2,-32312(gp)
8110dbe4:	e0fffd44 	addi	r3,fp,-11
8110dbe8:	180d883a 	mov	r6,r3
8110dbec:	01400144 	movi	r5,5
8110dbf0:	1009883a 	mov	r4,r2
8110dbf4:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110dbf8:	e0bffd43 	ldbu	r2,-11(fp)
8110dbfc:	10803fcc 	andi	r2,r2,255
8110dc00:	10000226 	beq	r2,zero,8110dc0c <bCheckInAck128+0x60>
        return bFound;
8110dc04:	e0bffc17 	ldw	r2,-16(fp)
8110dc08:	00003506 	br	8110dce0 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110dc0c:	e03ffd05 	stb	zero,-12(fp)
8110dc10:	00002706 	br	8110dcb0 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110dc14:	e0fffd03 	ldbu	r3,-12(fp)
8110dc18:	00a04574 	movhi	r2,33045
8110dc1c:	109f1504 	addi	r2,r2,31828
8110dc20:	18c02324 	muli	r3,r3,140
8110dc24:	10c5883a 	add	r2,r2,r3
8110dc28:	10802104 	addi	r2,r2,132
8110dc2c:	10c0000b 	ldhu	r3,0(r2)
8110dc30:	e0bffe17 	ldw	r2,-8(fp)
8110dc34:	1080008b 	ldhu	r2,2(r2)
8110dc38:	18ffffcc 	andi	r3,r3,65535
8110dc3c:	10bfffcc 	andi	r2,r2,65535
8110dc40:	1880181e 	bne	r3,r2,8110dca4 <bCheckInAck128+0xf8>
            bFound = TRUE;
8110dc44:	00800044 	movi	r2,1
8110dc48:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8110dc4c:	e0fffd03 	ldbu	r3,-12(fp)
8110dc50:	00a04574 	movhi	r2,33045
8110dc54:	109ef704 	addi	r2,r2,31708
8110dc58:	18c7883a 	add	r3,r3,r3
8110dc5c:	18c7883a 	add	r3,r3,r3
8110dc60:	10c5883a 	add	r2,r2,r3
8110dc64:	10000015 	stw	zero,0(r2)
            SemCount128++;
8110dc68:	d0a07843 	ldbu	r2,-32287(gp)
8110dc6c:	10800044 	addi	r2,r2,1
8110dc70:	d0a07845 	stb	r2,-32287(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110dc74:	d0a06017 	ldw	r2,-32384(gp)
8110dc78:	1009883a 	mov	r4,r2
8110dc7c:	1138dc40 	call	81138dc4 <OSSemPost>
8110dc80:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110dc84:	e0bffd43 	ldbu	r2,-11(fp)
8110dc88:	10803fcc 	andi	r2,r2,255
8110dc8c:	10000c26 	beq	r2,zero,8110dcc0 <bCheckInAck128+0x114>
                SemCount128--;
8110dc90:	d0a07843 	ldbu	r2,-32287(gp)
8110dc94:	10bfffc4 	addi	r2,r2,-1
8110dc98:	d0a07845 	stb	r2,-32287(gp)
                vFailSetCountSemaphorexBuffer128();
8110dc9c:	11163e40 	call	811163e4 <vFailSetCountSemaphorexBuffer128>
            }
            break;
8110dca0:	00000706 	br	8110dcc0 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110dca4:	e0bffd03 	ldbu	r2,-12(fp)
8110dca8:	10800044 	addi	r2,r2,1
8110dcac:	e0bffd05 	stb	r2,-12(fp)
8110dcb0:	e0bffd03 	ldbu	r2,-12(fp)
8110dcb4:	108001b0 	cmpltui	r2,r2,6
8110dcb8:	103fd61e 	bne	r2,zero,8110dc14 <__reset+0xfb0edc14>
8110dcbc:	00000106 	br	8110dcc4 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8110dcc0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110dcc4:	d0a07217 	ldw	r2,-32312(gp)
8110dcc8:	1009883a 	mov	r4,r2
8110dccc:	1136fd40 	call	81136fd4 <OSMutexPost>
    (*bFinished) = TRUE;
8110dcd0:	e0bfff17 	ldw	r2,-4(fp)
8110dcd4:	00c00044 	movi	r3,1
8110dcd8:	10c00015 	stw	r3,0(r2)

    return bFound;
8110dcdc:	e0bffc17 	ldw	r2,-16(fp)
}
8110dce0:	e037883a 	mov	sp,fp
8110dce4:	dfc00117 	ldw	ra,4(sp)
8110dce8:	df000017 	ldw	fp,0(sp)
8110dcec:	dec00204 	addi	sp,sp,8
8110dcf0:	f800283a 	ret

8110dcf4 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110dcf4:	defffa04 	addi	sp,sp,-24
8110dcf8:	de00012e 	bgeu	sp,et,8110dd00 <bCheckInAck64+0xc>
8110dcfc:	003b68fa 	trap	3
8110dd00:	dfc00515 	stw	ra,20(sp)
8110dd04:	df000415 	stw	fp,16(sp)
8110dd08:	df000404 	addi	fp,sp,16
8110dd0c:	e13ffe15 	stw	r4,-8(fp)
8110dd10:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110dd14:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110dd18:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110dd1c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110dd20:	e0bfff17 	ldw	r2,-4(fp)
8110dd24:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110dd28:	d0a07417 	ldw	r2,-32304(gp)
8110dd2c:	e0fffd44 	addi	r3,fp,-11
8110dd30:	180d883a 	mov	r6,r3
8110dd34:	01400044 	movi	r5,1
8110dd38:	1009883a 	mov	r4,r2
8110dd3c:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110dd40:	e0bffd43 	ldbu	r2,-11(fp)
8110dd44:	10803fcc 	andi	r2,r2,255
8110dd48:	10000226 	beq	r2,zero,8110dd54 <bCheckInAck64+0x60>
        return bFound;
8110dd4c:	e0bffc17 	ldw	r2,-16(fp)
8110dd50:	00003606 	br	8110de2c <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110dd54:	e03ffd05 	stb	zero,-12(fp)
8110dd58:	00002806 	br	8110ddfc <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110dd5c:	e0fffd03 	ldbu	r3,-12(fp)
8110dd60:	00a04574 	movhi	r2,33045
8110dd64:	10bae904 	addi	r2,r2,-5212
8110dd68:	18c01324 	muli	r3,r3,76
8110dd6c:	10c5883a 	add	r2,r2,r3
8110dd70:	10801104 	addi	r2,r2,68
8110dd74:	10c0000b 	ldhu	r3,0(r2)
8110dd78:	e0bffe17 	ldw	r2,-8(fp)
8110dd7c:	1080008b 	ldhu	r2,2(r2)
8110dd80:	18ffffcc 	andi	r3,r3,65535
8110dd84:	10bfffcc 	andi	r2,r2,65535
8110dd88:	1880191e 	bne	r3,r2,8110ddf0 <bCheckInAck64+0xfc>
            bFound = TRUE;
8110dd8c:	00800044 	movi	r2,1
8110dd90:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110dd94:	e0fffd03 	ldbu	r3,-12(fp)
8110dd98:	00a04574 	movhi	r2,33045
8110dd9c:	109ef704 	addi	r2,r2,31708
8110dda0:	18c00184 	addi	r3,r3,6
8110dda4:	18c7883a 	add	r3,r3,r3
8110dda8:	18c7883a 	add	r3,r3,r3
8110ddac:	10c5883a 	add	r2,r2,r3
8110ddb0:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110ddb4:	d0a07803 	ldbu	r2,-32288(gp)
8110ddb8:	10800044 	addi	r2,r2,1
8110ddbc:	d0a07805 	stb	r2,-32288(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110ddc0:	d0a05a17 	ldw	r2,-32408(gp)
8110ddc4:	1009883a 	mov	r4,r2
8110ddc8:	1138dc40 	call	81138dc4 <OSSemPost>
8110ddcc:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110ddd0:	e0bffd43 	ldbu	r2,-11(fp)
8110ddd4:	10803fcc 	andi	r2,r2,255
8110ddd8:	10000c26 	beq	r2,zero,8110de0c <bCheckInAck64+0x118>
                SemCount64--;
8110dddc:	d0a07803 	ldbu	r2,-32288(gp)
8110dde0:	10bfffc4 	addi	r2,r2,-1
8110dde4:	d0a07805 	stb	r2,-32288(gp)
                vFailSetCountSemaphorexBuffer64();
8110dde8:	111637c0 	call	8111637c <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110ddec:	00000706 	br	8110de0c <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110ddf0:	e0bffd03 	ldbu	r2,-12(fp)
8110ddf4:	10800044 	addi	r2,r2,1
8110ddf8:	e0bffd05 	stb	r2,-12(fp)
8110ddfc:	e0bffd03 	ldbu	r2,-12(fp)
8110de00:	10800230 	cmpltui	r2,r2,8
8110de04:	103fd51e 	bne	r2,zero,8110dd5c <__reset+0xfb0edd5c>
8110de08:	00000106 	br	8110de10 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110de0c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110de10:	d0a07417 	ldw	r2,-32304(gp)
8110de14:	1009883a 	mov	r4,r2
8110de18:	1136fd40 	call	81136fd4 <OSMutexPost>
    (*bFinished) = TRUE;
8110de1c:	e0bfff17 	ldw	r2,-4(fp)
8110de20:	00c00044 	movi	r3,1
8110de24:	10c00015 	stw	r3,0(r2)

    return bFound;
8110de28:	e0bffc17 	ldw	r2,-16(fp)
}
8110de2c:	e037883a 	mov	sp,fp
8110de30:	dfc00117 	ldw	ra,4(sp)
8110de34:	df000017 	ldw	fp,0(sp)
8110de38:	dec00204 	addi	sp,sp,8
8110de3c:	f800283a 	ret

8110de40 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110de40:	defffa04 	addi	sp,sp,-24
8110de44:	de00012e 	bgeu	sp,et,8110de4c <bCheckInAck32+0xc>
8110de48:	003b68fa 	trap	3
8110de4c:	dfc00515 	stw	ra,20(sp)
8110de50:	df000415 	stw	fp,16(sp)
8110de54:	df000404 	addi	fp,sp,16
8110de58:	e13ffe15 	stw	r4,-8(fp)
8110de5c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110de60:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110de64:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110de68:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110de6c:	e0bfff17 	ldw	r2,-4(fp)
8110de70:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110de74:	d0a07017 	ldw	r2,-32320(gp)
8110de78:	e0fffd44 	addi	r3,fp,-11
8110de7c:	180d883a 	mov	r6,r3
8110de80:	01400044 	movi	r5,1
8110de84:	1009883a 	mov	r4,r2
8110de88:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110de8c:	e0bffd43 	ldbu	r2,-11(fp)
8110de90:	10803fcc 	andi	r2,r2,255
8110de94:	10000226 	beq	r2,zero,8110dea0 <bCheckInAck32+0x60>
        return bFound;
8110de98:	e0bffc17 	ldw	r2,-16(fp)
8110de9c:	00003606 	br	8110df78 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110dea0:	e03ffd05 	stb	zero,-12(fp)
8110dea4:	00002806 	br	8110df48 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110dea8:	e0fffd03 	ldbu	r3,-12(fp)
8110deac:	00a04574 	movhi	r2,33045
8110deb0:	108c8b04 	addi	r2,r2,12844
8110deb4:	18c00b24 	muli	r3,r3,44
8110deb8:	10c5883a 	add	r2,r2,r3
8110debc:	10800904 	addi	r2,r2,36
8110dec0:	10c0000b 	ldhu	r3,0(r2)
8110dec4:	e0bffe17 	ldw	r2,-8(fp)
8110dec8:	1080008b 	ldhu	r2,2(r2)
8110decc:	18ffffcc 	andi	r3,r3,65535
8110ded0:	10bfffcc 	andi	r2,r2,65535
8110ded4:	1880191e 	bne	r3,r2,8110df3c <bCheckInAck32+0xfc>
            bFound = TRUE;
8110ded8:	00800044 	movi	r2,1
8110dedc:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110dee0:	e0fffd03 	ldbu	r3,-12(fp)
8110dee4:	00a04574 	movhi	r2,33045
8110dee8:	109ef704 	addi	r2,r2,31708
8110deec:	18c00384 	addi	r3,r3,14
8110def0:	18c7883a 	add	r3,r3,r3
8110def4:	18c7883a 	add	r3,r3,r3
8110def8:	10c5883a 	add	r2,r2,r3
8110defc:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110df00:	d0a06a03 	ldbu	r2,-32344(gp)
8110df04:	10800044 	addi	r2,r2,1
8110df08:	d0a06a05 	stb	r2,-32344(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110df0c:	d0a07317 	ldw	r2,-32308(gp)
8110df10:	1009883a 	mov	r4,r2
8110df14:	1138dc40 	call	81138dc4 <OSSemPost>
8110df18:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110df1c:	e0bffd43 	ldbu	r2,-11(fp)
8110df20:	10803fcc 	andi	r2,r2,255
8110df24:	10000c26 	beq	r2,zero,8110df58 <bCheckInAck32+0x118>
                SemCount32--;
8110df28:	d0a06a03 	ldbu	r2,-32344(gp)
8110df2c:	10bfffc4 	addi	r2,r2,-1
8110df30:	d0a06a05 	stb	r2,-32344(gp)
                vFailSetCountSemaphorexBuffer32();
8110df34:	11163140 	call	81116314 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110df38:	00000706 	br	8110df58 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110df3c:	e0bffd03 	ldbu	r2,-12(fp)
8110df40:	10800044 	addi	r2,r2,1
8110df44:	e0bffd05 	stb	r2,-12(fp)
8110df48:	e0bffd03 	ldbu	r2,-12(fp)
8110df4c:	10800230 	cmpltui	r2,r2,8
8110df50:	103fd51e 	bne	r2,zero,8110dea8 <__reset+0xfb0edea8>
8110df54:	00000106 	br	8110df5c <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110df58:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110df5c:	d0a07017 	ldw	r2,-32320(gp)
8110df60:	1009883a 	mov	r4,r2
8110df64:	1136fd40 	call	81136fd4 <OSMutexPost>
    (*bFinished) = TRUE;
8110df68:	e0bfff17 	ldw	r2,-4(fp)
8110df6c:	00c00044 	movi	r3,1
8110df70:	10c00015 	stw	r3,0(r2)

    return bFound;
8110df74:	e0bffc17 	ldw	r2,-16(fp)
}
8110df78:	e037883a 	mov	sp,fp
8110df7c:	dfc00117 	ldw	ra,4(sp)
8110df80:	df000017 	ldw	fp,0(sp)
8110df84:	dec00204 	addi	sp,sp,8
8110df88:	f800283a 	ret

8110df8c <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110df8c:	defff704 	addi	sp,sp,-36
8110df90:	de00012e 	bgeu	sp,et,8110df98 <vInitialTask+0xc>
8110df94:	003b68fa 	trap	3
8110df98:	dfc00815 	stw	ra,32(sp)
8110df9c:	df000715 	stw	fp,28(sp)
8110dfa0:	df000704 	addi	fp,sp,28
8110dfa4:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110dfa8:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110dfac:	d8000415 	stw	zero,16(sp)
8110dfb0:	d8000315 	stw	zero,12(sp)
8110dfb4:	00810004 	movi	r2,1024
8110dfb8:	d8800215 	stw	r2,8(sp)
8110dfbc:	00a04574 	movhi	r2,33045
8110dfc0:	10b2e904 	addi	r2,r2,-13404
8110dfc4:	d8800115 	stw	r2,4(sp)
8110dfc8:	00800244 	movi	r2,9
8110dfcc:	d8800015 	stw	r2,0(sp)
8110dfd0:	01c00244 	movi	r7,9
8110dfd4:	01a04574 	movhi	r6,33045
8110dfd8:	31b6e804 	addi	r6,r6,-9312
8110dfdc:	01604574 	movhi	r5,33045
8110dfe0:	2947f404 	addi	r5,r5,8144
8110dfe4:	01204474 	movhi	r4,33041
8110dfe8:	21319c04 	addi	r4,r4,-14736
8110dfec:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110dff0:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110dff4:	e0bffe03 	ldbu	r2,-8(fp)
8110dff8:	10803fcc 	andi	r2,r2,255
8110dffc:	10000526 	beq	r2,zero,8110e014 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e000:	e0bffe03 	ldbu	r2,-8(fp)
8110e004:	10803fcc 	andi	r2,r2,255
8110e008:	1009883a 	mov	r4,r2
8110e00c:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
8110e010:	111713c0 	call	8111713c <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e014:	01c17704 	movi	r7,1500
8110e018:	000d883a 	mov	r6,zero
8110e01c:	000b883a 	mov	r5,zero
8110e020:	0009883a 	mov	r4,zero
8110e024:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110e028:	d8000415 	stw	zero,16(sp)
8110e02c:	d8000315 	stw	zero,12(sp)
8110e030:	00810004 	movi	r2,1024
8110e034:	d8800215 	stw	r2,8(sp)
8110e038:	00a04574 	movhi	r2,33045
8110e03c:	1083e504 	addi	r2,r2,3988
8110e040:	d8800115 	stw	r2,4(sp)
8110e044:	00800204 	movi	r2,8
8110e048:	d8800015 	stw	r2,0(sp)
8110e04c:	01c00204 	movi	r7,8
8110e050:	01a04574 	movhi	r6,33045
8110e054:	3187e404 	addi	r6,r6,8080
8110e058:	01604574 	movhi	r5,33045
8110e05c:	2947ee04 	addi	r5,r5,8120
8110e060:	01204474 	movhi	r4,33041
8110e064:	21317c04 	addi	r4,r4,-14864
8110e068:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e06c:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e070:	e0bffe03 	ldbu	r2,-8(fp)
8110e074:	10803fcc 	andi	r2,r2,255
8110e078:	10000526 	beq	r2,zero,8110e090 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e07c:	e0bffe03 	ldbu	r2,-8(fp)
8110e080:	10803fcc 	andi	r2,r2,255
8110e084:	1009883a 	mov	r4,r2
8110e088:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
8110e08c:	11174140 	call	81117414 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e090:	01c17704 	movi	r7,1500
8110e094:	000d883a 	mov	r6,zero
8110e098:	000b883a 	mov	r5,zero
8110e09c:	0009883a 	mov	r4,zero
8110e0a0:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110e0a4:	d8000415 	stw	zero,16(sp)
8110e0a8:	d8000315 	stw	zero,12(sp)
8110e0ac:	00810004 	movi	r2,1024
8110e0b0:	d8800215 	stw	r2,8(sp)
8110e0b4:	00a04574 	movhi	r2,33045
8110e0b8:	109ffb04 	addi	r2,r2,32748
8110e0bc:	d8800115 	stw	r2,4(sp)
8110e0c0:	008001c4 	movi	r2,7
8110e0c4:	d8800015 	stw	r2,0(sp)
8110e0c8:	01c001c4 	movi	r7,7
8110e0cc:	01a045b4 	movhi	r6,33046
8110e0d0:	31a3fa04 	addi	r6,r6,-28696
8110e0d4:	01604574 	movhi	r5,33045
8110e0d8:	2947f404 	addi	r5,r5,8144
8110e0dc:	01204474 	movhi	r4,33041
8110e0e0:	21394404 	addi	r4,r4,-6896
8110e0e4:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e0e8:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e0ec:	e0bffe03 	ldbu	r2,-8(fp)
8110e0f0:	10803fcc 	andi	r2,r2,255
8110e0f4:	10000526 	beq	r2,zero,8110e10c <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e0f8:	e0bffe03 	ldbu	r2,-8(fp)
8110e0fc:	10803fcc 	andi	r2,r2,255
8110e100:	1009883a 	mov	r4,r2
8110e104:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110e108:	11173ac0 	call	811173ac <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e10c:	01c17704 	movi	r7,1500
8110e110:	000d883a 	mov	r6,zero
8110e114:	000b883a 	mov	r5,zero
8110e118:	0009883a 	mov	r4,zero
8110e11c:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110e120:	d8000415 	stw	zero,16(sp)
8110e124:	d8000315 	stw	zero,12(sp)
8110e128:	00810004 	movi	r2,1024
8110e12c:	d8800215 	stw	r2,8(sp)
8110e130:	00a045b4 	movhi	r2,33046
8110e134:	10b20504 	addi	r2,r2,-14316
8110e138:	d8800115 	stw	r2,4(sp)
8110e13c:	00800184 	movi	r2,6
8110e140:	d8800015 	stw	r2,0(sp)
8110e144:	01c00184 	movi	r7,6
8110e148:	01a045b4 	movhi	r6,33046
8110e14c:	31b60404 	addi	r6,r6,-10224
8110e150:	01604574 	movhi	r5,33045
8110e154:	2947e504 	addi	r5,r5,8084
8110e158:	01204474 	movhi	r4,33041
8110e15c:	21027604 	addi	r4,r4,2520
8110e160:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e164:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e168:	e0bffe03 	ldbu	r2,-8(fp)
8110e16c:	10803fcc 	andi	r2,r2,255
8110e170:	10000526 	beq	r2,zero,8110e188 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e174:	e0bffe03 	ldbu	r2,-8(fp)
8110e178:	10803fcc 	andi	r2,r2,255
8110e17c:	1009883a 	mov	r4,r2
8110e180:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8110e184:	111747c0 	call	8111747c <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110e188:	01c17704 	movi	r7,1500
8110e18c:	000d883a 	mov	r6,zero
8110e190:	000b883a 	mov	r5,zero
8110e194:	0009883a 	mov	r4,zero
8110e198:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110e19c:	d8000415 	stw	zero,16(sp)
8110e1a0:	d8000315 	stw	zero,12(sp)
8110e1a4:	00810004 	movi	r2,1024
8110e1a8:	d8800215 	stw	r2,8(sp)
8110e1ac:	00a04574 	movhi	r2,33045
8110e1b0:	10bfe504 	addi	r2,r2,-108
8110e1b4:	d8800115 	stw	r2,4(sp)
8110e1b8:	00800784 	movi	r2,30
8110e1bc:	d8800015 	stw	r2,0(sp)
8110e1c0:	01c00784 	movi	r7,30
8110e1c4:	01a04574 	movhi	r6,33045
8110e1c8:	3183e404 	addi	r6,r6,3984
8110e1cc:	000b883a 	mov	r5,zero
8110e1d0:	01204474 	movhi	r4,33041
8110e1d4:	2108a004 	addi	r4,r4,8832
8110e1d8:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e1dc:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e1e0:	e0bffe03 	ldbu	r2,-8(fp)
8110e1e4:	10803fcc 	andi	r2,r2,255
8110e1e8:	10000526 	beq	r2,zero,8110e200 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e1ec:	e0bffe03 	ldbu	r2,-8(fp)
8110e1f0:	10803fcc 	andi	r2,r2,255
8110e1f4:	1009883a 	mov	r4,r2
8110e1f8:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8110e1fc:	1116aa80 	call	81116aa8 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e200:	01c03204 	movi	r7,200
8110e204:	000d883a 	mov	r6,zero
8110e208:	000b883a 	mov	r5,zero
8110e20c:	0009883a 	mov	r4,zero
8110e210:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110e214:	d8000415 	stw	zero,16(sp)
8110e218:	d8000315 	stw	zero,12(sp)
8110e21c:	00810004 	movi	r2,1024
8110e220:	d8800215 	stw	r2,8(sp)
8110e224:	00a04574 	movhi	r2,33045
8110e228:	1092f304 	addi	r2,r2,19404
8110e22c:	d8800115 	stw	r2,4(sp)
8110e230:	008006c4 	movi	r2,27
8110e234:	d8800015 	stw	r2,0(sp)
8110e238:	01c006c4 	movi	r7,27
8110e23c:	01a04574 	movhi	r6,33045
8110e240:	3196f204 	addi	r6,r6,23496
8110e244:	000b883a 	mov	r5,zero
8110e248:	01204474 	movhi	r4,33041
8110e24c:	213ab804 	addi	r4,r4,-5408
8110e250:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e254:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e258:	e0bffe03 	ldbu	r2,-8(fp)
8110e25c:	10803fcc 	andi	r2,r2,255
8110e260:	10000526 	beq	r2,zero,8110e278 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e264:	e0bffe03 	ldbu	r2,-8(fp)
8110e268:	10803fcc 	andi	r2,r2,255
8110e26c:	1009883a 	mov	r4,r2
8110e270:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
8110e274:	11169c40 	call	811169c4 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e278:	01c03204 	movi	r7,200
8110e27c:	000d883a 	mov	r6,zero
8110e280:	000b883a 	mov	r5,zero
8110e284:	0009883a 	mov	r4,zero
8110e288:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110e28c:	d8000415 	stw	zero,16(sp)
8110e290:	d8000315 	stw	zero,12(sp)
8110e294:	00810004 	movi	r2,1024
8110e298:	d8800215 	stw	r2,8(sp)
8110e29c:	00a04574 	movhi	r2,33045
8110e2a0:	10b6e904 	addi	r2,r2,-9308
8110e2a4:	d8800115 	stw	r2,4(sp)
8110e2a8:	00800644 	movi	r2,25
8110e2ac:	d8800015 	stw	r2,0(sp)
8110e2b0:	01c00644 	movi	r7,25
8110e2b4:	01a04574 	movhi	r6,33045
8110e2b8:	31bae804 	addi	r6,r6,-5216
8110e2bc:	000b883a 	mov	r5,zero
8110e2c0:	01204474 	movhi	r4,33041
8110e2c4:	21361704 	addi	r4,r4,-10148
8110e2c8:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e2cc:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e2d0:	e0bffe03 	ldbu	r2,-8(fp)
8110e2d4:	10803fcc 	andi	r2,r2,255
8110e2d8:	10000526 	beq	r2,zero,8110e2f0 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e2dc:	e0bffe03 	ldbu	r2,-8(fp)
8110e2e0:	10803fcc 	andi	r2,r2,255
8110e2e4:	1009883a 	mov	r4,r2
8110e2e8:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8110e2ec:	11169780 	call	81116978 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e2f0:	01c03204 	movi	r7,200
8110e2f4:	000d883a 	mov	r6,zero
8110e2f8:	000b883a 	mov	r5,zero
8110e2fc:	0009883a 	mov	r4,zero
8110e300:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110e304:	d8000415 	stw	zero,16(sp)
8110e308:	d8000315 	stw	zero,12(sp)
8110e30c:	00818004 	movi	r2,1536
8110e310:	d8800215 	stw	r2,8(sp)
8110e314:	00a045b4 	movhi	r2,33046
8110e318:	10ac0504 	addi	r2,r2,-20460
8110e31c:	d8800115 	stw	r2,4(sp)
8110e320:	00800704 	movi	r2,28
8110e324:	d8800015 	stw	r2,0(sp)
8110e328:	01c00704 	movi	r7,28
8110e32c:	01a045b4 	movhi	r6,33046
8110e330:	31b20404 	addi	r6,r6,-14320
8110e334:	000b883a 	mov	r5,zero
8110e338:	01204474 	movhi	r4,33041
8110e33c:	213b7604 	addi	r4,r4,-4648
8110e340:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e344:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e348:	e0bffe03 	ldbu	r2,-8(fp)
8110e34c:	10803fcc 	andi	r2,r2,255
8110e350:	10000526 	beq	r2,zero,8110e368 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110e354:	e0bffe03 	ldbu	r2,-8(fp)
8110e358:	10803fcc 	andi	r2,r2,255
8110e35c:	1009883a 	mov	r4,r2
8110e360:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
8110e364:	111692c0 	call	8111692c <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e368:	01c03204 	movi	r7,200
8110e36c:	000d883a 	mov	r6,zero
8110e370:	000b883a 	mov	r5,zero
8110e374:	0009883a 	mov	r4,zero
8110e378:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110e37c:	d8000415 	stw	zero,16(sp)
8110e380:	d8000315 	stw	zero,12(sp)
8110e384:	00818004 	movi	r2,1536
8110e388:	d8800215 	stw	r2,8(sp)
8110e38c:	00a04574 	movhi	r2,33045
8110e390:	108ce304 	addi	r2,r2,13196
8110e394:	d8800115 	stw	r2,4(sp)
8110e398:	00800804 	movi	r2,32
8110e39c:	d8800015 	stw	r2,0(sp)
8110e3a0:	01c00804 	movi	r7,32
8110e3a4:	01a04574 	movhi	r6,33045
8110e3a8:	3192e204 	addi	r6,r6,19336
8110e3ac:	000b883a 	mov	r5,zero
8110e3b0:	01204474 	movhi	r4,33041
8110e3b4:	213f9604 	addi	r4,r4,-424
8110e3b8:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e3bc:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110e3c0:	e0bffe03 	ldbu	r2,-8(fp)
8110e3c4:	10803fcc 	andi	r2,r2,255
8110e3c8:	10000526 	beq	r2,zero,8110e3e0 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110e3cc:	e0bffe03 	ldbu	r2,-8(fp)
8110e3d0:	10803fcc 	andi	r2,r2,255
8110e3d4:	1009883a 	mov	r4,r2
8110e3d8:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailReceiverCreate();
8110e3dc:	11162300 	call	81116230 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110e3e0:	01c03204 	movi	r7,200
8110e3e4:	000d883a 	mov	r6,zero
8110e3e8:	000b883a 	mov	r5,zero
8110e3ec:	0009883a 	mov	r4,zero
8110e3f0:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110e3f4:	d8000415 	stw	zero,16(sp)
8110e3f8:	d8000315 	stw	zero,12(sp)
8110e3fc:	00810004 	movi	r2,1024
8110e400:	d8800215 	stw	r2,8(sp)
8110e404:	00a04574 	movhi	r2,33045
8110e408:	10bbd904 	addi	r2,r2,-4252
8110e40c:	d8800115 	stw	r2,4(sp)
8110e410:	00800684 	movi	r2,26
8110e414:	d8800015 	stw	r2,0(sp)
8110e418:	01c00684 	movi	r7,26
8110e41c:	01a04574 	movhi	r6,33045
8110e420:	31bfd804 	addi	r6,r6,-160
8110e424:	000b883a 	mov	r5,zero
8110e428:	01204474 	movhi	r4,33041
8110e42c:	21021804 	addi	r4,r4,2144
8110e430:	11395f40 	call	811395f4 <OSTaskCreateExt>
8110e434:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110e438:	01c03204 	movi	r7,200
8110e43c:	000d883a 	mov	r6,zero
8110e440:	000b883a 	mov	r5,zero
8110e444:	0009883a 	mov	r4,zero
8110e448:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110e44c:	e0bffe03 	ldbu	r2,-8(fp)
8110e450:	10803fcc 	andi	r2,r2,255
8110e454:	10000526 	beq	r2,zero,8110e46c <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110e458:	e0bffe03 	ldbu	r2,-8(fp)
8110e45c:	10803fcc 	andi	r2,r2,255
8110e460:	1009883a 	mov	r4,r2
8110e464:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailSenderCreate();
8110e468:	111627c0 	call	8111627c <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110e46c:	d0a07117 	ldw	r2,-32316(gp)
8110e470:	e17ffe04 	addi	r5,fp,-8
8110e474:	1009883a 	mov	r4,r2
8110e478:	113b3140 	call	8113b314 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110e47c:	e0bffe03 	ldbu	r2,-8(fp)
8110e480:	10803fcc 	andi	r2,r2,255
8110e484:	10000126 	beq	r2,zero,8110e48c <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110e488:	1116d640 	call	81116d64 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110e48c:	01c00084 	movi	r7,2
8110e490:	01800784 	movi	r6,30
8110e494:	000b883a 	mov	r5,zero
8110e498:	0009883a 	mov	r4,zero
8110e49c:	113a8200 	call	8113a820 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110e4a0:	01003fc4 	movi	r4,255
8110e4a4:	11397e00 	call	811397e0 <OSTaskDel>
8110e4a8:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110e4ac:	e0bffe03 	ldbu	r2,-8(fp)
8110e4b0:	10803fcc 	andi	r2,r2,255
8110e4b4:	10001026 	beq	r2,zero,8110e4f8 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110e4b8:	e0bffe03 	ldbu	r2,-8(fp)
8110e4bc:	10803fcc 	andi	r2,r2,255
8110e4c0:	1009883a 	mov	r4,r2
8110e4c4:	1115cdc0 	call	81115cdc <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110e4c8:	11162c80 	call	811162c8 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110e4cc:	014009c4 	movi	r5,39
8110e4d0:	01000044 	movi	r4,1
8110e4d4:	11390fc0 	call	811390fc <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110e4d8:	01003fc4 	movi	r4,255
8110e4dc:	11397e00 	call	811397e0 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110e4e0:	000f883a 	mov	r7,zero
8110e4e4:	01800284 	movi	r6,10
8110e4e8:	000b883a 	mov	r5,zero
8110e4ec:	0009883a 	mov	r4,zero
8110e4f0:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
		}
8110e4f4:	003ff806 	br	8110e4d8 <__reset+0xfb0ee4d8>
	}

}
8110e4f8:	0001883a 	nop
8110e4fc:	e037883a 	mov	sp,fp
8110e500:	dfc00117 	ldw	ra,4(sp)
8110e504:	df000017 	ldw	fp,0(sp)
8110e508:	dec00204 	addi	sp,sp,8
8110e50c:	f800283a 	ret

8110e510 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110e510:	defff804 	addi	sp,sp,-32
8110e514:	de00012e 	bgeu	sp,et,8110e51c <vNFeeControlTask+0xc>
8110e518:	003b68fa 	trap	3
8110e51c:	dfc00715 	stw	ra,28(sp)
8110e520:	df000615 	stw	fp,24(sp)
8110e524:	df000604 	addi	fp,sp,24
8110e528:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;

	pxFeeC = (TNFee_Control *) task_data;
8110e52c:	e0bfff17 	ldw	r2,-4(fp)
8110e530:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110e534:	d0a05f17 	ldw	r2,-32388(gp)
8110e538:	100f883a 	mov	r7,r2
8110e53c:	01800804 	movi	r6,32
8110e540:	01400044 	movi	r5,1
8110e544:	01204534 	movhi	r4,33044
8110e548:	211a7f04 	addi	r4,r4,27132
8110e54c:	111affc0 	call	8111affc <fwrite>
    #endif

	bCmdSent = FALSE;
8110e550:	e03ffb15 	stw	zero,-20(fp)
	bDmaBack = TRUE;
8110e554:	00800044 	movi	r2,1
8110e558:	d0a05515 	stw	r2,-32428(gp)
		/* todo: Tem os mesmos estados que o SIMUCAM : Config e Running */
		/* todo: No config ou a Meb ira configurar sozinha os FEEs e os controladores ou ir passar a mensagem completa sem usar a QueueMask */
		/* todo: No modo Running o NFEE control s utiliza o Queue MAsk pois  mais rapido e s transmite no Qmask tbm */

		
		switch (pxFeeC->sMode)
8110e55c:	e0bffa17 	ldw	r2,-24(fp)
8110e560:	10809517 	ldw	r2,596(r2)
8110e564:	10000326 	beq	r2,zero,8110e574 <vNFeeControlTask+0x64>
8110e568:	10800060 	cmpeqi	r2,r2,1
8110e56c:	1000201e 	bne	r2,zero,8110e5f0 <vNFeeControlTask+0xe0>
8110e570:	00007e06 	br	8110e76c <vNFeeControlTask+0x25c>
		{
			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_code); /* Blocking operation */
8110e574:	d0a05217 	ldw	r2,-32440(gp)
8110e578:	e0fffe04 	addi	r3,fp,-8
8110e57c:	180d883a 	mov	r6,r3
8110e580:	000b883a 	mov	r5,zero
8110e584:	1009883a 	mov	r4,r2
8110e588:	1137b440 	call	81137b44 <OSQPend>
8110e58c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e590:	e0bffe03 	ldbu	r2,-8(fp)
8110e594:	10803fcc 	andi	r2,r2,255
8110e598:	1000131e 	bne	r2,zero,8110e5e8 <vNFeeControlTask+0xd8>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110e59c:	e0bffdc3 	ldbu	r2,-9(fp)
8110e5a0:	10803fcc 	andi	r2,r2,255
8110e5a4:	10800418 	cmpnei	r2,r2,16
8110e5a8:	1000051e 	bne	r2,zero,8110e5c0 <vNFeeControlTask+0xb0>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110e5ac:	e0bffd17 	ldw	r2,-12(fp)
8110e5b0:	e17ffa17 	ldw	r5,-24(fp)
8110e5b4:	1009883a 	mov	r4,r2
8110e5b8:	110e79c0 	call	8110e79c <vPerformActionNFCConfig>
8110e5bc:	00000706 	br	8110e5dc <vNFeeControlTask+0xcc>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
8110e5c0:	d0a05f17 	ldw	r2,-32388(gp)
8110e5c4:	100f883a 	mov	r7,r2
8110e5c8:	01800704 	movi	r6,28
8110e5cc:	01400044 	movi	r5,1
8110e5d0:	01204534 	movhi	r4,33044
8110e5d4:	211a8804 	addi	r4,r4,27168
8110e5d8:	111affc0 	call	8111affc <fwrite>
						#endif
					}

					bDmaBack = TRUE;
8110e5dc:	00800044 	movi	r2,1
8110e5e0:	d0a05515 	stw	r2,-32428(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110e5e4:	00006c06 	br	8110e798 <vNFeeControlTask+0x288>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110e5e8:	11177140 	call	81117714 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110e5ec:	00006a06 	br	8110e798 <vNFeeControlTask+0x288>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110e5f0:	d0a05517 	ldw	r2,-32428(gp)
8110e5f4:	10800058 	cmpnei	r2,r2,1
8110e5f8:	1000201e 	bne	r2,zero,8110e67c <vNFeeControlTask+0x16c>
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 2, &error_code);
8110e5fc:	d0a05917 	ldw	r2,-32412(gp)
8110e600:	e0fffe04 	addi	r3,fp,-8
8110e604:	180d883a 	mov	r6,r3
8110e608:	01400084 	movi	r5,2
8110e60c:	1009883a 	mov	r4,r2
8110e610:	1137b440 	call	81137b44 <OSQPend>
8110e614:	e0bffd15 	stw	r2,-12(fp)
					if ( error_code == OS_ERR_NONE ) {
8110e618:	e0bffe03 	ldbu	r2,-8(fp)
8110e61c:	10803fcc 	andi	r2,r2,255
8110e620:	1000161e 	bne	r2,zero,8110e67c <vNFeeControlTask+0x16c>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110e624:	e0bffd03 	ldbu	r2,-12(fp)
8110e628:	e0bffc05 	stb	r2,-16(fp)
						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8110e62c:	e0bffc03 	ldbu	r2,-16(fp)
8110e630:	e0fffa17 	ldw	r3,-24(fp)
8110e634:	10809224 	muli	r2,r2,584
8110e638:	1885883a 	add	r2,r3,r2
8110e63c:	10802204 	addi	r2,r2,136
8110e640:	10800017 	ldw	r2,0(r2)
8110e644:	10800058 	cmpnei	r2,r2,1
8110e648:	10000c1e 	bne	r2,zero,8110e67c <vNFeeControlTask+0x16c>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110e64c:	e0bffc03 	ldbu	r2,-16(fp)
8110e650:	e0fffc03 	ldbu	r3,-16(fp)
8110e654:	180f883a 	mov	r7,r3
8110e658:	000d883a 	mov	r6,zero
8110e65c:	014023c4 	movi	r5,143
8110e660:	1009883a 	mov	r4,r2
8110e664:	110ea180 	call	8110ea18 <bSendCmdQToNFeeInst>
8110e668:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE )
8110e66c:	e0bffb17 	ldw	r2,-20(fp)
8110e670:	10800058 	cmpnei	r2,r2,1
8110e674:	1000011e 	bne	r2,zero,8110e67c <vNFeeControlTask+0x16c>
								bDmaBack = FALSE;
8110e678:	d0205515 	stw	zero,-32428(gp)
						}
					}
				} 

				if ( bDmaBack == FALSE )
8110e67c:	d0a05517 	ldw	r2,-32428(gp)
8110e680:	1000081e 	bne	r2,zero,8110e6a4 <vNFeeControlTask+0x194>
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110e684:	d0a05217 	ldw	r2,-32440(gp)
8110e688:	e0fffe44 	addi	r3,fp,-7
8110e68c:	180d883a 	mov	r6,r3
8110e690:	000b883a 	mov	r5,zero
8110e694:	1009883a 	mov	r4,r2
8110e698:	1137b440 	call	81137b44 <OSQPend>
8110e69c:	e0bffd15 	stw	r2,-12(fp)
8110e6a0:	00000706 	br	8110e6c0 <vNFeeControlTask+0x1b0>
				else
					/* If No FEE has the DMA */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 2, &error_codeCtrl);
8110e6a4:	d0a05217 	ldw	r2,-32440(gp)
8110e6a8:	e0fffe44 	addi	r3,fp,-7
8110e6ac:	180d883a 	mov	r6,r3
8110e6b0:	01400084 	movi	r5,2
8110e6b4:	1009883a 	mov	r4,r2
8110e6b8:	1137b440 	call	81137b44 <OSQPend>
8110e6bc:	e0bffd15 	stw	r2,-12(fp)

				if ( error_codeCtrl == OS_ERR_NONE ){
8110e6c0:	e0bffe43 	ldbu	r2,-7(fp)
8110e6c4:	10803fcc 	andi	r2,r2,255
8110e6c8:	1000321e 	bne	r2,zero,8110e794 <vNFeeControlTask+0x284>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110e6cc:	e0bffd83 	ldbu	r2,-10(fp)
8110e6d0:	10803fcc 	andi	r2,r2,255
8110e6d4:	10802058 	cmpnei	r2,r2,129
8110e6d8:	1000031e 	bne	r2,zero,8110e6e8 <vNFeeControlTask+0x1d8>
						bDmaBack = TRUE;
8110e6dc:	00800044 	movi	r2,1
8110e6e0:	d0a05515 	stw	r2,-32428(gp)
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110e6e4:	00002b06 	br	8110e794 <vNFeeControlTask+0x284>
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
						bDmaBack = TRUE;
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110e6e8:	e0bffdc3 	ldbu	r2,-9(fp)
8110e6ec:	10803fcc 	andi	r2,r2,255
8110e6f0:	10800418 	cmpnei	r2,r2,16
8110e6f4:	1000051e 	bne	r2,zero,8110e70c <vNFeeControlTask+0x1fc>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110e6f8:	e0bffd17 	ldw	r2,-12(fp)
8110e6fc:	e17ffa17 	ldw	r5,-24(fp)
8110e700:	1009883a 	mov	r4,r2
8110e704:	110e8e00 	call	8110e8e0 <vPerformActionNFCRunning>
8110e708:	00001606 	br	8110e764 <vNFeeControlTask+0x254>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8110e70c:	e0bffdc3 	ldbu	r2,-9(fp)
8110e710:	10803fcc 	andi	r2,r2,255
8110e714:	10800470 	cmpltui	r2,r2,17
8110e718:	1000121e 	bne	r2,zero,8110e764 <vNFeeControlTask+0x254>
8110e71c:	e0bffdc3 	ldbu	r2,-9(fp)
8110e720:	10803fcc 	andi	r2,r2,255
8110e724:	108004e8 	cmpgeui	r2,r2,19
8110e728:	10000e1e 	bne	r2,zero,8110e764 <vNFeeControlTask+0x254>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8110e72c:	e0bffdc3 	ldbu	r2,-9(fp)
8110e730:	10bffbc4 	addi	r2,r2,-17
8110e734:	10803fcc 	andi	r2,r2,255
8110e738:	e0fffd83 	ldbu	r3,-10(fp)
8110e73c:	18c03fcc 	andi	r3,r3,255
8110e740:	e13ffd43 	ldbu	r4,-11(fp)
8110e744:	21003fcc 	andi	r4,r4,255
8110e748:	e17ffd03 	ldbu	r5,-12(fp)
8110e74c:	29403fcc 	andi	r5,r5,255
8110e750:	280f883a 	mov	r7,r5
8110e754:	200d883a 	mov	r6,r4
8110e758:	180b883a 	mov	r5,r3
8110e75c:	1009883a 	mov	r4,r2
8110e760:	110ea180 	call	8110ea18 <bSendCmdQToNFeeInst>

							}
						}
						bDmaBack = FALSE;
8110e764:	d0205515 	stw	zero,-32428(gp)
					}
				}
				
				break;		
8110e768:	00000a06 	br	8110e794 <vNFeeControlTask+0x284>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknow state, backing to Config Mode.\n");
8110e76c:	d0a05f17 	ldw	r2,-32388(gp)
8110e770:	100f883a 	mov	r7,r2
8110e774:	01800f04 	movi	r6,60
8110e778:	01400044 	movi	r5,1
8110e77c:	01204534 	movhi	r4,33044
8110e780:	211a9004 	addi	r4,r4,27200
8110e784:	111affc0 	call	8111affc <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110e788:	e0bffa17 	ldw	r2,-24(fp)
8110e78c:	10009515 	stw	zero,596(r2)
				break;
8110e790:	00000106 	br	8110e798 <vNFeeControlTask+0x288>
						}
						bDmaBack = FALSE;
					}
				}
				
				break;		
8110e794:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8110e798:	003f7006 	br	8110e55c <__reset+0xfb0ee55c>

8110e79c <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110e79c:	defffa04 	addi	sp,sp,-24
8110e7a0:	de00012e 	bgeu	sp,et,8110e7a8 <vPerformActionNFCConfig+0xc>
8110e7a4:	003b68fa 	trap	3
8110e7a8:	dfc00515 	stw	ra,20(sp)
8110e7ac:	df000415 	stw	fp,16(sp)
8110e7b0:	df000404 	addi	fp,sp,16
8110e7b4:	e13ffe15 	stw	r4,-8(fp)
8110e7b8:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110e7bc:	e0bffe17 	ldw	r2,-8(fp)
8110e7c0:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110e7c4:	e0bffd83 	ldbu	r2,-10(fp)
8110e7c8:	10803fcc 	andi	r2,r2,255
8110e7cc:	10c00060 	cmpeqi	r3,r2,1
8110e7d0:	1800031e 	bne	r3,zero,8110e7e0 <vPerformActionNFCConfig+0x44>
8110e7d4:	108000a0 	cmpeqi	r2,r2,2
8110e7d8:	1000091e 	bne	r2,zero,8110e800 <vPerformActionNFCConfig+0x64>
8110e7dc:	00003206 	br	8110e8a8 <vPerformActionNFCConfig+0x10c>
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
8110e7e0:	d0a05f17 	ldw	r2,-32388(gp)
8110e7e4:	100f883a 	mov	r7,r2
8110e7e8:	01800d44 	movi	r6,53
8110e7ec:	01400044 	movi	r5,1
8110e7f0:	01204534 	movhi	r4,33044
8110e7f4:	211aa004 	addi	r4,r4,27264
8110e7f8:	111affc0 	call	8111affc <fwrite>
			#endif

			/* Do nothing for now */

			break;
8110e7fc:	00003206 	br	8110e8c8 <vPerformActionNFCConfig+0x12c>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to RUN Mode\n");
8110e800:	d0a05f17 	ldw	r2,-32388(gp)
8110e804:	100f883a 	mov	r7,r2
8110e808:	01800ac4 	movi	r6,43
8110e80c:	01400044 	movi	r5,1
8110e810:	01204534 	movhi	r4,33044
8110e814:	211aae04 	addi	r4,r4,27320
8110e818:	111affc0 	call	8111affc <fwrite>
			#endif

			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sRun);
8110e81c:	e0bfff17 	ldw	r2,-4(fp)
8110e820:	10809517 	ldw	r2,596(r2)
8110e824:	01400044 	movi	r5,1
8110e828:	1009883a 	mov	r4,r2
8110e82c:	11179e00 	call	811179e0 <vEvtChangeFeeControllerMode>
			pxFeeCP->sMode = sRun;
8110e830:	e0bfff17 	ldw	r2,-4(fp)
8110e834:	00c00044 	movi	r3,1
8110e838:	10c09515 	stw	r3,596(r2)
			/* ALlow NFEEs to go to any Running mode */

			/* Clear The Queue That gives access to the DMA */
			errorCodeL = OSQFlush(xNfeeSchedule);
8110e83c:	d0a05917 	ldw	r2,-32412(gp)
8110e840:	1009883a 	mov	r4,r2
8110e844:	1137a840 	call	81137a84 <OSQFlush>
8110e848:	e0bffc45 	stb	r2,-15(fp)
			if ( errorCodeL != OS_NO_ERR ) {
8110e84c:	e0bffc43 	ldbu	r2,-15(fp)
8110e850:	10000126 	beq	r2,zero,8110e858 <vPerformActionNFCConfig+0xbc>
				vFailFlushQueue();
8110e854:	11179240 	call	81117924 <vFailFlushQueue>
			}

			for( i = 0; i < N_OF_NFEE; i++)
8110e858:	e03ffc05 	stb	zero,-16(fp)
8110e85c:	00000f06 	br	8110e89c <vPerformActionNFCConfig+0x100>
			{
				errorCodeL = OSQFlush( xFeeQ[ i ] );
8110e860:	e0bffc03 	ldbu	r2,-16(fp)
8110e864:	1085883a 	add	r2,r2,r2
8110e868:	1087883a 	add	r3,r2,r2
8110e86c:	d0a06e04 	addi	r2,gp,-32328
8110e870:	1885883a 	add	r2,r3,r2
8110e874:	10800017 	ldw	r2,0(r2)
8110e878:	1009883a 	mov	r4,r2
8110e87c:	1137a840 	call	81137a84 <OSQFlush>
8110e880:	e0bffc45 	stb	r2,-15(fp)
				if ( errorCodeL != OS_NO_ERR ) {
8110e884:	e0bffc43 	ldbu	r2,-15(fp)
8110e888:	10000126 	beq	r2,zero,8110e890 <vPerformActionNFCConfig+0xf4>
					vFailFlushQueue();
8110e88c:	11179240 	call	81117924 <vFailFlushQueue>
			errorCodeL = OSQFlush(xNfeeSchedule);
			if ( errorCodeL != OS_NO_ERR ) {
				vFailFlushQueue();
			}

			for( i = 0; i < N_OF_NFEE; i++)
8110e890:	e0bffc03 	ldbu	r2,-16(fp)
8110e894:	10800044 	addi	r2,r2,1
8110e898:	e0bffc05 	stb	r2,-16(fp)
8110e89c:	e0bffc03 	ldbu	r2,-16(fp)
8110e8a0:	103fef26 	beq	r2,zero,8110e860 <__reset+0xfb0ee860>
					vFailFlushQueue();
				}
			}


			break;		
8110e8a4:	00000806 	br	8110e8c8 <vPerformActionNFCConfig+0x12c>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110e8a8:	d0a05f17 	ldw	r2,-32388(gp)
8110e8ac:	100f883a 	mov	r7,r2
8110e8b0:	01800984 	movi	r6,38
8110e8b4:	01400044 	movi	r5,1
8110e8b8:	01204534 	movhi	r4,33044
8110e8bc:	211ab904 	addi	r4,r4,27364
8110e8c0:	111affc0 	call	8111affc <fwrite>
			#endif	
			break;
8110e8c4:	0001883a 	nop
	}

}
8110e8c8:	0001883a 	nop
8110e8cc:	e037883a 	mov	sp,fp
8110e8d0:	dfc00117 	ldw	ra,4(sp)
8110e8d4:	df000017 	ldw	fp,0(sp)
8110e8d8:	dec00204 	addi	sp,sp,8
8110e8dc:	f800283a 	ret

8110e8e0 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110e8e0:	defffa04 	addi	sp,sp,-24
8110e8e4:	de00012e 	bgeu	sp,et,8110e8ec <vPerformActionNFCRunning+0xc>
8110e8e8:	003b68fa 	trap	3
8110e8ec:	dfc00515 	stw	ra,20(sp)
8110e8f0:	df000415 	stw	fp,16(sp)
8110e8f4:	df000404 	addi	fp,sp,16
8110e8f8:	e13ffe15 	stw	r4,-8(fp)
8110e8fc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
8110e900:	e0bffe17 	ldw	r2,-8(fp)
8110e904:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110e908:	e0bffd83 	ldbu	r2,-10(fp)
8110e90c:	10803fcc 	andi	r2,r2,255
8110e910:	10c00060 	cmpeqi	r3,r2,1
8110e914:	1800031e 	bne	r3,zero,8110e924 <vPerformActionNFCRunning+0x44>
8110e918:	108000a0 	cmpeqi	r2,r2,2
8110e91c:	1000281e 	bne	r2,zero,8110e9c0 <vPerformActionNFCRunning+0xe0>
8110e920:	00002f06 	br	8110e9e0 <vPerformActionNFCRunning+0x100>
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
8110e924:	d0a05f17 	ldw	r2,-32388(gp)
8110e928:	100f883a 	mov	r7,r2
8110e92c:	01800b84 	movi	r6,46
8110e930:	01400044 	movi	r5,1
8110e934:	01204534 	movhi	r4,33044
8110e938:	211ac304 	addi	r4,r4,27404
8110e93c:	111affc0 	call	8111affc <fwrite>
			#endif

			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sMebConfig);
8110e940:	e0bfff17 	ldw	r2,-4(fp)
8110e944:	10809517 	ldw	r2,596(r2)
8110e948:	000b883a 	mov	r5,zero
8110e94c:	1009883a 	mov	r4,r2
8110e950:	11179e00 	call	811179e0 <vEvtChangeFeeControllerMode>
			pxFeeCP->sMode = sMebConfig;
8110e954:	e0bfff17 	ldw	r2,-4(fp)
8110e958:	10009515 	stw	zero,596(r2)

			/* Change all NFEEs to Config mode */

			for( i = 0; i < N_OF_NFEE; i++)
8110e95c:	e03ffc05 	stb	zero,-16(fp)
8110e960:	00001406 	br	8110e9b4 <vPerformActionNFCRunning+0xd4>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110e964:	e0bffc03 	ldbu	r2,-16(fp)
8110e968:	e0ffff17 	ldw	r3,-4(fp)
8110e96c:	10802484 	addi	r2,r2,146
8110e970:	1085883a 	add	r2,r2,r2
8110e974:	1085883a 	add	r2,r2,r2
8110e978:	1885883a 	add	r2,r3,r2
8110e97c:	10800017 	ldw	r2,0(r2)
8110e980:	10800017 	ldw	r2,0(r2)
8110e984:	10800058 	cmpnei	r2,r2,1
8110e988:	1000071e 	bne	r2,zero,8110e9a8 <vPerformActionNFCRunning+0xc8>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
8110e98c:	e0bffc03 	ldbu	r2,-16(fp)
8110e990:	e0fffc03 	ldbu	r3,-16(fp)
8110e994:	180f883a 	mov	r7,r3
8110e998:	000d883a 	mov	r6,zero
8110e99c:	01402844 	movi	r5,161
8110e9a0:	1009883a 	mov	r4,r2
8110e9a4:	110ea180 	call	8110ea18 <bSendCmdQToNFeeInst>
			vEvtChangeFeeControllerMode(pxFeeCP->sMode, sMebConfig);
			pxFeeCP->sMode = sMebConfig;

			/* Change all NFEEs to Config mode */

			for( i = 0; i < N_OF_NFEE; i++)
8110e9a8:	e0bffc03 	ldbu	r2,-16(fp)
8110e9ac:	10800044 	addi	r2,r2,1
8110e9b0:	e0bffc05 	stb	r2,-16(fp)
8110e9b4:	e0bffc03 	ldbu	r2,-16(fp)
8110e9b8:	103fea26 	beq	r2,zero,8110e964 <__reset+0xfb0ee964>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
8110e9bc:	00001006 	br	8110ea00 <vPerformActionNFCRunning+0x120>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
8110e9c0:	d0a05f17 	ldw	r2,-32388(gp)
8110e9c4:	100f883a 	mov	r7,r2
8110e9c8:	01800d84 	movi	r6,54
8110e9cc:	01400044 	movi	r5,1
8110e9d0:	01204534 	movhi	r4,33044
8110e9d4:	211acf04 	addi	r4,r4,27452
8110e9d8:	111affc0 	call	8111affc <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
8110e9dc:	00000806 	br	8110ea00 <vPerformActionNFCRunning+0x120>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
8110e9e0:	d0a05f17 	ldw	r2,-32388(gp)
8110e9e4:	100f883a 	mov	r7,r2
8110e9e8:	01800984 	movi	r6,38
8110e9ec:	01400044 	movi	r5,1
8110e9f0:	01204534 	movhi	r4,33044
8110e9f4:	211ab904 	addi	r4,r4,27364
8110e9f8:	111affc0 	call	8111affc <fwrite>
			#endif	
			break;
8110e9fc:	0001883a 	nop
	}
}
8110ea00:	0001883a 	nop
8110ea04:	e037883a 	mov	sp,fp
8110ea08:	dfc00117 	ldw	ra,4(sp)
8110ea0c:	df000017 	ldw	fp,0(sp)
8110ea10:	dec00204 	addi	sp,sp,8
8110ea14:	f800283a 	ret

8110ea18 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110ea18:	defff704 	addi	sp,sp,-36
8110ea1c:	de00012e 	bgeu	sp,et,8110ea24 <bSendCmdQToNFeeInst+0xc>
8110ea20:	003b68fa 	trap	3
8110ea24:	dfc00815 	stw	ra,32(sp)
8110ea28:	df000715 	stw	fp,28(sp)
8110ea2c:	df000704 	addi	fp,sp,28
8110ea30:	2011883a 	mov	r8,r4
8110ea34:	2809883a 	mov	r4,r5
8110ea38:	3007883a 	mov	r3,r6
8110ea3c:	3805883a 	mov	r2,r7
8110ea40:	e23ffc05 	stb	r8,-16(fp)
8110ea44:	e13ffd05 	stb	r4,-12(fp)
8110ea48:	e0fffe05 	stb	r3,-8(fp)
8110ea4c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110ea50:	e0bffc03 	ldbu	r2,-16(fp)
8110ea54:	10800444 	addi	r2,r2,17
8110ea58:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110ea5c:	e0bffd03 	ldbu	r2,-12(fp)
8110ea60:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110ea64:	e0bffe03 	ldbu	r2,-8(fp)
8110ea68:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110ea6c:	e0bfff03 	ldbu	r2,-4(fp)
8110ea70:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110ea74:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110ea78:	e0bffc03 	ldbu	r2,-16(fp)
8110ea7c:	1085883a 	add	r2,r2,r2
8110ea80:	1087883a 	add	r3,r2,r2
8110ea84:	d0a06e04 	addi	r2,gp,-32328
8110ea88:	1885883a 	add	r2,r3,r2
8110ea8c:	10800017 	ldw	r2,0(r2)
8110ea90:	e0fffb17 	ldw	r3,-20(fp)
8110ea94:	180b883a 	mov	r5,r3
8110ea98:	1009883a 	mov	r4,r2
8110ea9c:	1137f4c0 	call	81137f4c <OSQPost>
8110eaa0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110eaa4:	e0bffa03 	ldbu	r2,-24(fp)
8110eaa8:	10000526 	beq	r2,zero,8110eac0 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110eaac:	e0bffc03 	ldbu	r2,-16(fp)
8110eab0:	1009883a 	mov	r4,r2
8110eab4:	11177e40 	call	811177e4 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110eab8:	e03ff915 	stw	zero,-28(fp)
8110eabc:	00000206 	br	8110eac8 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
8110eac0:	00800044 	movi	r2,1
8110eac4:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110eac8:	e0bff917 	ldw	r2,-28(fp)
}
8110eacc:	e037883a 	mov	sp,fp
8110ead0:	dfc00117 	ldw	ra,4(sp)
8110ead4:	df000017 	ldw	fp,0(sp)
8110ead8:	dec00204 	addi	sp,sp,8
8110eadc:	f800283a 	ret

8110eae0 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110eae0:	defff704 	addi	sp,sp,-36
8110eae4:	de00012e 	bgeu	sp,et,8110eaec <vOutAckHandlerTask+0xc>
8110eae8:	003b68fa 	trap	3
8110eaec:	dfc00815 	stw	ra,32(sp)
8110eaf0:	df000715 	stw	fp,28(sp)
8110eaf4:	df000704 	addi	fp,sp,28
8110eaf8:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110eafc:	e03ffac5 	stb	zero,-21(fp)
8110eb00:	e03ffb05 	stb	zero,-20(fp)
8110eb04:	e03ffb45 	stb	zero,-19(fp)
8110eb08:	e03ffb85 	stb	zero,-18(fp)
8110eb0c:	e03ffbc5 	stb	zero,-17(fp)
8110eb10:	e03ffc05 	stb	zero,-16(fp)
8110eb14:	e03ffc45 	stb	zero,-15(fp)
8110eb18:	e03ffc85 	stb	zero,-14(fp)
8110eb1c:	e03ffcc5 	stb	zero,-13(fp)
8110eb20:	e03ffd05 	stb	zero,-12(fp)
8110eb24:	e03ffd45 	stb	zero,-11(fp)
8110eb28:	e03ffd85 	stb	zero,-10(fp)
8110eb2c:	e03ffdc5 	stb	zero,-9(fp)
8110eb30:	e03ffe05 	stb	zero,-8(fp)
8110eb34:	e03ffe45 	stb	zero,-7(fp)
8110eb38:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110eb3c:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
8110eb40:	d0a05f17 	ldw	r2,-32388(gp)
8110eb44:	100f883a 	mov	r7,r2
8110eb48:	01800804 	movi	r6,32
8110eb4c:	01400044 	movi	r5,1
8110eb50:	01204534 	movhi	r4,33044
8110eb54:	211add04 	addi	r4,r4,27508
8110eb58:	111affc0 	call	8111affc <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8110eb5c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110eb60:	e0bff917 	ldw	r2,-28(fp)
8110eb64:	10c00060 	cmpeqi	r3,r2,1
8110eb68:	1800071e 	bne	r3,zero,8110eb88 <vOutAckHandlerTask+0xa8>
8110eb6c:	0080032e 	bgeu	zero,r2,8110eb7c <vOutAckHandlerTask+0x9c>
8110eb70:	108000a0 	cmpeqi	r2,r2,2
8110eb74:	1000471e 	bne	r2,zero,8110ec94 <vOutAckHandlerTask+0x1b4>
8110eb78:	00008c06 	br	8110edac <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110eb7c:	00800044 	movi	r2,1
8110eb80:	e0bff915 	stw	r2,-28(fp)
				break;
8110eb84:	00009306 	br	8110edd4 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110eb88:	00800044 	movi	r2,1
8110eb8c:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110eb90:	d0a05e17 	ldw	r2,-32392(gp)
8110eb94:	e0fffa84 	addi	r3,fp,-22
8110eb98:	180d883a 	mov	r6,r3
8110eb9c:	000b883a 	mov	r5,zero
8110eba0:	1009883a 	mov	r4,r2
8110eba4:	1138a3c0 	call	81138a3c <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110eba8:	e0bffa83 	ldbu	r2,-22(fp)
8110ebac:	10803fcc 	andi	r2,r2,255
8110ebb0:	1000361e 	bne	r2,zero,8110ec8c <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110ebb4:	d0a07517 	ldw	r2,-32300(gp)
8110ebb8:	e0fffa84 	addi	r3,fp,-22
8110ebbc:	180d883a 	mov	r6,r3
8110ebc0:	000b883a 	mov	r5,zero
8110ebc4:	1009883a 	mov	r4,r2
8110ebc8:	1136a300 	call	81136a30 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110ebcc:	e0bffa83 	ldbu	r2,-22(fp)
8110ebd0:	10803fcc 	andi	r2,r2,255
8110ebd4:	10002b1e 	bne	r2,zero,8110ec84 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110ebd8:	e03ffa05 	stb	zero,-24(fp)
8110ebdc:	00002206 	br	8110ec68 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110ebe0:	e0fffa03 	ldbu	r3,-24(fp)
8110ebe4:	00a045b4 	movhi	r2,33046
8110ebe8:	10be0904 	addi	r2,r2,-2012
8110ebec:	18c7883a 	add	r3,r3,r3
8110ebf0:	18c7883a 	add	r3,r3,r3
8110ebf4:	10c5883a 	add	r2,r2,r3
8110ebf8:	10800003 	ldbu	r2,0(r2)
8110ebfc:	10803fcc 	andi	r2,r2,255
8110ec00:	1080201c 	xori	r2,r2,128
8110ec04:	10bfe004 	addi	r2,r2,-128
8110ec08:	10001426 	beq	r2,zero,8110ec5c <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110ec0c:	e0fffa03 	ldbu	r3,-24(fp)
8110ec10:	00a045b4 	movhi	r2,33046
8110ec14:	10be0904 	addi	r2,r2,-2012
8110ec18:	18c7883a 	add	r3,r3,r3
8110ec1c:	18c7883a 	add	r3,r3,r3
8110ec20:	10c5883a 	add	r2,r2,r3
8110ec24:	10c0000b 	ldhu	r3,0(r2)
8110ec28:	d0e0560d 	sth	r3,-32424(gp)
8110ec2c:	1080008b 	ldhu	r2,2(r2)
8110ec30:	d0a0568d 	sth	r2,-32422(gp)
                                eSenderAckState = sSASending;
8110ec34:	00800084 	movi	r2,2
8110ec38:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110ec3c:	e0fffa03 	ldbu	r3,-24(fp)
8110ec40:	00a045b4 	movhi	r2,33046
8110ec44:	10be0904 	addi	r2,r2,-2012
8110ec48:	18c7883a 	add	r3,r3,r3
8110ec4c:	18c7883a 	add	r3,r3,r3
8110ec50:	10c5883a 	add	r2,r2,r3
8110ec54:	10000005 	stb	zero,0(r2)
                                break;
8110ec58:	00000606 	br	8110ec74 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110ec5c:	e0bffa03 	ldbu	r2,-24(fp)
8110ec60:	10800044 	addi	r2,r2,1
8110ec64:	e0bffa05 	stb	r2,-24(fp)
8110ec68:	e0bffa03 	ldbu	r2,-24(fp)
8110ec6c:	10800230 	cmpltui	r2,r2,8
8110ec70:	103fdb1e 	bne	r2,zero,8110ebe0 <__reset+0xfb0eebe0>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110ec74:	d0a07517 	ldw	r2,-32300(gp)
8110ec78:	1009883a 	mov	r4,r2
8110ec7c:	1136fd40 	call	81136fd4 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110ec80:	00005406 	br	8110edd4 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110ec84:	1115ff80 	call	81115ff8 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110ec88:	00005206 	br	8110edd4 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110ec8c:	1115f900 	call	81115f90 <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110ec90:	00005006 	br	8110edd4 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110ec94:	d0a05603 	ldbu	r2,-32424(gp)
8110ec98:	10803fcc 	andi	r2,r2,255
8110ec9c:	1080201c 	xori	r2,r2,128
8110eca0:	10bfe004 	addi	r2,r2,-128
8110eca4:	108008e0 	cmpeqi	r2,r2,35
8110eca8:	1000201e 	bne	r2,zero,8110ed2c <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110ecac:	d0a05643 	ldbu	r2,-32423(gp)
8110ecb0:	10c03fcc 	andi	r3,r2,255
8110ecb4:	18c0201c 	xori	r3,r3,128
8110ecb8:	18ffe004 	addi	r3,r3,-128
8110ecbc:	d0a0568b 	ldhu	r2,-32422(gp)
8110ecc0:	113fffcc 	andi	r4,r2,65535
8110ecc4:	e0bffac4 	addi	r2,fp,-21
8110ecc8:	200f883a 	mov	r7,r4
8110eccc:	180d883a 	mov	r6,r3
8110ecd0:	01604534 	movhi	r5,33044
8110ecd4:	295ae604 	addi	r5,r5,27544
8110ecd8:	1009883a 	mov	r4,r2
8110ecdc:	111c2f00 	call	8111c2f0 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110ece0:	e0bffac4 	addi	r2,fp,-21
8110ece4:	1009883a 	mov	r4,r2
8110ece8:	111c5040 	call	8111c504 <strlen>
8110ecec:	1007883a 	mov	r3,r2
8110ecf0:	e0bffac4 	addi	r2,fp,-21
8110ecf4:	180b883a 	mov	r5,r3
8110ecf8:	1009883a 	mov	r4,r2
8110ecfc:	1115ba80 	call	81115ba8 <ucCrc8wInit>
8110ed00:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110ed04:	e13ffa43 	ldbu	r4,-23(fp)
8110ed08:	e0fffac4 	addi	r3,fp,-21
8110ed0c:	e0bffac4 	addi	r2,fp,-21
8110ed10:	200f883a 	mov	r7,r4
8110ed14:	180d883a 	mov	r6,r3
8110ed18:	01604534 	movhi	r5,33044
8110ed1c:	295ae804 	addi	r5,r5,27552
8110ed20:	1009883a 	mov	r4,r2
8110ed24:	111c2f00 	call	8111c2f0 <sprintf>
8110ed28:	00000c06 	br	8110ed5c <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110ed2c:	e0bffac4 	addi	r2,fp,-21
8110ed30:	00c008c4 	movi	r3,35
8110ed34:	10c00005 	stb	r3,0(r2)
8110ed38:	00c01f04 	movi	r3,124
8110ed3c:	10c00045 	stb	r3,1(r2)
8110ed40:	00c00d44 	movi	r3,53
8110ed44:	10c00085 	stb	r3,2(r2)
8110ed48:	00c00d04 	movi	r3,52
8110ed4c:	10c000c5 	stb	r3,3(r2)
8110ed50:	00c00ec4 	movi	r3,59
8110ed54:	10c00105 	stb	r3,4(r2)
8110ed58:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110ed5c:	d0a07717 	ldw	r2,-32292(gp)
8110ed60:	e0fffa84 	addi	r3,fp,-22
8110ed64:	180d883a 	mov	r6,r3
8110ed68:	01401904 	movi	r5,100
8110ed6c:	1009883a 	mov	r4,r2
8110ed70:	1136a300 	call	81136a30 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110ed74:	e0bffa83 	ldbu	r2,-22(fp)
8110ed78:	10803fcc 	andi	r2,r2,255
8110ed7c:	1000071e 	bne	r2,zero,8110ed9c <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
8110ed80:	e0bffac4 	addi	r2,fp,-21
8110ed84:	1009883a 	mov	r4,r2
8110ed88:	111bfac0 	call	8111bfac <puts>
                    OSMutexPost(xTxUARTMutex);
8110ed8c:	d0a07717 	ldw	r2,-32292(gp)
8110ed90:	1009883a 	mov	r4,r2
8110ed94:	1136fd40 	call	81136fd4 <OSMutexPost>
8110ed98:	00000106 	br	8110eda0 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8110ed9c:	11161300 	call	81116130 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
8110eda0:	00800044 	movi	r2,1
8110eda4:	e0bff915 	stw	r2,-28(fp)
                
				break;
8110eda8:	00000a06 	br	8110edd4 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
8110edac:	d0a05f17 	ldw	r2,-32388(gp)
8110edb0:	100f883a 	mov	r7,r2
8110edb4:	01801104 	movi	r6,68
8110edb8:	01400044 	movi	r5,1
8110edbc:	01204534 	movhi	r4,33044
8110edc0:	211aeb04 	addi	r4,r4,27564
8110edc4:	111affc0 	call	8111affc <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
8110edc8:	00800044 	movi	r2,1
8110edcc:	e0bff915 	stw	r2,-28(fp)
				break;
8110edd0:	0001883a 	nop
		}
	}
8110edd4:	003f6206 	br	8110eb60 <__reset+0xfb0eeb60>

8110edd8 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110edd8:	deffd704 	addi	sp,sp,-164
8110eddc:	de00012e 	bgeu	sp,et,8110ede4 <vParserCommTask+0xc>
8110ede0:	003b68fa 	trap	3
8110ede4:	dfc02815 	stw	ra,160(sp)
8110ede8:	df002715 	stw	fp,156(sp)
8110edec:	df002704 	addi	fp,sp,156
8110edf0:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8110edf4:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
8110edf8:	d0a05f17 	ldw	r2,-32388(gp)
8110edfc:	100f883a 	mov	r7,r2
8110ee00:	01800704 	movi	r6,28
8110ee04:	01400044 	movi	r5,1
8110ee08:	01204534 	movhi	r4,33044
8110ee0c:	211afd04 	addi	r4,r4,27636
8110ee10:	111affc0 	call	8111affc <fwrite>
    #endif

	eParserMode = sConfiguring;
8110ee14:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
8110ee18:	e0bfdc17 	ldw	r2,-144(fp)
8110ee1c:	10800168 	cmpgeui	r2,r2,5
8110ee20:	1003691e 	bne	r2,zero,8110fbc8 <vParserCommTask+0xdf0>
8110ee24:	e0bfdc17 	ldw	r2,-144(fp)
8110ee28:	100690ba 	slli	r3,r2,2
8110ee2c:	00a04474 	movhi	r2,33041
8110ee30:	10bb9004 	addi	r2,r2,-4544
8110ee34:	1885883a 	add	r2,r3,r2
8110ee38:	10800017 	ldw	r2,0(r2)
8110ee3c:	1000683a 	jmp	r2
8110ee40:	8110ee54 	ori	r4,r16,17337
8110ee44:	8110ee60 	cmpeqi	r4,r16,17337
8110ee48:	8110eef4 	orhi	r4,r16,17339
8110ee4c:	8110f074 	orhi	r4,r16,17345
8110ee50:	8110f0b8 	rdprs	r4,r16,17346
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8110ee54:	00800044 	movi	r2,1
8110ee58:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110ee5c:	00035d06 	br	8110fbd4 <vParserCommTask+0xdfc>
			case sWaitingMessage:

				bSuccess = FALSE;
8110ee60:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
8110ee64:	00800044 	movi	r2,1
8110ee68:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8110ee6c:	d0a06117 	ldw	r2,-32380(gp)
8110ee70:	e0ffde84 	addi	r3,fp,-134
8110ee74:	180d883a 	mov	r6,r3
8110ee78:	000b883a 	mov	r5,zero
8110ee7c:	1009883a 	mov	r4,r2
8110ee80:	1138a3c0 	call	81138a3c <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8110ee84:	e0bfde83 	ldbu	r2,-134(fp)
8110ee88:	10803fcc 	andi	r2,r2,255
8110ee8c:	1000171e 	bne	r2,zero,8110eeec <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
8110ee90:	01204574 	movhi	r4,33045
8110ee94:	21313a04 	addi	r4,r4,-15128
8110ee98:	110fbd80 	call	8110fbd8 <getPreParsedPacket>
8110ee9c:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
8110eea0:	e0bfdd17 	ldw	r2,-140(fp)
8110eea4:	10800058 	cmpnei	r2,r2,1
8110eea8:	10000e1e 	bne	r2,zero,8110eee4 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8110eeac:	00a04574 	movhi	r2,33045
8110eeb0:	10b13a04 	addi	r2,r2,-15128
8110eeb4:	10800103 	ldbu	r2,4(r2)
8110eeb8:	10803fcc 	andi	r2,r2,255
8110eebc:	1080201c 	xori	r2,r2,128
8110eec0:	10bfe004 	addi	r2,r2,-128
8110eec4:	10800858 	cmpnei	r2,r2,33
8110eec8:	1000031e 	bne	r2,zero,8110eed8 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
8110eecc:	008000c4 	movi	r2,3
8110eed0:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110eed4:	00033f06 	br	8110fbd4 <vParserCommTask+0xdfc>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8110eed8:	00800084 	movi	r2,2
8110eedc:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110eee0:	00033c06 	br	8110fbd4 <vParserCommTask+0xdfc>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8110eee4:	11166bc0 	call	811166bc <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110eee8:	00033a06 	br	8110fbd4 <vParserCommTask+0xdfc>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110eeec:	11165ec0 	call	811165ec <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
8110eef0:	00033806 	br	8110fbd4 <vParserCommTask+0xdfc>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8110eef4:	00a04574 	movhi	r2,33045
8110eef8:	10b13a04 	addi	r2,r2,-15128
8110eefc:	10800143 	ldbu	r2,5(r2)
8110ef00:	10803fcc 	andi	r2,r2,255
8110ef04:	1080201c 	xori	r2,r2,128
8110ef08:	10bfe004 	addi	r2,r2,-128
8110ef0c:	10c010e0 	cmpeqi	r3,r2,67
8110ef10:	1800031e 	bne	r3,zero,8110ef20 <vParserCommTask+0x148>
8110ef14:	10801420 	cmpeqi	r2,r2,80
8110ef18:	1000051e 	bne	r2,zero,8110ef30 <vParserCommTask+0x158>
8110ef1c:	00005106 	br	8110f064 <vParserCommTask+0x28c>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
8110ef20:	11143780 	call	81114378 <vSendEthConf>
						eParserMode = sWaitingMessage;
8110ef24:	00800044 	movi	r2,1
8110ef28:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110ef2c:	00005006 	br	8110f070 <vParserCommTask+0x298>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							debug(fp,"PUS Received:\n");
8110ef30:	d0a05f17 	ldw	r2,-32388(gp)
8110ef34:	100f883a 	mov	r7,r2
8110ef38:	01800384 	movi	r6,14
8110ef3c:	01400044 	movi	r5,1
8110ef40:	01204534 	movhi	r4,33044
8110ef44:	211b0504 	addi	r4,r4,27668
8110ef48:	111affc0 	call	8111affc <fwrite>
							memset(cPUSDebug,0,128);
8110ef4c:	e0bfdec4 	addi	r2,fp,-133
8110ef50:	01802004 	movi	r6,128
8110ef54:	000b883a 	mov	r5,zero
8110ef58:	1009883a 	mov	r4,r2
8110ef5c:	111bb600 	call	8111bb60 <memset>
							sprintf(cPUSDebug, "TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
8110ef60:	00a04574 	movhi	r2,33045
8110ef64:	10b13a04 	addi	r2,r2,-15128
8110ef68:	1080028b 	ldhu	r2,10(r2)
8110ef6c:	117fffcc 	andi	r5,r2,65535
8110ef70:	00a04574 	movhi	r2,33045
8110ef74:	10b13a04 	addi	r2,r2,-15128
8110ef78:	1080030b 	ldhu	r2,12(r2)
8110ef7c:	11bfffcc 	andi	r6,r2,65535
8110ef80:	00a04574 	movhi	r2,33045
8110ef84:	10b13a04 	addi	r2,r2,-15128
8110ef88:	1080038b 	ldhu	r2,14(r2)
8110ef8c:	10ffffcc 	andi	r3,r2,65535
8110ef90:	00a04574 	movhi	r2,33045
8110ef94:	10b13a04 	addi	r2,r2,-15128
8110ef98:	1080040b 	ldhu	r2,16(r2)
8110ef9c:	113fffcc 	andi	r4,r2,65535
8110efa0:	00a04574 	movhi	r2,33045
8110efa4:	10b13a04 	addi	r2,r2,-15128
8110efa8:	1080048b 	ldhu	r2,18(r2)
8110efac:	10bfffcc 	andi	r2,r2,65535
8110efb0:	e23fdec4 	addi	r8,fp,-133
8110efb4:	d8800215 	stw	r2,8(sp)
8110efb8:	d9000115 	stw	r4,4(sp)
8110efbc:	d8c00015 	stw	r3,0(sp)
8110efc0:	300f883a 	mov	r7,r6
8110efc4:	280d883a 	mov	r6,r5
8110efc8:	01604534 	movhi	r5,33044
8110efcc:	295b0904 	addi	r5,r5,27684
8110efd0:	4009883a 	mov	r4,r8
8110efd4:	111c2f00 	call	8111c2f0 <sprintf>
							debug(fp, cPUSDebug );
8110efd8:	d0a05f17 	ldw	r2,-32388(gp)
8110efdc:	e0ffdec4 	addi	r3,fp,-133
8110efe0:	180b883a 	mov	r5,r3
8110efe4:	1009883a 	mov	r4,r2
8110efe8:	111a9600 	call	8111a960 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
8110efec:	00a04574 	movhi	r2,33045
8110eff0:	10b13a04 	addi	r2,r2,-15128
8110eff4:	10c0030b 	ldhu	r3,12(r2)
8110eff8:	00a04574 	movhi	r2,33045
8110effc:	10b14d04 	addi	r2,r2,-15052
8110f000:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
8110f004:	00a04574 	movhi	r2,33045
8110f008:	10b13a04 	addi	r2,r2,-15128
8110f00c:	10c0038b 	ldhu	r3,14(r2)
8110f010:	00a04574 	movhi	r2,33045
8110f014:	10b14d04 	addi	r2,r2,-15052
8110f018:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
8110f01c:	00a04574 	movhi	r2,33045
8110f020:	10b13a04 	addi	r2,r2,-15128
8110f024:	10c0040b 	ldhu	r3,16(r2)
8110f028:	00a04574 	movhi	r2,33045
8110f02c:	10b14d04 	addi	r2,r2,-15052
8110f030:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
8110f034:	00a04574 	movhi	r2,33045
8110f038:	10b13a04 	addi	r2,r2,-15128
8110f03c:	10c0048b 	ldhu	r3,18(r2)
8110f040:	00a04574 	movhi	r2,33045
8110f044:	10b14d04 	addi	r2,r2,-15052
8110f048:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
8110f04c:	00a04574 	movhi	r2,33045
8110f050:	10b14d04 	addi	r2,r2,-15052
8110f054:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8110f058:	00800104 	movi	r2,4
8110f05c:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
8110f060:	00000306 	br	8110f070 <vParserCommTask+0x298>
					default:
						eParserMode = sWaitingMessage;
8110f064:	00800044 	movi	r2,1
8110f068:	e0bfdc15 	stw	r2,-144(fp)
						break;
8110f06c:	0001883a 	nop
				}
				break;
8110f070:	0002d806 	br	8110fbd4 <vParserCommTask+0xdfc>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
8110f074:	00800044 	movi	r2,1
8110f078:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
8110f07c:	00a04574 	movhi	r2,33045
8110f080:	10b14d04 	addi	r2,r2,-15052
8110f084:	1080030b 	ldhu	r2,12(r2)
8110f088:	10bfffcc 	andi	r2,r2,65535
8110f08c:	10c01220 	cmpeqi	r3,r2,72
8110f090:	1800051e 	bne	r3,zero,8110f0a8 <vParserCommTask+0x2d0>
8110f094:	108014e0 	cmpeqi	r2,r2,83
8110f098:	1000051e 	bne	r2,zero,8110f0b0 <vParserCommTask+0x2d8>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
8110f09c:	00800044 	movi	r2,1
8110f0a0:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110f0a4:	00000306 	br	8110f0b4 <vParserCommTask+0x2dc>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8110f0a8:	0001883a 	nop
8110f0ac:	0002c906 	br	8110fbd4 <vParserCommTask+0xdfc>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
8110f0b0:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
8110f0b4:	0002c706 	br	8110fbd4 <vParserCommTask+0xdfc>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8110f0b8:	00800044 	movi	r2,1
8110f0bc:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
8110f0c0:	00a04574 	movhi	r2,33045
8110f0c4:	10b14d04 	addi	r2,r2,-15052
8110f0c8:	1080030b 	ldhu	r2,12(r2)
8110f0cc:	10bfffcc 	andi	r2,r2,65535
8110f0d0:	10c03ea0 	cmpeqi	r3,r2,250
8110f0d4:	1800401e 	bne	r3,zero,8110f1d8 <vParserCommTask+0x400>
8110f0d8:	10c03ec8 	cmpgei	r3,r2,251
8110f0dc:	1800031e 	bne	r3,zero,8110f0ec <vParserCommTask+0x314>
8110f0e0:	10800460 	cmpeqi	r2,r2,17
8110f0e4:	1000061e 	bne	r2,zero,8110f100 <vParserCommTask+0x328>
8110f0e8:	0002b306 	br	8110fbb8 <vParserCommTask+0xde0>
8110f0ec:	10c03ee0 	cmpeqi	r3,r2,251
8110f0f0:	18009a1e 	bne	r3,zero,8110f35c <vParserCommTask+0x584>
8110f0f4:	10803f20 	cmpeqi	r2,r2,252
8110f0f8:	10012f1e 	bne	r2,zero,8110f5b8 <vParserCommTask+0x7e0>
8110f0fc:	0002ae06 	br	8110fbb8 <vParserCommTask+0xde0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
8110f100:	00a04574 	movhi	r2,33045
8110f104:	10b14d04 	addi	r2,r2,-15052
8110f108:	1080038b 	ldhu	r2,14(r2)
8110f10c:	10bfffcc 	andi	r2,r2,65535
8110f110:	10800060 	cmpeqi	r2,r2,1
8110f114:	10000e26 	beq	r2,zero,8110f150 <vParserCommTask+0x378>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TEST_CONNECTION\n");
8110f118:	d0a05f17 	ldw	r2,-32388(gp)
8110f11c:	100f883a 	mov	r7,r2
8110f120:	01800604 	movi	r6,24
8110f124:	01400044 	movi	r5,1
8110f128:	01204534 	movhi	r4,33044
8110f12c:	211b1c04 	addi	r4,r4,27760
8110f130:	111affc0 	call	8111affc <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
8110f134:	00a04574 	movhi	r2,33045
8110f138:	10b14d04 	addi	r2,r2,-15052
8110f13c:	1080040b 	ldhu	r2,16(r2)
8110f140:	10bfffcc 	andi	r2,r2,65535
8110f144:	1009883a 	mov	r4,r2
8110f148:	1114d780 	call	81114d78 <vTMPusTestConnection>

								break;
8110f14c:	00002106 	br	8110f1d4 <vParserCommTask+0x3fc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f150:	e0bfdec4 	addi	r2,fp,-133
8110f154:	01802004 	movi	r6,128
8110f158:	000b883a 	mov	r5,zero
8110f15c:	1009883a 	mov	r4,r2
8110f160:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110f164:	00a04574 	movhi	r2,33045
8110f168:	10b14d04 	addi	r2,r2,-15052
8110f16c:	1080030b 	ldhu	r2,12(r2)
8110f170:	113fffcc 	andi	r4,r2,65535
8110f174:	00a04574 	movhi	r2,33045
8110f178:	10b14d04 	addi	r2,r2,-15052
8110f17c:	1080038b 	ldhu	r2,14(r2)
8110f180:	117fffcc 	andi	r5,r2,65535
8110f184:	00a04574 	movhi	r2,33045
8110f188:	10b14d04 	addi	r2,r2,-15052
8110f18c:	1080040b 	ldhu	r2,16(r2)
8110f190:	10bfffcc 	andi	r2,r2,65535
8110f194:	e0ffdec4 	addi	r3,fp,-133
8110f198:	d8800015 	stw	r2,0(sp)
8110f19c:	280f883a 	mov	r7,r5
8110f1a0:	200d883a 	mov	r6,r4
8110f1a4:	01604534 	movhi	r5,33044
8110f1a8:	295b2304 	addi	r5,r5,27788
8110f1ac:	1809883a 	mov	r4,r3
8110f1b0:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f1b4:	d0a05f17 	ldw	r2,-32388(gp)
8110f1b8:	e0ffdec4 	addi	r3,fp,-133
8110f1bc:	180b883a 	mov	r5,r3
8110f1c0:	1009883a 	mov	r4,r2
8110f1c4:	111a9600 	call	8111a960 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
8110f1c8:	00800044 	movi	r2,1
8110f1cc:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110f1d0:	0001883a 	nop
						}
                        break;
8110f1d4:	00027b06 	br	8110fbc4 <vParserCommTask+0xdec>
                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
8110f1d8:	00a04574 	movhi	r2,33045
8110f1dc:	10b14d04 	addi	r2,r2,-15052
8110f1e0:	1080038b 	ldhu	r2,14(r2)
8110f1e4:	10bfffcc 	andi	r2,r2,65535
8110f1e8:	10c00f20 	cmpeqi	r3,r2,60
8110f1ec:	18001a1e 	bne	r3,zero,8110f258 <vParserCommTask+0x480>
8110f1f0:	10c00f48 	cmpgei	r3,r2,61
8110f1f4:	1800031e 	bne	r3,zero,8110f204 <vParserCommTask+0x42c>
8110f1f8:	10800ee0 	cmpeqi	r2,r2,59
8110f1fc:	1000061e 	bne	r2,zero,8110f218 <vParserCommTask+0x440>
8110f200:	00003406 	br	8110f2d4 <vParserCommTask+0x4fc>
8110f204:	10c00f60 	cmpeqi	r3,r2,61
8110f208:	18001e1e 	bne	r3,zero,8110f284 <vParserCommTask+0x4ac>
8110f20c:	10800fa0 	cmpeqi	r2,r2,62
8110f210:	1000271e 	bne	r2,zero,8110f2b0 <vParserCommTask+0x4d8>
8110f214:	00002f06 	br	8110f2d4 <vParserCommTask+0x4fc>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RESET\n");
8110f218:	d0a05f17 	ldw	r2,-32388(gp)
8110f21c:	100f883a 	mov	r7,r2
8110f220:	01800384 	movi	r6,14
8110f224:	01400044 	movi	r5,1
8110f228:	01204534 	movhi	r4,33044
8110f22c:	211b3304 	addi	r4,r4,27852
8110f230:	111affc0 	call	8111affc <fwrite>
								#endif
								vSendReset();
8110f234:	11147200 	call	81114720 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,1,0);
8110f238:	000f883a 	mov	r7,zero
8110f23c:	01800044 	movi	r6,1
8110f240:	000b883a 	mov	r5,zero
8110f244:	0009883a 	mov	r4,zero
8110f248:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
								vRstcSimucamReset( 50000 );
8110f24c:	0130d414 	movui	r4,50000
8110f250:	110af6c0 	call	8110af6c <vRstcSimucamReset>

								break;
8110f254:	00004006 	br	8110f358 <vParserCommTask+0x580>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_CONFIG\n");
8110f258:	d0a05f17 	ldw	r2,-32388(gp)
8110f25c:	100f883a 	mov	r7,r2
8110f260:	018003c4 	movi	r6,15
8110f264:	01400044 	movi	r5,1
8110f268:	01204534 	movhi	r4,33044
8110f26c:	211b3704 	addi	r4,r4,27868
8110f270:	111affc0 	call	8111affc <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f274:	01204574 	movhi	r4,33045
8110f278:	21314d04 	addi	r4,r4,-15052
8110f27c:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

								break;
8110f280:	00003506 	br	8110f358 <vParserCommTask+0x580>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_RUN\n");
8110f284:	d0a05f17 	ldw	r2,-32388(gp)
8110f288:	100f883a 	mov	r7,r2
8110f28c:	01800304 	movi	r6,12
8110f290:	01400044 	movi	r5,1
8110f294:	01204534 	movhi	r4,33044
8110f298:	211b3b04 	addi	r4,r4,27884
8110f29c:	111affc0 	call	8111affc <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f2a0:	01204574 	movhi	r4,33045
8110f2a4:	21314d04 	addi	r4,r4,-15052
8110f2a8:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

								break;
8110f2ac:	00002a06 	br	8110f358 <vParserCommTask+0x580>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"TC_SCAM_TURNOFF\n");
8110f2b0:	d0a05f17 	ldw	r2,-32388(gp)
8110f2b4:	100f883a 	mov	r7,r2
8110f2b8:	01800404 	movi	r6,16
8110f2bc:	01400044 	movi	r5,1
8110f2c0:	01204534 	movhi	r4,33044
8110f2c4:	211b3f04 	addi	r4,r4,27900
8110f2c8:	111affc0 	call	8111affc <fwrite>
								#endif
								vSendTurnOff();
8110f2cc:	11146080 	call	81114608 <vSendTurnOff>

								/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
								/* todo:Enviar Sinalizar Led quando puder desligar */

								break;
8110f2d0:	00002106 	br	8110f358 <vParserCommTask+0x580>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f2d4:	e0bfdec4 	addi	r2,fp,-133
8110f2d8:	01802004 	movi	r6,128
8110f2dc:	000b883a 	mov	r5,zero
8110f2e0:	1009883a 	mov	r4,r2
8110f2e4:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110f2e8:	00a04574 	movhi	r2,33045
8110f2ec:	10b14d04 	addi	r2,r2,-15052
8110f2f0:	1080030b 	ldhu	r2,12(r2)
8110f2f4:	113fffcc 	andi	r4,r2,65535
8110f2f8:	00a04574 	movhi	r2,33045
8110f2fc:	10b14d04 	addi	r2,r2,-15052
8110f300:	1080038b 	ldhu	r2,14(r2)
8110f304:	117fffcc 	andi	r5,r2,65535
8110f308:	00a04574 	movhi	r2,33045
8110f30c:	10b14d04 	addi	r2,r2,-15052
8110f310:	1080040b 	ldhu	r2,16(r2)
8110f314:	10bfffcc 	andi	r2,r2,65535
8110f318:	e0ffdec4 	addi	r3,fp,-133
8110f31c:	d8800015 	stw	r2,0(sp)
8110f320:	280f883a 	mov	r7,r5
8110f324:	200d883a 	mov	r6,r4
8110f328:	01604534 	movhi	r5,33044
8110f32c:	295b2304 	addi	r5,r5,27788
8110f330:	1809883a 	mov	r4,r3
8110f334:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f338:	d0a05f17 	ldw	r2,-32388(gp)
8110f33c:	e0ffdec4 	addi	r3,fp,-133
8110f340:	180b883a 	mov	r5,r3
8110f344:	1009883a 	mov	r4,r2
8110f348:	111a9600 	call	8111a960 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110f34c:	00800044 	movi	r2,1
8110f350:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110f354:	0001883a 	nop
						}
                        break;
8110f358:	00021a06 	br	8110fbc4 <vParserCommTask+0xdec>
                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110f35c:	00a04574 	movhi	r2,33045
8110f360:	10b13a04 	addi	r2,r2,-15128
8110f364:	1080050b 	ldhu	r2,20(r2)
8110f368:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8110f36c:	e0bfde0b 	ldhu	r2,-136(fp)
8110f370:	108000b0 	cmpltui	r2,r2,2
8110f374:	1000121e 	bne	r2,zero,8110f3c0 <vParserCommTask+0x5e8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
8110f378:	e0bfdec4 	addi	r2,fp,-133
8110f37c:	01802004 	movi	r6,128
8110f380:	000b883a 	mov	r5,zero
8110f384:	1009883a 	mov	r4,r2
8110f388:	111bb600 	call	8111bb60 <memset>
								sprintf(cPUSDebug, "Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
8110f38c:	e0ffde0b 	ldhu	r3,-136(fp)
8110f390:	e0bfdec4 	addi	r2,fp,-133
8110f394:	180d883a 	mov	r6,r3
8110f398:	01604534 	movhi	r5,33044
8110f39c:	295b4404 	addi	r5,r5,27920
8110f3a0:	1009883a 	mov	r4,r2
8110f3a4:	111c2f00 	call	8111c2f0 <sprintf>
								debug(fp, cPUSDebug );
8110f3a8:	d0a05f17 	ldw	r2,-32388(gp)
8110f3ac:	e0ffdec4 	addi	r3,fp,-133
8110f3b0:	180b883a 	mov	r5,r3
8110f3b4:	1009883a 	mov	r4,r2
8110f3b8:	111a9600 	call	8111a960 <fprintf>
									break;
							}
						}


                        break;
8110f3bc:	00020106 	br	8110fbc4 <vParserCommTask+0xdec>
								sprintf(cPUSDebug, "Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110f3c0:	00a04574 	movhi	r2,33045
8110f3c4:	10b14d04 	addi	r2,r2,-15052
8110f3c8:	10800483 	ldbu	r2,18(r2)
8110f3cc:	10c03fcc 	andi	r3,r2,255
8110f3d0:	00a04574 	movhi	r2,33045
8110f3d4:	10b14d04 	addi	r2,r2,-15052
8110f3d8:	18c00284 	addi	r3,r3,10
8110f3dc:	18c7883a 	add	r3,r3,r3
8110f3e0:	10c5883a 	add	r2,r2,r3
8110f3e4:	e0ffde0b 	ldhu	r3,-136(fp)
8110f3e8:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8110f3ec:	00a04574 	movhi	r2,33045
8110f3f0:	10b14d04 	addi	r2,r2,-15052
8110f3f4:	10800483 	ldbu	r2,18(r2)
8110f3f8:	10800044 	addi	r2,r2,1
8110f3fc:	1007883a 	mov	r3,r2
8110f400:	00a04574 	movhi	r2,33045
8110f404:	10b14d04 	addi	r2,r2,-15052
8110f408:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8110f40c:	00a04574 	movhi	r2,33045
8110f410:	10b14d04 	addi	r2,r2,-15052
8110f414:	1080038b 	ldhu	r2,14(r2)
8110f418:	10bfffcc 	andi	r2,r2,65535
8110f41c:	10c000a0 	cmpeqi	r3,r2,2
8110f420:	1800191e 	bne	r3,zero,8110f488 <vParserCommTask+0x6b0>
8110f424:	10c00160 	cmpeqi	r3,r2,5
8110f428:	18002c1e 	bne	r3,zero,8110f4dc <vParserCommTask+0x704>
8110f42c:	10800060 	cmpeqi	r2,r2,1
8110f430:	10003f26 	beq	r2,zero,8110f530 <vParserCommTask+0x758>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110f434:	e0bfdec4 	addi	r2,fp,-133
8110f438:	01802004 	movi	r6,128
8110f43c:	000b883a 	mov	r5,zero
8110f440:	1009883a 	mov	r4,r2
8110f444:	111bb600 	call	8111bb60 <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_CONFIG_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110f448:	e0ffde0b 	ldhu	r3,-136(fp)
8110f44c:	e0bfdec4 	addi	r2,fp,-133
8110f450:	180d883a 	mov	r6,r3
8110f454:	01604534 	movhi	r5,33044
8110f458:	295b5004 	addi	r5,r5,27968
8110f45c:	1009883a 	mov	r4,r2
8110f460:	111c2f00 	call	8111c2f0 <sprintf>
										debug(fp, cPUSDebug );
8110f464:	d0a05f17 	ldw	r2,-32388(gp)
8110f468:	e0ffdec4 	addi	r3,fp,-133
8110f46c:	180b883a 	mov	r5,r3
8110f470:	1009883a 	mov	r4,r2
8110f474:	111a9600 	call	8111a960 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
8110f478:	01204574 	movhi	r4,33045
8110f47c:	21314d04 	addi	r4,r4,-15052
8110f480:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

									break;
8110f484:	00004b06 	br	8110f5b4 <vParserCommTask+0x7dc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110f488:	e0bfdec4 	addi	r2,fp,-133
8110f48c:	01802004 	movi	r6,128
8110f490:	000b883a 	mov	r5,zero
8110f494:	1009883a 	mov	r4,r2
8110f498:	111bb600 	call	8111bb60 <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_STANDBY_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110f49c:	e0ffde0b 	ldhu	r3,-136(fp)
8110f4a0:	e0bfdec4 	addi	r2,fp,-133
8110f4a4:	180d883a 	mov	r6,r3
8110f4a8:	01604534 	movhi	r5,33044
8110f4ac:	295b5c04 	addi	r5,r5,28016
8110f4b0:	1009883a 	mov	r4,r2
8110f4b4:	111c2f00 	call	8111c2f0 <sprintf>
										debug(fp, cPUSDebug );
8110f4b8:	d0a05f17 	ldw	r2,-32388(gp)
8110f4bc:	e0ffdec4 	addi	r3,fp,-133
8110f4c0:	180b883a 	mov	r5,r3
8110f4c4:	1009883a 	mov	r4,r2
8110f4c8:	111a9600 	call	8111a960 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110f4cc:	01204574 	movhi	r4,33045
8110f4d0:	21314d04 	addi	r4,r4,-15052
8110f4d4:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

									break;
8110f4d8:	00003606 	br	8110f5b4 <vParserCommTask+0x7dc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110f4dc:	e0bfdec4 	addi	r2,fp,-133
8110f4e0:	01802004 	movi	r6,128
8110f4e4:	000b883a 	mov	r5,zero
8110f4e8:	1009883a 	mov	r4,r2
8110f4ec:	111bb600 	call	8111bb60 <memset>
										sprintf(cPUSDebug, "TC_SCAM_FEE_CALIBRATION_TEST_ENTER-> Fee Instance: %hu;\n", usiFeeInstL );
8110f4f0:	e0ffde0b 	ldhu	r3,-136(fp)
8110f4f4:	e0bfdec4 	addi	r2,fp,-133
8110f4f8:	180d883a 	mov	r6,r3
8110f4fc:	01604534 	movhi	r5,33044
8110f500:	295b6804 	addi	r5,r5,28064
8110f504:	1009883a 	mov	r4,r2
8110f508:	111c2f00 	call	8111c2f0 <sprintf>
										debug(fp, cPUSDebug );
8110f50c:	d0a05f17 	ldw	r2,-32388(gp)
8110f510:	e0ffdec4 	addi	r3,fp,-133
8110f514:	180b883a 	mov	r5,r3
8110f518:	1009883a 	mov	r4,r2
8110f51c:	111a9600 	call	8111a960 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
8110f520:	01204574 	movhi	r4,33045
8110f524:	21314d04 	addi	r4,r4,-15052
8110f528:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

									break;
8110f52c:	00002106 	br	8110f5b4 <vParserCommTask+0x7dc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8110f530:	e0bfdec4 	addi	r2,fp,-133
8110f534:	01802004 	movi	r6,128
8110f538:	000b883a 	mov	r5,zero
8110f53c:	1009883a 	mov	r4,r2
8110f540:	111bb600 	call	8111bb60 <memset>
										sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110f544:	00a04574 	movhi	r2,33045
8110f548:	10b14d04 	addi	r2,r2,-15052
8110f54c:	1080030b 	ldhu	r2,12(r2)
8110f550:	113fffcc 	andi	r4,r2,65535
8110f554:	00a04574 	movhi	r2,33045
8110f558:	10b14d04 	addi	r2,r2,-15052
8110f55c:	1080038b 	ldhu	r2,14(r2)
8110f560:	117fffcc 	andi	r5,r2,65535
8110f564:	00a04574 	movhi	r2,33045
8110f568:	10b14d04 	addi	r2,r2,-15052
8110f56c:	1080040b 	ldhu	r2,16(r2)
8110f570:	10bfffcc 	andi	r2,r2,65535
8110f574:	e0ffdec4 	addi	r3,fp,-133
8110f578:	d8800015 	stw	r2,0(sp)
8110f57c:	280f883a 	mov	r7,r5
8110f580:	200d883a 	mov	r6,r4
8110f584:	01604534 	movhi	r5,33044
8110f588:	295b2304 	addi	r5,r5,27788
8110f58c:	1809883a 	mov	r4,r3
8110f590:	111c2f00 	call	8111c2f0 <sprintf>
										debug(fp, cPUSDebug );
8110f594:	d0a05f17 	ldw	r2,-32388(gp)
8110f598:	e0ffdec4 	addi	r3,fp,-133
8110f59c:	180b883a 	mov	r5,r3
8110f5a0:	1009883a 	mov	r4,r2
8110f5a4:	111a9600 	call	8111a960 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
8110f5a8:	00800044 	movi	r2,1
8110f5ac:	e0bfdc15 	stw	r2,-144(fp)
									break;
8110f5b0:	0001883a 	nop
							}
						}


                        break;
8110f5b4:	00018306 	br	8110fbc4 <vParserCommTask+0xdec>
					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8110f5b8:	00a04574 	movhi	r2,33045
8110f5bc:	10b13a04 	addi	r2,r2,-15128
8110f5c0:	1080050b 	ldhu	r2,20(r2)
8110f5c4:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8110f5c8:	00a04574 	movhi	r2,33045
8110f5cc:	10b14d04 	addi	r2,r2,-15052
8110f5d0:	10800483 	ldbu	r2,18(r2)
8110f5d4:	10c03fcc 	andi	r3,r2,255
8110f5d8:	00a04574 	movhi	r2,33045
8110f5dc:	10b14d04 	addi	r2,r2,-15052
8110f5e0:	18c00284 	addi	r3,r3,10
8110f5e4:	18c7883a 	add	r3,r3,r3
8110f5e8:	10c5883a 	add	r2,r2,r3
8110f5ec:	e0ffde0b 	ldhu	r3,-136(fp)
8110f5f0:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
8110f5f4:	00a04574 	movhi	r2,33045
8110f5f8:	10b14d04 	addi	r2,r2,-15052
8110f5fc:	10800483 	ldbu	r2,18(r2)
8110f600:	10800044 	addi	r2,r2,1
8110f604:	1007883a 	mov	r3,r2
8110f608:	00a04574 	movhi	r2,33045
8110f60c:	10b14d04 	addi	r2,r2,-15052
8110f610:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
8110f614:	00a04574 	movhi	r2,33045
8110f618:	10b14d04 	addi	r2,r2,-15052
8110f61c:	1080038b 	ldhu	r2,14(r2)
8110f620:	10bfffcc 	andi	r2,r2,65535
8110f624:	10c000e0 	cmpeqi	r3,r2,3
8110f628:	18000a1e 	bne	r3,zero,8110f654 <vParserCommTask+0x87c>
8110f62c:	10c00108 	cmpgei	r3,r2,4
8110f630:	1800031e 	bne	r3,zero,8110f640 <vParserCommTask+0x868>
8110f634:	108000a0 	cmpeqi	r2,r2,2
8110f638:	1000451e 	bne	r2,zero,8110f750 <vParserCommTask+0x978>
8110f63c:	00013c06 	br	8110fb30 <vParserCommTask+0xd58>
8110f640:	10c00120 	cmpeqi	r3,r2,4
8110f644:	1800181e 	bne	r3,zero,8110f6a8 <vParserCommTask+0x8d0>
8110f648:	10800160 	cmpeqi	r2,r2,5
8110f64c:	10002b1e 	bne	r2,zero,8110f6fc <vParserCommTask+0x924>
8110f650:	00013706 	br	8110fb30 <vParserCommTask+0xd58>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f654:	e0bfdec4 	addi	r2,fp,-133
8110f658:	01802004 	movi	r6,128
8110f65c:	000b883a 	mov	r5,zero
8110f660:	1009883a 	mov	r4,r2
8110f664:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_ENABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110f668:	e0ffde0b 	ldhu	r3,-136(fp)
8110f66c:	e0bfdec4 	addi	r2,fp,-133
8110f670:	180d883a 	mov	r6,r3
8110f674:	01604534 	movhi	r5,33044
8110f678:	295b7704 	addi	r5,r5,28124
8110f67c:	1009883a 	mov	r4,r2
8110f680:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f684:	d0a05f17 	ldw	r2,-32388(gp)
8110f688:	e0ffdec4 	addi	r3,fp,-133
8110f68c:	180b883a 	mov	r5,r3
8110f690:	1009883a 	mov	r4,r2
8110f694:	111a9600 	call	8111a960 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f698:	01204574 	movhi	r4,33045
8110f69c:	21314d04 	addi	r4,r4,-15052
8110f6a0:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

								break;
8110f6a4:	00014306 	br	8110fbb4 <vParserCommTask+0xddc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f6a8:	e0bfdec4 	addi	r2,fp,-133
8110f6ac:	01802004 	movi	r6,128
8110f6b0:	000b883a 	mov	r5,zero
8110f6b4:	1009883a 	mov	r4,r2
8110f6b8:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_DISABLE-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110f6bc:	e0ffde0b 	ldhu	r3,-136(fp)
8110f6c0:	e0bfdec4 	addi	r2,fp,-133
8110f6c4:	180d883a 	mov	r6,r3
8110f6c8:	01604534 	movhi	r5,33044
8110f6cc:	295b8404 	addi	r5,r5,28176
8110f6d0:	1009883a 	mov	r4,r2
8110f6d4:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f6d8:	d0a05f17 	ldw	r2,-32388(gp)
8110f6dc:	e0ffdec4 	addi	r3,fp,-133
8110f6e0:	180b883a 	mov	r5,r3
8110f6e4:	1009883a 	mov	r4,r2
8110f6e8:	111a9600 	call	8111a960 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f6ec:	01204574 	movhi	r4,33045
8110f6f0:	21314d04 	addi	r4,r4,-15052
8110f6f4:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

								break;
8110f6f8:	00012e06 	br	8110fbb4 <vParserCommTask+0xddc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f6fc:	e0bfdec4 	addi	r2,fp,-133
8110f700:	01802004 	movi	r6,128
8110f704:	000b883a 	mov	r5,zero
8110f708:	1009883a 	mov	r4,r2
8110f70c:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_LINK_RESET-> FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110f710:	e0ffde0b 	ldhu	r3,-136(fp)
8110f714:	e0bfdec4 	addi	r2,fp,-133
8110f718:	180d883a 	mov	r6,r3
8110f71c:	01604534 	movhi	r5,33044
8110f720:	295b9104 	addi	r5,r5,28228
8110f724:	1009883a 	mov	r4,r2
8110f728:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f72c:	d0a05f17 	ldw	r2,-32388(gp)
8110f730:	e0ffdec4 	addi	r3,fp,-133
8110f734:	180b883a 	mov	r5,r3
8110f738:	1009883a 	mov	r4,r2
8110f73c:	111a9600 	call	8111a960 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8110f740:	01204574 	movhi	r4,33045
8110f744:	21314d04 	addi	r4,r4,-15052
8110f748:	110fcf00 	call	8110fcf0 <bSendMessagePUStoMebTask>

								break;
8110f74c:	00011906 	br	8110fbb4 <vParserCommTask+0xddc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
8110f750:	00a04574 	movhi	r2,33045
8110f754:	10b14d04 	addi	r2,r2,-15052
8110f758:	10800483 	ldbu	r2,18(r2)
8110f75c:	10c03fcc 	andi	r3,r2,255
8110f760:	00a04574 	movhi	r2,33045
8110f764:	10b13a04 	addi	r2,r2,-15128
8110f768:	1100058b 	ldhu	r4,22(r2)
8110f76c:	00a04574 	movhi	r2,33045
8110f770:	10b14d04 	addi	r2,r2,-15052
8110f774:	18c00284 	addi	r3,r3,10
8110f778:	18c7883a 	add	r3,r3,r3
8110f77c:	10c5883a 	add	r2,r2,r3
8110f780:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110f784:	00a04574 	movhi	r2,33045
8110f788:	10b14d04 	addi	r2,r2,-15052
8110f78c:	10800483 	ldbu	r2,18(r2)
8110f790:	10800044 	addi	r2,r2,1
8110f794:	1007883a 	mov	r3,r2
8110f798:	00a04574 	movhi	r2,33045
8110f79c:	10b14d04 	addi	r2,r2,-15052
8110f7a0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
8110f7a4:	00a04574 	movhi	r2,33045
8110f7a8:	10b14d04 	addi	r2,r2,-15052
8110f7ac:	10800483 	ldbu	r2,18(r2)
8110f7b0:	10c03fcc 	andi	r3,r2,255
8110f7b4:	00a04574 	movhi	r2,33045
8110f7b8:	10b13a04 	addi	r2,r2,-15128
8110f7bc:	1100060b 	ldhu	r4,24(r2)
8110f7c0:	00a04574 	movhi	r2,33045
8110f7c4:	10b14d04 	addi	r2,r2,-15052
8110f7c8:	18c00284 	addi	r3,r3,10
8110f7cc:	18c7883a 	add	r3,r3,r3
8110f7d0:	10c5883a 	add	r2,r2,r3
8110f7d4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110f7d8:	00a04574 	movhi	r2,33045
8110f7dc:	10b14d04 	addi	r2,r2,-15052
8110f7e0:	10800483 	ldbu	r2,18(r2)
8110f7e4:	10800044 	addi	r2,r2,1
8110f7e8:	1007883a 	mov	r3,r2
8110f7ec:	00a04574 	movhi	r2,33045
8110f7f0:	10b14d04 	addi	r2,r2,-15052
8110f7f4:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
8110f7f8:	00a04574 	movhi	r2,33045
8110f7fc:	10b14d04 	addi	r2,r2,-15052
8110f800:	10800483 	ldbu	r2,18(r2)
8110f804:	10c03fcc 	andi	r3,r2,255
8110f808:	00a04574 	movhi	r2,33045
8110f80c:	10b13a04 	addi	r2,r2,-15128
8110f810:	1100068b 	ldhu	r4,26(r2)
8110f814:	00a04574 	movhi	r2,33045
8110f818:	10b14d04 	addi	r2,r2,-15052
8110f81c:	18c00284 	addi	r3,r3,10
8110f820:	18c7883a 	add	r3,r3,r3
8110f824:	10c5883a 	add	r2,r2,r3
8110f828:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110f82c:	00a04574 	movhi	r2,33045
8110f830:	10b14d04 	addi	r2,r2,-15052
8110f834:	10800483 	ldbu	r2,18(r2)
8110f838:	10800044 	addi	r2,r2,1
8110f83c:	1007883a 	mov	r3,r2
8110f840:	00a04574 	movhi	r2,33045
8110f844:	10b14d04 	addi	r2,r2,-15052
8110f848:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8110f84c:	00a04574 	movhi	r2,33045
8110f850:	10b14d04 	addi	r2,r2,-15052
8110f854:	10800483 	ldbu	r2,18(r2)
8110f858:	10c03fcc 	andi	r3,r2,255
8110f85c:	00a04574 	movhi	r2,33045
8110f860:	10b13a04 	addi	r2,r2,-15128
8110f864:	1100070b 	ldhu	r4,28(r2)
8110f868:	00a04574 	movhi	r2,33045
8110f86c:	10b14d04 	addi	r2,r2,-15052
8110f870:	18c00284 	addi	r3,r3,10
8110f874:	18c7883a 	add	r3,r3,r3
8110f878:	10c5883a 	add	r2,r2,r3
8110f87c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110f880:	00a04574 	movhi	r2,33045
8110f884:	10b14d04 	addi	r2,r2,-15052
8110f888:	10800483 	ldbu	r2,18(r2)
8110f88c:	10800044 	addi	r2,r2,1
8110f890:	1007883a 	mov	r3,r2
8110f894:	00a04574 	movhi	r2,33045
8110f898:	10b14d04 	addi	r2,r2,-15052
8110f89c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
8110f8a0:	00a04574 	movhi	r2,33045
8110f8a4:	10b14d04 	addi	r2,r2,-15052
8110f8a8:	10800483 	ldbu	r2,18(r2)
8110f8ac:	10c03fcc 	andi	r3,r2,255
8110f8b0:	00a04574 	movhi	r2,33045
8110f8b4:	10b13a04 	addi	r2,r2,-15128
8110f8b8:	1100078b 	ldhu	r4,30(r2)
8110f8bc:	00a04574 	movhi	r2,33045
8110f8c0:	10b14d04 	addi	r2,r2,-15052
8110f8c4:	18c00284 	addi	r3,r3,10
8110f8c8:	18c7883a 	add	r3,r3,r3
8110f8cc:	10c5883a 	add	r2,r2,r3
8110f8d0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110f8d4:	00a04574 	movhi	r2,33045
8110f8d8:	10b14d04 	addi	r2,r2,-15052
8110f8dc:	10800483 	ldbu	r2,18(r2)
8110f8e0:	10800044 	addi	r2,r2,1
8110f8e4:	1007883a 	mov	r3,r2
8110f8e8:	00a04574 	movhi	r2,33045
8110f8ec:	10b14d04 	addi	r2,r2,-15052
8110f8f0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
8110f8f4:	00a04574 	movhi	r2,33045
8110f8f8:	10b14d04 	addi	r2,r2,-15052
8110f8fc:	10800483 	ldbu	r2,18(r2)
8110f900:	10c03fcc 	andi	r3,r2,255
8110f904:	00a04574 	movhi	r2,33045
8110f908:	10b13a04 	addi	r2,r2,-15128
8110f90c:	1100080b 	ldhu	r4,32(r2)
8110f910:	00a04574 	movhi	r2,33045
8110f914:	10b14d04 	addi	r2,r2,-15052
8110f918:	18c00284 	addi	r3,r3,10
8110f91c:	18c7883a 	add	r3,r3,r3
8110f920:	10c5883a 	add	r2,r2,r3
8110f924:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8110f928:	00a04574 	movhi	r2,33045
8110f92c:	10b14d04 	addi	r2,r2,-15052
8110f930:	10800483 	ldbu	r2,18(r2)
8110f934:	10800044 	addi	r2,r2,1
8110f938:	1007883a 	mov	r3,r2
8110f93c:	00a04574 	movhi	r2,33045
8110f940:	10b14d04 	addi	r2,r2,-15052
8110f944:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110f948:	e0bfdec4 	addi	r2,fp,-133
8110f94c:	01802004 	movi	r6,128
8110f950:	000b883a 	mov	r5,zero
8110f954:	1009883a 	mov	r4,r2
8110f958:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "TC_SCAM_SPW_RMAP_CONFIG_UPDATE->\n");
8110f95c:	e0ffdec4 	addi	r3,fp,-133
8110f960:	00a04534 	movhi	r2,33044
8110f964:	109b9d04 	addi	r2,r2,28276
8110f968:	1009883a 	mov	r4,r2
8110f96c:	00800884 	movi	r2,34
8110f970:	100d883a 	mov	r6,r2
8110f974:	200b883a 	mov	r5,r4
8110f978:	1809883a 	mov	r4,r3
8110f97c:	111ba100 	call	8111ba10 <memcpy>
									debug(fp, cPUSDebug );
8110f980:	d0a05f17 	ldw	r2,-32388(gp)
8110f984:	e0ffdec4 	addi	r3,fp,-133
8110f988:	180b883a 	mov	r5,r3
8110f98c:	1009883a 	mov	r4,r2
8110f990:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
8110f994:	e0ffde0b 	ldhu	r3,-136(fp)
8110f998:	e0bfdec4 	addi	r2,fp,-133
8110f99c:	180d883a 	mov	r6,r3
8110f9a0:	01604534 	movhi	r5,33044
8110f9a4:	295ba604 	addi	r5,r5,28312
8110f9a8:	1009883a 	mov	r4,r2
8110f9ac:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f9b0:	d0a05f17 	ldw	r2,-32388(gp)
8110f9b4:	e0ffdec4 	addi	r3,fp,-133
8110f9b8:	180b883a 	mov	r5,r3
8110f9bc:	1009883a 	mov	r4,r2
8110f9c0:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
8110f9c4:	00a04574 	movhi	r2,33045
8110f9c8:	10b13a04 	addi	r2,r2,-15128
8110f9cc:	1080058b 	ldhu	r2,22(r2)
8110f9d0:	10ffffcc 	andi	r3,r2,65535
8110f9d4:	e0bfdec4 	addi	r2,fp,-133
8110f9d8:	180d883a 	mov	r6,r3
8110f9dc:	01604534 	movhi	r5,33044
8110f9e0:	295bad04 	addi	r5,r5,28340
8110f9e4:	1009883a 	mov	r4,r2
8110f9e8:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110f9ec:	d0a05f17 	ldw	r2,-32388(gp)
8110f9f0:	e0ffdec4 	addi	r3,fp,-133
8110f9f4:	180b883a 	mov	r5,r3
8110f9f8:	1009883a 	mov	r4,r2
8110f9fc:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
8110fa00:	00a04574 	movhi	r2,33045
8110fa04:	10b13a04 	addi	r2,r2,-15128
8110fa08:	1080060b 	ldhu	r2,24(r2)
8110fa0c:	10ffffcc 	andi	r3,r2,65535
8110fa10:	e0bfdec4 	addi	r2,fp,-133
8110fa14:	180d883a 	mov	r6,r3
8110fa18:	01604534 	movhi	r5,33044
8110fa1c:	295bb104 	addi	r5,r5,28356
8110fa20:	1009883a 	mov	r4,r2
8110fa24:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110fa28:	d0a05f17 	ldw	r2,-32388(gp)
8110fa2c:	e0ffdec4 	addi	r3,fp,-133
8110fa30:	180b883a 	mov	r5,r3
8110fa34:	1009883a 	mov	r4,r2
8110fa38:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
8110fa3c:	00a04574 	movhi	r2,33045
8110fa40:	10b13a04 	addi	r2,r2,-15128
8110fa44:	1080068b 	ldhu	r2,26(r2)
8110fa48:	10ffffcc 	andi	r3,r2,65535
8110fa4c:	e0bfdec4 	addi	r2,fp,-133
8110fa50:	180d883a 	mov	r6,r3
8110fa54:	01604534 	movhi	r5,33044
8110fa58:	295bb604 	addi	r5,r5,28376
8110fa5c:	1009883a 	mov	r4,r2
8110fa60:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110fa64:	d0a05f17 	ldw	r2,-32388(gp)
8110fa68:	e0ffdec4 	addi	r3,fp,-133
8110fa6c:	180b883a 	mov	r5,r3
8110fa70:	1009883a 	mov	r4,r2
8110fa74:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
8110fa78:	00a04574 	movhi	r2,33045
8110fa7c:	10b13a04 	addi	r2,r2,-15128
8110fa80:	1080070b 	ldhu	r2,28(r2)
8110fa84:	10ffffcc 	andi	r3,r2,65535
8110fa88:	e0bfdec4 	addi	r2,fp,-133
8110fa8c:	180d883a 	mov	r6,r3
8110fa90:	01604534 	movhi	r5,33044
8110fa94:	295bbd04 	addi	r5,r5,28404
8110fa98:	1009883a 	mov	r4,r2
8110fa9c:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110faa0:	d0a05f17 	ldw	r2,-32388(gp)
8110faa4:	e0ffdec4 	addi	r3,fp,-133
8110faa8:	180b883a 	mov	r5,r3
8110faac:	1009883a 	mov	r4,r2
8110fab0:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
8110fab4:	00a04574 	movhi	r2,33045
8110fab8:	10b13a04 	addi	r2,r2,-15128
8110fabc:	1080078b 	ldhu	r2,30(r2)
8110fac0:	10ffffcc 	andi	r3,r2,65535
8110fac4:	e0bfdec4 	addi	r2,fp,-133
8110fac8:	180d883a 	mov	r6,r3
8110facc:	01604534 	movhi	r5,33044
8110fad0:	295bc404 	addi	r5,r5,28432
8110fad4:	1009883a 	mov	r4,r2
8110fad8:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110fadc:	d0a05f17 	ldw	r2,-32388(gp)
8110fae0:	e0ffdec4 	addi	r3,fp,-133
8110fae4:	180b883a 	mov	r5,r3
8110fae8:	1009883a 	mov	r4,r2
8110faec:	111a9600 	call	8111a960 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
8110faf0:	00a04574 	movhi	r2,33045
8110faf4:	10b13a04 	addi	r2,r2,-15128
8110faf8:	1080080b 	ldhu	r2,32(r2)
8110fafc:	10ffffcc 	andi	r3,r2,65535
8110fb00:	e0bfdec4 	addi	r2,fp,-133
8110fb04:	180d883a 	mov	r6,r3
8110fb08:	01604534 	movhi	r5,33044
8110fb0c:	295bca04 	addi	r5,r5,28456
8110fb10:	1009883a 	mov	r4,r2
8110fb14:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110fb18:	d0a05f17 	ldw	r2,-32388(gp)
8110fb1c:	e0ffdec4 	addi	r3,fp,-133
8110fb20:	180b883a 	mov	r5,r3
8110fb24:	1009883a 	mov	r4,r2
8110fb28:	111a9600 	call	8111a960 <fprintf>
								#endif

								break;
8110fb2c:	00002106 	br	8110fbb4 <vParserCommTask+0xddc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8110fb30:	e0bfdec4 	addi	r2,fp,-133
8110fb34:	01802004 	movi	r6,128
8110fb38:	000b883a 	mov	r5,zero
8110fb3c:	1009883a 	mov	r4,r2
8110fb40:	111bb600 	call	8111bb60 <memset>
									sprintf(cPUSDebug, "Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8110fb44:	00a04574 	movhi	r2,33045
8110fb48:	10b14d04 	addi	r2,r2,-15052
8110fb4c:	1080030b 	ldhu	r2,12(r2)
8110fb50:	113fffcc 	andi	r4,r2,65535
8110fb54:	00a04574 	movhi	r2,33045
8110fb58:	10b14d04 	addi	r2,r2,-15052
8110fb5c:	1080038b 	ldhu	r2,14(r2)
8110fb60:	117fffcc 	andi	r5,r2,65535
8110fb64:	00a04574 	movhi	r2,33045
8110fb68:	10b14d04 	addi	r2,r2,-15052
8110fb6c:	1080040b 	ldhu	r2,16(r2)
8110fb70:	10bfffcc 	andi	r2,r2,65535
8110fb74:	e0ffdec4 	addi	r3,fp,-133
8110fb78:	d8800015 	stw	r2,0(sp)
8110fb7c:	280f883a 	mov	r7,r5
8110fb80:	200d883a 	mov	r6,r4
8110fb84:	01604534 	movhi	r5,33044
8110fb88:	295b2304 	addi	r5,r5,27788
8110fb8c:	1809883a 	mov	r4,r3
8110fb90:	111c2f00 	call	8111c2f0 <sprintf>
									debug(fp, cPUSDebug );
8110fb94:	d0a05f17 	ldw	r2,-32388(gp)
8110fb98:	e0ffdec4 	addi	r3,fp,-133
8110fb9c:	180b883a 	mov	r5,r3
8110fba0:	1009883a 	mov	r4,r2
8110fba4:	111a9600 	call	8111a960 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8110fba8:	00800044 	movi	r2,1
8110fbac:	e0bfdc15 	stw	r2,-144(fp)
								break;
8110fbb0:	0001883a 	nop
						}
                        break;
8110fbb4:	00000306 	br	8110fbc4 <vParserCommTask+0xdec>
                    default:
						eParserMode = sWaitingMessage;
8110fbb8:	00800044 	movi	r2,1
8110fbbc:	e0bfdc15 	stw	r2,-144(fp)
                        break;
8110fbc0:	0001883a 	nop
                }
				break;				
8110fbc4:	00000306 	br	8110fbd4 <vParserCommTask+0xdfc>
			default:
				eParserMode = sWaitingMessage;
8110fbc8:	00800044 	movi	r2,1
8110fbcc:	e0bfdc15 	stw	r2,-144(fp)
				break;
8110fbd0:	0001883a 	nop
		}
	}
8110fbd4:	003c9006 	br	8110ee18 <__reset+0xfb0eee18>

8110fbd8 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
8110fbd8:	defffb04 	addi	sp,sp,-20
8110fbdc:	de00012e 	bgeu	sp,et,8110fbe4 <getPreParsedPacket+0xc>
8110fbe0:	003b68fa 	trap	3
8110fbe4:	dfc00415 	stw	ra,16(sp)
8110fbe8:	df000315 	stw	fp,12(sp)
8110fbec:	df000304 	addi	fp,sp,12
8110fbf0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110fbf4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
8110fbf8:	d0a06f17 	ldw	r2,-32324(gp)
8110fbfc:	e0fffe44 	addi	r3,fp,-7
8110fc00:	180d883a 	mov	r6,r3
8110fc04:	000b883a 	mov	r5,zero
8110fc08:	1009883a 	mov	r4,r2
8110fc0c:	1136a300 	call	81136a30 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
8110fc10:	e0bffe43 	ldbu	r2,-7(fp)
8110fc14:	10803fcc 	andi	r2,r2,255
8110fc18:	10002e1e 	bne	r2,zero,8110fcd4 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8110fc1c:	e03ffe05 	stb	zero,-8(fp)
8110fc20:	00002506 	br	8110fcb8 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
8110fc24:	e0fffe03 	ldbu	r3,-8(fp)
8110fc28:	00a045b4 	movhi	r2,33046
8110fc2c:	10be1104 	addi	r2,r2,-1980
8110fc30:	18c01324 	muli	r3,r3,76
8110fc34:	10c5883a 	add	r2,r2,r3
8110fc38:	10800104 	addi	r2,r2,4
8110fc3c:	10800003 	ldbu	r2,0(r2)
8110fc40:	10803fcc 	andi	r2,r2,255
8110fc44:	1080201c 	xori	r2,r2,128
8110fc48:	10bfe004 	addi	r2,r2,-128
8110fc4c:	10001726 	beq	r2,zero,8110fcac <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
8110fc50:	e0fffe03 	ldbu	r3,-8(fp)
8110fc54:	e13fff17 	ldw	r4,-4(fp)
8110fc58:	00a045b4 	movhi	r2,33046
8110fc5c:	10be1104 	addi	r2,r2,-1980
8110fc60:	18c01324 	muli	r3,r3,76
8110fc64:	10c5883a 	add	r2,r2,r3
8110fc68:	2007883a 	mov	r3,r4
8110fc6c:	1009883a 	mov	r4,r2
8110fc70:	00801304 	movi	r2,76
8110fc74:	100d883a 	mov	r6,r2
8110fc78:	200b883a 	mov	r5,r4
8110fc7c:	1809883a 	mov	r4,r3
8110fc80:	111ba100 	call	8111ba10 <memcpy>
                bSuccess = TRUE;
8110fc84:	00800044 	movi	r2,1
8110fc88:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
8110fc8c:	e0fffe03 	ldbu	r3,-8(fp)
8110fc90:	00a045b4 	movhi	r2,33046
8110fc94:	10be1104 	addi	r2,r2,-1980
8110fc98:	18c01324 	muli	r3,r3,76
8110fc9c:	10c5883a 	add	r2,r2,r3
8110fca0:	10800104 	addi	r2,r2,4
8110fca4:	10000005 	stb	zero,0(r2)
                break;
8110fca8:	00000606 	br	8110fcc4 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8110fcac:	e0bffe03 	ldbu	r2,-8(fp)
8110fcb0:	10800044 	addi	r2,r2,1
8110fcb4:	e0bffe05 	stb	r2,-8(fp)
8110fcb8:	e0bffe03 	ldbu	r2,-8(fp)
8110fcbc:	10800230 	cmpltui	r2,r2,8
8110fcc0:	103fd81e 	bne	r2,zero,8110fc24 <__reset+0xfb0efc24>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
8110fcc4:	d0a06f17 	ldw	r2,-32324(gp)
8110fcc8:	1009883a 	mov	r4,r2
8110fccc:	1136fd40 	call	81136fd4 <OSMutexPost>
8110fcd0:	00000106 	br	8110fcd8 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
8110fcd4:	11166540 	call	81116654 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
8110fcd8:	e0bffd17 	ldw	r2,-12(fp)
}
8110fcdc:	e037883a 	mov	sp,fp
8110fce0:	dfc00117 	ldw	ra,4(sp)
8110fce4:	df000017 	ldw	fp,0(sp)
8110fce8:	dec00204 	addi	sp,sp,8
8110fcec:	f800283a 	ret

8110fcf0 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
8110fcf0:	defffa04 	addi	sp,sp,-24
8110fcf4:	de00012e 	bgeu	sp,et,8110fcfc <bSendMessagePUStoMebTask+0xc>
8110fcf8:	003b68fa 	trap	3
8110fcfc:	dfc00515 	stw	ra,20(sp)
8110fd00:	df000415 	stw	fp,16(sp)
8110fd04:	df000404 	addi	fp,sp,16
8110fd08:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110fd0c:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
8110fd10:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
8110fd14:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
8110fd18:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
8110fd1c:	d0a07617 	ldw	r2,-32296(gp)
8110fd20:	e0fffd44 	addi	r3,fp,-11
8110fd24:	180d883a 	mov	r6,r3
8110fd28:	01400284 	movi	r5,10
8110fd2c:	1009883a 	mov	r4,r2
8110fd30:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
8110fd34:	e0bffd43 	ldbu	r2,-11(fp)
8110fd38:	10803fcc 	andi	r2,r2,255
8110fd3c:	1000401e 	bne	r2,zero,8110fe40 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
8110fd40:	e03ffd05 	stb	zero,-12(fp)
8110fd44:	00003806 	br	8110fe28 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
8110fd48:	e0fffd03 	ldbu	r3,-12(fp)
8110fd4c:	00a04574 	movhi	r2,33045
8110fd50:	10bb8104 	addi	r2,r2,-4604
8110fd54:	18c01524 	muli	r3,r3,84
8110fd58:	10c5883a 	add	r2,r2,r3
8110fd5c:	10800104 	addi	r2,r2,4
8110fd60:	10800017 	ldw	r2,0(r2)
8110fd64:	10002d1e 	bne	r2,zero,8110fe1c <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
8110fd68:	e0fffd03 	ldbu	r3,-12(fp)
8110fd6c:	00a04574 	movhi	r2,33045
8110fd70:	10bb8104 	addi	r2,r2,-4604
8110fd74:	18c01524 	muli	r3,r3,84
8110fd78:	10c7883a 	add	r3,r2,r3
8110fd7c:	e0bfff17 	ldw	r2,-4(fp)
8110fd80:	1009883a 	mov	r4,r2
8110fd84:	00801504 	movi	r2,84
8110fd88:	100d883a 	mov	r6,r2
8110fd8c:	200b883a 	mov	r5,r4
8110fd90:	1809883a 	mov	r4,r3
8110fd94:	111ba100 	call	8111ba10 <memcpy>
            	xPus[i].bInUse = TRUE;
8110fd98:	e0fffd03 	ldbu	r3,-12(fp)
8110fd9c:	00a04574 	movhi	r2,33045
8110fda0:	10bb8104 	addi	r2,r2,-4604
8110fda4:	18c01524 	muli	r3,r3,84
8110fda8:	10c5883a 	add	r2,r2,r3
8110fdac:	10800104 	addi	r2,r2,4
8110fdb0:	00c00044 	movi	r3,1
8110fdb4:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
8110fdb8:	00800044 	movi	r2,1
8110fdbc:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
8110fdc0:	00800044 	movi	r2,1
8110fdc4:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
8110fdc8:	d0a06b17 	ldw	r2,-32340(gp)
8110fdcc:	e0fffe17 	ldw	r3,-8(fp)
8110fdd0:	180b883a 	mov	r5,r3
8110fdd4:	1009883a 	mov	r4,r2
8110fdd8:	1137f4c0 	call	81137f4c <OSQPost>
8110fddc:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
8110fde0:	e0bffd43 	ldbu	r2,-11(fp)
8110fde4:	10803fcc 	andi	r2,r2,255
8110fde8:	10000926 	beq	r2,zero,8110fe10 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
8110fdec:	11175440 	call	81117544 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
8110fdf0:	e0fffd03 	ldbu	r3,-12(fp)
8110fdf4:	00a04574 	movhi	r2,33045
8110fdf8:	10bb8104 	addi	r2,r2,-4604
8110fdfc:	18c01524 	muli	r3,r3,84
8110fe00:	10c5883a 	add	r2,r2,r3
8110fe04:	10800104 	addi	r2,r2,4
8110fe08:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
8110fe0c:	00000906 	br	8110fe34 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
8110fe10:	00800044 	movi	r2,1
8110fe14:	e0bffc15 	stw	r2,-16(fp)
                break;
8110fe18:	00000606 	br	8110fe34 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
8110fe1c:	e0bffd03 	ldbu	r2,-12(fp)
8110fe20:	10800044 	addi	r2,r2,1
8110fe24:	e0bffd05 	stb	r2,-12(fp)
8110fe28:	e0bffd03 	ldbu	r2,-12(fp)
8110fe2c:	10800130 	cmpltui	r2,r2,4
8110fe30:	103fc51e 	bne	r2,zero,8110fd48 <__reset+0xfb0efd48>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
8110fe34:	d0a07617 	ldw	r2,-32296(gp)
8110fe38:	1009883a 	mov	r4,r2
8110fe3c:	1136fd40 	call	81136fd4 <OSMutexPost>
    }

    return bSuccess;
8110fe40:	e0bffc17 	ldw	r2,-16(fp)
}
8110fe44:	e037883a 	mov	sp,fp
8110fe48:	dfc00117 	ldw	ra,4(sp)
8110fe4c:	df000017 	ldw	fp,0(sp)
8110fe50:	dec00204 	addi	sp,sp,8
8110fe54:	f800283a 	ret

8110fe58 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8110fe58:	deffab04 	addi	sp,sp,-340
8110fe5c:	de00012e 	bgeu	sp,et,8110fe64 <vReceiverUartTask+0xc>
8110fe60:	003b68fa 	trap	3
8110fe64:	dfc05415 	stw	ra,336(sp)
8110fe68:	df005315 	stw	fp,332(sp)
8110fe6c:	df005304 	addi	fp,sp,332
8110fe70:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110fe74:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
8110fe78:	d0a05f17 	ldw	r2,-32388(gp)
8110fe7c:	100f883a 	mov	r7,r2
8110fe80:	01800784 	movi	r6,30
8110fe84:	01400044 	movi	r5,1
8110fe88:	01204534 	movhi	r4,33044
8110fe8c:	211bd004 	addi	r4,r4,28480
8110fe90:	111affc0 	call	8111affc <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
8110fe94:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
8110fe98:	e0bfad17 	ldw	r2,-332(fp)
8110fe9c:	10c00060 	cmpeqi	r3,r2,1
8110fea0:	1800091e 	bne	r3,zero,8110fec8 <vReceiverUartTask+0x70>
8110fea4:	0080052e 	bgeu	zero,r2,8110febc <vReceiverUartTask+0x64>
8110fea8:	10c000a0 	cmpeqi	r3,r2,2
8110feac:	18005d1e 	bne	r3,zero,81110024 <vReceiverUartTask+0x1cc>
8110feb0:	108000e0 	cmpeqi	r2,r2,3
8110feb4:	10006e1e 	bne	r2,zero,81110070 <vReceiverUartTask+0x218>
8110feb8:	00007706 	br	81110098 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
8110febc:	00800044 	movi	r2,1
8110fec0:	e0bfad15 	stw	r2,-332(fp)
                break;
8110fec4:	00007706 	br	811100a4 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
8110fec8:	e0bfaf04 	addi	r2,fp,-324
8110fecc:	01802004 	movi	r6,128
8110fed0:	000b883a 	mov	r5,zero
8110fed4:	1009883a 	mov	r4,r2
8110fed8:	111bb600 	call	8111bb60 <memset>
                scanf("%s", cReceive);
8110fedc:	e0bfcf04 	addi	r2,fp,-196
8110fee0:	100b883a 	mov	r5,r2
8110fee4:	01204534 	movhi	r4,33044
8110fee8:	211bd804 	addi	r4,r4,28512
8110feec:	111c2140 	call	8111c214 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
8110fef0:	e0ffcf04 	addi	r3,fp,-196
8110fef4:	e0bfaf04 	addi	r2,fp,-324
8110fef8:	01801fc4 	movi	r6,127
8110fefc:	180b883a 	mov	r5,r3
8110ff00:	1009883a 	mov	r4,r2
8110ff04:	111ba100 	call	8111ba10 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
8110ff08:	e0bfaf04 	addi	r2,fp,-324
8110ff0c:	01604574 	movhi	r5,33045
8110ff10:	29716204 	addi	r5,r5,-14968
8110ff14:	1009883a 	mov	r4,r2
8110ff18:	11104fc0 	call	811104fc <bPreParserV2>
8110ff1c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
8110ff20:	e0bfae17 	ldw	r2,-328(fp)
8110ff24:	10800058 	cmpnei	r2,r2,1
8110ff28:	1000281e 	bne	r2,zero,8110ffcc <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
8110ff2c:	00a04574 	movhi	r2,33045
8110ff30:	10b16204 	addi	r2,r2,-14968
8110ff34:	10800103 	ldbu	r2,4(r2)
8110ff38:	10803fcc 	andi	r2,r2,255
8110ff3c:	1080201c 	xori	r2,r2,128
8110ff40:	10bfe004 	addi	r2,r2,-128
8110ff44:	10800fe0 	cmpeqi	r2,r2,63
8110ff48:	1000081e 	bne	r2,zero,8110ff6c <vReceiverUartTask+0x114>
8110ff4c:	00a04574 	movhi	r2,33045
8110ff50:	10b16204 	addi	r2,r2,-14968
8110ff54:	10800103 	ldbu	r2,4(r2)
8110ff58:	10803fcc 	andi	r2,r2,255
8110ff5c:	1080201c 	xori	r2,r2,128
8110ff60:	10bfe004 	addi	r2,r2,-128
8110ff64:	10800858 	cmpnei	r2,r2,33
8110ff68:	1000031e 	bne	r2,zero,8110ff78 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
8110ff6c:	00800084 	movi	r2,2
8110ff70:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110ff74:	00004b06 	br	811100a4 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
8110ff78:	00a04574 	movhi	r2,33045
8110ff7c:	10b16204 	addi	r2,r2,-14968
8110ff80:	10800103 	ldbu	r2,4(r2)
8110ff84:	10803fcc 	andi	r2,r2,255
8110ff88:	1080201c 	xori	r2,r2,128
8110ff8c:	10bfe004 	addi	r2,r2,-128
8110ff90:	108008d8 	cmpnei	r2,r2,35
8110ff94:	10000a1e 	bne	r2,zero,8110ffc0 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
8110ff98:	00800044 	movi	r2,1
8110ff9c:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
8110ffa0:	d0a05f17 	ldw	r2,-32388(gp)
8110ffa4:	100f883a 	mov	r7,r2
8110ffa8:	018006c4 	movi	r6,27
8110ffac:	01400044 	movi	r5,1
8110ffb0:	01204534 	movhi	r4,33044
8110ffb4:	211bd904 	addi	r4,r4,28516
8110ffb8:	111affc0 	call	8111affc <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110ffbc:	00003906 	br	811100a4 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
8110ffc0:	008000c4 	movi	r2,3
8110ffc4:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8110ffc8:	00003606 	br	811100a4 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
8110ffcc:	00a04574 	movhi	r2,33045
8110ffd0:	10b16204 	addi	r2,r2,-14968
8110ffd4:	00c008c4 	movi	r3,35
8110ffd8:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
8110ffdc:	00a04574 	movhi	r2,33045
8110ffe0:	10b16204 	addi	r2,r2,-14968
8110ffe4:	00c00b84 	movi	r3,46
8110ffe8:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
8110ffec:	00a04574 	movhi	r2,33045
8110fff0:	10b16204 	addi	r2,r2,-14968
8110fff4:	00c00044 	movi	r3,1
8110fff8:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
8110fffc:	01204574 	movhi	r4,33045
81110000:	21316204 	addi	r4,r4,-14968
81110004:	11101e40 	call	811101e4 <setPreAckSenderFreePos>
81110008:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
8111000c:	e0bfae17 	ldw	r2,-328(fp)
81110010:	1000011e 	bne	r2,zero,81110018 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81110014:	111678c0 	call	8111678c <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81110018:	00800044 	movi	r2,1
8111001c:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81110020:	00002006 	br	811100a4 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81110024:	01204574 	movhi	r4,33045
81110028:	21316204 	addi	r4,r4,-14968
8111002c:	11101e40 	call	811101e4 <setPreAckSenderFreePos>
81110030:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81110034:	e0bfae17 	ldw	r2,-328(fp)
81110038:	10800058 	cmpnei	r2,r2,1
8111003c:	1000081e 	bne	r2,zero,81110060 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81110040:	01204574 	movhi	r4,33045
81110044:	21316204 	addi	r4,r4,-14968
81110048:	11100a80 	call	811100a8 <setPreParsedFreePos>
8111004c:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81110050:	e0bfae17 	ldw	r2,-328(fp)
81110054:	1000031e 	bne	r2,zero,81110064 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81110058:	111685c0 	call	8111685c <vFailSetPreParsedBuffer>
8111005c:	00000106 	br	81110064 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81110060:	11167f40 	call	811167f4 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81110064:	00800044 	movi	r2,1
81110068:	e0bfad15 	stw	r2,-332(fp)
                break;
8111006c:	00000d06 	br	811100a4 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81110070:	01204574 	movhi	r4,33045
81110074:	21316204 	addi	r4,r4,-14968
81110078:	11103600 	call	81110360 <setPreAckReceiverFreePos>
8111007c:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81110080:	e0bfae17 	ldw	r2,-328(fp)
81110084:	1000011e 	bne	r2,zero,8111008c <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81110088:	11168c40 	call	811168c4 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
8111008c:	00800044 	movi	r2,1
81110090:	e0bfad15 	stw	r2,-332(fp)
                break;
81110094:	00000306 	br	811100a4 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81110098:	00800044 	movi	r2,1
8111009c:	e0bfad15 	stw	r2,-332(fp)
                break;
811100a0:	0001883a 	nop
        }

    }
811100a4:	003f7c06 	br	8110fe98 <__reset+0xfb0efe98>

811100a8 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
811100a8:	defffb04 	addi	sp,sp,-20
811100ac:	de00012e 	bgeu	sp,et,811100b4 <setPreParsedFreePos+0xc>
811100b0:	003b68fa 	trap	3
811100b4:	dfc00415 	stw	ra,16(sp)
811100b8:	df000315 	stw	fp,12(sp)
811100bc:	df000304 	addi	fp,sp,12
811100c0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811100c4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811100c8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811100cc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811100d0:	d0a06f17 	ldw	r2,-32324(gp)
811100d4:	e0fffe44 	addi	r3,fp,-7
811100d8:	180d883a 	mov	r6,r3
811100dc:	01400284 	movi	r5,10
811100e0:	1009883a 	mov	r4,r2
811100e4:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811100e8:	e0bffe43 	ldbu	r2,-7(fp)
811100ec:	10803fcc 	andi	r2,r2,255
811100f0:	1000361e 	bne	r2,zero,811101cc <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
811100f4:	e03ffe05 	stb	zero,-8(fp)
811100f8:	00002e06 	br	811101b4 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
811100fc:	e0fffe03 	ldbu	r3,-8(fp)
81110100:	00a045b4 	movhi	r2,33046
81110104:	10be1104 	addi	r2,r2,-1980
81110108:	18c01324 	muli	r3,r3,76
8111010c:	10c5883a 	add	r2,r2,r3
81110110:	10800104 	addi	r2,r2,4
81110114:	10800003 	ldbu	r2,0(r2)
81110118:	10803fcc 	andi	r2,r2,255
8111011c:	1080201c 	xori	r2,r2,128
81110120:	10bfe004 	addi	r2,r2,-128
81110124:	1000201e 	bne	r2,zero,811101a8 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81110128:	e0fffe03 	ldbu	r3,-8(fp)
8111012c:	00a045b4 	movhi	r2,33046
81110130:	10be1104 	addi	r2,r2,-1980
81110134:	18c01324 	muli	r3,r3,76
81110138:	10c7883a 	add	r3,r2,r3
8111013c:	e0bfff17 	ldw	r2,-4(fp)
81110140:	1009883a 	mov	r4,r2
81110144:	00801304 	movi	r2,76
81110148:	100d883a 	mov	r6,r2
8111014c:	200b883a 	mov	r5,r4
81110150:	1809883a 	mov	r4,r3
81110154:	111ba100 	call	8111ba10 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81110158:	d0a06117 	ldw	r2,-32380(gp)
8111015c:	1009883a 	mov	r4,r2
81110160:	1138dc40 	call	81138dc4 <OSSemPost>
81110164:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81110168:	e0bffe43 	ldbu	r2,-7(fp)
8111016c:	10803fcc 	andi	r2,r2,255
81110170:	1000031e 	bne	r2,zero,81110180 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81110174:	00800044 	movi	r2,1
81110178:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
8111017c:	00001006 	br	811101c0 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81110180:	1115eac0 	call	81115eac <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81110184:	e0fffe03 	ldbu	r3,-8(fp)
81110188:	00a045b4 	movhi	r2,33046
8111018c:	10be1104 	addi	r2,r2,-1980
81110190:	18c01324 	muli	r3,r3,76
81110194:	10c5883a 	add	r2,r2,r3
81110198:	10800104 	addi	r2,r2,4
8111019c:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
811101a0:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
811101a4:	00000606 	br	811101c0 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
811101a8:	e0bffe03 	ldbu	r2,-8(fp)
811101ac:	10800044 	addi	r2,r2,1
811101b0:	e0bffe05 	stb	r2,-8(fp)
811101b4:	e0bffe03 	ldbu	r2,-8(fp)
811101b8:	10800230 	cmpltui	r2,r2,8
811101bc:	103fcf1e 	bne	r2,zero,811100fc <__reset+0xfb0f00fc>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
811101c0:	d0a06f17 	ldw	r2,-32324(gp)
811101c4:	1009883a 	mov	r4,r2
811101c8:	1136fd40 	call	81136fd4 <OSMutexPost>
    }
    return bSuccess;
811101cc:	e0bffd17 	ldw	r2,-12(fp)
}
811101d0:	e037883a 	mov	sp,fp
811101d4:	dfc00117 	ldw	ra,4(sp)
811101d8:	df000017 	ldw	fp,0(sp)
811101dc:	dec00204 	addi	sp,sp,8
811101e0:	f800283a 	ret

811101e4 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
811101e4:	defffb04 	addi	sp,sp,-20
811101e8:	de00012e 	bgeu	sp,et,811101f0 <setPreAckSenderFreePos+0xc>
811101ec:	003b68fa 	trap	3
811101f0:	dfc00415 	stw	ra,16(sp)
811101f4:	df000315 	stw	fp,12(sp)
811101f8:	df000304 	addi	fp,sp,12
811101fc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110200:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110204:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110208:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
8111020c:	d0a07517 	ldw	r2,-32300(gp)
81110210:	e0fffe44 	addi	r3,fp,-7
81110214:	180d883a 	mov	r6,r3
81110218:	01400284 	movi	r5,10
8111021c:	1009883a 	mov	r4,r2
81110220:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110224:	e0bffe43 	ldbu	r2,-7(fp)
81110228:	10803fcc 	andi	r2,r2,255
8111022c:	1000461e 	bne	r2,zero,81110348 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81110230:	e03ffe05 	stb	zero,-8(fp)
81110234:	00003e06 	br	81110330 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81110238:	e0fffe03 	ldbu	r3,-8(fp)
8111023c:	00a045b4 	movhi	r2,33046
81110240:	10be0904 	addi	r2,r2,-2012
81110244:	18c7883a 	add	r3,r3,r3
81110248:	18c7883a 	add	r3,r3,r3
8111024c:	10c5883a 	add	r2,r2,r3
81110250:	10800003 	ldbu	r2,0(r2)
81110254:	10803fcc 	andi	r2,r2,255
81110258:	1080201c 	xori	r2,r2,128
8111025c:	10bfe004 	addi	r2,r2,-128
81110260:	1000301e 	bne	r2,zero,81110324 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81110264:	e0fffe03 	ldbu	r3,-8(fp)
81110268:	e0bfff17 	ldw	r2,-4(fp)
8111026c:	11000103 	ldbu	r4,4(r2)
81110270:	00a045b4 	movhi	r2,33046
81110274:	10be0904 	addi	r2,r2,-2012
81110278:	18c7883a 	add	r3,r3,r3
8111027c:	18c7883a 	add	r3,r3,r3
81110280:	10c5883a 	add	r2,r2,r3
81110284:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81110288:	e0fffe03 	ldbu	r3,-8(fp)
8111028c:	e0bfff17 	ldw	r2,-4(fp)
81110290:	11000143 	ldbu	r4,5(r2)
81110294:	00a045b4 	movhi	r2,33046
81110298:	10be0904 	addi	r2,r2,-2012
8111029c:	18c7883a 	add	r3,r3,r3
811102a0:	18c7883a 	add	r3,r3,r3
811102a4:	10c5883a 	add	r2,r2,r3
811102a8:	10800044 	addi	r2,r2,1
811102ac:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
811102b0:	e0fffe03 	ldbu	r3,-8(fp)
811102b4:	e0bfff17 	ldw	r2,-4(fp)
811102b8:	1100020b 	ldhu	r4,8(r2)
811102bc:	00a045b4 	movhi	r2,33046
811102c0:	10be0904 	addi	r2,r2,-2012
811102c4:	18c7883a 	add	r3,r3,r3
811102c8:	18c7883a 	add	r3,r3,r3
811102cc:	10c5883a 	add	r2,r2,r3
811102d0:	10800084 	addi	r2,r2,2
811102d4:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
811102d8:	d0a05e17 	ldw	r2,-32392(gp)
811102dc:	1009883a 	mov	r4,r2
811102e0:	1138dc40 	call	81138dc4 <OSSemPost>
811102e4:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
811102e8:	e0bffe43 	ldbu	r2,-7(fp)
811102ec:	10803fcc 	andi	r2,r2,255
811102f0:	10000926 	beq	r2,zero,81110318 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
811102f4:	1115f440 	call	81115f44 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
811102f8:	e0fffe03 	ldbu	r3,-8(fp)
811102fc:	00a045b4 	movhi	r2,33046
81110300:	10be0904 	addi	r2,r2,-2012
81110304:	18c7883a 	add	r3,r3,r3
81110308:	18c7883a 	add	r3,r3,r3
8111030c:	10c5883a 	add	r2,r2,r3
81110310:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81110314:	00000906 	br	8111033c <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81110318:	00800044 	movi	r2,1
8111031c:	e0bffd15 	stw	r2,-12(fp)
                break;
81110320:	00000606 	br	8111033c <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81110324:	e0bffe03 	ldbu	r2,-8(fp)
81110328:	10800044 	addi	r2,r2,1
8111032c:	e0bffe05 	stb	r2,-8(fp)
81110330:	e0bffe03 	ldbu	r2,-8(fp)
81110334:	10800230 	cmpltui	r2,r2,8
81110338:	103fbf1e 	bne	r2,zero,81110238 <__reset+0xfb0f0238>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8111033c:	d0a07517 	ldw	r2,-32300(gp)
81110340:	1009883a 	mov	r4,r2
81110344:	1136fd40 	call	81136fd4 <OSMutexPost>
    }

    return bSuccess;
81110348:	e0bffd17 	ldw	r2,-12(fp)
}
8111034c:	e037883a 	mov	sp,fp
81110350:	dfc00117 	ldw	ra,4(sp)
81110354:	df000017 	ldw	fp,0(sp)
81110358:	dec00204 	addi	sp,sp,8
8111035c:	f800283a 	ret

81110360 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81110360:	defffb04 	addi	sp,sp,-20
81110364:	de00012e 	bgeu	sp,et,8111036c <setPreAckReceiverFreePos+0xc>
81110368:	003b68fa 	trap	3
8111036c:	dfc00415 	stw	ra,16(sp)
81110370:	df000315 	stw	fp,12(sp)
81110374:	df000304 	addi	fp,sp,12
81110378:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8111037c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110380:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110384:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81110388:	d0a06217 	ldw	r2,-32376(gp)
8111038c:	e0fffe44 	addi	r3,fp,-7
81110390:	180d883a 	mov	r6,r3
81110394:	01400504 	movi	r5,20
81110398:	1009883a 	mov	r4,r2
8111039c:	1136a300 	call	81136a30 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811103a0:	e0bffe43 	ldbu	r2,-7(fp)
811103a4:	10803fcc 	andi	r2,r2,255
811103a8:	1000471e 	bne	r2,zero,811104c8 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
811103ac:	e03ffe05 	stb	zero,-8(fp)
811103b0:	00003e06 	br	811104ac <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
811103b4:	e0fffe03 	ldbu	r3,-8(fp)
811103b8:	00a045b4 	movhi	r2,33046
811103bc:	10a7ff04 	addi	r2,r2,-24580
811103c0:	18c7883a 	add	r3,r3,r3
811103c4:	18c7883a 	add	r3,r3,r3
811103c8:	10c5883a 	add	r2,r2,r3
811103cc:	10800003 	ldbu	r2,0(r2)
811103d0:	10803fcc 	andi	r2,r2,255
811103d4:	1080201c 	xori	r2,r2,128
811103d8:	10bfe004 	addi	r2,r2,-128
811103dc:	1000301e 	bne	r2,zero,811104a0 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
811103e0:	e0fffe03 	ldbu	r3,-8(fp)
811103e4:	e0bfff17 	ldw	r2,-4(fp)
811103e8:	11000103 	ldbu	r4,4(r2)
811103ec:	00a045b4 	movhi	r2,33046
811103f0:	10a7ff04 	addi	r2,r2,-24580
811103f4:	18c7883a 	add	r3,r3,r3
811103f8:	18c7883a 	add	r3,r3,r3
811103fc:	10c5883a 	add	r2,r2,r3
81110400:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81110404:	e0fffe03 	ldbu	r3,-8(fp)
81110408:	e0bfff17 	ldw	r2,-4(fp)
8111040c:	11000143 	ldbu	r4,5(r2)
81110410:	00a045b4 	movhi	r2,33046
81110414:	10a7ff04 	addi	r2,r2,-24580
81110418:	18c7883a 	add	r3,r3,r3
8111041c:	18c7883a 	add	r3,r3,r3
81110420:	10c5883a 	add	r2,r2,r3
81110424:	10800044 	addi	r2,r2,1
81110428:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8111042c:	e0fffe03 	ldbu	r3,-8(fp)
81110430:	e0bfff17 	ldw	r2,-4(fp)
81110434:	1100020b 	ldhu	r4,8(r2)
81110438:	00a045b4 	movhi	r2,33046
8111043c:	10a7ff04 	addi	r2,r2,-24580
81110440:	18c7883a 	add	r3,r3,r3
81110444:	18c7883a 	add	r3,r3,r3
81110448:	10c5883a 	add	r2,r2,r3
8111044c:	10800084 	addi	r2,r2,2
81110450:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81110454:	d0a06317 	ldw	r2,-32372(gp)
81110458:	1009883a 	mov	r4,r2
8111045c:	1138dc40 	call	81138dc4 <OSSemPost>
81110460:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81110464:	e0bffe43 	ldbu	r2,-7(fp)
81110468:	10803fcc 	andi	r2,r2,255
8111046c:	1000031e 	bne	r2,zero,8111047c <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81110470:	00800044 	movi	r2,1
81110474:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81110478:	00000f06 	br	811104b8 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
8111047c:	1115ef80 	call	81115ef8 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81110480:	e0fffe03 	ldbu	r3,-8(fp)
81110484:	00a045b4 	movhi	r2,33046
81110488:	10a7ff04 	addi	r2,r2,-24580
8111048c:	18c7883a 	add	r3,r3,r3
81110490:	18c7883a 	add	r3,r3,r3
81110494:	10c5883a 	add	r2,r2,r3
81110498:	10000005 	stb	zero,0(r2)
                }
                break;
8111049c:	00000606 	br	811104b8 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
811104a0:	e0bffe03 	ldbu	r2,-8(fp)
811104a4:	10800044 	addi	r2,r2,1
811104a8:	e0bffe05 	stb	r2,-8(fp)
811104ac:	e0bffe03 	ldbu	r2,-8(fp)
811104b0:	108001b0 	cmpltui	r2,r2,6
811104b4:	103fbf1e 	bne	r2,zero,811103b4 <__reset+0xfb0f03b4>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
811104b8:	d0a06217 	ldw	r2,-32376(gp)
811104bc:	1009883a 	mov	r4,r2
811104c0:	1136fd40 	call	81136fd4 <OSMutexPost>
811104c4:	00000706 	br	811104e4 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
811104c8:	d0a05f17 	ldw	r2,-32388(gp)
811104cc:	100f883a 	mov	r7,r2
811104d0:	01801404 	movi	r6,80
811104d4:	01400044 	movi	r5,1
811104d8:	01204534 	movhi	r4,33044
811104dc:	211be004 	addi	r4,r4,28544
811104e0:	111affc0 	call	8111affc <fwrite>
        #endif
    }

    return bSuccess;
811104e4:	e0bffd17 	ldw	r2,-12(fp)
}
811104e8:	e037883a 	mov	sp,fp
811104ec:	dfc00117 	ldw	ra,4(sp)
811104f0:	df000017 	ldw	fp,0(sp)
811104f4:	dec00204 	addi	sp,sp,8
811104f8:	f800283a 	ret

811104fc <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
811104fc:	defff404 	addi	sp,sp,-48
81110500:	de00012e 	bgeu	sp,et,81110508 <bPreParserV2+0xc>
81110504:	003b68fa 	trap	3
81110508:	dfc00b15 	stw	ra,44(sp)
8111050c:	df000a15 	stw	fp,40(sp)
81110510:	dc000915 	stw	r16,36(sp)
81110514:	df000a04 	addi	fp,sp,40
81110518:	e13ffd15 	stw	r4,-12(fp)
8111051c:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81110520:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81110524:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81110528:	01402004 	movi	r5,128
8111052c:	e13ffd17 	ldw	r4,-12(fp)
81110530:	111c59c0 	call	8111c59c <strnlen>
81110534:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81110538:	01400ec4 	movi	r5,59
8111053c:	e13ffd17 	ldw	r4,-12(fp)
81110540:	11149880 	call	81114988 <siPosStr>
81110544:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81110548:	e0fff98f 	ldh	r3,-26(fp)
8111054c:	e0bff90f 	ldh	r2,-28(fp)
81110550:	10bfffc4 	addi	r2,r2,-1
81110554:	18800226 	beq	r3,r2,81110560 <bPreParserV2+0x64>
        return bSuccess;
81110558:	e0bff617 	ldw	r2,-40(fp)
8111055c:	0000ba06 	br	81110848 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81110560:	01401f04 	movi	r5,124
81110564:	e13ffd17 	ldw	r4,-12(fp)
81110568:	11149880 	call	81114988 <siPosStr>
8111056c:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81110570:	e0bffa0f 	ldh	r2,-24(fp)
81110574:	e0fff98f 	ldh	r3,-26(fp)
81110578:	1880020e 	bge	r3,r2,81110584 <bPreParserV2+0x88>
        return bSuccess;
8111057c:	e0bff617 	ldw	r2,-40(fp)
81110580:	0000b106 	br	81110848 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81110584:	01604534 	movhi	r5,33044
81110588:	295bf504 	addi	r5,r5,28628
8111058c:	e13ffd17 	ldw	r4,-12(fp)
81110590:	111c4b80 	call	8111c4b8 <strcspn>
81110594:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81110598:	e0bffa8f 	ldh	r2,-22(fp)
8111059c:	e0fffa0f 	ldh	r3,-24(fp)
811105a0:	1880020e 	bge	r3,r2,811105ac <bPreParserV2+0xb0>
        return bSuccess;
811105a4:	e0bff617 	ldw	r2,-40(fp)
811105a8:	0000a706 	br	81110848 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
811105ac:	e0bffa8f 	ldh	r2,-22(fp)
811105b0:	e0fffd17 	ldw	r3,-12(fp)
811105b4:	1885883a 	add	r2,r3,r2
811105b8:	10c00003 	ldbu	r3,0(r2)
811105bc:	e0bffe17 	ldw	r2,-8(fp)
811105c0:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
811105c4:	e0bffe17 	ldw	r2,-8(fp)
811105c8:	10800103 	ldbu	r2,4(r2)
811105cc:	10803fcc 	andi	r2,r2,255
811105d0:	1080201c 	xori	r2,r2,128
811105d4:	10bfe004 	addi	r2,r2,-128
811105d8:	108008d8 	cmpnei	r2,r2,35
811105dc:	1000041e 	bne	r2,zero,811105f0 <bPreParserV2+0xf4>
        bSuccess = TRUE;
811105e0:	00800044 	movi	r2,1
811105e4:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
811105e8:	e0bff617 	ldw	r2,-40(fp)
811105ec:	00009606 	br	81110848 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
811105f0:	e0bffa8f 	ldh	r2,-22(fp)
811105f4:	e0fffd17 	ldw	r3,-12(fp)
811105f8:	1889883a 	add	r4,r3,r2
811105fc:	e0fffa0f 	ldh	r3,-24(fp)
81110600:	e0bffa8f 	ldh	r2,-22(fp)
81110604:	1885c83a 	sub	r2,r3,r2
81110608:	100b883a 	mov	r5,r2
8111060c:	1115ba80 	call	81115ba8 <ucCrc8wInit>
81110610:	1007883a 	mov	r3,r2
81110614:	e0bffe17 	ldw	r2,-8(fp)
81110618:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
8111061c:	e0bffa8f 	ldh	r2,-22(fp)
81110620:	10800044 	addi	r2,r2,1
81110624:	e0fffd17 	ldw	r3,-12(fp)
81110628:	1885883a 	add	r2,r3,r2
8111062c:	10c00003 	ldbu	r3,0(r2)
81110630:	e0bffe17 	ldw	r2,-8(fp)
81110634:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81110638:	e0bffe17 	ldw	r2,-8(fp)
8111063c:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81110640:	e0bffe17 	ldw	r2,-8(fp)
81110644:	10800204 	addi	r2,r2,8
81110648:	01801004 	movi	r6,64
8111064c:	000b883a 	mov	r5,zero
81110650:	1009883a 	mov	r4,r2
81110654:	111bb600 	call	8111bb60 <memset>

    i = siIni + 3; /* "?C:i..." */
81110658:	e0bffa8b 	ldhu	r2,-22(fp)
8111065c:	108000c4 	addi	r2,r2,3
81110660:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81110664:	e0bffb44 	addi	r2,fp,-19
81110668:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
8111066c:	e0bffb44 	addi	r2,fp,-19
81110670:	01800184 	movi	r6,6
81110674:	000b883a 	mov	r5,zero
81110678:	1009883a 	mov	r4,r2
8111067c:	111bb600 	call	8111bb60 <memset>
        do {
            c = buffer[i];
81110680:	e0bff703 	ldbu	r2,-36(fp)
81110684:	e0fffd17 	ldw	r3,-12(fp)
81110688:	1885883a 	add	r2,r3,r2
8111068c:	10800003 	ldbu	r2,0(r2)
81110690:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81110694:	d0e00317 	ldw	r3,-32756(gp)
81110698:	e0bffb07 	ldb	r2,-20(fp)
8111069c:	10800044 	addi	r2,r2,1
811106a0:	1885883a 	add	r2,r3,r2
811106a4:	10800003 	ldbu	r2,0(r2)
811106a8:	10803fcc 	andi	r2,r2,255
811106ac:	1080010c 	andi	r2,r2,4
811106b0:	10000626 	beq	r2,zero,811106cc <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
811106b4:	e0bff817 	ldw	r2,-32(fp)
811106b8:	e0fffb03 	ldbu	r3,-20(fp)
811106bc:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
811106c0:	e0bff817 	ldw	r2,-32(fp)
811106c4:	10800044 	addi	r2,r2,1
811106c8:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
811106cc:	e0bff703 	ldbu	r2,-36(fp)
811106d0:	10800044 	addi	r2,r2,1
811106d4:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
811106d8:	e0bff90f 	ldh	r2,-28(fp)
811106dc:	e0fff703 	ldbu	r3,-36(fp)
811106e0:	1880090e 	bge	r3,r2,81110708 <bPreParserV2+0x20c>
811106e4:	e0bffb07 	ldb	r2,-20(fp)
811106e8:	10800ea0 	cmpeqi	r2,r2,58
811106ec:	1000061e 	bne	r2,zero,81110708 <bPreParserV2+0x20c>
811106f0:	e0bffb07 	ldb	r2,-20(fp)
811106f4:	10800ee0 	cmpeqi	r2,r2,59
811106f8:	1000031e 	bne	r2,zero,81110708 <bPreParserV2+0x20c>
811106fc:	e0bffb07 	ldb	r2,-20(fp)
81110700:	10801f18 	cmpnei	r2,r2,124
81110704:	103fde1e 	bne	r2,zero,81110680 <__reset+0xfb0f0680>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81110708:	e0bff817 	ldw	r2,-32(fp)
8111070c:	00c00284 	movi	r3,10
81110710:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81110714:	e0bffb07 	ldb	r2,-20(fp)
81110718:	10800ea0 	cmpeqi	r2,r2,58
8111071c:	1000031e 	bne	r2,zero,8111072c <bPreParserV2+0x230>
81110720:	e0bffb07 	ldb	r2,-20(fp)
81110724:	10801f18 	cmpnei	r2,r2,124
81110728:	10001a1e 	bne	r2,zero,81110794 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8111072c:	e0bffe17 	ldw	r2,-8(fp)
81110730:	10800183 	ldbu	r2,6(r2)
81110734:	10803fcc 	andi	r2,r2,255
81110738:	10800828 	cmpgeui	r2,r2,32
8111073c:	1000041e 	bne	r2,zero,81110750 <bPreParserV2+0x254>
81110740:	e0bffe17 	ldw	r2,-8(fp)
81110744:	10800183 	ldbu	r2,6(r2)
81110748:	14003fcc 	andi	r16,r2,255
8111074c:	00000106 	br	81110754 <bPreParserV2+0x258>
81110750:	04000804 	movi	r16,32
81110754:	e0bffb44 	addi	r2,fp,-19
81110758:	1009883a 	mov	r4,r2
8111075c:	111a8040 	call	8111a804 <atoi>
81110760:	1009883a 	mov	r4,r2
81110764:	e0fffe17 	ldw	r3,-8(fp)
81110768:	80800104 	addi	r2,r16,4
8111076c:	1085883a 	add	r2,r2,r2
81110770:	1885883a 	add	r2,r3,r2
81110774:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
81110778:	e0bffe17 	ldw	r2,-8(fp)
8111077c:	10800183 	ldbu	r2,6(r2)
81110780:	10800044 	addi	r2,r2,1
81110784:	1007883a 	mov	r3,r2
81110788:	e0bffe17 	ldw	r2,-8(fp)
8111078c:	10c00185 	stb	r3,6(r2)
81110790:	00000906 	br	811107b8 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81110794:	e0bffb07 	ldb	r2,-20(fp)
81110798:	10800ed8 	cmpnei	r2,r2,59
8111079c:	1000061e 	bne	r2,zero,811107b8 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
811107a0:	e0bffb44 	addi	r2,fp,-19
811107a4:	1009883a 	mov	r4,r2
811107a8:	111a8040 	call	8111a804 <atoi>
811107ac:	1007883a 	mov	r3,r2
811107b0:	e0bffe17 	ldw	r2,-8(fp)
811107b4:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
811107b8:	e0bffb07 	ldb	r2,-20(fp)
811107bc:	10800ee0 	cmpeqi	r2,r2,59
811107c0:	1000031e 	bne	r2,zero,811107d0 <bPreParserV2+0x2d4>
811107c4:	e0bff90f 	ldh	r2,-28(fp)
811107c8:	e0fff703 	ldbu	r3,-36(fp)
811107cc:	18bfa516 	blt	r3,r2,81110664 <__reset+0xfb0f0664>


    if ( c == FINAL_CHAR )
811107d0:	e0bffb07 	ldb	r2,-20(fp)
811107d4:	10800ed8 	cmpnei	r2,r2,59
811107d8:	1000191e 	bne	r2,zero,81110840 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
811107dc:	e0bffe17 	ldw	r2,-8(fp)
811107e0:	10c01243 	ldbu	r3,73(r2)
811107e4:	e0bffe17 	ldw	r2,-8(fp)
811107e8:	10801203 	ldbu	r2,72(r2)
811107ec:	18c03fcc 	andi	r3,r3,255
811107f0:	10803fcc 	andi	r2,r2,255
811107f4:	1880031e 	bne	r3,r2,81110804 <bPreParserV2+0x308>
            bSuccess = TRUE;
811107f8:	00800044 	movi	r2,1
811107fc:	e0bff615 	stw	r2,-40(fp)
81110800:	00001006 	br	81110844 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81110804:	d0e05f17 	ldw	r3,-32388(gp)
81110808:	e0bffe17 	ldw	r2,-8(fp)
8111080c:	10801203 	ldbu	r2,72(r2)
81110810:	11003fcc 	andi	r4,r2,255
81110814:	e0bffe17 	ldw	r2,-8(fp)
81110818:	10801243 	ldbu	r2,73(r2)
8111081c:	10803fcc 	andi	r2,r2,255
81110820:	100f883a 	mov	r7,r2
81110824:	200d883a 	mov	r6,r4
81110828:	01604534 	movhi	r5,33044
8111082c:	295bf704 	addi	r5,r5,28636
81110830:	1809883a 	mov	r4,r3
81110834:	111a9600 	call	8111a960 <fprintf>
            #endif
            bSuccess = FALSE;
81110838:	e03ff615 	stw	zero,-40(fp)
8111083c:	00000106 	br	81110844 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81110840:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81110844:	e0bff617 	ldw	r2,-40(fp)
}
81110848:	e6ffff04 	addi	sp,fp,-4
8111084c:	dfc00217 	ldw	ra,8(sp)
81110850:	df000117 	ldw	fp,4(sp)
81110854:	dc000017 	ldw	r16,0(sp)
81110858:	dec00304 	addi	sp,sp,12
8111085c:	f800283a 	ret

81110860 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81110860:	defffb04 	addi	sp,sp,-20
81110864:	de00012e 	bgeu	sp,et,8111086c <vSenderComTask+0xc>
81110868:	003b68fa 	trap	3
8111086c:	dfc00415 	stw	ra,16(sp)
81110870:	df000315 	stw	fp,12(sp)
81110874:	df000304 	addi	fp,sp,12
81110878:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
8111087c:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81110880:	d0a05f17 	ldw	r2,-32388(gp)
81110884:	100f883a 	mov	r7,r2
81110888:	01800704 	movi	r6,28
8111088c:	01400044 	movi	r5,1
81110890:	01204534 	movhi	r4,33044
81110894:	211c0304 	addi	r4,r4,28684
81110898:	111affc0 	call	8111affc <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
8111089c:	e0bffd17 	ldw	r2,-12(fp)
811108a0:	10c00060 	cmpeqi	r3,r2,1
811108a4:	1800091e 	bne	r3,zero,811108cc <vSenderComTask+0x6c>
811108a8:	0080052e 	bgeu	zero,r2,811108c0 <vSenderComTask+0x60>
811108ac:	10c000a0 	cmpeqi	r3,r2,2
811108b0:	1800471e 	bne	r3,zero,811109d0 <vSenderComTask+0x170>
811108b4:	10800160 	cmpeqi	r2,r2,5
811108b8:	10002c1e 	bne	r2,zero,8111096c <vSenderComTask+0x10c>
811108bc:	00003a06 	br	811109a8 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
811108c0:	00800044 	movi	r2,1
811108c4:	e0bffd15 	stw	r2,-12(fp)
                break;
811108c8:	00004206 	br	811109d4 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
811108cc:	d0a05f17 	ldw	r2,-32388(gp)
811108d0:	100f883a 	mov	r7,r2
811108d4:	01800784 	movi	r6,30
811108d8:	01400044 	movi	r5,1
811108dc:	01204534 	movhi	r4,33044
811108e0:	211c0b04 	addi	r4,r4,28716
811108e4:	111affc0 	call	8111affc <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
811108e8:	01400044 	movi	r5,1
811108ec:	01204534 	movhi	r4,33044
811108f0:	211c1304 	addi	r4,r4,28748
811108f4:	11140800 	call	81114080 <bSendUART32v2>
811108f8:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
811108fc:	e0bffe17 	ldw	r2,-8(fp)
81110900:	10800058 	cmpnei	r2,r2,1
81110904:	10000a1e 	bne	r2,zero,81110930 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81110908:	00800144 	movi	r2,5
8111090c:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81110910:	d0a05f17 	ldw	r2,-32388(gp)
81110914:	100f883a 	mov	r7,r2
81110918:	01800d44 	movi	r6,53
8111091c:	01400044 	movi	r5,1
81110920:	01204534 	movhi	r4,33044
81110924:	211c1604 	addi	r4,r4,28760
81110928:	111affc0 	call	8111affc <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
8111092c:	00002906 	br	811109d4 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81110930:	d0a05f17 	ldw	r2,-32388(gp)
81110934:	100f883a 	mov	r7,r2
81110938:	01800784 	movi	r6,30
8111093c:	01400044 	movi	r5,1
81110940:	01204534 	movhi	r4,33044
81110944:	211c2404 	addi	r4,r4,28816
81110948:	111affc0 	call	8111affc <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
8111094c:	00800044 	movi	r2,1
81110950:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81110954:	000f883a 	mov	r7,zero
81110958:	01800144 	movi	r6,5
8111095c:	000b883a 	mov	r5,zero
81110960:	0009883a 	mov	r4,zero
81110964:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
                }
                break;
81110968:	00001a06 	br	811109d4 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
8111096c:	00800144 	movi	r2,5
81110970:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"sDummySender\n");
81110974:	d0a05f17 	ldw	r2,-32388(gp)
81110978:	100f883a 	mov	r7,r2
8111097c:	01800344 	movi	r6,13
81110980:	01400044 	movi	r5,1
81110984:	01204534 	movhi	r4,33044
81110988:	211c2c04 	addi	r4,r4,28848
8111098c:	111affc0 	call	8111affc <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 10, 0); /*Sleeps for 3 second*/
81110990:	000f883a 	mov	r7,zero
81110994:	01800284 	movi	r6,10
81110998:	000b883a 	mov	r5,zero
8111099c:	0009883a 	mov	r4,zero
811109a0:	113a8200 	call	8113a820 <OSTimeDlyHMSM>

                break;
811109a4:	00000b06 	br	811109d4 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
811109a8:	d0a05f17 	ldw	r2,-32388(gp)
811109ac:	100f883a 	mov	r7,r2
811109b0:	018003c4 	movi	r6,15
811109b4:	01400044 	movi	r5,1
811109b8:	01204534 	movhi	r4,33044
811109bc:	211c3004 	addi	r4,r4,28864
811109c0:	111affc0 	call	8111affc <fwrite>
                #endif
                eSenderMode = sDummySender;
811109c4:	00800144 	movi	r2,5
811109c8:	e0bffd15 	stw	r2,-12(fp)
                break;
811109cc:	00000106 	br	811109d4 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
811109d0:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
811109d4:	003fb106 	br	8111089c <__reset+0xfb0f089c>

811109d8 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
811109d8:	defffa04 	addi	sp,sp,-24
811109dc:	de00012e 	bgeu	sp,et,811109e4 <vSimMebTask+0xc>
811109e0:	003b68fa 	trap	3
811109e4:	dfc00515 	stw	ra,20(sp)
811109e8:	df000415 	stw	fp,16(sp)
811109ec:	df000404 	addi	fp,sp,16
811109f0:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
811109f4:	e0bfff17 	ldw	r2,-4(fp)
811109f8:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
811109fc:	d0a05f17 	ldw	r2,-32388(gp)
81110a00:	100f883a 	mov	r7,r2
81110a04:	018008c4 	movi	r6,35
81110a08:	01400044 	movi	r5,1
81110a0c:	01204534 	movhi	r4,33044
81110a10:	211c3404 	addi	r4,r4,28880
81110a14:	111affc0 	call	8111affc <fwrite>
    #endif

	for (;;) {
		switch ( pxMebC->eMode )
81110a18:	e0bffc17 	ldw	r2,-16(fp)
81110a1c:	10800117 	ldw	r2,4(r2)
81110a20:	10000326 	beq	r2,zero,81110a30 <vSimMebTask+0x58>
81110a24:	10800060 	cmpeqi	r2,r2,1
81110a28:	1000231e 	bne	r2,zero,81110ab8 <vSimMebTask+0xe0>
81110a2c:	00004406 	br	81110b40 <vSimMebTask+0x168>
		{
			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81110a30:	d0a06b17 	ldw	r2,-32340(gp)
81110a34:	e0fffe04 	addi	r3,fp,-8
81110a38:	180d883a 	mov	r6,r3
81110a3c:	000b883a 	mov	r5,zero
81110a40:	1009883a 	mov	r4,r2
81110a44:	1137b440 	call	81137b44 <OSQPend>
81110a48:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81110a4c:	e0bffe03 	ldbu	r2,-8(fp)
81110a50:	10803fcc 	andi	r2,r2,255
81110a54:	1000151e 	bne	r2,zero,81110aac <vSimMebTask+0xd4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81110a58:	e0bffdc3 	ldbu	r2,-9(fp)
81110a5c:	10803fcc 	andi	r2,r2,255
81110a60:	10800058 	cmpnei	r2,r2,1
81110a64:	1000081e 	bne	r2,zero,81110a88 <vSimMebTask+0xb0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81110a68:	e0bffd83 	ldbu	r2,-10(fp)
81110a6c:	10803fcc 	andi	r2,r2,255
81110a70:	10800060 	cmpeqi	r2,r2,1
81110a74:	1000011e 	bne	r2,zero,81110a7c <vSimMebTask+0xa4>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskConfigMode( pxMebC );
								break;
							default:
								break;
81110a78:	00000e06 	br	81110ab4 <vSimMebTask+0xdc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskConfigMode( pxMebC );
81110a7c:	e13ffc17 	ldw	r4,-16(fp)
81110a80:	1110b6c0 	call	81110b6c <vPusMebInTaskConfigMode>
								break;
81110a84:	00000b06 	br	81110ab4 <vSimMebTask+0xdc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdMeb.ucByte[3]);
81110a88:	d0a05f17 	ldw	r2,-32388(gp)
81110a8c:	e0fffdc3 	ldbu	r3,-9(fp)
81110a90:	18c03fcc 	andi	r3,r3,255
81110a94:	180d883a 	mov	r6,r3
81110a98:	01604534 	movhi	r5,33044
81110a9c:	295c3d04 	addi	r5,r5,28916
81110aa0:	1009883a 	mov	r4,r2
81110aa4:	111a9600 	call	8111a960 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81110aa8:	00002f06 	br	81110b68 <vSimMebTask+0x190>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81110aac:	11175900 	call	81117590 <vCouldNotGetCmdQueueMeb>
				}

				break;
81110ab0:	00002d06 	br	81110b68 <vSimMebTask+0x190>
81110ab4:	00002c06 	br	81110b68 <vSimMebTask+0x190>
			case sRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81110ab8:	d0a06b17 	ldw	r2,-32340(gp)
81110abc:	e0fffe04 	addi	r3,fp,-8
81110ac0:	180d883a 	mov	r6,r3
81110ac4:	000b883a 	mov	r5,zero
81110ac8:	1009883a 	mov	r4,r2
81110acc:	1137b440 	call	81137b44 <OSQPend>
81110ad0:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81110ad4:	e0bffe03 	ldbu	r2,-8(fp)
81110ad8:	10803fcc 	andi	r2,r2,255
81110adc:	1000151e 	bne	r2,zero,81110b34 <vSimMebTask+0x15c>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81110ae0:	e0bffdc3 	ldbu	r2,-9(fp)
81110ae4:	10803fcc 	andi	r2,r2,255
81110ae8:	10800058 	cmpnei	r2,r2,1
81110aec:	1000081e 	bne	r2,zero,81110b10 <vSimMebTask+0x138>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81110af0:	e0bffd83 	ldbu	r2,-10(fp)
81110af4:	10803fcc 	andi	r2,r2,255
81110af8:	10800060 	cmpeqi	r2,r2,1
81110afc:	1000011e 	bne	r2,zero,81110b04 <vSimMebTask+0x12c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskRunningMode( pxMebC );
								break;
							default:
								break;
81110b00:	00000e06 	br	81110b3c <vSimMebTask+0x164>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebInTaskRunningMode( pxMebC );
81110b04:	e13ffc17 	ldw	r4,-16(fp)
81110b08:	11110e00 	call	811110e0 <vPusMebInTaskRunningMode>
								break;
81110b0c:	00000b06 	br	81110b3c <vSimMebTask+0x164>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored. Not Addressed to Meb. ADDR= %ui\n", uiCmdMeb.ucByte[3]);
81110b10:	d0a05f17 	ldw	r2,-32388(gp)
81110b14:	e0fffdc3 	ldbu	r3,-9(fp)
81110b18:	18c03fcc 	andi	r3,r3,255
81110b1c:	180d883a 	mov	r6,r3
81110b20:	01604534 	movhi	r5,33044
81110b24:	295c3d04 	addi	r5,r5,28916
81110b28:	1009883a 	mov	r4,r2
81110b2c:	111a9600 	call	8111a960 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			

				break;
81110b30:	00000d06 	br	81110b68 <vSimMebTask+0x190>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81110b34:	11175900 	call	81117590 <vCouldNotGetCmdQueueMeb>
				}			

				break;
81110b38:	00000b06 	br	81110b68 <vSimMebTask+0x190>
81110b3c:	00000a06 	br	81110b68 <vSimMebTask+0x190>
			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode.\n");
81110b40:	d0a05f17 	ldw	r2,-32388(gp)
81110b44:	100f883a 	mov	r7,r2
81110b48:	01800c04 	movi	r6,48
81110b4c:	01400044 	movi	r5,1
81110b50:	01204534 	movhi	r4,33044
81110b54:	211c4c04 	addi	r4,r4,28976
81110b58:	111affc0 	call	8111affc <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebConfig;
81110b5c:	e0bffc17 	ldw	r2,-16(fp)
81110b60:	10000115 	stw	zero,4(r2)
				break;
81110b64:	0001883a 	nop
		}
	}
81110b68:	003fab06 	br	81110a18 <__reset+0xfb0f0a18>

81110b6c <vPusMebInTaskConfigMode>:
}

/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal ) {
81110b6c:	defff904 	addi	sp,sp,-28
81110b70:	de00012e 	bgeu	sp,et,81110b78 <vPusMebInTaskConfigMode+0xc>
81110b74:	003b68fa 	trap	3
81110b78:	dfc00615 	stw	ra,24(sp)
81110b7c:	df000515 	stw	fp,20(sp)
81110b80:	df000504 	addi	fp,sp,20
81110b84:	e13fff15 	stw	r4,-4(fp)
	unsigned char i;
	unsigned short int usiFeeInstL;
	static tTMPus xPusLocal;
	bool bSuccess = FALSE;
81110b88:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;

	bSuccess = FALSE;
81110b8c:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 1, &error_code);
81110b90:	d0a07617 	ldw	r2,-32296(gp)
81110b94:	e0fffe84 	addi	r3,fp,-6
81110b98:	180d883a 	mov	r6,r3
81110b9c:	01400044 	movi	r5,1
81110ba0:	1009883a 	mov	r4,r2
81110ba4:	1136a300 	call	81136a30 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81110ba8:	e0bffe83 	ldbu	r2,-6(fp)
81110bac:	10803fcc 	andi	r2,r2,255
81110bb0:	10002c1e 	bne	r2,zero,81110c64 <vPusMebInTaskConfigMode+0xf8>

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
81110bb4:	e03ffc05 	stb	zero,-16(fp)
81110bb8:	00002306 	br	81110c48 <vPusMebInTaskConfigMode+0xdc>
	    {
            if ( xPus[i].bInUse == TRUE ) {
81110bbc:	e0fffc03 	ldbu	r3,-16(fp)
81110bc0:	00a04574 	movhi	r2,33045
81110bc4:	10bb8104 	addi	r2,r2,-4604
81110bc8:	18c01524 	muli	r3,r3,84
81110bcc:	10c5883a 	add	r2,r2,r3
81110bd0:	10800104 	addi	r2,r2,4
81110bd4:	10800017 	ldw	r2,0(r2)
81110bd8:	10800058 	cmpnei	r2,r2,1
81110bdc:	1000171e 	bne	r2,zero,81110c3c <vPusMebInTaskConfigMode+0xd0>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[i];
81110be0:	e13ffc03 	ldbu	r4,-16(fp)
81110be4:	00e04574 	movhi	r3,33045
81110be8:	18f17504 	addi	r3,r3,-14892
81110bec:	00a04574 	movhi	r2,33045
81110bf0:	10bb8104 	addi	r2,r2,-4604
81110bf4:	21001524 	muli	r4,r4,84
81110bf8:	1105883a 	add	r2,r2,r4
81110bfc:	1009883a 	mov	r4,r2
81110c00:	00801504 	movi	r2,84
81110c04:	100d883a 	mov	r6,r2
81110c08:	200b883a 	mov	r5,r4
81110c0c:	1809883a 	mov	r4,r3
81110c10:	111ba100 	call	8111ba10 <memcpy>
            	xPus[i].bInUse = FALSE;
81110c14:	e0fffc03 	ldbu	r3,-16(fp)
81110c18:	00a04574 	movhi	r2,33045
81110c1c:	10bb8104 	addi	r2,r2,-4604
81110c20:	18c01524 	muli	r3,r3,84
81110c24:	10c5883a 	add	r2,r2,r3
81110c28:	10800104 	addi	r2,r2,4
81110c2c:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81110c30:	00800044 	movi	r2,1
81110c34:	e0bffd15 	stw	r2,-12(fp)
                break;
81110c38:	00000606 	br	81110c54 <vPusMebInTaskConfigMode+0xe8>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 1, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
81110c3c:	e0bffc03 	ldbu	r2,-16(fp)
81110c40:	10800044 	addi	r2,r2,1
81110c44:	e0bffc05 	stb	r2,-16(fp)
81110c48:	e0bffc03 	ldbu	r2,-16(fp)
81110c4c:	10800130 	cmpltui	r2,r2,4
81110c50:	103fda1e 	bne	r2,zero,81110bbc <__reset+0xfb0f0bbc>
            	xPus[i].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81110c54:	d0a07617 	ldw	r2,-32296(gp)
81110c58:	1009883a 	mov	r4,r2
81110c5c:	1136fd40 	call	81136fd4 <OSMutexPost>
81110c60:	00000106 	br	81110c68 <vPusMebInTaskConfigMode+0xfc>
	} else {
		vCouldNotGetMutexMebPus();
81110c64:	11175f80 	call	811175f8 <vCouldNotGetMutexMebPus>
	}

	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {
81110c68:	e0bffd17 	ldw	r2,-12(fp)
81110c6c:	10800058 	cmpnei	r2,r2,1
81110c70:	1001151e 	bne	r2,zero,811110c8 <vPusMebInTaskConfigMode+0x55c>

		switch (xPusLocal.usiType) {
81110c74:	00a04574 	movhi	r2,33045
81110c78:	10b17504 	addi	r2,r2,-14892
81110c7c:	1080030b 	ldhu	r2,12(r2)
81110c80:	10bfffcc 	andi	r2,r2,65535
81110c84:	10c03ee0 	cmpeqi	r3,r2,251
81110c88:	18003e1e 	bne	r3,zero,81110d84 <vPusMebInTaskConfigMode+0x218>
81110c8c:	10c03f20 	cmpeqi	r3,r2,252
81110c90:	18007e1e 	bne	r3,zero,81110e8c <vPusMebInTaskConfigMode+0x320>
81110c94:	10803ea0 	cmpeqi	r2,r2,250
81110c98:	1000011e 	bne	r2,zero,81110ca0 <vPusMebInTaskConfigMode+0x134>

						break;
				}
				break;
			default:
				break;
81110c9c:	00010a06 	br	811110c8 <vPusMebInTaskConfigMode+0x55c>
	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {

		switch (xPusLocal.usiType) {
			case 250: /* srv-Type = 250 */
				switch ( xPusLocal.usiSubType )
81110ca0:	00a04574 	movhi	r2,33045
81110ca4:	10b17504 	addi	r2,r2,-14892
81110ca8:	1080038b 	ldhu	r2,14(r2)
81110cac:	10bfffcc 	andi	r2,r2,65535
81110cb0:	10c00f60 	cmpeqi	r3,r2,61
81110cb4:	18000c1e 	bne	r3,zero,81110ce8 <vPusMebInTaskConfigMode+0x17c>
81110cb8:	10c00fa0 	cmpeqi	r3,r2,62
81110cbc:	1800131e 	bne	r3,zero,81110d0c <vPusMebInTaskConfigMode+0x1a0>
81110cc0:	10800f20 	cmpeqi	r2,r2,60
81110cc4:	10001926 	beq	r2,zero,81110d2c <vPusMebInTaskConfigMode+0x1c0>
				{
					case 60: /* TC_SCAM_CONFIG */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: MEB already in the Config Mode\n");
81110cc8:	d0a05f17 	ldw	r2,-32388(gp)
81110ccc:	100f883a 	mov	r7,r2
81110cd0:	01800a44 	movi	r6,41
81110cd4:	01400044 	movi	r5,1
81110cd8:	01204534 	movhi	r4,33044
81110cdc:	211c5904 	addi	r4,r4,29028
81110ce0:	111affc0 	call	8111affc <fwrite>
						#endif
						break;
81110ce4:	00002606 	br	81110d80 <vPusMebInTaskConfigMode+0x214>


					case 61: /* TC_SCAM_RUN */

						vMebChangeToRunning( pxMebCLocal );
81110ce8:	e13fff17 	ldw	r4,-4(fp)
81110cec:	1111a140 	call	81111a14 <vMebChangeToRunning>
						OSTimeDlyHMSM(0,0,0,20);
81110cf0:	01c00504 	movi	r7,20
81110cf4:	000d883a 	mov	r6,zero
81110cf8:	000b883a 	mov	r5,zero
81110cfc:	0009883a 	mov	r4,zero
81110d00:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
						bStartSync();
81110d04:	1118e640 	call	81118e64 <bStartSync>

						break;
81110d08:	00001d06 	br	81110d80 <vPusMebInTaskConfigMode+0x214>
					case 62: /* TC_SCAM_TURNOFF */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Turnning OFF \n");
81110d0c:	d0a05f17 	ldw	r2,-32388(gp)
81110d10:	100f883a 	mov	r7,r2
81110d14:	01800604 	movi	r6,24
81110d18:	01400044 	movi	r5,1
81110d1c:	01204534 	movhi	r4,33044
81110d20:	211c6404 	addi	r4,r4,29072
81110d24:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
						/* todo:Enviar Sinalizar Led quando puder desligar */

						break;
81110d28:	00001506 	br	81110d80 <vPusMebInTaskConfigMode+0x214>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
81110d2c:	d0e05f17 	ldw	r3,-32388(gp)
81110d30:	00a04574 	movhi	r2,33045
81110d34:	10b17504 	addi	r2,r2,-14892
81110d38:	1080030b 	ldhu	r2,12(r2)
81110d3c:	113fffcc 	andi	r4,r2,65535
81110d40:	00a04574 	movhi	r2,33045
81110d44:	10b17504 	addi	r2,r2,-14892
81110d48:	1080038b 	ldhu	r2,14(r2)
81110d4c:	117fffcc 	andi	r5,r2,65535
81110d50:	00a04574 	movhi	r2,33045
81110d54:	10b17504 	addi	r2,r2,-14892
81110d58:	1080040b 	ldhu	r2,16(r2)
81110d5c:	10bfffcc 	andi	r2,r2,65535
81110d60:	d8800015 	stw	r2,0(sp)
81110d64:	280f883a 	mov	r7,r5
81110d68:	200d883a 	mov	r6,r4
81110d6c:	01604534 	movhi	r5,33044
81110d70:	295c6b04 	addi	r5,r5,29100
81110d74:	1809883a 	mov	r4,r3
81110d78:	111a9600 	call	8111a960 <fprintf>
						#endif
						break;
81110d7c:	0001883a 	nop
				}
				break;
81110d80:	0000d106 	br	811110c8 <vPusMebInTaskConfigMode+0x55c>
			case 251: /* srv-Type = 251 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
81110d84:	00a04574 	movhi	r2,33045
81110d88:	10b17504 	addi	r2,r2,-14892
81110d8c:	1080050b 	ldhu	r2,20(r2)
81110d90:	e0bffe0d 	sth	r2,-8(fp)

				switch ( xPusLocal.usiSubType )
81110d94:	00a04574 	movhi	r2,33045
81110d98:	10b17504 	addi	r2,r2,-14892
81110d9c:	1080038b 	ldhu	r2,14(r2)
81110da0:	10bfffcc 	andi	r2,r2,65535
81110da4:	10c000a0 	cmpeqi	r3,r2,2
81110da8:	1800131e 	bne	r3,zero,81110df8 <vPusMebInTaskConfigMode+0x28c>
81110dac:	10c00160 	cmpeqi	r3,r2,5
81110db0:	1800111e 	bne	r3,zero,81110df8 <vPusMebInTaskConfigMode+0x28c>
81110db4:	10800060 	cmpeqi	r2,r2,1
81110db8:	10001e26 	beq	r2,zero,81110e34 <vPusMebInTaskConfigMode+0x2c8>
				{
					case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81110dbc:	d0a05f17 	ldw	r2,-32388(gp)
81110dc0:	e0fffe0b 	ldhu	r3,-8(fp)
81110dc4:	180d883a 	mov	r6,r3
81110dc8:	01604534 	movhi	r5,33044
81110dcc:	295c7f04 	addi	r5,r5,29180
81110dd0:	1009883a 	mov	r4,r2
81110dd4:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"WARNING: NFEE-%hu is already in Config Mode \n\n", usiFeeInstL);
81110dd8:	d0a05f17 	ldw	r2,-32388(gp)
81110ddc:	e0fffe0b 	ldhu	r3,-8(fp)
81110de0:	180d883a 	mov	r6,r3
81110de4:	01604534 	movhi	r5,33044
81110de8:	295c8604 	addi	r5,r5,29208
81110dec:	1009883a 	mov	r4,r2
81110df0:	111a9600 	call	8111a960 <fprintf>
						#endif

						/* Build a function to send this command to the FEE instance */

						break;
81110df4:	00002406 	br	81110e88 <vPusMebInTaskConfigMode+0x31c>
					case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
					case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81110df8:	d0a05f17 	ldw	r2,-32388(gp)
81110dfc:	e0fffe0b 	ldhu	r3,-8(fp)
81110e00:	180d883a 	mov	r6,r3
81110e04:	01604534 	movhi	r5,33044
81110e08:	295c7f04 	addi	r5,r5,29180
81110e0c:	1009883a 	mov	r4,r2
81110e10:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"WARNING: Can't change NFEE mode while MEB is in Config Mode. \n\n");
81110e14:	d0a05f17 	ldw	r2,-32388(gp)
81110e18:	100f883a 	mov	r7,r2
81110e1c:	01800fc4 	movi	r6,63
81110e20:	01400044 	movi	r5,1
81110e24:	01204534 	movhi	r4,33044
81110e28:	211c9204 	addi	r4,r4,29256
81110e2c:	111affc0 	call	8111affc <fwrite>
						#endif

							/* Do nothing */

						break;
81110e30:	00001506 	br	81110e88 <vPusMebInTaskConfigMode+0x31c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
81110e34:	d0e05f17 	ldw	r3,-32388(gp)
81110e38:	00a04574 	movhi	r2,33045
81110e3c:	10b17504 	addi	r2,r2,-14892
81110e40:	1080030b 	ldhu	r2,12(r2)
81110e44:	113fffcc 	andi	r4,r2,65535
81110e48:	00a04574 	movhi	r2,33045
81110e4c:	10b17504 	addi	r2,r2,-14892
81110e50:	1080038b 	ldhu	r2,14(r2)
81110e54:	117fffcc 	andi	r5,r2,65535
81110e58:	00a04574 	movhi	r2,33045
81110e5c:	10b17504 	addi	r2,r2,-14892
81110e60:	1080040b 	ldhu	r2,16(r2)
81110e64:	10bfffcc 	andi	r2,r2,65535
81110e68:	d8800015 	stw	r2,0(sp)
81110e6c:	280f883a 	mov	r7,r5
81110e70:	200d883a 	mov	r6,r4
81110e74:	01604534 	movhi	r5,33044
81110e78:	295c6b04 	addi	r5,r5,29100
81110e7c:	1809883a 	mov	r4,r3
81110e80:	111a9600 	call	8111a960 <fprintf>
						#endif
						break;
81110e84:	0001883a 	nop
				}
				break;
81110e88:	00008f06 	br	811110c8 <vPusMebInTaskConfigMode+0x55c>
			case 252: /* srv-Type = 252 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
81110e8c:	00a04574 	movhi	r2,33045
81110e90:	10b17504 	addi	r2,r2,-14892
81110e94:	1080050b 	ldhu	r2,20(r2)
81110e98:	e0bffe0d 	sth	r2,-8(fp)


				switch ( xPusLocal.usiSubType )
81110e9c:	00a04574 	movhi	r2,33045
81110ea0:	10b17504 	addi	r2,r2,-14892
81110ea4:	1080038b 	ldhu	r2,14(r2)
81110ea8:	10bfffcc 	andi	r2,r2,65535
81110eac:	10c000e0 	cmpeqi	r3,r2,3
81110eb0:	18000a1e 	bne	r3,zero,81110edc <vPusMebInTaskConfigMode+0x370>
81110eb4:	10c00108 	cmpgei	r3,r2,4
81110eb8:	1800031e 	bne	r3,zero,81110ec8 <vPusMebInTaskConfigMode+0x35c>
81110ebc:	108000a0 	cmpeqi	r2,r2,2
81110ec0:	1000481e 	bne	r2,zero,81110fe4 <vPusMebInTaskConfigMode+0x478>
81110ec4:	00006a06 	br	81111070 <vPusMebInTaskConfigMode+0x504>
81110ec8:	10c00120 	cmpeqi	r3,r2,4
81110ecc:	1800191e 	bne	r3,zero,81110f34 <vPusMebInTaskConfigMode+0x3c8>
81110ed0:	10800160 	cmpeqi	r2,r2,5
81110ed4:	10002d1e 	bne	r2,zero,81110f8c <vPusMebInTaskConfigMode+0x420>
81110ed8:	00006506 	br	81111070 <vPusMebInTaskConfigMode+0x504>
				{
					case 3: /* TC_SCAM_SPW_LINK_ENABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81110edc:	d0a05f17 	ldw	r2,-32388(gp)
81110ee0:	e0fffe0b 	ldhu	r3,-8(fp)
81110ee4:	180d883a 	mov	r6,r3
81110ee8:	01604534 	movhi	r5,33044
81110eec:	295c7f04 	addi	r5,r5,29180
81110ef0:	1009883a 	mov	r4,r2
81110ef4:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_ENABLE \n");
81110ef8:	d0a05f17 	ldw	r2,-32388(gp)
81110efc:	100f883a 	mov	r7,r2
81110f00:	01800844 	movi	r6,33
81110f04:	01400044 	movi	r5,1
81110f08:	01204534 	movhi	r4,33044
81110f0c:	211ca204 	addi	r4,r4,29320
81110f10:	111affc0 	call	8111affc <fwrite>
							fprintf(fp,"WARNING: Can't operate the Link while Meb is is Config mode \n\n");
81110f14:	d0a05f17 	ldw	r2,-32388(gp)
81110f18:	100f883a 	mov	r7,r2
81110f1c:	01800f84 	movi	r6,62
81110f20:	01400044 	movi	r5,1
81110f24:	01204534 	movhi	r4,33044
81110f28:	211cab04 	addi	r4,r4,29356
81110f2c:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
81110f30:	00006406 	br	811110c4 <vPusMebInTaskConfigMode+0x558>
					case 4: /* TC_SCAM_SPW_LINK_DISABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81110f34:	d0a05f17 	ldw	r2,-32388(gp)
81110f38:	e0fffe0b 	ldhu	r3,-8(fp)
81110f3c:	180d883a 	mov	r6,r3
81110f40:	01604534 	movhi	r5,33044
81110f44:	295c7f04 	addi	r5,r5,29180
81110f48:	1009883a 	mov	r4,r2
81110f4c:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_DISABLE \n");
81110f50:	d0a05f17 	ldw	r2,-32388(gp)
81110f54:	100f883a 	mov	r7,r2
81110f58:	01800884 	movi	r6,34
81110f5c:	01400044 	movi	r5,1
81110f60:	01204534 	movhi	r4,33044
81110f64:	211cbb04 	addi	r4,r4,29420
81110f68:	111affc0 	call	8111affc <fwrite>
							fprintf(fp,"WARNING: Can't operate the Link while Meb is is Config mode \n\n");
81110f6c:	d0a05f17 	ldw	r2,-32388(gp)
81110f70:	100f883a 	mov	r7,r2
81110f74:	01800f84 	movi	r6,62
81110f78:	01400044 	movi	r5,1
81110f7c:	01204534 	movhi	r4,33044
81110f80:	211cab04 	addi	r4,r4,29356
81110f84:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
81110f88:	00004e06 	br	811110c4 <vPusMebInTaskConfigMode+0x558>
					case 5: /* TC_SCAM_SPW_LINK_RESET */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81110f8c:	d0a05f17 	ldw	r2,-32388(gp)
81110f90:	e0fffe0b 	ldhu	r3,-8(fp)
81110f94:	180d883a 	mov	r6,r3
81110f98:	01604534 	movhi	r5,33044
81110f9c:	295c7f04 	addi	r5,r5,29180
81110fa0:	1009883a 	mov	r4,r2
81110fa4:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_RESET \n");
81110fa8:	d0a05f17 	ldw	r2,-32388(gp)
81110fac:	100f883a 	mov	r7,r2
81110fb0:	01800804 	movi	r6,32
81110fb4:	01400044 	movi	r5,1
81110fb8:	01204534 	movhi	r4,33044
81110fbc:	211cc404 	addi	r4,r4,29456
81110fc0:	111affc0 	call	8111affc <fwrite>
							fprintf(fp,"WARNING: Can't operate the Link while Meb is is Config mode \n\n");
81110fc4:	d0a05f17 	ldw	r2,-32388(gp)
81110fc8:	100f883a 	mov	r7,r2
81110fcc:	01800f84 	movi	r6,62
81110fd0:	01400044 	movi	r5,1
81110fd4:	01204534 	movhi	r4,33044
81110fd8:	211cab04 	addi	r4,r4,29356
81110fdc:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
81110fe0:	00003806 	br	811110c4 <vPusMebInTaskConfigMode+0x558>
					case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81110fe4:	d0a05f17 	ldw	r2,-32388(gp)
81110fe8:	e0fffe0b 	ldhu	r3,-8(fp)
81110fec:	180d883a 	mov	r6,r3
81110ff0:	01604534 	movhi	r5,33044
81110ff4:	295c7f04 	addi	r5,r5,29180
81110ff8:	1009883a 	mov	r4,r2
81110ffc:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_RMAP_CONFIG_UPDATE \n");
81111000:	d0a05f17 	ldw	r2,-32388(gp)
81111004:	100f883a 	mov	r7,r2
81111008:	01800a04 	movi	r6,40
8111100c:	01400044 	movi	r5,1
81111010:	01204534 	movhi	r4,33044
81111014:	211ccd04 	addi	r4,r4,29492
81111018:	111affc0 	call	8111affc <fwrite>
						xPusLocal.usiValues[5];
						xPusLocal.usiValues[6];
						xPusLocal.usiValues[7];
							*/

						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusLocal.usiValues[12];
8111101c:	e13ffe0b 	ldhu	r4,-8(fp)
81111020:	00a04574 	movhi	r2,33045
81111024:	10b17504 	addi	r2,r2,-14892
81111028:	10800b0b 	ldhu	r2,44(r2)
8111102c:	100b883a 	mov	r5,r2
81111030:	e0ffff17 	ldw	r3,-4(fp)
81111034:	20809224 	muli	r2,r4,584
81111038:	1885883a 	add	r2,r3,r2
8111103c:	10804f04 	addi	r2,r2,316
81111040:	11400005 	stb	r5,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusLocal.usiValues[9];
81111044:	e13ffe0b 	ldhu	r4,-8(fp)
81111048:	00a04574 	movhi	r2,33045
8111104c:	10b17504 	addi	r2,r2,-14892
81111050:	1080098b 	ldhu	r2,38(r2)
81111054:	100b883a 	mov	r5,r2
81111058:	e0ffff17 	ldw	r3,-4(fp)
8111105c:	20809224 	muli	r2,r4,584
81111060:	1885883a 	add	r2,r3,r2
81111064:	10804f44 	addi	r2,r2,317
81111068:	11400005 	stb	r5,0(r2)
							debug(fp, cPUSDebug );
							sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
							debug(fp, cPUSDebug );
						#endif
*/
						break;
8111106c:	00001506 	br	811110c4 <vPusMebInTaskConfigMode+0x558>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
81111070:	d0e05f17 	ldw	r3,-32388(gp)
81111074:	00a04574 	movhi	r2,33045
81111078:	10b17504 	addi	r2,r2,-14892
8111107c:	1080030b 	ldhu	r2,12(r2)
81111080:	113fffcc 	andi	r4,r2,65535
81111084:	00a04574 	movhi	r2,33045
81111088:	10b17504 	addi	r2,r2,-14892
8111108c:	1080038b 	ldhu	r2,14(r2)
81111090:	117fffcc 	andi	r5,r2,65535
81111094:	00a04574 	movhi	r2,33045
81111098:	10b17504 	addi	r2,r2,-14892
8111109c:	1080040b 	ldhu	r2,16(r2)
811110a0:	10bfffcc 	andi	r2,r2,65535
811110a4:	d8800015 	stw	r2,0(sp)
811110a8:	280f883a 	mov	r7,r5
811110ac:	200d883a 	mov	r6,r4
811110b0:	01604534 	movhi	r5,33044
811110b4:	295c6b04 	addi	r5,r5,29100
811110b8:	1809883a 	mov	r4,r3
811110bc:	111a9600 	call	8111a960 <fprintf>
						#endif

						break;
811110c0:	0001883a 	nop
				}
				break;
811110c4:	0001883a 	nop
				break;
		}

	}

}
811110c8:	0001883a 	nop
811110cc:	e037883a 	mov	sp,fp
811110d0:	dfc00117 	ldw	ra,4(sp)
811110d4:	df000017 	ldw	fp,0(sp)
811110d8:	dec00204 	addi	sp,sp,8
811110dc:	f800283a 	ret

811110e0 <vPusMebInTaskRunningMode>:


/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal ) {
811110e0:	defff904 	addi	sp,sp,-28
811110e4:	de00012e 	bgeu	sp,et,811110ec <vPusMebInTaskRunningMode+0xc>
811110e8:	003b68fa 	trap	3
811110ec:	dfc00615 	stw	ra,24(sp)
811110f0:	df000515 	stw	fp,20(sp)
811110f4:	df000504 	addi	fp,sp,20
811110f8:	e13fff15 	stw	r4,-4(fp)
	unsigned char i;
	unsigned short int usiFeeInstL;
	static tTMPus xPusLocal;
	bool bSuccess = FALSE;
811110fc:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;

	bSuccess = FALSE;
81111100:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 1, &error_code);
81111104:	d0a07617 	ldw	r2,-32296(gp)
81111108:	e0fffe84 	addi	r3,fp,-6
8111110c:	180d883a 	mov	r6,r3
81111110:	01400044 	movi	r5,1
81111114:	1009883a 	mov	r4,r2
81111118:	1136a300 	call	81136a30 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
8111111c:	e0bffe83 	ldbu	r2,-6(fp)
81111120:	10803fcc 	andi	r2,r2,255
81111124:	10002c1e 	bne	r2,zero,811111d8 <vPusMebInTaskRunningMode+0xf8>

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
81111128:	e03ffc05 	stb	zero,-16(fp)
8111112c:	00002306 	br	811111bc <vPusMebInTaskRunningMode+0xdc>
	    {
            if ( xPus[i].bInUse == TRUE ) {
81111130:	e0fffc03 	ldbu	r3,-16(fp)
81111134:	00a04574 	movhi	r2,33045
81111138:	10bb8104 	addi	r2,r2,-4604
8111113c:	18c01524 	muli	r3,r3,84
81111140:	10c5883a 	add	r2,r2,r3
81111144:	10800104 	addi	r2,r2,4
81111148:	10800017 	ldw	r2,0(r2)
8111114c:	10800058 	cmpnei	r2,r2,1
81111150:	1000171e 	bne	r2,zero,811111b0 <vPusMebInTaskRunningMode+0xd0>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[i];
81111154:	e13ffc03 	ldbu	r4,-16(fp)
81111158:	00e04574 	movhi	r3,33045
8111115c:	18f18a04 	addi	r3,r3,-14808
81111160:	00a04574 	movhi	r2,33045
81111164:	10bb8104 	addi	r2,r2,-4604
81111168:	21001524 	muli	r4,r4,84
8111116c:	1105883a 	add	r2,r2,r4
81111170:	1009883a 	mov	r4,r2
81111174:	00801504 	movi	r2,84
81111178:	100d883a 	mov	r6,r2
8111117c:	200b883a 	mov	r5,r4
81111180:	1809883a 	mov	r4,r3
81111184:	111ba100 	call	8111ba10 <memcpy>
            	xPus[i].bInUse = FALSE;
81111188:	e0fffc03 	ldbu	r3,-16(fp)
8111118c:	00a04574 	movhi	r2,33045
81111190:	10bb8104 	addi	r2,r2,-4604
81111194:	18c01524 	muli	r3,r3,84
81111198:	10c5883a 	add	r2,r2,r3
8111119c:	10800104 	addi	r2,r2,4
811111a0:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
811111a4:	00800044 	movi	r2,1
811111a8:	e0bffd15 	stw	r2,-12(fp)
                break;
811111ac:	00000606 	br	811111c8 <vPusMebInTaskRunningMode+0xe8>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 1, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(i = 0; i < N_PUS_PIPE; i++)
811111b0:	e0bffc03 	ldbu	r2,-16(fp)
811111b4:	10800044 	addi	r2,r2,1
811111b8:	e0bffc05 	stb	r2,-16(fp)
811111bc:	e0bffc03 	ldbu	r2,-16(fp)
811111c0:	10800130 	cmpltui	r2,r2,4
811111c4:	103fda1e 	bne	r2,zero,81111130 <__reset+0xfb0f1130>
            	xPus[i].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811111c8:	d0a07617 	ldw	r2,-32296(gp)
811111cc:	1009883a 	mov	r4,r2
811111d0:	1136fd40 	call	81136fd4 <OSMutexPost>
811111d4:	00000106 	br	811111dc <vPusMebInTaskRunningMode+0xfc>
	} else {
		vCouldNotGetMutexMebPus();
811111d8:	11175f80 	call	811175f8 <vCouldNotGetMutexMebPus>
	}

	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {
811111dc:	e0bffd17 	ldw	r2,-12(fp)
811111e0:	10800058 	cmpnei	r2,r2,1
811111e4:	1001801e 	bne	r2,zero,811117e8 <vPusMebInTaskRunningMode+0x708>

		switch (xPusLocal.usiType) {
811111e8:	00a04574 	movhi	r2,33045
811111ec:	10b18a04 	addi	r2,r2,-14808
811111f0:	1080030b 	ldhu	r2,12(r2)
811111f4:	10bfffcc 	andi	r2,r2,65535
811111f8:	10c03ee0 	cmpeqi	r3,r2,251
811111fc:	18005c1e 	bne	r3,zero,81111370 <vPusMebInTaskRunningMode+0x290>
81111200:	10c03f20 	cmpeqi	r3,r2,252
81111204:	1800c91e 	bne	r3,zero,8111152c <vPusMebInTaskRunningMode+0x44c>
81111208:	10803ea0 	cmpeqi	r2,r2,250
8111120c:	1000011e 	bne	r2,zero,81111214 <vPusMebInTaskRunningMode+0x134>

						break;
				}
				break;
			default:
				break;
81111210:	00017506 	br	811117e8 <vPusMebInTaskRunningMode+0x708>
	/* PUS command Retrieved*/
	if ( bSuccess == TRUE ) {

		switch (xPusLocal.usiType) {
			case 250: /* srv-Type = 250 */
				switch ( xPusLocal.usiSubType )
81111214:	00a04574 	movhi	r2,33045
81111218:	10b18a04 	addi	r2,r2,-14808
8111121c:	1080038b 	ldhu	r2,14(r2)
81111220:	10bfffcc 	andi	r2,r2,65535
81111224:	10c00f60 	cmpeqi	r3,r2,61
81111228:	18002b1e 	bne	r3,zero,811112d8 <vPusMebInTaskRunningMode+0x1f8>
8111122c:	10c00fa0 	cmpeqi	r3,r2,62
81111230:	1800311e 	bne	r3,zero,811112f8 <vPusMebInTaskRunningMode+0x218>
81111234:	10800f20 	cmpeqi	r2,r2,60
81111238:	10003726 	beq	r2,zero,81111318 <vPusMebInTaskRunningMode+0x238>
				{
					case 60: /* TC_SCAM_CONFIG */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Changing to Config Mode\n");
8111123c:	d0a05f17 	ldw	r2,-32388(gp)
81111240:	100f883a 	mov	r7,r2
81111244:	01800884 	movi	r6,34
81111248:	01400044 	movi	r5,1
8111124c:	01204534 	movhi	r4,33044
81111250:	211cd804 	addi	r4,r4,29536
81111254:	111affc0 	call	8111affc <fwrite>
						#endif

						vEvtChangeMebMode(pxMebCLocal->eMode, sMebConfig);
81111258:	e0bfff17 	ldw	r2,-4(fp)
8111125c:	10800117 	ldw	r2,4(r2)
81111260:	000b883a 	mov	r5,zero
81111264:	1009883a 	mov	r4,r2
81111268:	11179700 	call	81117970 <vEvtChangeMebMode>
						pxMebCLocal->eMode = sMebConfig;
8111126c:	e0bfff17 	ldw	r2,-4(fp)
81111270:	10000115 	stw	zero,4(r2)

	/*todo: URGENTE: Passar todos os FEE para modo de configurao  */
	/*todo: URGENTE: Data Controller e NFEE COntroller tambm  */

						vSendCmdQToNFeeCTRL( M_NFC_CONFIG, 0, 0 );
81111274:	000d883a 	mov	r6,zero
81111278:	000b883a 	mov	r5,zero
8111127c:	01000044 	movi	r4,1
81111280:	11118000 	call	81111800 <vSendCmdQToNFeeCTRL>
						OSTimeDlyHMSM(0,0,0,10);
81111284:	01c00284 	movi	r7,10
81111288:	000d883a 	mov	r6,zero
8111128c:	000b883a 	mov	r5,zero
81111290:	0009883a 	mov	r4,zero
81111294:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
						/* Stop Sync Generation */
						bStopSync();
81111298:	1118e9c0 	call	81118e9c <bStopSync>
						/* Clear all time code */
						for ( i=0 ; i<N_OF_NFEE; i++ ){
8111129c:	e03ffc05 	stb	zero,-16(fp)
811112a0:	00000a06 	br	811112cc <vPusMebInTaskRunningMode+0x1ec>
							bSpwcClearTimecode(&pxMebCLocal->xFeeControl.xNfee[i].xChannel.xSpacewire);
811112a4:	e0bffc03 	ldbu	r2,-16(fp)
811112a8:	10809224 	muli	r2,r2,584
811112ac:	10809404 	addi	r2,r2,592
811112b0:	e0ffff17 	ldw	r3,-4(fp)
811112b4:	1885883a 	add	r2,r3,r2
811112b8:	1009883a 	mov	r4,r2
811112bc:	11092380 	call	81109238 <bSpwcClearTimecode>
						vSendCmdQToNFeeCTRL( M_NFC_CONFIG, 0, 0 );
						OSTimeDlyHMSM(0,0,0,10);
						/* Stop Sync Generation */
						bStopSync();
						/* Clear all time code */
						for ( i=0 ; i<N_OF_NFEE; i++ ){
811112c0:	e0bffc03 	ldbu	r2,-16(fp)
811112c4:	10800044 	addi	r2,r2,1
811112c8:	e0bffc05 	stb	r2,-16(fp)
811112cc:	e0bffc03 	ldbu	r2,-16(fp)
811112d0:	103ff426 	beq	r2,zero,811112a4 <__reset+0xfb0f12a4>
							bSpwcClearTimecode(&pxMebCLocal->xFeeControl.xNfee[i].xChannel.xSpacewire);
						}

						break;
811112d4:	00002506 	br	8111136c <vPusMebInTaskRunningMode+0x28c>

					case 61: /* TC_SCAM_RUN */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: MEB already in the RUN Mode\n");
811112d8:	d0a05f17 	ldw	r2,-32388(gp)
811112dc:	100f883a 	mov	r7,r2
811112e0:	01800984 	movi	r6,38
811112e4:	01400044 	movi	r5,1
811112e8:	01204534 	movhi	r4,33044
811112ec:	211ce104 	addi	r4,r4,29572
811112f0:	111affc0 	call	8111affc <fwrite>
						#endif

						/* Do nothing */

						break;
811112f4:	00001d06 	br	8111136c <vPusMebInTaskRunningMode+0x28c>


					case 62: /* TC_SCAM_TURNOFF */
						#ifdef DEBUG_ON
							debug(fp,"MEB Task: Turnning OFF \n");
811112f8:	d0a05f17 	ldw	r2,-32388(gp)
811112fc:	100f883a 	mov	r7,r2
81111300:	01800604 	movi	r6,24
81111304:	01400044 	movi	r5,1
81111308:	01204534 	movhi	r4,33044
8111130c:	211c6404 	addi	r4,r4,29072
81111310:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo:Enviar emnsagens para a meb, e a meb distribui a mensagem */
						/* todo:Enviar Sinalizar Led quando puder desligar */

						break;
81111314:	00001506 	br	8111136c <vPusMebInTaskRunningMode+0x28c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
81111318:	d0e05f17 	ldw	r3,-32388(gp)
8111131c:	00a04574 	movhi	r2,33045
81111320:	10b18a04 	addi	r2,r2,-14808
81111324:	1080030b 	ldhu	r2,12(r2)
81111328:	113fffcc 	andi	r4,r2,65535
8111132c:	00a04574 	movhi	r2,33045
81111330:	10b18a04 	addi	r2,r2,-14808
81111334:	1080038b 	ldhu	r2,14(r2)
81111338:	117fffcc 	andi	r5,r2,65535
8111133c:	00a04574 	movhi	r2,33045
81111340:	10b18a04 	addi	r2,r2,-14808
81111344:	1080040b 	ldhu	r2,16(r2)
81111348:	10bfffcc 	andi	r2,r2,65535
8111134c:	d8800015 	stw	r2,0(sp)
81111350:	280f883a 	mov	r7,r5
81111354:	200d883a 	mov	r6,r4
81111358:	01604534 	movhi	r5,33044
8111135c:	295c6b04 	addi	r5,r5,29100
81111360:	1809883a 	mov	r4,r3
81111364:	111a9600 	call	8111a960 <fprintf>
						#endif
						break;
81111368:	0001883a 	nop
				}
				break;
8111136c:	00011e06 	br	811117e8 <vPusMebInTaskRunningMode+0x708>
			case 251: /* srv-Type = 251 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
81111370:	00a04574 	movhi	r2,33045
81111374:	10b18a04 	addi	r2,r2,-14808
81111378:	1080050b 	ldhu	r2,20(r2)
8111137c:	e0bffe0d 	sth	r2,-8(fp)

				switch ( xPusLocal.usiSubType )
81111380:	00a04574 	movhi	r2,33045
81111384:	10b18a04 	addi	r2,r2,-14808
81111388:	1080038b 	ldhu	r2,14(r2)
8111138c:	10bfffcc 	andi	r2,r2,65535
81111390:	10c000a0 	cmpeqi	r3,r2,2
81111394:	18001d1e 	bne	r3,zero,8111140c <vPusMebInTaskRunningMode+0x32c>
81111398:	10c00160 	cmpeqi	r3,r2,5
8111139c:	1800341e 	bne	r3,zero,81111470 <vPusMebInTaskRunningMode+0x390>
811113a0:	10800060 	cmpeqi	r2,r2,1
811113a4:	10004b26 	beq	r2,zero,811114d4 <vPusMebInTaskRunningMode+0x3f4>
				{
					case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"\nMEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
811113a8:	d0a05f17 	ldw	r2,-32388(gp)
811113ac:	e0fffe0b 	ldhu	r3,-8(fp)
811113b0:	180d883a 	mov	r6,r3
811113b4:	01604534 	movhi	r5,33044
811113b8:	295ceb04 	addi	r5,r5,29612
811113bc:	1009883a 	mov	r4,r2
811113c0:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> FEE_CONFIG_ENTER \n\n");
811113c4:	d0a05f17 	ldw	r2,-32388(gp)
811113c8:	100f883a 	mov	r7,r2
811113cc:	018006c4 	movi	r6,27
811113d0:	01400044 	movi	r5,1
811113d4:	01204534 	movhi	r4,33044
811113d8:	211cf304 	addi	r4,r4,29644
811113dc:	111affc0 	call	8111affc <fwrite>
						#endif

						vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
811113e0:	e0bffe0b 	ldhu	r2,-8(fp)
811113e4:	10800444 	addi	r2,r2,17
811113e8:	10803fcc 	andi	r2,r2,255
811113ec:	e0fffe0b 	ldhu	r3,-8(fp)
811113f0:	18c03fcc 	andi	r3,r3,255
811113f4:	180f883a 	mov	r7,r3
811113f8:	000d883a 	mov	r6,zero
811113fc:	01400044 	movi	r5,1
81111400:	1009883a 	mov	r4,r2
81111404:	11118880 	call	81111888 <vSendCmdQToNFeeCTRL_GEN>
						/* Build a function to send this command to the FEE instance */
						 /* Using QMASK send to NfeeControl that will forward */

						break;
81111408:	00004706 	br	81111528 <vPusMebInTaskRunningMode+0x448>
					case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8111140c:	d0a05f17 	ldw	r2,-32388(gp)
81111410:	e0fffe0b 	ldhu	r3,-8(fp)
81111414:	180d883a 	mov	r6,r3
81111418:	01604534 	movhi	r5,33044
8111141c:	295c7f04 	addi	r5,r5,29180
81111420:	1009883a 	mov	r4,r2
81111424:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> FEE_STANDBY_ENTER \n");
81111428:	d0a05f17 	ldw	r2,-32388(gp)
8111142c:	100f883a 	mov	r7,r2
81111430:	018006c4 	movi	r6,27
81111434:	01400044 	movi	r5,1
81111438:	01204534 	movhi	r4,33044
8111143c:	211cfa04 	addi	r4,r4,29672
81111440:	111affc0 	call	8111affc <fwrite>
						#endif

						/* Using QMASK send to NfeeControl that will foward */
						vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81111444:	e0bffe0b 	ldhu	r2,-8(fp)
81111448:	10800444 	addi	r2,r2,17
8111144c:	10803fcc 	andi	r2,r2,255
81111450:	e0fffe0b 	ldhu	r3,-8(fp)
81111454:	18c03fcc 	andi	r3,r3,255
81111458:	180f883a 	mov	r7,r3
8111145c:	000d883a 	mov	r6,zero
81111460:	01400104 	movi	r5,4
81111464:	1009883a 	mov	r4,r2
81111468:	11118880 	call	81111888 <vSendCmdQToNFeeCTRL_GEN>

						break;
8111146c:	00002e06 	br	81111528 <vPusMebInTaskRunningMode+0x448>
					case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81111470:	d0a05f17 	ldw	r2,-32388(gp)
81111474:	e0fffe0b 	ldhu	r3,-8(fp)
81111478:	180d883a 	mov	r6,r3
8111147c:	01604534 	movhi	r5,33044
81111480:	295c7f04 	addi	r5,r5,29180
81111484:	1009883a 	mov	r4,r2
81111488:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_FEE_CALIBRATION_TEST_ENTER \n");
8111148c:	d0a05f17 	ldw	r2,-32388(gp)
81111490:	100f883a 	mov	r7,r2
81111494:	01800b04 	movi	r6,44
81111498:	01400044 	movi	r5,1
8111149c:	01204534 	movhi	r4,33044
811114a0:	211d0104 	addi	r4,r4,29700
811114a4:	111affc0 	call	8111affc <fwrite>
						#endif

						/* Using QMASK send to NfeeControl that will foward */
						vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
811114a8:	e0bffe0b 	ldhu	r2,-8(fp)
811114ac:	10800444 	addi	r2,r2,17
811114b0:	10803fcc 	andi	r2,r2,255
811114b4:	e0fffe0b 	ldhu	r3,-8(fp)
811114b8:	18c03fcc 	andi	r3,r3,255
811114bc:	180f883a 	mov	r7,r3
811114c0:	000d883a 	mov	r6,zero
811114c4:	01400204 	movi	r5,8
811114c8:	1009883a 	mov	r4,r2
811114cc:	11118880 	call	81111888 <vSendCmdQToNFeeCTRL_GEN>

						break;
811114d0:	00001506 	br	81111528 <vPusMebInTaskRunningMode+0x448>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
811114d4:	d0e05f17 	ldw	r3,-32388(gp)
811114d8:	00a04574 	movhi	r2,33045
811114dc:	10b18a04 	addi	r2,r2,-14808
811114e0:	1080030b 	ldhu	r2,12(r2)
811114e4:	113fffcc 	andi	r4,r2,65535
811114e8:	00a04574 	movhi	r2,33045
811114ec:	10b18a04 	addi	r2,r2,-14808
811114f0:	1080038b 	ldhu	r2,14(r2)
811114f4:	117fffcc 	andi	r5,r2,65535
811114f8:	00a04574 	movhi	r2,33045
811114fc:	10b18a04 	addi	r2,r2,-14808
81111500:	1080040b 	ldhu	r2,16(r2)
81111504:	10bfffcc 	andi	r2,r2,65535
81111508:	d8800015 	stw	r2,0(sp)
8111150c:	280f883a 	mov	r7,r5
81111510:	200d883a 	mov	r6,r4
81111514:	01604534 	movhi	r5,33044
81111518:	295c6b04 	addi	r5,r5,29100
8111151c:	1809883a 	mov	r4,r3
81111520:	111a9600 	call	8111a960 <fprintf>
						#endif
						break;
81111524:	0001883a 	nop
				}
				break;
81111528:	0000af06 	br	811117e8 <vPusMebInTaskRunningMode+0x708>
			case 252: /* srv-Type = 252 */
				usiFeeInstL = xPusLocal.usiValues[0]; /* 0 is the NFEE instance */
8111152c:	00a04574 	movhi	r2,33045
81111530:	10b18a04 	addi	r2,r2,-14808
81111534:	1080050b 	ldhu	r2,20(r2)
81111538:	e0bffe0d 	sth	r2,-8(fp)


				switch ( xPusLocal.usiSubType )
8111153c:	00a04574 	movhi	r2,33045
81111540:	10b18a04 	addi	r2,r2,-14808
81111544:	1080038b 	ldhu	r2,14(r2)
81111548:	10bfffcc 	andi	r2,r2,65535
8111154c:	10c000e0 	cmpeqi	r3,r2,3
81111550:	18000a1e 	bne	r3,zero,8111157c <vPusMebInTaskRunningMode+0x49c>
81111554:	10c00108 	cmpgei	r3,r2,4
81111558:	1800031e 	bne	r3,zero,81111568 <vPusMebInTaskRunningMode+0x488>
8111155c:	108000a0 	cmpeqi	r2,r2,2
81111560:	1000751e 	bne	r2,zero,81111738 <vPusMebInTaskRunningMode+0x658>
81111564:	00008a06 	br	81111790 <vPusMebInTaskRunningMode+0x6b0>
81111568:	10c00120 	cmpeqi	r3,r2,4
8111156c:	1800331e 	bne	r3,zero,8111163c <vPusMebInTaskRunningMode+0x55c>
81111570:	10800160 	cmpeqi	r2,r2,5
81111574:	1000611e 	bne	r2,zero,811116fc <vPusMebInTaskRunningMode+0x61c>
81111578:	00008506 	br	81111790 <vPusMebInTaskRunningMode+0x6b0>
				{
					case 3: /* TC_SCAM_SPW_LINK_ENABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8111157c:	d0a05f17 	ldw	r2,-32388(gp)
81111580:	e0fffe0b 	ldhu	r3,-8(fp)
81111584:	180d883a 	mov	r6,r3
81111588:	01604534 	movhi	r5,33044
8111158c:	295c7f04 	addi	r5,r5,29180
81111590:	1009883a 	mov	r4,r2
81111594:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_ENABLE \n");
81111598:	d0a05f17 	ldw	r2,-32388(gp)
8111159c:	100f883a 	mov	r7,r2
811115a0:	01800844 	movi	r6,33
811115a4:	01400044 	movi	r5,1
811115a8:	01204534 	movhi	r4,33044
811115ac:	211ca204 	addi	r4,r4,29320
811115b0:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811115b4:	e0bffe0b 	ldhu	r2,-8(fp)
811115b8:	10809224 	muli	r2,r2,584
811115bc:	10809404 	addi	r2,r2,592
811115c0:	e0ffff17 	ldw	r3,-4(fp)
811115c4:	1885883a 	add	r2,r3,r2
811115c8:	1009883a 	mov	r4,r2
811115cc:	1108f000 	call	81108f00 <bSpwcGetLink>
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
811115d0:	e0bffe0b 	ldhu	r2,-8(fp)
811115d4:	e0ffff17 	ldw	r3,-4(fp)
811115d8:	10809224 	muli	r2,r2,584
811115dc:	1885883a 	add	r2,r3,r2
811115e0:	10809604 	addi	r2,r2,600
811115e4:	10000015 	stw	zero,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
811115e8:	e0bffe0b 	ldhu	r2,-8(fp)
811115ec:	e0ffff17 	ldw	r3,-4(fp)
811115f0:	10809224 	muli	r2,r2,584
811115f4:	1885883a 	add	r2,r3,r2
811115f8:	10809504 	addi	r2,r2,596
811115fc:	00c00044 	movi	r3,1
81111600:	10c00015 	stw	r3,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81111604:	e0bffe0b 	ldhu	r2,-8(fp)
81111608:	e0ffff17 	ldw	r3,-4(fp)
8111160c:	10809224 	muli	r2,r2,584
81111610:	1885883a 	add	r2,r3,r2
81111614:	10809704 	addi	r2,r2,604
81111618:	10000015 	stw	zero,0(r2)
						bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
8111161c:	e0bffe0b 	ldhu	r2,-8(fp)
81111620:	10809224 	muli	r2,r2,584
81111624:	10809404 	addi	r2,r2,592
81111628:	e0ffff17 	ldw	r3,-4(fp)
8111162c:	1885883a 	add	r2,r3,r2
81111630:	1009883a 	mov	r4,r2
81111634:	1108dcc0 	call	81108dcc <bSpwcSetLink>


						break;
81111638:	00006a06 	br	811117e4 <vPusMebInTaskRunningMode+0x704>
					case 4: /* TC_SCAM_SPW_LINK_DISABLE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
8111163c:	d0a05f17 	ldw	r2,-32388(gp)
81111640:	e0fffe0b 	ldhu	r3,-8(fp)
81111644:	180d883a 	mov	r6,r3
81111648:	01604534 	movhi	r5,33044
8111164c:	295c7f04 	addi	r5,r5,29180
81111650:	1009883a 	mov	r4,r2
81111654:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_DISABLE \n");
81111658:	d0a05f17 	ldw	r2,-32388(gp)
8111165c:	100f883a 	mov	r7,r2
81111660:	01800884 	movi	r6,34
81111664:	01400044 	movi	r5,1
81111668:	01204534 	movhi	r4,33044
8111166c:	211cbb04 	addi	r4,r4,29420
81111670:	111affc0 	call	8111affc <fwrite>
						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */
						/* Disable the link SPW */
						//todo: tratar retorno

						bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111674:	e0bffe0b 	ldhu	r2,-8(fp)
81111678:	10809224 	muli	r2,r2,584
8111167c:	10809404 	addi	r2,r2,592
81111680:	e0ffff17 	ldw	r3,-4(fp)
81111684:	1885883a 	add	r2,r3,r2
81111688:	1009883a 	mov	r4,r2
8111168c:	1108f000 	call	81108f00 <bSpwcGetLink>
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81111690:	e0bffe0b 	ldhu	r2,-8(fp)
81111694:	e0ffff17 	ldw	r3,-4(fp)
81111698:	10809224 	muli	r2,r2,584
8111169c:	1885883a 	add	r2,r3,r2
811116a0:	10809604 	addi	r2,r2,600
811116a4:	10000015 	stw	zero,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
811116a8:	e0bffe0b 	ldhu	r2,-8(fp)
811116ac:	e0ffff17 	ldw	r3,-4(fp)
811116b0:	10809224 	muli	r2,r2,584
811116b4:	1885883a 	add	r2,r3,r2
811116b8:	10809504 	addi	r2,r2,596
811116bc:	10000015 	stw	zero,0(r2)
						pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
811116c0:	e0bffe0b 	ldhu	r2,-8(fp)
811116c4:	e0ffff17 	ldw	r3,-4(fp)
811116c8:	10809224 	muli	r2,r2,584
811116cc:	1885883a 	add	r2,r3,r2
811116d0:	10809704 	addi	r2,r2,604
811116d4:	00c00044 	movi	r3,1
811116d8:	10c00015 	stw	r3,0(r2)
						bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811116dc:	e0bffe0b 	ldhu	r2,-8(fp)
811116e0:	10809224 	muli	r2,r2,584
811116e4:	10809404 	addi	r2,r2,592
811116e8:	e0ffff17 	ldw	r3,-4(fp)
811116ec:	1885883a 	add	r2,r3,r2
811116f0:	1009883a 	mov	r4,r2
811116f4:	1108dcc0 	call	81108dcc <bSpwcSetLink>

						break;
811116f8:	00003a06 	br	811117e4 <vPusMebInTaskRunningMode+0x704>
					case 5: /* TC_SCAM_SPW_LINK_RESET */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
811116fc:	d0a05f17 	ldw	r2,-32388(gp)
81111700:	e0fffe0b 	ldhu	r3,-8(fp)
81111704:	180d883a 	mov	r6,r3
81111708:	01604534 	movhi	r5,33044
8111170c:	295c7f04 	addi	r5,r5,29180
81111710:	1009883a 	mov	r4,r2
81111714:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_LINK_RESET \n");
81111718:	d0a05f17 	ldw	r2,-32388(gp)
8111171c:	100f883a 	mov	r7,r2
81111720:	01800804 	movi	r6,32
81111724:	01400044 	movi	r5,1
81111728:	01204534 	movhi	r4,33044
8111172c:	211cc404 	addi	r4,r4,29456
81111730:	111affc0 	call	8111affc <fwrite>
						#endif

						/* todo: Usar as funes de configurao disponibilizadas pelo Frana  */
						/* todo: Como a Meb esta em config ela pode operar todas as configuraes tranquilamente  */

						break;
81111734:	00002b06 	br	811117e4 <vPusMebInTaskRunningMode+0x704>
					case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: CMD to NFEE-%hu \n", usiFeeInstL);
81111738:	d0a05f17 	ldw	r2,-32388(gp)
8111173c:	e0fffe0b 	ldhu	r3,-8(fp)
81111740:	180d883a 	mov	r6,r3
81111744:	01604534 	movhi	r5,33044
81111748:	295c7f04 	addi	r5,r5,29180
8111174c:	1009883a 	mov	r4,r2
81111750:	111a9600 	call	8111a960 <fprintf>
							fprintf(fp,"     -> TC_SCAM_SPW_RMAP_CONFIG_UPDATE \n");
81111754:	d0a05f17 	ldw	r2,-32388(gp)
81111758:	100f883a 	mov	r7,r2
8111175c:	01800a04 	movi	r6,40
81111760:	01400044 	movi	r5,1
81111764:	01204534 	movhi	r4,33044
81111768:	211ccd04 	addi	r4,r4,29492
8111176c:	111affc0 	call	8111affc <fwrite>
							fprintf(fp,"WARNING: Operation Forbiden in Meb Running Mode. \n\n");
81111770:	d0a05f17 	ldw	r2,-32388(gp)
81111774:	100f883a 	mov	r7,r2
81111778:	01800cc4 	movi	r6,51
8111177c:	01400044 	movi	r5,1
81111780:	01204534 	movhi	r4,33044
81111784:	211d0d04 	addi	r4,r4,29748
81111788:	111affc0 	call	8111affc <fwrite>
						#endif

						/* Do nothing */
						/* Return a PUS error? */

						break;
8111178c:	00001506 	br	811117e4 <vPusMebInTaskRunningMode+0x704>
					default:
						#ifdef DEBUG_ON
							fprintf(fp, "MEB Task: Default - TC arrived-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xPusLocal.usiType, xPusLocal.usiSubType, xPusLocal.usiPusId );
81111790:	d0e05f17 	ldw	r3,-32388(gp)
81111794:	00a04574 	movhi	r2,33045
81111798:	10b18a04 	addi	r2,r2,-14808
8111179c:	1080030b 	ldhu	r2,12(r2)
811117a0:	113fffcc 	andi	r4,r2,65535
811117a4:	00a04574 	movhi	r2,33045
811117a8:	10b18a04 	addi	r2,r2,-14808
811117ac:	1080038b 	ldhu	r2,14(r2)
811117b0:	117fffcc 	andi	r5,r2,65535
811117b4:	00a04574 	movhi	r2,33045
811117b8:	10b18a04 	addi	r2,r2,-14808
811117bc:	1080040b 	ldhu	r2,16(r2)
811117c0:	10bfffcc 	andi	r2,r2,65535
811117c4:	d8800015 	stw	r2,0(sp)
811117c8:	280f883a 	mov	r7,r5
811117cc:	200d883a 	mov	r6,r4
811117d0:	01604534 	movhi	r5,33044
811117d4:	295c6b04 	addi	r5,r5,29100
811117d8:	1809883a 	mov	r4,r3
811117dc:	111a9600 	call	8111a960 <fprintf>
						#endif

						break;
811117e0:	0001883a 	nop
				}
				break;
811117e4:	0001883a 	nop
			default:
				break;
		}
	}
}
811117e8:	0001883a 	nop
811117ec:	e037883a 	mov	sp,fp
811117f0:	dfc00117 	ldw	ra,4(sp)
811117f4:	df000017 	ldw	fp,0(sp)
811117f8:	dec00204 	addi	sp,sp,8
811117fc:	f800283a 	ret

81111800 <vSendCmdQToNFeeCTRL>:

void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111800:	defff904 	addi	sp,sp,-28
81111804:	de00012e 	bgeu	sp,et,8111180c <vSendCmdQToNFeeCTRL+0xc>
81111808:	003b68fa 	trap	3
8111180c:	dfc00615 	stw	ra,24(sp)
81111810:	df000515 	stw	fp,20(sp)
81111814:	df000504 	addi	fp,sp,20
81111818:	2807883a 	mov	r3,r5
8111181c:	3005883a 	mov	r2,r6
81111820:	e13ffd05 	stb	r4,-12(fp)
81111824:	e0fffe05 	stb	r3,-8(fp)
81111828:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111182c:	00800404 	movi	r2,16
81111830:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111834:	e0bffd03 	ldbu	r2,-12(fp)
81111838:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111183c:	e0bffe03 	ldbu	r2,-8(fp)
81111840:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111844:	e0bfff03 	ldbu	r2,-4(fp)
81111848:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8111184c:	d0a05217 	ldw	r2,-32440(gp)
81111850:	e0fffc17 	ldw	r3,-16(fp)
81111854:	180b883a 	mov	r5,r3
81111858:	1009883a 	mov	r4,r2
8111185c:	1137f4c0 	call	81137f4c <OSQPost>
81111860:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111864:	e0bffb03 	ldbu	r2,-20(fp)
81111868:	10000126 	beq	r2,zero,81111870 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
8111186c:	111788c0 	call	8111788c <vFailSendMsgFeeCTRL>
	}

}
81111870:	0001883a 	nop
81111874:	e037883a 	mov	sp,fp
81111878:	dfc00117 	ldw	ra,4(sp)
8111187c:	df000017 	ldw	fp,0(sp)
81111880:	dec00204 	addi	sp,sp,8
81111884:	f800283a 	ret

81111888 <vSendCmdQToNFeeCTRL_GEN>:

/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111888:	defff804 	addi	sp,sp,-32
8111188c:	de00012e 	bgeu	sp,et,81111894 <vSendCmdQToNFeeCTRL_GEN+0xc>
81111890:	003b68fa 	trap	3
81111894:	dfc00715 	stw	ra,28(sp)
81111898:	df000615 	stw	fp,24(sp)
8111189c:	df000604 	addi	fp,sp,24
811118a0:	2011883a 	mov	r8,r4
811118a4:	2809883a 	mov	r4,r5
811118a8:	3007883a 	mov	r3,r6
811118ac:	3805883a 	mov	r2,r7
811118b0:	e23ffc05 	stb	r8,-16(fp)
811118b4:	e13ffd05 	stb	r4,-12(fp)
811118b8:	e0fffe05 	stb	r3,-8(fp)
811118bc:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
811118c0:	e0bffc03 	ldbu	r2,-16(fp)
811118c4:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811118c8:	e0bffd03 	ldbu	r2,-12(fp)
811118cc:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811118d0:	e0bffe03 	ldbu	r2,-8(fp)
811118d4:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811118d8:	e0bfff03 	ldbu	r2,-4(fp)
811118dc:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811118e0:	d0a05217 	ldw	r2,-32440(gp)
811118e4:	e0fffb17 	ldw	r3,-20(fp)
811118e8:	180b883a 	mov	r5,r3
811118ec:	1009883a 	mov	r4,r2
811118f0:	1137f4c0 	call	81137f4c <OSQPost>
811118f4:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811118f8:	e0bffa03 	ldbu	r2,-24(fp)
811118fc:	10000126 	beq	r2,zero,81111904 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81111900:	111788c0 	call	8111788c <vFailSendMsgFeeCTRL>
	}

}
81111904:	0001883a 	nop
81111908:	e037883a 	mov	sp,fp
8111190c:	dfc00117 	ldw	ra,4(sp)
81111910:	df000017 	ldw	fp,0(sp)
81111914:	dec00204 	addi	sp,sp,8
81111918:	f800283a 	ret

8111191c <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111191c:	defff904 	addi	sp,sp,-28
81111920:	de00012e 	bgeu	sp,et,81111928 <vSendCmdQToDataCTRL+0xc>
81111924:	003b68fa 	trap	3
81111928:	dfc00615 	stw	ra,24(sp)
8111192c:	df000515 	stw	fp,20(sp)
81111930:	df000504 	addi	fp,sp,20
81111934:	2807883a 	mov	r3,r5
81111938:	3005883a 	mov	r2,r6
8111193c:	e13ffd05 	stb	r4,-12(fp)
81111940:	e0fffe05 	stb	r3,-8(fp)
81111944:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81111948:	00800804 	movi	r2,32
8111194c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111950:	e0bffd03 	ldbu	r2,-12(fp)
81111954:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111958:	e0bffe03 	ldbu	r2,-8(fp)
8111195c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111960:	e0bfff03 	ldbu	r2,-4(fp)
81111964:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81111968:	d0a05017 	ldw	r2,-32448(gp)
8111196c:	e0fffc17 	ldw	r3,-16(fp)
81111970:	180b883a 	mov	r5,r3
81111974:	1009883a 	mov	r4,r2
81111978:	1137f4c0 	call	81137f4c <OSQPost>
8111197c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111980:	e0bffb03 	ldbu	r2,-20(fp)
81111984:	10000126 	beq	r2,zero,8111198c <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81111988:	11178d80 	call	811178d8 <vFailSendMsgDataCTRL>
	}

}
8111198c:	0001883a 	nop
81111990:	e037883a 	mov	sp,fp
81111994:	dfc00117 	ldw	ra,4(sp)
81111998:	df000017 	ldw	fp,0(sp)
8111199c:	dec00204 	addi	sp,sp,8
811119a0:	f800283a 	ret

811119a4 <vMebChangeToConfig>:

void vMebChangeToConfig( TSimucam_MEB *pxMebCLocal ) {
811119a4:	defffd04 	addi	sp,sp,-12
811119a8:	de00012e 	bgeu	sp,et,811119b0 <vMebChangeToConfig+0xc>
811119ac:	003b68fa 	trap	3
811119b0:	dfc00215 	stw	ra,8(sp)
811119b4:	df000115 	stw	fp,4(sp)
811119b8:	df000104 	addi	fp,sp,4
811119bc:	e13fff15 	stw	r4,-4(fp)
	vEvtChangeMebMode(pxMebCLocal->eMode, sMebConfig);
811119c0:	e0bfff17 	ldw	r2,-4(fp)
811119c4:	10800117 	ldw	r2,4(r2)
811119c8:	000b883a 	mov	r5,zero
811119cc:	1009883a 	mov	r4,r2
811119d0:	11179700 	call	81117970 <vEvtChangeMebMode>
	pxMebCLocal->eMode = sMebConfig;
811119d4:	e0bfff17 	ldw	r2,-4(fp)
811119d8:	10000115 	stw	zero,4(r2)

/*todo: URGENTE: Passar todos os FEE para modo de configurao  */
/*todo: URGENTE: Data Controller e NFEE COntroller tambm  */

	vSendCmdQToNFeeCTRL( M_NFC_CONFIG, 0, 0 );
811119dc:	000d883a 	mov	r6,zero
811119e0:	000b883a 	mov	r5,zero
811119e4:	01000044 	movi	r4,1
811119e8:	11118000 	call	81111800 <vSendCmdQToNFeeCTRL>
	vSendCmdQToDataCTRL( M_DATA_CONFIG, 0, 0 );
811119ec:	000d883a 	mov	r6,zero
811119f0:	000b883a 	mov	r5,zero
811119f4:	01000044 	movi	r4,1
811119f8:	111191c0 	call	8111191c <vSendCmdQToDataCTRL>

	/*todo: Para a gerao do Sync  */


}
811119fc:	0001883a 	nop
81111a00:	e037883a 	mov	sp,fp
81111a04:	dfc00117 	ldw	ra,4(sp)
81111a08:	df000017 	ldw	fp,0(sp)
81111a0c:	dec00204 	addi	sp,sp,8
81111a10:	f800283a 	ret

81111a14 <vMebChangeToRunning>:

void vMebChangeToRunning( TSimucam_MEB *pxMebCLocal ) {
81111a14:	defffd04 	addi	sp,sp,-12
81111a18:	de00012e 	bgeu	sp,et,81111a20 <vMebChangeToRunning+0xc>
81111a1c:	003b68fa 	trap	3
81111a20:	dfc00215 	stw	ra,8(sp)
81111a24:	df000115 	stw	fp,4(sp)
81111a28:	df000104 	addi	fp,sp,4
81111a2c:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"MEB Task: Changing to RUN Mode\n");
81111a30:	d0a05f17 	ldw	r2,-32388(gp)
81111a34:	100f883a 	mov	r7,r2
81111a38:	018007c4 	movi	r6,31
81111a3c:	01400044 	movi	r5,1
81111a40:	01204534 	movhi	r4,33044
81111a44:	211d1a04 	addi	r4,r4,29800
81111a48:	111affc0 	call	8111affc <fwrite>
	#endif

	vEvtChangeMebMode(pxMebCLocal->eMode, sRun);
81111a4c:	e0bfff17 	ldw	r2,-4(fp)
81111a50:	10800117 	ldw	r2,4(r2)
81111a54:	01400044 	movi	r5,1
81111a58:	1009883a 	mov	r4,r2
81111a5c:	11179700 	call	81117970 <vEvtChangeMebMode>
	pxMebCLocal->eMode = sRun;
81111a60:	e0bfff17 	ldw	r2,-4(fp)
81111a64:	00c00044 	movi	r3,1
81111a68:	10c00115 	stw	r3,4(r2)

	vSendCmdQToNFeeCTRL( M_NFC_RUN, 0, 0 );
81111a6c:	000d883a 	mov	r6,zero
81111a70:	000b883a 	mov	r5,zero
81111a74:	01000084 	movi	r4,2
81111a78:	11118000 	call	81111800 <vSendCmdQToNFeeCTRL>
	vSendCmdQToDataCTRL( M_DATA_RUN, 0, 0 );
81111a7c:	000d883a 	mov	r6,zero
81111a80:	000b883a 	mov	r5,zero
81111a84:	01000084 	movi	r4,2
81111a88:	111191c0 	call	8111191c <vSendCmdQToDataCTRL>


}
81111a8c:	0001883a 	nop
81111a90:	e037883a 	mov	sp,fp
81111a94:	dfc00117 	ldw	ra,4(sp)
81111a98:	df000017 	ldw	fp,0(sp)
81111a9c:	dec00204 	addi	sp,sp,8
81111aa0:	f800283a 	ret

81111aa4 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
81111aa4:	defff804 	addi	sp,sp,-32
81111aa8:	de00012e 	bgeu	sp,et,81111ab0 <vStackMonitor+0xc>
81111aac:	003b68fa 	trap	3
81111ab0:	dfc00715 	stw	ra,28(sp)
81111ab4:	df000615 	stw	fp,24(sp)
81111ab8:	df000604 	addi	fp,sp,24
81111abc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81111ac0:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81111ac4:	d0a05f17 	ldw	r2,-32388(gp)
81111ac8:	100f883a 	mov	r7,r2
81111acc:	018006c4 	movi	r6,27
81111ad0:	01400044 	movi	r5,1
81111ad4:	01204534 	movhi	r4,33044
81111ad8:	211d2204 	addi	r4,r4,29832
81111adc:	111affc0 	call	8111affc <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81111ae0:	d0a05f17 	ldw	r2,-32388(gp)
81111ae4:	100f883a 	mov	r7,r2
81111ae8:	01800b04 	movi	r6,44
81111aec:	01400044 	movi	r5,1
81111af0:	01204534 	movhi	r4,33044
81111af4:	211d2904 	addi	r4,r4,29860
81111af8:	111affc0 	call	8111affc <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81111afc:	d0a05f17 	ldw	r2,-32388(gp)
81111b00:	100f883a 	mov	r7,r2
81111b04:	01800f84 	movi	r6,62
81111b08:	01400044 	movi	r5,1
81111b0c:	01204534 	movhi	r4,33044
81111b10:	211d3504 	addi	r4,r4,29908
81111b14:	111affc0 	call	8111affc <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81111b18:	e0bffd04 	addi	r2,fp,-12
81111b1c:	100b883a 	mov	r5,r2
81111b20:	01000804 	movi	r4,32
81111b24:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111b28:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81111b2c:	e0bffc03 	ldbu	r2,-16(fp)
81111b30:	10000f1e 	bne	r2,zero,81111b70 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111b34:	d1205f17 	ldw	r4,-32388(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81111b38:	e0fffd17 	ldw	r3,-12(fp)
81111b3c:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111b40:	188b883a 	add	r5,r3,r2
81111b44:	e0bffd17 	ldw	r2,-12(fp)
81111b48:	e0fffe17 	ldw	r3,-8(fp)
81111b4c:	d8c00115 	stw	r3,4(sp)
81111b50:	d8800015 	stw	r2,0(sp)
81111b54:	280f883a 	mov	r7,r5
81111b58:	01a04534 	movhi	r6,33044
81111b5c:	319d4504 	addi	r6,r6,29972
81111b60:	01604534 	movhi	r5,33044
81111b64:	295d4904 	addi	r5,r5,29988
81111b68:	111a9600 	call	8111a960 <fprintf>
81111b6c:	00000706 	br	81111b8c <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81111b70:	d0a05f17 	ldw	r2,-32388(gp)
81111b74:	100f883a 	mov	r7,r2
81111b78:	01800904 	movi	r6,36
81111b7c:	01400044 	movi	r5,1
81111b80:	01204534 	movhi	r4,33044
81111b84:	211d5804 	addi	r4,r4,30048
81111b88:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81111b8c:	e0bffd04 	addi	r2,fp,-12
81111b90:	100b883a 	mov	r5,r2
81111b94:	01000784 	movi	r4,30
81111b98:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111b9c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111ba0:	e0bffc03 	ldbu	r2,-16(fp)
81111ba4:	10000f1e 	bne	r2,zero,81111be4 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111ba8:	d1205f17 	ldw	r4,-32388(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81111bac:	e0fffd17 	ldw	r3,-12(fp)
81111bb0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111bb4:	188b883a 	add	r5,r3,r2
81111bb8:	e0bffd17 	ldw	r2,-12(fp)
81111bbc:	e0fffe17 	ldw	r3,-8(fp)
81111bc0:	d8c00115 	stw	r3,4(sp)
81111bc4:	d8800015 	stw	r2,0(sp)
81111bc8:	280f883a 	mov	r7,r5
81111bcc:	01a04534 	movhi	r6,33044
81111bd0:	319d6204 	addi	r6,r6,30088
81111bd4:	01604534 	movhi	r5,33044
81111bd8:	295d4904 	addi	r5,r5,29988
81111bdc:	111a9600 	call	8111a960 <fprintf>
81111be0:	00000706 	br	81111c00 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81111be4:	d0a05f17 	ldw	r2,-32388(gp)
81111be8:	100f883a 	mov	r7,r2
81111bec:	01800984 	movi	r6,38
81111bf0:	01400044 	movi	r5,1
81111bf4:	01204534 	movhi	r4,33044
81111bf8:	211d6604 	addi	r4,r4,30104
81111bfc:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81111c00:	e0bffd04 	addi	r2,fp,-12
81111c04:	100b883a 	mov	r5,r2
81111c08:	01000704 	movi	r4,28
81111c0c:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111c10:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111c14:	e0bffc03 	ldbu	r2,-16(fp)
81111c18:	10000f1e 	bne	r2,zero,81111c58 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111c1c:	d1205f17 	ldw	r4,-32388(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81111c20:	e0fffd17 	ldw	r3,-12(fp)
81111c24:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111c28:	188b883a 	add	r5,r3,r2
81111c2c:	e0bffd17 	ldw	r2,-12(fp)
81111c30:	e0fffe17 	ldw	r3,-8(fp)
81111c34:	d8c00115 	stw	r3,4(sp)
81111c38:	d8800015 	stw	r2,0(sp)
81111c3c:	280f883a 	mov	r7,r5
81111c40:	01a04534 	movhi	r6,33044
81111c44:	319d7004 	addi	r6,r6,30144
81111c48:	01604534 	movhi	r5,33044
81111c4c:	295d4904 	addi	r5,r5,29988
81111c50:	111a9600 	call	8111a960 <fprintf>
81111c54:	00000706 	br	81111c74 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81111c58:	d0a05f17 	ldw	r2,-32388(gp)
81111c5c:	100f883a 	mov	r7,r2
81111c60:	01800884 	movi	r6,34
81111c64:	01400044 	movi	r5,1
81111c68:	01204534 	movhi	r4,33044
81111c6c:	211d7304 	addi	r4,r4,30156
81111c70:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81111c74:	e0bffd04 	addi	r2,fp,-12
81111c78:	100b883a 	mov	r5,r2
81111c7c:	010006c4 	movi	r4,27
81111c80:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111c84:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111c88:	e0bffc03 	ldbu	r2,-16(fp)
81111c8c:	10000f1e 	bne	r2,zero,81111ccc <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111c90:	d1205f17 	ldw	r4,-32388(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81111c94:	e0fffd17 	ldw	r3,-12(fp)
81111c98:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111c9c:	188b883a 	add	r5,r3,r2
81111ca0:	e0bffd17 	ldw	r2,-12(fp)
81111ca4:	e0fffe17 	ldw	r3,-8(fp)
81111ca8:	d8c00115 	stw	r3,4(sp)
81111cac:	d8800015 	stw	r2,0(sp)
81111cb0:	280f883a 	mov	r7,r5
81111cb4:	01a04534 	movhi	r6,33044
81111cb8:	319d7c04 	addi	r6,r6,30192
81111cbc:	01604534 	movhi	r5,33044
81111cc0:	295d4904 	addi	r5,r5,29988
81111cc4:	111a9600 	call	8111a960 <fprintf>
81111cc8:	00000706 	br	81111ce8 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81111ccc:	d0a05f17 	ldw	r2,-32388(gp)
81111cd0:	100f883a 	mov	r7,r2
81111cd4:	018008c4 	movi	r6,35
81111cd8:	01400044 	movi	r5,1
81111cdc:	01204534 	movhi	r4,33044
81111ce0:	211d8004 	addi	r4,r4,30208
81111ce4:	111affc0 	call	8111affc <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81111ce8:	e0bffd04 	addi	r2,fp,-12
81111cec:	100b883a 	mov	r5,r2
81111cf0:	01000684 	movi	r4,26
81111cf4:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111cf8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111cfc:	e0bffc03 	ldbu	r2,-16(fp)
81111d00:	10000f1e 	bne	r2,zero,81111d40 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111d04:	d1205f17 	ldw	r4,-32388(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81111d08:	e0fffd17 	ldw	r3,-12(fp)
81111d0c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111d10:	188b883a 	add	r5,r3,r2
81111d14:	e0bffd17 	ldw	r2,-12(fp)
81111d18:	e0fffe17 	ldw	r3,-8(fp)
81111d1c:	d8c00115 	stw	r3,4(sp)
81111d20:	d8800015 	stw	r2,0(sp)
81111d24:	280f883a 	mov	r7,r5
81111d28:	01a04534 	movhi	r6,33044
81111d2c:	319d8904 	addi	r6,r6,30244
81111d30:	01604534 	movhi	r5,33044
81111d34:	295d4904 	addi	r5,r5,29988
81111d38:	111a9600 	call	8111a960 <fprintf>
81111d3c:	00000706 	br	81111d5c <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81111d40:	d0a05f17 	ldw	r2,-32388(gp)
81111d44:	100f883a 	mov	r7,r2
81111d48:	01800884 	movi	r6,34
81111d4c:	01400044 	movi	r5,1
81111d50:	01204534 	movhi	r4,33044
81111d54:	211d8c04 	addi	r4,r4,30256
81111d58:	111affc0 	call	8111affc <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81111d5c:	e0bffd04 	addi	r2,fp,-12
81111d60:	100b883a 	mov	r5,r2
81111d64:	01000644 	movi	r4,25
81111d68:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111d6c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111d70:	e0bffc03 	ldbu	r2,-16(fp)
81111d74:	10000f1e 	bne	r2,zero,81111db4 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111d78:	d1205f17 	ldw	r4,-32388(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81111d7c:	e0fffd17 	ldw	r3,-12(fp)
81111d80:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111d84:	188b883a 	add	r5,r3,r2
81111d88:	e0bffd17 	ldw	r2,-12(fp)
81111d8c:	e0fffe17 	ldw	r3,-8(fp)
81111d90:	d8c00115 	stw	r3,4(sp)
81111d94:	d8800015 	stw	r2,0(sp)
81111d98:	280f883a 	mov	r7,r5
81111d9c:	01a04534 	movhi	r6,33044
81111da0:	319d9504 	addi	r6,r6,30292
81111da4:	01604534 	movhi	r5,33044
81111da8:	295d4904 	addi	r5,r5,29988
81111dac:	111a9600 	call	8111a960 <fprintf>
81111db0:	00000706 	br	81111dd0 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81111db4:	d0a05f17 	ldw	r2,-32388(gp)
81111db8:	100f883a 	mov	r7,r2
81111dbc:	01800884 	movi	r6,34
81111dc0:	01400044 	movi	r5,1
81111dc4:	01204534 	movhi	r4,33044
81111dc8:	211d9804 	addi	r4,r4,30304
81111dcc:	111affc0 	call	8111affc <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81111dd0:	e0bffd04 	addi	r2,fp,-12
81111dd4:	100b883a 	mov	r5,r2
81111dd8:	01000044 	movi	r4,1
81111ddc:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111de0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111de4:	e0bffc03 	ldbu	r2,-16(fp)
81111de8:	10000f1e 	bne	r2,zero,81111e28 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111dec:	d1205f17 	ldw	r4,-32388(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81111df0:	e0fffd17 	ldw	r3,-12(fp)
81111df4:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111df8:	188b883a 	add	r5,r3,r2
81111dfc:	e0bffd17 	ldw	r2,-12(fp)
81111e00:	e0fffe17 	ldw	r3,-8(fp)
81111e04:	d8c00115 	stw	r3,4(sp)
81111e08:	d8800015 	stw	r2,0(sp)
81111e0c:	280f883a 	mov	r7,r5
81111e10:	01a04534 	movhi	r6,33044
81111e14:	319da104 	addi	r6,r6,30340
81111e18:	01604534 	movhi	r5,33044
81111e1c:	295d4904 	addi	r5,r5,29988
81111e20:	111a9600 	call	8111a960 <fprintf>
81111e24:	00000706 	br	81111e44 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81111e28:	d0a05f17 	ldw	r2,-32388(gp)
81111e2c:	100f883a 	mov	r7,r2
81111e30:	01800804 	movi	r6,32
81111e34:	01400044 	movi	r5,1
81111e38:	01204534 	movhi	r4,33044
81111e3c:	211da404 	addi	r4,r4,30352
81111e40:	111affc0 	call	8111affc <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81111e44:	e0bffd04 	addi	r2,fp,-12
81111e48:	100b883a 	mov	r5,r2
81111e4c:	01000244 	movi	r4,9
81111e50:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111e54:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111e58:	e0bffc03 	ldbu	r2,-16(fp)
81111e5c:	10000f1e 	bne	r2,zero,81111e9c <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111e60:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81111e64:	e0fffd17 	ldw	r3,-12(fp)
81111e68:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111e6c:	188b883a 	add	r5,r3,r2
81111e70:	e0bffd17 	ldw	r2,-12(fp)
81111e74:	e0fffe17 	ldw	r3,-8(fp)
81111e78:	d8c00115 	stw	r3,4(sp)
81111e7c:	d8800015 	stw	r2,0(sp)
81111e80:	280f883a 	mov	r7,r5
81111e84:	01a04534 	movhi	r6,33044
81111e88:	319dad04 	addi	r6,r6,30388
81111e8c:	01604534 	movhi	r5,33044
81111e90:	295d4904 	addi	r5,r5,29988
81111e94:	111a9600 	call	8111a960 <fprintf>
81111e98:	00000706 	br	81111eb8 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81111e9c:	d0a05f17 	ldw	r2,-32388(gp)
81111ea0:	100f883a 	mov	r7,r2
81111ea4:	018008c4 	movi	r6,35
81111ea8:	01400044 	movi	r5,1
81111eac:	01204534 	movhi	r4,33044
81111eb0:	211db004 	addi	r4,r4,30400
81111eb4:	111affc0 	call	8111affc <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81111eb8:	e0bffd04 	addi	r2,fp,-12
81111ebc:	100b883a 	mov	r5,r2
81111ec0:	01000284 	movi	r4,10
81111ec4:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111ec8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111ecc:	e0bffc03 	ldbu	r2,-16(fp)
81111ed0:	10000f1e 	bne	r2,zero,81111f10 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111ed4:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81111ed8:	e0fffd17 	ldw	r3,-12(fp)
81111edc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111ee0:	188b883a 	add	r5,r3,r2
81111ee4:	e0bffd17 	ldw	r2,-12(fp)
81111ee8:	e0fffe17 	ldw	r3,-8(fp)
81111eec:	d8c00115 	stw	r3,4(sp)
81111ef0:	d8800015 	stw	r2,0(sp)
81111ef4:	280f883a 	mov	r7,r5
81111ef8:	01a04534 	movhi	r6,33044
81111efc:	319db904 	addi	r6,r6,30436
81111f00:	01604534 	movhi	r5,33044
81111f04:	295d4904 	addi	r5,r5,29988
81111f08:	111a9600 	call	8111a960 <fprintf>
81111f0c:	00000706 	br	81111f2c <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81111f10:	d0a05f17 	ldw	r2,-32388(gp)
81111f14:	100f883a 	mov	r7,r2
81111f18:	018008c4 	movi	r6,35
81111f1c:	01400044 	movi	r5,1
81111f20:	01204534 	movhi	r4,33044
81111f24:	211dbc04 	addi	r4,r4,30448
81111f28:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81111f2c:	e0bffd04 	addi	r2,fp,-12
81111f30:	100b883a 	mov	r5,r2
81111f34:	010002c4 	movi	r4,11
81111f38:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111f3c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111f40:	e0bffc03 	ldbu	r2,-16(fp)
81111f44:	10000f1e 	bne	r2,zero,81111f84 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111f48:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81111f4c:	e0fffd17 	ldw	r3,-12(fp)
81111f50:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111f54:	188b883a 	add	r5,r3,r2
81111f58:	e0bffd17 	ldw	r2,-12(fp)
81111f5c:	e0fffe17 	ldw	r3,-8(fp)
81111f60:	d8c00115 	stw	r3,4(sp)
81111f64:	d8800015 	stw	r2,0(sp)
81111f68:	280f883a 	mov	r7,r5
81111f6c:	01a04534 	movhi	r6,33044
81111f70:	319dc504 	addi	r6,r6,30484
81111f74:	01604534 	movhi	r5,33044
81111f78:	295d4904 	addi	r5,r5,29988
81111f7c:	111a9600 	call	8111a960 <fprintf>
81111f80:	00000706 	br	81111fa0 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81111f84:	d0a05f17 	ldw	r2,-32388(gp)
81111f88:	100f883a 	mov	r7,r2
81111f8c:	018008c4 	movi	r6,35
81111f90:	01400044 	movi	r5,1
81111f94:	01204534 	movhi	r4,33044
81111f98:	211dc804 	addi	r4,r4,30496
81111f9c:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81111fa0:	e0bffd04 	addi	r2,fp,-12
81111fa4:	100b883a 	mov	r5,r2
81111fa8:	01000304 	movi	r4,12
81111fac:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81111fb0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81111fb4:	e0bffc03 	ldbu	r2,-16(fp)
81111fb8:	10000f1e 	bne	r2,zero,81111ff8 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111fbc:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81111fc0:	e0fffd17 	ldw	r3,-12(fp)
81111fc4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81111fc8:	188b883a 	add	r5,r3,r2
81111fcc:	e0bffd17 	ldw	r2,-12(fp)
81111fd0:	e0fffe17 	ldw	r3,-8(fp)
81111fd4:	d8c00115 	stw	r3,4(sp)
81111fd8:	d8800015 	stw	r2,0(sp)
81111fdc:	280f883a 	mov	r7,r5
81111fe0:	01a04534 	movhi	r6,33044
81111fe4:	319dd104 	addi	r6,r6,30532
81111fe8:	01604534 	movhi	r5,33044
81111fec:	295d4904 	addi	r5,r5,29988
81111ff0:	111a9600 	call	8111a960 <fprintf>
81111ff4:	00000706 	br	81112014 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81111ff8:	d0a05f17 	ldw	r2,-32388(gp)
81111ffc:	100f883a 	mov	r7,r2
81112000:	018008c4 	movi	r6,35
81112004:	01400044 	movi	r5,1
81112008:	01204534 	movhi	r4,33044
8111200c:	211dd404 	addi	r4,r4,30544
81112010:	111affc0 	call	8111affc <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81112014:	e0bffd04 	addi	r2,fp,-12
81112018:	100b883a 	mov	r5,r2
8111201c:	01000344 	movi	r4,13
81112020:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81112024:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112028:	e0bffc03 	ldbu	r2,-16(fp)
8111202c:	10000f1e 	bne	r2,zero,8111206c <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112030:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81112034:	e0fffd17 	ldw	r3,-12(fp)
81112038:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111203c:	188b883a 	add	r5,r3,r2
81112040:	e0bffd17 	ldw	r2,-12(fp)
81112044:	e0fffe17 	ldw	r3,-8(fp)
81112048:	d8c00115 	stw	r3,4(sp)
8111204c:	d8800015 	stw	r2,0(sp)
81112050:	280f883a 	mov	r7,r5
81112054:	01a04534 	movhi	r6,33044
81112058:	319ddd04 	addi	r6,r6,30580
8111205c:	01604534 	movhi	r5,33044
81112060:	295d4904 	addi	r5,r5,29988
81112064:	111a9600 	call	8111a960 <fprintf>
81112068:	00000706 	br	81112088 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
8111206c:	d0a05f17 	ldw	r2,-32388(gp)
81112070:	100f883a 	mov	r7,r2
81112074:	018008c4 	movi	r6,35
81112078:	01400044 	movi	r5,1
8111207c:	01204534 	movhi	r4,33044
81112080:	211de004 	addi	r4,r4,30592
81112084:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81112088:	e0bffd04 	addi	r2,fp,-12
8111208c:	100b883a 	mov	r5,r2
81112090:	01000384 	movi	r4,14
81112094:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81112098:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111209c:	e0bffc03 	ldbu	r2,-16(fp)
811120a0:	10000f1e 	bne	r2,zero,811120e0 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811120a4:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
811120a8:	e0fffd17 	ldw	r3,-12(fp)
811120ac:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811120b0:	188b883a 	add	r5,r3,r2
811120b4:	e0bffd17 	ldw	r2,-12(fp)
811120b8:	e0fffe17 	ldw	r3,-8(fp)
811120bc:	d8c00115 	stw	r3,4(sp)
811120c0:	d8800015 	stw	r2,0(sp)
811120c4:	280f883a 	mov	r7,r5
811120c8:	01a04534 	movhi	r6,33044
811120cc:	319de904 	addi	r6,r6,30628
811120d0:	01604534 	movhi	r5,33044
811120d4:	295d4904 	addi	r5,r5,29988
811120d8:	111a9600 	call	8111a960 <fprintf>
811120dc:	00000706 	br	811120fc <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
811120e0:	d0a05f17 	ldw	r2,-32388(gp)
811120e4:	100f883a 	mov	r7,r2
811120e8:	018008c4 	movi	r6,35
811120ec:	01400044 	movi	r5,1
811120f0:	01204534 	movhi	r4,33044
811120f4:	211dec04 	addi	r4,r4,30640
811120f8:	111affc0 	call	8111affc <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
811120fc:	e0bffd04 	addi	r2,fp,-12
81112100:	100b883a 	mov	r5,r2
81112104:	01000204 	movi	r4,8
81112108:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
8111210c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112110:	e0bffc03 	ldbu	r2,-16(fp)
81112114:	10000f1e 	bne	r2,zero,81112154 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112118:	d1205f17 	ldw	r4,-32388(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
8111211c:	e0fffd17 	ldw	r3,-12(fp)
81112120:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112124:	188b883a 	add	r5,r3,r2
81112128:	e0bffd17 	ldw	r2,-12(fp)
8111212c:	e0fffe17 	ldw	r3,-8(fp)
81112130:	d8c00115 	stw	r3,4(sp)
81112134:	d8800015 	stw	r2,0(sp)
81112138:	280f883a 	mov	r7,r5
8111213c:	01a04534 	movhi	r6,33044
81112140:	319df504 	addi	r6,r6,30676
81112144:	01604534 	movhi	r5,33044
81112148:	295d4904 	addi	r5,r5,29988
8111214c:	111a9600 	call	8111a960 <fprintf>
81112150:	00000706 	br	81112170 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81112154:	d0a05f17 	ldw	r2,-32388(gp)
81112158:	100f883a 	mov	r7,r2
8111215c:	01800884 	movi	r6,34
81112160:	01400044 	movi	r5,1
81112164:	01204534 	movhi	r4,33044
81112168:	211df804 	addi	r4,r4,30688
8111216c:	111affc0 	call	8111affc <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81112170:	e0bffd04 	addi	r2,fp,-12
81112174:	100b883a 	mov	r5,r2
81112178:	010001c4 	movi	r4,7
8111217c:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81112180:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81112184:	e0bffc03 	ldbu	r2,-16(fp)
81112188:	10000f1e 	bne	r2,zero,811121c8 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111218c:	d1205f17 	ldw	r4,-32388(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81112190:	e0fffd17 	ldw	r3,-12(fp)
81112194:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112198:	188b883a 	add	r5,r3,r2
8111219c:	e0bffd17 	ldw	r2,-12(fp)
811121a0:	e0fffe17 	ldw	r3,-8(fp)
811121a4:	d8c00115 	stw	r3,4(sp)
811121a8:	d8800015 	stw	r2,0(sp)
811121ac:	280f883a 	mov	r7,r5
811121b0:	01a04534 	movhi	r6,33044
811121b4:	319e0104 	addi	r6,r6,30724
811121b8:	01604534 	movhi	r5,33044
811121bc:	295d4904 	addi	r5,r5,29988
811121c0:	111a9600 	call	8111a960 <fprintf>
811121c4:	00000706 	br	811121e4 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
811121c8:	d0a05f17 	ldw	r2,-32388(gp)
811121cc:	100f883a 	mov	r7,r2
811121d0:	01800844 	movi	r6,33
811121d4:	01400044 	movi	r5,1
811121d8:	01204534 	movhi	r4,33044
811121dc:	211e0404 	addi	r4,r4,30736
811121e0:	111affc0 	call	8111affc <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
811121e4:	e0bffd04 	addi	r2,fp,-12
811121e8:	100b883a 	mov	r5,r2
811121ec:	01000184 	movi	r4,6
811121f0:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
811121f4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811121f8:	e0bffc03 	ldbu	r2,-16(fp)
811121fc:	10000f1e 	bne	r2,zero,8111223c <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81112200:	d1205f17 	ldw	r4,-32388(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81112204:	e0fffd17 	ldw	r3,-12(fp)
81112208:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111220c:	188b883a 	add	r5,r3,r2
81112210:	e0bffd17 	ldw	r2,-12(fp)
81112214:	e0fffe17 	ldw	r3,-8(fp)
81112218:	d8c00115 	stw	r3,4(sp)
8111221c:	d8800015 	stw	r2,0(sp)
81112220:	280f883a 	mov	r7,r5
81112224:	01a04534 	movhi	r6,33044
81112228:	319e0d04 	addi	r6,r6,30772
8111222c:	01604534 	movhi	r5,33044
81112230:	295d4904 	addi	r5,r5,29988
81112234:	111a9600 	call	8111a960 <fprintf>
81112238:	00000706 	br	81112258 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
8111223c:	d0a05f17 	ldw	r2,-32388(gp)
81112240:	100f883a 	mov	r7,r2
81112244:	018007c4 	movi	r6,31
81112248:	01400044 	movi	r5,1
8111224c:	01204534 	movhi	r4,33044
81112250:	211e1004 	addi	r4,r4,30784
81112254:	111affc0 	call	8111affc <fwrite>
    	}		


    	fprintf(fp, "\n" );
81112258:	d0a05f17 	ldw	r2,-32388(gp)
8111225c:	100b883a 	mov	r5,r2
81112260:	01000284 	movi	r4,10
81112264:	111a9d80 	call	8111a9d8 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81112268:	000f883a 	mov	r7,zero
8111226c:	01800284 	movi	r6,10
81112270:	000b883a 	mov	r5,zero
81112274:	0009883a 	mov	r4,zero
81112278:	113a8200 	call	8113a820 <OSTimeDlyHMSM>
    }
8111227c:	003e1806 	br	81111ae0 <__reset+0xfb0f1ae0>

81112280 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81112280:	defffc04 	addi	sp,sp,-16
81112284:	de00012e 	bgeu	sp,et,8111228c <vTimeoutCheckerTaskv2+0xc>
81112288:	003b68fa 	trap	3
8111228c:	dfc00315 	stw	ra,12(sp)
81112290:	df000215 	stw	fp,8(sp)
81112294:	df000204 	addi	fp,sp,8
81112298:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
8111229c:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
811122a0:	d0a05f17 	ldw	r2,-32388(gp)
811122a4:	100f883a 	mov	r7,r2
811122a8:	01800844 	movi	r6,33
811122ac:	01400044 	movi	r5,1
811122b0:	01204534 	movhi	r4,33044
811122b4:	211e1804 	addi	r4,r4,30816
811122b8:	111affc0 	call	8111affc <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
811122bc:	d0a06417 	ldw	r2,-32368(gp)
811122c0:	e1bffe04 	addi	r6,fp,-8
811122c4:	000b883a 	mov	r5,zero
811122c8:	1009883a 	mov	r4,r2
811122cc:	1138a3c0 	call	81138a3c <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
811122d0:	e0bffe03 	ldbu	r2,-8(fp)
811122d4:	10803fcc 	andi	r2,r2,255
811122d8:	1000021e 	bne	r2,zero,811122e4 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
811122dc:	11122ec0 	call	811122ec <vCheck>
811122e0:	003ff606 	br	811122bc <__reset+0xfb0f22bc>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
811122e4:	1116af40 	call	81116af4 <vFailGetBlockingSemTimeoutTask>
        }
    }
811122e8:	003ff406 	br	811122bc <__reset+0xfb0f22bc>

811122ec <vCheck>:
}


void vCheck( void ) {
811122ec:	defffd04 	addi	sp,sp,-12
811122f0:	de00012e 	bgeu	sp,et,811122f8 <vCheck+0xc>
811122f4:	003b68fa 	trap	3
811122f8:	dfc00215 	stw	ra,8(sp)
811122fc:	df000115 	stw	fp,4(sp)
81112300:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81112304:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81112308:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
8111230c:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81112310:	d0a06a03 	ldbu	r2,-32344(gp)
81112314:	10803fcc 	andi	r2,r2,255
81112318:	10800218 	cmpnei	r2,r2,8
8111231c:	1000021e 	bne	r2,zero,81112328 <vCheck+0x3c>
81112320:	00c00104 	movi	r3,4
81112324:	00000106 	br	8111232c <vCheck+0x40>
81112328:	0007883a 	mov	r3,zero
8111232c:	d0a07803 	ldbu	r2,-32288(gp)
81112330:	10803fcc 	andi	r2,r2,255
81112334:	10800218 	cmpnei	r2,r2,8
81112338:	1000021e 	bne	r2,zero,81112344 <vCheck+0x58>
8111233c:	00800084 	movi	r2,2
81112340:	00000106 	br	81112348 <vCheck+0x5c>
81112344:	0005883a 	mov	r2,zero
81112348:	1884b03a 	or	r2,r3,r2
8111234c:	1007883a 	mov	r3,r2
81112350:	d0a07843 	ldbu	r2,-32287(gp)
81112354:	10803fcc 	andi	r2,r2,255
81112358:	108001a0 	cmpeqi	r2,r2,6
8111235c:	1884b03a 	or	r2,r3,r2
81112360:	1007883a 	mov	r3,r2
81112364:	e0bfff03 	ldbu	r2,-4(fp)
81112368:	1884b03a 	or	r2,r3,r2
8111236c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81112370:	e0bfff03 	ldbu	r2,-4(fp)
81112374:	108001d8 	cmpnei	r2,r2,7
81112378:	10003726 	beq	r2,zero,81112458 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
8111237c:	d0a07717 	ldw	r2,-32292(gp)
81112380:	e0ffff44 	addi	r3,fp,-3
81112384:	180d883a 	mov	r6,r3
81112388:	000b883a 	mov	r5,zero
8111238c:	1009883a 	mov	r4,r2
81112390:	1136a300 	call	81136a30 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81112394:	e0bfff43 	ldbu	r2,-3(fp)
81112398:	10803fcc 	andi	r2,r2,255
8111239c:	10000826 	beq	r2,zero,811123c0 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
811123a0:	d0a05f17 	ldw	r2,-32388(gp)
811123a4:	100f883a 	mov	r7,r2
811123a8:	01800f04 	movi	r6,60
811123ac:	01400044 	movi	r5,1
811123b0:	01204534 	movhi	r4,33044
811123b4:	211e2104 	addi	r4,r4,30852
811123b8:	111affc0 	call	8111affc <fwrite>
		#endif
        return;
811123bc:	00002706 	br	8111245c <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
811123c0:	e0bfff03 	ldbu	r2,-4(fp)
811123c4:	1080004c 	andi	r2,r2,1
811123c8:	10803fcc 	andi	r2,r2,255
811123cc:	1000021e 	bne	r2,zero,811123d8 <vCheck+0xec>
        vCheckRetransmission128();
811123d0:	11124700 	call	81112470 <vCheckRetransmission128>
811123d4:	00000506 	br	811123ec <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
811123d8:	01800604 	movi	r6,24
811123dc:	000b883a 	mov	r5,zero
811123e0:	01204574 	movhi	r4,33045
811123e4:	211ef704 	addi	r4,r4,31708
811123e8:	111bb600 	call	8111bb60 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
811123ec:	e0bfff03 	ldbu	r2,-4(fp)
811123f0:	1080008c 	andi	r2,r2,2
811123f4:	10803fcc 	andi	r2,r2,255
811123f8:	1000021e 	bne	r2,zero,81112404 <vCheck+0x118>
        vCheckRetransmission64();
811123fc:	11126f40 	call	811126f4 <vCheckRetransmission64>
81112400:	00000506 	br	81112418 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81112404:	01800804 	movi	r6,32
81112408:	000b883a 	mov	r5,zero
8111240c:	01204574 	movhi	r4,33045
81112410:	211efd04 	addi	r4,r4,31732
81112414:	111bb600 	call	8111bb60 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81112418:	e0bfff03 	ldbu	r2,-4(fp)
8111241c:	1080010c 	andi	r2,r2,4
81112420:	10803fcc 	andi	r2,r2,255
81112424:	1000021e 	bne	r2,zero,81112430 <vCheck+0x144>
        vCheckRetransmission32();
81112428:	11129800 	call	81112980 <vCheckRetransmission32>
8111242c:	00000506 	br	81112444 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81112430:	01800804 	movi	r6,32
81112434:	000b883a 	mov	r5,zero
81112438:	01204574 	movhi	r4,33045
8111243c:	211f0504 	addi	r4,r4,31764
81112440:	111bb600 	call	8111bb60 <memset>


    OSMutexPost(xTxUARTMutex);
81112444:	d0a07717 	ldw	r2,-32292(gp)
81112448:	1009883a 	mov	r4,r2
8111244c:	1136fd40 	call	81136fd4 <OSMutexPost>

    return;
81112450:	0001883a 	nop
81112454:	00000106 	br	8111245c <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81112458:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
8111245c:	e037883a 	mov	sp,fp
81112460:	dfc00117 	ldw	ra,4(sp)
81112464:	df000017 	ldw	fp,0(sp)
81112468:	dec00204 	addi	sp,sp,8
8111246c:	f800283a 	ret

81112470 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81112470:	defffd04 	addi	sp,sp,-12
81112474:	de00012e 	bgeu	sp,et,8111247c <vCheckRetransmission128+0xc>
81112478:	003b68fa 	trap	3
8111247c:	dfc00215 	stw	ra,8(sp)
81112480:	df000115 	stw	fp,4(sp)
81112484:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81112488:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8111248c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112490:	d0a07217 	ldw	r2,-32312(gp)
81112494:	e0ffff44 	addi	r3,fp,-3
81112498:	180b883a 	mov	r5,r3
8111249c:	1009883a 	mov	r4,r2
811124a0:	11363b00 	call	811363b0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811124a4:	e0bfff43 	ldbu	r2,-3(fp)
811124a8:	10803fcc 	andi	r2,r2,255
811124ac:	10008b1e 	bne	r2,zero,811126dc <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811124b0:	e03fff05 	stb	zero,-4(fp)
811124b4:	00008106 	br	811126bc <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
811124b8:	e0ffff03 	ldbu	r3,-4(fp)
811124bc:	00a04574 	movhi	r2,33045
811124c0:	109ef704 	addi	r2,r2,31708
811124c4:	18c7883a 	add	r3,r3,r3
811124c8:	18c7883a 	add	r3,r3,r3
811124cc:	10c5883a 	add	r2,r2,r3
811124d0:	10800017 	ldw	r2,0(r2)
811124d4:	10800058 	cmpnei	r2,r2,1
811124d8:	1000751e 	bne	r2,zero,811126b0 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
811124dc:	e0ffff03 	ldbu	r3,-4(fp)
811124e0:	00a04574 	movhi	r2,33045
811124e4:	109f1504 	addi	r2,r2,31828
811124e8:	18c02324 	muli	r3,r3,140
811124ec:	10c5883a 	add	r2,r2,r3
811124f0:	10802004 	addi	r2,r2,128
811124f4:	10800017 	ldw	r2,0(r2)
811124f8:	10800058 	cmpnei	r2,r2,1
811124fc:	1000211e 	bne	r2,zero,81112584 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112500:	e0ffff03 	ldbu	r3,-4(fp)
81112504:	00a04574 	movhi	r2,33045
81112508:	109f1504 	addi	r2,r2,31828
8111250c:	19002324 	muli	r4,r3,140
81112510:	1105883a 	add	r2,r2,r4
81112514:	10802184 	addi	r2,r2,134
81112518:	1080000b 	ldhu	r2,0(r2)
8111251c:	10800044 	addi	r2,r2,1
81112520:	100b883a 	mov	r5,r2
81112524:	00a04574 	movhi	r2,33045
81112528:	109f1504 	addi	r2,r2,31828
8111252c:	19002324 	muli	r4,r3,140
81112530:	1105883a 	add	r2,r2,r4
81112534:	10802184 	addi	r2,r2,134
81112538:	1140000d 	sth	r5,0(r2)
8111253c:	00a04574 	movhi	r2,33045
81112540:	109f1504 	addi	r2,r2,31828
81112544:	18c02324 	muli	r3,r3,140
81112548:	10c5883a 	add	r2,r2,r3
8111254c:	10802184 	addi	r2,r2,134
81112550:	1080000b 	ldhu	r2,0(r2)
81112554:	10bfffcc 	andi	r2,r2,65535
81112558:	10a0001c 	xori	r2,r2,32768
8111255c:	10a00004 	addi	r2,r2,-32768
81112560:	10800090 	cmplti	r2,r2,2
81112564:	1000071e 	bne	r2,zero,81112584 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81112568:	e0ffff03 	ldbu	r3,-4(fp)
8111256c:	00a04574 	movhi	r2,33045
81112570:	109f1504 	addi	r2,r2,31828
81112574:	18c02324 	muli	r3,r3,140
81112578:	10c5883a 	add	r2,r2,r3
8111257c:	10802004 	addi	r2,r2,128
81112580:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81112584:	e0ffff03 	ldbu	r3,-4(fp)
81112588:	00a04574 	movhi	r2,33045
8111258c:	109f1504 	addi	r2,r2,31828
81112590:	18c02324 	muli	r3,r3,140
81112594:	10c5883a 	add	r2,r2,r3
81112598:	10802004 	addi	r2,r2,128
8111259c:	10800017 	ldw	r2,0(r2)
811125a0:	1000431e 	bne	r2,zero,811126b0 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
811125a4:	e0bfff03 	ldbu	r2,-4(fp)
811125a8:	10c02324 	muli	r3,r2,140
811125ac:	00a04574 	movhi	r2,33045
811125b0:	109f1504 	addi	r2,r2,31828
811125b4:	1885883a 	add	r2,r3,r2
811125b8:	1009883a 	mov	r4,r2
811125bc:	111bfac0 	call	8111bfac <puts>
                xBuffer128[ucIL].bSent = TRUE;
811125c0:	e0ffff03 	ldbu	r3,-4(fp)
811125c4:	00a04574 	movhi	r2,33045
811125c8:	109f1504 	addi	r2,r2,31828
811125cc:	18c02324 	muli	r3,r3,140
811125d0:	10c5883a 	add	r2,r2,r3
811125d4:	10802004 	addi	r2,r2,128
811125d8:	00c00044 	movi	r3,1
811125dc:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
811125e0:	e0ffff03 	ldbu	r3,-4(fp)
811125e4:	00a04574 	movhi	r2,33045
811125e8:	109f1504 	addi	r2,r2,31828
811125ec:	18c02324 	muli	r3,r3,140
811125f0:	10c5883a 	add	r2,r2,r3
811125f4:	10802184 	addi	r2,r2,134
811125f8:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
811125fc:	e0ffff03 	ldbu	r3,-4(fp)
81112600:	00a04574 	movhi	r2,33045
81112604:	109f1504 	addi	r2,r2,31828
81112608:	19002324 	muli	r4,r3,140
8111260c:	1105883a 	add	r2,r2,r4
81112610:	10802204 	addi	r2,r2,136
81112614:	10800003 	ldbu	r2,0(r2)
81112618:	10800044 	addi	r2,r2,1
8111261c:	100b883a 	mov	r5,r2
81112620:	00a04574 	movhi	r2,33045
81112624:	109f1504 	addi	r2,r2,31828
81112628:	19002324 	muli	r4,r3,140
8111262c:	1105883a 	add	r2,r2,r4
81112630:	10802204 	addi	r2,r2,136
81112634:	11400005 	stb	r5,0(r2)
81112638:	00a04574 	movhi	r2,33045
8111263c:	109f1504 	addi	r2,r2,31828
81112640:	18c02324 	muli	r3,r3,140
81112644:	10c5883a 	add	r2,r2,r3
81112648:	10802204 	addi	r2,r2,136
8111264c:	10800003 	ldbu	r2,0(r2)
81112650:	10803fcc 	andi	r2,r2,255
81112654:	108000b0 	cmpltui	r2,r2,2
81112658:	1000151e 	bne	r2,zero,811126b0 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
8111265c:	e0ffff03 	ldbu	r3,-4(fp)
81112660:	00a04574 	movhi	r2,33045
81112664:	109ef704 	addi	r2,r2,31708
81112668:	18c7883a 	add	r3,r3,r3
8111266c:	18c7883a 	add	r3,r3,r3
81112670:	10c5883a 	add	r2,r2,r3
81112674:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81112678:	d0a07843 	ldbu	r2,-32287(gp)
8111267c:	10800044 	addi	r2,r2,1
81112680:	d0a07845 	stb	r2,-32287(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81112684:	d0a06017 	ldw	r2,-32384(gp)
81112688:	1009883a 	mov	r4,r2
8111268c:	1138dc40 	call	81138dc4 <OSSemPost>
81112690:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112694:	e0bfff43 	ldbu	r2,-3(fp)
81112698:	10803fcc 	andi	r2,r2,255
8111269c:	10000426 	beq	r2,zero,811126b0 <vCheckRetransmission128+0x240>
                        SemCount128--;
811126a0:	d0a07843 	ldbu	r2,-32287(gp)
811126a4:	10bfffc4 	addi	r2,r2,-1
811126a8:	d0a07845 	stb	r2,-32287(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811126ac:	11163e40 	call	811163e4 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811126b0:	e0bfff03 	ldbu	r2,-4(fp)
811126b4:	10800044 	addi	r2,r2,1
811126b8:	e0bfff05 	stb	r2,-4(fp)
811126bc:	e0bfff03 	ldbu	r2,-4(fp)
811126c0:	108001b0 	cmpltui	r2,r2,6
811126c4:	103f7c1e 	bne	r2,zero,811124b8 <__reset+0xfb0f24b8>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
811126c8:	d0a07217 	ldw	r2,-32312(gp)
811126cc:	1009883a 	mov	r4,r2
811126d0:	1136fd40 	call	81136fd4 <OSMutexPost>

    return;
811126d4:	0001883a 	nop
811126d8:	00000106 	br	811126e0 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811126dc:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
811126e0:	e037883a 	mov	sp,fp
811126e4:	dfc00117 	ldw	ra,4(sp)
811126e8:	df000017 	ldw	fp,0(sp)
811126ec:	dec00204 	addi	sp,sp,8
811126f0:	f800283a 	ret

811126f4 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
811126f4:	defffd04 	addi	sp,sp,-12
811126f8:	de00012e 	bgeu	sp,et,81112700 <vCheckRetransmission64+0xc>
811126fc:	003b68fa 	trap	3
81112700:	dfc00215 	stw	ra,8(sp)
81112704:	df000115 	stw	fp,4(sp)
81112708:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8111270c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81112710:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112714:	d0a07417 	ldw	r2,-32304(gp)
81112718:	e0ffff44 	addi	r3,fp,-3
8111271c:	180b883a 	mov	r5,r3
81112720:	1009883a 	mov	r4,r2
81112724:	11363b00 	call	811363b0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81112728:	e0bfff43 	ldbu	r2,-3(fp)
8111272c:	10803fcc 	andi	r2,r2,255
81112730:	10008d1e 	bne	r2,zero,81112968 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81112734:	e03fff05 	stb	zero,-4(fp)
81112738:	00008306 	br	81112948 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
8111273c:	e0ffff03 	ldbu	r3,-4(fp)
81112740:	00a04574 	movhi	r2,33045
81112744:	109ef704 	addi	r2,r2,31708
81112748:	18c00184 	addi	r3,r3,6
8111274c:	18c7883a 	add	r3,r3,r3
81112750:	18c7883a 	add	r3,r3,r3
81112754:	10c5883a 	add	r2,r2,r3
81112758:	10800017 	ldw	r2,0(r2)
8111275c:	10800058 	cmpnei	r2,r2,1
81112760:	1000761e 	bne	r2,zero,8111293c <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81112764:	e0ffff03 	ldbu	r3,-4(fp)
81112768:	00a04574 	movhi	r2,33045
8111276c:	10bae904 	addi	r2,r2,-5212
81112770:	18c01324 	muli	r3,r3,76
81112774:	10c5883a 	add	r2,r2,r3
81112778:	10801004 	addi	r2,r2,64
8111277c:	10800017 	ldw	r2,0(r2)
81112780:	10800058 	cmpnei	r2,r2,1
81112784:	1000211e 	bne	r2,zero,8111280c <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112788:	e0ffff03 	ldbu	r3,-4(fp)
8111278c:	00a04574 	movhi	r2,33045
81112790:	10bae904 	addi	r2,r2,-5212
81112794:	19001324 	muli	r4,r3,76
81112798:	1105883a 	add	r2,r2,r4
8111279c:	10801184 	addi	r2,r2,70
811127a0:	1080000b 	ldhu	r2,0(r2)
811127a4:	10800044 	addi	r2,r2,1
811127a8:	100b883a 	mov	r5,r2
811127ac:	00a04574 	movhi	r2,33045
811127b0:	10bae904 	addi	r2,r2,-5212
811127b4:	19001324 	muli	r4,r3,76
811127b8:	1105883a 	add	r2,r2,r4
811127bc:	10801184 	addi	r2,r2,70
811127c0:	1140000d 	sth	r5,0(r2)
811127c4:	00a04574 	movhi	r2,33045
811127c8:	10bae904 	addi	r2,r2,-5212
811127cc:	18c01324 	muli	r3,r3,76
811127d0:	10c5883a 	add	r2,r2,r3
811127d4:	10801184 	addi	r2,r2,70
811127d8:	1080000b 	ldhu	r2,0(r2)
811127dc:	10bfffcc 	andi	r2,r2,65535
811127e0:	10a0001c 	xori	r2,r2,32768
811127e4:	10a00004 	addi	r2,r2,-32768
811127e8:	10800090 	cmplti	r2,r2,2
811127ec:	1000071e 	bne	r2,zero,8111280c <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
811127f0:	e0ffff03 	ldbu	r3,-4(fp)
811127f4:	00a04574 	movhi	r2,33045
811127f8:	10bae904 	addi	r2,r2,-5212
811127fc:	18c01324 	muli	r3,r3,76
81112800:	10c5883a 	add	r2,r2,r3
81112804:	10801004 	addi	r2,r2,64
81112808:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8111280c:	e0ffff03 	ldbu	r3,-4(fp)
81112810:	00a04574 	movhi	r2,33045
81112814:	10bae904 	addi	r2,r2,-5212
81112818:	18c01324 	muli	r3,r3,76
8111281c:	10c5883a 	add	r2,r2,r3
81112820:	10801004 	addi	r2,r2,64
81112824:	10800017 	ldw	r2,0(r2)
81112828:	1000441e 	bne	r2,zero,8111293c <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8111282c:	e0bfff03 	ldbu	r2,-4(fp)
81112830:	10c01324 	muli	r3,r2,76
81112834:	00a04574 	movhi	r2,33045
81112838:	10bae904 	addi	r2,r2,-5212
8111283c:	1885883a 	add	r2,r3,r2
81112840:	1009883a 	mov	r4,r2
81112844:	111bfac0 	call	8111bfac <puts>
                xBuffer64[ucIL].bSent = TRUE;
81112848:	e0ffff03 	ldbu	r3,-4(fp)
8111284c:	00a04574 	movhi	r2,33045
81112850:	10bae904 	addi	r2,r2,-5212
81112854:	18c01324 	muli	r3,r3,76
81112858:	10c5883a 	add	r2,r2,r3
8111285c:	10801004 	addi	r2,r2,64
81112860:	00c00044 	movi	r3,1
81112864:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81112868:	e0ffff03 	ldbu	r3,-4(fp)
8111286c:	00a04574 	movhi	r2,33045
81112870:	10bae904 	addi	r2,r2,-5212
81112874:	18c01324 	muli	r3,r3,76
81112878:	10c5883a 	add	r2,r2,r3
8111287c:	10801184 	addi	r2,r2,70
81112880:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81112884:	e0ffff03 	ldbu	r3,-4(fp)
81112888:	00a04574 	movhi	r2,33045
8111288c:	10bae904 	addi	r2,r2,-5212
81112890:	19001324 	muli	r4,r3,76
81112894:	1105883a 	add	r2,r2,r4
81112898:	10801204 	addi	r2,r2,72
8111289c:	10800003 	ldbu	r2,0(r2)
811128a0:	10800044 	addi	r2,r2,1
811128a4:	100b883a 	mov	r5,r2
811128a8:	00a04574 	movhi	r2,33045
811128ac:	10bae904 	addi	r2,r2,-5212
811128b0:	19001324 	muli	r4,r3,76
811128b4:	1105883a 	add	r2,r2,r4
811128b8:	10801204 	addi	r2,r2,72
811128bc:	11400005 	stb	r5,0(r2)
811128c0:	00a04574 	movhi	r2,33045
811128c4:	10bae904 	addi	r2,r2,-5212
811128c8:	18c01324 	muli	r3,r3,76
811128cc:	10c5883a 	add	r2,r2,r3
811128d0:	10801204 	addi	r2,r2,72
811128d4:	10800003 	ldbu	r2,0(r2)
811128d8:	10803fcc 	andi	r2,r2,255
811128dc:	108000b0 	cmpltui	r2,r2,2
811128e0:	1000161e 	bne	r2,zero,8111293c <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
811128e4:	e0ffff03 	ldbu	r3,-4(fp)
811128e8:	00a04574 	movhi	r2,33045
811128ec:	109ef704 	addi	r2,r2,31708
811128f0:	18c00184 	addi	r3,r3,6
811128f4:	18c7883a 	add	r3,r3,r3
811128f8:	18c7883a 	add	r3,r3,r3
811128fc:	10c5883a 	add	r2,r2,r3
81112900:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81112904:	d0a07803 	ldbu	r2,-32288(gp)
81112908:	10800044 	addi	r2,r2,1
8111290c:	d0a07805 	stb	r2,-32288(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81112910:	d0a05a17 	ldw	r2,-32408(gp)
81112914:	1009883a 	mov	r4,r2
81112918:	1138dc40 	call	81138dc4 <OSSemPost>
8111291c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112920:	e0bfff43 	ldbu	r2,-3(fp)
81112924:	10803fcc 	andi	r2,r2,255
81112928:	10000426 	beq	r2,zero,8111293c <vCheckRetransmission64+0x248>
                        SemCount64--;
8111292c:	d0a07803 	ldbu	r2,-32288(gp)
81112930:	10bfffc4 	addi	r2,r2,-1
81112934:	d0a07805 	stb	r2,-32288(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81112938:	111637c0 	call	8111637c <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
8111293c:	e0bfff03 	ldbu	r2,-4(fp)
81112940:	10800044 	addi	r2,r2,1
81112944:	e0bfff05 	stb	r2,-4(fp)
81112948:	e0bfff03 	ldbu	r2,-4(fp)
8111294c:	10800230 	cmpltui	r2,r2,8
81112950:	103f7a1e 	bne	r2,zero,8111273c <__reset+0xfb0f273c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81112954:	d0a07417 	ldw	r2,-32304(gp)
81112958:	1009883a 	mov	r4,r2
8111295c:	1136fd40 	call	81136fd4 <OSMutexPost>

    return;
81112960:	0001883a 	nop
81112964:	00000106 	br	8111296c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81112968:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8111296c:	e037883a 	mov	sp,fp
81112970:	dfc00117 	ldw	ra,4(sp)
81112974:	df000017 	ldw	fp,0(sp)
81112978:	dec00204 	addi	sp,sp,8
8111297c:	f800283a 	ret

81112980 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81112980:	defffd04 	addi	sp,sp,-12
81112984:	de00012e 	bgeu	sp,et,8111298c <vCheckRetransmission32+0xc>
81112988:	003b68fa 	trap	3
8111298c:	dfc00215 	stw	ra,8(sp)
81112990:	df000115 	stw	fp,4(sp)
81112994:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81112998:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8111299c:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
811129a0:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811129a4:	d0a07017 	ldw	r2,-32320(gp)
811129a8:	e0ffff84 	addi	r3,fp,-2
811129ac:	180b883a 	mov	r5,r3
811129b0:	1009883a 	mov	r4,r2
811129b4:	11363b00 	call	811363b0 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811129b8:	e0bfff83 	ldbu	r2,-2(fp)
811129bc:	10803fcc 	andi	r2,r2,255
811129c0:	10009b1e 	bne	r2,zero,81112c30 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811129c4:	e03fff05 	stb	zero,-4(fp)
811129c8:	00009106 	br	81112c10 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
811129cc:	e0ffff03 	ldbu	r3,-4(fp)
811129d0:	00a04574 	movhi	r2,33045
811129d4:	109ef704 	addi	r2,r2,31708
811129d8:	18c00384 	addi	r3,r3,14
811129dc:	18c7883a 	add	r3,r3,r3
811129e0:	18c7883a 	add	r3,r3,r3
811129e4:	10c5883a 	add	r2,r2,r3
811129e8:	10800017 	ldw	r2,0(r2)
811129ec:	10800058 	cmpnei	r2,r2,1
811129f0:	1000841e 	bne	r2,zero,81112c04 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
811129f4:	e0ffff03 	ldbu	r3,-4(fp)
811129f8:	00a04574 	movhi	r2,33045
811129fc:	108c8b04 	addi	r2,r2,12844
81112a00:	18c00b24 	muli	r3,r3,44
81112a04:	10c5883a 	add	r2,r2,r3
81112a08:	10800804 	addi	r2,r2,32
81112a0c:	10800017 	ldw	r2,0(r2)
81112a10:	10800058 	cmpnei	r2,r2,1
81112a14:	1000211e 	bne	r2,zero,81112a9c <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112a18:	e0ffff03 	ldbu	r3,-4(fp)
81112a1c:	00a04574 	movhi	r2,33045
81112a20:	108c8b04 	addi	r2,r2,12844
81112a24:	19000b24 	muli	r4,r3,44
81112a28:	1105883a 	add	r2,r2,r4
81112a2c:	10800984 	addi	r2,r2,38
81112a30:	1080000b 	ldhu	r2,0(r2)
81112a34:	10800044 	addi	r2,r2,1
81112a38:	100b883a 	mov	r5,r2
81112a3c:	00a04574 	movhi	r2,33045
81112a40:	108c8b04 	addi	r2,r2,12844
81112a44:	19000b24 	muli	r4,r3,44
81112a48:	1105883a 	add	r2,r2,r4
81112a4c:	10800984 	addi	r2,r2,38
81112a50:	1140000d 	sth	r5,0(r2)
81112a54:	00a04574 	movhi	r2,33045
81112a58:	108c8b04 	addi	r2,r2,12844
81112a5c:	18c00b24 	muli	r3,r3,44
81112a60:	10c5883a 	add	r2,r2,r3
81112a64:	10800984 	addi	r2,r2,38
81112a68:	1080000b 	ldhu	r2,0(r2)
81112a6c:	10bfffcc 	andi	r2,r2,65535
81112a70:	10a0001c 	xori	r2,r2,32768
81112a74:	10a00004 	addi	r2,r2,-32768
81112a78:	10800090 	cmplti	r2,r2,2
81112a7c:	1000071e 	bne	r2,zero,81112a9c <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81112a80:	e0ffff03 	ldbu	r3,-4(fp)
81112a84:	00a04574 	movhi	r2,33045
81112a88:	108c8b04 	addi	r2,r2,12844
81112a8c:	18c00b24 	muli	r3,r3,44
81112a90:	10c5883a 	add	r2,r2,r3
81112a94:	10800804 	addi	r2,r2,32
81112a98:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81112a9c:	e0ffff03 	ldbu	r3,-4(fp)
81112aa0:	00a04574 	movhi	r2,33045
81112aa4:	108c8b04 	addi	r2,r2,12844
81112aa8:	18c00b24 	muli	r3,r3,44
81112aac:	10c5883a 	add	r2,r2,r3
81112ab0:	10800804 	addi	r2,r2,32
81112ab4:	10800017 	ldw	r2,0(r2)
81112ab8:	1000521e 	bne	r2,zero,81112c04 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81112abc:	e0bfff03 	ldbu	r2,-4(fp)
81112ac0:	10c00b24 	muli	r3,r2,44
81112ac4:	00a04574 	movhi	r2,33045
81112ac8:	108c8b04 	addi	r2,r2,12844
81112acc:	1885883a 	add	r2,r3,r2
81112ad0:	1009883a 	mov	r4,r2
81112ad4:	111bfac0 	call	8111bfac <puts>
                xBuffer32[ucIL].bSent = TRUE;
81112ad8:	e0ffff03 	ldbu	r3,-4(fp)
81112adc:	00a04574 	movhi	r2,33045
81112ae0:	108c8b04 	addi	r2,r2,12844
81112ae4:	18c00b24 	muli	r3,r3,44
81112ae8:	10c5883a 	add	r2,r2,r3
81112aec:	10800804 	addi	r2,r2,32
81112af0:	00c00044 	movi	r3,1
81112af4:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81112af8:	e0ffff03 	ldbu	r3,-4(fp)
81112afc:	00a04574 	movhi	r2,33045
81112b00:	108c8b04 	addi	r2,r2,12844
81112b04:	18c00b24 	muli	r3,r3,44
81112b08:	10c5883a 	add	r2,r2,r3
81112b0c:	10800984 	addi	r2,r2,38
81112b10:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81112b14:	e0ffff03 	ldbu	r3,-4(fp)
81112b18:	00a04574 	movhi	r2,33045
81112b1c:	108c8b04 	addi	r2,r2,12844
81112b20:	18c00b24 	muli	r3,r3,44
81112b24:	10c5883a 	add	r2,r2,r3
81112b28:	10800904 	addi	r2,r2,36
81112b2c:	1080000b 	ldhu	r2,0(r2)
81112b30:	10bfffcc 	andi	r2,r2,65535
81112b34:	10800058 	cmpnei	r2,r2,1
81112b38:	1000021e 	bne	r2,zero,81112b44 <vCheckRetransmission32+0x1c4>
81112b3c:	00bffe84 	movi	r2,-6
81112b40:	00000106 	br	81112b48 <vCheckRetransmission32+0x1c8>
81112b44:	00800044 	movi	r2,1
81112b48:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81112b4c:	e0ffff03 	ldbu	r3,-4(fp)
81112b50:	00a04574 	movhi	r2,33045
81112b54:	108c8b04 	addi	r2,r2,12844
81112b58:	19000b24 	muli	r4,r3,44
81112b5c:	1105883a 	add	r2,r2,r4
81112b60:	10800a04 	addi	r2,r2,40
81112b64:	10800003 	ldbu	r2,0(r2)
81112b68:	10800044 	addi	r2,r2,1
81112b6c:	100b883a 	mov	r5,r2
81112b70:	00a04574 	movhi	r2,33045
81112b74:	108c8b04 	addi	r2,r2,12844
81112b78:	19000b24 	muli	r4,r3,44
81112b7c:	1105883a 	add	r2,r2,r4
81112b80:	10800a04 	addi	r2,r2,40
81112b84:	11400005 	stb	r5,0(r2)
81112b88:	00a04574 	movhi	r2,33045
81112b8c:	108c8b04 	addi	r2,r2,12844
81112b90:	18c00b24 	muli	r3,r3,44
81112b94:	10c5883a 	add	r2,r2,r3
81112b98:	10800a04 	addi	r2,r2,40
81112b9c:	10800003 	ldbu	r2,0(r2)
81112ba0:	10803fcc 	andi	r2,r2,255
81112ba4:	e0ffff43 	ldbu	r3,-3(fp)
81112ba8:	1880162e 	bgeu	r3,r2,81112c04 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81112bac:	e0ffff03 	ldbu	r3,-4(fp)
81112bb0:	00a04574 	movhi	r2,33045
81112bb4:	109ef704 	addi	r2,r2,31708
81112bb8:	18c00384 	addi	r3,r3,14
81112bbc:	18c7883a 	add	r3,r3,r3
81112bc0:	18c7883a 	add	r3,r3,r3
81112bc4:	10c5883a 	add	r2,r2,r3
81112bc8:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81112bcc:	d0a06a03 	ldbu	r2,-32344(gp)
81112bd0:	10800044 	addi	r2,r2,1
81112bd4:	d0a06a05 	stb	r2,-32344(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81112bd8:	d0a07317 	ldw	r2,-32308(gp)
81112bdc:	1009883a 	mov	r4,r2
81112be0:	1138dc40 	call	81138dc4 <OSSemPost>
81112be4:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112be8:	e0bfff83 	ldbu	r2,-2(fp)
81112bec:	10803fcc 	andi	r2,r2,255
81112bf0:	10000426 	beq	r2,zero,81112c04 <vCheckRetransmission32+0x284>
                        SemCount32--;
81112bf4:	d0a06a03 	ldbu	r2,-32344(gp)
81112bf8:	10bfffc4 	addi	r2,r2,-1
81112bfc:	d0a06a05 	stb	r2,-32344(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81112c00:	11163140 	call	81116314 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81112c04:	e0bfff03 	ldbu	r2,-4(fp)
81112c08:	10800044 	addi	r2,r2,1
81112c0c:	e0bfff05 	stb	r2,-4(fp)
81112c10:	e0bfff03 	ldbu	r2,-4(fp)
81112c14:	10800230 	cmpltui	r2,r2,8
81112c18:	103f6c1e 	bne	r2,zero,811129cc <__reset+0xfb0f29cc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81112c1c:	d0a07017 	ldw	r2,-32320(gp)
81112c20:	1009883a 	mov	r4,r2
81112c24:	1136fd40 	call	81136fd4 <OSMutexPost>

    return;
81112c28:	0001883a 	nop
81112c2c:	00000106 	br	81112c34 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81112c30:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81112c34:	e037883a 	mov	sp,fp
81112c38:	dfc00117 	ldw	ra,4(sp)
81112c3c:	df000017 	ldw	fp,0(sp)
81112c40:	dec00204 	addi	sp,sp,8
81112c44:	f800283a 	ret

81112c48 <bResourcesInitRTOS>:
 * Control of all Simucam application
 */
TSimucam_MEB xSimMeb; /* Struct */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81112c48:	defff904 	addi	sp,sp,-28
81112c4c:	de00012e 	bgeu	sp,et,81112c54 <bResourcesInitRTOS+0xc>
81112c50:	003b68fa 	trap	3
81112c54:	dfc00615 	stw	ra,24(sp)
81112c58:	df000515 	stw	fp,20(sp)
81112c5c:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81112c60:	00800044 	movi	r2,1
81112c64:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81112c68:	0009883a 	mov	r4,zero
81112c6c:	11387140 	call	81138714 <OSSemCreate>
81112c70:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCommInit) {
81112c74:	d0a05d17 	ldw	r2,-32396(gp)
81112c78:	1000021e 	bne	r2,zero,81112c84 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81112c7c:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112c80:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81112c84:	e0bfff04 	addi	r2,fp,-4
81112c88:	100b883a 	mov	r5,r2
81112c8c:	01000444 	movi	r4,17
81112c90:	113655c0 	call	8113655c <OSMutexCreate>
81112c94:	d0a07715 	stw	r2,-32292(gp)
	if ( err != OS_ERR_NONE ) {
81112c98:	e0bfff03 	ldbu	r2,-4(fp)
81112c9c:	10803fcc 	andi	r2,r2,255
81112ca0:	10000526 	beq	r2,zero,81112cb8 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81112ca4:	e0bfff03 	ldbu	r2,-4(fp)
81112ca8:	10803fcc 	andi	r2,r2,255
81112cac:	1009883a 	mov	r4,r2
81112cb0:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112cb4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81112cb8:	e0bfff04 	addi	r2,fp,-4
81112cbc:	100b883a 	mov	r5,r2
81112cc0:	01000504 	movi	r4,20
81112cc4:	113655c0 	call	8113655c <OSMutexCreate>
81112cc8:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
81112ccc:	e0bfff03 	ldbu	r2,-4(fp)
81112cd0:	10803fcc 	andi	r2,r2,255
81112cd4:	10000526 	beq	r2,zero,81112cec <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81112cd8:	e0bfff03 	ldbu	r2,-4(fp)
81112cdc:	10803fcc 	andi	r2,r2,255
81112ce0:	1009883a 	mov	r4,r2
81112ce4:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112ce8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81112cec:	e0bfff04 	addi	r2,fp,-4
81112cf0:	100b883a 	mov	r5,r2
81112cf4:	01000544 	movi	r4,21
81112cf8:	113655c0 	call	8113655c <OSMutexCreate>
81112cfc:	d0a07415 	stw	r2,-32304(gp)
	if ( err != OS_ERR_NONE ) {
81112d00:	e0bfff03 	ldbu	r2,-4(fp)
81112d04:	10803fcc 	andi	r2,r2,255
81112d08:	10000526 	beq	r2,zero,81112d20 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81112d0c:	e0bfff03 	ldbu	r2,-4(fp)
81112d10:	10803fcc 	andi	r2,r2,255
81112d14:	1009883a 	mov	r4,r2
81112d18:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112d1c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81112d20:	e0bfff04 	addi	r2,fp,-4
81112d24:	100b883a 	mov	r5,r2
81112d28:	01000584 	movi	r4,22
81112d2c:	113655c0 	call	8113655c <OSMutexCreate>
81112d30:	d0a07015 	stw	r2,-32320(gp)
	if ( err != OS_ERR_NONE ) {
81112d34:	e0bfff03 	ldbu	r2,-4(fp)
81112d38:	10803fcc 	andi	r2,r2,255
81112d3c:	10000526 	beq	r2,zero,81112d54 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81112d40:	e0bfff03 	ldbu	r2,-4(fp)
81112d44:	10803fcc 	andi	r2,r2,255
81112d48:	1009883a 	mov	r4,r2
81112d4c:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112d50:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81112d54:	00800184 	movi	r2,6
81112d58:	d0a07845 	stb	r2,-32287(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81112d5c:	01000184 	movi	r4,6
81112d60:	11387140 	call	81138714 <OSSemCreate>
81112d64:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountBuffer128) {
81112d68:	d0a06017 	ldw	r2,-32384(gp)
81112d6c:	1000031e 	bne	r2,zero,81112d7c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81112d70:	d0207845 	stb	zero,-32287(gp)
		vFailCreateSemaphoreResources();
81112d74:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112d78:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81112d7c:	00800204 	movi	r2,8
81112d80:	d0a07805 	stb	r2,-32288(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81112d84:	01000204 	movi	r4,8
81112d88:	11387140 	call	81138714 <OSSemCreate>
81112d8c:	d0a05a15 	stw	r2,-32408(gp)
	if (!xSemCountBuffer64) {
81112d90:	d0a05a17 	ldw	r2,-32408(gp)
81112d94:	1000031e 	bne	r2,zero,81112da4 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81112d98:	d0207805 	stb	zero,-32288(gp)
		vFailCreateSemaphoreResources();
81112d9c:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112da0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81112da4:	00800204 	movi	r2,8
81112da8:	d0a06a05 	stb	r2,-32344(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81112dac:	01000204 	movi	r4,8
81112db0:	11387140 	call	81138714 <OSSemCreate>
81112db4:	d0a07315 	stw	r2,-32308(gp)
	if (!xSemCountBuffer32) {
81112db8:	d0a07317 	ldw	r2,-32308(gp)
81112dbc:	1000031e 	bne	r2,zero,81112dcc <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81112dc0:	d0206a05 	stb	zero,-32344(gp)
		vFailCreateSemaphoreResources();
81112dc4:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112dc8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81112dcc:	e0bfff04 	addi	r2,fp,-4
81112dd0:	100b883a 	mov	r5,r2
81112dd4:	010004c4 	movi	r4,19
81112dd8:	113655c0 	call	8113655c <OSMutexCreate>
81112ddc:	d0a06215 	stw	r2,-32376(gp)
	if ( err != OS_ERR_NONE ) {
81112de0:	e0bfff03 	ldbu	r2,-4(fp)
81112de4:	10803fcc 	andi	r2,r2,255
81112de8:	10000526 	beq	r2,zero,81112e00 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81112dec:	e0bfff03 	ldbu	r2,-4(fp)
81112df0:	10803fcc 	andi	r2,r2,255
81112df4:	1009883a 	mov	r4,r2
81112df8:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112dfc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81112e00:	e0bfff04 	addi	r2,fp,-4
81112e04:	100b883a 	mov	r5,r2
81112e08:	010005c4 	movi	r4,23
81112e0c:	113655c0 	call	8113655c <OSMutexCreate>
81112e10:	d0a06f15 	stw	r2,-32324(gp)
	if ( err != OS_ERR_NONE ) {
81112e14:	e0bfff03 	ldbu	r2,-4(fp)
81112e18:	10803fcc 	andi	r2,r2,255
81112e1c:	10000526 	beq	r2,zero,81112e34 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81112e20:	e0bfff03 	ldbu	r2,-4(fp)
81112e24:	10803fcc 	andi	r2,r2,255
81112e28:	1009883a 	mov	r4,r2
81112e2c:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112e30:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81112e34:	0009883a 	mov	r4,zero
81112e38:	11387140 	call	81138714 <OSSemCreate>
81112e3c:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountReceivedACK) {
81112e40:	d0a06317 	ldw	r2,-32372(gp)
81112e44:	1000021e 	bne	r2,zero,81112e50 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81112e48:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112e4c:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81112e50:	0009883a 	mov	r4,zero
81112e54:	11387140 	call	81138714 <OSSemCreate>
81112e58:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountPreParsed) {
81112e5c:	d0a06117 	ldw	r2,-32380(gp)
81112e60:	1000021e 	bne	r2,zero,81112e6c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81112e64:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112e68:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81112e6c:	0009883a 	mov	r4,zero
81112e70:	11387140 	call	81138714 <OSSemCreate>
81112e74:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountSenderACK) {
81112e78:	d0a05e17 	ldw	r2,-32392(gp)
81112e7c:	1000021e 	bne	r2,zero,81112e88 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81112e80:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112e84:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81112e88:	e0bfff04 	addi	r2,fp,-4
81112e8c:	100b883a 	mov	r5,r2
81112e90:	01000484 	movi	r4,18
81112e94:	113655c0 	call	8113655c <OSMutexCreate>
81112e98:	d0a07515 	stw	r2,-32300(gp)
	if ( err != OS_ERR_NONE ) {
81112e9c:	e0bfff03 	ldbu	r2,-4(fp)
81112ea0:	10803fcc 	andi	r2,r2,255
81112ea4:	10000526 	beq	r2,zero,81112ebc <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81112ea8:	e0bfff03 	ldbu	r2,-4(fp)
81112eac:	10803fcc 	andi	r2,r2,255
81112eb0:	1009883a 	mov	r4,r2
81112eb4:	1115d4c0 	call	81115d4c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112eb8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81112ebc:	0009883a 	mov	r4,zero
81112ec0:	11387140 	call	81138714 <OSSemCreate>
81112ec4:	d0a06415 	stw	r2,-32368(gp)
	if (!xSemTimeoutChecker) {
81112ec8:	d0a06417 	ldw	r2,-32368(gp)
81112ecc:	1000021e 	bne	r2,zero,81112ed8 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81112ed0:	1115dac0 	call	81115dac <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112ed4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81112ed8:	e0bfff04 	addi	r2,fp,-4
81112edc:	d8800215 	stw	r2,8(sp)
81112ee0:	00a04534 	movhi	r2,33044
81112ee4:	109e3104 	addi	r2,r2,30916
81112ee8:	d8800115 	stw	r2,4(sp)
81112eec:	d8000015 	stw	zero,0(sp)
81112ef0:	01e04474 	movhi	r7,33041
81112ef4:	39d27604 	addi	r7,r7,18904
81112ef8:	01800084 	movi	r6,2
81112efc:	01400104 	movi	r5,4
81112f00:	01000284 	movi	r4,10
81112f04:	113ac2c0 	call	8113ac2c <OSTmrCreate>
81112f08:	d0a07115 	stw	r2,-32316(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81112f0c:	e0bfff03 	ldbu	r2,-4(fp)
81112f10:	10803fcc 	andi	r2,r2,255
81112f14:	10000226 	beq	r2,zero,81112f20 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81112f18:	1116a100 	call	81116a10 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81112f1c:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81112f20:	01400304 	movi	r5,12
81112f24:	01204574 	movhi	r4,33045
81112f28:	213fd904 	addi	r4,r4,-156
81112f2c:	11376480 	call	81137648 <OSQCreate>
81112f30:	d0a05915 	stw	r2,-32412(gp)
	if ( xNfeeSchedule == NULL ) {
81112f34:	d0a05917 	ldw	r2,-32412(gp)
81112f38:	1000021e 	bne	r2,zero,81112f44 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81112f3c:	1116ff40 	call	81116ff4 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81112f40:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81112f44:	01400104 	movi	r5,4
81112f48:	012045b4 	movhi	r4,33046
81112f4c:	213ea904 	addi	r4,r4,-1372
81112f50:	11376480 	call	81137648 <OSQCreate>
81112f54:	d0a06e15 	stw	r2,-32328(gp)
	if ( xFeeQ[0] == NULL ) {
81112f58:	d0a06e17 	ldw	r2,-32328(gp)
81112f5c:	1000031e 	bne	r2,zero,81112f6c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81112f60:	0009883a 	mov	r4,zero
81112f64:	111705c0 	call	8111705c <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81112f68:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL1[0], N_MSG_SYNC);
81112f6c:	01400084 	movi	r5,2
81112f70:	d1207904 	addi	r4,gp,-32284
81112f74:	11376480 	call	81137648 <OSQCreate>
81112f78:	d0a05815 	stw	r2,-32416(gp)
	if ( xFeeQ[0] == NULL ) {
81112f7c:	d0a06e17 	ldw	r2,-32328(gp)
81112f80:	1000031e 	bne	r2,zero,81112f90 <bResourcesInitRTOS+0x348>
		vFailCreateNFEESyncQueue( 0 );
81112f84:	0009883a 	mov	r4,zero
81112f88:	11170cc0 	call	811170cc <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81112f8c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81112f90:	01400204 	movi	r5,8
81112f94:	01204574 	movhi	r4,33045
81112f98:	211f0d04 	addi	r4,r4,31796
81112f9c:	11376480 	call	81137648 <OSQCreate>
81112fa0:	d0a06b15 	stw	r2,-32340(gp)
	if ( xFeeQ[5] == NULL ) {
81112fa4:	d0a07317 	ldw	r2,-32308(gp)
81112fa8:	1000031e 	bne	r2,zero,81112fb8 <bResourcesInitRTOS+0x370>
		vFailCreateNFEEQueue( 5 );
81112fac:	01000144 	movi	r4,5
81112fb0:	111705c0 	call	8111705c <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81112fb4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81112fb8:	e0bfff04 	addi	r2,fp,-4
81112fbc:	100b883a 	mov	r5,r2
81112fc0:	01000144 	movi	r4,5
81112fc4:	113655c0 	call	8113655c <OSMutexCreate>
81112fc8:	d0a07615 	stw	r2,-32296(gp)
	if ( err != OS_ERR_NONE ) {
81112fcc:	e0bfff03 	ldbu	r2,-4(fp)
81112fd0:	10803fcc 	andi	r2,r2,255
81112fd4:	10000526 	beq	r2,zero,81112fec <bResourcesInitRTOS+0x3a4>
		vFailCreateMutexSPUSQueueMeb(err);
81112fd8:	e0bfff03 	ldbu	r2,-4(fp)
81112fdc:	10803fcc 	andi	r2,r2,255
81112fe0:	1009883a 	mov	r4,r2
81112fe4:	11174e40 	call	811174e4 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81112fe8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81112fec:	01400404 	movi	r5,16
81112ff0:	01204574 	movhi	r4,33045
81112ff4:	211fe704 	addi	r4,r4,32668
81112ff8:	11376480 	call	81137648 <OSQCreate>
81112ffc:	d0a05215 	stw	r2,-32440(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81113000:	d0a05217 	ldw	r2,-32440(gp)
81113004:	1000021e 	bne	r2,zero,81113010 <bResourcesInitRTOS+0x3c8>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81113008:	11176440 	call	81117644 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
8111300c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81113010:	01400404 	movi	r5,16
81113014:	01204574 	movhi	r4,33045
81113018:	2112e304 	addi	r4,r4,19340
8111301c:	11376480 	call	81137648 <OSQCreate>
81113020:	d0a05215 	stw	r2,-32440(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81113024:	d0a05217 	ldw	r2,-32440(gp)
81113028:	1000021e 	bne	r2,zero,81113034 <bResourcesInitRTOS+0x3ec>
		vCouldNotCreateQueueMaskDataCtrl( );
8111302c:	11176ac0 	call	811176ac <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81113030:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81113034:	e0bffe17 	ldw	r2,-8(fp)
}
81113038:	e037883a 	mov	sp,fp
8111303c:	dfc00117 	ldw	ra,4(sp)
81113040:	df000017 	ldw	fp,0(sp)
81113044:	dec00204 	addi	sp,sp,8
81113048:	f800283a 	ret

8111304c <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
8111304c:	defffd04 	addi	sp,sp,-12
81113050:	de00012e 	bgeu	sp,et,81113058 <vVariablesInitialization+0xc>
81113054:	003b68fa 	trap	3
81113058:	dfc00215 	stw	ra,8(sp)
8111305c:	df000115 	stw	fp,4(sp)
81113060:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81113064:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81113068:	00800084 	movi	r2,2
8111306c:	d0a0670d 	sth	r2,-32356(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81113070:	01800604 	movi	r6,24
81113074:	000b883a 	mov	r5,zero
81113078:	01204574 	movhi	r4,33045
8111307c:	211ef704 	addi	r4,r4,31708
81113080:	111bb600 	call	8111bb60 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81113084:	01800804 	movi	r6,32
81113088:	000b883a 	mov	r5,zero
8111308c:	01204574 	movhi	r4,33045
81113090:	211efd04 	addi	r4,r4,31732
81113094:	111bb600 	call	8111bb60 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81113098:	01800804 	movi	r6,32
8111309c:	000b883a 	mov	r5,zero
811130a0:	01204574 	movhi	r4,33045
811130a4:	211f0504 	addi	r4,r4,31764
811130a8:	111bb600 	call	8111bb60 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811130ac:	e03fff05 	stb	zero,-4(fp)
811130b0:	00002806 	br	81113154 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
811130b4:	e0bfff03 	ldbu	r2,-4(fp)
811130b8:	10c02324 	muli	r3,r2,140
811130bc:	00a04574 	movhi	r2,33045
811130c0:	109f1504 	addi	r2,r2,31828
811130c4:	1885883a 	add	r2,r3,r2
811130c8:	01802004 	movi	r6,128
811130cc:	000b883a 	mov	r5,zero
811130d0:	1009883a 	mov	r4,r2
811130d4:	111bb600 	call	8111bb60 <memset>
		xBuffer128[ucIL].bSent = FALSE;
811130d8:	e0ffff03 	ldbu	r3,-4(fp)
811130dc:	00a04574 	movhi	r2,33045
811130e0:	109f1504 	addi	r2,r2,31828
811130e4:	18c02324 	muli	r3,r3,140
811130e8:	10c5883a 	add	r2,r2,r3
811130ec:	10802004 	addi	r2,r2,128
811130f0:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811130f4:	e0ffff03 	ldbu	r3,-4(fp)
811130f8:	00a04574 	movhi	r2,33045
811130fc:	109f1504 	addi	r2,r2,31828
81113100:	18c02324 	muli	r3,r3,140
81113104:	10c5883a 	add	r2,r2,r3
81113108:	10802104 	addi	r2,r2,132
8111310c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
81113110:	e0ffff03 	ldbu	r3,-4(fp)
81113114:	00a04574 	movhi	r2,33045
81113118:	109f1504 	addi	r2,r2,31828
8111311c:	18c02324 	muli	r3,r3,140
81113120:	10c5883a 	add	r2,r2,r3
81113124:	10802184 	addi	r2,r2,134
81113128:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
8111312c:	e0ffff03 	ldbu	r3,-4(fp)
81113130:	00a04574 	movhi	r2,33045
81113134:	109f1504 	addi	r2,r2,31828
81113138:	18c02324 	muli	r3,r3,140
8111313c:	10c5883a 	add	r2,r2,r3
81113140:	10802204 	addi	r2,r2,136
81113144:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113148:	e0bfff03 	ldbu	r2,-4(fp)
8111314c:	10800044 	addi	r2,r2,1
81113150:	e0bfff05 	stb	r2,-4(fp)
81113154:	e0bfff03 	ldbu	r2,-4(fp)
81113158:	108001b0 	cmpltui	r2,r2,6
8111315c:	103fd51e 	bne	r2,zero,811130b4 <__reset+0xfb0f30b4>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81113160:	e03fff05 	stb	zero,-4(fp)
81113164:	00002806 	br	81113208 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81113168:	e0bfff03 	ldbu	r2,-4(fp)
8111316c:	10c01324 	muli	r3,r2,76
81113170:	00a04574 	movhi	r2,33045
81113174:	10bae904 	addi	r2,r2,-5212
81113178:	1885883a 	add	r2,r3,r2
8111317c:	01801004 	movi	r6,64
81113180:	000b883a 	mov	r5,zero
81113184:	1009883a 	mov	r4,r2
81113188:	111bb600 	call	8111bb60 <memset>
		xBuffer64[ucIL].bSent = FALSE;
8111318c:	e0ffff03 	ldbu	r3,-4(fp)
81113190:	00a04574 	movhi	r2,33045
81113194:	10bae904 	addi	r2,r2,-5212
81113198:	18c01324 	muli	r3,r3,76
8111319c:	10c5883a 	add	r2,r2,r3
811131a0:	10801004 	addi	r2,r2,64
811131a4:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
811131a8:	e0ffff03 	ldbu	r3,-4(fp)
811131ac:	00a04574 	movhi	r2,33045
811131b0:	10bae904 	addi	r2,r2,-5212
811131b4:	18c01324 	muli	r3,r3,76
811131b8:	10c5883a 	add	r2,r2,r3
811131bc:	10801104 	addi	r2,r2,68
811131c0:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
811131c4:	e0ffff03 	ldbu	r3,-4(fp)
811131c8:	00a04574 	movhi	r2,33045
811131cc:	10bae904 	addi	r2,r2,-5212
811131d0:	18c01324 	muli	r3,r3,76
811131d4:	10c5883a 	add	r2,r2,r3
811131d8:	10801184 	addi	r2,r2,70
811131dc:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
811131e0:	e0ffff03 	ldbu	r3,-4(fp)
811131e4:	00a04574 	movhi	r2,33045
811131e8:	10bae904 	addi	r2,r2,-5212
811131ec:	18c01324 	muli	r3,r3,76
811131f0:	10c5883a 	add	r2,r2,r3
811131f4:	10801204 	addi	r2,r2,72
811131f8:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811131fc:	e0bfff03 	ldbu	r2,-4(fp)
81113200:	10800044 	addi	r2,r2,1
81113204:	e0bfff05 	stb	r2,-4(fp)
81113208:	e0bfff03 	ldbu	r2,-4(fp)
8111320c:	10800230 	cmpltui	r2,r2,8
81113210:	103fd51e 	bne	r2,zero,81113168 <__reset+0xfb0f3168>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81113214:	e03fff05 	stb	zero,-4(fp)
81113218:	00002806 	br	811132bc <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
8111321c:	e0bfff03 	ldbu	r2,-4(fp)
81113220:	10c00b24 	muli	r3,r2,44
81113224:	00a04574 	movhi	r2,33045
81113228:	108c8b04 	addi	r2,r2,12844
8111322c:	1885883a 	add	r2,r3,r2
81113230:	01800804 	movi	r6,32
81113234:	000b883a 	mov	r5,zero
81113238:	1009883a 	mov	r4,r2
8111323c:	111bb600 	call	8111bb60 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81113240:	e0ffff03 	ldbu	r3,-4(fp)
81113244:	00a04574 	movhi	r2,33045
81113248:	108c8b04 	addi	r2,r2,12844
8111324c:	18c00b24 	muli	r3,r3,44
81113250:	10c5883a 	add	r2,r2,r3
81113254:	10800804 	addi	r2,r2,32
81113258:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
8111325c:	e0ffff03 	ldbu	r3,-4(fp)
81113260:	00a04574 	movhi	r2,33045
81113264:	108c8b04 	addi	r2,r2,12844
81113268:	18c00b24 	muli	r3,r3,44
8111326c:	10c5883a 	add	r2,r2,r3
81113270:	10800904 	addi	r2,r2,36
81113274:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81113278:	e0ffff03 	ldbu	r3,-4(fp)
8111327c:	00a04574 	movhi	r2,33045
81113280:	108c8b04 	addi	r2,r2,12844
81113284:	18c00b24 	muli	r3,r3,44
81113288:	10c5883a 	add	r2,r2,r3
8111328c:	10800984 	addi	r2,r2,38
81113290:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81113294:	e0ffff03 	ldbu	r3,-4(fp)
81113298:	00a04574 	movhi	r2,33045
8111329c:	108c8b04 	addi	r2,r2,12844
811132a0:	18c00b24 	muli	r3,r3,44
811132a4:	10c5883a 	add	r2,r2,r3
811132a8:	10800a04 	addi	r2,r2,40
811132ac:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811132b0:	e0bfff03 	ldbu	r2,-4(fp)
811132b4:	10800044 	addi	r2,r2,1
811132b8:	e0bfff05 	stb	r2,-4(fp)
811132bc:	e0bfff03 	ldbu	r2,-4(fp)
811132c0:	10800230 	cmpltui	r2,r2,8
811132c4:	103fd51e 	bne	r2,zero,8111321c <__reset+0xfb0f321c>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811132c8:	e03fff05 	stb	zero,-4(fp)
811132cc:	00001b06 	br	8111333c <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
811132d0:	e0ffff03 	ldbu	r3,-4(fp)
811132d4:	00a04574 	movhi	r2,33045
811132d8:	10bb8104 	addi	r2,r2,-4604
811132dc:	18c01524 	muli	r3,r3,84
811132e0:	10c5883a 	add	r2,r2,r3
811132e4:	10800104 	addi	r2,r2,4
811132e8:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
811132ec:	e0ffff03 	ldbu	r3,-4(fp)
811132f0:	00a04574 	movhi	r2,33045
811132f4:	10bb8104 	addi	r2,r2,-4604
811132f8:	18c01524 	muli	r3,r3,84
811132fc:	10c5883a 	add	r2,r2,r3
81113300:	10800484 	addi	r2,r2,18
81113304:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81113308:	e0bfff03 	ldbu	r2,-4(fp)
8111330c:	10801524 	muli	r2,r2,84
81113310:	10c00504 	addi	r3,r2,20
81113314:	00a04574 	movhi	r2,33045
81113318:	10bb8104 	addi	r2,r2,-4604
8111331c:	1885883a 	add	r2,r3,r2
81113320:	01801004 	movi	r6,64
81113324:	000b883a 	mov	r5,zero
81113328:	1009883a 	mov	r4,r2
8111332c:	111bb600 	call	8111bb60 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81113330:	e0bfff03 	ldbu	r2,-4(fp)
81113334:	10800044 	addi	r2,r2,1
81113338:	e0bfff05 	stb	r2,-4(fp)
8111333c:	e0bfff03 	ldbu	r2,-4(fp)
81113340:	10800130 	cmpltui	r2,r2,4
81113344:	103fe21e 	bne	r2,zero,811132d0 <__reset+0xfb0f32d0>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81113348:	0001883a 	nop
8111334c:	e037883a 	mov	sp,fp
81113350:	dfc00117 	ldw	ra,4(sp)
81113354:	df000017 	ldw	fp,0(sp)
81113358:	dec00204 	addi	sp,sp,8
8111335c:	f800283a 	ret

81113360 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81113360:	defff704 	addi	sp,sp,-36
81113364:	de00012e 	bgeu	sp,et,8111336c <main+0xc>
81113368:	003b68fa 	trap	3
8111336c:	dfc00815 	stw	ra,32(sp)
81113370:	df000715 	stw	fp,28(sp)
81113374:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81113378:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
8111337c:	11329f80 	call	811329f8 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81113380:	01604534 	movhi	r5,33044
81113384:	295e3504 	addi	r5,r5,30932
81113388:	01204534 	movhi	r4,33044
8111338c:	211e3604 	addi	r4,r4,30936
81113390:	111a9180 	call	8111a918 <fopen>
81113394:	d0a05f15 	stw	r2,-32388(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81113398:	d0a05f17 	ldw	r2,-32388(gp)
8111339c:	100f883a 	mov	r7,r2
811133a0:	01800484 	movi	r6,18
811133a4:	01400044 	movi	r5,1
811133a8:	01204534 	movhi	r4,33044
811133ac:	211e3b04 	addi	r4,r4,30956
811133b0:	111affc0 	call	8111affc <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
811133b4:	11183300 	call	81118330 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
811133b8:	1118ecc0 	call	81118ecc <bTestSimucamCriticalHW>
811133bc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811133c0:	e0bffe17 	ldw	r2,-8(fp)
811133c4:	1000031e 	bne	r2,zero,811133d4 <main+0x74>
		vFailTestCriticasParts();
811133c8:	1115df80 	call	81115df8 <vFailTestCriticasParts>
		return -1;
811133cc:	00bfffc4 	movi	r2,-1
811133d0:	00003e06 	br	811134cc <main+0x16c>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
811133d4:	1118a780 	call	81118a78 <bInitializeSDCard>
811133d8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811133dc:	e0bffe17 	ldw	r2,-8(fp)
811133e0:	1000031e 	bne	r2,zero,811133f0 <main+0x90>
		vFailTestCriticasParts();
811133e4:	1115df80 	call	81115df8 <vFailTestCriticasParts>
		return -1;
811133e8:	00bfffc4 	movi	r2,-1
811133ec:	00003706 	br	811134cc <main+0x16c>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
811133f0:	1114e000 	call	81114e00 <vLoadDefaultETHConf>
811133f4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811133f8:	e0bffe17 	ldw	r2,-8(fp)
811133fc:	1000091e 	bne	r2,zero,81113424 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
81113400:	d0a05f17 	ldw	r2,-32388(gp)
81113404:	100f883a 	mov	r7,r2
81113408:	01801644 	movi	r6,89
8111340c:	01400044 	movi	r5,1
81113410:	01204534 	movhi	r4,33044
81113414:	211e4004 	addi	r4,r4,30976
81113418:	111affc0 	call	8111affc <fwrite>
		#endif
		return -1;
8111341c:	00bfffc4 	movi	r2,-1
81113420:	00002a06 	br	811134cc <main+0x16c>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81113424:	11157d40 	call	811157d4 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81113428:	1112c480 	call	81112c48 <bResourcesInitRTOS>
8111342c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113430:	e0bffe17 	ldw	r2,-8(fp)
81113434:	1000091e 	bne	r2,zero,8111345c <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81113438:	d0a05f17 	ldw	r2,-32388(gp)
8111343c:	100f883a 	mov	r7,r2
81113440:	01800ac4 	movi	r6,43
81113444:	01400044 	movi	r5,1
81113448:	01204534 	movhi	r4,33044
8111344c:	211e5704 	addi	r4,r4,31068
81113450:	111affc0 	call	8111affc <fwrite>
		return -1;
81113454:	00bfffc4 	movi	r2,-1
81113458:	00001c06 	br	811134cc <main+0x16c>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
8111345c:	01204574 	movhi	r4,33045
81113460:	2107e504 	addi	r4,r4,8084
81113464:	11184700 	call	81118470 <vSimucamStructureInit>

	vVariablesInitialization();
81113468:	111304c0 	call	8111304c <vVariablesInitialization>

	bInitSync();
8111346c:	1118c2c0 	call	81118c2c <bInitSync>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81113470:	d8000415 	stw	zero,16(sp)
81113474:	d8000315 	stw	zero,12(sp)
81113478:	00810004 	movi	r2,1024
8111347c:	d8800215 	stw	r2,8(sp)
81113480:	00a04574 	movhi	r2,33045
81113484:	1096f704 	addi	r2,r2,23516
81113488:	d8800115 	stw	r2,4(sp)
8111348c:	00800044 	movi	r2,1
81113490:	d8800015 	stw	r2,0(sp)
81113494:	01c00044 	movi	r7,1
81113498:	01a04574 	movhi	r6,33045
8111349c:	319af604 	addi	r6,r6,27608
811134a0:	000b883a 	mov	r5,zero
811134a4:	01204474 	movhi	r4,33041
811134a8:	2137e304 	addi	r4,r4,-8308
811134ac:	11395f40 	call	811395f4 <OSTaskCreateExt>
811134b0:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
811134b4:	e0bfff03 	ldbu	r2,-4(fp)
811134b8:	1000021e 	bne	r2,zero,811134c4 <main+0x164>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
811134bc:	1132d280 	call	81132d28 <OSStart>
811134c0:	00000106 	br	811134c8 <main+0x168>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
811134c4:	11161e40 	call	811161e4 <vFailInitialization>
	}
  
	return 0;
811134c8:	0005883a 	mov	r2,zero
}
811134cc:	e037883a 	mov	sp,fp
811134d0:	dfc00117 	ldw	ra,4(sp)
811134d4:	df000017 	ldw	fp,0(sp)
811134d8:	dec00204 	addi	sp,sp,8
811134dc:	f800283a 	ret

811134e0 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
811134e0:	defff604 	addi	sp,sp,-40
811134e4:	de00012e 	bgeu	sp,et,811134ec <vFillMemmoryPattern+0xc>
811134e8:	003b68fa 	trap	3
811134ec:	dfc00915 	stw	ra,36(sp)
811134f0:	df000815 	stw	fp,32(sp)
811134f4:	df000804 	addi	fp,sp,32
811134f8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
811134fc:	00800044 	movi	r2,1
81113500:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81113504:	d0a05f17 	ldw	r2,-32388(gp)
81113508:	100f883a 	mov	r7,r2
8111350c:	018009c4 	movi	r6,39
81113510:	01400044 	movi	r5,1
81113514:	01204534 	movhi	r4,33044
81113518:	211e6204 	addi	r4,r4,31112
8111351c:	111affc0 	call	8111affc <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113520:	e03ffa05 	stb	zero,-24(fp)
81113524:	00007606 	br	81113700 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113528:	e03ffc85 	stb	zero,-14(fp)
8111352c:	00006706 	br	811136cc <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81113530:	e0bffc83 	ldbu	r2,-14(fp)
81113534:	e0ffff17 	ldw	r3,-4(fp)
81113538:	10809224 	muli	r2,r2,584
8111353c:	1885883a 	add	r2,r3,r2
81113540:	10803d04 	addi	r2,r2,244
81113544:	1080000b 	ldhu	r2,0(r2)
81113548:	10ffffcc 	andi	r3,r2,65535
8111354c:	e0bffc83 	ldbu	r2,-14(fp)
81113550:	e13fff17 	ldw	r4,-4(fp)
81113554:	10809224 	muli	r2,r2,584
81113558:	2085883a 	add	r2,r4,r2
8111355c:	10803c04 	addi	r2,r2,240
81113560:	1080000b 	ldhu	r2,0(r2)
81113564:	10bfffcc 	andi	r2,r2,65535
81113568:	1885883a 	add	r2,r3,r2
8111356c:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81113570:	e0bffc83 	ldbu	r2,-14(fp)
81113574:	e0ffff17 	ldw	r3,-4(fp)
81113578:	10809224 	muli	r2,r2,584
8111357c:	1885883a 	add	r2,r3,r2
81113580:	10803c84 	addi	r2,r2,242
81113584:	1080000b 	ldhu	r2,0(r2)
81113588:	10ffffcc 	andi	r3,r2,65535
8111358c:	e0bffc83 	ldbu	r2,-14(fp)
81113590:	e13fff17 	ldw	r4,-4(fp)
81113594:	10809224 	muli	r2,r2,584
81113598:	2085883a 	add	r2,r4,r2
8111359c:	10803b84 	addi	r2,r2,238
811135a0:	1080000b 	ldhu	r2,0(r2)
811135a4:	10bfffcc 	andi	r2,r2,65535
811135a8:	1887883a 	add	r3,r3,r2
811135ac:	e0bffc83 	ldbu	r2,-14(fp)
811135b0:	e13fff17 	ldw	r4,-4(fp)
811135b4:	10809224 	muli	r2,r2,584
811135b8:	2085883a 	add	r2,r4,r2
811135bc:	10803b04 	addi	r2,r2,236
811135c0:	1080000b 	ldhu	r2,0(r2)
811135c4:	10bfffcc 	andi	r2,r2,65535
811135c8:	1885883a 	add	r2,r3,r2
811135cc:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811135d0:	e03ffc05 	stb	zero,-16(fp)
811135d4:	00003706 	br	811136b4 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811135d8:	e03ffc45 	stb	zero,-15(fp)
811135dc:	00002606 	br	81113678 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
811135e0:	e0bffc43 	ldbu	r2,-15(fp)
811135e4:	10000b1e 	bne	r2,zero,81113614 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811135e8:	e0bffc83 	ldbu	r2,-14(fp)
811135ec:	e13ffc03 	ldbu	r4,-16(fp)
811135f0:	e0ffff17 	ldw	r3,-4(fp)
811135f4:	21000624 	muli	r4,r4,24
811135f8:	10809224 	muli	r2,r2,584
811135fc:	2085883a 	add	r2,r4,r2
81113600:	1885883a 	add	r2,r3,r2
81113604:	10801804 	addi	r2,r2,96
81113608:	10800017 	ldw	r2,0(r2)
8111360c:	e0bffb15 	stw	r2,-20(fp)
81113610:	00000a06 	br	8111363c <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81113614:	e0bffc83 	ldbu	r2,-14(fp)
81113618:	e13ffc03 	ldbu	r4,-16(fp)
8111361c:	e0ffff17 	ldw	r3,-4(fp)
81113620:	21000624 	muli	r4,r4,24
81113624:	10809224 	muli	r2,r2,584
81113628:	2085883a 	add	r2,r4,r2
8111362c:	1885883a 	add	r2,r3,r2
81113630:	10801b04 	addi	r2,r2,108
81113634:	10800017 	ldw	r2,0(r2)
81113638:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8111363c:	e0fffa03 	ldbu	r3,-24(fp)
81113640:	e13ffc03 	ldbu	r4,-16(fp)
81113644:	e17ffc43 	ldbu	r5,-15(fp)
81113648:	e0bffe17 	ldw	r2,-8(fp)
8111364c:	d8800115 	stw	r2,4(sp)
81113650:	e0bffd17 	ldw	r2,-12(fp)
81113654:	d8800015 	stw	r2,0(sp)
81113658:	280f883a 	mov	r7,r5
8111365c:	200d883a 	mov	r6,r4
81113660:	e17ffb17 	ldw	r5,-20(fp)
81113664:	1809883a 	mov	r4,r3
81113668:	11187fc0 	call	811187fc <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111366c:	e0bffc43 	ldbu	r2,-15(fp)
81113670:	10800044 	addi	r2,r2,1
81113674:	e0bffc45 	stb	r2,-15(fp)
81113678:	e0bffc43 	ldbu	r2,-15(fp)
8111367c:	108000b0 	cmpltui	r2,r2,2
81113680:	103fd71e 	bne	r2,zero,811135e0 <__reset+0xfb0f35e0>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81113684:	d0a05f17 	ldw	r2,-32388(gp)
81113688:	e0fffc83 	ldbu	r3,-14(fp)
8111368c:	e13ffc03 	ldbu	r4,-16(fp)
81113690:	200f883a 	mov	r7,r4
81113694:	180d883a 	mov	r6,r3
81113698:	01604534 	movhi	r5,33044
8111369c:	295e6c04 	addi	r5,r5,31152
811136a0:	1009883a 	mov	r4,r2
811136a4:	111a9600 	call	8111a960 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811136a8:	e0bffc03 	ldbu	r2,-16(fp)
811136ac:	10800044 	addi	r2,r2,1
811136b0:	e0bffc05 	stb	r2,-16(fp)
811136b4:	e0bffc03 	ldbu	r2,-16(fp)
811136b8:	10800130 	cmpltui	r2,r2,4
811136bc:	103fc61e 	bne	r2,zero,811135d8 <__reset+0xfb0f35d8>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811136c0:	e0bffc83 	ldbu	r2,-14(fp)
811136c4:	10800044 	addi	r2,r2,1
811136c8:	e0bffc85 	stb	r2,-14(fp)
811136cc:	e0fffc83 	ldbu	r3,-14(fp)
811136d0:	e0bffcc3 	ldbu	r2,-13(fp)
811136d4:	18bf9636 	bltu	r3,r2,81113530 <__reset+0xfb0f3530>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
811136d8:	d0a05f17 	ldw	r2,-32388(gp)
811136dc:	e0fffa03 	ldbu	r3,-24(fp)
811136e0:	180d883a 	mov	r6,r3
811136e4:	01604534 	movhi	r5,33044
811136e8:	295e7104 	addi	r5,r5,31172
811136ec:	1009883a 	mov	r4,r2
811136f0:	111a9600 	call	8111a960 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811136f4:	e0bffa03 	ldbu	r2,-24(fp)
811136f8:	10800044 	addi	r2,r2,1
811136fc:	e0bffa05 	stb	r2,-24(fp)
81113700:	e0bffa03 	ldbu	r2,-24(fp)
81113704:	108000b0 	cmpltui	r2,r2,2
81113708:	103f871e 	bne	r2,zero,81113528 <__reset+0xfb0f3528>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
8111370c:	d0a05f17 	ldw	r2,-32388(gp)
81113710:	100f883a 	mov	r7,r2
81113714:	01800404 	movi	r6,16
81113718:	01400044 	movi	r5,1
8111371c:	01204534 	movhi	r4,33044
81113720:	211e7504 	addi	r4,r4,31188
81113724:	111affc0 	call	8111affc <fwrite>
#endif


}
81113728:	0001883a 	nop
8111372c:	e037883a 	mov	sp,fp
81113730:	dfc00117 	ldw	ra,4(sp)
81113734:	df000017 	ldw	fp,0(sp)
81113738:	dec00204 	addi	sp,sp,8
8111373c:	f800283a 	ret

81113740 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81113740:	defff604 	addi	sp,sp,-40
81113744:	de00012e 	bgeu	sp,et,8111374c <vPrintMemmoryPattern+0xc>
81113748:	003b68fa 	trap	3
8111374c:	dfc00915 	stw	ra,36(sp)
81113750:	df000815 	stw	fp,32(sp)
81113754:	df000804 	addi	fp,sp,32
81113758:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8111375c:	00800044 	movi	r2,1
81113760:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81113764:	d0a05f17 	ldw	r2,-32388(gp)
81113768:	100f883a 	mov	r7,r2
8111376c:	018009c4 	movi	r6,39
81113770:	01400044 	movi	r5,1
81113774:	01204534 	movhi	r4,33044
81113778:	211e6204 	addi	r4,r4,31112
8111377c:	111affc0 	call	8111affc <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113780:	e03ffa05 	stb	zero,-24(fp)
81113784:	00007606 	br	81113960 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113788:	e03ffc85 	stb	zero,-14(fp)
8111378c:	00006706 	br	8111392c <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81113790:	e0bffc83 	ldbu	r2,-14(fp)
81113794:	e0ffff17 	ldw	r3,-4(fp)
81113798:	10809224 	muli	r2,r2,584
8111379c:	1885883a 	add	r2,r3,r2
811137a0:	10803d04 	addi	r2,r2,244
811137a4:	1080000b 	ldhu	r2,0(r2)
811137a8:	10ffffcc 	andi	r3,r2,65535
811137ac:	e0bffc83 	ldbu	r2,-14(fp)
811137b0:	e13fff17 	ldw	r4,-4(fp)
811137b4:	10809224 	muli	r2,r2,584
811137b8:	2085883a 	add	r2,r4,r2
811137bc:	10803c04 	addi	r2,r2,240
811137c0:	1080000b 	ldhu	r2,0(r2)
811137c4:	10bfffcc 	andi	r2,r2,65535
811137c8:	1885883a 	add	r2,r3,r2
811137cc:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811137d0:	e0bffc83 	ldbu	r2,-14(fp)
811137d4:	e0ffff17 	ldw	r3,-4(fp)
811137d8:	10809224 	muli	r2,r2,584
811137dc:	1885883a 	add	r2,r3,r2
811137e0:	10803c84 	addi	r2,r2,242
811137e4:	1080000b 	ldhu	r2,0(r2)
811137e8:	10ffffcc 	andi	r3,r2,65535
811137ec:	e0bffc83 	ldbu	r2,-14(fp)
811137f0:	e13fff17 	ldw	r4,-4(fp)
811137f4:	10809224 	muli	r2,r2,584
811137f8:	2085883a 	add	r2,r4,r2
811137fc:	10803b84 	addi	r2,r2,238
81113800:	1080000b 	ldhu	r2,0(r2)
81113804:	10bfffcc 	andi	r2,r2,65535
81113808:	1887883a 	add	r3,r3,r2
8111380c:	e0bffc83 	ldbu	r2,-14(fp)
81113810:	e13fff17 	ldw	r4,-4(fp)
81113814:	10809224 	muli	r2,r2,584
81113818:	2085883a 	add	r2,r4,r2
8111381c:	10803b04 	addi	r2,r2,236
81113820:	1080000b 	ldhu	r2,0(r2)
81113824:	10bfffcc 	andi	r2,r2,65535
81113828:	1885883a 	add	r2,r3,r2
8111382c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81113830:	e03ffc05 	stb	zero,-16(fp)
81113834:	00003706 	br	81113914 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81113838:	e03ffc45 	stb	zero,-15(fp)
8111383c:	00002606 	br	811138d8 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81113840:	e0bffc43 	ldbu	r2,-15(fp)
81113844:	10000b1e 	bne	r2,zero,81113874 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81113848:	e0bffc83 	ldbu	r2,-14(fp)
8111384c:	e13ffc03 	ldbu	r4,-16(fp)
81113850:	e0ffff17 	ldw	r3,-4(fp)
81113854:	21000624 	muli	r4,r4,24
81113858:	10809224 	muli	r2,r2,584
8111385c:	2085883a 	add	r2,r4,r2
81113860:	1885883a 	add	r2,r3,r2
81113864:	10801804 	addi	r2,r2,96
81113868:	10800017 	ldw	r2,0(r2)
8111386c:	e0bffb15 	stw	r2,-20(fp)
81113870:	00000a06 	br	8111389c <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81113874:	e0bffc83 	ldbu	r2,-14(fp)
81113878:	e13ffc03 	ldbu	r4,-16(fp)
8111387c:	e0ffff17 	ldw	r3,-4(fp)
81113880:	21000624 	muli	r4,r4,24
81113884:	10809224 	muli	r2,r2,584
81113888:	2085883a 	add	r2,r4,r2
8111388c:	1885883a 	add	r2,r3,r2
81113890:	10801b04 	addi	r2,r2,108
81113894:	10800017 	ldw	r2,0(r2)
81113898:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8111389c:	e0fffa03 	ldbu	r3,-24(fp)
811138a0:	e13ffc03 	ldbu	r4,-16(fp)
811138a4:	e17ffc43 	ldbu	r5,-15(fp)
811138a8:	e0bffe17 	ldw	r2,-8(fp)
811138ac:	d8800115 	stw	r2,4(sp)
811138b0:	e0bffd17 	ldw	r2,-12(fp)
811138b4:	d8800015 	stw	r2,0(sp)
811138b8:	280f883a 	mov	r7,r5
811138bc:	200d883a 	mov	r6,r4
811138c0:	e17ffb17 	ldw	r5,-20(fp)
811138c4:	1809883a 	mov	r4,r3
811138c8:	11187fc0 	call	811187fc <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811138cc:	e0bffc43 	ldbu	r2,-15(fp)
811138d0:	10800044 	addi	r2,r2,1
811138d4:	e0bffc45 	stb	r2,-15(fp)
811138d8:	e0bffc43 	ldbu	r2,-15(fp)
811138dc:	108000b0 	cmpltui	r2,r2,2
811138e0:	103fd71e 	bne	r2,zero,81113840 <__reset+0xfb0f3840>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
811138e4:	d0a05f17 	ldw	r2,-32388(gp)
811138e8:	e0fffc83 	ldbu	r3,-14(fp)
811138ec:	e13ffc03 	ldbu	r4,-16(fp)
811138f0:	200f883a 	mov	r7,r4
811138f4:	180d883a 	mov	r6,r3
811138f8:	01604534 	movhi	r5,33044
811138fc:	295e6c04 	addi	r5,r5,31152
81113900:	1009883a 	mov	r4,r2
81113904:	111a9600 	call	8111a960 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81113908:	e0bffc03 	ldbu	r2,-16(fp)
8111390c:	10800044 	addi	r2,r2,1
81113910:	e0bffc05 	stb	r2,-16(fp)
81113914:	e0bffc03 	ldbu	r2,-16(fp)
81113918:	10800130 	cmpltui	r2,r2,4
8111391c:	103fc61e 	bne	r2,zero,81113838 <__reset+0xfb0f3838>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113920:	e0bffc83 	ldbu	r2,-14(fp)
81113924:	10800044 	addi	r2,r2,1
81113928:	e0bffc85 	stb	r2,-14(fp)
8111392c:	e0fffc83 	ldbu	r3,-14(fp)
81113930:	e0bffcc3 	ldbu	r2,-13(fp)
81113934:	18bf9636 	bltu	r3,r2,81113790 <__reset+0xfb0f3790>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81113938:	d0a05f17 	ldw	r2,-32388(gp)
8111393c:	e0fffa03 	ldbu	r3,-24(fp)
81113940:	180d883a 	mov	r6,r3
81113944:	01604534 	movhi	r5,33044
81113948:	295e7104 	addi	r5,r5,31172
8111394c:	1009883a 	mov	r4,r2
81113950:	111a9600 	call	8111a960 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113954:	e0bffa03 	ldbu	r2,-24(fp)
81113958:	10800044 	addi	r2,r2,1
8111395c:	e0bffa05 	stb	r2,-24(fp)
81113960:	e0bffa03 	ldbu	r2,-24(fp)
81113964:	108000b0 	cmpltui	r2,r2,2
81113968:	103f871e 	bne	r2,zero,81113788 <__reset+0xfb0f3788>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
8111396c:	d0a05f17 	ldw	r2,-32388(gp)
81113970:	100f883a 	mov	r7,r2
81113974:	01800404 	movi	r6,16
81113978:	01400044 	movi	r5,1
8111397c:	01204534 	movhi	r4,33044
81113980:	211e7504 	addi	r4,r4,31188
81113984:	111affc0 	call	8111affc <fwrite>
#endif


}
81113988:	0001883a 	nop
8111398c:	e037883a 	mov	sp,fp
81113990:	dfc00117 	ldw	ra,4(sp)
81113994:	df000017 	ldw	fp,0(sp)
81113998:	dec00204 	addi	sp,sp,8
8111399c:	f800283a 	ret

811139a0 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
811139a0:	defffe04 	addi	sp,sp,-8
811139a4:	de00012e 	bgeu	sp,et,811139ac <vCCDLoadDefaultValues+0xc>
811139a8:	003b68fa 	trap	3
811139ac:	df000115 	stw	fp,4(sp)
811139b0:	df000104 	addi	fp,sp,4
811139b4:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
811139b8:	e0bfff17 	ldw	r2,-4(fp)
811139bc:	00c46784 	movi	r3,4510
811139c0:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
811139c4:	e0bfff17 	ldw	r2,-4(fp)
811139c8:	00c00784 	movi	r3,30
811139cc:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
811139d0:	e0bfff17 	ldw	r2,-4(fp)
811139d4:	00c233c4 	movi	r3,2255
811139d8:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
811139dc:	e0bfff17 	ldw	r2,-4(fp)
811139e0:	00c003c4 	movi	r3,15
811139e4:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
811139e8:	e0bfff17 	ldw	r2,-4(fp)
811139ec:	00c00644 	movi	r3,25
811139f0:	10c0000d 	sth	r3,0(r2)
}
811139f4:	0001883a 	nop
811139f8:	e037883a 	mov	sp,fp
811139fc:	df000017 	ldw	fp,0(sp)
81113a00:	dec00104 	addi	sp,sp,4
81113a04:	f800283a 	ret

81113a08 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81113a08:	defff904 	addi	sp,sp,-28
81113a0c:	de00012e 	bgeu	sp,et,81113a14 <vCCDChangeValues+0xc>
81113a10:	003b68fa 	trap	3
81113a14:	df000615 	stw	fp,24(sp)
81113a18:	df000604 	addi	fp,sp,24
81113a1c:	e13ffa15 	stw	r4,-24(fp)
81113a20:	2811883a 	mov	r8,r5
81113a24:	300b883a 	mov	r5,r6
81113a28:	3809883a 	mov	r4,r7
81113a2c:	e0c00117 	ldw	r3,4(fp)
81113a30:	e0800217 	ldw	r2,8(fp)
81113a34:	e23ffb0d 	sth	r8,-20(fp)
81113a38:	e17ffc0d 	sth	r5,-16(fp)
81113a3c:	e13ffd0d 	sth	r4,-12(fp)
81113a40:	e0fffe0d 	sth	r3,-8(fp)
81113a44:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81113a48:	e0bffa17 	ldw	r2,-24(fp)
81113a4c:	e0fffb0b 	ldhu	r3,-20(fp)
81113a50:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81113a54:	e0bffa17 	ldw	r2,-24(fp)
81113a58:	e0fffc0b 	ldhu	r3,-16(fp)
81113a5c:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81113a60:	e0bffa17 	ldw	r2,-24(fp)
81113a64:	e0fffd0b 	ldhu	r3,-12(fp)
81113a68:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81113a6c:	e0bffa17 	ldw	r2,-24(fp)
81113a70:	e0fffe0b 	ldhu	r3,-8(fp)
81113a74:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81113a78:	e0bffa17 	ldw	r2,-24(fp)
81113a7c:	e0ffff0b 	ldhu	r3,-4(fp)
81113a80:	10c0000d 	sth	r3,0(r2)
}
81113a84:	0001883a 	nop
81113a88:	e037883a 	mov	sp,fp
81113a8c:	df000017 	ldw	fp,0(sp)
81113a90:	dec00104 	addi	sp,sp,4
81113a94:	f800283a 	ret

81113a98 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81113a98:	defff904 	addi	sp,sp,-28
81113a9c:	de00012e 	bgeu	sp,et,81113aa4 <bSendUART128v2+0xc>
81113aa0:	003b68fa 	trap	3
81113aa4:	dfc00615 	stw	ra,24(sp)
81113aa8:	df000515 	stw	fp,20(sp)
81113aac:	df000504 	addi	fp,sp,20
81113ab0:	e13ffe15 	stw	r4,-8(fp)
81113ab4:	2805883a 	mov	r2,r5
81113ab8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81113abc:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81113ac0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81113ac4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81113ac8:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81113acc:	d0a06017 	ldw	r2,-32384(gp)
81113ad0:	e0fffd04 	addi	r3,fp,-12
81113ad4:	180d883a 	mov	r6,r3
81113ad8:	01400504 	movi	r5,20
81113adc:	1009883a 	mov	r4,r2
81113ae0:	1138a3c0 	call	81138a3c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81113ae4:	e0bffd03 	ldbu	r2,-12(fp)
81113ae8:	10803fcc 	andi	r2,r2,255
81113aec:	10000326 	beq	r2,zero,81113afc <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81113af0:	111644c0 	call	8111644c <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81113af4:	e0bffc17 	ldw	r2,-16(fp)
81113af8:	00009e06 	br	81113d74 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81113afc:	d0a07217 	ldw	r2,-32312(gp)
81113b00:	e0fffd04 	addi	r3,fp,-12
81113b04:	180d883a 	mov	r6,r3
81113b08:	01400104 	movi	r5,4
81113b0c:	1009883a 	mov	r4,r2
81113b10:	1136a300 	call	81136a30 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113b14:	e0bffd03 	ldbu	r2,-12(fp)
81113b18:	10803fcc 	andi	r2,r2,255
81113b1c:	10001126 	beq	r2,zero,81113b64 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81113b20:	d0a05f17 	ldw	r2,-32388(gp)
81113b24:	100f883a 	mov	r7,r2
81113b28:	01801484 	movi	r6,82
81113b2c:	01400044 	movi	r5,1
81113b30:	01204534 	movhi	r4,33044
81113b34:	211e7a04 	addi	r4,r4,31208
81113b38:	111affc0 	call	8111affc <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81113b3c:	d0a06017 	ldw	r2,-32384(gp)
81113b40:	1009883a 	mov	r4,r2
81113b44:	1138dc40 	call	81138dc4 <OSSemPost>
81113b48:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81113b4c:	e0bffd03 	ldbu	r2,-12(fp)
81113b50:	10803fcc 	andi	r2,r2,255
81113b54:	10000126 	beq	r2,zero,81113b5c <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81113b58:	11163e40 	call	811163e4 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81113b5c:	e0bffc17 	ldw	r2,-16(fp)
81113b60:	00008406 	br	81113d74 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113b64:	e03ffb05 	stb	zero,-20(fp)
81113b68:	00004306 	br	81113c78 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81113b6c:	e0fffb03 	ldbu	r3,-20(fp)
81113b70:	00a04574 	movhi	r2,33045
81113b74:	109ef704 	addi	r2,r2,31708
81113b78:	18c7883a 	add	r3,r3,r3
81113b7c:	18c7883a 	add	r3,r3,r3
81113b80:	10c5883a 	add	r2,r2,r3
81113b84:	10800017 	ldw	r2,0(r2)
81113b88:	1000381e 	bne	r2,zero,81113c6c <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81113b8c:	e0bffb03 	ldbu	r2,-20(fp)
81113b90:	10c02324 	muli	r3,r2,140
81113b94:	00a04574 	movhi	r2,33045
81113b98:	109f1504 	addi	r2,r2,31828
81113b9c:	1885883a 	add	r2,r3,r2
81113ba0:	01802004 	movi	r6,128
81113ba4:	000b883a 	mov	r5,zero
81113ba8:	1009883a 	mov	r4,r2
81113bac:	111bb600 	call	8111bb60 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81113bb0:	e0bffb03 	ldbu	r2,-20(fp)
81113bb4:	10c02324 	muli	r3,r2,140
81113bb8:	00a04574 	movhi	r2,33045
81113bbc:	109f1504 	addi	r2,r2,31828
81113bc0:	1885883a 	add	r2,r3,r2
81113bc4:	01801fc4 	movi	r6,127
81113bc8:	e17ffe17 	ldw	r5,-8(fp)
81113bcc:	1009883a 	mov	r4,r2
81113bd0:	111ba100 	call	8111ba10 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81113bd4:	e13ffb03 	ldbu	r4,-20(fp)
81113bd8:	e0ffff0b 	ldhu	r3,-4(fp)
81113bdc:	00a04574 	movhi	r2,33045
81113be0:	109f1504 	addi	r2,r2,31828
81113be4:	21002324 	muli	r4,r4,140
81113be8:	1105883a 	add	r2,r2,r4
81113bec:	10802104 	addi	r2,r2,132
81113bf0:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81113bf4:	e0fffb03 	ldbu	r3,-20(fp)
81113bf8:	00a04574 	movhi	r2,33045
81113bfc:	109f1504 	addi	r2,r2,31828
81113c00:	18c02324 	muli	r3,r3,140
81113c04:	10c5883a 	add	r2,r2,r3
81113c08:	10802204 	addi	r2,r2,136
81113c0c:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81113c10:	e0fffb03 	ldbu	r3,-20(fp)
81113c14:	00a04574 	movhi	r2,33045
81113c18:	109f1504 	addi	r2,r2,31828
81113c1c:	18c02324 	muli	r3,r3,140
81113c20:	10c5883a 	add	r2,r2,r3
81113c24:	10802184 	addi	r2,r2,134
81113c28:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81113c2c:	e0fffb03 	ldbu	r3,-20(fp)
81113c30:	00a04574 	movhi	r2,33045
81113c34:	109f1504 	addi	r2,r2,31828
81113c38:	18c02324 	muli	r3,r3,140
81113c3c:	10c5883a 	add	r2,r2,r3
81113c40:	10802004 	addi	r2,r2,128
81113c44:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81113c48:	e0fffb03 	ldbu	r3,-20(fp)
81113c4c:	00a04574 	movhi	r2,33045
81113c50:	109ef704 	addi	r2,r2,31708
81113c54:	18c7883a 	add	r3,r3,r3
81113c58:	18c7883a 	add	r3,r3,r3
81113c5c:	10c5883a 	add	r2,r2,r3
81113c60:	00c00044 	movi	r3,1
81113c64:	10c00015 	stw	r3,0(r2)
			break;
81113c68:	00000606 	br	81113c84 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113c6c:	e0bffb03 	ldbu	r2,-20(fp)
81113c70:	10800044 	addi	r2,r2,1
81113c74:	e0bffb05 	stb	r2,-20(fp)
81113c78:	e0bffb03 	ldbu	r2,-20(fp)
81113c7c:	108001b0 	cmpltui	r2,r2,6
81113c80:	103fba1e 	bne	r2,zero,81113b6c <__reset+0xfb0f3b6c>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81113c84:	e0bffb03 	ldbu	r2,-20(fp)
81113c88:	108001b0 	cmpltui	r2,r2,6
81113c8c:	1000091e 	bne	r2,zero,81113cb4 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81113c90:	d0a06017 	ldw	r2,-32384(gp)
81113c94:	1009883a 	mov	r4,r2
81113c98:	1138dc40 	call	81138dc4 <OSSemPost>
81113c9c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81113ca0:	d0a07217 	ldw	r2,-32312(gp)
81113ca4:	1009883a 	mov	r4,r2
81113ca8:	1136fd40 	call	81136fd4 <OSMutexPost>
		return bSuccessL;
81113cac:	e0bffc17 	ldw	r2,-16(fp)
81113cb0:	00003006 	br	81113d74 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81113cb4:	00800044 	movi	r2,1
81113cb8:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81113cbc:	d0a07843 	ldbu	r2,-32287(gp)
81113cc0:	10bfffc4 	addi	r2,r2,-1
81113cc4:	d0a07845 	stb	r2,-32287(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81113cc8:	d0a07717 	ldw	r2,-32292(gp)
81113ccc:	e0fffd04 	addi	r3,fp,-12
81113cd0:	180d883a 	mov	r6,r3
81113cd4:	01400084 	movi	r5,2
81113cd8:	1009883a 	mov	r4,r2
81113cdc:	1136a300 	call	81136a30 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113ce0:	e0bffd03 	ldbu	r2,-12(fp)
81113ce4:	10803fcc 	andi	r2,r2,255
81113ce8:	10000c26 	beq	r2,zero,81113d1c <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81113cec:	d0a05f17 	ldw	r2,-32388(gp)
81113cf0:	100f883a 	mov	r7,r2
81113cf4:	01801c04 	movi	r6,112
81113cf8:	01400044 	movi	r5,1
81113cfc:	01204534 	movhi	r4,33044
81113d00:	211e8f04 	addi	r4,r4,31292
81113d04:	111affc0 	call	8111affc <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81113d08:	d0a07217 	ldw	r2,-32312(gp)
81113d0c:	1009883a 	mov	r4,r2
81113d10:	1136fd40 	call	81136fd4 <OSMutexPost>
		return bSuccessL;
81113d14:	e0bffc17 	ldw	r2,-16(fp)
81113d18:	00001606 	br	81113d74 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81113d1c:	e0bffb03 	ldbu	r2,-20(fp)
81113d20:	10c02324 	muli	r3,r2,140
81113d24:	00a04574 	movhi	r2,33045
81113d28:	109f1504 	addi	r2,r2,31828
81113d2c:	1885883a 	add	r2,r3,r2
81113d30:	1009883a 	mov	r4,r2
81113d34:	111bfac0 	call	8111bfac <puts>
	xBuffer128[ucIL].bSent = TRUE;
81113d38:	e0fffb03 	ldbu	r3,-20(fp)
81113d3c:	00a04574 	movhi	r2,33045
81113d40:	109f1504 	addi	r2,r2,31828
81113d44:	18c02324 	muli	r3,r3,140
81113d48:	10c5883a 	add	r2,r2,r3
81113d4c:	10802004 	addi	r2,r2,128
81113d50:	00c00044 	movi	r3,1
81113d54:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81113d58:	d0a07717 	ldw	r2,-32292(gp)
81113d5c:	1009883a 	mov	r4,r2
81113d60:	1136fd40 	call	81136fd4 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81113d64:	d0a07217 	ldw	r2,-32312(gp)
81113d68:	1009883a 	mov	r4,r2
81113d6c:	1136fd40 	call	81136fd4 <OSMutexPost>

	return bSuccessL;
81113d70:	e0bffc17 	ldw	r2,-16(fp)
}
81113d74:	e037883a 	mov	sp,fp
81113d78:	dfc00117 	ldw	ra,4(sp)
81113d7c:	df000017 	ldw	fp,0(sp)
81113d80:	dec00204 	addi	sp,sp,8
81113d84:	f800283a 	ret

81113d88 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81113d88:	defff904 	addi	sp,sp,-28
81113d8c:	de00012e 	bgeu	sp,et,81113d94 <bSendUART64v2+0xc>
81113d90:	003b68fa 	trap	3
81113d94:	dfc00615 	stw	ra,24(sp)
81113d98:	df000515 	stw	fp,20(sp)
81113d9c:	df000504 	addi	fp,sp,20
81113da0:	e13ffe15 	stw	r4,-8(fp)
81113da4:	2805883a 	mov	r2,r5
81113da8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81113dac:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81113db0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81113db4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81113db8:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81113dbc:	d0a05a17 	ldw	r2,-32408(gp)
81113dc0:	e0fffd04 	addi	r3,fp,-12
81113dc4:	180d883a 	mov	r6,r3
81113dc8:	01400504 	movi	r5,20
81113dcc:	1009883a 	mov	r4,r2
81113dd0:	1138a3c0 	call	81138a3c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81113dd4:	e0bffd03 	ldbu	r2,-12(fp)
81113dd8:	10803fcc 	andi	r2,r2,255
81113ddc:	10000326 	beq	r2,zero,81113dec <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81113de0:	11164b40 	call	811164b4 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81113de4:	e0bffc17 	ldw	r2,-16(fp)
81113de8:	0000a006 	br	8111406c <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81113dec:	d0a07417 	ldw	r2,-32304(gp)
81113df0:	e0fffd04 	addi	r3,fp,-12
81113df4:	180d883a 	mov	r6,r3
81113df8:	01400104 	movi	r5,4
81113dfc:	1009883a 	mov	r4,r2
81113e00:	1136a300 	call	81136a30 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113e04:	e0bffd03 	ldbu	r2,-12(fp)
81113e08:	10803fcc 	andi	r2,r2,255
81113e0c:	10001126 	beq	r2,zero,81113e54 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81113e10:	d0a05f17 	ldw	r2,-32388(gp)
81113e14:	100f883a 	mov	r7,r2
81113e18:	018013c4 	movi	r6,79
81113e1c:	01400044 	movi	r5,1
81113e20:	01204534 	movhi	r4,33044
81113e24:	211eac04 	addi	r4,r4,31408
81113e28:	111affc0 	call	8111affc <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81113e2c:	d0a05a17 	ldw	r2,-32408(gp)
81113e30:	1009883a 	mov	r4,r2
81113e34:	1138dc40 	call	81138dc4 <OSSemPost>
81113e38:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81113e3c:	e0bffd03 	ldbu	r2,-12(fp)
81113e40:	10803fcc 	andi	r2,r2,255
81113e44:	10000126 	beq	r2,zero,81113e4c <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81113e48:	111637c0 	call	8111637c <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81113e4c:	e0bffc17 	ldw	r2,-16(fp)
81113e50:	00008606 	br	8111406c <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81113e54:	e03ffb05 	stb	zero,-20(fp)
81113e58:	00004506 	br	81113f70 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81113e5c:	e0fffb03 	ldbu	r3,-20(fp)
81113e60:	00a04574 	movhi	r2,33045
81113e64:	109ef704 	addi	r2,r2,31708
81113e68:	18c00184 	addi	r3,r3,6
81113e6c:	18c7883a 	add	r3,r3,r3
81113e70:	18c7883a 	add	r3,r3,r3
81113e74:	10c5883a 	add	r2,r2,r3
81113e78:	10800017 	ldw	r2,0(r2)
81113e7c:	1000391e 	bne	r2,zero,81113f64 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81113e80:	e0bffb03 	ldbu	r2,-20(fp)
81113e84:	10c01324 	muli	r3,r2,76
81113e88:	00a04574 	movhi	r2,33045
81113e8c:	10bae904 	addi	r2,r2,-5212
81113e90:	1885883a 	add	r2,r3,r2
81113e94:	01801004 	movi	r6,64
81113e98:	000b883a 	mov	r5,zero
81113e9c:	1009883a 	mov	r4,r2
81113ea0:	111bb600 	call	8111bb60 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81113ea4:	e0bffb03 	ldbu	r2,-20(fp)
81113ea8:	10c01324 	muli	r3,r2,76
81113eac:	00a04574 	movhi	r2,33045
81113eb0:	10bae904 	addi	r2,r2,-5212
81113eb4:	1885883a 	add	r2,r3,r2
81113eb8:	01800fc4 	movi	r6,63
81113ebc:	e17ffe17 	ldw	r5,-8(fp)
81113ec0:	1009883a 	mov	r4,r2
81113ec4:	111ba100 	call	8111ba10 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81113ec8:	e13ffb03 	ldbu	r4,-20(fp)
81113ecc:	e0ffff0b 	ldhu	r3,-4(fp)
81113ed0:	00a04574 	movhi	r2,33045
81113ed4:	10bae904 	addi	r2,r2,-5212
81113ed8:	21001324 	muli	r4,r4,76
81113edc:	1105883a 	add	r2,r2,r4
81113ee0:	10801104 	addi	r2,r2,68
81113ee4:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81113ee8:	e0fffb03 	ldbu	r3,-20(fp)
81113eec:	00a04574 	movhi	r2,33045
81113ef0:	10bae904 	addi	r2,r2,-5212
81113ef4:	18c01324 	muli	r3,r3,76
81113ef8:	10c5883a 	add	r2,r2,r3
81113efc:	10801204 	addi	r2,r2,72
81113f00:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81113f04:	e0fffb03 	ldbu	r3,-20(fp)
81113f08:	00a04574 	movhi	r2,33045
81113f0c:	10bae904 	addi	r2,r2,-5212
81113f10:	18c01324 	muli	r3,r3,76
81113f14:	10c5883a 	add	r2,r2,r3
81113f18:	10801184 	addi	r2,r2,70
81113f1c:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81113f20:	e0fffb03 	ldbu	r3,-20(fp)
81113f24:	00a04574 	movhi	r2,33045
81113f28:	10bae904 	addi	r2,r2,-5212
81113f2c:	18c01324 	muli	r3,r3,76
81113f30:	10c5883a 	add	r2,r2,r3
81113f34:	10801004 	addi	r2,r2,64
81113f38:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81113f3c:	e0fffb03 	ldbu	r3,-20(fp)
81113f40:	00a04574 	movhi	r2,33045
81113f44:	109ef704 	addi	r2,r2,31708
81113f48:	18c00184 	addi	r3,r3,6
81113f4c:	18c7883a 	add	r3,r3,r3
81113f50:	18c7883a 	add	r3,r3,r3
81113f54:	10c5883a 	add	r2,r2,r3
81113f58:	00c00044 	movi	r3,1
81113f5c:	10c00015 	stw	r3,0(r2)
			break;
81113f60:	00000606 	br	81113f7c <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81113f64:	e0bffb03 	ldbu	r2,-20(fp)
81113f68:	10800044 	addi	r2,r2,1
81113f6c:	e0bffb05 	stb	r2,-20(fp)
81113f70:	e0bffb03 	ldbu	r2,-20(fp)
81113f74:	10800230 	cmpltui	r2,r2,8
81113f78:	103fb81e 	bne	r2,zero,81113e5c <__reset+0xfb0f3e5c>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81113f7c:	e0bffb03 	ldbu	r2,-20(fp)
81113f80:	10800230 	cmpltui	r2,r2,8
81113f84:	1000091e 	bne	r2,zero,81113fac <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81113f88:	d0a05a17 	ldw	r2,-32408(gp)
81113f8c:	1009883a 	mov	r4,r2
81113f90:	1138dc40 	call	81138dc4 <OSSemPost>
81113f94:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81113f98:	d0a07417 	ldw	r2,-32304(gp)
81113f9c:	1009883a 	mov	r4,r2
81113fa0:	1136fd40 	call	81136fd4 <OSMutexPost>
		return bSuccessL;
81113fa4:	e0bffc17 	ldw	r2,-16(fp)
81113fa8:	00003006 	br	8111406c <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
81113fac:	00800044 	movi	r2,1
81113fb0:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81113fb4:	d0a07803 	ldbu	r2,-32288(gp)
81113fb8:	10bfffc4 	addi	r2,r2,-1
81113fbc:	d0a07805 	stb	r2,-32288(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81113fc0:	d0a07717 	ldw	r2,-32292(gp)
81113fc4:	e0fffd04 	addi	r3,fp,-12
81113fc8:	180d883a 	mov	r6,r3
81113fcc:	01400084 	movi	r5,2
81113fd0:	1009883a 	mov	r4,r2
81113fd4:	1136a300 	call	81136a30 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113fd8:	e0bffd03 	ldbu	r2,-12(fp)
81113fdc:	10803fcc 	andi	r2,r2,255
81113fe0:	10000c26 	beq	r2,zero,81114014 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81113fe4:	d0a05f17 	ldw	r2,-32388(gp)
81113fe8:	100f883a 	mov	r7,r2
81113fec:	01801bc4 	movi	r6,111
81113ff0:	01400044 	movi	r5,1
81113ff4:	01204534 	movhi	r4,33044
81113ff8:	211ec004 	addi	r4,r4,31488
81113ffc:	111affc0 	call	8111affc <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81114000:	d0a07417 	ldw	r2,-32304(gp)
81114004:	1009883a 	mov	r4,r2
81114008:	1136fd40 	call	81136fd4 <OSMutexPost>
		return bSuccessL;
8111400c:	e0bffc17 	ldw	r2,-16(fp)
81114010:	00001606 	br	8111406c <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81114014:	e0bffb03 	ldbu	r2,-20(fp)
81114018:	10c01324 	muli	r3,r2,76
8111401c:	00a04574 	movhi	r2,33045
81114020:	10bae904 	addi	r2,r2,-5212
81114024:	1885883a 	add	r2,r3,r2
81114028:	1009883a 	mov	r4,r2
8111402c:	111bfac0 	call	8111bfac <puts>
	xBuffer64[ucIL].bSent = TRUE;
81114030:	e0fffb03 	ldbu	r3,-20(fp)
81114034:	00a04574 	movhi	r2,33045
81114038:	10bae904 	addi	r2,r2,-5212
8111403c:	18c01324 	muli	r3,r3,76
81114040:	10c5883a 	add	r2,r2,r3
81114044:	10801004 	addi	r2,r2,64
81114048:	00c00044 	movi	r3,1
8111404c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81114050:	d0a07717 	ldw	r2,-32292(gp)
81114054:	1009883a 	mov	r4,r2
81114058:	1136fd40 	call	81136fd4 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
8111405c:	d0a07417 	ldw	r2,-32304(gp)
81114060:	1009883a 	mov	r4,r2
81114064:	1136fd40 	call	81136fd4 <OSMutexPost>

	return bSuccessL;
81114068:	e0bffc17 	ldw	r2,-16(fp)
}
8111406c:	e037883a 	mov	sp,fp
81114070:	dfc00117 	ldw	ra,4(sp)
81114074:	df000017 	ldw	fp,0(sp)
81114078:	dec00204 	addi	sp,sp,8
8111407c:	f800283a 	ret

81114080 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81114080:	defff904 	addi	sp,sp,-28
81114084:	de00012e 	bgeu	sp,et,8111408c <bSendUART32v2+0xc>
81114088:	003b68fa 	trap	3
8111408c:	dfc00615 	stw	ra,24(sp)
81114090:	df000515 	stw	fp,20(sp)
81114094:	df000504 	addi	fp,sp,20
81114098:	e13ffe15 	stw	r4,-8(fp)
8111409c:	2805883a 	mov	r2,r5
811140a0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
811140a4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811140a8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811140ac:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811140b0:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811140b4:	d0a07317 	ldw	r2,-32308(gp)
811140b8:	e0fffd04 	addi	r3,fp,-12
811140bc:	180d883a 	mov	r6,r3
811140c0:	01400504 	movi	r5,20
811140c4:	1009883a 	mov	r4,r2
811140c8:	1138a3c0 	call	81138a3c <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811140cc:	e0bffd03 	ldbu	r2,-12(fp)
811140d0:	10803fcc 	andi	r2,r2,255
811140d4:	10000326 	beq	r2,zero,811140e4 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811140d8:	111651c0 	call	8111651c <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811140dc:	e0bffc17 	ldw	r2,-16(fp)
811140e0:	0000a006 	br	81114364 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811140e4:	d0a07017 	ldw	r2,-32320(gp)
811140e8:	e0fffd04 	addi	r3,fp,-12
811140ec:	180d883a 	mov	r6,r3
811140f0:	01400104 	movi	r5,4
811140f4:	1009883a 	mov	r4,r2
811140f8:	1136a300 	call	81136a30 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811140fc:	e0bffd03 	ldbu	r2,-12(fp)
81114100:	10803fcc 	andi	r2,r2,255
81114104:	10001126 	beq	r2,zero,8111414c <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81114108:	d0a05f17 	ldw	r2,-32388(gp)
8111410c:	100f883a 	mov	r7,r2
81114110:	018013c4 	movi	r6,79
81114114:	01400044 	movi	r5,1
81114118:	01204534 	movhi	r4,33044
8111411c:	211edc04 	addi	r4,r4,31600
81114120:	111affc0 	call	8111affc <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81114124:	d0a07317 	ldw	r2,-32308(gp)
81114128:	1009883a 	mov	r4,r2
8111412c:	1138dc40 	call	81138dc4 <OSSemPost>
81114130:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81114134:	e0bffd03 	ldbu	r2,-12(fp)
81114138:	10803fcc 	andi	r2,r2,255
8111413c:	10000126 	beq	r2,zero,81114144 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81114140:	11163140 	call	81116314 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81114144:	e0bffc17 	ldw	r2,-16(fp)
81114148:	00008606 	br	81114364 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8111414c:	e03ffb05 	stb	zero,-20(fp)
81114150:	00004506 	br	81114268 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81114154:	e0fffb03 	ldbu	r3,-20(fp)
81114158:	00a04574 	movhi	r2,33045
8111415c:	109ef704 	addi	r2,r2,31708
81114160:	18c00384 	addi	r3,r3,14
81114164:	18c7883a 	add	r3,r3,r3
81114168:	18c7883a 	add	r3,r3,r3
8111416c:	10c5883a 	add	r2,r2,r3
81114170:	10800017 	ldw	r2,0(r2)
81114174:	1000391e 	bne	r2,zero,8111425c <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81114178:	e0bffb03 	ldbu	r2,-20(fp)
8111417c:	10c00b24 	muli	r3,r2,44
81114180:	00a04574 	movhi	r2,33045
81114184:	108c8b04 	addi	r2,r2,12844
81114188:	1885883a 	add	r2,r3,r2
8111418c:	01800804 	movi	r6,32
81114190:	000b883a 	mov	r5,zero
81114194:	1009883a 	mov	r4,r2
81114198:	111bb600 	call	8111bb60 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
8111419c:	e0bffb03 	ldbu	r2,-20(fp)
811141a0:	10c00b24 	muli	r3,r2,44
811141a4:	00a04574 	movhi	r2,33045
811141a8:	108c8b04 	addi	r2,r2,12844
811141ac:	1885883a 	add	r2,r3,r2
811141b0:	018007c4 	movi	r6,31
811141b4:	e17ffe17 	ldw	r5,-8(fp)
811141b8:	1009883a 	mov	r4,r2
811141bc:	111ba100 	call	8111ba10 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
811141c0:	e13ffb03 	ldbu	r4,-20(fp)
811141c4:	e0ffff0b 	ldhu	r3,-4(fp)
811141c8:	00a04574 	movhi	r2,33045
811141cc:	108c8b04 	addi	r2,r2,12844
811141d0:	21000b24 	muli	r4,r4,44
811141d4:	1105883a 	add	r2,r2,r4
811141d8:	10800904 	addi	r2,r2,36
811141dc:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
811141e0:	e0fffb03 	ldbu	r3,-20(fp)
811141e4:	00a04574 	movhi	r2,33045
811141e8:	108c8b04 	addi	r2,r2,12844
811141ec:	18c00b24 	muli	r3,r3,44
811141f0:	10c5883a 	add	r2,r2,r3
811141f4:	10800a04 	addi	r2,r2,40
811141f8:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
811141fc:	e0fffb03 	ldbu	r3,-20(fp)
81114200:	00a04574 	movhi	r2,33045
81114204:	108c8b04 	addi	r2,r2,12844
81114208:	18c00b24 	muli	r3,r3,44
8111420c:	10c5883a 	add	r2,r2,r3
81114210:	10800984 	addi	r2,r2,38
81114214:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81114218:	e0fffb03 	ldbu	r3,-20(fp)
8111421c:	00a04574 	movhi	r2,33045
81114220:	108c8b04 	addi	r2,r2,12844
81114224:	18c00b24 	muli	r3,r3,44
81114228:	10c5883a 	add	r2,r2,r3
8111422c:	10800804 	addi	r2,r2,32
81114230:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81114234:	e0fffb03 	ldbu	r3,-20(fp)
81114238:	00a04574 	movhi	r2,33045
8111423c:	109ef704 	addi	r2,r2,31708
81114240:	18c00384 	addi	r3,r3,14
81114244:	18c7883a 	add	r3,r3,r3
81114248:	18c7883a 	add	r3,r3,r3
8111424c:	10c5883a 	add	r2,r2,r3
81114250:	00c00044 	movi	r3,1
81114254:	10c00015 	stw	r3,0(r2)
			break;
81114258:	00000606 	br	81114274 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
8111425c:	e0bffb03 	ldbu	r2,-20(fp)
81114260:	10800044 	addi	r2,r2,1
81114264:	e0bffb05 	stb	r2,-20(fp)
81114268:	e0bffb03 	ldbu	r2,-20(fp)
8111426c:	10800230 	cmpltui	r2,r2,8
81114270:	103fb81e 	bne	r2,zero,81114154 <__reset+0xfb0f4154>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81114274:	e0bffb03 	ldbu	r2,-20(fp)
81114278:	10800230 	cmpltui	r2,r2,8
8111427c:	1000091e 	bne	r2,zero,811142a4 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81114280:	d0a07317 	ldw	r2,-32308(gp)
81114284:	1009883a 	mov	r4,r2
81114288:	1138dc40 	call	81138dc4 <OSSemPost>
8111428c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81114290:	d0a07017 	ldw	r2,-32320(gp)
81114294:	1009883a 	mov	r4,r2
81114298:	1136fd40 	call	81136fd4 <OSMutexPost>
		return bSuccessL;
8111429c:	e0bffc17 	ldw	r2,-16(fp)
811142a0:	00003006 	br	81114364 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
811142a4:	00800044 	movi	r2,1
811142a8:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
811142ac:	d0a06a03 	ldbu	r2,-32344(gp)
811142b0:	10bfffc4 	addi	r2,r2,-1
811142b4:	d0a06a05 	stb	r2,-32344(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811142b8:	d0a07717 	ldw	r2,-32292(gp)
811142bc:	e0fffd04 	addi	r3,fp,-12
811142c0:	180d883a 	mov	r6,r3
811142c4:	01400084 	movi	r5,2
811142c8:	1009883a 	mov	r4,r2
811142cc:	1136a300 	call	81136a30 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811142d0:	e0bffd03 	ldbu	r2,-12(fp)
811142d4:	10803fcc 	andi	r2,r2,255
811142d8:	10000c26 	beq	r2,zero,8111430c <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
811142dc:	d0a05f17 	ldw	r2,-32388(gp)
811142e0:	100f883a 	mov	r7,r2
811142e4:	01801bc4 	movi	r6,111
811142e8:	01400044 	movi	r5,1
811142ec:	01204534 	movhi	r4,33044
811142f0:	211ef004 	addi	r4,r4,31680
811142f4:	111affc0 	call	8111affc <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
811142f8:	d0a07017 	ldw	r2,-32320(gp)
811142fc:	1009883a 	mov	r4,r2
81114300:	1136fd40 	call	81136fd4 <OSMutexPost>
		return bSuccessL;
81114304:	e0bffc17 	ldw	r2,-16(fp)
81114308:	00001606 	br	81114364 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8111430c:	e0bffb03 	ldbu	r2,-20(fp)
81114310:	10c00b24 	muli	r3,r2,44
81114314:	00a04574 	movhi	r2,33045
81114318:	108c8b04 	addi	r2,r2,12844
8111431c:	1885883a 	add	r2,r3,r2
81114320:	1009883a 	mov	r4,r2
81114324:	111bfac0 	call	8111bfac <puts>
	xBuffer32[ucIL].bSent = TRUE;
81114328:	e0fffb03 	ldbu	r3,-20(fp)
8111432c:	00a04574 	movhi	r2,33045
81114330:	108c8b04 	addi	r2,r2,12844
81114334:	18c00b24 	muli	r3,r3,44
81114338:	10c5883a 	add	r2,r2,r3
8111433c:	10800804 	addi	r2,r2,32
81114340:	00c00044 	movi	r3,1
81114344:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81114348:	d0a07717 	ldw	r2,-32292(gp)
8111434c:	1009883a 	mov	r4,r2
81114350:	1136fd40 	call	81136fd4 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81114354:	d0a07017 	ldw	r2,-32320(gp)
81114358:	1009883a 	mov	r4,r2
8111435c:	1136fd40 	call	81136fd4 <OSMutexPost>

	return bSuccessL;
81114360:	e0bffc17 	ldw	r2,-16(fp)
}
81114364:	e037883a 	mov	sp,fp
81114368:	dfc00117 	ldw	ra,4(sp)
8111436c:	df000017 	ldw	fp,0(sp)
81114370:	dec00204 	addi	sp,sp,8
81114374:	f800283a 	ret

81114378 <vSendEthConf>:


void vSendEthConf ( void ) {
81114378:	deffc304 	addi	sp,sp,-244
8111437c:	de00012e 	bgeu	sp,et,81114384 <vSendEthConf+0xc>
81114380:	003b68fa 	trap	3
81114384:	dfc03c15 	stw	ra,240(sp)
81114388:	df003b15 	stw	fp,236(sp)
8111438c:	dd403a15 	stw	r21,232(sp)
81114390:	dd003915 	stw	r20,228(sp)
81114394:	dcc03815 	stw	r19,224(sp)
81114398:	dc803715 	stw	r18,220(sp)
8111439c:	dc403615 	stw	r17,216(sp)
811143a0:	dc003515 	stw	r16,212(sp)
811143a4:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
811143a8:	e03fd98d 	sth	zero,-154(fp)
811143ac:	e03fda0d 	sth	zero,-152(fp)
811143b0:	e0bfda84 	addi	r2,fp,-150
811143b4:	00c01f04 	movi	r3,124
811143b8:	180d883a 	mov	r6,r3
811143bc:	000b883a 	mov	r5,zero
811143c0:	1009883a 	mov	r4,r2
811143c4:	111bb600 	call	8111bb60 <memset>
    unsigned char crc = 0;
811143c8:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811143cc:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
811143d0:	11149380 	call	81114938 <usiGetIdCMD>
811143d4:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811143d8:	e57fd90b 	ldhu	r21,-156(fp)
811143dc:	00a045b4 	movhi	r2,33046
811143e0:	10bead04 	addi	r2,r2,-1356
811143e4:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811143e8:	00a045b4 	movhi	r2,33046
811143ec:	10bead04 	addi	r2,r2,-1356
811143f0:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811143f4:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811143f8:	00a045b4 	movhi	r2,33046
811143fc:	10bead04 	addi	r2,r2,-1356
81114400:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114404:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114408:	00a045b4 	movhi	r2,33046
8111440c:	10bead04 	addi	r2,r2,-1356
81114410:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114414:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114418:	00a045b4 	movhi	r2,33046
8111441c:	10bead04 	addi	r2,r2,-1356
81114420:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114424:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114428:	00a045b4 	movhi	r2,33046
8111442c:	10bead04 	addi	r2,r2,-1356
81114430:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114434:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114438:	00a045b4 	movhi	r2,33046
8111443c:	10bead04 	addi	r2,r2,-1356
81114440:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114444:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114448:	00a045b4 	movhi	r2,33046
8111444c:	10bead04 	addi	r2,r2,-1356
81114450:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114454:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114458:	00a045b4 	movhi	r2,33046
8111445c:	10bead04 	addi	r2,r2,-1356
81114460:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114464:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114468:	00a045b4 	movhi	r2,33046
8111446c:	10bead04 	addi	r2,r2,-1356
81114470:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114474:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114478:	00a045b4 	movhi	r2,33046
8111447c:	10bead04 	addi	r2,r2,-1356
81114480:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114484:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114488:	00a045b4 	movhi	r2,33046
8111448c:	10bead04 	addi	r2,r2,-1356
81114490:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114494:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114498:	00a045b4 	movhi	r2,33046
8111449c:	10bead04 	addi	r2,r2,-1356
811144a0:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811144a4:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811144a8:	00a045b4 	movhi	r2,33046
811144ac:	10bead04 	addi	r2,r2,-1356
811144b0:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811144b4:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811144b8:	00a045b4 	movhi	r2,33046
811144bc:	10bead04 	addi	r2,r2,-1356
811144c0:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811144c4:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811144c8:	00a045b4 	movhi	r2,33046
811144cc:	10bead04 	addi	r2,r2,-1356
811144d0:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811144d4:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811144d8:	00a045b4 	movhi	r2,33046
811144dc:	10bead04 	addi	r2,r2,-1356
811144e0:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811144e4:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
811144e8:	00a045b4 	movhi	r2,33046
811144ec:	10bead04 	addi	r2,r2,-1356
811144f0:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811144f4:	10bfffcc 	andi	r2,r2,65535
811144f8:	e53fd984 	addi	r20,fp,-154
811144fc:	d8801115 	stw	r2,68(sp)
81114500:	dcc01015 	stw	r19,64(sp)
81114504:	dc800f15 	stw	r18,60(sp)
81114508:	dc400e15 	stw	r17,56(sp)
8111450c:	dc000d15 	stw	r16,52(sp)
81114510:	dbc00c15 	stw	r15,48(sp)
81114514:	db800b15 	stw	r14,44(sp)
81114518:	db400a15 	stw	r13,40(sp)
8111451c:	db000915 	stw	r12,36(sp)
81114520:	dac00815 	stw	r11,32(sp)
81114524:	da800715 	stw	r10,28(sp)
81114528:	da400615 	stw	r9,24(sp)
8111452c:	da000515 	stw	r8,20(sp)
81114530:	d9c00415 	stw	r7,16(sp)
81114534:	d9800315 	stw	r6,12(sp)
81114538:	d9400215 	stw	r5,8(sp)
8111453c:	d9000115 	stw	r4,4(sp)
81114540:	d8c00015 	stw	r3,0(sp)
81114544:	a80f883a 	mov	r7,r21
81114548:	018010c4 	movi	r6,67
8111454c:	01604534 	movhi	r5,33044
81114550:	295f0c04 	addi	r5,r5,31792
81114554:	a009883a 	mov	r4,r20
81114558:	111c2f00 	call	8111c2f0 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8111455c:	e0bfd984 	addi	r2,fp,-154
81114560:	1009883a 	mov	r4,r2
81114564:	111c5040 	call	8111c504 <strlen>
81114568:	1007883a 	mov	r3,r2
8111456c:	e0bfd984 	addi	r2,fp,-154
81114570:	180b883a 	mov	r5,r3
81114574:	1009883a 	mov	r4,r2
81114578:	1115ba80 	call	81115ba8 <ucCrc8wInit>
8111457c:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81114580:	e13fd703 	ldbu	r4,-164(fp)
81114584:	e0ffd984 	addi	r3,fp,-154
81114588:	e0bfd984 	addi	r2,fp,-154
8111458c:	200f883a 	mov	r7,r4
81114590:	180d883a 	mov	r6,r3
81114594:	01604534 	movhi	r5,33044
81114598:	295f2404 	addi	r5,r5,31888
8111459c:	1009883a 	mov	r4,r2
811145a0:	111c2f00 	call	8111c2f0 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
811145a4:	e0bfd90b 	ldhu	r2,-156(fp)
811145a8:	10ffffcc 	andi	r3,r2,65535
811145ac:	18e0001c 	xori	r3,r3,32768
811145b0:	18e00004 	addi	r3,r3,-32768
811145b4:	e0bfd984 	addi	r2,fp,-154
811145b8:	180b883a 	mov	r5,r3
811145bc:	1009883a 	mov	r4,r2
811145c0:	1113a980 	call	81113a98 <bSendUART128v2>
811145c4:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
811145c8:	e0bfd817 	ldw	r2,-160(fp)
811145cc:	10800060 	cmpeqi	r2,r2,1
811145d0:	1000011e 	bne	r2,zero,811145d8 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
811145d4:	11167240 	call	81116724 <vCouldNotSendEthConfUART>
	}
}
811145d8:	0001883a 	nop
811145dc:	e6fffa04 	addi	sp,fp,-24
811145e0:	dfc00717 	ldw	ra,28(sp)
811145e4:	df000617 	ldw	fp,24(sp)
811145e8:	dd400517 	ldw	r21,20(sp)
811145ec:	dd000417 	ldw	r20,16(sp)
811145f0:	dcc00317 	ldw	r19,12(sp)
811145f4:	dc800217 	ldw	r18,8(sp)
811145f8:	dc400117 	ldw	r17,4(sp)
811145fc:	dc000017 	ldw	r16,0(sp)
81114600:	dec00804 	addi	sp,sp,32
81114604:	f800283a 	ret

81114608 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81114608:	defff304 	addi	sp,sp,-52
8111460c:	de00012e 	bgeu	sp,et,81114614 <vSendTurnOff+0xc>
81114610:	003b68fa 	trap	3
81114614:	dfc00c15 	stw	ra,48(sp)
81114618:	df000b15 	stw	fp,44(sp)
8111461c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81114620:	e03ff78d 	sth	zero,-34(fp)
81114624:	e03ff80d 	sth	zero,-32(fp)
81114628:	e03ff88d 	sth	zero,-30(fp)
8111462c:	e03ff90d 	sth	zero,-28(fp)
81114630:	e03ff98d 	sth	zero,-26(fp)
81114634:	e03ffa0d 	sth	zero,-24(fp)
81114638:	e03ffa8d 	sth	zero,-22(fp)
8111463c:	e03ffb0d 	sth	zero,-20(fp)
81114640:	e03ffb8d 	sth	zero,-18(fp)
81114644:	e03ffc0d 	sth	zero,-16(fp)
81114648:	e03ffc8d 	sth	zero,-14(fp)
8111464c:	e03ffd0d 	sth	zero,-12(fp)
81114650:	e03ffd8d 	sth	zero,-10(fp)
81114654:	e03ffe0d 	sth	zero,-8(fp)
81114658:	e03ffe8d 	sth	zero,-6(fp)
8111465c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81114660:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114664:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114668:	11149380 	call	81114938 <usiGetIdCMD>
8111466c:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81114670:	e0fff70b 	ldhu	r3,-36(fp)
81114674:	e0bff784 	addi	r2,fp,-34
81114678:	180d883a 	mov	r6,r3
8111467c:	01604534 	movhi	r5,33044
81114680:	295f2704 	addi	r5,r5,31900
81114684:	1009883a 	mov	r4,r2
81114688:	111c2f00 	call	8111c2f0 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111468c:	e0bff784 	addi	r2,fp,-34
81114690:	1009883a 	mov	r4,r2
81114694:	111c5040 	call	8111c504 <strlen>
81114698:	1007883a 	mov	r3,r2
8111469c:	e0bff784 	addi	r2,fp,-34
811146a0:	180b883a 	mov	r5,r3
811146a4:	1009883a 	mov	r4,r2
811146a8:	1115ba80 	call	81115ba8 <ucCrc8wInit>
811146ac:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811146b0:	e13ff503 	ldbu	r4,-44(fp)
811146b4:	e0fff784 	addi	r3,fp,-34
811146b8:	e0bff784 	addi	r2,fp,-34
811146bc:	200f883a 	mov	r7,r4
811146c0:	180d883a 	mov	r6,r3
811146c4:	01604534 	movhi	r5,33044
811146c8:	295f2404 	addi	r5,r5,31888
811146cc:	1009883a 	mov	r4,r2
811146d0:	111c2f00 	call	8111c2f0 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811146d4:	e0bff70b 	ldhu	r2,-36(fp)
811146d8:	10ffffcc 	andi	r3,r2,65535
811146dc:	18e0001c 	xori	r3,r3,32768
811146e0:	18e00004 	addi	r3,r3,-32768
811146e4:	e0bff784 	addi	r2,fp,-34
811146e8:	180b883a 	mov	r5,r3
811146ec:	1009883a 	mov	r4,r2
811146f0:	11140800 	call	81114080 <bSendUART32v2>
811146f4:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
811146f8:	e0bff617 	ldw	r2,-40(fp)
811146fc:	10800060 	cmpeqi	r2,r2,1
81114700:	1000011e 	bne	r2,zero,81114708 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81114704:	1116dcc0 	call	81116dcc <vCouldNotSendTurnOff>
	}
}
81114708:	0001883a 	nop
8111470c:	e037883a 	mov	sp,fp
81114710:	dfc00117 	ldw	ra,4(sp)
81114714:	df000017 	ldw	fp,0(sp)
81114718:	dec00204 	addi	sp,sp,8
8111471c:	f800283a 	ret

81114720 <vSendReset>:

void vSendReset ( void ) {
81114720:	defff304 	addi	sp,sp,-52
81114724:	de00012e 	bgeu	sp,et,8111472c <vSendReset+0xc>
81114728:	003b68fa 	trap	3
8111472c:	dfc00c15 	stw	ra,48(sp)
81114730:	df000b15 	stw	fp,44(sp)
81114734:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81114738:	e03ff78d 	sth	zero,-34(fp)
8111473c:	e03ff80d 	sth	zero,-32(fp)
81114740:	e03ff88d 	sth	zero,-30(fp)
81114744:	e03ff90d 	sth	zero,-28(fp)
81114748:	e03ff98d 	sth	zero,-26(fp)
8111474c:	e03ffa0d 	sth	zero,-24(fp)
81114750:	e03ffa8d 	sth	zero,-22(fp)
81114754:	e03ffb0d 	sth	zero,-20(fp)
81114758:	e03ffb8d 	sth	zero,-18(fp)
8111475c:	e03ffc0d 	sth	zero,-16(fp)
81114760:	e03ffc8d 	sth	zero,-14(fp)
81114764:	e03ffd0d 	sth	zero,-12(fp)
81114768:	e03ffd8d 	sth	zero,-10(fp)
8111476c:	e03ffe0d 	sth	zero,-8(fp)
81114770:	e03ffe8d 	sth	zero,-6(fp)
81114774:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81114778:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111477c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114780:	11149380 	call	81114938 <usiGetIdCMD>
81114784:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81114788:	e0fff70b 	ldhu	r3,-36(fp)
8111478c:	e0bff784 	addi	r2,fp,-34
81114790:	180d883a 	mov	r6,r3
81114794:	01604534 	movhi	r5,33044
81114798:	295f2904 	addi	r5,r5,31908
8111479c:	1009883a 	mov	r4,r2
811147a0:	111c2f00 	call	8111c2f0 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811147a4:	e0bff784 	addi	r2,fp,-34
811147a8:	1009883a 	mov	r4,r2
811147ac:	111c5040 	call	8111c504 <strlen>
811147b0:	1007883a 	mov	r3,r2
811147b4:	e0bff784 	addi	r2,fp,-34
811147b8:	180b883a 	mov	r5,r3
811147bc:	1009883a 	mov	r4,r2
811147c0:	1115ba80 	call	81115ba8 <ucCrc8wInit>
811147c4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811147c8:	e13ff503 	ldbu	r4,-44(fp)
811147cc:	e0fff784 	addi	r3,fp,-34
811147d0:	e0bff784 	addi	r2,fp,-34
811147d4:	200f883a 	mov	r7,r4
811147d8:	180d883a 	mov	r6,r3
811147dc:	01604534 	movhi	r5,33044
811147e0:	295f2404 	addi	r5,r5,31888
811147e4:	1009883a 	mov	r4,r2
811147e8:	111c2f00 	call	8111c2f0 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811147ec:	e0bff70b 	ldhu	r2,-36(fp)
811147f0:	10ffffcc 	andi	r3,r2,65535
811147f4:	18e0001c 	xori	r3,r3,32768
811147f8:	18e00004 	addi	r3,r3,-32768
811147fc:	e0bff784 	addi	r2,fp,-34
81114800:	180b883a 	mov	r5,r3
81114804:	1009883a 	mov	r4,r2
81114808:	11140800 	call	81114080 <bSendUART32v2>
8111480c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81114810:	e0bff617 	ldw	r2,-40(fp)
81114814:	10800060 	cmpeqi	r2,r2,1
81114818:	1000011e 	bne	r2,zero,81114820 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111481c:	1116dcc0 	call	81116dcc <vCouldNotSendTurnOff>
	}
}
81114820:	0001883a 	nop
81114824:	e037883a 	mov	sp,fp
81114828:	dfc00117 	ldw	ra,4(sp)
8111482c:	df000017 	ldw	fp,0(sp)
81114830:	dec00204 	addi	sp,sp,8
81114834:	f800283a 	ret

81114838 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81114838:	deffda04 	addi	sp,sp,-152
8111483c:	de00012e 	bgeu	sp,et,81114844 <vSendLog+0xc>
81114840:	003b68fa 	trap	3
81114844:	dfc02515 	stw	ra,148(sp)
81114848:	df002415 	stw	fp,144(sp)
8111484c:	df002404 	addi	fp,sp,144
81114850:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81114854:	e03fde8d 	sth	zero,-134(fp)
81114858:	e03fdf0d 	sth	zero,-132(fp)
8111485c:	e0bfdf84 	addi	r2,fp,-130
81114860:	00c01f04 	movi	r3,124
81114864:	180d883a 	mov	r6,r3
81114868:	000b883a 	mov	r5,zero
8111486c:	1009883a 	mov	r4,r2
81114870:	111bb600 	call	8111bb60 <memset>
    unsigned char crc = 0;
81114874:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114878:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111487c:	11149380 	call	81114938 <usiGetIdCMD>
81114880:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81114884:	e0ffde0b 	ldhu	r3,-136(fp)
81114888:	e0bfde84 	addi	r2,fp,-134
8111488c:	e1ffff17 	ldw	r7,-4(fp)
81114890:	180d883a 	mov	r6,r3
81114894:	01604534 	movhi	r5,33044
81114898:	295f2b04 	addi	r5,r5,31916
8111489c:	1009883a 	mov	r4,r2
811148a0:	111c2f00 	call	8111c2f0 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
811148a4:	e0bfde84 	addi	r2,fp,-134
811148a8:	1009883a 	mov	r4,r2
811148ac:	111c5040 	call	8111c504 <strlen>
811148b0:	1007883a 	mov	r3,r2
811148b4:	e0bfde84 	addi	r2,fp,-134
811148b8:	180b883a 	mov	r5,r3
811148bc:	1009883a 	mov	r4,r2
811148c0:	1115ba80 	call	81115ba8 <ucCrc8wInit>
811148c4:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
811148c8:	e13fdc03 	ldbu	r4,-144(fp)
811148cc:	e0ffde84 	addi	r3,fp,-134
811148d0:	e0bfde84 	addi	r2,fp,-134
811148d4:	200f883a 	mov	r7,r4
811148d8:	180d883a 	mov	r6,r3
811148dc:	01604534 	movhi	r5,33044
811148e0:	295f2404 	addi	r5,r5,31888
811148e4:	1009883a 	mov	r4,r2
811148e8:	111c2f00 	call	8111c2f0 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
811148ec:	e0bfde0b 	ldhu	r2,-136(fp)
811148f0:	10ffffcc 	andi	r3,r2,65535
811148f4:	18e0001c 	xori	r3,r3,32768
811148f8:	18e00004 	addi	r3,r3,-32768
811148fc:	e0bfde84 	addi	r2,fp,-134
81114900:	180b883a 	mov	r5,r3
81114904:	1009883a 	mov	r4,r2
81114908:	1113a980 	call	81113a98 <bSendUART128v2>
8111490c:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81114910:	e0bfdd17 	ldw	r2,-140(fp)
81114914:	10800060 	cmpeqi	r2,r2,1
81114918:	1000011e 	bne	r2,zero,81114920 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111491c:	1116e9c0 	call	81116e9c <vCouldNotSendLog>
	}
}
81114920:	0001883a 	nop
81114924:	e037883a 	mov	sp,fp
81114928:	dfc00117 	ldw	ra,4(sp)
8111492c:	df000017 	ldw	fp,0(sp)
81114930:	dec00204 	addi	sp,sp,8
81114934:	f800283a 	ret

81114938 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81114938:	deffff04 	addi	sp,sp,-4
8111493c:	de00012e 	bgeu	sp,et,81114944 <usiGetIdCMD+0xc>
81114940:	003b68fa 	trap	3
81114944:	df000015 	stw	fp,0(sp)
81114948:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8111494c:	d0a0670b 	ldhu	r2,-32356(gp)
81114950:	10ffffcc 	andi	r3,r2,65535
81114954:	00bfffd4 	movui	r2,65535
81114958:	1880031e 	bne	r3,r2,81114968 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111495c:	00800084 	movi	r2,2
81114960:	d0a0670d 	sth	r2,-32356(gp)
81114964:	00000306 	br	81114974 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81114968:	d0a0670b 	ldhu	r2,-32356(gp)
8111496c:	10800044 	addi	r2,r2,1
81114970:	d0a0670d 	sth	r2,-32356(gp)

    return usiIdCMD;
81114974:	d0a0670b 	ldhu	r2,-32356(gp)
}
81114978:	e037883a 	mov	sp,fp
8111497c:	df000017 	ldw	fp,0(sp)
81114980:	dec00104 	addi	sp,sp,4
81114984:	f800283a 	ret

81114988 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81114988:	defffb04 	addi	sp,sp,-20
8111498c:	de00012e 	bgeu	sp,et,81114994 <siPosStr+0xc>
81114990:	003b68fa 	trap	3
81114994:	dfc00415 	stw	ra,16(sp)
81114998:	df000315 	stw	fp,12(sp)
8111499c:	df000304 	addi	fp,sp,12
811149a0:	e13ffe15 	stw	r4,-8(fp)
811149a4:	2805883a 	mov	r2,r5
811149a8:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
811149ac:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
811149b0:	e0bfff03 	ldbu	r2,-4(fp)
811149b4:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
811149b8:	e17ffd04 	addi	r5,fp,-12
811149bc:	e13ffe17 	ldw	r4,-8(fp)
811149c0:	111c4b80 	call	8111c4b8 <strcspn>
}
811149c4:	e037883a 	mov	sp,fp
811149c8:	dfc00117 	ldw	ra,4(sp)
811149cc:	df000017 	ldw	fp,0(sp)
811149d0:	dec00204 	addi	sp,sp,8
811149d4:	f800283a 	ret

811149d8 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
811149d8:	defffc04 	addi	sp,sp,-16
811149dc:	de00012e 	bgeu	sp,et,811149e4 <vTimeoutCheck+0xc>
811149e0:	003b68fa 	trap	3
811149e4:	dfc00315 	stw	ra,12(sp)
811149e8:	df000215 	stw	fp,8(sp)
811149ec:	df000204 	addi	fp,sp,8
811149f0:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
811149f4:	d0a06417 	ldw	r2,-32368(gp)
811149f8:	1009883a 	mov	r4,r2
811149fc:	1138dc40 	call	81138dc4 <OSSemPost>
81114a00:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81114a04:	e0bffe03 	ldbu	r2,-8(fp)
81114a08:	10000126 	beq	r2,zero,81114a10 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81114a0c:	1116b5c0 	call	81116b5c <vFailPostBlockingSemTimeoutTask>
	}
}
81114a10:	0001883a 	nop
81114a14:	e037883a 	mov	sp,fp
81114a18:	dfc00117 	ldw	ra,4(sp)
81114a1c:	df000017 	ldw	fp,0(sp)
81114a20:	dec00204 	addi	sp,sp,8
81114a24:	f800283a 	ret

81114a28 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81114a28:	deffe304 	addi	sp,sp,-116
81114a2c:	de00012e 	bgeu	sp,et,81114a34 <vSendPusTM64+0xc>
81114a30:	003b68fa 	trap	3
81114a34:	dfc01815 	stw	ra,96(sp)
81114a38:	df001715 	stw	fp,92(sp)
81114a3c:	df001704 	addi	fp,sp,92
81114a40:	e1000215 	stw	r4,8(fp)
81114a44:	e1400315 	stw	r5,12(fp)
81114a48:	e1800415 	stw	r6,16(fp)
81114a4c:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81114a50:	e03fef8d 	sth	zero,-66(fp)
81114a54:	e03ff00d 	sth	zero,-64(fp)
81114a58:	e0bff084 	addi	r2,fp,-62
81114a5c:	00c00f04 	movi	r3,60
81114a60:	180d883a 	mov	r6,r3
81114a64:	000b883a 	mov	r5,zero
81114a68:	1009883a 	mov	r4,r2
81114a6c:	111bb600 	call	8111bb60 <memset>
    unsigned char crc = 0;
81114a70:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81114a74:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114a78:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114a7c:	11149380 	call	81114938 <usiGetIdCMD>
81114a80:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81114a84:	e1bfef0b 	ldhu	r6,-68(fp)
81114a88:	e080040b 	ldhu	r2,16(fp)
81114a8c:	11ffffcc 	andi	r7,r2,65535
81114a90:	e080048b 	ldhu	r2,18(fp)
81114a94:	10bfffcc 	andi	r2,r2,65535
81114a98:	e0c0050b 	ldhu	r3,20(fp)
81114a9c:	18ffffcc 	andi	r3,r3,65535
81114aa0:	e100058b 	ldhu	r4,22(fp)
81114aa4:	213fffcc 	andi	r4,r4,65535
81114aa8:	e140060b 	ldhu	r5,24(fp)
81114aac:	297fffcc 	andi	r5,r5,65535
81114ab0:	e23fef84 	addi	r8,fp,-66
81114ab4:	d9400315 	stw	r5,12(sp)
81114ab8:	d9000215 	stw	r4,8(sp)
81114abc:	d8c00115 	stw	r3,4(sp)
81114ac0:	d8800015 	stw	r2,0(sp)
81114ac4:	01604534 	movhi	r5,33044
81114ac8:	295f2e04 	addi	r5,r5,31928
81114acc:	4009883a 	mov	r4,r8
81114ad0:	111c2f00 	call	8111c2f0 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114ad4:	e03fed05 	stb	zero,-76(fp)
81114ad8:	00001206 	br	81114b24 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81114adc:	e0bfed03 	ldbu	r2,-76(fp)
81114ae0:	10800284 	addi	r2,r2,10
81114ae4:	1085883a 	add	r2,r2,r2
81114ae8:	e0c00204 	addi	r3,fp,8
81114aec:	1885883a 	add	r2,r3,r2
81114af0:	1080000b 	ldhu	r2,0(r2)
81114af4:	113fffcc 	andi	r4,r2,65535
81114af8:	e0ffef84 	addi	r3,fp,-66
81114afc:	e0bfef84 	addi	r2,fp,-66
81114b00:	200f883a 	mov	r7,r4
81114b04:	180d883a 	mov	r6,r3
81114b08:	01604534 	movhi	r5,33044
81114b0c:	295f3504 	addi	r5,r5,31956
81114b10:	1009883a 	mov	r4,r2
81114b14:	111c2f00 	call	8111c2f0 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114b18:	e0bfed03 	ldbu	r2,-76(fp)
81114b1c:	10800044 	addi	r2,r2,1
81114b20:	e0bfed05 	stb	r2,-76(fp)
81114b24:	e0800683 	ldbu	r2,26(fp)
81114b28:	10803fcc 	andi	r2,r2,255
81114b2c:	e0ffed03 	ldbu	r3,-76(fp)
81114b30:	18bfea36 	bltu	r3,r2,81114adc <__reset+0xfb0f4adc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81114b34:	e0bfef84 	addi	r2,fp,-66
81114b38:	1009883a 	mov	r4,r2
81114b3c:	111c5040 	call	8111c504 <strlen>
81114b40:	1007883a 	mov	r3,r2
81114b44:	e0bfef84 	addi	r2,fp,-66
81114b48:	180b883a 	mov	r5,r3
81114b4c:	1009883a 	mov	r4,r2
81114b50:	1115ba80 	call	81115ba8 <ucCrc8wInit>
81114b54:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81114b58:	e13fed43 	ldbu	r4,-75(fp)
81114b5c:	e0ffef84 	addi	r3,fp,-66
81114b60:	e0bfef84 	addi	r2,fp,-66
81114b64:	200f883a 	mov	r7,r4
81114b68:	180d883a 	mov	r6,r3
81114b6c:	01604534 	movhi	r5,33044
81114b70:	295f2404 	addi	r5,r5,31888
81114b74:	1009883a 	mov	r4,r2
81114b78:	111c2f00 	call	8111c2f0 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81114b7c:	e0bfef0b 	ldhu	r2,-68(fp)
81114b80:	10ffffcc 	andi	r3,r2,65535
81114b84:	18e0001c 	xori	r3,r3,32768
81114b88:	18e00004 	addi	r3,r3,-32768
81114b8c:	e0bfef84 	addi	r2,fp,-66
81114b90:	180b883a 	mov	r5,r3
81114b94:	1009883a 	mov	r4,r2
81114b98:	1113d880 	call	81113d88 <bSendUART64v2>
81114b9c:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81114ba0:	e0bfee17 	ldw	r2,-72(fp)
81114ba4:	10800060 	cmpeqi	r2,r2,1
81114ba8:	1000031e 	bne	r2,zero,81114bb8 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81114bac:	e0bfef84 	addi	r2,fp,-66
81114bb0:	1009883a 	mov	r4,r2
81114bb4:	1116f040 	call	81116f04 <vCouldNotSendTMPusCommand>
	}
}
81114bb8:	0001883a 	nop
81114bbc:	e037883a 	mov	sp,fp
81114bc0:	dfc00117 	ldw	ra,4(sp)
81114bc4:	df000017 	ldw	fp,0(sp)
81114bc8:	dec00604 	addi	sp,sp,24
81114bcc:	f800283a 	ret

81114bd0 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81114bd0:	deffd304 	addi	sp,sp,-180
81114bd4:	de00012e 	bgeu	sp,et,81114bdc <vSendPusTM128+0xc>
81114bd8:	003b68fa 	trap	3
81114bdc:	dfc02815 	stw	ra,160(sp)
81114be0:	df002715 	stw	fp,156(sp)
81114be4:	df002704 	addi	fp,sp,156
81114be8:	e1000215 	stw	r4,8(fp)
81114bec:	e1400315 	stw	r5,12(fp)
81114bf0:	e1800415 	stw	r6,16(fp)
81114bf4:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81114bf8:	e03fdf8d 	sth	zero,-130(fp)
81114bfc:	e03fe00d 	sth	zero,-128(fp)
81114c00:	e0bfe084 	addi	r2,fp,-126
81114c04:	00c01f04 	movi	r3,124
81114c08:	180d883a 	mov	r6,r3
81114c0c:	000b883a 	mov	r5,zero
81114c10:	1009883a 	mov	r4,r2
81114c14:	111bb600 	call	8111bb60 <memset>
    unsigned char crc = 0;
81114c18:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81114c1c:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81114c20:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114c24:	11149380 	call	81114938 <usiGetIdCMD>
81114c28:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81114c2c:	e1bfdf0b 	ldhu	r6,-132(fp)
81114c30:	e080040b 	ldhu	r2,16(fp)
81114c34:	11ffffcc 	andi	r7,r2,65535
81114c38:	e080048b 	ldhu	r2,18(fp)
81114c3c:	10bfffcc 	andi	r2,r2,65535
81114c40:	e0c0050b 	ldhu	r3,20(fp)
81114c44:	18ffffcc 	andi	r3,r3,65535
81114c48:	e100058b 	ldhu	r4,22(fp)
81114c4c:	213fffcc 	andi	r4,r4,65535
81114c50:	e140060b 	ldhu	r5,24(fp)
81114c54:	297fffcc 	andi	r5,r5,65535
81114c58:	e23fdf84 	addi	r8,fp,-130
81114c5c:	d9400315 	stw	r5,12(sp)
81114c60:	d9000215 	stw	r4,8(sp)
81114c64:	d8c00115 	stw	r3,4(sp)
81114c68:	d8800015 	stw	r2,0(sp)
81114c6c:	01604534 	movhi	r5,33044
81114c70:	295f2e04 	addi	r5,r5,31928
81114c74:	4009883a 	mov	r4,r8
81114c78:	111c2f00 	call	8111c2f0 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114c7c:	e03fdd05 	stb	zero,-140(fp)
81114c80:	00001206 	br	81114ccc <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81114c84:	e0bfdd03 	ldbu	r2,-140(fp)
81114c88:	10800284 	addi	r2,r2,10
81114c8c:	1085883a 	add	r2,r2,r2
81114c90:	e0c00204 	addi	r3,fp,8
81114c94:	1885883a 	add	r2,r3,r2
81114c98:	1080000b 	ldhu	r2,0(r2)
81114c9c:	113fffcc 	andi	r4,r2,65535
81114ca0:	e0ffdf84 	addi	r3,fp,-130
81114ca4:	e0bfdf84 	addi	r2,fp,-130
81114ca8:	200f883a 	mov	r7,r4
81114cac:	180d883a 	mov	r6,r3
81114cb0:	01604534 	movhi	r5,33044
81114cb4:	295f3504 	addi	r5,r5,31956
81114cb8:	1009883a 	mov	r4,r2
81114cbc:	111c2f00 	call	8111c2f0 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114cc0:	e0bfdd03 	ldbu	r2,-140(fp)
81114cc4:	10800044 	addi	r2,r2,1
81114cc8:	e0bfdd05 	stb	r2,-140(fp)
81114ccc:	e0800683 	ldbu	r2,26(fp)
81114cd0:	10803fcc 	andi	r2,r2,255
81114cd4:	e0ffdd03 	ldbu	r3,-140(fp)
81114cd8:	18bfea36 	bltu	r3,r2,81114c84 <__reset+0xfb0f4c84>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81114cdc:	e0bfdf84 	addi	r2,fp,-130
81114ce0:	1009883a 	mov	r4,r2
81114ce4:	111c5040 	call	8111c504 <strlen>
81114ce8:	1007883a 	mov	r3,r2
81114cec:	e0bfdf84 	addi	r2,fp,-130
81114cf0:	180b883a 	mov	r5,r3
81114cf4:	1009883a 	mov	r4,r2
81114cf8:	1115ba80 	call	81115ba8 <ucCrc8wInit>
81114cfc:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81114d00:	e13fdd43 	ldbu	r4,-139(fp)
81114d04:	e0ffdf84 	addi	r3,fp,-130
81114d08:	e0bfdf84 	addi	r2,fp,-130
81114d0c:	200f883a 	mov	r7,r4
81114d10:	180d883a 	mov	r6,r3
81114d14:	01604534 	movhi	r5,33044
81114d18:	295f2404 	addi	r5,r5,31888
81114d1c:	1009883a 	mov	r4,r2
81114d20:	111c2f00 	call	8111c2f0 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81114d24:	e0bfdf0b 	ldhu	r2,-132(fp)
81114d28:	10ffffcc 	andi	r3,r2,65535
81114d2c:	18e0001c 	xori	r3,r3,32768
81114d30:	18e00004 	addi	r3,r3,-32768
81114d34:	e0bfdf84 	addi	r2,fp,-130
81114d38:	180b883a 	mov	r5,r3
81114d3c:	1009883a 	mov	r4,r2
81114d40:	1113a980 	call	81113a98 <bSendUART128v2>
81114d44:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81114d48:	e0bfde17 	ldw	r2,-136(fp)
81114d4c:	10800060 	cmpeqi	r2,r2,1
81114d50:	1000031e 	bne	r2,zero,81114d60 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81114d54:	e0bfdf84 	addi	r2,fp,-130
81114d58:	1009883a 	mov	r4,r2
81114d5c:	1116f040 	call	81116f04 <vCouldNotSendTMPusCommand>
	}
}
81114d60:	0001883a 	nop
81114d64:	e037883a 	mov	sp,fp
81114d68:	dfc00117 	ldw	ra,4(sp)
81114d6c:	df000017 	ldw	fp,0(sp)
81114d70:	dec00604 	addi	sp,sp,24
81114d74:	f800283a 	ret

81114d78 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81114d78:	deffd704 	addi	sp,sp,-164
81114d7c:	de00012e 	bgeu	sp,et,81114d84 <vTMPusTestConnection+0xc>
81114d80:	003b68fa 	trap	3
81114d84:	dfc02815 	stw	ra,160(sp)
81114d88:	df002715 	stw	fp,156(sp)
81114d8c:	df002704 	addi	fp,sp,156
81114d90:	2005883a 	mov	r2,r4
81114d94:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81114d98:	e0bfff0b 	ldhu	r2,-4(fp)
81114d9c:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81114da0:	00801c04 	movi	r2,112
81114da4:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81114da8:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81114dac:	00800444 	movi	r2,17
81114db0:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81114db4:	00800084 	movi	r2,2
81114db8:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81114dbc:	d809883a 	mov	r4,sp
81114dc0:	e0bfee04 	addi	r2,fp,-72
81114dc4:	00c01104 	movi	r3,68
81114dc8:	180d883a 	mov	r6,r3
81114dcc:	100b883a 	mov	r5,r2
81114dd0:	111ba100 	call	8111ba10 <memcpy>
81114dd4:	e13fea17 	ldw	r4,-88(fp)
81114dd8:	e17feb17 	ldw	r5,-84(fp)
81114ddc:	e1bfec17 	ldw	r6,-80(fp)
81114de0:	e1ffed17 	ldw	r7,-76(fp)
81114de4:	1114a280 	call	81114a28 <vSendPusTM64>
}
81114de8:	0001883a 	nop
81114dec:	e037883a 	mov	sp,fp
81114df0:	dfc00117 	ldw	ra,4(sp)
81114df4:	df000017 	ldw	fp,0(sp)
81114df8:	dec00204 	addi	sp,sp,8
81114dfc:	f800283a 	ret

81114e00 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
81114e00:	defff504 	addi	sp,sp,-44
81114e04:	de00012e 	bgeu	sp,et,81114e0c <vLoadDefaultETHConf+0xc>
81114e08:	003b68fa 	trap	3
81114e0c:	dfc00a15 	stw	ra,40(sp)
81114e10:	df000915 	stw	fp,36(sp)
81114e14:	dc000815 	stw	r16,32(sp)
81114e18:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81114e1c:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81114e20:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81114e24:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81114e28:	d0a07b17 	ldw	r2,-32276(gp)
81114e2c:	10800058 	cmpnei	r2,r2,1
81114e30:	1002041e 	bne	r2,zero,81115644 <vLoadDefaultETHConf+0x844>
81114e34:	1118a180 	call	81118a18 <bSDcardIsPresent>
81114e38:	10020226 	beq	r2,zero,81115644 <vLoadDefaultETHConf+0x844>
81114e3c:	1118a480 	call	81118a48 <bSDcardFAT16Check>
81114e40:	10020026 	beq	r2,zero,81115644 <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
81114e44:	01204534 	movhi	r4,33044
81114e48:	211f3704 	addi	r4,r4,31964
81114e4c:	1118b700 	call	81118b70 <siOpenFile>
81114e50:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81114e54:	e0bffc0f 	ldh	r2,-16(fp)
81114e58:	1001f216 	blt	r2,zero,81115624 <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81114e5c:	e0bffd04 	addi	r2,fp,-12
81114e60:	01800204 	movi	r6,8
81114e64:	01400284 	movi	r5,10
81114e68:	1009883a 	mov	r4,r2
81114e6c:	111bb600 	call	8111bb60 <memset>
			p_inteiro = inteiro;
81114e70:	e0bffd04 	addi	r2,fp,-12
81114e74:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81114e78:	e0bffc0f 	ldh	r2,-16(fp)
81114e7c:	1009883a 	mov	r4,r2
81114e80:	1118bec0 	call	81118bec <cGetNextChar>
81114e84:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81114e88:	e0bff947 	ldb	r2,-27(fp)
81114e8c:	10800084 	addi	r2,r2,2
81114e90:	10c015a8 	cmpgeui	r3,r2,86
81114e94:	1801d71e 	bne	r3,zero,811155f4 <vLoadDefaultETHConf+0x7f4>
81114e98:	100690ba 	slli	r3,r2,2
81114e9c:	00a04474 	movhi	r2,33041
81114ea0:	1093ac04 	addi	r2,r2,20144
81114ea4:	1885883a 	add	r2,r3,r2
81114ea8:	10800017 	ldw	r2,0(r2)
81114eac:	1000683a 	jmp	r2
81114eb0:	81115048 	cmpgei	r4,r16,17729
81114eb4:	8111503c 	xorhi	r4,r16,17728
81114eb8:	811155f4 	orhi	r4,r16,17751
81114ebc:	811155f4 	orhi	r4,r16,17751
81114ec0:	811155f4 	orhi	r4,r16,17751
81114ec4:	811155f4 	orhi	r4,r16,17751
81114ec8:	811155f4 	orhi	r4,r16,17751
81114ecc:	811155f4 	orhi	r4,r16,17751
81114ed0:	811155f4 	orhi	r4,r16,17751
81114ed4:	811155f4 	orhi	r4,r16,17751
81114ed8:	811155f4 	orhi	r4,r16,17751
81114edc:	811155f4 	orhi	r4,r16,17751
81114ee0:	81115614 	ori	r4,r16,17752
81114ee4:	811155f4 	orhi	r4,r16,17751
81114ee8:	811155f4 	orhi	r4,r16,17751
81114eec:	81115614 	ori	r4,r16,17752
81114ef0:	811155f4 	orhi	r4,r16,17751
81114ef4:	811155f4 	orhi	r4,r16,17751
81114ef8:	811155f4 	orhi	r4,r16,17751
81114efc:	811155f4 	orhi	r4,r16,17751
81114f00:	811155f4 	orhi	r4,r16,17751
81114f04:	811155f4 	orhi	r4,r16,17751
81114f08:	811155f4 	orhi	r4,r16,17751
81114f0c:	811155f4 	orhi	r4,r16,17751
81114f10:	811155f4 	orhi	r4,r16,17751
81114f14:	811155f4 	orhi	r4,r16,17751
81114f18:	811155f4 	orhi	r4,r16,17751
81114f1c:	811155f4 	orhi	r4,r16,17751
81114f20:	811155f4 	orhi	r4,r16,17751
81114f24:	811155f4 	orhi	r4,r16,17751
81114f28:	811155f4 	orhi	r4,r16,17751
81114f2c:	811155f4 	orhi	r4,r16,17751
81114f30:	811155f4 	orhi	r4,r16,17751
81114f34:	811155f4 	orhi	r4,r16,17751
81114f38:	81115614 	ori	r4,r16,17752
81114f3c:	811155f4 	orhi	r4,r16,17751
81114f40:	811155f4 	orhi	r4,r16,17751
81114f44:	811155f4 	orhi	r4,r16,17751
81114f48:	811155f4 	orhi	r4,r16,17751
81114f4c:	811155f4 	orhi	r4,r16,17751
81114f50:	811155f4 	orhi	r4,r16,17751
81114f54:	81115008 	cmpgei	r4,r16,17728
81114f58:	811155f4 	orhi	r4,r16,17751
81114f5c:	811155f4 	orhi	r4,r16,17751
81114f60:	811155f4 	orhi	r4,r16,17751
81114f64:	811155f4 	orhi	r4,r16,17751
81114f68:	811155f4 	orhi	r4,r16,17751
81114f6c:	811155f4 	orhi	r4,r16,17751
81114f70:	811155f4 	orhi	r4,r16,17751
81114f74:	811155f4 	orhi	r4,r16,17751
81114f78:	811155f4 	orhi	r4,r16,17751
81114f7c:	811155f4 	orhi	r4,r16,17751
81114f80:	811155f4 	orhi	r4,r16,17751
81114f84:	811155f4 	orhi	r4,r16,17751
81114f88:	811155f4 	orhi	r4,r16,17751
81114f8c:	811155f4 	orhi	r4,r16,17751
81114f90:	811155f4 	orhi	r4,r16,17751
81114f94:	811155f4 	orhi	r4,r16,17751
81114f98:	811155f4 	orhi	r4,r16,17751
81114f9c:	811155f4 	orhi	r4,r16,17751
81114fa0:	811155f4 	orhi	r4,r16,17751
81114fa4:	811155f4 	orhi	r4,r16,17751
81114fa8:	811155ac 	andhi	r4,r16,17750
81114fac:	811155f4 	orhi	r4,r16,17751
81114fb0:	811155f4 	orhi	r4,r16,17751
81114fb4:	811155f4 	orhi	r4,r16,17751
81114fb8:	811155f4 	orhi	r4,r16,17751
81114fbc:	811155f4 	orhi	r4,r16,17751
81114fc0:	811155f4 	orhi	r4,r16,17751
81114fc4:	811155f4 	orhi	r4,r16,17751
81114fc8:	811153ac 	andhi	r4,r16,17742
81114fcc:	811155f4 	orhi	r4,r16,17751
81114fd0:	811155f4 	orhi	r4,r16,17751
81114fd4:	8111520c 	andi	r4,r16,17736
81114fd8:	81115504 	addi	r4,r16,17748
81114fdc:	81115140 	call	88111514 <__reset+0x20f1514>
81114fe0:	811155f4 	orhi	r4,r16,17751
81114fe4:	811155f4 	orhi	r4,r16,17751
81114fe8:	811155f4 	orhi	r4,r16,17751
81114fec:	81115070 	cmpltui	r4,r16,17729
81114ff0:	811155f4 	orhi	r4,r16,17751
81114ff4:	811155f4 	orhi	r4,r16,17751
81114ff8:	8111547c 	xorhi	r4,r16,17745
81114ffc:	811155f4 	orhi	r4,r16,17751
81115000:	811155f4 	orhi	r4,r16,17751
81115004:	811152dc 	xori	r4,r16,17739
					case 39:// single quote '
						c = cGetNextChar(siFile);
81115008:	e0bffc0f 	ldh	r2,-16(fp)
8111500c:	1009883a 	mov	r4,r2
81115010:	1118bec0 	call	81118bec <cGetNextChar>
81115014:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81115018:	00000406 	br	8111502c <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111501c:	e0bffc0f 	ldh	r2,-16(fp)
81115020:	1009883a 	mov	r4,r2
81115024:	1118bec0 	call	81118bec <cGetNextChar>
81115028:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111502c:	e0bff947 	ldb	r2,-27(fp)
81115030:	108009d8 	cmpnei	r2,r2,39
81115034:	103ff91e 	bne	r2,zero,8111501c <__reset+0xfb0f501c>
							c = cGetNextChar(siFile);
						}
						break;
81115038:	00017706 	br	81115618 <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
8111503c:	00800044 	movi	r2,1
81115040:	e0bff815 	stw	r2,-32(fp)
						break;
81115044:	00017406 	br	81115618 <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81115048:	d0a05f17 	ldw	r2,-32388(gp)
8111504c:	100f883a 	mov	r7,r2
81115050:	018006c4 	movi	r6,27
81115054:	01400044 	movi	r5,1
81115058:	01204534 	movhi	r4,33044
8111505c:	211f3904 	addi	r4,r4,31972
81115060:	111affc0 	call	8111affc <fwrite>
						#endif
						bEOF = TRUE;
81115064:	00800044 	movi	r2,1
81115068:	e0bff815 	stw	r2,-32(fp)
						break;
8111506c:	00016a06 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81115070:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115074:	e0bffc0f 	ldh	r2,-16(fp)
81115078:	1009883a 	mov	r4,r2
8111507c:	1118bec0 	call	81118bec <cGetNextChar>
81115080:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115084:	d0e00317 	ldw	r3,-32756(gp)
81115088:	e0bff947 	ldb	r2,-27(fp)
8111508c:	10800044 	addi	r2,r2,1
81115090:	1885883a 	add	r2,r3,r2
81115094:	10800003 	ldbu	r2,0(r2)
81115098:	10803fcc 	andi	r2,r2,255
8111509c:	1080010c 	andi	r2,r2,4
811150a0:	10000626 	beq	r2,zero,811150bc <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
811150a4:	e0bffa17 	ldw	r2,-24(fp)
811150a8:	e0fff943 	ldbu	r3,-27(fp)
811150ac:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811150b0:	e0bffa17 	ldw	r2,-24(fp)
811150b4:	10800044 	addi	r2,r2,1
811150b8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
811150bc:	e0bff947 	ldb	r2,-27(fp)
811150c0:	10800ea0 	cmpeqi	r2,r2,58
811150c4:	1000031e 	bne	r2,zero,811150d4 <vLoadDefaultETHConf+0x2d4>
811150c8:	e0bff947 	ldb	r2,-27(fp)
811150cc:	10800ed8 	cmpnei	r2,r2,59
811150d0:	103fe81e 	bne	r2,zero,81115074 <__reset+0xfb0f5074>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811150d4:	e0bffa17 	ldw	r2,-24(fp)
811150d8:	00c00284 	movi	r3,10
811150dc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
811150e0:	e0bff903 	ldbu	r2,-28(fp)
811150e4:	10800168 	cmpgeui	r2,r2,5
811150e8:	1000021e 	bne	r2,zero,811150f4 <vLoadDefaultETHConf+0x2f4>
811150ec:	e43ff903 	ldbu	r16,-28(fp)
811150f0:	00000106 	br	811150f8 <vLoadDefaultETHConf+0x2f8>
811150f4:	04000144 	movi	r16,5
811150f8:	e0bffd04 	addi	r2,fp,-12
811150fc:	1009883a 	mov	r4,r2
81115100:	111a8040 	call	8111a804 <atoi>
81115104:	1007883a 	mov	r3,r2
81115108:	00a045b4 	movhi	r2,33046
8111510c:	10bead04 	addi	r2,r2,-1356
81115110:	1405883a 	add	r2,r2,r16
81115114:	10800404 	addi	r2,r2,16
81115118:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111511c:	e0bffd04 	addi	r2,fp,-12
81115120:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115124:	e0bff903 	ldbu	r2,-28(fp)
81115128:	10800044 	addi	r2,r2,1
8111512c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115130:	e0bff947 	ldb	r2,-27(fp)
81115134:	10800ed8 	cmpnei	r2,r2,59
81115138:	103fce1e 	bne	r2,zero,81115074 <__reset+0xfb0f5074>

						break;
8111513c:	00013606 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
81115140:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115144:	e0bffc0f 	ldh	r2,-16(fp)
81115148:	1009883a 	mov	r4,r2
8111514c:	1118bec0 	call	81118bec <cGetNextChar>
81115150:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115154:	d0e00317 	ldw	r3,-32756(gp)
81115158:	e0bff947 	ldb	r2,-27(fp)
8111515c:	10800044 	addi	r2,r2,1
81115160:	1885883a 	add	r2,r3,r2
81115164:	10800003 	ldbu	r2,0(r2)
81115168:	10803fcc 	andi	r2,r2,255
8111516c:	1080010c 	andi	r2,r2,4
81115170:	10000626 	beq	r2,zero,8111518c <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81115174:	e0bffa17 	ldw	r2,-24(fp)
81115178:	e0fff943 	ldbu	r3,-27(fp)
8111517c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115180:	e0bffa17 	ldw	r2,-24(fp)
81115184:	10800044 	addi	r2,r2,1
81115188:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111518c:	e0bff947 	ldb	r2,-27(fp)
81115190:	10800ba0 	cmpeqi	r2,r2,46
81115194:	1000031e 	bne	r2,zero,811151a4 <vLoadDefaultETHConf+0x3a4>
81115198:	e0bff947 	ldb	r2,-27(fp)
8111519c:	10800ed8 	cmpnei	r2,r2,59
811151a0:	103fe81e 	bne	r2,zero,81115144 <__reset+0xfb0f5144>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811151a4:	e0bffa17 	ldw	r2,-24(fp)
811151a8:	00c00284 	movi	r3,10
811151ac:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
811151b0:	e0bff903 	ldbu	r2,-28(fp)
811151b4:	108000e8 	cmpgeui	r2,r2,3
811151b8:	1000021e 	bne	r2,zero,811151c4 <vLoadDefaultETHConf+0x3c4>
811151bc:	e43ff903 	ldbu	r16,-28(fp)
811151c0:	00000106 	br	811151c8 <vLoadDefaultETHConf+0x3c8>
811151c4:	040000c4 	movi	r16,3
811151c8:	e0bffd04 	addi	r2,fp,-12
811151cc:	1009883a 	mov	r4,r2
811151d0:	111a8040 	call	8111a804 <atoi>
811151d4:	1007883a 	mov	r3,r2
811151d8:	00a045b4 	movhi	r2,33046
811151dc:	10bead04 	addi	r2,r2,-1356
811151e0:	1405883a 	add	r2,r2,r16
811151e4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811151e8:	e0bffd04 	addi	r2,fp,-12
811151ec:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811151f0:	e0bff903 	ldbu	r2,-28(fp)
811151f4:	10800044 	addi	r2,r2,1
811151f8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811151fc:	e0bff947 	ldb	r2,-27(fp)
81115200:	10800ed8 	cmpnei	r2,r2,59
81115204:	103fcf1e 	bne	r2,zero,81115144 <__reset+0xfb0f5144>

						break;
81115208:	00010306 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
8111520c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115210:	e0bffc0f 	ldh	r2,-16(fp)
81115214:	1009883a 	mov	r4,r2
81115218:	1118bec0 	call	81118bec <cGetNextChar>
8111521c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115220:	d0e00317 	ldw	r3,-32756(gp)
81115224:	e0bff947 	ldb	r2,-27(fp)
81115228:	10800044 	addi	r2,r2,1
8111522c:	1885883a 	add	r2,r3,r2
81115230:	10800003 	ldbu	r2,0(r2)
81115234:	10803fcc 	andi	r2,r2,255
81115238:	1080010c 	andi	r2,r2,4
8111523c:	10000626 	beq	r2,zero,81115258 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81115240:	e0bffa17 	ldw	r2,-24(fp)
81115244:	e0fff943 	ldbu	r3,-27(fp)
81115248:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111524c:	e0bffa17 	ldw	r2,-24(fp)
81115250:	10800044 	addi	r2,r2,1
81115254:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115258:	e0bff947 	ldb	r2,-27(fp)
8111525c:	10800ba0 	cmpeqi	r2,r2,46
81115260:	1000031e 	bne	r2,zero,81115270 <vLoadDefaultETHConf+0x470>
81115264:	e0bff947 	ldb	r2,-27(fp)
81115268:	10800ed8 	cmpnei	r2,r2,59
8111526c:	103fe81e 	bne	r2,zero,81115210 <__reset+0xfb0f5210>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115270:	e0bffa17 	ldw	r2,-24(fp)
81115274:	00c00284 	movi	r3,10
81115278:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
8111527c:	e0bff903 	ldbu	r2,-28(fp)
81115280:	108000e8 	cmpgeui	r2,r2,3
81115284:	1000021e 	bne	r2,zero,81115290 <vLoadDefaultETHConf+0x490>
81115288:	e43ff903 	ldbu	r16,-28(fp)
8111528c:	00000106 	br	81115294 <vLoadDefaultETHConf+0x494>
81115290:	040000c4 	movi	r16,3
81115294:	e0bffd04 	addi	r2,fp,-12
81115298:	1009883a 	mov	r4,r2
8111529c:	111a8040 	call	8111a804 <atoi>
811152a0:	1007883a 	mov	r3,r2
811152a4:	00a045b4 	movhi	r2,33046
811152a8:	10bead04 	addi	r2,r2,-1356
811152ac:	1405883a 	add	r2,r2,r16
811152b0:	10800104 	addi	r2,r2,4
811152b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811152b8:	e0bffd04 	addi	r2,fp,-12
811152bc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811152c0:	e0bff903 	ldbu	r2,-28(fp)
811152c4:	10800044 	addi	r2,r2,1
811152c8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811152cc:	e0bff947 	ldb	r2,-27(fp)
811152d0:	10800ed8 	cmpnei	r2,r2,59
811152d4:	103fce1e 	bne	r2,zero,81115210 <__reset+0xfb0f5210>

						break;
811152d8:	0000cf06 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
811152dc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811152e0:	e0bffc0f 	ldh	r2,-16(fp)
811152e4:	1009883a 	mov	r4,r2
811152e8:	1118bec0 	call	81118bec <cGetNextChar>
811152ec:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811152f0:	d0e00317 	ldw	r3,-32756(gp)
811152f4:	e0bff947 	ldb	r2,-27(fp)
811152f8:	10800044 	addi	r2,r2,1
811152fc:	1885883a 	add	r2,r3,r2
81115300:	10800003 	ldbu	r2,0(r2)
81115304:	10803fcc 	andi	r2,r2,255
81115308:	1080010c 	andi	r2,r2,4
8111530c:	10000626 	beq	r2,zero,81115328 <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
81115310:	e0bffa17 	ldw	r2,-24(fp)
81115314:	e0fff943 	ldbu	r3,-27(fp)
81115318:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111531c:	e0bffa17 	ldw	r2,-24(fp)
81115320:	10800044 	addi	r2,r2,1
81115324:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115328:	e0bff947 	ldb	r2,-27(fp)
8111532c:	10800ba0 	cmpeqi	r2,r2,46
81115330:	1000031e 	bne	r2,zero,81115340 <vLoadDefaultETHConf+0x540>
81115334:	e0bff947 	ldb	r2,-27(fp)
81115338:	10800ed8 	cmpnei	r2,r2,59
8111533c:	103fe81e 	bne	r2,zero,811152e0 <__reset+0xfb0f52e0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115340:	e0bffa17 	ldw	r2,-24(fp)
81115344:	00c00284 	movi	r3,10
81115348:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
8111534c:	e0bff903 	ldbu	r2,-28(fp)
81115350:	108000e8 	cmpgeui	r2,r2,3
81115354:	1000021e 	bne	r2,zero,81115360 <vLoadDefaultETHConf+0x560>
81115358:	e43ff903 	ldbu	r16,-28(fp)
8111535c:	00000106 	br	81115364 <vLoadDefaultETHConf+0x564>
81115360:	040000c4 	movi	r16,3
81115364:	e0bffd04 	addi	r2,fp,-12
81115368:	1009883a 	mov	r4,r2
8111536c:	111a8040 	call	8111a804 <atoi>
81115370:	1007883a 	mov	r3,r2
81115374:	00a045b4 	movhi	r2,33046
81115378:	10bead04 	addi	r2,r2,-1356
8111537c:	1405883a 	add	r2,r2,r16
81115380:	10800204 	addi	r2,r2,8
81115384:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115388:	e0bffd04 	addi	r2,fp,-12
8111538c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115390:	e0bff903 	ldbu	r2,-28(fp)
81115394:	10800044 	addi	r2,r2,1
81115398:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111539c:	e0bff947 	ldb	r2,-27(fp)
811153a0:	10800ed8 	cmpnei	r2,r2,59
811153a4:	103fce1e 	bne	r2,zero,811152e0 <__reset+0xfb0f52e0>

						break;
811153a8:	00009b06 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
811153ac:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811153b0:	e0bffc0f 	ldh	r2,-16(fp)
811153b4:	1009883a 	mov	r4,r2
811153b8:	1118bec0 	call	81118bec <cGetNextChar>
811153bc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811153c0:	d0e00317 	ldw	r3,-32756(gp)
811153c4:	e0bff947 	ldb	r2,-27(fp)
811153c8:	10800044 	addi	r2,r2,1
811153cc:	1885883a 	add	r2,r3,r2
811153d0:	10800003 	ldbu	r2,0(r2)
811153d4:	10803fcc 	andi	r2,r2,255
811153d8:	1080010c 	andi	r2,r2,4
811153dc:	10000626 	beq	r2,zero,811153f8 <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
811153e0:	e0bffa17 	ldw	r2,-24(fp)
811153e4:	e0fff943 	ldbu	r3,-27(fp)
811153e8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811153ec:	e0bffa17 	ldw	r2,-24(fp)
811153f0:	10800044 	addi	r2,r2,1
811153f4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811153f8:	e0bff947 	ldb	r2,-27(fp)
811153fc:	10800ba0 	cmpeqi	r2,r2,46
81115400:	1000031e 	bne	r2,zero,81115410 <vLoadDefaultETHConf+0x610>
81115404:	e0bff947 	ldb	r2,-27(fp)
81115408:	10800ed8 	cmpnei	r2,r2,59
8111540c:	103fe81e 	bne	r2,zero,811153b0 <__reset+0xfb0f53b0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115410:	e0bffa17 	ldw	r2,-24(fp)
81115414:	00c00284 	movi	r3,10
81115418:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
8111541c:	e0bff903 	ldbu	r2,-28(fp)
81115420:	108000e8 	cmpgeui	r2,r2,3
81115424:	1000021e 	bne	r2,zero,81115430 <vLoadDefaultETHConf+0x630>
81115428:	e43ff903 	ldbu	r16,-28(fp)
8111542c:	00000106 	br	81115434 <vLoadDefaultETHConf+0x634>
81115430:	040000c4 	movi	r16,3
81115434:	e0bffd04 	addi	r2,fp,-12
81115438:	1009883a 	mov	r4,r2
8111543c:	111a8040 	call	8111a804 <atoi>
81115440:	1007883a 	mov	r3,r2
81115444:	00a045b4 	movhi	r2,33046
81115448:	10bead04 	addi	r2,r2,-1356
8111544c:	1405883a 	add	r2,r2,r16
81115450:	10800304 	addi	r2,r2,12
81115454:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115458:	e0bffd04 	addi	r2,fp,-12
8111545c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115460:	e0bff903 	ldbu	r2,-28(fp)
81115464:	10800044 	addi	r2,r2,1
81115468:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111546c:	e0bff947 	ldb	r2,-27(fp)
81115470:	10800ed8 	cmpnei	r2,r2,59
81115474:	103fce1e 	bne	r2,zero,811153b0 <__reset+0xfb0f53b0>

						break;						
81115478:	00006706 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
8111547c:	e0bffc0f 	ldh	r2,-16(fp)
81115480:	1009883a 	mov	r4,r2
81115484:	1118bec0 	call	81118bec <cGetNextChar>
81115488:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111548c:	d0e00317 	ldw	r3,-32756(gp)
81115490:	e0bff947 	ldb	r2,-27(fp)
81115494:	10800044 	addi	r2,r2,1
81115498:	1885883a 	add	r2,r3,r2
8111549c:	10800003 	ldbu	r2,0(r2)
811154a0:	10803fcc 	andi	r2,r2,255
811154a4:	1080010c 	andi	r2,r2,4
811154a8:	10000626 	beq	r2,zero,811154c4 <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
811154ac:	e0bffa17 	ldw	r2,-24(fp)
811154b0:	e0fff943 	ldbu	r3,-27(fp)
811154b4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811154b8:	e0bffa17 	ldw	r2,-24(fp)
811154bc:	10800044 	addi	r2,r2,1
811154c0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811154c4:	e0bff947 	ldb	r2,-27(fp)
811154c8:	10800ed8 	cmpnei	r2,r2,59
811154cc:	103feb1e 	bne	r2,zero,8111547c <__reset+0xfb0f547c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811154d0:	e0bffa17 	ldw	r2,-24(fp)
811154d4:	00c00284 	movi	r3,10
811154d8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
811154dc:	e0bffd04 	addi	r2,fp,-12
811154e0:	1009883a 	mov	r4,r2
811154e4:	111a8040 	call	8111a804 <atoi>
811154e8:	1007883a 	mov	r3,r2
811154ec:	00a045b4 	movhi	r2,33046
811154f0:	10bead04 	addi	r2,r2,-1356
811154f4:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811154f8:	e0bffd04 	addi	r2,fp,-12
811154fc:	e0bffa15 	stw	r2,-24(fp)

						break;
81115500:	00004506 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
81115504:	e0bffc0f 	ldh	r2,-16(fp)
81115508:	1009883a 	mov	r4,r2
8111550c:	1118bec0 	call	81118bec <cGetNextChar>
81115510:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81115514:	d0e00317 	ldw	r3,-32756(gp)
81115518:	e0bff947 	ldb	r2,-27(fp)
8111551c:	10800044 	addi	r2,r2,1
81115520:	1885883a 	add	r2,r3,r2
81115524:	10800003 	ldbu	r2,0(r2)
81115528:	10803fcc 	andi	r2,r2,255
8111552c:	1080010c 	andi	r2,r2,4
81115530:	10000626 	beq	r2,zero,8111554c <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
81115534:	e0bffa17 	ldw	r2,-24(fp)
81115538:	e0fff943 	ldbu	r3,-27(fp)
8111553c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115540:	e0bffa17 	ldw	r2,-24(fp)
81115544:	10800044 	addi	r2,r2,1
81115548:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111554c:	e0bff947 	ldb	r2,-27(fp)
81115550:	10800ed8 	cmpnei	r2,r2,59
81115554:	103feb1e 	bne	r2,zero,81115504 <__reset+0xfb0f5504>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115558:	e0bffa17 	ldw	r2,-24(fp)
8111555c:	00c00284 	movi	r3,10
81115560:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81115564:	e0bffd04 	addi	r2,fp,-12
81115568:	1009883a 	mov	r4,r2
8111556c:	111a8040 	call	8111a804 <atoi>
81115570:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81115574:	e0bffc8f 	ldh	r2,-14(fp)
81115578:	10800058 	cmpnei	r2,r2,1
8111557c:	1000051e 	bne	r2,zero,81115594 <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81115580:	00a045b4 	movhi	r2,33046
81115584:	10bead04 	addi	r2,r2,-1356
81115588:	00c00044 	movi	r3,1
8111558c:	10c00615 	stw	r3,24(r2)
81115590:	00000306 	br	811155a0 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
81115594:	00a045b4 	movhi	r2,33046
81115598:	10bead04 	addi	r2,r2,-1356
8111559c:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811155a0:	e0bffd04 	addi	r2,fp,-12
811155a4:	e0bffa15 	stw	r2,-24(fp)

						break;
811155a8:	00001b06 	br	81115618 <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
811155ac:	e0bffc0f 	ldh	r2,-16(fp)
811155b0:	1009883a 	mov	r4,r2
811155b4:	1118bac0 	call	81118bac <siCloseFile>
811155b8:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
811155bc:	e0bffb17 	ldw	r2,-20(fp)
811155c0:	1000071e 	bne	r2,zero,811155e0 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
811155c4:	d0a05f17 	ldw	r2,-32388(gp)
811155c8:	100f883a 	mov	r7,r2
811155cc:	01800784 	movi	r6,30
811155d0:	01400044 	movi	r5,1
811155d4:	01204534 	movhi	r4,33044
811155d8:	211f4004 	addi	r4,r4,32000
811155dc:	111affc0 	call	8111affc <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
811155e0:	00800044 	movi	r2,1
811155e4:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
811155e8:	00800044 	movi	r2,1
811155ec:	e0bff715 	stw	r2,-36(fp)
						break;
811155f0:	00000906 	br	81115618 <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
811155f4:	d0a05f17 	ldw	r2,-32388(gp)
811155f8:	100f883a 	mov	r7,r2
811155fc:	01800844 	movi	r6,33
81115600:	01400044 	movi	r5,1
81115604:	01204534 	movhi	r4,33044
81115608:	211f4804 	addi	r4,r4,32032
8111560c:	111affc0 	call	8111affc <fwrite>
						#endif
						break;
81115610:	00000106 	br	81115618 <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81115614:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81115618:	e0bff817 	ldw	r2,-32(fp)
8111561c:	103e1626 	beq	r2,zero,81114e78 <__reset+0xfb0f4e78>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81115620:	00000f06 	br	81115660 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81115624:	d0a05f17 	ldw	r2,-32388(gp)
81115628:	100f883a 	mov	r7,r2
8111562c:	01800604 	movi	r6,24
81115630:	01400044 	movi	r5,1
81115634:	01204534 	movhi	r4,33044
81115638:	211f5104 	addi	r4,r4,32068
8111563c:	111affc0 	call	8111affc <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81115640:	00000706 	br	81115660 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81115644:	d0a05f17 	ldw	r2,-32388(gp)
81115648:	100f883a 	mov	r7,r2
8111564c:	018004c4 	movi	r6,19
81115650:	01400044 	movi	r5,1
81115654:	01204534 	movhi	r4,33044
81115658:	211f5804 	addi	r4,r4,32096
8111565c:	111affc0 	call	8111affc <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81115660:	e0bff717 	ldw	r2,-36(fp)
81115664:	1000541e 	bne	r2,zero,811157b8 <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81115668:	01204534 	movhi	r4,33044
8111566c:	211f5d04 	addi	r4,r4,32116
81115670:	111bfac0 	call	8111bfac <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81115674:	01604534 	movhi	r5,33044
81115678:	295f3704 	addi	r5,r5,31964
8111567c:	01204534 	movhi	r4,33044
81115680:	211f7104 	addi	r4,r4,32196
81115684:	111bd280 	call	8111bd28 <printf>


		xConfEth.siPortPUS = 17000;
81115688:	00a045b4 	movhi	r2,33046
8111568c:	10bead04 	addi	r2,r2,-1356
81115690:	00d09a04 	movi	r3,17000
81115694:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81115698:	00a045b4 	movhi	r2,33046
8111569c:	10bead04 	addi	r2,r2,-1356
811156a0:	00fff004 	movi	r3,-64
811156a4:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
811156a8:	00a045b4 	movhi	r2,33046
811156ac:	10bead04 	addi	r2,r2,-1356
811156b0:	00ffea04 	movi	r3,-88
811156b4:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
811156b8:	00a045b4 	movhi	r2,33046
811156bc:	10bead04 	addi	r2,r2,-1356
811156c0:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
811156c4:	00a045b4 	movhi	r2,33046
811156c8:	10bead04 	addi	r2,r2,-1356
811156cc:	00c00144 	movi	r3,5
811156d0:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
811156d4:	00a045b4 	movhi	r2,33046
811156d8:	10bead04 	addi	r2,r2,-1356
811156dc:	00fff004 	movi	r3,-64
811156e0:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
811156e4:	00a045b4 	movhi	r2,33046
811156e8:	10bead04 	addi	r2,r2,-1356
811156ec:	00ffea04 	movi	r3,-88
811156f0:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
811156f4:	00a045b4 	movhi	r2,33046
811156f8:	10bead04 	addi	r2,r2,-1356
811156fc:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81115700:	00a045b4 	movhi	r2,33046
81115704:	10bead04 	addi	r2,r2,-1356
81115708:	00c00044 	movi	r3,1
8111570c:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81115710:	00a045b4 	movhi	r2,33046
81115714:	10bead04 	addi	r2,r2,-1356
81115718:	00ffffc4 	movi	r3,-1
8111571c:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81115720:	00a045b4 	movhi	r2,33046
81115724:	10bead04 	addi	r2,r2,-1356
81115728:	00ffffc4 	movi	r3,-1
8111572c:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81115730:	00a045b4 	movhi	r2,33046
81115734:	10bead04 	addi	r2,r2,-1356
81115738:	00ffffc4 	movi	r3,-1
8111573c:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81115740:	00a045b4 	movhi	r2,33046
81115744:	10bead04 	addi	r2,r2,-1356
81115748:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
8111574c:	00a045b4 	movhi	r2,33046
81115750:	10bead04 	addi	r2,r2,-1356
81115754:	00ffff04 	movi	r3,-4
81115758:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111575c:	00a045b4 	movhi	r2,33046
81115760:	10bead04 	addi	r2,r2,-1356
81115764:	00fffdc4 	movi	r3,-9
81115768:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111576c:	00a045b4 	movhi	r2,33046
81115770:	10bead04 	addi	r2,r2,-1356
81115774:	00c018c4 	movi	r3,99
81115778:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111577c:	00a045b4 	movhi	r2,33046
81115780:	10bead04 	addi	r2,r2,-1356
81115784:	00c01344 	movi	r3,77
81115788:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111578c:	00a045b4 	movhi	r2,33046
81115790:	10bead04 	addi	r2,r2,-1356
81115794:	00c007c4 	movi	r3,31
81115798:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111579c:	00a045b4 	movhi	r2,33046
811157a0:	10bead04 	addi	r2,r2,-1356
811157a4:	00c01084 	movi	r3,66
811157a8:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
811157ac:	00a045b4 	movhi	r2,33046
811157b0:	10bead04 	addi	r2,r2,-1356
811157b4:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
811157b8:	e0bff717 	ldw	r2,-36(fp)
}
811157bc:	e6ffff04 	addi	sp,fp,-4
811157c0:	dfc00217 	ldw	ra,8(sp)
811157c4:	df000117 	ldw	fp,4(sp)
811157c8:	dc000017 	ldw	r16,0(sp)
811157cc:	dec00304 	addi	sp,sp,12
811157d0:	f800283a 	ret

811157d4 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
811157d4:	defff004 	addi	sp,sp,-64
811157d8:	de00012e 	bgeu	sp,et,811157e0 <vShowEthConfig+0xc>
811157dc:	003b68fa 	trap	3
811157e0:	dfc00f15 	stw	ra,60(sp)
811157e4:	df000e15 	stw	fp,56(sp)
811157e8:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
811157ec:	d0a05f17 	ldw	r2,-32388(gp)
811157f0:	100f883a 	mov	r7,r2
811157f4:	018007c4 	movi	r6,31
811157f8:	01400044 	movi	r5,1
811157fc:	01204534 	movhi	r4,33044
81115800:	211f7704 	addi	r4,r4,32220
81115804:	111affc0 	call	8111affc <fwrite>

		memset(buffer,0,40);
81115808:	01800a04 	movi	r6,40
8111580c:	000b883a 	mov	r5,zero
81115810:	e13ff604 	addi	r4,fp,-40
81115814:	111bb600 	call	8111bb60 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
81115818:	00a045b4 	movhi	r2,33046
8111581c:	10bead04 	addi	r2,r2,-1356
81115820:	10800403 	ldbu	r2,16(r2)
81115824:	11803fcc 	andi	r6,r2,255
81115828:	00a045b4 	movhi	r2,33046
8111582c:	10bead04 	addi	r2,r2,-1356
81115830:	10800443 	ldbu	r2,17(r2)
81115834:	11c03fcc 	andi	r7,r2,255
81115838:	00a045b4 	movhi	r2,33046
8111583c:	10bead04 	addi	r2,r2,-1356
81115840:	10800483 	ldbu	r2,18(r2)
81115844:	10c03fcc 	andi	r3,r2,255
81115848:	00a045b4 	movhi	r2,33046
8111584c:	10bead04 	addi	r2,r2,-1356
81115850:	108004c3 	ldbu	r2,19(r2)
81115854:	11003fcc 	andi	r4,r2,255
81115858:	00a045b4 	movhi	r2,33046
8111585c:	10bead04 	addi	r2,r2,-1356
81115860:	10800503 	ldbu	r2,20(r2)
81115864:	11403fcc 	andi	r5,r2,255
81115868:	00a045b4 	movhi	r2,33046
8111586c:	10bead04 	addi	r2,r2,-1356
81115870:	10800543 	ldbu	r2,21(r2)
81115874:	10803fcc 	andi	r2,r2,255
81115878:	d8800315 	stw	r2,12(sp)
8111587c:	d9400215 	stw	r5,8(sp)
81115880:	d9000115 	stw	r4,4(sp)
81115884:	d8c00015 	stw	r3,0(sp)
81115888:	01604534 	movhi	r5,33044
8111588c:	295f7f04 	addi	r5,r5,32252
81115890:	e13ff604 	addi	r4,fp,-40
81115894:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer );
81115898:	d0a05f17 	ldw	r2,-32388(gp)
8111589c:	e17ff604 	addi	r5,fp,-40
811158a0:	1009883a 	mov	r4,r2
811158a4:	111a9600 	call	8111a960 <fprintf>

		memset(buffer,0,40);
811158a8:	01800a04 	movi	r6,40
811158ac:	000b883a 	mov	r5,zero
811158b0:	e13ff604 	addi	r4,fp,-40
811158b4:	111bb600 	call	8111bb60 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
811158b8:	00a045b4 	movhi	r2,33046
811158bc:	10bead04 	addi	r2,r2,-1356
811158c0:	10800003 	ldbu	r2,0(r2)
811158c4:	11003fcc 	andi	r4,r2,255
811158c8:	00a045b4 	movhi	r2,33046
811158cc:	10bead04 	addi	r2,r2,-1356
811158d0:	10800043 	ldbu	r2,1(r2)
811158d4:	11403fcc 	andi	r5,r2,255
811158d8:	00a045b4 	movhi	r2,33046
811158dc:	10bead04 	addi	r2,r2,-1356
811158e0:	10800083 	ldbu	r2,2(r2)
811158e4:	10c03fcc 	andi	r3,r2,255
811158e8:	00a045b4 	movhi	r2,33046
811158ec:	10bead04 	addi	r2,r2,-1356
811158f0:	108000c3 	ldbu	r2,3(r2)
811158f4:	10803fcc 	andi	r2,r2,255
811158f8:	d8800115 	stw	r2,4(sp)
811158fc:	d8c00015 	stw	r3,0(sp)
81115900:	280f883a 	mov	r7,r5
81115904:	200d883a 	mov	r6,r4
81115908:	01604534 	movhi	r5,33044
8111590c:	295f8804 	addi	r5,r5,32288
81115910:	e13ff604 	addi	r4,fp,-40
81115914:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer );
81115918:	d0a05f17 	ldw	r2,-32388(gp)
8111591c:	e17ff604 	addi	r5,fp,-40
81115920:	1009883a 	mov	r4,r2
81115924:	111a9600 	call	8111a960 <fprintf>

		memset(buffer,0,40);
81115928:	01800a04 	movi	r6,40
8111592c:	000b883a 	mov	r5,zero
81115930:	e13ff604 	addi	r4,fp,-40
81115934:	111bb600 	call	8111bb60 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
81115938:	00a045b4 	movhi	r2,33046
8111593c:	10bead04 	addi	r2,r2,-1356
81115940:	10800103 	ldbu	r2,4(r2)
81115944:	11003fcc 	andi	r4,r2,255
81115948:	00a045b4 	movhi	r2,33046
8111594c:	10bead04 	addi	r2,r2,-1356
81115950:	10800143 	ldbu	r2,5(r2)
81115954:	11403fcc 	andi	r5,r2,255
81115958:	00a045b4 	movhi	r2,33046
8111595c:	10bead04 	addi	r2,r2,-1356
81115960:	10800183 	ldbu	r2,6(r2)
81115964:	10c03fcc 	andi	r3,r2,255
81115968:	00a045b4 	movhi	r2,33046
8111596c:	10bead04 	addi	r2,r2,-1356
81115970:	108001c3 	ldbu	r2,7(r2)
81115974:	10803fcc 	andi	r2,r2,255
81115978:	d8800115 	stw	r2,4(sp)
8111597c:	d8c00015 	stw	r3,0(sp)
81115980:	280f883a 	mov	r7,r5
81115984:	200d883a 	mov	r6,r4
81115988:	01604534 	movhi	r5,33044
8111598c:	295f8e04 	addi	r5,r5,32312
81115990:	e13ff604 	addi	r4,fp,-40
81115994:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer );
81115998:	d0a05f17 	ldw	r2,-32388(gp)
8111599c:	e17ff604 	addi	r5,fp,-40
811159a0:	1009883a 	mov	r4,r2
811159a4:	111a9600 	call	8111a960 <fprintf>

		memset(buffer,0,40);
811159a8:	01800a04 	movi	r6,40
811159ac:	000b883a 	mov	r5,zero
811159b0:	e13ff604 	addi	r4,fp,-40
811159b4:	111bb600 	call	8111bb60 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
811159b8:	00a045b4 	movhi	r2,33046
811159bc:	10bead04 	addi	r2,r2,-1356
811159c0:	10800203 	ldbu	r2,8(r2)
811159c4:	11003fcc 	andi	r4,r2,255
811159c8:	00a045b4 	movhi	r2,33046
811159cc:	10bead04 	addi	r2,r2,-1356
811159d0:	10800243 	ldbu	r2,9(r2)
811159d4:	11403fcc 	andi	r5,r2,255
811159d8:	00a045b4 	movhi	r2,33046
811159dc:	10bead04 	addi	r2,r2,-1356
811159e0:	10800283 	ldbu	r2,10(r2)
811159e4:	10c03fcc 	andi	r3,r2,255
811159e8:	00a045b4 	movhi	r2,33046
811159ec:	10bead04 	addi	r2,r2,-1356
811159f0:	108002c3 	ldbu	r2,11(r2)
811159f4:	10803fcc 	andi	r2,r2,255
811159f8:	d8800115 	stw	r2,4(sp)
811159fc:	d8c00015 	stw	r3,0(sp)
81115a00:	280f883a 	mov	r7,r5
81115a04:	200d883a 	mov	r6,r4
81115a08:	01604534 	movhi	r5,33044
81115a0c:	295f9504 	addi	r5,r5,32340
81115a10:	e13ff604 	addi	r4,fp,-40
81115a14:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer );
81115a18:	d0a05f17 	ldw	r2,-32388(gp)
81115a1c:	e17ff604 	addi	r5,fp,-40
81115a20:	1009883a 	mov	r4,r2
81115a24:	111a9600 	call	8111a960 <fprintf>

		memset(buffer,0,40);
81115a28:	01800a04 	movi	r6,40
81115a2c:	000b883a 	mov	r5,zero
81115a30:	e13ff604 	addi	r4,fp,-40
81115a34:	111bb600 	call	8111bb60 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81115a38:	00a045b4 	movhi	r2,33046
81115a3c:	10bead04 	addi	r2,r2,-1356
81115a40:	10800303 	ldbu	r2,12(r2)
81115a44:	11003fcc 	andi	r4,r2,255
81115a48:	00a045b4 	movhi	r2,33046
81115a4c:	10bead04 	addi	r2,r2,-1356
81115a50:	10800343 	ldbu	r2,13(r2)
81115a54:	11403fcc 	andi	r5,r2,255
81115a58:	00a045b4 	movhi	r2,33046
81115a5c:	10bead04 	addi	r2,r2,-1356
81115a60:	10800383 	ldbu	r2,14(r2)
81115a64:	10c03fcc 	andi	r3,r2,255
81115a68:	00a045b4 	movhi	r2,33046
81115a6c:	10bead04 	addi	r2,r2,-1356
81115a70:	108003c3 	ldbu	r2,15(r2)
81115a74:	10803fcc 	andi	r2,r2,255
81115a78:	d8800115 	stw	r2,4(sp)
81115a7c:	d8c00015 	stw	r3,0(sp)
81115a80:	280f883a 	mov	r7,r5
81115a84:	200d883a 	mov	r6,r4
81115a88:	01604534 	movhi	r5,33044
81115a8c:	295f9c04 	addi	r5,r5,32368
81115a90:	e13ff604 	addi	r4,fp,-40
81115a94:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer );
81115a98:	d0a05f17 	ldw	r2,-32388(gp)
81115a9c:	e17ff604 	addi	r5,fp,-40
81115aa0:	1009883a 	mov	r4,r2
81115aa4:	111a9600 	call	8111a960 <fprintf>

		memset(buffer,0,40);
81115aa8:	01800a04 	movi	r6,40
81115aac:	000b883a 	mov	r5,zero
81115ab0:	e13ff604 	addi	r4,fp,-40
81115ab4:	111bb600 	call	8111bb60 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81115ab8:	00a045b4 	movhi	r2,33046
81115abc:	10bead04 	addi	r2,r2,-1356
81115ac0:	1080058b 	ldhu	r2,22(r2)
81115ac4:	10bfffcc 	andi	r2,r2,65535
81115ac8:	100d883a 	mov	r6,r2
81115acc:	01604534 	movhi	r5,33044
81115ad0:	295fa304 	addi	r5,r5,32396
81115ad4:	e13ff604 	addi	r4,fp,-40
81115ad8:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer );
81115adc:	d0a05f17 	ldw	r2,-32388(gp)
81115ae0:	e17ff604 	addi	r5,fp,-40
81115ae4:	1009883a 	mov	r4,r2
81115ae8:	111a9600 	call	8111a960 <fprintf>

	}
81115aec:	0001883a 	nop
81115af0:	e037883a 	mov	sp,fp
81115af4:	dfc00117 	ldw	ra,4(sp)
81115af8:	df000017 	ldw	fp,0(sp)
81115afc:	dec00204 	addi	sp,sp,8
81115b00:	f800283a 	ret

81115b04 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
81115b04:	defffb04 	addi	sp,sp,-20
81115b08:	de00012e 	bgeu	sp,et,81115b10 <ucCrc8+0xc>
81115b0c:	003b68fa 	trap	3
81115b10:	df000415 	stw	fp,16(sp)
81115b14:	df000404 	addi	fp,sp,16
81115b18:	e13ffd15 	stw	r4,-12(fp)
81115b1c:	e17ffe15 	stw	r5,-8(fp)
81115b20:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
81115b24:	e0bffe17 	ldw	r2,-8(fp)
81115b28:	1000021e 	bne	r2,zero,81115b34 <ucCrc8+0x30>
        return 0;
81115b2c:	0005883a 	mov	r2,zero
81115b30:	00001906 	br	81115b98 <ucCrc8+0x94>
    crc &= 0xff;
81115b34:	e0bffd17 	ldw	r2,-12(fp)
81115b38:	10803fcc 	andi	r2,r2,255
81115b3c:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
81115b40:	e0fffe17 	ldw	r3,-8(fp)
81115b44:	e0bfff17 	ldw	r2,-4(fp)
81115b48:	1885883a 	add	r2,r3,r2
81115b4c:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81115b50:	00000d06 	br	81115b88 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
81115b54:	e0bffe17 	ldw	r2,-8(fp)
81115b58:	10c00044 	addi	r3,r2,1
81115b5c:	e0fffe15 	stw	r3,-8(fp)
81115b60:	10800003 	ldbu	r2,0(r2)
81115b64:	10c03fcc 	andi	r3,r2,255
81115b68:	e0bffd17 	ldw	r2,-12(fp)
81115b6c:	1886f03a 	xor	r3,r3,r2
81115b70:	00a04534 	movhi	r2,33044
81115b74:	109fa6c4 	addi	r2,r2,32411
81115b78:	10c5883a 	add	r2,r2,r3
81115b7c:	10800003 	ldbu	r2,0(r2)
81115b80:	10803fcc 	andi	r2,r2,255
81115b84:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
81115b88:	e0fffe17 	ldw	r3,-8(fp)
81115b8c:	e0bffc17 	ldw	r2,-16(fp)
81115b90:	18bff036 	bltu	r3,r2,81115b54 <__reset+0xfb0f5b54>
        crc = crc8_table[crc ^ *data++];
    return crc;
81115b94:	e0bffd17 	ldw	r2,-12(fp)
}
81115b98:	e037883a 	mov	sp,fp
81115b9c:	df000017 	ldw	fp,0(sp)
81115ba0:	dec00104 	addi	sp,sp,4
81115ba4:	f800283a 	ret

81115ba8 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
81115ba8:	defffb04 	addi	sp,sp,-20
81115bac:	de00012e 	bgeu	sp,et,81115bb4 <ucCrc8wInit+0xc>
81115bb0:	003b68fa 	trap	3
81115bb4:	dfc00415 	stw	ra,16(sp)
81115bb8:	df000315 	stw	fp,12(sp)
81115bbc:	df000304 	addi	fp,sp,12
81115bc0:	e13ffe15 	stw	r4,-8(fp)
81115bc4:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
81115bc8:	000d883a 	mov	r6,zero
81115bcc:	000b883a 	mov	r5,zero
81115bd0:	0009883a 	mov	r4,zero
81115bd4:	1115b040 	call	81115b04 <ucCrc8>
81115bd8:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
81115bdc:	e0bffd03 	ldbu	r2,-12(fp)
81115be0:	e1bfff17 	ldw	r6,-4(fp)
81115be4:	e17ffe17 	ldw	r5,-8(fp)
81115be8:	1009883a 	mov	r4,r2
81115bec:	1115b040 	call	81115b04 <ucCrc8>
}
81115bf0:	e037883a 	mov	sp,fp
81115bf4:	dfc00117 	ldw	ra,4(sp)
81115bf8:	df000017 	ldw	fp,0(sp)
81115bfc:	dec00204 	addi	sp,sp,8
81115c00:	f800283a 	ret

81115c04 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
81115c04:	defffc04 	addi	sp,sp,-16
81115c08:	de00012e 	bgeu	sp,et,81115c10 <vDataControllerInit+0xc>
81115c0c:	003b68fa 	trap	3
81115c10:	df000315 	stw	fp,12(sp)
81115c14:	df000304 	addi	fp,sp,12
81115c18:	e13ffe15 	stw	r4,-8(fp)
81115c1c:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81115c20:	e03ffd05 	stb	zero,-12(fp)
81115c24:	00001c06 	br	81115c98 <vDataControllerInit+0x94>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
81115c28:	e0bffd03 	ldbu	r2,-12(fp)
81115c2c:	e0fffd03 	ldbu	r3,-12(fp)
81115c30:	18c09224 	muli	r3,r3,584
81115c34:	e13fff17 	ldw	r4,-4(fp)
81115c38:	20c7883a 	add	r3,r4,r3
81115c3c:	e13ffe17 	ldw	r4,-8(fp)
81115c40:	10800084 	addi	r2,r2,2
81115c44:	1085883a 	add	r2,r2,r2
81115c48:	1085883a 	add	r2,r2,r2
81115c4c:	2085883a 	add	r2,r4,r2
81115c50:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
81115c54:	e17ffd03 	ldbu	r5,-12(fp)
81115c58:	e0bffd03 	ldbu	r2,-12(fp)
81115c5c:	e0ffff17 	ldw	r3,-4(fp)
81115c60:	10802484 	addi	r2,r2,146
81115c64:	1085883a 	add	r2,r2,r2
81115c68:	1085883a 	add	r2,r2,r2
81115c6c:	1885883a 	add	r2,r3,r2
81115c70:	10c00017 	ldw	r3,0(r2)
81115c74:	e13ffe17 	ldw	r4,-8(fp)
81115c78:	288000c4 	addi	r2,r5,3
81115c7c:	1085883a 	add	r2,r2,r2
81115c80:	1085883a 	add	r2,r2,r2
81115c84:	2085883a 	add	r2,r4,r2
81115c88:	10c00015 	stw	r3,0(r2)


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81115c8c:	e0bffd03 	ldbu	r2,-12(fp)
81115c90:	10800044 	addi	r2,r2,1
81115c94:	e0bffd05 	stb	r2,-12(fp)
81115c98:	e0bffd03 	ldbu	r2,-12(fp)
81115c9c:	103fe226 	beq	r2,zero,81115c28 <__reset+0xfb0f5c28>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
81115ca0:	e0bfff17 	ldw	r2,-4(fp)
81115ca4:	10c09404 	addi	r3,r2,592
81115ca8:	e0bffe17 	ldw	r2,-8(fp)
81115cac:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
81115cb0:	e0bffe17 	ldw	r2,-8(fp)
81115cb4:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81115cb8:	e0bffe17 	ldw	r2,-8(fp)
81115cbc:	10c00504 	addi	r3,r2,20
81115cc0:	e0bfff17 	ldw	r2,-4(fp)
81115cc4:	10c09615 	stw	r3,600(r2)
}
81115cc8:	0001883a 	nop
81115ccc:	e037883a 	mov	sp,fp
81115cd0:	df000017 	ldw	fp,0(sp)
81115cd4:	dec00104 	addi	sp,sp,4
81115cd8:	f800283a 	ret

81115cdc <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81115cdc:	defff904 	addi	sp,sp,-28
81115ce0:	de00012e 	bgeu	sp,et,81115ce8 <printErrorTask+0xc>
81115ce4:	003b68fa 	trap	3
81115ce8:	dfc00615 	stw	ra,24(sp)
81115cec:	df000515 	stw	fp,20(sp)
81115cf0:	df000504 	addi	fp,sp,20
81115cf4:	2005883a 	mov	r2,r4
81115cf8:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81115cfc:	e03ffb15 	stw	zero,-20(fp)
81115d00:	e03ffc15 	stw	zero,-16(fp)
81115d04:	e03ffd15 	stw	zero,-12(fp)
81115d08:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81115d0c:	e0bfff03 	ldbu	r2,-4(fp)
81115d10:	100d883a 	mov	r6,r2
81115d14:	01604534 	movhi	r5,33044
81115d18:	295fe704 	addi	r5,r5,32668
81115d1c:	e13ffb04 	addi	r4,fp,-20
81115d20:	111c2f00 	call	8111c2f0 <sprintf>
		debug(fp, buffer);
81115d24:	d0a05f17 	ldw	r2,-32388(gp)
81115d28:	e17ffb04 	addi	r5,fp,-20
81115d2c:	1009883a 	mov	r4,r2
81115d30:	111a9600 	call	8111a960 <fprintf>
	}
81115d34:	0001883a 	nop
81115d38:	e037883a 	mov	sp,fp
81115d3c:	dfc00117 	ldw	ra,4(sp)
81115d40:	df000017 	ldw	fp,0(sp)
81115d44:	dec00204 	addi	sp,sp,8
81115d48:	f800283a 	ret

81115d4c <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81115d4c:	defffd04 	addi	sp,sp,-12
81115d50:	de00012e 	bgeu	sp,et,81115d58 <vFailCreateMutexSResources+0xc>
81115d54:	003b68fa 	trap	3
81115d58:	dfc00215 	stw	ra,8(sp)
81115d5c:	df000115 	stw	fp,4(sp)
81115d60:	df000104 	addi	fp,sp,4
81115d64:	2005883a 	mov	r2,r4
81115d68:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
81115d6c:	d0a05f17 	ldw	r2,-32388(gp)
81115d70:	100f883a 	mov	r7,r2
81115d74:	018008c4 	movi	r6,35
81115d78:	01400044 	movi	r5,1
81115d7c:	01204534 	movhi	r4,33044
81115d80:	211fea04 	addi	r4,r4,32680
81115d84:	111affc0 	call	8111affc <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81115d88:	e0bfff03 	ldbu	r2,-4(fp)
81115d8c:	1009883a 	mov	r4,r2
81115d90:	1115cdc0 	call	81115cdc <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115d94:	0001883a 	nop
81115d98:	e037883a 	mov	sp,fp
81115d9c:	dfc00117 	ldw	ra,4(sp)
81115da0:	df000017 	ldw	fp,0(sp)
81115da4:	dec00204 	addi	sp,sp,8
81115da8:	f800283a 	ret

81115dac <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
81115dac:	defffe04 	addi	sp,sp,-8
81115db0:	de00012e 	bgeu	sp,et,81115db8 <vFailCreateSemaphoreResources+0xc>
81115db4:	003b68fa 	trap	3
81115db8:	dfc00115 	stw	ra,4(sp)
81115dbc:	df000015 	stw	fp,0(sp)
81115dc0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
81115dc4:	d0a05f17 	ldw	r2,-32388(gp)
81115dc8:	100f883a 	mov	r7,r2
81115dcc:	01800984 	movi	r6,38
81115dd0:	01400044 	movi	r5,1
81115dd4:	01204534 	movhi	r4,33044
81115dd8:	211ff304 	addi	r4,r4,32716
81115ddc:	111affc0 	call	8111affc <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115de0:	0001883a 	nop
81115de4:	e037883a 	mov	sp,fp
81115de8:	dfc00117 	ldw	ra,4(sp)
81115dec:	df000017 	ldw	fp,0(sp)
81115df0:	dec00204 	addi	sp,sp,8
81115df4:	f800283a 	ret

81115df8 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81115df8:	defffe04 	addi	sp,sp,-8
81115dfc:	de00012e 	bgeu	sp,et,81115e04 <vFailTestCriticasParts+0xc>
81115e00:	003b68fa 	trap	3
81115e04:	dfc00115 	stw	ra,4(sp)
81115e08:	df000015 	stw	fp,0(sp)
81115e0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
81115e10:	d0a05f17 	ldw	r2,-32388(gp)
81115e14:	100f883a 	mov	r7,r2
81115e18:	018007c4 	movi	r6,31
81115e1c:	01400044 	movi	r5,1
81115e20:	01204534 	movhi	r4,33044
81115e24:	211ffd04 	addi	r4,r4,32756
81115e28:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115e2c:	0001883a 	nop
81115e30:	e037883a 	mov	sp,fp
81115e34:	dfc00117 	ldw	ra,4(sp)
81115e38:	df000017 	ldw	fp,0(sp)
81115e3c:	dec00204 	addi	sp,sp,8
81115e40:	f800283a 	ret

81115e44 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81115e44:	defffe04 	addi	sp,sp,-8
81115e48:	de00012e 	bgeu	sp,et,81115e50 <vFailSendxSemCommInit+0xc>
81115e4c:	003b68fa 	trap	3
81115e50:	dfc00115 	stw	ra,4(sp)
81115e54:	df000015 	stw	fp,0(sp)
81115e58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81115e5c:	d0a05f17 	ldw	r2,-32388(gp)
81115e60:	100f883a 	mov	r7,r2
81115e64:	01800744 	movi	r6,29
81115e68:	01400044 	movi	r5,1
81115e6c:	01204574 	movhi	r4,33045
81115e70:	21200504 	addi	r4,r4,-32748
81115e74:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
81115e78:	d0a05f17 	ldw	r2,-32388(gp)
81115e7c:	100f883a 	mov	r7,r2
81115e80:	01800a44 	movi	r6,41
81115e84:	01400044 	movi	r5,1
81115e88:	01204574 	movhi	r4,33045
81115e8c:	21200d04 	addi	r4,r4,-32716
81115e90:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115e94:	0001883a 	nop
81115e98:	e037883a 	mov	sp,fp
81115e9c:	dfc00117 	ldw	ra,4(sp)
81115ea0:	df000017 	ldw	fp,0(sp)
81115ea4:	dec00204 	addi	sp,sp,8
81115ea8:	f800283a 	ret

81115eac <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
81115eac:	defffe04 	addi	sp,sp,-8
81115eb0:	de00012e 	bgeu	sp,et,81115eb8 <vFailSendPreParsedSemaphore+0xc>
81115eb4:	003b68fa 	trap	3
81115eb8:	dfc00115 	stw	ra,4(sp)
81115ebc:	df000015 	stw	fp,0(sp)
81115ec0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
81115ec4:	d0a05f17 	ldw	r2,-32388(gp)
81115ec8:	100f883a 	mov	r7,r2
81115ecc:	01800904 	movi	r6,36
81115ed0:	01400044 	movi	r5,1
81115ed4:	01204574 	movhi	r4,33045
81115ed8:	21201804 	addi	r4,r4,-32672
81115edc:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115ee0:	0001883a 	nop
81115ee4:	e037883a 	mov	sp,fp
81115ee8:	dfc00117 	ldw	ra,4(sp)
81115eec:	df000017 	ldw	fp,0(sp)
81115ef0:	dec00204 	addi	sp,sp,8
81115ef4:	f800283a 	ret

81115ef8 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81115ef8:	defffe04 	addi	sp,sp,-8
81115efc:	de00012e 	bgeu	sp,et,81115f04 <vFailSendPreAckReceiverSemaphore+0xc>
81115f00:	003b68fa 	trap	3
81115f04:	dfc00115 	stw	ra,4(sp)
81115f08:	df000015 	stw	fp,0(sp)
81115f0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
81115f10:	d0a05f17 	ldw	r2,-32388(gp)
81115f14:	100f883a 	mov	r7,r2
81115f18:	01800a44 	movi	r6,41
81115f1c:	01400044 	movi	r5,1
81115f20:	01204574 	movhi	r4,33045
81115f24:	21202204 	addi	r4,r4,-32632
81115f28:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115f2c:	0001883a 	nop
81115f30:	e037883a 	mov	sp,fp
81115f34:	dfc00117 	ldw	ra,4(sp)
81115f38:	df000017 	ldw	fp,0(sp)
81115f3c:	dec00204 	addi	sp,sp,8
81115f40:	f800283a 	ret

81115f44 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81115f44:	defffe04 	addi	sp,sp,-8
81115f48:	de00012e 	bgeu	sp,et,81115f50 <vFailSendPreAckSenderSemaphore+0xc>
81115f4c:	003b68fa 	trap	3
81115f50:	dfc00115 	stw	ra,4(sp)
81115f54:	df000015 	stw	fp,0(sp)
81115f58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81115f5c:	d0a05f17 	ldw	r2,-32388(gp)
81115f60:	100f883a 	mov	r7,r2
81115f64:	018009c4 	movi	r6,39
81115f68:	01400044 	movi	r5,1
81115f6c:	01204574 	movhi	r4,33045
81115f70:	21202d04 	addi	r4,r4,-32588
81115f74:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115f78:	0001883a 	nop
81115f7c:	e037883a 	mov	sp,fp
81115f80:	dfc00117 	ldw	ra,4(sp)
81115f84:	df000017 	ldw	fp,0(sp)
81115f88:	dec00204 	addi	sp,sp,8
81115f8c:	f800283a 	ret

81115f90 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
81115f90:	defffe04 	addi	sp,sp,-8
81115f94:	de00012e 	bgeu	sp,et,81115f9c <vFailGetCountSemaphoreSenderTask+0xc>
81115f98:	003b68fa 	trap	3
81115f9c:	dfc00115 	stw	ra,4(sp)
81115fa0:	df000015 	stw	fp,0(sp)
81115fa4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
81115fa8:	d0a05f17 	ldw	r2,-32388(gp)
81115fac:	100f883a 	mov	r7,r2
81115fb0:	01800a44 	movi	r6,41
81115fb4:	01400044 	movi	r5,1
81115fb8:	01204574 	movhi	r4,33045
81115fbc:	21203704 	addi	r4,r4,-32548
81115fc0:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
81115fc4:	d0a05f17 	ldw	r2,-32388(gp)
81115fc8:	100f883a 	mov	r7,r2
81115fcc:	01801104 	movi	r6,68
81115fd0:	01400044 	movi	r5,1
81115fd4:	01204574 	movhi	r4,33045
81115fd8:	21204204 	addi	r4,r4,-32504
81115fdc:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81115fe0:	0001883a 	nop
81115fe4:	e037883a 	mov	sp,fp
81115fe8:	dfc00117 	ldw	ra,4(sp)
81115fec:	df000017 	ldw	fp,0(sp)
81115ff0:	dec00204 	addi	sp,sp,8
81115ff4:	f800283a 	ret

81115ff8 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81115ff8:	defffe04 	addi	sp,sp,-8
81115ffc:	de00012e 	bgeu	sp,et,81116004 <vFailGetMutexSenderTask+0xc>
81116000:	003b68fa 	trap	3
81116004:	dfc00115 	stw	ra,4(sp)
81116008:	df000015 	stw	fp,0(sp)
8111600c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
81116010:	d0a05f17 	ldw	r2,-32388(gp)
81116014:	100f883a 	mov	r7,r2
81116018:	01800804 	movi	r6,32
8111601c:	01400044 	movi	r5,1
81116020:	01204574 	movhi	r4,33045
81116024:	21205404 	addi	r4,r4,-32432
81116028:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111602c:	d0a05f17 	ldw	r2,-32388(gp)
81116030:	100f883a 	mov	r7,r2
81116034:	01801084 	movi	r6,66
81116038:	01400044 	movi	r5,1
8111603c:	01204574 	movhi	r4,33045
81116040:	21205d04 	addi	r4,r4,-32396
81116044:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116048:	0001883a 	nop
8111604c:	e037883a 	mov	sp,fp
81116050:	dfc00117 	ldw	ra,4(sp)
81116054:	df000017 	ldw	fp,0(sp)
81116058:	dec00204 	addi	sp,sp,8
8111605c:	f800283a 	ret

81116060 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81116060:	defffe04 	addi	sp,sp,-8
81116064:	de00012e 	bgeu	sp,et,8111606c <vFailGetCountSemaphoreReceiverTask+0xc>
81116068:	003b68fa 	trap	3
8111606c:	dfc00115 	stw	ra,4(sp)
81116070:	df000015 	stw	fp,0(sp)
81116074:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
81116078:	d0a05f17 	ldw	r2,-32388(gp)
8111607c:	100f883a 	mov	r7,r2
81116080:	01800ac4 	movi	r6,43
81116084:	01400044 	movi	r5,1
81116088:	01204574 	movhi	r4,33045
8111608c:	21206e04 	addi	r4,r4,-32328
81116090:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
81116094:	d0a05f17 	ldw	r2,-32388(gp)
81116098:	100f883a 	mov	r7,r2
8111609c:	01801184 	movi	r6,70
811160a0:	01400044 	movi	r5,1
811160a4:	01204574 	movhi	r4,33045
811160a8:	21207904 	addi	r4,r4,-32284
811160ac:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811160b0:	0001883a 	nop
811160b4:	e037883a 	mov	sp,fp
811160b8:	dfc00117 	ldw	ra,4(sp)
811160bc:	df000017 	ldw	fp,0(sp)
811160c0:	dec00204 	addi	sp,sp,8
811160c4:	f800283a 	ret

811160c8 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
811160c8:	defffe04 	addi	sp,sp,-8
811160cc:	de00012e 	bgeu	sp,et,811160d4 <vFailGetMutexReceiverTask+0xc>
811160d0:	003b68fa 	trap	3
811160d4:	dfc00115 	stw	ra,4(sp)
811160d8:	df000015 	stw	fp,0(sp)
811160dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
811160e0:	d0a05f17 	ldw	r2,-32388(gp)
811160e4:	100f883a 	mov	r7,r2
811160e8:	01800884 	movi	r6,34
811160ec:	01400044 	movi	r5,1
811160f0:	01204574 	movhi	r4,33045
811160f4:	21208b04 	addi	r4,r4,-32212
811160f8:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
811160fc:	d0a05f17 	ldw	r2,-32388(gp)
81116100:	100f883a 	mov	r7,r2
81116104:	01801104 	movi	r6,68
81116108:	01400044 	movi	r5,1
8111610c:	01204574 	movhi	r4,33045
81116110:	21209404 	addi	r4,r4,-32176
81116114:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116118:	0001883a 	nop
8111611c:	e037883a 	mov	sp,fp
81116120:	dfc00117 	ldw	ra,4(sp)
81116124:	df000017 	ldw	fp,0(sp)
81116128:	dec00204 	addi	sp,sp,8
8111612c:	f800283a 	ret

81116130 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81116130:	defffe04 	addi	sp,sp,-8
81116134:	de00012e 	bgeu	sp,et,8111613c <vFailGetMutexTxUARTSenderTask+0xc>
81116138:	003b68fa 	trap	3
8111613c:	dfc00115 	stw	ra,4(sp)
81116140:	df000015 	stw	fp,0(sp)
81116144:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81116148:	d0a05f17 	ldw	r2,-32388(gp)
8111614c:	100f883a 	mov	r7,r2
81116150:	01800984 	movi	r6,38
81116154:	01400044 	movi	r5,1
81116158:	01204574 	movhi	r4,33045
8111615c:	2120a604 	addi	r4,r4,-32104
81116160:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
81116164:	d0a05f17 	ldw	r2,-32388(gp)
81116168:	100f883a 	mov	r7,r2
8111616c:	01801044 	movi	r6,65
81116170:	01400044 	movi	r5,1
81116174:	01204574 	movhi	r4,33045
81116178:	2120b004 	addi	r4,r4,-32064
8111617c:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116180:	0001883a 	nop
81116184:	e037883a 	mov	sp,fp
81116188:	dfc00117 	ldw	ra,4(sp)
8111618c:	df000017 	ldw	fp,0(sp)
81116190:	dec00204 	addi	sp,sp,8
81116194:	f800283a 	ret

81116198 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
81116198:	defffe04 	addi	sp,sp,-8
8111619c:	de00012e 	bgeu	sp,et,811161a4 <vFailGetMacRTC+0xc>
811161a0:	003b68fa 	trap	3
811161a4:	dfc00115 	stw	ra,4(sp)
811161a8:	df000015 	stw	fp,0(sp)
811161ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
811161b0:	d0a05f17 	ldw	r2,-32388(gp)
811161b4:	100f883a 	mov	r7,r2
811161b8:	018003c4 	movi	r6,15
811161bc:	01400044 	movi	r5,1
811161c0:	01204574 	movhi	r4,33045
811161c4:	2120c104 	addi	r4,r4,-31996
811161c8:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811161cc:	0001883a 	nop
811161d0:	e037883a 	mov	sp,fp
811161d4:	dfc00117 	ldw	ra,4(sp)
811161d8:	df000017 	ldw	fp,0(sp)
811161dc:	dec00204 	addi	sp,sp,8
811161e0:	f800283a 	ret

811161e4 <vFailInitialization>:


void vFailInitialization( void )
{
811161e4:	defffe04 	addi	sp,sp,-8
811161e8:	de00012e 	bgeu	sp,et,811161f0 <vFailInitialization+0xc>
811161ec:	003b68fa 	trap	3
811161f0:	dfc00115 	stw	ra,4(sp)
811161f4:	df000015 	stw	fp,0(sp)
811161f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
811161fc:	d0a05f17 	ldw	r2,-32388(gp)
81116200:	100f883a 	mov	r7,r2
81116204:	01800504 	movi	r6,20
81116208:	01400044 	movi	r5,1
8111620c:	01204574 	movhi	r4,33045
81116210:	2120c504 	addi	r4,r4,-31980
81116214:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116218:	0001883a 	nop
8111621c:	e037883a 	mov	sp,fp
81116220:	dfc00117 	ldw	ra,4(sp)
81116224:	df000017 	ldw	fp,0(sp)
81116228:	dec00204 	addi	sp,sp,8
8111622c:	f800283a 	ret

81116230 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81116230:	defffe04 	addi	sp,sp,-8
81116234:	de00012e 	bgeu	sp,et,8111623c <vFailReceiverCreate+0xc>
81116238:	003b68fa 	trap	3
8111623c:	dfc00115 	stw	ra,4(sp)
81116240:	df000015 	stw	fp,0(sp)
81116244:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81116248:	d0a05f17 	ldw	r2,-32388(gp)
8111624c:	100f883a 	mov	r7,r2
81116250:	01800484 	movi	r6,18
81116254:	01400044 	movi	r5,1
81116258:	01204574 	movhi	r4,33045
8111625c:	2120cb04 	addi	r4,r4,-31956
81116260:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116264:	0001883a 	nop
81116268:	e037883a 	mov	sp,fp
8111626c:	dfc00117 	ldw	ra,4(sp)
81116270:	df000017 	ldw	fp,0(sp)
81116274:	dec00204 	addi	sp,sp,8
81116278:	f800283a 	ret

8111627c <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111627c:	defffe04 	addi	sp,sp,-8
81116280:	de00012e 	bgeu	sp,et,81116288 <vFailSenderCreate+0xc>
81116284:	003b68fa 	trap	3
81116288:	dfc00115 	stw	ra,4(sp)
8111628c:	df000015 	stw	fp,0(sp)
81116290:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
81116294:	d0a05f17 	ldw	r2,-32388(gp)
81116298:	100f883a 	mov	r7,r2
8111629c:	01800484 	movi	r6,18
811162a0:	01400044 	movi	r5,1
811162a4:	01204574 	movhi	r4,33045
811162a8:	2120d004 	addi	r4,r4,-31936
811162ac:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811162b0:	0001883a 	nop
811162b4:	e037883a 	mov	sp,fp
811162b8:	dfc00117 	ldw	ra,4(sp)
811162bc:	df000017 	ldw	fp,0(sp)
811162c0:	dec00204 	addi	sp,sp,8
811162c4:	f800283a 	ret

811162c8 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
811162c8:	defffe04 	addi	sp,sp,-8
811162cc:	de00012e 	bgeu	sp,et,811162d4 <vFailDeleteInitialization+0xc>
811162d0:	003b68fa 	trap	3
811162d4:	dfc00115 	stw	ra,4(sp)
811162d8:	df000015 	stw	fp,0(sp)
811162dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
811162e0:	d0a05f17 	ldw	r2,-32388(gp)
811162e4:	100f883a 	mov	r7,r2
811162e8:	01800684 	movi	r6,26
811162ec:	01400044 	movi	r5,1
811162f0:	01204574 	movhi	r4,33045
811162f4:	2120d504 	addi	r4,r4,-31916
811162f8:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811162fc:	0001883a 	nop
81116300:	e037883a 	mov	sp,fp
81116304:	dfc00117 	ldw	ra,4(sp)
81116308:	df000017 	ldw	fp,0(sp)
8111630c:	dec00204 	addi	sp,sp,8
81116310:	f800283a 	ret

81116314 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81116314:	defffe04 	addi	sp,sp,-8
81116318:	de00012e 	bgeu	sp,et,81116320 <vFailSetCountSemaphorexBuffer32+0xc>
8111631c:	003b68fa 	trap	3
81116320:	dfc00115 	stw	ra,4(sp)
81116324:	df000015 	stw	fp,0(sp)
81116328:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111632c:	d0a05f17 	ldw	r2,-32388(gp)
81116330:	100f883a 	mov	r7,r2
81116334:	01800a04 	movi	r6,40
81116338:	01400044 	movi	r5,1
8111633c:	01204574 	movhi	r4,33045
81116340:	2120dc04 	addi	r4,r4,-31888
81116344:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81116348:	d0a05f17 	ldw	r2,-32388(gp)
8111634c:	100f883a 	mov	r7,r2
81116350:	018008c4 	movi	r6,35
81116354:	01400044 	movi	r5,1
81116358:	01204574 	movhi	r4,33045
8111635c:	2120e704 	addi	r4,r4,-31844
81116360:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116364:	0001883a 	nop
81116368:	e037883a 	mov	sp,fp
8111636c:	dfc00117 	ldw	ra,4(sp)
81116370:	df000017 	ldw	fp,0(sp)
81116374:	dec00204 	addi	sp,sp,8
81116378:	f800283a 	ret

8111637c <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111637c:	defffe04 	addi	sp,sp,-8
81116380:	de00012e 	bgeu	sp,et,81116388 <vFailSetCountSemaphorexBuffer64+0xc>
81116384:	003b68fa 	trap	3
81116388:	dfc00115 	stw	ra,4(sp)
8111638c:	df000015 	stw	fp,0(sp)
81116390:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
81116394:	d0a05f17 	ldw	r2,-32388(gp)
81116398:	100f883a 	mov	r7,r2
8111639c:	01800a04 	movi	r6,40
811163a0:	01400044 	movi	r5,1
811163a4:	01204574 	movhi	r4,33045
811163a8:	2120f004 	addi	r4,r4,-31808
811163ac:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
811163b0:	d0a05f17 	ldw	r2,-32388(gp)
811163b4:	100f883a 	mov	r7,r2
811163b8:	018008c4 	movi	r6,35
811163bc:	01400044 	movi	r5,1
811163c0:	01204574 	movhi	r4,33045
811163c4:	2120e704 	addi	r4,r4,-31844
811163c8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811163cc:	0001883a 	nop
811163d0:	e037883a 	mov	sp,fp
811163d4:	dfc00117 	ldw	ra,4(sp)
811163d8:	df000017 	ldw	fp,0(sp)
811163dc:	dec00204 	addi	sp,sp,8
811163e0:	f800283a 	ret

811163e4 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
811163e4:	defffe04 	addi	sp,sp,-8
811163e8:	de00012e 	bgeu	sp,et,811163f0 <vFailSetCountSemaphorexBuffer128+0xc>
811163ec:	003b68fa 	trap	3
811163f0:	dfc00115 	stw	ra,4(sp)
811163f4:	df000015 	stw	fp,0(sp)
811163f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
811163fc:	d0a05f17 	ldw	r2,-32388(gp)
81116400:	100f883a 	mov	r7,r2
81116404:	01800a44 	movi	r6,41
81116408:	01400044 	movi	r5,1
8111640c:	01204574 	movhi	r4,33045
81116410:	2120fb04 	addi	r4,r4,-31764
81116414:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81116418:	d0a05f17 	ldw	r2,-32388(gp)
8111641c:	100f883a 	mov	r7,r2
81116420:	018008c4 	movi	r6,35
81116424:	01400044 	movi	r5,1
81116428:	01204574 	movhi	r4,33045
8111642c:	2120e704 	addi	r4,r4,-31844
81116430:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116434:	0001883a 	nop
81116438:	e037883a 	mov	sp,fp
8111643c:	dfc00117 	ldw	ra,4(sp)
81116440:	df000017 	ldw	fp,0(sp)
81116444:	dec00204 	addi	sp,sp,8
81116448:	f800283a 	ret

8111644c <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111644c:	defffe04 	addi	sp,sp,-8
81116450:	de00012e 	bgeu	sp,et,81116458 <vFailGetCountSemaphorexBuffer128+0xc>
81116454:	003b68fa 	trap	3
81116458:	dfc00115 	stw	ra,4(sp)
8111645c:	df000015 	stw	fp,0(sp)
81116460:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
81116464:	d0a05f17 	ldw	r2,-32388(gp)
81116468:	100f883a 	mov	r7,r2
8111646c:	01800a44 	movi	r6,41
81116470:	01400044 	movi	r5,1
81116474:	01204574 	movhi	r4,33045
81116478:	21210604 	addi	r4,r4,-31720
8111647c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81116480:	d0a05f17 	ldw	r2,-32388(gp)
81116484:	100f883a 	mov	r7,r2
81116488:	01800884 	movi	r6,34
8111648c:	01400044 	movi	r5,1
81116490:	01204574 	movhi	r4,33045
81116494:	21211104 	addi	r4,r4,-31676
81116498:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111649c:	0001883a 	nop
811164a0:	e037883a 	mov	sp,fp
811164a4:	dfc00117 	ldw	ra,4(sp)
811164a8:	df000017 	ldw	fp,0(sp)
811164ac:	dec00204 	addi	sp,sp,8
811164b0:	f800283a 	ret

811164b4 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
811164b4:	defffe04 	addi	sp,sp,-8
811164b8:	de00012e 	bgeu	sp,et,811164c0 <vFailGetCountSemaphorexBuffer64+0xc>
811164bc:	003b68fa 	trap	3
811164c0:	dfc00115 	stw	ra,4(sp)
811164c4:	df000015 	stw	fp,0(sp)
811164c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
811164cc:	d0a05f17 	ldw	r2,-32388(gp)
811164d0:	100f883a 	mov	r7,r2
811164d4:	01800a04 	movi	r6,40
811164d8:	01400044 	movi	r5,1
811164dc:	01204574 	movhi	r4,33045
811164e0:	21211a04 	addi	r4,r4,-31640
811164e4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
811164e8:	d0a05f17 	ldw	r2,-32388(gp)
811164ec:	100f883a 	mov	r7,r2
811164f0:	01800884 	movi	r6,34
811164f4:	01400044 	movi	r5,1
811164f8:	01204574 	movhi	r4,33045
811164fc:	21211104 	addi	r4,r4,-31676
81116500:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116504:	0001883a 	nop
81116508:	e037883a 	mov	sp,fp
8111650c:	dfc00117 	ldw	ra,4(sp)
81116510:	df000017 	ldw	fp,0(sp)
81116514:	dec00204 	addi	sp,sp,8
81116518:	f800283a 	ret

8111651c <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111651c:	defffe04 	addi	sp,sp,-8
81116520:	de00012e 	bgeu	sp,et,81116528 <vFailGetCountSemaphorexBuffer32+0xc>
81116524:	003b68fa 	trap	3
81116528:	dfc00115 	stw	ra,4(sp)
8111652c:	df000015 	stw	fp,0(sp)
81116530:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
81116534:	d0a05f17 	ldw	r2,-32388(gp)
81116538:	100f883a 	mov	r7,r2
8111653c:	01800a04 	movi	r6,40
81116540:	01400044 	movi	r5,1
81116544:	01204574 	movhi	r4,33045
81116548:	21212504 	addi	r4,r4,-31596
8111654c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81116550:	d0a05f17 	ldw	r2,-32388(gp)
81116554:	100f883a 	mov	r7,r2
81116558:	01800884 	movi	r6,34
8111655c:	01400044 	movi	r5,1
81116560:	01204574 	movhi	r4,33045
81116564:	21211104 	addi	r4,r4,-31676
81116568:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111656c:	0001883a 	nop
81116570:	e037883a 	mov	sp,fp
81116574:	dfc00117 	ldw	ra,4(sp)
81116578:	df000017 	ldw	fp,0(sp)
8111657c:	dec00204 	addi	sp,sp,8
81116580:	f800283a 	ret

81116584 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
81116584:	defffe04 	addi	sp,sp,-8
81116588:	de00012e 	bgeu	sp,et,81116590 <vFailFoundBufferRetransmission+0xc>
8111658c:	003b68fa 	trap	3
81116590:	dfc00115 	stw	ra,4(sp)
81116594:	df000015 	stw	fp,0(sp)
81116598:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111659c:	d0a05f17 	ldw	r2,-32388(gp)
811165a0:	100f883a 	mov	r7,r2
811165a4:	01800a84 	movi	r6,42
811165a8:	01400044 	movi	r5,1
811165ac:	01204574 	movhi	r4,33045
811165b0:	21213004 	addi	r4,r4,-31552
811165b4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
811165b8:	d0a05f17 	ldw	r2,-32388(gp)
811165bc:	100f883a 	mov	r7,r2
811165c0:	01801204 	movi	r6,72
811165c4:	01400044 	movi	r5,1
811165c8:	01204574 	movhi	r4,33045
811165cc:	21213b04 	addi	r4,r4,-31508
811165d0:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811165d4:	0001883a 	nop
811165d8:	e037883a 	mov	sp,fp
811165dc:	dfc00117 	ldw	ra,4(sp)
811165e0:	df000017 	ldw	fp,0(sp)
811165e4:	dec00204 	addi	sp,sp,8
811165e8:	f800283a 	ret

811165ec <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
811165ec:	defffe04 	addi	sp,sp,-8
811165f0:	de00012e 	bgeu	sp,et,811165f8 <vFailGetCountSemaphorePreParsedBuffer+0xc>
811165f4:	003b68fa 	trap	3
811165f8:	dfc00115 	stw	ra,4(sp)
811165fc:	df000015 	stw	fp,0(sp)
81116600:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81116604:	d0a05f17 	ldw	r2,-32388(gp)
81116608:	100f883a 	mov	r7,r2
8111660c:	01800b84 	movi	r6,46
81116610:	01400044 	movi	r5,1
81116614:	01204574 	movhi	r4,33045
81116618:	21214e04 	addi	r4,r4,-31432
8111661c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
81116620:	d0a05f17 	ldw	r2,-32388(gp)
81116624:	100f883a 	mov	r7,r2
81116628:	018010c4 	movi	r6,67
8111662c:	01400044 	movi	r5,1
81116630:	01204574 	movhi	r4,33045
81116634:	21215a04 	addi	r4,r4,-31384
81116638:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111663c:	0001883a 	nop
81116640:	e037883a 	mov	sp,fp
81116644:	dfc00117 	ldw	ra,4(sp)
81116648:	df000017 	ldw	fp,0(sp)
8111664c:	dec00204 	addi	sp,sp,8
81116650:	f800283a 	ret

81116654 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
81116654:	defffe04 	addi	sp,sp,-8
81116658:	de00012e 	bgeu	sp,et,81116660 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111665c:	003b68fa 	trap	3
81116660:	dfc00115 	stw	ra,4(sp)
81116664:	df000015 	stw	fp,0(sp)
81116668:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111666c:	d0a05f17 	ldw	r2,-32388(gp)
81116670:	100f883a 	mov	r7,r2
81116674:	01800b04 	movi	r6,44
81116678:	01400044 	movi	r5,1
8111667c:	01204574 	movhi	r4,33045
81116680:	21216b04 	addi	r4,r4,-31316
81116684:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
81116688:	d0a05f17 	ldw	r2,-32388(gp)
8111668c:	100f883a 	mov	r7,r2
81116690:	01800fc4 	movi	r6,63
81116694:	01400044 	movi	r5,1
81116698:	01204574 	movhi	r4,33045
8111669c:	21217704 	addi	r4,r4,-31268
811166a0:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811166a4:	0001883a 	nop
811166a8:	e037883a 	mov	sp,fp
811166ac:	dfc00117 	ldw	ra,4(sp)
811166b0:	df000017 	ldw	fp,0(sp)
811166b4:	dec00204 	addi	sp,sp,8
811166b8:	f800283a 	ret

811166bc <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
811166bc:	defffe04 	addi	sp,sp,-8
811166c0:	de00012e 	bgeu	sp,et,811166c8 <vNoContentInPreParsedBuffer+0xc>
811166c4:	003b68fa 	trap	3
811166c8:	dfc00115 	stw	ra,4(sp)
811166cc:	df000015 	stw	fp,0(sp)
811166d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
811166d4:	d0a05f17 	ldw	r2,-32388(gp)
811166d8:	100f883a 	mov	r7,r2
811166dc:	01800904 	movi	r6,36
811166e0:	01400044 	movi	r5,1
811166e4:	01204574 	movhi	r4,33045
811166e8:	21218704 	addi	r4,r4,-31204
811166ec:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
811166f0:	d0a05f17 	ldw	r2,-32388(gp)
811166f4:	100f883a 	mov	r7,r2
811166f8:	01801684 	movi	r6,90
811166fc:	01400044 	movi	r5,1
81116700:	01204574 	movhi	r4,33045
81116704:	21219104 	addi	r4,r4,-31164
81116708:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111670c:	0001883a 	nop
81116710:	e037883a 	mov	sp,fp
81116714:	dfc00117 	ldw	ra,4(sp)
81116718:	df000017 	ldw	fp,0(sp)
8111671c:	dec00204 	addi	sp,sp,8
81116720:	f800283a 	ret

81116724 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81116724:	defffe04 	addi	sp,sp,-8
81116728:	de00012e 	bgeu	sp,et,81116730 <vCouldNotSendEthConfUART+0xc>
8111672c:	003b68fa 	trap	3
81116730:	dfc00115 	stw	ra,4(sp)
81116734:	df000015 	stw	fp,0(sp)
81116738:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111673c:	d0a05f17 	ldw	r2,-32388(gp)
81116740:	100f883a 	mov	r7,r2
81116744:	01800844 	movi	r6,33
81116748:	01400044 	movi	r5,1
8111674c:	01204574 	movhi	r4,33045
81116750:	2121a804 	addi	r4,r4,-31072
81116754:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
81116758:	d0a05f17 	ldw	r2,-32388(gp)
8111675c:	100f883a 	mov	r7,r2
81116760:	01801784 	movi	r6,94
81116764:	01400044 	movi	r5,1
81116768:	01204574 	movhi	r4,33045
8111676c:	2121b104 	addi	r4,r4,-31036
81116770:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116774:	0001883a 	nop
81116778:	e037883a 	mov	sp,fp
8111677c:	dfc00117 	ldw	ra,4(sp)
81116780:	df000017 	ldw	fp,0(sp)
81116784:	dec00204 	addi	sp,sp,8
81116788:	f800283a 	ret

8111678c <vFailSendNack>:

void vFailSendNack( void )
{
8111678c:	defffe04 	addi	sp,sp,-8
81116790:	de00012e 	bgeu	sp,et,81116798 <vFailSendNack+0xc>
81116794:	003b68fa 	trap	3
81116798:	dfc00115 	stw	ra,4(sp)
8111679c:	df000015 	stw	fp,0(sp)
811167a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
811167a4:	d0a05f17 	ldw	r2,-32388(gp)
811167a8:	100f883a 	mov	r7,r2
811167ac:	01800584 	movi	r6,22
811167b0:	01400044 	movi	r5,1
811167b4:	01204574 	movhi	r4,33045
811167b8:	2121c904 	addi	r4,r4,-30940
811167bc:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
811167c0:	d0a05f17 	ldw	r2,-32388(gp)
811167c4:	100f883a 	mov	r7,r2
811167c8:	01800a84 	movi	r6,42
811167cc:	01400044 	movi	r5,1
811167d0:	01204574 	movhi	r4,33045
811167d4:	2121cf04 	addi	r4,r4,-30916
811167d8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811167dc:	0001883a 	nop
811167e0:	e037883a 	mov	sp,fp
811167e4:	dfc00117 	ldw	ra,4(sp)
811167e8:	df000017 	ldw	fp,0(sp)
811167ec:	dec00204 	addi	sp,sp,8
811167f0:	f800283a 	ret

811167f4 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
811167f4:	defffe04 	addi	sp,sp,-8
811167f8:	de00012e 	bgeu	sp,et,81116800 <vFailSetPreAckSenderBuffer+0xc>
811167fc:	003b68fa 	trap	3
81116800:	dfc00115 	stw	ra,4(sp)
81116804:	df000015 	stw	fp,0(sp)
81116808:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111680c:	d0a05f17 	ldw	r2,-32388(gp)
81116810:	100f883a 	mov	r7,r2
81116814:	018008c4 	movi	r6,35
81116818:	01400044 	movi	r5,1
8111681c:	01204574 	movhi	r4,33045
81116820:	2121da04 	addi	r4,r4,-30872
81116824:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
81116828:	d0a05f17 	ldw	r2,-32388(gp)
8111682c:	100f883a 	mov	r7,r2
81116830:	01801584 	movi	r6,86
81116834:	01400044 	movi	r5,1
81116838:	01204574 	movhi	r4,33045
8111683c:	2121e304 	addi	r4,r4,-30836
81116840:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116844:	0001883a 	nop
81116848:	e037883a 	mov	sp,fp
8111684c:	dfc00117 	ldw	ra,4(sp)
81116850:	df000017 	ldw	fp,0(sp)
81116854:	dec00204 	addi	sp,sp,8
81116858:	f800283a 	ret

8111685c <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111685c:	defffe04 	addi	sp,sp,-8
81116860:	de00012e 	bgeu	sp,et,81116868 <vFailSetPreParsedBuffer+0xc>
81116864:	003b68fa 	trap	3
81116868:	dfc00115 	stw	ra,4(sp)
8111686c:	df000015 	stw	fp,0(sp)
81116870:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
81116874:	d0a05f17 	ldw	r2,-32388(gp)
81116878:	100f883a 	mov	r7,r2
8111687c:	01800804 	movi	r6,32
81116880:	01400044 	movi	r5,1
81116884:	01204574 	movhi	r4,33045
81116888:	2121f904 	addi	r4,r4,-30748
8111688c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
81116890:	d0a05f17 	ldw	r2,-32388(gp)
81116894:	100f883a 	mov	r7,r2
81116898:	018013c4 	movi	r6,79
8111689c:	01400044 	movi	r5,1
811168a0:	01204574 	movhi	r4,33045
811168a4:	21220204 	addi	r4,r4,-30712
811168a8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811168ac:	0001883a 	nop
811168b0:	e037883a 	mov	sp,fp
811168b4:	dfc00117 	ldw	ra,4(sp)
811168b8:	df000017 	ldw	fp,0(sp)
811168bc:	dec00204 	addi	sp,sp,8
811168c0:	f800283a 	ret

811168c4 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
811168c4:	defffe04 	addi	sp,sp,-8
811168c8:	de00012e 	bgeu	sp,et,811168d0 <vFailSetPreAckReceiverBuffer+0xc>
811168cc:	003b68fa 	trap	3
811168d0:	dfc00115 	stw	ra,4(sp)
811168d4:	df000015 	stw	fp,0(sp)
811168d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
811168dc:	d0a05f17 	ldw	r2,-32388(gp)
811168e0:	100f883a 	mov	r7,r2
811168e4:	01800944 	movi	r6,37
811168e8:	01400044 	movi	r5,1
811168ec:	01204574 	movhi	r4,33045
811168f0:	21221604 	addi	r4,r4,-30632
811168f4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
811168f8:	d0a05f17 	ldw	r2,-32388(gp)
811168fc:	100f883a 	mov	r7,r2
81116900:	018015c4 	movi	r6,87
81116904:	01400044 	movi	r5,1
81116908:	01204574 	movhi	r4,33045
8111690c:	21222004 	addi	r4,r4,-30592
81116910:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116914:	0001883a 	nop
81116918:	e037883a 	mov	sp,fp
8111691c:	dfc00117 	ldw	ra,4(sp)
81116920:	df000017 	ldw	fp,0(sp)
81116924:	dec00204 	addi	sp,sp,8
81116928:	f800283a 	ret

8111692c <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111692c:	defffe04 	addi	sp,sp,-8
81116930:	de00012e 	bgeu	sp,et,81116938 <vFailParserCommTaskCreate+0xc>
81116934:	003b68fa 	trap	3
81116938:	dfc00115 	stw	ra,4(sp)
8111693c:	df000015 	stw	fp,0(sp)
81116940:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
81116944:	d0a05f17 	ldw	r2,-32388(gp)
81116948:	100f883a 	mov	r7,r2
8111694c:	01800684 	movi	r6,26
81116950:	01400044 	movi	r5,1
81116954:	01204574 	movhi	r4,33045
81116958:	21223604 	addi	r4,r4,-30504
8111695c:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116960:	0001883a 	nop
81116964:	e037883a 	mov	sp,fp
81116968:	dfc00117 	ldw	ra,4(sp)
8111696c:	df000017 	ldw	fp,0(sp)
81116970:	dec00204 	addi	sp,sp,8
81116974:	f800283a 	ret

81116978 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
81116978:	defffe04 	addi	sp,sp,-8
8111697c:	de00012e 	bgeu	sp,et,81116984 <vFailInAckHandlerTaskCreate+0xc>
81116980:	003b68fa 	trap	3
81116984:	dfc00115 	stw	ra,4(sp)
81116988:	df000015 	stw	fp,0(sp)
8111698c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81116990:	d0a05f17 	ldw	r2,-32388(gp)
81116994:	100f883a 	mov	r7,r2
81116998:	01800704 	movi	r6,28
8111699c:	01400044 	movi	r5,1
811169a0:	01204574 	movhi	r4,33045
811169a4:	21223d04 	addi	r4,r4,-30476
811169a8:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811169ac:	0001883a 	nop
811169b0:	e037883a 	mov	sp,fp
811169b4:	dfc00117 	ldw	ra,4(sp)
811169b8:	df000017 	ldw	fp,0(sp)
811169bc:	dec00204 	addi	sp,sp,8
811169c0:	f800283a 	ret

811169c4 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
811169c4:	defffe04 	addi	sp,sp,-8
811169c8:	de00012e 	bgeu	sp,et,811169d0 <vFailOutAckHandlerTaskCreate+0xc>
811169cc:	003b68fa 	trap	3
811169d0:	dfc00115 	stw	ra,4(sp)
811169d4:	df000015 	stw	fp,0(sp)
811169d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
811169dc:	d0a05f17 	ldw	r2,-32388(gp)
811169e0:	100f883a 	mov	r7,r2
811169e4:	01800704 	movi	r6,28
811169e8:	01400044 	movi	r5,1
811169ec:	01204574 	movhi	r4,33045
811169f0:	21223d04 	addi	r4,r4,-30476
811169f4:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811169f8:	0001883a 	nop
811169fc:	e037883a 	mov	sp,fp
81116a00:	dfc00117 	ldw	ra,4(sp)
81116a04:	df000017 	ldw	fp,0(sp)
81116a08:	dec00204 	addi	sp,sp,8
81116a0c:	f800283a 	ret

81116a10 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
81116a10:	defffe04 	addi	sp,sp,-8
81116a14:	de00012e 	bgeu	sp,et,81116a1c <vFailCreateTimerRetransmisison+0xc>
81116a18:	003b68fa 	trap	3
81116a1c:	dfc00115 	stw	ra,4(sp)
81116a20:	df000015 	stw	fp,0(sp)
81116a24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
81116a28:	d0a05f17 	ldw	r2,-32388(gp)
81116a2c:	100f883a 	mov	r7,r2
81116a30:	018007c4 	movi	r6,31
81116a34:	01400044 	movi	r5,1
81116a38:	01204574 	movhi	r4,33045
81116a3c:	21224504 	addi	r4,r4,-30444
81116a40:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a44:	0001883a 	nop
81116a48:	e037883a 	mov	sp,fp
81116a4c:	dfc00117 	ldw	ra,4(sp)
81116a50:	df000017 	ldw	fp,0(sp)
81116a54:	dec00204 	addi	sp,sp,8
81116a58:	f800283a 	ret

81116a5c <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81116a5c:	defffe04 	addi	sp,sp,-8
81116a60:	de00012e 	bgeu	sp,et,81116a68 <vCouldNotCheckBufferTimeOutFunction+0xc>
81116a64:	003b68fa 	trap	3
81116a68:	dfc00115 	stw	ra,4(sp)
81116a6c:	df000015 	stw	fp,0(sp)
81116a70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
81116a74:	d0a05f17 	ldw	r2,-32388(gp)
81116a78:	100f883a 	mov	r7,r2
81116a7c:	01800904 	movi	r6,36
81116a80:	01400044 	movi	r5,1
81116a84:	01204574 	movhi	r4,33045
81116a88:	21224d04 	addi	r4,r4,-30412
81116a8c:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a90:	0001883a 	nop
81116a94:	e037883a 	mov	sp,fp
81116a98:	dfc00117 	ldw	ra,4(sp)
81116a9c:	df000017 	ldw	fp,0(sp)
81116aa0:	dec00204 	addi	sp,sp,8
81116aa4:	f800283a 	ret

81116aa8 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
81116aa8:	defffe04 	addi	sp,sp,-8
81116aac:	de00012e 	bgeu	sp,et,81116ab4 <vFailTimeoutCheckerTaskCreate+0xc>
81116ab0:	003b68fa 	trap	3
81116ab4:	dfc00115 	stw	ra,4(sp)
81116ab8:	df000015 	stw	fp,0(sp)
81116abc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
81116ac0:	d0a05f17 	ldw	r2,-32388(gp)
81116ac4:	100f883a 	mov	r7,r2
81116ac8:	01800a04 	movi	r6,40
81116acc:	01400044 	movi	r5,1
81116ad0:	01204574 	movhi	r4,33045
81116ad4:	21225704 	addi	r4,r4,-30372
81116ad8:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116adc:	0001883a 	nop
81116ae0:	e037883a 	mov	sp,fp
81116ae4:	dfc00117 	ldw	ra,4(sp)
81116ae8:	df000017 	ldw	fp,0(sp)
81116aec:	dec00204 	addi	sp,sp,8
81116af0:	f800283a 	ret

81116af4 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
81116af4:	defffe04 	addi	sp,sp,-8
81116af8:	de00012e 	bgeu	sp,et,81116b00 <vFailGetBlockingSemTimeoutTask+0xc>
81116afc:	003b68fa 	trap	3
81116b00:	dfc00115 	stw	ra,4(sp)
81116b04:	df000015 	stw	fp,0(sp)
81116b08:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81116b0c:	d0a05f17 	ldw	r2,-32388(gp)
81116b10:	100f883a 	mov	r7,r2
81116b14:	018009c4 	movi	r6,39
81116b18:	01400044 	movi	r5,1
81116b1c:	01204574 	movhi	r4,33045
81116b20:	21226204 	addi	r4,r4,-30328
81116b24:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
81116b28:	d0a05f17 	ldw	r2,-32388(gp)
81116b2c:	100f883a 	mov	r7,r2
81116b30:	01800cc4 	movi	r6,51
81116b34:	01400044 	movi	r5,1
81116b38:	01204574 	movhi	r4,33045
81116b3c:	21226c04 	addi	r4,r4,-30288
81116b40:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b44:	0001883a 	nop
81116b48:	e037883a 	mov	sp,fp
81116b4c:	dfc00117 	ldw	ra,4(sp)
81116b50:	df000017 	ldw	fp,0(sp)
81116b54:	dec00204 	addi	sp,sp,8
81116b58:	f800283a 	ret

81116b5c <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81116b5c:	defffe04 	addi	sp,sp,-8
81116b60:	de00012e 	bgeu	sp,et,81116b68 <vFailPostBlockingSemTimeoutTask+0xc>
81116b64:	003b68fa 	trap	3
81116b68:	dfc00115 	stw	ra,4(sp)
81116b6c:	df000015 	stw	fp,0(sp)
81116b70:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
81116b74:	d0a05f17 	ldw	r2,-32388(gp)
81116b78:	100f883a 	mov	r7,r2
81116b7c:	01800a04 	movi	r6,40
81116b80:	01400044 	movi	r5,1
81116b84:	01204574 	movhi	r4,33045
81116b88:	21227904 	addi	r4,r4,-30236
81116b8c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
81116b90:	d0a05f17 	ldw	r2,-32388(gp)
81116b94:	100f883a 	mov	r7,r2
81116b98:	01800c84 	movi	r6,50
81116b9c:	01400044 	movi	r5,1
81116ba0:	01204574 	movhi	r4,33045
81116ba4:	21228404 	addi	r4,r4,-30192
81116ba8:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116bac:	0001883a 	nop
81116bb0:	e037883a 	mov	sp,fp
81116bb4:	dfc00117 	ldw	ra,4(sp)
81116bb8:	df000017 	ldw	fp,0(sp)
81116bbc:	dec00204 	addi	sp,sp,8
81116bc0:	f800283a 	ret

81116bc4 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
81116bc4:	defffe04 	addi	sp,sp,-8
81116bc8:	de00012e 	bgeu	sp,et,81116bd0 <vFailCouldNotRetransmitTimeoutTask+0xc>
81116bcc:	003b68fa 	trap	3
81116bd0:	dfc00115 	stw	ra,4(sp)
81116bd4:	df000015 	stw	fp,0(sp)
81116bd8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
81116bdc:	d0a05f17 	ldw	r2,-32388(gp)
81116be0:	100f883a 	mov	r7,r2
81116be4:	01800ac4 	movi	r6,43
81116be8:	01400044 	movi	r5,1
81116bec:	01204574 	movhi	r4,33045
81116bf0:	21229104 	addi	r4,r4,-30140
81116bf4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
81116bf8:	d0a05f17 	ldw	r2,-32388(gp)
81116bfc:	100f883a 	mov	r7,r2
81116c00:	01801644 	movi	r6,89
81116c04:	01400044 	movi	r5,1
81116c08:	01204574 	movhi	r4,33045
81116c0c:	21229c04 	addi	r4,r4,-30096
81116c10:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c14:	0001883a 	nop
81116c18:	e037883a 	mov	sp,fp
81116c1c:	dfc00117 	ldw	ra,4(sp)
81116c20:	df000017 	ldw	fp,0(sp)
81116c24:	dec00204 	addi	sp,sp,8
81116c28:	f800283a 	ret

81116c2c <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81116c2c:	defffe04 	addi	sp,sp,-8
81116c30:	de00012e 	bgeu	sp,et,81116c38 <vCouldNotRetransmitB32TimeoutTask+0xc>
81116c34:	003b68fa 	trap	3
81116c38:	dfc00115 	stw	ra,4(sp)
81116c3c:	df000015 	stw	fp,0(sp)
81116c40:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
81116c44:	d0a05f17 	ldw	r2,-32388(gp)
81116c48:	100f883a 	mov	r7,r2
81116c4c:	01800a84 	movi	r6,42
81116c50:	01400044 	movi	r5,1
81116c54:	01204574 	movhi	r4,33045
81116c58:	2122b304 	addi	r4,r4,-30004
81116c5c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
81116c60:	d0a05f17 	ldw	r2,-32388(gp)
81116c64:	100f883a 	mov	r7,r2
81116c68:	01801444 	movi	r6,81
81116c6c:	01400044 	movi	r5,1
81116c70:	01204574 	movhi	r4,33045
81116c74:	2122be04 	addi	r4,r4,-29960
81116c78:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c7c:	0001883a 	nop
81116c80:	e037883a 	mov	sp,fp
81116c84:	dfc00117 	ldw	ra,4(sp)
81116c88:	df000017 	ldw	fp,0(sp)
81116c8c:	dec00204 	addi	sp,sp,8
81116c90:	f800283a 	ret

81116c94 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81116c94:	defffe04 	addi	sp,sp,-8
81116c98:	de00012e 	bgeu	sp,et,81116ca0 <vCouldNotRetransmitB64TimeoutTask+0xc>
81116c9c:	003b68fa 	trap	3
81116ca0:	dfc00115 	stw	ra,4(sp)
81116ca4:	df000015 	stw	fp,0(sp)
81116ca8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
81116cac:	d0a05f17 	ldw	r2,-32388(gp)
81116cb0:	100f883a 	mov	r7,r2
81116cb4:	01800a84 	movi	r6,42
81116cb8:	01400044 	movi	r5,1
81116cbc:	01204574 	movhi	r4,33045
81116cc0:	2122d304 	addi	r4,r4,-29876
81116cc4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
81116cc8:	d0a05f17 	ldw	r2,-32388(gp)
81116ccc:	100f883a 	mov	r7,r2
81116cd0:	01801444 	movi	r6,81
81116cd4:	01400044 	movi	r5,1
81116cd8:	01204574 	movhi	r4,33045
81116cdc:	2122de04 	addi	r4,r4,-29832
81116ce0:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ce4:	0001883a 	nop
81116ce8:	e037883a 	mov	sp,fp
81116cec:	dfc00117 	ldw	ra,4(sp)
81116cf0:	df000017 	ldw	fp,0(sp)
81116cf4:	dec00204 	addi	sp,sp,8
81116cf8:	f800283a 	ret

81116cfc <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81116cfc:	defffe04 	addi	sp,sp,-8
81116d00:	de00012e 	bgeu	sp,et,81116d08 <vCouldNotRetransmitB128TimeoutTask+0xc>
81116d04:	003b68fa 	trap	3
81116d08:	dfc00115 	stw	ra,4(sp)
81116d0c:	df000015 	stw	fp,0(sp)
81116d10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
81116d14:	d0a05f17 	ldw	r2,-32388(gp)
81116d18:	100f883a 	mov	r7,r2
81116d1c:	01800ac4 	movi	r6,43
81116d20:	01400044 	movi	r5,1
81116d24:	01204574 	movhi	r4,33045
81116d28:	2122f304 	addi	r4,r4,-29748
81116d2c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
81116d30:	d0a05f17 	ldw	r2,-32388(gp)
81116d34:	100f883a 	mov	r7,r2
81116d38:	01801484 	movi	r6,82
81116d3c:	01400044 	movi	r5,1
81116d40:	01204574 	movhi	r4,33045
81116d44:	2122fe04 	addi	r4,r4,-29704
81116d48:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d4c:	0001883a 	nop
81116d50:	e037883a 	mov	sp,fp
81116d54:	dfc00117 	ldw	ra,4(sp)
81116d58:	df000017 	ldw	fp,0(sp)
81116d5c:	dec00204 	addi	sp,sp,8
81116d60:	f800283a 	ret

81116d64 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81116d64:	defffe04 	addi	sp,sp,-8
81116d68:	de00012e 	bgeu	sp,et,81116d70 <vFailStartTimerRetransmission+0xc>
81116d6c:	003b68fa 	trap	3
81116d70:	dfc00115 	stw	ra,4(sp)
81116d74:	df000015 	stw	fp,0(sp)
81116d78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
81116d7c:	d0a05f17 	ldw	r2,-32388(gp)
81116d80:	100f883a 	mov	r7,r2
81116d84:	01800984 	movi	r6,38
81116d88:	01400044 	movi	r5,1
81116d8c:	01204574 	movhi	r4,33045
81116d90:	21231304 	addi	r4,r4,-29620
81116d94:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
81116d98:	d0a05f17 	ldw	r2,-32388(gp)
81116d9c:	100f883a 	mov	r7,r2
81116da0:	01800d44 	movi	r6,53
81116da4:	01400044 	movi	r5,1
81116da8:	01204574 	movhi	r4,33045
81116dac:	21231d04 	addi	r4,r4,-29580
81116db0:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116db4:	0001883a 	nop
81116db8:	e037883a 	mov	sp,fp
81116dbc:	dfc00117 	ldw	ra,4(sp)
81116dc0:	df000017 	ldw	fp,0(sp)
81116dc4:	dec00204 	addi	sp,sp,8
81116dc8:	f800283a 	ret

81116dcc <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
81116dcc:	defffe04 	addi	sp,sp,-8
81116dd0:	de00012e 	bgeu	sp,et,81116dd8 <vCouldNotSendTurnOff+0xc>
81116dd4:	003b68fa 	trap	3
81116dd8:	dfc00115 	stw	ra,4(sp)
81116ddc:	df000015 	stw	fp,0(sp)
81116de0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
81116de4:	d0a05f17 	ldw	r2,-32388(gp)
81116de8:	100f883a 	mov	r7,r2
81116dec:	01800744 	movi	r6,29
81116df0:	01400044 	movi	r5,1
81116df4:	01204574 	movhi	r4,33045
81116df8:	21232b04 	addi	r4,r4,-29524
81116dfc:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
81116e00:	d0a05f17 	ldw	r2,-32388(gp)
81116e04:	100f883a 	mov	r7,r2
81116e08:	01800984 	movi	r6,38
81116e0c:	01400044 	movi	r5,1
81116e10:	01204574 	movhi	r4,33045
81116e14:	21233304 	addi	r4,r4,-29492
81116e18:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e1c:	0001883a 	nop
81116e20:	e037883a 	mov	sp,fp
81116e24:	dfc00117 	ldw	ra,4(sp)
81116e28:	df000017 	ldw	fp,0(sp)
81116e2c:	dec00204 	addi	sp,sp,8
81116e30:	f800283a 	ret

81116e34 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81116e34:	defffe04 	addi	sp,sp,-8
81116e38:	de00012e 	bgeu	sp,et,81116e40 <vCouldNotSendReset+0xc>
81116e3c:	003b68fa 	trap	3
81116e40:	dfc00115 	stw	ra,4(sp)
81116e44:	df000015 	stw	fp,0(sp)
81116e48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81116e4c:	d0a05f17 	ldw	r2,-32388(gp)
81116e50:	100f883a 	mov	r7,r2
81116e54:	018006c4 	movi	r6,27
81116e58:	01400044 	movi	r5,1
81116e5c:	01204574 	movhi	r4,33045
81116e60:	21233d04 	addi	r4,r4,-29452
81116e64:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
81116e68:	d0a05f17 	ldw	r2,-32388(gp)
81116e6c:	100f883a 	mov	r7,r2
81116e70:	018008c4 	movi	r6,35
81116e74:	01400044 	movi	r5,1
81116e78:	01204574 	movhi	r4,33045
81116e7c:	21234404 	addi	r4,r4,-29424
81116e80:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e84:	0001883a 	nop
81116e88:	e037883a 	mov	sp,fp
81116e8c:	dfc00117 	ldw	ra,4(sp)
81116e90:	df000017 	ldw	fp,0(sp)
81116e94:	dec00204 	addi	sp,sp,8
81116e98:	f800283a 	ret

81116e9c <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
81116e9c:	defffe04 	addi	sp,sp,-8
81116ea0:	de00012e 	bgeu	sp,et,81116ea8 <vCouldNotSendLog+0xc>
81116ea4:	003b68fa 	trap	3
81116ea8:	dfc00115 	stw	ra,4(sp)
81116eac:	df000015 	stw	fp,0(sp)
81116eb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
81116eb4:	d0a05f17 	ldw	r2,-32388(gp)
81116eb8:	100f883a 	mov	r7,r2
81116ebc:	01800644 	movi	r6,25
81116ec0:	01400044 	movi	r5,1
81116ec4:	01204574 	movhi	r4,33045
81116ec8:	21234d04 	addi	r4,r4,-29388
81116ecc:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
81116ed0:	d0a05f17 	ldw	r2,-32388(gp)
81116ed4:	100f883a 	mov	r7,r2
81116ed8:	018008c4 	movi	r6,35
81116edc:	01400044 	movi	r5,1
81116ee0:	01204574 	movhi	r4,33045
81116ee4:	21235404 	addi	r4,r4,-29360
81116ee8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116eec:	0001883a 	nop
81116ef0:	e037883a 	mov	sp,fp
81116ef4:	dfc00117 	ldw	ra,4(sp)
81116ef8:	df000017 	ldw	fp,0(sp)
81116efc:	dec00204 	addi	sp,sp,8
81116f00:	f800283a 	ret

81116f04 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81116f04:	defffd04 	addi	sp,sp,-12
81116f08:	de00012e 	bgeu	sp,et,81116f10 <vCouldNotSendTMPusCommand+0xc>
81116f0c:	003b68fa 	trap	3
81116f10:	dfc00215 	stw	ra,8(sp)
81116f14:	df000115 	stw	fp,4(sp)
81116f18:	df000104 	addi	fp,sp,4
81116f1c:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
81116f20:	d0a05f17 	ldw	r2,-32388(gp)
81116f24:	100f883a 	mov	r7,r2
81116f28:	01800884 	movi	r6,34
81116f2c:	01400044 	movi	r5,1
81116f30:	01204574 	movhi	r4,33045
81116f34:	21235d04 	addi	r4,r4,-29324
81116f38:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81116f3c:	d0a05f17 	ldw	r2,-32388(gp)
81116f40:	100f883a 	mov	r7,r2
81116f44:	01800ac4 	movi	r6,43
81116f48:	01400044 	movi	r5,1
81116f4c:	01204574 	movhi	r4,33045
81116f50:	21236604 	addi	r4,r4,-29288
81116f54:	111affc0 	call	8111affc <fwrite>
		debug(fp,"cData");
81116f58:	d0a05f17 	ldw	r2,-32388(gp)
81116f5c:	100f883a 	mov	r7,r2
81116f60:	01800144 	movi	r6,5
81116f64:	01400044 	movi	r5,1
81116f68:	01204574 	movhi	r4,33045
81116f6c:	21237104 	addi	r4,r4,-29244
81116f70:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f74:	0001883a 	nop
81116f78:	e037883a 	mov	sp,fp
81116f7c:	dfc00117 	ldw	ra,4(sp)
81116f80:	df000017 	ldw	fp,0(sp)
81116f84:	dec00204 	addi	sp,sp,8
81116f88:	f800283a 	ret

81116f8c <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
81116f8c:	defffe04 	addi	sp,sp,-8
81116f90:	de00012e 	bgeu	sp,et,81116f98 <vWarnCouldNotgetMutexRetrans128+0xc>
81116f94:	003b68fa 	trap	3
81116f98:	dfc00115 	stw	ra,4(sp)
81116f9c:	df000015 	stw	fp,0(sp)
81116fa0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
81116fa4:	d0a05f17 	ldw	r2,-32388(gp)
81116fa8:	100f883a 	mov	r7,r2
81116fac:	01800a04 	movi	r6,40
81116fb0:	01400044 	movi	r5,1
81116fb4:	01204574 	movhi	r4,33045
81116fb8:	21237304 	addi	r4,r4,-29236
81116fbc:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
81116fc0:	d0a05f17 	ldw	r2,-32388(gp)
81116fc4:	100f883a 	mov	r7,r2
81116fc8:	018014c4 	movi	r6,83
81116fcc:	01400044 	movi	r5,1
81116fd0:	01204574 	movhi	r4,33045
81116fd4:	21237e04 	addi	r4,r4,-29192
81116fd8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116fdc:	0001883a 	nop
81116fe0:	e037883a 	mov	sp,fp
81116fe4:	dfc00117 	ldw	ra,4(sp)
81116fe8:	df000017 	ldw	fp,0(sp)
81116fec:	dec00204 	addi	sp,sp,8
81116ff0:	f800283a 	ret

81116ff4 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
81116ff4:	defffe04 	addi	sp,sp,-8
81116ff8:	de00012e 	bgeu	sp,et,81117000 <vFailCreateScheduleQueue+0xc>
81116ffc:	003b68fa 	trap	3
81117000:	dfc00115 	stw	ra,4(sp)
81117004:	df000015 	stw	fp,0(sp)
81117008:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111700c:	d0a05f17 	ldw	r2,-32388(gp)
81117010:	100f883a 	mov	r7,r2
81117014:	01800844 	movi	r6,33
81117018:	01400044 	movi	r5,1
8111701c:	01204574 	movhi	r4,33045
81117020:	21239304 	addi	r4,r4,-29108
81117024:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
81117028:	d0a05f17 	ldw	r2,-32388(gp)
8111702c:	100f883a 	mov	r7,r2
81117030:	01801204 	movi	r6,72
81117034:	01400044 	movi	r5,1
81117038:	01204574 	movhi	r4,33045
8111703c:	21239c04 	addi	r4,r4,-29072
81117040:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117044:	0001883a 	nop
81117048:	e037883a 	mov	sp,fp
8111704c:	dfc00117 	ldw	ra,4(sp)
81117050:	df000017 	ldw	fp,0(sp)
81117054:	dec00204 	addi	sp,sp,8
81117058:	f800283a 	ret

8111705c <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111705c:	defffd04 	addi	sp,sp,-12
81117060:	de00012e 	bgeu	sp,et,81117068 <vFailCreateNFEEQueue+0xc>
81117064:	003b68fa 	trap	3
81117068:	dfc00215 	stw	ra,8(sp)
8111706c:	df000115 	stw	fp,4(sp)
81117070:	df000104 	addi	fp,sp,4
81117074:	2005883a 	mov	r2,r4
81117078:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111707c:	d0a05f17 	ldw	r2,-32388(gp)
81117080:	100f883a 	mov	r7,r2
81117084:	01800744 	movi	r6,29
81117088:	01400044 	movi	r5,1
8111708c:	01204574 	movhi	r4,33045
81117090:	2123af04 	addi	r4,r4,-28996
81117094:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
81117098:	d0a05f17 	ldw	r2,-32388(gp)
8111709c:	e0ffff03 	ldbu	r3,-4(fp)
811170a0:	180d883a 	mov	r6,r3
811170a4:	01604574 	movhi	r5,33045
811170a8:	2963b704 	addi	r5,r5,-28964
811170ac:	1009883a 	mov	r4,r2
811170b0:	111bd280 	call	8111bd28 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811170b4:	0001883a 	nop
811170b8:	e037883a 	mov	sp,fp
811170bc:	dfc00117 	ldw	ra,4(sp)
811170c0:	df000017 	ldw	fp,0(sp)
811170c4:	dec00204 	addi	sp,sp,8
811170c8:	f800283a 	ret

811170cc <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
811170cc:	defffd04 	addi	sp,sp,-12
811170d0:	de00012e 	bgeu	sp,et,811170d8 <vFailCreateNFEESyncQueue+0xc>
811170d4:	003b68fa 	trap	3
811170d8:	dfc00215 	stw	ra,8(sp)
811170dc:	df000115 	stw	fp,4(sp)
811170e0:	df000104 	addi	fp,sp,4
811170e4:	2005883a 	mov	r2,r4
811170e8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
811170ec:	d0a05f17 	ldw	r2,-32388(gp)
811170f0:	100f883a 	mov	r7,r2
811170f4:	01800844 	movi	r6,33
811170f8:	01400044 	movi	r5,1
811170fc:	01204574 	movhi	r4,33045
81117100:	2123c504 	addi	r4,r4,-28908
81117104:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
81117108:	d0a05f17 	ldw	r2,-32388(gp)
8111710c:	e0ffff03 	ldbu	r3,-4(fp)
81117110:	180d883a 	mov	r6,r3
81117114:	01604574 	movhi	r5,33045
81117118:	2963ce04 	addi	r5,r5,-28872
8111711c:	1009883a 	mov	r4,r2
81117120:	111bd280 	call	8111bd28 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117124:	0001883a 	nop
81117128:	e037883a 	mov	sp,fp
8111712c:	dfc00117 	ldw	ra,4(sp)
81117130:	df000017 	ldw	fp,0(sp)
81117134:	dec00204 	addi	sp,sp,8
81117138:	f800283a 	ret

8111713c <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111713c:	defffe04 	addi	sp,sp,-8
81117140:	de00012e 	bgeu	sp,et,81117148 <vCoudlNotCreateNFee0Task+0xc>
81117144:	003b68fa 	trap	3
81117148:	dfc00115 	stw	ra,4(sp)
8111714c:	df000015 	stw	fp,0(sp)
81117150:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
81117154:	d0a05f17 	ldw	r2,-32388(gp)
81117158:	100f883a 	mov	r7,r2
8111715c:	01800844 	movi	r6,33
81117160:	01400044 	movi	r5,1
81117164:	01204574 	movhi	r4,33045
81117168:	2123dc04 	addi	r4,r4,-28816
8111716c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
81117170:	d0a05f17 	ldw	r2,-32388(gp)
81117174:	100f883a 	mov	r7,r2
81117178:	01800784 	movi	r6,30
8111717c:	01400044 	movi	r5,1
81117180:	01204574 	movhi	r4,33045
81117184:	2123e504 	addi	r4,r4,-28780
81117188:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111718c:	0001883a 	nop
81117190:	e037883a 	mov	sp,fp
81117194:	dfc00117 	ldw	ra,4(sp)
81117198:	df000017 	ldw	fp,0(sp)
8111719c:	dec00204 	addi	sp,sp,8
811171a0:	f800283a 	ret

811171a4 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
811171a4:	defffe04 	addi	sp,sp,-8
811171a8:	de00012e 	bgeu	sp,et,811171b0 <vCoudlNotCreateNFee1Task+0xc>
811171ac:	003b68fa 	trap	3
811171b0:	dfc00115 	stw	ra,4(sp)
811171b4:	df000015 	stw	fp,0(sp)
811171b8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
811171bc:	d0a05f17 	ldw	r2,-32388(gp)
811171c0:	100f883a 	mov	r7,r2
811171c4:	01800844 	movi	r6,33
811171c8:	01400044 	movi	r5,1
811171cc:	01204574 	movhi	r4,33045
811171d0:	2123ed04 	addi	r4,r4,-28748
811171d4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
811171d8:	d0a05f17 	ldw	r2,-32388(gp)
811171dc:	100f883a 	mov	r7,r2
811171e0:	01800784 	movi	r6,30
811171e4:	01400044 	movi	r5,1
811171e8:	01204574 	movhi	r4,33045
811171ec:	2123f604 	addi	r4,r4,-28712
811171f0:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811171f4:	0001883a 	nop
811171f8:	e037883a 	mov	sp,fp
811171fc:	dfc00117 	ldw	ra,4(sp)
81117200:	df000017 	ldw	fp,0(sp)
81117204:	dec00204 	addi	sp,sp,8
81117208:	f800283a 	ret

8111720c <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111720c:	defffe04 	addi	sp,sp,-8
81117210:	de00012e 	bgeu	sp,et,81117218 <vCoudlNotCreateNFee2Task+0xc>
81117214:	003b68fa 	trap	3
81117218:	dfc00115 	stw	ra,4(sp)
8111721c:	df000015 	stw	fp,0(sp)
81117220:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
81117224:	d0a05f17 	ldw	r2,-32388(gp)
81117228:	100f883a 	mov	r7,r2
8111722c:	01800844 	movi	r6,33
81117230:	01400044 	movi	r5,1
81117234:	01204574 	movhi	r4,33045
81117238:	2123fe04 	addi	r4,r4,-28680
8111723c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
81117240:	d0a05f17 	ldw	r2,-32388(gp)
81117244:	100f883a 	mov	r7,r2
81117248:	01800784 	movi	r6,30
8111724c:	01400044 	movi	r5,1
81117250:	01204574 	movhi	r4,33045
81117254:	21240704 	addi	r4,r4,-28644
81117258:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111725c:	0001883a 	nop
81117260:	e037883a 	mov	sp,fp
81117264:	dfc00117 	ldw	ra,4(sp)
81117268:	df000017 	ldw	fp,0(sp)
8111726c:	dec00204 	addi	sp,sp,8
81117270:	f800283a 	ret

81117274 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81117274:	defffe04 	addi	sp,sp,-8
81117278:	de00012e 	bgeu	sp,et,81117280 <vCoudlNotCreateNFee3Task+0xc>
8111727c:	003b68fa 	trap	3
81117280:	dfc00115 	stw	ra,4(sp)
81117284:	df000015 	stw	fp,0(sp)
81117288:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111728c:	d0a05f17 	ldw	r2,-32388(gp)
81117290:	100f883a 	mov	r7,r2
81117294:	01800844 	movi	r6,33
81117298:	01400044 	movi	r5,1
8111729c:	01204574 	movhi	r4,33045
811172a0:	21240f04 	addi	r4,r4,-28612
811172a4:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
811172a8:	d0a05f17 	ldw	r2,-32388(gp)
811172ac:	100f883a 	mov	r7,r2
811172b0:	01800784 	movi	r6,30
811172b4:	01400044 	movi	r5,1
811172b8:	01204574 	movhi	r4,33045
811172bc:	21241804 	addi	r4,r4,-28576
811172c0:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172c4:	0001883a 	nop
811172c8:	e037883a 	mov	sp,fp
811172cc:	dfc00117 	ldw	ra,4(sp)
811172d0:	df000017 	ldw	fp,0(sp)
811172d4:	dec00204 	addi	sp,sp,8
811172d8:	f800283a 	ret

811172dc <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
811172dc:	defffe04 	addi	sp,sp,-8
811172e0:	de00012e 	bgeu	sp,et,811172e8 <vCoudlNotCreateNFee4Task+0xc>
811172e4:	003b68fa 	trap	3
811172e8:	dfc00115 	stw	ra,4(sp)
811172ec:	df000015 	stw	fp,0(sp)
811172f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
811172f4:	d0a05f17 	ldw	r2,-32388(gp)
811172f8:	100f883a 	mov	r7,r2
811172fc:	01800844 	movi	r6,33
81117300:	01400044 	movi	r5,1
81117304:	01204574 	movhi	r4,33045
81117308:	21242004 	addi	r4,r4,-28544
8111730c:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
81117310:	d0a05f17 	ldw	r2,-32388(gp)
81117314:	100f883a 	mov	r7,r2
81117318:	01800784 	movi	r6,30
8111731c:	01400044 	movi	r5,1
81117320:	01204574 	movhi	r4,33045
81117324:	21242904 	addi	r4,r4,-28508
81117328:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111732c:	0001883a 	nop
81117330:	e037883a 	mov	sp,fp
81117334:	dfc00117 	ldw	ra,4(sp)
81117338:	df000017 	ldw	fp,0(sp)
8111733c:	dec00204 	addi	sp,sp,8
81117340:	f800283a 	ret

81117344 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
81117344:	defffe04 	addi	sp,sp,-8
81117348:	de00012e 	bgeu	sp,et,81117350 <vCoudlNotCreateNFee5Task+0xc>
8111734c:	003b68fa 	trap	3
81117350:	dfc00115 	stw	ra,4(sp)
81117354:	df000015 	stw	fp,0(sp)
81117358:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111735c:	d0a05f17 	ldw	r2,-32388(gp)
81117360:	100f883a 	mov	r7,r2
81117364:	01800844 	movi	r6,33
81117368:	01400044 	movi	r5,1
8111736c:	01204574 	movhi	r4,33045
81117370:	21243104 	addi	r4,r4,-28476
81117374:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
81117378:	d0a05f17 	ldw	r2,-32388(gp)
8111737c:	100f883a 	mov	r7,r2
81117380:	01800784 	movi	r6,30
81117384:	01400044 	movi	r5,1
81117388:	01204574 	movhi	r4,33045
8111738c:	21243a04 	addi	r4,r4,-28440
81117390:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117394:	0001883a 	nop
81117398:	e037883a 	mov	sp,fp
8111739c:	dfc00117 	ldw	ra,4(sp)
811173a0:	df000017 	ldw	fp,0(sp)
811173a4:	dec00204 	addi	sp,sp,8
811173a8:	f800283a 	ret

811173ac <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
811173ac:	defffe04 	addi	sp,sp,-8
811173b0:	de00012e 	bgeu	sp,et,811173b8 <vCoudlNotCreateNFeeControllerTask+0xc>
811173b4:	003b68fa 	trap	3
811173b8:	dfc00115 	stw	ra,4(sp)
811173bc:	df000015 	stw	fp,0(sp)
811173c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
811173c4:	d0a05f17 	ldw	r2,-32388(gp)
811173c8:	100f883a 	mov	r7,r2
811173cc:	01800a84 	movi	r6,42
811173d0:	01400044 	movi	r5,1
811173d4:	01204574 	movhi	r4,33045
811173d8:	21244204 	addi	r4,r4,-28408
811173dc:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
811173e0:	d0a05f17 	ldw	r2,-32388(gp)
811173e4:	100f883a 	mov	r7,r2
811173e8:	018009c4 	movi	r6,39
811173ec:	01400044 	movi	r5,1
811173f0:	01204574 	movhi	r4,33045
811173f4:	21244d04 	addi	r4,r4,-28364
811173f8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173fc:	0001883a 	nop
81117400:	e037883a 	mov	sp,fp
81117404:	dfc00117 	ldw	ra,4(sp)
81117408:	df000017 	ldw	fp,0(sp)
8111740c:	dec00204 	addi	sp,sp,8
81117410:	f800283a 	ret

81117414 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
81117414:	defffe04 	addi	sp,sp,-8
81117418:	de00012e 	bgeu	sp,et,81117420 <vCoudlNotCreateDataControllerTask+0xc>
8111741c:	003b68fa 	trap	3
81117420:	dfc00115 	stw	ra,4(sp)
81117424:	df000015 	stw	fp,0(sp)
81117428:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111742c:	d0a05f17 	ldw	r2,-32388(gp)
81117430:	100f883a 	mov	r7,r2
81117434:	01800a84 	movi	r6,42
81117438:	01400044 	movi	r5,1
8111743c:	01204574 	movhi	r4,33045
81117440:	21245704 	addi	r4,r4,-28324
81117444:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
81117448:	d0a05f17 	ldw	r2,-32388(gp)
8111744c:	100f883a 	mov	r7,r2
81117450:	018009c4 	movi	r6,39
81117454:	01400044 	movi	r5,1
81117458:	01204574 	movhi	r4,33045
8111745c:	21246204 	addi	r4,r4,-28280
81117460:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117464:	0001883a 	nop
81117468:	e037883a 	mov	sp,fp
8111746c:	dfc00117 	ldw	ra,4(sp)
81117470:	df000017 	ldw	fp,0(sp)
81117474:	dec00204 	addi	sp,sp,8
81117478:	f800283a 	ret

8111747c <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111747c:	defffe04 	addi	sp,sp,-8
81117480:	de00012e 	bgeu	sp,et,81117488 <vCoudlNotCreateMebTask+0xc>
81117484:	003b68fa 	trap	3
81117488:	dfc00115 	stw	ra,4(sp)
8111748c:	df000015 	stw	fp,0(sp)
81117490:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
81117494:	d0a05f17 	ldw	r2,-32388(gp)
81117498:	100f883a 	mov	r7,r2
8111749c:	018007c4 	movi	r6,31
811174a0:	01400044 	movi	r5,1
811174a4:	01204574 	movhi	r4,33045
811174a8:	21246c04 	addi	r4,r4,-28240
811174ac:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
811174b0:	d0a05f17 	ldw	r2,-32388(gp)
811174b4:	100f883a 	mov	r7,r2
811174b8:	018006c4 	movi	r6,27
811174bc:	01400044 	movi	r5,1
811174c0:	01204574 	movhi	r4,33045
811174c4:	21247404 	addi	r4,r4,-28208
811174c8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811174cc:	0001883a 	nop
811174d0:	e037883a 	mov	sp,fp
811174d4:	dfc00117 	ldw	ra,4(sp)
811174d8:	df000017 	ldw	fp,0(sp)
811174dc:	dec00204 	addi	sp,sp,8
811174e0:	f800283a 	ret

811174e4 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
811174e4:	defffd04 	addi	sp,sp,-12
811174e8:	de00012e 	bgeu	sp,et,811174f0 <vFailCreateMutexSPUSQueueMeb+0xc>
811174ec:	003b68fa 	trap	3
811174f0:	dfc00215 	stw	ra,8(sp)
811174f4:	df000115 	stw	fp,4(sp)
811174f8:	df000104 	addi	fp,sp,4
811174fc:	2005883a 	mov	r2,r4
81117500:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
81117504:	d0a05f17 	ldw	r2,-32388(gp)
81117508:	100f883a 	mov	r7,r2
8111750c:	01800944 	movi	r6,37
81117510:	01400044 	movi	r5,1
81117514:	01204574 	movhi	r4,33045
81117518:	21247b04 	addi	r4,r4,-28180
8111751c:	111affc0 	call	8111affc <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81117520:	e0bfff03 	ldbu	r2,-4(fp)
81117524:	1009883a 	mov	r4,r2
81117528:	1115cdc0 	call	81115cdc <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111752c:	0001883a 	nop
81117530:	e037883a 	mov	sp,fp
81117534:	dfc00117 	ldw	ra,4(sp)
81117538:	df000017 	ldw	fp,0(sp)
8111753c:	dec00204 	addi	sp,sp,8
81117540:	f800283a 	ret

81117544 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
81117544:	defffe04 	addi	sp,sp,-8
81117548:	de00012e 	bgeu	sp,et,81117550 <vFailSendPUStoMebTask+0xc>
8111754c:	003b68fa 	trap	3
81117550:	dfc00115 	stw	ra,4(sp)
81117554:	df000015 	stw	fp,0(sp)
81117558:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111755c:	d0a05f17 	ldw	r2,-32388(gp)
81117560:	100f883a 	mov	r7,r2
81117564:	01800784 	movi	r6,30
81117568:	01400044 	movi	r5,1
8111756c:	01204574 	movhi	r4,33045
81117570:	21248504 	addi	r4,r4,-28140
81117574:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117578:	0001883a 	nop
8111757c:	e037883a 	mov	sp,fp
81117580:	dfc00117 	ldw	ra,4(sp)
81117584:	df000017 	ldw	fp,0(sp)
81117588:	dec00204 	addi	sp,sp,8
8111758c:	f800283a 	ret

81117590 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
81117590:	defffe04 	addi	sp,sp,-8
81117594:	de00012e 	bgeu	sp,et,8111759c <vCouldNotGetCmdQueueMeb+0xc>
81117598:	003b68fa 	trap	3
8111759c:	dfc00115 	stw	ra,4(sp)
811175a0:	df000015 	stw	fp,0(sp)
811175a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetCmdQueueMeb. (exit)\n");
811175a8:	d0a05f17 	ldw	r2,-32388(gp)
811175ac:	100f883a 	mov	r7,r2
811175b0:	01800804 	movi	r6,32
811175b4:	01400044 	movi	r5,1
811175b8:	01204574 	movhi	r4,33045
811175bc:	21248d04 	addi	r4,r4,-28108
811175c0:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
811175c4:	d0a05f17 	ldw	r2,-32388(gp)
811175c8:	100f883a 	mov	r7,r2
811175cc:	01800cc4 	movi	r6,51
811175d0:	01400044 	movi	r5,1
811175d4:	01204574 	movhi	r4,33045
811175d8:	21249604 	addi	r4,r4,-28072
811175dc:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811175e0:	0001883a 	nop
811175e4:	e037883a 	mov	sp,fp
811175e8:	dfc00117 	ldw	ra,4(sp)
811175ec:	df000017 	ldw	fp,0(sp)
811175f0:	dec00204 	addi	sp,sp,8
811175f4:	f800283a 	ret

811175f8 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
811175f8:	defffe04 	addi	sp,sp,-8
811175fc:	de00012e 	bgeu	sp,et,81117604 <vCouldNotGetMutexMebPus+0xc>
81117600:	003b68fa 	trap	3
81117604:	dfc00115 	stw	ra,4(sp)
81117608:	df000015 	stw	fp,0(sp)
8111760c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
81117610:	d0a05f17 	ldw	r2,-32388(gp)
81117614:	100f883a 	mov	r7,r2
81117618:	01800804 	movi	r6,32
8111761c:	01400044 	movi	r5,1
81117620:	01204574 	movhi	r4,33045
81117624:	2124a304 	addi	r4,r4,-28020
81117628:	111affc0 	call	8111affc <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111762c:	0001883a 	nop
81117630:	e037883a 	mov	sp,fp
81117634:	dfc00117 	ldw	ra,4(sp)
81117638:	df000017 	ldw	fp,0(sp)
8111763c:	dec00204 	addi	sp,sp,8
81117640:	f800283a 	ret

81117644 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81117644:	defffe04 	addi	sp,sp,-8
81117648:	de00012e 	bgeu	sp,et,81117650 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111764c:	003b68fa 	trap	3
81117650:	dfc00115 	stw	ra,4(sp)
81117654:	df000015 	stw	fp,0(sp)
81117658:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111765c:	d0a05f17 	ldw	r2,-32388(gp)
81117660:	100f883a 	mov	r7,r2
81117664:	01800a44 	movi	r6,41
81117668:	01400044 	movi	r5,1
8111766c:	01204574 	movhi	r4,33045
81117670:	2124ac04 	addi	r4,r4,-27984
81117674:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
81117678:	d0a05f17 	ldw	r2,-32388(gp)
8111767c:	100f883a 	mov	r7,r2
81117680:	01800c84 	movi	r6,50
81117684:	01400044 	movi	r5,1
81117688:	01204574 	movhi	r4,33045
8111768c:	2124b704 	addi	r4,r4,-27940
81117690:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117694:	0001883a 	nop
81117698:	e037883a 	mov	sp,fp
8111769c:	dfc00117 	ldw	ra,4(sp)
811176a0:	df000017 	ldw	fp,0(sp)
811176a4:	dec00204 	addi	sp,sp,8
811176a8:	f800283a 	ret

811176ac <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
811176ac:	defffe04 	addi	sp,sp,-8
811176b0:	de00012e 	bgeu	sp,et,811176b8 <vCouldNotCreateQueueMaskDataCtrl+0xc>
811176b4:	003b68fa 	trap	3
811176b8:	dfc00115 	stw	ra,4(sp)
811176bc:	df000015 	stw	fp,0(sp)
811176c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
811176c4:	d0a05f17 	ldw	r2,-32388(gp)
811176c8:	100f883a 	mov	r7,r2
811176cc:	01800a44 	movi	r6,41
811176d0:	01400044 	movi	r5,1
811176d4:	01204574 	movhi	r4,33045
811176d8:	2124c404 	addi	r4,r4,-27888
811176dc:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
811176e0:	d0a05f17 	ldw	r2,-32388(gp)
811176e4:	100f883a 	mov	r7,r2
811176e8:	01800c84 	movi	r6,50
811176ec:	01400044 	movi	r5,1
811176f0:	01204574 	movhi	r4,33045
811176f4:	2124cf04 	addi	r4,r4,-27844
811176f8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811176fc:	0001883a 	nop
81117700:	e037883a 	mov	sp,fp
81117704:	dfc00117 	ldw	ra,4(sp)
81117708:	df000017 	ldw	fp,0(sp)
8111770c:	dec00204 	addi	sp,sp,8
81117710:	f800283a 	ret

81117714 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81117714:	defffe04 	addi	sp,sp,-8
81117718:	de00012e 	bgeu	sp,et,81117720 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111771c:	003b68fa 	trap	3
81117720:	dfc00115 	stw	ra,4(sp)
81117724:	df000015 	stw	fp,0(sp)
81117728:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111772c:	d0a05f17 	ldw	r2,-32388(gp)
81117730:	100f883a 	mov	r7,r2
81117734:	01800984 	movi	r6,38
81117738:	01400044 	movi	r5,1
8111773c:	01204574 	movhi	r4,33045
81117740:	2124dc04 	addi	r4,r4,-27792
81117744:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
81117748:	d0a05f17 	ldw	r2,-32388(gp)
8111774c:	100f883a 	mov	r7,r2
81117750:	01800bc4 	movi	r6,47
81117754:	01400044 	movi	r5,1
81117758:	01204574 	movhi	r4,33045
8111775c:	2124e604 	addi	r4,r4,-27752
81117760:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117764:	0001883a 	nop
81117768:	e037883a 	mov	sp,fp
8111776c:	dfc00117 	ldw	ra,4(sp)
81117770:	df000017 	ldw	fp,0(sp)
81117774:	dec00204 	addi	sp,sp,8
81117778:	f800283a 	ret

8111777c <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111777c:	defffe04 	addi	sp,sp,-8
81117780:	de00012e 	bgeu	sp,et,81117788 <vCouldNotGetQueueMaskDataCtrl+0xc>
81117784:	003b68fa 	trap	3
81117788:	dfc00115 	stw	ra,4(sp)
8111778c:	df000015 	stw	fp,0(sp)
81117790:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
81117794:	d0a05f17 	ldw	r2,-32388(gp)
81117798:	100f883a 	mov	r7,r2
8111779c:	01800984 	movi	r6,38
811177a0:	01400044 	movi	r5,1
811177a4:	01204574 	movhi	r4,33045
811177a8:	2124f204 	addi	r4,r4,-27704
811177ac:	111affc0 	call	8111affc <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
811177b0:	d0a05f17 	ldw	r2,-32388(gp)
811177b4:	100f883a 	mov	r7,r2
811177b8:	01800bc4 	movi	r6,47
811177bc:	01400044 	movi	r5,1
811177c0:	01204574 	movhi	r4,33045
811177c4:	2124fc04 	addi	r4,r4,-27664
811177c8:	111affc0 	call	8111affc <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811177cc:	0001883a 	nop
811177d0:	e037883a 	mov	sp,fp
811177d4:	dfc00117 	ldw	ra,4(sp)
811177d8:	df000017 	ldw	fp,0(sp)
811177dc:	dec00204 	addi	sp,sp,8
811177e0:	f800283a 	ret

811177e4 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
811177e4:	defffd04 	addi	sp,sp,-12
811177e8:	de00012e 	bgeu	sp,et,811177f0 <vFailSendMsgAccessDMA+0xc>
811177ec:	003b68fa 	trap	3
811177f0:	dfc00215 	stw	ra,8(sp)
811177f4:	df000115 	stw	fp,4(sp)
811177f8:	df000104 	addi	fp,sp,4
811177fc:	2005883a 	mov	r2,r4
81117800:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
81117804:	d0a05f17 	ldw	r2,-32388(gp)
81117808:	e0ffff03 	ldbu	r3,-4(fp)
8111780c:	180d883a 	mov	r6,r3
81117810:	01604574 	movhi	r5,33045
81117814:	29650804 	addi	r5,r5,-27616
81117818:	1009883a 	mov	r4,r2
8111781c:	111a9600 	call	8111a960 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117820:	0001883a 	nop
81117824:	e037883a 	mov	sp,fp
81117828:	dfc00117 	ldw	ra,4(sp)
8111782c:	df000017 	ldw	fp,0(sp)
81117830:	dec00204 	addi	sp,sp,8
81117834:	f800283a 	ret

81117838 <vFailSendMsgSync>:

void vFailSendMsgSync( unsigned char ucTemp)
{
81117838:	defffd04 	addi	sp,sp,-12
8111783c:	de00012e 	bgeu	sp,et,81117844 <vFailSendMsgSync+0xc>
81117840:	003b68fa 	trap	3
81117844:	dfc00215 	stw	ra,8(sp)
81117848:	df000115 	stw	fp,4(sp)
8111784c:	df000104 	addi	fp,sp,4
81117850:	2005883a 	mov	r2,r4
81117854:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
81117858:	d0a05f17 	ldw	r2,-32388(gp)
8111785c:	e0ffff03 	ldbu	r3,-4(fp)
81117860:	180d883a 	mov	r6,r3
81117864:	01604574 	movhi	r5,33045
81117868:	29651004 	addi	r5,r5,-27584
8111786c:	1009883a 	mov	r4,r2
81117870:	111a9600 	call	8111a960 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117874:	0001883a 	nop
81117878:	e037883a 	mov	sp,fp
8111787c:	dfc00117 	ldw	ra,4(sp)
81117880:	df000017 	ldw	fp,0(sp)
81117884:	dec00204 	addi	sp,sp,8
81117888:	f800283a 	ret

8111788c <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111788c:	defffe04 	addi	sp,sp,-8
81117890:	de00012e 	bgeu	sp,et,81117898 <vFailSendMsgFeeCTRL+0xc>
81117894:	003b68fa 	trap	3
81117898:	dfc00115 	stw	ra,4(sp)
8111789c:	df000015 	stw	fp,0(sp)
811178a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
811178a4:	d0a05f17 	ldw	r2,-32388(gp)
811178a8:	100f883a 	mov	r7,r2
811178ac:	018005c4 	movi	r6,23
811178b0:	01400044 	movi	r5,1
811178b4:	01204574 	movhi	r4,33045
811178b8:	21251704 	addi	r4,r4,-27556
811178bc:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811178c0:	0001883a 	nop
811178c4:	e037883a 	mov	sp,fp
811178c8:	dfc00117 	ldw	ra,4(sp)
811178cc:	df000017 	ldw	fp,0(sp)
811178d0:	dec00204 	addi	sp,sp,8
811178d4:	f800283a 	ret

811178d8 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
811178d8:	defffe04 	addi	sp,sp,-8
811178dc:	de00012e 	bgeu	sp,et,811178e4 <vFailSendMsgDataCTRL+0xc>
811178e0:	003b68fa 	trap	3
811178e4:	dfc00115 	stw	ra,4(sp)
811178e8:	df000015 	stw	fp,0(sp)
811178ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
811178f0:	d0a05f17 	ldw	r2,-32388(gp)
811178f4:	100f883a 	mov	r7,r2
811178f8:	01800604 	movi	r6,24
811178fc:	01400044 	movi	r5,1
81117900:	01204574 	movhi	r4,33045
81117904:	21251d04 	addi	r4,r4,-27532
81117908:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111790c:	0001883a 	nop
81117910:	e037883a 	mov	sp,fp
81117914:	dfc00117 	ldw	ra,4(sp)
81117918:	df000017 	ldw	fp,0(sp)
8111791c:	dec00204 	addi	sp,sp,8
81117920:	f800283a 	ret

81117924 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
81117924:	defffe04 	addi	sp,sp,-8
81117928:	de00012e 	bgeu	sp,et,81117930 <vFailFlushQueue+0xc>
8111792c:	003b68fa 	trap	3
81117930:	dfc00115 	stw	ra,4(sp)
81117934:	df000015 	stw	fp,0(sp)
81117938:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111793c:	d0a05f17 	ldw	r2,-32388(gp)
81117940:	100f883a 	mov	r7,r2
81117944:	01800744 	movi	r6,29
81117948:	01400044 	movi	r5,1
8111794c:	01204574 	movhi	r4,33045
81117950:	21252404 	addi	r4,r4,-27504
81117954:	111affc0 	call	8111affc <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117958:	0001883a 	nop
8111795c:	e037883a 	mov	sp,fp
81117960:	dfc00117 	ldw	ra,4(sp)
81117964:	df000017 	ldw	fp,0(sp)
81117968:	dec00204 	addi	sp,sp,8
8111796c:	f800283a 	ret

81117970 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81117970:	defffc04 	addi	sp,sp,-16
81117974:	de00012e 	bgeu	sp,et,8111797c <vEvtChangeMebMode+0xc>
81117978:	003b68fa 	trap	3
8111797c:	dfc00315 	stw	ra,12(sp)
81117980:	df000215 	stw	fp,8(sp)
81117984:	df000204 	addi	fp,sp,8
81117988:	e13ffe15 	stw	r4,-8(fp)
8111798c:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\nvEvtChangeMebMode ( sMebConfig = 0, sRun = 1 ) \n");
81117990:	d0a05f17 	ldw	r2,-32388(gp)
81117994:	100f883a 	mov	r7,r2
81117998:	01800c44 	movi	r6,49
8111799c:	01400044 	movi	r5,1
811179a0:	01204574 	movhi	r4,33045
811179a4:	21252c04 	addi	r4,r4,-27472
811179a8:	111affc0 	call	8111affc <fwrite>
		fprintf(fp, "Meb State Change: %hu -> %hu \n\n", eOldState, eNewState );
811179ac:	d0a05f17 	ldw	r2,-32388(gp)
811179b0:	e1ffff17 	ldw	r7,-4(fp)
811179b4:	e1bffe17 	ldw	r6,-8(fp)
811179b8:	01604574 	movhi	r5,33045
811179bc:	29653904 	addi	r5,r5,-27420
811179c0:	1009883a 	mov	r4,r2
811179c4:	111a9600 	call	8111a960 <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
811179c8:	0001883a 	nop
811179cc:	e037883a 	mov	sp,fp
811179d0:	dfc00117 	ldw	ra,4(sp)
811179d4:	df000017 	ldw	fp,0(sp)
811179d8:	dec00204 	addi	sp,sp,8
811179dc:	f800283a 	ret

811179e0 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
811179e0:	defffc04 	addi	sp,sp,-16
811179e4:	de00012e 	bgeu	sp,et,811179ec <vEvtChangeFeeControllerMode+0xc>
811179e8:	003b68fa 	trap	3
811179ec:	dfc00315 	stw	ra,12(sp)
811179f0:	df000215 	stw	fp,8(sp)
811179f4:	df000204 	addi	fp,sp,8
811179f8:	e13ffe15 	stw	r4,-8(fp)
811179fc:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\vEvtChangeFeeControllerMode ( sMebConfig = 0, sRun = 1 ) \n");
81117a00:	d0a05f17 	ldw	r2,-32388(gp)
81117a04:	100f883a 	mov	r7,r2
81117a08:	01800e84 	movi	r6,58
81117a0c:	01400044 	movi	r5,1
81117a10:	01204574 	movhi	r4,33045
81117a14:	21254104 	addi	r4,r4,-27388
81117a18:	111affc0 	call	8111affc <fwrite>
		fprintf(fp, "NFEE Controller State Change: %hu -> %hu \n\n", eOldState, eNewState );
81117a1c:	d0a05f17 	ldw	r2,-32388(gp)
81117a20:	e1ffff17 	ldw	r7,-4(fp)
81117a24:	e1bffe17 	ldw	r6,-8(fp)
81117a28:	01604574 	movhi	r5,33045
81117a2c:	29655004 	addi	r5,r5,-27328
81117a30:	1009883a 	mov	r4,r2
81117a34:	111a9600 	call	8111a960 <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81117a38:	0001883a 	nop
81117a3c:	e037883a 	mov	sp,fp
81117a40:	dfc00117 	ldw	ra,4(sp)
81117a44:	df000017 	ldw	fp,0(sp)
81117a48:	dec00204 	addi	sp,sp,8
81117a4c:	f800283a 	ret

81117a50 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( tSimucamStates eOldState, tSimucamStates eNewState ) {
81117a50:	defffc04 	addi	sp,sp,-16
81117a54:	de00012e 	bgeu	sp,et,81117a5c <vEvtChangeDataControllerMode+0xc>
81117a58:	003b68fa 	trap	3
81117a5c:	dfc00315 	stw	ra,12(sp)
81117a60:	df000215 	stw	fp,8(sp)
81117a64:	df000204 	addi	fp,sp,8
81117a68:	e13ffe15 	stw	r4,-8(fp)
81117a6c:	e17fff15 	stw	r5,-4(fp)

	#ifdef DEBUG_ON
		fprintf(fp, "\vEvtChangeDataControllerMode ( sMebConfig = 0, sRun = 1 ) \n");
81117a70:	d0a05f17 	ldw	r2,-32388(gp)
81117a74:	100f883a 	mov	r7,r2
81117a78:	01800ec4 	movi	r6,59
81117a7c:	01400044 	movi	r5,1
81117a80:	01204574 	movhi	r4,33045
81117a84:	21255b04 	addi	r4,r4,-27284
81117a88:	111affc0 	call	8111affc <fwrite>
		fprintf(fp, "Data Controller State Change: %hu -> %hu \n\n", eOldState, eNewState );
81117a8c:	d0a05f17 	ldw	r2,-32388(gp)
81117a90:	e1ffff17 	ldw	r7,-4(fp)
81117a94:	e1bffe17 	ldw	r6,-8(fp)
81117a98:	01604574 	movhi	r5,33045
81117a9c:	29656a04 	addi	r5,r5,-27224
81117aa0:	1009883a 	mov	r4,r2
81117aa4:	111a9600 	call	8111a960 <fprintf>
	#endif

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
81117aa8:	0001883a 	nop
81117aac:	e037883a 	mov	sp,fp
81117ab0:	dfc00117 	ldw	ra,4(sp)
81117ab4:	df000017 	ldw	fp,0(sp)
81117ab8:	dec00204 	addi	sp,sp,8
81117abc:	f800283a 	ret

81117ac0 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81117ac0:	defffd04 	addi	sp,sp,-12
81117ac4:	de00012e 	bgeu	sp,et,81117acc <vNFeeNotInUse+0xc>
81117ac8:	003b68fa 	trap	3
81117acc:	df000215 	stw	fp,8(sp)
81117ad0:	df000204 	addi	fp,sp,8
81117ad4:	e13ffe15 	stw	r4,-8(fp)
81117ad8:	2805883a 	mov	r2,r5
81117adc:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
81117ae0:	e0bffe17 	ldw	r2,-8(fp)
81117ae4:	e0ffff03 	ldbu	r3,-4(fp)
81117ae8:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81117aec:	e0bffe17 	ldw	r2,-8(fp)
81117af0:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81117af4:	e0bffe17 	ldw	r2,-8(fp)
81117af8:	10002215 	stw	zero,136(r2)
}
81117afc:	0001883a 	nop
81117b00:	e037883a 	mov	sp,fp
81117b04:	df000017 	ldw	fp,0(sp)
81117b08:	dec00104 	addi	sp,sp,4
81117b0c:	f800283a 	ret

81117b10 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81117b10:	defffb04 	addi	sp,sp,-20
81117b14:	de00012e 	bgeu	sp,et,81117b1c <vNFeeStructureInit+0xc>
81117b18:	003b68fa 	trap	3
81117b1c:	dfc00415 	stw	ra,16(sp)
81117b20:	df000315 	stw	fp,12(sp)
81117b24:	df000304 	addi	fp,sp,12
81117b28:	e13ffe15 	stw	r4,-8(fp)
81117b2c:	2805883a 	mov	r2,r5
81117b30:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
81117b34:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
81117b38:	e0bffe17 	ldw	r2,-8(fp)
81117b3c:	e0ffff03 	ldbu	r3,-4(fp)
81117b40:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
81117b44:	e0bffe17 	ldw	r2,-8(fp)
81117b48:	10802c04 	addi	r2,r2,176
81117b4c:	1009883a 	mov	r4,r2
81117b50:	11139a00 	call	811139a0 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
81117b54:	e13ffe17 	ldw	r4,-8(fp)
81117b58:	1117c080 	call	81117c08 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
81117b5c:	e0bffe17 	ldw	r2,-8(fp)
81117b60:	00c00044 	movi	r3,1
81117b64:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81117b68:	e0bffe17 	ldw	r2,-8(fp)
81117b6c:	10002215 	stw	zero,136(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81117b70:	e0bffe17 	ldw	r2,-8(fp)
81117b74:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
81117b78:	e0bffe17 	ldw	r2,-8(fp)
81117b7c:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
81117b80:	e0bffe17 	ldw	r2,-8(fp)
81117b84:	10002715 	stw	zero,156(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
81117b88:	e0bffe17 	ldw	r2,-8(fp)
81117b8c:	10002915 	stw	zero,164(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
81117b90:	e0bffe17 	ldw	r2,-8(fp)
81117b94:	10002a15 	stw	zero,168(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81117b98:	e03ffd05 	stb	zero,-12(fp)
81117b9c:	00000906 	br	81117bc4 <vNFeeStructureInit+0xb4>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
81117ba0:	e0bffd03 	ldbu	r2,-12(fp)
81117ba4:	e0fffe17 	ldw	r3,-8(fp)
81117ba8:	1885883a 	add	r2,r3,r2
81117bac:	10802804 	addi	r2,r2,160
81117bb0:	e0fffd03 	ldbu	r3,-12(fp)
81117bb4:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81117bb8:	e0bffd03 	ldbu	r2,-12(fp)
81117bbc:	10800044 	addi	r2,r2,1
81117bc0:	e0bffd05 	stb	r2,-12(fp)
81117bc4:	e0bffd03 	ldbu	r2,-12(fp)
81117bc8:	10800130 	cmpltui	r2,r2,4
81117bcc:	103ff41e 	bne	r2,zero,81117ba0 <__reset+0xfb0f7ba0>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
81117bd0:	e0bffe17 	ldw	r2,-8(fp)
81117bd4:	10002b15 	stw	zero,172(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
81117bd8:	e0bffe17 	ldw	r2,-8(fp)
81117bdc:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bLogging = FALSE;
81117be0:	e0bffe17 	ldw	r2,-8(fp)
81117be4:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81117be8:	e0bffe17 	ldw	r2,-8(fp)
81117bec:	10002515 	stw	zero,148(r2)
		#endif
    }
	*/


}
81117bf0:	0001883a 	nop
81117bf4:	e037883a 	mov	sp,fp
81117bf8:	dfc00117 	ldw	ra,4(sp)
81117bfc:	df000017 	ldw	fp,0(sp)
81117c00:	dec00204 	addi	sp,sp,8
81117c04:	f800283a 	ret

81117c08 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
81117c08:	defff404 	addi	sp,sp,-48
81117c0c:	de00012e 	bgeu	sp,et,81117c14 <vUpdateMemMapFEE+0xc>
81117c10:	003b68fa 	trap	3
81117c14:	df000b15 	stw	fp,44(sp)
81117c18:	df000b04 	addi	fp,sp,44
81117c1c:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
81117c20:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
81117c24:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
81117c28:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
81117c2c:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
81117c30:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
81117c34:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
81117c38:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
81117c3c:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
81117c40:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
81117c44:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
81117c48:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
81117c4c:	e17fff17 	ldw	r5,-4(fp)
81117c50:	01035a34 	movhi	r4,3432
81117c54:	21348c04 	addi	r4,r4,-11728
81117c58:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
81117c5c:	e13fff17 	ldw	r4,-4(fp)
81117c60:	21000003 	ldbu	r4,0(r4)
81117c64:	21403fcc 	andi	r5,r4,255
81117c68:	01035a34 	movhi	r4,3432
81117c6c:	21348c04 	addi	r4,r4,-11728
81117c70:	2909383a 	mul	r4,r5,r4
81117c74:	200b883a 	mov	r5,r4
81117c78:	e13fff17 	ldw	r4,-4(fp)
81117c7c:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
81117c80:	e13fff17 	ldw	r4,-4(fp)
81117c84:	21400117 	ldw	r5,4(r4)
81117c88:	01033234 	movhi	r4,3272
81117c8c:	21348c04 	addi	r4,r4,-11728
81117c90:	290b883a 	add	r5,r5,r4
81117c94:	e13fff17 	ldw	r4,-4(fp)
81117c98:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81117c9c:	e13fff17 	ldw	r4,-4(fp)
81117ca0:	21002e0b 	ldhu	r4,184(r4)
81117ca4:	217fffcc 	andi	r5,r4,65535
81117ca8:	e13fff17 	ldw	r4,-4(fp)
81117cac:	21002d0b 	ldhu	r4,180(r4)
81117cb0:	213fffcc 	andi	r4,r4,65535
81117cb4:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
81117cb8:	e13fff17 	ldw	r4,-4(fp)
81117cbc:	21002d8b 	ldhu	r4,182(r4)
81117cc0:	21bfffcc 	andi	r6,r4,65535
81117cc4:	e13fff17 	ldw	r4,-4(fp)
81117cc8:	21002c8b 	ldhu	r4,178(r4)
81117ccc:	213fffcc 	andi	r4,r4,65535
81117cd0:	310d883a 	add	r6,r6,r4
81117cd4:	e13fff17 	ldw	r4,-4(fp)
81117cd8:	21002c0b 	ldhu	r4,176(r4)
81117cdc:	213fffcc 	andi	r4,r4,65535
81117ce0:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81117ce4:	2909383a 	mul	r4,r5,r4
81117ce8:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81117cec:	e13ffa17 	ldw	r4,-24(fp)
81117cf0:	2109883a 	add	r4,r4,r4
81117cf4:	200b883a 	mov	r5,r4
81117cf8:	e13fff17 	ldw	r4,-4(fp)
81117cfc:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81117d00:	e13fff17 	ldw	r4,-4(fp)
81117d04:	21000517 	ldw	r4,20(r4)
81117d08:	2008d0fa 	srli	r4,r4,3
81117d0c:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
81117d10:	e13fff17 	ldw	r4,-4(fp)
81117d14:	21000517 	ldw	r4,20(r4)
81117d18:	210001cc 	andi	r4,r4,7
81117d1c:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
81117d20:	e13ffb17 	ldw	r4,-20(fp)
81117d24:	20001226 	beq	r4,zero,81117d70 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
81117d28:	e13ff517 	ldw	r4,-44(fp)
81117d2c:	21000044 	addi	r4,r4,1
81117d30:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
81117d34:	e13fff17 	ldw	r4,-4(fp)
81117d38:	21400517 	ldw	r5,20(r4)
81117d3c:	e13ffb17 	ldw	r4,-20(fp)
81117d40:	2909c83a 	sub	r4,r5,r4
81117d44:	21400204 	addi	r5,r4,8
81117d48:	e13fff17 	ldw	r4,-4(fp)
81117d4c:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
81117d50:	e13ffb17 	ldw	r4,-20(fp)
81117d54:	200b883a 	mov	r5,r4
81117d58:	01000204 	movi	r4,8
81117d5c:	2149c83a 	sub	r4,r4,r5
81117d60:	200b883a 	mov	r5,r4
81117d64:	e13fff17 	ldw	r4,-4(fp)
81117d68:	21400605 	stb	r5,24(r4)
81117d6c:	00000206 	br	81117d78 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
81117d70:	e13fff17 	ldw	r4,-4(fp)
81117d74:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
81117d78:	e13ff517 	ldw	r4,-44(fp)
81117d7c:	2008d13a 	srli	r4,r4,4
81117d80:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
81117d84:	e13ff517 	ldw	r4,-44(fp)
81117d88:	210003cc 	andi	r4,r4,15
81117d8c:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
81117d90:	e13ffc17 	ldw	r4,-16(fp)
81117d94:	20000b26 	beq	r4,zero,81117dc4 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
81117d98:	e13ff717 	ldw	r4,-36(fp)
81117d9c:	21000044 	addi	r4,r4,1
81117da0:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81117da4:	e17ff517 	ldw	r5,-44(fp)
81117da8:	e13ffc17 	ldw	r4,-16(fp)
81117dac:	290bc83a 	sub	r5,r5,r4
81117db0:	e13ff717 	ldw	r4,-36(fp)
81117db4:	2909883a 	add	r4,r5,r4
81117db8:	21000404 	addi	r4,r4,16
81117dbc:	e13ff615 	stw	r4,-40(fp)
81117dc0:	00000406 	br	81117dd4 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81117dc4:	e17ff517 	ldw	r5,-44(fp)
81117dc8:	e13ff717 	ldw	r4,-36(fp)
81117dcc:	2909883a 	add	r4,r5,r4
81117dd0:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
81117dd4:	e13ff617 	ldw	r4,-40(fp)
81117dd8:	200a90fa 	slli	r5,r4,3
81117ddc:	e13fff17 	ldw	r4,-4(fp)
81117de0:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81117de4:	e13ffb17 	ldw	r4,-20(fp)
81117de8:	20000926 	beq	r4,zero,81117e10 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81117dec:	e13ffc17 	ldw	r4,-16(fp)
81117df0:	2109883a 	add	r4,r4,r4
81117df4:	2109883a 	add	r4,r4,r4
81117df8:	200b883a 	mov	r5,r4
81117dfc:	e13ffb17 	ldw	r4,-20(fp)
81117e00:	2008d07a 	srli	r4,r4,1
81117e04:	2909883a 	add	r4,r5,r4
81117e08:	e13ff805 	stb	r4,-32(fp)
81117e0c:	00000406 	br	81117e20 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
81117e10:	e13ffc17 	ldw	r4,-16(fp)
81117e14:	2109883a 	add	r4,r4,r4
81117e18:	2109883a 	add	r4,r4,r4
81117e1c:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
81117e20:	e13ff803 	ldbu	r4,-32(fp)
81117e24:	01401004 	movi	r5,64
81117e28:	2909c83a 	sub	r4,r5,r4
81117e2c:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
81117e30:	e13ffd03 	ldbu	r4,-12(fp)
81117e34:	217ff804 	addi	r5,r4,-32
81117e38:	28000416 	blt	r5,zero,81117e4c <vUpdateMemMapFEE+0x244>
81117e3c:	013fffc4 	movi	r4,-1
81117e40:	2144d83a 	srl	r2,r4,r5
81117e44:	0007883a 	mov	r3,zero
81117e48:	00000a06 	br	81117e74 <vUpdateMemMapFEE+0x26c>
81117e4c:	017fffc4 	movi	r5,-1
81117e50:	280c907a 	slli	r6,r5,1
81117e54:	014007c4 	movi	r5,31
81117e58:	290bc83a 	sub	r5,r5,r4
81117e5c:	314a983a 	sll	r5,r6,r5
81117e60:	01bfffc4 	movi	r6,-1
81117e64:	3104d83a 	srl	r2,r6,r4
81117e68:	2884b03a 	or	r2,r5,r2
81117e6c:	017fffc4 	movi	r5,-1
81117e70:	2906d83a 	srl	r3,r5,r4
81117e74:	e13fff17 	ldw	r4,-4(fp)
81117e78:	20800715 	stw	r2,28(r4)
81117e7c:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
81117e80:	e0bfff17 	ldw	r2,-4(fp)
81117e84:	e0fff717 	ldw	r3,-36(fp)
81117e88:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
81117e8c:	e0bfff17 	ldw	r2,-4(fp)
81117e90:	10c00117 	ldw	r3,4(r2)
81117e94:	008004b4 	movhi	r2,18
81117e98:	10a40004 	addi	r2,r2,-28672
81117e9c:	1885883a 	add	r2,r3,r2
81117ea0:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
81117ea4:	e0bfff17 	ldw	r2,-4(fp)
81117ea8:	10c00517 	ldw	r3,20(r2)
81117eac:	008000b4 	movhi	r2,2
81117eb0:	10a40004 	addi	r2,r2,-28672
81117eb4:	1885883a 	add	r2,r3,r2
81117eb8:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81117ebc:	e03ff845 	stb	zero,-31(fp)
81117ec0:	00001906 	br	81117f28 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
81117ec4:	e0bff843 	ldbu	r2,-31(fp)
81117ec8:	e0ffff17 	ldw	r3,-4(fp)
81117ecc:	10800624 	muli	r2,r2,24
81117ed0:	1885883a 	add	r2,r3,r2
81117ed4:	10800904 	addi	r2,r2,36
81117ed8:	e0fff917 	ldw	r3,-28(fp)
81117edc:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81117ee0:	e0fff917 	ldw	r3,-28(fp)
81117ee4:	e0bffe17 	ldw	r2,-8(fp)
81117ee8:	1885883a 	add	r2,r3,r2
81117eec:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81117ef0:	e0bff843 	ldbu	r2,-31(fp)
81117ef4:	e0ffff17 	ldw	r3,-4(fp)
81117ef8:	10800624 	muli	r2,r2,24
81117efc:	1885883a 	add	r2,r3,r2
81117f00:	10800c04 	addi	r2,r2,48
81117f04:	e0fff917 	ldw	r3,-28(fp)
81117f08:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81117f0c:	e0fff917 	ldw	r3,-28(fp)
81117f10:	e0bffe17 	ldw	r2,-8(fp)
81117f14:	1885883a 	add	r2,r3,r2
81117f18:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81117f1c:	e0bff843 	ldbu	r2,-31(fp)
81117f20:	10800044 	addi	r2,r2,1
81117f24:	e0bff845 	stb	r2,-31(fp)
81117f28:	e0bff843 	ldbu	r2,-31(fp)
81117f2c:	10800130 	cmpltui	r2,r2,4
81117f30:	103fe41e 	bne	r2,zero,81117ec4 <__reset+0xfb0f7ec4>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
81117f34:	0001883a 	nop
81117f38:	e037883a 	mov	sp,fp
81117f3c:	df000017 	ldw	fp,0(sp)
81117f40:	dec00104 	addi	sp,sp,4
81117f44:	f800283a 	ret

81117f48 <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
81117f48:	defffe04 	addi	sp,sp,-8
81117f4c:	de00012e 	bgeu	sp,et,81117f54 <vFeeSpwRMAPLoadDefault+0xc>
81117f50:	003b68fa 	trap	3
81117f54:	df000115 	stw	fp,4(sp)
81117f58:	df000104 	addi	fp,sp,4
81117f5c:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
81117f60:	0001883a 	nop
81117f64:	e037883a 	mov	sp,fp
81117f68:	df000017 	ldw	fp,0(sp)
81117f6c:	dec00104 	addi	sp,sp,4
81117f70:	f800283a 	ret

81117f74 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81117f74:	defffe04 	addi	sp,sp,-8
81117f78:	de00012e 	bgeu	sp,et,81117f80 <vFeeSpwRMAPChangeConfig+0xc>
81117f7c:	003b68fa 	trap	3
81117f80:	df000115 	stw	fp,4(sp)
81117f84:	df000104 	addi	fp,sp,4
81117f88:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81117f8c:	0001883a 	nop
81117f90:	e037883a 	mov	sp,fp
81117f94:	df000017 	ldw	fp,0(sp)
81117f98:	dec00104 	addi	sp,sp,4
81117f9c:	f800283a 	ret

81117fa0 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81117fa0:	defffe04 	addi	sp,sp,-8
81117fa4:	de00012e 	bgeu	sp,et,81117fac <vFeeSpwRMAPChangeDefault+0xc>
81117fa8:	003b68fa 	trap	3
81117fac:	df000115 	stw	fp,4(sp)
81117fb0:	df000104 	addi	fp,sp,4
81117fb4:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
81117fb8:	0001883a 	nop
81117fbc:	e037883a 	mov	sp,fp
81117fc0:	df000017 	ldw	fp,0(sp)
81117fc4:	dec00104 	addi	sp,sp,4
81117fc8:	f800283a 	ret

81117fcc <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81117fcc:	defffe04 	addi	sp,sp,-8
81117fd0:	de00012e 	bgeu	sp,et,81117fd8 <cFeeSpwChannelEnable+0xc>
81117fd4:	003b68fa 	trap	3
81117fd8:	df000115 	stw	fp,4(sp)
81117fdc:	df000104 	addi	fp,sp,4
81117fe0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81117fe4:	0001883a 	nop
81117fe8:	e037883a 	mov	sp,fp
81117fec:	df000017 	ldw	fp,0(sp)
81117ff0:	dec00104 	addi	sp,sp,4
81117ff4:	f800283a 	ret

81117ff8 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81117ff8:	defffe04 	addi	sp,sp,-8
81117ffc:	de00012e 	bgeu	sp,et,81118004 <cFeeSpwChannelDisable+0xc>
81118000:	003b68fa 	trap	3
81118004:	df000115 	stw	fp,4(sp)
81118008:	df000104 	addi	fp,sp,4
8111800c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81118010:	0001883a 	nop
81118014:	e037883a 	mov	sp,fp
81118018:	df000017 	ldw	fp,0(sp)
8111801c:	dec00104 	addi	sp,sp,4
81118020:	f800283a 	ret

81118024 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
81118024:	defffe04 	addi	sp,sp,-8
81118028:	de00012e 	bgeu	sp,et,81118030 <cFeeRMAPDump+0xc>
8111802c:	003b68fa 	trap	3
81118030:	df000115 	stw	fp,4(sp)
81118034:	df000104 	addi	fp,sp,4
81118038:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111803c:	0001883a 	nop
81118040:	e037883a 	mov	sp,fp
81118044:	df000017 	ldw	fp,0(sp)
81118048:	dec00104 	addi	sp,sp,4
8111804c:	f800283a 	ret

81118050 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
81118050:	defffe04 	addi	sp,sp,-8
81118054:	de00012e 	bgeu	sp,et,8111805c <cFeeRMAPEchoingEnable+0xc>
81118058:	003b68fa 	trap	3
8111805c:	df000115 	stw	fp,4(sp)
81118060:	df000104 	addi	fp,sp,4
81118064:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
81118068:	e0bfff17 	ldw	r2,-4(fp)
8111806c:	00c00044 	movi	r3,1
81118070:	10c02415 	stw	r3,144(r2)
}
81118074:	0001883a 	nop
81118078:	e037883a 	mov	sp,fp
8111807c:	df000017 	ldw	fp,0(sp)
81118080:	dec00104 	addi	sp,sp,4
81118084:	f800283a 	ret

81118088 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
81118088:	defffe04 	addi	sp,sp,-8
8111808c:	de00012e 	bgeu	sp,et,81118094 <cFeeRMAPEchoingDisable+0xc>
81118090:	003b68fa 	trap	3
81118094:	df000115 	stw	fp,4(sp)
81118098:	df000104 	addi	fp,sp,4
8111809c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
811180a0:	e0bfff17 	ldw	r2,-4(fp)
811180a4:	10002415 	stw	zero,144(r2)
}
811180a8:	0001883a 	nop
811180ac:	e037883a 	mov	sp,fp
811180b0:	df000017 	ldw	fp,0(sp)
811180b4:	dec00104 	addi	sp,sp,4
811180b8:	f800283a 	ret

811180bc <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
811180bc:	defffe04 	addi	sp,sp,-8
811180c0:	de00012e 	bgeu	sp,et,811180c8 <cFeeRMAPLogEnable+0xc>
811180c4:	003b68fa 	trap	3
811180c8:	df000115 	stw	fp,4(sp)
811180cc:	df000104 	addi	fp,sp,4
811180d0:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
811180d4:	e0bfff17 	ldw	r2,-4(fp)
811180d8:	00c00044 	movi	r3,1
811180dc:	10c02315 	stw	r3,140(r2)
}
811180e0:	0001883a 	nop
811180e4:	e037883a 	mov	sp,fp
811180e8:	df000017 	ldw	fp,0(sp)
811180ec:	dec00104 	addi	sp,sp,4
811180f0:	f800283a 	ret

811180f4 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
811180f4:	defffe04 	addi	sp,sp,-8
811180f8:	de00012e 	bgeu	sp,et,81118100 <cFeeRMAPLogDisable+0xc>
811180fc:	003b68fa 	trap	3
81118100:	df000115 	stw	fp,4(sp)
81118104:	df000104 	addi	fp,sp,4
81118108:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111810c:	e0bfff17 	ldw	r2,-4(fp)
81118110:	10002315 	stw	zero,140(r2)
}
81118114:	0001883a 	nop
81118118:	e037883a 	mov	sp,fp
8111811c:	df000017 	ldw	fp,0(sp)
81118120:	dec00104 	addi	sp,sp,4
81118124:	f800283a 	ret

81118128 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
81118128:	defffc04 	addi	sp,sp,-16
8111812c:	de00012e 	bgeu	sp,et,81118134 <vNFeeControlInit+0xc>
81118130:	003b68fa 	trap	3
81118134:	dfc00315 	stw	ra,12(sp)
81118138:	df000215 	stw	fp,8(sp)
8111813c:	df000204 	addi	fp,sp,8
81118140:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
81118144:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
81118148:	e13fff17 	ldw	r4,-4(fp)
8111814c:	11182540 	call	81118254 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
81118150:	e13fff17 	ldw	r4,-4(fp)
81118154:	11182880 	call	81118288 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebConfig;
81118158:	e0bfff17 	ldw	r2,-4(fp)
8111815c:	10009515 	stw	zero,596(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81118160:	e03ffe05 	stb	zero,-8(fp)
81118164:	00002306 	br	811181f4 <vNFeeControlInit+0xcc>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
81118168:	e0bffe03 	ldbu	r2,-8(fp)
8111816c:	10809224 	muli	r2,r2,584
81118170:	e0ffff17 	ldw	r3,-4(fp)
81118174:	1885883a 	add	r2,r3,r2
81118178:	e0fffe03 	ldbu	r3,-8(fp)
8111817c:	180b883a 	mov	r5,r3
81118180:	1009883a 	mov	r4,r2
81118184:	1117b100 	call	81117b10 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
81118188:	e0bffe03 	ldbu	r2,-8(fp)
8111818c:	e0fffe03 	ldbu	r3,-8(fp)
81118190:	18c09224 	muli	r3,r3,584
81118194:	18c02104 	addi	r3,r3,132
81118198:	e13fff17 	ldw	r4,-4(fp)
8111819c:	20c7883a 	add	r3,r4,r3
811181a0:	e13fff17 	ldw	r4,-4(fp)
811181a4:	10802484 	addi	r2,r2,146
811181a8:	1085883a 	add	r2,r2,r2
811181ac:	1085883a 	add	r2,r2,r2
811181b0:	2085883a 	add	r2,r4,r2
811181b4:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
811181b8:	e0bffe03 	ldbu	r2,-8(fp)
811181bc:	e0fffe03 	ldbu	r3,-8(fp)
811181c0:	18c09224 	muli	r3,r3,584
811181c4:	18c02604 	addi	r3,r3,152
811181c8:	e13fff17 	ldw	r4,-4(fp)
811181cc:	20c7883a 	add	r3,r4,r3
811181d0:	e13fff17 	ldw	r4,-4(fp)
811181d4:	108024c4 	addi	r2,r2,147
811181d8:	1085883a 	add	r2,r2,r2
811181dc:	1085883a 	add	r2,r2,r2
811181e0:	2085883a 	add	r2,r4,r2
811181e4:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebConfig;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
811181e8:	e0bffe03 	ldbu	r2,-8(fp)
811181ec:	10800044 	addi	r2,r2,1
811181f0:	e0bffe05 	stb	r2,-8(fp)
811181f4:	e0bffe03 	ldbu	r2,-8(fp)
811181f8:	103fdb26 	beq	r2,zero,81118168 <__reset+0xfb0f8168>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
    }

}
811181fc:	0001883a 	nop
81118200:	e037883a 	mov	sp,fp
81118204:	dfc00117 	ldw	ra,4(sp)
81118208:	df000017 	ldw	fp,0(sp)
8111820c:	dec00204 	addi	sp,sp,8
81118210:	f800283a 	ret

81118214 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
81118214:	defffd04 	addi	sp,sp,-12
81118218:	de00012e 	bgeu	sp,et,81118220 <vSetTimeCode+0xc>
8111821c:	003b68fa 	trap	3
81118220:	df000215 	stw	fp,8(sp)
81118224:	df000204 	addi	fp,sp,8
81118228:	e13ffe15 	stw	r4,-8(fp)
8111822c:	2805883a 	mov	r2,r5
81118230:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
81118234:	e0bffe17 	ldw	r2,-8(fp)
81118238:	e0ffff03 	ldbu	r3,-4(fp)
8111823c:	10c09405 	stb	r3,592(r2)
}
81118240:	0001883a 	nop
81118244:	e037883a 	mov	sp,fp
81118248:	df000017 	ldw	fp,0(sp)
8111824c:	dec00104 	addi	sp,sp,4
81118250:	f800283a 	ret

81118254 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
81118254:	defffe04 	addi	sp,sp,-8
81118258:	de00012e 	bgeu	sp,et,81118260 <vResetTimeCode+0xc>
8111825c:	003b68fa 	trap	3
81118260:	df000115 	stw	fp,4(sp)
81118264:	df000104 	addi	fp,sp,4
81118268:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111826c:	e0bfff17 	ldw	r2,-4(fp)
81118270:	10009405 	stb	zero,592(r2)
}
81118274:	0001883a 	nop
81118278:	e037883a 	mov	sp,fp
8111827c:	df000017 	ldw	fp,0(sp)
81118280:	dec00104 	addi	sp,sp,4
81118284:	f800283a 	ret

81118288 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
81118288:	defffe04 	addi	sp,sp,-8
8111828c:	de00012e 	bgeu	sp,et,81118294 <vLoadDefaultIdNFEEMaster+0xc>
81118290:	003b68fa 	trap	3
81118294:	df000115 	stw	fp,4(sp)
81118298:	df000104 	addi	fp,sp,4
8111829c:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
811182a0:	e0bfff17 	ldw	r2,-4(fp)
811182a4:	10009445 	stb	zero,593(r2)
}
811182a8:	0001883a 	nop
811182ac:	e037883a 	mov	sp,fp
811182b0:	df000017 	ldw	fp,0(sp)
811182b4:	dec00104 	addi	sp,sp,4
811182b8:	f800283a 	ret

811182bc <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
811182bc:	defffd04 	addi	sp,sp,-12
811182c0:	de00012e 	bgeu	sp,et,811182c8 <vChangeIdNFEEMaster+0xc>
811182c4:	003b68fa 	trap	3
811182c8:	df000215 	stw	fp,8(sp)
811182cc:	df000204 	addi	fp,sp,8
811182d0:	e13ffe15 	stw	r4,-8(fp)
811182d4:	2805883a 	mov	r2,r5
811182d8:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
811182dc:	e0bffe17 	ldw	r2,-8(fp)
811182e0:	e0ffff03 	ldbu	r3,-4(fp)
811182e4:	10c09445 	stb	r3,593(r2)
}
811182e8:	0001883a 	nop
811182ec:	e037883a 	mov	sp,fp
811182f0:	df000017 	ldw	fp,0(sp)
811182f4:	dec00104 	addi	sp,sp,4
811182f8:	f800283a 	ret

811182fc <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
811182fc:	defffd04 	addi	sp,sp,-12
81118300:	de00012e 	bgeu	sp,et,81118308 <vChangeDefaultIdNFEEMaster+0xc>
81118304:	003b68fa 	trap	3
81118308:	df000215 	stw	fp,8(sp)
8111830c:	df000204 	addi	fp,sp,8
81118310:	e13ffe15 	stw	r4,-8(fp)
81118314:	2805883a 	mov	r2,r5
81118318:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111831c:	0001883a 	nop
81118320:	e037883a 	mov	sp,fp
81118324:	df000017 	ldw	fp,0(sp)
81118328:	dec00104 	addi	sp,sp,4
8111832c:	f800283a 	ret

81118330 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
81118330:	defffe04 	addi	sp,sp,-8
81118334:	de00012e 	bgeu	sp,et,8111833c <vInitSimucamBasicHW+0xc>
81118338:	003b68fa 	trap	3
8111833c:	dfc00115 	stw	ra,4(sp)
81118340:	df000015 	stw	fp,0(sp)
81118344:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81118348:	01403fc4 	movi	r5,255
8111834c:	0009883a 	mov	r4,zero
81118350:	1109e900 	call	81109e90 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81118354:	01400834 	movhi	r5,32
81118358:	297fffc4 	addi	r5,r5,-1
8111835c:	0009883a 	mov	r4,zero
81118360:	1109f100 	call	81109f10 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81118364:	01400074 	movhi	r5,1
81118368:	01000044 	movi	r4,1
8111836c:	1109f100 	call	81109f10 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
81118370:	0009883a 	mov	r4,zero
81118374:	110b4ec0 	call	8110b4ec <bSSDisplayConfig>
	bSSDisplayUpdate(0);
81118378:	0009883a 	mov	r4,zero
8111837c:	110b5bc0 	call	8110b5bc <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81118380:	01008004 	movi	r4,512
81118384:	110b04c0 	call	8110b04c <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81118388:	01008004 	movi	r4,512
8111838c:	110afd80 	call	8110afd8 <vRstcReleaseDeviceReset>

}
81118390:	0001883a 	nop
81118394:	e037883a 	mov	sp,fp
81118398:	dfc00117 	ldw	ra,4(sp)
8111839c:	df000017 	ldw	fp,0(sp)
811183a0:	dec00204 	addi	sp,sp,8
811183a4:	f800283a 	ret

811183a8 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
811183a8:	defffd04 	addi	sp,sp,-12
811183ac:	de00012e 	bgeu	sp,et,811183b4 <bLogWriteSDCard+0xc>
811183b0:	003b68fa 	trap	3
811183b4:	df000215 	stw	fp,8(sp)
811183b8:	df000204 	addi	fp,sp,8
811183bc:	e13ffe15 	stw	r4,-8(fp)
811183c0:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
811183c4:	00800044 	movi	r2,1
}
811183c8:	e037883a 	mov	sp,fp
811183cc:	df000017 	ldw	fp,0(sp)
811183d0:	dec00104 	addi	sp,sp,4
811183d4:	f800283a 	ret

811183d8 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
811183d8:	deffe004 	addi	sp,sp,-128
811183dc:	de00012e 	bgeu	sp,et,811183e4 <vLogWriteNUC+0xc>
811183e0:	003b68fa 	trap	3
811183e4:	dfc01f15 	stw	ra,124(sp)
811183e8:	df001e15 	stw	fp,120(sp)
811183ec:	df001e04 	addi	fp,sp,120
811183f0:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
811183f4:	e03fe215 	stw	zero,-120(fp)
811183f8:	e0bfe304 	addi	r2,fp,-116
811183fc:	00c01b84 	movi	r3,110
81118400:	180d883a 	mov	r6,r3
81118404:	000b883a 	mov	r5,zero
81118408:	1009883a 	mov	r4,r2
8111840c:	111bb600 	call	8111bb60 <memset>
	memset(cTemp,0,114);
81118410:	01801c84 	movi	r6,114
81118414:	000b883a 	mov	r5,zero
81118418:	e13fe204 	addi	r4,fp,-120
8111841c:	111bb600 	call	8111bb60 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81118420:	e13fff17 	ldw	r4,-4(fp)
81118424:	111c5040 	call	8111c504 <strlen>
81118428:	10801c68 	cmpgeui	r2,r2,113
8111842c:	1000031e 	bne	r2,zero,8111843c <vLogWriteNUC+0x64>
81118430:	e13fff17 	ldw	r4,-4(fp)
81118434:	111c5040 	call	8111c504 <strlen>
81118438:	00000106 	br	81118440 <vLogWriteNUC+0x68>
8111843c:	00801c44 	movi	r2,113
81118440:	100d883a 	mov	r6,r2
81118444:	e17fff17 	ldw	r5,-4(fp)
81118448:	e13fe204 	addi	r4,fp,-120
8111844c:	111ba100 	call	8111ba10 <memcpy>
	vSendLog ( cDataIn );
81118450:	e13fff17 	ldw	r4,-4(fp)
81118454:	11148380 	call	81114838 <vSendLog>
}
81118458:	0001883a 	nop
8111845c:	e037883a 	mov	sp,fp
81118460:	dfc00117 	ldw	ra,4(sp)
81118464:	df000017 	ldw	fp,0(sp)
81118468:	dec00204 	addi	sp,sp,8
8111846c:	f800283a 	ret

81118470 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
81118470:	defffd04 	addi	sp,sp,-12
81118474:	de00012e 	bgeu	sp,et,8111847c <vSimucamStructureInit+0xc>
81118478:	003b68fa 	trap	3
8111847c:	dfc00215 	stw	ra,8(sp)
81118480:	df000115 	stw	fp,4(sp)
81118484:	df000104 	addi	fp,sp,4
81118488:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111848c:	e0bfff17 	ldw	r2,-4(fp)
81118490:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebConfig;
81118494:	e0bfff17 	ldw	r2,-4(fp)
81118498:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111849c:	e13fff17 	ldw	r4,-4(fp)
811184a0:	11185240 	call	81118524 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
811184a4:	e13fff17 	ldw	r4,-4(fp)
811184a8:	11185c80 	call	811185c8 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
811184ac:	e13fff17 	ldw	r4,-4(fp)
811184b0:	11186700 	call	81118670 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
811184b4:	e13fff17 	ldw	r4,-4(fp)
811184b8:	11187100 	call	81118710 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
811184bc:	e0bfff17 	ldw	r2,-4(fp)
811184c0:	10000515 	stw	zero,20(r2)
    xMeb->fPixelTransferTime = 0;
811184c4:	e0bfff17 	ldw	r2,-4(fp)
811184c8:	10000615 	stw	zero,24(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
811184cc:	e0bfff17 	ldw	r2,-4(fp)
811184d0:	10800017 	ldw	r2,0(r2)
811184d4:	10000b1e 	bne	r2,zero,81118504 <vSimucamStructureInit+0x94>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
811184d8:	e0bfff17 	ldw	r2,-4(fp)
811184dc:	10800f04 	addi	r2,r2,60
811184e0:	1009883a 	mov	r4,r2
811184e4:	11181280 	call	81118128 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
811184e8:	e0bfff17 	ldw	r2,-4(fp)
811184ec:	10c00904 	addi	r3,r2,36
811184f0:	e0bfff17 	ldw	r2,-4(fp)
811184f4:	10800f04 	addi	r2,r2,60
811184f8:	100b883a 	mov	r5,r2
811184fc:	1809883a 	mov	r4,r3
81118500:	1115c040 	call	81115c04 <vDataControllerInit>
        /* todo: Not in use yet */
    }


    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
81118504:	e0bfff17 	ldw	r2,-4(fp)
81118508:	10000205 	stb	zero,8(r2)

    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111850c:	0001883a 	nop
81118510:	e037883a 	mov	sp,fp
81118514:	dfc00117 	ldw	ra,4(sp)
81118518:	df000017 	ldw	fp,0(sp)
8111851c:	dec00204 	addi	sp,sp,8
81118520:	f800283a 	ret

81118524 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81118524:	defffe04 	addi	sp,sp,-8
81118528:	de00012e 	bgeu	sp,et,81118530 <vLoadDefaultEPValue+0xc>
8111852c:	003b68fa 	trap	3
81118530:	df000115 	stw	fp,4(sp)
81118534:	df000104 	addi	fp,sp,4
81118538:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111853c:	e0bfff17 	ldw	r2,-4(fp)
81118540:	00d07234 	movhi	r3,16840
81118544:	10c00315 	stw	r3,12(r2)
}
81118548:	0001883a 	nop
8111854c:	e037883a 	mov	sp,fp
81118550:	df000017 	ldw	fp,0(sp)
81118554:	dec00104 	addi	sp,sp,4
81118558:	f800283a 	ret

8111855c <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111855c:	defffd04 	addi	sp,sp,-12
81118560:	de00012e 	bgeu	sp,et,81118568 <vChangeEPValue+0xc>
81118564:	003b68fa 	trap	3
81118568:	df000215 	stw	fp,8(sp)
8111856c:	df000204 	addi	fp,sp,8
81118570:	e13ffe15 	stw	r4,-8(fp)
81118574:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
81118578:	e0bffe17 	ldw	r2,-8(fp)
8111857c:	e0ffff17 	ldw	r3,-4(fp)
81118580:	10c00315 	stw	r3,12(r2)
}
81118584:	0001883a 	nop
81118588:	e037883a 	mov	sp,fp
8111858c:	df000017 	ldw	fp,0(sp)
81118590:	dec00104 	addi	sp,sp,4
81118594:	f800283a 	ret

81118598 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81118598:	defffd04 	addi	sp,sp,-12
8111859c:	de00012e 	bgeu	sp,et,811185a4 <vChangeDefaultEPValue+0xc>
811185a0:	003b68fa 	trap	3
811185a4:	df000215 	stw	fp,8(sp)
811185a8:	df000204 	addi	fp,sp,8
811185ac:	e13ffe15 	stw	r4,-8(fp)
811185b0:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
811185b4:	0001883a 	nop
811185b8:	e037883a 	mov	sp,fp
811185bc:	df000017 	ldw	fp,0(sp)
811185c0:	dec00104 	addi	sp,sp,4
811185c4:	f800283a 	ret

811185c8 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
811185c8:	defffe04 	addi	sp,sp,-8
811185cc:	de00012e 	bgeu	sp,et,811185d4 <vLoadDefaultRTValue+0xc>
811185d0:	003b68fa 	trap	3
811185d4:	df000115 	stw	fp,4(sp)
811185d8:	df000104 	addi	fp,sp,4
811185dc:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
811185e0:	e0ffff17 	ldw	r3,-4(fp)
811185e4:	00901eb4 	movhi	r2,16506
811185e8:	10a66684 	addi	r2,r2,-26214
811185ec:	18800415 	stw	r2,16(r3)
}
811185f0:	0001883a 	nop
811185f4:	e037883a 	mov	sp,fp
811185f8:	df000017 	ldw	fp,0(sp)
811185fc:	dec00104 	addi	sp,sp,4
81118600:	f800283a 	ret

81118604 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81118604:	defffd04 	addi	sp,sp,-12
81118608:	de00012e 	bgeu	sp,et,81118610 <vChangeRTValue+0xc>
8111860c:	003b68fa 	trap	3
81118610:	df000215 	stw	fp,8(sp)
81118614:	df000204 	addi	fp,sp,8
81118618:	e13ffe15 	stw	r4,-8(fp)
8111861c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
81118620:	e0bffe17 	ldw	r2,-8(fp)
81118624:	e0ffff17 	ldw	r3,-4(fp)
81118628:	10c00415 	stw	r3,16(r2)
}
8111862c:	0001883a 	nop
81118630:	e037883a 	mov	sp,fp
81118634:	df000017 	ldw	fp,0(sp)
81118638:	dec00104 	addi	sp,sp,4
8111863c:	f800283a 	ret

81118640 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81118640:	defffd04 	addi	sp,sp,-12
81118644:	de00012e 	bgeu	sp,et,8111864c <vChangeDefaultRTValue+0xc>
81118648:	003b68fa 	trap	3
8111864c:	df000215 	stw	fp,8(sp)
81118650:	df000204 	addi	fp,sp,8
81118654:	e13ffe15 	stw	r4,-8(fp)
81118658:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111865c:	0001883a 	nop
81118660:	e037883a 	mov	sp,fp
81118664:	df000017 	ldw	fp,0(sp)
81118668:	dec00104 	addi	sp,sp,4
8111866c:	f800283a 	ret

81118670 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
81118670:	defffe04 	addi	sp,sp,-8
81118674:	de00012e 	bgeu	sp,et,8111867c <vLoadDefaultSyncSource+0xc>
81118678:	003b68fa 	trap	3
8111867c:	df000115 	stw	fp,4(sp)
81118680:	df000104 	addi	fp,sp,4
81118684:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
81118688:	e0bfff17 	ldw	r2,-4(fp)
8111868c:	10000715 	stw	zero,28(r2)
}
81118690:	0001883a 	nop
81118694:	e037883a 	mov	sp,fp
81118698:	df000017 	ldw	fp,0(sp)
8111869c:	dec00104 	addi	sp,sp,4
811186a0:	f800283a 	ret

811186a4 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811186a4:	defffd04 	addi	sp,sp,-12
811186a8:	de00012e 	bgeu	sp,et,811186b0 <vChangeSyncSource+0xc>
811186ac:	003b68fa 	trap	3
811186b0:	df000215 	stw	fp,8(sp)
811186b4:	df000204 	addi	fp,sp,8
811186b8:	e13ffe15 	stw	r4,-8(fp)
811186bc:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
811186c0:	e0bffe17 	ldw	r2,-8(fp)
811186c4:	e0ffff17 	ldw	r3,-4(fp)
811186c8:	10c00715 	stw	r3,28(r2)
}
811186cc:	0001883a 	nop
811186d0:	e037883a 	mov	sp,fp
811186d4:	df000017 	ldw	fp,0(sp)
811186d8:	dec00104 	addi	sp,sp,4
811186dc:	f800283a 	ret

811186e0 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
811186e0:	defffd04 	addi	sp,sp,-12
811186e4:	de00012e 	bgeu	sp,et,811186ec <vChangeDefaultSyncSource+0xc>
811186e8:	003b68fa 	trap	3
811186ec:	df000215 	stw	fp,8(sp)
811186f0:	df000204 	addi	fp,sp,8
811186f4:	e13ffe15 	stw	r4,-8(fp)
811186f8:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
811186fc:	0001883a 	nop
81118700:	e037883a 	mov	sp,fp
81118704:	df000017 	ldw	fp,0(sp)
81118708:	dec00104 	addi	sp,sp,4
8111870c:	f800283a 	ret

81118710 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
81118710:	defffe04 	addi	sp,sp,-8
81118714:	de00012e 	bgeu	sp,et,8111871c <vLoadDefaultAutoResetSync+0xc>
81118718:	003b68fa 	trap	3
8111871c:	df000115 	stw	fp,4(sp)
81118720:	df000104 	addi	fp,sp,4
81118724:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoRestSyncMode = TRUE;
81118728:	e0bfff17 	ldw	r2,-4(fp)
8111872c:	00c00044 	movi	r3,1
81118730:	10c00815 	stw	r3,32(r2)
}
81118734:	0001883a 	nop
81118738:	e037883a 	mov	sp,fp
8111873c:	df000017 	ldw	fp,0(sp)
81118740:	dec00104 	addi	sp,sp,4
81118744:	f800283a 	ret

81118748 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81118748:	defffd04 	addi	sp,sp,-12
8111874c:	de00012e 	bgeu	sp,et,81118754 <vChangeAutoResetSync+0xc>
81118750:	003b68fa 	trap	3
81118754:	df000215 	stw	fp,8(sp)
81118758:	df000204 	addi	fp,sp,8
8111875c:	e13ffe15 	stw	r4,-8(fp)
81118760:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoRestSyncMode = bAutoReset;
81118764:	e0bffe17 	ldw	r2,-8(fp)
81118768:	e0ffff17 	ldw	r3,-4(fp)
8111876c:	10c00815 	stw	r3,32(r2)
}
81118770:	0001883a 	nop
81118774:	e037883a 	mov	sp,fp
81118778:	df000017 	ldw	fp,0(sp)
8111877c:	dec00104 	addi	sp,sp,4
81118780:	f800283a 	ret

81118784 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
81118784:	defffd04 	addi	sp,sp,-12
81118788:	de00012e 	bgeu	sp,et,81118790 <vChangeDefaultAutoResetSync+0xc>
8111878c:	003b68fa 	trap	3
81118790:	df000215 	stw	fp,8(sp)
81118794:	df000204 	addi	fp,sp,8
81118798:	e13ffe15 	stw	r4,-8(fp)
8111879c:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
811187a0:	0001883a 	nop
811187a4:	e037883a 	mov	sp,fp
811187a8:	df000017 	ldw	fp,0(sp)
811187ac:	dec00104 	addi	sp,sp,4
811187b0:	f800283a 	ret

811187b4 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
811187b4:	defffc04 	addi	sp,sp,-16
811187b8:	de00012e 	bgeu	sp,et,811187c0 <vSyncReset+0xc>
811187bc:	003b68fa 	trap	3
811187c0:	dfc00315 	stw	ra,12(sp)
811187c4:	df000215 	stw	fp,8(sp)
811187c8:	df000204 	addi	fp,sp,8
811187cc:	e13ffe15 	stw	r4,-8(fp)
811187d0:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
811187d4:	e0bffe17 	ldw	r2,-8(fp)
811187d8:	10800f04 	addi	r2,r2,60
811187dc:	1009883a 	mov	r4,r2
811187e0:	11182540 	call	81118254 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
811187e4:	0001883a 	nop
811187e8:	e037883a 	mov	sp,fp
811187ec:	dfc00117 	ldw	ra,4(sp)
811187f0:	df000017 	ldw	fp,0(sp)
811187f4:	dec00204 	addi	sp,sp,8
811187f8:	f800283a 	ret

811187fc <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
811187fc:	defff004 	addi	sp,sp,-64
81118800:	de00012e 	bgeu	sp,et,81118808 <pattern_createPattern+0xc>
81118804:	003b68fa 	trap	3
81118808:	dfc00f15 	stw	ra,60(sp)
8111880c:	df000e15 	stw	fp,56(sp)
81118810:	dcc00d15 	stw	r19,52(sp)
81118814:	dc800c15 	stw	r18,48(sp)
81118818:	dc400b15 	stw	r17,44(sp)
8111881c:	dc000a15 	stw	r16,40(sp)
81118820:	df000e04 	addi	fp,sp,56
81118824:	e17ff915 	stw	r5,-28(fp)
81118828:	3007883a 	mov	r3,r6
8111882c:	3805883a 	mov	r2,r7
81118830:	e13ff805 	stb	r4,-32(fp)
81118834:	e0fffa05 	stb	r3,-24(fp)
81118838:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111883c:	e0bff803 	ldbu	r2,-32(fp)
81118840:	1009883a 	mov	r4,r2
81118844:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
81118848:	e0bff917 	ldw	r2,-28(fp)
8111884c:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
81118850:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
81118854:	e0bff217 	ldw	r2,-56(fp)
81118858:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111885c:	e03ff515 	stw	zero,-44(fp)
81118860:	00003606 	br	8111893c <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81118864:	e03ff615 	stw	zero,-40(fp)
81118868:	00002e06 	br	81118924 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111886c:	e0bff303 	ldbu	r2,-52(fp)
81118870:	10801018 	cmpnei	r2,r2,64
81118874:	10000b1e 	bne	r2,zero,811188a4 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
81118878:	e0bff417 	ldw	r2,-48(fp)
8111887c:	00ffffc4 	movi	r3,-1
81118880:	10c02015 	stw	r3,128(r2)
81118884:	00ffffc4 	movi	r3,-1
81118888:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111888c:	e0bff217 	ldw	r2,-56(fp)
81118890:	10802204 	addi	r2,r2,136
81118894:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
81118898:	e0bff217 	ldw	r2,-56(fp)
8111889c:	e0bff415 	stw	r2,-48(fp)
				i = 0;
811188a0:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
811188a4:	e0bff303 	ldbu	r2,-52(fp)
811188a8:	10c00044 	addi	r3,r2,1
811188ac:	e0fff305 	stb	r3,-52(fp)
811188b0:	10803fcc 	andi	r2,r2,255
811188b4:	e0fffa03 	ldbu	r3,-24(fp)
811188b8:	18c000cc 	andi	r3,r3,3
811188bc:	180692fa 	slli	r3,r3,11
811188c0:	1809883a 	mov	r4,r3
811188c4:	00f80004 	movi	r3,-8192
811188c8:	20c6b03a 	or	r3,r4,r3
811188cc:	1809883a 	mov	r4,r3
811188d0:	e0fffb03 	ldbu	r3,-20(fp)
811188d4:	18c0004c 	andi	r3,r3,1
811188d8:	180692ba 	slli	r3,r3,10
811188dc:	20c6b03a 	or	r3,r4,r3
811188e0:	1809883a 	mov	r4,r3
811188e4:	e0fff517 	ldw	r3,-44(fp)
811188e8:	18c007cc 	andi	r3,r3,31
811188ec:	1806917a 	slli	r3,r3,5
811188f0:	20c6b03a 	or	r3,r4,r3
811188f4:	1809883a 	mov	r4,r3
811188f8:	e0fff617 	ldw	r3,-40(fp)
811188fc:	18c007cc 	andi	r3,r3,31
81118900:	20c6b03a 	or	r3,r4,r3
81118904:	1809883a 	mov	r4,r3
81118908:	e0fff417 	ldw	r3,-48(fp)
8111890c:	1085883a 	add	r2,r2,r2
81118910:	1885883a 	add	r2,r3,r2
81118914:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81118918:	e0bff617 	ldw	r2,-40(fp)
8111891c:	10800044 	addi	r2,r2,1
81118920:	e0bff615 	stw	r2,-40(fp)
81118924:	e0fff617 	ldw	r3,-40(fp)
81118928:	e0800217 	ldw	r2,8(fp)
8111892c:	18bfcf36 	bltu	r3,r2,8111886c <__reset+0xfb0f886c>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
81118930:	e0bff517 	ldw	r2,-44(fp)
81118934:	10800044 	addi	r2,r2,1
81118938:	e0bff515 	stw	r2,-44(fp)
8111893c:	e0fff517 	ldw	r3,-44(fp)
81118940:	e0800317 	ldw	r2,12(fp)
81118944:	18bfc736 	bltu	r3,r2,81118864 <__reset+0xfb0f8864>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81118948:	e0bff303 	ldbu	r2,-52(fp)
8111894c:	e0bff705 	stb	r2,-36(fp)
81118950:	00000806 	br	81118974 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
81118954:	e0bff703 	ldbu	r2,-36(fp)
81118958:	e0fff417 	ldw	r3,-48(fp)
8111895c:	1085883a 	add	r2,r2,r2
81118960:	1885883a 	add	r2,r3,r2
81118964:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
81118968:	e0bff703 	ldbu	r2,-36(fp)
8111896c:	10800044 	addi	r2,r2,1
81118970:	e0bff705 	stb	r2,-36(fp)
81118974:	e0bff703 	ldbu	r2,-36(fp)
81118978:	10801030 	cmpltui	r2,r2,64
8111897c:	103ff51e 	bne	r2,zero,81118954 <__reset+0xfb0f8954>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
81118980:	e0bff417 	ldw	r2,-48(fp)
81118984:	10002015 	stw	zero,128(r2)
81118988:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111898c:	e03ff745 	stb	zero,-35(fp)
81118990:	00001106 	br	811189d8 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
81118994:	e13ff417 	ldw	r4,-48(fp)
81118998:	20802017 	ldw	r2,128(r4)
8111899c:	20c02117 	ldw	r3,132(r4)
811189a0:	e13ff743 	ldbu	r4,-35(fp)
811189a4:	01400044 	movi	r5,1
811189a8:	2908983a 	sll	r4,r5,r4
811189ac:	2025883a 	mov	r18,r4
811189b0:	2009d7fa 	srai	r4,r4,31
811189b4:	2027883a 	mov	r19,r4
811189b8:	14a0b03a 	or	r16,r2,r18
811189bc:	1ce2b03a 	or	r17,r3,r19
811189c0:	e0bff417 	ldw	r2,-48(fp)
811189c4:	14002015 	stw	r16,128(r2)
811189c8:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
811189cc:	e0bff743 	ldbu	r2,-35(fp)
811189d0:	10800044 	addi	r2,r2,1
811189d4:	e0bff745 	stb	r2,-35(fp)
811189d8:	e0fff743 	ldbu	r3,-35(fp)
811189dc:	e0bff303 	ldbu	r2,-52(fp)
811189e0:	18bfec36 	bltu	r3,r2,81118994 <__reset+0xfb0f8994>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
811189e4:	e0bff217 	ldw	r2,-56(fp)
811189e8:	10802204 	addi	r2,r2,136
811189ec:	e0bff215 	stw	r2,-56(fp)
	return offset;
811189f0:	e0bff217 	ldw	r2,-56(fp)
}
811189f4:	e6fffc04 	addi	sp,fp,-16
811189f8:	dfc00517 	ldw	ra,20(sp)
811189fc:	df000417 	ldw	fp,16(sp)
81118a00:	dcc00317 	ldw	r19,12(sp)
81118a04:	dc800217 	ldw	r18,8(sp)
81118a08:	dc400117 	ldw	r17,4(sp)
81118a0c:	dc000017 	ldw	r16,0(sp)
81118a10:	dec00604 	addi	sp,sp,24
81118a14:	f800283a 	ret

81118a18 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81118a18:	defffe04 	addi	sp,sp,-8
81118a1c:	de00012e 	bgeu	sp,et,81118a24 <bSDcardIsPresent+0xc>
81118a20:	003b68fa 	trap	3
81118a24:	dfc00115 	stw	ra,4(sp)
81118a28:	df000015 	stw	fp,0(sp)
81118a2c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81118a30:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
}
81118a34:	e037883a 	mov	sp,fp
81118a38:	dfc00117 	ldw	ra,4(sp)
81118a3c:	df000017 	ldw	fp,0(sp)
81118a40:	dec00204 	addi	sp,sp,8
81118a44:	f800283a 	ret

81118a48 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
81118a48:	defffe04 	addi	sp,sp,-8
81118a4c:	de00012e 	bgeu	sp,et,81118a54 <bSDcardFAT16Check+0xc>
81118a50:	003b68fa 	trap	3
81118a54:	dfc00115 	stw	ra,4(sp)
81118a58:	df000015 	stw	fp,0(sp)
81118a5c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
81118a60:	113ed940 	call	8113ed94 <alt_up_sd_card_is_FAT16>
}
81118a64:	e037883a 	mov	sp,fp
81118a68:	dfc00117 	ldw	ra,4(sp)
81118a6c:	df000017 	ldw	fp,0(sp)
81118a70:	dec00204 	addi	sp,sp,8
81118a74:	f800283a 	ret

81118a78 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
81118a78:	defffd04 	addi	sp,sp,-12
81118a7c:	de00012e 	bgeu	sp,et,81118a84 <bInitializeSDCard+0xc>
81118a80:	003b68fa 	trap	3
81118a84:	dfc00215 	stw	ra,8(sp)
81118a88:	df000115 	stw	fp,4(sp)
81118a8c:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
81118a90:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
81118a94:	d0207c15 	stw	zero,-32272(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
81118a98:	01204574 	movhi	r4,33045
81118a9c:	21257504 	addi	r4,r4,-27180
81118aa0:	113ec040 	call	8113ec04 <alt_up_sd_card_open_dev>
81118aa4:	d0a07c15 	stw	r2,-32272(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81118aa8:	d0a07c17 	ldw	r2,-32272(gp)
81118aac:	10002226 	beq	r2,zero,81118b38 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
81118ab0:	1118a180 	call	81118a18 <bSDcardIsPresent>
81118ab4:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81118ab8:	e0bfff17 	ldw	r2,-4(fp)
81118abc:	10001626 	beq	r2,zero,81118b18 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
81118ac0:	1118a480 	call	81118a48 <bSDcardFAT16Check>
81118ac4:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81118ac8:	e0bfff17 	ldw	r2,-4(fp)
81118acc:	10000a26 	beq	r2,zero,81118af8 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
81118ad0:	00800044 	movi	r2,1
81118ad4:	d0a07b15 	stw	r2,-32276(gp)
				debug(fp, "SD is up.\r\n");
81118ad8:	d0a05f17 	ldw	r2,-32388(gp)
81118adc:	100f883a 	mov	r7,r2
81118ae0:	018002c4 	movi	r6,11
81118ae4:	01400044 	movi	r5,1
81118ae8:	01204574 	movhi	r4,33045
81118aec:	21258004 	addi	r4,r4,-27136
81118af0:	111affc0 	call	8111affc <fwrite>
81118af4:	00001806 	br	81118b58 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
81118af8:	d0a05f17 	ldw	r2,-32388(gp)
81118afc:	100f883a 	mov	r7,r2
81118b00:	01800984 	movi	r6,38
81118b04:	01400044 	movi	r5,1
81118b08:	01204574 	movhi	r4,33045
81118b0c:	21258304 	addi	r4,r4,-27124
81118b10:	111affc0 	call	8111affc <fwrite>
81118b14:	00001006 	br	81118b58 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
81118b18:	d0a05f17 	ldw	r2,-32388(gp)
81118b1c:	100f883a 	mov	r7,r2
81118b20:	01800744 	movi	r6,29
81118b24:	01400044 	movi	r5,1
81118b28:	01204574 	movhi	r4,33045
81118b2c:	21258d04 	addi	r4,r4,-27084
81118b30:	111affc0 	call	8111affc <fwrite>
81118b34:	00000806 	br	81118b58 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
81118b38:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
81118b3c:	d0a05f17 	ldw	r2,-32388(gp)
81118b40:	100f883a 	mov	r7,r2
81118b44:	018008c4 	movi	r6,35
81118b48:	01400044 	movi	r5,1
81118b4c:	01204574 	movhi	r4,33045
81118b50:	21259504 	addi	r4,r4,-27052
81118b54:	111affc0 	call	8111affc <fwrite>
	}

	return bSucess;
81118b58:	e0bfff17 	ldw	r2,-4(fp)
}
81118b5c:	e037883a 	mov	sp,fp
81118b60:	dfc00117 	ldw	ra,4(sp)
81118b64:	df000017 	ldw	fp,0(sp)
81118b68:	dec00204 	addi	sp,sp,8
81118b6c:	f800283a 	ret

81118b70 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
81118b70:	defffd04 	addi	sp,sp,-12
81118b74:	de00012e 	bgeu	sp,et,81118b7c <siOpenFile+0xc>
81118b78:	003b68fa 	trap	3
81118b7c:	dfc00215 	stw	ra,8(sp)
81118b80:	df000115 	stw	fp,4(sp)
81118b84:	df000104 	addi	fp,sp,4
81118b88:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81118b8c:	000b883a 	mov	r5,zero
81118b90:	e13fff17 	ldw	r4,-4(fp)
81118b94:	113f2a00 	call	8113f2a0 <alt_up_sd_card_fopen>
}
81118b98:	e037883a 	mov	sp,fp
81118b9c:	dfc00117 	ldw	ra,4(sp)
81118ba0:	df000017 	ldw	fp,0(sp)
81118ba4:	dec00204 	addi	sp,sp,8
81118ba8:	f800283a 	ret

81118bac <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81118bac:	defffd04 	addi	sp,sp,-12
81118bb0:	de00012e 	bgeu	sp,et,81118bb8 <siCloseFile+0xc>
81118bb4:	003b68fa 	trap	3
81118bb8:	dfc00215 	stw	ra,8(sp)
81118bbc:	df000115 	stw	fp,4(sp)
81118bc0:	df000104 	addi	fp,sp,4
81118bc4:	2005883a 	mov	r2,r4
81118bc8:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
81118bcc:	e0bfff0f 	ldh	r2,-4(fp)
81118bd0:	1009883a 	mov	r4,r2
81118bd4:	11400ec0 	call	811400ec <alt_up_sd_card_fclose>
}
81118bd8:	e037883a 	mov	sp,fp
81118bdc:	dfc00117 	ldw	ra,4(sp)
81118be0:	df000017 	ldw	fp,0(sp)
81118be4:	dec00204 	addi	sp,sp,8
81118be8:	f800283a 	ret

81118bec <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
81118bec:	defffd04 	addi	sp,sp,-12
81118bf0:	de00012e 	bgeu	sp,et,81118bf8 <cGetNextChar+0xc>
81118bf4:	003b68fa 	trap	3
81118bf8:	dfc00215 	stw	ra,8(sp)
81118bfc:	df000115 	stw	fp,4(sp)
81118c00:	df000104 	addi	fp,sp,4
81118c04:	2005883a 	mov	r2,r4
81118c08:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
81118c0c:	e0bfff0f 	ldh	r2,-4(fp)
81118c10:	1009883a 	mov	r4,r2
81118c14:	113f7440 	call	8113f744 <alt_up_sd_card_read>
}
81118c18:	e037883a 	mov	sp,fp
81118c1c:	dfc00117 	ldw	ra,4(sp)
81118c20:	df000017 	ldw	fp,0(sp)
81118c24:	dec00204 	addi	sp,sp,8
81118c28:	f800283a 	ret

81118c2c <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81118c2c:	defffc04 	addi	sp,sp,-16
81118c30:	de00012e 	bgeu	sp,et,81118c38 <bInitSync+0xc>
81118c34:	003b68fa 	trap	3
81118c38:	dfc00315 	stw	ra,12(sp)
81118c3c:	df000215 	stw	fp,8(sp)
81118c40:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
81118c44:	110b7100 	call	8110b710 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
81118c48:	d0a05f17 	ldw	r2,-32388(gp)
81118c4c:	100f883a 	mov	r7,r2
81118c50:	01800684 	movi	r6,26
81118c54:	01400044 	movi	r5,1
81118c58:	01204574 	movhi	r4,33045
81118c5c:	21259e04 	addi	r4,r4,-27016
81118c60:	111affc0 	call	8111affc <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
81118c64:	01004c74 	movhi	r4,305
81118c68:	210b4004 	addi	r4,r4,11520
81118c6c:	110b9180 	call	8110b918 <bSyncSetMbt>
81118c70:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118c74:	e0bffe17 	ldw	r2,-8(fp)
81118c78:	1000091e 	bne	r2,zero,81118ca0 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118c7c:	d0a05f17 	ldw	r2,-32388(gp)
81118c80:	100f883a 	mov	r7,r2
81118c84:	018005c4 	movi	r6,23
81118c88:	01400044 	movi	r5,1
81118c8c:	01204574 	movhi	r4,33045
81118c90:	2125a504 	addi	r4,r4,-26988
81118c94:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118c98:	e0bffe17 	ldw	r2,-8(fp)
81118c9c:	00006c06 	br	81118e50 <bInitSync+0x224>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
81118ca0:	01002674 	movhi	r4,153
81118ca4:	2125a004 	addi	r4,r4,-27008
81118ca8:	110b9580 	call	8110b958 <bSyncSetBt>
81118cac:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118cb0:	e0bffe17 	ldw	r2,-8(fp)
81118cb4:	1000091e 	bne	r2,zero,81118cdc <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118cb8:	d0a05f17 	ldw	r2,-32388(gp)
81118cbc:	100f883a 	mov	r7,r2
81118cc0:	018005c4 	movi	r6,23
81118cc4:	01400044 	movi	r5,1
81118cc8:	01204574 	movhi	r4,33045
81118ccc:	2125a504 	addi	r4,r4,-26988
81118cd0:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118cd4:	e0bffe17 	ldw	r2,-8(fp)
81118cd8:	00005d06 	br	81118e50 <bInitSync+0x224>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer((alt_u32)PER);
81118cdc:	0104a834 	movhi	r4,4768
81118ce0:	2117c804 	addi	r4,r4,24352
81118ce4:	110b9980 	call	8110b998 <bSyncSetPer>
81118ce8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118cec:	e0bffe17 	ldw	r2,-8(fp)
81118cf0:	1000091e 	bne	r2,zero,81118d18 <bInitSync+0xec>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118cf4:	d0a05f17 	ldw	r2,-32388(gp)
81118cf8:	100f883a 	mov	r7,r2
81118cfc:	018005c4 	movi	r6,23
81118d00:	01400044 	movi	r5,1
81118d04:	01204574 	movhi	r4,33045
81118d08:	2125a504 	addi	r4,r4,-26988
81118d0c:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118d10:	e0bffe17 	ldw	r2,-8(fp)
81118d14:	00004e06 	br	81118e50 <bInitSync+0x224>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
81118d18:	01005f74 	movhi	r4,381
81118d1c:	211e1004 	addi	r4,r4,30784
81118d20:	110b9d80 	call	8110b9d8 <bSyncSetOst>
81118d24:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118d28:	e0bffe17 	ldw	r2,-8(fp)
81118d2c:	1000091e 	bne	r2,zero,81118d54 <bInitSync+0x128>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118d30:	d0a05f17 	ldw	r2,-32388(gp)
81118d34:	100f883a 	mov	r7,r2
81118d38:	018005c4 	movi	r6,23
81118d3c:	01400044 	movi	r5,1
81118d40:	01204574 	movhi	r4,33045
81118d44:	2125a504 	addi	r4,r4,-26988
81118d48:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118d4c:	e0bffe17 	ldw	r2,-8(fp)
81118d50:	00003f06 	br	81118e50 <bInitSync+0x224>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
81118d54:	0009883a 	mov	r4,zero
81118d58:	110ba180 	call	8110ba18 <bSyncSetPolarity>
81118d5c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118d60:	e0bffe17 	ldw	r2,-8(fp)
81118d64:	1000091e 	bne	r2,zero,81118d8c <bInitSync+0x160>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118d68:	d0a05f17 	ldw	r2,-32388(gp)
81118d6c:	100f883a 	mov	r7,r2
81118d70:	018005c4 	movi	r6,23
81118d74:	01400044 	movi	r5,1
81118d78:	01204574 	movhi	r4,33045
81118d7c:	2125a504 	addi	r4,r4,-26988
81118d80:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118d84:	e0bffe17 	ldw	r2,-8(fp)
81118d88:	00003106 	br	81118e50 <bInitSync+0x224>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
81118d8c:	01000104 	movi	r4,4
81118d90:	110ba8c0 	call	8110ba8c <bSyncSetNCycles>
81118d94:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118d98:	e0bffe17 	ldw	r2,-8(fp)
81118d9c:	1000091e 	bne	r2,zero,81118dc4 <bInitSync+0x198>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118da0:	d0a05f17 	ldw	r2,-32388(gp)
81118da4:	100f883a 	mov	r7,r2
81118da8:	018005c4 	movi	r6,23
81118dac:	01400044 	movi	r5,1
81118db0:	01204574 	movhi	r4,33045
81118db4:	2125a504 	addi	r4,r4,-26988
81118db8:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118dbc:	e0bffe17 	ldw	r2,-8(fp)
81118dc0:	00002306 	br	81118e50 <bInitSync+0x224>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
81118dc4:	01000044 	movi	r4,1
81118dc8:	110bc680 	call	8110bc68 <bSyncCtrExtnIrq>
81118dcc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118dd0:	e0bffe17 	ldw	r2,-8(fp)
81118dd4:	1000091e 	bne	r2,zero,81118dfc <bInitSync+0x1d0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118dd8:	d0a05f17 	ldw	r2,-32388(gp)
81118ddc:	100f883a 	mov	r7,r2
81118de0:	018005c4 	movi	r6,23
81118de4:	01400044 	movi	r5,1
81118de8:	01204574 	movhi	r4,33045
81118dec:	2125a504 	addi	r4,r4,-26988
81118df0:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118df4:	e0bffe17 	ldw	r2,-8(fp)
81118df8:	00001506 	br	81118e50 <bInitSync+0x224>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
81118dfc:	01000044 	movi	r4,1
81118e00:	110be300 	call	8110be30 <bSyncCtrSyncOutEnable>
81118e04:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118e08:	e0bffe17 	ldw	r2,-8(fp)
81118e0c:	1000091e 	bne	r2,zero,81118e34 <bInitSync+0x208>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
81118e10:	d0a05f17 	ldw	r2,-32388(gp)
81118e14:	100f883a 	mov	r7,r2
81118e18:	018005c4 	movi	r6,23
81118e1c:	01400044 	movi	r5,1
81118e20:	01204574 	movhi	r4,33045
81118e24:	2125a504 	addi	r4,r4,-26988
81118e28:	111affc0 	call	8111affc <fwrite>
		#endif
		return bSuccess;
81118e2c:	e0bffe17 	ldw	r2,-8(fp)
81118e30:	00000706 	br	81118e50 <bInitSync+0x224>
	}

	bSuccess = bSyncCtrStart();
81118e34:	110bce00 	call	8110bce0 <bSyncCtrStart>
81118e38:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
81118e3c:	110bd340 	call	8110bd34 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
81118e40:	01000044 	movi	r4,1
81118e44:	110c2b80 	call	8110c2b8 <bSyncIrqEnableBlank>
81118e48:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
81118e4c:	e0bffe17 	ldw	r2,-8(fp)
}
81118e50:	e037883a 	mov	sp,fp
81118e54:	dfc00117 	ldw	ra,4(sp)
81118e58:	df000017 	ldw	fp,0(sp)
81118e5c:	dec00204 	addi	sp,sp,8
81118e60:	f800283a 	ret

81118e64 <bStartSync>:


bool bStartSync(void) {
81118e64:	defffd04 	addi	sp,sp,-12
81118e68:	de00012e 	bgeu	sp,et,81118e70 <bStartSync+0xc>
81118e6c:	003b68fa 	trap	3
81118e70:	dfc00215 	stw	ra,8(sp)
81118e74:	df000115 	stw	fp,4(sp)
81118e78:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSuccess = bSyncCtrStart();
81118e7c:	110bce00 	call	8110bce0 <bSyncCtrStart>
81118e80:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
81118e84:	e0bfff17 	ldw	r2,-4(fp)
}
81118e88:	e037883a 	mov	sp,fp
81118e8c:	dfc00117 	ldw	ra,4(sp)
81118e90:	df000017 	ldw	fp,0(sp)
81118e94:	dec00204 	addi	sp,sp,8
81118e98:	f800283a 	ret

81118e9c <bStopSync>:

bool bStopSync(void) {
81118e9c:	defffe04 	addi	sp,sp,-8
81118ea0:	de00012e 	bgeu	sp,et,81118ea8 <bStopSync+0xc>
81118ea4:	003b68fa 	trap	3
81118ea8:	dfc00115 	stw	ra,4(sp)
81118eac:	df000015 	stw	fp,0(sp)
81118eb0:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
81118eb4:	110bd340 	call	8110bd34 <bSyncCtrReset>
}
81118eb8:	e037883a 	mov	sp,fp
81118ebc:	dfc00117 	ldw	ra,4(sp)
81118ec0:	df000017 	ldw	fp,0(sp)
81118ec4:	dec00204 	addi	sp,sp,8
81118ec8:	f800283a 	ret

81118ecc <bTestSimucamCriticalHW>:


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void )
{
81118ecc:	deffff04 	addi	sp,sp,-4
81118ed0:	de00012e 	bgeu	sp,et,81118ed8 <bTestSimucamCriticalHW+0xc>
81118ed4:	003b68fa 	trap	3
81118ed8:	df000015 	stw	fp,0(sp)
81118edc:	d839883a 	mov	fp,sp
	 * SDcard para criar logs e pegar defaults
	 */



	return TRUE;
81118ee0:	00800044 	movi	r2,1
}
81118ee4:	e037883a 	mov	sp,fp
81118ee8:	df000017 	ldw	fp,0(sp)
81118eec:	dec00104 	addi	sp,sp,4
81118ef0:	f800283a 	ret

81118ef4 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
81118ef4:	defffc04 	addi	sp,sp,-16
81118ef8:	de00012e 	bgeu	sp,et,81118f00 <_reg_write+0xc>
81118efc:	003b68fa 	trap	3
81118f00:	df000315 	stw	fp,12(sp)
81118f04:	df000304 	addi	fp,sp,12
81118f08:	e13ffd15 	stw	r4,-12(fp)
81118f0c:	e17ffe15 	stw	r5,-8(fp)
81118f10:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
81118f14:	e0bffe17 	ldw	r2,-8(fp)
81118f18:	1085883a 	add	r2,r2,r2
81118f1c:	1085883a 	add	r2,r2,r2
81118f20:	1007883a 	mov	r3,r2
81118f24:	e0bffd17 	ldw	r2,-12(fp)
81118f28:	1885883a 	add	r2,r3,r2
81118f2c:	1007883a 	mov	r3,r2
81118f30:	e0bfff17 	ldw	r2,-4(fp)
81118f34:	18800035 	stwio	r2,0(r3)
	return 1;
81118f38:	00800044 	movi	r2,1

}
81118f3c:	e037883a 	mov	sp,fp
81118f40:	df000017 	ldw	fp,0(sp)
81118f44:	dec00104 	addi	sp,sp,4
81118f48:	f800283a 	ret

81118f4c <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
81118f4c:	defffc04 	addi	sp,sp,-16
81118f50:	de00012e 	bgeu	sp,et,81118f58 <_reg_read+0xc>
81118f54:	003b68fa 	trap	3
81118f58:	df000315 	stw	fp,12(sp)
81118f5c:	df000304 	addi	fp,sp,12
81118f60:	e13ffd15 	stw	r4,-12(fp)
81118f64:	e17ffe15 	stw	r5,-8(fp)
81118f68:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81118f6c:	e0bffe17 	ldw	r2,-8(fp)
81118f70:	1085883a 	add	r2,r2,r2
81118f74:	1085883a 	add	r2,r2,r2
81118f78:	1007883a 	mov	r3,r2
81118f7c:	e0bffd17 	ldw	r2,-12(fp)
81118f80:	1885883a 	add	r2,r3,r2
81118f84:	10c00037 	ldwio	r3,0(r2)
81118f88:	e0bfff17 	ldw	r2,-4(fp)
81118f8c:	10c00015 	stw	r3,0(r2)
	return 1;
81118f90:	00800044 	movi	r2,1

}
81118f94:	e037883a 	mov	sp,fp
81118f98:	df000017 	ldw	fp,0(sp)
81118f9c:	dec00104 	addi	sp,sp,4
81118fa0:	f800283a 	ret

81118fa4 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81118fa4:	defffa04 	addi	sp,sp,-24
81118fa8:	de00012e 	bgeu	sp,et,81118fb0 <_print_codec_status+0xc>
81118fac:	003b68fa 	trap	3
81118fb0:	dfc00515 	stw	ra,20(sp)
81118fb4:	df000415 	stw	fp,16(sp)
81118fb8:	df000404 	addi	fp,sp,16
81118fbc:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
81118fc0:	e0bfff17 	ldw	r2,-4(fp)
81118fc4:	1005d1ba 	srai	r2,r2,6
81118fc8:	1080004c 	andi	r2,r2,1
81118fcc:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81118fd0:	e0bfff17 	ldw	r2,-4(fp)
81118fd4:	1005d17a 	srai	r2,r2,5
81118fd8:	1080004c 	andi	r2,r2,1
81118fdc:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81118fe0:	e0bfff17 	ldw	r2,-4(fp)
81118fe4:	1005d13a 	srai	r2,r2,4
81118fe8:	1080004c 	andi	r2,r2,1
81118fec:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
81118ff0:	00e04574 	movhi	r3,33045
81118ff4:	18f1a904 	addi	r3,r3,-14684
81118ff8:	00a04574 	movhi	r2,33045
81118ffc:	10a5ab04 	addi	r2,r2,-26964
81119000:	1009883a 	mov	r4,r2
81119004:	008005c4 	movi	r2,23
81119008:	100d883a 	mov	r6,r2
8111900c:	200b883a 	mov	r5,r4
81119010:	1809883a 	mov	r4,r3
81119014:	111ba100 	call	8111ba10 <memcpy>
	debug(fp, cDebugBuffer);
81119018:	d0a05f17 	ldw	r2,-32388(gp)
8111901c:	01604574 	movhi	r5,33045
81119020:	2971a904 	addi	r5,r5,-14684
81119024:	1009883a 	mov	r4,r2
81119028:	111a9600 	call	8111a960 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111902c:	e0bffc17 	ldw	r2,-16(fp)
81119030:	10800058 	cmpnei	r2,r2,1
81119034:	1000031e 	bne	r2,zero,81119044 <_print_codec_status+0xa0>
81119038:	00a04574 	movhi	r2,33045
8111903c:	10a5b104 	addi	r2,r2,-26940
81119040:	00000206 	br	8111904c <_print_codec_status+0xa8>
81119044:	00a04574 	movhi	r2,33045
81119048:	10a5b204 	addi	r2,r2,-26936
8111904c:	100d883a 	mov	r6,r2
81119050:	01604574 	movhi	r5,33045
81119054:	2965b304 	addi	r5,r5,-26932
81119058:	01204574 	movhi	r4,33045
8111905c:	2131a904 	addi	r4,r4,-14684
81119060:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
81119064:	d0a05f17 	ldw	r2,-32388(gp)
81119068:	01604574 	movhi	r5,33045
8111906c:	2971a904 	addi	r5,r5,-14684
81119070:	1009883a 	mov	r4,r2
81119074:	111a9600 	call	8111a960 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
81119078:	e0bffd17 	ldw	r2,-12(fp)
8111907c:	10800058 	cmpnei	r2,r2,1
81119080:	1000031e 	bne	r2,zero,81119090 <_print_codec_status+0xec>
81119084:	00a04574 	movhi	r2,33045
81119088:	10a5b104 	addi	r2,r2,-26940
8111908c:	00000206 	br	81119098 <_print_codec_status+0xf4>
81119090:	00a04574 	movhi	r2,33045
81119094:	10a5b204 	addi	r2,r2,-26936
81119098:	100d883a 	mov	r6,r2
8111909c:	01604574 	movhi	r5,33045
811190a0:	2965b904 	addi	r5,r5,-26908
811190a4:	01204574 	movhi	r4,33045
811190a8:	2131a904 	addi	r4,r4,-14684
811190ac:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
811190b0:	d0a05f17 	ldw	r2,-32388(gp)
811190b4:	01604574 	movhi	r5,33045
811190b8:	2971a904 	addi	r5,r5,-14684
811190bc:	1009883a 	mov	r4,r2
811190c0:	111a9600 	call	8111a960 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
811190c4:	e0bffe17 	ldw	r2,-8(fp)
811190c8:	10800058 	cmpnei	r2,r2,1
811190cc:	1000031e 	bne	r2,zero,811190dc <_print_codec_status+0x138>
811190d0:	00a04574 	movhi	r2,33045
811190d4:	10a5b104 	addi	r2,r2,-26940
811190d8:	00000206 	br	811190e4 <_print_codec_status+0x140>
811190dc:	00a04574 	movhi	r2,33045
811190e0:	10a5b204 	addi	r2,r2,-26936
811190e4:	100d883a 	mov	r6,r2
811190e8:	01604574 	movhi	r5,33045
811190ec:	2965bf04 	addi	r5,r5,-26884
811190f0:	01204574 	movhi	r4,33045
811190f4:	2131a904 	addi	r4,r4,-14684
811190f8:	111c2f00 	call	8111c2f0 <sprintf>
	debug(fp, cDebugBuffer);
811190fc:	d0a05f17 	ldw	r2,-32388(gp)
81119100:	01604574 	movhi	r5,33045
81119104:	2971a904 	addi	r5,r5,-14684
81119108:	1009883a 	mov	r4,r2
8111910c:	111a9600 	call	8111a960 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
81119110:	00a04574 	movhi	r2,33045
81119114:	10b1a904 	addi	r2,r2,-14684
81119118:	00c00b44 	movi	r3,45
8111911c:	10c00005 	stb	r3,0(r2)
81119120:	00c00b44 	movi	r3,45
81119124:	10c00045 	stb	r3,1(r2)
81119128:	00c00b44 	movi	r3,45
8111912c:	10c00085 	stb	r3,2(r2)
81119130:	00c00b44 	movi	r3,45
81119134:	10c000c5 	stb	r3,3(r2)
81119138:	00c00b44 	movi	r3,45
8111913c:	10c00105 	stb	r3,4(r2)
81119140:	00c00b44 	movi	r3,45
81119144:	10c00145 	stb	r3,5(r2)
81119148:	00c00b44 	movi	r3,45
8111914c:	10c00185 	stb	r3,6(r2)
81119150:	00c00b44 	movi	r3,45
81119154:	10c001c5 	stb	r3,7(r2)
81119158:	00c00804 	movi	r3,32
8111915c:	10c00205 	stb	r3,8(r2)
81119160:	00c00804 	movi	r3,32
81119164:	10c00245 	stb	r3,9(r2)
81119168:	00c00284 	movi	r3,10
8111916c:	10c00285 	stb	r3,10(r2)
81119170:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
81119174:	d0a05f17 	ldw	r2,-32388(gp)
81119178:	01604574 	movhi	r5,33045
8111917c:	2971a904 	addi	r5,r5,-14684
81119180:	1009883a 	mov	r4,r2
81119184:	111a9600 	call	8111a960 <fprintf>
#endif
}
81119188:	0001883a 	nop
8111918c:	e037883a 	mov	sp,fp
81119190:	dfc00117 	ldw	ra,4(sp)
81119194:	df000017 	ldw	fp,0(sp)
81119198:	dec00204 	addi	sp,sp,8
8111919c:	f800283a 	ret

811191a0 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
811191a0:	defffb04 	addi	sp,sp,-20
811191a4:	de00012e 	bgeu	sp,et,811191ac <_split_codec_status+0xc>
811191a8:	003b68fa 	trap	3
811191ac:	df000415 	stw	fp,16(sp)
811191b0:	df000404 	addi	fp,sp,16
811191b4:	e13ffc15 	stw	r4,-16(fp)
811191b8:	e17ffd15 	stw	r5,-12(fp)
811191bc:	e1bffe15 	stw	r6,-8(fp)
811191c0:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
811191c4:	e0bffc17 	ldw	r2,-16(fp)
811191c8:	1005d1ba 	srai	r2,r2,6
811191cc:	10c0004c 	andi	r3,r2,1
811191d0:	e0bffd17 	ldw	r2,-12(fp)
811191d4:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
811191d8:	e0bffc17 	ldw	r2,-16(fp)
811191dc:	1005d17a 	srai	r2,r2,5
811191e0:	10c0004c 	andi	r3,r2,1
811191e4:	e0bffe17 	ldw	r2,-8(fp)
811191e8:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
811191ec:	e0bffc17 	ldw	r2,-16(fp)
811191f0:	1005d13a 	srai	r2,r2,4
811191f4:	10c0004c 	andi	r3,r2,1
811191f8:	e0bfff17 	ldw	r2,-4(fp)
811191fc:	10c00015 	stw	r3,0(r2)
}
81119200:	0001883a 	nop
81119204:	e037883a 	mov	sp,fp
81119208:	df000017 	ldw	fp,0(sp)
8111920c:	dec00104 	addi	sp,sp,4
81119210:	f800283a 	ret

81119214 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81119214:	defffc04 	addi	sp,sp,-16
81119218:	de00012e 	bgeu	sp,et,81119220 <aatoh+0xc>
8111921c:	003b68fa 	trap	3
81119220:	df000315 	stw	fp,12(sp)
81119224:	df000304 	addi	fp,sp,12
81119228:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111922c:	e0bfff17 	ldw	r2,-4(fp)
81119230:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81119234:	e0bffd17 	ldw	r2,-12(fp)
81119238:	10c00003 	ldbu	r3,0(r2)
8111923c:	e0bffd17 	ldw	r2,-12(fp)
81119240:	10800003 	ldbu	r2,0(r2)
81119244:	10803fcc 	andi	r2,r2,255
81119248:	10800eb0 	cmpltui	r2,r2,58
8111924c:	1000021e 	bne	r2,zero,81119258 <aatoh+0x44>
81119250:	00800dc4 	movi	r2,55
81119254:	00000106 	br	8111925c <aatoh+0x48>
81119258:	00800c04 	movi	r2,48
8111925c:	1885c83a 	sub	r2,r3,r2
81119260:	1004913a 	slli	r2,r2,4
81119264:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81119268:	e0bffd17 	ldw	r2,-12(fp)
8111926c:	10800044 	addi	r2,r2,1
81119270:	10c00003 	ldbu	r3,0(r2)
81119274:	e0bffd17 	ldw	r2,-12(fp)
81119278:	10800044 	addi	r2,r2,1
8111927c:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81119280:	10803fcc 	andi	r2,r2,255
81119284:	10800eb0 	cmpltui	r2,r2,58
81119288:	1000021e 	bne	r2,zero,81119294 <aatoh+0x80>
8111928c:	00800dc4 	movi	r2,55
81119290:	00000106 	br	81119298 <aatoh+0x84>
81119294:	00800c04 	movi	r2,48
81119298:	1885c83a 	sub	r2,r3,r2
8111929c:	2085883a 	add	r2,r4,r2
811192a0:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
811192a4:	e0bffe03 	ldbu	r2,-8(fp)
}
811192a8:	e037883a 	mov	sp,fp
811192ac:	df000017 	ldw	fp,0(sp)
811192b0:	dec00104 	addi	sp,sp,4
811192b4:	f800283a 	ret

811192b8 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
811192b8:	defffd04 	addi	sp,sp,-12
811192bc:	de00012e 	bgeu	sp,et,811192c4 <Verif_Error+0xc>
811192c0:	003b68fa 	trap	3
811192c4:	dfc00215 	stw	ra,8(sp)
811192c8:	df000115 	stw	fp,4(sp)
811192cc:	df000104 	addi	fp,sp,4
811192d0:	2005883a 	mov	r2,r4
811192d4:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
811192d8:	e0bfff03 	ldbu	r2,-4(fp)
811192dc:	1000091e 	bne	r2,zero,81119304 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
811192e0:	d0a05f17 	ldw	r2,-32388(gp)
811192e4:	100f883a 	mov	r7,r2
811192e8:	018001c4 	movi	r6,7
811192ec:	01400044 	movi	r5,1
811192f0:	01204574 	movhi	r4,33045
811192f4:	2125c504 	addi	r4,r4,-26860
811192f8:	111affc0 	call	8111affc <fwrite>
#endif
		return 0;
811192fc:	0005883a 	mov	r2,zero
81119300:	00000106 	br	81119308 <Verif_Error+0x50>
	} else
		return 1;
81119304:	00800044 	movi	r2,1
}
81119308:	e037883a 	mov	sp,fp
8111930c:	dfc00117 	ldw	ra,4(sp)
81119310:	df000017 	ldw	fp,0(sp)
81119314:	dec00204 	addi	sp,sp,8
81119318:	f800283a 	ret

8111931c <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111931c:	defffe04 	addi	sp,sp,-8
81119320:	de00012e 	bgeu	sp,et,81119328 <toInt+0xc>
81119324:	003b68fa 	trap	3
81119328:	df000115 	stw	fp,4(sp)
8111932c:	df000104 	addi	fp,sp,4
81119330:	2005883a 	mov	r2,r4
81119334:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
81119338:	e0bfff03 	ldbu	r2,-4(fp)
8111933c:	10bff404 	addi	r2,r2,-48
}
81119340:	e037883a 	mov	sp,fp
81119344:	df000017 	ldw	fp,0(sp)
81119348:	dec00104 	addi	sp,sp,4
8111934c:	f800283a 	ret

81119350 <__divsf3>:
81119350:	defff504 	addi	sp,sp,-44
81119354:	200cd5fa 	srli	r6,r4,23
81119358:	de00012e 	bgeu	sp,et,81119360 <__divsf3+0x10>
8111935c:	003b68fa 	trap	3
81119360:	dcc00415 	stw	r19,16(sp)
81119364:	2026d7fa 	srli	r19,r4,31
81119368:	00c02034 	movhi	r3,128
8111936c:	dd800715 	stw	r22,28(sp)
81119370:	dd000515 	stw	r20,20(sp)
81119374:	dc800315 	stw	r18,12(sp)
81119378:	18ffffc4 	addi	r3,r3,-1
8111937c:	dfc00a15 	stw	ra,40(sp)
81119380:	df000915 	stw	fp,36(sp)
81119384:	ddc00815 	stw	r23,32(sp)
81119388:	dd400615 	stw	r21,24(sp)
8111938c:	dc400215 	stw	r17,8(sp)
81119390:	dc000115 	stw	r16,4(sp)
81119394:	35003fcc 	andi	r20,r6,255
81119398:	1924703a 	and	r18,r3,r4
8111939c:	9d803fcc 	andi	r22,r19,255
811193a0:	a0005226 	beq	r20,zero,811194ec <__divsf3+0x19c>
811193a4:	00803fc4 	movi	r2,255
811193a8:	a0802e26 	beq	r20,r2,81119464 <__divsf3+0x114>
811193ac:	91002034 	orhi	r4,r18,128
811193b0:	202490fa 	slli	r18,r4,3
811193b4:	a53fe044 	addi	r20,r20,-127
811193b8:	0021883a 	mov	r16,zero
811193bc:	002f883a 	mov	r23,zero
811193c0:	280cd5fa 	srli	r6,r5,23
811193c4:	282ad7fa 	srli	r21,r5,31
811193c8:	00c02034 	movhi	r3,128
811193cc:	18ffffc4 	addi	r3,r3,-1
811193d0:	31803fcc 	andi	r6,r6,255
811193d4:	1962703a 	and	r17,r3,r5
811193d8:	af003fcc 	andi	fp,r21,255
811193dc:	30004a26 	beq	r6,zero,81119508 <__divsf3+0x1b8>
811193e0:	00803fc4 	movi	r2,255
811193e4:	30804526 	beq	r6,r2,811194fc <__divsf3+0x1ac>
811193e8:	89402034 	orhi	r5,r17,128
811193ec:	282290fa 	slli	r17,r5,3
811193f0:	31bfe044 	addi	r6,r6,-127
811193f4:	000b883a 	mov	r5,zero
811193f8:	2c20b03a 	or	r16,r5,r16
811193fc:	802090ba 	slli	r16,r16,2
81119400:	00a044b4 	movhi	r2,33042
81119404:	10a50904 	addi	r2,r2,-27612
81119408:	80a1883a 	add	r16,r16,r2
8111940c:	81000017 	ldw	r4,0(r16)
81119410:	9d46f03a 	xor	r3,r19,r21
81119414:	180f883a 	mov	r7,r3
81119418:	18803fcc 	andi	r2,r3,255
8111941c:	a18dc83a 	sub	r6,r20,r6
81119420:	2000683a 	jmp	r4
81119424:	81119608 	cmpgei	r4,r16,18008
81119428:	8111948c 	andi	r4,r16,18002
8111942c:	811195fc 	xorhi	r4,r16,18007
81119430:	81119478 	rdprs	r4,r16,18001
81119434:	811195fc 	xorhi	r4,r16,18007
81119438:	811195d4 	ori	r4,r16,18007
8111943c:	811195fc 	xorhi	r4,r16,18007
81119440:	81119478 	rdprs	r4,r16,18001
81119444:	8111948c 	andi	r4,r16,18002
81119448:	8111948c 	andi	r4,r16,18002
8111944c:	811195d4 	ori	r4,r16,18007
81119450:	81119478 	rdprs	r4,r16,18001
81119454:	811196e8 	cmpgeui	r4,r16,18011
81119458:	811196e8 	cmpgeui	r4,r16,18011
8111945c:	811196e8 	cmpgeui	r4,r16,18011
81119460:	8111969c 	xori	r4,r16,18010
81119464:	9000581e 	bne	r18,zero,811195c8 <__divsf3+0x278>
81119468:	04000204 	movi	r16,8
8111946c:	05c00084 	movi	r23,2
81119470:	003fd306 	br	811193c0 <__reset+0xfb0f93c0>
81119474:	0023883a 	mov	r17,zero
81119478:	e02d883a 	mov	r22,fp
8111947c:	282f883a 	mov	r23,r5
81119480:	00800084 	movi	r2,2
81119484:	b8808f1e 	bne	r23,r2,811196c4 <__divsf3+0x374>
81119488:	b005883a 	mov	r2,r22
8111948c:	11c0004c 	andi	r7,r2,1
81119490:	013fffc4 	movi	r4,-1
81119494:	000d883a 	mov	r6,zero
81119498:	21003fcc 	andi	r4,r4,255
8111949c:	200895fa 	slli	r4,r4,23
811194a0:	38803fcc 	andi	r2,r7,255
811194a4:	00c02034 	movhi	r3,128
811194a8:	100497fa 	slli	r2,r2,31
811194ac:	18ffffc4 	addi	r3,r3,-1
811194b0:	30c6703a 	and	r3,r6,r3
811194b4:	1906b03a 	or	r3,r3,r4
811194b8:	1884b03a 	or	r2,r3,r2
811194bc:	dfc00a17 	ldw	ra,40(sp)
811194c0:	df000917 	ldw	fp,36(sp)
811194c4:	ddc00817 	ldw	r23,32(sp)
811194c8:	dd800717 	ldw	r22,28(sp)
811194cc:	dd400617 	ldw	r21,24(sp)
811194d0:	dd000517 	ldw	r20,20(sp)
811194d4:	dcc00417 	ldw	r19,16(sp)
811194d8:	dc800317 	ldw	r18,12(sp)
811194dc:	dc400217 	ldw	r17,8(sp)
811194e0:	dc000117 	ldw	r16,4(sp)
811194e4:	dec00b04 	addi	sp,sp,44
811194e8:	f800283a 	ret
811194ec:	90002b1e 	bne	r18,zero,8111959c <__divsf3+0x24c>
811194f0:	04000104 	movi	r16,4
811194f4:	05c00044 	movi	r23,1
811194f8:	003fb106 	br	811193c0 <__reset+0xfb0f93c0>
811194fc:	8800251e 	bne	r17,zero,81119594 <__divsf3+0x244>
81119500:	01400084 	movi	r5,2
81119504:	00000206 	br	81119510 <__divsf3+0x1c0>
81119508:	88001a1e 	bne	r17,zero,81119574 <__divsf3+0x224>
8111950c:	01400044 	movi	r5,1
81119510:	8160b03a 	or	r16,r16,r5
81119514:	802090ba 	slli	r16,r16,2
81119518:	00e044b4 	movhi	r3,33042
8111951c:	18e54d04 	addi	r3,r3,-27340
81119520:	80e1883a 	add	r16,r16,r3
81119524:	80c00017 	ldw	r3,0(r16)
81119528:	9d44f03a 	xor	r2,r19,r21
8111952c:	a18dc83a 	sub	r6,r20,r6
81119530:	1800683a 	jmp	r3
81119534:	8111948c 	andi	r4,r16,18002
81119538:	8111948c 	andi	r4,r16,18002
8111953c:	811196d8 	cmpnei	r4,r16,18011
81119540:	81119474 	orhi	r4,r16,18001
81119544:	811196d8 	cmpnei	r4,r16,18011
81119548:	811195d4 	ori	r4,r16,18007
8111954c:	811196d8 	cmpnei	r4,r16,18011
81119550:	81119474 	orhi	r4,r16,18001
81119554:	8111948c 	andi	r4,r16,18002
81119558:	8111948c 	andi	r4,r16,18002
8111955c:	811195d4 	ori	r4,r16,18007
81119560:	81119474 	orhi	r4,r16,18001
81119564:	811196e8 	cmpgeui	r4,r16,18011
81119568:	811196e8 	cmpgeui	r4,r16,18011
8111956c:	811196e8 	cmpgeui	r4,r16,18011
81119570:	81119700 	call	88111970 <__reset+0x20f1970>
81119574:	8809883a 	mov	r4,r17
81119578:	111a7a00 	call	8111a7a0 <__clzsi2>
8111957c:	10fffec4 	addi	r3,r2,-5
81119580:	10801d84 	addi	r2,r2,118
81119584:	88e2983a 	sll	r17,r17,r3
81119588:	008dc83a 	sub	r6,zero,r2
8111958c:	000b883a 	mov	r5,zero
81119590:	003f9906 	br	811193f8 <__reset+0xfb0f93f8>
81119594:	014000c4 	movi	r5,3
81119598:	003f9706 	br	811193f8 <__reset+0xfb0f93f8>
8111959c:	9009883a 	mov	r4,r18
811195a0:	d9400015 	stw	r5,0(sp)
811195a4:	111a7a00 	call	8111a7a0 <__clzsi2>
811195a8:	10fffec4 	addi	r3,r2,-5
811195ac:	11801d84 	addi	r6,r2,118
811195b0:	90e4983a 	sll	r18,r18,r3
811195b4:	01a9c83a 	sub	r20,zero,r6
811195b8:	0021883a 	mov	r16,zero
811195bc:	002f883a 	mov	r23,zero
811195c0:	d9400017 	ldw	r5,0(sp)
811195c4:	003f7e06 	br	811193c0 <__reset+0xfb0f93c0>
811195c8:	04000304 	movi	r16,12
811195cc:	05c000c4 	movi	r23,3
811195d0:	003f7b06 	br	811193c0 <__reset+0xfb0f93c0>
811195d4:	01802034 	movhi	r6,128
811195d8:	000f883a 	mov	r7,zero
811195dc:	31bfffc4 	addi	r6,r6,-1
811195e0:	013fffc4 	movi	r4,-1
811195e4:	003fac06 	br	81119498 <__reset+0xfb0f9498>
811195e8:	01400044 	movi	r5,1
811195ec:	2909c83a 	sub	r4,r5,r4
811195f0:	00c006c4 	movi	r3,27
811195f4:	19004b0e 	bge	r3,r4,81119724 <__divsf3+0x3d4>
811195f8:	114e703a 	and	r7,r2,r5
811195fc:	0009883a 	mov	r4,zero
81119600:	000d883a 	mov	r6,zero
81119604:	003fa406 	br	81119498 <__reset+0xfb0f9498>
81119608:	9006917a 	slli	r3,r18,5
8111960c:	8822917a 	slli	r17,r17,5
81119610:	1c40372e 	bgeu	r3,r17,811196f0 <__divsf3+0x3a0>
81119614:	31bfffc4 	addi	r6,r6,-1
81119618:	010006c4 	movi	r4,27
8111961c:	000b883a 	mov	r5,zero
81119620:	180f883a 	mov	r7,r3
81119624:	294b883a 	add	r5,r5,r5
81119628:	18c7883a 	add	r3,r3,r3
8111962c:	38000116 	blt	r7,zero,81119634 <__divsf3+0x2e4>
81119630:	1c400236 	bltu	r3,r17,8111963c <__divsf3+0x2ec>
81119634:	1c47c83a 	sub	r3,r3,r17
81119638:	29400054 	ori	r5,r5,1
8111963c:	213fffc4 	addi	r4,r4,-1
81119640:	203ff71e 	bne	r4,zero,81119620 <__reset+0xfb0f9620>
81119644:	1806c03a 	cmpne	r3,r3,zero
81119648:	1962b03a 	or	r17,r3,r5
8111964c:	31001fc4 	addi	r4,r6,127
81119650:	013fe50e 	bge	zero,r4,811195e8 <__reset+0xfb0f95e8>
81119654:	88c001cc 	andi	r3,r17,7
81119658:	18000426 	beq	r3,zero,8111966c <__divsf3+0x31c>
8111965c:	88c003cc 	andi	r3,r17,15
81119660:	01400104 	movi	r5,4
81119664:	19400126 	beq	r3,r5,8111966c <__divsf3+0x31c>
81119668:	8963883a 	add	r17,r17,r5
8111966c:	88c2002c 	andhi	r3,r17,2048
81119670:	18000426 	beq	r3,zero,81119684 <__divsf3+0x334>
81119674:	00fe0034 	movhi	r3,63488
81119678:	18ffffc4 	addi	r3,r3,-1
8111967c:	31002004 	addi	r4,r6,128
81119680:	88e2703a 	and	r17,r17,r3
81119684:	00c03f84 	movi	r3,254
81119688:	193f8016 	blt	r3,r4,8111948c <__reset+0xfb0f948c>
8111968c:	880c91ba 	slli	r6,r17,6
81119690:	11c0004c 	andi	r7,r2,1
81119694:	300cd27a 	srli	r6,r6,9
81119698:	003f7f06 	br	81119498 <__reset+0xfb0f9498>
8111969c:	9080102c 	andhi	r2,r18,64
811196a0:	10000226 	beq	r2,zero,811196ac <__divsf3+0x35c>
811196a4:	8880102c 	andhi	r2,r17,64
811196a8:	10001826 	beq	r2,zero,8111970c <__divsf3+0x3bc>
811196ac:	00802034 	movhi	r2,128
811196b0:	91801034 	orhi	r6,r18,64
811196b4:	10bfffc4 	addi	r2,r2,-1
811196b8:	980f883a 	mov	r7,r19
811196bc:	308c703a 	and	r6,r6,r2
811196c0:	003fc706 	br	811195e0 <__reset+0xfb0f95e0>
811196c4:	008000c4 	movi	r2,3
811196c8:	b8802d26 	beq	r23,r2,81119780 <__divsf3+0x430>
811196cc:	00c00044 	movi	r3,1
811196d0:	b005883a 	mov	r2,r22
811196d4:	b8ffdd1e 	bne	r23,r3,8111964c <__reset+0xfb0f964c>
811196d8:	11c0004c 	andi	r7,r2,1
811196dc:	0009883a 	mov	r4,zero
811196e0:	000d883a 	mov	r6,zero
811196e4:	003f6c06 	br	81119498 <__reset+0xfb0f9498>
811196e8:	9023883a 	mov	r17,r18
811196ec:	003f6406 	br	81119480 <__reset+0xfb0f9480>
811196f0:	1c47c83a 	sub	r3,r3,r17
811196f4:	01000684 	movi	r4,26
811196f8:	01400044 	movi	r5,1
811196fc:	003fc806 	br	81119620 <__reset+0xfb0f9620>
81119700:	9080102c 	andhi	r2,r18,64
81119704:	103fe926 	beq	r2,zero,811196ac <__reset+0xfb0f96ac>
81119708:	0023883a 	mov	r17,zero
8111970c:	00802034 	movhi	r2,128
81119710:	89801034 	orhi	r6,r17,64
81119714:	10bfffc4 	addi	r2,r2,-1
81119718:	a80f883a 	mov	r7,r21
8111971c:	308c703a 	and	r6,r6,r2
81119720:	003faf06 	br	811195e0 <__reset+0xfb0f95e0>
81119724:	01c00804 	movi	r7,32
81119728:	390fc83a 	sub	r7,r7,r4
8111972c:	89ce983a 	sll	r7,r17,r7
81119730:	890ad83a 	srl	r5,r17,r4
81119734:	380ec03a 	cmpne	r7,r7,zero
81119738:	29cab03a 	or	r5,r5,r7
8111973c:	28c001cc 	andi	r3,r5,7
81119740:	18000426 	beq	r3,zero,81119754 <__divsf3+0x404>
81119744:	28c003cc 	andi	r3,r5,15
81119748:	01000104 	movi	r4,4
8111974c:	19000126 	beq	r3,r4,81119754 <__divsf3+0x404>
81119750:	290b883a 	add	r5,r5,r4
81119754:	28c1002c 	andhi	r3,r5,1024
81119758:	18000426 	beq	r3,zero,8111976c <__divsf3+0x41c>
8111975c:	11c0004c 	andi	r7,r2,1
81119760:	01000044 	movi	r4,1
81119764:	000d883a 	mov	r6,zero
81119768:	003f4b06 	br	81119498 <__reset+0xfb0f9498>
8111976c:	280a91ba 	slli	r5,r5,6
81119770:	11c0004c 	andi	r7,r2,1
81119774:	0009883a 	mov	r4,zero
81119778:	280cd27a 	srli	r6,r5,9
8111977c:	003f4606 	br	81119498 <__reset+0xfb0f9498>
81119780:	00802034 	movhi	r2,128
81119784:	89801034 	orhi	r6,r17,64
81119788:	10bfffc4 	addi	r2,r2,-1
8111978c:	b00f883a 	mov	r7,r22
81119790:	308c703a 	and	r6,r6,r2
81119794:	003f9206 	br	811195e0 <__reset+0xfb0f95e0>

81119798 <__mulsf3>:
81119798:	defff504 	addi	sp,sp,-44
8111979c:	de00012e 	bgeu	sp,et,811197a4 <__mulsf3+0xc>
811197a0:	003b68fa 	trap	3
811197a4:	dc000115 	stw	r16,4(sp)
811197a8:	2020d5fa 	srli	r16,r4,23
811197ac:	dd400615 	stw	r21,24(sp)
811197b0:	202ad7fa 	srli	r21,r4,31
811197b4:	dc800315 	stw	r18,12(sp)
811197b8:	04802034 	movhi	r18,128
811197bc:	df000915 	stw	fp,36(sp)
811197c0:	dd000515 	stw	r20,20(sp)
811197c4:	94bfffc4 	addi	r18,r18,-1
811197c8:	dfc00a15 	stw	ra,40(sp)
811197cc:	ddc00815 	stw	r23,32(sp)
811197d0:	dd800715 	stw	r22,28(sp)
811197d4:	dcc00415 	stw	r19,16(sp)
811197d8:	dc400215 	stw	r17,8(sp)
811197dc:	84003fcc 	andi	r16,r16,255
811197e0:	9124703a 	and	r18,r18,r4
811197e4:	a829883a 	mov	r20,r21
811197e8:	af003fcc 	andi	fp,r21,255
811197ec:	80005426 	beq	r16,zero,81119940 <__mulsf3+0x1a8>
811197f0:	00803fc4 	movi	r2,255
811197f4:	80802f26 	beq	r16,r2,811198b4 <__mulsf3+0x11c>
811197f8:	91002034 	orhi	r4,r18,128
811197fc:	202490fa 	slli	r18,r4,3
81119800:	843fe044 	addi	r16,r16,-127
81119804:	0023883a 	mov	r17,zero
81119808:	002f883a 	mov	r23,zero
8111980c:	2804d5fa 	srli	r2,r5,23
81119810:	282cd7fa 	srli	r22,r5,31
81119814:	01002034 	movhi	r4,128
81119818:	213fffc4 	addi	r4,r4,-1
8111981c:	10803fcc 	andi	r2,r2,255
81119820:	2166703a 	and	r19,r4,r5
81119824:	b1803fcc 	andi	r6,r22,255
81119828:	10004c26 	beq	r2,zero,8111995c <__mulsf3+0x1c4>
8111982c:	00c03fc4 	movi	r3,255
81119830:	10c04726 	beq	r2,r3,81119950 <__mulsf3+0x1b8>
81119834:	99002034 	orhi	r4,r19,128
81119838:	202690fa 	slli	r19,r4,3
8111983c:	10bfe044 	addi	r2,r2,-127
81119840:	0007883a 	mov	r3,zero
81119844:	80a1883a 	add	r16,r16,r2
81119848:	010003c4 	movi	r4,15
8111984c:	1c44b03a 	or	r2,r3,r17
81119850:	b56af03a 	xor	r21,r22,r21
81119854:	81c00044 	addi	r7,r16,1
81119858:	20806b36 	bltu	r4,r2,81119a08 <__mulsf3+0x270>
8111985c:	100490ba 	slli	r2,r2,2
81119860:	012044b4 	movhi	r4,33042
81119864:	21261d04 	addi	r4,r4,-26508
81119868:	1105883a 	add	r2,r2,r4
8111986c:	10800017 	ldw	r2,0(r2)
81119870:	1000683a 	jmp	r2
81119874:	81119a08 	cmpgei	r4,r16,18024
81119878:	811198c8 	cmpgei	r4,r16,18019
8111987c:	811198c8 	cmpgei	r4,r16,18019
81119880:	811198c4 	addi	r4,r16,18019
81119884:	811199ec 	andhi	r4,r16,18023
81119888:	811199ec 	andhi	r4,r16,18023
8111988c:	811199d8 	cmpnei	r4,r16,18023
81119890:	811198c4 	addi	r4,r16,18019
81119894:	811199ec 	andhi	r4,r16,18023
81119898:	811199d8 	cmpnei	r4,r16,18023
8111989c:	811199ec 	andhi	r4,r16,18023
811198a0:	811198c4 	addi	r4,r16,18019
811198a4:	811199f8 	rdprs	r4,r16,18023
811198a8:	811199f8 	rdprs	r4,r16,18023
811198ac:	811199f8 	rdprs	r4,r16,18023
811198b0:	81119ad4 	ori	r4,r16,18027
811198b4:	90003b1e 	bne	r18,zero,811199a4 <__mulsf3+0x20c>
811198b8:	04400204 	movi	r17,8
811198bc:	05c00084 	movi	r23,2
811198c0:	003fd206 	br	8111980c <__reset+0xfb0f980c>
811198c4:	302b883a 	mov	r21,r6
811198c8:	00800084 	movi	r2,2
811198cc:	18802626 	beq	r3,r2,81119968 <__mulsf3+0x1d0>
811198d0:	008000c4 	movi	r2,3
811198d4:	1880ab26 	beq	r3,r2,81119b84 <__mulsf3+0x3ec>
811198d8:	00800044 	movi	r2,1
811198dc:	1880a21e 	bne	r3,r2,81119b68 <__mulsf3+0x3d0>
811198e0:	a829883a 	mov	r20,r21
811198e4:	0007883a 	mov	r3,zero
811198e8:	0009883a 	mov	r4,zero
811198ec:	18803fcc 	andi	r2,r3,255
811198f0:	100695fa 	slli	r3,r2,23
811198f4:	a0803fcc 	andi	r2,r20,255
811198f8:	100a97fa 	slli	r5,r2,31
811198fc:	00802034 	movhi	r2,128
81119900:	10bfffc4 	addi	r2,r2,-1
81119904:	2084703a 	and	r2,r4,r2
81119908:	10c4b03a 	or	r2,r2,r3
8111990c:	1144b03a 	or	r2,r2,r5
81119910:	dfc00a17 	ldw	ra,40(sp)
81119914:	df000917 	ldw	fp,36(sp)
81119918:	ddc00817 	ldw	r23,32(sp)
8111991c:	dd800717 	ldw	r22,28(sp)
81119920:	dd400617 	ldw	r21,24(sp)
81119924:	dd000517 	ldw	r20,20(sp)
81119928:	dcc00417 	ldw	r19,16(sp)
8111992c:	dc800317 	ldw	r18,12(sp)
81119930:	dc400217 	ldw	r17,8(sp)
81119934:	dc000117 	ldw	r16,4(sp)
81119938:	dec00b04 	addi	sp,sp,44
8111993c:	f800283a 	ret
81119940:	90000d1e 	bne	r18,zero,81119978 <__mulsf3+0x1e0>
81119944:	04400104 	movi	r17,4
81119948:	05c00044 	movi	r23,1
8111994c:	003faf06 	br	8111980c <__reset+0xfb0f980c>
81119950:	9806c03a 	cmpne	r3,r19,zero
81119954:	18c00084 	addi	r3,r3,2
81119958:	003fba06 	br	81119844 <__reset+0xfb0f9844>
8111995c:	9800141e 	bne	r19,zero,811199b0 <__mulsf3+0x218>
81119960:	00c00044 	movi	r3,1
81119964:	003fb706 	br	81119844 <__reset+0xfb0f9844>
81119968:	a829883a 	mov	r20,r21
8111996c:	00ffffc4 	movi	r3,-1
81119970:	0009883a 	mov	r4,zero
81119974:	003fdd06 	br	811198ec <__reset+0xfb0f98ec>
81119978:	9009883a 	mov	r4,r18
8111997c:	d9400015 	stw	r5,0(sp)
81119980:	111a7a00 	call	8111a7a0 <__clzsi2>
81119984:	10fffec4 	addi	r3,r2,-5
81119988:	10801d84 	addi	r2,r2,118
8111998c:	90e4983a 	sll	r18,r18,r3
81119990:	00a1c83a 	sub	r16,zero,r2
81119994:	0023883a 	mov	r17,zero
81119998:	002f883a 	mov	r23,zero
8111999c:	d9400017 	ldw	r5,0(sp)
811199a0:	003f9a06 	br	8111980c <__reset+0xfb0f980c>
811199a4:	04400304 	movi	r17,12
811199a8:	05c000c4 	movi	r23,3
811199ac:	003f9706 	br	8111980c <__reset+0xfb0f980c>
811199b0:	9809883a 	mov	r4,r19
811199b4:	d9800015 	stw	r6,0(sp)
811199b8:	111a7a00 	call	8111a7a0 <__clzsi2>
811199bc:	10fffec4 	addi	r3,r2,-5
811199c0:	10801d84 	addi	r2,r2,118
811199c4:	98e6983a 	sll	r19,r19,r3
811199c8:	0085c83a 	sub	r2,zero,r2
811199cc:	0007883a 	mov	r3,zero
811199d0:	d9800017 	ldw	r6,0(sp)
811199d4:	003f9b06 	br	81119844 <__reset+0xfb0f9844>
811199d8:	01002034 	movhi	r4,128
811199dc:	0029883a 	mov	r20,zero
811199e0:	213fffc4 	addi	r4,r4,-1
811199e4:	00ffffc4 	movi	r3,-1
811199e8:	003fc006 	br	811198ec <__reset+0xfb0f98ec>
811199ec:	9027883a 	mov	r19,r18
811199f0:	b807883a 	mov	r3,r23
811199f4:	003fb406 	br	811198c8 <__reset+0xfb0f98c8>
811199f8:	9027883a 	mov	r19,r18
811199fc:	e02b883a 	mov	r21,fp
81119a00:	b807883a 	mov	r3,r23
81119a04:	003fb006 	br	811198c8 <__reset+0xfb0f98c8>
81119a08:	9004d43a 	srli	r2,r18,16
81119a0c:	9810d43a 	srli	r8,r19,16
81119a10:	94bfffcc 	andi	r18,r18,65535
81119a14:	993fffcc 	andi	r4,r19,65535
81119a18:	910d383a 	mul	r6,r18,r4
81119a1c:	20a7383a 	mul	r19,r4,r2
81119a20:	9225383a 	mul	r18,r18,r8
81119a24:	3006d43a 	srli	r3,r6,16
81119a28:	1211383a 	mul	r8,r2,r8
81119a2c:	94e5883a 	add	r18,r18,r19
81119a30:	1c87883a 	add	r3,r3,r18
81119a34:	1cc0022e 	bgeu	r3,r19,81119a40 <__mulsf3+0x2a8>
81119a38:	00800074 	movhi	r2,1
81119a3c:	4091883a 	add	r8,r8,r2
81119a40:	1804943a 	slli	r2,r3,16
81119a44:	31bfffcc 	andi	r6,r6,65535
81119a48:	1806d43a 	srli	r3,r3,16
81119a4c:	1185883a 	add	r2,r2,r6
81119a50:	102691ba 	slli	r19,r2,6
81119a54:	1a07883a 	add	r3,r3,r8
81119a58:	1004d6ba 	srli	r2,r2,26
81119a5c:	180891ba 	slli	r4,r3,6
81119a60:	9826c03a 	cmpne	r19,r19,zero
81119a64:	9884b03a 	or	r2,r19,r2
81119a68:	1126b03a 	or	r19,r2,r4
81119a6c:	9882002c 	andhi	r2,r19,2048
81119a70:	10000426 	beq	r2,zero,81119a84 <__mulsf3+0x2ec>
81119a74:	9804d07a 	srli	r2,r19,1
81119a78:	9900004c 	andi	r4,r19,1
81119a7c:	3821883a 	mov	r16,r7
81119a80:	1126b03a 	or	r19,r2,r4
81119a84:	80c01fc4 	addi	r3,r16,127
81119a88:	00c0210e 	bge	zero,r3,81119b10 <__mulsf3+0x378>
81119a8c:	988001cc 	andi	r2,r19,7
81119a90:	10000426 	beq	r2,zero,81119aa4 <__mulsf3+0x30c>
81119a94:	988003cc 	andi	r2,r19,15
81119a98:	01000104 	movi	r4,4
81119a9c:	11000126 	beq	r2,r4,81119aa4 <__mulsf3+0x30c>
81119aa0:	9927883a 	add	r19,r19,r4
81119aa4:	9882002c 	andhi	r2,r19,2048
81119aa8:	10000426 	beq	r2,zero,81119abc <__mulsf3+0x324>
81119aac:	00be0034 	movhi	r2,63488
81119ab0:	10bfffc4 	addi	r2,r2,-1
81119ab4:	80c02004 	addi	r3,r16,128
81119ab8:	98a6703a 	and	r19,r19,r2
81119abc:	00803f84 	movi	r2,254
81119ac0:	10ffa916 	blt	r2,r3,81119968 <__reset+0xfb0f9968>
81119ac4:	980891ba 	slli	r4,r19,6
81119ac8:	a829883a 	mov	r20,r21
81119acc:	2008d27a 	srli	r4,r4,9
81119ad0:	003f8606 	br	811198ec <__reset+0xfb0f98ec>
81119ad4:	9080102c 	andhi	r2,r18,64
81119ad8:	10000826 	beq	r2,zero,81119afc <__mulsf3+0x364>
81119adc:	9880102c 	andhi	r2,r19,64
81119ae0:	1000061e 	bne	r2,zero,81119afc <__mulsf3+0x364>
81119ae4:	00802034 	movhi	r2,128
81119ae8:	99001034 	orhi	r4,r19,64
81119aec:	10bfffc4 	addi	r2,r2,-1
81119af0:	b029883a 	mov	r20,r22
81119af4:	2088703a 	and	r4,r4,r2
81119af8:	003fba06 	br	811199e4 <__reset+0xfb0f99e4>
81119afc:	00802034 	movhi	r2,128
81119b00:	91001034 	orhi	r4,r18,64
81119b04:	10bfffc4 	addi	r2,r2,-1
81119b08:	2088703a 	and	r4,r4,r2
81119b0c:	003fb506 	br	811199e4 <__reset+0xfb0f99e4>
81119b10:	00800044 	movi	r2,1
81119b14:	10c7c83a 	sub	r3,r2,r3
81119b18:	008006c4 	movi	r2,27
81119b1c:	10ff7016 	blt	r2,r3,811198e0 <__reset+0xfb0f98e0>
81119b20:	00800804 	movi	r2,32
81119b24:	10c5c83a 	sub	r2,r2,r3
81119b28:	9884983a 	sll	r2,r19,r2
81119b2c:	98c6d83a 	srl	r3,r19,r3
81119b30:	1004c03a 	cmpne	r2,r2,zero
81119b34:	1884b03a 	or	r2,r3,r2
81119b38:	10c001cc 	andi	r3,r2,7
81119b3c:	18000426 	beq	r3,zero,81119b50 <__mulsf3+0x3b8>
81119b40:	10c003cc 	andi	r3,r2,15
81119b44:	01000104 	movi	r4,4
81119b48:	19000126 	beq	r3,r4,81119b50 <__mulsf3+0x3b8>
81119b4c:	1105883a 	add	r2,r2,r4
81119b50:	10c1002c 	andhi	r3,r2,1024
81119b54:	18000626 	beq	r3,zero,81119b70 <__mulsf3+0x3d8>
81119b58:	a829883a 	mov	r20,r21
81119b5c:	00c00044 	movi	r3,1
81119b60:	0009883a 	mov	r4,zero
81119b64:	003f6106 	br	811198ec <__reset+0xfb0f98ec>
81119b68:	3821883a 	mov	r16,r7
81119b6c:	003fc506 	br	81119a84 <__reset+0xfb0f9a84>
81119b70:	100491ba 	slli	r2,r2,6
81119b74:	a829883a 	mov	r20,r21
81119b78:	0007883a 	mov	r3,zero
81119b7c:	1008d27a 	srli	r4,r2,9
81119b80:	003f5a06 	br	811198ec <__reset+0xfb0f98ec>
81119b84:	00802034 	movhi	r2,128
81119b88:	99001034 	orhi	r4,r19,64
81119b8c:	10bfffc4 	addi	r2,r2,-1
81119b90:	a829883a 	mov	r20,r21
81119b94:	2088703a 	and	r4,r4,r2
81119b98:	003f9206 	br	811199e4 <__reset+0xfb0f99e4>

81119b9c <__floatsisf>:
81119b9c:	defffd04 	addi	sp,sp,-12
81119ba0:	de00012e 	bgeu	sp,et,81119ba8 <__floatsisf+0xc>
81119ba4:	003b68fa 	trap	3
81119ba8:	dfc00215 	stw	ra,8(sp)
81119bac:	dc400115 	stw	r17,4(sp)
81119bb0:	dc000015 	stw	r16,0(sp)
81119bb4:	20003526 	beq	r4,zero,81119c8c <__floatsisf+0xf0>
81119bb8:	2021883a 	mov	r16,r4
81119bbc:	2022d7fa 	srli	r17,r4,31
81119bc0:	20003616 	blt	r4,zero,81119c9c <__floatsisf+0x100>
81119bc4:	8009883a 	mov	r4,r16
81119bc8:	111a7a00 	call	8111a7a0 <__clzsi2>
81119bcc:	00c02784 	movi	r3,158
81119bd0:	1887c83a 	sub	r3,r3,r2
81119bd4:	01002584 	movi	r4,150
81119bd8:	20c01416 	blt	r4,r3,81119c2c <__floatsisf+0x90>
81119bdc:	20c9c83a 	sub	r4,r4,r3
81119be0:	8120983a 	sll	r16,r16,r4
81119be4:	00802034 	movhi	r2,128
81119be8:	10bfffc4 	addi	r2,r2,-1
81119bec:	8809883a 	mov	r4,r17
81119bf0:	80a0703a 	and	r16,r16,r2
81119bf4:	18803fcc 	andi	r2,r3,255
81119bf8:	100695fa 	slli	r3,r2,23
81119bfc:	20803fcc 	andi	r2,r4,255
81119c00:	100897fa 	slli	r4,r2,31
81119c04:	00802034 	movhi	r2,128
81119c08:	10bfffc4 	addi	r2,r2,-1
81119c0c:	8084703a 	and	r2,r16,r2
81119c10:	10c4b03a 	or	r2,r2,r3
81119c14:	1104b03a 	or	r2,r2,r4
81119c18:	dfc00217 	ldw	ra,8(sp)
81119c1c:	dc400117 	ldw	r17,4(sp)
81119c20:	dc000017 	ldw	r16,0(sp)
81119c24:	dec00304 	addi	sp,sp,12
81119c28:	f800283a 	ret
81119c2c:	01002644 	movi	r4,153
81119c30:	20c01c16 	blt	r4,r3,81119ca4 <__floatsisf+0x108>
81119c34:	20c9c83a 	sub	r4,r4,r3
81119c38:	8120983a 	sll	r16,r16,r4
81119c3c:	013f0034 	movhi	r4,64512
81119c40:	213fffc4 	addi	r4,r4,-1
81119c44:	814001cc 	andi	r5,r16,7
81119c48:	8108703a 	and	r4,r16,r4
81119c4c:	28000426 	beq	r5,zero,81119c60 <__floatsisf+0xc4>
81119c50:	840003cc 	andi	r16,r16,15
81119c54:	01400104 	movi	r5,4
81119c58:	81400126 	beq	r16,r5,81119c60 <__floatsisf+0xc4>
81119c5c:	2149883a 	add	r4,r4,r5
81119c60:	2141002c 	andhi	r5,r4,1024
81119c64:	28000526 	beq	r5,zero,81119c7c <__floatsisf+0xe0>
81119c68:	00c027c4 	movi	r3,159
81119c6c:	1887c83a 	sub	r3,r3,r2
81119c70:	00bf0034 	movhi	r2,64512
81119c74:	10bfffc4 	addi	r2,r2,-1
81119c78:	2088703a 	and	r4,r4,r2
81119c7c:	202091ba 	slli	r16,r4,6
81119c80:	8809883a 	mov	r4,r17
81119c84:	8020d27a 	srli	r16,r16,9
81119c88:	003fda06 	br	81119bf4 <__reset+0xfb0f9bf4>
81119c8c:	0009883a 	mov	r4,zero
81119c90:	0007883a 	mov	r3,zero
81119c94:	0021883a 	mov	r16,zero
81119c98:	003fd606 	br	81119bf4 <__reset+0xfb0f9bf4>
81119c9c:	0121c83a 	sub	r16,zero,r4
81119ca0:	003fc806 	br	81119bc4 <__reset+0xfb0f9bc4>
81119ca4:	01002e44 	movi	r4,185
81119ca8:	20c9c83a 	sub	r4,r4,r3
81119cac:	01400144 	movi	r5,5
81119cb0:	8108983a 	sll	r4,r16,r4
81119cb4:	288bc83a 	sub	r5,r5,r2
81119cb8:	8160d83a 	srl	r16,r16,r5
81119cbc:	2008c03a 	cmpne	r4,r4,zero
81119cc0:	8120b03a 	or	r16,r16,r4
81119cc4:	003fdd06 	br	81119c3c <__reset+0xfb0f9c3c>

81119cc8 <__floatunsisf>:
81119cc8:	defffe04 	addi	sp,sp,-8
81119ccc:	de00012e 	bgeu	sp,et,81119cd4 <__floatunsisf+0xc>
81119cd0:	003b68fa 	trap	3
81119cd4:	dfc00115 	stw	ra,4(sp)
81119cd8:	dc000015 	stw	r16,0(sp)
81119cdc:	20002c26 	beq	r4,zero,81119d90 <__floatunsisf+0xc8>
81119ce0:	2021883a 	mov	r16,r4
81119ce4:	111a7a00 	call	8111a7a0 <__clzsi2>
81119ce8:	00c02784 	movi	r3,158
81119cec:	1887c83a 	sub	r3,r3,r2
81119cf0:	01002584 	movi	r4,150
81119cf4:	20c00f16 	blt	r4,r3,81119d34 <__floatunsisf+0x6c>
81119cf8:	20c9c83a 	sub	r4,r4,r3
81119cfc:	8108983a 	sll	r4,r16,r4
81119d00:	00802034 	movhi	r2,128
81119d04:	10bfffc4 	addi	r2,r2,-1
81119d08:	2088703a 	and	r4,r4,r2
81119d0c:	18803fcc 	andi	r2,r3,255
81119d10:	100695fa 	slli	r3,r2,23
81119d14:	00802034 	movhi	r2,128
81119d18:	10bfffc4 	addi	r2,r2,-1
81119d1c:	2084703a 	and	r2,r4,r2
81119d20:	10c4b03a 	or	r2,r2,r3
81119d24:	dfc00117 	ldw	ra,4(sp)
81119d28:	dc000017 	ldw	r16,0(sp)
81119d2c:	dec00204 	addi	sp,sp,8
81119d30:	f800283a 	ret
81119d34:	01002644 	movi	r4,153
81119d38:	20c01816 	blt	r4,r3,81119d9c <__floatunsisf+0xd4>
81119d3c:	20c9c83a 	sub	r4,r4,r3
81119d40:	8108983a 	sll	r4,r16,r4
81119d44:	017f0034 	movhi	r5,64512
81119d48:	297fffc4 	addi	r5,r5,-1
81119d4c:	218001cc 	andi	r6,r4,7
81119d50:	214a703a 	and	r5,r4,r5
81119d54:	30000426 	beq	r6,zero,81119d68 <__floatunsisf+0xa0>
81119d58:	210003cc 	andi	r4,r4,15
81119d5c:	01800104 	movi	r6,4
81119d60:	21800126 	beq	r4,r6,81119d68 <__floatunsisf+0xa0>
81119d64:	298b883a 	add	r5,r5,r6
81119d68:	2901002c 	andhi	r4,r5,1024
81119d6c:	20000526 	beq	r4,zero,81119d84 <__floatunsisf+0xbc>
81119d70:	00c027c4 	movi	r3,159
81119d74:	1887c83a 	sub	r3,r3,r2
81119d78:	00bf0034 	movhi	r2,64512
81119d7c:	10bfffc4 	addi	r2,r2,-1
81119d80:	288a703a 	and	r5,r5,r2
81119d84:	280891ba 	slli	r4,r5,6
81119d88:	2008d27a 	srli	r4,r4,9
81119d8c:	003fdf06 	br	81119d0c <__reset+0xfb0f9d0c>
81119d90:	0007883a 	mov	r3,zero
81119d94:	0009883a 	mov	r4,zero
81119d98:	003fdc06 	br	81119d0c <__reset+0xfb0f9d0c>
81119d9c:	01402e44 	movi	r5,185
81119da0:	28cbc83a 	sub	r5,r5,r3
81119da4:	01000144 	movi	r4,5
81119da8:	2089c83a 	sub	r4,r4,r2
81119dac:	814a983a 	sll	r5,r16,r5
81119db0:	8108d83a 	srl	r4,r16,r4
81119db4:	2820c03a 	cmpne	r16,r5,zero
81119db8:	2408b03a 	or	r4,r4,r16
81119dbc:	003fe106 	br	81119d44 <__reset+0xfb0f9d44>

81119dc0 <__muldf3>:
81119dc0:	defff304 	addi	sp,sp,-52
81119dc4:	2804d53a 	srli	r2,r5,20
81119dc8:	de00012e 	bgeu	sp,et,81119dd0 <__muldf3+0x10>
81119dcc:	003b68fa 	trap	3
81119dd0:	dd800915 	stw	r22,36(sp)
81119dd4:	282cd7fa 	srli	r22,r5,31
81119dd8:	dc000315 	stw	r16,12(sp)
81119ddc:	04000434 	movhi	r16,16
81119de0:	dd400815 	stw	r21,32(sp)
81119de4:	dc800515 	stw	r18,20(sp)
81119de8:	843fffc4 	addi	r16,r16,-1
81119dec:	dfc00c15 	stw	ra,48(sp)
81119df0:	df000b15 	stw	fp,44(sp)
81119df4:	ddc00a15 	stw	r23,40(sp)
81119df8:	dd000715 	stw	r20,28(sp)
81119dfc:	dcc00615 	stw	r19,24(sp)
81119e00:	dc400415 	stw	r17,16(sp)
81119e04:	1481ffcc 	andi	r18,r2,2047
81119e08:	2c20703a 	and	r16,r5,r16
81119e0c:	b02b883a 	mov	r21,r22
81119e10:	b2403fcc 	andi	r9,r22,255
81119e14:	90006026 	beq	r18,zero,81119f98 <__muldf3+0x1d8>
81119e18:	0081ffc4 	movi	r2,2047
81119e1c:	2029883a 	mov	r20,r4
81119e20:	90803626 	beq	r18,r2,81119efc <__muldf3+0x13c>
81119e24:	80800434 	orhi	r2,r16,16
81119e28:	100490fa 	slli	r2,r2,3
81119e2c:	2020d77a 	srli	r16,r4,29
81119e30:	202890fa 	slli	r20,r4,3
81119e34:	94bf0044 	addi	r18,r18,-1023
81119e38:	80a0b03a 	or	r16,r16,r2
81119e3c:	0027883a 	mov	r19,zero
81119e40:	0039883a 	mov	fp,zero
81119e44:	3804d53a 	srli	r2,r7,20
81119e48:	382ed7fa 	srli	r23,r7,31
81119e4c:	04400434 	movhi	r17,16
81119e50:	8c7fffc4 	addi	r17,r17,-1
81119e54:	1081ffcc 	andi	r2,r2,2047
81119e58:	3011883a 	mov	r8,r6
81119e5c:	3c62703a 	and	r17,r7,r17
81119e60:	ba803fcc 	andi	r10,r23,255
81119e64:	10006d26 	beq	r2,zero,8111a01c <__muldf3+0x25c>
81119e68:	00c1ffc4 	movi	r3,2047
81119e6c:	10c06526 	beq	r2,r3,8111a004 <__muldf3+0x244>
81119e70:	88c00434 	orhi	r3,r17,16
81119e74:	180690fa 	slli	r3,r3,3
81119e78:	3022d77a 	srli	r17,r6,29
81119e7c:	301090fa 	slli	r8,r6,3
81119e80:	10bf0044 	addi	r2,r2,-1023
81119e84:	88e2b03a 	or	r17,r17,r3
81119e88:	000b883a 	mov	r5,zero
81119e8c:	9085883a 	add	r2,r18,r2
81119e90:	2cc8b03a 	or	r4,r5,r19
81119e94:	00c003c4 	movi	r3,15
81119e98:	bdacf03a 	xor	r22,r23,r22
81119e9c:	12c00044 	addi	r11,r2,1
81119ea0:	19009936 	bltu	r3,r4,8111a108 <__muldf3+0x348>
81119ea4:	200890ba 	slli	r4,r4,2
81119ea8:	00e044b4 	movhi	r3,33042
81119eac:	18e7af04 	addi	r3,r3,-24900
81119eb0:	20c9883a 	add	r4,r4,r3
81119eb4:	20c00017 	ldw	r3,0(r4)
81119eb8:	1800683a 	jmp	r3
81119ebc:	8111a108 	cmpgei	r4,r16,18052
81119ec0:	81119f1c 	xori	r4,r16,18044
81119ec4:	81119f1c 	xori	r4,r16,18044
81119ec8:	81119f18 	cmpnei	r4,r16,18044
81119ecc:	8111a0e4 	muli	r4,r16,18051
81119ed0:	8111a0e4 	muli	r4,r16,18051
81119ed4:	8111a0cc 	andi	r4,r16,18051
81119ed8:	81119f18 	cmpnei	r4,r16,18044
81119edc:	8111a0e4 	muli	r4,r16,18051
81119ee0:	8111a0cc 	andi	r4,r16,18051
81119ee4:	8111a0e4 	muli	r4,r16,18051
81119ee8:	81119f18 	cmpnei	r4,r16,18044
81119eec:	8111a0f4 	orhi	r4,r16,18051
81119ef0:	8111a0f4 	orhi	r4,r16,18051
81119ef4:	8111a0f4 	orhi	r4,r16,18051
81119ef8:	8111a310 	cmplti	r4,r16,18060
81119efc:	2404b03a 	or	r2,r4,r16
81119f00:	10006f1e 	bne	r2,zero,8111a0c0 <__muldf3+0x300>
81119f04:	04c00204 	movi	r19,8
81119f08:	0021883a 	mov	r16,zero
81119f0c:	0029883a 	mov	r20,zero
81119f10:	07000084 	movi	fp,2
81119f14:	003fcb06 	br	81119e44 <__reset+0xfb0f9e44>
81119f18:	502d883a 	mov	r22,r10
81119f1c:	00800084 	movi	r2,2
81119f20:	28805726 	beq	r5,r2,8111a080 <__muldf3+0x2c0>
81119f24:	008000c4 	movi	r2,3
81119f28:	28816626 	beq	r5,r2,8111a4c4 <__muldf3+0x704>
81119f2c:	00800044 	movi	r2,1
81119f30:	2881411e 	bne	r5,r2,8111a438 <__muldf3+0x678>
81119f34:	b02b883a 	mov	r21,r22
81119f38:	0005883a 	mov	r2,zero
81119f3c:	000b883a 	mov	r5,zero
81119f40:	0029883a 	mov	r20,zero
81119f44:	1004953a 	slli	r2,r2,20
81119f48:	a8c03fcc 	andi	r3,r21,255
81119f4c:	04400434 	movhi	r17,16
81119f50:	8c7fffc4 	addi	r17,r17,-1
81119f54:	180697fa 	slli	r3,r3,31
81119f58:	2c4a703a 	and	r5,r5,r17
81119f5c:	288ab03a 	or	r5,r5,r2
81119f60:	28c6b03a 	or	r3,r5,r3
81119f64:	a005883a 	mov	r2,r20
81119f68:	dfc00c17 	ldw	ra,48(sp)
81119f6c:	df000b17 	ldw	fp,44(sp)
81119f70:	ddc00a17 	ldw	r23,40(sp)
81119f74:	dd800917 	ldw	r22,36(sp)
81119f78:	dd400817 	ldw	r21,32(sp)
81119f7c:	dd000717 	ldw	r20,28(sp)
81119f80:	dcc00617 	ldw	r19,24(sp)
81119f84:	dc800517 	ldw	r18,20(sp)
81119f88:	dc400417 	ldw	r17,16(sp)
81119f8c:	dc000317 	ldw	r16,12(sp)
81119f90:	dec00d04 	addi	sp,sp,52
81119f94:	f800283a 	ret
81119f98:	2404b03a 	or	r2,r4,r16
81119f9c:	2027883a 	mov	r19,r4
81119fa0:	10004226 	beq	r2,zero,8111a0ac <__muldf3+0x2ec>
81119fa4:	8000fc26 	beq	r16,zero,8111a398 <__muldf3+0x5d8>
81119fa8:	8009883a 	mov	r4,r16
81119fac:	d9800215 	stw	r6,8(sp)
81119fb0:	d9c00015 	stw	r7,0(sp)
81119fb4:	da400115 	stw	r9,4(sp)
81119fb8:	111a7a00 	call	8111a7a0 <__clzsi2>
81119fbc:	d9800217 	ldw	r6,8(sp)
81119fc0:	d9c00017 	ldw	r7,0(sp)
81119fc4:	da400117 	ldw	r9,4(sp)
81119fc8:	113ffd44 	addi	r4,r2,-11
81119fcc:	00c00704 	movi	r3,28
81119fd0:	1900ed16 	blt	r3,r4,8111a388 <__muldf3+0x5c8>
81119fd4:	00c00744 	movi	r3,29
81119fd8:	147ffe04 	addi	r17,r2,-8
81119fdc:	1907c83a 	sub	r3,r3,r4
81119fe0:	8460983a 	sll	r16,r16,r17
81119fe4:	98c6d83a 	srl	r3,r19,r3
81119fe8:	9c68983a 	sll	r20,r19,r17
81119fec:	1c20b03a 	or	r16,r3,r16
81119ff0:	1080fcc4 	addi	r2,r2,1011
81119ff4:	00a5c83a 	sub	r18,zero,r2
81119ff8:	0027883a 	mov	r19,zero
81119ffc:	0039883a 	mov	fp,zero
8111a000:	003f9006 	br	81119e44 <__reset+0xfb0f9e44>
8111a004:	3446b03a 	or	r3,r6,r17
8111a008:	1800261e 	bne	r3,zero,8111a0a4 <__muldf3+0x2e4>
8111a00c:	0023883a 	mov	r17,zero
8111a010:	0011883a 	mov	r8,zero
8111a014:	01400084 	movi	r5,2
8111a018:	003f9c06 	br	81119e8c <__reset+0xfb0f9e8c>
8111a01c:	3446b03a 	or	r3,r6,r17
8111a020:	18001c26 	beq	r3,zero,8111a094 <__muldf3+0x2d4>
8111a024:	8800ce26 	beq	r17,zero,8111a360 <__muldf3+0x5a0>
8111a028:	8809883a 	mov	r4,r17
8111a02c:	d9800215 	stw	r6,8(sp)
8111a030:	da400115 	stw	r9,4(sp)
8111a034:	da800015 	stw	r10,0(sp)
8111a038:	111a7a00 	call	8111a7a0 <__clzsi2>
8111a03c:	d9800217 	ldw	r6,8(sp)
8111a040:	da400117 	ldw	r9,4(sp)
8111a044:	da800017 	ldw	r10,0(sp)
8111a048:	113ffd44 	addi	r4,r2,-11
8111a04c:	00c00704 	movi	r3,28
8111a050:	1900bf16 	blt	r3,r4,8111a350 <__muldf3+0x590>
8111a054:	00c00744 	movi	r3,29
8111a058:	123ffe04 	addi	r8,r2,-8
8111a05c:	1907c83a 	sub	r3,r3,r4
8111a060:	8a22983a 	sll	r17,r17,r8
8111a064:	30c6d83a 	srl	r3,r6,r3
8111a068:	3210983a 	sll	r8,r6,r8
8111a06c:	1c62b03a 	or	r17,r3,r17
8111a070:	1080fcc4 	addi	r2,r2,1011
8111a074:	0085c83a 	sub	r2,zero,r2
8111a078:	000b883a 	mov	r5,zero
8111a07c:	003f8306 	br	81119e8c <__reset+0xfb0f9e8c>
8111a080:	b02b883a 	mov	r21,r22
8111a084:	0081ffc4 	movi	r2,2047
8111a088:	000b883a 	mov	r5,zero
8111a08c:	0029883a 	mov	r20,zero
8111a090:	003fac06 	br	81119f44 <__reset+0xfb0f9f44>
8111a094:	0023883a 	mov	r17,zero
8111a098:	0011883a 	mov	r8,zero
8111a09c:	01400044 	movi	r5,1
8111a0a0:	003f7a06 	br	81119e8c <__reset+0xfb0f9e8c>
8111a0a4:	014000c4 	movi	r5,3
8111a0a8:	003f7806 	br	81119e8c <__reset+0xfb0f9e8c>
8111a0ac:	04c00104 	movi	r19,4
8111a0b0:	0021883a 	mov	r16,zero
8111a0b4:	0029883a 	mov	r20,zero
8111a0b8:	07000044 	movi	fp,1
8111a0bc:	003f6106 	br	81119e44 <__reset+0xfb0f9e44>
8111a0c0:	04c00304 	movi	r19,12
8111a0c4:	070000c4 	movi	fp,3
8111a0c8:	003f5e06 	br	81119e44 <__reset+0xfb0f9e44>
8111a0cc:	01400434 	movhi	r5,16
8111a0d0:	002b883a 	mov	r21,zero
8111a0d4:	297fffc4 	addi	r5,r5,-1
8111a0d8:	053fffc4 	movi	r20,-1
8111a0dc:	0081ffc4 	movi	r2,2047
8111a0e0:	003f9806 	br	81119f44 <__reset+0xfb0f9f44>
8111a0e4:	8023883a 	mov	r17,r16
8111a0e8:	a011883a 	mov	r8,r20
8111a0ec:	e00b883a 	mov	r5,fp
8111a0f0:	003f8a06 	br	81119f1c <__reset+0xfb0f9f1c>
8111a0f4:	8023883a 	mov	r17,r16
8111a0f8:	a011883a 	mov	r8,r20
8111a0fc:	482d883a 	mov	r22,r9
8111a100:	e00b883a 	mov	r5,fp
8111a104:	003f8506 	br	81119f1c <__reset+0xfb0f9f1c>
8111a108:	a00ad43a 	srli	r5,r20,16
8111a10c:	401ad43a 	srli	r13,r8,16
8111a110:	a53fffcc 	andi	r20,r20,65535
8111a114:	423fffcc 	andi	r8,r8,65535
8111a118:	4519383a 	mul	r12,r8,r20
8111a11c:	4147383a 	mul	r3,r8,r5
8111a120:	6d09383a 	mul	r4,r13,r20
8111a124:	600cd43a 	srli	r6,r12,16
8111a128:	2b5d383a 	mul	r14,r5,r13
8111a12c:	20c9883a 	add	r4,r4,r3
8111a130:	310d883a 	add	r6,r6,r4
8111a134:	30c0022e 	bgeu	r6,r3,8111a140 <__muldf3+0x380>
8111a138:	00c00074 	movhi	r3,1
8111a13c:	70dd883a 	add	r14,r14,r3
8111a140:	8826d43a 	srli	r19,r17,16
8111a144:	8bffffcc 	andi	r15,r17,65535
8111a148:	7d23383a 	mul	r17,r15,r20
8111a14c:	7949383a 	mul	r4,r15,r5
8111a150:	9d29383a 	mul	r20,r19,r20
8111a154:	8814d43a 	srli	r10,r17,16
8111a158:	3012943a 	slli	r9,r6,16
8111a15c:	a129883a 	add	r20,r20,r4
8111a160:	633fffcc 	andi	r12,r12,65535
8111a164:	5515883a 	add	r10,r10,r20
8111a168:	3006d43a 	srli	r3,r6,16
8111a16c:	4b13883a 	add	r9,r9,r12
8111a170:	2ccb383a 	mul	r5,r5,r19
8111a174:	5100022e 	bgeu	r10,r4,8111a180 <__muldf3+0x3c0>
8111a178:	01000074 	movhi	r4,1
8111a17c:	290b883a 	add	r5,r5,r4
8111a180:	802ad43a 	srli	r21,r16,16
8111a184:	843fffcc 	andi	r16,r16,65535
8111a188:	440d383a 	mul	r6,r8,r16
8111a18c:	4565383a 	mul	r18,r8,r21
8111a190:	8349383a 	mul	r4,r16,r13
8111a194:	500e943a 	slli	r7,r10,16
8111a198:	3010d43a 	srli	r8,r6,16
8111a19c:	5028d43a 	srli	r20,r10,16
8111a1a0:	2489883a 	add	r4,r4,r18
8111a1a4:	8abfffcc 	andi	r10,r17,65535
8111a1a8:	3a95883a 	add	r10,r7,r10
8111a1ac:	4119883a 	add	r12,r8,r4
8111a1b0:	a169883a 	add	r20,r20,r5
8111a1b4:	1a87883a 	add	r3,r3,r10
8111a1b8:	6d5b383a 	mul	r13,r13,r21
8111a1bc:	6480022e 	bgeu	r12,r18,8111a1c8 <__muldf3+0x408>
8111a1c0:	01000074 	movhi	r4,1
8111a1c4:	691b883a 	add	r13,r13,r4
8111a1c8:	7c25383a 	mul	r18,r15,r16
8111a1cc:	7d4b383a 	mul	r5,r15,r21
8111a1d0:	84cf383a 	mul	r7,r16,r19
8111a1d4:	901ed43a 	srli	r15,r18,16
8111a1d8:	6008d43a 	srli	r4,r12,16
8111a1dc:	6010943a 	slli	r8,r12,16
8111a1e0:	394f883a 	add	r7,r7,r5
8111a1e4:	333fffcc 	andi	r12,r6,65535
8111a1e8:	79df883a 	add	r15,r15,r7
8111a1ec:	235b883a 	add	r13,r4,r13
8111a1f0:	9d63383a 	mul	r17,r19,r21
8111a1f4:	4309883a 	add	r4,r8,r12
8111a1f8:	7940022e 	bgeu	r15,r5,8111a204 <__muldf3+0x444>
8111a1fc:	01400074 	movhi	r5,1
8111a200:	8963883a 	add	r17,r17,r5
8111a204:	780a943a 	slli	r5,r15,16
8111a208:	91bfffcc 	andi	r6,r18,65535
8111a20c:	70c7883a 	add	r3,r14,r3
8111a210:	298d883a 	add	r6,r5,r6
8111a214:	1a8f803a 	cmpltu	r7,r3,r10
8111a218:	350b883a 	add	r5,r6,r20
8111a21c:	20c7883a 	add	r3,r4,r3
8111a220:	3955883a 	add	r10,r7,r5
8111a224:	1909803a 	cmpltu	r4,r3,r4
8111a228:	6a91883a 	add	r8,r13,r10
8111a22c:	780cd43a 	srli	r6,r15,16
8111a230:	2219883a 	add	r12,r4,r8
8111a234:	2d0b803a 	cmpltu	r5,r5,r20
8111a238:	51cf803a 	cmpltu	r7,r10,r7
8111a23c:	29ceb03a 	or	r7,r5,r7
8111a240:	4351803a 	cmpltu	r8,r8,r13
8111a244:	610b803a 	cmpltu	r5,r12,r4
8111a248:	4148b03a 	or	r4,r8,r5
8111a24c:	398f883a 	add	r7,r7,r6
8111a250:	3909883a 	add	r4,r7,r4
8111a254:	1810927a 	slli	r8,r3,9
8111a258:	2449883a 	add	r4,r4,r17
8111a25c:	2008927a 	slli	r4,r4,9
8111a260:	6022d5fa 	srli	r17,r12,23
8111a264:	1806d5fa 	srli	r3,r3,23
8111a268:	4252b03a 	or	r9,r8,r9
8111a26c:	600a927a 	slli	r5,r12,9
8111a270:	4810c03a 	cmpne	r8,r9,zero
8111a274:	2462b03a 	or	r17,r4,r17
8111a278:	40c6b03a 	or	r3,r8,r3
8111a27c:	8900402c 	andhi	r4,r17,256
8111a280:	1950b03a 	or	r8,r3,r5
8111a284:	20000726 	beq	r4,zero,8111a2a4 <__muldf3+0x4e4>
8111a288:	4006d07a 	srli	r3,r8,1
8111a28c:	880497fa 	slli	r2,r17,31
8111a290:	4200004c 	andi	r8,r8,1
8111a294:	8822d07a 	srli	r17,r17,1
8111a298:	1a10b03a 	or	r8,r3,r8
8111a29c:	1210b03a 	or	r8,r2,r8
8111a2a0:	5805883a 	mov	r2,r11
8111a2a4:	1140ffc4 	addi	r5,r2,1023
8111a2a8:	0140440e 	bge	zero,r5,8111a3bc <__muldf3+0x5fc>
8111a2ac:	40c001cc 	andi	r3,r8,7
8111a2b0:	18000726 	beq	r3,zero,8111a2d0 <__muldf3+0x510>
8111a2b4:	40c003cc 	andi	r3,r8,15
8111a2b8:	01000104 	movi	r4,4
8111a2bc:	19000426 	beq	r3,r4,8111a2d0 <__muldf3+0x510>
8111a2c0:	4107883a 	add	r3,r8,r4
8111a2c4:	1a11803a 	cmpltu	r8,r3,r8
8111a2c8:	8a23883a 	add	r17,r17,r8
8111a2cc:	1811883a 	mov	r8,r3
8111a2d0:	88c0402c 	andhi	r3,r17,256
8111a2d4:	18000426 	beq	r3,zero,8111a2e8 <__muldf3+0x528>
8111a2d8:	11410004 	addi	r5,r2,1024
8111a2dc:	00bfc034 	movhi	r2,65280
8111a2e0:	10bfffc4 	addi	r2,r2,-1
8111a2e4:	88a2703a 	and	r17,r17,r2
8111a2e8:	0081ff84 	movi	r2,2046
8111a2ec:	117f6416 	blt	r2,r5,8111a080 <__reset+0xfb0fa080>
8111a2f0:	8828977a 	slli	r20,r17,29
8111a2f4:	4010d0fa 	srli	r8,r8,3
8111a2f8:	8822927a 	slli	r17,r17,9
8111a2fc:	2881ffcc 	andi	r2,r5,2047
8111a300:	a228b03a 	or	r20,r20,r8
8111a304:	880ad33a 	srli	r5,r17,12
8111a308:	b02b883a 	mov	r21,r22
8111a30c:	003f0d06 	br	81119f44 <__reset+0xfb0f9f44>
8111a310:	8080022c 	andhi	r2,r16,8
8111a314:	10000926 	beq	r2,zero,8111a33c <__muldf3+0x57c>
8111a318:	8880022c 	andhi	r2,r17,8
8111a31c:	1000071e 	bne	r2,zero,8111a33c <__muldf3+0x57c>
8111a320:	00800434 	movhi	r2,16
8111a324:	89400234 	orhi	r5,r17,8
8111a328:	10bfffc4 	addi	r2,r2,-1
8111a32c:	b82b883a 	mov	r21,r23
8111a330:	288a703a 	and	r5,r5,r2
8111a334:	4029883a 	mov	r20,r8
8111a338:	003f6806 	br	8111a0dc <__reset+0xfb0fa0dc>
8111a33c:	00800434 	movhi	r2,16
8111a340:	81400234 	orhi	r5,r16,8
8111a344:	10bfffc4 	addi	r2,r2,-1
8111a348:	288a703a 	and	r5,r5,r2
8111a34c:	003f6306 	br	8111a0dc <__reset+0xfb0fa0dc>
8111a350:	147ff604 	addi	r17,r2,-40
8111a354:	3462983a 	sll	r17,r6,r17
8111a358:	0011883a 	mov	r8,zero
8111a35c:	003f4406 	br	8111a070 <__reset+0xfb0fa070>
8111a360:	3009883a 	mov	r4,r6
8111a364:	d9800215 	stw	r6,8(sp)
8111a368:	da400115 	stw	r9,4(sp)
8111a36c:	da800015 	stw	r10,0(sp)
8111a370:	111a7a00 	call	8111a7a0 <__clzsi2>
8111a374:	10800804 	addi	r2,r2,32
8111a378:	da800017 	ldw	r10,0(sp)
8111a37c:	da400117 	ldw	r9,4(sp)
8111a380:	d9800217 	ldw	r6,8(sp)
8111a384:	003f3006 	br	8111a048 <__reset+0xfb0fa048>
8111a388:	143ff604 	addi	r16,r2,-40
8111a38c:	9c20983a 	sll	r16,r19,r16
8111a390:	0029883a 	mov	r20,zero
8111a394:	003f1606 	br	81119ff0 <__reset+0xfb0f9ff0>
8111a398:	d9800215 	stw	r6,8(sp)
8111a39c:	d9c00015 	stw	r7,0(sp)
8111a3a0:	da400115 	stw	r9,4(sp)
8111a3a4:	111a7a00 	call	8111a7a0 <__clzsi2>
8111a3a8:	10800804 	addi	r2,r2,32
8111a3ac:	da400117 	ldw	r9,4(sp)
8111a3b0:	d9c00017 	ldw	r7,0(sp)
8111a3b4:	d9800217 	ldw	r6,8(sp)
8111a3b8:	003f0306 	br	81119fc8 <__reset+0xfb0f9fc8>
8111a3bc:	00c00044 	movi	r3,1
8111a3c0:	1947c83a 	sub	r3,r3,r5
8111a3c4:	00800e04 	movi	r2,56
8111a3c8:	10feda16 	blt	r2,r3,81119f34 <__reset+0xfb0f9f34>
8111a3cc:	008007c4 	movi	r2,31
8111a3d0:	10c01b16 	blt	r2,r3,8111a440 <__muldf3+0x680>
8111a3d4:	00800804 	movi	r2,32
8111a3d8:	10c5c83a 	sub	r2,r2,r3
8111a3dc:	888a983a 	sll	r5,r17,r2
8111a3e0:	40c8d83a 	srl	r4,r8,r3
8111a3e4:	4084983a 	sll	r2,r8,r2
8111a3e8:	88e2d83a 	srl	r17,r17,r3
8111a3ec:	2906b03a 	or	r3,r5,r4
8111a3f0:	1004c03a 	cmpne	r2,r2,zero
8111a3f4:	1886b03a 	or	r3,r3,r2
8111a3f8:	188001cc 	andi	r2,r3,7
8111a3fc:	10000726 	beq	r2,zero,8111a41c <__muldf3+0x65c>
8111a400:	188003cc 	andi	r2,r3,15
8111a404:	01000104 	movi	r4,4
8111a408:	11000426 	beq	r2,r4,8111a41c <__muldf3+0x65c>
8111a40c:	1805883a 	mov	r2,r3
8111a410:	10c00104 	addi	r3,r2,4
8111a414:	1885803a 	cmpltu	r2,r3,r2
8111a418:	88a3883a 	add	r17,r17,r2
8111a41c:	8880202c 	andhi	r2,r17,128
8111a420:	10001c26 	beq	r2,zero,8111a494 <__muldf3+0x6d4>
8111a424:	b02b883a 	mov	r21,r22
8111a428:	00800044 	movi	r2,1
8111a42c:	000b883a 	mov	r5,zero
8111a430:	0029883a 	mov	r20,zero
8111a434:	003ec306 	br	81119f44 <__reset+0xfb0f9f44>
8111a438:	5805883a 	mov	r2,r11
8111a43c:	003f9906 	br	8111a2a4 <__reset+0xfb0fa2a4>
8111a440:	00bff844 	movi	r2,-31
8111a444:	1145c83a 	sub	r2,r2,r5
8111a448:	8888d83a 	srl	r4,r17,r2
8111a44c:	00800804 	movi	r2,32
8111a450:	18801a26 	beq	r3,r2,8111a4bc <__muldf3+0x6fc>
8111a454:	00801004 	movi	r2,64
8111a458:	10c5c83a 	sub	r2,r2,r3
8111a45c:	8884983a 	sll	r2,r17,r2
8111a460:	1204b03a 	or	r2,r2,r8
8111a464:	1004c03a 	cmpne	r2,r2,zero
8111a468:	2084b03a 	or	r2,r4,r2
8111a46c:	144001cc 	andi	r17,r2,7
8111a470:	88000d1e 	bne	r17,zero,8111a4a8 <__muldf3+0x6e8>
8111a474:	000b883a 	mov	r5,zero
8111a478:	1028d0fa 	srli	r20,r2,3
8111a47c:	b02b883a 	mov	r21,r22
8111a480:	0005883a 	mov	r2,zero
8111a484:	a468b03a 	or	r20,r20,r17
8111a488:	003eae06 	br	81119f44 <__reset+0xfb0f9f44>
8111a48c:	1007883a 	mov	r3,r2
8111a490:	0023883a 	mov	r17,zero
8111a494:	880a927a 	slli	r5,r17,9
8111a498:	1805883a 	mov	r2,r3
8111a49c:	8822977a 	slli	r17,r17,29
8111a4a0:	280ad33a 	srli	r5,r5,12
8111a4a4:	003ff406 	br	8111a478 <__reset+0xfb0fa478>
8111a4a8:	10c003cc 	andi	r3,r2,15
8111a4ac:	01000104 	movi	r4,4
8111a4b0:	193ff626 	beq	r3,r4,8111a48c <__reset+0xfb0fa48c>
8111a4b4:	0023883a 	mov	r17,zero
8111a4b8:	003fd506 	br	8111a410 <__reset+0xfb0fa410>
8111a4bc:	0005883a 	mov	r2,zero
8111a4c0:	003fe706 	br	8111a460 <__reset+0xfb0fa460>
8111a4c4:	00800434 	movhi	r2,16
8111a4c8:	89400234 	orhi	r5,r17,8
8111a4cc:	10bfffc4 	addi	r2,r2,-1
8111a4d0:	b02b883a 	mov	r21,r22
8111a4d4:	288a703a 	and	r5,r5,r2
8111a4d8:	4029883a 	mov	r20,r8
8111a4dc:	003eff06 	br	8111a0dc <__reset+0xfb0fa0dc>

8111a4e0 <__extendsfdf2>:
8111a4e0:	200ad5fa 	srli	r5,r4,23
8111a4e4:	defffd04 	addi	sp,sp,-12
8111a4e8:	de00012e 	bgeu	sp,et,8111a4f0 <__extendsfdf2+0x10>
8111a4ec:	003b68fa 	trap	3
8111a4f0:	29403fcc 	andi	r5,r5,255
8111a4f4:	dc400115 	stw	r17,4(sp)
8111a4f8:	29800044 	addi	r6,r5,1
8111a4fc:	04402034 	movhi	r17,128
8111a500:	dc000015 	stw	r16,0(sp)
8111a504:	8c7fffc4 	addi	r17,r17,-1
8111a508:	dfc00215 	stw	ra,8(sp)
8111a50c:	31803fcc 	andi	r6,r6,255
8111a510:	00800044 	movi	r2,1
8111a514:	8922703a 	and	r17,r17,r4
8111a518:	2020d7fa 	srli	r16,r4,31
8111a51c:	1180110e 	bge	r2,r6,8111a564 <__extendsfdf2+0x84>
8111a520:	880cd0fa 	srli	r6,r17,3
8111a524:	8822977a 	slli	r17,r17,29
8111a528:	2940e004 	addi	r5,r5,896
8111a52c:	2941ffcc 	andi	r5,r5,2047
8111a530:	2804953a 	slli	r2,r5,20
8111a534:	01400434 	movhi	r5,16
8111a538:	800697fa 	slli	r3,r16,31
8111a53c:	297fffc4 	addi	r5,r5,-1
8111a540:	314a703a 	and	r5,r6,r5
8111a544:	288ab03a 	or	r5,r5,r2
8111a548:	28c6b03a 	or	r3,r5,r3
8111a54c:	8805883a 	mov	r2,r17
8111a550:	dfc00217 	ldw	ra,8(sp)
8111a554:	dc400117 	ldw	r17,4(sp)
8111a558:	dc000017 	ldw	r16,0(sp)
8111a55c:	dec00304 	addi	sp,sp,12
8111a560:	f800283a 	ret
8111a564:	2800111e 	bne	r5,zero,8111a5ac <__extendsfdf2+0xcc>
8111a568:	88001c26 	beq	r17,zero,8111a5dc <__extendsfdf2+0xfc>
8111a56c:	8809883a 	mov	r4,r17
8111a570:	111a7a00 	call	8111a7a0 <__clzsi2>
8111a574:	00c00284 	movi	r3,10
8111a578:	18801b16 	blt	r3,r2,8111a5e8 <__extendsfdf2+0x108>
8111a57c:	018002c4 	movi	r6,11
8111a580:	308dc83a 	sub	r6,r6,r2
8111a584:	11000544 	addi	r4,r2,21
8111a588:	8986d83a 	srl	r3,r17,r6
8111a58c:	8922983a 	sll	r17,r17,r4
8111a590:	0180e244 	movi	r6,905
8111a594:	01400434 	movhi	r5,16
8111a598:	3085c83a 	sub	r2,r6,r2
8111a59c:	297fffc4 	addi	r5,r5,-1
8111a5a0:	194c703a 	and	r6,r3,r5
8111a5a4:	1141ffcc 	andi	r5,r2,2047
8111a5a8:	003fe006 	br	8111a52c <__reset+0xfb0fa52c>
8111a5ac:	88000826 	beq	r17,zero,8111a5d0 <__extendsfdf2+0xf0>
8111a5b0:	880cd0fa 	srli	r6,r17,3
8111a5b4:	00800434 	movhi	r2,16
8111a5b8:	10bfffc4 	addi	r2,r2,-1
8111a5bc:	31800234 	orhi	r6,r6,8
8111a5c0:	8822977a 	slli	r17,r17,29
8111a5c4:	308c703a 	and	r6,r6,r2
8111a5c8:	0141ffc4 	movi	r5,2047
8111a5cc:	003fd706 	br	8111a52c <__reset+0xfb0fa52c>
8111a5d0:	0141ffc4 	movi	r5,2047
8111a5d4:	000d883a 	mov	r6,zero
8111a5d8:	003fd406 	br	8111a52c <__reset+0xfb0fa52c>
8111a5dc:	000b883a 	mov	r5,zero
8111a5e0:	000d883a 	mov	r6,zero
8111a5e4:	003fd106 	br	8111a52c <__reset+0xfb0fa52c>
8111a5e8:	11bffd44 	addi	r6,r2,-11
8111a5ec:	8986983a 	sll	r3,r17,r6
8111a5f0:	0023883a 	mov	r17,zero
8111a5f4:	003fe606 	br	8111a590 <__reset+0xfb0fa590>

8111a5f8 <__truncdfsf2>:
8111a5f8:	2810d53a 	srli	r8,r5,20
8111a5fc:	01c00434 	movhi	r7,16
8111a600:	39ffffc4 	addi	r7,r7,-1
8111a604:	29ce703a 	and	r7,r5,r7
8111a608:	4201ffcc 	andi	r8,r8,2047
8111a60c:	380e90fa 	slli	r7,r7,3
8111a610:	200cd77a 	srli	r6,r4,29
8111a614:	42400044 	addi	r9,r8,1
8111a618:	4a41ffcc 	andi	r9,r9,2047
8111a61c:	00c00044 	movi	r3,1
8111a620:	280ad7fa 	srli	r5,r5,31
8111a624:	31ceb03a 	or	r7,r6,r7
8111a628:	200490fa 	slli	r2,r4,3
8111a62c:	1a40230e 	bge	r3,r9,8111a6bc <__truncdfsf2+0xc4>
8111a630:	40ff2004 	addi	r3,r8,-896
8111a634:	01803f84 	movi	r6,254
8111a638:	30c01516 	blt	r6,r3,8111a690 <__truncdfsf2+0x98>
8111a63c:	00c0380e 	bge	zero,r3,8111a720 <__truncdfsf2+0x128>
8111a640:	200c91ba 	slli	r6,r4,6
8111a644:	380e90fa 	slli	r7,r7,3
8111a648:	1004d77a 	srli	r2,r2,29
8111a64c:	300cc03a 	cmpne	r6,r6,zero
8111a650:	31ccb03a 	or	r6,r6,r7
8111a654:	308cb03a 	or	r6,r6,r2
8111a658:	308001cc 	andi	r2,r6,7
8111a65c:	10000426 	beq	r2,zero,8111a670 <__truncdfsf2+0x78>
8111a660:	308003cc 	andi	r2,r6,15
8111a664:	01000104 	movi	r4,4
8111a668:	11000126 	beq	r2,r4,8111a670 <__truncdfsf2+0x78>
8111a66c:	31800104 	addi	r6,r6,4
8111a670:	3081002c 	andhi	r2,r6,1024
8111a674:	10001626 	beq	r2,zero,8111a6d0 <__truncdfsf2+0xd8>
8111a678:	18c00044 	addi	r3,r3,1
8111a67c:	00803fc4 	movi	r2,255
8111a680:	18800326 	beq	r3,r2,8111a690 <__truncdfsf2+0x98>
8111a684:	300c91ba 	slli	r6,r6,6
8111a688:	300cd27a 	srli	r6,r6,9
8111a68c:	00000206 	br	8111a698 <__truncdfsf2+0xa0>
8111a690:	00ffffc4 	movi	r3,-1
8111a694:	000d883a 	mov	r6,zero
8111a698:	18c03fcc 	andi	r3,r3,255
8111a69c:	180895fa 	slli	r4,r3,23
8111a6a0:	00c02034 	movhi	r3,128
8111a6a4:	280a97fa 	slli	r5,r5,31
8111a6a8:	18ffffc4 	addi	r3,r3,-1
8111a6ac:	30c6703a 	and	r3,r6,r3
8111a6b0:	1906b03a 	or	r3,r3,r4
8111a6b4:	1944b03a 	or	r2,r3,r5
8111a6b8:	f800283a 	ret
8111a6bc:	40000b1e 	bne	r8,zero,8111a6ec <__truncdfsf2+0xf4>
8111a6c0:	388cb03a 	or	r6,r7,r2
8111a6c4:	0007883a 	mov	r3,zero
8111a6c8:	30000426 	beq	r6,zero,8111a6dc <__truncdfsf2+0xe4>
8111a6cc:	01800144 	movi	r6,5
8111a6d0:	00803fc4 	movi	r2,255
8111a6d4:	300cd0fa 	srli	r6,r6,3
8111a6d8:	18800a26 	beq	r3,r2,8111a704 <__truncdfsf2+0x10c>
8111a6dc:	00802034 	movhi	r2,128
8111a6e0:	10bfffc4 	addi	r2,r2,-1
8111a6e4:	308c703a 	and	r6,r6,r2
8111a6e8:	003feb06 	br	8111a698 <__reset+0xfb0fa698>
8111a6ec:	3888b03a 	or	r4,r7,r2
8111a6f0:	203fe726 	beq	r4,zero,8111a690 <__reset+0xfb0fa690>
8111a6f4:	380c90fa 	slli	r6,r7,3
8111a6f8:	00c03fc4 	movi	r3,255
8111a6fc:	31808034 	orhi	r6,r6,512
8111a700:	003fd506 	br	8111a658 <__reset+0xfb0fa658>
8111a704:	303fe226 	beq	r6,zero,8111a690 <__reset+0xfb0fa690>
8111a708:	00802034 	movhi	r2,128
8111a70c:	31801034 	orhi	r6,r6,64
8111a710:	10bfffc4 	addi	r2,r2,-1
8111a714:	00ffffc4 	movi	r3,-1
8111a718:	308c703a 	and	r6,r6,r2
8111a71c:	003fde06 	br	8111a698 <__reset+0xfb0fa698>
8111a720:	013ffa44 	movi	r4,-23
8111a724:	19000e16 	blt	r3,r4,8111a760 <__truncdfsf2+0x168>
8111a728:	01000784 	movi	r4,30
8111a72c:	20c9c83a 	sub	r4,r4,r3
8111a730:	018007c4 	movi	r6,31
8111a734:	39c02034 	orhi	r7,r7,128
8111a738:	31000b16 	blt	r6,r4,8111a768 <__truncdfsf2+0x170>
8111a73c:	423f2084 	addi	r8,r8,-894
8111a740:	120c983a 	sll	r6,r2,r8
8111a744:	3a0e983a 	sll	r7,r7,r8
8111a748:	1104d83a 	srl	r2,r2,r4
8111a74c:	300cc03a 	cmpne	r6,r6,zero
8111a750:	31ceb03a 	or	r7,r6,r7
8111a754:	388cb03a 	or	r6,r7,r2
8111a758:	0007883a 	mov	r3,zero
8111a75c:	003fbe06 	br	8111a658 <__reset+0xfb0fa658>
8111a760:	0007883a 	mov	r3,zero
8111a764:	003fd906 	br	8111a6cc <__reset+0xfb0fa6cc>
8111a768:	01bfff84 	movi	r6,-2
8111a76c:	30cdc83a 	sub	r6,r6,r3
8111a770:	00c00804 	movi	r3,32
8111a774:	398cd83a 	srl	r6,r7,r6
8111a778:	20c00726 	beq	r4,r3,8111a798 <__truncdfsf2+0x1a0>
8111a77c:	423f2884 	addi	r8,r8,-862
8111a780:	3a0e983a 	sll	r7,r7,r8
8111a784:	3884b03a 	or	r2,r7,r2
8111a788:	1004c03a 	cmpne	r2,r2,zero
8111a78c:	118cb03a 	or	r6,r2,r6
8111a790:	0007883a 	mov	r3,zero
8111a794:	003fb006 	br	8111a658 <__reset+0xfb0fa658>
8111a798:	000f883a 	mov	r7,zero
8111a79c:	003ff906 	br	8111a784 <__reset+0xfb0fa784>

8111a7a0 <__clzsi2>:
8111a7a0:	00bfffd4 	movui	r2,65535
8111a7a4:	11000536 	bltu	r2,r4,8111a7bc <__clzsi2+0x1c>
8111a7a8:	00803fc4 	movi	r2,255
8111a7ac:	11000f36 	bltu	r2,r4,8111a7ec <__clzsi2+0x4c>
8111a7b0:	00800804 	movi	r2,32
8111a7b4:	0007883a 	mov	r3,zero
8111a7b8:	00000506 	br	8111a7d0 <__clzsi2+0x30>
8111a7bc:	00804034 	movhi	r2,256
8111a7c0:	10bfffc4 	addi	r2,r2,-1
8111a7c4:	11000c2e 	bgeu	r2,r4,8111a7f8 <__clzsi2+0x58>
8111a7c8:	00800204 	movi	r2,8
8111a7cc:	00c00604 	movi	r3,24
8111a7d0:	20c8d83a 	srl	r4,r4,r3
8111a7d4:	00e04574 	movhi	r3,33045
8111a7d8:	18e5c704 	addi	r3,r3,-26852
8111a7dc:	1909883a 	add	r4,r3,r4
8111a7e0:	20c00003 	ldbu	r3,0(r4)
8111a7e4:	10c5c83a 	sub	r2,r2,r3
8111a7e8:	f800283a 	ret
8111a7ec:	00800604 	movi	r2,24
8111a7f0:	00c00204 	movi	r3,8
8111a7f4:	003ff606 	br	8111a7d0 <__reset+0xfb0fa7d0>
8111a7f8:	00800404 	movi	r2,16
8111a7fc:	1007883a 	mov	r3,r2
8111a800:	003ff306 	br	8111a7d0 <__reset+0xfb0fa7d0>

8111a804 <atoi>:
8111a804:	01800284 	movi	r6,10
8111a808:	000b883a 	mov	r5,zero
8111a80c:	111c8201 	jmpi	8111c820 <strtol>

8111a810 <_atoi_r>:
8111a810:	01c00284 	movi	r7,10
8111a814:	000d883a 	mov	r6,zero
8111a818:	111c5e01 	jmpi	8111c5e0 <_strtol_r>

8111a81c <_fopen_r>:
8111a81c:	defffa04 	addi	sp,sp,-24
8111a820:	3005883a 	mov	r2,r6
8111a824:	de00012e 	bgeu	sp,et,8111a82c <_fopen_r+0x10>
8111a828:	003b68fa 	trap	3
8111a82c:	d80d883a 	mov	r6,sp
8111a830:	dcc00415 	stw	r19,16(sp)
8111a834:	2827883a 	mov	r19,r5
8111a838:	100b883a 	mov	r5,r2
8111a83c:	dc800315 	stw	r18,12(sp)
8111a840:	dfc00515 	stw	ra,20(sp)
8111a844:	dc400215 	stw	r17,8(sp)
8111a848:	dc000115 	stw	r16,4(sp)
8111a84c:	2025883a 	mov	r18,r4
8111a850:	11248280 	call	81124828 <__sflags>
8111a854:	10002726 	beq	r2,zero,8111a8f4 <_fopen_r+0xd8>
8111a858:	9009883a 	mov	r4,r18
8111a85c:	1023883a 	mov	r17,r2
8111a860:	11246a00 	call	811246a0 <__sfp>
8111a864:	1021883a 	mov	r16,r2
8111a868:	10002226 	beq	r2,zero,8111a8f4 <_fopen_r+0xd8>
8111a86c:	d9800017 	ldw	r6,0(sp)
8111a870:	01c06d84 	movi	r7,438
8111a874:	980b883a 	mov	r5,r19
8111a878:	9009883a 	mov	r4,r18
8111a87c:	111bc880 	call	8111bc88 <_open_r>
8111a880:	10001916 	blt	r2,zero,8111a8e8 <_fopen_r+0xcc>
8111a884:	8080038d 	sth	r2,14(r16)
8111a888:	00a044b4 	movhi	r2,33042
8111a88c:	10b0d904 	addi	r2,r2,-15516
8111a890:	80800815 	stw	r2,32(r16)
8111a894:	00a044b4 	movhi	r2,33042
8111a898:	10b0f204 	addi	r2,r2,-15416
8111a89c:	80800915 	stw	r2,36(r16)
8111a8a0:	00a044b4 	movhi	r2,33042
8111a8a4:	10b11304 	addi	r2,r2,-15284
8111a8a8:	80800a15 	stw	r2,40(r16)
8111a8ac:	00a044b4 	movhi	r2,33042
8111a8b0:	10b12c04 	addi	r2,r2,-15184
8111a8b4:	8440030d 	sth	r17,12(r16)
8111a8b8:	84000715 	stw	r16,28(r16)
8111a8bc:	80800b15 	stw	r2,44(r16)
8111a8c0:	8c40400c 	andi	r17,r17,256
8111a8c4:	88000d1e 	bne	r17,zero,8111a8fc <_fopen_r+0xe0>
8111a8c8:	8005883a 	mov	r2,r16
8111a8cc:	dfc00517 	ldw	ra,20(sp)
8111a8d0:	dcc00417 	ldw	r19,16(sp)
8111a8d4:	dc800317 	ldw	r18,12(sp)
8111a8d8:	dc400217 	ldw	r17,8(sp)
8111a8dc:	dc000117 	ldw	r16,4(sp)
8111a8e0:	dec00604 	addi	sp,sp,24
8111a8e4:	f800283a 	ret
8111a8e8:	11247e80 	call	811247e8 <__sfp_lock_acquire>
8111a8ec:	8000030d 	sth	zero,12(r16)
8111a8f0:	11247ec0 	call	811247ec <__sfp_lock_release>
8111a8f4:	0005883a 	mov	r2,zero
8111a8f8:	003ff406 	br	8111a8cc <__reset+0xfb0fa8cc>
8111a8fc:	01c00084 	movi	r7,2
8111a900:	000d883a 	mov	r6,zero
8111a904:	800b883a 	mov	r5,r16
8111a908:	9009883a 	mov	r4,r18
8111a90c:	111aa3c0 	call	8111aa3c <_fseek_r>
8111a910:	8005883a 	mov	r2,r16
8111a914:	003fed06 	br	8111a8cc <__reset+0xfb0fa8cc>

8111a918 <fopen>:
8111a918:	00a04574 	movhi	r2,33045
8111a91c:	10b08204 	addi	r2,r2,-15864
8111a920:	280d883a 	mov	r6,r5
8111a924:	200b883a 	mov	r5,r4
8111a928:	11000017 	ldw	r4,0(r2)
8111a92c:	111a81c1 	jmpi	8111a81c <_fopen_r>

8111a930 <_fprintf_r>:
8111a930:	defffe04 	addi	sp,sp,-8
8111a934:	2809883a 	mov	r4,r5
8111a938:	300b883a 	mov	r5,r6
8111a93c:	de00012e 	bgeu	sp,et,8111a944 <_fprintf_r+0x14>
8111a940:	003b68fa 	trap	3
8111a944:	dfc00015 	stw	ra,0(sp)
8111a948:	d9c00115 	stw	r7,4(sp)
8111a94c:	d9800104 	addi	r6,sp,4
8111a950:	1120c1c0 	call	81120c1c <__vfprintf_internal>
8111a954:	dfc00017 	ldw	ra,0(sp)
8111a958:	dec00204 	addi	sp,sp,8
8111a95c:	f800283a 	ret

8111a960 <fprintf>:
8111a960:	defffd04 	addi	sp,sp,-12
8111a964:	de00012e 	bgeu	sp,et,8111a96c <fprintf+0xc>
8111a968:	003b68fa 	trap	3
8111a96c:	dfc00015 	stw	ra,0(sp)
8111a970:	d9800115 	stw	r6,4(sp)
8111a974:	d9c00215 	stw	r7,8(sp)
8111a978:	d9800104 	addi	r6,sp,4
8111a97c:	1120c1c0 	call	81120c1c <__vfprintf_internal>
8111a980:	dfc00017 	ldw	ra,0(sp)
8111a984:	dec00304 	addi	sp,sp,12
8111a988:	f800283a 	ret

8111a98c <_fputc_r>:
8111a98c:	defffc04 	addi	sp,sp,-16
8111a990:	de00012e 	bgeu	sp,et,8111a998 <_fputc_r+0xc>
8111a994:	003b68fa 	trap	3
8111a998:	dc000215 	stw	r16,8(sp)
8111a99c:	dfc00315 	stw	ra,12(sp)
8111a9a0:	2021883a 	mov	r16,r4
8111a9a4:	20000726 	beq	r4,zero,8111a9c4 <_fputc_r+0x38>
8111a9a8:	20800e17 	ldw	r2,56(r4)
8111a9ac:	1000051e 	bne	r2,zero,8111a9c4 <_fputc_r+0x38>
8111a9b0:	d9400015 	stw	r5,0(sp)
8111a9b4:	d9800115 	stw	r6,4(sp)
8111a9b8:	11247d80 	call	811247d8 <__sinit>
8111a9bc:	d9800117 	ldw	r6,4(sp)
8111a9c0:	d9400017 	ldw	r5,0(sp)
8111a9c4:	8009883a 	mov	r4,r16
8111a9c8:	dfc00317 	ldw	ra,12(sp)
8111a9cc:	dc000217 	ldw	r16,8(sp)
8111a9d0:	dec00404 	addi	sp,sp,16
8111a9d4:	111bd6c1 	jmpi	8111bd6c <_putc_r>

8111a9d8 <fputc>:
8111a9d8:	00a04574 	movhi	r2,33045
8111a9dc:	defffc04 	addi	sp,sp,-16
8111a9e0:	10b08204 	addi	r2,r2,-15864
8111a9e4:	de00012e 	bgeu	sp,et,8111a9ec <fputc+0x14>
8111a9e8:	003b68fa 	trap	3
8111a9ec:	dc000115 	stw	r16,4(sp)
8111a9f0:	14000017 	ldw	r16,0(r2)
8111a9f4:	dc400215 	stw	r17,8(sp)
8111a9f8:	dfc00315 	stw	ra,12(sp)
8111a9fc:	2023883a 	mov	r17,r4
8111aa00:	80000626 	beq	r16,zero,8111aa1c <fputc+0x44>
8111aa04:	80800e17 	ldw	r2,56(r16)
8111aa08:	1000041e 	bne	r2,zero,8111aa1c <fputc+0x44>
8111aa0c:	8009883a 	mov	r4,r16
8111aa10:	d9400015 	stw	r5,0(sp)
8111aa14:	11247d80 	call	811247d8 <__sinit>
8111aa18:	d9400017 	ldw	r5,0(sp)
8111aa1c:	280d883a 	mov	r6,r5
8111aa20:	8009883a 	mov	r4,r16
8111aa24:	880b883a 	mov	r5,r17
8111aa28:	dfc00317 	ldw	ra,12(sp)
8111aa2c:	dc400217 	ldw	r17,8(sp)
8111aa30:	dc000117 	ldw	r16,4(sp)
8111aa34:	dec00404 	addi	sp,sp,16
8111aa38:	111bd6c1 	jmpi	8111bd6c <_putc_r>

8111aa3c <_fseek_r>:
8111aa3c:	111aa5c1 	jmpi	8111aa5c <_fseeko_r>

8111aa40 <fseek>:
8111aa40:	00a04574 	movhi	r2,33045
8111aa44:	10b08204 	addi	r2,r2,-15864
8111aa48:	300f883a 	mov	r7,r6
8111aa4c:	280d883a 	mov	r6,r5
8111aa50:	200b883a 	mov	r5,r4
8111aa54:	11000017 	ldw	r4,0(r2)
8111aa58:	111aa5c1 	jmpi	8111aa5c <_fseeko_r>

8111aa5c <_fseeko_r>:
8111aa5c:	deffe804 	addi	sp,sp,-96
8111aa60:	de00012e 	bgeu	sp,et,8111aa68 <_fseeko_r+0xc>
8111aa64:	003b68fa 	trap	3
8111aa68:	dd401415 	stw	r21,80(sp)
8111aa6c:	dc801115 	stw	r18,68(sp)
8111aa70:	dc401015 	stw	r17,64(sp)
8111aa74:	dc000f15 	stw	r16,60(sp)
8111aa78:	dfc01715 	stw	ra,92(sp)
8111aa7c:	ddc01615 	stw	r23,88(sp)
8111aa80:	dd801515 	stw	r22,84(sp)
8111aa84:	dd001315 	stw	r20,76(sp)
8111aa88:	dcc01215 	stw	r19,72(sp)
8111aa8c:	2023883a 	mov	r17,r4
8111aa90:	2821883a 	mov	r16,r5
8111aa94:	302b883a 	mov	r21,r6
8111aa98:	3825883a 	mov	r18,r7
8111aa9c:	20000226 	beq	r4,zero,8111aaa8 <_fseeko_r+0x4c>
8111aaa0:	20800e17 	ldw	r2,56(r4)
8111aaa4:	10005a26 	beq	r2,zero,8111ac10 <_fseeko_r+0x1b4>
8111aaa8:	8080030b 	ldhu	r2,12(r16)
8111aaac:	00c04204 	movi	r3,264
8111aab0:	1080420c 	andi	r2,r2,264
8111aab4:	10c05b26 	beq	r2,r3,8111ac24 <_fseeko_r+0x1c8>
8111aab8:	85000a17 	ldw	r20,40(r16)
8111aabc:	a000f626 	beq	r20,zero,8111ae98 <_fseeko_r+0x43c>
8111aac0:	00800044 	movi	r2,1
8111aac4:	90803e26 	beq	r18,r2,8111abc0 <_fseeko_r+0x164>
8111aac8:	00800084 	movi	r2,2
8111aacc:	90801026 	beq	r18,r2,8111ab10 <_fseeko_r+0xb4>
8111aad0:	90000f26 	beq	r18,zero,8111ab10 <_fseeko_r+0xb4>
8111aad4:	00800584 	movi	r2,22
8111aad8:	88800015 	stw	r2,0(r17)
8111aadc:	04ffffc4 	movi	r19,-1
8111aae0:	9805883a 	mov	r2,r19
8111aae4:	dfc01717 	ldw	ra,92(sp)
8111aae8:	ddc01617 	ldw	r23,88(sp)
8111aaec:	dd801517 	ldw	r22,84(sp)
8111aaf0:	dd401417 	ldw	r21,80(sp)
8111aaf4:	dd001317 	ldw	r20,76(sp)
8111aaf8:	dcc01217 	ldw	r19,72(sp)
8111aafc:	dc801117 	ldw	r18,68(sp)
8111ab00:	dc401017 	ldw	r17,64(sp)
8111ab04:	dc000f17 	ldw	r16,60(sp)
8111ab08:	dec01804 	addi	sp,sp,96
8111ab0c:	f800283a 	ret
8111ab10:	80800417 	ldw	r2,16(r16)
8111ab14:	002f883a 	mov	r23,zero
8111ab18:	0027883a 	mov	r19,zero
8111ab1c:	1000cb26 	beq	r2,zero,8111ae4c <_fseeko_r+0x3f0>
8111ab20:	8080030b 	ldhu	r2,12(r16)
8111ab24:	10c2068c 	andi	r3,r2,2074
8111ab28:	1800071e 	bne	r3,zero,8111ab48 <_fseeko_r+0xec>
8111ab2c:	10c1000c 	andi	r3,r2,1024
8111ab30:	1800451e 	bne	r3,zero,8111ac48 <_fseeko_r+0x1ec>
8111ab34:	00e044b4 	movhi	r3,33042
8111ab38:	18f11304 	addi	r3,r3,-15284
8111ab3c:	a0c0b726 	beq	r20,r3,8111ae1c <_fseeko_r+0x3c0>
8111ab40:	10820014 	ori	r2,r2,2048
8111ab44:	8080030d 	sth	r2,12(r16)
8111ab48:	800b883a 	mov	r5,r16
8111ab4c:	8809883a 	mov	r4,r17
8111ab50:	11243dc0 	call	811243dc <_fflush_r>
8111ab54:	1027883a 	mov	r19,r2
8111ab58:	103fe01e 	bne	r2,zero,8111aadc <__reset+0xfb0faadc>
8111ab5c:	81400717 	ldw	r5,28(r16)
8111ab60:	900f883a 	mov	r7,r18
8111ab64:	a80d883a 	mov	r6,r21
8111ab68:	8809883a 	mov	r4,r17
8111ab6c:	a03ee83a 	callr	r20
8111ab70:	00ffffc4 	movi	r3,-1
8111ab74:	10ffd926 	beq	r2,r3,8111aadc <__reset+0xfb0faadc>
8111ab78:	81400c17 	ldw	r5,48(r16)
8111ab7c:	28000526 	beq	r5,zero,8111ab94 <_fseeko_r+0x138>
8111ab80:	80801004 	addi	r2,r16,64
8111ab84:	28800226 	beq	r5,r2,8111ab90 <_fseeko_r+0x134>
8111ab88:	8809883a 	mov	r4,r17
8111ab8c:	1124c700 	call	81124c70 <_free_r>
8111ab90:	80000c15 	stw	zero,48(r16)
8111ab94:	8080030b 	ldhu	r2,12(r16)
8111ab98:	80c00417 	ldw	r3,16(r16)
8111ab9c:	80000115 	stw	zero,4(r16)
8111aba0:	10bdf7cc 	andi	r2,r2,63455
8111aba4:	80c00015 	stw	r3,0(r16)
8111aba8:	8080030d 	sth	r2,12(r16)
8111abac:	01800204 	movi	r6,8
8111abb0:	000b883a 	mov	r5,zero
8111abb4:	81001704 	addi	r4,r16,92
8111abb8:	111bb600 	call	8111bb60 <memset>
8111abbc:	003fc806 	br	8111aae0 <__reset+0xfb0faae0>
8111abc0:	800b883a 	mov	r5,r16
8111abc4:	8809883a 	mov	r4,r17
8111abc8:	11243dc0 	call	811243dc <_fflush_r>
8111abcc:	8080030b 	ldhu	r2,12(r16)
8111abd0:	10c4000c 	andi	r3,r2,4096
8111abd4:	18008726 	beq	r3,zero,8111adf4 <_fseeko_r+0x398>
8111abd8:	84c01417 	ldw	r19,80(r16)
8111abdc:	10c0010c 	andi	r3,r2,4
8111abe0:	1800431e 	bne	r3,zero,8111acf0 <_fseeko_r+0x294>
8111abe4:	1080020c 	andi	r2,r2,8
8111abe8:	10008026 	beq	r2,zero,8111adec <_fseeko_r+0x390>
8111abec:	80c00017 	ldw	r3,0(r16)
8111abf0:	80800417 	ldw	r2,16(r16)
8111abf4:	18000226 	beq	r3,zero,8111ac00 <_fseeko_r+0x1a4>
8111abf8:	1887c83a 	sub	r3,r3,r2
8111abfc:	98e7883a 	add	r19,r19,r3
8111ac00:	aceb883a 	add	r21,r21,r19
8111ac04:	05c00044 	movi	r23,1
8111ac08:	0025883a 	mov	r18,zero
8111ac0c:	003fc306 	br	8111ab1c <__reset+0xfb0fab1c>
8111ac10:	11247d80 	call	811247d8 <__sinit>
8111ac14:	8080030b 	ldhu	r2,12(r16)
8111ac18:	00c04204 	movi	r3,264
8111ac1c:	1080420c 	andi	r2,r2,264
8111ac20:	10ffa51e 	bne	r2,r3,8111aab8 <__reset+0xfb0faab8>
8111ac24:	800b883a 	mov	r5,r16
8111ac28:	8809883a 	mov	r4,r17
8111ac2c:	11243dc0 	call	811243dc <_fflush_r>
8111ac30:	003fa106 	br	8111aab8 <__reset+0xfb0faab8>
8111ac34:	8080030b 	ldhu	r2,12(r16)
8111ac38:	00c10004 	movi	r3,1024
8111ac3c:	80c01315 	stw	r3,76(r16)
8111ac40:	10c4b03a 	or	r2,r2,r3
8111ac44:	8080030d 	sth	r2,12(r16)
8111ac48:	9000311e 	bne	r18,zero,8111ad10 <_fseeko_r+0x2b4>
8111ac4c:	a82d883a 	mov	r22,r21
8111ac50:	b800371e 	bne	r23,zero,8111ad30 <_fseeko_r+0x2d4>
8111ac54:	8080030b 	ldhu	r2,12(r16)
8111ac58:	1084000c 	andi	r2,r2,4096
8111ac5c:	10007f26 	beq	r2,zero,8111ae5c <_fseeko_r+0x400>
8111ac60:	80801417 	ldw	r2,80(r16)
8111ac64:	81800117 	ldw	r6,4(r16)
8111ac68:	81400c17 	ldw	r5,48(r16)
8111ac6c:	11a7c83a 	sub	r19,r2,r6
8111ac70:	28008226 	beq	r5,zero,8111ae7c <_fseeko_r+0x420>
8111ac74:	81c00f17 	ldw	r7,60(r16)
8111ac78:	99e7c83a 	sub	r19,r19,r7
8111ac7c:	81000e17 	ldw	r4,56(r16)
8111ac80:	80800417 	ldw	r2,16(r16)
8111ac84:	99a7883a 	add	r19,r19,r6
8111ac88:	2087c83a 	sub	r3,r4,r2
8111ac8c:	98e7c83a 	sub	r19,r19,r3
8111ac90:	38c7883a 	add	r3,r7,r3
8111ac94:	b4c02b16 	blt	r22,r19,8111ad44 <_fseeko_r+0x2e8>
8111ac98:	98c9883a 	add	r4,r19,r3
8111ac9c:	b100292e 	bgeu	r22,r4,8111ad44 <_fseeko_r+0x2e8>
8111aca0:	b4e7c83a 	sub	r19,r22,r19
8111aca4:	14c5883a 	add	r2,r2,r19
8111aca8:	1ce7c83a 	sub	r19,r3,r19
8111acac:	80800015 	stw	r2,0(r16)
8111acb0:	84c00115 	stw	r19,4(r16)
8111acb4:	28000526 	beq	r5,zero,8111accc <_fseeko_r+0x270>
8111acb8:	80801004 	addi	r2,r16,64
8111acbc:	28800226 	beq	r5,r2,8111acc8 <_fseeko_r+0x26c>
8111acc0:	8809883a 	mov	r4,r17
8111acc4:	1124c700 	call	81124c70 <_free_r>
8111acc8:	80000c15 	stw	zero,48(r16)
8111accc:	8080030b 	ldhu	r2,12(r16)
8111acd0:	01800204 	movi	r6,8
8111acd4:	000b883a 	mov	r5,zero
8111acd8:	10bff7cc 	andi	r2,r2,65503
8111acdc:	8080030d 	sth	r2,12(r16)
8111ace0:	81001704 	addi	r4,r16,92
8111ace4:	111bb600 	call	8111bb60 <memset>
8111ace8:	0027883a 	mov	r19,zero
8111acec:	003f7c06 	br	8111aae0 <__reset+0xfb0faae0>
8111acf0:	80c00117 	ldw	r3,4(r16)
8111acf4:	80800c17 	ldw	r2,48(r16)
8111acf8:	98e7c83a 	sub	r19,r19,r3
8111acfc:	10003b26 	beq	r2,zero,8111adec <_fseeko_r+0x390>
8111ad00:	80c00f17 	ldw	r3,60(r16)
8111ad04:	80800417 	ldw	r2,16(r16)
8111ad08:	98e7c83a 	sub	r19,r19,r3
8111ad0c:	003fbc06 	br	8111ac00 <__reset+0xfb0fac00>
8111ad10:	8140038f 	ldh	r5,14(r16)
8111ad14:	d80d883a 	mov	r6,sp
8111ad18:	8809883a 	mov	r4,r17
8111ad1c:	111aec40 	call	8111aec4 <_fstat_r>
8111ad20:	103f891e 	bne	r2,zero,8111ab48 <__reset+0xfb0fab48>
8111ad24:	dd800417 	ldw	r22,16(sp)
8111ad28:	adad883a 	add	r22,r21,r22
8111ad2c:	b83fc926 	beq	r23,zero,8111ac54 <__reset+0xfb0fac54>
8111ad30:	81400c17 	ldw	r5,48(r16)
8111ad34:	81800117 	ldw	r6,4(r16)
8111ad38:	28005026 	beq	r5,zero,8111ae7c <_fseeko_r+0x420>
8111ad3c:	81c00f17 	ldw	r7,60(r16)
8111ad40:	003fce06 	br	8111ac7c <__reset+0xfb0fac7c>
8111ad44:	84c01317 	ldw	r19,76(r16)
8111ad48:	81400717 	ldw	r5,28(r16)
8111ad4c:	000f883a 	mov	r7,zero
8111ad50:	04e7c83a 	sub	r19,zero,r19
8111ad54:	9da6703a 	and	r19,r19,r22
8111ad58:	980d883a 	mov	r6,r19
8111ad5c:	8809883a 	mov	r4,r17
8111ad60:	a03ee83a 	callr	r20
8111ad64:	00ffffc4 	movi	r3,-1
8111ad68:	10ff7726 	beq	r2,r3,8111ab48 <__reset+0xfb0fab48>
8111ad6c:	80800417 	ldw	r2,16(r16)
8111ad70:	81400c17 	ldw	r5,48(r16)
8111ad74:	80000115 	stw	zero,4(r16)
8111ad78:	80800015 	stw	r2,0(r16)
8111ad7c:	28000526 	beq	r5,zero,8111ad94 <_fseeko_r+0x338>
8111ad80:	80801004 	addi	r2,r16,64
8111ad84:	28800226 	beq	r5,r2,8111ad90 <_fseeko_r+0x334>
8111ad88:	8809883a 	mov	r4,r17
8111ad8c:	1124c700 	call	81124c70 <_free_r>
8111ad90:	80000c15 	stw	zero,48(r16)
8111ad94:	8080030b 	ldhu	r2,12(r16)
8111ad98:	b4e7c83a 	sub	r19,r22,r19
8111ad9c:	10bff7cc 	andi	r2,r2,65503
8111ada0:	8080030d 	sth	r2,12(r16)
8111ada4:	98000b26 	beq	r19,zero,8111add4 <_fseeko_r+0x378>
8111ada8:	800b883a 	mov	r5,r16
8111adac:	8809883a 	mov	r4,r17
8111adb0:	111bfdc0 	call	8111bfdc <__srefill_r>
8111adb4:	103f641e 	bne	r2,zero,8111ab48 <__reset+0xfb0fab48>
8111adb8:	80800117 	ldw	r2,4(r16)
8111adbc:	14ff6236 	bltu	r2,r19,8111ab48 <__reset+0xfb0fab48>
8111adc0:	80c00017 	ldw	r3,0(r16)
8111adc4:	14c5c83a 	sub	r2,r2,r19
8111adc8:	80800115 	stw	r2,4(r16)
8111adcc:	1ce7883a 	add	r19,r3,r19
8111add0:	84c00015 	stw	r19,0(r16)
8111add4:	01800204 	movi	r6,8
8111add8:	000b883a 	mov	r5,zero
8111addc:	81001704 	addi	r4,r16,92
8111ade0:	111bb600 	call	8111bb60 <memset>
8111ade4:	0027883a 	mov	r19,zero
8111ade8:	003f3d06 	br	8111aae0 <__reset+0xfb0faae0>
8111adec:	80800417 	ldw	r2,16(r16)
8111adf0:	003f8306 	br	8111ac00 <__reset+0xfb0fac00>
8111adf4:	81400717 	ldw	r5,28(r16)
8111adf8:	900f883a 	mov	r7,r18
8111adfc:	000d883a 	mov	r6,zero
8111ae00:	8809883a 	mov	r4,r17
8111ae04:	a03ee83a 	callr	r20
8111ae08:	1027883a 	mov	r19,r2
8111ae0c:	00bfffc4 	movi	r2,-1
8111ae10:	98bf3226 	beq	r19,r2,8111aadc <__reset+0xfb0faadc>
8111ae14:	8080030b 	ldhu	r2,12(r16)
8111ae18:	003f7006 	br	8111abdc <__reset+0xfb0fabdc>
8111ae1c:	8140038f 	ldh	r5,14(r16)
8111ae20:	283f4716 	blt	r5,zero,8111ab40 <__reset+0xfb0fab40>
8111ae24:	d80d883a 	mov	r6,sp
8111ae28:	8809883a 	mov	r4,r17
8111ae2c:	111aec40 	call	8111aec4 <_fstat_r>
8111ae30:	1000041e 	bne	r2,zero,8111ae44 <_fseeko_r+0x3e8>
8111ae34:	d8800117 	ldw	r2,4(sp)
8111ae38:	00e00014 	movui	r3,32768
8111ae3c:	10bc000c 	andi	r2,r2,61440
8111ae40:	10ff7c26 	beq	r2,r3,8111ac34 <__reset+0xfb0fac34>
8111ae44:	8080030b 	ldhu	r2,12(r16)
8111ae48:	003f3d06 	br	8111ab40 <__reset+0xfb0fab40>
8111ae4c:	800b883a 	mov	r5,r16
8111ae50:	8809883a 	mov	r4,r17
8111ae54:	111b0380 	call	8111b038 <__smakebuf_r>
8111ae58:	003f3106 	br	8111ab20 <__reset+0xfb0fab20>
8111ae5c:	81400717 	ldw	r5,28(r16)
8111ae60:	01c00044 	movi	r7,1
8111ae64:	000d883a 	mov	r6,zero
8111ae68:	8809883a 	mov	r4,r17
8111ae6c:	a03ee83a 	callr	r20
8111ae70:	00ffffc4 	movi	r3,-1
8111ae74:	10ff7b1e 	bne	r2,r3,8111ac64 <__reset+0xfb0fac64>
8111ae78:	003f3306 	br	8111ab48 <__reset+0xfb0fab48>
8111ae7c:	80c00017 	ldw	r3,0(r16)
8111ae80:	80800417 	ldw	r2,16(r16)
8111ae84:	000b883a 	mov	r5,zero
8111ae88:	1887c83a 	sub	r3,r3,r2
8111ae8c:	98e7c83a 	sub	r19,r19,r3
8111ae90:	30c7883a 	add	r3,r6,r3
8111ae94:	003f7f06 	br	8111ac94 <__reset+0xfb0fac94>
8111ae98:	00800744 	movi	r2,29
8111ae9c:	88800015 	stw	r2,0(r17)
8111aea0:	04ffffc4 	movi	r19,-1
8111aea4:	003f0e06 	br	8111aae0 <__reset+0xfb0faae0>

8111aea8 <fseeko>:
8111aea8:	00a04574 	movhi	r2,33045
8111aeac:	10b08204 	addi	r2,r2,-15864
8111aeb0:	300f883a 	mov	r7,r6
8111aeb4:	280d883a 	mov	r6,r5
8111aeb8:	200b883a 	mov	r5,r4
8111aebc:	11000017 	ldw	r4,0(r2)
8111aec0:	111aa5c1 	jmpi	8111aa5c <_fseeko_r>

8111aec4 <_fstat_r>:
8111aec4:	defffd04 	addi	sp,sp,-12
8111aec8:	de00012e 	bgeu	sp,et,8111aed0 <_fstat_r+0xc>
8111aecc:	003b68fa 	trap	3
8111aed0:	2805883a 	mov	r2,r5
8111aed4:	dc000015 	stw	r16,0(sp)
8111aed8:	04204574 	movhi	r16,33045
8111aedc:	dc400115 	stw	r17,4(sp)
8111aee0:	8430fa04 	addi	r16,r16,-15384
8111aee4:	2023883a 	mov	r17,r4
8111aee8:	300b883a 	mov	r5,r6
8111aeec:	1009883a 	mov	r4,r2
8111aef0:	dfc00215 	stw	ra,8(sp)
8111aef4:	80000015 	stw	zero,0(r16)
8111aef8:	11304b00 	call	811304b0 <fstat>
8111aefc:	00ffffc4 	movi	r3,-1
8111af00:	10c00526 	beq	r2,r3,8111af18 <_fstat_r+0x54>
8111af04:	dfc00217 	ldw	ra,8(sp)
8111af08:	dc400117 	ldw	r17,4(sp)
8111af0c:	dc000017 	ldw	r16,0(sp)
8111af10:	dec00304 	addi	sp,sp,12
8111af14:	f800283a 	ret
8111af18:	80c00017 	ldw	r3,0(r16)
8111af1c:	183ff926 	beq	r3,zero,8111af04 <__reset+0xfb0faf04>
8111af20:	88c00015 	stw	r3,0(r17)
8111af24:	003ff706 	br	8111af04 <__reset+0xfb0faf04>

8111af28 <_fwrite_r>:
8111af28:	defff504 	addi	sp,sp,-44
8111af2c:	de00012e 	bgeu	sp,et,8111af34 <_fwrite_r+0xc>
8111af30:	003b68fa 	trap	3
8111af34:	dc800815 	stw	r18,32(sp)
8111af38:	39a5383a 	mul	r18,r7,r6
8111af3c:	d8800304 	addi	r2,sp,12
8111af40:	d8800015 	stw	r2,0(sp)
8111af44:	00800044 	movi	r2,1
8111af48:	dcc00915 	stw	r19,36(sp)
8111af4c:	dc400715 	stw	r17,28(sp)
8111af50:	dc000615 	stw	r16,24(sp)
8111af54:	d9400315 	stw	r5,12(sp)
8111af58:	dfc00a15 	stw	ra,40(sp)
8111af5c:	dc800415 	stw	r18,16(sp)
8111af60:	dc800215 	stw	r18,8(sp)
8111af64:	d8800115 	stw	r2,4(sp)
8111af68:	3027883a 	mov	r19,r6
8111af6c:	3821883a 	mov	r16,r7
8111af70:	2023883a 	mov	r17,r4
8111af74:	d9400b17 	ldw	r5,44(sp)
8111af78:	20000226 	beq	r4,zero,8111af84 <_fwrite_r+0x5c>
8111af7c:	20800e17 	ldw	r2,56(r4)
8111af80:	10001a26 	beq	r2,zero,8111afec <_fwrite_r+0xc4>
8111af84:	2880030b 	ldhu	r2,12(r5)
8111af88:	10c8000c 	andi	r3,r2,8192
8111af8c:	1800061e 	bne	r3,zero,8111afa8 <_fwrite_r+0x80>
8111af90:	29001917 	ldw	r4,100(r5)
8111af94:	00f7ffc4 	movi	r3,-8193
8111af98:	10880014 	ori	r2,r2,8192
8111af9c:	20c6703a 	and	r3,r4,r3
8111afa0:	2880030d 	sth	r2,12(r5)
8111afa4:	28c01915 	stw	r3,100(r5)
8111afa8:	d80d883a 	mov	r6,sp
8111afac:	8809883a 	mov	r4,r17
8111afb0:	1124f880 	call	81124f88 <__sfvwrite_r>
8111afb4:	10000b26 	beq	r2,zero,8111afe4 <_fwrite_r+0xbc>
8111afb8:	d9000217 	ldw	r4,8(sp)
8111afbc:	980b883a 	mov	r5,r19
8111afc0:	9109c83a 	sub	r4,r18,r4
8111afc4:	112dff80 	call	8112dff8 <__udivsi3>
8111afc8:	dfc00a17 	ldw	ra,40(sp)
8111afcc:	dcc00917 	ldw	r19,36(sp)
8111afd0:	dc800817 	ldw	r18,32(sp)
8111afd4:	dc400717 	ldw	r17,28(sp)
8111afd8:	dc000617 	ldw	r16,24(sp)
8111afdc:	dec00b04 	addi	sp,sp,44
8111afe0:	f800283a 	ret
8111afe4:	8005883a 	mov	r2,r16
8111afe8:	003ff706 	br	8111afc8 <__reset+0xfb0fafc8>
8111afec:	d9400515 	stw	r5,20(sp)
8111aff0:	11247d80 	call	811247d8 <__sinit>
8111aff4:	d9400517 	ldw	r5,20(sp)
8111aff8:	003fe206 	br	8111af84 <__reset+0xfb0faf84>

8111affc <fwrite>:
8111affc:	defffe04 	addi	sp,sp,-8
8111b000:	00a04574 	movhi	r2,33045
8111b004:	de00012e 	bgeu	sp,et,8111b00c <fwrite+0x10>
8111b008:	003b68fa 	trap	3
8111b00c:	10b08204 	addi	r2,r2,-15864
8111b010:	d9c00015 	stw	r7,0(sp)
8111b014:	300f883a 	mov	r7,r6
8111b018:	280d883a 	mov	r6,r5
8111b01c:	200b883a 	mov	r5,r4
8111b020:	11000017 	ldw	r4,0(r2)
8111b024:	dfc00115 	stw	ra,4(sp)
8111b028:	111af280 	call	8111af28 <_fwrite_r>
8111b02c:	dfc00117 	ldw	ra,4(sp)
8111b030:	dec00204 	addi	sp,sp,8
8111b034:	f800283a 	ret

8111b038 <__smakebuf_r>:
8111b038:	2880030b 	ldhu	r2,12(r5)
8111b03c:	10c0008c 	andi	r3,r2,2
8111b040:	1800431e 	bne	r3,zero,8111b150 <__smakebuf_r+0x118>
8111b044:	deffec04 	addi	sp,sp,-80
8111b048:	de00012e 	bgeu	sp,et,8111b050 <__smakebuf_r+0x18>
8111b04c:	003b68fa 	trap	3
8111b050:	dc000f15 	stw	r16,60(sp)
8111b054:	2821883a 	mov	r16,r5
8111b058:	2940038f 	ldh	r5,14(r5)
8111b05c:	dc401015 	stw	r17,64(sp)
8111b060:	dfc01315 	stw	ra,76(sp)
8111b064:	dcc01215 	stw	r19,72(sp)
8111b068:	dc801115 	stw	r18,68(sp)
8111b06c:	2023883a 	mov	r17,r4
8111b070:	28001c16 	blt	r5,zero,8111b0e4 <__smakebuf_r+0xac>
8111b074:	d80d883a 	mov	r6,sp
8111b078:	111aec40 	call	8111aec4 <_fstat_r>
8111b07c:	10001816 	blt	r2,zero,8111b0e0 <__smakebuf_r+0xa8>
8111b080:	d8800117 	ldw	r2,4(sp)
8111b084:	00e00014 	movui	r3,32768
8111b088:	10bc000c 	andi	r2,r2,61440
8111b08c:	14c80020 	cmpeqi	r19,r2,8192
8111b090:	10c03726 	beq	r2,r3,8111b170 <__smakebuf_r+0x138>
8111b094:	80c0030b 	ldhu	r3,12(r16)
8111b098:	18c20014 	ori	r3,r3,2048
8111b09c:	80c0030d 	sth	r3,12(r16)
8111b0a0:	00c80004 	movi	r3,8192
8111b0a4:	10c0521e 	bne	r2,r3,8111b1f0 <__smakebuf_r+0x1b8>
8111b0a8:	8140038f 	ldh	r5,14(r16)
8111b0ac:	8809883a 	mov	r4,r17
8111b0b0:	11255e40 	call	811255e4 <_isatty_r>
8111b0b4:	10004c26 	beq	r2,zero,8111b1e8 <__smakebuf_r+0x1b0>
8111b0b8:	8080030b 	ldhu	r2,12(r16)
8111b0bc:	80c010c4 	addi	r3,r16,67
8111b0c0:	80c00015 	stw	r3,0(r16)
8111b0c4:	10800054 	ori	r2,r2,1
8111b0c8:	8080030d 	sth	r2,12(r16)
8111b0cc:	00800044 	movi	r2,1
8111b0d0:	80c00415 	stw	r3,16(r16)
8111b0d4:	80800515 	stw	r2,20(r16)
8111b0d8:	04810004 	movi	r18,1024
8111b0dc:	00000706 	br	8111b0fc <__smakebuf_r+0xc4>
8111b0e0:	8080030b 	ldhu	r2,12(r16)
8111b0e4:	10c0200c 	andi	r3,r2,128
8111b0e8:	18001f1e 	bne	r3,zero,8111b168 <__smakebuf_r+0x130>
8111b0ec:	04810004 	movi	r18,1024
8111b0f0:	10820014 	ori	r2,r2,2048
8111b0f4:	8080030d 	sth	r2,12(r16)
8111b0f8:	0027883a 	mov	r19,zero
8111b0fc:	900b883a 	mov	r5,r18
8111b100:	8809883a 	mov	r4,r17
8111b104:	111b1fc0 	call	8111b1fc <_malloc_r>
8111b108:	10002c26 	beq	r2,zero,8111b1bc <__smakebuf_r+0x184>
8111b10c:	80c0030b 	ldhu	r3,12(r16)
8111b110:	012044b4 	movhi	r4,33042
8111b114:	21111e04 	addi	r4,r4,17528
8111b118:	89000f15 	stw	r4,60(r17)
8111b11c:	18c02014 	ori	r3,r3,128
8111b120:	80c0030d 	sth	r3,12(r16)
8111b124:	80800015 	stw	r2,0(r16)
8111b128:	80800415 	stw	r2,16(r16)
8111b12c:	84800515 	stw	r18,20(r16)
8111b130:	98001a1e 	bne	r19,zero,8111b19c <__smakebuf_r+0x164>
8111b134:	dfc01317 	ldw	ra,76(sp)
8111b138:	dcc01217 	ldw	r19,72(sp)
8111b13c:	dc801117 	ldw	r18,68(sp)
8111b140:	dc401017 	ldw	r17,64(sp)
8111b144:	dc000f17 	ldw	r16,60(sp)
8111b148:	dec01404 	addi	sp,sp,80
8111b14c:	f800283a 	ret
8111b150:	288010c4 	addi	r2,r5,67
8111b154:	28800015 	stw	r2,0(r5)
8111b158:	28800415 	stw	r2,16(r5)
8111b15c:	00800044 	movi	r2,1
8111b160:	28800515 	stw	r2,20(r5)
8111b164:	f800283a 	ret
8111b168:	04801004 	movi	r18,64
8111b16c:	003fe006 	br	8111b0f0 <__reset+0xfb0fb0f0>
8111b170:	81000a17 	ldw	r4,40(r16)
8111b174:	00e044b4 	movhi	r3,33042
8111b178:	18f11304 	addi	r3,r3,-15284
8111b17c:	20ffc51e 	bne	r4,r3,8111b094 <__reset+0xfb0fb094>
8111b180:	8080030b 	ldhu	r2,12(r16)
8111b184:	04810004 	movi	r18,1024
8111b188:	84801315 	stw	r18,76(r16)
8111b18c:	1484b03a 	or	r2,r2,r18
8111b190:	8080030d 	sth	r2,12(r16)
8111b194:	0027883a 	mov	r19,zero
8111b198:	003fd806 	br	8111b0fc <__reset+0xfb0fb0fc>
8111b19c:	8140038f 	ldh	r5,14(r16)
8111b1a0:	8809883a 	mov	r4,r17
8111b1a4:	11255e40 	call	811255e4 <_isatty_r>
8111b1a8:	103fe226 	beq	r2,zero,8111b134 <__reset+0xfb0fb134>
8111b1ac:	8080030b 	ldhu	r2,12(r16)
8111b1b0:	10800054 	ori	r2,r2,1
8111b1b4:	8080030d 	sth	r2,12(r16)
8111b1b8:	003fde06 	br	8111b134 <__reset+0xfb0fb134>
8111b1bc:	8080030b 	ldhu	r2,12(r16)
8111b1c0:	10c0800c 	andi	r3,r2,512
8111b1c4:	183fdb1e 	bne	r3,zero,8111b134 <__reset+0xfb0fb134>
8111b1c8:	10800094 	ori	r2,r2,2
8111b1cc:	80c010c4 	addi	r3,r16,67
8111b1d0:	8080030d 	sth	r2,12(r16)
8111b1d4:	00800044 	movi	r2,1
8111b1d8:	80c00015 	stw	r3,0(r16)
8111b1dc:	80c00415 	stw	r3,16(r16)
8111b1e0:	80800515 	stw	r2,20(r16)
8111b1e4:	003fd306 	br	8111b134 <__reset+0xfb0fb134>
8111b1e8:	04810004 	movi	r18,1024
8111b1ec:	003fc306 	br	8111b0fc <__reset+0xfb0fb0fc>
8111b1f0:	0027883a 	mov	r19,zero
8111b1f4:	04810004 	movi	r18,1024
8111b1f8:	003fc006 	br	8111b0fc <__reset+0xfb0fb0fc>

8111b1fc <_malloc_r>:
8111b1fc:	defff504 	addi	sp,sp,-44
8111b200:	de00012e 	bgeu	sp,et,8111b208 <_malloc_r+0xc>
8111b204:	003b68fa 	trap	3
8111b208:	288002c4 	addi	r2,r5,11
8111b20c:	dc800315 	stw	r18,12(sp)
8111b210:	dfc00a15 	stw	ra,40(sp)
8111b214:	df000915 	stw	fp,36(sp)
8111b218:	ddc00815 	stw	r23,32(sp)
8111b21c:	dd800715 	stw	r22,28(sp)
8111b220:	dd400615 	stw	r21,24(sp)
8111b224:	dd000515 	stw	r20,20(sp)
8111b228:	dcc00415 	stw	r19,16(sp)
8111b22c:	dc400215 	stw	r17,8(sp)
8111b230:	dc000115 	stw	r16,4(sp)
8111b234:	00c00584 	movi	r3,22
8111b238:	2025883a 	mov	r18,r4
8111b23c:	18807f2e 	bgeu	r3,r2,8111b43c <_malloc_r+0x240>
8111b240:	047ffe04 	movi	r17,-8
8111b244:	1462703a 	and	r17,r2,r17
8111b248:	8800a316 	blt	r17,zero,8111b4d8 <_malloc_r+0x2dc>
8111b24c:	8940a236 	bltu	r17,r5,8111b4d8 <_malloc_r+0x2dc>
8111b250:	1131ff80 	call	81131ff8 <__malloc_lock>
8111b254:	00807dc4 	movi	r2,503
8111b258:	1441e92e 	bgeu	r2,r17,8111ba00 <_malloc_r+0x804>
8111b25c:	8804d27a 	srli	r2,r17,9
8111b260:	1000a126 	beq	r2,zero,8111b4e8 <_malloc_r+0x2ec>
8111b264:	00c00104 	movi	r3,4
8111b268:	18811e36 	bltu	r3,r2,8111b6e4 <_malloc_r+0x4e8>
8111b26c:	8804d1ba 	srli	r2,r17,6
8111b270:	12000e44 	addi	r8,r2,57
8111b274:	11c00e04 	addi	r7,r2,56
8111b278:	4209883a 	add	r4,r8,r8
8111b27c:	04e04574 	movhi	r19,33045
8111b280:	2109883a 	add	r4,r4,r4
8111b284:	9cea4004 	addi	r19,r19,-22272
8111b288:	2109883a 	add	r4,r4,r4
8111b28c:	9909883a 	add	r4,r19,r4
8111b290:	24000117 	ldw	r16,4(r4)
8111b294:	213ffe04 	addi	r4,r4,-8
8111b298:	24009726 	beq	r4,r16,8111b4f8 <_malloc_r+0x2fc>
8111b29c:	80800117 	ldw	r2,4(r16)
8111b2a0:	01bfff04 	movi	r6,-4
8111b2a4:	014003c4 	movi	r5,15
8111b2a8:	1184703a 	and	r2,r2,r6
8111b2ac:	1447c83a 	sub	r3,r2,r17
8111b2b0:	28c00716 	blt	r5,r3,8111b2d0 <_malloc_r+0xd4>
8111b2b4:	1800920e 	bge	r3,zero,8111b500 <_malloc_r+0x304>
8111b2b8:	84000317 	ldw	r16,12(r16)
8111b2bc:	24008e26 	beq	r4,r16,8111b4f8 <_malloc_r+0x2fc>
8111b2c0:	80800117 	ldw	r2,4(r16)
8111b2c4:	1184703a 	and	r2,r2,r6
8111b2c8:	1447c83a 	sub	r3,r2,r17
8111b2cc:	28fff90e 	bge	r5,r3,8111b2b4 <__reset+0xfb0fb2b4>
8111b2d0:	3809883a 	mov	r4,r7
8111b2d4:	01a04574 	movhi	r6,33045
8111b2d8:	9c000417 	ldw	r16,16(r19)
8111b2dc:	31aa4004 	addi	r6,r6,-22272
8111b2e0:	32000204 	addi	r8,r6,8
8111b2e4:	82013426 	beq	r16,r8,8111b7b8 <_malloc_r+0x5bc>
8111b2e8:	80c00117 	ldw	r3,4(r16)
8111b2ec:	00bfff04 	movi	r2,-4
8111b2f0:	188e703a 	and	r7,r3,r2
8111b2f4:	3c45c83a 	sub	r2,r7,r17
8111b2f8:	00c003c4 	movi	r3,15
8111b2fc:	18811f16 	blt	r3,r2,8111b77c <_malloc_r+0x580>
8111b300:	32000515 	stw	r8,20(r6)
8111b304:	32000415 	stw	r8,16(r6)
8111b308:	10007f0e 	bge	r2,zero,8111b508 <_malloc_r+0x30c>
8111b30c:	00807fc4 	movi	r2,511
8111b310:	11c0fd36 	bltu	r2,r7,8111b708 <_malloc_r+0x50c>
8111b314:	3806d0fa 	srli	r3,r7,3
8111b318:	01c00044 	movi	r7,1
8111b31c:	30800117 	ldw	r2,4(r6)
8111b320:	19400044 	addi	r5,r3,1
8111b324:	294b883a 	add	r5,r5,r5
8111b328:	1807d0ba 	srai	r3,r3,2
8111b32c:	294b883a 	add	r5,r5,r5
8111b330:	294b883a 	add	r5,r5,r5
8111b334:	298b883a 	add	r5,r5,r6
8111b338:	38c6983a 	sll	r3,r7,r3
8111b33c:	29c00017 	ldw	r7,0(r5)
8111b340:	2a7ffe04 	addi	r9,r5,-8
8111b344:	1886b03a 	or	r3,r3,r2
8111b348:	82400315 	stw	r9,12(r16)
8111b34c:	81c00215 	stw	r7,8(r16)
8111b350:	30c00115 	stw	r3,4(r6)
8111b354:	2c000015 	stw	r16,0(r5)
8111b358:	3c000315 	stw	r16,12(r7)
8111b35c:	2005d0ba 	srai	r2,r4,2
8111b360:	01400044 	movi	r5,1
8111b364:	288a983a 	sll	r5,r5,r2
8111b368:	19406f36 	bltu	r3,r5,8111b528 <_malloc_r+0x32c>
8111b36c:	28c4703a 	and	r2,r5,r3
8111b370:	10000a1e 	bne	r2,zero,8111b39c <_malloc_r+0x1a0>
8111b374:	00bfff04 	movi	r2,-4
8111b378:	294b883a 	add	r5,r5,r5
8111b37c:	2088703a 	and	r4,r4,r2
8111b380:	28c4703a 	and	r2,r5,r3
8111b384:	21000104 	addi	r4,r4,4
8111b388:	1000041e 	bne	r2,zero,8111b39c <_malloc_r+0x1a0>
8111b38c:	294b883a 	add	r5,r5,r5
8111b390:	28c4703a 	and	r2,r5,r3
8111b394:	21000104 	addi	r4,r4,4
8111b398:	103ffc26 	beq	r2,zero,8111b38c <__reset+0xfb0fb38c>
8111b39c:	02bfff04 	movi	r10,-4
8111b3a0:	024003c4 	movi	r9,15
8111b3a4:	21800044 	addi	r6,r4,1
8111b3a8:	318d883a 	add	r6,r6,r6
8111b3ac:	318d883a 	add	r6,r6,r6
8111b3b0:	318d883a 	add	r6,r6,r6
8111b3b4:	998d883a 	add	r6,r19,r6
8111b3b8:	333ffe04 	addi	r12,r6,-8
8111b3bc:	2017883a 	mov	r11,r4
8111b3c0:	31800104 	addi	r6,r6,4
8111b3c4:	34000017 	ldw	r16,0(r6)
8111b3c8:	31fffd04 	addi	r7,r6,-12
8111b3cc:	81c0041e 	bne	r16,r7,8111b3e0 <_malloc_r+0x1e4>
8111b3d0:	0000fb06 	br	8111b7c0 <_malloc_r+0x5c4>
8111b3d4:	1801030e 	bge	r3,zero,8111b7e4 <_malloc_r+0x5e8>
8111b3d8:	84000317 	ldw	r16,12(r16)
8111b3dc:	81c0f826 	beq	r16,r7,8111b7c0 <_malloc_r+0x5c4>
8111b3e0:	80800117 	ldw	r2,4(r16)
8111b3e4:	1284703a 	and	r2,r2,r10
8111b3e8:	1447c83a 	sub	r3,r2,r17
8111b3ec:	48fff90e 	bge	r9,r3,8111b3d4 <__reset+0xfb0fb3d4>
8111b3f0:	80800317 	ldw	r2,12(r16)
8111b3f4:	81000217 	ldw	r4,8(r16)
8111b3f8:	89400054 	ori	r5,r17,1
8111b3fc:	81400115 	stw	r5,4(r16)
8111b400:	20800315 	stw	r2,12(r4)
8111b404:	11000215 	stw	r4,8(r2)
8111b408:	8463883a 	add	r17,r16,r17
8111b40c:	9c400515 	stw	r17,20(r19)
8111b410:	9c400415 	stw	r17,16(r19)
8111b414:	18800054 	ori	r2,r3,1
8111b418:	88800115 	stw	r2,4(r17)
8111b41c:	8a000315 	stw	r8,12(r17)
8111b420:	8a000215 	stw	r8,8(r17)
8111b424:	88e3883a 	add	r17,r17,r3
8111b428:	88c00015 	stw	r3,0(r17)
8111b42c:	9009883a 	mov	r4,r18
8111b430:	11321200 	call	81132120 <__malloc_unlock>
8111b434:	80800204 	addi	r2,r16,8
8111b438:	00001b06 	br	8111b4a8 <_malloc_r+0x2ac>
8111b43c:	04400404 	movi	r17,16
8111b440:	89402536 	bltu	r17,r5,8111b4d8 <_malloc_r+0x2dc>
8111b444:	1131ff80 	call	81131ff8 <__malloc_lock>
8111b448:	00800184 	movi	r2,6
8111b44c:	01000084 	movi	r4,2
8111b450:	04e04574 	movhi	r19,33045
8111b454:	1085883a 	add	r2,r2,r2
8111b458:	9cea4004 	addi	r19,r19,-22272
8111b45c:	1085883a 	add	r2,r2,r2
8111b460:	9885883a 	add	r2,r19,r2
8111b464:	14000117 	ldw	r16,4(r2)
8111b468:	10fffe04 	addi	r3,r2,-8
8111b46c:	80c0d926 	beq	r16,r3,8111b7d4 <_malloc_r+0x5d8>
8111b470:	80c00117 	ldw	r3,4(r16)
8111b474:	81000317 	ldw	r4,12(r16)
8111b478:	00bfff04 	movi	r2,-4
8111b47c:	1884703a 	and	r2,r3,r2
8111b480:	81400217 	ldw	r5,8(r16)
8111b484:	8085883a 	add	r2,r16,r2
8111b488:	10c00117 	ldw	r3,4(r2)
8111b48c:	29000315 	stw	r4,12(r5)
8111b490:	21400215 	stw	r5,8(r4)
8111b494:	18c00054 	ori	r3,r3,1
8111b498:	10c00115 	stw	r3,4(r2)
8111b49c:	9009883a 	mov	r4,r18
8111b4a0:	11321200 	call	81132120 <__malloc_unlock>
8111b4a4:	80800204 	addi	r2,r16,8
8111b4a8:	dfc00a17 	ldw	ra,40(sp)
8111b4ac:	df000917 	ldw	fp,36(sp)
8111b4b0:	ddc00817 	ldw	r23,32(sp)
8111b4b4:	dd800717 	ldw	r22,28(sp)
8111b4b8:	dd400617 	ldw	r21,24(sp)
8111b4bc:	dd000517 	ldw	r20,20(sp)
8111b4c0:	dcc00417 	ldw	r19,16(sp)
8111b4c4:	dc800317 	ldw	r18,12(sp)
8111b4c8:	dc400217 	ldw	r17,8(sp)
8111b4cc:	dc000117 	ldw	r16,4(sp)
8111b4d0:	dec00b04 	addi	sp,sp,44
8111b4d4:	f800283a 	ret
8111b4d8:	00800304 	movi	r2,12
8111b4dc:	90800015 	stw	r2,0(r18)
8111b4e0:	0005883a 	mov	r2,zero
8111b4e4:	003ff006 	br	8111b4a8 <__reset+0xfb0fb4a8>
8111b4e8:	01002004 	movi	r4,128
8111b4ec:	02001004 	movi	r8,64
8111b4f0:	01c00fc4 	movi	r7,63
8111b4f4:	003f6106 	br	8111b27c <__reset+0xfb0fb27c>
8111b4f8:	4009883a 	mov	r4,r8
8111b4fc:	003f7506 	br	8111b2d4 <__reset+0xfb0fb2d4>
8111b500:	81000317 	ldw	r4,12(r16)
8111b504:	003fde06 	br	8111b480 <__reset+0xfb0fb480>
8111b508:	81c5883a 	add	r2,r16,r7
8111b50c:	11400117 	ldw	r5,4(r2)
8111b510:	9009883a 	mov	r4,r18
8111b514:	29400054 	ori	r5,r5,1
8111b518:	11400115 	stw	r5,4(r2)
8111b51c:	11321200 	call	81132120 <__malloc_unlock>
8111b520:	80800204 	addi	r2,r16,8
8111b524:	003fe006 	br	8111b4a8 <__reset+0xfb0fb4a8>
8111b528:	9c000217 	ldw	r16,8(r19)
8111b52c:	00bfff04 	movi	r2,-4
8111b530:	85800117 	ldw	r22,4(r16)
8111b534:	b0ac703a 	and	r22,r22,r2
8111b538:	b4400336 	bltu	r22,r17,8111b548 <_malloc_r+0x34c>
8111b53c:	b445c83a 	sub	r2,r22,r17
8111b540:	00c003c4 	movi	r3,15
8111b544:	18805d16 	blt	r3,r2,8111b6bc <_malloc_r+0x4c0>
8111b548:	05e04574 	movhi	r23,33045
8111b54c:	00a04574 	movhi	r2,33045
8111b550:	10b0fd04 	addi	r2,r2,-15372
8111b554:	bdf08304 	addi	r23,r23,-15860
8111b558:	15400017 	ldw	r21,0(r2)
8111b55c:	b8c00017 	ldw	r3,0(r23)
8111b560:	00bfffc4 	movi	r2,-1
8111b564:	858d883a 	add	r6,r16,r22
8111b568:	8d6b883a 	add	r21,r17,r21
8111b56c:	1880ea26 	beq	r3,r2,8111b918 <_malloc_r+0x71c>
8111b570:	ad4403c4 	addi	r21,r21,4111
8111b574:	00bc0004 	movi	r2,-4096
8111b578:	a8aa703a 	and	r21,r21,r2
8111b57c:	a80b883a 	mov	r5,r21
8111b580:	9009883a 	mov	r4,r18
8111b584:	d9800015 	stw	r6,0(sp)
8111b588:	111c1b80 	call	8111c1b8 <_sbrk_r>
8111b58c:	1029883a 	mov	r20,r2
8111b590:	00bfffc4 	movi	r2,-1
8111b594:	d9800017 	ldw	r6,0(sp)
8111b598:	a080e826 	beq	r20,r2,8111b93c <_malloc_r+0x740>
8111b59c:	a180a636 	bltu	r20,r6,8111b838 <_malloc_r+0x63c>
8111b5a0:	07204574 	movhi	fp,33045
8111b5a4:	e7319f04 	addi	fp,fp,-14724
8111b5a8:	e0800017 	ldw	r2,0(fp)
8111b5ac:	a887883a 	add	r3,r21,r2
8111b5b0:	e0c00015 	stw	r3,0(fp)
8111b5b4:	3500e626 	beq	r6,r20,8111b950 <_malloc_r+0x754>
8111b5b8:	b9000017 	ldw	r4,0(r23)
8111b5bc:	00bfffc4 	movi	r2,-1
8111b5c0:	2080ee26 	beq	r4,r2,8111b97c <_malloc_r+0x780>
8111b5c4:	a185c83a 	sub	r2,r20,r6
8111b5c8:	10c5883a 	add	r2,r2,r3
8111b5cc:	e0800015 	stw	r2,0(fp)
8111b5d0:	a0c001cc 	andi	r3,r20,7
8111b5d4:	1800bc26 	beq	r3,zero,8111b8c8 <_malloc_r+0x6cc>
8111b5d8:	a0e9c83a 	sub	r20,r20,r3
8111b5dc:	00840204 	movi	r2,4104
8111b5e0:	a5000204 	addi	r20,r20,8
8111b5e4:	10c7c83a 	sub	r3,r2,r3
8111b5e8:	a545883a 	add	r2,r20,r21
8111b5ec:	1083ffcc 	andi	r2,r2,4095
8111b5f0:	18abc83a 	sub	r21,r3,r2
8111b5f4:	a80b883a 	mov	r5,r21
8111b5f8:	9009883a 	mov	r4,r18
8111b5fc:	111c1b80 	call	8111c1b8 <_sbrk_r>
8111b600:	00ffffc4 	movi	r3,-1
8111b604:	10c0e126 	beq	r2,r3,8111b98c <_malloc_r+0x790>
8111b608:	1505c83a 	sub	r2,r2,r20
8111b60c:	1545883a 	add	r2,r2,r21
8111b610:	10800054 	ori	r2,r2,1
8111b614:	e0c00017 	ldw	r3,0(fp)
8111b618:	9d000215 	stw	r20,8(r19)
8111b61c:	a0800115 	stw	r2,4(r20)
8111b620:	a8c7883a 	add	r3,r21,r3
8111b624:	e0c00015 	stw	r3,0(fp)
8111b628:	84c00e26 	beq	r16,r19,8111b664 <_malloc_r+0x468>
8111b62c:	018003c4 	movi	r6,15
8111b630:	3580a72e 	bgeu	r6,r22,8111b8d0 <_malloc_r+0x6d4>
8111b634:	81400117 	ldw	r5,4(r16)
8111b638:	013ffe04 	movi	r4,-8
8111b63c:	b0bffd04 	addi	r2,r22,-12
8111b640:	1104703a 	and	r2,r2,r4
8111b644:	2900004c 	andi	r4,r5,1
8111b648:	2088b03a 	or	r4,r4,r2
8111b64c:	81000115 	stw	r4,4(r16)
8111b650:	01400144 	movi	r5,5
8111b654:	8089883a 	add	r4,r16,r2
8111b658:	21400115 	stw	r5,4(r4)
8111b65c:	21400215 	stw	r5,8(r4)
8111b660:	3080cd36 	bltu	r6,r2,8111b998 <_malloc_r+0x79c>
8111b664:	00a04574 	movhi	r2,33045
8111b668:	10b0fc04 	addi	r2,r2,-15376
8111b66c:	11000017 	ldw	r4,0(r2)
8111b670:	20c0012e 	bgeu	r4,r3,8111b678 <_malloc_r+0x47c>
8111b674:	10c00015 	stw	r3,0(r2)
8111b678:	00a04574 	movhi	r2,33045
8111b67c:	10b0fb04 	addi	r2,r2,-15380
8111b680:	11000017 	ldw	r4,0(r2)
8111b684:	9c000217 	ldw	r16,8(r19)
8111b688:	20c0012e 	bgeu	r4,r3,8111b690 <_malloc_r+0x494>
8111b68c:	10c00015 	stw	r3,0(r2)
8111b690:	80c00117 	ldw	r3,4(r16)
8111b694:	00bfff04 	movi	r2,-4
8111b698:	1886703a 	and	r3,r3,r2
8111b69c:	1c45c83a 	sub	r2,r3,r17
8111b6a0:	1c400236 	bltu	r3,r17,8111b6ac <_malloc_r+0x4b0>
8111b6a4:	00c003c4 	movi	r3,15
8111b6a8:	18800416 	blt	r3,r2,8111b6bc <_malloc_r+0x4c0>
8111b6ac:	9009883a 	mov	r4,r18
8111b6b0:	11321200 	call	81132120 <__malloc_unlock>
8111b6b4:	0005883a 	mov	r2,zero
8111b6b8:	003f7b06 	br	8111b4a8 <__reset+0xfb0fb4a8>
8111b6bc:	88c00054 	ori	r3,r17,1
8111b6c0:	80c00115 	stw	r3,4(r16)
8111b6c4:	8463883a 	add	r17,r16,r17
8111b6c8:	10800054 	ori	r2,r2,1
8111b6cc:	9c400215 	stw	r17,8(r19)
8111b6d0:	88800115 	stw	r2,4(r17)
8111b6d4:	9009883a 	mov	r4,r18
8111b6d8:	11321200 	call	81132120 <__malloc_unlock>
8111b6dc:	80800204 	addi	r2,r16,8
8111b6e0:	003f7106 	br	8111b4a8 <__reset+0xfb0fb4a8>
8111b6e4:	00c00504 	movi	r3,20
8111b6e8:	18804a2e 	bgeu	r3,r2,8111b814 <_malloc_r+0x618>
8111b6ec:	00c01504 	movi	r3,84
8111b6f0:	18806e36 	bltu	r3,r2,8111b8ac <_malloc_r+0x6b0>
8111b6f4:	8804d33a 	srli	r2,r17,12
8111b6f8:	12001bc4 	addi	r8,r2,111
8111b6fc:	11c01b84 	addi	r7,r2,110
8111b700:	4209883a 	add	r4,r8,r8
8111b704:	003edd06 	br	8111b27c <__reset+0xfb0fb27c>
8111b708:	3804d27a 	srli	r2,r7,9
8111b70c:	00c00104 	movi	r3,4
8111b710:	1880442e 	bgeu	r3,r2,8111b824 <_malloc_r+0x628>
8111b714:	00c00504 	movi	r3,20
8111b718:	18808136 	bltu	r3,r2,8111b920 <_malloc_r+0x724>
8111b71c:	11401704 	addi	r5,r2,92
8111b720:	10c016c4 	addi	r3,r2,91
8111b724:	294b883a 	add	r5,r5,r5
8111b728:	294b883a 	add	r5,r5,r5
8111b72c:	294b883a 	add	r5,r5,r5
8111b730:	994b883a 	add	r5,r19,r5
8111b734:	28800017 	ldw	r2,0(r5)
8111b738:	01a04574 	movhi	r6,33045
8111b73c:	297ffe04 	addi	r5,r5,-8
8111b740:	31aa4004 	addi	r6,r6,-22272
8111b744:	28806526 	beq	r5,r2,8111b8dc <_malloc_r+0x6e0>
8111b748:	01bfff04 	movi	r6,-4
8111b74c:	10c00117 	ldw	r3,4(r2)
8111b750:	1986703a 	and	r3,r3,r6
8111b754:	38c0022e 	bgeu	r7,r3,8111b760 <_malloc_r+0x564>
8111b758:	10800217 	ldw	r2,8(r2)
8111b75c:	28bffb1e 	bne	r5,r2,8111b74c <__reset+0xfb0fb74c>
8111b760:	11400317 	ldw	r5,12(r2)
8111b764:	98c00117 	ldw	r3,4(r19)
8111b768:	81400315 	stw	r5,12(r16)
8111b76c:	80800215 	stw	r2,8(r16)
8111b770:	2c000215 	stw	r16,8(r5)
8111b774:	14000315 	stw	r16,12(r2)
8111b778:	003ef806 	br	8111b35c <__reset+0xfb0fb35c>
8111b77c:	88c00054 	ori	r3,r17,1
8111b780:	80c00115 	stw	r3,4(r16)
8111b784:	8463883a 	add	r17,r16,r17
8111b788:	34400515 	stw	r17,20(r6)
8111b78c:	34400415 	stw	r17,16(r6)
8111b790:	10c00054 	ori	r3,r2,1
8111b794:	8a000315 	stw	r8,12(r17)
8111b798:	8a000215 	stw	r8,8(r17)
8111b79c:	88c00115 	stw	r3,4(r17)
8111b7a0:	88a3883a 	add	r17,r17,r2
8111b7a4:	88800015 	stw	r2,0(r17)
8111b7a8:	9009883a 	mov	r4,r18
8111b7ac:	11321200 	call	81132120 <__malloc_unlock>
8111b7b0:	80800204 	addi	r2,r16,8
8111b7b4:	003f3c06 	br	8111b4a8 <__reset+0xfb0fb4a8>
8111b7b8:	30c00117 	ldw	r3,4(r6)
8111b7bc:	003ee706 	br	8111b35c <__reset+0xfb0fb35c>
8111b7c0:	5ac00044 	addi	r11,r11,1
8111b7c4:	588000cc 	andi	r2,r11,3
8111b7c8:	31800204 	addi	r6,r6,8
8111b7cc:	103efd1e 	bne	r2,zero,8111b3c4 <__reset+0xfb0fb3c4>
8111b7d0:	00002406 	br	8111b864 <_malloc_r+0x668>
8111b7d4:	14000317 	ldw	r16,12(r2)
8111b7d8:	143f251e 	bne	r2,r16,8111b470 <__reset+0xfb0fb470>
8111b7dc:	21000084 	addi	r4,r4,2
8111b7e0:	003ebc06 	br	8111b2d4 <__reset+0xfb0fb2d4>
8111b7e4:	8085883a 	add	r2,r16,r2
8111b7e8:	10c00117 	ldw	r3,4(r2)
8111b7ec:	81000317 	ldw	r4,12(r16)
8111b7f0:	81400217 	ldw	r5,8(r16)
8111b7f4:	18c00054 	ori	r3,r3,1
8111b7f8:	10c00115 	stw	r3,4(r2)
8111b7fc:	29000315 	stw	r4,12(r5)
8111b800:	21400215 	stw	r5,8(r4)
8111b804:	9009883a 	mov	r4,r18
8111b808:	11321200 	call	81132120 <__malloc_unlock>
8111b80c:	80800204 	addi	r2,r16,8
8111b810:	003f2506 	br	8111b4a8 <__reset+0xfb0fb4a8>
8111b814:	12001704 	addi	r8,r2,92
8111b818:	11c016c4 	addi	r7,r2,91
8111b81c:	4209883a 	add	r4,r8,r8
8111b820:	003e9606 	br	8111b27c <__reset+0xfb0fb27c>
8111b824:	3804d1ba 	srli	r2,r7,6
8111b828:	11400e44 	addi	r5,r2,57
8111b82c:	10c00e04 	addi	r3,r2,56
8111b830:	294b883a 	add	r5,r5,r5
8111b834:	003fbc06 	br	8111b728 <__reset+0xfb0fb728>
8111b838:	84ff5926 	beq	r16,r19,8111b5a0 <__reset+0xfb0fb5a0>
8111b83c:	00a04574 	movhi	r2,33045
8111b840:	10aa4004 	addi	r2,r2,-22272
8111b844:	14000217 	ldw	r16,8(r2)
8111b848:	00bfff04 	movi	r2,-4
8111b84c:	80c00117 	ldw	r3,4(r16)
8111b850:	1886703a 	and	r3,r3,r2
8111b854:	003f9106 	br	8111b69c <__reset+0xfb0fb69c>
8111b858:	60800217 	ldw	r2,8(r12)
8111b85c:	213fffc4 	addi	r4,r4,-1
8111b860:	1300651e 	bne	r2,r12,8111b9f8 <_malloc_r+0x7fc>
8111b864:	208000cc 	andi	r2,r4,3
8111b868:	633ffe04 	addi	r12,r12,-8
8111b86c:	103ffa1e 	bne	r2,zero,8111b858 <__reset+0xfb0fb858>
8111b870:	98800117 	ldw	r2,4(r19)
8111b874:	0146303a 	nor	r3,zero,r5
8111b878:	1884703a 	and	r2,r3,r2
8111b87c:	98800115 	stw	r2,4(r19)
8111b880:	294b883a 	add	r5,r5,r5
8111b884:	117f2836 	bltu	r2,r5,8111b528 <__reset+0xfb0fb528>
8111b888:	283f2726 	beq	r5,zero,8111b528 <__reset+0xfb0fb528>
8111b88c:	2886703a 	and	r3,r5,r2
8111b890:	5809883a 	mov	r4,r11
8111b894:	183ec31e 	bne	r3,zero,8111b3a4 <__reset+0xfb0fb3a4>
8111b898:	294b883a 	add	r5,r5,r5
8111b89c:	2886703a 	and	r3,r5,r2
8111b8a0:	21000104 	addi	r4,r4,4
8111b8a4:	183ffc26 	beq	r3,zero,8111b898 <__reset+0xfb0fb898>
8111b8a8:	003ebe06 	br	8111b3a4 <__reset+0xfb0fb3a4>
8111b8ac:	00c05504 	movi	r3,340
8111b8b0:	18801236 	bltu	r3,r2,8111b8fc <_malloc_r+0x700>
8111b8b4:	8804d3fa 	srli	r2,r17,15
8111b8b8:	12001e04 	addi	r8,r2,120
8111b8bc:	11c01dc4 	addi	r7,r2,119
8111b8c0:	4209883a 	add	r4,r8,r8
8111b8c4:	003e6d06 	br	8111b27c <__reset+0xfb0fb27c>
8111b8c8:	00c40004 	movi	r3,4096
8111b8cc:	003f4606 	br	8111b5e8 <__reset+0xfb0fb5e8>
8111b8d0:	00800044 	movi	r2,1
8111b8d4:	a0800115 	stw	r2,4(r20)
8111b8d8:	003f7406 	br	8111b6ac <__reset+0xfb0fb6ac>
8111b8dc:	1805d0ba 	srai	r2,r3,2
8111b8e0:	01c00044 	movi	r7,1
8111b8e4:	30c00117 	ldw	r3,4(r6)
8111b8e8:	388e983a 	sll	r7,r7,r2
8111b8ec:	2805883a 	mov	r2,r5
8111b8f0:	38c6b03a 	or	r3,r7,r3
8111b8f4:	30c00115 	stw	r3,4(r6)
8111b8f8:	003f9b06 	br	8111b768 <__reset+0xfb0fb768>
8111b8fc:	00c15504 	movi	r3,1364
8111b900:	18801a36 	bltu	r3,r2,8111b96c <_malloc_r+0x770>
8111b904:	8804d4ba 	srli	r2,r17,18
8111b908:	12001f44 	addi	r8,r2,125
8111b90c:	11c01f04 	addi	r7,r2,124
8111b910:	4209883a 	add	r4,r8,r8
8111b914:	003e5906 	br	8111b27c <__reset+0xfb0fb27c>
8111b918:	ad400404 	addi	r21,r21,16
8111b91c:	003f1706 	br	8111b57c <__reset+0xfb0fb57c>
8111b920:	00c01504 	movi	r3,84
8111b924:	18802336 	bltu	r3,r2,8111b9b4 <_malloc_r+0x7b8>
8111b928:	3804d33a 	srli	r2,r7,12
8111b92c:	11401bc4 	addi	r5,r2,111
8111b930:	10c01b84 	addi	r3,r2,110
8111b934:	294b883a 	add	r5,r5,r5
8111b938:	003f7b06 	br	8111b728 <__reset+0xfb0fb728>
8111b93c:	9c000217 	ldw	r16,8(r19)
8111b940:	00bfff04 	movi	r2,-4
8111b944:	80c00117 	ldw	r3,4(r16)
8111b948:	1886703a 	and	r3,r3,r2
8111b94c:	003f5306 	br	8111b69c <__reset+0xfb0fb69c>
8111b950:	3083ffcc 	andi	r2,r6,4095
8111b954:	103f181e 	bne	r2,zero,8111b5b8 <__reset+0xfb0fb5b8>
8111b958:	99000217 	ldw	r4,8(r19)
8111b95c:	b545883a 	add	r2,r22,r21
8111b960:	10800054 	ori	r2,r2,1
8111b964:	20800115 	stw	r2,4(r4)
8111b968:	003f3e06 	br	8111b664 <__reset+0xfb0fb664>
8111b96c:	01003f84 	movi	r4,254
8111b970:	02001fc4 	movi	r8,127
8111b974:	01c01f84 	movi	r7,126
8111b978:	003e4006 	br	8111b27c <__reset+0xfb0fb27c>
8111b97c:	00a04574 	movhi	r2,33045
8111b980:	10b08304 	addi	r2,r2,-15860
8111b984:	15000015 	stw	r20,0(r2)
8111b988:	003f1106 	br	8111b5d0 <__reset+0xfb0fb5d0>
8111b98c:	00800044 	movi	r2,1
8111b990:	002b883a 	mov	r21,zero
8111b994:	003f1f06 	br	8111b614 <__reset+0xfb0fb614>
8111b998:	81400204 	addi	r5,r16,8
8111b99c:	9009883a 	mov	r4,r18
8111b9a0:	1124c700 	call	81124c70 <_free_r>
8111b9a4:	00a04574 	movhi	r2,33045
8111b9a8:	10b19f04 	addi	r2,r2,-14724
8111b9ac:	10c00017 	ldw	r3,0(r2)
8111b9b0:	003f2c06 	br	8111b664 <__reset+0xfb0fb664>
8111b9b4:	00c05504 	movi	r3,340
8111b9b8:	18800536 	bltu	r3,r2,8111b9d0 <_malloc_r+0x7d4>
8111b9bc:	3804d3fa 	srli	r2,r7,15
8111b9c0:	11401e04 	addi	r5,r2,120
8111b9c4:	10c01dc4 	addi	r3,r2,119
8111b9c8:	294b883a 	add	r5,r5,r5
8111b9cc:	003f5606 	br	8111b728 <__reset+0xfb0fb728>
8111b9d0:	00c15504 	movi	r3,1364
8111b9d4:	18800536 	bltu	r3,r2,8111b9ec <_malloc_r+0x7f0>
8111b9d8:	3804d4ba 	srli	r2,r7,18
8111b9dc:	11401f44 	addi	r5,r2,125
8111b9e0:	10c01f04 	addi	r3,r2,124
8111b9e4:	294b883a 	add	r5,r5,r5
8111b9e8:	003f4f06 	br	8111b728 <__reset+0xfb0fb728>
8111b9ec:	01403f84 	movi	r5,254
8111b9f0:	00c01f84 	movi	r3,126
8111b9f4:	003f4c06 	br	8111b728 <__reset+0xfb0fb728>
8111b9f8:	98800117 	ldw	r2,4(r19)
8111b9fc:	003fa006 	br	8111b880 <__reset+0xfb0fb880>
8111ba00:	8808d0fa 	srli	r4,r17,3
8111ba04:	20800044 	addi	r2,r4,1
8111ba08:	1085883a 	add	r2,r2,r2
8111ba0c:	003e9006 	br	8111b450 <__reset+0xfb0fb450>

8111ba10 <memcpy>:
8111ba10:	defffd04 	addi	sp,sp,-12
8111ba14:	de00012e 	bgeu	sp,et,8111ba1c <memcpy+0xc>
8111ba18:	003b68fa 	trap	3
8111ba1c:	00c003c4 	movi	r3,15
8111ba20:	dfc00215 	stw	ra,8(sp)
8111ba24:	dc400115 	stw	r17,4(sp)
8111ba28:	dc000015 	stw	r16,0(sp)
8111ba2c:	2005883a 	mov	r2,r4
8111ba30:	1980452e 	bgeu	r3,r6,8111bb48 <memcpy+0x138>
8111ba34:	2906b03a 	or	r3,r5,r4
8111ba38:	18c000cc 	andi	r3,r3,3
8111ba3c:	1800441e 	bne	r3,zero,8111bb50 <memcpy+0x140>
8111ba40:	347ffc04 	addi	r17,r6,-16
8111ba44:	8822d13a 	srli	r17,r17,4
8111ba48:	28c00104 	addi	r3,r5,4
8111ba4c:	23400104 	addi	r13,r4,4
8111ba50:	8820913a 	slli	r16,r17,4
8111ba54:	2b000204 	addi	r12,r5,8
8111ba58:	22c00204 	addi	r11,r4,8
8111ba5c:	84000504 	addi	r16,r16,20
8111ba60:	2a800304 	addi	r10,r5,12
8111ba64:	22400304 	addi	r9,r4,12
8111ba68:	2c21883a 	add	r16,r5,r16
8111ba6c:	2811883a 	mov	r8,r5
8111ba70:	200f883a 	mov	r7,r4
8111ba74:	41000017 	ldw	r4,0(r8)
8111ba78:	1fc00017 	ldw	ra,0(r3)
8111ba7c:	63c00017 	ldw	r15,0(r12)
8111ba80:	39000015 	stw	r4,0(r7)
8111ba84:	53800017 	ldw	r14,0(r10)
8111ba88:	6fc00015 	stw	ra,0(r13)
8111ba8c:	5bc00015 	stw	r15,0(r11)
8111ba90:	4b800015 	stw	r14,0(r9)
8111ba94:	18c00404 	addi	r3,r3,16
8111ba98:	39c00404 	addi	r7,r7,16
8111ba9c:	42000404 	addi	r8,r8,16
8111baa0:	6b400404 	addi	r13,r13,16
8111baa4:	63000404 	addi	r12,r12,16
8111baa8:	5ac00404 	addi	r11,r11,16
8111baac:	52800404 	addi	r10,r10,16
8111bab0:	4a400404 	addi	r9,r9,16
8111bab4:	1c3fef1e 	bne	r3,r16,8111ba74 <__reset+0xfb0fba74>
8111bab8:	89c00044 	addi	r7,r17,1
8111babc:	380e913a 	slli	r7,r7,4
8111bac0:	310003cc 	andi	r4,r6,15
8111bac4:	02c000c4 	movi	r11,3
8111bac8:	11c7883a 	add	r3,r2,r7
8111bacc:	29cb883a 	add	r5,r5,r7
8111bad0:	5900212e 	bgeu	r11,r4,8111bb58 <memcpy+0x148>
8111bad4:	1813883a 	mov	r9,r3
8111bad8:	2811883a 	mov	r8,r5
8111badc:	200f883a 	mov	r7,r4
8111bae0:	42800017 	ldw	r10,0(r8)
8111bae4:	4a400104 	addi	r9,r9,4
8111bae8:	39ffff04 	addi	r7,r7,-4
8111baec:	4abfff15 	stw	r10,-4(r9)
8111baf0:	42000104 	addi	r8,r8,4
8111baf4:	59fffa36 	bltu	r11,r7,8111bae0 <__reset+0xfb0fbae0>
8111baf8:	213fff04 	addi	r4,r4,-4
8111bafc:	2008d0ba 	srli	r4,r4,2
8111bb00:	318000cc 	andi	r6,r6,3
8111bb04:	21000044 	addi	r4,r4,1
8111bb08:	2109883a 	add	r4,r4,r4
8111bb0c:	2109883a 	add	r4,r4,r4
8111bb10:	1907883a 	add	r3,r3,r4
8111bb14:	290b883a 	add	r5,r5,r4
8111bb18:	30000626 	beq	r6,zero,8111bb34 <memcpy+0x124>
8111bb1c:	198d883a 	add	r6,r3,r6
8111bb20:	29c00003 	ldbu	r7,0(r5)
8111bb24:	18c00044 	addi	r3,r3,1
8111bb28:	29400044 	addi	r5,r5,1
8111bb2c:	19ffffc5 	stb	r7,-1(r3)
8111bb30:	19bffb1e 	bne	r3,r6,8111bb20 <__reset+0xfb0fbb20>
8111bb34:	dfc00217 	ldw	ra,8(sp)
8111bb38:	dc400117 	ldw	r17,4(sp)
8111bb3c:	dc000017 	ldw	r16,0(sp)
8111bb40:	dec00304 	addi	sp,sp,12
8111bb44:	f800283a 	ret
8111bb48:	2007883a 	mov	r3,r4
8111bb4c:	003ff206 	br	8111bb18 <__reset+0xfb0fbb18>
8111bb50:	2007883a 	mov	r3,r4
8111bb54:	003ff106 	br	8111bb1c <__reset+0xfb0fbb1c>
8111bb58:	200d883a 	mov	r6,r4
8111bb5c:	003fee06 	br	8111bb18 <__reset+0xfb0fbb18>

8111bb60 <memset>:
8111bb60:	20c000cc 	andi	r3,r4,3
8111bb64:	2005883a 	mov	r2,r4
8111bb68:	18004426 	beq	r3,zero,8111bc7c <memset+0x11c>
8111bb6c:	31ffffc4 	addi	r7,r6,-1
8111bb70:	30004026 	beq	r6,zero,8111bc74 <memset+0x114>
8111bb74:	2813883a 	mov	r9,r5
8111bb78:	200d883a 	mov	r6,r4
8111bb7c:	2007883a 	mov	r3,r4
8111bb80:	00000406 	br	8111bb94 <memset+0x34>
8111bb84:	3a3fffc4 	addi	r8,r7,-1
8111bb88:	31800044 	addi	r6,r6,1
8111bb8c:	38003926 	beq	r7,zero,8111bc74 <memset+0x114>
8111bb90:	400f883a 	mov	r7,r8
8111bb94:	18c00044 	addi	r3,r3,1
8111bb98:	32400005 	stb	r9,0(r6)
8111bb9c:	1a0000cc 	andi	r8,r3,3
8111bba0:	403ff81e 	bne	r8,zero,8111bb84 <__reset+0xfb0fbb84>
8111bba4:	010000c4 	movi	r4,3
8111bba8:	21c02d2e 	bgeu	r4,r7,8111bc60 <memset+0x100>
8111bbac:	29003fcc 	andi	r4,r5,255
8111bbb0:	200c923a 	slli	r6,r4,8
8111bbb4:	3108b03a 	or	r4,r6,r4
8111bbb8:	200c943a 	slli	r6,r4,16
8111bbbc:	218cb03a 	or	r6,r4,r6
8111bbc0:	010003c4 	movi	r4,15
8111bbc4:	21c0182e 	bgeu	r4,r7,8111bc28 <memset+0xc8>
8111bbc8:	3b3ffc04 	addi	r12,r7,-16
8111bbcc:	6018d13a 	srli	r12,r12,4
8111bbd0:	1a000104 	addi	r8,r3,4
8111bbd4:	1ac00204 	addi	r11,r3,8
8111bbd8:	6008913a 	slli	r4,r12,4
8111bbdc:	1a800304 	addi	r10,r3,12
8111bbe0:	1813883a 	mov	r9,r3
8111bbe4:	21000504 	addi	r4,r4,20
8111bbe8:	1909883a 	add	r4,r3,r4
8111bbec:	49800015 	stw	r6,0(r9)
8111bbf0:	41800015 	stw	r6,0(r8)
8111bbf4:	59800015 	stw	r6,0(r11)
8111bbf8:	51800015 	stw	r6,0(r10)
8111bbfc:	42000404 	addi	r8,r8,16
8111bc00:	4a400404 	addi	r9,r9,16
8111bc04:	5ac00404 	addi	r11,r11,16
8111bc08:	52800404 	addi	r10,r10,16
8111bc0c:	413ff71e 	bne	r8,r4,8111bbec <__reset+0xfb0fbbec>
8111bc10:	63000044 	addi	r12,r12,1
8111bc14:	6018913a 	slli	r12,r12,4
8111bc18:	39c003cc 	andi	r7,r7,15
8111bc1c:	010000c4 	movi	r4,3
8111bc20:	1b07883a 	add	r3,r3,r12
8111bc24:	21c00e2e 	bgeu	r4,r7,8111bc60 <memset+0x100>
8111bc28:	1813883a 	mov	r9,r3
8111bc2c:	3811883a 	mov	r8,r7
8111bc30:	010000c4 	movi	r4,3
8111bc34:	49800015 	stw	r6,0(r9)
8111bc38:	423fff04 	addi	r8,r8,-4
8111bc3c:	4a400104 	addi	r9,r9,4
8111bc40:	223ffc36 	bltu	r4,r8,8111bc34 <__reset+0xfb0fbc34>
8111bc44:	393fff04 	addi	r4,r7,-4
8111bc48:	2008d0ba 	srli	r4,r4,2
8111bc4c:	39c000cc 	andi	r7,r7,3
8111bc50:	21000044 	addi	r4,r4,1
8111bc54:	2109883a 	add	r4,r4,r4
8111bc58:	2109883a 	add	r4,r4,r4
8111bc5c:	1907883a 	add	r3,r3,r4
8111bc60:	38000526 	beq	r7,zero,8111bc78 <memset+0x118>
8111bc64:	19cf883a 	add	r7,r3,r7
8111bc68:	19400005 	stb	r5,0(r3)
8111bc6c:	18c00044 	addi	r3,r3,1
8111bc70:	38fffd1e 	bne	r7,r3,8111bc68 <__reset+0xfb0fbc68>
8111bc74:	f800283a 	ret
8111bc78:	f800283a 	ret
8111bc7c:	2007883a 	mov	r3,r4
8111bc80:	300f883a 	mov	r7,r6
8111bc84:	003fc706 	br	8111bba4 <__reset+0xfb0fbba4>

8111bc88 <_open_r>:
8111bc88:	defffd04 	addi	sp,sp,-12
8111bc8c:	de00012e 	bgeu	sp,et,8111bc94 <_open_r+0xc>
8111bc90:	003b68fa 	trap	3
8111bc94:	2805883a 	mov	r2,r5
8111bc98:	dc000015 	stw	r16,0(sp)
8111bc9c:	04204574 	movhi	r16,33045
8111bca0:	dc400115 	stw	r17,4(sp)
8111bca4:	300b883a 	mov	r5,r6
8111bca8:	8430fa04 	addi	r16,r16,-15384
8111bcac:	2023883a 	mov	r17,r4
8111bcb0:	380d883a 	mov	r6,r7
8111bcb4:	1009883a 	mov	r4,r2
8111bcb8:	dfc00215 	stw	ra,8(sp)
8111bcbc:	80000015 	stw	zero,0(r16)
8111bcc0:	11316780 	call	81131678 <open>
8111bcc4:	00ffffc4 	movi	r3,-1
8111bcc8:	10c00526 	beq	r2,r3,8111bce0 <_open_r+0x58>
8111bccc:	dfc00217 	ldw	ra,8(sp)
8111bcd0:	dc400117 	ldw	r17,4(sp)
8111bcd4:	dc000017 	ldw	r16,0(sp)
8111bcd8:	dec00304 	addi	sp,sp,12
8111bcdc:	f800283a 	ret
8111bce0:	80c00017 	ldw	r3,0(r16)
8111bce4:	183ff926 	beq	r3,zero,8111bccc <__reset+0xfb0fbccc>
8111bce8:	88c00015 	stw	r3,0(r17)
8111bcec:	003ff706 	br	8111bccc <__reset+0xfb0fbccc>

8111bcf0 <_printf_r>:
8111bcf0:	defffd04 	addi	sp,sp,-12
8111bcf4:	2805883a 	mov	r2,r5
8111bcf8:	de00012e 	bgeu	sp,et,8111bd00 <_printf_r+0x10>
8111bcfc:	003b68fa 	trap	3
8111bd00:	dfc00015 	stw	ra,0(sp)
8111bd04:	d9800115 	stw	r6,4(sp)
8111bd08:	d9c00215 	stw	r7,8(sp)
8111bd0c:	21400217 	ldw	r5,8(r4)
8111bd10:	d9c00104 	addi	r7,sp,4
8111bd14:	100d883a 	mov	r6,r2
8111bd18:	111ea1c0 	call	8111ea1c <___vfprintf_internal_r>
8111bd1c:	dfc00017 	ldw	ra,0(sp)
8111bd20:	dec00304 	addi	sp,sp,12
8111bd24:	f800283a 	ret

8111bd28 <printf>:
8111bd28:	defffc04 	addi	sp,sp,-16
8111bd2c:	de00012e 	bgeu	sp,et,8111bd34 <printf+0xc>
8111bd30:	003b68fa 	trap	3
8111bd34:	dfc00015 	stw	ra,0(sp)
8111bd38:	d9400115 	stw	r5,4(sp)
8111bd3c:	d9800215 	stw	r6,8(sp)
8111bd40:	d9c00315 	stw	r7,12(sp)
8111bd44:	00a04574 	movhi	r2,33045
8111bd48:	10b08204 	addi	r2,r2,-15864
8111bd4c:	10800017 	ldw	r2,0(r2)
8111bd50:	200b883a 	mov	r5,r4
8111bd54:	d9800104 	addi	r6,sp,4
8111bd58:	11000217 	ldw	r4,8(r2)
8111bd5c:	1120c1c0 	call	81120c1c <__vfprintf_internal>
8111bd60:	dfc00017 	ldw	ra,0(sp)
8111bd64:	dec00404 	addi	sp,sp,16
8111bd68:	f800283a 	ret

8111bd6c <_putc_r>:
8111bd6c:	defffc04 	addi	sp,sp,-16
8111bd70:	de00012e 	bgeu	sp,et,8111bd78 <_putc_r+0xc>
8111bd74:	003b68fa 	trap	3
8111bd78:	dc000215 	stw	r16,8(sp)
8111bd7c:	dfc00315 	stw	ra,12(sp)
8111bd80:	2021883a 	mov	r16,r4
8111bd84:	20000226 	beq	r4,zero,8111bd90 <_putc_r+0x24>
8111bd88:	20800e17 	ldw	r2,56(r4)
8111bd8c:	10001b26 	beq	r2,zero,8111bdfc <_putc_r+0x90>
8111bd90:	30800217 	ldw	r2,8(r6)
8111bd94:	10bfffc4 	addi	r2,r2,-1
8111bd98:	30800215 	stw	r2,8(r6)
8111bd9c:	10000a16 	blt	r2,zero,8111bdc8 <_putc_r+0x5c>
8111bda0:	30800017 	ldw	r2,0(r6)
8111bda4:	11400005 	stb	r5,0(r2)
8111bda8:	30800017 	ldw	r2,0(r6)
8111bdac:	10c00044 	addi	r3,r2,1
8111bdb0:	30c00015 	stw	r3,0(r6)
8111bdb4:	10800003 	ldbu	r2,0(r2)
8111bdb8:	dfc00317 	ldw	ra,12(sp)
8111bdbc:	dc000217 	ldw	r16,8(sp)
8111bdc0:	dec00404 	addi	sp,sp,16
8111bdc4:	f800283a 	ret
8111bdc8:	30c00617 	ldw	r3,24(r6)
8111bdcc:	10c00616 	blt	r2,r3,8111bde8 <_putc_r+0x7c>
8111bdd0:	30800017 	ldw	r2,0(r6)
8111bdd4:	00c00284 	movi	r3,10
8111bdd8:	11400005 	stb	r5,0(r2)
8111bddc:	30800017 	ldw	r2,0(r6)
8111bde0:	11400003 	ldbu	r5,0(r2)
8111bde4:	28fff11e 	bne	r5,r3,8111bdac <__reset+0xfb0fbdac>
8111bde8:	8009883a 	mov	r4,r16
8111bdec:	dfc00317 	ldw	ra,12(sp)
8111bdf0:	dc000217 	ldw	r16,8(sp)
8111bdf4:	dec00404 	addi	sp,sp,16
8111bdf8:	11225a01 	jmpi	811225a0 <__swbuf_r>
8111bdfc:	d9400015 	stw	r5,0(sp)
8111be00:	d9800115 	stw	r6,4(sp)
8111be04:	11247d80 	call	811247d8 <__sinit>
8111be08:	d9800117 	ldw	r6,4(sp)
8111be0c:	d9400017 	ldw	r5,0(sp)
8111be10:	003fdf06 	br	8111bd90 <__reset+0xfb0fbd90>

8111be14 <putc>:
8111be14:	00a04574 	movhi	r2,33045
8111be18:	defffc04 	addi	sp,sp,-16
8111be1c:	10b08204 	addi	r2,r2,-15864
8111be20:	de00012e 	bgeu	sp,et,8111be28 <putc+0x14>
8111be24:	003b68fa 	trap	3
8111be28:	dc000115 	stw	r16,4(sp)
8111be2c:	14000017 	ldw	r16,0(r2)
8111be30:	dc400215 	stw	r17,8(sp)
8111be34:	dfc00315 	stw	ra,12(sp)
8111be38:	2023883a 	mov	r17,r4
8111be3c:	80000226 	beq	r16,zero,8111be48 <putc+0x34>
8111be40:	80800e17 	ldw	r2,56(r16)
8111be44:	10001a26 	beq	r2,zero,8111beb0 <putc+0x9c>
8111be48:	28800217 	ldw	r2,8(r5)
8111be4c:	10bfffc4 	addi	r2,r2,-1
8111be50:	28800215 	stw	r2,8(r5)
8111be54:	10000b16 	blt	r2,zero,8111be84 <putc+0x70>
8111be58:	28800017 	ldw	r2,0(r5)
8111be5c:	14400005 	stb	r17,0(r2)
8111be60:	28800017 	ldw	r2,0(r5)
8111be64:	10c00044 	addi	r3,r2,1
8111be68:	28c00015 	stw	r3,0(r5)
8111be6c:	10800003 	ldbu	r2,0(r2)
8111be70:	dfc00317 	ldw	ra,12(sp)
8111be74:	dc400217 	ldw	r17,8(sp)
8111be78:	dc000117 	ldw	r16,4(sp)
8111be7c:	dec00404 	addi	sp,sp,16
8111be80:	f800283a 	ret
8111be84:	28c00617 	ldw	r3,24(r5)
8111be88:	10c00e16 	blt	r2,r3,8111bec4 <putc+0xb0>
8111be8c:	28800017 	ldw	r2,0(r5)
8111be90:	01000284 	movi	r4,10
8111be94:	14400005 	stb	r17,0(r2)
8111be98:	28800017 	ldw	r2,0(r5)
8111be9c:	10c00003 	ldbu	r3,0(r2)
8111bea0:	193ff01e 	bne	r3,r4,8111be64 <__reset+0xfb0fbe64>
8111bea4:	280d883a 	mov	r6,r5
8111bea8:	180b883a 	mov	r5,r3
8111beac:	00000706 	br	8111becc <putc+0xb8>
8111beb0:	8009883a 	mov	r4,r16
8111beb4:	d9400015 	stw	r5,0(sp)
8111beb8:	11247d80 	call	811247d8 <__sinit>
8111bebc:	d9400017 	ldw	r5,0(sp)
8111bec0:	003fe106 	br	8111be48 <__reset+0xfb0fbe48>
8111bec4:	280d883a 	mov	r6,r5
8111bec8:	880b883a 	mov	r5,r17
8111becc:	8009883a 	mov	r4,r16
8111bed0:	dfc00317 	ldw	ra,12(sp)
8111bed4:	dc400217 	ldw	r17,8(sp)
8111bed8:	dc000117 	ldw	r16,4(sp)
8111bedc:	dec00404 	addi	sp,sp,16
8111bee0:	11225a01 	jmpi	811225a0 <__swbuf_r>

8111bee4 <_puts_r>:
8111bee4:	defff604 	addi	sp,sp,-40
8111bee8:	de00012e 	bgeu	sp,et,8111bef0 <_puts_r+0xc>
8111beec:	003b68fa 	trap	3
8111bef0:	dc000715 	stw	r16,28(sp)
8111bef4:	2021883a 	mov	r16,r4
8111bef8:	2809883a 	mov	r4,r5
8111befc:	dc400815 	stw	r17,32(sp)
8111bf00:	dfc00915 	stw	ra,36(sp)
8111bf04:	2823883a 	mov	r17,r5
8111bf08:	111c5040 	call	8111c504 <strlen>
8111bf0c:	10c00044 	addi	r3,r2,1
8111bf10:	d8800115 	stw	r2,4(sp)
8111bf14:	00a04574 	movhi	r2,33045
8111bf18:	10a6a904 	addi	r2,r2,-25948
8111bf1c:	d8800215 	stw	r2,8(sp)
8111bf20:	00800044 	movi	r2,1
8111bf24:	d8800315 	stw	r2,12(sp)
8111bf28:	00800084 	movi	r2,2
8111bf2c:	dc400015 	stw	r17,0(sp)
8111bf30:	d8c00615 	stw	r3,24(sp)
8111bf34:	dec00415 	stw	sp,16(sp)
8111bf38:	d8800515 	stw	r2,20(sp)
8111bf3c:	80000226 	beq	r16,zero,8111bf48 <_puts_r+0x64>
8111bf40:	80800e17 	ldw	r2,56(r16)
8111bf44:	10001426 	beq	r2,zero,8111bf98 <_puts_r+0xb4>
8111bf48:	81400217 	ldw	r5,8(r16)
8111bf4c:	2880030b 	ldhu	r2,12(r5)
8111bf50:	10c8000c 	andi	r3,r2,8192
8111bf54:	1800061e 	bne	r3,zero,8111bf70 <_puts_r+0x8c>
8111bf58:	29001917 	ldw	r4,100(r5)
8111bf5c:	00f7ffc4 	movi	r3,-8193
8111bf60:	10880014 	ori	r2,r2,8192
8111bf64:	20c6703a 	and	r3,r4,r3
8111bf68:	2880030d 	sth	r2,12(r5)
8111bf6c:	28c01915 	stw	r3,100(r5)
8111bf70:	d9800404 	addi	r6,sp,16
8111bf74:	8009883a 	mov	r4,r16
8111bf78:	1124f880 	call	81124f88 <__sfvwrite_r>
8111bf7c:	1000091e 	bne	r2,zero,8111bfa4 <_puts_r+0xc0>
8111bf80:	00800284 	movi	r2,10
8111bf84:	dfc00917 	ldw	ra,36(sp)
8111bf88:	dc400817 	ldw	r17,32(sp)
8111bf8c:	dc000717 	ldw	r16,28(sp)
8111bf90:	dec00a04 	addi	sp,sp,40
8111bf94:	f800283a 	ret
8111bf98:	8009883a 	mov	r4,r16
8111bf9c:	11247d80 	call	811247d8 <__sinit>
8111bfa0:	003fe906 	br	8111bf48 <__reset+0xfb0fbf48>
8111bfa4:	00bfffc4 	movi	r2,-1
8111bfa8:	003ff606 	br	8111bf84 <__reset+0xfb0fbf84>

8111bfac <puts>:
8111bfac:	00a04574 	movhi	r2,33045
8111bfb0:	10b08204 	addi	r2,r2,-15864
8111bfb4:	200b883a 	mov	r5,r4
8111bfb8:	11000017 	ldw	r4,0(r2)
8111bfbc:	111bee41 	jmpi	8111bee4 <_puts_r>

8111bfc0 <lflush>:
8111bfc0:	2080030b 	ldhu	r2,12(r4)
8111bfc4:	00c00244 	movi	r3,9
8111bfc8:	1080024c 	andi	r2,r2,9
8111bfcc:	10c00226 	beq	r2,r3,8111bfd8 <lflush+0x18>
8111bfd0:	0005883a 	mov	r2,zero
8111bfd4:	f800283a 	ret
8111bfd8:	11244401 	jmpi	81124440 <fflush>

8111bfdc <__srefill_r>:
8111bfdc:	defffc04 	addi	sp,sp,-16
8111bfe0:	de00012e 	bgeu	sp,et,8111bfe8 <__srefill_r+0xc>
8111bfe4:	003b68fa 	trap	3
8111bfe8:	dc400115 	stw	r17,4(sp)
8111bfec:	dc000015 	stw	r16,0(sp)
8111bff0:	dfc00315 	stw	ra,12(sp)
8111bff4:	dc800215 	stw	r18,8(sp)
8111bff8:	2023883a 	mov	r17,r4
8111bffc:	2821883a 	mov	r16,r5
8111c000:	20000226 	beq	r4,zero,8111c00c <__srefill_r+0x30>
8111c004:	20800e17 	ldw	r2,56(r4)
8111c008:	10003c26 	beq	r2,zero,8111c0fc <__srefill_r+0x120>
8111c00c:	80c0030b 	ldhu	r3,12(r16)
8111c010:	1908000c 	andi	r4,r3,8192
8111c014:	1805883a 	mov	r2,r3
8111c018:	2000071e 	bne	r4,zero,8111c038 <__srefill_r+0x5c>
8111c01c:	81001917 	ldw	r4,100(r16)
8111c020:	18880014 	ori	r2,r3,8192
8111c024:	00f7ffc4 	movi	r3,-8193
8111c028:	20c8703a 	and	r4,r4,r3
8111c02c:	8080030d 	sth	r2,12(r16)
8111c030:	1007883a 	mov	r3,r2
8111c034:	81001915 	stw	r4,100(r16)
8111c038:	80000115 	stw	zero,4(r16)
8111c03c:	1100080c 	andi	r4,r2,32
8111c040:	2000571e 	bne	r4,zero,8111c1a0 <__srefill_r+0x1c4>
8111c044:	1100010c 	andi	r4,r2,4
8111c048:	20001f26 	beq	r4,zero,8111c0c8 <__srefill_r+0xec>
8111c04c:	81400c17 	ldw	r5,48(r16)
8111c050:	28000826 	beq	r5,zero,8111c074 <__srefill_r+0x98>
8111c054:	80801004 	addi	r2,r16,64
8111c058:	28800226 	beq	r5,r2,8111c064 <__srefill_r+0x88>
8111c05c:	8809883a 	mov	r4,r17
8111c060:	1124c700 	call	81124c70 <_free_r>
8111c064:	80800f17 	ldw	r2,60(r16)
8111c068:	80000c15 	stw	zero,48(r16)
8111c06c:	80800115 	stw	r2,4(r16)
8111c070:	1000391e 	bne	r2,zero,8111c158 <__srefill_r+0x17c>
8111c074:	80800417 	ldw	r2,16(r16)
8111c078:	10004b26 	beq	r2,zero,8111c1a8 <__srefill_r+0x1cc>
8111c07c:	8480030b 	ldhu	r18,12(r16)
8111c080:	908000cc 	andi	r2,r18,3
8111c084:	10001f1e 	bne	r2,zero,8111c104 <__srefill_r+0x128>
8111c088:	81800417 	ldw	r6,16(r16)
8111c08c:	80800817 	ldw	r2,32(r16)
8111c090:	81c00517 	ldw	r7,20(r16)
8111c094:	81400717 	ldw	r5,28(r16)
8111c098:	81800015 	stw	r6,0(r16)
8111c09c:	8809883a 	mov	r4,r17
8111c0a0:	103ee83a 	callr	r2
8111c0a4:	80800115 	stw	r2,4(r16)
8111c0a8:	00800e0e 	bge	zero,r2,8111c0e4 <__srefill_r+0x108>
8111c0ac:	0005883a 	mov	r2,zero
8111c0b0:	dfc00317 	ldw	ra,12(sp)
8111c0b4:	dc800217 	ldw	r18,8(sp)
8111c0b8:	dc400117 	ldw	r17,4(sp)
8111c0bc:	dc000017 	ldw	r16,0(sp)
8111c0c0:	dec00404 	addi	sp,sp,16
8111c0c4:	f800283a 	ret
8111c0c8:	1100040c 	andi	r4,r2,16
8111c0cc:	20003026 	beq	r4,zero,8111c190 <__srefill_r+0x1b4>
8111c0d0:	1080020c 	andi	r2,r2,8
8111c0d4:	1000241e 	bne	r2,zero,8111c168 <__srefill_r+0x18c>
8111c0d8:	18c00114 	ori	r3,r3,4
8111c0dc:	80c0030d 	sth	r3,12(r16)
8111c0e0:	003fe406 	br	8111c074 <__reset+0xfb0fc074>
8111c0e4:	80c0030b 	ldhu	r3,12(r16)
8111c0e8:	1000161e 	bne	r2,zero,8111c144 <__srefill_r+0x168>
8111c0ec:	18c00814 	ori	r3,r3,32
8111c0f0:	00bfffc4 	movi	r2,-1
8111c0f4:	80c0030d 	sth	r3,12(r16)
8111c0f8:	003fed06 	br	8111c0b0 <__reset+0xfb0fc0b0>
8111c0fc:	11247d80 	call	811247d8 <__sinit>
8111c100:	003fc206 	br	8111c00c <__reset+0xfb0fc00c>
8111c104:	00a04574 	movhi	r2,33045
8111c108:	10b08104 	addi	r2,r2,-15868
8111c10c:	11000017 	ldw	r4,0(r2)
8111c110:	016044b4 	movhi	r5,33042
8111c114:	00800044 	movi	r2,1
8111c118:	296ff004 	addi	r5,r5,-16448
8111c11c:	8080030d 	sth	r2,12(r16)
8111c120:	112544c0 	call	8112544c <_fwalk>
8111c124:	00800244 	movi	r2,9
8111c128:	8480030d 	sth	r18,12(r16)
8111c12c:	9480024c 	andi	r18,r18,9
8111c130:	90bfd51e 	bne	r18,r2,8111c088 <__reset+0xfb0fc088>
8111c134:	800b883a 	mov	r5,r16
8111c138:	8809883a 	mov	r4,r17
8111c13c:	11241b80 	call	811241b8 <__sflush_r>
8111c140:	003fd106 	br	8111c088 <__reset+0xfb0fc088>
8111c144:	18c01014 	ori	r3,r3,64
8111c148:	80000115 	stw	zero,4(r16)
8111c14c:	00bfffc4 	movi	r2,-1
8111c150:	80c0030d 	sth	r3,12(r16)
8111c154:	003fd606 	br	8111c0b0 <__reset+0xfb0fc0b0>
8111c158:	80c00e17 	ldw	r3,56(r16)
8111c15c:	0005883a 	mov	r2,zero
8111c160:	80c00015 	stw	r3,0(r16)
8111c164:	003fd206 	br	8111c0b0 <__reset+0xfb0fc0b0>
8111c168:	800b883a 	mov	r5,r16
8111c16c:	8809883a 	mov	r4,r17
8111c170:	11243dc0 	call	811243dc <_fflush_r>
8111c174:	10000a1e 	bne	r2,zero,8111c1a0 <__srefill_r+0x1c4>
8111c178:	8080030b 	ldhu	r2,12(r16)
8111c17c:	00fffdc4 	movi	r3,-9
8111c180:	80000215 	stw	zero,8(r16)
8111c184:	1886703a 	and	r3,r3,r2
8111c188:	80000615 	stw	zero,24(r16)
8111c18c:	003fd206 	br	8111c0d8 <__reset+0xfb0fc0d8>
8111c190:	00800244 	movi	r2,9
8111c194:	88800015 	stw	r2,0(r17)
8111c198:	18c01014 	ori	r3,r3,64
8111c19c:	80c0030d 	sth	r3,12(r16)
8111c1a0:	00bfffc4 	movi	r2,-1
8111c1a4:	003fc206 	br	8111c0b0 <__reset+0xfb0fc0b0>
8111c1a8:	800b883a 	mov	r5,r16
8111c1ac:	8809883a 	mov	r4,r17
8111c1b0:	111b0380 	call	8111b038 <__smakebuf_r>
8111c1b4:	003fb106 	br	8111c07c <__reset+0xfb0fc07c>

8111c1b8 <_sbrk_r>:
8111c1b8:	defffd04 	addi	sp,sp,-12
8111c1bc:	de00012e 	bgeu	sp,et,8111c1c4 <_sbrk_r+0xc>
8111c1c0:	003b68fa 	trap	3
8111c1c4:	dc000015 	stw	r16,0(sp)
8111c1c8:	04204574 	movhi	r16,33045
8111c1cc:	dc400115 	stw	r17,4(sp)
8111c1d0:	8430fa04 	addi	r16,r16,-15384
8111c1d4:	2023883a 	mov	r17,r4
8111c1d8:	2809883a 	mov	r4,r5
8111c1dc:	dfc00215 	stw	ra,8(sp)
8111c1e0:	80000015 	stw	zero,0(r16)
8111c1e4:	11319880 	call	81131988 <sbrk>
8111c1e8:	00ffffc4 	movi	r3,-1
8111c1ec:	10c00526 	beq	r2,r3,8111c204 <_sbrk_r+0x4c>
8111c1f0:	dfc00217 	ldw	ra,8(sp)
8111c1f4:	dc400117 	ldw	r17,4(sp)
8111c1f8:	dc000017 	ldw	r16,0(sp)
8111c1fc:	dec00304 	addi	sp,sp,12
8111c200:	f800283a 	ret
8111c204:	80c00017 	ldw	r3,0(r16)
8111c208:	183ff926 	beq	r3,zero,8111c1f0 <__reset+0xfb0fc1f0>
8111c20c:	88c00015 	stw	r3,0(r17)
8111c210:	003ff706 	br	8111c1f0 <__reset+0xfb0fc1f0>

8111c214 <scanf>:
8111c214:	defffc04 	addi	sp,sp,-16
8111c218:	de00012e 	bgeu	sp,et,8111c220 <scanf+0xc>
8111c21c:	003b68fa 	trap	3
8111c220:	dfc00015 	stw	ra,0(sp)
8111c224:	d9400115 	stw	r5,4(sp)
8111c228:	d9800215 	stw	r6,8(sp)
8111c22c:	d9c00315 	stw	r7,12(sp)
8111c230:	00a04574 	movhi	r2,33045
8111c234:	10b08204 	addi	r2,r2,-15864
8111c238:	200d883a 	mov	r6,r4
8111c23c:	11000017 	ldw	r4,0(r2)
8111c240:	d9c00104 	addi	r7,sp,4
8111c244:	21400117 	ldw	r5,4(r4)
8111c248:	112254c0 	call	8112254c <_vfscanf_r>
8111c24c:	dfc00017 	ldw	ra,0(sp)
8111c250:	dec00404 	addi	sp,sp,16
8111c254:	f800283a 	ret

8111c258 <_scanf_r>:
8111c258:	defffd04 	addi	sp,sp,-12
8111c25c:	2805883a 	mov	r2,r5
8111c260:	de00012e 	bgeu	sp,et,8111c268 <_scanf_r+0x10>
8111c264:	003b68fa 	trap	3
8111c268:	dfc00015 	stw	ra,0(sp)
8111c26c:	d9800115 	stw	r6,4(sp)
8111c270:	d9c00215 	stw	r7,8(sp)
8111c274:	21400117 	ldw	r5,4(r4)
8111c278:	d9c00104 	addi	r7,sp,4
8111c27c:	100d883a 	mov	r6,r2
8111c280:	112254c0 	call	8112254c <_vfscanf_r>
8111c284:	dfc00017 	ldw	ra,0(sp)
8111c288:	dec00304 	addi	sp,sp,12
8111c28c:	f800283a 	ret

8111c290 <_sprintf_r>:
8111c290:	deffe404 	addi	sp,sp,-112
8111c294:	2807883a 	mov	r3,r5
8111c298:	de00012e 	bgeu	sp,et,8111c2a0 <_sprintf_r+0x10>
8111c29c:	003b68fa 	trap	3
8111c2a0:	dfc01a15 	stw	ra,104(sp)
8111c2a4:	d9c01b15 	stw	r7,108(sp)
8111c2a8:	00a00034 	movhi	r2,32768
8111c2ac:	10bfffc4 	addi	r2,r2,-1
8111c2b0:	02008204 	movi	r8,520
8111c2b4:	d8800215 	stw	r2,8(sp)
8111c2b8:	d8800515 	stw	r2,20(sp)
8111c2bc:	d9c01b04 	addi	r7,sp,108
8111c2c0:	d80b883a 	mov	r5,sp
8111c2c4:	00bfffc4 	movi	r2,-1
8111c2c8:	d8c00015 	stw	r3,0(sp)
8111c2cc:	d8c00415 	stw	r3,16(sp)
8111c2d0:	da00030d 	sth	r8,12(sp)
8111c2d4:	d880038d 	sth	r2,14(sp)
8111c2d8:	111c83c0 	call	8111c83c <___svfprintf_internal_r>
8111c2dc:	d8c00017 	ldw	r3,0(sp)
8111c2e0:	18000005 	stb	zero,0(r3)
8111c2e4:	dfc01a17 	ldw	ra,104(sp)
8111c2e8:	dec01c04 	addi	sp,sp,112
8111c2ec:	f800283a 	ret

8111c2f0 <sprintf>:
8111c2f0:	deffe304 	addi	sp,sp,-116
8111c2f4:	2007883a 	mov	r3,r4
8111c2f8:	de00012e 	bgeu	sp,et,8111c300 <sprintf+0x10>
8111c2fc:	003b68fa 	trap	3
8111c300:	dfc01a15 	stw	ra,104(sp)
8111c304:	d9801b15 	stw	r6,108(sp)
8111c308:	d9c01c15 	stw	r7,112(sp)
8111c30c:	01204574 	movhi	r4,33045
8111c310:	21308204 	addi	r4,r4,-15864
8111c314:	21000017 	ldw	r4,0(r4)
8111c318:	00a00034 	movhi	r2,32768
8111c31c:	10bfffc4 	addi	r2,r2,-1
8111c320:	280d883a 	mov	r6,r5
8111c324:	02008204 	movi	r8,520
8111c328:	d8800215 	stw	r2,8(sp)
8111c32c:	d8800515 	stw	r2,20(sp)
8111c330:	d9c01b04 	addi	r7,sp,108
8111c334:	d80b883a 	mov	r5,sp
8111c338:	00bfffc4 	movi	r2,-1
8111c33c:	d8c00015 	stw	r3,0(sp)
8111c340:	d8c00415 	stw	r3,16(sp)
8111c344:	da00030d 	sth	r8,12(sp)
8111c348:	d880038d 	sth	r2,14(sp)
8111c34c:	111c83c0 	call	8111c83c <___svfprintf_internal_r>
8111c350:	d8c00017 	ldw	r3,0(sp)
8111c354:	18000005 	stb	zero,0(r3)
8111c358:	dfc01a17 	ldw	ra,104(sp)
8111c35c:	dec01d04 	addi	sp,sp,116
8111c360:	f800283a 	ret

8111c364 <__sread>:
8111c364:	defffe04 	addi	sp,sp,-8
8111c368:	de00012e 	bgeu	sp,et,8111c370 <__sread+0xc>
8111c36c:	003b68fa 	trap	3
8111c370:	dc000015 	stw	r16,0(sp)
8111c374:	2821883a 	mov	r16,r5
8111c378:	2940038f 	ldh	r5,14(r5)
8111c37c:	dfc00115 	stw	ra,4(sp)
8111c380:	1126c9c0 	call	81126c9c <_read_r>
8111c384:	10000716 	blt	r2,zero,8111c3a4 <__sread+0x40>
8111c388:	80c01417 	ldw	r3,80(r16)
8111c38c:	1887883a 	add	r3,r3,r2
8111c390:	80c01415 	stw	r3,80(r16)
8111c394:	dfc00117 	ldw	ra,4(sp)
8111c398:	dc000017 	ldw	r16,0(sp)
8111c39c:	dec00204 	addi	sp,sp,8
8111c3a0:	f800283a 	ret
8111c3a4:	80c0030b 	ldhu	r3,12(r16)
8111c3a8:	18fbffcc 	andi	r3,r3,61439
8111c3ac:	80c0030d 	sth	r3,12(r16)
8111c3b0:	dfc00117 	ldw	ra,4(sp)
8111c3b4:	dc000017 	ldw	r16,0(sp)
8111c3b8:	dec00204 	addi	sp,sp,8
8111c3bc:	f800283a 	ret

8111c3c0 <__seofread>:
8111c3c0:	0005883a 	mov	r2,zero
8111c3c4:	f800283a 	ret

8111c3c8 <__swrite>:
8111c3c8:	defffb04 	addi	sp,sp,-20
8111c3cc:	de00012e 	bgeu	sp,et,8111c3d4 <__swrite+0xc>
8111c3d0:	003b68fa 	trap	3
8111c3d4:	2880030b 	ldhu	r2,12(r5)
8111c3d8:	dcc00315 	stw	r19,12(sp)
8111c3dc:	dc800215 	stw	r18,8(sp)
8111c3e0:	dc400115 	stw	r17,4(sp)
8111c3e4:	dc000015 	stw	r16,0(sp)
8111c3e8:	dfc00415 	stw	ra,16(sp)
8111c3ec:	10c0400c 	andi	r3,r2,256
8111c3f0:	2821883a 	mov	r16,r5
8111c3f4:	2023883a 	mov	r17,r4
8111c3f8:	3025883a 	mov	r18,r6
8111c3fc:	3827883a 	mov	r19,r7
8111c400:	18000526 	beq	r3,zero,8111c418 <__swrite+0x50>
8111c404:	2940038f 	ldh	r5,14(r5)
8111c408:	01c00084 	movi	r7,2
8111c40c:	000d883a 	mov	r6,zero
8111c410:	11257540 	call	81125754 <_lseek_r>
8111c414:	8080030b 	ldhu	r2,12(r16)
8111c418:	8140038f 	ldh	r5,14(r16)
8111c41c:	10bbffcc 	andi	r2,r2,61439
8111c420:	980f883a 	mov	r7,r19
8111c424:	900d883a 	mov	r6,r18
8111c428:	8809883a 	mov	r4,r17
8111c42c:	8080030d 	sth	r2,12(r16)
8111c430:	dfc00417 	ldw	ra,16(sp)
8111c434:	dcc00317 	ldw	r19,12(sp)
8111c438:	dc800217 	ldw	r18,8(sp)
8111c43c:	dc400117 	ldw	r17,4(sp)
8111c440:	dc000017 	ldw	r16,0(sp)
8111c444:	dec00504 	addi	sp,sp,20
8111c448:	11227001 	jmpi	81122700 <_write_r>

8111c44c <__sseek>:
8111c44c:	defffe04 	addi	sp,sp,-8
8111c450:	de00012e 	bgeu	sp,et,8111c458 <__sseek+0xc>
8111c454:	003b68fa 	trap	3
8111c458:	dc000015 	stw	r16,0(sp)
8111c45c:	2821883a 	mov	r16,r5
8111c460:	2940038f 	ldh	r5,14(r5)
8111c464:	dfc00115 	stw	ra,4(sp)
8111c468:	11257540 	call	81125754 <_lseek_r>
8111c46c:	00ffffc4 	movi	r3,-1
8111c470:	10c00826 	beq	r2,r3,8111c494 <__sseek+0x48>
8111c474:	80c0030b 	ldhu	r3,12(r16)
8111c478:	80801415 	stw	r2,80(r16)
8111c47c:	18c40014 	ori	r3,r3,4096
8111c480:	80c0030d 	sth	r3,12(r16)
8111c484:	dfc00117 	ldw	ra,4(sp)
8111c488:	dc000017 	ldw	r16,0(sp)
8111c48c:	dec00204 	addi	sp,sp,8
8111c490:	f800283a 	ret
8111c494:	80c0030b 	ldhu	r3,12(r16)
8111c498:	18fbffcc 	andi	r3,r3,61439
8111c49c:	80c0030d 	sth	r3,12(r16)
8111c4a0:	dfc00117 	ldw	ra,4(sp)
8111c4a4:	dc000017 	ldw	r16,0(sp)
8111c4a8:	dec00204 	addi	sp,sp,8
8111c4ac:	f800283a 	ret

8111c4b0 <__sclose>:
8111c4b0:	2940038f 	ldh	r5,14(r5)
8111c4b4:	11228c41 	jmpi	811228c4 <_close_r>

8111c4b8 <strcspn>:
8111c4b8:	21c00007 	ldb	r7,0(r4)
8111c4bc:	38000f26 	beq	r7,zero,8111c4fc <strcspn+0x44>
8111c4c0:	2a000007 	ldb	r8,0(r5)
8111c4c4:	2005883a 	mov	r2,r4
8111c4c8:	40000726 	beq	r8,zero,8111c4e8 <strcspn+0x30>
8111c4cc:	3a000926 	beq	r7,r8,8111c4f4 <strcspn+0x3c>
8111c4d0:	2807883a 	mov	r3,r5
8111c4d4:	00000106 	br	8111c4dc <strcspn+0x24>
8111c4d8:	31c00626 	beq	r6,r7,8111c4f4 <strcspn+0x3c>
8111c4dc:	18c00044 	addi	r3,r3,1
8111c4e0:	19800007 	ldb	r6,0(r3)
8111c4e4:	303ffc1e 	bne	r6,zero,8111c4d8 <__reset+0xfb0fc4d8>
8111c4e8:	10800044 	addi	r2,r2,1
8111c4ec:	11c00007 	ldb	r7,0(r2)
8111c4f0:	383ff51e 	bne	r7,zero,8111c4c8 <__reset+0xfb0fc4c8>
8111c4f4:	1105c83a 	sub	r2,r2,r4
8111c4f8:	f800283a 	ret
8111c4fc:	0005883a 	mov	r2,zero
8111c500:	f800283a 	ret

8111c504 <strlen>:
8111c504:	208000cc 	andi	r2,r4,3
8111c508:	10002026 	beq	r2,zero,8111c58c <strlen+0x88>
8111c50c:	20800007 	ldb	r2,0(r4)
8111c510:	10002026 	beq	r2,zero,8111c594 <strlen+0x90>
8111c514:	2005883a 	mov	r2,r4
8111c518:	00000206 	br	8111c524 <strlen+0x20>
8111c51c:	10c00007 	ldb	r3,0(r2)
8111c520:	18001826 	beq	r3,zero,8111c584 <strlen+0x80>
8111c524:	10800044 	addi	r2,r2,1
8111c528:	10c000cc 	andi	r3,r2,3
8111c52c:	183ffb1e 	bne	r3,zero,8111c51c <__reset+0xfb0fc51c>
8111c530:	10c00017 	ldw	r3,0(r2)
8111c534:	01ffbff4 	movhi	r7,65279
8111c538:	39ffbfc4 	addi	r7,r7,-257
8111c53c:	00ca303a 	nor	r5,zero,r3
8111c540:	01a02074 	movhi	r6,32897
8111c544:	19c7883a 	add	r3,r3,r7
8111c548:	31a02004 	addi	r6,r6,-32640
8111c54c:	1946703a 	and	r3,r3,r5
8111c550:	1986703a 	and	r3,r3,r6
8111c554:	1800091e 	bne	r3,zero,8111c57c <strlen+0x78>
8111c558:	10800104 	addi	r2,r2,4
8111c55c:	10c00017 	ldw	r3,0(r2)
8111c560:	19cb883a 	add	r5,r3,r7
8111c564:	00c6303a 	nor	r3,zero,r3
8111c568:	28c6703a 	and	r3,r5,r3
8111c56c:	1986703a 	and	r3,r3,r6
8111c570:	183ff926 	beq	r3,zero,8111c558 <__reset+0xfb0fc558>
8111c574:	00000106 	br	8111c57c <strlen+0x78>
8111c578:	10800044 	addi	r2,r2,1
8111c57c:	10c00007 	ldb	r3,0(r2)
8111c580:	183ffd1e 	bne	r3,zero,8111c578 <__reset+0xfb0fc578>
8111c584:	1105c83a 	sub	r2,r2,r4
8111c588:	f800283a 	ret
8111c58c:	2005883a 	mov	r2,r4
8111c590:	003fe706 	br	8111c530 <__reset+0xfb0fc530>
8111c594:	0005883a 	mov	r2,zero
8111c598:	f800283a 	ret

8111c59c <strnlen>:
8111c59c:	28000e26 	beq	r5,zero,8111c5d8 <strnlen+0x3c>
8111c5a0:	20800007 	ldb	r2,0(r4)
8111c5a4:	10000c26 	beq	r2,zero,8111c5d8 <strnlen+0x3c>
8111c5a8:	20c00044 	addi	r3,r4,1
8111c5ac:	214b883a 	add	r5,r4,r5
8111c5b0:	28c00526 	beq	r5,r3,8111c5c8 <strnlen+0x2c>
8111c5b4:	19800007 	ldb	r6,0(r3)
8111c5b8:	19c00044 	addi	r7,r3,1
8111c5bc:	30000426 	beq	r6,zero,8111c5d0 <strnlen+0x34>
8111c5c0:	3807883a 	mov	r3,r7
8111c5c4:	28fffb1e 	bne	r5,r3,8111c5b4 <__reset+0xfb0fc5b4>
8111c5c8:	2905c83a 	sub	r2,r5,r4
8111c5cc:	f800283a 	ret
8111c5d0:	1905c83a 	sub	r2,r3,r4
8111c5d4:	f800283a 	ret
8111c5d8:	0005883a 	mov	r2,zero
8111c5dc:	f800283a 	ret

8111c5e0 <_strtol_r>:
8111c5e0:	00a04574 	movhi	r2,33045
8111c5e4:	defff404 	addi	sp,sp,-48
8111c5e8:	10b08004 	addi	r2,r2,-15872
8111c5ec:	de00012e 	bgeu	sp,et,8111c5f4 <_strtol_r+0x14>
8111c5f0:	003b68fa 	trap	3
8111c5f4:	dd400715 	stw	r21,28(sp)
8111c5f8:	15400017 	ldw	r21,0(r2)
8111c5fc:	dd800815 	stw	r22,32(sp)
8111c600:	dd000615 	stw	r20,24(sp)
8111c604:	dcc00515 	stw	r19,20(sp)
8111c608:	d9000015 	stw	r4,0(sp)
8111c60c:	dfc00b15 	stw	ra,44(sp)
8111c610:	df000a15 	stw	fp,40(sp)
8111c614:	ddc00915 	stw	r23,36(sp)
8111c618:	dc800415 	stw	r18,16(sp)
8111c61c:	dc400315 	stw	r17,12(sp)
8111c620:	dc000215 	stw	r16,8(sp)
8111c624:	2829883a 	mov	r20,r5
8111c628:	3027883a 	mov	r19,r6
8111c62c:	382d883a 	mov	r22,r7
8111c630:	2809883a 	mov	r4,r5
8111c634:	24000003 	ldbu	r16,0(r4)
8111c638:	24400044 	addi	r17,r4,1
8111c63c:	2007883a 	mov	r3,r4
8111c640:	ac05883a 	add	r2,r21,r16
8111c644:	10800043 	ldbu	r2,1(r2)
8111c648:	8809883a 	mov	r4,r17
8111c64c:	1080020c 	andi	r2,r2,8
8111c650:	103ff81e 	bne	r2,zero,8111c634 <__reset+0xfb0fc634>
8111c654:	00800b44 	movi	r2,45
8111c658:	80805826 	beq	r16,r2,8111c7bc <_strtol_r+0x1dc>
8111c65c:	00800ac4 	movi	r2,43
8111c660:	80805a26 	beq	r16,r2,8111c7cc <_strtol_r+0x1ec>
8111c664:	0039883a 	mov	fp,zero
8111c668:	b0004426 	beq	r22,zero,8111c77c <_strtol_r+0x19c>
8111c66c:	00800404 	movi	r2,16
8111c670:	b0806026 	beq	r22,r2,8111c7f4 <_strtol_r+0x214>
8111c674:	b02f883a 	mov	r23,r22
8111c678:	00a00034 	movhi	r2,32768
8111c67c:	e025003a 	cmpeq	r18,fp,zero
8111c680:	14a5c83a 	sub	r18,r2,r18
8111c684:	b80b883a 	mov	r5,r23
8111c688:	9009883a 	mov	r4,r18
8111c68c:	112e05c0 	call	8112e05c <__umodsi3>
8111c690:	b80b883a 	mov	r5,r23
8111c694:	9009883a 	mov	r4,r18
8111c698:	d8800115 	stw	r2,4(sp)
8111c69c:	112dff80 	call	8112dff8 <__udivsi3>
8111c6a0:	ac07883a 	add	r3,r21,r16
8111c6a4:	18c00043 	ldbu	r3,1(r3)
8111c6a8:	880b883a 	mov	r5,r17
8111c6ac:	000d883a 	mov	r6,zero
8111c6b0:	1a00010c 	andi	r8,r3,4
8111c6b4:	0009883a 	mov	r4,zero
8111c6b8:	02800044 	movi	r10,1
8111c6bc:	027fffc4 	movi	r9,-1
8111c6c0:	d9c00117 	ldw	r7,4(sp)
8111c6c4:	40000e26 	beq	r8,zero,8111c700 <_strtol_r+0x120>
8111c6c8:	843ff404 	addi	r16,r16,-48
8111c6cc:	8580120e 	bge	r16,r22,8111c718 <_strtol_r+0x138>
8111c6d0:	32400526 	beq	r6,r9,8111c6e8 <_strtol_r+0x108>
8111c6d4:	11002536 	bltu	r2,r4,8111c76c <_strtol_r+0x18c>
8111c6d8:	20802326 	beq	r4,r2,8111c768 <_strtol_r+0x188>
8111c6dc:	25c9383a 	mul	r4,r4,r23
8111c6e0:	01800044 	movi	r6,1
8111c6e4:	8109883a 	add	r4,r16,r4
8111c6e8:	2c000003 	ldbu	r16,0(r5)
8111c6ec:	29400044 	addi	r5,r5,1
8111c6f0:	ac07883a 	add	r3,r21,r16
8111c6f4:	18c00043 	ldbu	r3,1(r3)
8111c6f8:	1a00010c 	andi	r8,r3,4
8111c6fc:	403ff21e 	bne	r8,zero,8111c6c8 <__reset+0xfb0fc6c8>
8111c700:	18c000cc 	andi	r3,r3,3
8111c704:	18000426 	beq	r3,zero,8111c718 <_strtol_r+0x138>
8111c708:	1a801a26 	beq	r3,r10,8111c774 <_strtol_r+0x194>
8111c70c:	00c015c4 	movi	r3,87
8111c710:	80e1c83a 	sub	r16,r16,r3
8111c714:	85bfee16 	blt	r16,r22,8111c6d0 <__reset+0xfb0fc6d0>
8111c718:	00bfffc4 	movi	r2,-1
8111c71c:	30801e26 	beq	r6,r2,8111c798 <_strtol_r+0x1b8>
8111c720:	e0001b1e 	bne	fp,zero,8111c790 <_strtol_r+0x1b0>
8111c724:	2005883a 	mov	r2,r4
8111c728:	98000326 	beq	r19,zero,8111c738 <_strtol_r+0x158>
8111c72c:	3000211e 	bne	r6,zero,8111c7b4 <_strtol_r+0x1d4>
8111c730:	a00b883a 	mov	r5,r20
8111c734:	99400015 	stw	r5,0(r19)
8111c738:	dfc00b17 	ldw	ra,44(sp)
8111c73c:	df000a17 	ldw	fp,40(sp)
8111c740:	ddc00917 	ldw	r23,36(sp)
8111c744:	dd800817 	ldw	r22,32(sp)
8111c748:	dd400717 	ldw	r21,28(sp)
8111c74c:	dd000617 	ldw	r20,24(sp)
8111c750:	dcc00517 	ldw	r19,20(sp)
8111c754:	dc800417 	ldw	r18,16(sp)
8111c758:	dc400317 	ldw	r17,12(sp)
8111c75c:	dc000217 	ldw	r16,8(sp)
8111c760:	dec00c04 	addi	sp,sp,48
8111c764:	f800283a 	ret
8111c768:	3c3fdc0e 	bge	r7,r16,8111c6dc <__reset+0xfb0fc6dc>
8111c76c:	01bfffc4 	movi	r6,-1
8111c770:	003fdd06 	br	8111c6e8 <__reset+0xfb0fc6e8>
8111c774:	00c00dc4 	movi	r3,55
8111c778:	003fe506 	br	8111c710 <__reset+0xfb0fc710>
8111c77c:	00800c04 	movi	r2,48
8111c780:	80801626 	beq	r16,r2,8111c7dc <_strtol_r+0x1fc>
8111c784:	05800284 	movi	r22,10
8111c788:	b02f883a 	mov	r23,r22
8111c78c:	003fba06 	br	8111c678 <__reset+0xfb0fc678>
8111c790:	0109c83a 	sub	r4,zero,r4
8111c794:	003fe306 	br	8111c724 <__reset+0xfb0fc724>
8111c798:	d9000017 	ldw	r4,0(sp)
8111c79c:	00c00884 	movi	r3,34
8111c7a0:	e005003a 	cmpeq	r2,fp,zero
8111c7a4:	20c00015 	stw	r3,0(r4)
8111c7a8:	00e00034 	movhi	r3,32768
8111c7ac:	1885c83a 	sub	r2,r3,r2
8111c7b0:	983fe126 	beq	r19,zero,8111c738 <__reset+0xfb0fc738>
8111c7b4:	297fffc4 	addi	r5,r5,-1
8111c7b8:	003fde06 	br	8111c734 <__reset+0xfb0fc734>
8111c7bc:	1c400084 	addi	r17,r3,2
8111c7c0:	1c000043 	ldbu	r16,1(r3)
8111c7c4:	07000044 	movi	fp,1
8111c7c8:	003fa706 	br	8111c668 <__reset+0xfb0fc668>
8111c7cc:	1c400084 	addi	r17,r3,2
8111c7d0:	1c000043 	ldbu	r16,1(r3)
8111c7d4:	0039883a 	mov	fp,zero
8111c7d8:	003fa306 	br	8111c668 <__reset+0xfb0fc668>
8111c7dc:	88800003 	ldbu	r2,0(r17)
8111c7e0:	00c01604 	movi	r3,88
8111c7e4:	108037cc 	andi	r2,r2,223
8111c7e8:	10c00826 	beq	r2,r3,8111c80c <_strtol_r+0x22c>
8111c7ec:	05800204 	movi	r22,8
8111c7f0:	003fa006 	br	8111c674 <__reset+0xfb0fc674>
8111c7f4:	00800c04 	movi	r2,48
8111c7f8:	80bf9e1e 	bne	r16,r2,8111c674 <__reset+0xfb0fc674>
8111c7fc:	88800003 	ldbu	r2,0(r17)
8111c800:	00c01604 	movi	r3,88
8111c804:	108037cc 	andi	r2,r2,223
8111c808:	10ff9a1e 	bne	r2,r3,8111c674 <__reset+0xfb0fc674>
8111c80c:	05c00404 	movi	r23,16
8111c810:	8c000043 	ldbu	r16,1(r17)
8111c814:	b82d883a 	mov	r22,r23
8111c818:	8c400084 	addi	r17,r17,2
8111c81c:	003f9606 	br	8111c678 <__reset+0xfb0fc678>

8111c820 <strtol>:
8111c820:	00a04574 	movhi	r2,33045
8111c824:	10b08204 	addi	r2,r2,-15864
8111c828:	300f883a 	mov	r7,r6
8111c82c:	280d883a 	mov	r6,r5
8111c830:	200b883a 	mov	r5,r4
8111c834:	11000017 	ldw	r4,0(r2)
8111c838:	111c5e01 	jmpi	8111c5e0 <_strtol_r>

8111c83c <___svfprintf_internal_r>:
8111c83c:	deffb704 	addi	sp,sp,-292
8111c840:	de00012e 	bgeu	sp,et,8111c848 <___svfprintf_internal_r+0xc>
8111c844:	003b68fa 	trap	3
8111c848:	dfc04815 	stw	ra,288(sp)
8111c84c:	ddc04615 	stw	r23,280(sp)
8111c850:	d9402c15 	stw	r5,176(sp)
8111c854:	d9003915 	stw	r4,228(sp)
8111c858:	302f883a 	mov	r23,r6
8111c85c:	d9c02d15 	stw	r7,180(sp)
8111c860:	df004715 	stw	fp,284(sp)
8111c864:	dd804515 	stw	r22,276(sp)
8111c868:	dd404415 	stw	r21,272(sp)
8111c86c:	dd004315 	stw	r20,268(sp)
8111c870:	dcc04215 	stw	r19,264(sp)
8111c874:	dc804115 	stw	r18,260(sp)
8111c878:	dc404015 	stw	r17,256(sp)
8111c87c:	dc003f15 	stw	r16,252(sp)
8111c880:	11257240 	call	81125724 <_localeconv_r>
8111c884:	10800017 	ldw	r2,0(r2)
8111c888:	1009883a 	mov	r4,r2
8111c88c:	d8803415 	stw	r2,208(sp)
8111c890:	111c5040 	call	8111c504 <strlen>
8111c894:	d8c02c17 	ldw	r3,176(sp)
8111c898:	d8803815 	stw	r2,224(sp)
8111c89c:	1880030b 	ldhu	r2,12(r3)
8111c8a0:	1080200c 	andi	r2,r2,128
8111c8a4:	10000226 	beq	r2,zero,8111c8b0 <___svfprintf_internal_r+0x74>
8111c8a8:	18800417 	ldw	r2,16(r3)
8111c8ac:	10067f26 	beq	r2,zero,8111e2ac <___svfprintf_internal_r+0x1a70>
8111c8b0:	dcc03917 	ldw	r19,228(sp)
8111c8b4:	d8c00404 	addi	r3,sp,16
8111c8b8:	05604574 	movhi	r21,33045
8111c8bc:	d9001e04 	addi	r4,sp,120
8111c8c0:	ad66ba84 	addi	r21,r21,-25878
8111c8c4:	d8c01e15 	stw	r3,120(sp)
8111c8c8:	d8002015 	stw	zero,128(sp)
8111c8cc:	d8001f15 	stw	zero,124(sp)
8111c8d0:	d8003315 	stw	zero,204(sp)
8111c8d4:	d8003615 	stw	zero,216(sp)
8111c8d8:	d8003715 	stw	zero,220(sp)
8111c8dc:	1811883a 	mov	r8,r3
8111c8e0:	d8003a15 	stw	zero,232(sp)
8111c8e4:	d8003b15 	stw	zero,236(sp)
8111c8e8:	d8002f15 	stw	zero,188(sp)
8111c8ec:	d9002815 	stw	r4,160(sp)
8111c8f0:	b8800007 	ldb	r2,0(r23)
8111c8f4:	10026726 	beq	r2,zero,8111d294 <___svfprintf_internal_r+0xa58>
8111c8f8:	00c00944 	movi	r3,37
8111c8fc:	b821883a 	mov	r16,r23
8111c900:	10c0021e 	bne	r2,r3,8111c90c <___svfprintf_internal_r+0xd0>
8111c904:	00001406 	br	8111c958 <___svfprintf_internal_r+0x11c>
8111c908:	10c00326 	beq	r2,r3,8111c918 <___svfprintf_internal_r+0xdc>
8111c90c:	84000044 	addi	r16,r16,1
8111c910:	80800007 	ldb	r2,0(r16)
8111c914:	103ffc1e 	bne	r2,zero,8111c908 <__reset+0xfb0fc908>
8111c918:	85e3c83a 	sub	r17,r16,r23
8111c91c:	88000e26 	beq	r17,zero,8111c958 <___svfprintf_internal_r+0x11c>
8111c920:	d8c02017 	ldw	r3,128(sp)
8111c924:	d8801f17 	ldw	r2,124(sp)
8111c928:	45c00015 	stw	r23,0(r8)
8111c92c:	1c47883a 	add	r3,r3,r17
8111c930:	10800044 	addi	r2,r2,1
8111c934:	d8c02015 	stw	r3,128(sp)
8111c938:	44400115 	stw	r17,4(r8)
8111c93c:	d8801f15 	stw	r2,124(sp)
8111c940:	00c001c4 	movi	r3,7
8111c944:	18809716 	blt	r3,r2,8111cba4 <___svfprintf_internal_r+0x368>
8111c948:	42000204 	addi	r8,r8,8
8111c94c:	d9402f17 	ldw	r5,188(sp)
8111c950:	2c4b883a 	add	r5,r5,r17
8111c954:	d9402f15 	stw	r5,188(sp)
8111c958:	80800007 	ldb	r2,0(r16)
8111c95c:	10009826 	beq	r2,zero,8111cbc0 <___svfprintf_internal_r+0x384>
8111c960:	84400047 	ldb	r17,1(r16)
8111c964:	00bfffc4 	movi	r2,-1
8111c968:	85c00044 	addi	r23,r16,1
8111c96c:	d8002785 	stb	zero,158(sp)
8111c970:	0007883a 	mov	r3,zero
8111c974:	000f883a 	mov	r7,zero
8111c978:	d8802915 	stw	r2,164(sp)
8111c97c:	d8003115 	stw	zero,196(sp)
8111c980:	0025883a 	mov	r18,zero
8111c984:	01401604 	movi	r5,88
8111c988:	01800244 	movi	r6,9
8111c98c:	02800a84 	movi	r10,42
8111c990:	02401b04 	movi	r9,108
8111c994:	bdc00044 	addi	r23,r23,1
8111c998:	88bff804 	addi	r2,r17,-32
8111c99c:	2882f036 	bltu	r5,r2,8111d560 <___svfprintf_internal_r+0xd24>
8111c9a0:	100490ba 	slli	r2,r2,2
8111c9a4:	012044b4 	movhi	r4,33042
8111c9a8:	21326e04 	addi	r4,r4,-13896
8111c9ac:	1105883a 	add	r2,r2,r4
8111c9b0:	10800017 	ldw	r2,0(r2)
8111c9b4:	1000683a 	jmp	r2
8111c9b8:	8111d4c8 	cmpgei	r4,r16,18259
8111c9bc:	8111d560 	cmpeqi	r4,r16,18261
8111c9c0:	8111d560 	cmpeqi	r4,r16,18261
8111c9c4:	8111d4bc 	xorhi	r4,r16,18258
8111c9c8:	8111d560 	cmpeqi	r4,r16,18261
8111c9cc:	8111d560 	cmpeqi	r4,r16,18261
8111c9d0:	8111d560 	cmpeqi	r4,r16,18261
8111c9d4:	8111d560 	cmpeqi	r4,r16,18261
8111c9d8:	8111d560 	cmpeqi	r4,r16,18261
8111c9dc:	8111d560 	cmpeqi	r4,r16,18261
8111c9e0:	8111cc1c 	xori	r4,r16,18224
8111c9e4:	8111d3f8 	rdprs	r4,r16,18255
8111c9e8:	8111d560 	cmpeqi	r4,r16,18261
8111c9ec:	8111cb2c 	andhi	r4,r16,18220
8111c9f0:	8111cc44 	addi	r4,r16,18225
8111c9f4:	8111d560 	cmpeqi	r4,r16,18261
8111c9f8:	8111ccb8 	rdprs	r4,r16,18226
8111c9fc:	8111cc84 	addi	r4,r16,18226
8111ca00:	8111cc84 	addi	r4,r16,18226
8111ca04:	8111cc84 	addi	r4,r16,18226
8111ca08:	8111cc84 	addi	r4,r16,18226
8111ca0c:	8111cc84 	addi	r4,r16,18226
8111ca10:	8111cc84 	addi	r4,r16,18226
8111ca14:	8111cc84 	addi	r4,r16,18226
8111ca18:	8111cc84 	addi	r4,r16,18226
8111ca1c:	8111cc84 	addi	r4,r16,18226
8111ca20:	8111d560 	cmpeqi	r4,r16,18261
8111ca24:	8111d560 	cmpeqi	r4,r16,18261
8111ca28:	8111d560 	cmpeqi	r4,r16,18261
8111ca2c:	8111d560 	cmpeqi	r4,r16,18261
8111ca30:	8111d560 	cmpeqi	r4,r16,18261
8111ca34:	8111d560 	cmpeqi	r4,r16,18261
8111ca38:	8111d560 	cmpeqi	r4,r16,18261
8111ca3c:	8111d560 	cmpeqi	r4,r16,18261
8111ca40:	8111d560 	cmpeqi	r4,r16,18261
8111ca44:	8111d560 	cmpeqi	r4,r16,18261
8111ca48:	8111cd70 	cmpltui	r4,r16,18229
8111ca4c:	8111ccc4 	addi	r4,r16,18227
8111ca50:	8111d560 	cmpeqi	r4,r16,18261
8111ca54:	8111ccc4 	addi	r4,r16,18227
8111ca58:	8111d560 	cmpeqi	r4,r16,18261
8111ca5c:	8111d560 	cmpeqi	r4,r16,18261
8111ca60:	8111d560 	cmpeqi	r4,r16,18261
8111ca64:	8111d560 	cmpeqi	r4,r16,18261
8111ca68:	8111cd64 	muli	r4,r16,18229
8111ca6c:	8111d560 	cmpeqi	r4,r16,18261
8111ca70:	8111d560 	cmpeqi	r4,r16,18261
8111ca74:	8111ce2c 	andhi	r4,r16,18232
8111ca78:	8111d560 	cmpeqi	r4,r16,18261
8111ca7c:	8111d560 	cmpeqi	r4,r16,18261
8111ca80:	8111d560 	cmpeqi	r4,r16,18261
8111ca84:	8111d560 	cmpeqi	r4,r16,18261
8111ca88:	8111d560 	cmpeqi	r4,r16,18261
8111ca8c:	8111d29c 	xori	r4,r16,18250
8111ca90:	8111d560 	cmpeqi	r4,r16,18261
8111ca94:	8111d560 	cmpeqi	r4,r16,18261
8111ca98:	8111d2fc 	xorhi	r4,r16,18251
8111ca9c:	8111d560 	cmpeqi	r4,r16,18261
8111caa0:	8111d560 	cmpeqi	r4,r16,18261
8111caa4:	8111d560 	cmpeqi	r4,r16,18261
8111caa8:	8111d560 	cmpeqi	r4,r16,18261
8111caac:	8111d560 	cmpeqi	r4,r16,18261
8111cab0:	8111d560 	cmpeqi	r4,r16,18261
8111cab4:	8111d560 	cmpeqi	r4,r16,18261
8111cab8:	8111d560 	cmpeqi	r4,r16,18261
8111cabc:	8111d560 	cmpeqi	r4,r16,18261
8111cac0:	8111d560 	cmpeqi	r4,r16,18261
8111cac4:	8111d3ac 	andhi	r4,r16,18254
8111cac8:	8111d4e8 	cmpgeui	r4,r16,18259
8111cacc:	8111ccc4 	addi	r4,r16,18227
8111cad0:	8111ccc4 	addi	r4,r16,18227
8111cad4:	8111ccc4 	addi	r4,r16,18227
8111cad8:	8111d53c 	xorhi	r4,r16,18260
8111cadc:	8111d4e8 	cmpgeui	r4,r16,18259
8111cae0:	8111d560 	cmpeqi	r4,r16,18261
8111cae4:	8111d560 	cmpeqi	r4,r16,18261
8111cae8:	8111d4f8 	rdprs	r4,r16,18259
8111caec:	8111d560 	cmpeqi	r4,r16,18261
8111caf0:	8111d508 	cmpgei	r4,r16,18260
8111caf4:	8111d3e8 	cmpgeui	r4,r16,18255
8111caf8:	8111cb38 	rdprs	r4,r16,18220
8111cafc:	8111d408 	cmpgei	r4,r16,18256
8111cb00:	8111d560 	cmpeqi	r4,r16,18261
8111cb04:	8111d414 	ori	r4,r16,18256
8111cb08:	8111d560 	cmpeqi	r4,r16,18261
8111cb0c:	8111d470 	cmpltui	r4,r16,18257
8111cb10:	8111d560 	cmpeqi	r4,r16,18261
8111cb14:	8111d560 	cmpeqi	r4,r16,18261
8111cb18:	8111d480 	call	88111d48 <__reset+0x20f1d48>
8111cb1c:	d9003117 	ldw	r4,196(sp)
8111cb20:	d8802d15 	stw	r2,180(sp)
8111cb24:	0109c83a 	sub	r4,zero,r4
8111cb28:	d9003115 	stw	r4,196(sp)
8111cb2c:	94800114 	ori	r18,r18,4
8111cb30:	bc400007 	ldb	r17,0(r23)
8111cb34:	003f9706 	br	8111c994 <__reset+0xfb0fc994>
8111cb38:	00800c04 	movi	r2,48
8111cb3c:	d9002d17 	ldw	r4,180(sp)
8111cb40:	d9402917 	ldw	r5,164(sp)
8111cb44:	d8802705 	stb	r2,156(sp)
8111cb48:	00801e04 	movi	r2,120
8111cb4c:	d8802745 	stb	r2,157(sp)
8111cb50:	d8002785 	stb	zero,158(sp)
8111cb54:	20c00104 	addi	r3,r4,4
8111cb58:	25000017 	ldw	r20,0(r4)
8111cb5c:	002d883a 	mov	r22,zero
8111cb60:	90800094 	ori	r2,r18,2
8111cb64:	28028616 	blt	r5,zero,8111d580 <___svfprintf_internal_r+0xd44>
8111cb68:	00bfdfc4 	movi	r2,-129
8111cb6c:	90a4703a 	and	r18,r18,r2
8111cb70:	d8c02d15 	stw	r3,180(sp)
8111cb74:	94800094 	ori	r18,r18,2
8111cb78:	a002731e 	bne	r20,zero,8111d548 <___svfprintf_internal_r+0xd0c>
8111cb7c:	00a04574 	movhi	r2,33045
8111cb80:	10a6b304 	addi	r2,r2,-25908
8111cb84:	d8803a15 	stw	r2,232(sp)
8111cb88:	04401e04 	movi	r17,120
8111cb8c:	d8c02917 	ldw	r3,164(sp)
8111cb90:	0039883a 	mov	fp,zero
8111cb94:	1801d526 	beq	r3,zero,8111d2ec <___svfprintf_internal_r+0xab0>
8111cb98:	0029883a 	mov	r20,zero
8111cb9c:	002d883a 	mov	r22,zero
8111cba0:	0001f106 	br	8111d368 <___svfprintf_internal_r+0xb2c>
8111cba4:	d9402c17 	ldw	r5,176(sp)
8111cba8:	d9801e04 	addi	r6,sp,120
8111cbac:	9809883a 	mov	r4,r19
8111cbb0:	112945c0 	call	8112945c <__ssprint_r>
8111cbb4:	1000081e 	bne	r2,zero,8111cbd8 <___svfprintf_internal_r+0x39c>
8111cbb8:	da000404 	addi	r8,sp,16
8111cbbc:	003f6306 	br	8111c94c <__reset+0xfb0fc94c>
8111cbc0:	d8802017 	ldw	r2,128(sp)
8111cbc4:	10000426 	beq	r2,zero,8111cbd8 <___svfprintf_internal_r+0x39c>
8111cbc8:	d9402c17 	ldw	r5,176(sp)
8111cbcc:	d9003917 	ldw	r4,228(sp)
8111cbd0:	d9801e04 	addi	r6,sp,120
8111cbd4:	112945c0 	call	8112945c <__ssprint_r>
8111cbd8:	d8802c17 	ldw	r2,176(sp)
8111cbdc:	10c0030b 	ldhu	r3,12(r2)
8111cbe0:	d8802f17 	ldw	r2,188(sp)
8111cbe4:	18c0100c 	andi	r3,r3,64
8111cbe8:	1805f51e 	bne	r3,zero,8111e3c0 <___svfprintf_internal_r+0x1b84>
8111cbec:	dfc04817 	ldw	ra,288(sp)
8111cbf0:	df004717 	ldw	fp,284(sp)
8111cbf4:	ddc04617 	ldw	r23,280(sp)
8111cbf8:	dd804517 	ldw	r22,276(sp)
8111cbfc:	dd404417 	ldw	r21,272(sp)
8111cc00:	dd004317 	ldw	r20,268(sp)
8111cc04:	dcc04217 	ldw	r19,264(sp)
8111cc08:	dc804117 	ldw	r18,260(sp)
8111cc0c:	dc404017 	ldw	r17,256(sp)
8111cc10:	dc003f17 	ldw	r16,252(sp)
8111cc14:	dec04904 	addi	sp,sp,292
8111cc18:	f800283a 	ret
8111cc1c:	d8802d17 	ldw	r2,180(sp)
8111cc20:	d9002d17 	ldw	r4,180(sp)
8111cc24:	10800017 	ldw	r2,0(r2)
8111cc28:	d8803115 	stw	r2,196(sp)
8111cc2c:	20800104 	addi	r2,r4,4
8111cc30:	d9003117 	ldw	r4,196(sp)
8111cc34:	203fb916 	blt	r4,zero,8111cb1c <__reset+0xfb0fcb1c>
8111cc38:	d8802d15 	stw	r2,180(sp)
8111cc3c:	bc400007 	ldb	r17,0(r23)
8111cc40:	003f5406 	br	8111c994 <__reset+0xfb0fc994>
8111cc44:	bc400007 	ldb	r17,0(r23)
8111cc48:	bac00044 	addi	r11,r23,1
8111cc4c:	8a873926 	beq	r17,r10,8111e934 <___svfprintf_internal_r+0x20f8>
8111cc50:	88bff404 	addi	r2,r17,-48
8111cc54:	0009883a 	mov	r4,zero
8111cc58:	30868836 	bltu	r6,r2,8111e67c <___svfprintf_internal_r+0x1e40>
8111cc5c:	5c400007 	ldb	r17,0(r11)
8111cc60:	210002a4 	muli	r4,r4,10
8111cc64:	5dc00044 	addi	r23,r11,1
8111cc68:	b817883a 	mov	r11,r23
8111cc6c:	2089883a 	add	r4,r4,r2
8111cc70:	88bff404 	addi	r2,r17,-48
8111cc74:	30bff92e 	bgeu	r6,r2,8111cc5c <__reset+0xfb0fcc5c>
8111cc78:	2005d716 	blt	r4,zero,8111e3d8 <___svfprintf_internal_r+0x1b9c>
8111cc7c:	d9002915 	stw	r4,164(sp)
8111cc80:	003f4506 	br	8111c998 <__reset+0xfb0fc998>
8111cc84:	b809883a 	mov	r4,r23
8111cc88:	d8003115 	stw	zero,196(sp)
8111cc8c:	88bff404 	addi	r2,r17,-48
8111cc90:	0017883a 	mov	r11,zero
8111cc94:	24400007 	ldb	r17,0(r4)
8111cc98:	5ac002a4 	muli	r11,r11,10
8111cc9c:	bdc00044 	addi	r23,r23,1
8111cca0:	b809883a 	mov	r4,r23
8111cca4:	12d7883a 	add	r11,r2,r11
8111cca8:	88bff404 	addi	r2,r17,-48
8111ccac:	30bff92e 	bgeu	r6,r2,8111cc94 <__reset+0xfb0fcc94>
8111ccb0:	dac03115 	stw	r11,196(sp)
8111ccb4:	003f3806 	br	8111c998 <__reset+0xfb0fc998>
8111ccb8:	94802014 	ori	r18,r18,128
8111ccbc:	bc400007 	ldb	r17,0(r23)
8111ccc0:	003f3406 	br	8111c994 <__reset+0xfb0fc994>
8111ccc4:	18c03fcc 	andi	r3,r3,255
8111ccc8:	1807471e 	bne	r3,zero,8111e9e8 <___svfprintf_internal_r+0x21ac>
8111cccc:	9080020c 	andi	r2,r18,8
8111ccd0:	10047d26 	beq	r2,zero,8111dec8 <___svfprintf_internal_r+0x168c>
8111ccd4:	d8c02d17 	ldw	r3,180(sp)
8111ccd8:	d9002d17 	ldw	r4,180(sp)
8111ccdc:	d9402d17 	ldw	r5,180(sp)
8111cce0:	18c00017 	ldw	r3,0(r3)
8111cce4:	21000117 	ldw	r4,4(r4)
8111cce8:	29400204 	addi	r5,r5,8
8111ccec:	d8c03615 	stw	r3,216(sp)
8111ccf0:	d9003715 	stw	r4,220(sp)
8111ccf4:	d9402d15 	stw	r5,180(sp)
8111ccf8:	d9003617 	ldw	r4,216(sp)
8111ccfc:	d9403717 	ldw	r5,220(sp)
8111cd00:	da003e15 	stw	r8,248(sp)
8111cd04:	04000044 	movi	r16,1
8111cd08:	11272700 	call	81127270 <__fpclassifyd>
8111cd0c:	da003e17 	ldw	r8,248(sp)
8111cd10:	14044b1e 	bne	r2,r16,8111de40 <___svfprintf_internal_r+0x1604>
8111cd14:	d9003617 	ldw	r4,216(sp)
8111cd18:	d9403717 	ldw	r5,220(sp)
8111cd1c:	000d883a 	mov	r6,zero
8111cd20:	000f883a 	mov	r7,zero
8111cd24:	112f5b80 	call	8112f5b8 <__ledf2>
8111cd28:	da003e17 	ldw	r8,248(sp)
8111cd2c:	1005f316 	blt	r2,zero,8111e4fc <___svfprintf_internal_r+0x1cc0>
8111cd30:	df002783 	ldbu	fp,158(sp)
8111cd34:	008011c4 	movi	r2,71
8111cd38:	1445590e 	bge	r2,r17,8111e2a0 <___svfprintf_internal_r+0x1a64>
8111cd3c:	04204574 	movhi	r16,33045
8111cd40:	8426ab04 	addi	r16,r16,-25940
8111cd44:	00c000c4 	movi	r3,3
8111cd48:	00bfdfc4 	movi	r2,-129
8111cd4c:	d8c02a15 	stw	r3,168(sp)
8111cd50:	90a4703a 	and	r18,r18,r2
8111cd54:	d8c02e15 	stw	r3,184(sp)
8111cd58:	d8002915 	stw	zero,164(sp)
8111cd5c:	d8003215 	stw	zero,200(sp)
8111cd60:	00006606 	br	8111cefc <___svfprintf_internal_r+0x6c0>
8111cd64:	94800214 	ori	r18,r18,8
8111cd68:	bc400007 	ldb	r17,0(r23)
8111cd6c:	003f0906 	br	8111c994 <__reset+0xfb0fc994>
8111cd70:	18c03fcc 	andi	r3,r3,255
8111cd74:	1807181e 	bne	r3,zero,8111e9d8 <___svfprintf_internal_r+0x219c>
8111cd78:	94800414 	ori	r18,r18,16
8111cd7c:	9080080c 	andi	r2,r18,32
8111cd80:	10039626 	beq	r2,zero,8111dbdc <___svfprintf_internal_r+0x13a0>
8111cd84:	d9402d17 	ldw	r5,180(sp)
8111cd88:	28800117 	ldw	r2,4(r5)
8111cd8c:	2d000017 	ldw	r20,0(r5)
8111cd90:	29400204 	addi	r5,r5,8
8111cd94:	d9402d15 	stw	r5,180(sp)
8111cd98:	102d883a 	mov	r22,r2
8111cd9c:	10039816 	blt	r2,zero,8111dc00 <___svfprintf_internal_r+0x13c4>
8111cda0:	d9402917 	ldw	r5,164(sp)
8111cda4:	df002783 	ldbu	fp,158(sp)
8111cda8:	2803ab16 	blt	r5,zero,8111dc58 <___svfprintf_internal_r+0x141c>
8111cdac:	00ffdfc4 	movi	r3,-129
8111cdb0:	a584b03a 	or	r2,r20,r22
8111cdb4:	90e4703a 	and	r18,r18,r3
8111cdb8:	10014a26 	beq	r2,zero,8111d2e4 <___svfprintf_internal_r+0xaa8>
8111cdbc:	b0034b26 	beq	r22,zero,8111daec <___svfprintf_internal_r+0x12b0>
8111cdc0:	dc402a15 	stw	r17,168(sp)
8111cdc4:	dc001e04 	addi	r16,sp,120
8111cdc8:	b023883a 	mov	r17,r22
8111cdcc:	402d883a 	mov	r22,r8
8111cdd0:	a009883a 	mov	r4,r20
8111cdd4:	880b883a 	mov	r5,r17
8111cdd8:	01800284 	movi	r6,10
8111cddc:	000f883a 	mov	r7,zero
8111cde0:	112d9c00 	call	8112d9c0 <__umoddi3>
8111cde4:	10800c04 	addi	r2,r2,48
8111cde8:	843fffc4 	addi	r16,r16,-1
8111cdec:	a009883a 	mov	r4,r20
8111cdf0:	880b883a 	mov	r5,r17
8111cdf4:	80800005 	stb	r2,0(r16)
8111cdf8:	01800284 	movi	r6,10
8111cdfc:	000f883a 	mov	r7,zero
8111ce00:	112d4400 	call	8112d440 <__udivdi3>
8111ce04:	1029883a 	mov	r20,r2
8111ce08:	10c4b03a 	or	r2,r2,r3
8111ce0c:	1823883a 	mov	r17,r3
8111ce10:	103fef1e 	bne	r2,zero,8111cdd0 <__reset+0xfb0fcdd0>
8111ce14:	d8c02817 	ldw	r3,160(sp)
8111ce18:	dc402a17 	ldw	r17,168(sp)
8111ce1c:	b011883a 	mov	r8,r22
8111ce20:	1c07c83a 	sub	r3,r3,r16
8111ce24:	d8c02e15 	stw	r3,184(sp)
8111ce28:	00002e06 	br	8111cee4 <___svfprintf_internal_r+0x6a8>
8111ce2c:	18c03fcc 	andi	r3,r3,255
8111ce30:	1806e71e 	bne	r3,zero,8111e9d0 <___svfprintf_internal_r+0x2194>
8111ce34:	94800414 	ori	r18,r18,16
8111ce38:	9080080c 	andi	r2,r18,32
8111ce3c:	1002d426 	beq	r2,zero,8111d990 <___svfprintf_internal_r+0x1154>
8111ce40:	d9402d17 	ldw	r5,180(sp)
8111ce44:	d8c02917 	ldw	r3,164(sp)
8111ce48:	d8002785 	stb	zero,158(sp)
8111ce4c:	28800204 	addi	r2,r5,8
8111ce50:	2d000017 	ldw	r20,0(r5)
8111ce54:	2d800117 	ldw	r22,4(r5)
8111ce58:	18041516 	blt	r3,zero,8111deb0 <___svfprintf_internal_r+0x1674>
8111ce5c:	013fdfc4 	movi	r4,-129
8111ce60:	a586b03a 	or	r3,r20,r22
8111ce64:	d8802d15 	stw	r2,180(sp)
8111ce68:	9124703a 	and	r18,r18,r4
8111ce6c:	1802d51e 	bne	r3,zero,8111d9c4 <___svfprintf_internal_r+0x1188>
8111ce70:	d9402917 	ldw	r5,164(sp)
8111ce74:	0039883a 	mov	fp,zero
8111ce78:	2806be26 	beq	r5,zero,8111e974 <___svfprintf_internal_r+0x2138>
8111ce7c:	0029883a 	mov	r20,zero
8111ce80:	002d883a 	mov	r22,zero
8111ce84:	dc001e04 	addi	r16,sp,120
8111ce88:	a006d0fa 	srli	r3,r20,3
8111ce8c:	b008977a 	slli	r4,r22,29
8111ce90:	b02cd0fa 	srli	r22,r22,3
8111ce94:	a50001cc 	andi	r20,r20,7
8111ce98:	a0800c04 	addi	r2,r20,48
8111ce9c:	843fffc4 	addi	r16,r16,-1
8111cea0:	20e8b03a 	or	r20,r4,r3
8111cea4:	80800005 	stb	r2,0(r16)
8111cea8:	a586b03a 	or	r3,r20,r22
8111ceac:	183ff61e 	bne	r3,zero,8111ce88 <__reset+0xfb0fce88>
8111ceb0:	90c0004c 	andi	r3,r18,1
8111ceb4:	18013926 	beq	r3,zero,8111d39c <___svfprintf_internal_r+0xb60>
8111ceb8:	10803fcc 	andi	r2,r2,255
8111cebc:	1080201c 	xori	r2,r2,128
8111cec0:	10bfe004 	addi	r2,r2,-128
8111cec4:	00c00c04 	movi	r3,48
8111cec8:	10c13426 	beq	r2,r3,8111d39c <___svfprintf_internal_r+0xb60>
8111cecc:	80ffffc5 	stb	r3,-1(r16)
8111ced0:	d8c02817 	ldw	r3,160(sp)
8111ced4:	80bfffc4 	addi	r2,r16,-1
8111ced8:	1021883a 	mov	r16,r2
8111cedc:	1887c83a 	sub	r3,r3,r2
8111cee0:	d8c02e15 	stw	r3,184(sp)
8111cee4:	d8802e17 	ldw	r2,184(sp)
8111cee8:	d9002917 	ldw	r4,164(sp)
8111ceec:	1100010e 	bge	r2,r4,8111cef4 <___svfprintf_internal_r+0x6b8>
8111cef0:	2005883a 	mov	r2,r4
8111cef4:	d8802a15 	stw	r2,168(sp)
8111cef8:	d8003215 	stw	zero,200(sp)
8111cefc:	e7003fcc 	andi	fp,fp,255
8111cf00:	e700201c 	xori	fp,fp,128
8111cf04:	e73fe004 	addi	fp,fp,-128
8111cf08:	e0000326 	beq	fp,zero,8111cf18 <___svfprintf_internal_r+0x6dc>
8111cf0c:	d8c02a17 	ldw	r3,168(sp)
8111cf10:	18c00044 	addi	r3,r3,1
8111cf14:	d8c02a15 	stw	r3,168(sp)
8111cf18:	90c0008c 	andi	r3,r18,2
8111cf1c:	d8c02b15 	stw	r3,172(sp)
8111cf20:	18000326 	beq	r3,zero,8111cf30 <___svfprintf_internal_r+0x6f4>
8111cf24:	d8c02a17 	ldw	r3,168(sp)
8111cf28:	18c00084 	addi	r3,r3,2
8111cf2c:	d8c02a15 	stw	r3,168(sp)
8111cf30:	90c0210c 	andi	r3,r18,132
8111cf34:	d8c03015 	stw	r3,192(sp)
8111cf38:	1801a11e 	bne	r3,zero,8111d5c0 <___svfprintf_internal_r+0xd84>
8111cf3c:	d9003117 	ldw	r4,196(sp)
8111cf40:	d8c02a17 	ldw	r3,168(sp)
8111cf44:	20e9c83a 	sub	r20,r4,r3
8111cf48:	05019d0e 	bge	zero,r20,8111d5c0 <___svfprintf_internal_r+0xd84>
8111cf4c:	02400404 	movi	r9,16
8111cf50:	d8c02017 	ldw	r3,128(sp)
8111cf54:	d8801f17 	ldw	r2,124(sp)
8111cf58:	4d051b0e 	bge	r9,r20,8111e3c8 <___svfprintf_internal_r+0x1b8c>
8111cf5c:	01604574 	movhi	r5,33045
8111cf60:	2966be84 	addi	r5,r5,-25862
8111cf64:	dc403c15 	stw	r17,240(sp)
8111cf68:	d9403515 	stw	r5,212(sp)
8111cf6c:	a023883a 	mov	r17,r20
8111cf70:	482d883a 	mov	r22,r9
8111cf74:	9029883a 	mov	r20,r18
8111cf78:	070001c4 	movi	fp,7
8111cf7c:	8025883a 	mov	r18,r16
8111cf80:	dc002c17 	ldw	r16,176(sp)
8111cf84:	00000306 	br	8111cf94 <___svfprintf_internal_r+0x758>
8111cf88:	8c7ffc04 	addi	r17,r17,-16
8111cf8c:	42000204 	addi	r8,r8,8
8111cf90:	b440130e 	bge	r22,r17,8111cfe0 <___svfprintf_internal_r+0x7a4>
8111cf94:	01204574 	movhi	r4,33045
8111cf98:	18c00404 	addi	r3,r3,16
8111cf9c:	10800044 	addi	r2,r2,1
8111cfa0:	2126be84 	addi	r4,r4,-25862
8111cfa4:	41000015 	stw	r4,0(r8)
8111cfa8:	45800115 	stw	r22,4(r8)
8111cfac:	d8c02015 	stw	r3,128(sp)
8111cfb0:	d8801f15 	stw	r2,124(sp)
8111cfb4:	e0bff40e 	bge	fp,r2,8111cf88 <__reset+0xfb0fcf88>
8111cfb8:	d9801e04 	addi	r6,sp,120
8111cfbc:	800b883a 	mov	r5,r16
8111cfc0:	9809883a 	mov	r4,r19
8111cfc4:	112945c0 	call	8112945c <__ssprint_r>
8111cfc8:	103f031e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111cfcc:	8c7ffc04 	addi	r17,r17,-16
8111cfd0:	d8c02017 	ldw	r3,128(sp)
8111cfd4:	d8801f17 	ldw	r2,124(sp)
8111cfd8:	da000404 	addi	r8,sp,16
8111cfdc:	b47fed16 	blt	r22,r17,8111cf94 <__reset+0xfb0fcf94>
8111cfe0:	9021883a 	mov	r16,r18
8111cfe4:	a025883a 	mov	r18,r20
8111cfe8:	8829883a 	mov	r20,r17
8111cfec:	dc403c17 	ldw	r17,240(sp)
8111cff0:	d9403517 	ldw	r5,212(sp)
8111cff4:	a0c7883a 	add	r3,r20,r3
8111cff8:	10800044 	addi	r2,r2,1
8111cffc:	41400015 	stw	r5,0(r8)
8111d000:	45000115 	stw	r20,4(r8)
8111d004:	d8c02015 	stw	r3,128(sp)
8111d008:	d8801f15 	stw	r2,124(sp)
8111d00c:	010001c4 	movi	r4,7
8111d010:	20829f16 	blt	r4,r2,8111da90 <___svfprintf_internal_r+0x1254>
8111d014:	df002787 	ldb	fp,158(sp)
8111d018:	42000204 	addi	r8,r8,8
8111d01c:	e0000c26 	beq	fp,zero,8111d050 <___svfprintf_internal_r+0x814>
8111d020:	d8801f17 	ldw	r2,124(sp)
8111d024:	d9002784 	addi	r4,sp,158
8111d028:	18c00044 	addi	r3,r3,1
8111d02c:	10800044 	addi	r2,r2,1
8111d030:	41000015 	stw	r4,0(r8)
8111d034:	01000044 	movi	r4,1
8111d038:	41000115 	stw	r4,4(r8)
8111d03c:	d8c02015 	stw	r3,128(sp)
8111d040:	d8801f15 	stw	r2,124(sp)
8111d044:	010001c4 	movi	r4,7
8111d048:	20823816 	blt	r4,r2,8111d92c <___svfprintf_internal_r+0x10f0>
8111d04c:	42000204 	addi	r8,r8,8
8111d050:	d8802b17 	ldw	r2,172(sp)
8111d054:	10000c26 	beq	r2,zero,8111d088 <___svfprintf_internal_r+0x84c>
8111d058:	d8801f17 	ldw	r2,124(sp)
8111d05c:	d9002704 	addi	r4,sp,156
8111d060:	18c00084 	addi	r3,r3,2
8111d064:	10800044 	addi	r2,r2,1
8111d068:	41000015 	stw	r4,0(r8)
8111d06c:	01000084 	movi	r4,2
8111d070:	41000115 	stw	r4,4(r8)
8111d074:	d8c02015 	stw	r3,128(sp)
8111d078:	d8801f15 	stw	r2,124(sp)
8111d07c:	010001c4 	movi	r4,7
8111d080:	20823216 	blt	r4,r2,8111d94c <___svfprintf_internal_r+0x1110>
8111d084:	42000204 	addi	r8,r8,8
8111d088:	d9003017 	ldw	r4,192(sp)
8111d08c:	00802004 	movi	r2,128
8111d090:	20819726 	beq	r4,r2,8111d6f0 <___svfprintf_internal_r+0xeb4>
8111d094:	d9402917 	ldw	r5,164(sp)
8111d098:	d8802e17 	ldw	r2,184(sp)
8111d09c:	28adc83a 	sub	r22,r5,r2
8111d0a0:	05802f0e 	bge	zero,r22,8111d160 <___svfprintf_internal_r+0x924>
8111d0a4:	07000404 	movi	fp,16
8111d0a8:	d8801f17 	ldw	r2,124(sp)
8111d0ac:	e583c00e 	bge	fp,r22,8111dfb0 <___svfprintf_internal_r+0x1774>
8111d0b0:	01604574 	movhi	r5,33045
8111d0b4:	2966ba84 	addi	r5,r5,-25878
8111d0b8:	dc402915 	stw	r17,164(sp)
8111d0bc:	d9402b15 	stw	r5,172(sp)
8111d0c0:	b023883a 	mov	r17,r22
8111d0c4:	050001c4 	movi	r20,7
8111d0c8:	902d883a 	mov	r22,r18
8111d0cc:	8025883a 	mov	r18,r16
8111d0d0:	dc002c17 	ldw	r16,176(sp)
8111d0d4:	00000306 	br	8111d0e4 <___svfprintf_internal_r+0x8a8>
8111d0d8:	8c7ffc04 	addi	r17,r17,-16
8111d0dc:	42000204 	addi	r8,r8,8
8111d0e0:	e440110e 	bge	fp,r17,8111d128 <___svfprintf_internal_r+0x8ec>
8111d0e4:	18c00404 	addi	r3,r3,16
8111d0e8:	10800044 	addi	r2,r2,1
8111d0ec:	45400015 	stw	r21,0(r8)
8111d0f0:	47000115 	stw	fp,4(r8)
8111d0f4:	d8c02015 	stw	r3,128(sp)
8111d0f8:	d8801f15 	stw	r2,124(sp)
8111d0fc:	a0bff60e 	bge	r20,r2,8111d0d8 <__reset+0xfb0fd0d8>
8111d100:	d9801e04 	addi	r6,sp,120
8111d104:	800b883a 	mov	r5,r16
8111d108:	9809883a 	mov	r4,r19
8111d10c:	112945c0 	call	8112945c <__ssprint_r>
8111d110:	103eb11e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d114:	8c7ffc04 	addi	r17,r17,-16
8111d118:	d8c02017 	ldw	r3,128(sp)
8111d11c:	d8801f17 	ldw	r2,124(sp)
8111d120:	da000404 	addi	r8,sp,16
8111d124:	e47fef16 	blt	fp,r17,8111d0e4 <__reset+0xfb0fd0e4>
8111d128:	9021883a 	mov	r16,r18
8111d12c:	b025883a 	mov	r18,r22
8111d130:	882d883a 	mov	r22,r17
8111d134:	dc402917 	ldw	r17,164(sp)
8111d138:	d9002b17 	ldw	r4,172(sp)
8111d13c:	1d87883a 	add	r3,r3,r22
8111d140:	10800044 	addi	r2,r2,1
8111d144:	41000015 	stw	r4,0(r8)
8111d148:	45800115 	stw	r22,4(r8)
8111d14c:	d8c02015 	stw	r3,128(sp)
8111d150:	d8801f15 	stw	r2,124(sp)
8111d154:	010001c4 	movi	r4,7
8111d158:	2081ec16 	blt	r4,r2,8111d90c <___svfprintf_internal_r+0x10d0>
8111d15c:	42000204 	addi	r8,r8,8
8111d160:	9080400c 	andi	r2,r18,256
8111d164:	1001181e 	bne	r2,zero,8111d5c8 <___svfprintf_internal_r+0xd8c>
8111d168:	d9402e17 	ldw	r5,184(sp)
8111d16c:	d8801f17 	ldw	r2,124(sp)
8111d170:	44000015 	stw	r16,0(r8)
8111d174:	1947883a 	add	r3,r3,r5
8111d178:	10800044 	addi	r2,r2,1
8111d17c:	41400115 	stw	r5,4(r8)
8111d180:	d8c02015 	stw	r3,128(sp)
8111d184:	d8801f15 	stw	r2,124(sp)
8111d188:	010001c4 	movi	r4,7
8111d18c:	2081d116 	blt	r4,r2,8111d8d4 <___svfprintf_internal_r+0x1098>
8111d190:	42000204 	addi	r8,r8,8
8111d194:	9480010c 	andi	r18,r18,4
8111d198:	90003226 	beq	r18,zero,8111d264 <___svfprintf_internal_r+0xa28>
8111d19c:	d9403117 	ldw	r5,196(sp)
8111d1a0:	d8802a17 	ldw	r2,168(sp)
8111d1a4:	28a1c83a 	sub	r16,r5,r2
8111d1a8:	04002e0e 	bge	zero,r16,8111d264 <___svfprintf_internal_r+0xa28>
8111d1ac:	04400404 	movi	r17,16
8111d1b0:	d8801f17 	ldw	r2,124(sp)
8111d1b4:	8c04b90e 	bge	r17,r16,8111e49c <___svfprintf_internal_r+0x1c60>
8111d1b8:	01604574 	movhi	r5,33045
8111d1bc:	2966be84 	addi	r5,r5,-25862
8111d1c0:	d9403515 	stw	r5,212(sp)
8111d1c4:	048001c4 	movi	r18,7
8111d1c8:	dd002c17 	ldw	r20,176(sp)
8111d1cc:	00000306 	br	8111d1dc <___svfprintf_internal_r+0x9a0>
8111d1d0:	843ffc04 	addi	r16,r16,-16
8111d1d4:	42000204 	addi	r8,r8,8
8111d1d8:	8c00130e 	bge	r17,r16,8111d228 <___svfprintf_internal_r+0x9ec>
8111d1dc:	01204574 	movhi	r4,33045
8111d1e0:	18c00404 	addi	r3,r3,16
8111d1e4:	10800044 	addi	r2,r2,1
8111d1e8:	2126be84 	addi	r4,r4,-25862
8111d1ec:	41000015 	stw	r4,0(r8)
8111d1f0:	44400115 	stw	r17,4(r8)
8111d1f4:	d8c02015 	stw	r3,128(sp)
8111d1f8:	d8801f15 	stw	r2,124(sp)
8111d1fc:	90bff40e 	bge	r18,r2,8111d1d0 <__reset+0xfb0fd1d0>
8111d200:	d9801e04 	addi	r6,sp,120
8111d204:	a00b883a 	mov	r5,r20
8111d208:	9809883a 	mov	r4,r19
8111d20c:	112945c0 	call	8112945c <__ssprint_r>
8111d210:	103e711e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d214:	843ffc04 	addi	r16,r16,-16
8111d218:	d8c02017 	ldw	r3,128(sp)
8111d21c:	d8801f17 	ldw	r2,124(sp)
8111d220:	da000404 	addi	r8,sp,16
8111d224:	8c3fed16 	blt	r17,r16,8111d1dc <__reset+0xfb0fd1dc>
8111d228:	d9403517 	ldw	r5,212(sp)
8111d22c:	1c07883a 	add	r3,r3,r16
8111d230:	10800044 	addi	r2,r2,1
8111d234:	41400015 	stw	r5,0(r8)
8111d238:	44000115 	stw	r16,4(r8)
8111d23c:	d8c02015 	stw	r3,128(sp)
8111d240:	d8801f15 	stw	r2,124(sp)
8111d244:	010001c4 	movi	r4,7
8111d248:	2080060e 	bge	r4,r2,8111d264 <___svfprintf_internal_r+0xa28>
8111d24c:	d9402c17 	ldw	r5,176(sp)
8111d250:	d9801e04 	addi	r6,sp,120
8111d254:	9809883a 	mov	r4,r19
8111d258:	112945c0 	call	8112945c <__ssprint_r>
8111d25c:	103e5e1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d260:	d8c02017 	ldw	r3,128(sp)
8111d264:	d8803117 	ldw	r2,196(sp)
8111d268:	d9002a17 	ldw	r4,168(sp)
8111d26c:	1100010e 	bge	r2,r4,8111d274 <___svfprintf_internal_r+0xa38>
8111d270:	2005883a 	mov	r2,r4
8111d274:	d9402f17 	ldw	r5,188(sp)
8111d278:	288b883a 	add	r5,r5,r2
8111d27c:	d9402f15 	stw	r5,188(sp)
8111d280:	18019c1e 	bne	r3,zero,8111d8f4 <___svfprintf_internal_r+0x10b8>
8111d284:	b8800007 	ldb	r2,0(r23)
8111d288:	d8001f15 	stw	zero,124(sp)
8111d28c:	da000404 	addi	r8,sp,16
8111d290:	103d991e 	bne	r2,zero,8111c8f8 <__reset+0xfb0fc8f8>
8111d294:	b821883a 	mov	r16,r23
8111d298:	003daf06 	br	8111c958 <__reset+0xfb0fc958>
8111d29c:	18c03fcc 	andi	r3,r3,255
8111d2a0:	1805c71e 	bne	r3,zero,8111e9c0 <___svfprintf_internal_r+0x2184>
8111d2a4:	94800414 	ori	r18,r18,16
8111d2a8:	9080080c 	andi	r2,r18,32
8111d2ac:	10020126 	beq	r2,zero,8111dab4 <___svfprintf_internal_r+0x1278>
8111d2b0:	d8802d17 	ldw	r2,180(sp)
8111d2b4:	d9002917 	ldw	r4,164(sp)
8111d2b8:	d8002785 	stb	zero,158(sp)
8111d2bc:	10c00204 	addi	r3,r2,8
8111d2c0:	15000017 	ldw	r20,0(r2)
8111d2c4:	15800117 	ldw	r22,4(r2)
8111d2c8:	20038e16 	blt	r4,zero,8111e104 <___svfprintf_internal_r+0x18c8>
8111d2cc:	013fdfc4 	movi	r4,-129
8111d2d0:	a584b03a 	or	r2,r20,r22
8111d2d4:	d8c02d15 	stw	r3,180(sp)
8111d2d8:	9124703a 	and	r18,r18,r4
8111d2dc:	0039883a 	mov	fp,zero
8111d2e0:	103eb61e 	bne	r2,zero,8111cdbc <__reset+0xfb0fcdbc>
8111d2e4:	d8802917 	ldw	r2,164(sp)
8111d2e8:	1002c81e 	bne	r2,zero,8111de0c <___svfprintf_internal_r+0x15d0>
8111d2ec:	d8002915 	stw	zero,164(sp)
8111d2f0:	d8002e15 	stw	zero,184(sp)
8111d2f4:	dc001e04 	addi	r16,sp,120
8111d2f8:	003efa06 	br	8111cee4 <__reset+0xfb0fcee4>
8111d2fc:	18c03fcc 	andi	r3,r3,255
8111d300:	1805ad1e 	bne	r3,zero,8111e9b8 <___svfprintf_internal_r+0x217c>
8111d304:	01604574 	movhi	r5,33045
8111d308:	2966ae04 	addi	r5,r5,-25928
8111d30c:	d9403a15 	stw	r5,232(sp)
8111d310:	9080080c 	andi	r2,r18,32
8111d314:	10006126 	beq	r2,zero,8111d49c <___svfprintf_internal_r+0xc60>
8111d318:	d8802d17 	ldw	r2,180(sp)
8111d31c:	15000017 	ldw	r20,0(r2)
8111d320:	15800117 	ldw	r22,4(r2)
8111d324:	10800204 	addi	r2,r2,8
8111d328:	d8802d15 	stw	r2,180(sp)
8111d32c:	9080004c 	andi	r2,r18,1
8111d330:	10018e26 	beq	r2,zero,8111d96c <___svfprintf_internal_r+0x1130>
8111d334:	a584b03a 	or	r2,r20,r22
8111d338:	10030926 	beq	r2,zero,8111df60 <___svfprintf_internal_r+0x1724>
8111d33c:	d8c02917 	ldw	r3,164(sp)
8111d340:	00800c04 	movi	r2,48
8111d344:	d8802705 	stb	r2,156(sp)
8111d348:	dc402745 	stb	r17,157(sp)
8111d34c:	d8002785 	stb	zero,158(sp)
8111d350:	90800094 	ori	r2,r18,2
8111d354:	18048716 	blt	r3,zero,8111e574 <___svfprintf_internal_r+0x1d38>
8111d358:	00bfdfc4 	movi	r2,-129
8111d35c:	90a4703a 	and	r18,r18,r2
8111d360:	94800094 	ori	r18,r18,2
8111d364:	0039883a 	mov	fp,zero
8111d368:	d9003a17 	ldw	r4,232(sp)
8111d36c:	dc001e04 	addi	r16,sp,120
8111d370:	a08003cc 	andi	r2,r20,15
8111d374:	b006973a 	slli	r3,r22,28
8111d378:	2085883a 	add	r2,r4,r2
8111d37c:	a028d13a 	srli	r20,r20,4
8111d380:	10800003 	ldbu	r2,0(r2)
8111d384:	b02cd13a 	srli	r22,r22,4
8111d388:	843fffc4 	addi	r16,r16,-1
8111d38c:	1d28b03a 	or	r20,r3,r20
8111d390:	80800005 	stb	r2,0(r16)
8111d394:	a584b03a 	or	r2,r20,r22
8111d398:	103ff51e 	bne	r2,zero,8111d370 <__reset+0xfb0fd370>
8111d39c:	d8c02817 	ldw	r3,160(sp)
8111d3a0:	1c07c83a 	sub	r3,r3,r16
8111d3a4:	d8c02e15 	stw	r3,184(sp)
8111d3a8:	003ece06 	br	8111cee4 <__reset+0xfb0fcee4>
8111d3ac:	d8c02d17 	ldw	r3,180(sp)
8111d3b0:	d9002d17 	ldw	r4,180(sp)
8111d3b4:	d8002785 	stb	zero,158(sp)
8111d3b8:	18800017 	ldw	r2,0(r3)
8111d3bc:	21000104 	addi	r4,r4,4
8111d3c0:	00c00044 	movi	r3,1
8111d3c4:	d8c02a15 	stw	r3,168(sp)
8111d3c8:	d8801405 	stb	r2,80(sp)
8111d3cc:	d9002d15 	stw	r4,180(sp)
8111d3d0:	d8c02e15 	stw	r3,184(sp)
8111d3d4:	d8002915 	stw	zero,164(sp)
8111d3d8:	d8003215 	stw	zero,200(sp)
8111d3dc:	dc001404 	addi	r16,sp,80
8111d3e0:	0039883a 	mov	fp,zero
8111d3e4:	003ecc06 	br	8111cf18 <__reset+0xfb0fcf18>
8111d3e8:	18c03fcc 	andi	r3,r3,255
8111d3ec:	183e9226 	beq	r3,zero,8111ce38 <__reset+0xfb0fce38>
8111d3f0:	d9c02785 	stb	r7,158(sp)
8111d3f4:	003e9006 	br	8111ce38 <__reset+0xfb0fce38>
8111d3f8:	00c00044 	movi	r3,1
8111d3fc:	01c00ac4 	movi	r7,43
8111d400:	bc400007 	ldb	r17,0(r23)
8111d404:	003d6306 	br	8111c994 <__reset+0xfb0fc994>
8111d408:	94800814 	ori	r18,r18,32
8111d40c:	bc400007 	ldb	r17,0(r23)
8111d410:	003d6006 	br	8111c994 <__reset+0xfb0fc994>
8111d414:	d8c02d17 	ldw	r3,180(sp)
8111d418:	d8002785 	stb	zero,158(sp)
8111d41c:	1c000017 	ldw	r16,0(r3)
8111d420:	1d000104 	addi	r20,r3,4
8111d424:	80040f26 	beq	r16,zero,8111e464 <___svfprintf_internal_r+0x1c28>
8111d428:	d9002917 	ldw	r4,164(sp)
8111d42c:	2003dc16 	blt	r4,zero,8111e3a0 <___svfprintf_internal_r+0x1b64>
8111d430:	200d883a 	mov	r6,r4
8111d434:	000b883a 	mov	r5,zero
8111d438:	8009883a 	mov	r4,r16
8111d43c:	da003e15 	stw	r8,248(sp)
8111d440:	1125a000 	call	81125a00 <memchr>
8111d444:	da003e17 	ldw	r8,248(sp)
8111d448:	10045826 	beq	r2,zero,8111e5ac <___svfprintf_internal_r+0x1d70>
8111d44c:	1405c83a 	sub	r2,r2,r16
8111d450:	d8802e15 	stw	r2,184(sp)
8111d454:	1003d816 	blt	r2,zero,8111e3b8 <___svfprintf_internal_r+0x1b7c>
8111d458:	df002783 	ldbu	fp,158(sp)
8111d45c:	d8802a15 	stw	r2,168(sp)
8111d460:	dd002d15 	stw	r20,180(sp)
8111d464:	d8002915 	stw	zero,164(sp)
8111d468:	d8003215 	stw	zero,200(sp)
8111d46c:	003ea306 	br	8111cefc <__reset+0xfb0fcefc>
8111d470:	18c03fcc 	andi	r3,r3,255
8111d474:	183f8c26 	beq	r3,zero,8111d2a8 <__reset+0xfb0fd2a8>
8111d478:	d9c02785 	stb	r7,158(sp)
8111d47c:	003f8a06 	br	8111d2a8 <__reset+0xfb0fd2a8>
8111d480:	18c03fcc 	andi	r3,r3,255
8111d484:	1805631e 	bne	r3,zero,8111ea14 <___svfprintf_internal_r+0x21d8>
8111d488:	01604574 	movhi	r5,33045
8111d48c:	2966b304 	addi	r5,r5,-25908
8111d490:	d9403a15 	stw	r5,232(sp)
8111d494:	9080080c 	andi	r2,r18,32
8111d498:	103f9f1e 	bne	r2,zero,8111d318 <__reset+0xfb0fd318>
8111d49c:	9080040c 	andi	r2,r18,16
8111d4a0:	10029c26 	beq	r2,zero,8111df14 <___svfprintf_internal_r+0x16d8>
8111d4a4:	d8c02d17 	ldw	r3,180(sp)
8111d4a8:	002d883a 	mov	r22,zero
8111d4ac:	1d000017 	ldw	r20,0(r3)
8111d4b0:	18c00104 	addi	r3,r3,4
8111d4b4:	d8c02d15 	stw	r3,180(sp)
8111d4b8:	003f9c06 	br	8111d32c <__reset+0xfb0fd32c>
8111d4bc:	94800054 	ori	r18,r18,1
8111d4c0:	bc400007 	ldb	r17,0(r23)
8111d4c4:	003d3306 	br	8111c994 <__reset+0xfb0fc994>
8111d4c8:	38803fcc 	andi	r2,r7,255
8111d4cc:	1080201c 	xori	r2,r2,128
8111d4d0:	10bfe004 	addi	r2,r2,-128
8111d4d4:	1002971e 	bne	r2,zero,8111df34 <___svfprintf_internal_r+0x16f8>
8111d4d8:	00c00044 	movi	r3,1
8111d4dc:	01c00804 	movi	r7,32
8111d4e0:	bc400007 	ldb	r17,0(r23)
8111d4e4:	003d2b06 	br	8111c994 <__reset+0xfb0fc994>
8111d4e8:	18c03fcc 	andi	r3,r3,255
8111d4ec:	183e2326 	beq	r3,zero,8111cd7c <__reset+0xfb0fcd7c>
8111d4f0:	d9c02785 	stb	r7,158(sp)
8111d4f4:	003e2106 	br	8111cd7c <__reset+0xfb0fcd7c>
8111d4f8:	bc400007 	ldb	r17,0(r23)
8111d4fc:	8a430426 	beq	r17,r9,8111e110 <___svfprintf_internal_r+0x18d4>
8111d500:	94800414 	ori	r18,r18,16
8111d504:	003d2306 	br	8111c994 <__reset+0xfb0fc994>
8111d508:	18c03fcc 	andi	r3,r3,255
8111d50c:	18053f1e 	bne	r3,zero,8111ea0c <___svfprintf_internal_r+0x21d0>
8111d510:	9080080c 	andi	r2,r18,32
8111d514:	10028926 	beq	r2,zero,8111df3c <___svfprintf_internal_r+0x1700>
8111d518:	d9402d17 	ldw	r5,180(sp)
8111d51c:	d9002f17 	ldw	r4,188(sp)
8111d520:	28800017 	ldw	r2,0(r5)
8111d524:	2007d7fa 	srai	r3,r4,31
8111d528:	29400104 	addi	r5,r5,4
8111d52c:	d9402d15 	stw	r5,180(sp)
8111d530:	11000015 	stw	r4,0(r2)
8111d534:	10c00115 	stw	r3,4(r2)
8111d538:	003ced06 	br	8111c8f0 <__reset+0xfb0fc8f0>
8111d53c:	94801014 	ori	r18,r18,64
8111d540:	bc400007 	ldb	r17,0(r23)
8111d544:	003d1306 	br	8111c994 <__reset+0xfb0fc994>
8111d548:	01204574 	movhi	r4,33045
8111d54c:	2126b304 	addi	r4,r4,-25908
8111d550:	0039883a 	mov	fp,zero
8111d554:	d9003a15 	stw	r4,232(sp)
8111d558:	04401e04 	movi	r17,120
8111d55c:	003f8206 	br	8111d368 <__reset+0xfb0fd368>
8111d560:	18c03fcc 	andi	r3,r3,255
8111d564:	1805221e 	bne	r3,zero,8111e9f0 <___svfprintf_internal_r+0x21b4>
8111d568:	883d9526 	beq	r17,zero,8111cbc0 <__reset+0xfb0fcbc0>
8111d56c:	00c00044 	movi	r3,1
8111d570:	d8c02a15 	stw	r3,168(sp)
8111d574:	dc401405 	stb	r17,80(sp)
8111d578:	d8002785 	stb	zero,158(sp)
8111d57c:	003f9406 	br	8111d3d0 <__reset+0xfb0fd3d0>
8111d580:	01204574 	movhi	r4,33045
8111d584:	2126b304 	addi	r4,r4,-25908
8111d588:	d9003a15 	stw	r4,232(sp)
8111d58c:	d8c02d15 	stw	r3,180(sp)
8111d590:	1025883a 	mov	r18,r2
8111d594:	04401e04 	movi	r17,120
8111d598:	a584b03a 	or	r2,r20,r22
8111d59c:	1000fa1e 	bne	r2,zero,8111d988 <___svfprintf_internal_r+0x114c>
8111d5a0:	0039883a 	mov	fp,zero
8111d5a4:	00800084 	movi	r2,2
8111d5a8:	10803fcc 	andi	r2,r2,255
8111d5ac:	00c00044 	movi	r3,1
8111d5b0:	10c21626 	beq	r2,r3,8111de0c <___svfprintf_internal_r+0x15d0>
8111d5b4:	00c00084 	movi	r3,2
8111d5b8:	10fe301e 	bne	r2,r3,8111ce7c <__reset+0xfb0fce7c>
8111d5bc:	003d7606 	br	8111cb98 <__reset+0xfb0fcb98>
8111d5c0:	d8c02017 	ldw	r3,128(sp)
8111d5c4:	003e9506 	br	8111d01c <__reset+0xfb0fd01c>
8111d5c8:	00801944 	movi	r2,101
8111d5cc:	14407c0e 	bge	r2,r17,8111d7c0 <___svfprintf_internal_r+0xf84>
8111d5d0:	d9003617 	ldw	r4,216(sp)
8111d5d4:	d9403717 	ldw	r5,220(sp)
8111d5d8:	000d883a 	mov	r6,zero
8111d5dc:	000f883a 	mov	r7,zero
8111d5e0:	d8c03d15 	stw	r3,244(sp)
8111d5e4:	da003e15 	stw	r8,248(sp)
8111d5e8:	112f4540 	call	8112f454 <__eqdf2>
8111d5ec:	d8c03d17 	ldw	r3,244(sp)
8111d5f0:	da003e17 	ldw	r8,248(sp)
8111d5f4:	1000f51e 	bne	r2,zero,8111d9cc <___svfprintf_internal_r+0x1190>
8111d5f8:	d8801f17 	ldw	r2,124(sp)
8111d5fc:	01204574 	movhi	r4,33045
8111d600:	2126ba04 	addi	r4,r4,-25880
8111d604:	18c00044 	addi	r3,r3,1
8111d608:	10800044 	addi	r2,r2,1
8111d60c:	41000015 	stw	r4,0(r8)
8111d610:	01000044 	movi	r4,1
8111d614:	41000115 	stw	r4,4(r8)
8111d618:	d8c02015 	stw	r3,128(sp)
8111d61c:	d8801f15 	stw	r2,124(sp)
8111d620:	010001c4 	movi	r4,7
8111d624:	20826616 	blt	r4,r2,8111dfc0 <___svfprintf_internal_r+0x1784>
8111d628:	42000204 	addi	r8,r8,8
8111d62c:	d8802617 	ldw	r2,152(sp)
8111d630:	d9403317 	ldw	r5,204(sp)
8111d634:	11400216 	blt	r2,r5,8111d640 <___svfprintf_internal_r+0xe04>
8111d638:	9080004c 	andi	r2,r18,1
8111d63c:	103ed526 	beq	r2,zero,8111d194 <__reset+0xfb0fd194>
8111d640:	d8803817 	ldw	r2,224(sp)
8111d644:	d9003417 	ldw	r4,208(sp)
8111d648:	d9403817 	ldw	r5,224(sp)
8111d64c:	1887883a 	add	r3,r3,r2
8111d650:	d8801f17 	ldw	r2,124(sp)
8111d654:	41000015 	stw	r4,0(r8)
8111d658:	41400115 	stw	r5,4(r8)
8111d65c:	10800044 	addi	r2,r2,1
8111d660:	d8c02015 	stw	r3,128(sp)
8111d664:	d8801f15 	stw	r2,124(sp)
8111d668:	010001c4 	movi	r4,7
8111d66c:	2082af16 	blt	r4,r2,8111e12c <___svfprintf_internal_r+0x18f0>
8111d670:	42000204 	addi	r8,r8,8
8111d674:	d8803317 	ldw	r2,204(sp)
8111d678:	143fffc4 	addi	r16,r2,-1
8111d67c:	043ec50e 	bge	zero,r16,8111d194 <__reset+0xfb0fd194>
8111d680:	04400404 	movi	r17,16
8111d684:	d8801f17 	ldw	r2,124(sp)
8111d688:	8c00860e 	bge	r17,r16,8111d8a4 <___svfprintf_internal_r+0x1068>
8111d68c:	01604574 	movhi	r5,33045
8111d690:	2966ba84 	addi	r5,r5,-25878
8111d694:	d9402b15 	stw	r5,172(sp)
8111d698:	058001c4 	movi	r22,7
8111d69c:	dd002c17 	ldw	r20,176(sp)
8111d6a0:	00000306 	br	8111d6b0 <___svfprintf_internal_r+0xe74>
8111d6a4:	42000204 	addi	r8,r8,8
8111d6a8:	843ffc04 	addi	r16,r16,-16
8111d6ac:	8c00800e 	bge	r17,r16,8111d8b0 <___svfprintf_internal_r+0x1074>
8111d6b0:	18c00404 	addi	r3,r3,16
8111d6b4:	10800044 	addi	r2,r2,1
8111d6b8:	45400015 	stw	r21,0(r8)
8111d6bc:	44400115 	stw	r17,4(r8)
8111d6c0:	d8c02015 	stw	r3,128(sp)
8111d6c4:	d8801f15 	stw	r2,124(sp)
8111d6c8:	b0bff60e 	bge	r22,r2,8111d6a4 <__reset+0xfb0fd6a4>
8111d6cc:	d9801e04 	addi	r6,sp,120
8111d6d0:	a00b883a 	mov	r5,r20
8111d6d4:	9809883a 	mov	r4,r19
8111d6d8:	112945c0 	call	8112945c <__ssprint_r>
8111d6dc:	103d3e1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d6e0:	d8c02017 	ldw	r3,128(sp)
8111d6e4:	d8801f17 	ldw	r2,124(sp)
8111d6e8:	da000404 	addi	r8,sp,16
8111d6ec:	003fee06 	br	8111d6a8 <__reset+0xfb0fd6a8>
8111d6f0:	d9403117 	ldw	r5,196(sp)
8111d6f4:	d8802a17 	ldw	r2,168(sp)
8111d6f8:	28adc83a 	sub	r22,r5,r2
8111d6fc:	05be650e 	bge	zero,r22,8111d094 <__reset+0xfb0fd094>
8111d700:	07000404 	movi	fp,16
8111d704:	d8801f17 	ldw	r2,124(sp)
8111d708:	e583a20e 	bge	fp,r22,8111e594 <___svfprintf_internal_r+0x1d58>
8111d70c:	01604574 	movhi	r5,33045
8111d710:	2966ba84 	addi	r5,r5,-25878
8111d714:	dc403015 	stw	r17,192(sp)
8111d718:	d9402b15 	stw	r5,172(sp)
8111d71c:	b023883a 	mov	r17,r22
8111d720:	050001c4 	movi	r20,7
8111d724:	902d883a 	mov	r22,r18
8111d728:	8025883a 	mov	r18,r16
8111d72c:	dc002c17 	ldw	r16,176(sp)
8111d730:	00000306 	br	8111d740 <___svfprintf_internal_r+0xf04>
8111d734:	8c7ffc04 	addi	r17,r17,-16
8111d738:	42000204 	addi	r8,r8,8
8111d73c:	e440110e 	bge	fp,r17,8111d784 <___svfprintf_internal_r+0xf48>
8111d740:	18c00404 	addi	r3,r3,16
8111d744:	10800044 	addi	r2,r2,1
8111d748:	45400015 	stw	r21,0(r8)
8111d74c:	47000115 	stw	fp,4(r8)
8111d750:	d8c02015 	stw	r3,128(sp)
8111d754:	d8801f15 	stw	r2,124(sp)
8111d758:	a0bff60e 	bge	r20,r2,8111d734 <__reset+0xfb0fd734>
8111d75c:	d9801e04 	addi	r6,sp,120
8111d760:	800b883a 	mov	r5,r16
8111d764:	9809883a 	mov	r4,r19
8111d768:	112945c0 	call	8112945c <__ssprint_r>
8111d76c:	103d1a1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d770:	8c7ffc04 	addi	r17,r17,-16
8111d774:	d8c02017 	ldw	r3,128(sp)
8111d778:	d8801f17 	ldw	r2,124(sp)
8111d77c:	da000404 	addi	r8,sp,16
8111d780:	e47fef16 	blt	fp,r17,8111d740 <__reset+0xfb0fd740>
8111d784:	9021883a 	mov	r16,r18
8111d788:	b025883a 	mov	r18,r22
8111d78c:	882d883a 	mov	r22,r17
8111d790:	dc403017 	ldw	r17,192(sp)
8111d794:	d9002b17 	ldw	r4,172(sp)
8111d798:	1d87883a 	add	r3,r3,r22
8111d79c:	10800044 	addi	r2,r2,1
8111d7a0:	41000015 	stw	r4,0(r8)
8111d7a4:	45800115 	stw	r22,4(r8)
8111d7a8:	d8c02015 	stw	r3,128(sp)
8111d7ac:	d8801f15 	stw	r2,124(sp)
8111d7b0:	010001c4 	movi	r4,7
8111d7b4:	20819a16 	blt	r4,r2,8111de20 <___svfprintf_internal_r+0x15e4>
8111d7b8:	42000204 	addi	r8,r8,8
8111d7bc:	003e3506 	br	8111d094 <__reset+0xfb0fd094>
8111d7c0:	d9403317 	ldw	r5,204(sp)
8111d7c4:	00800044 	movi	r2,1
8111d7c8:	18c00044 	addi	r3,r3,1
8111d7cc:	1141710e 	bge	r2,r5,8111dd94 <___svfprintf_internal_r+0x1558>
8111d7d0:	dc401f17 	ldw	r17,124(sp)
8111d7d4:	00800044 	movi	r2,1
8111d7d8:	40800115 	stw	r2,4(r8)
8111d7dc:	8c400044 	addi	r17,r17,1
8111d7e0:	44000015 	stw	r16,0(r8)
8111d7e4:	d8c02015 	stw	r3,128(sp)
8111d7e8:	dc401f15 	stw	r17,124(sp)
8111d7ec:	008001c4 	movi	r2,7
8111d7f0:	14417416 	blt	r2,r17,8111ddc4 <___svfprintf_internal_r+0x1588>
8111d7f4:	42000204 	addi	r8,r8,8
8111d7f8:	d8803817 	ldw	r2,224(sp)
8111d7fc:	d9003417 	ldw	r4,208(sp)
8111d800:	8c400044 	addi	r17,r17,1
8111d804:	10c7883a 	add	r3,r2,r3
8111d808:	40800115 	stw	r2,4(r8)
8111d80c:	41000015 	stw	r4,0(r8)
8111d810:	d8c02015 	stw	r3,128(sp)
8111d814:	dc401f15 	stw	r17,124(sp)
8111d818:	008001c4 	movi	r2,7
8111d81c:	14417216 	blt	r2,r17,8111dde8 <___svfprintf_internal_r+0x15ac>
8111d820:	45800204 	addi	r22,r8,8
8111d824:	d9003617 	ldw	r4,216(sp)
8111d828:	d9403717 	ldw	r5,220(sp)
8111d82c:	000d883a 	mov	r6,zero
8111d830:	000f883a 	mov	r7,zero
8111d834:	d8c03d15 	stw	r3,244(sp)
8111d838:	112f4540 	call	8112f454 <__eqdf2>
8111d83c:	d8c03d17 	ldw	r3,244(sp)
8111d840:	1000b326 	beq	r2,zero,8111db10 <___svfprintf_internal_r+0x12d4>
8111d844:	d9403317 	ldw	r5,204(sp)
8111d848:	84000044 	addi	r16,r16,1
8111d84c:	8c400044 	addi	r17,r17,1
8111d850:	28bfffc4 	addi	r2,r5,-1
8111d854:	1887883a 	add	r3,r3,r2
8111d858:	b0800115 	stw	r2,4(r22)
8111d85c:	b4000015 	stw	r16,0(r22)
8111d860:	d8c02015 	stw	r3,128(sp)
8111d864:	dc401f15 	stw	r17,124(sp)
8111d868:	008001c4 	movi	r2,7
8111d86c:	1440d216 	blt	r2,r17,8111dbb8 <___svfprintf_internal_r+0x137c>
8111d870:	b5800204 	addi	r22,r22,8
8111d874:	d9003b17 	ldw	r4,236(sp)
8111d878:	df0022c4 	addi	fp,sp,139
8111d87c:	8c400044 	addi	r17,r17,1
8111d880:	20c7883a 	add	r3,r4,r3
8111d884:	b7000015 	stw	fp,0(r22)
8111d888:	b1000115 	stw	r4,4(r22)
8111d88c:	d8c02015 	stw	r3,128(sp)
8111d890:	dc401f15 	stw	r17,124(sp)
8111d894:	008001c4 	movi	r2,7
8111d898:	14400e16 	blt	r2,r17,8111d8d4 <___svfprintf_internal_r+0x1098>
8111d89c:	b2000204 	addi	r8,r22,8
8111d8a0:	003e3c06 	br	8111d194 <__reset+0xfb0fd194>
8111d8a4:	01204574 	movhi	r4,33045
8111d8a8:	2126ba84 	addi	r4,r4,-25878
8111d8ac:	d9002b15 	stw	r4,172(sp)
8111d8b0:	d9002b17 	ldw	r4,172(sp)
8111d8b4:	1c07883a 	add	r3,r3,r16
8111d8b8:	44000115 	stw	r16,4(r8)
8111d8bc:	41000015 	stw	r4,0(r8)
8111d8c0:	10800044 	addi	r2,r2,1
8111d8c4:	d8c02015 	stw	r3,128(sp)
8111d8c8:	d8801f15 	stw	r2,124(sp)
8111d8cc:	010001c4 	movi	r4,7
8111d8d0:	20be2f0e 	bge	r4,r2,8111d190 <__reset+0xfb0fd190>
8111d8d4:	d9402c17 	ldw	r5,176(sp)
8111d8d8:	d9801e04 	addi	r6,sp,120
8111d8dc:	9809883a 	mov	r4,r19
8111d8e0:	112945c0 	call	8112945c <__ssprint_r>
8111d8e4:	103cbc1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d8e8:	d8c02017 	ldw	r3,128(sp)
8111d8ec:	da000404 	addi	r8,sp,16
8111d8f0:	003e2806 	br	8111d194 <__reset+0xfb0fd194>
8111d8f4:	d9402c17 	ldw	r5,176(sp)
8111d8f8:	d9801e04 	addi	r6,sp,120
8111d8fc:	9809883a 	mov	r4,r19
8111d900:	112945c0 	call	8112945c <__ssprint_r>
8111d904:	103e5f26 	beq	r2,zero,8111d284 <__reset+0xfb0fd284>
8111d908:	003cb306 	br	8111cbd8 <__reset+0xfb0fcbd8>
8111d90c:	d9402c17 	ldw	r5,176(sp)
8111d910:	d9801e04 	addi	r6,sp,120
8111d914:	9809883a 	mov	r4,r19
8111d918:	112945c0 	call	8112945c <__ssprint_r>
8111d91c:	103cae1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d920:	d8c02017 	ldw	r3,128(sp)
8111d924:	da000404 	addi	r8,sp,16
8111d928:	003e0d06 	br	8111d160 <__reset+0xfb0fd160>
8111d92c:	d9402c17 	ldw	r5,176(sp)
8111d930:	d9801e04 	addi	r6,sp,120
8111d934:	9809883a 	mov	r4,r19
8111d938:	112945c0 	call	8112945c <__ssprint_r>
8111d93c:	103ca61e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d940:	d8c02017 	ldw	r3,128(sp)
8111d944:	da000404 	addi	r8,sp,16
8111d948:	003dc106 	br	8111d050 <__reset+0xfb0fd050>
8111d94c:	d9402c17 	ldw	r5,176(sp)
8111d950:	d9801e04 	addi	r6,sp,120
8111d954:	9809883a 	mov	r4,r19
8111d958:	112945c0 	call	8112945c <__ssprint_r>
8111d95c:	103c9e1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111d960:	d8c02017 	ldw	r3,128(sp)
8111d964:	da000404 	addi	r8,sp,16
8111d968:	003dc706 	br	8111d088 <__reset+0xfb0fd088>
8111d96c:	d8802917 	ldw	r2,164(sp)
8111d970:	d8002785 	stb	zero,158(sp)
8111d974:	103f0816 	blt	r2,zero,8111d598 <__reset+0xfb0fd598>
8111d978:	00ffdfc4 	movi	r3,-129
8111d97c:	a584b03a 	or	r2,r20,r22
8111d980:	90e4703a 	and	r18,r18,r3
8111d984:	103c8126 	beq	r2,zero,8111cb8c <__reset+0xfb0fcb8c>
8111d988:	0039883a 	mov	fp,zero
8111d98c:	003e7606 	br	8111d368 <__reset+0xfb0fd368>
8111d990:	9080040c 	andi	r2,r18,16
8111d994:	10013d26 	beq	r2,zero,8111de8c <___svfprintf_internal_r+0x1650>
8111d998:	d9002d17 	ldw	r4,180(sp)
8111d99c:	d9402917 	ldw	r5,164(sp)
8111d9a0:	d8002785 	stb	zero,158(sp)
8111d9a4:	20800104 	addi	r2,r4,4
8111d9a8:	25000017 	ldw	r20,0(r4)
8111d9ac:	002d883a 	mov	r22,zero
8111d9b0:	28013f16 	blt	r5,zero,8111deb0 <___svfprintf_internal_r+0x1674>
8111d9b4:	00ffdfc4 	movi	r3,-129
8111d9b8:	d8802d15 	stw	r2,180(sp)
8111d9bc:	90e4703a 	and	r18,r18,r3
8111d9c0:	a03d2b26 	beq	r20,zero,8111ce70 <__reset+0xfb0fce70>
8111d9c4:	0039883a 	mov	fp,zero
8111d9c8:	003d2e06 	br	8111ce84 <__reset+0xfb0fce84>
8111d9cc:	dc402617 	ldw	r17,152(sp)
8111d9d0:	0441830e 	bge	zero,r17,8111dfe0 <___svfprintf_internal_r+0x17a4>
8111d9d4:	dc403217 	ldw	r17,200(sp)
8111d9d8:	d8803317 	ldw	r2,204(sp)
8111d9dc:	1440010e 	bge	r2,r17,8111d9e4 <___svfprintf_internal_r+0x11a8>
8111d9e0:	1023883a 	mov	r17,r2
8111d9e4:	04400a0e 	bge	zero,r17,8111da10 <___svfprintf_internal_r+0x11d4>
8111d9e8:	d8801f17 	ldw	r2,124(sp)
8111d9ec:	1c47883a 	add	r3,r3,r17
8111d9f0:	44000015 	stw	r16,0(r8)
8111d9f4:	10800044 	addi	r2,r2,1
8111d9f8:	44400115 	stw	r17,4(r8)
8111d9fc:	d8c02015 	stw	r3,128(sp)
8111da00:	d8801f15 	stw	r2,124(sp)
8111da04:	010001c4 	movi	r4,7
8111da08:	20827516 	blt	r4,r2,8111e3e0 <___svfprintf_internal_r+0x1ba4>
8111da0c:	42000204 	addi	r8,r8,8
8111da10:	88027b16 	blt	r17,zero,8111e400 <___svfprintf_internal_r+0x1bc4>
8111da14:	d9003217 	ldw	r4,200(sp)
8111da18:	2463c83a 	sub	r17,r4,r17
8111da1c:	0440990e 	bge	zero,r17,8111dc84 <___svfprintf_internal_r+0x1448>
8111da20:	05800404 	movi	r22,16
8111da24:	d8801f17 	ldw	r2,124(sp)
8111da28:	b441530e 	bge	r22,r17,8111df78 <___svfprintf_internal_r+0x173c>
8111da2c:	01204574 	movhi	r4,33045
8111da30:	2126ba84 	addi	r4,r4,-25878
8111da34:	d9002b15 	stw	r4,172(sp)
8111da38:	070001c4 	movi	fp,7
8111da3c:	dd002c17 	ldw	r20,176(sp)
8111da40:	00000306 	br	8111da50 <___svfprintf_internal_r+0x1214>
8111da44:	42000204 	addi	r8,r8,8
8111da48:	8c7ffc04 	addi	r17,r17,-16
8111da4c:	b4414d0e 	bge	r22,r17,8111df84 <___svfprintf_internal_r+0x1748>
8111da50:	18c00404 	addi	r3,r3,16
8111da54:	10800044 	addi	r2,r2,1
8111da58:	45400015 	stw	r21,0(r8)
8111da5c:	45800115 	stw	r22,4(r8)
8111da60:	d8c02015 	stw	r3,128(sp)
8111da64:	d8801f15 	stw	r2,124(sp)
8111da68:	e0bff60e 	bge	fp,r2,8111da44 <__reset+0xfb0fda44>
8111da6c:	d9801e04 	addi	r6,sp,120
8111da70:	a00b883a 	mov	r5,r20
8111da74:	9809883a 	mov	r4,r19
8111da78:	112945c0 	call	8112945c <__ssprint_r>
8111da7c:	103c561e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111da80:	d8c02017 	ldw	r3,128(sp)
8111da84:	d8801f17 	ldw	r2,124(sp)
8111da88:	da000404 	addi	r8,sp,16
8111da8c:	003fee06 	br	8111da48 <__reset+0xfb0fda48>
8111da90:	d9402c17 	ldw	r5,176(sp)
8111da94:	d9801e04 	addi	r6,sp,120
8111da98:	9809883a 	mov	r4,r19
8111da9c:	112945c0 	call	8112945c <__ssprint_r>
8111daa0:	103c4d1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111daa4:	d8c02017 	ldw	r3,128(sp)
8111daa8:	df002787 	ldb	fp,158(sp)
8111daac:	da000404 	addi	r8,sp,16
8111dab0:	003d5a06 	br	8111d01c <__reset+0xfb0fd01c>
8111dab4:	9080040c 	andi	r2,r18,16
8111dab8:	10005c26 	beq	r2,zero,8111dc2c <___svfprintf_internal_r+0x13f0>
8111dabc:	d9402d17 	ldw	r5,180(sp)
8111dac0:	d8c02917 	ldw	r3,164(sp)
8111dac4:	d8002785 	stb	zero,158(sp)
8111dac8:	28800104 	addi	r2,r5,4
8111dacc:	2d000017 	ldw	r20,0(r5)
8111dad0:	002d883a 	mov	r22,zero
8111dad4:	18005e16 	blt	r3,zero,8111dc50 <___svfprintf_internal_r+0x1414>
8111dad8:	00ffdfc4 	movi	r3,-129
8111dadc:	d8802d15 	stw	r2,180(sp)
8111dae0:	90e4703a 	and	r18,r18,r3
8111dae4:	0039883a 	mov	fp,zero
8111dae8:	a03dfe26 	beq	r20,zero,8111d2e4 <__reset+0xfb0fd2e4>
8111daec:	00800244 	movi	r2,9
8111daf0:	153cb336 	bltu	r2,r20,8111cdc0 <__reset+0xfb0fcdc0>
8111daf4:	a5000c04 	addi	r20,r20,48
8111daf8:	dc001dc4 	addi	r16,sp,119
8111dafc:	dd001dc5 	stb	r20,119(sp)
8111db00:	d8c02817 	ldw	r3,160(sp)
8111db04:	1c07c83a 	sub	r3,r3,r16
8111db08:	d8c02e15 	stw	r3,184(sp)
8111db0c:	003cf506 	br	8111cee4 <__reset+0xfb0fcee4>
8111db10:	d8803317 	ldw	r2,204(sp)
8111db14:	143fffc4 	addi	r16,r2,-1
8111db18:	043f560e 	bge	zero,r16,8111d874 <__reset+0xfb0fd874>
8111db1c:	07000404 	movi	fp,16
8111db20:	e403530e 	bge	fp,r16,8111e870 <___svfprintf_internal_r+0x2034>
8111db24:	01604574 	movhi	r5,33045
8111db28:	2966ba84 	addi	r5,r5,-25878
8111db2c:	d9402b15 	stw	r5,172(sp)
8111db30:	01c001c4 	movi	r7,7
8111db34:	dd002c17 	ldw	r20,176(sp)
8111db38:	00000306 	br	8111db48 <___svfprintf_internal_r+0x130c>
8111db3c:	843ffc04 	addi	r16,r16,-16
8111db40:	b5800204 	addi	r22,r22,8
8111db44:	e400130e 	bge	fp,r16,8111db94 <___svfprintf_internal_r+0x1358>
8111db48:	18c00404 	addi	r3,r3,16
8111db4c:	8c400044 	addi	r17,r17,1
8111db50:	b5400015 	stw	r21,0(r22)
8111db54:	b7000115 	stw	fp,4(r22)
8111db58:	d8c02015 	stw	r3,128(sp)
8111db5c:	dc401f15 	stw	r17,124(sp)
8111db60:	3c7ff60e 	bge	r7,r17,8111db3c <__reset+0xfb0fdb3c>
8111db64:	d9801e04 	addi	r6,sp,120
8111db68:	a00b883a 	mov	r5,r20
8111db6c:	9809883a 	mov	r4,r19
8111db70:	d9c03d15 	stw	r7,244(sp)
8111db74:	112945c0 	call	8112945c <__ssprint_r>
8111db78:	d9c03d17 	ldw	r7,244(sp)
8111db7c:	103c161e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111db80:	843ffc04 	addi	r16,r16,-16
8111db84:	d8c02017 	ldw	r3,128(sp)
8111db88:	dc401f17 	ldw	r17,124(sp)
8111db8c:	dd800404 	addi	r22,sp,16
8111db90:	e43fed16 	blt	fp,r16,8111db48 <__reset+0xfb0fdb48>
8111db94:	d8802b17 	ldw	r2,172(sp)
8111db98:	1c07883a 	add	r3,r3,r16
8111db9c:	8c400044 	addi	r17,r17,1
8111dba0:	b0800015 	stw	r2,0(r22)
8111dba4:	b4000115 	stw	r16,4(r22)
8111dba8:	d8c02015 	stw	r3,128(sp)
8111dbac:	dc401f15 	stw	r17,124(sp)
8111dbb0:	008001c4 	movi	r2,7
8111dbb4:	147f2e0e 	bge	r2,r17,8111d870 <__reset+0xfb0fd870>
8111dbb8:	d9402c17 	ldw	r5,176(sp)
8111dbbc:	d9801e04 	addi	r6,sp,120
8111dbc0:	9809883a 	mov	r4,r19
8111dbc4:	112945c0 	call	8112945c <__ssprint_r>
8111dbc8:	103c031e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111dbcc:	d8c02017 	ldw	r3,128(sp)
8111dbd0:	dc401f17 	ldw	r17,124(sp)
8111dbd4:	dd800404 	addi	r22,sp,16
8111dbd8:	003f2606 	br	8111d874 <__reset+0xfb0fd874>
8111dbdc:	9080040c 	andi	r2,r18,16
8111dbe0:	1000c326 	beq	r2,zero,8111def0 <___svfprintf_internal_r+0x16b4>
8111dbe4:	d8802d17 	ldw	r2,180(sp)
8111dbe8:	15000017 	ldw	r20,0(r2)
8111dbec:	10800104 	addi	r2,r2,4
8111dbf0:	d8802d15 	stw	r2,180(sp)
8111dbf4:	a02dd7fa 	srai	r22,r20,31
8111dbf8:	b005883a 	mov	r2,r22
8111dbfc:	103c680e 	bge	r2,zero,8111cda0 <__reset+0xfb0fcda0>
8111dc00:	0529c83a 	sub	r20,zero,r20
8111dc04:	a004c03a 	cmpne	r2,r20,zero
8111dc08:	05adc83a 	sub	r22,zero,r22
8111dc0c:	b0adc83a 	sub	r22,r22,r2
8111dc10:	d8802917 	ldw	r2,164(sp)
8111dc14:	07000b44 	movi	fp,45
8111dc18:	df002785 	stb	fp,158(sp)
8111dc1c:	10022e16 	blt	r2,zero,8111e4d8 <___svfprintf_internal_r+0x1c9c>
8111dc20:	00bfdfc4 	movi	r2,-129
8111dc24:	90a4703a 	and	r18,r18,r2
8111dc28:	003c6406 	br	8111cdbc <__reset+0xfb0fcdbc>
8111dc2c:	9080100c 	andi	r2,r18,64
8111dc30:	d8002785 	stb	zero,158(sp)
8111dc34:	10012526 	beq	r2,zero,8111e0cc <___svfprintf_internal_r+0x1890>
8111dc38:	d9002d17 	ldw	r4,180(sp)
8111dc3c:	d9402917 	ldw	r5,164(sp)
8111dc40:	002d883a 	mov	r22,zero
8111dc44:	20800104 	addi	r2,r4,4
8111dc48:	2500000b 	ldhu	r20,0(r4)
8111dc4c:	283fa20e 	bge	r5,zero,8111dad8 <__reset+0xfb0fdad8>
8111dc50:	d8802d15 	stw	r2,180(sp)
8111dc54:	0039883a 	mov	fp,zero
8111dc58:	a584b03a 	or	r2,r20,r22
8111dc5c:	103c571e 	bne	r2,zero,8111cdbc <__reset+0xfb0fcdbc>
8111dc60:	00800044 	movi	r2,1
8111dc64:	003e5006 	br	8111d5a8 <__reset+0xfb0fd5a8>
8111dc68:	d9402c17 	ldw	r5,176(sp)
8111dc6c:	d9801e04 	addi	r6,sp,120
8111dc70:	9809883a 	mov	r4,r19
8111dc74:	112945c0 	call	8112945c <__ssprint_r>
8111dc78:	103bd71e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111dc7c:	d8c02017 	ldw	r3,128(sp)
8111dc80:	da000404 	addi	r8,sp,16
8111dc84:	d9003217 	ldw	r4,200(sp)
8111dc88:	d8802617 	ldw	r2,152(sp)
8111dc8c:	d9403317 	ldw	r5,204(sp)
8111dc90:	8123883a 	add	r17,r16,r4
8111dc94:	11400216 	blt	r2,r5,8111dca0 <___svfprintf_internal_r+0x1464>
8111dc98:	9100004c 	andi	r4,r18,1
8111dc9c:	20000d26 	beq	r4,zero,8111dcd4 <___svfprintf_internal_r+0x1498>
8111dca0:	d9003817 	ldw	r4,224(sp)
8111dca4:	d9403417 	ldw	r5,208(sp)
8111dca8:	1907883a 	add	r3,r3,r4
8111dcac:	d9001f17 	ldw	r4,124(sp)
8111dcb0:	41400015 	stw	r5,0(r8)
8111dcb4:	d9403817 	ldw	r5,224(sp)
8111dcb8:	21000044 	addi	r4,r4,1
8111dcbc:	d8c02015 	stw	r3,128(sp)
8111dcc0:	41400115 	stw	r5,4(r8)
8111dcc4:	d9001f15 	stw	r4,124(sp)
8111dcc8:	014001c4 	movi	r5,7
8111dccc:	2901dc16 	blt	r5,r4,8111e440 <___svfprintf_internal_r+0x1c04>
8111dcd0:	42000204 	addi	r8,r8,8
8111dcd4:	d9003317 	ldw	r4,204(sp)
8111dcd8:	8121883a 	add	r16,r16,r4
8111dcdc:	2085c83a 	sub	r2,r4,r2
8111dce0:	8461c83a 	sub	r16,r16,r17
8111dce4:	1400010e 	bge	r2,r16,8111dcec <___svfprintf_internal_r+0x14b0>
8111dce8:	1021883a 	mov	r16,r2
8111dcec:	04000a0e 	bge	zero,r16,8111dd18 <___svfprintf_internal_r+0x14dc>
8111dcf0:	d9001f17 	ldw	r4,124(sp)
8111dcf4:	1c07883a 	add	r3,r3,r16
8111dcf8:	44400015 	stw	r17,0(r8)
8111dcfc:	21000044 	addi	r4,r4,1
8111dd00:	44000115 	stw	r16,4(r8)
8111dd04:	d8c02015 	stw	r3,128(sp)
8111dd08:	d9001f15 	stw	r4,124(sp)
8111dd0c:	014001c4 	movi	r5,7
8111dd10:	2901e616 	blt	r5,r4,8111e4ac <___svfprintf_internal_r+0x1c70>
8111dd14:	42000204 	addi	r8,r8,8
8111dd18:	8001f616 	blt	r16,zero,8111e4f4 <___svfprintf_internal_r+0x1cb8>
8111dd1c:	1421c83a 	sub	r16,r2,r16
8111dd20:	043d1c0e 	bge	zero,r16,8111d194 <__reset+0xfb0fd194>
8111dd24:	04400404 	movi	r17,16
8111dd28:	d8801f17 	ldw	r2,124(sp)
8111dd2c:	8c3edd0e 	bge	r17,r16,8111d8a4 <__reset+0xfb0fd8a4>
8111dd30:	01604574 	movhi	r5,33045
8111dd34:	2966ba84 	addi	r5,r5,-25878
8111dd38:	d9402b15 	stw	r5,172(sp)
8111dd3c:	058001c4 	movi	r22,7
8111dd40:	dd002c17 	ldw	r20,176(sp)
8111dd44:	00000306 	br	8111dd54 <___svfprintf_internal_r+0x1518>
8111dd48:	42000204 	addi	r8,r8,8
8111dd4c:	843ffc04 	addi	r16,r16,-16
8111dd50:	8c3ed70e 	bge	r17,r16,8111d8b0 <__reset+0xfb0fd8b0>
8111dd54:	18c00404 	addi	r3,r3,16
8111dd58:	10800044 	addi	r2,r2,1
8111dd5c:	45400015 	stw	r21,0(r8)
8111dd60:	44400115 	stw	r17,4(r8)
8111dd64:	d8c02015 	stw	r3,128(sp)
8111dd68:	d8801f15 	stw	r2,124(sp)
8111dd6c:	b0bff60e 	bge	r22,r2,8111dd48 <__reset+0xfb0fdd48>
8111dd70:	d9801e04 	addi	r6,sp,120
8111dd74:	a00b883a 	mov	r5,r20
8111dd78:	9809883a 	mov	r4,r19
8111dd7c:	112945c0 	call	8112945c <__ssprint_r>
8111dd80:	103b951e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111dd84:	d8c02017 	ldw	r3,128(sp)
8111dd88:	d8801f17 	ldw	r2,124(sp)
8111dd8c:	da000404 	addi	r8,sp,16
8111dd90:	003fee06 	br	8111dd4c <__reset+0xfb0fdd4c>
8111dd94:	9088703a 	and	r4,r18,r2
8111dd98:	203e8d1e 	bne	r4,zero,8111d7d0 <__reset+0xfb0fd7d0>
8111dd9c:	dc401f17 	ldw	r17,124(sp)
8111dda0:	40800115 	stw	r2,4(r8)
8111dda4:	44000015 	stw	r16,0(r8)
8111dda8:	8c400044 	addi	r17,r17,1
8111ddac:	d8c02015 	stw	r3,128(sp)
8111ddb0:	dc401f15 	stw	r17,124(sp)
8111ddb4:	008001c4 	movi	r2,7
8111ddb8:	147f7f16 	blt	r2,r17,8111dbb8 <__reset+0xfb0fdbb8>
8111ddbc:	45800204 	addi	r22,r8,8
8111ddc0:	003eac06 	br	8111d874 <__reset+0xfb0fd874>
8111ddc4:	d9402c17 	ldw	r5,176(sp)
8111ddc8:	d9801e04 	addi	r6,sp,120
8111ddcc:	9809883a 	mov	r4,r19
8111ddd0:	112945c0 	call	8112945c <__ssprint_r>
8111ddd4:	103b801e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111ddd8:	d8c02017 	ldw	r3,128(sp)
8111dddc:	dc401f17 	ldw	r17,124(sp)
8111dde0:	da000404 	addi	r8,sp,16
8111dde4:	003e8406 	br	8111d7f8 <__reset+0xfb0fd7f8>
8111dde8:	d9402c17 	ldw	r5,176(sp)
8111ddec:	d9801e04 	addi	r6,sp,120
8111ddf0:	9809883a 	mov	r4,r19
8111ddf4:	112945c0 	call	8112945c <__ssprint_r>
8111ddf8:	103b771e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111ddfc:	d8c02017 	ldw	r3,128(sp)
8111de00:	dc401f17 	ldw	r17,124(sp)
8111de04:	dd800404 	addi	r22,sp,16
8111de08:	003e8606 	br	8111d824 <__reset+0xfb0fd824>
8111de0c:	0029883a 	mov	r20,zero
8111de10:	a5000c04 	addi	r20,r20,48
8111de14:	dc001dc4 	addi	r16,sp,119
8111de18:	dd001dc5 	stb	r20,119(sp)
8111de1c:	003f3806 	br	8111db00 <__reset+0xfb0fdb00>
8111de20:	d9402c17 	ldw	r5,176(sp)
8111de24:	d9801e04 	addi	r6,sp,120
8111de28:	9809883a 	mov	r4,r19
8111de2c:	112945c0 	call	8112945c <__ssprint_r>
8111de30:	103b691e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111de34:	d8c02017 	ldw	r3,128(sp)
8111de38:	da000404 	addi	r8,sp,16
8111de3c:	003c9506 	br	8111d094 <__reset+0xfb0fd094>
8111de40:	d9003617 	ldw	r4,216(sp)
8111de44:	d9403717 	ldw	r5,220(sp)
8111de48:	da003e15 	stw	r8,248(sp)
8111de4c:	11272700 	call	81127270 <__fpclassifyd>
8111de50:	da003e17 	ldw	r8,248(sp)
8111de54:	1000bd1e 	bne	r2,zero,8111e14c <___svfprintf_internal_r+0x1910>
8111de58:	008011c4 	movi	r2,71
8111de5c:	14411e0e 	bge	r2,r17,8111e2d8 <___svfprintf_internal_r+0x1a9c>
8111de60:	04204574 	movhi	r16,33045
8111de64:	8426ad04 	addi	r16,r16,-25932
8111de68:	00c000c4 	movi	r3,3
8111de6c:	00bfdfc4 	movi	r2,-129
8111de70:	d8c02a15 	stw	r3,168(sp)
8111de74:	90a4703a 	and	r18,r18,r2
8111de78:	df002783 	ldbu	fp,158(sp)
8111de7c:	d8c02e15 	stw	r3,184(sp)
8111de80:	d8002915 	stw	zero,164(sp)
8111de84:	d8003215 	stw	zero,200(sp)
8111de88:	003c1c06 	br	8111cefc <__reset+0xfb0fcefc>
8111de8c:	9080100c 	andi	r2,r18,64
8111de90:	d8002785 	stb	zero,158(sp)
8111de94:	10009426 	beq	r2,zero,8111e0e8 <___svfprintf_internal_r+0x18ac>
8111de98:	d8c02d17 	ldw	r3,180(sp)
8111de9c:	d9002917 	ldw	r4,164(sp)
8111dea0:	002d883a 	mov	r22,zero
8111dea4:	18800104 	addi	r2,r3,4
8111dea8:	1d00000b 	ldhu	r20,0(r3)
8111deac:	203ec10e 	bge	r4,zero,8111d9b4 <__reset+0xfb0fd9b4>
8111deb0:	a586b03a 	or	r3,r20,r22
8111deb4:	d8802d15 	stw	r2,180(sp)
8111deb8:	183ec21e 	bne	r3,zero,8111d9c4 <__reset+0xfb0fd9c4>
8111debc:	0039883a 	mov	fp,zero
8111dec0:	0005883a 	mov	r2,zero
8111dec4:	003db806 	br	8111d5a8 <__reset+0xfb0fd5a8>
8111dec8:	d8802d17 	ldw	r2,180(sp)
8111decc:	d8c02d17 	ldw	r3,180(sp)
8111ded0:	d9002d17 	ldw	r4,180(sp)
8111ded4:	10800017 	ldw	r2,0(r2)
8111ded8:	18c00117 	ldw	r3,4(r3)
8111dedc:	21000204 	addi	r4,r4,8
8111dee0:	d8803615 	stw	r2,216(sp)
8111dee4:	d8c03715 	stw	r3,220(sp)
8111dee8:	d9002d15 	stw	r4,180(sp)
8111deec:	003b8206 	br	8111ccf8 <__reset+0xfb0fccf8>
8111def0:	9080100c 	andi	r2,r18,64
8111def4:	10010726 	beq	r2,zero,8111e314 <___svfprintf_internal_r+0x1ad8>
8111def8:	d8c02d17 	ldw	r3,180(sp)
8111defc:	1d00000f 	ldh	r20,0(r3)
8111df00:	18c00104 	addi	r3,r3,4
8111df04:	d8c02d15 	stw	r3,180(sp)
8111df08:	a02dd7fa 	srai	r22,r20,31
8111df0c:	b005883a 	mov	r2,r22
8111df10:	003ba206 	br	8111cd9c <__reset+0xfb0fcd9c>
8111df14:	9080100c 	andi	r2,r18,64
8111df18:	10010526 	beq	r2,zero,8111e330 <___svfprintf_internal_r+0x1af4>
8111df1c:	d9002d17 	ldw	r4,180(sp)
8111df20:	002d883a 	mov	r22,zero
8111df24:	2500000b 	ldhu	r20,0(r4)
8111df28:	21000104 	addi	r4,r4,4
8111df2c:	d9002d15 	stw	r4,180(sp)
8111df30:	003cfe06 	br	8111d32c <__reset+0xfb0fd32c>
8111df34:	bc400007 	ldb	r17,0(r23)
8111df38:	003a9606 	br	8111c994 <__reset+0xfb0fc994>
8111df3c:	9080040c 	andi	r2,r18,16
8111df40:	10010126 	beq	r2,zero,8111e348 <___svfprintf_internal_r+0x1b0c>
8111df44:	d9402d17 	ldw	r5,180(sp)
8111df48:	d8c02f17 	ldw	r3,188(sp)
8111df4c:	28800017 	ldw	r2,0(r5)
8111df50:	29400104 	addi	r5,r5,4
8111df54:	d9402d15 	stw	r5,180(sp)
8111df58:	10c00015 	stw	r3,0(r2)
8111df5c:	003a6406 	br	8111c8f0 <__reset+0xfb0fc8f0>
8111df60:	d9002917 	ldw	r4,164(sp)
8111df64:	d8002785 	stb	zero,158(sp)
8111df68:	203d8d16 	blt	r4,zero,8111d5a0 <__reset+0xfb0fd5a0>
8111df6c:	00bfdfc4 	movi	r2,-129
8111df70:	90a4703a 	and	r18,r18,r2
8111df74:	003b0506 	br	8111cb8c <__reset+0xfb0fcb8c>
8111df78:	01604574 	movhi	r5,33045
8111df7c:	2966ba84 	addi	r5,r5,-25878
8111df80:	d9402b15 	stw	r5,172(sp)
8111df84:	d9402b17 	ldw	r5,172(sp)
8111df88:	1c47883a 	add	r3,r3,r17
8111df8c:	10800044 	addi	r2,r2,1
8111df90:	41400015 	stw	r5,0(r8)
8111df94:	44400115 	stw	r17,4(r8)
8111df98:	d8c02015 	stw	r3,128(sp)
8111df9c:	d8801f15 	stw	r2,124(sp)
8111dfa0:	010001c4 	movi	r4,7
8111dfa4:	20bf3016 	blt	r4,r2,8111dc68 <__reset+0xfb0fdc68>
8111dfa8:	42000204 	addi	r8,r8,8
8111dfac:	003f3506 	br	8111dc84 <__reset+0xfb0fdc84>
8111dfb0:	01204574 	movhi	r4,33045
8111dfb4:	2126ba84 	addi	r4,r4,-25878
8111dfb8:	d9002b15 	stw	r4,172(sp)
8111dfbc:	003c5e06 	br	8111d138 <__reset+0xfb0fd138>
8111dfc0:	d9402c17 	ldw	r5,176(sp)
8111dfc4:	d9801e04 	addi	r6,sp,120
8111dfc8:	9809883a 	mov	r4,r19
8111dfcc:	112945c0 	call	8112945c <__ssprint_r>
8111dfd0:	103b011e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111dfd4:	d8c02017 	ldw	r3,128(sp)
8111dfd8:	da000404 	addi	r8,sp,16
8111dfdc:	003d9306 	br	8111d62c <__reset+0xfb0fd62c>
8111dfe0:	d8801f17 	ldw	r2,124(sp)
8111dfe4:	01604574 	movhi	r5,33045
8111dfe8:	01000044 	movi	r4,1
8111dfec:	18c00044 	addi	r3,r3,1
8111dff0:	10800044 	addi	r2,r2,1
8111dff4:	2966ba04 	addi	r5,r5,-25880
8111dff8:	41000115 	stw	r4,4(r8)
8111dffc:	41400015 	stw	r5,0(r8)
8111e000:	d8c02015 	stw	r3,128(sp)
8111e004:	d8801f15 	stw	r2,124(sp)
8111e008:	010001c4 	movi	r4,7
8111e00c:	2080b516 	blt	r4,r2,8111e2e4 <___svfprintf_internal_r+0x1aa8>
8111e010:	42000204 	addi	r8,r8,8
8111e014:	8800041e 	bne	r17,zero,8111e028 <___svfprintf_internal_r+0x17ec>
8111e018:	d8803317 	ldw	r2,204(sp)
8111e01c:	1000021e 	bne	r2,zero,8111e028 <___svfprintf_internal_r+0x17ec>
8111e020:	9080004c 	andi	r2,r18,1
8111e024:	103c5b26 	beq	r2,zero,8111d194 <__reset+0xfb0fd194>
8111e028:	d9003817 	ldw	r4,224(sp)
8111e02c:	d8801f17 	ldw	r2,124(sp)
8111e030:	d9403417 	ldw	r5,208(sp)
8111e034:	20c7883a 	add	r3,r4,r3
8111e038:	10800044 	addi	r2,r2,1
8111e03c:	41000115 	stw	r4,4(r8)
8111e040:	41400015 	stw	r5,0(r8)
8111e044:	d8c02015 	stw	r3,128(sp)
8111e048:	d8801f15 	stw	r2,124(sp)
8111e04c:	010001c4 	movi	r4,7
8111e050:	20818016 	blt	r4,r2,8111e654 <___svfprintf_internal_r+0x1e18>
8111e054:	42000204 	addi	r8,r8,8
8111e058:	0463c83a 	sub	r17,zero,r17
8111e05c:	0440cb0e 	bge	zero,r17,8111e38c <___svfprintf_internal_r+0x1b50>
8111e060:	05800404 	movi	r22,16
8111e064:	b440e80e 	bge	r22,r17,8111e408 <___svfprintf_internal_r+0x1bcc>
8111e068:	01604574 	movhi	r5,33045
8111e06c:	2966ba84 	addi	r5,r5,-25878
8111e070:	d9402b15 	stw	r5,172(sp)
8111e074:	070001c4 	movi	fp,7
8111e078:	dd002c17 	ldw	r20,176(sp)
8111e07c:	00000306 	br	8111e08c <___svfprintf_internal_r+0x1850>
8111e080:	42000204 	addi	r8,r8,8
8111e084:	8c7ffc04 	addi	r17,r17,-16
8111e088:	b440e20e 	bge	r22,r17,8111e414 <___svfprintf_internal_r+0x1bd8>
8111e08c:	18c00404 	addi	r3,r3,16
8111e090:	10800044 	addi	r2,r2,1
8111e094:	45400015 	stw	r21,0(r8)
8111e098:	45800115 	stw	r22,4(r8)
8111e09c:	d8c02015 	stw	r3,128(sp)
8111e0a0:	d8801f15 	stw	r2,124(sp)
8111e0a4:	e0bff60e 	bge	fp,r2,8111e080 <__reset+0xfb0fe080>
8111e0a8:	d9801e04 	addi	r6,sp,120
8111e0ac:	a00b883a 	mov	r5,r20
8111e0b0:	9809883a 	mov	r4,r19
8111e0b4:	112945c0 	call	8112945c <__ssprint_r>
8111e0b8:	103ac71e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e0bc:	d8c02017 	ldw	r3,128(sp)
8111e0c0:	d8801f17 	ldw	r2,124(sp)
8111e0c4:	da000404 	addi	r8,sp,16
8111e0c8:	003fee06 	br	8111e084 <__reset+0xfb0fe084>
8111e0cc:	d8c02d17 	ldw	r3,180(sp)
8111e0d0:	d9002917 	ldw	r4,164(sp)
8111e0d4:	002d883a 	mov	r22,zero
8111e0d8:	18800104 	addi	r2,r3,4
8111e0dc:	1d000017 	ldw	r20,0(r3)
8111e0e0:	203e7d0e 	bge	r4,zero,8111dad8 <__reset+0xfb0fdad8>
8111e0e4:	003eda06 	br	8111dc50 <__reset+0xfb0fdc50>
8111e0e8:	d9402d17 	ldw	r5,180(sp)
8111e0ec:	d8c02917 	ldw	r3,164(sp)
8111e0f0:	002d883a 	mov	r22,zero
8111e0f4:	28800104 	addi	r2,r5,4
8111e0f8:	2d000017 	ldw	r20,0(r5)
8111e0fc:	183e2d0e 	bge	r3,zero,8111d9b4 <__reset+0xfb0fd9b4>
8111e100:	003f6b06 	br	8111deb0 <__reset+0xfb0fdeb0>
8111e104:	d8c02d15 	stw	r3,180(sp)
8111e108:	0039883a 	mov	fp,zero
8111e10c:	003ed206 	br	8111dc58 <__reset+0xfb0fdc58>
8111e110:	bc400043 	ldbu	r17,1(r23)
8111e114:	94800814 	ori	r18,r18,32
8111e118:	bdc00044 	addi	r23,r23,1
8111e11c:	8c403fcc 	andi	r17,r17,255
8111e120:	8c40201c 	xori	r17,r17,128
8111e124:	8c7fe004 	addi	r17,r17,-128
8111e128:	003a1a06 	br	8111c994 <__reset+0xfb0fc994>
8111e12c:	d9402c17 	ldw	r5,176(sp)
8111e130:	d9801e04 	addi	r6,sp,120
8111e134:	9809883a 	mov	r4,r19
8111e138:	112945c0 	call	8112945c <__ssprint_r>
8111e13c:	103aa61e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e140:	d8c02017 	ldw	r3,128(sp)
8111e144:	da000404 	addi	r8,sp,16
8111e148:	003d4a06 	br	8111d674 <__reset+0xfb0fd674>
8111e14c:	d9002917 	ldw	r4,164(sp)
8111e150:	05bff7c4 	movi	r22,-33
8111e154:	00bfffc4 	movi	r2,-1
8111e158:	8dac703a 	and	r22,r17,r22
8111e15c:	20806a26 	beq	r4,r2,8111e308 <___svfprintf_internal_r+0x1acc>
8111e160:	008011c4 	movi	r2,71
8111e164:	b0813726 	beq	r22,r2,8111e644 <___svfprintf_internal_r+0x1e08>
8111e168:	d9003717 	ldw	r4,220(sp)
8111e16c:	90c04014 	ori	r3,r18,256
8111e170:	d8c02b15 	stw	r3,172(sp)
8111e174:	20015d16 	blt	r4,zero,8111e6ec <___svfprintf_internal_r+0x1eb0>
8111e178:	dd003717 	ldw	r20,220(sp)
8111e17c:	d8002a05 	stb	zero,168(sp)
8111e180:	00801984 	movi	r2,102
8111e184:	88814026 	beq	r17,r2,8111e688 <___svfprintf_internal_r+0x1e4c>
8111e188:	00801184 	movi	r2,70
8111e18c:	88817126 	beq	r17,r2,8111e754 <___svfprintf_internal_r+0x1f18>
8111e190:	00801144 	movi	r2,69
8111e194:	b0816226 	beq	r22,r2,8111e720 <___svfprintf_internal_r+0x1ee4>
8111e198:	d8c02917 	ldw	r3,164(sp)
8111e19c:	d8802104 	addi	r2,sp,132
8111e1a0:	d8800315 	stw	r2,12(sp)
8111e1a4:	d9403617 	ldw	r5,216(sp)
8111e1a8:	d8802504 	addi	r2,sp,148
8111e1ac:	d8800215 	stw	r2,8(sp)
8111e1b0:	d8802604 	addi	r2,sp,152
8111e1b4:	d8c00015 	stw	r3,0(sp)
8111e1b8:	d8800115 	stw	r2,4(sp)
8111e1bc:	01c00084 	movi	r7,2
8111e1c0:	a00d883a 	mov	r6,r20
8111e1c4:	9809883a 	mov	r4,r19
8111e1c8:	d8c03d15 	stw	r3,244(sp)
8111e1cc:	da003e15 	stw	r8,248(sp)
8111e1d0:	1122b280 	call	81122b28 <_dtoa_r>
8111e1d4:	1021883a 	mov	r16,r2
8111e1d8:	008019c4 	movi	r2,103
8111e1dc:	d8c03d17 	ldw	r3,244(sp)
8111e1e0:	da003e17 	ldw	r8,248(sp)
8111e1e4:	8880e726 	beq	r17,r2,8111e584 <___svfprintf_internal_r+0x1d48>
8111e1e8:	008011c4 	movi	r2,71
8111e1ec:	8880d426 	beq	r17,r2,8111e540 <___svfprintf_internal_r+0x1d04>
8111e1f0:	80f9883a 	add	fp,r16,r3
8111e1f4:	d9003617 	ldw	r4,216(sp)
8111e1f8:	000d883a 	mov	r6,zero
8111e1fc:	000f883a 	mov	r7,zero
8111e200:	a00b883a 	mov	r5,r20
8111e204:	da003e15 	stw	r8,248(sp)
8111e208:	112f4540 	call	8112f454 <__eqdf2>
8111e20c:	da003e17 	ldw	r8,248(sp)
8111e210:	1000e426 	beq	r2,zero,8111e5a4 <___svfprintf_internal_r+0x1d68>
8111e214:	d8802117 	ldw	r2,132(sp)
8111e218:	1700062e 	bgeu	r2,fp,8111e234 <___svfprintf_internal_r+0x19f8>
8111e21c:	01000c04 	movi	r4,48
8111e220:	10c00044 	addi	r3,r2,1
8111e224:	d8c02115 	stw	r3,132(sp)
8111e228:	11000005 	stb	r4,0(r2)
8111e22c:	d8802117 	ldw	r2,132(sp)
8111e230:	173ffb36 	bltu	r2,fp,8111e220 <__reset+0xfb0fe220>
8111e234:	1405c83a 	sub	r2,r2,r16
8111e238:	d8803315 	stw	r2,204(sp)
8111e23c:	008011c4 	movi	r2,71
8111e240:	b080c526 	beq	r22,r2,8111e558 <___svfprintf_internal_r+0x1d1c>
8111e244:	00801944 	movi	r2,101
8111e248:	1441d90e 	bge	r2,r17,8111e9b0 <___svfprintf_internal_r+0x2174>
8111e24c:	d8c02617 	ldw	r3,152(sp)
8111e250:	00801984 	movi	r2,102
8111e254:	d8c03215 	stw	r3,200(sp)
8111e258:	88813426 	beq	r17,r2,8111e72c <___svfprintf_internal_r+0x1ef0>
8111e25c:	d8c03217 	ldw	r3,200(sp)
8111e260:	d9003317 	ldw	r4,204(sp)
8111e264:	19012516 	blt	r3,r4,8111e6fc <___svfprintf_internal_r+0x1ec0>
8111e268:	9480004c 	andi	r18,r18,1
8111e26c:	9001841e 	bne	r18,zero,8111e880 <___svfprintf_internal_r+0x2044>
8111e270:	1805883a 	mov	r2,r3
8111e274:	1801cc16 	blt	r3,zero,8111e9a8 <___svfprintf_internal_r+0x216c>
8111e278:	d8c03217 	ldw	r3,200(sp)
8111e27c:	044019c4 	movi	r17,103
8111e280:	d8c02e15 	stw	r3,184(sp)
8111e284:	df002a07 	ldb	fp,168(sp)
8111e288:	e000a61e 	bne	fp,zero,8111e524 <___svfprintf_internal_r+0x1ce8>
8111e28c:	df002783 	ldbu	fp,158(sp)
8111e290:	d8802a15 	stw	r2,168(sp)
8111e294:	dc802b17 	ldw	r18,172(sp)
8111e298:	d8002915 	stw	zero,164(sp)
8111e29c:	003b1706 	br	8111cefc <__reset+0xfb0fcefc>
8111e2a0:	04204574 	movhi	r16,33045
8111e2a4:	8426aa04 	addi	r16,r16,-25944
8111e2a8:	003aa606 	br	8111cd44 <__reset+0xfb0fcd44>
8111e2ac:	d9003917 	ldw	r4,228(sp)
8111e2b0:	04001004 	movi	r16,64
8111e2b4:	800b883a 	mov	r5,r16
8111e2b8:	111b1fc0 	call	8111b1fc <_malloc_r>
8111e2bc:	d9002c17 	ldw	r4,176(sp)
8111e2c0:	20800015 	stw	r2,0(r4)
8111e2c4:	20800415 	stw	r2,16(r4)
8111e2c8:	1001cb26 	beq	r2,zero,8111e9f8 <___svfprintf_internal_r+0x21bc>
8111e2cc:	d8802c17 	ldw	r2,176(sp)
8111e2d0:	14000515 	stw	r16,20(r2)
8111e2d4:	00397606 	br	8111c8b0 <__reset+0xfb0fc8b0>
8111e2d8:	04204574 	movhi	r16,33045
8111e2dc:	8426ac04 	addi	r16,r16,-25936
8111e2e0:	003ee106 	br	8111de68 <__reset+0xfb0fde68>
8111e2e4:	d9402c17 	ldw	r5,176(sp)
8111e2e8:	d9801e04 	addi	r6,sp,120
8111e2ec:	9809883a 	mov	r4,r19
8111e2f0:	112945c0 	call	8112945c <__ssprint_r>
8111e2f4:	103a381e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e2f8:	dc402617 	ldw	r17,152(sp)
8111e2fc:	d8c02017 	ldw	r3,128(sp)
8111e300:	da000404 	addi	r8,sp,16
8111e304:	003f4306 	br	8111e014 <__reset+0xfb0fe014>
8111e308:	01400184 	movi	r5,6
8111e30c:	d9402915 	stw	r5,164(sp)
8111e310:	003f9506 	br	8111e168 <__reset+0xfb0fe168>
8111e314:	d9002d17 	ldw	r4,180(sp)
8111e318:	25000017 	ldw	r20,0(r4)
8111e31c:	21000104 	addi	r4,r4,4
8111e320:	d9002d15 	stw	r4,180(sp)
8111e324:	a02dd7fa 	srai	r22,r20,31
8111e328:	b005883a 	mov	r2,r22
8111e32c:	003a9b06 	br	8111cd9c <__reset+0xfb0fcd9c>
8111e330:	d9402d17 	ldw	r5,180(sp)
8111e334:	002d883a 	mov	r22,zero
8111e338:	2d000017 	ldw	r20,0(r5)
8111e33c:	29400104 	addi	r5,r5,4
8111e340:	d9402d15 	stw	r5,180(sp)
8111e344:	003bf906 	br	8111d32c <__reset+0xfb0fd32c>
8111e348:	9480100c 	andi	r18,r18,64
8111e34c:	90006e26 	beq	r18,zero,8111e508 <___svfprintf_internal_r+0x1ccc>
8111e350:	d9002d17 	ldw	r4,180(sp)
8111e354:	d9402f17 	ldw	r5,188(sp)
8111e358:	20800017 	ldw	r2,0(r4)
8111e35c:	21000104 	addi	r4,r4,4
8111e360:	d9002d15 	stw	r4,180(sp)
8111e364:	1140000d 	sth	r5,0(r2)
8111e368:	00396106 	br	8111c8f0 <__reset+0xfb0fc8f0>
8111e36c:	d9402c17 	ldw	r5,176(sp)
8111e370:	d9801e04 	addi	r6,sp,120
8111e374:	9809883a 	mov	r4,r19
8111e378:	112945c0 	call	8112945c <__ssprint_r>
8111e37c:	103a161e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e380:	d8c02017 	ldw	r3,128(sp)
8111e384:	d8801f17 	ldw	r2,124(sp)
8111e388:	da000404 	addi	r8,sp,16
8111e38c:	d9403317 	ldw	r5,204(sp)
8111e390:	10800044 	addi	r2,r2,1
8111e394:	44000015 	stw	r16,0(r8)
8111e398:	28c7883a 	add	r3,r5,r3
8111e39c:	003b7706 	br	8111d17c <__reset+0xfb0fd17c>
8111e3a0:	8009883a 	mov	r4,r16
8111e3a4:	da003e15 	stw	r8,248(sp)
8111e3a8:	111c5040 	call	8111c504 <strlen>
8111e3ac:	d8802e15 	stw	r2,184(sp)
8111e3b0:	da003e17 	ldw	r8,248(sp)
8111e3b4:	103c280e 	bge	r2,zero,8111d458 <__reset+0xfb0fd458>
8111e3b8:	0005883a 	mov	r2,zero
8111e3bc:	003c2606 	br	8111d458 <__reset+0xfb0fd458>
8111e3c0:	00bfffc4 	movi	r2,-1
8111e3c4:	003a0906 	br	8111cbec <__reset+0xfb0fcbec>
8111e3c8:	01204574 	movhi	r4,33045
8111e3cc:	2126be84 	addi	r4,r4,-25862
8111e3d0:	d9003515 	stw	r4,212(sp)
8111e3d4:	003b0606 	br	8111cff0 <__reset+0xfb0fcff0>
8111e3d8:	013fffc4 	movi	r4,-1
8111e3dc:	003a2706 	br	8111cc7c <__reset+0xfb0fcc7c>
8111e3e0:	d9402c17 	ldw	r5,176(sp)
8111e3e4:	d9801e04 	addi	r6,sp,120
8111e3e8:	9809883a 	mov	r4,r19
8111e3ec:	112945c0 	call	8112945c <__ssprint_r>
8111e3f0:	1039f91e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e3f4:	d8c02017 	ldw	r3,128(sp)
8111e3f8:	da000404 	addi	r8,sp,16
8111e3fc:	003d8406 	br	8111da10 <__reset+0xfb0fda10>
8111e400:	0023883a 	mov	r17,zero
8111e404:	003d8306 	br	8111da14 <__reset+0xfb0fda14>
8111e408:	01204574 	movhi	r4,33045
8111e40c:	2126ba84 	addi	r4,r4,-25878
8111e410:	d9002b15 	stw	r4,172(sp)
8111e414:	d9002b17 	ldw	r4,172(sp)
8111e418:	1c47883a 	add	r3,r3,r17
8111e41c:	10800044 	addi	r2,r2,1
8111e420:	41000015 	stw	r4,0(r8)
8111e424:	44400115 	stw	r17,4(r8)
8111e428:	d8c02015 	stw	r3,128(sp)
8111e42c:	d8801f15 	stw	r2,124(sp)
8111e430:	010001c4 	movi	r4,7
8111e434:	20bfcd16 	blt	r4,r2,8111e36c <__reset+0xfb0fe36c>
8111e438:	42000204 	addi	r8,r8,8
8111e43c:	003fd306 	br	8111e38c <__reset+0xfb0fe38c>
8111e440:	d9402c17 	ldw	r5,176(sp)
8111e444:	d9801e04 	addi	r6,sp,120
8111e448:	9809883a 	mov	r4,r19
8111e44c:	112945c0 	call	8112945c <__ssprint_r>
8111e450:	1039e11e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e454:	d8802617 	ldw	r2,152(sp)
8111e458:	d8c02017 	ldw	r3,128(sp)
8111e45c:	da000404 	addi	r8,sp,16
8111e460:	003e1c06 	br	8111dcd4 <__reset+0xfb0fdcd4>
8111e464:	d8802917 	ldw	r2,164(sp)
8111e468:	00c00184 	movi	r3,6
8111e46c:	1880012e 	bgeu	r3,r2,8111e474 <___svfprintf_internal_r+0x1c38>
8111e470:	1805883a 	mov	r2,r3
8111e474:	d8802e15 	stw	r2,184(sp)
8111e478:	1000f316 	blt	r2,zero,8111e848 <___svfprintf_internal_r+0x200c>
8111e47c:	04204574 	movhi	r16,33045
8111e480:	d8802a15 	stw	r2,168(sp)
8111e484:	dd002d15 	stw	r20,180(sp)
8111e488:	d8002915 	stw	zero,164(sp)
8111e48c:	d8003215 	stw	zero,200(sp)
8111e490:	8426b804 	addi	r16,r16,-25888
8111e494:	0039883a 	mov	fp,zero
8111e498:	003a9f06 	br	8111cf18 <__reset+0xfb0fcf18>
8111e49c:	01204574 	movhi	r4,33045
8111e4a0:	2126be84 	addi	r4,r4,-25862
8111e4a4:	d9003515 	stw	r4,212(sp)
8111e4a8:	003b5f06 	br	8111d228 <__reset+0xfb0fd228>
8111e4ac:	d9402c17 	ldw	r5,176(sp)
8111e4b0:	d9801e04 	addi	r6,sp,120
8111e4b4:	9809883a 	mov	r4,r19
8111e4b8:	112945c0 	call	8112945c <__ssprint_r>
8111e4bc:	1039c61e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e4c0:	d8802617 	ldw	r2,152(sp)
8111e4c4:	d9403317 	ldw	r5,204(sp)
8111e4c8:	d8c02017 	ldw	r3,128(sp)
8111e4cc:	da000404 	addi	r8,sp,16
8111e4d0:	2885c83a 	sub	r2,r5,r2
8111e4d4:	003e1006 	br	8111dd18 <__reset+0xfb0fdd18>
8111e4d8:	00800044 	movi	r2,1
8111e4dc:	10803fcc 	andi	r2,r2,255
8111e4e0:	00c00044 	movi	r3,1
8111e4e4:	10fa3526 	beq	r2,r3,8111cdbc <__reset+0xfb0fcdbc>
8111e4e8:	00c00084 	movi	r3,2
8111e4ec:	10fb9e26 	beq	r2,r3,8111d368 <__reset+0xfb0fd368>
8111e4f0:	003a6406 	br	8111ce84 <__reset+0xfb0fce84>
8111e4f4:	0021883a 	mov	r16,zero
8111e4f8:	003e0806 	br	8111dd1c <__reset+0xfb0fdd1c>
8111e4fc:	07000b44 	movi	fp,45
8111e500:	df002785 	stb	fp,158(sp)
8111e504:	003a0b06 	br	8111cd34 <__reset+0xfb0fcd34>
8111e508:	d8c02d17 	ldw	r3,180(sp)
8111e50c:	d9002f17 	ldw	r4,188(sp)
8111e510:	18800017 	ldw	r2,0(r3)
8111e514:	18c00104 	addi	r3,r3,4
8111e518:	d8c02d15 	stw	r3,180(sp)
8111e51c:	11000015 	stw	r4,0(r2)
8111e520:	0038f306 	br	8111c8f0 <__reset+0xfb0fc8f0>
8111e524:	00c00b44 	movi	r3,45
8111e528:	d8c02785 	stb	r3,158(sp)
8111e52c:	d8802a15 	stw	r2,168(sp)
8111e530:	dc802b17 	ldw	r18,172(sp)
8111e534:	d8002915 	stw	zero,164(sp)
8111e538:	07000b44 	movi	fp,45
8111e53c:	003a7306 	br	8111cf0c <__reset+0xfb0fcf0c>
8111e540:	9080004c 	andi	r2,r18,1
8111e544:	1000941e 	bne	r2,zero,8111e798 <___svfprintf_internal_r+0x1f5c>
8111e548:	d8802117 	ldw	r2,132(sp)
8111e54c:	1405c83a 	sub	r2,r2,r16
8111e550:	d8803315 	stw	r2,204(sp)
8111e554:	b441161e 	bne	r22,r17,8111e9b0 <___svfprintf_internal_r+0x2174>
8111e558:	dd802617 	ldw	r22,152(sp)
8111e55c:	00bfff44 	movi	r2,-3
8111e560:	b0801a16 	blt	r22,r2,8111e5cc <___svfprintf_internal_r+0x1d90>
8111e564:	d9402917 	ldw	r5,164(sp)
8111e568:	2d801816 	blt	r5,r22,8111e5cc <___svfprintf_internal_r+0x1d90>
8111e56c:	dd803215 	stw	r22,200(sp)
8111e570:	003f3a06 	br	8111e25c <__reset+0xfb0fe25c>
8111e574:	1025883a 	mov	r18,r2
8111e578:	0039883a 	mov	fp,zero
8111e57c:	00800084 	movi	r2,2
8111e580:	003fd606 	br	8111e4dc <__reset+0xfb0fe4dc>
8111e584:	9080004c 	andi	r2,r18,1
8111e588:	103f191e 	bne	r2,zero,8111e1f0 <__reset+0xfb0fe1f0>
8111e58c:	d8802117 	ldw	r2,132(sp)
8111e590:	003f2806 	br	8111e234 <__reset+0xfb0fe234>
8111e594:	01204574 	movhi	r4,33045
8111e598:	2126ba84 	addi	r4,r4,-25878
8111e59c:	d9002b15 	stw	r4,172(sp)
8111e5a0:	003c7c06 	br	8111d794 <__reset+0xfb0fd794>
8111e5a4:	e005883a 	mov	r2,fp
8111e5a8:	003f2206 	br	8111e234 <__reset+0xfb0fe234>
8111e5ac:	d9402917 	ldw	r5,164(sp)
8111e5b0:	df002783 	ldbu	fp,158(sp)
8111e5b4:	dd002d15 	stw	r20,180(sp)
8111e5b8:	d9402a15 	stw	r5,168(sp)
8111e5bc:	d9402e15 	stw	r5,184(sp)
8111e5c0:	d8002915 	stw	zero,164(sp)
8111e5c4:	d8003215 	stw	zero,200(sp)
8111e5c8:	003a4c06 	br	8111cefc <__reset+0xfb0fcefc>
8111e5cc:	8c7fff84 	addi	r17,r17,-2
8111e5d0:	b5bfffc4 	addi	r22,r22,-1
8111e5d4:	dd802615 	stw	r22,152(sp)
8111e5d8:	dc4022c5 	stb	r17,139(sp)
8111e5dc:	b000c316 	blt	r22,zero,8111e8ec <___svfprintf_internal_r+0x20b0>
8111e5e0:	00800ac4 	movi	r2,43
8111e5e4:	d8802305 	stb	r2,140(sp)
8111e5e8:	00800244 	movi	r2,9
8111e5ec:	15806e16 	blt	r2,r22,8111e7a8 <___svfprintf_internal_r+0x1f6c>
8111e5f0:	00800c04 	movi	r2,48
8111e5f4:	b5800c04 	addi	r22,r22,48
8111e5f8:	d8802345 	stb	r2,141(sp)
8111e5fc:	dd802385 	stb	r22,142(sp)
8111e600:	d88023c4 	addi	r2,sp,143
8111e604:	df0022c4 	addi	fp,sp,139
8111e608:	d8c03317 	ldw	r3,204(sp)
8111e60c:	1739c83a 	sub	fp,r2,fp
8111e610:	d9003317 	ldw	r4,204(sp)
8111e614:	e0c7883a 	add	r3,fp,r3
8111e618:	df003b15 	stw	fp,236(sp)
8111e61c:	d8c02e15 	stw	r3,184(sp)
8111e620:	00800044 	movi	r2,1
8111e624:	1100b70e 	bge	r2,r4,8111e904 <___svfprintf_internal_r+0x20c8>
8111e628:	d8c02e17 	ldw	r3,184(sp)
8111e62c:	18c00044 	addi	r3,r3,1
8111e630:	d8c02e15 	stw	r3,184(sp)
8111e634:	1805883a 	mov	r2,r3
8111e638:	1800b016 	blt	r3,zero,8111e8fc <___svfprintf_internal_r+0x20c0>
8111e63c:	d8003215 	stw	zero,200(sp)
8111e640:	003f1006 	br	8111e284 <__reset+0xfb0fe284>
8111e644:	d8802917 	ldw	r2,164(sp)
8111e648:	103ec71e 	bne	r2,zero,8111e168 <__reset+0xfb0fe168>
8111e64c:	dc002915 	stw	r16,164(sp)
8111e650:	003ec506 	br	8111e168 <__reset+0xfb0fe168>
8111e654:	d9402c17 	ldw	r5,176(sp)
8111e658:	d9801e04 	addi	r6,sp,120
8111e65c:	9809883a 	mov	r4,r19
8111e660:	112945c0 	call	8112945c <__ssprint_r>
8111e664:	10395c1e 	bne	r2,zero,8111cbd8 <__reset+0xfb0fcbd8>
8111e668:	dc402617 	ldw	r17,152(sp)
8111e66c:	d8c02017 	ldw	r3,128(sp)
8111e670:	d8801f17 	ldw	r2,124(sp)
8111e674:	da000404 	addi	r8,sp,16
8111e678:	003e7706 	br	8111e058 <__reset+0xfb0fe058>
8111e67c:	582f883a 	mov	r23,r11
8111e680:	d8002915 	stw	zero,164(sp)
8111e684:	0038c406 	br	8111c998 <__reset+0xfb0fc998>
8111e688:	d8c02917 	ldw	r3,164(sp)
8111e68c:	d8802104 	addi	r2,sp,132
8111e690:	d8800315 	stw	r2,12(sp)
8111e694:	d9403617 	ldw	r5,216(sp)
8111e698:	d8802504 	addi	r2,sp,148
8111e69c:	d8800215 	stw	r2,8(sp)
8111e6a0:	d8802604 	addi	r2,sp,152
8111e6a4:	d8c00015 	stw	r3,0(sp)
8111e6a8:	9809883a 	mov	r4,r19
8111e6ac:	d8800115 	stw	r2,4(sp)
8111e6b0:	01c000c4 	movi	r7,3
8111e6b4:	a00d883a 	mov	r6,r20
8111e6b8:	da003e15 	stw	r8,248(sp)
8111e6bc:	1122b280 	call	81122b28 <_dtoa_r>
8111e6c0:	d9002917 	ldw	r4,164(sp)
8111e6c4:	da003e17 	ldw	r8,248(sp)
8111e6c8:	1021883a 	mov	r16,r2
8111e6cc:	1139883a 	add	fp,r2,r4
8111e6d0:	2007883a 	mov	r3,r4
8111e6d4:	81000007 	ldb	r4,0(r16)
8111e6d8:	00800c04 	movi	r2,48
8111e6dc:	20806f26 	beq	r4,r2,8111e89c <___svfprintf_internal_r+0x2060>
8111e6e0:	d8c02617 	ldw	r3,152(sp)
8111e6e4:	e0f9883a 	add	fp,fp,r3
8111e6e8:	003ec206 	br	8111e1f4 <__reset+0xfb0fe1f4>
8111e6ec:	00c00b44 	movi	r3,45
8111e6f0:	2520003c 	xorhi	r20,r4,32768
8111e6f4:	d8c02a05 	stb	r3,168(sp)
8111e6f8:	003ea106 	br	8111e180 <__reset+0xfb0fe180>
8111e6fc:	d8c03217 	ldw	r3,200(sp)
8111e700:	00c0890e 	bge	zero,r3,8111e928 <___svfprintf_internal_r+0x20ec>
8111e704:	00800044 	movi	r2,1
8111e708:	d9003317 	ldw	r4,204(sp)
8111e70c:	1105883a 	add	r2,r2,r4
8111e710:	d8802e15 	stw	r2,184(sp)
8111e714:	10005f16 	blt	r2,zero,8111e894 <___svfprintf_internal_r+0x2058>
8111e718:	044019c4 	movi	r17,103
8111e71c:	003ed906 	br	8111e284 <__reset+0xfb0fe284>
8111e720:	d9002917 	ldw	r4,164(sp)
8111e724:	20c00044 	addi	r3,r4,1
8111e728:	003e9c06 	br	8111e19c <__reset+0xfb0fe19c>
8111e72c:	d9002917 	ldw	r4,164(sp)
8111e730:	00c0680e 	bge	zero,r3,8111e8d4 <___svfprintf_internal_r+0x2098>
8111e734:	2000461e 	bne	r4,zero,8111e850 <___svfprintf_internal_r+0x2014>
8111e738:	9480004c 	andi	r18,r18,1
8111e73c:	9000441e 	bne	r18,zero,8111e850 <___svfprintf_internal_r+0x2014>
8111e740:	1805883a 	mov	r2,r3
8111e744:	1800a016 	blt	r3,zero,8111e9c8 <___svfprintf_internal_r+0x218c>
8111e748:	d8c03217 	ldw	r3,200(sp)
8111e74c:	d8c02e15 	stw	r3,184(sp)
8111e750:	003ecc06 	br	8111e284 <__reset+0xfb0fe284>
8111e754:	d9402917 	ldw	r5,164(sp)
8111e758:	d8802104 	addi	r2,sp,132
8111e75c:	d8800315 	stw	r2,12(sp)
8111e760:	d9400015 	stw	r5,0(sp)
8111e764:	d8802504 	addi	r2,sp,148
8111e768:	d9403617 	ldw	r5,216(sp)
8111e76c:	d8800215 	stw	r2,8(sp)
8111e770:	d8802604 	addi	r2,sp,152
8111e774:	d8800115 	stw	r2,4(sp)
8111e778:	01c000c4 	movi	r7,3
8111e77c:	a00d883a 	mov	r6,r20
8111e780:	9809883a 	mov	r4,r19
8111e784:	da003e15 	stw	r8,248(sp)
8111e788:	1122b280 	call	81122b28 <_dtoa_r>
8111e78c:	d8c02917 	ldw	r3,164(sp)
8111e790:	da003e17 	ldw	r8,248(sp)
8111e794:	1021883a 	mov	r16,r2
8111e798:	00801184 	movi	r2,70
8111e79c:	80f9883a 	add	fp,r16,r3
8111e7a0:	88bfcc26 	beq	r17,r2,8111e6d4 <__reset+0xfb0fe6d4>
8111e7a4:	003e9306 	br	8111e1f4 <__reset+0xfb0fe1f4>
8111e7a8:	df0022c4 	addi	fp,sp,139
8111e7ac:	dc002915 	stw	r16,164(sp)
8111e7b0:	9829883a 	mov	r20,r19
8111e7b4:	e021883a 	mov	r16,fp
8111e7b8:	4027883a 	mov	r19,r8
8111e7bc:	b009883a 	mov	r4,r22
8111e7c0:	01400284 	movi	r5,10
8111e7c4:	112df840 	call	8112df84 <__modsi3>
8111e7c8:	10800c04 	addi	r2,r2,48
8111e7cc:	843fffc4 	addi	r16,r16,-1
8111e7d0:	b009883a 	mov	r4,r22
8111e7d4:	01400284 	movi	r5,10
8111e7d8:	80800005 	stb	r2,0(r16)
8111e7dc:	112df000 	call	8112df00 <__divsi3>
8111e7e0:	102d883a 	mov	r22,r2
8111e7e4:	00800244 	movi	r2,9
8111e7e8:	15bff416 	blt	r2,r22,8111e7bc <__reset+0xfb0fe7bc>
8111e7ec:	9811883a 	mov	r8,r19
8111e7f0:	b0800c04 	addi	r2,r22,48
8111e7f4:	a027883a 	mov	r19,r20
8111e7f8:	8029883a 	mov	r20,r16
8111e7fc:	a17fffc4 	addi	r5,r20,-1
8111e800:	a0bfffc5 	stb	r2,-1(r20)
8111e804:	dc002917 	ldw	r16,164(sp)
8111e808:	2f00752e 	bgeu	r5,fp,8111e9e0 <___svfprintf_internal_r+0x21a4>
8111e80c:	d9c02384 	addi	r7,sp,142
8111e810:	3d0fc83a 	sub	r7,r7,r20
8111e814:	d9002344 	addi	r4,sp,141
8111e818:	e1cf883a 	add	r7,fp,r7
8111e81c:	00000106 	br	8111e824 <___svfprintf_internal_r+0x1fe8>
8111e820:	28800003 	ldbu	r2,0(r5)
8111e824:	20800005 	stb	r2,0(r4)
8111e828:	21000044 	addi	r4,r4,1
8111e82c:	29400044 	addi	r5,r5,1
8111e830:	21fffb1e 	bne	r4,r7,8111e820 <__reset+0xfb0fe820>
8111e834:	d8802304 	addi	r2,sp,140
8111e838:	1505c83a 	sub	r2,r2,r20
8111e83c:	d8c02344 	addi	r3,sp,141
8111e840:	1885883a 	add	r2,r3,r2
8111e844:	003f7006 	br	8111e608 <__reset+0xfb0fe608>
8111e848:	0005883a 	mov	r2,zero
8111e84c:	003f0b06 	br	8111e47c <__reset+0xfb0fe47c>
8111e850:	d9002917 	ldw	r4,164(sp)
8111e854:	d8c03217 	ldw	r3,200(sp)
8111e858:	20800044 	addi	r2,r4,1
8111e85c:	1885883a 	add	r2,r3,r2
8111e860:	d8802e15 	stw	r2,184(sp)
8111e864:	103e870e 	bge	r2,zero,8111e284 <__reset+0xfb0fe284>
8111e868:	0005883a 	mov	r2,zero
8111e86c:	003e8506 	br	8111e284 <__reset+0xfb0fe284>
8111e870:	01204574 	movhi	r4,33045
8111e874:	2126ba84 	addi	r4,r4,-25878
8111e878:	d9002b15 	stw	r4,172(sp)
8111e87c:	003cc506 	br	8111db94 <__reset+0xfb0fdb94>
8111e880:	d8c03217 	ldw	r3,200(sp)
8111e884:	18c00044 	addi	r3,r3,1
8111e888:	d8c02e15 	stw	r3,184(sp)
8111e88c:	1805883a 	mov	r2,r3
8111e890:	183fa10e 	bge	r3,zero,8111e718 <__reset+0xfb0fe718>
8111e894:	0005883a 	mov	r2,zero
8111e898:	003f9f06 	br	8111e718 <__reset+0xfb0fe718>
8111e89c:	d9003617 	ldw	r4,216(sp)
8111e8a0:	000d883a 	mov	r6,zero
8111e8a4:	000f883a 	mov	r7,zero
8111e8a8:	a00b883a 	mov	r5,r20
8111e8ac:	d8c03d15 	stw	r3,244(sp)
8111e8b0:	da003e15 	stw	r8,248(sp)
8111e8b4:	112f4540 	call	8112f454 <__eqdf2>
8111e8b8:	d8c03d17 	ldw	r3,244(sp)
8111e8bc:	da003e17 	ldw	r8,248(sp)
8111e8c0:	103f8726 	beq	r2,zero,8111e6e0 <__reset+0xfb0fe6e0>
8111e8c4:	00800044 	movi	r2,1
8111e8c8:	10c7c83a 	sub	r3,r2,r3
8111e8cc:	d8c02615 	stw	r3,152(sp)
8111e8d0:	003f8406 	br	8111e6e4 <__reset+0xfb0fe6e4>
8111e8d4:	20000e1e 	bne	r4,zero,8111e910 <___svfprintf_internal_r+0x20d4>
8111e8d8:	9480004c 	andi	r18,r18,1
8111e8dc:	90000c1e 	bne	r18,zero,8111e910 <___svfprintf_internal_r+0x20d4>
8111e8e0:	00800044 	movi	r2,1
8111e8e4:	d8802e15 	stw	r2,184(sp)
8111e8e8:	003e6606 	br	8111e284 <__reset+0xfb0fe284>
8111e8ec:	00800b44 	movi	r2,45
8111e8f0:	05adc83a 	sub	r22,zero,r22
8111e8f4:	d8802305 	stb	r2,140(sp)
8111e8f8:	003f3b06 	br	8111e5e8 <__reset+0xfb0fe5e8>
8111e8fc:	0005883a 	mov	r2,zero
8111e900:	003f4e06 	br	8111e63c <__reset+0xfb0fe63c>
8111e904:	90a4703a 	and	r18,r18,r2
8111e908:	903f4a26 	beq	r18,zero,8111e634 <__reset+0xfb0fe634>
8111e90c:	003f4606 	br	8111e628 <__reset+0xfb0fe628>
8111e910:	d8c02917 	ldw	r3,164(sp)
8111e914:	18c00084 	addi	r3,r3,2
8111e918:	d8c02e15 	stw	r3,184(sp)
8111e91c:	1805883a 	mov	r2,r3
8111e920:	183e580e 	bge	r3,zero,8111e284 <__reset+0xfb0fe284>
8111e924:	003fd006 	br	8111e868 <__reset+0xfb0fe868>
8111e928:	00800084 	movi	r2,2
8111e92c:	10c5c83a 	sub	r2,r2,r3
8111e930:	003f7506 	br	8111e708 <__reset+0xfb0fe708>
8111e934:	d8802d17 	ldw	r2,180(sp)
8111e938:	d9002d17 	ldw	r4,180(sp)
8111e93c:	bc400043 	ldbu	r17,1(r23)
8111e940:	10800017 	ldw	r2,0(r2)
8111e944:	582f883a 	mov	r23,r11
8111e948:	d8802915 	stw	r2,164(sp)
8111e94c:	20800104 	addi	r2,r4,4
8111e950:	d9002917 	ldw	r4,164(sp)
8111e954:	d8802d15 	stw	r2,180(sp)
8111e958:	203df00e 	bge	r4,zero,8111e11c <__reset+0xfb0fe11c>
8111e95c:	8c403fcc 	andi	r17,r17,255
8111e960:	00bfffc4 	movi	r2,-1
8111e964:	8c40201c 	xori	r17,r17,128
8111e968:	d8802915 	stw	r2,164(sp)
8111e96c:	8c7fe004 	addi	r17,r17,-128
8111e970:	00380806 	br	8111c994 <__reset+0xfb0fc994>
8111e974:	9080004c 	andi	r2,r18,1
8111e978:	0039883a 	mov	fp,zero
8111e97c:	10000726 	beq	r2,zero,8111e99c <___svfprintf_internal_r+0x2160>
8111e980:	d8c02817 	ldw	r3,160(sp)
8111e984:	dc001dc4 	addi	r16,sp,119
8111e988:	00800c04 	movi	r2,48
8111e98c:	1c07c83a 	sub	r3,r3,r16
8111e990:	d8801dc5 	stb	r2,119(sp)
8111e994:	d8c02e15 	stw	r3,184(sp)
8111e998:	00395206 	br	8111cee4 <__reset+0xfb0fcee4>
8111e99c:	d8002e15 	stw	zero,184(sp)
8111e9a0:	dc001e04 	addi	r16,sp,120
8111e9a4:	00394f06 	br	8111cee4 <__reset+0xfb0fcee4>
8111e9a8:	0005883a 	mov	r2,zero
8111e9ac:	003e3206 	br	8111e278 <__reset+0xfb0fe278>
8111e9b0:	dd802617 	ldw	r22,152(sp)
8111e9b4:	003f0606 	br	8111e5d0 <__reset+0xfb0fe5d0>
8111e9b8:	d9c02785 	stb	r7,158(sp)
8111e9bc:	003a5106 	br	8111d304 <__reset+0xfb0fd304>
8111e9c0:	d9c02785 	stb	r7,158(sp)
8111e9c4:	003a3706 	br	8111d2a4 <__reset+0xfb0fd2a4>
8111e9c8:	0005883a 	mov	r2,zero
8111e9cc:	003f5e06 	br	8111e748 <__reset+0xfb0fe748>
8111e9d0:	d9c02785 	stb	r7,158(sp)
8111e9d4:	00391706 	br	8111ce34 <__reset+0xfb0fce34>
8111e9d8:	d9c02785 	stb	r7,158(sp)
8111e9dc:	0038e606 	br	8111cd78 <__reset+0xfb0fcd78>
8111e9e0:	d8802344 	addi	r2,sp,141
8111e9e4:	003f0806 	br	8111e608 <__reset+0xfb0fe608>
8111e9e8:	d9c02785 	stb	r7,158(sp)
8111e9ec:	0038b706 	br	8111cccc <__reset+0xfb0fcccc>
8111e9f0:	d9c02785 	stb	r7,158(sp)
8111e9f4:	003adc06 	br	8111d568 <__reset+0xfb0fd568>
8111e9f8:	d9403917 	ldw	r5,228(sp)
8111e9fc:	00800304 	movi	r2,12
8111ea00:	28800015 	stw	r2,0(r5)
8111ea04:	00bfffc4 	movi	r2,-1
8111ea08:	00387806 	br	8111cbec <__reset+0xfb0fcbec>
8111ea0c:	d9c02785 	stb	r7,158(sp)
8111ea10:	003abf06 	br	8111d510 <__reset+0xfb0fd510>
8111ea14:	d9c02785 	stb	r7,158(sp)
8111ea18:	003a9b06 	br	8111d488 <__reset+0xfb0fd488>

8111ea1c <___vfprintf_internal_r>:
8111ea1c:	deffb804 	addi	sp,sp,-288
8111ea20:	de00012e 	bgeu	sp,et,8111ea28 <___vfprintf_internal_r+0xc>
8111ea24:	003b68fa 	trap	3
8111ea28:	dfc04715 	stw	ra,284(sp)
8111ea2c:	ddc04515 	stw	r23,276(sp)
8111ea30:	dd404315 	stw	r21,268(sp)
8111ea34:	d9002c15 	stw	r4,176(sp)
8111ea38:	282f883a 	mov	r23,r5
8111ea3c:	302b883a 	mov	r21,r6
8111ea40:	d9c02d15 	stw	r7,180(sp)
8111ea44:	df004615 	stw	fp,280(sp)
8111ea48:	dd804415 	stw	r22,272(sp)
8111ea4c:	dd004215 	stw	r20,264(sp)
8111ea50:	dcc04115 	stw	r19,260(sp)
8111ea54:	dc804015 	stw	r18,256(sp)
8111ea58:	dc403f15 	stw	r17,252(sp)
8111ea5c:	dc003e15 	stw	r16,248(sp)
8111ea60:	11257240 	call	81125724 <_localeconv_r>
8111ea64:	10800017 	ldw	r2,0(r2)
8111ea68:	1009883a 	mov	r4,r2
8111ea6c:	d8803415 	stw	r2,208(sp)
8111ea70:	111c5040 	call	8111c504 <strlen>
8111ea74:	d8803715 	stw	r2,220(sp)
8111ea78:	d8802c17 	ldw	r2,176(sp)
8111ea7c:	10000226 	beq	r2,zero,8111ea88 <___vfprintf_internal_r+0x6c>
8111ea80:	10800e17 	ldw	r2,56(r2)
8111ea84:	1000f926 	beq	r2,zero,8111ee6c <___vfprintf_internal_r+0x450>
8111ea88:	b880030b 	ldhu	r2,12(r23)
8111ea8c:	10c8000c 	andi	r3,r2,8192
8111ea90:	1800061e 	bne	r3,zero,8111eaac <___vfprintf_internal_r+0x90>
8111ea94:	b9001917 	ldw	r4,100(r23)
8111ea98:	00f7ffc4 	movi	r3,-8193
8111ea9c:	10880014 	ori	r2,r2,8192
8111eaa0:	20c6703a 	and	r3,r4,r3
8111eaa4:	b880030d 	sth	r2,12(r23)
8111eaa8:	b8c01915 	stw	r3,100(r23)
8111eaac:	10c0020c 	andi	r3,r2,8
8111eab0:	1800c126 	beq	r3,zero,8111edb8 <___vfprintf_internal_r+0x39c>
8111eab4:	b8c00417 	ldw	r3,16(r23)
8111eab8:	1800bf26 	beq	r3,zero,8111edb8 <___vfprintf_internal_r+0x39c>
8111eabc:	1080068c 	andi	r2,r2,26
8111eac0:	00c00284 	movi	r3,10
8111eac4:	10c0c426 	beq	r2,r3,8111edd8 <___vfprintf_internal_r+0x3bc>
8111eac8:	d8c00404 	addi	r3,sp,16
8111eacc:	05204574 	movhi	r20,33045
8111ead0:	d9001e04 	addi	r4,sp,120
8111ead4:	a526c284 	addi	r20,r20,-25846
8111ead8:	d8c01e15 	stw	r3,120(sp)
8111eadc:	d8002015 	stw	zero,128(sp)
8111eae0:	d8001f15 	stw	zero,124(sp)
8111eae4:	d8003315 	stw	zero,204(sp)
8111eae8:	d8003615 	stw	zero,216(sp)
8111eaec:	d8003815 	stw	zero,224(sp)
8111eaf0:	1811883a 	mov	r8,r3
8111eaf4:	d8003915 	stw	zero,228(sp)
8111eaf8:	d8003a15 	stw	zero,232(sp)
8111eafc:	d8002f15 	stw	zero,188(sp)
8111eb00:	d9002815 	stw	r4,160(sp)
8111eb04:	a8800007 	ldb	r2,0(r21)
8111eb08:	10027b26 	beq	r2,zero,8111f4f8 <___vfprintf_internal_r+0xadc>
8111eb0c:	00c00944 	movi	r3,37
8111eb10:	a821883a 	mov	r16,r21
8111eb14:	10c0021e 	bne	r2,r3,8111eb20 <___vfprintf_internal_r+0x104>
8111eb18:	00001406 	br	8111eb6c <___vfprintf_internal_r+0x150>
8111eb1c:	10c00326 	beq	r2,r3,8111eb2c <___vfprintf_internal_r+0x110>
8111eb20:	84000044 	addi	r16,r16,1
8111eb24:	80800007 	ldb	r2,0(r16)
8111eb28:	103ffc1e 	bne	r2,zero,8111eb1c <__reset+0xfb0feb1c>
8111eb2c:	8563c83a 	sub	r17,r16,r21
8111eb30:	88000e26 	beq	r17,zero,8111eb6c <___vfprintf_internal_r+0x150>
8111eb34:	d8c02017 	ldw	r3,128(sp)
8111eb38:	d8801f17 	ldw	r2,124(sp)
8111eb3c:	45400015 	stw	r21,0(r8)
8111eb40:	1c47883a 	add	r3,r3,r17
8111eb44:	10800044 	addi	r2,r2,1
8111eb48:	d8c02015 	stw	r3,128(sp)
8111eb4c:	44400115 	stw	r17,4(r8)
8111eb50:	d8801f15 	stw	r2,124(sp)
8111eb54:	00c001c4 	movi	r3,7
8111eb58:	1880a716 	blt	r3,r2,8111edf8 <___vfprintf_internal_r+0x3dc>
8111eb5c:	42000204 	addi	r8,r8,8
8111eb60:	d9402f17 	ldw	r5,188(sp)
8111eb64:	2c4b883a 	add	r5,r5,r17
8111eb68:	d9402f15 	stw	r5,188(sp)
8111eb6c:	80800007 	ldb	r2,0(r16)
8111eb70:	1000a826 	beq	r2,zero,8111ee14 <___vfprintf_internal_r+0x3f8>
8111eb74:	84400047 	ldb	r17,1(r16)
8111eb78:	00bfffc4 	movi	r2,-1
8111eb7c:	85400044 	addi	r21,r16,1
8111eb80:	d8002785 	stb	zero,158(sp)
8111eb84:	0007883a 	mov	r3,zero
8111eb88:	000f883a 	mov	r7,zero
8111eb8c:	d8802915 	stw	r2,164(sp)
8111eb90:	d8003115 	stw	zero,196(sp)
8111eb94:	0025883a 	mov	r18,zero
8111eb98:	01401604 	movi	r5,88
8111eb9c:	01800244 	movi	r6,9
8111eba0:	02800a84 	movi	r10,42
8111eba4:	02401b04 	movi	r9,108
8111eba8:	ad400044 	addi	r21,r21,1
8111ebac:	88bff804 	addi	r2,r17,-32
8111ebb0:	28830436 	bltu	r5,r2,8111f7c4 <___vfprintf_internal_r+0xda8>
8111ebb4:	100490ba 	slli	r2,r2,2
8111ebb8:	012044b4 	movhi	r4,33042
8111ebbc:	213af304 	addi	r4,r4,-5172
8111ebc0:	1105883a 	add	r2,r2,r4
8111ebc4:	10800017 	ldw	r2,0(r2)
8111ebc8:	1000683a 	jmp	r2
8111ebcc:	8111f6e4 	muli	r4,r16,18395
8111ebd0:	8111f7c4 	addi	r4,r16,18399
8111ebd4:	8111f7c4 	addi	r4,r16,18399
8111ebd8:	8111f704 	addi	r4,r16,18396
8111ebdc:	8111f7c4 	addi	r4,r16,18399
8111ebe0:	8111f7c4 	addi	r4,r16,18399
8111ebe4:	8111f7c4 	addi	r4,r16,18399
8111ebe8:	8111f7c4 	addi	r4,r16,18399
8111ebec:	8111f7c4 	addi	r4,r16,18399
8111ebf0:	8111f7c4 	addi	r4,r16,18399
8111ebf4:	8111ee78 	rdprs	r4,r16,18361
8111ebf8:	8111f620 	cmpeqi	r4,r16,18392
8111ebfc:	8111f7c4 	addi	r4,r16,18399
8111ec00:	8111ed40 	call	88111ed4 <__reset+0x20f1ed4>
8111ec04:	8111eea0 	cmpeqi	r4,r16,18362
8111ec08:	8111f7c4 	addi	r4,r16,18399
8111ec0c:	8111eee0 	cmpeqi	r4,r16,18363
8111ec10:	8111eeec 	andhi	r4,r16,18363
8111ec14:	8111eeec 	andhi	r4,r16,18363
8111ec18:	8111eeec 	andhi	r4,r16,18363
8111ec1c:	8111eeec 	andhi	r4,r16,18363
8111ec20:	8111eeec 	andhi	r4,r16,18363
8111ec24:	8111eeec 	andhi	r4,r16,18363
8111ec28:	8111eeec 	andhi	r4,r16,18363
8111ec2c:	8111eeec 	andhi	r4,r16,18363
8111ec30:	8111eeec 	andhi	r4,r16,18363
8111ec34:	8111f7c4 	addi	r4,r16,18399
8111ec38:	8111f7c4 	addi	r4,r16,18399
8111ec3c:	8111f7c4 	addi	r4,r16,18399
8111ec40:	8111f7c4 	addi	r4,r16,18399
8111ec44:	8111f7c4 	addi	r4,r16,18399
8111ec48:	8111f7c4 	addi	r4,r16,18399
8111ec4c:	8111f7c4 	addi	r4,r16,18399
8111ec50:	8111f7c4 	addi	r4,r16,18399
8111ec54:	8111f7c4 	addi	r4,r16,18399
8111ec58:	8111f7c4 	addi	r4,r16,18399
8111ec5c:	8111ef20 	cmpeqi	r4,r16,18364
8111ec60:	8111efdc 	xori	r4,r16,18367
8111ec64:	8111f7c4 	addi	r4,r16,18399
8111ec68:	8111efdc 	xori	r4,r16,18367
8111ec6c:	8111f7c4 	addi	r4,r16,18399
8111ec70:	8111f7c4 	addi	r4,r16,18399
8111ec74:	8111f7c4 	addi	r4,r16,18399
8111ec78:	8111f7c4 	addi	r4,r16,18399
8111ec7c:	8111f07c 	xorhi	r4,r16,18369
8111ec80:	8111f7c4 	addi	r4,r16,18399
8111ec84:	8111f7c4 	addi	r4,r16,18399
8111ec88:	8111f088 	cmpgei	r4,r16,18370
8111ec8c:	8111f7c4 	addi	r4,r16,18399
8111ec90:	8111f7c4 	addi	r4,r16,18399
8111ec94:	8111f7c4 	addi	r4,r16,18399
8111ec98:	8111f7c4 	addi	r4,r16,18399
8111ec9c:	8111f7c4 	addi	r4,r16,18399
8111eca0:	8111f500 	call	88111f50 <__reset+0x20f1f50>
8111eca4:	8111f7c4 	addi	r4,r16,18399
8111eca8:	8111f7c4 	addi	r4,r16,18399
8111ecac:	8111f560 	cmpeqi	r4,r16,18389
8111ecb0:	8111f7c4 	addi	r4,r16,18399
8111ecb4:	8111f7c4 	addi	r4,r16,18399
8111ecb8:	8111f7c4 	addi	r4,r16,18399
8111ecbc:	8111f7c4 	addi	r4,r16,18399
8111ecc0:	8111f7c4 	addi	r4,r16,18399
8111ecc4:	8111f7c4 	addi	r4,r16,18399
8111ecc8:	8111f7c4 	addi	r4,r16,18399
8111eccc:	8111f7c4 	addi	r4,r16,18399
8111ecd0:	8111f7c4 	addi	r4,r16,18399
8111ecd4:	8111f7c4 	addi	r4,r16,18399
8111ecd8:	8111f770 	cmpltui	r4,r16,18397
8111ecdc:	8111f710 	cmplti	r4,r16,18396
8111ece0:	8111efdc 	xori	r4,r16,18367
8111ece4:	8111efdc 	xori	r4,r16,18367
8111ece8:	8111efdc 	xori	r4,r16,18367
8111ecec:	8111f720 	cmpeqi	r4,r16,18396
8111ecf0:	8111f710 	cmplti	r4,r16,18396
8111ecf4:	8111f7c4 	addi	r4,r16,18399
8111ecf8:	8111f7c4 	addi	r4,r16,18399
8111ecfc:	8111f72c 	andhi	r4,r16,18396
8111ed00:	8111f7c4 	addi	r4,r16,18399
8111ed04:	8111f73c 	xorhi	r4,r16,18396
8111ed08:	8111f610 	cmplti	r4,r16,18392
8111ed0c:	8111ed4c 	andi	r4,r16,18357
8111ed10:	8111f630 	cmpltui	r4,r16,18392
8111ed14:	8111f7c4 	addi	r4,r16,18399
8111ed18:	8111f63c 	xorhi	r4,r16,18392
8111ed1c:	8111f7c4 	addi	r4,r16,18399
8111ed20:	8111f698 	cmpnei	r4,r16,18394
8111ed24:	8111f7c4 	addi	r4,r16,18399
8111ed28:	8111f7c4 	addi	r4,r16,18399
8111ed2c:	8111f6a8 	cmpgeui	r4,r16,18394
8111ed30:	d9003117 	ldw	r4,196(sp)
8111ed34:	d8802d15 	stw	r2,180(sp)
8111ed38:	0109c83a 	sub	r4,zero,r4
8111ed3c:	d9003115 	stw	r4,196(sp)
8111ed40:	94800114 	ori	r18,r18,4
8111ed44:	ac400007 	ldb	r17,0(r21)
8111ed48:	003f9706 	br	8111eba8 <__reset+0xfb0feba8>
8111ed4c:	00800c04 	movi	r2,48
8111ed50:	d9002d17 	ldw	r4,180(sp)
8111ed54:	d9402917 	ldw	r5,164(sp)
8111ed58:	d8802705 	stb	r2,156(sp)
8111ed5c:	00801e04 	movi	r2,120
8111ed60:	d8802745 	stb	r2,157(sp)
8111ed64:	d8002785 	stb	zero,158(sp)
8111ed68:	20c00104 	addi	r3,r4,4
8111ed6c:	24c00017 	ldw	r19,0(r4)
8111ed70:	002d883a 	mov	r22,zero
8111ed74:	90800094 	ori	r2,r18,2
8111ed78:	28029a16 	blt	r5,zero,8111f7e4 <___vfprintf_internal_r+0xdc8>
8111ed7c:	00bfdfc4 	movi	r2,-129
8111ed80:	90a4703a 	and	r18,r18,r2
8111ed84:	d8c02d15 	stw	r3,180(sp)
8111ed88:	94800094 	ori	r18,r18,2
8111ed8c:	9802871e 	bne	r19,zero,8111f7ac <___vfprintf_internal_r+0xd90>
8111ed90:	00a04574 	movhi	r2,33045
8111ed94:	10a6b304 	addi	r2,r2,-25908
8111ed98:	d8803915 	stw	r2,228(sp)
8111ed9c:	04401e04 	movi	r17,120
8111eda0:	d8802917 	ldw	r2,164(sp)
8111eda4:	0039883a 	mov	fp,zero
8111eda8:	1001e926 	beq	r2,zero,8111f550 <___vfprintf_internal_r+0xb34>
8111edac:	0027883a 	mov	r19,zero
8111edb0:	002d883a 	mov	r22,zero
8111edb4:	00020506 	br	8111f5cc <___vfprintf_internal_r+0xbb0>
8111edb8:	d9002c17 	ldw	r4,176(sp)
8111edbc:	b80b883a 	mov	r5,r23
8111edc0:	11227680 	call	81122768 <__swsetup_r>
8111edc4:	1005ac1e 	bne	r2,zero,81120478 <___vfprintf_internal_r+0x1a5c>
8111edc8:	b880030b 	ldhu	r2,12(r23)
8111edcc:	00c00284 	movi	r3,10
8111edd0:	1080068c 	andi	r2,r2,26
8111edd4:	10ff3c1e 	bne	r2,r3,8111eac8 <__reset+0xfb0feac8>
8111edd8:	b880038f 	ldh	r2,14(r23)
8111eddc:	103f3a16 	blt	r2,zero,8111eac8 <__reset+0xfb0feac8>
8111ede0:	d9c02d17 	ldw	r7,180(sp)
8111ede4:	d9002c17 	ldw	r4,176(sp)
8111ede8:	a80d883a 	mov	r6,r21
8111edec:	b80b883a 	mov	r5,r23
8111edf0:	1120c380 	call	81120c38 <__sbprintf>
8111edf4:	00001106 	br	8111ee3c <___vfprintf_internal_r+0x420>
8111edf8:	d9002c17 	ldw	r4,176(sp)
8111edfc:	d9801e04 	addi	r6,sp,120
8111ee00:	b80b883a 	mov	r5,r23
8111ee04:	112ac0c0 	call	8112ac0c <__sprint_r>
8111ee08:	1000081e 	bne	r2,zero,8111ee2c <___vfprintf_internal_r+0x410>
8111ee0c:	da000404 	addi	r8,sp,16
8111ee10:	003f5306 	br	8111eb60 <__reset+0xfb0feb60>
8111ee14:	d8802017 	ldw	r2,128(sp)
8111ee18:	10000426 	beq	r2,zero,8111ee2c <___vfprintf_internal_r+0x410>
8111ee1c:	d9002c17 	ldw	r4,176(sp)
8111ee20:	d9801e04 	addi	r6,sp,120
8111ee24:	b80b883a 	mov	r5,r23
8111ee28:	112ac0c0 	call	8112ac0c <__sprint_r>
8111ee2c:	b880030b 	ldhu	r2,12(r23)
8111ee30:	1080100c 	andi	r2,r2,64
8111ee34:	1005901e 	bne	r2,zero,81120478 <___vfprintf_internal_r+0x1a5c>
8111ee38:	d8802f17 	ldw	r2,188(sp)
8111ee3c:	dfc04717 	ldw	ra,284(sp)
8111ee40:	df004617 	ldw	fp,280(sp)
8111ee44:	ddc04517 	ldw	r23,276(sp)
8111ee48:	dd804417 	ldw	r22,272(sp)
8111ee4c:	dd404317 	ldw	r21,268(sp)
8111ee50:	dd004217 	ldw	r20,264(sp)
8111ee54:	dcc04117 	ldw	r19,260(sp)
8111ee58:	dc804017 	ldw	r18,256(sp)
8111ee5c:	dc403f17 	ldw	r17,252(sp)
8111ee60:	dc003e17 	ldw	r16,248(sp)
8111ee64:	dec04804 	addi	sp,sp,288
8111ee68:	f800283a 	ret
8111ee6c:	d9002c17 	ldw	r4,176(sp)
8111ee70:	11247d80 	call	811247d8 <__sinit>
8111ee74:	003f0406 	br	8111ea88 <__reset+0xfb0fea88>
8111ee78:	d8802d17 	ldw	r2,180(sp)
8111ee7c:	d9002d17 	ldw	r4,180(sp)
8111ee80:	10800017 	ldw	r2,0(r2)
8111ee84:	d8803115 	stw	r2,196(sp)
8111ee88:	20800104 	addi	r2,r4,4
8111ee8c:	d9003117 	ldw	r4,196(sp)
8111ee90:	203fa716 	blt	r4,zero,8111ed30 <__reset+0xfb0fed30>
8111ee94:	d8802d15 	stw	r2,180(sp)
8111ee98:	ac400007 	ldb	r17,0(r21)
8111ee9c:	003f4206 	br	8111eba8 <__reset+0xfb0feba8>
8111eea0:	ac400007 	ldb	r17,0(r21)
8111eea4:	aac00044 	addi	r11,r21,1
8111eea8:	8a872826 	beq	r17,r10,81120b4c <___vfprintf_internal_r+0x2130>
8111eeac:	88bff404 	addi	r2,r17,-48
8111eeb0:	0009883a 	mov	r4,zero
8111eeb4:	30867d36 	bltu	r6,r2,811208ac <___vfprintf_internal_r+0x1e90>
8111eeb8:	5c400007 	ldb	r17,0(r11)
8111eebc:	210002a4 	muli	r4,r4,10
8111eec0:	5d400044 	addi	r21,r11,1
8111eec4:	a817883a 	mov	r11,r21
8111eec8:	2089883a 	add	r4,r4,r2
8111eecc:	88bff404 	addi	r2,r17,-48
8111eed0:	30bff92e 	bgeu	r6,r2,8111eeb8 <__reset+0xfb0feeb8>
8111eed4:	2005c916 	blt	r4,zero,811205fc <___vfprintf_internal_r+0x1be0>
8111eed8:	d9002915 	stw	r4,164(sp)
8111eedc:	003f3306 	br	8111ebac <__reset+0xfb0febac>
8111eee0:	94802014 	ori	r18,r18,128
8111eee4:	ac400007 	ldb	r17,0(r21)
8111eee8:	003f2f06 	br	8111eba8 <__reset+0xfb0feba8>
8111eeec:	a809883a 	mov	r4,r21
8111eef0:	d8003115 	stw	zero,196(sp)
8111eef4:	88bff404 	addi	r2,r17,-48
8111eef8:	0017883a 	mov	r11,zero
8111eefc:	24400007 	ldb	r17,0(r4)
8111ef00:	5ac002a4 	muli	r11,r11,10
8111ef04:	ad400044 	addi	r21,r21,1
8111ef08:	a809883a 	mov	r4,r21
8111ef0c:	12d7883a 	add	r11,r2,r11
8111ef10:	88bff404 	addi	r2,r17,-48
8111ef14:	30bff92e 	bgeu	r6,r2,8111eefc <__reset+0xfb0feefc>
8111ef18:	dac03115 	stw	r11,196(sp)
8111ef1c:	003f2306 	br	8111ebac <__reset+0xfb0febac>
8111ef20:	18c03fcc 	andi	r3,r3,255
8111ef24:	18072b1e 	bne	r3,zero,81120bd4 <___vfprintf_internal_r+0x21b8>
8111ef28:	94800414 	ori	r18,r18,16
8111ef2c:	9080080c 	andi	r2,r18,32
8111ef30:	10037b26 	beq	r2,zero,8111fd20 <___vfprintf_internal_r+0x1304>
8111ef34:	d9402d17 	ldw	r5,180(sp)
8111ef38:	28800117 	ldw	r2,4(r5)
8111ef3c:	2cc00017 	ldw	r19,0(r5)
8111ef40:	29400204 	addi	r5,r5,8
8111ef44:	d9402d15 	stw	r5,180(sp)
8111ef48:	102d883a 	mov	r22,r2
8111ef4c:	10044b16 	blt	r2,zero,8112007c <___vfprintf_internal_r+0x1660>
8111ef50:	d9402917 	ldw	r5,164(sp)
8111ef54:	df002783 	ldbu	fp,158(sp)
8111ef58:	2803bc16 	blt	r5,zero,8111fe4c <___vfprintf_internal_r+0x1430>
8111ef5c:	00ffdfc4 	movi	r3,-129
8111ef60:	9d84b03a 	or	r2,r19,r22
8111ef64:	90e4703a 	and	r18,r18,r3
8111ef68:	10017726 	beq	r2,zero,8111f548 <___vfprintf_internal_r+0xb2c>
8111ef6c:	b0038326 	beq	r22,zero,8111fd7c <___vfprintf_internal_r+0x1360>
8111ef70:	dc402a15 	stw	r17,168(sp)
8111ef74:	dc001e04 	addi	r16,sp,120
8111ef78:	b023883a 	mov	r17,r22
8111ef7c:	402d883a 	mov	r22,r8
8111ef80:	9809883a 	mov	r4,r19
8111ef84:	880b883a 	mov	r5,r17
8111ef88:	01800284 	movi	r6,10
8111ef8c:	000f883a 	mov	r7,zero
8111ef90:	112d9c00 	call	8112d9c0 <__umoddi3>
8111ef94:	10800c04 	addi	r2,r2,48
8111ef98:	843fffc4 	addi	r16,r16,-1
8111ef9c:	9809883a 	mov	r4,r19
8111efa0:	880b883a 	mov	r5,r17
8111efa4:	80800005 	stb	r2,0(r16)
8111efa8:	01800284 	movi	r6,10
8111efac:	000f883a 	mov	r7,zero
8111efb0:	112d4400 	call	8112d440 <__udivdi3>
8111efb4:	1027883a 	mov	r19,r2
8111efb8:	10c4b03a 	or	r2,r2,r3
8111efbc:	1823883a 	mov	r17,r3
8111efc0:	103fef1e 	bne	r2,zero,8111ef80 <__reset+0xfb0fef80>
8111efc4:	d8c02817 	ldw	r3,160(sp)
8111efc8:	dc402a17 	ldw	r17,168(sp)
8111efcc:	b011883a 	mov	r8,r22
8111efd0:	1c07c83a 	sub	r3,r3,r16
8111efd4:	d8c02e15 	stw	r3,184(sp)
8111efd8:	00005906 	br	8111f140 <___vfprintf_internal_r+0x724>
8111efdc:	18c03fcc 	andi	r3,r3,255
8111efe0:	1806fa1e 	bne	r3,zero,81120bcc <___vfprintf_internal_r+0x21b0>
8111efe4:	9080020c 	andi	r2,r18,8
8111efe8:	10048a26 	beq	r2,zero,81120214 <___vfprintf_internal_r+0x17f8>
8111efec:	d8c02d17 	ldw	r3,180(sp)
8111eff0:	d9002d17 	ldw	r4,180(sp)
8111eff4:	d9402d17 	ldw	r5,180(sp)
8111eff8:	18c00017 	ldw	r3,0(r3)
8111effc:	21000117 	ldw	r4,4(r4)
8111f000:	29400204 	addi	r5,r5,8
8111f004:	d8c03615 	stw	r3,216(sp)
8111f008:	d9003815 	stw	r4,224(sp)
8111f00c:	d9402d15 	stw	r5,180(sp)
8111f010:	d9003617 	ldw	r4,216(sp)
8111f014:	d9403817 	ldw	r5,224(sp)
8111f018:	da003d15 	stw	r8,244(sp)
8111f01c:	04000044 	movi	r16,1
8111f020:	11272700 	call	81127270 <__fpclassifyd>
8111f024:	da003d17 	ldw	r8,244(sp)
8111f028:	14041f1e 	bne	r2,r16,811200a8 <___vfprintf_internal_r+0x168c>
8111f02c:	d9003617 	ldw	r4,216(sp)
8111f030:	d9403817 	ldw	r5,224(sp)
8111f034:	000d883a 	mov	r6,zero
8111f038:	000f883a 	mov	r7,zero
8111f03c:	112f5b80 	call	8112f5b8 <__ledf2>
8111f040:	da003d17 	ldw	r8,244(sp)
8111f044:	1005be16 	blt	r2,zero,81120740 <___vfprintf_internal_r+0x1d24>
8111f048:	df002783 	ldbu	fp,158(sp)
8111f04c:	008011c4 	movi	r2,71
8111f050:	1445330e 	bge	r2,r17,81120520 <___vfprintf_internal_r+0x1b04>
8111f054:	04204574 	movhi	r16,33045
8111f058:	8426ab04 	addi	r16,r16,-25940
8111f05c:	00c000c4 	movi	r3,3
8111f060:	00bfdfc4 	movi	r2,-129
8111f064:	d8c02a15 	stw	r3,168(sp)
8111f068:	90a4703a 	and	r18,r18,r2
8111f06c:	d8c02e15 	stw	r3,184(sp)
8111f070:	d8002915 	stw	zero,164(sp)
8111f074:	d8003215 	stw	zero,200(sp)
8111f078:	00003706 	br	8111f158 <___vfprintf_internal_r+0x73c>
8111f07c:	94800214 	ori	r18,r18,8
8111f080:	ac400007 	ldb	r17,0(r21)
8111f084:	003ec806 	br	8111eba8 <__reset+0xfb0feba8>
8111f088:	18c03fcc 	andi	r3,r3,255
8111f08c:	1806db1e 	bne	r3,zero,81120bfc <___vfprintf_internal_r+0x21e0>
8111f090:	94800414 	ori	r18,r18,16
8111f094:	9080080c 	andi	r2,r18,32
8111f098:	1002d826 	beq	r2,zero,8111fbfc <___vfprintf_internal_r+0x11e0>
8111f09c:	d9402d17 	ldw	r5,180(sp)
8111f0a0:	d8c02917 	ldw	r3,164(sp)
8111f0a4:	d8002785 	stb	zero,158(sp)
8111f0a8:	28800204 	addi	r2,r5,8
8111f0ac:	2cc00017 	ldw	r19,0(r5)
8111f0b0:	2d800117 	ldw	r22,4(r5)
8111f0b4:	18048f16 	blt	r3,zero,811202f4 <___vfprintf_internal_r+0x18d8>
8111f0b8:	013fdfc4 	movi	r4,-129
8111f0bc:	9d86b03a 	or	r3,r19,r22
8111f0c0:	d8802d15 	stw	r2,180(sp)
8111f0c4:	9124703a 	and	r18,r18,r4
8111f0c8:	1802d91e 	bne	r3,zero,8111fc30 <___vfprintf_internal_r+0x1214>
8111f0cc:	d8c02917 	ldw	r3,164(sp)
8111f0d0:	0039883a 	mov	fp,zero
8111f0d4:	1805c326 	beq	r3,zero,811207e4 <___vfprintf_internal_r+0x1dc8>
8111f0d8:	0027883a 	mov	r19,zero
8111f0dc:	002d883a 	mov	r22,zero
8111f0e0:	dc001e04 	addi	r16,sp,120
8111f0e4:	9806d0fa 	srli	r3,r19,3
8111f0e8:	b008977a 	slli	r4,r22,29
8111f0ec:	b02cd0fa 	srli	r22,r22,3
8111f0f0:	9cc001cc 	andi	r19,r19,7
8111f0f4:	98800c04 	addi	r2,r19,48
8111f0f8:	843fffc4 	addi	r16,r16,-1
8111f0fc:	20e6b03a 	or	r19,r4,r3
8111f100:	80800005 	stb	r2,0(r16)
8111f104:	9d86b03a 	or	r3,r19,r22
8111f108:	183ff61e 	bne	r3,zero,8111f0e4 <__reset+0xfb0ff0e4>
8111f10c:	90c0004c 	andi	r3,r18,1
8111f110:	18013b26 	beq	r3,zero,8111f600 <___vfprintf_internal_r+0xbe4>
8111f114:	10803fcc 	andi	r2,r2,255
8111f118:	1080201c 	xori	r2,r2,128
8111f11c:	10bfe004 	addi	r2,r2,-128
8111f120:	00c00c04 	movi	r3,48
8111f124:	10c13626 	beq	r2,r3,8111f600 <___vfprintf_internal_r+0xbe4>
8111f128:	80ffffc5 	stb	r3,-1(r16)
8111f12c:	d8c02817 	ldw	r3,160(sp)
8111f130:	80bfffc4 	addi	r2,r16,-1
8111f134:	1021883a 	mov	r16,r2
8111f138:	1887c83a 	sub	r3,r3,r2
8111f13c:	d8c02e15 	stw	r3,184(sp)
8111f140:	d8802e17 	ldw	r2,184(sp)
8111f144:	d9002917 	ldw	r4,164(sp)
8111f148:	1100010e 	bge	r2,r4,8111f150 <___vfprintf_internal_r+0x734>
8111f14c:	2005883a 	mov	r2,r4
8111f150:	d8802a15 	stw	r2,168(sp)
8111f154:	d8003215 	stw	zero,200(sp)
8111f158:	e7003fcc 	andi	fp,fp,255
8111f15c:	e700201c 	xori	fp,fp,128
8111f160:	e73fe004 	addi	fp,fp,-128
8111f164:	e0000326 	beq	fp,zero,8111f174 <___vfprintf_internal_r+0x758>
8111f168:	d8c02a17 	ldw	r3,168(sp)
8111f16c:	18c00044 	addi	r3,r3,1
8111f170:	d8c02a15 	stw	r3,168(sp)
8111f174:	90c0008c 	andi	r3,r18,2
8111f178:	d8c02b15 	stw	r3,172(sp)
8111f17c:	18000326 	beq	r3,zero,8111f18c <___vfprintf_internal_r+0x770>
8111f180:	d8c02a17 	ldw	r3,168(sp)
8111f184:	18c00084 	addi	r3,r3,2
8111f188:	d8c02a15 	stw	r3,168(sp)
8111f18c:	90c0210c 	andi	r3,r18,132
8111f190:	d8c03015 	stw	r3,192(sp)
8111f194:	1801a31e 	bne	r3,zero,8111f824 <___vfprintf_internal_r+0xe08>
8111f198:	d9003117 	ldw	r4,196(sp)
8111f19c:	d8c02a17 	ldw	r3,168(sp)
8111f1a0:	20e7c83a 	sub	r19,r4,r3
8111f1a4:	04c19f0e 	bge	zero,r19,8111f824 <___vfprintf_internal_r+0xe08>
8111f1a8:	02400404 	movi	r9,16
8111f1ac:	d8c02017 	ldw	r3,128(sp)
8111f1b0:	d8801f17 	ldw	r2,124(sp)
8111f1b4:	4cc50d0e 	bge	r9,r19,811205ec <___vfprintf_internal_r+0x1bd0>
8111f1b8:	01604574 	movhi	r5,33045
8111f1bc:	2966c684 	addi	r5,r5,-25830
8111f1c0:	dc403b15 	stw	r17,236(sp)
8111f1c4:	d9403515 	stw	r5,212(sp)
8111f1c8:	9823883a 	mov	r17,r19
8111f1cc:	482d883a 	mov	r22,r9
8111f1d0:	9027883a 	mov	r19,r18
8111f1d4:	070001c4 	movi	fp,7
8111f1d8:	8025883a 	mov	r18,r16
8111f1dc:	dc002c17 	ldw	r16,176(sp)
8111f1e0:	00000306 	br	8111f1f0 <___vfprintf_internal_r+0x7d4>
8111f1e4:	8c7ffc04 	addi	r17,r17,-16
8111f1e8:	42000204 	addi	r8,r8,8
8111f1ec:	b440130e 	bge	r22,r17,8111f23c <___vfprintf_internal_r+0x820>
8111f1f0:	01204574 	movhi	r4,33045
8111f1f4:	18c00404 	addi	r3,r3,16
8111f1f8:	10800044 	addi	r2,r2,1
8111f1fc:	2126c684 	addi	r4,r4,-25830
8111f200:	41000015 	stw	r4,0(r8)
8111f204:	45800115 	stw	r22,4(r8)
8111f208:	d8c02015 	stw	r3,128(sp)
8111f20c:	d8801f15 	stw	r2,124(sp)
8111f210:	e0bff40e 	bge	fp,r2,8111f1e4 <__reset+0xfb0ff1e4>
8111f214:	d9801e04 	addi	r6,sp,120
8111f218:	b80b883a 	mov	r5,r23
8111f21c:	8009883a 	mov	r4,r16
8111f220:	112ac0c0 	call	8112ac0c <__sprint_r>
8111f224:	103f011e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111f228:	8c7ffc04 	addi	r17,r17,-16
8111f22c:	d8c02017 	ldw	r3,128(sp)
8111f230:	d8801f17 	ldw	r2,124(sp)
8111f234:	da000404 	addi	r8,sp,16
8111f238:	b47fed16 	blt	r22,r17,8111f1f0 <__reset+0xfb0ff1f0>
8111f23c:	9021883a 	mov	r16,r18
8111f240:	9825883a 	mov	r18,r19
8111f244:	8827883a 	mov	r19,r17
8111f248:	dc403b17 	ldw	r17,236(sp)
8111f24c:	d9403517 	ldw	r5,212(sp)
8111f250:	98c7883a 	add	r3,r19,r3
8111f254:	10800044 	addi	r2,r2,1
8111f258:	41400015 	stw	r5,0(r8)
8111f25c:	44c00115 	stw	r19,4(r8)
8111f260:	d8c02015 	stw	r3,128(sp)
8111f264:	d8801f15 	stw	r2,124(sp)
8111f268:	010001c4 	movi	r4,7
8111f26c:	2082a316 	blt	r4,r2,8111fcfc <___vfprintf_internal_r+0x12e0>
8111f270:	df002787 	ldb	fp,158(sp)
8111f274:	42000204 	addi	r8,r8,8
8111f278:	e0000c26 	beq	fp,zero,8111f2ac <___vfprintf_internal_r+0x890>
8111f27c:	d8801f17 	ldw	r2,124(sp)
8111f280:	d9002784 	addi	r4,sp,158
8111f284:	18c00044 	addi	r3,r3,1
8111f288:	10800044 	addi	r2,r2,1
8111f28c:	41000015 	stw	r4,0(r8)
8111f290:	01000044 	movi	r4,1
8111f294:	41000115 	stw	r4,4(r8)
8111f298:	d8c02015 	stw	r3,128(sp)
8111f29c:	d8801f15 	stw	r2,124(sp)
8111f2a0:	010001c4 	movi	r4,7
8111f2a4:	20823c16 	blt	r4,r2,8111fb98 <___vfprintf_internal_r+0x117c>
8111f2a8:	42000204 	addi	r8,r8,8
8111f2ac:	d8802b17 	ldw	r2,172(sp)
8111f2b0:	10000c26 	beq	r2,zero,8111f2e4 <___vfprintf_internal_r+0x8c8>
8111f2b4:	d8801f17 	ldw	r2,124(sp)
8111f2b8:	d9002704 	addi	r4,sp,156
8111f2bc:	18c00084 	addi	r3,r3,2
8111f2c0:	10800044 	addi	r2,r2,1
8111f2c4:	41000015 	stw	r4,0(r8)
8111f2c8:	01000084 	movi	r4,2
8111f2cc:	41000115 	stw	r4,4(r8)
8111f2d0:	d8c02015 	stw	r3,128(sp)
8111f2d4:	d8801f15 	stw	r2,124(sp)
8111f2d8:	010001c4 	movi	r4,7
8111f2dc:	20823616 	blt	r4,r2,8111fbb8 <___vfprintf_internal_r+0x119c>
8111f2e0:	42000204 	addi	r8,r8,8
8111f2e4:	d9003017 	ldw	r4,192(sp)
8111f2e8:	00802004 	movi	r2,128
8111f2ec:	20819926 	beq	r4,r2,8111f954 <___vfprintf_internal_r+0xf38>
8111f2f0:	d9402917 	ldw	r5,164(sp)
8111f2f4:	d8802e17 	ldw	r2,184(sp)
8111f2f8:	28adc83a 	sub	r22,r5,r2
8111f2fc:	0580310e 	bge	zero,r22,8111f3c4 <___vfprintf_internal_r+0x9a8>
8111f300:	07000404 	movi	fp,16
8111f304:	d8801f17 	ldw	r2,124(sp)
8111f308:	e584140e 	bge	fp,r22,8112035c <___vfprintf_internal_r+0x1940>
8111f30c:	01604574 	movhi	r5,33045
8111f310:	2966c284 	addi	r5,r5,-25846
8111f314:	dc402915 	stw	r17,164(sp)
8111f318:	d9402b15 	stw	r5,172(sp)
8111f31c:	b023883a 	mov	r17,r22
8111f320:	04c001c4 	movi	r19,7
8111f324:	a82d883a 	mov	r22,r21
8111f328:	902b883a 	mov	r21,r18
8111f32c:	8025883a 	mov	r18,r16
8111f330:	dc002c17 	ldw	r16,176(sp)
8111f334:	00000306 	br	8111f344 <___vfprintf_internal_r+0x928>
8111f338:	8c7ffc04 	addi	r17,r17,-16
8111f33c:	42000204 	addi	r8,r8,8
8111f340:	e440110e 	bge	fp,r17,8111f388 <___vfprintf_internal_r+0x96c>
8111f344:	18c00404 	addi	r3,r3,16
8111f348:	10800044 	addi	r2,r2,1
8111f34c:	45000015 	stw	r20,0(r8)
8111f350:	47000115 	stw	fp,4(r8)
8111f354:	d8c02015 	stw	r3,128(sp)
8111f358:	d8801f15 	stw	r2,124(sp)
8111f35c:	98bff60e 	bge	r19,r2,8111f338 <__reset+0xfb0ff338>
8111f360:	d9801e04 	addi	r6,sp,120
8111f364:	b80b883a 	mov	r5,r23
8111f368:	8009883a 	mov	r4,r16
8111f36c:	112ac0c0 	call	8112ac0c <__sprint_r>
8111f370:	103eae1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111f374:	8c7ffc04 	addi	r17,r17,-16
8111f378:	d8c02017 	ldw	r3,128(sp)
8111f37c:	d8801f17 	ldw	r2,124(sp)
8111f380:	da000404 	addi	r8,sp,16
8111f384:	e47fef16 	blt	fp,r17,8111f344 <__reset+0xfb0ff344>
8111f388:	9021883a 	mov	r16,r18
8111f38c:	a825883a 	mov	r18,r21
8111f390:	b02b883a 	mov	r21,r22
8111f394:	882d883a 	mov	r22,r17
8111f398:	dc402917 	ldw	r17,164(sp)
8111f39c:	d9002b17 	ldw	r4,172(sp)
8111f3a0:	1d87883a 	add	r3,r3,r22
8111f3a4:	10800044 	addi	r2,r2,1
8111f3a8:	41000015 	stw	r4,0(r8)
8111f3ac:	45800115 	stw	r22,4(r8)
8111f3b0:	d8c02015 	stw	r3,128(sp)
8111f3b4:	d8801f15 	stw	r2,124(sp)
8111f3b8:	010001c4 	movi	r4,7
8111f3bc:	2081ee16 	blt	r4,r2,8111fb78 <___vfprintf_internal_r+0x115c>
8111f3c0:	42000204 	addi	r8,r8,8
8111f3c4:	9080400c 	andi	r2,r18,256
8111f3c8:	1001181e 	bne	r2,zero,8111f82c <___vfprintf_internal_r+0xe10>
8111f3cc:	d9402e17 	ldw	r5,184(sp)
8111f3d0:	d8801f17 	ldw	r2,124(sp)
8111f3d4:	44000015 	stw	r16,0(r8)
8111f3d8:	1947883a 	add	r3,r3,r5
8111f3dc:	10800044 	addi	r2,r2,1
8111f3e0:	41400115 	stw	r5,4(r8)
8111f3e4:	d8c02015 	stw	r3,128(sp)
8111f3e8:	d8801f15 	stw	r2,124(sp)
8111f3ec:	010001c4 	movi	r4,7
8111f3f0:	2081d316 	blt	r4,r2,8111fb40 <___vfprintf_internal_r+0x1124>
8111f3f4:	42000204 	addi	r8,r8,8
8111f3f8:	9480010c 	andi	r18,r18,4
8111f3fc:	90003226 	beq	r18,zero,8111f4c8 <___vfprintf_internal_r+0xaac>
8111f400:	d9403117 	ldw	r5,196(sp)
8111f404:	d8802a17 	ldw	r2,168(sp)
8111f408:	28a1c83a 	sub	r16,r5,r2
8111f40c:	04002e0e 	bge	zero,r16,8111f4c8 <___vfprintf_internal_r+0xaac>
8111f410:	04400404 	movi	r17,16
8111f414:	d8801f17 	ldw	r2,124(sp)
8111f418:	8c04a20e 	bge	r17,r16,811206a4 <___vfprintf_internal_r+0x1c88>
8111f41c:	01604574 	movhi	r5,33045
8111f420:	2966c684 	addi	r5,r5,-25830
8111f424:	d9403515 	stw	r5,212(sp)
8111f428:	048001c4 	movi	r18,7
8111f42c:	dcc02c17 	ldw	r19,176(sp)
8111f430:	00000306 	br	8111f440 <___vfprintf_internal_r+0xa24>
8111f434:	843ffc04 	addi	r16,r16,-16
8111f438:	42000204 	addi	r8,r8,8
8111f43c:	8c00130e 	bge	r17,r16,8111f48c <___vfprintf_internal_r+0xa70>
8111f440:	01204574 	movhi	r4,33045
8111f444:	18c00404 	addi	r3,r3,16
8111f448:	10800044 	addi	r2,r2,1
8111f44c:	2126c684 	addi	r4,r4,-25830
8111f450:	41000015 	stw	r4,0(r8)
8111f454:	44400115 	stw	r17,4(r8)
8111f458:	d8c02015 	stw	r3,128(sp)
8111f45c:	d8801f15 	stw	r2,124(sp)
8111f460:	90bff40e 	bge	r18,r2,8111f434 <__reset+0xfb0ff434>
8111f464:	d9801e04 	addi	r6,sp,120
8111f468:	b80b883a 	mov	r5,r23
8111f46c:	9809883a 	mov	r4,r19
8111f470:	112ac0c0 	call	8112ac0c <__sprint_r>
8111f474:	103e6d1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111f478:	843ffc04 	addi	r16,r16,-16
8111f47c:	d8c02017 	ldw	r3,128(sp)
8111f480:	d8801f17 	ldw	r2,124(sp)
8111f484:	da000404 	addi	r8,sp,16
8111f488:	8c3fed16 	blt	r17,r16,8111f440 <__reset+0xfb0ff440>
8111f48c:	d9403517 	ldw	r5,212(sp)
8111f490:	1c07883a 	add	r3,r3,r16
8111f494:	10800044 	addi	r2,r2,1
8111f498:	41400015 	stw	r5,0(r8)
8111f49c:	44000115 	stw	r16,4(r8)
8111f4a0:	d8c02015 	stw	r3,128(sp)
8111f4a4:	d8801f15 	stw	r2,124(sp)
8111f4a8:	010001c4 	movi	r4,7
8111f4ac:	2080060e 	bge	r4,r2,8111f4c8 <___vfprintf_internal_r+0xaac>
8111f4b0:	d9002c17 	ldw	r4,176(sp)
8111f4b4:	d9801e04 	addi	r6,sp,120
8111f4b8:	b80b883a 	mov	r5,r23
8111f4bc:	112ac0c0 	call	8112ac0c <__sprint_r>
8111f4c0:	103e5a1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111f4c4:	d8c02017 	ldw	r3,128(sp)
8111f4c8:	d8803117 	ldw	r2,196(sp)
8111f4cc:	d9002a17 	ldw	r4,168(sp)
8111f4d0:	1100010e 	bge	r2,r4,8111f4d8 <___vfprintf_internal_r+0xabc>
8111f4d4:	2005883a 	mov	r2,r4
8111f4d8:	d9402f17 	ldw	r5,188(sp)
8111f4dc:	288b883a 	add	r5,r5,r2
8111f4e0:	d9402f15 	stw	r5,188(sp)
8111f4e4:	18019e1e 	bne	r3,zero,8111fb60 <___vfprintf_internal_r+0x1144>
8111f4e8:	a8800007 	ldb	r2,0(r21)
8111f4ec:	d8001f15 	stw	zero,124(sp)
8111f4f0:	da000404 	addi	r8,sp,16
8111f4f4:	103d851e 	bne	r2,zero,8111eb0c <__reset+0xfb0feb0c>
8111f4f8:	a821883a 	mov	r16,r21
8111f4fc:	003d9b06 	br	8111eb6c <__reset+0xfb0feb6c>
8111f500:	18c03fcc 	andi	r3,r3,255
8111f504:	1805c11e 	bne	r3,zero,81120c0c <___vfprintf_internal_r+0x21f0>
8111f508:	94800414 	ori	r18,r18,16
8111f50c:	9080080c 	andi	r2,r18,32
8111f510:	10020c26 	beq	r2,zero,8111fd44 <___vfprintf_internal_r+0x1328>
8111f514:	d8802d17 	ldw	r2,180(sp)
8111f518:	d9002917 	ldw	r4,164(sp)
8111f51c:	d8002785 	stb	zero,158(sp)
8111f520:	10c00204 	addi	r3,r2,8
8111f524:	14c00017 	ldw	r19,0(r2)
8111f528:	15800117 	ldw	r22,4(r2)
8111f52c:	20040f16 	blt	r4,zero,8112056c <___vfprintf_internal_r+0x1b50>
8111f530:	013fdfc4 	movi	r4,-129
8111f534:	9d84b03a 	or	r2,r19,r22
8111f538:	d8c02d15 	stw	r3,180(sp)
8111f53c:	9124703a 	and	r18,r18,r4
8111f540:	0039883a 	mov	fp,zero
8111f544:	103e891e 	bne	r2,zero,8111ef6c <__reset+0xfb0fef6c>
8111f548:	d9002917 	ldw	r4,164(sp)
8111f54c:	2002c11e 	bne	r4,zero,81120054 <___vfprintf_internal_r+0x1638>
8111f550:	d8002915 	stw	zero,164(sp)
8111f554:	d8002e15 	stw	zero,184(sp)
8111f558:	dc001e04 	addi	r16,sp,120
8111f55c:	003ef806 	br	8111f140 <__reset+0xfb0ff140>
8111f560:	18c03fcc 	andi	r3,r3,255
8111f564:	18059d1e 	bne	r3,zero,81120bdc <___vfprintf_internal_r+0x21c0>
8111f568:	01604574 	movhi	r5,33045
8111f56c:	2966ae04 	addi	r5,r5,-25928
8111f570:	d9403915 	stw	r5,228(sp)
8111f574:	9080080c 	andi	r2,r18,32
8111f578:	10005226 	beq	r2,zero,8111f6c4 <___vfprintf_internal_r+0xca8>
8111f57c:	d8802d17 	ldw	r2,180(sp)
8111f580:	14c00017 	ldw	r19,0(r2)
8111f584:	15800117 	ldw	r22,4(r2)
8111f588:	10800204 	addi	r2,r2,8
8111f58c:	d8802d15 	stw	r2,180(sp)
8111f590:	9080004c 	andi	r2,r18,1
8111f594:	10019026 	beq	r2,zero,8111fbd8 <___vfprintf_internal_r+0x11bc>
8111f598:	9d84b03a 	or	r2,r19,r22
8111f59c:	10036926 	beq	r2,zero,81120344 <___vfprintf_internal_r+0x1928>
8111f5a0:	d8c02917 	ldw	r3,164(sp)
8111f5a4:	00800c04 	movi	r2,48
8111f5a8:	d8802705 	stb	r2,156(sp)
8111f5ac:	dc402745 	stb	r17,157(sp)
8111f5b0:	d8002785 	stb	zero,158(sp)
8111f5b4:	90800094 	ori	r2,r18,2
8111f5b8:	18045d16 	blt	r3,zero,81120730 <___vfprintf_internal_r+0x1d14>
8111f5bc:	00bfdfc4 	movi	r2,-129
8111f5c0:	90a4703a 	and	r18,r18,r2
8111f5c4:	94800094 	ori	r18,r18,2
8111f5c8:	0039883a 	mov	fp,zero
8111f5cc:	d9003917 	ldw	r4,228(sp)
8111f5d0:	dc001e04 	addi	r16,sp,120
8111f5d4:	988003cc 	andi	r2,r19,15
8111f5d8:	b006973a 	slli	r3,r22,28
8111f5dc:	2085883a 	add	r2,r4,r2
8111f5e0:	9826d13a 	srli	r19,r19,4
8111f5e4:	10800003 	ldbu	r2,0(r2)
8111f5e8:	b02cd13a 	srli	r22,r22,4
8111f5ec:	843fffc4 	addi	r16,r16,-1
8111f5f0:	1ce6b03a 	or	r19,r3,r19
8111f5f4:	80800005 	stb	r2,0(r16)
8111f5f8:	9d84b03a 	or	r2,r19,r22
8111f5fc:	103ff51e 	bne	r2,zero,8111f5d4 <__reset+0xfb0ff5d4>
8111f600:	d8c02817 	ldw	r3,160(sp)
8111f604:	1c07c83a 	sub	r3,r3,r16
8111f608:	d8c02e15 	stw	r3,184(sp)
8111f60c:	003ecc06 	br	8111f140 <__reset+0xfb0ff140>
8111f610:	18c03fcc 	andi	r3,r3,255
8111f614:	183e9f26 	beq	r3,zero,8111f094 <__reset+0xfb0ff094>
8111f618:	d9c02785 	stb	r7,158(sp)
8111f61c:	003e9d06 	br	8111f094 <__reset+0xfb0ff094>
8111f620:	00c00044 	movi	r3,1
8111f624:	01c00ac4 	movi	r7,43
8111f628:	ac400007 	ldb	r17,0(r21)
8111f62c:	003d5e06 	br	8111eba8 <__reset+0xfb0feba8>
8111f630:	94800814 	ori	r18,r18,32
8111f634:	ac400007 	ldb	r17,0(r21)
8111f638:	003d5b06 	br	8111eba8 <__reset+0xfb0feba8>
8111f63c:	d8c02d17 	ldw	r3,180(sp)
8111f640:	d8002785 	stb	zero,158(sp)
8111f644:	1c000017 	ldw	r16,0(r3)
8111f648:	1cc00104 	addi	r19,r3,4
8111f64c:	80041926 	beq	r16,zero,811206b4 <___vfprintf_internal_r+0x1c98>
8111f650:	d9002917 	ldw	r4,164(sp)
8111f654:	2003d016 	blt	r4,zero,81120598 <___vfprintf_internal_r+0x1b7c>
8111f658:	200d883a 	mov	r6,r4
8111f65c:	000b883a 	mov	r5,zero
8111f660:	8009883a 	mov	r4,r16
8111f664:	da003d15 	stw	r8,244(sp)
8111f668:	1125a000 	call	81125a00 <memchr>
8111f66c:	da003d17 	ldw	r8,244(sp)
8111f670:	10045426 	beq	r2,zero,811207c4 <___vfprintf_internal_r+0x1da8>
8111f674:	1405c83a 	sub	r2,r2,r16
8111f678:	d8802e15 	stw	r2,184(sp)
8111f67c:	1003cc16 	blt	r2,zero,811205b0 <___vfprintf_internal_r+0x1b94>
8111f680:	df002783 	ldbu	fp,158(sp)
8111f684:	d8802a15 	stw	r2,168(sp)
8111f688:	dcc02d15 	stw	r19,180(sp)
8111f68c:	d8002915 	stw	zero,164(sp)
8111f690:	d8003215 	stw	zero,200(sp)
8111f694:	003eb006 	br	8111f158 <__reset+0xfb0ff158>
8111f698:	18c03fcc 	andi	r3,r3,255
8111f69c:	183f9b26 	beq	r3,zero,8111f50c <__reset+0xfb0ff50c>
8111f6a0:	d9c02785 	stb	r7,158(sp)
8111f6a4:	003f9906 	br	8111f50c <__reset+0xfb0ff50c>
8111f6a8:	18c03fcc 	andi	r3,r3,255
8111f6ac:	1805551e 	bne	r3,zero,81120c04 <___vfprintf_internal_r+0x21e8>
8111f6b0:	01604574 	movhi	r5,33045
8111f6b4:	2966b304 	addi	r5,r5,-25908
8111f6b8:	d9403915 	stw	r5,228(sp)
8111f6bc:	9080080c 	andi	r2,r18,32
8111f6c0:	103fae1e 	bne	r2,zero,8111f57c <__reset+0xfb0ff57c>
8111f6c4:	9080040c 	andi	r2,r18,16
8111f6c8:	1002de26 	beq	r2,zero,81120244 <___vfprintf_internal_r+0x1828>
8111f6cc:	d8c02d17 	ldw	r3,180(sp)
8111f6d0:	002d883a 	mov	r22,zero
8111f6d4:	1cc00017 	ldw	r19,0(r3)
8111f6d8:	18c00104 	addi	r3,r3,4
8111f6dc:	d8c02d15 	stw	r3,180(sp)
8111f6e0:	003fab06 	br	8111f590 <__reset+0xfb0ff590>
8111f6e4:	38803fcc 	andi	r2,r7,255
8111f6e8:	1080201c 	xori	r2,r2,128
8111f6ec:	10bfe004 	addi	r2,r2,-128
8111f6f0:	1002d21e 	bne	r2,zero,8112023c <___vfprintf_internal_r+0x1820>
8111f6f4:	00c00044 	movi	r3,1
8111f6f8:	01c00804 	movi	r7,32
8111f6fc:	ac400007 	ldb	r17,0(r21)
8111f700:	003d2906 	br	8111eba8 <__reset+0xfb0feba8>
8111f704:	94800054 	ori	r18,r18,1
8111f708:	ac400007 	ldb	r17,0(r21)
8111f70c:	003d2606 	br	8111eba8 <__reset+0xfb0feba8>
8111f710:	18c03fcc 	andi	r3,r3,255
8111f714:	183e0526 	beq	r3,zero,8111ef2c <__reset+0xfb0fef2c>
8111f718:	d9c02785 	stb	r7,158(sp)
8111f71c:	003e0306 	br	8111ef2c <__reset+0xfb0fef2c>
8111f720:	94801014 	ori	r18,r18,64
8111f724:	ac400007 	ldb	r17,0(r21)
8111f728:	003d1f06 	br	8111eba8 <__reset+0xfb0feba8>
8111f72c:	ac400007 	ldb	r17,0(r21)
8111f730:	8a438726 	beq	r17,r9,81120550 <___vfprintf_internal_r+0x1b34>
8111f734:	94800414 	ori	r18,r18,16
8111f738:	003d1b06 	br	8111eba8 <__reset+0xfb0feba8>
8111f73c:	18c03fcc 	andi	r3,r3,255
8111f740:	1805341e 	bne	r3,zero,81120c14 <___vfprintf_internal_r+0x21f8>
8111f744:	9080080c 	andi	r2,r18,32
8111f748:	1002cd26 	beq	r2,zero,81120280 <___vfprintf_internal_r+0x1864>
8111f74c:	d9402d17 	ldw	r5,180(sp)
8111f750:	d9002f17 	ldw	r4,188(sp)
8111f754:	28800017 	ldw	r2,0(r5)
8111f758:	2007d7fa 	srai	r3,r4,31
8111f75c:	29400104 	addi	r5,r5,4
8111f760:	d9402d15 	stw	r5,180(sp)
8111f764:	11000015 	stw	r4,0(r2)
8111f768:	10c00115 	stw	r3,4(r2)
8111f76c:	003ce506 	br	8111eb04 <__reset+0xfb0feb04>
8111f770:	d8c02d17 	ldw	r3,180(sp)
8111f774:	d9002d17 	ldw	r4,180(sp)
8111f778:	d8002785 	stb	zero,158(sp)
8111f77c:	18800017 	ldw	r2,0(r3)
8111f780:	21000104 	addi	r4,r4,4
8111f784:	00c00044 	movi	r3,1
8111f788:	d8c02a15 	stw	r3,168(sp)
8111f78c:	d8801405 	stb	r2,80(sp)
8111f790:	d9002d15 	stw	r4,180(sp)
8111f794:	d8c02e15 	stw	r3,184(sp)
8111f798:	d8002915 	stw	zero,164(sp)
8111f79c:	d8003215 	stw	zero,200(sp)
8111f7a0:	dc001404 	addi	r16,sp,80
8111f7a4:	0039883a 	mov	fp,zero
8111f7a8:	003e7206 	br	8111f174 <__reset+0xfb0ff174>
8111f7ac:	01204574 	movhi	r4,33045
8111f7b0:	2126b304 	addi	r4,r4,-25908
8111f7b4:	0039883a 	mov	fp,zero
8111f7b8:	d9003915 	stw	r4,228(sp)
8111f7bc:	04401e04 	movi	r17,120
8111f7c0:	003f8206 	br	8111f5cc <__reset+0xfb0ff5cc>
8111f7c4:	18c03fcc 	andi	r3,r3,255
8111f7c8:	1805061e 	bne	r3,zero,81120be4 <___vfprintf_internal_r+0x21c8>
8111f7cc:	883d9126 	beq	r17,zero,8111ee14 <__reset+0xfb0fee14>
8111f7d0:	00c00044 	movi	r3,1
8111f7d4:	d8c02a15 	stw	r3,168(sp)
8111f7d8:	dc401405 	stb	r17,80(sp)
8111f7dc:	d8002785 	stb	zero,158(sp)
8111f7e0:	003fec06 	br	8111f794 <__reset+0xfb0ff794>
8111f7e4:	01604574 	movhi	r5,33045
8111f7e8:	2966b304 	addi	r5,r5,-25908
8111f7ec:	d9403915 	stw	r5,228(sp)
8111f7f0:	d8c02d15 	stw	r3,180(sp)
8111f7f4:	1025883a 	mov	r18,r2
8111f7f8:	04401e04 	movi	r17,120
8111f7fc:	9d84b03a 	or	r2,r19,r22
8111f800:	1000fc1e 	bne	r2,zero,8111fbf4 <___vfprintf_internal_r+0x11d8>
8111f804:	0039883a 	mov	fp,zero
8111f808:	00800084 	movi	r2,2
8111f80c:	10803fcc 	andi	r2,r2,255
8111f810:	00c00044 	movi	r3,1
8111f814:	10c20f26 	beq	r2,r3,81120054 <___vfprintf_internal_r+0x1638>
8111f818:	00c00084 	movi	r3,2
8111f81c:	10fd6326 	beq	r2,r3,8111edac <__reset+0xfb0fedac>
8111f820:	003e2d06 	br	8111f0d8 <__reset+0xfb0ff0d8>
8111f824:	d8c02017 	ldw	r3,128(sp)
8111f828:	003e9306 	br	8111f278 <__reset+0xfb0ff278>
8111f82c:	00801944 	movi	r2,101
8111f830:	14407e0e 	bge	r2,r17,8111fa2c <___vfprintf_internal_r+0x1010>
8111f834:	d9003617 	ldw	r4,216(sp)
8111f838:	d9403817 	ldw	r5,224(sp)
8111f83c:	000d883a 	mov	r6,zero
8111f840:	000f883a 	mov	r7,zero
8111f844:	d8c03c15 	stw	r3,240(sp)
8111f848:	da003d15 	stw	r8,244(sp)
8111f84c:	112f4540 	call	8112f454 <__eqdf2>
8111f850:	d8c03c17 	ldw	r3,240(sp)
8111f854:	da003d17 	ldw	r8,244(sp)
8111f858:	1000f71e 	bne	r2,zero,8111fc38 <___vfprintf_internal_r+0x121c>
8111f85c:	d8801f17 	ldw	r2,124(sp)
8111f860:	01204574 	movhi	r4,33045
8111f864:	2126ba04 	addi	r4,r4,-25880
8111f868:	18c00044 	addi	r3,r3,1
8111f86c:	10800044 	addi	r2,r2,1
8111f870:	41000015 	stw	r4,0(r8)
8111f874:	01000044 	movi	r4,1
8111f878:	41000115 	stw	r4,4(r8)
8111f87c:	d8c02015 	stw	r3,128(sp)
8111f880:	d8801f15 	stw	r2,124(sp)
8111f884:	010001c4 	movi	r4,7
8111f888:	2082b816 	blt	r4,r2,8112036c <___vfprintf_internal_r+0x1950>
8111f88c:	42000204 	addi	r8,r8,8
8111f890:	d8802617 	ldw	r2,152(sp)
8111f894:	d9403317 	ldw	r5,204(sp)
8111f898:	11400216 	blt	r2,r5,8111f8a4 <___vfprintf_internal_r+0xe88>
8111f89c:	9080004c 	andi	r2,r18,1
8111f8a0:	103ed526 	beq	r2,zero,8111f3f8 <__reset+0xfb0ff3f8>
8111f8a4:	d8803717 	ldw	r2,220(sp)
8111f8a8:	d9003417 	ldw	r4,208(sp)
8111f8ac:	d9403717 	ldw	r5,220(sp)
8111f8b0:	1887883a 	add	r3,r3,r2
8111f8b4:	d8801f17 	ldw	r2,124(sp)
8111f8b8:	41000015 	stw	r4,0(r8)
8111f8bc:	41400115 	stw	r5,4(r8)
8111f8c0:	10800044 	addi	r2,r2,1
8111f8c4:	d8c02015 	stw	r3,128(sp)
8111f8c8:	d8801f15 	stw	r2,124(sp)
8111f8cc:	010001c4 	movi	r4,7
8111f8d0:	20832916 	blt	r4,r2,81120578 <___vfprintf_internal_r+0x1b5c>
8111f8d4:	42000204 	addi	r8,r8,8
8111f8d8:	d8803317 	ldw	r2,204(sp)
8111f8dc:	143fffc4 	addi	r16,r2,-1
8111f8e0:	043ec50e 	bge	zero,r16,8111f3f8 <__reset+0xfb0ff3f8>
8111f8e4:	04400404 	movi	r17,16
8111f8e8:	d8801f17 	ldw	r2,124(sp)
8111f8ec:	8c00880e 	bge	r17,r16,8111fb10 <___vfprintf_internal_r+0x10f4>
8111f8f0:	01604574 	movhi	r5,33045
8111f8f4:	2966c284 	addi	r5,r5,-25846
8111f8f8:	d9402b15 	stw	r5,172(sp)
8111f8fc:	058001c4 	movi	r22,7
8111f900:	dcc02c17 	ldw	r19,176(sp)
8111f904:	00000306 	br	8111f914 <___vfprintf_internal_r+0xef8>
8111f908:	42000204 	addi	r8,r8,8
8111f90c:	843ffc04 	addi	r16,r16,-16
8111f910:	8c00820e 	bge	r17,r16,8111fb1c <___vfprintf_internal_r+0x1100>
8111f914:	18c00404 	addi	r3,r3,16
8111f918:	10800044 	addi	r2,r2,1
8111f91c:	45000015 	stw	r20,0(r8)
8111f920:	44400115 	stw	r17,4(r8)
8111f924:	d8c02015 	stw	r3,128(sp)
8111f928:	d8801f15 	stw	r2,124(sp)
8111f92c:	b0bff60e 	bge	r22,r2,8111f908 <__reset+0xfb0ff908>
8111f930:	d9801e04 	addi	r6,sp,120
8111f934:	b80b883a 	mov	r5,r23
8111f938:	9809883a 	mov	r4,r19
8111f93c:	112ac0c0 	call	8112ac0c <__sprint_r>
8111f940:	103d3a1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111f944:	d8c02017 	ldw	r3,128(sp)
8111f948:	d8801f17 	ldw	r2,124(sp)
8111f94c:	da000404 	addi	r8,sp,16
8111f950:	003fee06 	br	8111f90c <__reset+0xfb0ff90c>
8111f954:	d9403117 	ldw	r5,196(sp)
8111f958:	d8802a17 	ldw	r2,168(sp)
8111f95c:	28adc83a 	sub	r22,r5,r2
8111f960:	05be630e 	bge	zero,r22,8111f2f0 <__reset+0xfb0ff2f0>
8111f964:	07000404 	movi	fp,16
8111f968:	d8801f17 	ldw	r2,124(sp)
8111f96c:	e5838f0e 	bge	fp,r22,811207ac <___vfprintf_internal_r+0x1d90>
8111f970:	01604574 	movhi	r5,33045
8111f974:	2966c284 	addi	r5,r5,-25846
8111f978:	dc403015 	stw	r17,192(sp)
8111f97c:	d9402b15 	stw	r5,172(sp)
8111f980:	b023883a 	mov	r17,r22
8111f984:	04c001c4 	movi	r19,7
8111f988:	a82d883a 	mov	r22,r21
8111f98c:	902b883a 	mov	r21,r18
8111f990:	8025883a 	mov	r18,r16
8111f994:	dc002c17 	ldw	r16,176(sp)
8111f998:	00000306 	br	8111f9a8 <___vfprintf_internal_r+0xf8c>
8111f99c:	8c7ffc04 	addi	r17,r17,-16
8111f9a0:	42000204 	addi	r8,r8,8
8111f9a4:	e440110e 	bge	fp,r17,8111f9ec <___vfprintf_internal_r+0xfd0>
8111f9a8:	18c00404 	addi	r3,r3,16
8111f9ac:	10800044 	addi	r2,r2,1
8111f9b0:	45000015 	stw	r20,0(r8)
8111f9b4:	47000115 	stw	fp,4(r8)
8111f9b8:	d8c02015 	stw	r3,128(sp)
8111f9bc:	d8801f15 	stw	r2,124(sp)
8111f9c0:	98bff60e 	bge	r19,r2,8111f99c <__reset+0xfb0ff99c>
8111f9c4:	d9801e04 	addi	r6,sp,120
8111f9c8:	b80b883a 	mov	r5,r23
8111f9cc:	8009883a 	mov	r4,r16
8111f9d0:	112ac0c0 	call	8112ac0c <__sprint_r>
8111f9d4:	103d151e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111f9d8:	8c7ffc04 	addi	r17,r17,-16
8111f9dc:	d8c02017 	ldw	r3,128(sp)
8111f9e0:	d8801f17 	ldw	r2,124(sp)
8111f9e4:	da000404 	addi	r8,sp,16
8111f9e8:	e47fef16 	blt	fp,r17,8111f9a8 <__reset+0xfb0ff9a8>
8111f9ec:	9021883a 	mov	r16,r18
8111f9f0:	a825883a 	mov	r18,r21
8111f9f4:	b02b883a 	mov	r21,r22
8111f9f8:	882d883a 	mov	r22,r17
8111f9fc:	dc403017 	ldw	r17,192(sp)
8111fa00:	d9002b17 	ldw	r4,172(sp)
8111fa04:	1d87883a 	add	r3,r3,r22
8111fa08:	10800044 	addi	r2,r2,1
8111fa0c:	41000015 	stw	r4,0(r8)
8111fa10:	45800115 	stw	r22,4(r8)
8111fa14:	d8c02015 	stw	r3,128(sp)
8111fa18:	d8801f15 	stw	r2,124(sp)
8111fa1c:	010001c4 	movi	r4,7
8111fa20:	20818e16 	blt	r4,r2,8112005c <___vfprintf_internal_r+0x1640>
8111fa24:	42000204 	addi	r8,r8,8
8111fa28:	003e3106 	br	8111f2f0 <__reset+0xfb0ff2f0>
8111fa2c:	d9403317 	ldw	r5,204(sp)
8111fa30:	00800044 	movi	r2,1
8111fa34:	18c00044 	addi	r3,r3,1
8111fa38:	1141530e 	bge	r2,r5,8111ff88 <___vfprintf_internal_r+0x156c>
8111fa3c:	dc401f17 	ldw	r17,124(sp)
8111fa40:	00800044 	movi	r2,1
8111fa44:	40800115 	stw	r2,4(r8)
8111fa48:	8c400044 	addi	r17,r17,1
8111fa4c:	44000015 	stw	r16,0(r8)
8111fa50:	d8c02015 	stw	r3,128(sp)
8111fa54:	dc401f15 	stw	r17,124(sp)
8111fa58:	008001c4 	movi	r2,7
8111fa5c:	14416b16 	blt	r2,r17,8112000c <___vfprintf_internal_r+0x15f0>
8111fa60:	42000204 	addi	r8,r8,8
8111fa64:	d8803717 	ldw	r2,220(sp)
8111fa68:	d9003417 	ldw	r4,208(sp)
8111fa6c:	8c400044 	addi	r17,r17,1
8111fa70:	10c7883a 	add	r3,r2,r3
8111fa74:	40800115 	stw	r2,4(r8)
8111fa78:	41000015 	stw	r4,0(r8)
8111fa7c:	d8c02015 	stw	r3,128(sp)
8111fa80:	dc401f15 	stw	r17,124(sp)
8111fa84:	008001c4 	movi	r2,7
8111fa88:	14416916 	blt	r2,r17,81120030 <___vfprintf_internal_r+0x1614>
8111fa8c:	45800204 	addi	r22,r8,8
8111fa90:	d9003617 	ldw	r4,216(sp)
8111fa94:	d9403817 	ldw	r5,224(sp)
8111fa98:	000d883a 	mov	r6,zero
8111fa9c:	000f883a 	mov	r7,zero
8111faa0:	d8c03c15 	stw	r3,240(sp)
8111faa4:	112f4540 	call	8112f454 <__eqdf2>
8111faa8:	d8c03c17 	ldw	r3,240(sp)
8111faac:	1000bc26 	beq	r2,zero,8111fda0 <___vfprintf_internal_r+0x1384>
8111fab0:	d9403317 	ldw	r5,204(sp)
8111fab4:	84000044 	addi	r16,r16,1
8111fab8:	8c400044 	addi	r17,r17,1
8111fabc:	28bfffc4 	addi	r2,r5,-1
8111fac0:	1887883a 	add	r3,r3,r2
8111fac4:	b0800115 	stw	r2,4(r22)
8111fac8:	b4000015 	stw	r16,0(r22)
8111facc:	d8c02015 	stw	r3,128(sp)
8111fad0:	dc401f15 	stw	r17,124(sp)
8111fad4:	008001c4 	movi	r2,7
8111fad8:	14414316 	blt	r2,r17,8111ffe8 <___vfprintf_internal_r+0x15cc>
8111fadc:	b5800204 	addi	r22,r22,8
8111fae0:	d9003a17 	ldw	r4,232(sp)
8111fae4:	df0022c4 	addi	fp,sp,139
8111fae8:	8c400044 	addi	r17,r17,1
8111faec:	20c7883a 	add	r3,r4,r3
8111faf0:	b7000015 	stw	fp,0(r22)
8111faf4:	b1000115 	stw	r4,4(r22)
8111faf8:	d8c02015 	stw	r3,128(sp)
8111fafc:	dc401f15 	stw	r17,124(sp)
8111fb00:	008001c4 	movi	r2,7
8111fb04:	14400e16 	blt	r2,r17,8111fb40 <___vfprintf_internal_r+0x1124>
8111fb08:	b2000204 	addi	r8,r22,8
8111fb0c:	003e3a06 	br	8111f3f8 <__reset+0xfb0ff3f8>
8111fb10:	01204574 	movhi	r4,33045
8111fb14:	2126c284 	addi	r4,r4,-25846
8111fb18:	d9002b15 	stw	r4,172(sp)
8111fb1c:	d9002b17 	ldw	r4,172(sp)
8111fb20:	1c07883a 	add	r3,r3,r16
8111fb24:	44000115 	stw	r16,4(r8)
8111fb28:	41000015 	stw	r4,0(r8)
8111fb2c:	10800044 	addi	r2,r2,1
8111fb30:	d8c02015 	stw	r3,128(sp)
8111fb34:	d8801f15 	stw	r2,124(sp)
8111fb38:	010001c4 	movi	r4,7
8111fb3c:	20be2d0e 	bge	r4,r2,8111f3f4 <__reset+0xfb0ff3f4>
8111fb40:	d9002c17 	ldw	r4,176(sp)
8111fb44:	d9801e04 	addi	r6,sp,120
8111fb48:	b80b883a 	mov	r5,r23
8111fb4c:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fb50:	103cb61e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fb54:	d8c02017 	ldw	r3,128(sp)
8111fb58:	da000404 	addi	r8,sp,16
8111fb5c:	003e2606 	br	8111f3f8 <__reset+0xfb0ff3f8>
8111fb60:	d9002c17 	ldw	r4,176(sp)
8111fb64:	d9801e04 	addi	r6,sp,120
8111fb68:	b80b883a 	mov	r5,r23
8111fb6c:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fb70:	103e5d26 	beq	r2,zero,8111f4e8 <__reset+0xfb0ff4e8>
8111fb74:	003cad06 	br	8111ee2c <__reset+0xfb0fee2c>
8111fb78:	d9002c17 	ldw	r4,176(sp)
8111fb7c:	d9801e04 	addi	r6,sp,120
8111fb80:	b80b883a 	mov	r5,r23
8111fb84:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fb88:	103ca81e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fb8c:	d8c02017 	ldw	r3,128(sp)
8111fb90:	da000404 	addi	r8,sp,16
8111fb94:	003e0b06 	br	8111f3c4 <__reset+0xfb0ff3c4>
8111fb98:	d9002c17 	ldw	r4,176(sp)
8111fb9c:	d9801e04 	addi	r6,sp,120
8111fba0:	b80b883a 	mov	r5,r23
8111fba4:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fba8:	103ca01e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fbac:	d8c02017 	ldw	r3,128(sp)
8111fbb0:	da000404 	addi	r8,sp,16
8111fbb4:	003dbd06 	br	8111f2ac <__reset+0xfb0ff2ac>
8111fbb8:	d9002c17 	ldw	r4,176(sp)
8111fbbc:	d9801e04 	addi	r6,sp,120
8111fbc0:	b80b883a 	mov	r5,r23
8111fbc4:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fbc8:	103c981e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fbcc:	d8c02017 	ldw	r3,128(sp)
8111fbd0:	da000404 	addi	r8,sp,16
8111fbd4:	003dc306 	br	8111f2e4 <__reset+0xfb0ff2e4>
8111fbd8:	d8802917 	ldw	r2,164(sp)
8111fbdc:	d8002785 	stb	zero,158(sp)
8111fbe0:	103f0616 	blt	r2,zero,8111f7fc <__reset+0xfb0ff7fc>
8111fbe4:	00ffdfc4 	movi	r3,-129
8111fbe8:	9d84b03a 	or	r2,r19,r22
8111fbec:	90e4703a 	and	r18,r18,r3
8111fbf0:	103c6b26 	beq	r2,zero,8111eda0 <__reset+0xfb0feda0>
8111fbf4:	0039883a 	mov	fp,zero
8111fbf8:	003e7406 	br	8111f5cc <__reset+0xfb0ff5cc>
8111fbfc:	9080040c 	andi	r2,r18,16
8111fc00:	1001b326 	beq	r2,zero,811202d0 <___vfprintf_internal_r+0x18b4>
8111fc04:	d9002d17 	ldw	r4,180(sp)
8111fc08:	d9402917 	ldw	r5,164(sp)
8111fc0c:	d8002785 	stb	zero,158(sp)
8111fc10:	20800104 	addi	r2,r4,4
8111fc14:	24c00017 	ldw	r19,0(r4)
8111fc18:	002d883a 	mov	r22,zero
8111fc1c:	2801b516 	blt	r5,zero,811202f4 <___vfprintf_internal_r+0x18d8>
8111fc20:	00ffdfc4 	movi	r3,-129
8111fc24:	d8802d15 	stw	r2,180(sp)
8111fc28:	90e4703a 	and	r18,r18,r3
8111fc2c:	983d2726 	beq	r19,zero,8111f0cc <__reset+0xfb0ff0cc>
8111fc30:	0039883a 	mov	fp,zero
8111fc34:	003d2a06 	br	8111f0e0 <__reset+0xfb0ff0e0>
8111fc38:	dc402617 	ldw	r17,152(sp)
8111fc3c:	0441d30e 	bge	zero,r17,8112038c <___vfprintf_internal_r+0x1970>
8111fc40:	dc403217 	ldw	r17,200(sp)
8111fc44:	d8803317 	ldw	r2,204(sp)
8111fc48:	1440010e 	bge	r2,r17,8111fc50 <___vfprintf_internal_r+0x1234>
8111fc4c:	1023883a 	mov	r17,r2
8111fc50:	04400a0e 	bge	zero,r17,8111fc7c <___vfprintf_internal_r+0x1260>
8111fc54:	d8801f17 	ldw	r2,124(sp)
8111fc58:	1c47883a 	add	r3,r3,r17
8111fc5c:	44000015 	stw	r16,0(r8)
8111fc60:	10800044 	addi	r2,r2,1
8111fc64:	44400115 	stw	r17,4(r8)
8111fc68:	d8c02015 	stw	r3,128(sp)
8111fc6c:	d8801f15 	stw	r2,124(sp)
8111fc70:	010001c4 	movi	r4,7
8111fc74:	20826516 	blt	r4,r2,8112060c <___vfprintf_internal_r+0x1bf0>
8111fc78:	42000204 	addi	r8,r8,8
8111fc7c:	88026116 	blt	r17,zero,81120604 <___vfprintf_internal_r+0x1be8>
8111fc80:	d9003217 	ldw	r4,200(sp)
8111fc84:	2463c83a 	sub	r17,r4,r17
8111fc88:	04407b0e 	bge	zero,r17,8111fe78 <___vfprintf_internal_r+0x145c>
8111fc8c:	05800404 	movi	r22,16
8111fc90:	d8801f17 	ldw	r2,124(sp)
8111fc94:	b4419d0e 	bge	r22,r17,8112030c <___vfprintf_internal_r+0x18f0>
8111fc98:	01204574 	movhi	r4,33045
8111fc9c:	2126c284 	addi	r4,r4,-25846
8111fca0:	d9002b15 	stw	r4,172(sp)
8111fca4:	070001c4 	movi	fp,7
8111fca8:	dcc02c17 	ldw	r19,176(sp)
8111fcac:	00000306 	br	8111fcbc <___vfprintf_internal_r+0x12a0>
8111fcb0:	42000204 	addi	r8,r8,8
8111fcb4:	8c7ffc04 	addi	r17,r17,-16
8111fcb8:	b441970e 	bge	r22,r17,81120318 <___vfprintf_internal_r+0x18fc>
8111fcbc:	18c00404 	addi	r3,r3,16
8111fcc0:	10800044 	addi	r2,r2,1
8111fcc4:	45000015 	stw	r20,0(r8)
8111fcc8:	45800115 	stw	r22,4(r8)
8111fccc:	d8c02015 	stw	r3,128(sp)
8111fcd0:	d8801f15 	stw	r2,124(sp)
8111fcd4:	e0bff60e 	bge	fp,r2,8111fcb0 <__reset+0xfb0ffcb0>
8111fcd8:	d9801e04 	addi	r6,sp,120
8111fcdc:	b80b883a 	mov	r5,r23
8111fce0:	9809883a 	mov	r4,r19
8111fce4:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fce8:	103c501e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fcec:	d8c02017 	ldw	r3,128(sp)
8111fcf0:	d8801f17 	ldw	r2,124(sp)
8111fcf4:	da000404 	addi	r8,sp,16
8111fcf8:	003fee06 	br	8111fcb4 <__reset+0xfb0ffcb4>
8111fcfc:	d9002c17 	ldw	r4,176(sp)
8111fd00:	d9801e04 	addi	r6,sp,120
8111fd04:	b80b883a 	mov	r5,r23
8111fd08:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fd0c:	103c471e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fd10:	d8c02017 	ldw	r3,128(sp)
8111fd14:	df002787 	ldb	fp,158(sp)
8111fd18:	da000404 	addi	r8,sp,16
8111fd1c:	003d5606 	br	8111f278 <__reset+0xfb0ff278>
8111fd20:	9080040c 	andi	r2,r18,16
8111fd24:	10016126 	beq	r2,zero,811202ac <___vfprintf_internal_r+0x1890>
8111fd28:	d8802d17 	ldw	r2,180(sp)
8111fd2c:	14c00017 	ldw	r19,0(r2)
8111fd30:	10800104 	addi	r2,r2,4
8111fd34:	d8802d15 	stw	r2,180(sp)
8111fd38:	982dd7fa 	srai	r22,r19,31
8111fd3c:	b005883a 	mov	r2,r22
8111fd40:	003c8206 	br	8111ef4c <__reset+0xfb0fef4c>
8111fd44:	9080040c 	andi	r2,r18,16
8111fd48:	10003526 	beq	r2,zero,8111fe20 <___vfprintf_internal_r+0x1404>
8111fd4c:	d9402d17 	ldw	r5,180(sp)
8111fd50:	d8c02917 	ldw	r3,164(sp)
8111fd54:	d8002785 	stb	zero,158(sp)
8111fd58:	28800104 	addi	r2,r5,4
8111fd5c:	2cc00017 	ldw	r19,0(r5)
8111fd60:	002d883a 	mov	r22,zero
8111fd64:	18003716 	blt	r3,zero,8111fe44 <___vfprintf_internal_r+0x1428>
8111fd68:	00ffdfc4 	movi	r3,-129
8111fd6c:	d8802d15 	stw	r2,180(sp)
8111fd70:	90e4703a 	and	r18,r18,r3
8111fd74:	0039883a 	mov	fp,zero
8111fd78:	983df326 	beq	r19,zero,8111f548 <__reset+0xfb0ff548>
8111fd7c:	00800244 	movi	r2,9
8111fd80:	14fc7b36 	bltu	r2,r19,8111ef70 <__reset+0xfb0fef70>
8111fd84:	d8c02817 	ldw	r3,160(sp)
8111fd88:	dc001dc4 	addi	r16,sp,119
8111fd8c:	9cc00c04 	addi	r19,r19,48
8111fd90:	1c07c83a 	sub	r3,r3,r16
8111fd94:	dcc01dc5 	stb	r19,119(sp)
8111fd98:	d8c02e15 	stw	r3,184(sp)
8111fd9c:	003ce806 	br	8111f140 <__reset+0xfb0ff140>
8111fda0:	d8803317 	ldw	r2,204(sp)
8111fda4:	143fffc4 	addi	r16,r2,-1
8111fda8:	043f4d0e 	bge	zero,r16,8111fae0 <__reset+0xfb0ffae0>
8111fdac:	07000404 	movi	fp,16
8111fdb0:	e400810e 	bge	fp,r16,8111ffb8 <___vfprintf_internal_r+0x159c>
8111fdb4:	01604574 	movhi	r5,33045
8111fdb8:	2966c284 	addi	r5,r5,-25846
8111fdbc:	d9402b15 	stw	r5,172(sp)
8111fdc0:	01c001c4 	movi	r7,7
8111fdc4:	dcc02c17 	ldw	r19,176(sp)
8111fdc8:	00000306 	br	8111fdd8 <___vfprintf_internal_r+0x13bc>
8111fdcc:	b5800204 	addi	r22,r22,8
8111fdd0:	843ffc04 	addi	r16,r16,-16
8111fdd4:	e4007b0e 	bge	fp,r16,8111ffc4 <___vfprintf_internal_r+0x15a8>
8111fdd8:	18c00404 	addi	r3,r3,16
8111fddc:	8c400044 	addi	r17,r17,1
8111fde0:	b5000015 	stw	r20,0(r22)
8111fde4:	b7000115 	stw	fp,4(r22)
8111fde8:	d8c02015 	stw	r3,128(sp)
8111fdec:	dc401f15 	stw	r17,124(sp)
8111fdf0:	3c7ff60e 	bge	r7,r17,8111fdcc <__reset+0xfb0ffdcc>
8111fdf4:	d9801e04 	addi	r6,sp,120
8111fdf8:	b80b883a 	mov	r5,r23
8111fdfc:	9809883a 	mov	r4,r19
8111fe00:	d9c03c15 	stw	r7,240(sp)
8111fe04:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fe08:	d9c03c17 	ldw	r7,240(sp)
8111fe0c:	103c071e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fe10:	d8c02017 	ldw	r3,128(sp)
8111fe14:	dc401f17 	ldw	r17,124(sp)
8111fe18:	dd800404 	addi	r22,sp,16
8111fe1c:	003fec06 	br	8111fdd0 <__reset+0xfb0ffdd0>
8111fe20:	9080100c 	andi	r2,r18,64
8111fe24:	d8002785 	stb	zero,158(sp)
8111fe28:	10010e26 	beq	r2,zero,81120264 <___vfprintf_internal_r+0x1848>
8111fe2c:	d9002d17 	ldw	r4,180(sp)
8111fe30:	d9402917 	ldw	r5,164(sp)
8111fe34:	002d883a 	mov	r22,zero
8111fe38:	20800104 	addi	r2,r4,4
8111fe3c:	24c0000b 	ldhu	r19,0(r4)
8111fe40:	283fc90e 	bge	r5,zero,8111fd68 <__reset+0xfb0ffd68>
8111fe44:	d8802d15 	stw	r2,180(sp)
8111fe48:	0039883a 	mov	fp,zero
8111fe4c:	9d84b03a 	or	r2,r19,r22
8111fe50:	103c461e 	bne	r2,zero,8111ef6c <__reset+0xfb0fef6c>
8111fe54:	00800044 	movi	r2,1
8111fe58:	003e6c06 	br	8111f80c <__reset+0xfb0ff80c>
8111fe5c:	d9002c17 	ldw	r4,176(sp)
8111fe60:	d9801e04 	addi	r6,sp,120
8111fe64:	b80b883a 	mov	r5,r23
8111fe68:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fe6c:	103bef1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fe70:	d8c02017 	ldw	r3,128(sp)
8111fe74:	da000404 	addi	r8,sp,16
8111fe78:	d9003217 	ldw	r4,200(sp)
8111fe7c:	d8802617 	ldw	r2,152(sp)
8111fe80:	d9403317 	ldw	r5,204(sp)
8111fe84:	8123883a 	add	r17,r16,r4
8111fe88:	11400216 	blt	r2,r5,8111fe94 <___vfprintf_internal_r+0x1478>
8111fe8c:	9100004c 	andi	r4,r18,1
8111fe90:	20000d26 	beq	r4,zero,8111fec8 <___vfprintf_internal_r+0x14ac>
8111fe94:	d9003717 	ldw	r4,220(sp)
8111fe98:	d9403417 	ldw	r5,208(sp)
8111fe9c:	1907883a 	add	r3,r3,r4
8111fea0:	d9001f17 	ldw	r4,124(sp)
8111fea4:	41400015 	stw	r5,0(r8)
8111fea8:	d9403717 	ldw	r5,220(sp)
8111feac:	21000044 	addi	r4,r4,1
8111feb0:	d8c02015 	stw	r3,128(sp)
8111feb4:	41400115 	stw	r5,4(r8)
8111feb8:	d9001f15 	stw	r4,124(sp)
8111febc:	014001c4 	movi	r5,7
8111fec0:	2901e816 	blt	r5,r4,81120664 <___vfprintf_internal_r+0x1c48>
8111fec4:	42000204 	addi	r8,r8,8
8111fec8:	d9003317 	ldw	r4,204(sp)
8111fecc:	8121883a 	add	r16,r16,r4
8111fed0:	2085c83a 	sub	r2,r4,r2
8111fed4:	8461c83a 	sub	r16,r16,r17
8111fed8:	1400010e 	bge	r2,r16,8111fee0 <___vfprintf_internal_r+0x14c4>
8111fedc:	1021883a 	mov	r16,r2
8111fee0:	04000a0e 	bge	zero,r16,8111ff0c <___vfprintf_internal_r+0x14f0>
8111fee4:	d9001f17 	ldw	r4,124(sp)
8111fee8:	1c07883a 	add	r3,r3,r16
8111feec:	44400015 	stw	r17,0(r8)
8111fef0:	21000044 	addi	r4,r4,1
8111fef4:	44000115 	stw	r16,4(r8)
8111fef8:	d8c02015 	stw	r3,128(sp)
8111fefc:	d9001f15 	stw	r4,124(sp)
8111ff00:	014001c4 	movi	r5,7
8111ff04:	2901fb16 	blt	r5,r4,811206f4 <___vfprintf_internal_r+0x1cd8>
8111ff08:	42000204 	addi	r8,r8,8
8111ff0c:	8001f716 	blt	r16,zero,811206ec <___vfprintf_internal_r+0x1cd0>
8111ff10:	1421c83a 	sub	r16,r2,r16
8111ff14:	043d380e 	bge	zero,r16,8111f3f8 <__reset+0xfb0ff3f8>
8111ff18:	04400404 	movi	r17,16
8111ff1c:	d8801f17 	ldw	r2,124(sp)
8111ff20:	8c3efb0e 	bge	r17,r16,8111fb10 <__reset+0xfb0ffb10>
8111ff24:	01604574 	movhi	r5,33045
8111ff28:	2966c284 	addi	r5,r5,-25846
8111ff2c:	d9402b15 	stw	r5,172(sp)
8111ff30:	058001c4 	movi	r22,7
8111ff34:	dcc02c17 	ldw	r19,176(sp)
8111ff38:	00000306 	br	8111ff48 <___vfprintf_internal_r+0x152c>
8111ff3c:	42000204 	addi	r8,r8,8
8111ff40:	843ffc04 	addi	r16,r16,-16
8111ff44:	8c3ef50e 	bge	r17,r16,8111fb1c <__reset+0xfb0ffb1c>
8111ff48:	18c00404 	addi	r3,r3,16
8111ff4c:	10800044 	addi	r2,r2,1
8111ff50:	45000015 	stw	r20,0(r8)
8111ff54:	44400115 	stw	r17,4(r8)
8111ff58:	d8c02015 	stw	r3,128(sp)
8111ff5c:	d8801f15 	stw	r2,124(sp)
8111ff60:	b0bff60e 	bge	r22,r2,8111ff3c <__reset+0xfb0fff3c>
8111ff64:	d9801e04 	addi	r6,sp,120
8111ff68:	b80b883a 	mov	r5,r23
8111ff6c:	9809883a 	mov	r4,r19
8111ff70:	112ac0c0 	call	8112ac0c <__sprint_r>
8111ff74:	103bad1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111ff78:	d8c02017 	ldw	r3,128(sp)
8111ff7c:	d8801f17 	ldw	r2,124(sp)
8111ff80:	da000404 	addi	r8,sp,16
8111ff84:	003fee06 	br	8111ff40 <__reset+0xfb0fff40>
8111ff88:	9088703a 	and	r4,r18,r2
8111ff8c:	203eab1e 	bne	r4,zero,8111fa3c <__reset+0xfb0ffa3c>
8111ff90:	dc401f17 	ldw	r17,124(sp)
8111ff94:	40800115 	stw	r2,4(r8)
8111ff98:	44000015 	stw	r16,0(r8)
8111ff9c:	8c400044 	addi	r17,r17,1
8111ffa0:	d8c02015 	stw	r3,128(sp)
8111ffa4:	dc401f15 	stw	r17,124(sp)
8111ffa8:	008001c4 	movi	r2,7
8111ffac:	14400e16 	blt	r2,r17,8111ffe8 <___vfprintf_internal_r+0x15cc>
8111ffb0:	45800204 	addi	r22,r8,8
8111ffb4:	003eca06 	br	8111fae0 <__reset+0xfb0ffae0>
8111ffb8:	01204574 	movhi	r4,33045
8111ffbc:	2126c284 	addi	r4,r4,-25846
8111ffc0:	d9002b15 	stw	r4,172(sp)
8111ffc4:	d8802b17 	ldw	r2,172(sp)
8111ffc8:	1c07883a 	add	r3,r3,r16
8111ffcc:	8c400044 	addi	r17,r17,1
8111ffd0:	b0800015 	stw	r2,0(r22)
8111ffd4:	b4000115 	stw	r16,4(r22)
8111ffd8:	d8c02015 	stw	r3,128(sp)
8111ffdc:	dc401f15 	stw	r17,124(sp)
8111ffe0:	008001c4 	movi	r2,7
8111ffe4:	147ebd0e 	bge	r2,r17,8111fadc <__reset+0xfb0ffadc>
8111ffe8:	d9002c17 	ldw	r4,176(sp)
8111ffec:	d9801e04 	addi	r6,sp,120
8111fff0:	b80b883a 	mov	r5,r23
8111fff4:	112ac0c0 	call	8112ac0c <__sprint_r>
8111fff8:	103b8c1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8111fffc:	d8c02017 	ldw	r3,128(sp)
81120000:	dc401f17 	ldw	r17,124(sp)
81120004:	dd800404 	addi	r22,sp,16
81120008:	003eb506 	br	8111fae0 <__reset+0xfb0ffae0>
8112000c:	d9002c17 	ldw	r4,176(sp)
81120010:	d9801e04 	addi	r6,sp,120
81120014:	b80b883a 	mov	r5,r23
81120018:	112ac0c0 	call	8112ac0c <__sprint_r>
8112001c:	103b831e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120020:	d8c02017 	ldw	r3,128(sp)
81120024:	dc401f17 	ldw	r17,124(sp)
81120028:	da000404 	addi	r8,sp,16
8112002c:	003e8d06 	br	8111fa64 <__reset+0xfb0ffa64>
81120030:	d9002c17 	ldw	r4,176(sp)
81120034:	d9801e04 	addi	r6,sp,120
81120038:	b80b883a 	mov	r5,r23
8112003c:	112ac0c0 	call	8112ac0c <__sprint_r>
81120040:	103b7a1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120044:	d8c02017 	ldw	r3,128(sp)
81120048:	dc401f17 	ldw	r17,124(sp)
8112004c:	dd800404 	addi	r22,sp,16
81120050:	003e8f06 	br	8111fa90 <__reset+0xfb0ffa90>
81120054:	0027883a 	mov	r19,zero
81120058:	003f4a06 	br	8111fd84 <__reset+0xfb0ffd84>
8112005c:	d9002c17 	ldw	r4,176(sp)
81120060:	d9801e04 	addi	r6,sp,120
81120064:	b80b883a 	mov	r5,r23
81120068:	112ac0c0 	call	8112ac0c <__sprint_r>
8112006c:	103b6f1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120070:	d8c02017 	ldw	r3,128(sp)
81120074:	da000404 	addi	r8,sp,16
81120078:	003c9d06 	br	8111f2f0 <__reset+0xfb0ff2f0>
8112007c:	04e7c83a 	sub	r19,zero,r19
81120080:	9804c03a 	cmpne	r2,r19,zero
81120084:	05adc83a 	sub	r22,zero,r22
81120088:	b0adc83a 	sub	r22,r22,r2
8112008c:	d8802917 	ldw	r2,164(sp)
81120090:	07000b44 	movi	fp,45
81120094:	df002785 	stb	fp,158(sp)
81120098:	10017b16 	blt	r2,zero,81120688 <___vfprintf_internal_r+0x1c6c>
8112009c:	00bfdfc4 	movi	r2,-129
811200a0:	90a4703a 	and	r18,r18,r2
811200a4:	003bb106 	br	8111ef6c <__reset+0xfb0fef6c>
811200a8:	d9003617 	ldw	r4,216(sp)
811200ac:	d9403817 	ldw	r5,224(sp)
811200b0:	da003d15 	stw	r8,244(sp)
811200b4:	11272700 	call	81127270 <__fpclassifyd>
811200b8:	da003d17 	ldw	r8,244(sp)
811200bc:	1000f026 	beq	r2,zero,81120480 <___vfprintf_internal_r+0x1a64>
811200c0:	d9002917 	ldw	r4,164(sp)
811200c4:	05bff7c4 	movi	r22,-33
811200c8:	00bfffc4 	movi	r2,-1
811200cc:	8dac703a 	and	r22,r17,r22
811200d0:	20820026 	beq	r4,r2,811208d4 <___vfprintf_internal_r+0x1eb8>
811200d4:	008011c4 	movi	r2,71
811200d8:	b081f726 	beq	r22,r2,811208b8 <___vfprintf_internal_r+0x1e9c>
811200dc:	d9003817 	ldw	r4,224(sp)
811200e0:	90c04014 	ori	r3,r18,256
811200e4:	d8c02b15 	stw	r3,172(sp)
811200e8:	20021516 	blt	r4,zero,81120940 <___vfprintf_internal_r+0x1f24>
811200ec:	dcc03817 	ldw	r19,224(sp)
811200f0:	d8002a05 	stb	zero,168(sp)
811200f4:	00801984 	movi	r2,102
811200f8:	8881f926 	beq	r17,r2,811208e0 <___vfprintf_internal_r+0x1ec4>
811200fc:	00801184 	movi	r2,70
81120100:	88821c26 	beq	r17,r2,81120974 <___vfprintf_internal_r+0x1f58>
81120104:	00801144 	movi	r2,69
81120108:	b081ef26 	beq	r22,r2,811208c8 <___vfprintf_internal_r+0x1eac>
8112010c:	d8c02917 	ldw	r3,164(sp)
81120110:	d8802104 	addi	r2,sp,132
81120114:	d8800315 	stw	r2,12(sp)
81120118:	d9403617 	ldw	r5,216(sp)
8112011c:	d8802504 	addi	r2,sp,148
81120120:	d9002c17 	ldw	r4,176(sp)
81120124:	d8800215 	stw	r2,8(sp)
81120128:	d8802604 	addi	r2,sp,152
8112012c:	d8c00015 	stw	r3,0(sp)
81120130:	d8800115 	stw	r2,4(sp)
81120134:	01c00084 	movi	r7,2
81120138:	980d883a 	mov	r6,r19
8112013c:	d8c03c15 	stw	r3,240(sp)
81120140:	da003d15 	stw	r8,244(sp)
81120144:	1122b280 	call	81122b28 <_dtoa_r>
81120148:	1021883a 	mov	r16,r2
8112014c:	008019c4 	movi	r2,103
81120150:	d8c03c17 	ldw	r3,240(sp)
81120154:	da003d17 	ldw	r8,244(sp)
81120158:	88817126 	beq	r17,r2,81120720 <___vfprintf_internal_r+0x1d04>
8112015c:	008011c4 	movi	r2,71
81120160:	88829226 	beq	r17,r2,81120bac <___vfprintf_internal_r+0x2190>
81120164:	80f9883a 	add	fp,r16,r3
81120168:	d9003617 	ldw	r4,216(sp)
8112016c:	000d883a 	mov	r6,zero
81120170:	000f883a 	mov	r7,zero
81120174:	980b883a 	mov	r5,r19
81120178:	da003d15 	stw	r8,244(sp)
8112017c:	112f4540 	call	8112f454 <__eqdf2>
81120180:	da003d17 	ldw	r8,244(sp)
81120184:	10018d26 	beq	r2,zero,811207bc <___vfprintf_internal_r+0x1da0>
81120188:	d8802117 	ldw	r2,132(sp)
8112018c:	1700062e 	bgeu	r2,fp,811201a8 <___vfprintf_internal_r+0x178c>
81120190:	01000c04 	movi	r4,48
81120194:	10c00044 	addi	r3,r2,1
81120198:	d8c02115 	stw	r3,132(sp)
8112019c:	11000005 	stb	r4,0(r2)
811201a0:	d8802117 	ldw	r2,132(sp)
811201a4:	173ffb36 	bltu	r2,fp,81120194 <__reset+0xfb100194>
811201a8:	1405c83a 	sub	r2,r2,r16
811201ac:	d8803315 	stw	r2,204(sp)
811201b0:	008011c4 	movi	r2,71
811201b4:	b0817626 	beq	r22,r2,81120790 <___vfprintf_internal_r+0x1d74>
811201b8:	00801944 	movi	r2,101
811201bc:	1442810e 	bge	r2,r17,81120bc4 <___vfprintf_internal_r+0x21a8>
811201c0:	d8c02617 	ldw	r3,152(sp)
811201c4:	00801984 	movi	r2,102
811201c8:	d8c03215 	stw	r3,200(sp)
811201cc:	8881fe26 	beq	r17,r2,811209c8 <___vfprintf_internal_r+0x1fac>
811201d0:	d8c03217 	ldw	r3,200(sp)
811201d4:	d9003317 	ldw	r4,204(sp)
811201d8:	1901dd16 	blt	r3,r4,81120950 <___vfprintf_internal_r+0x1f34>
811201dc:	9480004c 	andi	r18,r18,1
811201e0:	90022b1e 	bne	r18,zero,81120a90 <___vfprintf_internal_r+0x2074>
811201e4:	1805883a 	mov	r2,r3
811201e8:	18028016 	blt	r3,zero,81120bec <___vfprintf_internal_r+0x21d0>
811201ec:	d8c03217 	ldw	r3,200(sp)
811201f0:	044019c4 	movi	r17,103
811201f4:	d8c02e15 	stw	r3,184(sp)
811201f8:	df002a07 	ldb	fp,168(sp)
811201fc:	e001531e 	bne	fp,zero,8112074c <___vfprintf_internal_r+0x1d30>
81120200:	df002783 	ldbu	fp,158(sp)
81120204:	d8802a15 	stw	r2,168(sp)
81120208:	dc802b17 	ldw	r18,172(sp)
8112020c:	d8002915 	stw	zero,164(sp)
81120210:	003bd106 	br	8111f158 <__reset+0xfb0ff158>
81120214:	d8802d17 	ldw	r2,180(sp)
81120218:	d8c02d17 	ldw	r3,180(sp)
8112021c:	d9002d17 	ldw	r4,180(sp)
81120220:	10800017 	ldw	r2,0(r2)
81120224:	18c00117 	ldw	r3,4(r3)
81120228:	21000204 	addi	r4,r4,8
8112022c:	d8803615 	stw	r2,216(sp)
81120230:	d8c03815 	stw	r3,224(sp)
81120234:	d9002d15 	stw	r4,180(sp)
81120238:	003b7506 	br	8111f010 <__reset+0xfb0ff010>
8112023c:	ac400007 	ldb	r17,0(r21)
81120240:	003a5906 	br	8111eba8 <__reset+0xfb0feba8>
81120244:	9080100c 	andi	r2,r18,64
81120248:	1000a826 	beq	r2,zero,811204ec <___vfprintf_internal_r+0x1ad0>
8112024c:	d9002d17 	ldw	r4,180(sp)
81120250:	002d883a 	mov	r22,zero
81120254:	24c0000b 	ldhu	r19,0(r4)
81120258:	21000104 	addi	r4,r4,4
8112025c:	d9002d15 	stw	r4,180(sp)
81120260:	003ccb06 	br	8111f590 <__reset+0xfb0ff590>
81120264:	d8c02d17 	ldw	r3,180(sp)
81120268:	d9002917 	ldw	r4,164(sp)
8112026c:	002d883a 	mov	r22,zero
81120270:	18800104 	addi	r2,r3,4
81120274:	1cc00017 	ldw	r19,0(r3)
81120278:	203ebb0e 	bge	r4,zero,8111fd68 <__reset+0xfb0ffd68>
8112027c:	003ef106 	br	8111fe44 <__reset+0xfb0ffe44>
81120280:	9080040c 	andi	r2,r18,16
81120284:	1000921e 	bne	r2,zero,811204d0 <___vfprintf_internal_r+0x1ab4>
81120288:	9480100c 	andi	r18,r18,64
8112028c:	90013926 	beq	r18,zero,81120774 <___vfprintf_internal_r+0x1d58>
81120290:	d9002d17 	ldw	r4,180(sp)
81120294:	d9402f17 	ldw	r5,188(sp)
81120298:	20800017 	ldw	r2,0(r4)
8112029c:	21000104 	addi	r4,r4,4
811202a0:	d9002d15 	stw	r4,180(sp)
811202a4:	1140000d 	sth	r5,0(r2)
811202a8:	003a1606 	br	8111eb04 <__reset+0xfb0feb04>
811202ac:	9080100c 	andi	r2,r18,64
811202b0:	10008026 	beq	r2,zero,811204b4 <___vfprintf_internal_r+0x1a98>
811202b4:	d8c02d17 	ldw	r3,180(sp)
811202b8:	1cc0000f 	ldh	r19,0(r3)
811202bc:	18c00104 	addi	r3,r3,4
811202c0:	d8c02d15 	stw	r3,180(sp)
811202c4:	982dd7fa 	srai	r22,r19,31
811202c8:	b005883a 	mov	r2,r22
811202cc:	003b1f06 	br	8111ef4c <__reset+0xfb0fef4c>
811202d0:	9080100c 	andi	r2,r18,64
811202d4:	d8002785 	stb	zero,158(sp)
811202d8:	10008a1e 	bne	r2,zero,81120504 <___vfprintf_internal_r+0x1ae8>
811202dc:	d9402d17 	ldw	r5,180(sp)
811202e0:	d8c02917 	ldw	r3,164(sp)
811202e4:	002d883a 	mov	r22,zero
811202e8:	28800104 	addi	r2,r5,4
811202ec:	2cc00017 	ldw	r19,0(r5)
811202f0:	183e4b0e 	bge	r3,zero,8111fc20 <__reset+0xfb0ffc20>
811202f4:	9d86b03a 	or	r3,r19,r22
811202f8:	d8802d15 	stw	r2,180(sp)
811202fc:	183e4c1e 	bne	r3,zero,8111fc30 <__reset+0xfb0ffc30>
81120300:	0039883a 	mov	fp,zero
81120304:	0005883a 	mov	r2,zero
81120308:	003d4006 	br	8111f80c <__reset+0xfb0ff80c>
8112030c:	01604574 	movhi	r5,33045
81120310:	2966c284 	addi	r5,r5,-25846
81120314:	d9402b15 	stw	r5,172(sp)
81120318:	d9402b17 	ldw	r5,172(sp)
8112031c:	1c47883a 	add	r3,r3,r17
81120320:	10800044 	addi	r2,r2,1
81120324:	41400015 	stw	r5,0(r8)
81120328:	44400115 	stw	r17,4(r8)
8112032c:	d8c02015 	stw	r3,128(sp)
81120330:	d8801f15 	stw	r2,124(sp)
81120334:	010001c4 	movi	r4,7
81120338:	20bec816 	blt	r4,r2,8111fe5c <__reset+0xfb0ffe5c>
8112033c:	42000204 	addi	r8,r8,8
81120340:	003ecd06 	br	8111fe78 <__reset+0xfb0ffe78>
81120344:	d9002917 	ldw	r4,164(sp)
81120348:	d8002785 	stb	zero,158(sp)
8112034c:	203d2d16 	blt	r4,zero,8111f804 <__reset+0xfb0ff804>
81120350:	00bfdfc4 	movi	r2,-129
81120354:	90a4703a 	and	r18,r18,r2
81120358:	003a9106 	br	8111eda0 <__reset+0xfb0feda0>
8112035c:	01204574 	movhi	r4,33045
81120360:	2126c284 	addi	r4,r4,-25846
81120364:	d9002b15 	stw	r4,172(sp)
81120368:	003c0c06 	br	8111f39c <__reset+0xfb0ff39c>
8112036c:	d9002c17 	ldw	r4,176(sp)
81120370:	d9801e04 	addi	r6,sp,120
81120374:	b80b883a 	mov	r5,r23
81120378:	112ac0c0 	call	8112ac0c <__sprint_r>
8112037c:	103aab1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120380:	d8c02017 	ldw	r3,128(sp)
81120384:	da000404 	addi	r8,sp,16
81120388:	003d4106 	br	8111f890 <__reset+0xfb0ff890>
8112038c:	d8801f17 	ldw	r2,124(sp)
81120390:	01604574 	movhi	r5,33045
81120394:	01000044 	movi	r4,1
81120398:	18c00044 	addi	r3,r3,1
8112039c:	10800044 	addi	r2,r2,1
811203a0:	2966ba04 	addi	r5,r5,-25880
811203a4:	41000115 	stw	r4,4(r8)
811203a8:	41400015 	stw	r5,0(r8)
811203ac:	d8c02015 	stw	r3,128(sp)
811203b0:	d8801f15 	stw	r2,124(sp)
811203b4:	010001c4 	movi	r4,7
811203b8:	20805c16 	blt	r4,r2,8112052c <___vfprintf_internal_r+0x1b10>
811203bc:	42000204 	addi	r8,r8,8
811203c0:	8800041e 	bne	r17,zero,811203d4 <___vfprintf_internal_r+0x19b8>
811203c4:	d8803317 	ldw	r2,204(sp)
811203c8:	1000021e 	bne	r2,zero,811203d4 <___vfprintf_internal_r+0x19b8>
811203cc:	9080004c 	andi	r2,r18,1
811203d0:	103c0926 	beq	r2,zero,8111f3f8 <__reset+0xfb0ff3f8>
811203d4:	d9003717 	ldw	r4,220(sp)
811203d8:	d8801f17 	ldw	r2,124(sp)
811203dc:	d9403417 	ldw	r5,208(sp)
811203e0:	20c7883a 	add	r3,r4,r3
811203e4:	10800044 	addi	r2,r2,1
811203e8:	41000115 	stw	r4,4(r8)
811203ec:	41400015 	stw	r5,0(r8)
811203f0:	d8c02015 	stw	r3,128(sp)
811203f4:	d8801f15 	stw	r2,124(sp)
811203f8:	010001c4 	movi	r4,7
811203fc:	20812116 	blt	r4,r2,81120884 <___vfprintf_internal_r+0x1e68>
81120400:	42000204 	addi	r8,r8,8
81120404:	0463c83a 	sub	r17,zero,r17
81120408:	0440730e 	bge	zero,r17,811205d8 <___vfprintf_internal_r+0x1bbc>
8112040c:	05800404 	movi	r22,16
81120410:	b440860e 	bge	r22,r17,8112062c <___vfprintf_internal_r+0x1c10>
81120414:	01604574 	movhi	r5,33045
81120418:	2966c284 	addi	r5,r5,-25846
8112041c:	d9402b15 	stw	r5,172(sp)
81120420:	070001c4 	movi	fp,7
81120424:	dcc02c17 	ldw	r19,176(sp)
81120428:	00000306 	br	81120438 <___vfprintf_internal_r+0x1a1c>
8112042c:	42000204 	addi	r8,r8,8
81120430:	8c7ffc04 	addi	r17,r17,-16
81120434:	b440800e 	bge	r22,r17,81120638 <___vfprintf_internal_r+0x1c1c>
81120438:	18c00404 	addi	r3,r3,16
8112043c:	10800044 	addi	r2,r2,1
81120440:	45000015 	stw	r20,0(r8)
81120444:	45800115 	stw	r22,4(r8)
81120448:	d8c02015 	stw	r3,128(sp)
8112044c:	d8801f15 	stw	r2,124(sp)
81120450:	e0bff60e 	bge	fp,r2,8112042c <__reset+0xfb10042c>
81120454:	d9801e04 	addi	r6,sp,120
81120458:	b80b883a 	mov	r5,r23
8112045c:	9809883a 	mov	r4,r19
81120460:	112ac0c0 	call	8112ac0c <__sprint_r>
81120464:	103a711e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120468:	d8c02017 	ldw	r3,128(sp)
8112046c:	d8801f17 	ldw	r2,124(sp)
81120470:	da000404 	addi	r8,sp,16
81120474:	003fee06 	br	81120430 <__reset+0xfb100430>
81120478:	00bfffc4 	movi	r2,-1
8112047c:	003a6f06 	br	8111ee3c <__reset+0xfb0fee3c>
81120480:	008011c4 	movi	r2,71
81120484:	1440b816 	blt	r2,r17,81120768 <___vfprintf_internal_r+0x1d4c>
81120488:	04204574 	movhi	r16,33045
8112048c:	8426ac04 	addi	r16,r16,-25936
81120490:	00c000c4 	movi	r3,3
81120494:	00bfdfc4 	movi	r2,-129
81120498:	d8c02a15 	stw	r3,168(sp)
8112049c:	90a4703a 	and	r18,r18,r2
811204a0:	df002783 	ldbu	fp,158(sp)
811204a4:	d8c02e15 	stw	r3,184(sp)
811204a8:	d8002915 	stw	zero,164(sp)
811204ac:	d8003215 	stw	zero,200(sp)
811204b0:	003b2906 	br	8111f158 <__reset+0xfb0ff158>
811204b4:	d9002d17 	ldw	r4,180(sp)
811204b8:	24c00017 	ldw	r19,0(r4)
811204bc:	21000104 	addi	r4,r4,4
811204c0:	d9002d15 	stw	r4,180(sp)
811204c4:	982dd7fa 	srai	r22,r19,31
811204c8:	b005883a 	mov	r2,r22
811204cc:	003a9f06 	br	8111ef4c <__reset+0xfb0fef4c>
811204d0:	d9402d17 	ldw	r5,180(sp)
811204d4:	d8c02f17 	ldw	r3,188(sp)
811204d8:	28800017 	ldw	r2,0(r5)
811204dc:	29400104 	addi	r5,r5,4
811204e0:	d9402d15 	stw	r5,180(sp)
811204e4:	10c00015 	stw	r3,0(r2)
811204e8:	00398606 	br	8111eb04 <__reset+0xfb0feb04>
811204ec:	d9402d17 	ldw	r5,180(sp)
811204f0:	002d883a 	mov	r22,zero
811204f4:	2cc00017 	ldw	r19,0(r5)
811204f8:	29400104 	addi	r5,r5,4
811204fc:	d9402d15 	stw	r5,180(sp)
81120500:	003c2306 	br	8111f590 <__reset+0xfb0ff590>
81120504:	d8c02d17 	ldw	r3,180(sp)
81120508:	d9002917 	ldw	r4,164(sp)
8112050c:	002d883a 	mov	r22,zero
81120510:	18800104 	addi	r2,r3,4
81120514:	1cc0000b 	ldhu	r19,0(r3)
81120518:	203dc10e 	bge	r4,zero,8111fc20 <__reset+0xfb0ffc20>
8112051c:	003f7506 	br	811202f4 <__reset+0xfb1002f4>
81120520:	04204574 	movhi	r16,33045
81120524:	8426aa04 	addi	r16,r16,-25944
81120528:	003acc06 	br	8111f05c <__reset+0xfb0ff05c>
8112052c:	d9002c17 	ldw	r4,176(sp)
81120530:	d9801e04 	addi	r6,sp,120
81120534:	b80b883a 	mov	r5,r23
81120538:	112ac0c0 	call	8112ac0c <__sprint_r>
8112053c:	103a3b1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120540:	dc402617 	ldw	r17,152(sp)
81120544:	d8c02017 	ldw	r3,128(sp)
81120548:	da000404 	addi	r8,sp,16
8112054c:	003f9c06 	br	811203c0 <__reset+0xfb1003c0>
81120550:	ac400043 	ldbu	r17,1(r21)
81120554:	94800814 	ori	r18,r18,32
81120558:	ad400044 	addi	r21,r21,1
8112055c:	8c403fcc 	andi	r17,r17,255
81120560:	8c40201c 	xori	r17,r17,128
81120564:	8c7fe004 	addi	r17,r17,-128
81120568:	00398f06 	br	8111eba8 <__reset+0xfb0feba8>
8112056c:	d8c02d15 	stw	r3,180(sp)
81120570:	0039883a 	mov	fp,zero
81120574:	003e3506 	br	8111fe4c <__reset+0xfb0ffe4c>
81120578:	d9002c17 	ldw	r4,176(sp)
8112057c:	d9801e04 	addi	r6,sp,120
81120580:	b80b883a 	mov	r5,r23
81120584:	112ac0c0 	call	8112ac0c <__sprint_r>
81120588:	103a281e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
8112058c:	d8c02017 	ldw	r3,128(sp)
81120590:	da000404 	addi	r8,sp,16
81120594:	003cd006 	br	8111f8d8 <__reset+0xfb0ff8d8>
81120598:	8009883a 	mov	r4,r16
8112059c:	da003d15 	stw	r8,244(sp)
811205a0:	111c5040 	call	8111c504 <strlen>
811205a4:	d8802e15 	stw	r2,184(sp)
811205a8:	da003d17 	ldw	r8,244(sp)
811205ac:	103c340e 	bge	r2,zero,8111f680 <__reset+0xfb0ff680>
811205b0:	0005883a 	mov	r2,zero
811205b4:	003c3206 	br	8111f680 <__reset+0xfb0ff680>
811205b8:	d9002c17 	ldw	r4,176(sp)
811205bc:	d9801e04 	addi	r6,sp,120
811205c0:	b80b883a 	mov	r5,r23
811205c4:	112ac0c0 	call	8112ac0c <__sprint_r>
811205c8:	103a181e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
811205cc:	d8c02017 	ldw	r3,128(sp)
811205d0:	d8801f17 	ldw	r2,124(sp)
811205d4:	da000404 	addi	r8,sp,16
811205d8:	d9403317 	ldw	r5,204(sp)
811205dc:	10800044 	addi	r2,r2,1
811205e0:	44000015 	stw	r16,0(r8)
811205e4:	28c7883a 	add	r3,r5,r3
811205e8:	003b7d06 	br	8111f3e0 <__reset+0xfb0ff3e0>
811205ec:	01204574 	movhi	r4,33045
811205f0:	2126c684 	addi	r4,r4,-25830
811205f4:	d9003515 	stw	r4,212(sp)
811205f8:	003b1406 	br	8111f24c <__reset+0xfb0ff24c>
811205fc:	013fffc4 	movi	r4,-1
81120600:	003a3506 	br	8111eed8 <__reset+0xfb0feed8>
81120604:	0023883a 	mov	r17,zero
81120608:	003d9d06 	br	8111fc80 <__reset+0xfb0ffc80>
8112060c:	d9002c17 	ldw	r4,176(sp)
81120610:	d9801e04 	addi	r6,sp,120
81120614:	b80b883a 	mov	r5,r23
81120618:	112ac0c0 	call	8112ac0c <__sprint_r>
8112061c:	103a031e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120620:	d8c02017 	ldw	r3,128(sp)
81120624:	da000404 	addi	r8,sp,16
81120628:	003d9406 	br	8111fc7c <__reset+0xfb0ffc7c>
8112062c:	01204574 	movhi	r4,33045
81120630:	2126c284 	addi	r4,r4,-25846
81120634:	d9002b15 	stw	r4,172(sp)
81120638:	d9002b17 	ldw	r4,172(sp)
8112063c:	1c47883a 	add	r3,r3,r17
81120640:	10800044 	addi	r2,r2,1
81120644:	41000015 	stw	r4,0(r8)
81120648:	44400115 	stw	r17,4(r8)
8112064c:	d8c02015 	stw	r3,128(sp)
81120650:	d8801f15 	stw	r2,124(sp)
81120654:	010001c4 	movi	r4,7
81120658:	20bfd716 	blt	r4,r2,811205b8 <__reset+0xfb1005b8>
8112065c:	42000204 	addi	r8,r8,8
81120660:	003fdd06 	br	811205d8 <__reset+0xfb1005d8>
81120664:	d9002c17 	ldw	r4,176(sp)
81120668:	d9801e04 	addi	r6,sp,120
8112066c:	b80b883a 	mov	r5,r23
81120670:	112ac0c0 	call	8112ac0c <__sprint_r>
81120674:	1039ed1e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120678:	d8802617 	ldw	r2,152(sp)
8112067c:	d8c02017 	ldw	r3,128(sp)
81120680:	da000404 	addi	r8,sp,16
81120684:	003e1006 	br	8111fec8 <__reset+0xfb0ffec8>
81120688:	00800044 	movi	r2,1
8112068c:	10803fcc 	andi	r2,r2,255
81120690:	00c00044 	movi	r3,1
81120694:	10fa3526 	beq	r2,r3,8111ef6c <__reset+0xfb0fef6c>
81120698:	00c00084 	movi	r3,2
8112069c:	10fbcb26 	beq	r2,r3,8111f5cc <__reset+0xfb0ff5cc>
811206a0:	003a8f06 	br	8111f0e0 <__reset+0xfb0ff0e0>
811206a4:	01204574 	movhi	r4,33045
811206a8:	2126c684 	addi	r4,r4,-25830
811206ac:	d9003515 	stw	r4,212(sp)
811206b0:	003b7606 	br	8111f48c <__reset+0xfb0ff48c>
811206b4:	d8802917 	ldw	r2,164(sp)
811206b8:	00c00184 	movi	r3,6
811206bc:	1880012e 	bgeu	r3,r2,811206c4 <___vfprintf_internal_r+0x1ca8>
811206c0:	1805883a 	mov	r2,r3
811206c4:	d8802e15 	stw	r2,184(sp)
811206c8:	1000ef16 	blt	r2,zero,81120a88 <___vfprintf_internal_r+0x206c>
811206cc:	04204574 	movhi	r16,33045
811206d0:	d8802a15 	stw	r2,168(sp)
811206d4:	dcc02d15 	stw	r19,180(sp)
811206d8:	d8002915 	stw	zero,164(sp)
811206dc:	d8003215 	stw	zero,200(sp)
811206e0:	8426b804 	addi	r16,r16,-25888
811206e4:	0039883a 	mov	fp,zero
811206e8:	003aa206 	br	8111f174 <__reset+0xfb0ff174>
811206ec:	0021883a 	mov	r16,zero
811206f0:	003e0706 	br	8111ff10 <__reset+0xfb0fff10>
811206f4:	d9002c17 	ldw	r4,176(sp)
811206f8:	d9801e04 	addi	r6,sp,120
811206fc:	b80b883a 	mov	r5,r23
81120700:	112ac0c0 	call	8112ac0c <__sprint_r>
81120704:	1039c91e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120708:	d8802617 	ldw	r2,152(sp)
8112070c:	d9403317 	ldw	r5,204(sp)
81120710:	d8c02017 	ldw	r3,128(sp)
81120714:	da000404 	addi	r8,sp,16
81120718:	2885c83a 	sub	r2,r5,r2
8112071c:	003dfb06 	br	8111ff0c <__reset+0xfb0fff0c>
81120720:	9080004c 	andi	r2,r18,1
81120724:	103e8f1e 	bne	r2,zero,81120164 <__reset+0xfb100164>
81120728:	d8802117 	ldw	r2,132(sp)
8112072c:	003e9e06 	br	811201a8 <__reset+0xfb1001a8>
81120730:	1025883a 	mov	r18,r2
81120734:	0039883a 	mov	fp,zero
81120738:	00800084 	movi	r2,2
8112073c:	003fd306 	br	8112068c <__reset+0xfb10068c>
81120740:	07000b44 	movi	fp,45
81120744:	df002785 	stb	fp,158(sp)
81120748:	003a4006 	br	8111f04c <__reset+0xfb0ff04c>
8112074c:	00c00b44 	movi	r3,45
81120750:	d8c02785 	stb	r3,158(sp)
81120754:	d8802a15 	stw	r2,168(sp)
81120758:	dc802b17 	ldw	r18,172(sp)
8112075c:	d8002915 	stw	zero,164(sp)
81120760:	07000b44 	movi	fp,45
81120764:	003a8006 	br	8111f168 <__reset+0xfb0ff168>
81120768:	04204574 	movhi	r16,33045
8112076c:	8426ad04 	addi	r16,r16,-25932
81120770:	003f4706 	br	81120490 <__reset+0xfb100490>
81120774:	d8c02d17 	ldw	r3,180(sp)
81120778:	d9002f17 	ldw	r4,188(sp)
8112077c:	18800017 	ldw	r2,0(r3)
81120780:	18c00104 	addi	r3,r3,4
81120784:	d8c02d15 	stw	r3,180(sp)
81120788:	11000015 	stw	r4,0(r2)
8112078c:	0038dd06 	br	8111eb04 <__reset+0xfb0feb04>
81120790:	dd802617 	ldw	r22,152(sp)
81120794:	00bfff44 	movi	r2,-3
81120798:	b0801c16 	blt	r22,r2,8112080c <___vfprintf_internal_r+0x1df0>
8112079c:	d9402917 	ldw	r5,164(sp)
811207a0:	2d801a16 	blt	r5,r22,8112080c <___vfprintf_internal_r+0x1df0>
811207a4:	dd803215 	stw	r22,200(sp)
811207a8:	003e8906 	br	811201d0 <__reset+0xfb1001d0>
811207ac:	01204574 	movhi	r4,33045
811207b0:	2126c284 	addi	r4,r4,-25846
811207b4:	d9002b15 	stw	r4,172(sp)
811207b8:	003c9106 	br	8111fa00 <__reset+0xfb0ffa00>
811207bc:	e005883a 	mov	r2,fp
811207c0:	003e7906 	br	811201a8 <__reset+0xfb1001a8>
811207c4:	d9402917 	ldw	r5,164(sp)
811207c8:	df002783 	ldbu	fp,158(sp)
811207cc:	dcc02d15 	stw	r19,180(sp)
811207d0:	d9402a15 	stw	r5,168(sp)
811207d4:	d9402e15 	stw	r5,184(sp)
811207d8:	d8002915 	stw	zero,164(sp)
811207dc:	d8003215 	stw	zero,200(sp)
811207e0:	003a5d06 	br	8111f158 <__reset+0xfb0ff158>
811207e4:	9080004c 	andi	r2,r18,1
811207e8:	0039883a 	mov	fp,zero
811207ec:	10000426 	beq	r2,zero,81120800 <___vfprintf_internal_r+0x1de4>
811207f0:	00800c04 	movi	r2,48
811207f4:	dc001dc4 	addi	r16,sp,119
811207f8:	d8801dc5 	stb	r2,119(sp)
811207fc:	003b8006 	br	8111f600 <__reset+0xfb0ff600>
81120800:	d8002e15 	stw	zero,184(sp)
81120804:	dc001e04 	addi	r16,sp,120
81120808:	003a4d06 	br	8111f140 <__reset+0xfb0ff140>
8112080c:	8c7fff84 	addi	r17,r17,-2
81120810:	b5bfffc4 	addi	r22,r22,-1
81120814:	dd802615 	stw	r22,152(sp)
81120818:	dc4022c5 	stb	r17,139(sp)
8112081c:	b000bf16 	blt	r22,zero,81120b1c <___vfprintf_internal_r+0x2100>
81120820:	00800ac4 	movi	r2,43
81120824:	d8802305 	stb	r2,140(sp)
81120828:	00800244 	movi	r2,9
8112082c:	15807016 	blt	r2,r22,811209f0 <___vfprintf_internal_r+0x1fd4>
81120830:	00800c04 	movi	r2,48
81120834:	b5800c04 	addi	r22,r22,48
81120838:	d8802345 	stb	r2,141(sp)
8112083c:	dd802385 	stb	r22,142(sp)
81120840:	d88023c4 	addi	r2,sp,143
81120844:	df0022c4 	addi	fp,sp,139
81120848:	d8c03317 	ldw	r3,204(sp)
8112084c:	1739c83a 	sub	fp,r2,fp
81120850:	d9003317 	ldw	r4,204(sp)
81120854:	e0c7883a 	add	r3,fp,r3
81120858:	df003a15 	stw	fp,232(sp)
8112085c:	d8c02e15 	stw	r3,184(sp)
81120860:	00800044 	movi	r2,1
81120864:	1100b30e 	bge	r2,r4,81120b34 <___vfprintf_internal_r+0x2118>
81120868:	d8c02e17 	ldw	r3,184(sp)
8112086c:	18c00044 	addi	r3,r3,1
81120870:	d8c02e15 	stw	r3,184(sp)
81120874:	1805883a 	mov	r2,r3
81120878:	1800ac16 	blt	r3,zero,81120b2c <___vfprintf_internal_r+0x2110>
8112087c:	d8003215 	stw	zero,200(sp)
81120880:	003e5d06 	br	811201f8 <__reset+0xfb1001f8>
81120884:	d9002c17 	ldw	r4,176(sp)
81120888:	d9801e04 	addi	r6,sp,120
8112088c:	b80b883a 	mov	r5,r23
81120890:	112ac0c0 	call	8112ac0c <__sprint_r>
81120894:	1039651e 	bne	r2,zero,8111ee2c <__reset+0xfb0fee2c>
81120898:	dc402617 	ldw	r17,152(sp)
8112089c:	d8c02017 	ldw	r3,128(sp)
811208a0:	d8801f17 	ldw	r2,124(sp)
811208a4:	da000404 	addi	r8,sp,16
811208a8:	003ed606 	br	81120404 <__reset+0xfb100404>
811208ac:	582b883a 	mov	r21,r11
811208b0:	d8002915 	stw	zero,164(sp)
811208b4:	0038bd06 	br	8111ebac <__reset+0xfb0febac>
811208b8:	d8802917 	ldw	r2,164(sp)
811208bc:	103e071e 	bne	r2,zero,811200dc <__reset+0xfb1000dc>
811208c0:	dc002915 	stw	r16,164(sp)
811208c4:	003e0506 	br	811200dc <__reset+0xfb1000dc>
811208c8:	d9002917 	ldw	r4,164(sp)
811208cc:	20c00044 	addi	r3,r4,1
811208d0:	003e0f06 	br	81120110 <__reset+0xfb100110>
811208d4:	01400184 	movi	r5,6
811208d8:	d9402915 	stw	r5,164(sp)
811208dc:	003dff06 	br	811200dc <__reset+0xfb1000dc>
811208e0:	d8802104 	addi	r2,sp,132
811208e4:	d8800315 	stw	r2,12(sp)
811208e8:	d8802504 	addi	r2,sp,148
811208ec:	d8800215 	stw	r2,8(sp)
811208f0:	d8802604 	addi	r2,sp,152
811208f4:	d8800115 	stw	r2,4(sp)
811208f8:	d8802917 	ldw	r2,164(sp)
811208fc:	d9403617 	ldw	r5,216(sp)
81120900:	d9002c17 	ldw	r4,176(sp)
81120904:	d8800015 	stw	r2,0(sp)
81120908:	01c000c4 	movi	r7,3
8112090c:	980d883a 	mov	r6,r19
81120910:	da003d15 	stw	r8,244(sp)
81120914:	1122b280 	call	81122b28 <_dtoa_r>
81120918:	d8c02917 	ldw	r3,164(sp)
8112091c:	da003d17 	ldw	r8,244(sp)
81120920:	1021883a 	mov	r16,r2
81120924:	10f9883a 	add	fp,r2,r3
81120928:	81000007 	ldb	r4,0(r16)
8112092c:	00800c04 	movi	r2,48
81120930:	20805e26 	beq	r4,r2,81120aac <___vfprintf_internal_r+0x2090>
81120934:	d8c02617 	ldw	r3,152(sp)
81120938:	e0f9883a 	add	fp,fp,r3
8112093c:	003e0a06 	br	81120168 <__reset+0xfb100168>
81120940:	00c00b44 	movi	r3,45
81120944:	24e0003c 	xorhi	r19,r4,32768
81120948:	d8c02a05 	stb	r3,168(sp)
8112094c:	003de906 	br	811200f4 <__reset+0xfb1000f4>
81120950:	d8c03217 	ldw	r3,200(sp)
81120954:	00c07a0e 	bge	zero,r3,81120b40 <___vfprintf_internal_r+0x2124>
81120958:	00800044 	movi	r2,1
8112095c:	d9003317 	ldw	r4,204(sp)
81120960:	1105883a 	add	r2,r2,r4
81120964:	d8802e15 	stw	r2,184(sp)
81120968:	10004e16 	blt	r2,zero,81120aa4 <___vfprintf_internal_r+0x2088>
8112096c:	044019c4 	movi	r17,103
81120970:	003e2106 	br	811201f8 <__reset+0xfb1001f8>
81120974:	d9002917 	ldw	r4,164(sp)
81120978:	d8802104 	addi	r2,sp,132
8112097c:	d8800315 	stw	r2,12(sp)
81120980:	d9000015 	stw	r4,0(sp)
81120984:	d8802504 	addi	r2,sp,148
81120988:	d9403617 	ldw	r5,216(sp)
8112098c:	d9002c17 	ldw	r4,176(sp)
81120990:	d8800215 	stw	r2,8(sp)
81120994:	d8802604 	addi	r2,sp,152
81120998:	d8800115 	stw	r2,4(sp)
8112099c:	01c000c4 	movi	r7,3
811209a0:	980d883a 	mov	r6,r19
811209a4:	da003d15 	stw	r8,244(sp)
811209a8:	1122b280 	call	81122b28 <_dtoa_r>
811209ac:	d8c02917 	ldw	r3,164(sp)
811209b0:	da003d17 	ldw	r8,244(sp)
811209b4:	1021883a 	mov	r16,r2
811209b8:	00801184 	movi	r2,70
811209bc:	80f9883a 	add	fp,r16,r3
811209c0:	88bfd926 	beq	r17,r2,81120928 <__reset+0xfb100928>
811209c4:	003de806 	br	81120168 <__reset+0xfb100168>
811209c8:	d9002917 	ldw	r4,164(sp)
811209cc:	00c04d0e 	bge	zero,r3,81120b04 <___vfprintf_internal_r+0x20e8>
811209d0:	2000441e 	bne	r4,zero,81120ae4 <___vfprintf_internal_r+0x20c8>
811209d4:	9480004c 	andi	r18,r18,1
811209d8:	9000421e 	bne	r18,zero,81120ae4 <___vfprintf_internal_r+0x20c8>
811209dc:	1805883a 	mov	r2,r3
811209e0:	18007016 	blt	r3,zero,81120ba4 <___vfprintf_internal_r+0x2188>
811209e4:	d8c03217 	ldw	r3,200(sp)
811209e8:	d8c02e15 	stw	r3,184(sp)
811209ec:	003e0206 	br	811201f8 <__reset+0xfb1001f8>
811209f0:	df0022c4 	addi	fp,sp,139
811209f4:	dc002915 	stw	r16,164(sp)
811209f8:	4027883a 	mov	r19,r8
811209fc:	e021883a 	mov	r16,fp
81120a00:	b009883a 	mov	r4,r22
81120a04:	01400284 	movi	r5,10
81120a08:	112df840 	call	8112df84 <__modsi3>
81120a0c:	10800c04 	addi	r2,r2,48
81120a10:	843fffc4 	addi	r16,r16,-1
81120a14:	b009883a 	mov	r4,r22
81120a18:	01400284 	movi	r5,10
81120a1c:	80800005 	stb	r2,0(r16)
81120a20:	112df000 	call	8112df00 <__divsi3>
81120a24:	102d883a 	mov	r22,r2
81120a28:	00800244 	movi	r2,9
81120a2c:	15bff416 	blt	r2,r22,81120a00 <__reset+0xfb100a00>
81120a30:	9811883a 	mov	r8,r19
81120a34:	b0800c04 	addi	r2,r22,48
81120a38:	8027883a 	mov	r19,r16
81120a3c:	997fffc4 	addi	r5,r19,-1
81120a40:	98bfffc5 	stb	r2,-1(r19)
81120a44:	dc002917 	ldw	r16,164(sp)
81120a48:	2f006a2e 	bgeu	r5,fp,81120bf4 <___vfprintf_internal_r+0x21d8>
81120a4c:	d9c02384 	addi	r7,sp,142
81120a50:	3ccfc83a 	sub	r7,r7,r19
81120a54:	d9002344 	addi	r4,sp,141
81120a58:	e1cf883a 	add	r7,fp,r7
81120a5c:	00000106 	br	81120a64 <___vfprintf_internal_r+0x2048>
81120a60:	28800003 	ldbu	r2,0(r5)
81120a64:	20800005 	stb	r2,0(r4)
81120a68:	21000044 	addi	r4,r4,1
81120a6c:	29400044 	addi	r5,r5,1
81120a70:	393ffb1e 	bne	r7,r4,81120a60 <__reset+0xfb100a60>
81120a74:	d8802304 	addi	r2,sp,140
81120a78:	14c5c83a 	sub	r2,r2,r19
81120a7c:	d8c02344 	addi	r3,sp,141
81120a80:	1885883a 	add	r2,r3,r2
81120a84:	003f7006 	br	81120848 <__reset+0xfb100848>
81120a88:	0005883a 	mov	r2,zero
81120a8c:	003f0f06 	br	811206cc <__reset+0xfb1006cc>
81120a90:	d8c03217 	ldw	r3,200(sp)
81120a94:	18c00044 	addi	r3,r3,1
81120a98:	d8c02e15 	stw	r3,184(sp)
81120a9c:	1805883a 	mov	r2,r3
81120aa0:	183fb20e 	bge	r3,zero,8112096c <__reset+0xfb10096c>
81120aa4:	0005883a 	mov	r2,zero
81120aa8:	003fb006 	br	8112096c <__reset+0xfb10096c>
81120aac:	d9003617 	ldw	r4,216(sp)
81120ab0:	000d883a 	mov	r6,zero
81120ab4:	000f883a 	mov	r7,zero
81120ab8:	980b883a 	mov	r5,r19
81120abc:	d8c03c15 	stw	r3,240(sp)
81120ac0:	da003d15 	stw	r8,244(sp)
81120ac4:	112f4540 	call	8112f454 <__eqdf2>
81120ac8:	d8c03c17 	ldw	r3,240(sp)
81120acc:	da003d17 	ldw	r8,244(sp)
81120ad0:	103f9826 	beq	r2,zero,81120934 <__reset+0xfb100934>
81120ad4:	00800044 	movi	r2,1
81120ad8:	10c7c83a 	sub	r3,r2,r3
81120adc:	d8c02615 	stw	r3,152(sp)
81120ae0:	003f9506 	br	81120938 <__reset+0xfb100938>
81120ae4:	d9002917 	ldw	r4,164(sp)
81120ae8:	d8c03217 	ldw	r3,200(sp)
81120aec:	20800044 	addi	r2,r4,1
81120af0:	1885883a 	add	r2,r3,r2
81120af4:	d8802e15 	stw	r2,184(sp)
81120af8:	103dbf0e 	bge	r2,zero,811201f8 <__reset+0xfb1001f8>
81120afc:	0005883a 	mov	r2,zero
81120b00:	003dbd06 	br	811201f8 <__reset+0xfb1001f8>
81120b04:	2000211e 	bne	r4,zero,81120b8c <___vfprintf_internal_r+0x2170>
81120b08:	9480004c 	andi	r18,r18,1
81120b0c:	90001f1e 	bne	r18,zero,81120b8c <___vfprintf_internal_r+0x2170>
81120b10:	00800044 	movi	r2,1
81120b14:	d8802e15 	stw	r2,184(sp)
81120b18:	003db706 	br	811201f8 <__reset+0xfb1001f8>
81120b1c:	00800b44 	movi	r2,45
81120b20:	05adc83a 	sub	r22,zero,r22
81120b24:	d8802305 	stb	r2,140(sp)
81120b28:	003f3f06 	br	81120828 <__reset+0xfb100828>
81120b2c:	0005883a 	mov	r2,zero
81120b30:	003f5206 	br	8112087c <__reset+0xfb10087c>
81120b34:	90a4703a 	and	r18,r18,r2
81120b38:	903f4e26 	beq	r18,zero,81120874 <__reset+0xfb100874>
81120b3c:	003f4a06 	br	81120868 <__reset+0xfb100868>
81120b40:	00800084 	movi	r2,2
81120b44:	10c5c83a 	sub	r2,r2,r3
81120b48:	003f8406 	br	8112095c <__reset+0xfb10095c>
81120b4c:	d8802d17 	ldw	r2,180(sp)
81120b50:	d9002d17 	ldw	r4,180(sp)
81120b54:	ac400043 	ldbu	r17,1(r21)
81120b58:	10800017 	ldw	r2,0(r2)
81120b5c:	582b883a 	mov	r21,r11
81120b60:	d8802915 	stw	r2,164(sp)
81120b64:	20800104 	addi	r2,r4,4
81120b68:	d9002917 	ldw	r4,164(sp)
81120b6c:	d8802d15 	stw	r2,180(sp)
81120b70:	203e7a0e 	bge	r4,zero,8112055c <__reset+0xfb10055c>
81120b74:	8c403fcc 	andi	r17,r17,255
81120b78:	00bfffc4 	movi	r2,-1
81120b7c:	8c40201c 	xori	r17,r17,128
81120b80:	d8802915 	stw	r2,164(sp)
81120b84:	8c7fe004 	addi	r17,r17,-128
81120b88:	00380706 	br	8111eba8 <__reset+0xfb0feba8>
81120b8c:	d8c02917 	ldw	r3,164(sp)
81120b90:	18c00084 	addi	r3,r3,2
81120b94:	d8c02e15 	stw	r3,184(sp)
81120b98:	1805883a 	mov	r2,r3
81120b9c:	183d960e 	bge	r3,zero,811201f8 <__reset+0xfb1001f8>
81120ba0:	003fd606 	br	81120afc <__reset+0xfb100afc>
81120ba4:	0005883a 	mov	r2,zero
81120ba8:	003f8e06 	br	811209e4 <__reset+0xfb1009e4>
81120bac:	9080004c 	andi	r2,r18,1
81120bb0:	103f811e 	bne	r2,zero,811209b8 <__reset+0xfb1009b8>
81120bb4:	d8802117 	ldw	r2,132(sp)
81120bb8:	1405c83a 	sub	r2,r2,r16
81120bbc:	d8803315 	stw	r2,204(sp)
81120bc0:	b47ef326 	beq	r22,r17,81120790 <__reset+0xfb100790>
81120bc4:	dd802617 	ldw	r22,152(sp)
81120bc8:	003f1106 	br	81120810 <__reset+0xfb100810>
81120bcc:	d9c02785 	stb	r7,158(sp)
81120bd0:	00390406 	br	8111efe4 <__reset+0xfb0fefe4>
81120bd4:	d9c02785 	stb	r7,158(sp)
81120bd8:	0038d306 	br	8111ef28 <__reset+0xfb0fef28>
81120bdc:	d9c02785 	stb	r7,158(sp)
81120be0:	003a6106 	br	8111f568 <__reset+0xfb0ff568>
81120be4:	d9c02785 	stb	r7,158(sp)
81120be8:	003af806 	br	8111f7cc <__reset+0xfb0ff7cc>
81120bec:	0005883a 	mov	r2,zero
81120bf0:	003d7e06 	br	811201ec <__reset+0xfb1001ec>
81120bf4:	d8802344 	addi	r2,sp,141
81120bf8:	003f1306 	br	81120848 <__reset+0xfb100848>
81120bfc:	d9c02785 	stb	r7,158(sp)
81120c00:	00392306 	br	8111f090 <__reset+0xfb0ff090>
81120c04:	d9c02785 	stb	r7,158(sp)
81120c08:	003aa906 	br	8111f6b0 <__reset+0xfb0ff6b0>
81120c0c:	d9c02785 	stb	r7,158(sp)
81120c10:	003a3d06 	br	8111f508 <__reset+0xfb0ff508>
81120c14:	d9c02785 	stb	r7,158(sp)
81120c18:	003aca06 	br	8111f744 <__reset+0xfb0ff744>

81120c1c <__vfprintf_internal>:
81120c1c:	00a04574 	movhi	r2,33045
81120c20:	10b08204 	addi	r2,r2,-15864
81120c24:	300f883a 	mov	r7,r6
81120c28:	280d883a 	mov	r6,r5
81120c2c:	200b883a 	mov	r5,r4
81120c30:	11000017 	ldw	r4,0(r2)
81120c34:	111ea1c1 	jmpi	8111ea1c <___vfprintf_internal_r>

81120c38 <__sbprintf>:
81120c38:	defee204 	addi	sp,sp,-1144
81120c3c:	de00012e 	bgeu	sp,et,81120c44 <__sbprintf+0xc>
81120c40:	003b68fa 	trap	3
81120c44:	2880030b 	ldhu	r2,12(r5)
81120c48:	2ac01917 	ldw	r11,100(r5)
81120c4c:	2a80038b 	ldhu	r10,14(r5)
81120c50:	2a400717 	ldw	r9,28(r5)
81120c54:	2a000917 	ldw	r8,36(r5)
81120c58:	00c10004 	movi	r3,1024
81120c5c:	dc011a15 	stw	r16,1128(sp)
81120c60:	10bfff4c 	andi	r2,r2,65533
81120c64:	2821883a 	mov	r16,r5
81120c68:	d8cb883a 	add	r5,sp,r3
81120c6c:	dc811c15 	stw	r18,1136(sp)
81120c70:	dc411b15 	stw	r17,1132(sp)
81120c74:	dfc11d15 	stw	ra,1140(sp)
81120c78:	2025883a 	mov	r18,r4
81120c7c:	d881030d 	sth	r2,1036(sp)
81120c80:	dac11915 	stw	r11,1124(sp)
81120c84:	da81038d 	sth	r10,1038(sp)
81120c88:	da410715 	stw	r9,1052(sp)
81120c8c:	da010915 	stw	r8,1060(sp)
81120c90:	dec10015 	stw	sp,1024(sp)
81120c94:	dec10415 	stw	sp,1040(sp)
81120c98:	d8c10215 	stw	r3,1032(sp)
81120c9c:	d8c10515 	stw	r3,1044(sp)
81120ca0:	d8010615 	stw	zero,1048(sp)
81120ca4:	111ea1c0 	call	8111ea1c <___vfprintf_internal_r>
81120ca8:	1023883a 	mov	r17,r2
81120cac:	10000416 	blt	r2,zero,81120cc0 <__sbprintf+0x88>
81120cb0:	d9410004 	addi	r5,sp,1024
81120cb4:	9009883a 	mov	r4,r18
81120cb8:	11243dc0 	call	811243dc <_fflush_r>
81120cbc:	10000d1e 	bne	r2,zero,81120cf4 <__sbprintf+0xbc>
81120cc0:	d881030b 	ldhu	r2,1036(sp)
81120cc4:	1080100c 	andi	r2,r2,64
81120cc8:	10000326 	beq	r2,zero,81120cd8 <__sbprintf+0xa0>
81120ccc:	8080030b 	ldhu	r2,12(r16)
81120cd0:	10801014 	ori	r2,r2,64
81120cd4:	8080030d 	sth	r2,12(r16)
81120cd8:	8805883a 	mov	r2,r17
81120cdc:	dfc11d17 	ldw	ra,1140(sp)
81120ce0:	dc811c17 	ldw	r18,1136(sp)
81120ce4:	dc411b17 	ldw	r17,1132(sp)
81120ce8:	dc011a17 	ldw	r16,1128(sp)
81120cec:	dec11e04 	addi	sp,sp,1144
81120cf0:	f800283a 	ret
81120cf4:	047fffc4 	movi	r17,-1
81120cf8:	003ff106 	br	81120cc0 <__reset+0xfb100cc0>

81120cfc <__svfscanf_r>:
81120cfc:	deff4b04 	addi	sp,sp,-724
81120d00:	de00012e 	bgeu	sp,et,81120d08 <__svfscanf_r+0xc>
81120d04:	003b68fa 	trap	3
81120d08:	2880030b 	ldhu	r2,12(r5)
81120d0c:	df00b315 	stw	fp,716(sp)
81120d10:	dd80b115 	stw	r22,708(sp)
81120d14:	dfc0b415 	stw	ra,720(sp)
81120d18:	ddc0b215 	stw	r23,712(sp)
81120d1c:	dd40b015 	stw	r21,704(sp)
81120d20:	dd00af15 	stw	r20,700(sp)
81120d24:	dcc0ae15 	stw	r19,696(sp)
81120d28:	dc80ad15 	stw	r18,692(sp)
81120d2c:	dc40ac15 	stw	r17,688(sp)
81120d30:	dc00ab15 	stw	r16,684(sp)
81120d34:	10c8000c 	andi	r3,r2,8192
81120d38:	d9c09c15 	stw	r7,624(sp)
81120d3c:	2839883a 	mov	fp,r5
81120d40:	202d883a 	mov	r22,r4
81120d44:	1800061e 	bne	r3,zero,81120d60 <__svfscanf_r+0x64>
81120d48:	29001917 	ldw	r4,100(r5)
81120d4c:	00f7ffc4 	movi	r3,-8193
81120d50:	10880014 	ori	r2,r2,8192
81120d54:	20c6703a 	and	r3,r4,r3
81120d58:	2880030d 	sth	r2,12(r5)
81120d5c:	28c01915 	stw	r3,100(r5)
81120d60:	30800003 	ldbu	r2,0(r6)
81120d64:	0021883a 	mov	r16,zero
81120d68:	05e04574 	movhi	r23,33045
81120d6c:	d800a115 	stw	zero,644(sp)
81120d70:	d8009e15 	stw	zero,632(sp)
81120d74:	d800a015 	stw	zero,640(sp)
81120d78:	d8809b15 	stw	r2,620(sp)
81120d7c:	bdf08004 	addi	r23,r23,-15872
81120d80:	8025883a 	mov	r18,r16
81120d84:	35000044 	addi	r20,r6,1
81120d88:	10001e26 	beq	r2,zero,81120e04 <__svfscanf_r+0x108>
81120d8c:	b9c00017 	ldw	r7,0(r23)
81120d90:	3887883a 	add	r3,r7,r2
81120d94:	18c00043 	ldbu	r3,1(r3)
81120d98:	18c0020c 	andi	r3,r3,8
81120d9c:	18001b26 	beq	r3,zero,81120e0c <__svfscanf_r+0x110>
81120da0:	e0800117 	ldw	r2,4(fp)
81120da4:	00800e0e 	bge	zero,r2,81120de0 <__svfscanf_r+0xe4>
81120da8:	e0c00017 	ldw	r3,0(fp)
81120dac:	b9000017 	ldw	r4,0(r23)
81120db0:	18800003 	ldbu	r2,0(r3)
81120db4:	2085883a 	add	r2,r4,r2
81120db8:	10800043 	ldbu	r2,1(r2)
81120dbc:	1080020c 	andi	r2,r2,8
81120dc0:	10000b26 	beq	r2,zero,81120df0 <__svfscanf_r+0xf4>
81120dc4:	e0800117 	ldw	r2,4(fp)
81120dc8:	18c00044 	addi	r3,r3,1
81120dcc:	e0c00015 	stw	r3,0(fp)
81120dd0:	10bfffc4 	addi	r2,r2,-1
81120dd4:	e0800115 	stw	r2,4(fp)
81120dd8:	94800044 	addi	r18,r18,1
81120ddc:	00bff216 	blt	zero,r2,81120da8 <__reset+0xfb100da8>
81120de0:	e00b883a 	mov	r5,fp
81120de4:	b009883a 	mov	r4,r22
81120de8:	111bfdc0 	call	8111bfdc <__srefill_r>
81120dec:	103fee26 	beq	r2,zero,81120da8 <__reset+0xfb100da8>
81120df0:	a00d883a 	mov	r6,r20
81120df4:	30800003 	ldbu	r2,0(r6)
81120df8:	35000044 	addi	r20,r6,1
81120dfc:	d8809b15 	stw	r2,620(sp)
81120e00:	103fe21e 	bne	r2,zero,81120d8c <__reset+0xfb100d8c>
81120e04:	d880a017 	ldw	r2,640(sp)
81120e08:	00009906 	br	81121070 <__svfscanf_r+0x374>
81120e0c:	00c00944 	movi	r3,37
81120e10:	10c0881e 	bne	r2,r3,81121034 <__svfscanf_r+0x338>
81120e14:	30c00043 	ldbu	r3,1(r6)
81120e18:	0023883a 	mov	r17,zero
81120e1c:	0027883a 	mov	r19,zero
81120e20:	01001e04 	movi	r4,120
81120e24:	01401b04 	movi	r5,108
81120e28:	a1800044 	addi	r6,r20,1
81120e2c:	20c0a236 	bltu	r4,r3,811210b8 <__svfscanf_r+0x3bc>
81120e30:	180490ba 	slli	r2,r3,2
81120e34:	022044b4 	movhi	r8,33042
81120e38:	42039204 	addi	r8,r8,3656
81120e3c:	1205883a 	add	r2,r2,r8
81120e40:	10800017 	ldw	r2,0(r2)
81120e44:	1000683a 	jmp	r2
81120e48:	8112106c 	andhi	r4,r16,18497
81120e4c:	811210b8 	rdprs	r4,r16,18498
81120e50:	811210b8 	rdprs	r4,r16,18498
81120e54:	811210b8 	rdprs	r4,r16,18498
81120e58:	811210b8 	rdprs	r4,r16,18498
81120e5c:	811210b8 	rdprs	r4,r16,18498
81120e60:	811210b8 	rdprs	r4,r16,18498
81120e64:	811210b8 	rdprs	r4,r16,18498
81120e68:	811210b8 	rdprs	r4,r16,18498
81120e6c:	811210b8 	rdprs	r4,r16,18498
81120e70:	811210b8 	rdprs	r4,r16,18498
81120e74:	811210b8 	rdprs	r4,r16,18498
81120e78:	811210b8 	rdprs	r4,r16,18498
81120e7c:	811210b8 	rdprs	r4,r16,18498
81120e80:	811210b8 	rdprs	r4,r16,18498
81120e84:	811210b8 	rdprs	r4,r16,18498
81120e88:	811210b8 	rdprs	r4,r16,18498
81120e8c:	811210b8 	rdprs	r4,r16,18498
81120e90:	811210b8 	rdprs	r4,r16,18498
81120e94:	811210b8 	rdprs	r4,r16,18498
81120e98:	811210b8 	rdprs	r4,r16,18498
81120e9c:	811210b8 	rdprs	r4,r16,18498
81120ea0:	811210b8 	rdprs	r4,r16,18498
81120ea4:	811210b8 	rdprs	r4,r16,18498
81120ea8:	811210b8 	rdprs	r4,r16,18498
81120eac:	811210b8 	rdprs	r4,r16,18498
81120eb0:	811210b8 	rdprs	r4,r16,18498
81120eb4:	811210b8 	rdprs	r4,r16,18498
81120eb8:	811210b8 	rdprs	r4,r16,18498
81120ebc:	811210b8 	rdprs	r4,r16,18498
81120ec0:	811210b8 	rdprs	r4,r16,18498
81120ec4:	811210b8 	rdprs	r4,r16,18498
81120ec8:	811210b8 	rdprs	r4,r16,18498
81120ecc:	811210b8 	rdprs	r4,r16,18498
81120ed0:	811210b8 	rdprs	r4,r16,18498
81120ed4:	811210b8 	rdprs	r4,r16,18498
81120ed8:	811210b8 	rdprs	r4,r16,18498
81120edc:	8112102c 	andhi	r4,r16,18496
81120ee0:	811210b8 	rdprs	r4,r16,18498
81120ee4:	811210b8 	rdprs	r4,r16,18498
81120ee8:	811210b8 	rdprs	r4,r16,18498
81120eec:	811210b8 	rdprs	r4,r16,18498
81120ef0:	811210a0 	cmpeqi	r4,r16,18498
81120ef4:	811210b8 	rdprs	r4,r16,18498
81120ef8:	811210b8 	rdprs	r4,r16,18498
81120efc:	811210b8 	rdprs	r4,r16,18498
81120f00:	811210b8 	rdprs	r4,r16,18498
81120f04:	811210b8 	rdprs	r4,r16,18498
81120f08:	811211d4 	ori	r4,r16,18503
81120f0c:	811211d4 	ori	r4,r16,18503
81120f10:	811211d4 	ori	r4,r16,18503
81120f14:	811211d4 	ori	r4,r16,18503
81120f18:	811211d4 	ori	r4,r16,18503
81120f1c:	811211d4 	ori	r4,r16,18503
81120f20:	811211d4 	ori	r4,r16,18503
81120f24:	811211d4 	ori	r4,r16,18503
81120f28:	811211d4 	ori	r4,r16,18503
81120f2c:	811211d4 	ori	r4,r16,18503
81120f30:	811210b8 	rdprs	r4,r16,18498
81120f34:	811210b8 	rdprs	r4,r16,18498
81120f38:	811210b8 	rdprs	r4,r16,18498
81120f3c:	811210b8 	rdprs	r4,r16,18498
81120f40:	811210b8 	rdprs	r4,r16,18498
81120f44:	811210b8 	rdprs	r4,r16,18498
81120f48:	811210b8 	rdprs	r4,r16,18498
81120f4c:	811210b8 	rdprs	r4,r16,18498
81120f50:	811210b8 	rdprs	r4,r16,18498
81120f54:	811210b8 	rdprs	r4,r16,18498
81120f58:	811211a8 	cmpgeui	r4,r16,18502
81120f5c:	81121258 	cmpnei	r4,r16,18505
81120f60:	811210b8 	rdprs	r4,r16,18498
81120f64:	81121258 	cmpnei	r4,r16,18505
81120f68:	811210b8 	rdprs	r4,r16,18498
81120f6c:	811210b8 	rdprs	r4,r16,18498
81120f70:	811210b8 	rdprs	r4,r16,18498
81120f74:	811210b8 	rdprs	r4,r16,18498
81120f78:	81121244 	addi	r4,r16,18505
81120f7c:	811210b8 	rdprs	r4,r16,18498
81120f80:	811210b8 	rdprs	r4,r16,18498
81120f84:	81121218 	cmpnei	r4,r16,18504
81120f88:	811210b8 	rdprs	r4,r16,18498
81120f8c:	811210b8 	rdprs	r4,r16,18498
81120f90:	811210b8 	rdprs	r4,r16,18498
81120f94:	811210b8 	rdprs	r4,r16,18498
81120f98:	811210b8 	rdprs	r4,r16,18498
81120f9c:	811210b8 	rdprs	r4,r16,18498
81120fa0:	811210b8 	rdprs	r4,r16,18498
81120fa4:	811210b8 	rdprs	r4,r16,18498
81120fa8:	811211f0 	cmpltui	r4,r16,18503
81120fac:	811210b8 	rdprs	r4,r16,18498
81120fb0:	811210b8 	rdprs	r4,r16,18498
81120fb4:	8112138c 	andi	r4,r16,18510
81120fb8:	811210b8 	rdprs	r4,r16,18498
81120fbc:	811210b8 	rdprs	r4,r16,18498
81120fc0:	811210b8 	rdprs	r4,r16,18498
81120fc4:	811210b8 	rdprs	r4,r16,18498
81120fc8:	811210b8 	rdprs	r4,r16,18498
81120fcc:	811210b8 	rdprs	r4,r16,18498
81120fd0:	811210b8 	rdprs	r4,r16,18498
81120fd4:	81121310 	cmplti	r4,r16,18508
81120fd8:	811212e8 	cmpgeui	r4,r16,18507
81120fdc:	81121258 	cmpnei	r4,r16,18505
81120fe0:	81121258 	cmpnei	r4,r16,18505
81120fe4:	81121258 	cmpnei	r4,r16,18505
81120fe8:	811212d4 	ori	r4,r16,18507
81120fec:	81121418 	cmpnei	r4,r16,18512
81120ff0:	811210b8 	rdprs	r4,r16,18498
81120ff4:	811210b8 	rdprs	r4,r16,18498
81120ff8:	811212c0 	call	8811212c <__reset+0x20f212c>
81120ffc:	811210b8 	rdprs	r4,r16,18498
81121000:	81121290 	cmplti	r4,r16,18506
81121004:	8112126c 	andhi	r4,r16,18505
81121008:	8112117c 	xorhi	r4,r16,18501
8112100c:	811210b8 	rdprs	r4,r16,18498
81121010:	811210b8 	rdprs	r4,r16,18498
81121014:	81121168 	cmpgeui	r4,r16,18501
81121018:	811210b8 	rdprs	r4,r16,18498
8112101c:	811210f0 	cmpltui	r4,r16,18499
81121020:	811210b8 	rdprs	r4,r16,18498
81121024:	811210b8 	rdprs	r4,r16,18498
81121028:	811211f0 	cmpltui	r4,r16,18503
8112102c:	d9809d15 	stw	r6,628(sp)
81121030:	3029883a 	mov	r20,r6
81121034:	e0800117 	ldw	r2,4(fp)
81121038:	0081aa0e 	bge	zero,r2,811216e4 <__svfscanf_r+0x9e8>
8112103c:	e0800017 	ldw	r2,0(fp)
81121040:	a0ffffc3 	ldbu	r3,-1(r20)
81121044:	11000003 	ldbu	r4,0(r2)
81121048:	20ff6e1e 	bne	r4,r3,81120e04 <__reset+0xfb100e04>
8112104c:	e0c00117 	ldw	r3,4(fp)
81121050:	10800044 	addi	r2,r2,1
81121054:	e0800015 	stw	r2,0(fp)
81121058:	18bfffc4 	addi	r2,r3,-1
8112105c:	e0800115 	stw	r2,4(fp)
81121060:	94800044 	addi	r18,r18,1
81121064:	a00d883a 	mov	r6,r20
81121068:	003f6206 	br	81120df4 <__reset+0xfb100df4>
8112106c:	00bfffc4 	movi	r2,-1
81121070:	dfc0b417 	ldw	ra,720(sp)
81121074:	df00b317 	ldw	fp,716(sp)
81121078:	ddc0b217 	ldw	r23,712(sp)
8112107c:	dd80b117 	ldw	r22,708(sp)
81121080:	dd40b017 	ldw	r21,704(sp)
81121084:	dd00af17 	ldw	r20,700(sp)
81121088:	dcc0ae17 	ldw	r19,696(sp)
8112108c:	dc80ad17 	ldw	r18,692(sp)
81121090:	dc40ac17 	ldw	r17,688(sp)
81121094:	dc00ab17 	ldw	r16,684(sp)
81121098:	dec0b504 	addi	sp,sp,724
8112109c:	f800283a 	ret
811210a0:	a0800043 	ldbu	r2,1(r20)
811210a4:	3029883a 	mov	r20,r6
811210a8:	8c400414 	ori	r17,r17,16
811210ac:	10c03fcc 	andi	r3,r2,255
811210b0:	a1800044 	addi	r6,r20,1
811210b4:	20ff5e2e 	bgeu	r4,r3,81120e30 <__reset+0xfb100e30>
811210b8:	38c7883a 	add	r3,r7,r3
811210bc:	18800043 	ldbu	r2,1(r3)
811210c0:	d9809d15 	stw	r6,628(sp)
811210c4:	00c00044 	movi	r3,1
811210c8:	108000cc 	andi	r2,r2,3
811210cc:	10c18f26 	beq	r2,r3,8112170c <__svfscanf_r+0xa10>
811210d0:	e0800117 	ldw	r2,4(fp)
811210d4:	00808716 	blt	zero,r2,811212f4 <__svfscanf_r+0x5f8>
811210d8:	e00b883a 	mov	r5,fp
811210dc:	b009883a 	mov	r4,r22
811210e0:	111bfdc0 	call	8111bfdc <__srefill_r>
811210e4:	1001431e 	bne	r2,zero,811215f4 <__svfscanf_r+0x8f8>
811210e8:	b9c00017 	ldw	r7,0(r23)
811210ec:	00008106 	br	811212f4 <__svfscanf_r+0x5f8>
811210f0:	e0800117 	ldw	r2,4(fp)
811210f4:	d9809d15 	stw	r6,628(sp)
811210f8:	0081a30e 	bge	zero,r2,81121788 <__svfscanf_r+0xa8c>
811210fc:	00a044f4 	movhi	r2,33043
81121100:	10a3c304 	addi	r2,r2,-28916
81121104:	02000284 	movi	r8,10
81121108:	d880a115 	stw	r2,644(sp)
8112110c:	da009e15 	stw	r8,632(sp)
81121110:	050000c4 	movi	r20,3
81121114:	e0c00017 	ldw	r3,0(fp)
81121118:	00000206 	br	81121124 <__svfscanf_r+0x428>
8112111c:	18c00044 	addi	r3,r3,1
81121120:	e0c00015 	stw	r3,0(fp)
81121124:	19000003 	ldbu	r4,0(r3)
81121128:	20803fcc 	andi	r2,r4,255
8112112c:	3885883a 	add	r2,r7,r2
81121130:	10800043 	ldbu	r2,1(r2)
81121134:	1140020c 	andi	r5,r2,8
81121138:	2801ab26 	beq	r5,zero,811217e8 <__svfscanf_r+0xaec>
8112113c:	e0800117 	ldw	r2,4(fp)
81121140:	94800044 	addi	r18,r18,1
81121144:	10bfffc4 	addi	r2,r2,-1
81121148:	e0800115 	stw	r2,4(fp)
8112114c:	00bff316 	blt	zero,r2,8112111c <__reset+0xfb10111c>
81121150:	e00b883a 	mov	r5,fp
81121154:	b009883a 	mov	r4,r22
81121158:	111bfdc0 	call	8111bfdc <__srefill_r>
8112115c:	1001251e 	bne	r2,zero,811215f4 <__svfscanf_r+0x8f8>
81121160:	b9c00017 	ldw	r7,0(r23)
81121164:	003feb06 	br	81121114 <__reset+0xfb101114>
81121168:	e0800117 	ldw	r2,4(fp)
8112116c:	d9809d15 	stw	r6,628(sp)
81121170:	00818b0e 	bge	zero,r2,811217a0 <__svfscanf_r+0xaa4>
81121174:	05000084 	movi	r20,2
81121178:	003fe606 	br	81121114 <__reset+0xfb101114>
8112117c:	e0800117 	ldw	r2,4(fp)
81121180:	d9809d15 	stw	r6,628(sp)
81121184:	8c408814 	ori	r17,r17,544
81121188:	00801d0e 	bge	zero,r2,81121200 <__svfscanf_r+0x504>
8112118c:	00a044f4 	movhi	r2,33043
81121190:	10a3c304 	addi	r2,r2,-28916
81121194:	02000404 	movi	r8,16
81121198:	d880a115 	stw	r2,644(sp)
8112119c:	da009e15 	stw	r8,632(sp)
811211a0:	050000c4 	movi	r20,3
811211a4:	003fdb06 	br	81121114 <__reset+0xfb101114>
811211a8:	e0800117 	ldw	r2,4(fp)
811211ac:	d9809d15 	stw	r6,628(sp)
811211b0:	8c400054 	ori	r17,r17,1
811211b4:	00bfc80e 	bge	zero,r2,811210d8 <__reset+0xfb1010d8>
811211b8:	00e044b4 	movhi	r3,33042
811211bc:	18f17804 	addi	r3,r3,-14880
811211c0:	02000284 	movi	r8,10
811211c4:	d8c0a115 	stw	r3,644(sp)
811211c8:	da009e15 	stw	r8,632(sp)
811211cc:	050000c4 	movi	r20,3
811211d0:	003fd006 	br	81121114 <__reset+0xfb101114>
811211d4:	9cc002a4 	muli	r19,r19,10
811211d8:	a0800043 	ldbu	r2,1(r20)
811211dc:	3029883a 	mov	r20,r6
811211e0:	98e7883a 	add	r19,r19,r3
811211e4:	9cfff404 	addi	r19,r19,-48
811211e8:	10c03fcc 	andi	r3,r2,255
811211ec:	003f0e06 	br	81120e28 <__reset+0xfb100e28>
811211f0:	e0800117 	ldw	r2,4(fp)
811211f4:	d9809d15 	stw	r6,628(sp)
811211f8:	8c408014 	ori	r17,r17,512
811211fc:	00bfe316 	blt	zero,r2,8112118c <__reset+0xfb10118c>
81121200:	e00b883a 	mov	r5,fp
81121204:	b009883a 	mov	r4,r22
81121208:	111bfdc0 	call	8111bfdc <__srefill_r>
8112120c:	1000f91e 	bne	r2,zero,811215f4 <__svfscanf_r+0x8f8>
81121210:	b9c00017 	ldw	r7,0(r23)
81121214:	003fdd06 	br	8112118c <__reset+0xfb10118c>
81121218:	e0800117 	ldw	r2,4(fp)
8112121c:	d9809d15 	stw	r6,628(sp)
81121220:	8c400054 	ori	r17,r17,1
81121224:	0080140e 	bge	zero,r2,81121278 <__svfscanf_r+0x57c>
81121228:	00a044f4 	movhi	r2,33043
8112122c:	10a3c304 	addi	r2,r2,-28916
81121230:	02000204 	movi	r8,8
81121234:	d880a115 	stw	r2,644(sp)
81121238:	da009e15 	stw	r8,632(sp)
8112123c:	050000c4 	movi	r20,3
81121240:	003fb406 	br	81121114 <__reset+0xfb101114>
81121244:	a0800043 	ldbu	r2,1(r20)
81121248:	8c400094 	ori	r17,r17,2
8112124c:	3029883a 	mov	r20,r6
81121250:	10c03fcc 	andi	r3,r2,255
81121254:	003ef406 	br	81120e28 <__reset+0xfb100e28>
81121258:	e0800117 	ldw	r2,4(fp)
8112125c:	d9809d15 	stw	r6,628(sp)
81121260:	0081420e 	bge	zero,r2,8112176c <__svfscanf_r+0xa70>
81121264:	05000104 	movi	r20,4
81121268:	003faa06 	br	81121114 <__reset+0xfb101114>
8112126c:	e0800117 	ldw	r2,4(fp)
81121270:	d9809d15 	stw	r6,628(sp)
81121274:	00bfec16 	blt	zero,r2,81121228 <__reset+0xfb101228>
81121278:	e00b883a 	mov	r5,fp
8112127c:	b009883a 	mov	r4,r22
81121280:	111bfdc0 	call	8111bfdc <__srefill_r>
81121284:	1000db1e 	bne	r2,zero,811215f4 <__svfscanf_r+0x8f8>
81121288:	b9c00017 	ldw	r7,0(r23)
8112128c:	003fe606 	br	81121228 <__reset+0xfb101228>
81121290:	d9809d15 	stw	r6,628(sp)
81121294:	8880040c 	andi	r2,r17,16
81121298:	10009c1e 	bne	r2,zero,8112150c <__svfscanf_r+0x810>
8112129c:	8880010c 	andi	r2,r17,4
811212a0:	10011e26 	beq	r2,zero,8112171c <__svfscanf_r+0xa20>
811212a4:	da009c17 	ldw	r8,624(sp)
811212a8:	3029883a 	mov	r20,r6
811212ac:	40800017 	ldw	r2,0(r8)
811212b0:	42000104 	addi	r8,r8,4
811212b4:	da009c15 	stw	r8,624(sp)
811212b8:	1480000d 	sth	r18,0(r2)
811212bc:	003ecc06 	br	81120df0 <__reset+0xfb100df0>
811212c0:	a0c00043 	ldbu	r3,1(r20)
811212c4:	19410c26 	beq	r3,r5,811216f8 <__svfscanf_r+0x9fc>
811212c8:	8c400054 	ori	r17,r17,1
811212cc:	3029883a 	mov	r20,r6
811212d0:	003ed506 	br	81120e28 <__reset+0xfb100e28>
811212d4:	a0800043 	ldbu	r2,1(r20)
811212d8:	8c400114 	ori	r17,r17,4
811212dc:	3029883a 	mov	r20,r6
811212e0:	10c03fcc 	andi	r3,r2,255
811212e4:	003ed006 	br	81120e28 <__reset+0xfb100e28>
811212e8:	e0800117 	ldw	r2,4(fp)
811212ec:	d9809d15 	stw	r6,628(sp)
811212f0:	00bf790e 	bge	zero,r2,811210d8 <__reset+0xfb1010d8>
811212f4:	00a044b4 	movhi	r2,33042
811212f8:	10b17804 	addi	r2,r2,-14880
811212fc:	02000284 	movi	r8,10
81121300:	d880a115 	stw	r2,644(sp)
81121304:	da009e15 	stw	r8,632(sp)
81121308:	050000c4 	movi	r20,3
8112130c:	003f8106 	br	81121114 <__reset+0xfb101114>
81121310:	e0800117 	ldw	r2,4(fp)
81121314:	d9809d15 	stw	r6,628(sp)
81121318:	0080c40e 	bge	zero,r2,8112162c <__svfscanf_r+0x930>
8112131c:	9800011e 	bne	r19,zero,81121324 <__svfscanf_r+0x628>
81121320:	04c00044 	movi	r19,1
81121324:	8880004c 	andi	r2,r17,1
81121328:	1000441e 	bne	r2,zero,8112143c <__svfscanf_r+0x740>
8112132c:	8c40040c 	andi	r17,r17,16
81121330:	8800da26 	beq	r17,zero,8112169c <__svfscanf_r+0x9a0>
81121334:	0021883a 	mov	r16,zero
81121338:	00000806 	br	8112135c <__svfscanf_r+0x660>
8112133c:	1887883a 	add	r3,r3,r2
81121340:	e00b883a 	mov	r5,fp
81121344:	b009883a 	mov	r4,r22
81121348:	e0c00015 	stw	r3,0(fp)
8112134c:	80a1883a 	add	r16,r16,r2
81121350:	98a7c83a 	sub	r19,r19,r2
81121354:	111bfdc0 	call	8111bfdc <__srefill_r>
81121358:	1000ca1e 	bne	r2,zero,81121684 <__svfscanf_r+0x988>
8112135c:	e0800117 	ldw	r2,4(fp)
81121360:	e0c00017 	ldw	r3,0(fp)
81121364:	14fff516 	blt	r2,r19,8112133c <__reset+0xfb10133c>
81121368:	14c5c83a 	sub	r2,r2,r19
8112136c:	1cd5883a 	add	r10,r3,r19
81121370:	84e1883a 	add	r16,r16,r19
81121374:	e0800115 	stw	r2,4(fp)
81121378:	e2800015 	stw	r10,0(fp)
8112137c:	dd009d17 	ldw	r20,628(sp)
81121380:	9425883a 	add	r18,r18,r16
81121384:	a00d883a 	mov	r6,r20
81121388:	003e9a06 	br	81120df4 <__reset+0xfb100df4>
8112138c:	300b883a 	mov	r5,r6
81121390:	d9005884 	addi	r4,sp,354
81121394:	d9809d15 	stw	r6,628(sp)
81121398:	11272e40 	call	811272e4 <__sccl>
8112139c:	1029883a 	mov	r20,r2
811213a0:	e0800117 	ldw	r2,4(fp)
811213a4:	0081050e 	bge	zero,r2,811217bc <__svfscanf_r+0xac0>
811213a8:	e1000017 	ldw	r4,0(fp)
811213ac:	20800003 	ldbu	r2,0(r4)
811213b0:	98005926 	beq	r19,zero,81121518 <__svfscanf_r+0x81c>
811213b4:	8c40040c 	andi	r17,r17,16
811213b8:	88005a26 	beq	r17,zero,81121524 <__svfscanf_r+0x828>
811213bc:	9823883a 	mov	r17,r19
811213c0:	0021883a 	mov	r16,zero
811213c4:	00000106 	br	811213cc <__svfscanf_r+0x6d0>
811213c8:	20800003 	ldbu	r2,0(r4)
811213cc:	10803fcc 	andi	r2,r2,255
811213d0:	d8c05884 	addi	r3,sp,354
811213d4:	1885883a 	add	r2,r3,r2
811213d8:	10800007 	ldb	r2,0(r2)
811213dc:	1000ad26 	beq	r2,zero,81121694 <__svfscanf_r+0x998>
811213e0:	e0800117 	ldw	r2,4(fp)
811213e4:	21000044 	addi	r4,r4,1
811213e8:	84000044 	addi	r16,r16,1
811213ec:	10bfffc4 	addi	r2,r2,-1
811213f0:	e0800115 	stw	r2,4(fp)
811213f4:	e1000015 	stw	r4,0(fp)
811213f8:	84c0a026 	beq	r16,r19,8112167c <__svfscanf_r+0x980>
811213fc:	00bff216 	blt	zero,r2,811213c8 <__reset+0xfb1013c8>
81121400:	e00b883a 	mov	r5,fp
81121404:	b009883a 	mov	r4,r22
81121408:	111bfdc0 	call	8111bfdc <__srefill_r>
8112140c:	10009a1e 	bne	r2,zero,81121678 <__svfscanf_r+0x97c>
81121410:	e1000017 	ldw	r4,0(fp)
81121414:	003fec06 	br	811213c8 <__reset+0xfb1013c8>
81121418:	e0800117 	ldw	r2,4(fp)
8112141c:	d9809d15 	stw	r6,628(sp)
81121420:	0080eb0e 	bge	zero,r2,811217d0 <__svfscanf_r+0xad4>
81121424:	00a044b4 	movhi	r2,33042
81121428:	10b17804 	addi	r2,r2,-14880
8112142c:	d880a115 	stw	r2,644(sp)
81121430:	d8009e15 	stw	zero,632(sp)
81121434:	050000c4 	movi	r20,3
81121438:	003f3606 	br	81121114 <__reset+0xfb101114>
8112143c:	dd409904 	addi	r21,sp,612
81121440:	8c40040c 	andi	r17,r17,16
81121444:	01800204 	movi	r6,8
81121448:	000b883a 	mov	r5,zero
8112144c:	a809883a 	mov	r4,r21
81121450:	dc409f15 	stw	r17,636(sp)
81121454:	111bb600 	call	8111bb60 <memset>
81121458:	dc409f17 	ldw	r17,636(sp)
8112145c:	88006e26 	beq	r17,zero,81121618 <__svfscanf_r+0x91c>
81121460:	0029883a 	mov	r20,zero
81121464:	0023883a 	mov	r17,zero
81121468:	11257000 	call	81125700 <__locale_mb_cur_max>
8112146c:	14406126 	beq	r2,r17,811215f4 <__svfscanf_r+0x8f8>
81121470:	e0800017 	ldw	r2,0(fp)
81121474:	e0c00117 	ldw	r3,4(fp)
81121478:	d9000104 	addi	r4,sp,4
8112147c:	12000003 	ldbu	r8,0(r2)
81121480:	18ffffc4 	addi	r3,r3,-1
81121484:	10800044 	addi	r2,r2,1
81121488:	e0c00115 	stw	r3,4(fp)
8112148c:	e0800015 	stw	r2,0(fp)
81121490:	8c000044 	addi	r16,r17,1
81121494:	dd400015 	stw	r21,0(sp)
81121498:	2463883a 	add	r17,r4,r17
8112149c:	200d883a 	mov	r6,r4
811214a0:	a00b883a 	mov	r5,r20
811214a4:	800f883a 	mov	r7,r16
811214a8:	b009883a 	mov	r4,r22
811214ac:	8a000005 	stb	r8,0(r17)
811214b0:	11257bc0 	call	811257bc <_mbrtowc_r>
811214b4:	017fffc4 	movi	r5,-1
811214b8:	11404e26 	beq	r2,r5,811215f4 <__svfscanf_r+0x8f8>
811214bc:	1000601e 	bne	r2,zero,81121640 <__svfscanf_r+0x944>
811214c0:	da009f17 	ldw	r8,636(sp)
811214c4:	4000641e 	bne	r8,zero,81121658 <__svfscanf_r+0x95c>
811214c8:	a0000015 	stw	zero,0(r20)
811214cc:	9425883a 	add	r18,r18,r16
811214d0:	9967883a 	add	r19,r19,r5
811214d4:	a5000104 	addi	r20,r20,4
811214d8:	e0800117 	ldw	r2,4(fp)
811214dc:	0023883a 	mov	r17,zero
811214e0:	00804b16 	blt	zero,r2,81121610 <__svfscanf_r+0x914>
811214e4:	e00b883a 	mov	r5,fp
811214e8:	b009883a 	mov	r4,r22
811214ec:	111bfdc0 	call	8111bfdc <__srefill_r>
811214f0:	10004726 	beq	r2,zero,81121610 <__svfscanf_r+0x914>
811214f4:	88003f1e 	bne	r17,zero,811215f4 <__svfscanf_r+0x8f8>
811214f8:	d8c09f17 	ldw	r3,636(sp)
811214fc:	1800031e 	bne	r3,zero,8112150c <__svfscanf_r+0x810>
81121500:	da00a017 	ldw	r8,640(sp)
81121504:	42000044 	addi	r8,r8,1
81121508:	da00a015 	stw	r8,640(sp)
8112150c:	dd009d17 	ldw	r20,628(sp)
81121510:	a00d883a 	mov	r6,r20
81121514:	003e3706 	br	81120df4 <__reset+0xfb100df4>
81121518:	8c40040c 	andi	r17,r17,16
8112151c:	04ffffc4 	movi	r19,-1
81121520:	883fa61e 	bne	r17,zero,811213bc <__reset+0xfb1013bc>
81121524:	da009c17 	ldw	r8,624(sp)
81121528:	9abfffc4 	addi	r10,r19,-1
8112152c:	44000017 	ldw	r16,0(r8)
81121530:	44400104 	addi	r17,r8,4
81121534:	8007883a 	mov	r3,r16
81121538:	82ab883a 	add	r21,r16,r10
8112153c:	00000306 	br	8112154c <__svfscanf_r+0x850>
81121540:	e1000017 	ldw	r4,0(fp)
81121544:	9807883a 	mov	r3,r19
81121548:	20800003 	ldbu	r2,0(r4)
8112154c:	10803fcc 	andi	r2,r2,255
81121550:	d9405884 	addi	r5,sp,354
81121554:	2885883a 	add	r2,r5,r2
81121558:	10800007 	ldb	r2,0(r2)
8112155c:	10004b26 	beq	r2,zero,8112168c <__svfscanf_r+0x990>
81121560:	e0800117 	ldw	r2,4(fp)
81121564:	21400044 	addi	r5,r4,1
81121568:	e1400015 	stw	r5,0(fp)
8112156c:	10bfffc4 	addi	r2,r2,-1
81121570:	e0800115 	stw	r2,4(fp)
81121574:	20800003 	ldbu	r2,0(r4)
81121578:	1cc00044 	addi	r19,r3,1
8112157c:	18800005 	stb	r2,0(r3)
81121580:	1d400726 	beq	r3,r21,811215a0 <__svfscanf_r+0x8a4>
81121584:	e0800117 	ldw	r2,4(fp)
81121588:	00bfed16 	blt	zero,r2,81121540 <__reset+0xfb101540>
8112158c:	e00b883a 	mov	r5,fp
81121590:	b009883a 	mov	r4,r22
81121594:	111bfdc0 	call	8111bfdc <__srefill_r>
81121598:	103fe926 	beq	r2,zero,81121540 <__reset+0xfb101540>
8112159c:	84c01526 	beq	r16,r19,811215f4 <__svfscanf_r+0x8f8>
811215a0:	9c21c83a 	sub	r16,r19,r16
811215a4:	803e1726 	beq	r16,zero,81120e04 <__reset+0xfb100e04>
811215a8:	da00a017 	ldw	r8,640(sp)
811215ac:	98000005 	stb	zero,0(r19)
811215b0:	dc409c15 	stw	r17,624(sp)
811215b4:	42000044 	addi	r8,r8,1
811215b8:	da00a015 	stw	r8,640(sp)
811215bc:	9425883a 	add	r18,r18,r16
811215c0:	a00d883a 	mov	r6,r20
811215c4:	003e0b06 	br	81120df4 <__reset+0xfb100df4>
811215c8:	017fff84 	movi	r5,-2
811215cc:	11439b1e 	bne	r2,r5,8112243c <__svfscanf_r+0x1740>
811215d0:	8821883a 	mov	r16,r17
811215d4:	e0800117 	ldw	r2,4(fp)
811215d8:	0082e516 	blt	zero,r2,81122170 <__svfscanf_r+0x1474>
811215dc:	e00b883a 	mov	r5,fp
811215e0:	b009883a 	mov	r4,r22
811215e4:	111bfdc0 	call	8111bfdc <__srefill_r>
811215e8:	1002e126 	beq	r2,zero,81122170 <__svfscanf_r+0x1474>
811215ec:	dc409f17 	ldw	r17,636(sp)
811215f0:	8002e826 	beq	r16,zero,81122194 <__svfscanf_r+0x1498>
811215f4:	da00a017 	ldw	r8,640(sp)
811215f8:	403e9c26 	beq	r8,zero,8112106c <__reset+0xfb10106c>
811215fc:	e080030b 	ldhu	r2,12(fp)
81121600:	1080100c 	andi	r2,r2,64
81121604:	103e991e 	bne	r2,zero,8112106c <__reset+0xfb10106c>
81121608:	4005883a 	mov	r2,r8
8112160c:	003e9806 	br	81121070 <__reset+0xfb101070>
81121610:	983f951e 	bne	r19,zero,81121468 <__reset+0xfb101468>
81121614:	003fb806 	br	811214f8 <__reset+0xfb1014f8>
81121618:	da009c17 	ldw	r8,624(sp)
8112161c:	45000017 	ldw	r20,0(r8)
81121620:	42000104 	addi	r8,r8,4
81121624:	da009c15 	stw	r8,624(sp)
81121628:	003f8e06 	br	81121464 <__reset+0xfb101464>
8112162c:	e00b883a 	mov	r5,fp
81121630:	b009883a 	mov	r4,r22
81121634:	111bfdc0 	call	8111bfdc <__srefill_r>
81121638:	103f3826 	beq	r2,zero,8112131c <__reset+0xfb10131c>
8112163c:	003fed06 	br	811215f4 <__reset+0xfb1015f4>
81121640:	00ffff84 	movi	r3,-2
81121644:	10c0071e 	bne	r2,r3,81121664 <__svfscanf_r+0x968>
81121648:	e0800117 	ldw	r2,4(fp)
8112164c:	8023883a 	mov	r17,r16
81121650:	00bf8516 	blt	zero,r2,81121468 <__reset+0xfb101468>
81121654:	003fa306 	br	811214e4 <__reset+0xfb1014e4>
81121658:	9425883a 	add	r18,r18,r16
8112165c:	9cffffc4 	addi	r19,r19,-1
81121660:	003f9d06 	br	811214d8 <__reset+0xfb1014d8>
81121664:	da009f17 	ldw	r8,636(sp)
81121668:	9425883a 	add	r18,r18,r16
8112166c:	9cffffc4 	addi	r19,r19,-1
81121670:	403f9826 	beq	r8,zero,811214d4 <__reset+0xfb1014d4>
81121674:	003f9806 	br	811214d8 <__reset+0xfb1014d8>
81121678:	8023883a 	mov	r17,r16
8112167c:	8821883a 	mov	r16,r17
81121680:	003fce06 	br	811215bc <__reset+0xfb1015bc>
81121684:	803f3d1e 	bne	r16,zero,8112137c <__reset+0xfb10137c>
81121688:	003fda06 	br	811215f4 <__reset+0xfb1015f4>
8112168c:	1827883a 	mov	r19,r3
81121690:	003fc306 	br	811215a0 <__reset+0xfb1015a0>
81121694:	803fc91e 	bne	r16,zero,811215bc <__reset+0xfb1015bc>
81121698:	003dda06 	br	81120e04 <__reset+0xfb100e04>
8112169c:	da009c17 	ldw	r8,624(sp)
811216a0:	df000015 	stw	fp,0(sp)
811216a4:	980f883a 	mov	r7,r19
811216a8:	41400017 	ldw	r5,0(r8)
811216ac:	01800044 	movi	r6,1
811216b0:	b009883a 	mov	r4,r22
811216b4:	11248d40 	call	811248d4 <_fread_r>
811216b8:	da009c17 	ldw	r8,624(sp)
811216bc:	40c00104 	addi	r3,r8,4
811216c0:	103fcc26 	beq	r2,zero,811215f4 <__reset+0xfb1015f4>
811216c4:	da00a017 	ldw	r8,640(sp)
811216c8:	dd009d17 	ldw	r20,628(sp)
811216cc:	90a5883a 	add	r18,r18,r2
811216d0:	42000044 	addi	r8,r8,1
811216d4:	da00a015 	stw	r8,640(sp)
811216d8:	d8c09c15 	stw	r3,624(sp)
811216dc:	a00d883a 	mov	r6,r20
811216e0:	003dc406 	br	81120df4 <__reset+0xfb100df4>
811216e4:	e00b883a 	mov	r5,fp
811216e8:	b009883a 	mov	r4,r22
811216ec:	111bfdc0 	call	8111bfdc <__srefill_r>
811216f0:	103e5226 	beq	r2,zero,8112103c <__reset+0xfb10103c>
811216f4:	003fbf06 	br	811215f4 <__reset+0xfb1015f4>
811216f8:	a0800083 	ldbu	r2,2(r20)
811216fc:	8c400094 	ori	r17,r17,2
81121700:	a5000084 	addi	r20,r20,2
81121704:	10c03fcc 	andi	r3,r2,255
81121708:	003dc706 	br	81120e28 <__reset+0xfb100e28>
8112170c:	e0800117 	ldw	r2,4(fp)
81121710:	88e2b03a 	or	r17,r17,r3
81121714:	00bef716 	blt	zero,r2,811212f4 <__reset+0xfb1012f4>
81121718:	003e6f06 	br	811210d8 <__reset+0xfb1010d8>
8112171c:	8880004c 	andi	r2,r17,1
81121720:	10000b1e 	bne	r2,zero,81121750 <__svfscanf_r+0xa54>
81121724:	8c40008c 	andi	r17,r17,2
81121728:	88000926 	beq	r17,zero,81121750 <__svfscanf_r+0xa54>
8112172c:	da009c17 	ldw	r8,624(sp)
81121730:	9007d7fa 	srai	r3,r18,31
81121734:	dd009d17 	ldw	r20,628(sp)
81121738:	40800017 	ldw	r2,0(r8)
8112173c:	42000104 	addi	r8,r8,4
81121740:	da009c15 	stw	r8,624(sp)
81121744:	14800015 	stw	r18,0(r2)
81121748:	10c00115 	stw	r3,4(r2)
8112174c:	003da806 	br	81120df0 <__reset+0xfb100df0>
81121750:	da009c17 	ldw	r8,624(sp)
81121754:	dd009d17 	ldw	r20,628(sp)
81121758:	40800017 	ldw	r2,0(r8)
8112175c:	42000104 	addi	r8,r8,4
81121760:	da009c15 	stw	r8,624(sp)
81121764:	14800015 	stw	r18,0(r2)
81121768:	003da106 	br	81120df0 <__reset+0xfb100df0>
8112176c:	e00b883a 	mov	r5,fp
81121770:	b009883a 	mov	r4,r22
81121774:	111bfdc0 	call	8111bfdc <__srefill_r>
81121778:	103f9e1e 	bne	r2,zero,811215f4 <__reset+0xfb1015f4>
8112177c:	b9c00017 	ldw	r7,0(r23)
81121780:	05000104 	movi	r20,4
81121784:	003e6306 	br	81121114 <__reset+0xfb101114>
81121788:	e00b883a 	mov	r5,fp
8112178c:	b009883a 	mov	r4,r22
81121790:	111bfdc0 	call	8111bfdc <__srefill_r>
81121794:	103f971e 	bne	r2,zero,811215f4 <__reset+0xfb1015f4>
81121798:	b9c00017 	ldw	r7,0(r23)
8112179c:	003e5706 	br	811210fc <__reset+0xfb1010fc>
811217a0:	e00b883a 	mov	r5,fp
811217a4:	b009883a 	mov	r4,r22
811217a8:	111bfdc0 	call	8111bfdc <__srefill_r>
811217ac:	103f911e 	bne	r2,zero,811215f4 <__reset+0xfb1015f4>
811217b0:	b9c00017 	ldw	r7,0(r23)
811217b4:	05000084 	movi	r20,2
811217b8:	003e5606 	br	81121114 <__reset+0xfb101114>
811217bc:	e00b883a 	mov	r5,fp
811217c0:	b009883a 	mov	r4,r22
811217c4:	111bfdc0 	call	8111bfdc <__srefill_r>
811217c8:	103ef726 	beq	r2,zero,811213a8 <__reset+0xfb1013a8>
811217cc:	003f8906 	br	811215f4 <__reset+0xfb1015f4>
811217d0:	e00b883a 	mov	r5,fp
811217d4:	b009883a 	mov	r4,r22
811217d8:	111bfdc0 	call	8111bfdc <__srefill_r>
811217dc:	103f851e 	bne	r2,zero,811215f4 <__reset+0xfb1015f4>
811217e0:	b9c00017 	ldw	r7,0(r23)
811217e4:	003f0f06 	br	81121424 <__reset+0xfb101424>
811217e8:	014000c4 	movi	r5,3
811217ec:	a1414a26 	beq	r20,r5,81121d18 <__svfscanf_r+0x101c>
811217f0:	01000104 	movi	r4,4
811217f4:	a101f11e 	bne	r20,r4,81121fbc <__svfscanf_r+0x12c0>
811217f8:	b009883a 	mov	r4,r22
811217fc:	11257240 	call	81125724 <_localeconv_r>
81121800:	10800017 	ldw	r2,0(r2)
81121804:	98ffffc4 	addi	r3,r19,-1
81121808:	d880a315 	stw	r2,652(sp)
8112180c:	00805704 	movi	r2,348
81121810:	10c21e2e 	bgeu	r2,r3,8112208c <__svfscanf_r+0x1390>
81121814:	9cffa8c4 	addi	r19,r19,-349
81121818:	dcc0a215 	stw	r19,648(sp)
8112181c:	04c05744 	movi	r19,349
81121820:	8d01e014 	ori	r20,r17,1920
81121824:	0023883a 	mov	r17,zero
81121828:	dc000104 	addi	r16,sp,4
8112182c:	8805883a 	mov	r2,r17
81121830:	0019883a 	mov	r12,zero
81121834:	8023883a 	mov	r17,r16
81121838:	b007883a 	mov	r3,r22
8112183c:	9821883a 	mov	r16,r19
81121840:	002b883a 	mov	r21,zero
81121844:	d800a515 	stw	zero,660(sp)
81121848:	d800a415 	stw	zero,656(sp)
8112184c:	d8009f15 	stw	zero,636(sp)
81121850:	01c01384 	movi	r7,78
81121854:	602d883a 	mov	r22,r12
81121858:	1027883a 	mov	r19,r2
8112185c:	e1000017 	ldw	r4,0(fp)
81121860:	21400003 	ldbu	r5,0(r4)
81121864:	28bff544 	addi	r2,r5,-43
81121868:	10803fcc 	andi	r2,r2,255
8112186c:	38810e36 	bltu	r7,r2,81121ca8 <__svfscanf_r+0xfac>
81121870:	100490ba 	slli	r2,r2,2
81121874:	01a044b4 	movhi	r6,33042
81121878:	31862204 	addi	r6,r6,6280
8112187c:	1185883a 	add	r2,r2,r6
81121880:	10800017 	ldw	r2,0(r2)
81121884:	1000683a 	jmp	r2
81121888:	81121b80 	call	881121b8 <__reset+0x20f21b8>
8112188c:	81121ca8 	cmpgeui	r4,r16,18546
81121890:	81121b80 	call	881121b8 <__reset+0x20f21b8>
81121894:	81121ca8 	cmpgeui	r4,r16,18546
81121898:	81121ca8 	cmpgeui	r4,r16,18546
8112189c:	81121b54 	ori	r4,r16,18541
811218a0:	811219c4 	addi	r4,r16,18535
811218a4:	811219c4 	addi	r4,r16,18535
811218a8:	811219c4 	addi	r4,r16,18535
811218ac:	811219c4 	addi	r4,r16,18535
811218b0:	811219c4 	addi	r4,r16,18535
811218b4:	811219c4 	addi	r4,r16,18535
811218b8:	811219c4 	addi	r4,r16,18535
811218bc:	811219c4 	addi	r4,r16,18535
811218c0:	811219c4 	addi	r4,r16,18535
811218c4:	81121ca8 	cmpgeui	r4,r16,18546
811218c8:	81121ca8 	cmpgeui	r4,r16,18546
811218cc:	81121ca8 	cmpgeui	r4,r16,18546
811218d0:	81121ca8 	cmpgeui	r4,r16,18546
811218d4:	81121ca8 	cmpgeui	r4,r16,18546
811218d8:	81121ca8 	cmpgeui	r4,r16,18546
811218dc:	81121ca8 	cmpgeui	r4,r16,18546
811218e0:	81121c98 	cmpnei	r4,r16,18546
811218e4:	81121ca8 	cmpgeui	r4,r16,18546
811218e8:	81121ca8 	cmpgeui	r4,r16,18546
811218ec:	81121ca8 	cmpgeui	r4,r16,18546
811218f0:	81121c54 	ori	r4,r16,18545
811218f4:	81121c38 	rdprs	r4,r16,18544
811218f8:	81121ca8 	cmpgeui	r4,r16,18546
811218fc:	81121ca8 	cmpgeui	r4,r16,18546
81121900:	81121c04 	addi	r4,r16,18544
81121904:	81121ca8 	cmpgeui	r4,r16,18546
81121908:	81121ca8 	cmpgeui	r4,r16,18546
8112190c:	81121ca8 	cmpgeui	r4,r16,18546
81121910:	81121ca8 	cmpgeui	r4,r16,18546
81121914:	81121bcc 	andi	r4,r16,18543
81121918:	81121ca8 	cmpgeui	r4,r16,18546
8112191c:	81121ca8 	cmpgeui	r4,r16,18546
81121920:	81121ca8 	cmpgeui	r4,r16,18546
81121924:	81121ca8 	cmpgeui	r4,r16,18546
81121928:	81121ca8 	cmpgeui	r4,r16,18546
8112192c:	81121bb0 	cmpltui	r4,r16,18542
81121930:	81121ca8 	cmpgeui	r4,r16,18546
81121934:	81121ca8 	cmpgeui	r4,r16,18546
81121938:	81121ca8 	cmpgeui	r4,r16,18546
8112193c:	81121ca8 	cmpgeui	r4,r16,18546
81121940:	81121b94 	ori	r4,r16,18542
81121944:	81121ca8 	cmpgeui	r4,r16,18546
81121948:	81121ca8 	cmpgeui	r4,r16,18546
8112194c:	81121ca8 	cmpgeui	r4,r16,18546
81121950:	81121ca8 	cmpgeui	r4,r16,18546
81121954:	81121ca8 	cmpgeui	r4,r16,18546
81121958:	81121ca8 	cmpgeui	r4,r16,18546
8112195c:	81121ca8 	cmpgeui	r4,r16,18546
81121960:	81121c98 	cmpnei	r4,r16,18546
81121964:	81121ca8 	cmpgeui	r4,r16,18546
81121968:	81121ca8 	cmpgeui	r4,r16,18546
8112196c:	81121ca8 	cmpgeui	r4,r16,18546
81121970:	81121c54 	ori	r4,r16,18545
81121974:	81121c38 	rdprs	r4,r16,18544
81121978:	81121ca8 	cmpgeui	r4,r16,18546
8112197c:	81121ca8 	cmpgeui	r4,r16,18546
81121980:	81121c04 	addi	r4,r16,18544
81121984:	81121ca8 	cmpgeui	r4,r16,18546
81121988:	81121ca8 	cmpgeui	r4,r16,18546
8112198c:	81121ca8 	cmpgeui	r4,r16,18546
81121990:	81121ca8 	cmpgeui	r4,r16,18546
81121994:	81121bcc 	andi	r4,r16,18543
81121998:	81121ca8 	cmpgeui	r4,r16,18546
8112199c:	81121ca8 	cmpgeui	r4,r16,18546
811219a0:	81121ca8 	cmpgeui	r4,r16,18546
811219a4:	81121ca8 	cmpgeui	r4,r16,18546
811219a8:	81121ca8 	cmpgeui	r4,r16,18546
811219ac:	81121bb0 	cmpltui	r4,r16,18542
811219b0:	81121ca8 	cmpgeui	r4,r16,18546
811219b4:	81121ca8 	cmpgeui	r4,r16,18546
811219b8:	81121ca8 	cmpgeui	r4,r16,18546
811219bc:	81121ca8 	cmpgeui	r4,r16,18546
811219c0:	81121b94 	ori	r4,r16,18542
811219c4:	a8803fcc 	andi	r2,r21,255
811219c8:	1080201c 	xori	r2,r2,128
811219cc:	10bfe004 	addi	r2,r2,-128
811219d0:	b085883a 	add	r2,r22,r2
811219d4:	10000d1e 	bne	r2,zero,81121a0c <__svfscanf_r+0xd10>
811219d8:	00bf9fc4 	movi	r2,-385
811219dc:	a0a8703a 	and	r20,r20,r2
811219e0:	89400005 	stb	r5,0(r17)
811219e4:	8c400044 	addi	r17,r17,1
811219e8:	e0800117 	ldw	r2,4(fp)
811219ec:	843fffc4 	addi	r16,r16,-1
811219f0:	94800044 	addi	r18,r18,1
811219f4:	10bfffc4 	addi	r2,r2,-1
811219f8:	e0800115 	stw	r2,4(fp)
811219fc:	0080b40e 	bge	zero,r2,81121cd0 <__svfscanf_r+0xfd4>
81121a00:	21000044 	addi	r4,r4,1
81121a04:	e1000015 	stw	r4,0(fp)
81121a08:	803f941e 	bne	r16,zero,8112185c <__reset+0xfb10185c>
81121a0c:	8821883a 	mov	r16,r17
81121a10:	b019883a 	mov	r12,r22
81121a14:	9823883a 	mov	r17,r19
81121a18:	182d883a 	mov	r22,r3
81121a1c:	9801961e 	bne	r19,zero,81122078 <__svfscanf_r+0x137c>
81121a20:	633fffc4 	addi	r12,r12,-1
81121a24:	00800044 	movi	r2,1
81121a28:	1302882e 	bgeu	r2,r12,8112244c <__svfscanf_r+0x1750>
81121a2c:	a8803fcc 	andi	r2,r21,255
81121a30:	1080201c 	xori	r2,r2,128
81121a34:	10bfe004 	addi	r2,r2,-128
81121a38:	113fffc4 	addi	r4,r2,-1
81121a3c:	01400184 	movi	r5,6
81121a40:	29001136 	bltu	r5,r4,81121a88 <__svfscanf_r+0xd8c>
81121a44:	01000084 	movi	r4,2
81121a48:	2082900e 	bge	r4,r2,8112248c <__svfscanf_r+0x1790>
81121a4c:	00c000c4 	movi	r3,3
81121a50:	10c00d26 	beq	r2,r3,81121a88 <__svfscanf_r+0xd8c>
81121a54:	9425c83a 	sub	r18,r18,r16
81121a58:	1827883a 	mov	r19,r3
81121a5c:	843fffc4 	addi	r16,r16,-1
81121a60:	81400007 	ldb	r5,0(r16)
81121a64:	e00d883a 	mov	r6,fp
81121a68:	b009883a 	mov	r4,r22
81121a6c:	112a9540 	call	8112a954 <_ungetc_r>
81121a70:	a8bfffc4 	addi	r2,r21,-1
81121a74:	10c03fcc 	andi	r3,r2,255
81121a78:	8493883a 	add	r9,r16,r18
81121a7c:	102b883a 	mov	r21,r2
81121a80:	98fff636 	bltu	r19,r3,81121a5c <__reset+0xfb101a5c>
81121a84:	4825883a 	mov	r18,r9
81121a88:	a080400c 	andi	r2,r20,256
81121a8c:	10001426 	beq	r2,zero,81121ae0 <__svfscanf_r+0xde4>
81121a90:	a081000c 	andi	r2,r20,1024
81121a94:	1002571e 	bne	r2,zero,811223f4 <__svfscanf_r+0x16f8>
81121a98:	817fffc7 	ldb	r5,-1(r16)
81121a9c:	00801944 	movi	r2,101
81121aa0:	84ffffc4 	addi	r19,r16,-1
81121aa4:	957fffc4 	addi	r21,r18,-1
81121aa8:	28800826 	beq	r5,r2,81121acc <__svfscanf_r+0xdd0>
81121aac:	00801144 	movi	r2,69
81121ab0:	28800626 	beq	r5,r2,81121acc <__svfscanf_r+0xdd0>
81121ab4:	e00d883a 	mov	r6,fp
81121ab8:	b009883a 	mov	r4,r22
81121abc:	112a9540 	call	8112a954 <_ungetc_r>
81121ac0:	817fff87 	ldb	r5,-2(r16)
81121ac4:	84ffff84 	addi	r19,r16,-2
81121ac8:	957fff84 	addi	r21,r18,-2
81121acc:	e00d883a 	mov	r6,fp
81121ad0:	b009883a 	mov	r4,r22
81121ad4:	112a9540 	call	8112a954 <_ungetc_r>
81121ad8:	a825883a 	mov	r18,r21
81121adc:	9821883a 	mov	r16,r19
81121ae0:	a080040c 	andi	r2,r20,16
81121ae4:	103e891e 	bne	r2,zero,8112150c <__reset+0xfb10150c>
81121ae8:	80000005 	stb	zero,0(r16)
81121aec:	a081800c 	andi	r2,r20,1536
81121af0:	01010004 	movi	r4,1024
81121af4:	1101dd26 	beq	r2,r4,8112226c <__svfscanf_r+0x1570>
81121af8:	da00a417 	ldw	r8,656(sp)
81121afc:	4001e71e 	bne	r8,zero,8112229c <__svfscanf_r+0x15a0>
81121b00:	000d883a 	mov	r6,zero
81121b04:	d9400104 	addi	r5,sp,4
81121b08:	b009883a 	mov	r4,r22
81121b0c:	11275040 	call	81127504 <_strtod_r>
81121b10:	1021883a 	mov	r16,r2
81121b14:	a080004c 	andi	r2,r20,1
81121b18:	1000021e 	bne	r2,zero,81121b24 <__svfscanf_r+0xe28>
81121b1c:	a2c0008c 	andi	r11,r20,2
81121b20:	5801e826 	beq	r11,zero,811222c4 <__svfscanf_r+0x15c8>
81121b24:	da009c17 	ldw	r8,624(sp)
81121b28:	40800017 	ldw	r2,0(r8)
81121b2c:	42000104 	addi	r8,r8,4
81121b30:	da009c15 	stw	r8,624(sp)
81121b34:	14000015 	stw	r16,0(r2)
81121b38:	10c00115 	stw	r3,4(r2)
81121b3c:	da00a017 	ldw	r8,640(sp)
81121b40:	dd009d17 	ldw	r20,628(sp)
81121b44:	42000044 	addi	r8,r8,1
81121b48:	da00a015 	stw	r8,640(sp)
81121b4c:	a00d883a 	mov	r6,r20
81121b50:	003ca806 	br	81120df4 <__reset+0xfb100df4>
81121b54:	a080400c 	andi	r2,r20,256
81121b58:	103f9a26 	beq	r2,zero,811219c4 <__reset+0xfb1019c4>
81121b5c:	da00a217 	ldw	r8,648(sp)
81121b60:	00bfdfc4 	movi	r2,-129
81121b64:	a0a8703a 	and	r20,r20,r2
81121b68:	9cc00044 	addi	r19,r19,1
81121b6c:	403f9e26 	beq	r8,zero,811219e8 <__reset+0xfb1019e8>
81121b70:	423fffc4 	addi	r8,r8,-1
81121b74:	da00a215 	stw	r8,648(sp)
81121b78:	84000044 	addi	r16,r16,1
81121b7c:	003f9a06 	br	811219e8 <__reset+0xfb1019e8>
81121b80:	a080200c 	andi	r2,r20,128
81121b84:	103fa126 	beq	r2,zero,81121a0c <__reset+0xfb101a0c>
81121b88:	00bfdfc4 	movi	r2,-129
81121b8c:	a0a8703a 	and	r20,r20,r2
81121b90:	003f9306 	br	811219e0 <__reset+0xfb1019e0>
81121b94:	a8803fcc 	andi	r2,r21,255
81121b98:	1080201c 	xori	r2,r2,128
81121b9c:	10bfe004 	addi	r2,r2,-128
81121ba0:	020001c4 	movi	r8,7
81121ba4:	123f991e 	bne	r2,r8,81121a0c <__reset+0xfb101a0c>
81121ba8:	05400204 	movi	r21,8
81121bac:	003f8c06 	br	811219e0 <__reset+0xfb1019e0>
81121bb0:	a8803fcc 	andi	r2,r21,255
81121bb4:	1080201c 	xori	r2,r2,128
81121bb8:	10bfe004 	addi	r2,r2,-128
81121bbc:	01800184 	movi	r6,6
81121bc0:	11bf921e 	bne	r2,r6,81121a0c <__reset+0xfb101a0c>
81121bc4:	054001c4 	movi	r21,7
81121bc8:	003f8506 	br	811219e0 <__reset+0xfb1019e0>
81121bcc:	b000491e 	bne	r22,zero,81121cf4 <__svfscanf_r+0xff8>
81121bd0:	9800031e 	bne	r19,zero,81121be0 <__svfscanf_r+0xee4>
81121bd4:	a081c00c 	andi	r2,r20,1792
81121bd8:	0181c004 	movi	r6,1792
81121bdc:	11819f26 	beq	r2,r6,8112225c <__svfscanf_r+0x1560>
81121be0:	a8803fcc 	andi	r2,r21,255
81121be4:	1080201c 	xori	r2,r2,128
81121be8:	10bfe004 	addi	r2,r2,-128
81121bec:	01800044 	movi	r6,1
81121bf0:	11800226 	beq	r2,r6,81121bfc <__svfscanf_r+0xf00>
81121bf4:	01800104 	movi	r6,4
81121bf8:	11bf841e 	bne	r2,r6,81121a0c <__reset+0xfb101a0c>
81121bfc:	ad400044 	addi	r21,r21,1
81121c00:	003f7706 	br	811219e0 <__reset+0xfb1019e0>
81121c04:	a8803fcc 	andi	r2,r21,255
81121c08:	1080201c 	xori	r2,r2,128
81121c0c:	10bfe004 	addi	r2,r2,-128
81121c10:	10003c1e 	bne	r2,zero,81121d04 <__svfscanf_r+0x1008>
81121c14:	9801141e 	bne	r19,zero,81122068 <__svfscanf_r+0x136c>
81121c18:	a081c00c 	andi	r2,r20,1792
81121c1c:	0181c004 	movi	r6,1792
81121c20:	11818226 	beq	r2,r6,8112222c <__svfscanf_r+0x1530>
81121c24:	8821883a 	mov	r16,r17
81121c28:	b019883a 	mov	r12,r22
81121c2c:	9823883a 	mov	r17,r19
81121c30:	182d883a 	mov	r22,r3
81121c34:	003f7a06 	br	81121a20 <__reset+0xfb101a20>
81121c38:	a8803fcc 	andi	r2,r21,255
81121c3c:	1080201c 	xori	r2,r2,128
81121c40:	10bfe004 	addi	r2,r2,-128
81121c44:	01800084 	movi	r6,2
81121c48:	11bf701e 	bne	r2,r6,81121a0c <__reset+0xfb101a0c>
81121c4c:	054000c4 	movi	r21,3
81121c50:	003f6306 	br	811219e0 <__reset+0xfb1019e0>
81121c54:	a081400c 	andi	r2,r20,1280
81121c58:	01810004 	movi	r6,1024
81121c5c:	11800326 	beq	r2,r6,81121c6c <__svfscanf_r+0xf70>
81121c60:	a184703a 	and	r2,r20,r6
81121c64:	103f6926 	beq	r2,zero,81121a0c <__reset+0xfb101a0c>
81121c68:	983fee26 	beq	r19,zero,81121c24 <__reset+0xfb101c24>
81121c6c:	a080800c 	andi	r2,r20,512
81121c70:	1000041e 	bne	r2,zero,81121c84 <__svfscanf_r+0xf88>
81121c74:	da009f17 	ldw	r8,636(sp)
81121c78:	dc40a515 	stw	r17,660(sp)
81121c7c:	9a27c83a 	sub	r19,r19,r8
81121c80:	dcc0a415 	stw	r19,656(sp)
81121c84:	00be1fc4 	movi	r2,-1921
81121c88:	a0a8703a 	and	r20,r20,r2
81121c8c:	a5006014 	ori	r20,r20,384
81121c90:	0027883a 	mov	r19,zero
81121c94:	003f5206 	br	811219e0 <__reset+0xfb1019e0>
81121c98:	00800044 	movi	r2,1
81121c9c:	b0bf5b1e 	bne	r22,r2,81121a0c <__reset+0xfb101a0c>
81121ca0:	05800084 	movi	r22,2
81121ca4:	003f4e06 	br	811219e0 <__reset+0xfb1019e0>
81121ca8:	d980a317 	ldw	r6,652(sp)
81121cac:	30800003 	ldbu	r2,0(r6)
81121cb0:	29803fcc 	andi	r6,r5,255
81121cb4:	30bf551e 	bne	r6,r2,81121a0c <__reset+0xfb101a0c>
81121cb8:	a080800c 	andi	r2,r20,512
81121cbc:	103f5326 	beq	r2,zero,81121a0c <__reset+0xfb101a0c>
81121cc0:	023f5fc4 	movi	r8,-641
81121cc4:	a228703a 	and	r20,r20,r8
81121cc8:	dcc09f15 	stw	r19,636(sp)
81121ccc:	003f4406 	br	811219e0 <__reset+0xfb1019e0>
81121cd0:	1809883a 	mov	r4,r3
81121cd4:	e00b883a 	mov	r5,fp
81121cd8:	d8c0a615 	stw	r3,664(sp)
81121cdc:	d9c0aa15 	stw	r7,680(sp)
81121ce0:	111bfdc0 	call	8111bfdc <__srefill_r>
81121ce4:	d8c0a617 	ldw	r3,664(sp)
81121ce8:	d9c0aa17 	ldw	r7,680(sp)
81121cec:	103f4626 	beq	r2,zero,81121a08 <__reset+0xfb101a08>
81121cf0:	003f4606 	br	81121a0c <__reset+0xfb101a0c>
81121cf4:	00800084 	movi	r2,2
81121cf8:	b0bfb91e 	bne	r22,r2,81121be0 <__reset+0xfb101be0>
81121cfc:	058000c4 	movi	r22,3
81121d00:	003f3706 	br	811219e0 <__reset+0xfb1019e0>
81121d04:	018000c4 	movi	r6,3
81121d08:	11bfbc26 	beq	r2,r6,81121bfc <__reset+0xfb101bfc>
81121d0c:	01800144 	movi	r6,5
81121d10:	11bfba26 	beq	r2,r6,81121bfc <__reset+0xfb101bfc>
81121d14:	003f3d06 	br	81121a0c <__reset+0xfb101a0c>
81121d18:	98bfffc4 	addi	r2,r19,-1
81121d1c:	01405704 	movi	r5,348
81121d20:	2880d82e 	bgeu	r5,r2,81122084 <__svfscanf_r+0x1388>
81121d24:	99ffa8c4 	addi	r7,r19,-349
81121d28:	04c05744 	movi	r19,349
81121d2c:	8c436014 	ori	r17,r17,3456
81121d30:	9013883a 	mov	r9,r18
81121d34:	8825883a 	mov	r18,r17
81121d38:	dc409e17 	ldw	r17,632(sp)
81121d3c:	0029883a 	mov	r20,zero
81121d40:	dc000104 	addi	r16,sp,4
81121d44:	05401344 	movi	r21,77
81121d48:	02c08004 	movi	r11,512
81121d4c:	01bf7fc4 	movi	r6,-513
81121d50:	023fdfc4 	movi	r8,-129
81121d54:	20bff544 	addi	r2,r4,-43
81121d58:	10803fcc 	andi	r2,r2,255
81121d5c:	a8807236 	bltu	r21,r2,81121f28 <__svfscanf_r+0x122c>
81121d60:	100490ba 	slli	r2,r2,2
81121d64:	016044b4 	movhi	r5,33042
81121d68:	29475e04 	addi	r5,r5,7544
81121d6c:	1145883a 	add	r2,r2,r5
81121d70:	10800017 	ldw	r2,0(r2)
81121d74:	1000683a 	jmp	r2
81121d78:	81121fac 	andhi	r4,r16,18558
81121d7c:	81121f28 	cmpgeui	r4,r16,18556
81121d80:	81121fac 	andhi	r4,r16,18558
81121d84:	81121f28 	cmpgeui	r4,r16,18556
81121d88:	81121f28 	cmpgeui	r4,r16,18556
81121d8c:	81121f84 	addi	r4,r16,18558
81121d90:	81121f64 	muli	r4,r16,18557
81121d94:	81121f64 	muli	r4,r16,18557
81121d98:	81121f64 	muli	r4,r16,18557
81121d9c:	81121f64 	muli	r4,r16,18557
81121da0:	81121f64 	muli	r4,r16,18557
81121da4:	81121f64 	muli	r4,r16,18557
81121da8:	81121f64 	muli	r4,r16,18557
81121dac:	81121f0c 	andi	r4,r16,18556
81121db0:	81121f0c 	andi	r4,r16,18556
81121db4:	81121f28 	cmpgeui	r4,r16,18556
81121db8:	81121f28 	cmpgeui	r4,r16,18556
81121dbc:	81121f28 	cmpgeui	r4,r16,18556
81121dc0:	81121f28 	cmpgeui	r4,r16,18556
81121dc4:	81121f28 	cmpgeui	r4,r16,18556
81121dc8:	81121f28 	cmpgeui	r4,r16,18556
81121dcc:	81121f28 	cmpgeui	r4,r16,18556
81121dd0:	81121ef8 	rdprs	r4,r16,18555
81121dd4:	81121ef8 	rdprs	r4,r16,18555
81121dd8:	81121ef8 	rdprs	r4,r16,18555
81121ddc:	81121ef8 	rdprs	r4,r16,18555
81121de0:	81121ef8 	rdprs	r4,r16,18555
81121de4:	81121ef8 	rdprs	r4,r16,18555
81121de8:	81121f28 	cmpgeui	r4,r16,18556
81121dec:	81121f28 	cmpgeui	r4,r16,18556
81121df0:	81121f28 	cmpgeui	r4,r16,18556
81121df4:	81121f28 	cmpgeui	r4,r16,18556
81121df8:	81121f28 	cmpgeui	r4,r16,18556
81121dfc:	81121f28 	cmpgeui	r4,r16,18556
81121e00:	81121f28 	cmpgeui	r4,r16,18556
81121e04:	81121f28 	cmpgeui	r4,r16,18556
81121e08:	81121f28 	cmpgeui	r4,r16,18556
81121e0c:	81121f28 	cmpgeui	r4,r16,18556
81121e10:	81121f28 	cmpgeui	r4,r16,18556
81121e14:	81121f28 	cmpgeui	r4,r16,18556
81121e18:	81121f28 	cmpgeui	r4,r16,18556
81121e1c:	81121f28 	cmpgeui	r4,r16,18556
81121e20:	81121f28 	cmpgeui	r4,r16,18556
81121e24:	81121f28 	cmpgeui	r4,r16,18556
81121e28:	81121f28 	cmpgeui	r4,r16,18556
81121e2c:	81121eb0 	cmpltui	r4,r16,18554
81121e30:	81121f28 	cmpgeui	r4,r16,18556
81121e34:	81121f28 	cmpgeui	r4,r16,18556
81121e38:	81121f28 	cmpgeui	r4,r16,18556
81121e3c:	81121f28 	cmpgeui	r4,r16,18556
81121e40:	81121f28 	cmpgeui	r4,r16,18556
81121e44:	81121f28 	cmpgeui	r4,r16,18556
81121e48:	81121f28 	cmpgeui	r4,r16,18556
81121e4c:	81121f28 	cmpgeui	r4,r16,18556
81121e50:	81121ef8 	rdprs	r4,r16,18555
81121e54:	81121ef8 	rdprs	r4,r16,18555
81121e58:	81121ef8 	rdprs	r4,r16,18555
81121e5c:	81121ef8 	rdprs	r4,r16,18555
81121e60:	81121ef8 	rdprs	r4,r16,18555
81121e64:	81121ef8 	rdprs	r4,r16,18555
81121e68:	81121f28 	cmpgeui	r4,r16,18556
81121e6c:	81121f28 	cmpgeui	r4,r16,18556
81121e70:	81121f28 	cmpgeui	r4,r16,18556
81121e74:	81121f28 	cmpgeui	r4,r16,18556
81121e78:	81121f28 	cmpgeui	r4,r16,18556
81121e7c:	81121f28 	cmpgeui	r4,r16,18556
81121e80:	81121f28 	cmpgeui	r4,r16,18556
81121e84:	81121f28 	cmpgeui	r4,r16,18556
81121e88:	81121f28 	cmpgeui	r4,r16,18556
81121e8c:	81121f28 	cmpgeui	r4,r16,18556
81121e90:	81121f28 	cmpgeui	r4,r16,18556
81121e94:	81121f28 	cmpgeui	r4,r16,18556
81121e98:	81121f28 	cmpgeui	r4,r16,18556
81121e9c:	81121f28 	cmpgeui	r4,r16,18556
81121ea0:	81121f28 	cmpgeui	r4,r16,18556
81121ea4:	81121f28 	cmpgeui	r4,r16,18556
81121ea8:	81121f28 	cmpgeui	r4,r16,18556
81121eac:	81121eb0 	cmpltui	r4,r16,18554
81121eb0:	9081800c 	andi	r2,r18,1536
81121eb4:	12c01c1e 	bne	r2,r11,81121f28 <__svfscanf_r+0x122c>
81121eb8:	91a4703a 	and	r18,r18,r6
81121ebc:	94814014 	ori	r18,r18,1280
81121ec0:	04400404 	movi	r17,16
81121ec4:	81000005 	stb	r4,0(r16)
81121ec8:	84000044 	addi	r16,r16,1
81121ecc:	e0800117 	ldw	r2,4(fp)
81121ed0:	10bfffc4 	addi	r2,r2,-1
81121ed4:	e0800115 	stw	r2,4(fp)
81121ed8:	0080540e 	bge	zero,r2,8112202c <__svfscanf_r+0x1330>
81121edc:	18c00044 	addi	r3,r3,1
81121ee0:	e0c00015 	stw	r3,0(fp)
81121ee4:	9cffffc4 	addi	r19,r19,-1
81121ee8:	98000f26 	beq	r19,zero,81121f28 <__svfscanf_r+0x122c>
81121eec:	e0c00017 	ldw	r3,0(fp)
81121ef0:	19000003 	ldbu	r4,0(r3)
81121ef4:	003f9706 	br	81121d54 <__reset+0xfb101d54>
81121ef8:	00800284 	movi	r2,10
81121efc:	14400a0e 	bge	r2,r17,81121f28 <__svfscanf_r+0x122c>
81121f00:	00bd1fc4 	movi	r2,-2945
81121f04:	90a4703a 	and	r18,r18,r2
81121f08:	003fee06 	br	81121ec4 <__reset+0xfb101ec4>
81121f0c:	01604574 	movhi	r5,33045
81121f10:	8c63883a 	add	r17,r17,r17
81121f14:	2966cc84 	addi	r5,r5,-25806
81121f18:	2c45883a 	add	r2,r5,r17
81121f1c:	1440000f 	ldh	r17,0(r2)
81121f20:	00800204 	movi	r2,8
81121f24:	147ff616 	blt	r2,r17,81121f00 <__reset+0xfb101f00>
81121f28:	dc409e15 	stw	r17,632(sp)
81121f2c:	9023883a 	mov	r17,r18
81121f30:	8880400c 	andi	r2,r17,256
81121f34:	4825883a 	mov	r18,r9
81121f38:	10000426 	beq	r2,zero,81121f4c <__svfscanf_r+0x1250>
81121f3c:	d9800104 	addi	r6,sp,4
81121f40:	3400be36 	bltu	r6,r16,8112223c <__svfscanf_r+0x1540>
81121f44:	da000104 	addi	r8,sp,4
81121f48:	443bae26 	beq	r8,r16,81120e04 <__reset+0xfb100e04>
81121f4c:	8880040c 	andi	r2,r17,16
81121f50:	10009326 	beq	r2,zero,811221a0 <__svfscanf_r+0x14a4>
81121f54:	d8800104 	addi	r2,sp,4
81121f58:	80a1c83a 	sub	r16,r16,r2
81121f5c:	8521883a 	add	r16,r16,r20
81121f60:	003d0606 	br	8112137c <__reset+0xfb10137c>
81121f64:	01604574 	movhi	r5,33045
81121f68:	8c63883a 	add	r17,r17,r17
81121f6c:	2966cc84 	addi	r5,r5,-25806
81121f70:	2c45883a 	add	r2,r5,r17
81121f74:	1440000f 	ldh	r17,0(r2)
81121f78:	00bd1fc4 	movi	r2,-2945
81121f7c:	90a4703a 	and	r18,r18,r2
81121f80:	003fd006 	br	81121ec4 <__reset+0xfb101ec4>
81121f84:	9082000c 	andi	r2,r18,2048
81121f88:	103fce26 	beq	r2,zero,81121ec4 <__reset+0xfb101ec4>
81121f8c:	8800021e 	bne	r17,zero,81121f98 <__svfscanf_r+0x129c>
81121f90:	94808014 	ori	r18,r18,512
81121f94:	04400204 	movi	r17,8
81121f98:	9081000c 	andi	r2,r18,1024
81121f9c:	10009426 	beq	r2,zero,811221f0 <__svfscanf_r+0x14f4>
81121fa0:	00be9fc4 	movi	r2,-1409
81121fa4:	90a4703a 	and	r18,r18,r2
81121fa8:	003fc606 	br	81121ec4 <__reset+0xfb101ec4>
81121fac:	9080200c 	andi	r2,r18,128
81121fb0:	103fdd26 	beq	r2,zero,81121f28 <__reset+0xfb101f28>
81121fb4:	9224703a 	and	r18,r18,r8
81121fb8:	003fc206 	br	81121ec4 <__reset+0xfb101ec4>
81121fbc:	9800011e 	bne	r19,zero,81121fc4 <__svfscanf_r+0x12c8>
81121fc0:	04ffffc4 	movi	r19,-1
81121fc4:	8900004c 	andi	r4,r17,1
81121fc8:	20005b1e 	bne	r4,zero,81122138 <__svfscanf_r+0x143c>
81121fcc:	8c40040c 	andi	r17,r17,16
81121fd0:	88003026 	beq	r17,zero,81122094 <__svfscanf_r+0x1398>
81121fd4:	0021883a 	mov	r16,zero
81121fd8:	00000306 	br	81121fe8 <__svfscanf_r+0x12ec>
81121fdc:	18800003 	ldbu	r2,0(r3)
81121fe0:	3885883a 	add	r2,r7,r2
81121fe4:	10800043 	ldbu	r2,1(r2)
81121fe8:	1080020c 	andi	r2,r2,8
81121fec:	103ce31e 	bne	r2,zero,8112137c <__reset+0xfb10137c>
81121ff0:	e0800117 	ldw	r2,4(fp)
81121ff4:	18c00044 	addi	r3,r3,1
81121ff8:	84000044 	addi	r16,r16,1
81121ffc:	10bfffc4 	addi	r2,r2,-1
81122000:	e0800115 	stw	r2,4(fp)
81122004:	e0c00015 	stw	r3,0(fp)
81122008:	84fcdc26 	beq	r16,r19,8112137c <__reset+0xfb10137c>
8112200c:	00bff316 	blt	zero,r2,81121fdc <__reset+0xfb101fdc>
81122010:	e00b883a 	mov	r5,fp
81122014:	b009883a 	mov	r4,r22
81122018:	111bfdc0 	call	8111bfdc <__srefill_r>
8112201c:	103cd71e 	bne	r2,zero,8112137c <__reset+0xfb10137c>
81122020:	b9c00017 	ldw	r7,0(r23)
81122024:	e0c00017 	ldw	r3,0(fp)
81122028:	003fec06 	br	81121fdc <__reset+0xfb101fdc>
8112202c:	e00b883a 	mov	r5,fp
81122030:	b009883a 	mov	r4,r22
81122034:	d980a715 	stw	r6,668(sp)
81122038:	d9c0aa15 	stw	r7,680(sp)
8112203c:	da00a815 	stw	r8,672(sp)
81122040:	da40a915 	stw	r9,676(sp)
81122044:	dac0a615 	stw	r11,664(sp)
81122048:	111bfdc0 	call	8111bfdc <__srefill_r>
8112204c:	d980a717 	ldw	r6,668(sp)
81122050:	d9c0aa17 	ldw	r7,680(sp)
81122054:	da00a817 	ldw	r8,672(sp)
81122058:	da40a917 	ldw	r9,676(sp)
8112205c:	dac0a617 	ldw	r11,664(sp)
81122060:	103fa026 	beq	r2,zero,81121ee4 <__reset+0xfb101ee4>
81122064:	003fb006 	br	81121f28 <__reset+0xfb101f28>
81122068:	8821883a 	mov	r16,r17
8112206c:	b019883a 	mov	r12,r22
81122070:	9823883a 	mov	r17,r19
81122074:	182d883a 	mov	r22,r3
81122078:	00bfbfc4 	movi	r2,-257
8112207c:	a0a8703a 	and	r20,r20,r2
81122080:	003e6706 	br	81121a20 <__reset+0xfb101a20>
81122084:	000f883a 	mov	r7,zero
81122088:	003f2806 	br	81121d2c <__reset+0xfb101d2c>
8112208c:	d800a215 	stw	zero,648(sp)
81122090:	003de306 	br	81121820 <__reset+0xfb101820>
81122094:	da009c17 	ldw	r8,624(sp)
81122098:	9abfffc4 	addi	r10,r19,-1
8112209c:	44400017 	ldw	r17,0(r8)
811220a0:	44000104 	addi	r16,r8,4
811220a4:	880b883a 	mov	r5,r17
811220a8:	8aa9883a 	add	r20,r17,r10
811220ac:	00000606 	br	811220c8 <__svfscanf_r+0x13cc>
811220b0:	e0c00017 	ldw	r3,0(fp)
811220b4:	b9000017 	ldw	r4,0(r23)
811220b8:	a80b883a 	mov	r5,r21
811220bc:	18800003 	ldbu	r2,0(r3)
811220c0:	2085883a 	add	r2,r4,r2
811220c4:	10800043 	ldbu	r2,1(r2)
811220c8:	1080020c 	andi	r2,r2,8
811220cc:	1000551e 	bne	r2,zero,81122224 <__svfscanf_r+0x1528>
811220d0:	e0800117 	ldw	r2,4(fp)
811220d4:	19000044 	addi	r4,r3,1
811220d8:	e1000015 	stw	r4,0(fp)
811220dc:	10bfffc4 	addi	r2,r2,-1
811220e0:	e0800115 	stw	r2,4(fp)
811220e4:	18800003 	ldbu	r2,0(r3)
811220e8:	2d400044 	addi	r21,r5,1
811220ec:	a827883a 	mov	r19,r21
811220f0:	28800005 	stb	r2,0(r5)
811220f4:	2d000626 	beq	r5,r20,81122110 <__svfscanf_r+0x1414>
811220f8:	e0800117 	ldw	r2,4(fp)
811220fc:	00bfec16 	blt	zero,r2,811220b0 <__reset+0xfb1020b0>
81122100:	e00b883a 	mov	r5,fp
81122104:	b009883a 	mov	r4,r22
81122108:	111bfdc0 	call	8111bfdc <__srefill_r>
8112210c:	103fe826 	beq	r2,zero,811220b0 <__reset+0xfb1020b0>
81122110:	da00a017 	ldw	r8,640(sp)
81122114:	dd009d17 	ldw	r20,628(sp)
81122118:	9c63c83a 	sub	r17,r19,r17
8112211c:	42000044 	addi	r8,r8,1
81122120:	98000005 	stb	zero,0(r19)
81122124:	9465883a 	add	r18,r18,r17
81122128:	da00a015 	stw	r8,640(sp)
8112212c:	dc009c15 	stw	r16,624(sp)
81122130:	a00d883a 	mov	r6,r20
81122134:	003b2f06 	br	81120df4 <__reset+0xfb100df4>
81122138:	dd409904 	addi	r21,sp,612
8112213c:	8c40040c 	andi	r17,r17,16
81122140:	01800204 	movi	r6,8
81122144:	000b883a 	mov	r5,zero
81122148:	a809883a 	mov	r4,r21
8112214c:	111bb600 	call	8111bb60 <memset>
81122150:	8800401e 	bne	r17,zero,81122254 <__svfscanf_r+0x1558>
81122154:	da009c17 	ldw	r8,624(sp)
81122158:	45000017 	ldw	r20,0(r8)
8112215c:	42000104 	addi	r8,r8,4
81122160:	da009c15 	stw	r8,624(sp)
81122164:	000d883a 	mov	r6,zero
81122168:	3021883a 	mov	r16,r6
8112216c:	dc409f15 	stw	r17,636(sp)
81122170:	e0800017 	ldw	r2,0(fp)
81122174:	b8c00017 	ldw	r3,0(r23)
81122178:	10800003 	ldbu	r2,0(r2)
8112217c:	1885883a 	add	r2,r3,r2
81122180:	10800043 	ldbu	r2,1(r2)
81122184:	1080020c 	andi	r2,r2,8
81122188:	1000011e 	bne	r2,zero,81122190 <__svfscanf_r+0x1494>
8112218c:	9800701e 	bne	r19,zero,81122350 <__svfscanf_r+0x1654>
81122190:	dc409f17 	ldw	r17,636(sp)
81122194:	883cdd1e 	bne	r17,zero,8112150c <__reset+0xfb10150c>
81122198:	a0000015 	stw	zero,0(r20)
8112219c:	003cd806 	br	81121500 <__reset+0xfb101500>
811221a0:	d9c09e17 	ldw	r7,632(sp)
811221a4:	da00a117 	ldw	r8,644(sp)
811221a8:	000d883a 	mov	r6,zero
811221ac:	d9400104 	addi	r5,sp,4
811221b0:	b009883a 	mov	r4,r22
811221b4:	80000005 	stb	zero,0(r16)
811221b8:	403ee83a 	callr	r8
811221bc:	88c0080c 	andi	r3,r17,32
811221c0:	1800121e 	bne	r3,zero,8112220c <__svfscanf_r+0x1510>
811221c4:	88c0010c 	andi	r3,r17,4
811221c8:	18004d26 	beq	r3,zero,81122300 <__svfscanf_r+0x1604>
811221cc:	da009c17 	ldw	r8,624(sp)
811221d0:	40c00017 	ldw	r3,0(r8)
811221d4:	42000104 	addi	r8,r8,4
811221d8:	da009c15 	stw	r8,624(sp)
811221dc:	1880000d 	sth	r2,0(r3)
811221e0:	da00a017 	ldw	r8,640(sp)
811221e4:	42000044 	addi	r8,r8,1
811221e8:	da00a015 	stw	r8,640(sp)
811221ec:	003f5906 	br	81121f54 <__reset+0xfb101f54>
811221f0:	00bf1fc4 	movi	r2,-897
811221f4:	90a4703a 	and	r18,r18,r2
811221f8:	38000226 	beq	r7,zero,81122204 <__svfscanf_r+0x1508>
811221fc:	39ffffc4 	addi	r7,r7,-1
81122200:	9cc00044 	addi	r19,r19,1
81122204:	a5000044 	addi	r20,r20,1
81122208:	003f3006 	br	81121ecc <__reset+0xfb101ecc>
8112220c:	da009c17 	ldw	r8,624(sp)
81122210:	40c00017 	ldw	r3,0(r8)
81122214:	42000104 	addi	r8,r8,4
81122218:	da009c15 	stw	r8,624(sp)
8112221c:	18800015 	stw	r2,0(r3)
81122220:	003fef06 	br	811221e0 <__reset+0xfb1021e0>
81122224:	2827883a 	mov	r19,r5
81122228:	003fb906 	br	81122110 <__reset+0xfb102110>
8112222c:	01be1fc4 	movi	r6,-1921
81122230:	a1a8703a 	and	r20,r20,r6
81122234:	05400044 	movi	r21,1
81122238:	003de906 	br	811219e0 <__reset+0xfb1019e0>
8112223c:	817fffc7 	ldb	r5,-1(r16)
81122240:	e00d883a 	mov	r6,fp
81122244:	b009883a 	mov	r4,r22
81122248:	843fffc4 	addi	r16,r16,-1
8112224c:	112a9540 	call	8112a954 <_ungetc_r>
81122250:	003f3c06 	br	81121f44 <__reset+0xfb101f44>
81122254:	dd009b04 	addi	r20,sp,620
81122258:	003fc206 	br	81122164 <__reset+0xfb102164>
8112225c:	00be1fc4 	movi	r2,-1921
81122260:	a0a8703a 	and	r20,r20,r2
81122264:	05800044 	movi	r22,1
81122268:	003ddd06 	br	811219e0 <__reset+0xfb1019e0>
8112226c:	d8c09f17 	ldw	r3,636(sp)
81122270:	88e3c83a 	sub	r17,r17,r3
81122274:	044dc83a 	sub	r6,zero,r17
81122278:	883e2126 	beq	r17,zero,81121b00 <__reset+0xfb101b00>
8112227c:	d88055c4 	addi	r2,sp,343
81122280:	80800136 	bltu	r16,r2,81122288 <__svfscanf_r+0x158c>
81122284:	dc005584 	addi	r16,sp,342
81122288:	01604574 	movhi	r5,33045
8112228c:	2966cb04 	addi	r5,r5,-25812
81122290:	8009883a 	mov	r4,r16
81122294:	111c2f00 	call	8111c2f0 <sprintf>
81122298:	003e1906 	br	81121b00 <__reset+0xfb101b00>
8112229c:	d8c0a517 	ldw	r3,660(sp)
811222a0:	000d883a 	mov	r6,zero
811222a4:	01c00284 	movi	r7,10
811222a8:	19400044 	addi	r5,r3,1
811222ac:	b009883a 	mov	r4,r22
811222b0:	111c5e00 	call	8111c5e0 <_strtol_r>
811222b4:	da00a417 	ldw	r8,656(sp)
811222b8:	dc00a517 	ldw	r16,660(sp)
811222bc:	120dc83a 	sub	r6,r2,r8
811222c0:	003fee06 	br	8112227c <__reset+0xfb10227c>
811222c4:	da009c17 	ldw	r8,624(sp)
811222c8:	180b883a 	mov	r5,r3
811222cc:	8009883a 	mov	r4,r16
811222d0:	45000017 	ldw	r20,0(r8)
811222d4:	44400104 	addi	r17,r8,4
811222d8:	d8c0a615 	stw	r3,664(sp)
811222dc:	11272700 	call	81127270 <__fpclassifyd>
811222e0:	d8c0a617 	ldw	r3,664(sp)
811222e4:	10006426 	beq	r2,zero,81122478 <__svfscanf_r+0x177c>
811222e8:	8009883a 	mov	r4,r16
811222ec:	180b883a 	mov	r5,r3
811222f0:	111a5f80 	call	8111a5f8 <__truncdfsf2>
811222f4:	a0800015 	stw	r2,0(r20)
811222f8:	dc409c15 	stw	r17,624(sp)
811222fc:	003e0f06 	br	81121b3c <__reset+0xfb101b3c>
81122300:	88c0004c 	andi	r3,r17,1
81122304:	183fc11e 	bne	r3,zero,8112220c <__reset+0xfb10220c>
81122308:	8c40008c 	andi	r17,r17,2
8112230c:	883fbf26 	beq	r17,zero,8112220c <__reset+0xfb10220c>
81122310:	da00a117 	ldw	r8,644(sp)
81122314:	00a044f4 	movhi	r2,33043
81122318:	10a3c304 	addi	r2,r2,-28916
8112231c:	d9c09e17 	ldw	r7,632(sp)
81122320:	000d883a 	mov	r6,zero
81122324:	d9400104 	addi	r5,sp,4
81122328:	b009883a 	mov	r4,r22
8112232c:	40806226 	beq	r8,r2,811224b8 <__svfscanf_r+0x17bc>
81122330:	1128c240 	call	81128c24 <_strtoll_r>
81122334:	da009c17 	ldw	r8,624(sp)
81122338:	41000017 	ldw	r4,0(r8)
8112233c:	42000104 	addi	r8,r8,4
81122340:	da009c15 	stw	r8,624(sp)
81122344:	20800015 	stw	r2,0(r4)
81122348:	20c00115 	stw	r3,4(r4)
8112234c:	003fa406 	br	811221e0 <__reset+0xfb1021e0>
81122350:	11257000 	call	81125700 <__locale_mb_cur_max>
81122354:	80bca726 	beq	r16,r2,811215f4 <__reset+0xfb1015f4>
81122358:	e0800017 	ldw	r2,0(fp)
8112235c:	e1000117 	ldw	r4,4(fp)
81122360:	d8c00104 	addi	r3,sp,4
81122364:	12000003 	ldbu	r8,0(r2)
81122368:	213fffc4 	addi	r4,r4,-1
8112236c:	10800044 	addi	r2,r2,1
81122370:	e1000115 	stw	r4,4(fp)
81122374:	e0800015 	stw	r2,0(fp)
81122378:	84400044 	addi	r17,r16,1
8112237c:	dd400015 	stw	r21,0(sp)
81122380:	1c21883a 	add	r16,r3,r16
81122384:	b009883a 	mov	r4,r22
81122388:	880f883a 	mov	r7,r17
8112238c:	180d883a 	mov	r6,r3
81122390:	a00b883a 	mov	r5,r20
81122394:	82000005 	stb	r8,0(r16)
81122398:	11257bc0 	call	811257bc <_mbrtowc_r>
8112239c:	013fffc4 	movi	r4,-1
811223a0:	113c9426 	beq	r2,r4,811215f4 <__reset+0xfb1015f4>
811223a4:	103c881e 	bne	r2,zero,811215c8 <__reset+0xfb1015c8>
811223a8:	a0000015 	stw	zero,0(r20)
811223ac:	0009883a 	mov	r4,zero
811223b0:	11256400 	call	81125640 <iswspace>
811223b4:	10001a26 	beq	r2,zero,81122420 <__svfscanf_r+0x1724>
811223b8:	8821883a 	mov	r16,r17
811223bc:	dc409f17 	ldw	r17,636(sp)
811223c0:	803f7426 	beq	r16,zero,81122194 <__reset+0xfb102194>
811223c4:	843fffc4 	addi	r16,r16,-1
811223c8:	d9800104 	addi	r6,sp,4
811223cc:	342b883a 	add	r21,r6,r16
811223d0:	00000106 	br	811223d8 <__svfscanf_r+0x16dc>
811223d4:	843fffc4 	addi	r16,r16,-1
811223d8:	a9400003 	ldbu	r5,0(r21)
811223dc:	e00d883a 	mov	r6,fp
811223e0:	b009883a 	mov	r4,r22
811223e4:	112a9540 	call	8112a954 <_ungetc_r>
811223e8:	ad7fffc4 	addi	r21,r21,-1
811223ec:	803ff91e 	bne	r16,zero,811223d4 <__reset+0xfb1023d4>
811223f0:	003f6806 	br	81122194 <__reset+0xfb102194>
811223f4:	d9800104 	addi	r6,sp,4
811223f8:	802b883a 	mov	r21,r16
811223fc:	343a812e 	bgeu	r6,r16,81120e04 <__reset+0xfb100e04>
81122400:	ad7fffc4 	addi	r21,r21,-1
81122404:	a9400007 	ldb	r5,0(r21)
81122408:	e00d883a 	mov	r6,fp
8112240c:	b009883a 	mov	r4,r22
81122410:	112a9540 	call	8112a954 <_ungetc_r>
81122414:	da000104 	addi	r8,sp,4
81122418:	457ff91e 	bne	r8,r21,81122400 <__reset+0xfb102400>
8112241c:	003a7906 	br	81120e04 <__reset+0xfb100e04>
81122420:	da009f17 	ldw	r8,636(sp)
81122424:	9465883a 	add	r18,r18,r17
81122428:	9cffffc4 	addi	r19,r19,-1
8112242c:	4000051e 	bne	r8,zero,81122444 <__svfscanf_r+0x1748>
81122430:	a5000104 	addi	r20,r20,4
81122434:	0021883a 	mov	r16,zero
81122438:	003c6606 	br	811215d4 <__reset+0xfb1015d4>
8112243c:	a1000017 	ldw	r4,0(r20)
81122440:	003fdb06 	br	811223b0 <__reset+0xfb1023b0>
81122444:	0021883a 	mov	r16,zero
81122448:	003c6206 	br	811215d4 <__reset+0xfb1015d4>
8112244c:	d8800104 	addi	r2,sp,4
81122450:	802b883a 	mov	r21,r16
81122454:	143a6b2e 	bgeu	r2,r16,81120e04 <__reset+0xfb100e04>
81122458:	ad7fffc4 	addi	r21,r21,-1
8112245c:	a9400007 	ldb	r5,0(r21)
81122460:	e00d883a 	mov	r6,fp
81122464:	b009883a 	mov	r4,r22
81122468:	112a9540 	call	8112a954 <_ungetc_r>
8112246c:	d8c00104 	addi	r3,sp,4
81122470:	1d7ff91e 	bne	r3,r21,81122458 <__reset+0xfb102458>
81122474:	003a6306 	br	81120e04 <__reset+0xfb100e04>
81122478:	0009883a 	mov	r4,zero
8112247c:	11273b40 	call	811273b4 <nanf>
81122480:	a0800015 	stw	r2,0(r20)
81122484:	dc409c15 	stw	r17,624(sp)
81122488:	003dac06 	br	81121b3c <__reset+0xfb101b3c>
8112248c:	d9000104 	addi	r4,sp,4
81122490:	802b883a 	mov	r21,r16
81122494:	243a5b2e 	bgeu	r4,r16,81120e04 <__reset+0xfb100e04>
81122498:	ad7fffc4 	addi	r21,r21,-1
8112249c:	a9400007 	ldb	r5,0(r21)
811224a0:	e00d883a 	mov	r6,fp
811224a4:	b009883a 	mov	r4,r22
811224a8:	112a9540 	call	8112a954 <_ungetc_r>
811224ac:	d9400104 	addi	r5,sp,4
811224b0:	2d7ff91e 	bne	r5,r21,81122498 <__reset+0xfb102498>
811224b4:	003a5306 	br	81120e04 <__reset+0xfb100e04>
811224b8:	112917c0 	call	8112917c <_strtoull_r>
811224bc:	003f9d06 	br	81122334 <__reset+0xfb102334>

811224c0 <vfscanf>:
811224c0:	00a04574 	movhi	r2,33045
811224c4:	defffb04 	addi	sp,sp,-20
811224c8:	10b08204 	addi	r2,r2,-15864
811224cc:	de00012e 	bgeu	sp,et,811224d4 <vfscanf+0x14>
811224d0:	003b68fa 	trap	3
811224d4:	dc000215 	stw	r16,8(sp)
811224d8:	14000017 	ldw	r16,0(r2)
811224dc:	dc400315 	stw	r17,12(sp)
811224e0:	dfc00415 	stw	ra,16(sp)
811224e4:	2023883a 	mov	r17,r4
811224e8:	80000826 	beq	r16,zero,8112250c <vfscanf+0x4c>
811224ec:	80800e17 	ldw	r2,56(r16)
811224f0:	1000061e 	bne	r2,zero,8112250c <vfscanf+0x4c>
811224f4:	8009883a 	mov	r4,r16
811224f8:	d9400015 	stw	r5,0(sp)
811224fc:	d9800115 	stw	r6,4(sp)
81122500:	11247d80 	call	811247d8 <__sinit>
81122504:	d9800117 	ldw	r6,4(sp)
81122508:	d9400017 	ldw	r5,0(sp)
8112250c:	300f883a 	mov	r7,r6
81122510:	8009883a 	mov	r4,r16
81122514:	280d883a 	mov	r6,r5
81122518:	880b883a 	mov	r5,r17
8112251c:	dfc00417 	ldw	ra,16(sp)
81122520:	dc400317 	ldw	r17,12(sp)
81122524:	dc000217 	ldw	r16,8(sp)
81122528:	dec00504 	addi	sp,sp,20
8112252c:	1120cfc1 	jmpi	81120cfc <__svfscanf_r>

81122530 <__svfscanf>:
81122530:	00a04574 	movhi	r2,33045
81122534:	10b08204 	addi	r2,r2,-15864
81122538:	300f883a 	mov	r7,r6
8112253c:	280d883a 	mov	r6,r5
81122540:	200b883a 	mov	r5,r4
81122544:	11000017 	ldw	r4,0(r2)
81122548:	1120cfc1 	jmpi	81120cfc <__svfscanf_r>

8112254c <_vfscanf_r>:
8112254c:	defffb04 	addi	sp,sp,-20
81122550:	de00012e 	bgeu	sp,et,81122558 <_vfscanf_r+0xc>
81122554:	003b68fa 	trap	3
81122558:	dc000315 	stw	r16,12(sp)
8112255c:	dfc00415 	stw	ra,16(sp)
81122560:	2021883a 	mov	r16,r4
81122564:	20000926 	beq	r4,zero,8112258c <_vfscanf_r+0x40>
81122568:	20800e17 	ldw	r2,56(r4)
8112256c:	1000071e 	bne	r2,zero,8112258c <_vfscanf_r+0x40>
81122570:	d9400015 	stw	r5,0(sp)
81122574:	d9800115 	stw	r6,4(sp)
81122578:	d9c00215 	stw	r7,8(sp)
8112257c:	11247d80 	call	811247d8 <__sinit>
81122580:	d9c00217 	ldw	r7,8(sp)
81122584:	d9800117 	ldw	r6,4(sp)
81122588:	d9400017 	ldw	r5,0(sp)
8112258c:	8009883a 	mov	r4,r16
81122590:	dfc00417 	ldw	ra,16(sp)
81122594:	dc000317 	ldw	r16,12(sp)
81122598:	dec00504 	addi	sp,sp,20
8112259c:	1120cfc1 	jmpi	81120cfc <__svfscanf_r>

811225a0 <__swbuf_r>:
811225a0:	defffb04 	addi	sp,sp,-20
811225a4:	de00012e 	bgeu	sp,et,811225ac <__swbuf_r+0xc>
811225a8:	003b68fa 	trap	3
811225ac:	dcc00315 	stw	r19,12(sp)
811225b0:	dc800215 	stw	r18,8(sp)
811225b4:	dc000015 	stw	r16,0(sp)
811225b8:	dfc00415 	stw	ra,16(sp)
811225bc:	dc400115 	stw	r17,4(sp)
811225c0:	2025883a 	mov	r18,r4
811225c4:	2827883a 	mov	r19,r5
811225c8:	3021883a 	mov	r16,r6
811225cc:	20000226 	beq	r4,zero,811225d8 <__swbuf_r+0x38>
811225d0:	20800e17 	ldw	r2,56(r4)
811225d4:	10004226 	beq	r2,zero,811226e0 <__swbuf_r+0x140>
811225d8:	80800617 	ldw	r2,24(r16)
811225dc:	8100030b 	ldhu	r4,12(r16)
811225e0:	80800215 	stw	r2,8(r16)
811225e4:	2080020c 	andi	r2,r4,8
811225e8:	10003626 	beq	r2,zero,811226c4 <__swbuf_r+0x124>
811225ec:	80c00417 	ldw	r3,16(r16)
811225f0:	18003426 	beq	r3,zero,811226c4 <__swbuf_r+0x124>
811225f4:	2088000c 	andi	r2,r4,8192
811225f8:	9c403fcc 	andi	r17,r19,255
811225fc:	10001a26 	beq	r2,zero,81122668 <__swbuf_r+0xc8>
81122600:	80800017 	ldw	r2,0(r16)
81122604:	81000517 	ldw	r4,20(r16)
81122608:	10c7c83a 	sub	r3,r2,r3
8112260c:	1900200e 	bge	r3,r4,81122690 <__swbuf_r+0xf0>
81122610:	18c00044 	addi	r3,r3,1
81122614:	81000217 	ldw	r4,8(r16)
81122618:	11400044 	addi	r5,r2,1
8112261c:	81400015 	stw	r5,0(r16)
81122620:	213fffc4 	addi	r4,r4,-1
81122624:	81000215 	stw	r4,8(r16)
81122628:	14c00005 	stb	r19,0(r2)
8112262c:	80800517 	ldw	r2,20(r16)
81122630:	10c01e26 	beq	r2,r3,811226ac <__swbuf_r+0x10c>
81122634:	8080030b 	ldhu	r2,12(r16)
81122638:	1080004c 	andi	r2,r2,1
8112263c:	10000226 	beq	r2,zero,81122648 <__swbuf_r+0xa8>
81122640:	00800284 	movi	r2,10
81122644:	88801926 	beq	r17,r2,811226ac <__swbuf_r+0x10c>
81122648:	8805883a 	mov	r2,r17
8112264c:	dfc00417 	ldw	ra,16(sp)
81122650:	dcc00317 	ldw	r19,12(sp)
81122654:	dc800217 	ldw	r18,8(sp)
81122658:	dc400117 	ldw	r17,4(sp)
8112265c:	dc000017 	ldw	r16,0(sp)
81122660:	dec00504 	addi	sp,sp,20
81122664:	f800283a 	ret
81122668:	81401917 	ldw	r5,100(r16)
8112266c:	00b7ffc4 	movi	r2,-8193
81122670:	21080014 	ori	r4,r4,8192
81122674:	2884703a 	and	r2,r5,r2
81122678:	80801915 	stw	r2,100(r16)
8112267c:	80800017 	ldw	r2,0(r16)
81122680:	8100030d 	sth	r4,12(r16)
81122684:	81000517 	ldw	r4,20(r16)
81122688:	10c7c83a 	sub	r3,r2,r3
8112268c:	193fe016 	blt	r3,r4,81122610 <__reset+0xfb102610>
81122690:	800b883a 	mov	r5,r16
81122694:	9009883a 	mov	r4,r18
81122698:	11243dc0 	call	811243dc <_fflush_r>
8112269c:	1000071e 	bne	r2,zero,811226bc <__swbuf_r+0x11c>
811226a0:	80800017 	ldw	r2,0(r16)
811226a4:	00c00044 	movi	r3,1
811226a8:	003fda06 	br	81122614 <__reset+0xfb102614>
811226ac:	800b883a 	mov	r5,r16
811226b0:	9009883a 	mov	r4,r18
811226b4:	11243dc0 	call	811243dc <_fflush_r>
811226b8:	103fe326 	beq	r2,zero,81122648 <__reset+0xfb102648>
811226bc:	00bfffc4 	movi	r2,-1
811226c0:	003fe206 	br	8112264c <__reset+0xfb10264c>
811226c4:	800b883a 	mov	r5,r16
811226c8:	9009883a 	mov	r4,r18
811226cc:	11227680 	call	81122768 <__swsetup_r>
811226d0:	103ffa1e 	bne	r2,zero,811226bc <__reset+0xfb1026bc>
811226d4:	8100030b 	ldhu	r4,12(r16)
811226d8:	80c00417 	ldw	r3,16(r16)
811226dc:	003fc506 	br	811225f4 <__reset+0xfb1025f4>
811226e0:	11247d80 	call	811247d8 <__sinit>
811226e4:	003fbc06 	br	811225d8 <__reset+0xfb1025d8>

811226e8 <__swbuf>:
811226e8:	00a04574 	movhi	r2,33045
811226ec:	10b08204 	addi	r2,r2,-15864
811226f0:	280d883a 	mov	r6,r5
811226f4:	200b883a 	mov	r5,r4
811226f8:	11000017 	ldw	r4,0(r2)
811226fc:	11225a01 	jmpi	811225a0 <__swbuf_r>

81122700 <_write_r>:
81122700:	defffd04 	addi	sp,sp,-12
81122704:	de00012e 	bgeu	sp,et,8112270c <_write_r+0xc>
81122708:	003b68fa 	trap	3
8112270c:	2805883a 	mov	r2,r5
81122710:	dc000015 	stw	r16,0(sp)
81122714:	04204574 	movhi	r16,33045
81122718:	dc400115 	stw	r17,4(sp)
8112271c:	300b883a 	mov	r5,r6
81122720:	8430fa04 	addi	r16,r16,-15384
81122724:	2023883a 	mov	r17,r4
81122728:	380d883a 	mov	r6,r7
8112272c:	1009883a 	mov	r4,r2
81122730:	dfc00215 	stw	ra,8(sp)
81122734:	80000015 	stw	zero,0(r16)
81122738:	1131db80 	call	81131db8 <write>
8112273c:	00ffffc4 	movi	r3,-1
81122740:	10c00526 	beq	r2,r3,81122758 <_write_r+0x58>
81122744:	dfc00217 	ldw	ra,8(sp)
81122748:	dc400117 	ldw	r17,4(sp)
8112274c:	dc000017 	ldw	r16,0(sp)
81122750:	dec00304 	addi	sp,sp,12
81122754:	f800283a 	ret
81122758:	80c00017 	ldw	r3,0(r16)
8112275c:	183ff926 	beq	r3,zero,81122744 <__reset+0xfb102744>
81122760:	88c00015 	stw	r3,0(r17)
81122764:	003ff706 	br	81122744 <__reset+0xfb102744>

81122768 <__swsetup_r>:
81122768:	00a04574 	movhi	r2,33045
8112276c:	defffd04 	addi	sp,sp,-12
81122770:	10b08204 	addi	r2,r2,-15864
81122774:	de00012e 	bgeu	sp,et,8112277c <__swsetup_r+0x14>
81122778:	003b68fa 	trap	3
8112277c:	dc400115 	stw	r17,4(sp)
81122780:	2023883a 	mov	r17,r4
81122784:	11000017 	ldw	r4,0(r2)
81122788:	dc000015 	stw	r16,0(sp)
8112278c:	dfc00215 	stw	ra,8(sp)
81122790:	2821883a 	mov	r16,r5
81122794:	20000226 	beq	r4,zero,811227a0 <__swsetup_r+0x38>
81122798:	20800e17 	ldw	r2,56(r4)
8112279c:	10003126 	beq	r2,zero,81122864 <__swsetup_r+0xfc>
811227a0:	8080030b 	ldhu	r2,12(r16)
811227a4:	10c0020c 	andi	r3,r2,8
811227a8:	1009883a 	mov	r4,r2
811227ac:	18000f26 	beq	r3,zero,811227ec <__swsetup_r+0x84>
811227b0:	80c00417 	ldw	r3,16(r16)
811227b4:	18001526 	beq	r3,zero,8112280c <__swsetup_r+0xa4>
811227b8:	1100004c 	andi	r4,r2,1
811227bc:	20001c1e 	bne	r4,zero,81122830 <__swsetup_r+0xc8>
811227c0:	1080008c 	andi	r2,r2,2
811227c4:	1000291e 	bne	r2,zero,8112286c <__swsetup_r+0x104>
811227c8:	80800517 	ldw	r2,20(r16)
811227cc:	80800215 	stw	r2,8(r16)
811227d0:	18001c26 	beq	r3,zero,81122844 <__swsetup_r+0xdc>
811227d4:	0005883a 	mov	r2,zero
811227d8:	dfc00217 	ldw	ra,8(sp)
811227dc:	dc400117 	ldw	r17,4(sp)
811227e0:	dc000017 	ldw	r16,0(sp)
811227e4:	dec00304 	addi	sp,sp,12
811227e8:	f800283a 	ret
811227ec:	2080040c 	andi	r2,r4,16
811227f0:	10002e26 	beq	r2,zero,811228ac <__swsetup_r+0x144>
811227f4:	2080010c 	andi	r2,r4,4
811227f8:	10001e1e 	bne	r2,zero,81122874 <__swsetup_r+0x10c>
811227fc:	80c00417 	ldw	r3,16(r16)
81122800:	20800214 	ori	r2,r4,8
81122804:	8080030d 	sth	r2,12(r16)
81122808:	183feb1e 	bne	r3,zero,811227b8 <__reset+0xfb1027b8>
8112280c:	1100a00c 	andi	r4,r2,640
81122810:	01408004 	movi	r5,512
81122814:	217fe826 	beq	r4,r5,811227b8 <__reset+0xfb1027b8>
81122818:	800b883a 	mov	r5,r16
8112281c:	8809883a 	mov	r4,r17
81122820:	111b0380 	call	8111b038 <__smakebuf_r>
81122824:	8080030b 	ldhu	r2,12(r16)
81122828:	80c00417 	ldw	r3,16(r16)
8112282c:	003fe206 	br	811227b8 <__reset+0xfb1027b8>
81122830:	80800517 	ldw	r2,20(r16)
81122834:	80000215 	stw	zero,8(r16)
81122838:	0085c83a 	sub	r2,zero,r2
8112283c:	80800615 	stw	r2,24(r16)
81122840:	183fe41e 	bne	r3,zero,811227d4 <__reset+0xfb1027d4>
81122844:	80c0030b 	ldhu	r3,12(r16)
81122848:	0005883a 	mov	r2,zero
8112284c:	1900200c 	andi	r4,r3,128
81122850:	203fe126 	beq	r4,zero,811227d8 <__reset+0xfb1027d8>
81122854:	18c01014 	ori	r3,r3,64
81122858:	80c0030d 	sth	r3,12(r16)
8112285c:	00bfffc4 	movi	r2,-1
81122860:	003fdd06 	br	811227d8 <__reset+0xfb1027d8>
81122864:	11247d80 	call	811247d8 <__sinit>
81122868:	003fcd06 	br	811227a0 <__reset+0xfb1027a0>
8112286c:	0005883a 	mov	r2,zero
81122870:	003fd606 	br	811227cc <__reset+0xfb1027cc>
81122874:	81400c17 	ldw	r5,48(r16)
81122878:	28000626 	beq	r5,zero,81122894 <__swsetup_r+0x12c>
8112287c:	80801004 	addi	r2,r16,64
81122880:	28800326 	beq	r5,r2,81122890 <__swsetup_r+0x128>
81122884:	8809883a 	mov	r4,r17
81122888:	1124c700 	call	81124c70 <_free_r>
8112288c:	8100030b 	ldhu	r4,12(r16)
81122890:	80000c15 	stw	zero,48(r16)
81122894:	80c00417 	ldw	r3,16(r16)
81122898:	00bff6c4 	movi	r2,-37
8112289c:	1108703a 	and	r4,r2,r4
811228a0:	80000115 	stw	zero,4(r16)
811228a4:	80c00015 	stw	r3,0(r16)
811228a8:	003fd506 	br	81122800 <__reset+0xfb102800>
811228ac:	00800244 	movi	r2,9
811228b0:	88800015 	stw	r2,0(r17)
811228b4:	20801014 	ori	r2,r4,64
811228b8:	8080030d 	sth	r2,12(r16)
811228bc:	00bfffc4 	movi	r2,-1
811228c0:	003fc506 	br	811227d8 <__reset+0xfb1027d8>

811228c4 <_close_r>:
811228c4:	defffd04 	addi	sp,sp,-12
811228c8:	de00012e 	bgeu	sp,et,811228d0 <_close_r+0xc>
811228cc:	003b68fa 	trap	3
811228d0:	dc000015 	stw	r16,0(sp)
811228d4:	04204574 	movhi	r16,33045
811228d8:	dc400115 	stw	r17,4(sp)
811228dc:	8430fa04 	addi	r16,r16,-15384
811228e0:	2023883a 	mov	r17,r4
811228e4:	2809883a 	mov	r4,r5
811228e8:	dfc00215 	stw	ra,8(sp)
811228ec:	80000015 	stw	zero,0(r16)
811228f0:	11303380 	call	81130338 <close>
811228f4:	00ffffc4 	movi	r3,-1
811228f8:	10c00526 	beq	r2,r3,81122910 <_close_r+0x4c>
811228fc:	dfc00217 	ldw	ra,8(sp)
81122900:	dc400117 	ldw	r17,4(sp)
81122904:	dc000017 	ldw	r16,0(sp)
81122908:	dec00304 	addi	sp,sp,12
8112290c:	f800283a 	ret
81122910:	80c00017 	ldw	r3,0(r16)
81122914:	183ff926 	beq	r3,zero,811228fc <__reset+0xfb1028fc>
81122918:	88c00015 	stw	r3,0(r17)
8112291c:	003ff706 	br	811228fc <__reset+0xfb1028fc>

81122920 <quorem>:
81122920:	defff704 	addi	sp,sp,-36
81122924:	de00012e 	bgeu	sp,et,8112292c <quorem+0xc>
81122928:	003b68fa 	trap	3
8112292c:	dc800215 	stw	r18,8(sp)
81122930:	20800417 	ldw	r2,16(r4)
81122934:	2c800417 	ldw	r18,16(r5)
81122938:	dfc00815 	stw	ra,32(sp)
8112293c:	ddc00715 	stw	r23,28(sp)
81122940:	dd800615 	stw	r22,24(sp)
81122944:	dd400515 	stw	r21,20(sp)
81122948:	dd000415 	stw	r20,16(sp)
8112294c:	dcc00315 	stw	r19,12(sp)
81122950:	dc400115 	stw	r17,4(sp)
81122954:	dc000015 	stw	r16,0(sp)
81122958:	14807116 	blt	r2,r18,81122b20 <quorem+0x200>
8112295c:	94bfffc4 	addi	r18,r18,-1
81122960:	94ad883a 	add	r22,r18,r18
81122964:	b5ad883a 	add	r22,r22,r22
81122968:	2c400504 	addi	r17,r5,20
8112296c:	8da9883a 	add	r20,r17,r22
81122970:	25400504 	addi	r21,r4,20
81122974:	282f883a 	mov	r23,r5
81122978:	adad883a 	add	r22,r21,r22
8112297c:	a1400017 	ldw	r5,0(r20)
81122980:	2021883a 	mov	r16,r4
81122984:	b1000017 	ldw	r4,0(r22)
81122988:	29400044 	addi	r5,r5,1
8112298c:	112dff80 	call	8112dff8 <__udivsi3>
81122990:	1027883a 	mov	r19,r2
81122994:	10002c26 	beq	r2,zero,81122a48 <quorem+0x128>
81122998:	a813883a 	mov	r9,r21
8112299c:	880b883a 	mov	r5,r17
811229a0:	0009883a 	mov	r4,zero
811229a4:	000d883a 	mov	r6,zero
811229a8:	2a000017 	ldw	r8,0(r5)
811229ac:	49c00017 	ldw	r7,0(r9)
811229b0:	29400104 	addi	r5,r5,4
811229b4:	40bfffcc 	andi	r2,r8,65535
811229b8:	14c5383a 	mul	r2,r2,r19
811229bc:	4010d43a 	srli	r8,r8,16
811229c0:	38ffffcc 	andi	r3,r7,65535
811229c4:	1105883a 	add	r2,r2,r4
811229c8:	1008d43a 	srli	r4,r2,16
811229cc:	44d1383a 	mul	r8,r8,r19
811229d0:	198d883a 	add	r6,r3,r6
811229d4:	10ffffcc 	andi	r3,r2,65535
811229d8:	30c7c83a 	sub	r3,r6,r3
811229dc:	380ed43a 	srli	r7,r7,16
811229e0:	4105883a 	add	r2,r8,r4
811229e4:	180dd43a 	srai	r6,r3,16
811229e8:	113fffcc 	andi	r4,r2,65535
811229ec:	390fc83a 	sub	r7,r7,r4
811229f0:	398d883a 	add	r6,r7,r6
811229f4:	300e943a 	slli	r7,r6,16
811229f8:	18ffffcc 	andi	r3,r3,65535
811229fc:	1008d43a 	srli	r4,r2,16
81122a00:	38ceb03a 	or	r7,r7,r3
81122a04:	49c00015 	stw	r7,0(r9)
81122a08:	300dd43a 	srai	r6,r6,16
81122a0c:	4a400104 	addi	r9,r9,4
81122a10:	a17fe52e 	bgeu	r20,r5,811229a8 <__reset+0xfb1029a8>
81122a14:	b0800017 	ldw	r2,0(r22)
81122a18:	10000b1e 	bne	r2,zero,81122a48 <quorem+0x128>
81122a1c:	b0bfff04 	addi	r2,r22,-4
81122a20:	a880082e 	bgeu	r21,r2,81122a44 <quorem+0x124>
81122a24:	b0ffff17 	ldw	r3,-4(r22)
81122a28:	18000326 	beq	r3,zero,81122a38 <quorem+0x118>
81122a2c:	00000506 	br	81122a44 <quorem+0x124>
81122a30:	10c00017 	ldw	r3,0(r2)
81122a34:	1800031e 	bne	r3,zero,81122a44 <quorem+0x124>
81122a38:	10bfff04 	addi	r2,r2,-4
81122a3c:	94bfffc4 	addi	r18,r18,-1
81122a40:	a8bffb36 	bltu	r21,r2,81122a30 <__reset+0xfb102a30>
81122a44:	84800415 	stw	r18,16(r16)
81122a48:	b80b883a 	mov	r5,r23
81122a4c:	8009883a 	mov	r4,r16
81122a50:	11265400 	call	81126540 <__mcmp>
81122a54:	10002616 	blt	r2,zero,81122af0 <quorem+0x1d0>
81122a58:	9cc00044 	addi	r19,r19,1
81122a5c:	a805883a 	mov	r2,r21
81122a60:	000b883a 	mov	r5,zero
81122a64:	11000017 	ldw	r4,0(r2)
81122a68:	89800017 	ldw	r6,0(r17)
81122a6c:	10800104 	addi	r2,r2,4
81122a70:	20ffffcc 	andi	r3,r4,65535
81122a74:	194b883a 	add	r5,r3,r5
81122a78:	30ffffcc 	andi	r3,r6,65535
81122a7c:	28c7c83a 	sub	r3,r5,r3
81122a80:	300cd43a 	srli	r6,r6,16
81122a84:	2008d43a 	srli	r4,r4,16
81122a88:	180bd43a 	srai	r5,r3,16
81122a8c:	18ffffcc 	andi	r3,r3,65535
81122a90:	2189c83a 	sub	r4,r4,r6
81122a94:	2149883a 	add	r4,r4,r5
81122a98:	200c943a 	slli	r6,r4,16
81122a9c:	8c400104 	addi	r17,r17,4
81122aa0:	200bd43a 	srai	r5,r4,16
81122aa4:	30c6b03a 	or	r3,r6,r3
81122aa8:	10ffff15 	stw	r3,-4(r2)
81122aac:	a47fed2e 	bgeu	r20,r17,81122a64 <__reset+0xfb102a64>
81122ab0:	9485883a 	add	r2,r18,r18
81122ab4:	1085883a 	add	r2,r2,r2
81122ab8:	a887883a 	add	r3,r21,r2
81122abc:	18800017 	ldw	r2,0(r3)
81122ac0:	10000b1e 	bne	r2,zero,81122af0 <quorem+0x1d0>
81122ac4:	18bfff04 	addi	r2,r3,-4
81122ac8:	a880082e 	bgeu	r21,r2,81122aec <quorem+0x1cc>
81122acc:	18ffff17 	ldw	r3,-4(r3)
81122ad0:	18000326 	beq	r3,zero,81122ae0 <quorem+0x1c0>
81122ad4:	00000506 	br	81122aec <quorem+0x1cc>
81122ad8:	10c00017 	ldw	r3,0(r2)
81122adc:	1800031e 	bne	r3,zero,81122aec <quorem+0x1cc>
81122ae0:	10bfff04 	addi	r2,r2,-4
81122ae4:	94bfffc4 	addi	r18,r18,-1
81122ae8:	a8bffb36 	bltu	r21,r2,81122ad8 <__reset+0xfb102ad8>
81122aec:	84800415 	stw	r18,16(r16)
81122af0:	9805883a 	mov	r2,r19
81122af4:	dfc00817 	ldw	ra,32(sp)
81122af8:	ddc00717 	ldw	r23,28(sp)
81122afc:	dd800617 	ldw	r22,24(sp)
81122b00:	dd400517 	ldw	r21,20(sp)
81122b04:	dd000417 	ldw	r20,16(sp)
81122b08:	dcc00317 	ldw	r19,12(sp)
81122b0c:	dc800217 	ldw	r18,8(sp)
81122b10:	dc400117 	ldw	r17,4(sp)
81122b14:	dc000017 	ldw	r16,0(sp)
81122b18:	dec00904 	addi	sp,sp,36
81122b1c:	f800283a 	ret
81122b20:	0005883a 	mov	r2,zero
81122b24:	003ff306 	br	81122af4 <__reset+0xfb102af4>

81122b28 <_dtoa_r>:
81122b28:	deffde04 	addi	sp,sp,-136
81122b2c:	de00012e 	bgeu	sp,et,81122b34 <_dtoa_r+0xc>
81122b30:	003b68fa 	trap	3
81122b34:	20801017 	ldw	r2,64(r4)
81122b38:	df002015 	stw	fp,128(sp)
81122b3c:	dcc01b15 	stw	r19,108(sp)
81122b40:	dc801a15 	stw	r18,104(sp)
81122b44:	dc401915 	stw	r17,100(sp)
81122b48:	dc001815 	stw	r16,96(sp)
81122b4c:	dfc02115 	stw	ra,132(sp)
81122b50:	ddc01f15 	stw	r23,124(sp)
81122b54:	dd801e15 	stw	r22,120(sp)
81122b58:	dd401d15 	stw	r21,116(sp)
81122b5c:	dd001c15 	stw	r20,112(sp)
81122b60:	d9c00315 	stw	r7,12(sp)
81122b64:	2039883a 	mov	fp,r4
81122b68:	3023883a 	mov	r17,r6
81122b6c:	2825883a 	mov	r18,r5
81122b70:	dc002417 	ldw	r16,144(sp)
81122b74:	3027883a 	mov	r19,r6
81122b78:	10000826 	beq	r2,zero,81122b9c <_dtoa_r+0x74>
81122b7c:	21801117 	ldw	r6,68(r4)
81122b80:	00c00044 	movi	r3,1
81122b84:	100b883a 	mov	r5,r2
81122b88:	1986983a 	sll	r3,r3,r6
81122b8c:	11800115 	stw	r6,4(r2)
81122b90:	10c00215 	stw	r3,8(r2)
81122b94:	1125cf00 	call	81125cf0 <_Bfree>
81122b98:	e0001015 	stw	zero,64(fp)
81122b9c:	88002e16 	blt	r17,zero,81122c58 <_dtoa_r+0x130>
81122ba0:	80000015 	stw	zero,0(r16)
81122ba4:	889ffc2c 	andhi	r2,r17,32752
81122ba8:	00dffc34 	movhi	r3,32752
81122bac:	10c01c26 	beq	r2,r3,81122c20 <_dtoa_r+0xf8>
81122bb0:	000d883a 	mov	r6,zero
81122bb4:	000f883a 	mov	r7,zero
81122bb8:	9009883a 	mov	r4,r18
81122bbc:	980b883a 	mov	r5,r19
81122bc0:	112f4540 	call	8112f454 <__eqdf2>
81122bc4:	10002b1e 	bne	r2,zero,81122c74 <_dtoa_r+0x14c>
81122bc8:	d9c02317 	ldw	r7,140(sp)
81122bcc:	00800044 	movi	r2,1
81122bd0:	38800015 	stw	r2,0(r7)
81122bd4:	d8802517 	ldw	r2,148(sp)
81122bd8:	10019e26 	beq	r2,zero,81123254 <_dtoa_r+0x72c>
81122bdc:	d8c02517 	ldw	r3,148(sp)
81122be0:	00a04574 	movhi	r2,33045
81122be4:	10a6ba44 	addi	r2,r2,-25879
81122be8:	18800015 	stw	r2,0(r3)
81122bec:	10bfffc4 	addi	r2,r2,-1
81122bf0:	dfc02117 	ldw	ra,132(sp)
81122bf4:	df002017 	ldw	fp,128(sp)
81122bf8:	ddc01f17 	ldw	r23,124(sp)
81122bfc:	dd801e17 	ldw	r22,120(sp)
81122c00:	dd401d17 	ldw	r21,116(sp)
81122c04:	dd001c17 	ldw	r20,112(sp)
81122c08:	dcc01b17 	ldw	r19,108(sp)
81122c0c:	dc801a17 	ldw	r18,104(sp)
81122c10:	dc401917 	ldw	r17,100(sp)
81122c14:	dc001817 	ldw	r16,96(sp)
81122c18:	dec02204 	addi	sp,sp,136
81122c1c:	f800283a 	ret
81122c20:	d8c02317 	ldw	r3,140(sp)
81122c24:	0089c3c4 	movi	r2,9999
81122c28:	18800015 	stw	r2,0(r3)
81122c2c:	90017726 	beq	r18,zero,8112320c <_dtoa_r+0x6e4>
81122c30:	00a04574 	movhi	r2,33045
81122c34:	10a6d804 	addi	r2,r2,-25760
81122c38:	d9002517 	ldw	r4,148(sp)
81122c3c:	203fec26 	beq	r4,zero,81122bf0 <__reset+0xfb102bf0>
81122c40:	10c000c7 	ldb	r3,3(r2)
81122c44:	1801781e 	bne	r3,zero,81123228 <_dtoa_r+0x700>
81122c48:	10c000c4 	addi	r3,r2,3
81122c4c:	d9802517 	ldw	r6,148(sp)
81122c50:	30c00015 	stw	r3,0(r6)
81122c54:	003fe606 	br	81122bf0 <__reset+0xfb102bf0>
81122c58:	04e00034 	movhi	r19,32768
81122c5c:	9cffffc4 	addi	r19,r19,-1
81122c60:	00800044 	movi	r2,1
81122c64:	8ce6703a 	and	r19,r17,r19
81122c68:	80800015 	stw	r2,0(r16)
81122c6c:	9823883a 	mov	r17,r19
81122c70:	003fcc06 	br	81122ba4 <__reset+0xfb102ba4>
81122c74:	d8800204 	addi	r2,sp,8
81122c78:	d8800015 	stw	r2,0(sp)
81122c7c:	d9c00104 	addi	r7,sp,4
81122c80:	900b883a 	mov	r5,r18
81122c84:	980d883a 	mov	r6,r19
81122c88:	e009883a 	mov	r4,fp
81122c8c:	8820d53a 	srli	r16,r17,20
81122c90:	112691c0 	call	8112691c <__d2b>
81122c94:	d8800915 	stw	r2,36(sp)
81122c98:	8001651e 	bne	r16,zero,81123230 <_dtoa_r+0x708>
81122c9c:	dd800217 	ldw	r22,8(sp)
81122ca0:	dc000117 	ldw	r16,4(sp)
81122ca4:	00800804 	movi	r2,32
81122ca8:	b421883a 	add	r16,r22,r16
81122cac:	80c10c84 	addi	r3,r16,1074
81122cb0:	10c2d10e 	bge	r2,r3,811237f8 <_dtoa_r+0xcd0>
81122cb4:	00801004 	movi	r2,64
81122cb8:	81010484 	addi	r4,r16,1042
81122cbc:	10c7c83a 	sub	r3,r2,r3
81122cc0:	9108d83a 	srl	r4,r18,r4
81122cc4:	88e2983a 	sll	r17,r17,r3
81122cc8:	2448b03a 	or	r4,r4,r17
81122ccc:	11301140 	call	81130114 <__floatunsidf>
81122cd0:	017f8434 	movhi	r5,65040
81122cd4:	01800044 	movi	r6,1
81122cd8:	1009883a 	mov	r4,r2
81122cdc:	194b883a 	add	r5,r3,r5
81122ce0:	843fffc4 	addi	r16,r16,-1
81122ce4:	d9801115 	stw	r6,68(sp)
81122ce8:	000d883a 	mov	r6,zero
81122cec:	01cffe34 	movhi	r7,16376
81122cf0:	112f6ac0 	call	8112f6ac <__subdf3>
81122cf4:	0198dbf4 	movhi	r6,25455
81122cf8:	01cff4f4 	movhi	r7,16339
81122cfc:	3190d844 	addi	r6,r6,17249
81122d00:	39e1e9c4 	addi	r7,r7,-30809
81122d04:	1009883a 	mov	r4,r2
81122d08:	180b883a 	mov	r5,r3
81122d0c:	1119dc00 	call	81119dc0 <__muldf3>
81122d10:	01a2d874 	movhi	r6,35681
81122d14:	01cff1f4 	movhi	r7,16327
81122d18:	31b22cc4 	addi	r6,r6,-14157
81122d1c:	39e28a04 	addi	r7,r7,-30168
81122d20:	180b883a 	mov	r5,r3
81122d24:	1009883a 	mov	r4,r2
81122d28:	112e2b00 	call	8112e2b0 <__adddf3>
81122d2c:	8009883a 	mov	r4,r16
81122d30:	1029883a 	mov	r20,r2
81122d34:	1823883a 	mov	r17,r3
81122d38:	11300300 	call	81130030 <__floatsidf>
81122d3c:	019427f4 	movhi	r6,20639
81122d40:	01cff4f4 	movhi	r7,16339
81122d44:	319e7ec4 	addi	r6,r6,31227
81122d48:	39d104c4 	addi	r7,r7,17427
81122d4c:	1009883a 	mov	r4,r2
81122d50:	180b883a 	mov	r5,r3
81122d54:	1119dc00 	call	81119dc0 <__muldf3>
81122d58:	100d883a 	mov	r6,r2
81122d5c:	180f883a 	mov	r7,r3
81122d60:	a009883a 	mov	r4,r20
81122d64:	880b883a 	mov	r5,r17
81122d68:	112e2b00 	call	8112e2b0 <__adddf3>
81122d6c:	1009883a 	mov	r4,r2
81122d70:	180b883a 	mov	r5,r3
81122d74:	1029883a 	mov	r20,r2
81122d78:	1823883a 	mov	r17,r3
81122d7c:	112ffb00 	call	8112ffb0 <__fixdfsi>
81122d80:	000d883a 	mov	r6,zero
81122d84:	000f883a 	mov	r7,zero
81122d88:	a009883a 	mov	r4,r20
81122d8c:	880b883a 	mov	r5,r17
81122d90:	d8800515 	stw	r2,20(sp)
81122d94:	112f5b80 	call	8112f5b8 <__ledf2>
81122d98:	10028716 	blt	r2,zero,811237b8 <_dtoa_r+0xc90>
81122d9c:	d8c00517 	ldw	r3,20(sp)
81122da0:	00800584 	movi	r2,22
81122da4:	10c27536 	bltu	r2,r3,8112377c <_dtoa_r+0xc54>
81122da8:	180490fa 	slli	r2,r3,3
81122dac:	00e04574 	movhi	r3,33045
81122db0:	18e6f304 	addi	r3,r3,-25652
81122db4:	1885883a 	add	r2,r3,r2
81122db8:	11000017 	ldw	r4,0(r2)
81122dbc:	11400117 	ldw	r5,4(r2)
81122dc0:	900d883a 	mov	r6,r18
81122dc4:	980f883a 	mov	r7,r19
81122dc8:	112f4dc0 	call	8112f4dc <__gedf2>
81122dcc:	00828d0e 	bge	zero,r2,81123804 <_dtoa_r+0xcdc>
81122dd0:	d9000517 	ldw	r4,20(sp)
81122dd4:	d8000e15 	stw	zero,56(sp)
81122dd8:	213fffc4 	addi	r4,r4,-1
81122ddc:	d9000515 	stw	r4,20(sp)
81122de0:	b42dc83a 	sub	r22,r22,r16
81122de4:	b5bfffc4 	addi	r22,r22,-1
81122de8:	b0026f16 	blt	r22,zero,811237a8 <_dtoa_r+0xc80>
81122dec:	d8000815 	stw	zero,32(sp)
81122df0:	d9c00517 	ldw	r7,20(sp)
81122df4:	38026416 	blt	r7,zero,81123788 <_dtoa_r+0xc60>
81122df8:	b1ed883a 	add	r22,r22,r7
81122dfc:	d9c00d15 	stw	r7,52(sp)
81122e00:	d8000a15 	stw	zero,40(sp)
81122e04:	d9800317 	ldw	r6,12(sp)
81122e08:	00800244 	movi	r2,9
81122e0c:	11811436 	bltu	r2,r6,81123260 <_dtoa_r+0x738>
81122e10:	00800144 	movi	r2,5
81122e14:	1184e10e 	bge	r2,r6,8112419c <_dtoa_r+0x1674>
81122e18:	31bfff04 	addi	r6,r6,-4
81122e1c:	d9800315 	stw	r6,12(sp)
81122e20:	0023883a 	mov	r17,zero
81122e24:	d9800317 	ldw	r6,12(sp)
81122e28:	008000c4 	movi	r2,3
81122e2c:	30836726 	beq	r6,r2,81123bcc <_dtoa_r+0x10a4>
81122e30:	1183410e 	bge	r2,r6,81123b38 <_dtoa_r+0x1010>
81122e34:	d9c00317 	ldw	r7,12(sp)
81122e38:	00800104 	movi	r2,4
81122e3c:	38827c26 	beq	r7,r2,81123830 <_dtoa_r+0xd08>
81122e40:	00800144 	movi	r2,5
81122e44:	3884c41e 	bne	r7,r2,81124158 <_dtoa_r+0x1630>
81122e48:	00800044 	movi	r2,1
81122e4c:	d8800b15 	stw	r2,44(sp)
81122e50:	d8c00517 	ldw	r3,20(sp)
81122e54:	d9002217 	ldw	r4,136(sp)
81122e58:	1907883a 	add	r3,r3,r4
81122e5c:	19800044 	addi	r6,r3,1
81122e60:	d8c00c15 	stw	r3,48(sp)
81122e64:	d9800615 	stw	r6,24(sp)
81122e68:	0183a40e 	bge	zero,r6,81123cfc <_dtoa_r+0x11d4>
81122e6c:	d9800617 	ldw	r6,24(sp)
81122e70:	3021883a 	mov	r16,r6
81122e74:	e0001115 	stw	zero,68(fp)
81122e78:	008005c4 	movi	r2,23
81122e7c:	1184c92e 	bgeu	r2,r6,811241a4 <_dtoa_r+0x167c>
81122e80:	00c00044 	movi	r3,1
81122e84:	00800104 	movi	r2,4
81122e88:	1085883a 	add	r2,r2,r2
81122e8c:	11000504 	addi	r4,r2,20
81122e90:	180b883a 	mov	r5,r3
81122e94:	18c00044 	addi	r3,r3,1
81122e98:	313ffb2e 	bgeu	r6,r4,81122e88 <__reset+0xfb102e88>
81122e9c:	e1401115 	stw	r5,68(fp)
81122ea0:	e009883a 	mov	r4,fp
81122ea4:	1125c400 	call	81125c40 <_Balloc>
81122ea8:	d8800715 	stw	r2,28(sp)
81122eac:	e0801015 	stw	r2,64(fp)
81122eb0:	00800384 	movi	r2,14
81122eb4:	1400f736 	bltu	r2,r16,81123294 <_dtoa_r+0x76c>
81122eb8:	8800f626 	beq	r17,zero,81123294 <_dtoa_r+0x76c>
81122ebc:	d9c00517 	ldw	r7,20(sp)
81122ec0:	01c39a0e 	bge	zero,r7,81123d2c <_dtoa_r+0x1204>
81122ec4:	388003cc 	andi	r2,r7,15
81122ec8:	100490fa 	slli	r2,r2,3
81122ecc:	382bd13a 	srai	r21,r7,4
81122ed0:	00e04574 	movhi	r3,33045
81122ed4:	18e6f304 	addi	r3,r3,-25652
81122ed8:	1885883a 	add	r2,r3,r2
81122edc:	a8c0040c 	andi	r3,r21,16
81122ee0:	12400017 	ldw	r9,0(r2)
81122ee4:	12000117 	ldw	r8,4(r2)
81122ee8:	18037926 	beq	r3,zero,81123cd0 <_dtoa_r+0x11a8>
81122eec:	00a04574 	movhi	r2,33045
81122ef0:	10a6e904 	addi	r2,r2,-25692
81122ef4:	11800817 	ldw	r6,32(r2)
81122ef8:	11c00917 	ldw	r7,36(r2)
81122efc:	9009883a 	mov	r4,r18
81122f00:	980b883a 	mov	r5,r19
81122f04:	da001715 	stw	r8,92(sp)
81122f08:	da401615 	stw	r9,88(sp)
81122f0c:	112eb640 	call	8112eb64 <__divdf3>
81122f10:	da001717 	ldw	r8,92(sp)
81122f14:	da401617 	ldw	r9,88(sp)
81122f18:	ad4003cc 	andi	r21,r21,15
81122f1c:	040000c4 	movi	r16,3
81122f20:	1023883a 	mov	r17,r2
81122f24:	1829883a 	mov	r20,r3
81122f28:	a8001126 	beq	r21,zero,81122f70 <_dtoa_r+0x448>
81122f2c:	05e04574 	movhi	r23,33045
81122f30:	bde6e904 	addi	r23,r23,-25692
81122f34:	4805883a 	mov	r2,r9
81122f38:	4007883a 	mov	r3,r8
81122f3c:	a980004c 	andi	r6,r21,1
81122f40:	1009883a 	mov	r4,r2
81122f44:	a82bd07a 	srai	r21,r21,1
81122f48:	180b883a 	mov	r5,r3
81122f4c:	30000426 	beq	r6,zero,81122f60 <_dtoa_r+0x438>
81122f50:	b9800017 	ldw	r6,0(r23)
81122f54:	b9c00117 	ldw	r7,4(r23)
81122f58:	84000044 	addi	r16,r16,1
81122f5c:	1119dc00 	call	81119dc0 <__muldf3>
81122f60:	bdc00204 	addi	r23,r23,8
81122f64:	a83ff51e 	bne	r21,zero,81122f3c <__reset+0xfb102f3c>
81122f68:	1013883a 	mov	r9,r2
81122f6c:	1811883a 	mov	r8,r3
81122f70:	480d883a 	mov	r6,r9
81122f74:	400f883a 	mov	r7,r8
81122f78:	8809883a 	mov	r4,r17
81122f7c:	a00b883a 	mov	r5,r20
81122f80:	112eb640 	call	8112eb64 <__divdf3>
81122f84:	d8800f15 	stw	r2,60(sp)
81122f88:	d8c01015 	stw	r3,64(sp)
81122f8c:	d8c00e17 	ldw	r3,56(sp)
81122f90:	18000626 	beq	r3,zero,81122fac <_dtoa_r+0x484>
81122f94:	d9000f17 	ldw	r4,60(sp)
81122f98:	d9401017 	ldw	r5,64(sp)
81122f9c:	000d883a 	mov	r6,zero
81122fa0:	01cffc34 	movhi	r7,16368
81122fa4:	112f5b80 	call	8112f5b8 <__ledf2>
81122fa8:	10040b16 	blt	r2,zero,81123fd8 <_dtoa_r+0x14b0>
81122fac:	8009883a 	mov	r4,r16
81122fb0:	11300300 	call	81130030 <__floatsidf>
81122fb4:	d9800f17 	ldw	r6,60(sp)
81122fb8:	d9c01017 	ldw	r7,64(sp)
81122fbc:	1009883a 	mov	r4,r2
81122fc0:	180b883a 	mov	r5,r3
81122fc4:	1119dc00 	call	81119dc0 <__muldf3>
81122fc8:	000d883a 	mov	r6,zero
81122fcc:	01d00734 	movhi	r7,16412
81122fd0:	1009883a 	mov	r4,r2
81122fd4:	180b883a 	mov	r5,r3
81122fd8:	112e2b00 	call	8112e2b0 <__adddf3>
81122fdc:	1021883a 	mov	r16,r2
81122fe0:	d8800617 	ldw	r2,24(sp)
81122fe4:	047f3034 	movhi	r17,64704
81122fe8:	1c63883a 	add	r17,r3,r17
81122fec:	10031826 	beq	r2,zero,81123c50 <_dtoa_r+0x1128>
81122ff0:	d8c00517 	ldw	r3,20(sp)
81122ff4:	db000617 	ldw	r12,24(sp)
81122ff8:	d8c01315 	stw	r3,76(sp)
81122ffc:	d9000b17 	ldw	r4,44(sp)
81123000:	20038f26 	beq	r4,zero,81123e40 <_dtoa_r+0x1318>
81123004:	60bfffc4 	addi	r2,r12,-1
81123008:	100490fa 	slli	r2,r2,3
8112300c:	00e04574 	movhi	r3,33045
81123010:	18e6f304 	addi	r3,r3,-25652
81123014:	1885883a 	add	r2,r3,r2
81123018:	11800017 	ldw	r6,0(r2)
8112301c:	11c00117 	ldw	r7,4(r2)
81123020:	d8800717 	ldw	r2,28(sp)
81123024:	0009883a 	mov	r4,zero
81123028:	014ff834 	movhi	r5,16352
8112302c:	db001615 	stw	r12,88(sp)
81123030:	15c00044 	addi	r23,r2,1
81123034:	112eb640 	call	8112eb64 <__divdf3>
81123038:	800d883a 	mov	r6,r16
8112303c:	880f883a 	mov	r7,r17
81123040:	1009883a 	mov	r4,r2
81123044:	180b883a 	mov	r5,r3
81123048:	112f6ac0 	call	8112f6ac <__subdf3>
8112304c:	d9401017 	ldw	r5,64(sp)
81123050:	d9000f17 	ldw	r4,60(sp)
81123054:	102b883a 	mov	r21,r2
81123058:	d8c01215 	stw	r3,72(sp)
8112305c:	112ffb00 	call	8112ffb0 <__fixdfsi>
81123060:	1009883a 	mov	r4,r2
81123064:	1029883a 	mov	r20,r2
81123068:	11300300 	call	81130030 <__floatsidf>
8112306c:	d9000f17 	ldw	r4,60(sp)
81123070:	d9401017 	ldw	r5,64(sp)
81123074:	100d883a 	mov	r6,r2
81123078:	180f883a 	mov	r7,r3
8112307c:	112f6ac0 	call	8112f6ac <__subdf3>
81123080:	1823883a 	mov	r17,r3
81123084:	d8c00717 	ldw	r3,28(sp)
81123088:	d9401217 	ldw	r5,72(sp)
8112308c:	a2000c04 	addi	r8,r20,48
81123090:	1021883a 	mov	r16,r2
81123094:	1a000005 	stb	r8,0(r3)
81123098:	800d883a 	mov	r6,r16
8112309c:	880f883a 	mov	r7,r17
811230a0:	a809883a 	mov	r4,r21
811230a4:	4029883a 	mov	r20,r8
811230a8:	112f4dc0 	call	8112f4dc <__gedf2>
811230ac:	00841d16 	blt	zero,r2,81124124 <_dtoa_r+0x15fc>
811230b0:	800d883a 	mov	r6,r16
811230b4:	880f883a 	mov	r7,r17
811230b8:	0009883a 	mov	r4,zero
811230bc:	014ffc34 	movhi	r5,16368
811230c0:	112f6ac0 	call	8112f6ac <__subdf3>
811230c4:	d9401217 	ldw	r5,72(sp)
811230c8:	100d883a 	mov	r6,r2
811230cc:	180f883a 	mov	r7,r3
811230d0:	a809883a 	mov	r4,r21
811230d4:	112f4dc0 	call	8112f4dc <__gedf2>
811230d8:	db001617 	ldw	r12,88(sp)
811230dc:	00840e16 	blt	zero,r2,81124118 <_dtoa_r+0x15f0>
811230e0:	00800044 	movi	r2,1
811230e4:	13006b0e 	bge	r2,r12,81123294 <_dtoa_r+0x76c>
811230e8:	d9000717 	ldw	r4,28(sp)
811230ec:	dd800f15 	stw	r22,60(sp)
811230f0:	dcc01015 	stw	r19,64(sp)
811230f4:	2319883a 	add	r12,r4,r12
811230f8:	dcc01217 	ldw	r19,72(sp)
811230fc:	602d883a 	mov	r22,r12
81123100:	dc801215 	stw	r18,72(sp)
81123104:	b825883a 	mov	r18,r23
81123108:	00000906 	br	81123130 <_dtoa_r+0x608>
8112310c:	112f6ac0 	call	8112f6ac <__subdf3>
81123110:	a80d883a 	mov	r6,r21
81123114:	980f883a 	mov	r7,r19
81123118:	1009883a 	mov	r4,r2
8112311c:	180b883a 	mov	r5,r3
81123120:	112f5b80 	call	8112f5b8 <__ledf2>
81123124:	1003e816 	blt	r2,zero,811240c8 <_dtoa_r+0x15a0>
81123128:	b825883a 	mov	r18,r23
8112312c:	bd83e926 	beq	r23,r22,811240d4 <_dtoa_r+0x15ac>
81123130:	a809883a 	mov	r4,r21
81123134:	980b883a 	mov	r5,r19
81123138:	000d883a 	mov	r6,zero
8112313c:	01d00934 	movhi	r7,16420
81123140:	1119dc00 	call	81119dc0 <__muldf3>
81123144:	000d883a 	mov	r6,zero
81123148:	01d00934 	movhi	r7,16420
8112314c:	8009883a 	mov	r4,r16
81123150:	880b883a 	mov	r5,r17
81123154:	102b883a 	mov	r21,r2
81123158:	1827883a 	mov	r19,r3
8112315c:	1119dc00 	call	81119dc0 <__muldf3>
81123160:	180b883a 	mov	r5,r3
81123164:	1009883a 	mov	r4,r2
81123168:	1821883a 	mov	r16,r3
8112316c:	1023883a 	mov	r17,r2
81123170:	112ffb00 	call	8112ffb0 <__fixdfsi>
81123174:	1009883a 	mov	r4,r2
81123178:	1029883a 	mov	r20,r2
8112317c:	11300300 	call	81130030 <__floatsidf>
81123180:	8809883a 	mov	r4,r17
81123184:	800b883a 	mov	r5,r16
81123188:	100d883a 	mov	r6,r2
8112318c:	180f883a 	mov	r7,r3
81123190:	112f6ac0 	call	8112f6ac <__subdf3>
81123194:	a5000c04 	addi	r20,r20,48
81123198:	a80d883a 	mov	r6,r21
8112319c:	980f883a 	mov	r7,r19
811231a0:	1009883a 	mov	r4,r2
811231a4:	180b883a 	mov	r5,r3
811231a8:	95000005 	stb	r20,0(r18)
811231ac:	1021883a 	mov	r16,r2
811231b0:	1823883a 	mov	r17,r3
811231b4:	112f5b80 	call	8112f5b8 <__ledf2>
811231b8:	bdc00044 	addi	r23,r23,1
811231bc:	800d883a 	mov	r6,r16
811231c0:	880f883a 	mov	r7,r17
811231c4:	0009883a 	mov	r4,zero
811231c8:	014ffc34 	movhi	r5,16368
811231cc:	103fcf0e 	bge	r2,zero,8112310c <__reset+0xfb10310c>
811231d0:	d8c01317 	ldw	r3,76(sp)
811231d4:	d8c00515 	stw	r3,20(sp)
811231d8:	d9400917 	ldw	r5,36(sp)
811231dc:	e009883a 	mov	r4,fp
811231e0:	1125cf00 	call	81125cf0 <_Bfree>
811231e4:	d9000517 	ldw	r4,20(sp)
811231e8:	d9802317 	ldw	r6,140(sp)
811231ec:	d9c02517 	ldw	r7,148(sp)
811231f0:	b8000005 	stb	zero,0(r23)
811231f4:	20800044 	addi	r2,r4,1
811231f8:	30800015 	stw	r2,0(r6)
811231fc:	3802aa26 	beq	r7,zero,81123ca8 <_dtoa_r+0x1180>
81123200:	3dc00015 	stw	r23,0(r7)
81123204:	d8800717 	ldw	r2,28(sp)
81123208:	003e7906 	br	81122bf0 <__reset+0xfb102bf0>
8112320c:	00800434 	movhi	r2,16
81123210:	10bfffc4 	addi	r2,r2,-1
81123214:	88a2703a 	and	r17,r17,r2
81123218:	883e851e 	bne	r17,zero,81122c30 <__reset+0xfb102c30>
8112321c:	00a04574 	movhi	r2,33045
81123220:	10a6d504 	addi	r2,r2,-25772
81123224:	003e8406 	br	81122c38 <__reset+0xfb102c38>
81123228:	10c00204 	addi	r3,r2,8
8112322c:	003e8706 	br	81122c4c <__reset+0xfb102c4c>
81123230:	01400434 	movhi	r5,16
81123234:	297fffc4 	addi	r5,r5,-1
81123238:	994a703a 	and	r5,r19,r5
8112323c:	9009883a 	mov	r4,r18
81123240:	843f0044 	addi	r16,r16,-1023
81123244:	294ffc34 	orhi	r5,r5,16368
81123248:	dd800217 	ldw	r22,8(sp)
8112324c:	d8001115 	stw	zero,68(sp)
81123250:	003ea506 	br	81122ce8 <__reset+0xfb102ce8>
81123254:	00a04574 	movhi	r2,33045
81123258:	10a6ba04 	addi	r2,r2,-25880
8112325c:	003e6406 	br	81122bf0 <__reset+0xfb102bf0>
81123260:	e0001115 	stw	zero,68(fp)
81123264:	000b883a 	mov	r5,zero
81123268:	e009883a 	mov	r4,fp
8112326c:	1125c400 	call	81125c40 <_Balloc>
81123270:	01bfffc4 	movi	r6,-1
81123274:	01c00044 	movi	r7,1
81123278:	d8800715 	stw	r2,28(sp)
8112327c:	d9800c15 	stw	r6,48(sp)
81123280:	e0801015 	stw	r2,64(fp)
81123284:	d8000315 	stw	zero,12(sp)
81123288:	d9c00b15 	stw	r7,44(sp)
8112328c:	d9800615 	stw	r6,24(sp)
81123290:	d8002215 	stw	zero,136(sp)
81123294:	d8800117 	ldw	r2,4(sp)
81123298:	10008916 	blt	r2,zero,811234c0 <_dtoa_r+0x998>
8112329c:	d9000517 	ldw	r4,20(sp)
811232a0:	00c00384 	movi	r3,14
811232a4:	19008616 	blt	r3,r4,811234c0 <_dtoa_r+0x998>
811232a8:	200490fa 	slli	r2,r4,3
811232ac:	00e04574 	movhi	r3,33045
811232b0:	d9802217 	ldw	r6,136(sp)
811232b4:	18e6f304 	addi	r3,r3,-25652
811232b8:	1885883a 	add	r2,r3,r2
811232bc:	14000017 	ldw	r16,0(r2)
811232c0:	14400117 	ldw	r17,4(r2)
811232c4:	30016316 	blt	r6,zero,81123854 <_dtoa_r+0xd2c>
811232c8:	800d883a 	mov	r6,r16
811232cc:	880f883a 	mov	r7,r17
811232d0:	9009883a 	mov	r4,r18
811232d4:	980b883a 	mov	r5,r19
811232d8:	112eb640 	call	8112eb64 <__divdf3>
811232dc:	180b883a 	mov	r5,r3
811232e0:	1009883a 	mov	r4,r2
811232e4:	112ffb00 	call	8112ffb0 <__fixdfsi>
811232e8:	1009883a 	mov	r4,r2
811232ec:	102b883a 	mov	r21,r2
811232f0:	11300300 	call	81130030 <__floatsidf>
811232f4:	800d883a 	mov	r6,r16
811232f8:	880f883a 	mov	r7,r17
811232fc:	1009883a 	mov	r4,r2
81123300:	180b883a 	mov	r5,r3
81123304:	1119dc00 	call	81119dc0 <__muldf3>
81123308:	100d883a 	mov	r6,r2
8112330c:	180f883a 	mov	r7,r3
81123310:	9009883a 	mov	r4,r18
81123314:	980b883a 	mov	r5,r19
81123318:	112f6ac0 	call	8112f6ac <__subdf3>
8112331c:	d9c00717 	ldw	r7,28(sp)
81123320:	1009883a 	mov	r4,r2
81123324:	a8800c04 	addi	r2,r21,48
81123328:	38800005 	stb	r2,0(r7)
8112332c:	3dc00044 	addi	r23,r7,1
81123330:	d9c00617 	ldw	r7,24(sp)
81123334:	01800044 	movi	r6,1
81123338:	180b883a 	mov	r5,r3
8112333c:	2005883a 	mov	r2,r4
81123340:	39803826 	beq	r7,r6,81123424 <_dtoa_r+0x8fc>
81123344:	000d883a 	mov	r6,zero
81123348:	01d00934 	movhi	r7,16420
8112334c:	1119dc00 	call	81119dc0 <__muldf3>
81123350:	000d883a 	mov	r6,zero
81123354:	000f883a 	mov	r7,zero
81123358:	1009883a 	mov	r4,r2
8112335c:	180b883a 	mov	r5,r3
81123360:	1025883a 	mov	r18,r2
81123364:	1827883a 	mov	r19,r3
81123368:	112f4540 	call	8112f454 <__eqdf2>
8112336c:	103f9a26 	beq	r2,zero,811231d8 <__reset+0xfb1031d8>
81123370:	d9c00617 	ldw	r7,24(sp)
81123374:	d8c00717 	ldw	r3,28(sp)
81123378:	b829883a 	mov	r20,r23
8112337c:	38bfffc4 	addi	r2,r7,-1
81123380:	18ad883a 	add	r22,r3,r2
81123384:	00000a06 	br	811233b0 <_dtoa_r+0x888>
81123388:	1119dc00 	call	81119dc0 <__muldf3>
8112338c:	000d883a 	mov	r6,zero
81123390:	000f883a 	mov	r7,zero
81123394:	1009883a 	mov	r4,r2
81123398:	180b883a 	mov	r5,r3
8112339c:	1025883a 	mov	r18,r2
811233a0:	1827883a 	mov	r19,r3
811233a4:	b829883a 	mov	r20,r23
811233a8:	112f4540 	call	8112f454 <__eqdf2>
811233ac:	103f8a26 	beq	r2,zero,811231d8 <__reset+0xfb1031d8>
811233b0:	800d883a 	mov	r6,r16
811233b4:	880f883a 	mov	r7,r17
811233b8:	9009883a 	mov	r4,r18
811233bc:	980b883a 	mov	r5,r19
811233c0:	112eb640 	call	8112eb64 <__divdf3>
811233c4:	180b883a 	mov	r5,r3
811233c8:	1009883a 	mov	r4,r2
811233cc:	112ffb00 	call	8112ffb0 <__fixdfsi>
811233d0:	1009883a 	mov	r4,r2
811233d4:	102b883a 	mov	r21,r2
811233d8:	11300300 	call	81130030 <__floatsidf>
811233dc:	800d883a 	mov	r6,r16
811233e0:	880f883a 	mov	r7,r17
811233e4:	1009883a 	mov	r4,r2
811233e8:	180b883a 	mov	r5,r3
811233ec:	1119dc00 	call	81119dc0 <__muldf3>
811233f0:	100d883a 	mov	r6,r2
811233f4:	180f883a 	mov	r7,r3
811233f8:	9009883a 	mov	r4,r18
811233fc:	980b883a 	mov	r5,r19
81123400:	112f6ac0 	call	8112f6ac <__subdf3>
81123404:	aa000c04 	addi	r8,r21,48
81123408:	a2000005 	stb	r8,0(r20)
8112340c:	000d883a 	mov	r6,zero
81123410:	01d00934 	movhi	r7,16420
81123414:	1009883a 	mov	r4,r2
81123418:	180b883a 	mov	r5,r3
8112341c:	a5c00044 	addi	r23,r20,1
81123420:	b53fd91e 	bne	r22,r20,81123388 <__reset+0xfb103388>
81123424:	100d883a 	mov	r6,r2
81123428:	180f883a 	mov	r7,r3
8112342c:	1009883a 	mov	r4,r2
81123430:	180b883a 	mov	r5,r3
81123434:	112e2b00 	call	8112e2b0 <__adddf3>
81123438:	100d883a 	mov	r6,r2
8112343c:	180f883a 	mov	r7,r3
81123440:	8009883a 	mov	r4,r16
81123444:	880b883a 	mov	r5,r17
81123448:	1027883a 	mov	r19,r2
8112344c:	1825883a 	mov	r18,r3
81123450:	112f5b80 	call	8112f5b8 <__ledf2>
81123454:	10000816 	blt	r2,zero,81123478 <_dtoa_r+0x950>
81123458:	980d883a 	mov	r6,r19
8112345c:	900f883a 	mov	r7,r18
81123460:	8009883a 	mov	r4,r16
81123464:	880b883a 	mov	r5,r17
81123468:	112f4540 	call	8112f454 <__eqdf2>
8112346c:	103f5a1e 	bne	r2,zero,811231d8 <__reset+0xfb1031d8>
81123470:	ad40004c 	andi	r21,r21,1
81123474:	a83f5826 	beq	r21,zero,811231d8 <__reset+0xfb1031d8>
81123478:	bd3fffc3 	ldbu	r20,-1(r23)
8112347c:	b8bfffc4 	addi	r2,r23,-1
81123480:	1007883a 	mov	r3,r2
81123484:	01400e44 	movi	r5,57
81123488:	d9800717 	ldw	r6,28(sp)
8112348c:	00000506 	br	811234a4 <_dtoa_r+0x97c>
81123490:	18ffffc4 	addi	r3,r3,-1
81123494:	11824726 	beq	r2,r6,81123db4 <_dtoa_r+0x128c>
81123498:	1d000003 	ldbu	r20,0(r3)
8112349c:	102f883a 	mov	r23,r2
811234a0:	10bfffc4 	addi	r2,r2,-1
811234a4:	a1003fcc 	andi	r4,r20,255
811234a8:	2100201c 	xori	r4,r4,128
811234ac:	213fe004 	addi	r4,r4,-128
811234b0:	217ff726 	beq	r4,r5,81123490 <__reset+0xfb103490>
811234b4:	a2000044 	addi	r8,r20,1
811234b8:	12000005 	stb	r8,0(r2)
811234bc:	003f4606 	br	811231d8 <__reset+0xfb1031d8>
811234c0:	d9000b17 	ldw	r4,44(sp)
811234c4:	2000c826 	beq	r4,zero,811237e8 <_dtoa_r+0xcc0>
811234c8:	d9800317 	ldw	r6,12(sp)
811234cc:	00c00044 	movi	r3,1
811234d0:	1980f90e 	bge	r3,r6,811238b8 <_dtoa_r+0xd90>
811234d4:	d8800617 	ldw	r2,24(sp)
811234d8:	d8c00a17 	ldw	r3,40(sp)
811234dc:	157fffc4 	addi	r21,r2,-1
811234e0:	1d41f316 	blt	r3,r21,81123cb0 <_dtoa_r+0x1188>
811234e4:	1d6bc83a 	sub	r21,r3,r21
811234e8:	d9c00617 	ldw	r7,24(sp)
811234ec:	3802aa16 	blt	r7,zero,81123f98 <_dtoa_r+0x1470>
811234f0:	dd000817 	ldw	r20,32(sp)
811234f4:	d8800617 	ldw	r2,24(sp)
811234f8:	d8c00817 	ldw	r3,32(sp)
811234fc:	01400044 	movi	r5,1
81123500:	e009883a 	mov	r4,fp
81123504:	1887883a 	add	r3,r3,r2
81123508:	d8c00815 	stw	r3,32(sp)
8112350c:	b0ad883a 	add	r22,r22,r2
81123510:	11260640 	call	81126064 <__i2b>
81123514:	1023883a 	mov	r17,r2
81123518:	a0000826 	beq	r20,zero,8112353c <_dtoa_r+0xa14>
8112351c:	0580070e 	bge	zero,r22,8112353c <_dtoa_r+0xa14>
81123520:	a005883a 	mov	r2,r20
81123524:	b500b916 	blt	r22,r20,8112380c <_dtoa_r+0xce4>
81123528:	d9000817 	ldw	r4,32(sp)
8112352c:	a0a9c83a 	sub	r20,r20,r2
81123530:	b0adc83a 	sub	r22,r22,r2
81123534:	2089c83a 	sub	r4,r4,r2
81123538:	d9000815 	stw	r4,32(sp)
8112353c:	d9800a17 	ldw	r6,40(sp)
81123540:	0181810e 	bge	zero,r6,81123b48 <_dtoa_r+0x1020>
81123544:	d9c00b17 	ldw	r7,44(sp)
81123548:	3800b326 	beq	r7,zero,81123818 <_dtoa_r+0xcf0>
8112354c:	a800b226 	beq	r21,zero,81123818 <_dtoa_r+0xcf0>
81123550:	880b883a 	mov	r5,r17
81123554:	a80d883a 	mov	r6,r21
81123558:	e009883a 	mov	r4,fp
8112355c:	11262a80 	call	811262a8 <__pow5mult>
81123560:	d9800917 	ldw	r6,36(sp)
81123564:	100b883a 	mov	r5,r2
81123568:	e009883a 	mov	r4,fp
8112356c:	1023883a 	mov	r17,r2
81123570:	11260a80 	call	811260a8 <__multiply>
81123574:	1021883a 	mov	r16,r2
81123578:	d8800a17 	ldw	r2,40(sp)
8112357c:	d9400917 	ldw	r5,36(sp)
81123580:	e009883a 	mov	r4,fp
81123584:	1545c83a 	sub	r2,r2,r21
81123588:	d8800a15 	stw	r2,40(sp)
8112358c:	1125cf00 	call	81125cf0 <_Bfree>
81123590:	d8c00a17 	ldw	r3,40(sp)
81123594:	18009f1e 	bne	r3,zero,81123814 <_dtoa_r+0xcec>
81123598:	05c00044 	movi	r23,1
8112359c:	e009883a 	mov	r4,fp
811235a0:	b80b883a 	mov	r5,r23
811235a4:	11260640 	call	81126064 <__i2b>
811235a8:	d9000d17 	ldw	r4,52(sp)
811235ac:	102b883a 	mov	r21,r2
811235b0:	2000ce26 	beq	r4,zero,811238ec <_dtoa_r+0xdc4>
811235b4:	200d883a 	mov	r6,r4
811235b8:	100b883a 	mov	r5,r2
811235bc:	e009883a 	mov	r4,fp
811235c0:	11262a80 	call	811262a8 <__pow5mult>
811235c4:	d9800317 	ldw	r6,12(sp)
811235c8:	102b883a 	mov	r21,r2
811235cc:	b981810e 	bge	r23,r6,81123bd4 <_dtoa_r+0x10ac>
811235d0:	0027883a 	mov	r19,zero
811235d4:	a8800417 	ldw	r2,16(r21)
811235d8:	05c00804 	movi	r23,32
811235dc:	10800104 	addi	r2,r2,4
811235e0:	1085883a 	add	r2,r2,r2
811235e4:	1085883a 	add	r2,r2,r2
811235e8:	a885883a 	add	r2,r21,r2
811235ec:	11000017 	ldw	r4,0(r2)
811235f0:	1125f4c0 	call	81125f4c <__hi0bits>
811235f4:	b885c83a 	sub	r2,r23,r2
811235f8:	1585883a 	add	r2,r2,r22
811235fc:	108007cc 	andi	r2,r2,31
81123600:	1000b326 	beq	r2,zero,811238d0 <_dtoa_r+0xda8>
81123604:	00c00804 	movi	r3,32
81123608:	1887c83a 	sub	r3,r3,r2
8112360c:	01000104 	movi	r4,4
81123610:	20c2cd0e 	bge	r4,r3,81124148 <_dtoa_r+0x1620>
81123614:	00c00704 	movi	r3,28
81123618:	1885c83a 	sub	r2,r3,r2
8112361c:	d8c00817 	ldw	r3,32(sp)
81123620:	a0a9883a 	add	r20,r20,r2
81123624:	b0ad883a 	add	r22,r22,r2
81123628:	1887883a 	add	r3,r3,r2
8112362c:	d8c00815 	stw	r3,32(sp)
81123630:	d9800817 	ldw	r6,32(sp)
81123634:	0180040e 	bge	zero,r6,81123648 <_dtoa_r+0xb20>
81123638:	800b883a 	mov	r5,r16
8112363c:	e009883a 	mov	r4,fp
81123640:	11263f00 	call	811263f0 <__lshift>
81123644:	1021883a 	mov	r16,r2
81123648:	0580050e 	bge	zero,r22,81123660 <_dtoa_r+0xb38>
8112364c:	a80b883a 	mov	r5,r21
81123650:	b00d883a 	mov	r6,r22
81123654:	e009883a 	mov	r4,fp
81123658:	11263f00 	call	811263f0 <__lshift>
8112365c:	102b883a 	mov	r21,r2
81123660:	d9c00e17 	ldw	r7,56(sp)
81123664:	3801211e 	bne	r7,zero,81123aec <_dtoa_r+0xfc4>
81123668:	d9800617 	ldw	r6,24(sp)
8112366c:	0181380e 	bge	zero,r6,81123b50 <_dtoa_r+0x1028>
81123670:	d8c00b17 	ldw	r3,44(sp)
81123674:	1800ab1e 	bne	r3,zero,81123924 <_dtoa_r+0xdfc>
81123678:	dc800717 	ldw	r18,28(sp)
8112367c:	dcc00617 	ldw	r19,24(sp)
81123680:	9029883a 	mov	r20,r18
81123684:	00000206 	br	81123690 <_dtoa_r+0xb68>
81123688:	1125d180 	call	81125d18 <__multadd>
8112368c:	1021883a 	mov	r16,r2
81123690:	a80b883a 	mov	r5,r21
81123694:	8009883a 	mov	r4,r16
81123698:	11229200 	call	81122920 <quorem>
8112369c:	10800c04 	addi	r2,r2,48
811236a0:	90800005 	stb	r2,0(r18)
811236a4:	94800044 	addi	r18,r18,1
811236a8:	9507c83a 	sub	r3,r18,r20
811236ac:	000f883a 	mov	r7,zero
811236b0:	01800284 	movi	r6,10
811236b4:	800b883a 	mov	r5,r16
811236b8:	e009883a 	mov	r4,fp
811236bc:	1cfff216 	blt	r3,r19,81123688 <__reset+0xfb103688>
811236c0:	1011883a 	mov	r8,r2
811236c4:	d8800617 	ldw	r2,24(sp)
811236c8:	0082370e 	bge	zero,r2,81123fa8 <_dtoa_r+0x1480>
811236cc:	d9000717 	ldw	r4,28(sp)
811236d0:	0025883a 	mov	r18,zero
811236d4:	20af883a 	add	r23,r4,r2
811236d8:	01800044 	movi	r6,1
811236dc:	800b883a 	mov	r5,r16
811236e0:	e009883a 	mov	r4,fp
811236e4:	da001715 	stw	r8,92(sp)
811236e8:	11263f00 	call	811263f0 <__lshift>
811236ec:	a80b883a 	mov	r5,r21
811236f0:	1009883a 	mov	r4,r2
811236f4:	d8800915 	stw	r2,36(sp)
811236f8:	11265400 	call	81126540 <__mcmp>
811236fc:	da001717 	ldw	r8,92(sp)
81123700:	0081800e 	bge	zero,r2,81123d04 <_dtoa_r+0x11dc>
81123704:	b93fffc3 	ldbu	r4,-1(r23)
81123708:	b8bfffc4 	addi	r2,r23,-1
8112370c:	1007883a 	mov	r3,r2
81123710:	01800e44 	movi	r6,57
81123714:	d9c00717 	ldw	r7,28(sp)
81123718:	00000506 	br	81123730 <_dtoa_r+0xc08>
8112371c:	18ffffc4 	addi	r3,r3,-1
81123720:	11c12326 	beq	r2,r7,81123bb0 <_dtoa_r+0x1088>
81123724:	19000003 	ldbu	r4,0(r3)
81123728:	102f883a 	mov	r23,r2
8112372c:	10bfffc4 	addi	r2,r2,-1
81123730:	21403fcc 	andi	r5,r4,255
81123734:	2940201c 	xori	r5,r5,128
81123738:	297fe004 	addi	r5,r5,-128
8112373c:	29bff726 	beq	r5,r6,8112371c <__reset+0xfb10371c>
81123740:	21000044 	addi	r4,r4,1
81123744:	11000005 	stb	r4,0(r2)
81123748:	a80b883a 	mov	r5,r21
8112374c:	e009883a 	mov	r4,fp
81123750:	1125cf00 	call	81125cf0 <_Bfree>
81123754:	883ea026 	beq	r17,zero,811231d8 <__reset+0xfb1031d8>
81123758:	90000426 	beq	r18,zero,8112376c <_dtoa_r+0xc44>
8112375c:	94400326 	beq	r18,r17,8112376c <_dtoa_r+0xc44>
81123760:	900b883a 	mov	r5,r18
81123764:	e009883a 	mov	r4,fp
81123768:	1125cf00 	call	81125cf0 <_Bfree>
8112376c:	880b883a 	mov	r5,r17
81123770:	e009883a 	mov	r4,fp
81123774:	1125cf00 	call	81125cf0 <_Bfree>
81123778:	003e9706 	br	811231d8 <__reset+0xfb1031d8>
8112377c:	01800044 	movi	r6,1
81123780:	d9800e15 	stw	r6,56(sp)
81123784:	003d9606 	br	81122de0 <__reset+0xfb102de0>
81123788:	d8800817 	ldw	r2,32(sp)
8112378c:	d8c00517 	ldw	r3,20(sp)
81123790:	d8000d15 	stw	zero,52(sp)
81123794:	10c5c83a 	sub	r2,r2,r3
81123798:	00c9c83a 	sub	r4,zero,r3
8112379c:	d8800815 	stw	r2,32(sp)
811237a0:	d9000a15 	stw	r4,40(sp)
811237a4:	003d9706 	br	81122e04 <__reset+0xfb102e04>
811237a8:	05adc83a 	sub	r22,zero,r22
811237ac:	dd800815 	stw	r22,32(sp)
811237b0:	002d883a 	mov	r22,zero
811237b4:	003d8e06 	br	81122df0 <__reset+0xfb102df0>
811237b8:	d9000517 	ldw	r4,20(sp)
811237bc:	11300300 	call	81130030 <__floatsidf>
811237c0:	100d883a 	mov	r6,r2
811237c4:	180f883a 	mov	r7,r3
811237c8:	a009883a 	mov	r4,r20
811237cc:	880b883a 	mov	r5,r17
811237d0:	112f4540 	call	8112f454 <__eqdf2>
811237d4:	103d7126 	beq	r2,zero,81122d9c <__reset+0xfb102d9c>
811237d8:	d9c00517 	ldw	r7,20(sp)
811237dc:	39ffffc4 	addi	r7,r7,-1
811237e0:	d9c00515 	stw	r7,20(sp)
811237e4:	003d6d06 	br	81122d9c <__reset+0xfb102d9c>
811237e8:	dd400a17 	ldw	r21,40(sp)
811237ec:	dd000817 	ldw	r20,32(sp)
811237f0:	0023883a 	mov	r17,zero
811237f4:	003f4806 	br	81123518 <__reset+0xfb103518>
811237f8:	10e3c83a 	sub	r17,r2,r3
811237fc:	9448983a 	sll	r4,r18,r17
81123800:	003d3206 	br	81122ccc <__reset+0xfb102ccc>
81123804:	d8000e15 	stw	zero,56(sp)
81123808:	003d7506 	br	81122de0 <__reset+0xfb102de0>
8112380c:	b005883a 	mov	r2,r22
81123810:	003f4506 	br	81123528 <__reset+0xfb103528>
81123814:	dc000915 	stw	r16,36(sp)
81123818:	d9800a17 	ldw	r6,40(sp)
8112381c:	d9400917 	ldw	r5,36(sp)
81123820:	e009883a 	mov	r4,fp
81123824:	11262a80 	call	811262a8 <__pow5mult>
81123828:	1021883a 	mov	r16,r2
8112382c:	003f5a06 	br	81123598 <__reset+0xfb103598>
81123830:	01c00044 	movi	r7,1
81123834:	d9c00b15 	stw	r7,44(sp)
81123838:	d8802217 	ldw	r2,136(sp)
8112383c:	0081280e 	bge	zero,r2,81123ce0 <_dtoa_r+0x11b8>
81123840:	100d883a 	mov	r6,r2
81123844:	1021883a 	mov	r16,r2
81123848:	d8800c15 	stw	r2,48(sp)
8112384c:	d8800615 	stw	r2,24(sp)
81123850:	003d8806 	br	81122e74 <__reset+0xfb102e74>
81123854:	d8800617 	ldw	r2,24(sp)
81123858:	00be9b16 	blt	zero,r2,811232c8 <__reset+0xfb1032c8>
8112385c:	10010f1e 	bne	r2,zero,81123c9c <_dtoa_r+0x1174>
81123860:	880b883a 	mov	r5,r17
81123864:	000d883a 	mov	r6,zero
81123868:	01d00534 	movhi	r7,16404
8112386c:	8009883a 	mov	r4,r16
81123870:	1119dc00 	call	81119dc0 <__muldf3>
81123874:	900d883a 	mov	r6,r18
81123878:	980f883a 	mov	r7,r19
8112387c:	1009883a 	mov	r4,r2
81123880:	180b883a 	mov	r5,r3
81123884:	112f4dc0 	call	8112f4dc <__gedf2>
81123888:	002b883a 	mov	r21,zero
8112388c:	0023883a 	mov	r17,zero
81123890:	1000bf16 	blt	r2,zero,81123b90 <_dtoa_r+0x1068>
81123894:	d9802217 	ldw	r6,136(sp)
81123898:	ddc00717 	ldw	r23,28(sp)
8112389c:	018c303a 	nor	r6,zero,r6
811238a0:	d9800515 	stw	r6,20(sp)
811238a4:	a80b883a 	mov	r5,r21
811238a8:	e009883a 	mov	r4,fp
811238ac:	1125cf00 	call	81125cf0 <_Bfree>
811238b0:	883e4926 	beq	r17,zero,811231d8 <__reset+0xfb1031d8>
811238b4:	003fad06 	br	8112376c <__reset+0xfb10376c>
811238b8:	d9c01117 	ldw	r7,68(sp)
811238bc:	3801bc26 	beq	r7,zero,81123fb0 <_dtoa_r+0x1488>
811238c0:	10810cc4 	addi	r2,r2,1075
811238c4:	dd400a17 	ldw	r21,40(sp)
811238c8:	dd000817 	ldw	r20,32(sp)
811238cc:	003f0a06 	br	811234f8 <__reset+0xfb1034f8>
811238d0:	00800704 	movi	r2,28
811238d4:	d9000817 	ldw	r4,32(sp)
811238d8:	a0a9883a 	add	r20,r20,r2
811238dc:	b0ad883a 	add	r22,r22,r2
811238e0:	2089883a 	add	r4,r4,r2
811238e4:	d9000815 	stw	r4,32(sp)
811238e8:	003f5106 	br	81123630 <__reset+0xfb103630>
811238ec:	d8c00317 	ldw	r3,12(sp)
811238f0:	b8c1fc0e 	bge	r23,r3,811240e4 <_dtoa_r+0x15bc>
811238f4:	0027883a 	mov	r19,zero
811238f8:	b805883a 	mov	r2,r23
811238fc:	003f3e06 	br	811235f8 <__reset+0xfb1035f8>
81123900:	880b883a 	mov	r5,r17
81123904:	e009883a 	mov	r4,fp
81123908:	000f883a 	mov	r7,zero
8112390c:	01800284 	movi	r6,10
81123910:	1125d180 	call	81125d18 <__multadd>
81123914:	d9000c17 	ldw	r4,48(sp)
81123918:	1023883a 	mov	r17,r2
8112391c:	0102040e 	bge	zero,r4,81124130 <_dtoa_r+0x1608>
81123920:	d9000615 	stw	r4,24(sp)
81123924:	0500050e 	bge	zero,r20,8112393c <_dtoa_r+0xe14>
81123928:	880b883a 	mov	r5,r17
8112392c:	a00d883a 	mov	r6,r20
81123930:	e009883a 	mov	r4,fp
81123934:	11263f00 	call	811263f0 <__lshift>
81123938:	1023883a 	mov	r17,r2
8112393c:	9801241e 	bne	r19,zero,81123dd0 <_dtoa_r+0x12a8>
81123940:	8829883a 	mov	r20,r17
81123944:	d9000617 	ldw	r4,24(sp)
81123948:	dcc00717 	ldw	r19,28(sp)
8112394c:	9480004c 	andi	r18,r18,1
81123950:	20bfffc4 	addi	r2,r4,-1
81123954:	9885883a 	add	r2,r19,r2
81123958:	d8800415 	stw	r2,16(sp)
8112395c:	dc800615 	stw	r18,24(sp)
81123960:	a80b883a 	mov	r5,r21
81123964:	8009883a 	mov	r4,r16
81123968:	11229200 	call	81122920 <quorem>
8112396c:	880b883a 	mov	r5,r17
81123970:	8009883a 	mov	r4,r16
81123974:	102f883a 	mov	r23,r2
81123978:	11265400 	call	81126540 <__mcmp>
8112397c:	a80b883a 	mov	r5,r21
81123980:	a00d883a 	mov	r6,r20
81123984:	e009883a 	mov	r4,fp
81123988:	102d883a 	mov	r22,r2
8112398c:	11265a00 	call	811265a0 <__mdiff>
81123990:	1007883a 	mov	r3,r2
81123994:	10800317 	ldw	r2,12(r2)
81123998:	bc800c04 	addi	r18,r23,48
8112399c:	180b883a 	mov	r5,r3
811239a0:	10004e1e 	bne	r2,zero,81123adc <_dtoa_r+0xfb4>
811239a4:	8009883a 	mov	r4,r16
811239a8:	d8c01615 	stw	r3,88(sp)
811239ac:	11265400 	call	81126540 <__mcmp>
811239b0:	d8c01617 	ldw	r3,88(sp)
811239b4:	e009883a 	mov	r4,fp
811239b8:	d8801615 	stw	r2,88(sp)
811239bc:	180b883a 	mov	r5,r3
811239c0:	1125cf00 	call	81125cf0 <_Bfree>
811239c4:	d8801617 	ldw	r2,88(sp)
811239c8:	1000041e 	bne	r2,zero,811239dc <_dtoa_r+0xeb4>
811239cc:	d9800317 	ldw	r6,12(sp)
811239d0:	3000021e 	bne	r6,zero,811239dc <_dtoa_r+0xeb4>
811239d4:	d8c00617 	ldw	r3,24(sp)
811239d8:	18003726 	beq	r3,zero,81123ab8 <_dtoa_r+0xf90>
811239dc:	b0002016 	blt	r22,zero,81123a60 <_dtoa_r+0xf38>
811239e0:	b000041e 	bne	r22,zero,811239f4 <_dtoa_r+0xecc>
811239e4:	d9000317 	ldw	r4,12(sp)
811239e8:	2000021e 	bne	r4,zero,811239f4 <_dtoa_r+0xecc>
811239ec:	d8c00617 	ldw	r3,24(sp)
811239f0:	18001b26 	beq	r3,zero,81123a60 <_dtoa_r+0xf38>
811239f4:	00810716 	blt	zero,r2,81123e14 <_dtoa_r+0x12ec>
811239f8:	d8c00417 	ldw	r3,16(sp)
811239fc:	9d800044 	addi	r22,r19,1
81123a00:	9c800005 	stb	r18,0(r19)
81123a04:	b02f883a 	mov	r23,r22
81123a08:	98c10626 	beq	r19,r3,81123e24 <_dtoa_r+0x12fc>
81123a0c:	800b883a 	mov	r5,r16
81123a10:	000f883a 	mov	r7,zero
81123a14:	01800284 	movi	r6,10
81123a18:	e009883a 	mov	r4,fp
81123a1c:	1125d180 	call	81125d18 <__multadd>
81123a20:	1021883a 	mov	r16,r2
81123a24:	000f883a 	mov	r7,zero
81123a28:	01800284 	movi	r6,10
81123a2c:	880b883a 	mov	r5,r17
81123a30:	e009883a 	mov	r4,fp
81123a34:	8d002526 	beq	r17,r20,81123acc <_dtoa_r+0xfa4>
81123a38:	1125d180 	call	81125d18 <__multadd>
81123a3c:	a00b883a 	mov	r5,r20
81123a40:	000f883a 	mov	r7,zero
81123a44:	01800284 	movi	r6,10
81123a48:	e009883a 	mov	r4,fp
81123a4c:	1023883a 	mov	r17,r2
81123a50:	1125d180 	call	81125d18 <__multadd>
81123a54:	1029883a 	mov	r20,r2
81123a58:	b027883a 	mov	r19,r22
81123a5c:	003fc006 	br	81123960 <__reset+0xfb103960>
81123a60:	9011883a 	mov	r8,r18
81123a64:	00800e0e 	bge	zero,r2,81123aa0 <_dtoa_r+0xf78>
81123a68:	800b883a 	mov	r5,r16
81123a6c:	01800044 	movi	r6,1
81123a70:	e009883a 	mov	r4,fp
81123a74:	da001715 	stw	r8,92(sp)
81123a78:	11263f00 	call	811263f0 <__lshift>
81123a7c:	a80b883a 	mov	r5,r21
81123a80:	1009883a 	mov	r4,r2
81123a84:	1021883a 	mov	r16,r2
81123a88:	11265400 	call	81126540 <__mcmp>
81123a8c:	da001717 	ldw	r8,92(sp)
81123a90:	0081960e 	bge	zero,r2,811240ec <_dtoa_r+0x15c4>
81123a94:	00800e44 	movi	r2,57
81123a98:	40817026 	beq	r8,r2,8112405c <_dtoa_r+0x1534>
81123a9c:	ba000c44 	addi	r8,r23,49
81123aa0:	8825883a 	mov	r18,r17
81123aa4:	9dc00044 	addi	r23,r19,1
81123aa8:	9a000005 	stb	r8,0(r19)
81123aac:	a023883a 	mov	r17,r20
81123ab0:	dc000915 	stw	r16,36(sp)
81123ab4:	003f2406 	br	81123748 <__reset+0xfb103748>
81123ab8:	00800e44 	movi	r2,57
81123abc:	9011883a 	mov	r8,r18
81123ac0:	90816626 	beq	r18,r2,8112405c <_dtoa_r+0x1534>
81123ac4:	05bff516 	blt	zero,r22,81123a9c <__reset+0xfb103a9c>
81123ac8:	003ff506 	br	81123aa0 <__reset+0xfb103aa0>
81123acc:	1125d180 	call	81125d18 <__multadd>
81123ad0:	1023883a 	mov	r17,r2
81123ad4:	1029883a 	mov	r20,r2
81123ad8:	003fdf06 	br	81123a58 <__reset+0xfb103a58>
81123adc:	e009883a 	mov	r4,fp
81123ae0:	1125cf00 	call	81125cf0 <_Bfree>
81123ae4:	00800044 	movi	r2,1
81123ae8:	003fbc06 	br	811239dc <__reset+0xfb1039dc>
81123aec:	a80b883a 	mov	r5,r21
81123af0:	8009883a 	mov	r4,r16
81123af4:	11265400 	call	81126540 <__mcmp>
81123af8:	103edb0e 	bge	r2,zero,81123668 <__reset+0xfb103668>
81123afc:	800b883a 	mov	r5,r16
81123b00:	000f883a 	mov	r7,zero
81123b04:	01800284 	movi	r6,10
81123b08:	e009883a 	mov	r4,fp
81123b0c:	1125d180 	call	81125d18 <__multadd>
81123b10:	1021883a 	mov	r16,r2
81123b14:	d8800517 	ldw	r2,20(sp)
81123b18:	d8c00b17 	ldw	r3,44(sp)
81123b1c:	10bfffc4 	addi	r2,r2,-1
81123b20:	d8800515 	stw	r2,20(sp)
81123b24:	183f761e 	bne	r3,zero,81123900 <__reset+0xfb103900>
81123b28:	d9000c17 	ldw	r4,48(sp)
81123b2c:	0101730e 	bge	zero,r4,811240fc <_dtoa_r+0x15d4>
81123b30:	d9000615 	stw	r4,24(sp)
81123b34:	003ed006 	br	81123678 <__reset+0xfb103678>
81123b38:	00800084 	movi	r2,2
81123b3c:	3081861e 	bne	r6,r2,81124158 <_dtoa_r+0x1630>
81123b40:	d8000b15 	stw	zero,44(sp)
81123b44:	003f3c06 	br	81123838 <__reset+0xfb103838>
81123b48:	dc000917 	ldw	r16,36(sp)
81123b4c:	003e9206 	br	81123598 <__reset+0xfb103598>
81123b50:	d9c00317 	ldw	r7,12(sp)
81123b54:	00800084 	movi	r2,2
81123b58:	11fec50e 	bge	r2,r7,81123670 <__reset+0xfb103670>
81123b5c:	d9000617 	ldw	r4,24(sp)
81123b60:	20013c1e 	bne	r4,zero,81124054 <_dtoa_r+0x152c>
81123b64:	a80b883a 	mov	r5,r21
81123b68:	000f883a 	mov	r7,zero
81123b6c:	01800144 	movi	r6,5
81123b70:	e009883a 	mov	r4,fp
81123b74:	1125d180 	call	81125d18 <__multadd>
81123b78:	100b883a 	mov	r5,r2
81123b7c:	8009883a 	mov	r4,r16
81123b80:	102b883a 	mov	r21,r2
81123b84:	11265400 	call	81126540 <__mcmp>
81123b88:	dc000915 	stw	r16,36(sp)
81123b8c:	00bf410e 	bge	zero,r2,81123894 <__reset+0xfb103894>
81123b90:	d9c00717 	ldw	r7,28(sp)
81123b94:	00800c44 	movi	r2,49
81123b98:	38800005 	stb	r2,0(r7)
81123b9c:	d8800517 	ldw	r2,20(sp)
81123ba0:	3dc00044 	addi	r23,r7,1
81123ba4:	10800044 	addi	r2,r2,1
81123ba8:	d8800515 	stw	r2,20(sp)
81123bac:	003f3d06 	br	811238a4 <__reset+0xfb1038a4>
81123bb0:	d9800517 	ldw	r6,20(sp)
81123bb4:	d9c00717 	ldw	r7,28(sp)
81123bb8:	00800c44 	movi	r2,49
81123bbc:	31800044 	addi	r6,r6,1
81123bc0:	d9800515 	stw	r6,20(sp)
81123bc4:	38800005 	stb	r2,0(r7)
81123bc8:	003edf06 	br	81123748 <__reset+0xfb103748>
81123bcc:	d8000b15 	stw	zero,44(sp)
81123bd0:	003c9f06 	br	81122e50 <__reset+0xfb102e50>
81123bd4:	903e7e1e 	bne	r18,zero,811235d0 <__reset+0xfb1035d0>
81123bd8:	00800434 	movhi	r2,16
81123bdc:	10bfffc4 	addi	r2,r2,-1
81123be0:	9884703a 	and	r2,r19,r2
81123be4:	1000ea1e 	bne	r2,zero,81123f90 <_dtoa_r+0x1468>
81123be8:	9cdffc2c 	andhi	r19,r19,32752
81123bec:	9800e826 	beq	r19,zero,81123f90 <_dtoa_r+0x1468>
81123bf0:	d9c00817 	ldw	r7,32(sp)
81123bf4:	b5800044 	addi	r22,r22,1
81123bf8:	04c00044 	movi	r19,1
81123bfc:	39c00044 	addi	r7,r7,1
81123c00:	d9c00815 	stw	r7,32(sp)
81123c04:	d8800d17 	ldw	r2,52(sp)
81123c08:	103e721e 	bne	r2,zero,811235d4 <__reset+0xfb1035d4>
81123c0c:	00800044 	movi	r2,1
81123c10:	003e7906 	br	811235f8 <__reset+0xfb1035f8>
81123c14:	8009883a 	mov	r4,r16
81123c18:	11300300 	call	81130030 <__floatsidf>
81123c1c:	d9800f17 	ldw	r6,60(sp)
81123c20:	d9c01017 	ldw	r7,64(sp)
81123c24:	1009883a 	mov	r4,r2
81123c28:	180b883a 	mov	r5,r3
81123c2c:	1119dc00 	call	81119dc0 <__muldf3>
81123c30:	000d883a 	mov	r6,zero
81123c34:	01d00734 	movhi	r7,16412
81123c38:	1009883a 	mov	r4,r2
81123c3c:	180b883a 	mov	r5,r3
81123c40:	112e2b00 	call	8112e2b0 <__adddf3>
81123c44:	047f3034 	movhi	r17,64704
81123c48:	1021883a 	mov	r16,r2
81123c4c:	1c63883a 	add	r17,r3,r17
81123c50:	d9000f17 	ldw	r4,60(sp)
81123c54:	d9401017 	ldw	r5,64(sp)
81123c58:	000d883a 	mov	r6,zero
81123c5c:	01d00534 	movhi	r7,16404
81123c60:	112f6ac0 	call	8112f6ac <__subdf3>
81123c64:	800d883a 	mov	r6,r16
81123c68:	880f883a 	mov	r7,r17
81123c6c:	1009883a 	mov	r4,r2
81123c70:	180b883a 	mov	r5,r3
81123c74:	102b883a 	mov	r21,r2
81123c78:	1829883a 	mov	r20,r3
81123c7c:	112f4dc0 	call	8112f4dc <__gedf2>
81123c80:	00806c16 	blt	zero,r2,81123e34 <_dtoa_r+0x130c>
81123c84:	89e0003c 	xorhi	r7,r17,32768
81123c88:	800d883a 	mov	r6,r16
81123c8c:	a809883a 	mov	r4,r21
81123c90:	a00b883a 	mov	r5,r20
81123c94:	112f5b80 	call	8112f5b8 <__ledf2>
81123c98:	103d7e0e 	bge	r2,zero,81123294 <__reset+0xfb103294>
81123c9c:	002b883a 	mov	r21,zero
81123ca0:	0023883a 	mov	r17,zero
81123ca4:	003efb06 	br	81123894 <__reset+0xfb103894>
81123ca8:	d8800717 	ldw	r2,28(sp)
81123cac:	003bd006 	br	81122bf0 <__reset+0xfb102bf0>
81123cb0:	d9000a17 	ldw	r4,40(sp)
81123cb4:	d9800d17 	ldw	r6,52(sp)
81123cb8:	dd400a15 	stw	r21,40(sp)
81123cbc:	a905c83a 	sub	r2,r21,r4
81123cc0:	308d883a 	add	r6,r6,r2
81123cc4:	d9800d15 	stw	r6,52(sp)
81123cc8:	002b883a 	mov	r21,zero
81123ccc:	003e0606 	br	811234e8 <__reset+0xfb1034e8>
81123cd0:	9023883a 	mov	r17,r18
81123cd4:	9829883a 	mov	r20,r19
81123cd8:	04000084 	movi	r16,2
81123cdc:	003c9206 	br	81122f28 <__reset+0xfb102f28>
81123ce0:	04000044 	movi	r16,1
81123ce4:	dc000c15 	stw	r16,48(sp)
81123ce8:	dc000615 	stw	r16,24(sp)
81123cec:	dc002215 	stw	r16,136(sp)
81123cf0:	e0001115 	stw	zero,68(fp)
81123cf4:	000b883a 	mov	r5,zero
81123cf8:	003c6906 	br	81122ea0 <__reset+0xfb102ea0>
81123cfc:	3021883a 	mov	r16,r6
81123d00:	003ffb06 	br	81123cf0 <__reset+0xfb103cf0>
81123d04:	1000021e 	bne	r2,zero,81123d10 <_dtoa_r+0x11e8>
81123d08:	4200004c 	andi	r8,r8,1
81123d0c:	403e7d1e 	bne	r8,zero,81123704 <__reset+0xfb103704>
81123d10:	01000c04 	movi	r4,48
81123d14:	00000106 	br	81123d1c <_dtoa_r+0x11f4>
81123d18:	102f883a 	mov	r23,r2
81123d1c:	b8bfffc4 	addi	r2,r23,-1
81123d20:	10c00007 	ldb	r3,0(r2)
81123d24:	193ffc26 	beq	r3,r4,81123d18 <__reset+0xfb103d18>
81123d28:	003e8706 	br	81123748 <__reset+0xfb103748>
81123d2c:	d8800517 	ldw	r2,20(sp)
81123d30:	00a3c83a 	sub	r17,zero,r2
81123d34:	8800a426 	beq	r17,zero,81123fc8 <_dtoa_r+0x14a0>
81123d38:	888003cc 	andi	r2,r17,15
81123d3c:	100490fa 	slli	r2,r2,3
81123d40:	00e04574 	movhi	r3,33045
81123d44:	18e6f304 	addi	r3,r3,-25652
81123d48:	1885883a 	add	r2,r3,r2
81123d4c:	11800017 	ldw	r6,0(r2)
81123d50:	11c00117 	ldw	r7,4(r2)
81123d54:	9009883a 	mov	r4,r18
81123d58:	980b883a 	mov	r5,r19
81123d5c:	8823d13a 	srai	r17,r17,4
81123d60:	1119dc00 	call	81119dc0 <__muldf3>
81123d64:	d8800f15 	stw	r2,60(sp)
81123d68:	d8c01015 	stw	r3,64(sp)
81123d6c:	8800e826 	beq	r17,zero,81124110 <_dtoa_r+0x15e8>
81123d70:	05204574 	movhi	r20,33045
81123d74:	a526e904 	addi	r20,r20,-25692
81123d78:	04000084 	movi	r16,2
81123d7c:	8980004c 	andi	r6,r17,1
81123d80:	1009883a 	mov	r4,r2
81123d84:	8823d07a 	srai	r17,r17,1
81123d88:	180b883a 	mov	r5,r3
81123d8c:	30000426 	beq	r6,zero,81123da0 <_dtoa_r+0x1278>
81123d90:	a1800017 	ldw	r6,0(r20)
81123d94:	a1c00117 	ldw	r7,4(r20)
81123d98:	84000044 	addi	r16,r16,1
81123d9c:	1119dc00 	call	81119dc0 <__muldf3>
81123da0:	a5000204 	addi	r20,r20,8
81123da4:	883ff51e 	bne	r17,zero,81123d7c <__reset+0xfb103d7c>
81123da8:	d8800f15 	stw	r2,60(sp)
81123dac:	d8c01015 	stw	r3,64(sp)
81123db0:	003c7606 	br	81122f8c <__reset+0xfb102f8c>
81123db4:	00c00c04 	movi	r3,48
81123db8:	10c00005 	stb	r3,0(r2)
81123dbc:	d8c00517 	ldw	r3,20(sp)
81123dc0:	bd3fffc3 	ldbu	r20,-1(r23)
81123dc4:	18c00044 	addi	r3,r3,1
81123dc8:	d8c00515 	stw	r3,20(sp)
81123dcc:	003db906 	br	811234b4 <__reset+0xfb1034b4>
81123dd0:	89400117 	ldw	r5,4(r17)
81123dd4:	e009883a 	mov	r4,fp
81123dd8:	1125c400 	call	81125c40 <_Balloc>
81123ddc:	89800417 	ldw	r6,16(r17)
81123de0:	89400304 	addi	r5,r17,12
81123de4:	11000304 	addi	r4,r2,12
81123de8:	31800084 	addi	r6,r6,2
81123dec:	318d883a 	add	r6,r6,r6
81123df0:	318d883a 	add	r6,r6,r6
81123df4:	1027883a 	mov	r19,r2
81123df8:	111ba100 	call	8111ba10 <memcpy>
81123dfc:	01800044 	movi	r6,1
81123e00:	980b883a 	mov	r5,r19
81123e04:	e009883a 	mov	r4,fp
81123e08:	11263f00 	call	811263f0 <__lshift>
81123e0c:	1029883a 	mov	r20,r2
81123e10:	003ecc06 	br	81123944 <__reset+0xfb103944>
81123e14:	00800e44 	movi	r2,57
81123e18:	90809026 	beq	r18,r2,8112405c <_dtoa_r+0x1534>
81123e1c:	92000044 	addi	r8,r18,1
81123e20:	003f1f06 	br	81123aa0 <__reset+0xfb103aa0>
81123e24:	9011883a 	mov	r8,r18
81123e28:	8825883a 	mov	r18,r17
81123e2c:	a023883a 	mov	r17,r20
81123e30:	003e2906 	br	811236d8 <__reset+0xfb1036d8>
81123e34:	002b883a 	mov	r21,zero
81123e38:	0023883a 	mov	r17,zero
81123e3c:	003f5406 	br	81123b90 <__reset+0xfb103b90>
81123e40:	61bfffc4 	addi	r6,r12,-1
81123e44:	300490fa 	slli	r2,r6,3
81123e48:	00e04574 	movhi	r3,33045
81123e4c:	18e6f304 	addi	r3,r3,-25652
81123e50:	1885883a 	add	r2,r3,r2
81123e54:	11000017 	ldw	r4,0(r2)
81123e58:	11400117 	ldw	r5,4(r2)
81123e5c:	d8800717 	ldw	r2,28(sp)
81123e60:	880f883a 	mov	r7,r17
81123e64:	d9801215 	stw	r6,72(sp)
81123e68:	800d883a 	mov	r6,r16
81123e6c:	db001615 	stw	r12,88(sp)
81123e70:	15c00044 	addi	r23,r2,1
81123e74:	1119dc00 	call	81119dc0 <__muldf3>
81123e78:	d9401017 	ldw	r5,64(sp)
81123e7c:	d9000f17 	ldw	r4,60(sp)
81123e80:	d8c01515 	stw	r3,84(sp)
81123e84:	d8801415 	stw	r2,80(sp)
81123e88:	112ffb00 	call	8112ffb0 <__fixdfsi>
81123e8c:	1009883a 	mov	r4,r2
81123e90:	1021883a 	mov	r16,r2
81123e94:	11300300 	call	81130030 <__floatsidf>
81123e98:	d9000f17 	ldw	r4,60(sp)
81123e9c:	d9401017 	ldw	r5,64(sp)
81123ea0:	100d883a 	mov	r6,r2
81123ea4:	180f883a 	mov	r7,r3
81123ea8:	112f6ac0 	call	8112f6ac <__subdf3>
81123eac:	1829883a 	mov	r20,r3
81123eb0:	d8c00717 	ldw	r3,28(sp)
81123eb4:	84000c04 	addi	r16,r16,48
81123eb8:	1023883a 	mov	r17,r2
81123ebc:	1c000005 	stb	r16,0(r3)
81123ec0:	db001617 	ldw	r12,88(sp)
81123ec4:	00800044 	movi	r2,1
81123ec8:	60802226 	beq	r12,r2,81123f54 <_dtoa_r+0x142c>
81123ecc:	d9c00717 	ldw	r7,28(sp)
81123ed0:	8805883a 	mov	r2,r17
81123ed4:	b82b883a 	mov	r21,r23
81123ed8:	3b19883a 	add	r12,r7,r12
81123edc:	6023883a 	mov	r17,r12
81123ee0:	a007883a 	mov	r3,r20
81123ee4:	dc800f15 	stw	r18,60(sp)
81123ee8:	000d883a 	mov	r6,zero
81123eec:	01d00934 	movhi	r7,16420
81123ef0:	1009883a 	mov	r4,r2
81123ef4:	180b883a 	mov	r5,r3
81123ef8:	1119dc00 	call	81119dc0 <__muldf3>
81123efc:	180b883a 	mov	r5,r3
81123f00:	1009883a 	mov	r4,r2
81123f04:	1829883a 	mov	r20,r3
81123f08:	1025883a 	mov	r18,r2
81123f0c:	112ffb00 	call	8112ffb0 <__fixdfsi>
81123f10:	1009883a 	mov	r4,r2
81123f14:	1021883a 	mov	r16,r2
81123f18:	11300300 	call	81130030 <__floatsidf>
81123f1c:	100d883a 	mov	r6,r2
81123f20:	180f883a 	mov	r7,r3
81123f24:	9009883a 	mov	r4,r18
81123f28:	a00b883a 	mov	r5,r20
81123f2c:	84000c04 	addi	r16,r16,48
81123f30:	112f6ac0 	call	8112f6ac <__subdf3>
81123f34:	ad400044 	addi	r21,r21,1
81123f38:	ac3fffc5 	stb	r16,-1(r21)
81123f3c:	ac7fea1e 	bne	r21,r17,81123ee8 <__reset+0xfb103ee8>
81123f40:	1023883a 	mov	r17,r2
81123f44:	d8801217 	ldw	r2,72(sp)
81123f48:	dc800f17 	ldw	r18,60(sp)
81123f4c:	1829883a 	mov	r20,r3
81123f50:	b8af883a 	add	r23,r23,r2
81123f54:	d9001417 	ldw	r4,80(sp)
81123f58:	d9401517 	ldw	r5,84(sp)
81123f5c:	000d883a 	mov	r6,zero
81123f60:	01cff834 	movhi	r7,16352
81123f64:	112e2b00 	call	8112e2b0 <__adddf3>
81123f68:	880d883a 	mov	r6,r17
81123f6c:	a00f883a 	mov	r7,r20
81123f70:	1009883a 	mov	r4,r2
81123f74:	180b883a 	mov	r5,r3
81123f78:	112f5b80 	call	8112f5b8 <__ledf2>
81123f7c:	10003e0e 	bge	r2,zero,81124078 <_dtoa_r+0x1550>
81123f80:	d9001317 	ldw	r4,76(sp)
81123f84:	bd3fffc3 	ldbu	r20,-1(r23)
81123f88:	d9000515 	stw	r4,20(sp)
81123f8c:	003d3b06 	br	8112347c <__reset+0xfb10347c>
81123f90:	0027883a 	mov	r19,zero
81123f94:	003f1b06 	br	81123c04 <__reset+0xfb103c04>
81123f98:	d8800817 	ldw	r2,32(sp)
81123f9c:	11e9c83a 	sub	r20,r2,r7
81123fa0:	0005883a 	mov	r2,zero
81123fa4:	003d5406 	br	811234f8 <__reset+0xfb1034f8>
81123fa8:	00800044 	movi	r2,1
81123fac:	003dc706 	br	811236cc <__reset+0xfb1036cc>
81123fb0:	d8c00217 	ldw	r3,8(sp)
81123fb4:	00800d84 	movi	r2,54
81123fb8:	dd400a17 	ldw	r21,40(sp)
81123fbc:	10c5c83a 	sub	r2,r2,r3
81123fc0:	dd000817 	ldw	r20,32(sp)
81123fc4:	003d4c06 	br	811234f8 <__reset+0xfb1034f8>
81123fc8:	dc800f15 	stw	r18,60(sp)
81123fcc:	dcc01015 	stw	r19,64(sp)
81123fd0:	04000084 	movi	r16,2
81123fd4:	003bed06 	br	81122f8c <__reset+0xfb102f8c>
81123fd8:	d9000617 	ldw	r4,24(sp)
81123fdc:	203f0d26 	beq	r4,zero,81123c14 <__reset+0xfb103c14>
81123fe0:	d9800c17 	ldw	r6,48(sp)
81123fe4:	01bcab0e 	bge	zero,r6,81123294 <__reset+0xfb103294>
81123fe8:	d9401017 	ldw	r5,64(sp)
81123fec:	d9000f17 	ldw	r4,60(sp)
81123ff0:	000d883a 	mov	r6,zero
81123ff4:	01d00934 	movhi	r7,16420
81123ff8:	1119dc00 	call	81119dc0 <__muldf3>
81123ffc:	81000044 	addi	r4,r16,1
81124000:	d8800f15 	stw	r2,60(sp)
81124004:	d8c01015 	stw	r3,64(sp)
81124008:	11300300 	call	81130030 <__floatsidf>
8112400c:	d9800f17 	ldw	r6,60(sp)
81124010:	d9c01017 	ldw	r7,64(sp)
81124014:	1009883a 	mov	r4,r2
81124018:	180b883a 	mov	r5,r3
8112401c:	1119dc00 	call	81119dc0 <__muldf3>
81124020:	01d00734 	movhi	r7,16412
81124024:	000d883a 	mov	r6,zero
81124028:	1009883a 	mov	r4,r2
8112402c:	180b883a 	mov	r5,r3
81124030:	112e2b00 	call	8112e2b0 <__adddf3>
81124034:	d9c00517 	ldw	r7,20(sp)
81124038:	047f3034 	movhi	r17,64704
8112403c:	1021883a 	mov	r16,r2
81124040:	39ffffc4 	addi	r7,r7,-1
81124044:	d9c01315 	stw	r7,76(sp)
81124048:	1c63883a 	add	r17,r3,r17
8112404c:	db000c17 	ldw	r12,48(sp)
81124050:	003bea06 	br	81122ffc <__reset+0xfb102ffc>
81124054:	dc000915 	stw	r16,36(sp)
81124058:	003e0e06 	br	81123894 <__reset+0xfb103894>
8112405c:	01000e44 	movi	r4,57
81124060:	8825883a 	mov	r18,r17
81124064:	9dc00044 	addi	r23,r19,1
81124068:	99000005 	stb	r4,0(r19)
8112406c:	a023883a 	mov	r17,r20
81124070:	dc000915 	stw	r16,36(sp)
81124074:	003da406 	br	81123708 <__reset+0xfb103708>
81124078:	d9801417 	ldw	r6,80(sp)
8112407c:	d9c01517 	ldw	r7,84(sp)
81124080:	0009883a 	mov	r4,zero
81124084:	014ff834 	movhi	r5,16352
81124088:	112f6ac0 	call	8112f6ac <__subdf3>
8112408c:	880d883a 	mov	r6,r17
81124090:	a00f883a 	mov	r7,r20
81124094:	1009883a 	mov	r4,r2
81124098:	180b883a 	mov	r5,r3
8112409c:	112f4dc0 	call	8112f4dc <__gedf2>
811240a0:	00bc7c0e 	bge	zero,r2,81123294 <__reset+0xfb103294>
811240a4:	01000c04 	movi	r4,48
811240a8:	00000106 	br	811240b0 <_dtoa_r+0x1588>
811240ac:	102f883a 	mov	r23,r2
811240b0:	b8bfffc4 	addi	r2,r23,-1
811240b4:	10c00007 	ldb	r3,0(r2)
811240b8:	193ffc26 	beq	r3,r4,811240ac <__reset+0xfb1040ac>
811240bc:	d9801317 	ldw	r6,76(sp)
811240c0:	d9800515 	stw	r6,20(sp)
811240c4:	003c4406 	br	811231d8 <__reset+0xfb1031d8>
811240c8:	d9801317 	ldw	r6,76(sp)
811240cc:	d9800515 	stw	r6,20(sp)
811240d0:	003cea06 	br	8112347c <__reset+0xfb10347c>
811240d4:	dd800f17 	ldw	r22,60(sp)
811240d8:	dcc01017 	ldw	r19,64(sp)
811240dc:	dc801217 	ldw	r18,72(sp)
811240e0:	003c6c06 	br	81123294 <__reset+0xfb103294>
811240e4:	903e031e 	bne	r18,zero,811238f4 <__reset+0xfb1038f4>
811240e8:	003ebb06 	br	81123bd8 <__reset+0xfb103bd8>
811240ec:	103e6c1e 	bne	r2,zero,81123aa0 <__reset+0xfb103aa0>
811240f0:	4080004c 	andi	r2,r8,1
811240f4:	103e6a26 	beq	r2,zero,81123aa0 <__reset+0xfb103aa0>
811240f8:	003e6606 	br	81123a94 <__reset+0xfb103a94>
811240fc:	d8c00317 	ldw	r3,12(sp)
81124100:	00800084 	movi	r2,2
81124104:	10c02916 	blt	r2,r3,811241ac <_dtoa_r+0x1684>
81124108:	d9000c17 	ldw	r4,48(sp)
8112410c:	003e8806 	br	81123b30 <__reset+0xfb103b30>
81124110:	04000084 	movi	r16,2
81124114:	003b9d06 	br	81122f8c <__reset+0xfb102f8c>
81124118:	d9001317 	ldw	r4,76(sp)
8112411c:	d9000515 	stw	r4,20(sp)
81124120:	003cd606 	br	8112347c <__reset+0xfb10347c>
81124124:	d8801317 	ldw	r2,76(sp)
81124128:	d8800515 	stw	r2,20(sp)
8112412c:	003c2a06 	br	811231d8 <__reset+0xfb1031d8>
81124130:	d9800317 	ldw	r6,12(sp)
81124134:	00800084 	movi	r2,2
81124138:	11801516 	blt	r2,r6,81124190 <_dtoa_r+0x1668>
8112413c:	d9c00c17 	ldw	r7,48(sp)
81124140:	d9c00615 	stw	r7,24(sp)
81124144:	003df706 	br	81123924 <__reset+0xfb103924>
81124148:	193d3926 	beq	r3,r4,81123630 <__reset+0xfb103630>
8112414c:	00c00f04 	movi	r3,60
81124150:	1885c83a 	sub	r2,r3,r2
81124154:	003ddf06 	br	811238d4 <__reset+0xfb1038d4>
81124158:	e009883a 	mov	r4,fp
8112415c:	e0001115 	stw	zero,68(fp)
81124160:	000b883a 	mov	r5,zero
81124164:	1125c400 	call	81125c40 <_Balloc>
81124168:	d8800715 	stw	r2,28(sp)
8112416c:	d8c00717 	ldw	r3,28(sp)
81124170:	00bfffc4 	movi	r2,-1
81124174:	01000044 	movi	r4,1
81124178:	d8800c15 	stw	r2,48(sp)
8112417c:	e0c01015 	stw	r3,64(fp)
81124180:	d9000b15 	stw	r4,44(sp)
81124184:	d8800615 	stw	r2,24(sp)
81124188:	d8002215 	stw	zero,136(sp)
8112418c:	003c4106 	br	81123294 <__reset+0xfb103294>
81124190:	d8c00c17 	ldw	r3,48(sp)
81124194:	d8c00615 	stw	r3,24(sp)
81124198:	003e7006 	br	81123b5c <__reset+0xfb103b5c>
8112419c:	04400044 	movi	r17,1
811241a0:	003b2006 	br	81122e24 <__reset+0xfb102e24>
811241a4:	000b883a 	mov	r5,zero
811241a8:	003b3d06 	br	81122ea0 <__reset+0xfb102ea0>
811241ac:	d8800c17 	ldw	r2,48(sp)
811241b0:	d8800615 	stw	r2,24(sp)
811241b4:	003e6906 	br	81123b5c <__reset+0xfb103b5c>

811241b8 <__sflush_r>:
811241b8:	defffb04 	addi	sp,sp,-20
811241bc:	de00012e 	bgeu	sp,et,811241c4 <__sflush_r+0xc>
811241c0:	003b68fa 	trap	3
811241c4:	2880030b 	ldhu	r2,12(r5)
811241c8:	dcc00315 	stw	r19,12(sp)
811241cc:	dc400115 	stw	r17,4(sp)
811241d0:	dfc00415 	stw	ra,16(sp)
811241d4:	dc800215 	stw	r18,8(sp)
811241d8:	dc000015 	stw	r16,0(sp)
811241dc:	10c0020c 	andi	r3,r2,8
811241e0:	2823883a 	mov	r17,r5
811241e4:	2027883a 	mov	r19,r4
811241e8:	1800311e 	bne	r3,zero,811242b0 <__sflush_r+0xf8>
811241ec:	28c00117 	ldw	r3,4(r5)
811241f0:	10820014 	ori	r2,r2,2048
811241f4:	2880030d 	sth	r2,12(r5)
811241f8:	00c04b0e 	bge	zero,r3,81124328 <__sflush_r+0x170>
811241fc:	8a000a17 	ldw	r8,40(r17)
81124200:	40002326 	beq	r8,zero,81124290 <__sflush_r+0xd8>
81124204:	9c000017 	ldw	r16,0(r19)
81124208:	10c4000c 	andi	r3,r2,4096
8112420c:	98000015 	stw	zero,0(r19)
81124210:	18004826 	beq	r3,zero,81124334 <__sflush_r+0x17c>
81124214:	89801417 	ldw	r6,80(r17)
81124218:	10c0010c 	andi	r3,r2,4
8112421c:	18000626 	beq	r3,zero,81124238 <__sflush_r+0x80>
81124220:	88c00117 	ldw	r3,4(r17)
81124224:	88800c17 	ldw	r2,48(r17)
81124228:	30cdc83a 	sub	r6,r6,r3
8112422c:	10000226 	beq	r2,zero,81124238 <__sflush_r+0x80>
81124230:	88800f17 	ldw	r2,60(r17)
81124234:	308dc83a 	sub	r6,r6,r2
81124238:	89400717 	ldw	r5,28(r17)
8112423c:	000f883a 	mov	r7,zero
81124240:	9809883a 	mov	r4,r19
81124244:	403ee83a 	callr	r8
81124248:	00ffffc4 	movi	r3,-1
8112424c:	10c04426 	beq	r2,r3,81124360 <__sflush_r+0x1a8>
81124250:	88c0030b 	ldhu	r3,12(r17)
81124254:	89000417 	ldw	r4,16(r17)
81124258:	88000115 	stw	zero,4(r17)
8112425c:	197dffcc 	andi	r5,r3,63487
81124260:	8940030d 	sth	r5,12(r17)
81124264:	89000015 	stw	r4,0(r17)
81124268:	18c4000c 	andi	r3,r3,4096
8112426c:	18002c1e 	bne	r3,zero,81124320 <__sflush_r+0x168>
81124270:	89400c17 	ldw	r5,48(r17)
81124274:	9c000015 	stw	r16,0(r19)
81124278:	28000526 	beq	r5,zero,81124290 <__sflush_r+0xd8>
8112427c:	88801004 	addi	r2,r17,64
81124280:	28800226 	beq	r5,r2,8112428c <__sflush_r+0xd4>
81124284:	9809883a 	mov	r4,r19
81124288:	1124c700 	call	81124c70 <_free_r>
8112428c:	88000c15 	stw	zero,48(r17)
81124290:	0005883a 	mov	r2,zero
81124294:	dfc00417 	ldw	ra,16(sp)
81124298:	dcc00317 	ldw	r19,12(sp)
8112429c:	dc800217 	ldw	r18,8(sp)
811242a0:	dc400117 	ldw	r17,4(sp)
811242a4:	dc000017 	ldw	r16,0(sp)
811242a8:	dec00504 	addi	sp,sp,20
811242ac:	f800283a 	ret
811242b0:	2c800417 	ldw	r18,16(r5)
811242b4:	903ff626 	beq	r18,zero,81124290 <__reset+0xfb104290>
811242b8:	2c000017 	ldw	r16,0(r5)
811242bc:	108000cc 	andi	r2,r2,3
811242c0:	2c800015 	stw	r18,0(r5)
811242c4:	84a1c83a 	sub	r16,r16,r18
811242c8:	1000131e 	bne	r2,zero,81124318 <__sflush_r+0x160>
811242cc:	28800517 	ldw	r2,20(r5)
811242d0:	88800215 	stw	r2,8(r17)
811242d4:	04000316 	blt	zero,r16,811242e4 <__sflush_r+0x12c>
811242d8:	003fed06 	br	81124290 <__reset+0xfb104290>
811242dc:	90a5883a 	add	r18,r18,r2
811242e0:	043feb0e 	bge	zero,r16,81124290 <__reset+0xfb104290>
811242e4:	88800917 	ldw	r2,36(r17)
811242e8:	89400717 	ldw	r5,28(r17)
811242ec:	800f883a 	mov	r7,r16
811242f0:	900d883a 	mov	r6,r18
811242f4:	9809883a 	mov	r4,r19
811242f8:	103ee83a 	callr	r2
811242fc:	80a1c83a 	sub	r16,r16,r2
81124300:	00bff616 	blt	zero,r2,811242dc <__reset+0xfb1042dc>
81124304:	88c0030b 	ldhu	r3,12(r17)
81124308:	00bfffc4 	movi	r2,-1
8112430c:	18c01014 	ori	r3,r3,64
81124310:	88c0030d 	sth	r3,12(r17)
81124314:	003fdf06 	br	81124294 <__reset+0xfb104294>
81124318:	0005883a 	mov	r2,zero
8112431c:	003fec06 	br	811242d0 <__reset+0xfb1042d0>
81124320:	88801415 	stw	r2,80(r17)
81124324:	003fd206 	br	81124270 <__reset+0xfb104270>
81124328:	28c00f17 	ldw	r3,60(r5)
8112432c:	00ffb316 	blt	zero,r3,811241fc <__reset+0xfb1041fc>
81124330:	003fd706 	br	81124290 <__reset+0xfb104290>
81124334:	89400717 	ldw	r5,28(r17)
81124338:	000d883a 	mov	r6,zero
8112433c:	01c00044 	movi	r7,1
81124340:	9809883a 	mov	r4,r19
81124344:	403ee83a 	callr	r8
81124348:	100d883a 	mov	r6,r2
8112434c:	00bfffc4 	movi	r2,-1
81124350:	30801426 	beq	r6,r2,811243a4 <__sflush_r+0x1ec>
81124354:	8880030b 	ldhu	r2,12(r17)
81124358:	8a000a17 	ldw	r8,40(r17)
8112435c:	003fae06 	br	81124218 <__reset+0xfb104218>
81124360:	98c00017 	ldw	r3,0(r19)
81124364:	183fba26 	beq	r3,zero,81124250 <__reset+0xfb104250>
81124368:	01000744 	movi	r4,29
8112436c:	19000626 	beq	r3,r4,81124388 <__sflush_r+0x1d0>
81124370:	01000584 	movi	r4,22
81124374:	19000426 	beq	r3,r4,81124388 <__sflush_r+0x1d0>
81124378:	88c0030b 	ldhu	r3,12(r17)
8112437c:	18c01014 	ori	r3,r3,64
81124380:	88c0030d 	sth	r3,12(r17)
81124384:	003fc306 	br	81124294 <__reset+0xfb104294>
81124388:	8880030b 	ldhu	r2,12(r17)
8112438c:	88c00417 	ldw	r3,16(r17)
81124390:	88000115 	stw	zero,4(r17)
81124394:	10bdffcc 	andi	r2,r2,63487
81124398:	8880030d 	sth	r2,12(r17)
8112439c:	88c00015 	stw	r3,0(r17)
811243a0:	003fb306 	br	81124270 <__reset+0xfb104270>
811243a4:	98800017 	ldw	r2,0(r19)
811243a8:	103fea26 	beq	r2,zero,81124354 <__reset+0xfb104354>
811243ac:	00c00744 	movi	r3,29
811243b0:	10c00226 	beq	r2,r3,811243bc <__sflush_r+0x204>
811243b4:	00c00584 	movi	r3,22
811243b8:	10c0031e 	bne	r2,r3,811243c8 <__sflush_r+0x210>
811243bc:	9c000015 	stw	r16,0(r19)
811243c0:	0005883a 	mov	r2,zero
811243c4:	003fb306 	br	81124294 <__reset+0xfb104294>
811243c8:	88c0030b 	ldhu	r3,12(r17)
811243cc:	3005883a 	mov	r2,r6
811243d0:	18c01014 	ori	r3,r3,64
811243d4:	88c0030d 	sth	r3,12(r17)
811243d8:	003fae06 	br	81124294 <__reset+0xfb104294>

811243dc <_fflush_r>:
811243dc:	defffd04 	addi	sp,sp,-12
811243e0:	de00012e 	bgeu	sp,et,811243e8 <_fflush_r+0xc>
811243e4:	003b68fa 	trap	3
811243e8:	dc000115 	stw	r16,4(sp)
811243ec:	dfc00215 	stw	ra,8(sp)
811243f0:	2021883a 	mov	r16,r4
811243f4:	20000226 	beq	r4,zero,81124400 <_fflush_r+0x24>
811243f8:	20800e17 	ldw	r2,56(r4)
811243fc:	10000c26 	beq	r2,zero,81124430 <_fflush_r+0x54>
81124400:	2880030f 	ldh	r2,12(r5)
81124404:	1000051e 	bne	r2,zero,8112441c <_fflush_r+0x40>
81124408:	0005883a 	mov	r2,zero
8112440c:	dfc00217 	ldw	ra,8(sp)
81124410:	dc000117 	ldw	r16,4(sp)
81124414:	dec00304 	addi	sp,sp,12
81124418:	f800283a 	ret
8112441c:	8009883a 	mov	r4,r16
81124420:	dfc00217 	ldw	ra,8(sp)
81124424:	dc000117 	ldw	r16,4(sp)
81124428:	dec00304 	addi	sp,sp,12
8112442c:	11241b81 	jmpi	811241b8 <__sflush_r>
81124430:	d9400015 	stw	r5,0(sp)
81124434:	11247d80 	call	811247d8 <__sinit>
81124438:	d9400017 	ldw	r5,0(sp)
8112443c:	003ff006 	br	81124400 <__reset+0xfb104400>

81124440 <fflush>:
81124440:	20000526 	beq	r4,zero,81124458 <fflush+0x18>
81124444:	00a04574 	movhi	r2,33045
81124448:	10b08204 	addi	r2,r2,-15864
8112444c:	200b883a 	mov	r5,r4
81124450:	11000017 	ldw	r4,0(r2)
81124454:	11243dc1 	jmpi	811243dc <_fflush_r>
81124458:	00a04574 	movhi	r2,33045
8112445c:	10b08104 	addi	r2,r2,-15868
81124460:	11000017 	ldw	r4,0(r2)
81124464:	016044b4 	movhi	r5,33042
81124468:	2950f704 	addi	r5,r5,17372
8112446c:	11255181 	jmpi	81125518 <_fwalk_reent>

81124470 <__fp_unlock>:
81124470:	0005883a 	mov	r2,zero
81124474:	f800283a 	ret

81124478 <_cleanup_r>:
81124478:	016044f4 	movhi	r5,33043
8112447c:	29708d04 	addi	r5,r5,-15820
81124480:	11255181 	jmpi	81125518 <_fwalk_reent>

81124484 <__sinit.part.1>:
81124484:	defff704 	addi	sp,sp,-36
81124488:	00e044b4 	movhi	r3,33042
8112448c:	de00012e 	bgeu	sp,et,81124494 <__sinit.part.1+0x10>
81124490:	003b68fa 	trap	3
81124494:	18d11e04 	addi	r3,r3,17528
81124498:	dfc00815 	stw	ra,32(sp)
8112449c:	ddc00715 	stw	r23,28(sp)
811244a0:	dd800615 	stw	r22,24(sp)
811244a4:	dd400515 	stw	r21,20(sp)
811244a8:	dd000415 	stw	r20,16(sp)
811244ac:	dcc00315 	stw	r19,12(sp)
811244b0:	dc800215 	stw	r18,8(sp)
811244b4:	dc400115 	stw	r17,4(sp)
811244b8:	dc000015 	stw	r16,0(sp)
811244bc:	24000117 	ldw	r16,4(r4)
811244c0:	20c00f15 	stw	r3,60(r4)
811244c4:	2080bb04 	addi	r2,r4,748
811244c8:	00c000c4 	movi	r3,3
811244cc:	20c0b915 	stw	r3,740(r4)
811244d0:	2080ba15 	stw	r2,744(r4)
811244d4:	2000b815 	stw	zero,736(r4)
811244d8:	05c00204 	movi	r23,8
811244dc:	00800104 	movi	r2,4
811244e0:	2025883a 	mov	r18,r4
811244e4:	b80d883a 	mov	r6,r23
811244e8:	81001704 	addi	r4,r16,92
811244ec:	000b883a 	mov	r5,zero
811244f0:	80000015 	stw	zero,0(r16)
811244f4:	80000115 	stw	zero,4(r16)
811244f8:	80000215 	stw	zero,8(r16)
811244fc:	8080030d 	sth	r2,12(r16)
81124500:	80001915 	stw	zero,100(r16)
81124504:	8000038d 	sth	zero,14(r16)
81124508:	80000415 	stw	zero,16(r16)
8112450c:	80000515 	stw	zero,20(r16)
81124510:	80000615 	stw	zero,24(r16)
81124514:	111bb600 	call	8111bb60 <memset>
81124518:	05a044b4 	movhi	r22,33042
8112451c:	94400217 	ldw	r17,8(r18)
81124520:	056044b4 	movhi	r21,33042
81124524:	052044b4 	movhi	r20,33042
81124528:	04e044b4 	movhi	r19,33042
8112452c:	b5b0d904 	addi	r22,r22,-15516
81124530:	ad70f204 	addi	r21,r21,-15416
81124534:	a5311304 	addi	r20,r20,-15284
81124538:	9cf12c04 	addi	r19,r19,-15184
8112453c:	85800815 	stw	r22,32(r16)
81124540:	85400915 	stw	r21,36(r16)
81124544:	85000a15 	stw	r20,40(r16)
81124548:	84c00b15 	stw	r19,44(r16)
8112454c:	84000715 	stw	r16,28(r16)
81124550:	00800284 	movi	r2,10
81124554:	8880030d 	sth	r2,12(r17)
81124558:	00800044 	movi	r2,1
8112455c:	b80d883a 	mov	r6,r23
81124560:	89001704 	addi	r4,r17,92
81124564:	000b883a 	mov	r5,zero
81124568:	88000015 	stw	zero,0(r17)
8112456c:	88000115 	stw	zero,4(r17)
81124570:	88000215 	stw	zero,8(r17)
81124574:	88001915 	stw	zero,100(r17)
81124578:	8880038d 	sth	r2,14(r17)
8112457c:	88000415 	stw	zero,16(r17)
81124580:	88000515 	stw	zero,20(r17)
81124584:	88000615 	stw	zero,24(r17)
81124588:	111bb600 	call	8111bb60 <memset>
8112458c:	94000317 	ldw	r16,12(r18)
81124590:	00800484 	movi	r2,18
81124594:	8c400715 	stw	r17,28(r17)
81124598:	8d800815 	stw	r22,32(r17)
8112459c:	8d400915 	stw	r21,36(r17)
811245a0:	8d000a15 	stw	r20,40(r17)
811245a4:	8cc00b15 	stw	r19,44(r17)
811245a8:	8080030d 	sth	r2,12(r16)
811245ac:	00800084 	movi	r2,2
811245b0:	80000015 	stw	zero,0(r16)
811245b4:	80000115 	stw	zero,4(r16)
811245b8:	80000215 	stw	zero,8(r16)
811245bc:	80001915 	stw	zero,100(r16)
811245c0:	8080038d 	sth	r2,14(r16)
811245c4:	80000415 	stw	zero,16(r16)
811245c8:	80000515 	stw	zero,20(r16)
811245cc:	80000615 	stw	zero,24(r16)
811245d0:	b80d883a 	mov	r6,r23
811245d4:	000b883a 	mov	r5,zero
811245d8:	81001704 	addi	r4,r16,92
811245dc:	111bb600 	call	8111bb60 <memset>
811245e0:	00800044 	movi	r2,1
811245e4:	84000715 	stw	r16,28(r16)
811245e8:	85800815 	stw	r22,32(r16)
811245ec:	85400915 	stw	r21,36(r16)
811245f0:	85000a15 	stw	r20,40(r16)
811245f4:	84c00b15 	stw	r19,44(r16)
811245f8:	90800e15 	stw	r2,56(r18)
811245fc:	dfc00817 	ldw	ra,32(sp)
81124600:	ddc00717 	ldw	r23,28(sp)
81124604:	dd800617 	ldw	r22,24(sp)
81124608:	dd400517 	ldw	r21,20(sp)
8112460c:	dd000417 	ldw	r20,16(sp)
81124610:	dcc00317 	ldw	r19,12(sp)
81124614:	dc800217 	ldw	r18,8(sp)
81124618:	dc400117 	ldw	r17,4(sp)
8112461c:	dc000017 	ldw	r16,0(sp)
81124620:	dec00904 	addi	sp,sp,36
81124624:	f800283a 	ret

81124628 <__fp_lock>:
81124628:	0005883a 	mov	r2,zero
8112462c:	f800283a 	ret

81124630 <__sfmoreglue>:
81124630:	defffc04 	addi	sp,sp,-16
81124634:	de00012e 	bgeu	sp,et,8112463c <__sfmoreglue+0xc>
81124638:	003b68fa 	trap	3
8112463c:	dc400115 	stw	r17,4(sp)
81124640:	2c7fffc4 	addi	r17,r5,-1
81124644:	8c401a24 	muli	r17,r17,104
81124648:	dc800215 	stw	r18,8(sp)
8112464c:	2825883a 	mov	r18,r5
81124650:	89401d04 	addi	r5,r17,116
81124654:	dc000015 	stw	r16,0(sp)
81124658:	dfc00315 	stw	ra,12(sp)
8112465c:	111b1fc0 	call	8111b1fc <_malloc_r>
81124660:	1021883a 	mov	r16,r2
81124664:	10000726 	beq	r2,zero,81124684 <__sfmoreglue+0x54>
81124668:	11000304 	addi	r4,r2,12
8112466c:	10000015 	stw	zero,0(r2)
81124670:	14800115 	stw	r18,4(r2)
81124674:	11000215 	stw	r4,8(r2)
81124678:	89801a04 	addi	r6,r17,104
8112467c:	000b883a 	mov	r5,zero
81124680:	111bb600 	call	8111bb60 <memset>
81124684:	8005883a 	mov	r2,r16
81124688:	dfc00317 	ldw	ra,12(sp)
8112468c:	dc800217 	ldw	r18,8(sp)
81124690:	dc400117 	ldw	r17,4(sp)
81124694:	dc000017 	ldw	r16,0(sp)
81124698:	dec00404 	addi	sp,sp,16
8112469c:	f800283a 	ret

811246a0 <__sfp>:
811246a0:	defffb04 	addi	sp,sp,-20
811246a4:	de00012e 	bgeu	sp,et,811246ac <__sfp+0xc>
811246a8:	003b68fa 	trap	3
811246ac:	dc000015 	stw	r16,0(sp)
811246b0:	04204574 	movhi	r16,33045
811246b4:	84308104 	addi	r16,r16,-15868
811246b8:	dcc00315 	stw	r19,12(sp)
811246bc:	2027883a 	mov	r19,r4
811246c0:	81000017 	ldw	r4,0(r16)
811246c4:	dfc00415 	stw	ra,16(sp)
811246c8:	dc800215 	stw	r18,8(sp)
811246cc:	20800e17 	ldw	r2,56(r4)
811246d0:	dc400115 	stw	r17,4(sp)
811246d4:	1000021e 	bne	r2,zero,811246e0 <__sfp+0x40>
811246d8:	11244840 	call	81124484 <__sinit.part.1>
811246dc:	81000017 	ldw	r4,0(r16)
811246e0:	2480b804 	addi	r18,r4,736
811246e4:	047fffc4 	movi	r17,-1
811246e8:	91000117 	ldw	r4,4(r18)
811246ec:	94000217 	ldw	r16,8(r18)
811246f0:	213fffc4 	addi	r4,r4,-1
811246f4:	20000a16 	blt	r4,zero,81124720 <__sfp+0x80>
811246f8:	8080030f 	ldh	r2,12(r16)
811246fc:	10000c26 	beq	r2,zero,81124730 <__sfp+0x90>
81124700:	80c01d04 	addi	r3,r16,116
81124704:	00000206 	br	81124710 <__sfp+0x70>
81124708:	18bfe60f 	ldh	r2,-104(r3)
8112470c:	10000826 	beq	r2,zero,81124730 <__sfp+0x90>
81124710:	213fffc4 	addi	r4,r4,-1
81124714:	1c3ffd04 	addi	r16,r3,-12
81124718:	18c01a04 	addi	r3,r3,104
8112471c:	247ffa1e 	bne	r4,r17,81124708 <__reset+0xfb104708>
81124720:	90800017 	ldw	r2,0(r18)
81124724:	10001d26 	beq	r2,zero,8112479c <__sfp+0xfc>
81124728:	1025883a 	mov	r18,r2
8112472c:	003fee06 	br	811246e8 <__reset+0xfb1046e8>
81124730:	00bfffc4 	movi	r2,-1
81124734:	8080038d 	sth	r2,14(r16)
81124738:	00800044 	movi	r2,1
8112473c:	8080030d 	sth	r2,12(r16)
81124740:	80001915 	stw	zero,100(r16)
81124744:	80000015 	stw	zero,0(r16)
81124748:	80000215 	stw	zero,8(r16)
8112474c:	80000115 	stw	zero,4(r16)
81124750:	80000415 	stw	zero,16(r16)
81124754:	80000515 	stw	zero,20(r16)
81124758:	80000615 	stw	zero,24(r16)
8112475c:	01800204 	movi	r6,8
81124760:	000b883a 	mov	r5,zero
81124764:	81001704 	addi	r4,r16,92
81124768:	111bb600 	call	8111bb60 <memset>
8112476c:	8005883a 	mov	r2,r16
81124770:	80000c15 	stw	zero,48(r16)
81124774:	80000d15 	stw	zero,52(r16)
81124778:	80001115 	stw	zero,68(r16)
8112477c:	80001215 	stw	zero,72(r16)
81124780:	dfc00417 	ldw	ra,16(sp)
81124784:	dcc00317 	ldw	r19,12(sp)
81124788:	dc800217 	ldw	r18,8(sp)
8112478c:	dc400117 	ldw	r17,4(sp)
81124790:	dc000017 	ldw	r16,0(sp)
81124794:	dec00504 	addi	sp,sp,20
81124798:	f800283a 	ret
8112479c:	01400104 	movi	r5,4
811247a0:	9809883a 	mov	r4,r19
811247a4:	11246300 	call	81124630 <__sfmoreglue>
811247a8:	90800015 	stw	r2,0(r18)
811247ac:	103fde1e 	bne	r2,zero,81124728 <__reset+0xfb104728>
811247b0:	00800304 	movi	r2,12
811247b4:	98800015 	stw	r2,0(r19)
811247b8:	0005883a 	mov	r2,zero
811247bc:	003ff006 	br	81124780 <__reset+0xfb104780>

811247c0 <_cleanup>:
811247c0:	00a04574 	movhi	r2,33045
811247c4:	10b08104 	addi	r2,r2,-15868
811247c8:	11000017 	ldw	r4,0(r2)
811247cc:	016044f4 	movhi	r5,33043
811247d0:	29708d04 	addi	r5,r5,-15820
811247d4:	11255181 	jmpi	81125518 <_fwalk_reent>

811247d8 <__sinit>:
811247d8:	20800e17 	ldw	r2,56(r4)
811247dc:	10000126 	beq	r2,zero,811247e4 <__sinit+0xc>
811247e0:	f800283a 	ret
811247e4:	11244841 	jmpi	81124484 <__sinit.part.1>

811247e8 <__sfp_lock_acquire>:
811247e8:	f800283a 	ret

811247ec <__sfp_lock_release>:
811247ec:	f800283a 	ret

811247f0 <__sinit_lock_acquire>:
811247f0:	f800283a 	ret

811247f4 <__sinit_lock_release>:
811247f4:	f800283a 	ret

811247f8 <__fp_lock_all>:
811247f8:	00a04574 	movhi	r2,33045
811247fc:	10b08204 	addi	r2,r2,-15864
81124800:	11000017 	ldw	r4,0(r2)
81124804:	016044b4 	movhi	r5,33042
81124808:	29518a04 	addi	r5,r5,17960
8112480c:	112544c1 	jmpi	8112544c <_fwalk>

81124810 <__fp_unlock_all>:
81124810:	00a04574 	movhi	r2,33045
81124814:	10b08204 	addi	r2,r2,-15864
81124818:	11000017 	ldw	r4,0(r2)
8112481c:	016044b4 	movhi	r5,33042
81124820:	29511c04 	addi	r5,r5,17520
81124824:	112544c1 	jmpi	8112544c <_fwalk>

81124828 <__sflags>:
81124828:	28800007 	ldb	r2,0(r5)
8112482c:	00c01c84 	movi	r3,114
81124830:	10c02426 	beq	r2,r3,811248c4 <__sflags+0x9c>
81124834:	00c01dc4 	movi	r3,119
81124838:	10c01e26 	beq	r2,r3,811248b4 <__sflags+0x8c>
8112483c:	00c01844 	movi	r3,97
81124840:	10c00426 	beq	r2,r3,81124854 <__sflags+0x2c>
81124844:	00800584 	movi	r2,22
81124848:	20800015 	stw	r2,0(r4)
8112484c:	0005883a 	mov	r2,zero
81124850:	f800283a 	ret
81124854:	02c08204 	movi	r11,520
81124858:	01000044 	movi	r4,1
8112485c:	00804204 	movi	r2,264
81124860:	01c00ac4 	movi	r7,43
81124864:	02bff8c4 	movi	r10,-29
81124868:	027fff04 	movi	r9,-4
8112486c:	02001e04 	movi	r8,120
81124870:	29400044 	addi	r5,r5,1
81124874:	28c00007 	ldb	r3,0(r5)
81124878:	18000626 	beq	r3,zero,81124894 <__sflags+0x6c>
8112487c:	19c00826 	beq	r3,r7,811248a0 <__sflags+0x78>
81124880:	1a3ffb1e 	bne	r3,r8,81124870 <__reset+0xfb104870>
81124884:	29400044 	addi	r5,r5,1
81124888:	28c00007 	ldb	r3,0(r5)
8112488c:	21020014 	ori	r4,r4,2048
81124890:	183ffa1e 	bne	r3,zero,8112487c <__reset+0xfb10487c>
81124894:	22c8b03a 	or	r4,r4,r11
81124898:	31000015 	stw	r4,0(r6)
8112489c:	f800283a 	ret
811248a0:	1284703a 	and	r2,r2,r10
811248a4:	2248703a 	and	r4,r4,r9
811248a8:	10800414 	ori	r2,r2,16
811248ac:	21000094 	ori	r4,r4,2
811248b0:	003fef06 	br	81124870 <__reset+0xfb104870>
811248b4:	02c18004 	movi	r11,1536
811248b8:	01000044 	movi	r4,1
811248bc:	00800204 	movi	r2,8
811248c0:	003fe706 	br	81124860 <__reset+0xfb104860>
811248c4:	0017883a 	mov	r11,zero
811248c8:	0009883a 	mov	r4,zero
811248cc:	00800104 	movi	r2,4
811248d0:	003fe306 	br	81124860 <__reset+0xfb104860>

811248d4 <_fread_r>:
811248d4:	defff404 	addi	sp,sp,-48
811248d8:	de00012e 	bgeu	sp,et,811248e0 <_fread_r+0xc>
811248dc:	003b68fa 	trap	3
811248e0:	dd800815 	stw	r22,32(sp)
811248e4:	39ad383a 	mul	r22,r7,r6
811248e8:	dc000215 	stw	r16,8(sp)
811248ec:	dfc00b15 	stw	ra,44(sp)
811248f0:	df000a15 	stw	fp,40(sp)
811248f4:	ddc00915 	stw	r23,36(sp)
811248f8:	dd400715 	stw	r21,28(sp)
811248fc:	dd000615 	stw	r20,24(sp)
81124900:	dcc00515 	stw	r19,20(sp)
81124904:	dc800415 	stw	r18,16(sp)
81124908:	dc400315 	stw	r17,12(sp)
8112490c:	dc000c17 	ldw	r16,48(sp)
81124910:	b0003b26 	beq	r22,zero,81124a00 <_fread_r+0x12c>
81124914:	302f883a 	mov	r23,r6
81124918:	382b883a 	mov	r21,r7
8112491c:	2029883a 	mov	r20,r4
81124920:	2827883a 	mov	r19,r5
81124924:	20000226 	beq	r4,zero,81124930 <_fread_r+0x5c>
81124928:	20800e17 	ldw	r2,56(r4)
8112492c:	10006e26 	beq	r2,zero,81124ae8 <_fread_r+0x214>
81124930:	8080030b 	ldhu	r2,12(r16)
81124934:	10c8000c 	andi	r3,r2,8192
81124938:	1800061e 	bne	r3,zero,81124954 <_fread_r+0x80>
8112493c:	81001917 	ldw	r4,100(r16)
81124940:	00f7ffc4 	movi	r3,-8193
81124944:	10880014 	ori	r2,r2,8192
81124948:	20c6703a 	and	r3,r4,r3
8112494c:	8080030d 	sth	r2,12(r16)
81124950:	80c01915 	stw	r3,100(r16)
81124954:	84400117 	ldw	r17,4(r16)
81124958:	88005f16 	blt	r17,zero,81124ad8 <_fread_r+0x204>
8112495c:	8809883a 	mov	r4,r17
81124960:	1080008c 	andi	r2,r2,2
81124964:	1000281e 	bne	r2,zero,81124a08 <_fread_r+0x134>
81124968:	b025883a 	mov	r18,r22
8112496c:	00000b06 	br	8112499c <_fread_r+0xc8>
81124970:	111ba100 	call	8111ba10 <memcpy>
81124974:	80800017 	ldw	r2,0(r16)
81124978:	9c67883a 	add	r19,r19,r17
8112497c:	9465c83a 	sub	r18,r18,r17
81124980:	1463883a 	add	r17,r2,r17
81124984:	800b883a 	mov	r5,r16
81124988:	a009883a 	mov	r4,r20
8112498c:	84400015 	stw	r17,0(r16)
81124990:	111bfdc0 	call	8111bfdc <__srefill_r>
81124994:	10004c1e 	bne	r2,zero,81124ac8 <_fread_r+0x1f4>
81124998:	84400117 	ldw	r17,4(r16)
8112499c:	880d883a 	mov	r6,r17
811249a0:	9809883a 	mov	r4,r19
811249a4:	81400017 	ldw	r5,0(r16)
811249a8:	8cbff136 	bltu	r17,r18,81124970 <__reset+0xfb104970>
811249ac:	900d883a 	mov	r6,r18
811249b0:	111ba100 	call	8111ba10 <memcpy>
811249b4:	80c00117 	ldw	r3,4(r16)
811249b8:	81000017 	ldw	r4,0(r16)
811249bc:	a805883a 	mov	r2,r21
811249c0:	1c87c83a 	sub	r3,r3,r18
811249c4:	24a5883a 	add	r18,r4,r18
811249c8:	80c00115 	stw	r3,4(r16)
811249cc:	84800015 	stw	r18,0(r16)
811249d0:	dfc00b17 	ldw	ra,44(sp)
811249d4:	df000a17 	ldw	fp,40(sp)
811249d8:	ddc00917 	ldw	r23,36(sp)
811249dc:	dd800817 	ldw	r22,32(sp)
811249e0:	dd400717 	ldw	r21,28(sp)
811249e4:	dd000617 	ldw	r20,24(sp)
811249e8:	dcc00517 	ldw	r19,20(sp)
811249ec:	dc800417 	ldw	r18,16(sp)
811249f0:	dc400317 	ldw	r17,12(sp)
811249f4:	dc000217 	ldw	r16,8(sp)
811249f8:	dec00c04 	addi	sp,sp,48
811249fc:	f800283a 	ret
81124a00:	0005883a 	mov	r2,zero
81124a04:	003ff206 	br	811249d0 <__reset+0xfb1049d0>
81124a08:	b007883a 	mov	r3,r22
81124a0c:	2580012e 	bgeu	r4,r22,81124a14 <_fread_r+0x140>
81124a10:	2007883a 	mov	r3,r4
81124a14:	81400017 	ldw	r5,0(r16)
81124a18:	180d883a 	mov	r6,r3
81124a1c:	9809883a 	mov	r4,r19
81124a20:	d8c00115 	stw	r3,4(sp)
81124a24:	111ba100 	call	8111ba10 <memcpy>
81124a28:	d8c00117 	ldw	r3,4(sp)
81124a2c:	84400017 	ldw	r17,0(r16)
81124a30:	80800117 	ldw	r2,4(r16)
81124a34:	81400c17 	ldw	r5,48(r16)
81124a38:	88e3883a 	add	r17,r17,r3
81124a3c:	10c5c83a 	sub	r2,r2,r3
81124a40:	84400015 	stw	r17,0(r16)
81124a44:	80800115 	stw	r2,4(r16)
81124a48:	b0e5c83a 	sub	r18,r22,r3
81124a4c:	28002b26 	beq	r5,zero,81124afc <_fread_r+0x228>
81124a50:	90002b26 	beq	r18,zero,81124b00 <_fread_r+0x22c>
81124a54:	80801004 	addi	r2,r16,64
81124a58:	28800526 	beq	r5,r2,81124a70 <_fread_r+0x19c>
81124a5c:	a009883a 	mov	r4,r20
81124a60:	d8c00115 	stw	r3,4(sp)
81124a64:	1124c700 	call	81124c70 <_free_r>
81124a68:	d8c00117 	ldw	r3,4(sp)
81124a6c:	84400017 	ldw	r17,0(r16)
81124a70:	80000c15 	stw	zero,48(r16)
81124a74:	80800517 	ldw	r2,20(r16)
81124a78:	87000417 	ldw	fp,16(r16)
81124a7c:	98e7883a 	add	r19,r19,r3
81124a80:	d8800015 	stw	r2,0(sp)
81124a84:	00000106 	br	81124a8c <_fread_r+0x1b8>
81124a88:	90001d26 	beq	r18,zero,81124b00 <_fread_r+0x22c>
81124a8c:	84c00415 	stw	r19,16(r16)
81124a90:	84800515 	stw	r18,20(r16)
81124a94:	84c00015 	stw	r19,0(r16)
81124a98:	a009883a 	mov	r4,r20
81124a9c:	800b883a 	mov	r5,r16
81124aa0:	111bfdc0 	call	8111bfdc <__srefill_r>
81124aa4:	d9000017 	ldw	r4,0(sp)
81124aa8:	80c00117 	ldw	r3,4(r16)
81124aac:	87000415 	stw	fp,16(r16)
81124ab0:	81000515 	stw	r4,20(r16)
81124ab4:	84400015 	stw	r17,0(r16)
81124ab8:	80000115 	stw	zero,4(r16)
81124abc:	90e5c83a 	sub	r18,r18,r3
81124ac0:	98e7883a 	add	r19,r19,r3
81124ac4:	103ff026 	beq	r2,zero,81124a88 <__reset+0xfb104a88>
81124ac8:	b80b883a 	mov	r5,r23
81124acc:	b489c83a 	sub	r4,r22,r18
81124ad0:	112dff80 	call	8112dff8 <__udivsi3>
81124ad4:	003fbe06 	br	811249d0 <__reset+0xfb1049d0>
81124ad8:	80000115 	stw	zero,4(r16)
81124adc:	0009883a 	mov	r4,zero
81124ae0:	0023883a 	mov	r17,zero
81124ae4:	003f9e06 	br	81124960 <__reset+0xfb104960>
81124ae8:	11247d80 	call	811247d8 <__sinit>
81124aec:	8080030b 	ldhu	r2,12(r16)
81124af0:	10c8000c 	andi	r3,r2,8192
81124af4:	183f971e 	bne	r3,zero,81124954 <__reset+0xfb104954>
81124af8:	003f9006 	br	8112493c <__reset+0xfb10493c>
81124afc:	903fdd1e 	bne	r18,zero,81124a74 <__reset+0xfb104a74>
81124b00:	a805883a 	mov	r2,r21
81124b04:	003fb206 	br	811249d0 <__reset+0xfb1049d0>

81124b08 <fread>:
81124b08:	defffe04 	addi	sp,sp,-8
81124b0c:	00a04574 	movhi	r2,33045
81124b10:	de00012e 	bgeu	sp,et,81124b18 <fread+0x10>
81124b14:	003b68fa 	trap	3
81124b18:	10b08204 	addi	r2,r2,-15864
81124b1c:	d9c00015 	stw	r7,0(sp)
81124b20:	300f883a 	mov	r7,r6
81124b24:	280d883a 	mov	r6,r5
81124b28:	200b883a 	mov	r5,r4
81124b2c:	11000017 	ldw	r4,0(r2)
81124b30:	dfc00115 	stw	ra,4(sp)
81124b34:	11248d40 	call	811248d4 <_fread_r>
81124b38:	dfc00117 	ldw	ra,4(sp)
81124b3c:	dec00204 	addi	sp,sp,8
81124b40:	f800283a 	ret

81124b44 <_malloc_trim_r>:
81124b44:	defffb04 	addi	sp,sp,-20
81124b48:	de00012e 	bgeu	sp,et,81124b50 <_malloc_trim_r+0xc>
81124b4c:	003b68fa 	trap	3
81124b50:	dcc00315 	stw	r19,12(sp)
81124b54:	04e04574 	movhi	r19,33045
81124b58:	dc800215 	stw	r18,8(sp)
81124b5c:	dc400115 	stw	r17,4(sp)
81124b60:	dc000015 	stw	r16,0(sp)
81124b64:	dfc00415 	stw	ra,16(sp)
81124b68:	2821883a 	mov	r16,r5
81124b6c:	9cea4004 	addi	r19,r19,-22272
81124b70:	2025883a 	mov	r18,r4
81124b74:	1131ff80 	call	81131ff8 <__malloc_lock>
81124b78:	98800217 	ldw	r2,8(r19)
81124b7c:	14400117 	ldw	r17,4(r2)
81124b80:	00bfff04 	movi	r2,-4
81124b84:	88a2703a 	and	r17,r17,r2
81124b88:	8c21c83a 	sub	r16,r17,r16
81124b8c:	8403fbc4 	addi	r16,r16,4079
81124b90:	8020d33a 	srli	r16,r16,12
81124b94:	0083ffc4 	movi	r2,4095
81124b98:	843fffc4 	addi	r16,r16,-1
81124b9c:	8020933a 	slli	r16,r16,12
81124ba0:	1400060e 	bge	r2,r16,81124bbc <_malloc_trim_r+0x78>
81124ba4:	000b883a 	mov	r5,zero
81124ba8:	9009883a 	mov	r4,r18
81124bac:	111c1b80 	call	8111c1b8 <_sbrk_r>
81124bb0:	98c00217 	ldw	r3,8(r19)
81124bb4:	1c47883a 	add	r3,r3,r17
81124bb8:	10c00a26 	beq	r2,r3,81124be4 <_malloc_trim_r+0xa0>
81124bbc:	9009883a 	mov	r4,r18
81124bc0:	11321200 	call	81132120 <__malloc_unlock>
81124bc4:	0005883a 	mov	r2,zero
81124bc8:	dfc00417 	ldw	ra,16(sp)
81124bcc:	dcc00317 	ldw	r19,12(sp)
81124bd0:	dc800217 	ldw	r18,8(sp)
81124bd4:	dc400117 	ldw	r17,4(sp)
81124bd8:	dc000017 	ldw	r16,0(sp)
81124bdc:	dec00504 	addi	sp,sp,20
81124be0:	f800283a 	ret
81124be4:	040bc83a 	sub	r5,zero,r16
81124be8:	9009883a 	mov	r4,r18
81124bec:	111c1b80 	call	8111c1b8 <_sbrk_r>
81124bf0:	00ffffc4 	movi	r3,-1
81124bf4:	10c00d26 	beq	r2,r3,81124c2c <_malloc_trim_r+0xe8>
81124bf8:	00e04574 	movhi	r3,33045
81124bfc:	18f19f04 	addi	r3,r3,-14724
81124c00:	18800017 	ldw	r2,0(r3)
81124c04:	99000217 	ldw	r4,8(r19)
81124c08:	8c23c83a 	sub	r17,r17,r16
81124c0c:	8c400054 	ori	r17,r17,1
81124c10:	1421c83a 	sub	r16,r2,r16
81124c14:	24400115 	stw	r17,4(r4)
81124c18:	9009883a 	mov	r4,r18
81124c1c:	1c000015 	stw	r16,0(r3)
81124c20:	11321200 	call	81132120 <__malloc_unlock>
81124c24:	00800044 	movi	r2,1
81124c28:	003fe706 	br	81124bc8 <__reset+0xfb104bc8>
81124c2c:	000b883a 	mov	r5,zero
81124c30:	9009883a 	mov	r4,r18
81124c34:	111c1b80 	call	8111c1b8 <_sbrk_r>
81124c38:	99000217 	ldw	r4,8(r19)
81124c3c:	014003c4 	movi	r5,15
81124c40:	1107c83a 	sub	r3,r2,r4
81124c44:	28ffdd0e 	bge	r5,r3,81124bbc <__reset+0xfb104bbc>
81124c48:	01604574 	movhi	r5,33045
81124c4c:	29708304 	addi	r5,r5,-15860
81124c50:	29400017 	ldw	r5,0(r5)
81124c54:	18c00054 	ori	r3,r3,1
81124c58:	20c00115 	stw	r3,4(r4)
81124c5c:	00e04574 	movhi	r3,33045
81124c60:	1145c83a 	sub	r2,r2,r5
81124c64:	18f19f04 	addi	r3,r3,-14724
81124c68:	18800015 	stw	r2,0(r3)
81124c6c:	003fd306 	br	81124bbc <__reset+0xfb104bbc>

81124c70 <_free_r>:
81124c70:	28004326 	beq	r5,zero,81124d80 <_free_r+0x110>
81124c74:	defffd04 	addi	sp,sp,-12
81124c78:	de00012e 	bgeu	sp,et,81124c80 <_free_r+0x10>
81124c7c:	003b68fa 	trap	3
81124c80:	dc400115 	stw	r17,4(sp)
81124c84:	dc000015 	stw	r16,0(sp)
81124c88:	2023883a 	mov	r17,r4
81124c8c:	2821883a 	mov	r16,r5
81124c90:	dfc00215 	stw	ra,8(sp)
81124c94:	1131ff80 	call	81131ff8 <__malloc_lock>
81124c98:	81ffff17 	ldw	r7,-4(r16)
81124c9c:	00bfff84 	movi	r2,-2
81124ca0:	01204574 	movhi	r4,33045
81124ca4:	81bffe04 	addi	r6,r16,-8
81124ca8:	3884703a 	and	r2,r7,r2
81124cac:	212a4004 	addi	r4,r4,-22272
81124cb0:	308b883a 	add	r5,r6,r2
81124cb4:	2a400117 	ldw	r9,4(r5)
81124cb8:	22000217 	ldw	r8,8(r4)
81124cbc:	00ffff04 	movi	r3,-4
81124cc0:	48c6703a 	and	r3,r9,r3
81124cc4:	2a005726 	beq	r5,r8,81124e24 <_free_r+0x1b4>
81124cc8:	28c00115 	stw	r3,4(r5)
81124ccc:	39c0004c 	andi	r7,r7,1
81124cd0:	3800091e 	bne	r7,zero,81124cf8 <_free_r+0x88>
81124cd4:	823ffe17 	ldw	r8,-8(r16)
81124cd8:	22400204 	addi	r9,r4,8
81124cdc:	320dc83a 	sub	r6,r6,r8
81124ce0:	31c00217 	ldw	r7,8(r6)
81124ce4:	1205883a 	add	r2,r2,r8
81124ce8:	3a406526 	beq	r7,r9,81124e80 <_free_r+0x210>
81124cec:	32000317 	ldw	r8,12(r6)
81124cf0:	3a000315 	stw	r8,12(r7)
81124cf4:	41c00215 	stw	r7,8(r8)
81124cf8:	28cf883a 	add	r7,r5,r3
81124cfc:	39c00117 	ldw	r7,4(r7)
81124d00:	39c0004c 	andi	r7,r7,1
81124d04:	38003a26 	beq	r7,zero,81124df0 <_free_r+0x180>
81124d08:	10c00054 	ori	r3,r2,1
81124d0c:	30c00115 	stw	r3,4(r6)
81124d10:	3087883a 	add	r3,r6,r2
81124d14:	18800015 	stw	r2,0(r3)
81124d18:	00c07fc4 	movi	r3,511
81124d1c:	18801936 	bltu	r3,r2,81124d84 <_free_r+0x114>
81124d20:	1004d0fa 	srli	r2,r2,3
81124d24:	01c00044 	movi	r7,1
81124d28:	21400117 	ldw	r5,4(r4)
81124d2c:	10c00044 	addi	r3,r2,1
81124d30:	18c7883a 	add	r3,r3,r3
81124d34:	1005d0ba 	srai	r2,r2,2
81124d38:	18c7883a 	add	r3,r3,r3
81124d3c:	18c7883a 	add	r3,r3,r3
81124d40:	1907883a 	add	r3,r3,r4
81124d44:	3884983a 	sll	r2,r7,r2
81124d48:	19c00017 	ldw	r7,0(r3)
81124d4c:	1a3ffe04 	addi	r8,r3,-8
81124d50:	1144b03a 	or	r2,r2,r5
81124d54:	32000315 	stw	r8,12(r6)
81124d58:	31c00215 	stw	r7,8(r6)
81124d5c:	20800115 	stw	r2,4(r4)
81124d60:	19800015 	stw	r6,0(r3)
81124d64:	39800315 	stw	r6,12(r7)
81124d68:	8809883a 	mov	r4,r17
81124d6c:	dfc00217 	ldw	ra,8(sp)
81124d70:	dc400117 	ldw	r17,4(sp)
81124d74:	dc000017 	ldw	r16,0(sp)
81124d78:	dec00304 	addi	sp,sp,12
81124d7c:	11321201 	jmpi	81132120 <__malloc_unlock>
81124d80:	f800283a 	ret
81124d84:	100ad27a 	srli	r5,r2,9
81124d88:	00c00104 	movi	r3,4
81124d8c:	19404a36 	bltu	r3,r5,81124eb8 <_free_r+0x248>
81124d90:	100ad1ba 	srli	r5,r2,6
81124d94:	28c00e44 	addi	r3,r5,57
81124d98:	18c7883a 	add	r3,r3,r3
81124d9c:	29400e04 	addi	r5,r5,56
81124da0:	18c7883a 	add	r3,r3,r3
81124da4:	18c7883a 	add	r3,r3,r3
81124da8:	1909883a 	add	r4,r3,r4
81124dac:	20c00017 	ldw	r3,0(r4)
81124db0:	01e04574 	movhi	r7,33045
81124db4:	213ffe04 	addi	r4,r4,-8
81124db8:	39ea4004 	addi	r7,r7,-22272
81124dbc:	20c04426 	beq	r4,r3,81124ed0 <_free_r+0x260>
81124dc0:	01ffff04 	movi	r7,-4
81124dc4:	19400117 	ldw	r5,4(r3)
81124dc8:	29ca703a 	and	r5,r5,r7
81124dcc:	1140022e 	bgeu	r2,r5,81124dd8 <_free_r+0x168>
81124dd0:	18c00217 	ldw	r3,8(r3)
81124dd4:	20fffb1e 	bne	r4,r3,81124dc4 <__reset+0xfb104dc4>
81124dd8:	19000317 	ldw	r4,12(r3)
81124ddc:	31000315 	stw	r4,12(r6)
81124de0:	30c00215 	stw	r3,8(r6)
81124de4:	21800215 	stw	r6,8(r4)
81124de8:	19800315 	stw	r6,12(r3)
81124dec:	003fde06 	br	81124d68 <__reset+0xfb104d68>
81124df0:	29c00217 	ldw	r7,8(r5)
81124df4:	10c5883a 	add	r2,r2,r3
81124df8:	00e04574 	movhi	r3,33045
81124dfc:	18ea4204 	addi	r3,r3,-22264
81124e00:	38c03b26 	beq	r7,r3,81124ef0 <_free_r+0x280>
81124e04:	2a000317 	ldw	r8,12(r5)
81124e08:	11400054 	ori	r5,r2,1
81124e0c:	3087883a 	add	r3,r6,r2
81124e10:	3a000315 	stw	r8,12(r7)
81124e14:	41c00215 	stw	r7,8(r8)
81124e18:	31400115 	stw	r5,4(r6)
81124e1c:	18800015 	stw	r2,0(r3)
81124e20:	003fbd06 	br	81124d18 <__reset+0xfb104d18>
81124e24:	39c0004c 	andi	r7,r7,1
81124e28:	10c5883a 	add	r2,r2,r3
81124e2c:	3800071e 	bne	r7,zero,81124e4c <_free_r+0x1dc>
81124e30:	81fffe17 	ldw	r7,-8(r16)
81124e34:	31cdc83a 	sub	r6,r6,r7
81124e38:	30c00317 	ldw	r3,12(r6)
81124e3c:	31400217 	ldw	r5,8(r6)
81124e40:	11c5883a 	add	r2,r2,r7
81124e44:	28c00315 	stw	r3,12(r5)
81124e48:	19400215 	stw	r5,8(r3)
81124e4c:	10c00054 	ori	r3,r2,1
81124e50:	30c00115 	stw	r3,4(r6)
81124e54:	00e04574 	movhi	r3,33045
81124e58:	18f08404 	addi	r3,r3,-15856
81124e5c:	18c00017 	ldw	r3,0(r3)
81124e60:	21800215 	stw	r6,8(r4)
81124e64:	10ffc036 	bltu	r2,r3,81124d68 <__reset+0xfb104d68>
81124e68:	00a04574 	movhi	r2,33045
81124e6c:	10b0fd04 	addi	r2,r2,-15372
81124e70:	11400017 	ldw	r5,0(r2)
81124e74:	8809883a 	mov	r4,r17
81124e78:	1124b440 	call	81124b44 <_malloc_trim_r>
81124e7c:	003fba06 	br	81124d68 <__reset+0xfb104d68>
81124e80:	28c9883a 	add	r4,r5,r3
81124e84:	21000117 	ldw	r4,4(r4)
81124e88:	2100004c 	andi	r4,r4,1
81124e8c:	2000391e 	bne	r4,zero,81124f74 <_free_r+0x304>
81124e90:	29c00217 	ldw	r7,8(r5)
81124e94:	29000317 	ldw	r4,12(r5)
81124e98:	1885883a 	add	r2,r3,r2
81124e9c:	10c00054 	ori	r3,r2,1
81124ea0:	39000315 	stw	r4,12(r7)
81124ea4:	21c00215 	stw	r7,8(r4)
81124ea8:	30c00115 	stw	r3,4(r6)
81124eac:	308d883a 	add	r6,r6,r2
81124eb0:	30800015 	stw	r2,0(r6)
81124eb4:	003fac06 	br	81124d68 <__reset+0xfb104d68>
81124eb8:	00c00504 	movi	r3,20
81124ebc:	19401536 	bltu	r3,r5,81124f14 <_free_r+0x2a4>
81124ec0:	28c01704 	addi	r3,r5,92
81124ec4:	18c7883a 	add	r3,r3,r3
81124ec8:	294016c4 	addi	r5,r5,91
81124ecc:	003fb406 	br	81124da0 <__reset+0xfb104da0>
81124ed0:	280bd0ba 	srai	r5,r5,2
81124ed4:	00c00044 	movi	r3,1
81124ed8:	38800117 	ldw	r2,4(r7)
81124edc:	194a983a 	sll	r5,r3,r5
81124ee0:	2007883a 	mov	r3,r4
81124ee4:	2884b03a 	or	r2,r5,r2
81124ee8:	38800115 	stw	r2,4(r7)
81124eec:	003fbb06 	br	81124ddc <__reset+0xfb104ddc>
81124ef0:	21800515 	stw	r6,20(r4)
81124ef4:	21800415 	stw	r6,16(r4)
81124ef8:	10c00054 	ori	r3,r2,1
81124efc:	31c00315 	stw	r7,12(r6)
81124f00:	31c00215 	stw	r7,8(r6)
81124f04:	30c00115 	stw	r3,4(r6)
81124f08:	308d883a 	add	r6,r6,r2
81124f0c:	30800015 	stw	r2,0(r6)
81124f10:	003f9506 	br	81124d68 <__reset+0xfb104d68>
81124f14:	00c01504 	movi	r3,84
81124f18:	19400536 	bltu	r3,r5,81124f30 <_free_r+0x2c0>
81124f1c:	100ad33a 	srli	r5,r2,12
81124f20:	28c01bc4 	addi	r3,r5,111
81124f24:	18c7883a 	add	r3,r3,r3
81124f28:	29401b84 	addi	r5,r5,110
81124f2c:	003f9c06 	br	81124da0 <__reset+0xfb104da0>
81124f30:	00c05504 	movi	r3,340
81124f34:	19400536 	bltu	r3,r5,81124f4c <_free_r+0x2dc>
81124f38:	100ad3fa 	srli	r5,r2,15
81124f3c:	28c01e04 	addi	r3,r5,120
81124f40:	18c7883a 	add	r3,r3,r3
81124f44:	29401dc4 	addi	r5,r5,119
81124f48:	003f9506 	br	81124da0 <__reset+0xfb104da0>
81124f4c:	00c15504 	movi	r3,1364
81124f50:	19400536 	bltu	r3,r5,81124f68 <_free_r+0x2f8>
81124f54:	100ad4ba 	srli	r5,r2,18
81124f58:	28c01f44 	addi	r3,r5,125
81124f5c:	18c7883a 	add	r3,r3,r3
81124f60:	29401f04 	addi	r5,r5,124
81124f64:	003f8e06 	br	81124da0 <__reset+0xfb104da0>
81124f68:	00c03f84 	movi	r3,254
81124f6c:	01401f84 	movi	r5,126
81124f70:	003f8b06 	br	81124da0 <__reset+0xfb104da0>
81124f74:	10c00054 	ori	r3,r2,1
81124f78:	30c00115 	stw	r3,4(r6)
81124f7c:	308d883a 	add	r6,r6,r2
81124f80:	30800015 	stw	r2,0(r6)
81124f84:	003f7806 	br	81124d68 <__reset+0xfb104d68>

81124f88 <__sfvwrite_r>:
81124f88:	30800217 	ldw	r2,8(r6)
81124f8c:	10006926 	beq	r2,zero,81125134 <__sfvwrite_r+0x1ac>
81124f90:	defff404 	addi	sp,sp,-48
81124f94:	de00012e 	bgeu	sp,et,81124f9c <__sfvwrite_r+0x14>
81124f98:	003b68fa 	trap	3
81124f9c:	28c0030b 	ldhu	r3,12(r5)
81124fa0:	dd400715 	stw	r21,28(sp)
81124fa4:	dd000615 	stw	r20,24(sp)
81124fa8:	dc000215 	stw	r16,8(sp)
81124fac:	dfc00b15 	stw	ra,44(sp)
81124fb0:	df000a15 	stw	fp,40(sp)
81124fb4:	ddc00915 	stw	r23,36(sp)
81124fb8:	dd800815 	stw	r22,32(sp)
81124fbc:	dcc00515 	stw	r19,20(sp)
81124fc0:	dc800415 	stw	r18,16(sp)
81124fc4:	dc400315 	stw	r17,12(sp)
81124fc8:	1880020c 	andi	r2,r3,8
81124fcc:	2821883a 	mov	r16,r5
81124fd0:	202b883a 	mov	r21,r4
81124fd4:	3029883a 	mov	r20,r6
81124fd8:	10002726 	beq	r2,zero,81125078 <__sfvwrite_r+0xf0>
81124fdc:	28800417 	ldw	r2,16(r5)
81124fe0:	10002526 	beq	r2,zero,81125078 <__sfvwrite_r+0xf0>
81124fe4:	1880008c 	andi	r2,r3,2
81124fe8:	a4400017 	ldw	r17,0(r20)
81124fec:	10002a26 	beq	r2,zero,81125098 <__sfvwrite_r+0x110>
81124ff0:	05a00034 	movhi	r22,32768
81124ff4:	0027883a 	mov	r19,zero
81124ff8:	0025883a 	mov	r18,zero
81124ffc:	b5bf0004 	addi	r22,r22,-1024
81125000:	980d883a 	mov	r6,r19
81125004:	a809883a 	mov	r4,r21
81125008:	90004626 	beq	r18,zero,81125124 <__sfvwrite_r+0x19c>
8112500c:	900f883a 	mov	r7,r18
81125010:	b480022e 	bgeu	r22,r18,8112501c <__sfvwrite_r+0x94>
81125014:	01e00034 	movhi	r7,32768
81125018:	39ff0004 	addi	r7,r7,-1024
8112501c:	80800917 	ldw	r2,36(r16)
81125020:	81400717 	ldw	r5,28(r16)
81125024:	103ee83a 	callr	r2
81125028:	0080570e 	bge	zero,r2,81125188 <__sfvwrite_r+0x200>
8112502c:	a0c00217 	ldw	r3,8(r20)
81125030:	98a7883a 	add	r19,r19,r2
81125034:	90a5c83a 	sub	r18,r18,r2
81125038:	1885c83a 	sub	r2,r3,r2
8112503c:	a0800215 	stw	r2,8(r20)
81125040:	103fef1e 	bne	r2,zero,81125000 <__reset+0xfb105000>
81125044:	0005883a 	mov	r2,zero
81125048:	dfc00b17 	ldw	ra,44(sp)
8112504c:	df000a17 	ldw	fp,40(sp)
81125050:	ddc00917 	ldw	r23,36(sp)
81125054:	dd800817 	ldw	r22,32(sp)
81125058:	dd400717 	ldw	r21,28(sp)
8112505c:	dd000617 	ldw	r20,24(sp)
81125060:	dcc00517 	ldw	r19,20(sp)
81125064:	dc800417 	ldw	r18,16(sp)
81125068:	dc400317 	ldw	r17,12(sp)
8112506c:	dc000217 	ldw	r16,8(sp)
81125070:	dec00c04 	addi	sp,sp,48
81125074:	f800283a 	ret
81125078:	800b883a 	mov	r5,r16
8112507c:	a809883a 	mov	r4,r21
81125080:	11227680 	call	81122768 <__swsetup_r>
81125084:	1000eb1e 	bne	r2,zero,81125434 <__sfvwrite_r+0x4ac>
81125088:	80c0030b 	ldhu	r3,12(r16)
8112508c:	a4400017 	ldw	r17,0(r20)
81125090:	1880008c 	andi	r2,r3,2
81125094:	103fd61e 	bne	r2,zero,81124ff0 <__reset+0xfb104ff0>
81125098:	1880004c 	andi	r2,r3,1
8112509c:	10003f1e 	bne	r2,zero,8112519c <__sfvwrite_r+0x214>
811250a0:	0039883a 	mov	fp,zero
811250a4:	0025883a 	mov	r18,zero
811250a8:	90001a26 	beq	r18,zero,81125114 <__sfvwrite_r+0x18c>
811250ac:	1880800c 	andi	r2,r3,512
811250b0:	84c00217 	ldw	r19,8(r16)
811250b4:	10002126 	beq	r2,zero,8112513c <__sfvwrite_r+0x1b4>
811250b8:	982f883a 	mov	r23,r19
811250bc:	94c09336 	bltu	r18,r19,8112530c <__sfvwrite_r+0x384>
811250c0:	1881200c 	andi	r2,r3,1152
811250c4:	10009e1e 	bne	r2,zero,81125340 <__sfvwrite_r+0x3b8>
811250c8:	81000017 	ldw	r4,0(r16)
811250cc:	b80d883a 	mov	r6,r23
811250d0:	e00b883a 	mov	r5,fp
811250d4:	1125ae40 	call	81125ae4 <memmove>
811250d8:	80c00217 	ldw	r3,8(r16)
811250dc:	81000017 	ldw	r4,0(r16)
811250e0:	9005883a 	mov	r2,r18
811250e4:	1ce7c83a 	sub	r19,r3,r19
811250e8:	25cf883a 	add	r7,r4,r23
811250ec:	84c00215 	stw	r19,8(r16)
811250f0:	81c00015 	stw	r7,0(r16)
811250f4:	a0c00217 	ldw	r3,8(r20)
811250f8:	e0b9883a 	add	fp,fp,r2
811250fc:	90a5c83a 	sub	r18,r18,r2
81125100:	18a7c83a 	sub	r19,r3,r2
81125104:	a4c00215 	stw	r19,8(r20)
81125108:	983fce26 	beq	r19,zero,81125044 <__reset+0xfb105044>
8112510c:	80c0030b 	ldhu	r3,12(r16)
81125110:	903fe61e 	bne	r18,zero,811250ac <__reset+0xfb1050ac>
81125114:	8f000017 	ldw	fp,0(r17)
81125118:	8c800117 	ldw	r18,4(r17)
8112511c:	8c400204 	addi	r17,r17,8
81125120:	003fe106 	br	811250a8 <__reset+0xfb1050a8>
81125124:	8cc00017 	ldw	r19,0(r17)
81125128:	8c800117 	ldw	r18,4(r17)
8112512c:	8c400204 	addi	r17,r17,8
81125130:	003fb306 	br	81125000 <__reset+0xfb105000>
81125134:	0005883a 	mov	r2,zero
81125138:	f800283a 	ret
8112513c:	81000017 	ldw	r4,0(r16)
81125140:	80800417 	ldw	r2,16(r16)
81125144:	11005736 	bltu	r2,r4,811252a4 <__sfvwrite_r+0x31c>
81125148:	85c00517 	ldw	r23,20(r16)
8112514c:	95c05536 	bltu	r18,r23,811252a4 <__sfvwrite_r+0x31c>
81125150:	00a00034 	movhi	r2,32768
81125154:	10bfffc4 	addi	r2,r2,-1
81125158:	9009883a 	mov	r4,r18
8112515c:	1480012e 	bgeu	r2,r18,81125164 <__sfvwrite_r+0x1dc>
81125160:	1009883a 	mov	r4,r2
81125164:	b80b883a 	mov	r5,r23
81125168:	112df000 	call	8112df00 <__divsi3>
8112516c:	15cf383a 	mul	r7,r2,r23
81125170:	81400717 	ldw	r5,28(r16)
81125174:	80800917 	ldw	r2,36(r16)
81125178:	e00d883a 	mov	r6,fp
8112517c:	a809883a 	mov	r4,r21
81125180:	103ee83a 	callr	r2
81125184:	00bfdb16 	blt	zero,r2,811250f4 <__reset+0xfb1050f4>
81125188:	8080030b 	ldhu	r2,12(r16)
8112518c:	10801014 	ori	r2,r2,64
81125190:	8080030d 	sth	r2,12(r16)
81125194:	00bfffc4 	movi	r2,-1
81125198:	003fab06 	br	81125048 <__reset+0xfb105048>
8112519c:	0027883a 	mov	r19,zero
811251a0:	0011883a 	mov	r8,zero
811251a4:	0039883a 	mov	fp,zero
811251a8:	0025883a 	mov	r18,zero
811251ac:	90001f26 	beq	r18,zero,8112522c <__sfvwrite_r+0x2a4>
811251b0:	40005a26 	beq	r8,zero,8112531c <__sfvwrite_r+0x394>
811251b4:	982d883a 	mov	r22,r19
811251b8:	94c0012e 	bgeu	r18,r19,811251c0 <__sfvwrite_r+0x238>
811251bc:	902d883a 	mov	r22,r18
811251c0:	81000017 	ldw	r4,0(r16)
811251c4:	80800417 	ldw	r2,16(r16)
811251c8:	b02f883a 	mov	r23,r22
811251cc:	81c00517 	ldw	r7,20(r16)
811251d0:	1100032e 	bgeu	r2,r4,811251e0 <__sfvwrite_r+0x258>
811251d4:	80c00217 	ldw	r3,8(r16)
811251d8:	38c7883a 	add	r3,r7,r3
811251dc:	1d801816 	blt	r3,r22,81125240 <__sfvwrite_r+0x2b8>
811251e0:	b1c03e16 	blt	r22,r7,811252dc <__sfvwrite_r+0x354>
811251e4:	80800917 	ldw	r2,36(r16)
811251e8:	81400717 	ldw	r5,28(r16)
811251ec:	e00d883a 	mov	r6,fp
811251f0:	da000115 	stw	r8,4(sp)
811251f4:	a809883a 	mov	r4,r21
811251f8:	103ee83a 	callr	r2
811251fc:	102f883a 	mov	r23,r2
81125200:	da000117 	ldw	r8,4(sp)
81125204:	00bfe00e 	bge	zero,r2,81125188 <__reset+0xfb105188>
81125208:	9de7c83a 	sub	r19,r19,r23
8112520c:	98001f26 	beq	r19,zero,8112528c <__sfvwrite_r+0x304>
81125210:	a0800217 	ldw	r2,8(r20)
81125214:	e5f9883a 	add	fp,fp,r23
81125218:	95e5c83a 	sub	r18,r18,r23
8112521c:	15efc83a 	sub	r23,r2,r23
81125220:	a5c00215 	stw	r23,8(r20)
81125224:	b83f8726 	beq	r23,zero,81125044 <__reset+0xfb105044>
81125228:	903fe11e 	bne	r18,zero,811251b0 <__reset+0xfb1051b0>
8112522c:	8f000017 	ldw	fp,0(r17)
81125230:	8c800117 	ldw	r18,4(r17)
81125234:	0011883a 	mov	r8,zero
81125238:	8c400204 	addi	r17,r17,8
8112523c:	003fdb06 	br	811251ac <__reset+0xfb1051ac>
81125240:	180d883a 	mov	r6,r3
81125244:	e00b883a 	mov	r5,fp
81125248:	da000115 	stw	r8,4(sp)
8112524c:	d8c00015 	stw	r3,0(sp)
81125250:	1125ae40 	call	81125ae4 <memmove>
81125254:	d8c00017 	ldw	r3,0(sp)
81125258:	80800017 	ldw	r2,0(r16)
8112525c:	800b883a 	mov	r5,r16
81125260:	a809883a 	mov	r4,r21
81125264:	10c5883a 	add	r2,r2,r3
81125268:	80800015 	stw	r2,0(r16)
8112526c:	d8c00015 	stw	r3,0(sp)
81125270:	11243dc0 	call	811243dc <_fflush_r>
81125274:	d8c00017 	ldw	r3,0(sp)
81125278:	da000117 	ldw	r8,4(sp)
8112527c:	103fc21e 	bne	r2,zero,81125188 <__reset+0xfb105188>
81125280:	182f883a 	mov	r23,r3
81125284:	9de7c83a 	sub	r19,r19,r23
81125288:	983fe11e 	bne	r19,zero,81125210 <__reset+0xfb105210>
8112528c:	800b883a 	mov	r5,r16
81125290:	a809883a 	mov	r4,r21
81125294:	11243dc0 	call	811243dc <_fflush_r>
81125298:	103fbb1e 	bne	r2,zero,81125188 <__reset+0xfb105188>
8112529c:	0011883a 	mov	r8,zero
811252a0:	003fdb06 	br	81125210 <__reset+0xfb105210>
811252a4:	94c0012e 	bgeu	r18,r19,811252ac <__sfvwrite_r+0x324>
811252a8:	9027883a 	mov	r19,r18
811252ac:	980d883a 	mov	r6,r19
811252b0:	e00b883a 	mov	r5,fp
811252b4:	1125ae40 	call	81125ae4 <memmove>
811252b8:	80800217 	ldw	r2,8(r16)
811252bc:	80c00017 	ldw	r3,0(r16)
811252c0:	14c5c83a 	sub	r2,r2,r19
811252c4:	1cc7883a 	add	r3,r3,r19
811252c8:	80800215 	stw	r2,8(r16)
811252cc:	80c00015 	stw	r3,0(r16)
811252d0:	10004326 	beq	r2,zero,811253e0 <__sfvwrite_r+0x458>
811252d4:	9805883a 	mov	r2,r19
811252d8:	003f8606 	br	811250f4 <__reset+0xfb1050f4>
811252dc:	b00d883a 	mov	r6,r22
811252e0:	e00b883a 	mov	r5,fp
811252e4:	da000115 	stw	r8,4(sp)
811252e8:	1125ae40 	call	81125ae4 <memmove>
811252ec:	80800217 	ldw	r2,8(r16)
811252f0:	80c00017 	ldw	r3,0(r16)
811252f4:	da000117 	ldw	r8,4(sp)
811252f8:	1585c83a 	sub	r2,r2,r22
811252fc:	1dad883a 	add	r22,r3,r22
81125300:	80800215 	stw	r2,8(r16)
81125304:	85800015 	stw	r22,0(r16)
81125308:	003fbf06 	br	81125208 <__reset+0xfb105208>
8112530c:	81000017 	ldw	r4,0(r16)
81125310:	9027883a 	mov	r19,r18
81125314:	902f883a 	mov	r23,r18
81125318:	003f6c06 	br	811250cc <__reset+0xfb1050cc>
8112531c:	900d883a 	mov	r6,r18
81125320:	01400284 	movi	r5,10
81125324:	e009883a 	mov	r4,fp
81125328:	1125a000 	call	81125a00 <memchr>
8112532c:	10003e26 	beq	r2,zero,81125428 <__sfvwrite_r+0x4a0>
81125330:	10800044 	addi	r2,r2,1
81125334:	1727c83a 	sub	r19,r2,fp
81125338:	02000044 	movi	r8,1
8112533c:	003f9d06 	br	811251b4 <__reset+0xfb1051b4>
81125340:	80800517 	ldw	r2,20(r16)
81125344:	81400417 	ldw	r5,16(r16)
81125348:	81c00017 	ldw	r7,0(r16)
8112534c:	10a7883a 	add	r19,r2,r2
81125350:	9885883a 	add	r2,r19,r2
81125354:	1026d7fa 	srli	r19,r2,31
81125358:	396dc83a 	sub	r22,r7,r5
8112535c:	b1000044 	addi	r4,r22,1
81125360:	9885883a 	add	r2,r19,r2
81125364:	1027d07a 	srai	r19,r2,1
81125368:	2485883a 	add	r2,r4,r18
8112536c:	980d883a 	mov	r6,r19
81125370:	9880022e 	bgeu	r19,r2,8112537c <__sfvwrite_r+0x3f4>
81125374:	1027883a 	mov	r19,r2
81125378:	100d883a 	mov	r6,r2
8112537c:	18c1000c 	andi	r3,r3,1024
81125380:	18001c26 	beq	r3,zero,811253f4 <__sfvwrite_r+0x46c>
81125384:	300b883a 	mov	r5,r6
81125388:	a809883a 	mov	r4,r21
8112538c:	111b1fc0 	call	8111b1fc <_malloc_r>
81125390:	102f883a 	mov	r23,r2
81125394:	10002926 	beq	r2,zero,8112543c <__sfvwrite_r+0x4b4>
81125398:	81400417 	ldw	r5,16(r16)
8112539c:	b00d883a 	mov	r6,r22
811253a0:	1009883a 	mov	r4,r2
811253a4:	111ba100 	call	8111ba10 <memcpy>
811253a8:	8080030b 	ldhu	r2,12(r16)
811253ac:	00fedfc4 	movi	r3,-1153
811253b0:	10c4703a 	and	r2,r2,r3
811253b4:	10802014 	ori	r2,r2,128
811253b8:	8080030d 	sth	r2,12(r16)
811253bc:	bd89883a 	add	r4,r23,r22
811253c0:	9d8fc83a 	sub	r7,r19,r22
811253c4:	85c00415 	stw	r23,16(r16)
811253c8:	84c00515 	stw	r19,20(r16)
811253cc:	81000015 	stw	r4,0(r16)
811253d0:	9027883a 	mov	r19,r18
811253d4:	81c00215 	stw	r7,8(r16)
811253d8:	902f883a 	mov	r23,r18
811253dc:	003f3b06 	br	811250cc <__reset+0xfb1050cc>
811253e0:	800b883a 	mov	r5,r16
811253e4:	a809883a 	mov	r4,r21
811253e8:	11243dc0 	call	811243dc <_fflush_r>
811253ec:	103fb926 	beq	r2,zero,811252d4 <__reset+0xfb1052d4>
811253f0:	003f6506 	br	81125188 <__reset+0xfb105188>
811253f4:	a809883a 	mov	r4,r21
811253f8:	1126d040 	call	81126d04 <_realloc_r>
811253fc:	102f883a 	mov	r23,r2
81125400:	103fee1e 	bne	r2,zero,811253bc <__reset+0xfb1053bc>
81125404:	81400417 	ldw	r5,16(r16)
81125408:	a809883a 	mov	r4,r21
8112540c:	1124c700 	call	81124c70 <_free_r>
81125410:	8080030b 	ldhu	r2,12(r16)
81125414:	00ffdfc4 	movi	r3,-129
81125418:	1884703a 	and	r2,r3,r2
8112541c:	00c00304 	movi	r3,12
81125420:	a8c00015 	stw	r3,0(r21)
81125424:	003f5906 	br	8112518c <__reset+0xfb10518c>
81125428:	94c00044 	addi	r19,r18,1
8112542c:	02000044 	movi	r8,1
81125430:	003f6006 	br	811251b4 <__reset+0xfb1051b4>
81125434:	00bfffc4 	movi	r2,-1
81125438:	003f0306 	br	81125048 <__reset+0xfb105048>
8112543c:	00800304 	movi	r2,12
81125440:	a8800015 	stw	r2,0(r21)
81125444:	8080030b 	ldhu	r2,12(r16)
81125448:	003f5006 	br	8112518c <__reset+0xfb10518c>

8112544c <_fwalk>:
8112544c:	defff704 	addi	sp,sp,-36
81125450:	de00012e 	bgeu	sp,et,81125458 <_fwalk+0xc>
81125454:	003b68fa 	trap	3
81125458:	dd000415 	stw	r20,16(sp)
8112545c:	dfc00815 	stw	ra,32(sp)
81125460:	ddc00715 	stw	r23,28(sp)
81125464:	dd800615 	stw	r22,24(sp)
81125468:	dd400515 	stw	r21,20(sp)
8112546c:	dcc00315 	stw	r19,12(sp)
81125470:	dc800215 	stw	r18,8(sp)
81125474:	dc400115 	stw	r17,4(sp)
81125478:	dc000015 	stw	r16,0(sp)
8112547c:	2500b804 	addi	r20,r4,736
81125480:	a0002326 	beq	r20,zero,81125510 <_fwalk+0xc4>
81125484:	282b883a 	mov	r21,r5
81125488:	002f883a 	mov	r23,zero
8112548c:	05800044 	movi	r22,1
81125490:	04ffffc4 	movi	r19,-1
81125494:	a4400117 	ldw	r17,4(r20)
81125498:	a4800217 	ldw	r18,8(r20)
8112549c:	8c7fffc4 	addi	r17,r17,-1
811254a0:	88000d16 	blt	r17,zero,811254d8 <_fwalk+0x8c>
811254a4:	94000304 	addi	r16,r18,12
811254a8:	94800384 	addi	r18,r18,14
811254ac:	8080000b 	ldhu	r2,0(r16)
811254b0:	8c7fffc4 	addi	r17,r17,-1
811254b4:	813ffd04 	addi	r4,r16,-12
811254b8:	b080042e 	bgeu	r22,r2,811254cc <_fwalk+0x80>
811254bc:	9080000f 	ldh	r2,0(r18)
811254c0:	14c00226 	beq	r2,r19,811254cc <_fwalk+0x80>
811254c4:	a83ee83a 	callr	r21
811254c8:	b8aeb03a 	or	r23,r23,r2
811254cc:	84001a04 	addi	r16,r16,104
811254d0:	94801a04 	addi	r18,r18,104
811254d4:	8cfff51e 	bne	r17,r19,811254ac <__reset+0xfb1054ac>
811254d8:	a5000017 	ldw	r20,0(r20)
811254dc:	a03fed1e 	bne	r20,zero,81125494 <__reset+0xfb105494>
811254e0:	b805883a 	mov	r2,r23
811254e4:	dfc00817 	ldw	ra,32(sp)
811254e8:	ddc00717 	ldw	r23,28(sp)
811254ec:	dd800617 	ldw	r22,24(sp)
811254f0:	dd400517 	ldw	r21,20(sp)
811254f4:	dd000417 	ldw	r20,16(sp)
811254f8:	dcc00317 	ldw	r19,12(sp)
811254fc:	dc800217 	ldw	r18,8(sp)
81125500:	dc400117 	ldw	r17,4(sp)
81125504:	dc000017 	ldw	r16,0(sp)
81125508:	dec00904 	addi	sp,sp,36
8112550c:	f800283a 	ret
81125510:	002f883a 	mov	r23,zero
81125514:	003ff206 	br	811254e0 <__reset+0xfb1054e0>

81125518 <_fwalk_reent>:
81125518:	defff704 	addi	sp,sp,-36
8112551c:	de00012e 	bgeu	sp,et,81125524 <_fwalk_reent+0xc>
81125520:	003b68fa 	trap	3
81125524:	dd000415 	stw	r20,16(sp)
81125528:	dfc00815 	stw	ra,32(sp)
8112552c:	ddc00715 	stw	r23,28(sp)
81125530:	dd800615 	stw	r22,24(sp)
81125534:	dd400515 	stw	r21,20(sp)
81125538:	dcc00315 	stw	r19,12(sp)
8112553c:	dc800215 	stw	r18,8(sp)
81125540:	dc400115 	stw	r17,4(sp)
81125544:	dc000015 	stw	r16,0(sp)
81125548:	2500b804 	addi	r20,r4,736
8112554c:	a0002326 	beq	r20,zero,811255dc <_fwalk_reent+0xc4>
81125550:	282b883a 	mov	r21,r5
81125554:	2027883a 	mov	r19,r4
81125558:	002f883a 	mov	r23,zero
8112555c:	05800044 	movi	r22,1
81125560:	04bfffc4 	movi	r18,-1
81125564:	a4400117 	ldw	r17,4(r20)
81125568:	a4000217 	ldw	r16,8(r20)
8112556c:	8c7fffc4 	addi	r17,r17,-1
81125570:	88000c16 	blt	r17,zero,811255a4 <_fwalk_reent+0x8c>
81125574:	84000304 	addi	r16,r16,12
81125578:	8080000b 	ldhu	r2,0(r16)
8112557c:	8c7fffc4 	addi	r17,r17,-1
81125580:	817ffd04 	addi	r5,r16,-12
81125584:	b080052e 	bgeu	r22,r2,8112559c <_fwalk_reent+0x84>
81125588:	8080008f 	ldh	r2,2(r16)
8112558c:	9809883a 	mov	r4,r19
81125590:	14800226 	beq	r2,r18,8112559c <_fwalk_reent+0x84>
81125594:	a83ee83a 	callr	r21
81125598:	b8aeb03a 	or	r23,r23,r2
8112559c:	84001a04 	addi	r16,r16,104
811255a0:	8cbff51e 	bne	r17,r18,81125578 <__reset+0xfb105578>
811255a4:	a5000017 	ldw	r20,0(r20)
811255a8:	a03fee1e 	bne	r20,zero,81125564 <__reset+0xfb105564>
811255ac:	b805883a 	mov	r2,r23
811255b0:	dfc00817 	ldw	ra,32(sp)
811255b4:	ddc00717 	ldw	r23,28(sp)
811255b8:	dd800617 	ldw	r22,24(sp)
811255bc:	dd400517 	ldw	r21,20(sp)
811255c0:	dd000417 	ldw	r20,16(sp)
811255c4:	dcc00317 	ldw	r19,12(sp)
811255c8:	dc800217 	ldw	r18,8(sp)
811255cc:	dc400117 	ldw	r17,4(sp)
811255d0:	dc000017 	ldw	r16,0(sp)
811255d4:	dec00904 	addi	sp,sp,36
811255d8:	f800283a 	ret
811255dc:	002f883a 	mov	r23,zero
811255e0:	003ff206 	br	811255ac <__reset+0xfb1055ac>

811255e4 <_isatty_r>:
811255e4:	defffd04 	addi	sp,sp,-12
811255e8:	de00012e 	bgeu	sp,et,811255f0 <_isatty_r+0xc>
811255ec:	003b68fa 	trap	3
811255f0:	dc000015 	stw	r16,0(sp)
811255f4:	04204574 	movhi	r16,33045
811255f8:	dc400115 	stw	r17,4(sp)
811255fc:	8430fa04 	addi	r16,r16,-15384
81125600:	2023883a 	mov	r17,r4
81125604:	2809883a 	mov	r4,r5
81125608:	dfc00215 	stw	ra,8(sp)
8112560c:	80000015 	stw	zero,0(r16)
81125610:	11307340 	call	81130734 <isatty>
81125614:	00ffffc4 	movi	r3,-1
81125618:	10c00526 	beq	r2,r3,81125630 <_isatty_r+0x4c>
8112561c:	dfc00217 	ldw	ra,8(sp)
81125620:	dc400117 	ldw	r17,4(sp)
81125624:	dc000017 	ldw	r16,0(sp)
81125628:	dec00304 	addi	sp,sp,12
8112562c:	f800283a 	ret
81125630:	80c00017 	ldw	r3,0(r16)
81125634:	183ff926 	beq	r3,zero,8112561c <__reset+0xfb10561c>
81125638:	88c00015 	stw	r3,0(r17)
8112563c:	003ff706 	br	8112561c <__reset+0xfb10561c>

81125640 <iswspace>:
81125640:	00803fc4 	movi	r2,255
81125644:	11000836 	bltu	r2,r4,81125668 <iswspace+0x28>
81125648:	00a04574 	movhi	r2,33045
8112564c:	10b08004 	addi	r2,r2,-15872
81125650:	10800017 	ldw	r2,0(r2)
81125654:	1109883a 	add	r4,r2,r4
81125658:	20800043 	ldbu	r2,1(r4)
8112565c:	1080020c 	andi	r2,r2,8
81125660:	10803fcc 	andi	r2,r2,255
81125664:	f800283a 	ret
81125668:	0005883a 	mov	r2,zero
8112566c:	f800283a 	ret

81125670 <_setlocale_r>:
81125670:	30001d26 	beq	r6,zero,811256e8 <_setlocale_r+0x78>
81125674:	01604574 	movhi	r5,33045
81125678:	defffe04 	addi	sp,sp,-8
8112567c:	2966d904 	addi	r5,r5,-25756
81125680:	3009883a 	mov	r4,r6
81125684:	de00012e 	bgeu	sp,et,8112568c <_setlocale_r+0x1c>
81125688:	003b68fa 	trap	3
8112568c:	dc000015 	stw	r16,0(sp)
81125690:	dfc00115 	stw	ra,4(sp)
81125694:	3021883a 	mov	r16,r6
81125698:	11273bc0 	call	811273bc <strcmp>
8112569c:	1000061e 	bne	r2,zero,811256b8 <_setlocale_r+0x48>
811256a0:	00a04574 	movhi	r2,33045
811256a4:	10a6a804 	addi	r2,r2,-25952
811256a8:	dfc00117 	ldw	ra,4(sp)
811256ac:	dc000017 	ldw	r16,0(sp)
811256b0:	dec00204 	addi	sp,sp,8
811256b4:	f800283a 	ret
811256b8:	01604574 	movhi	r5,33045
811256bc:	2966a804 	addi	r5,r5,-25952
811256c0:	8009883a 	mov	r4,r16
811256c4:	11273bc0 	call	811273bc <strcmp>
811256c8:	103ff526 	beq	r2,zero,811256a0 <__reset+0xfb1056a0>
811256cc:	01604574 	movhi	r5,33045
811256d0:	2966b204 	addi	r5,r5,-25912
811256d4:	8009883a 	mov	r4,r16
811256d8:	11273bc0 	call	811273bc <strcmp>
811256dc:	103ff026 	beq	r2,zero,811256a0 <__reset+0xfb1056a0>
811256e0:	0005883a 	mov	r2,zero
811256e4:	003ff006 	br	811256a8 <__reset+0xfb1056a8>
811256e8:	00a04574 	movhi	r2,33045
811256ec:	10a6a804 	addi	r2,r2,-25952
811256f0:	f800283a 	ret

811256f4 <__locale_charset>:
811256f4:	00a04574 	movhi	r2,33045
811256f8:	10ab4a04 	addi	r2,r2,-21208
811256fc:	f800283a 	ret

81125700 <__locale_mb_cur_max>:
81125700:	00a04574 	movhi	r2,33045
81125704:	10b08504 	addi	r2,r2,-15852
81125708:	10800017 	ldw	r2,0(r2)
8112570c:	f800283a 	ret

81125710 <__locale_msgcharset>:
81125710:	00a04574 	movhi	r2,33045
81125714:	10ab4204 	addi	r2,r2,-21240
81125718:	f800283a 	ret

8112571c <__locale_cjk_lang>:
8112571c:	0005883a 	mov	r2,zero
81125720:	f800283a 	ret

81125724 <_localeconv_r>:
81125724:	00a04574 	movhi	r2,33045
81125728:	10ab5204 	addi	r2,r2,-21176
8112572c:	f800283a 	ret

81125730 <setlocale>:
81125730:	00a04574 	movhi	r2,33045
81125734:	10b08204 	addi	r2,r2,-15864
81125738:	280d883a 	mov	r6,r5
8112573c:	200b883a 	mov	r5,r4
81125740:	11000017 	ldw	r4,0(r2)
81125744:	11256701 	jmpi	81125670 <_setlocale_r>

81125748 <localeconv>:
81125748:	00a04574 	movhi	r2,33045
8112574c:	10ab5204 	addi	r2,r2,-21176
81125750:	f800283a 	ret

81125754 <_lseek_r>:
81125754:	defffd04 	addi	sp,sp,-12
81125758:	de00012e 	bgeu	sp,et,81125760 <_lseek_r+0xc>
8112575c:	003b68fa 	trap	3
81125760:	2805883a 	mov	r2,r5
81125764:	dc000015 	stw	r16,0(sp)
81125768:	04204574 	movhi	r16,33045
8112576c:	dc400115 	stw	r17,4(sp)
81125770:	300b883a 	mov	r5,r6
81125774:	8430fa04 	addi	r16,r16,-15384
81125778:	2023883a 	mov	r17,r4
8112577c:	380d883a 	mov	r6,r7
81125780:	1009883a 	mov	r4,r2
81125784:	dfc00215 	stw	ra,8(sp)
81125788:	80000015 	stw	zero,0(r16)
8112578c:	11313300 	call	81131330 <lseek>
81125790:	00ffffc4 	movi	r3,-1
81125794:	10c00526 	beq	r2,r3,811257ac <_lseek_r+0x58>
81125798:	dfc00217 	ldw	ra,8(sp)
8112579c:	dc400117 	ldw	r17,4(sp)
811257a0:	dc000017 	ldw	r16,0(sp)
811257a4:	dec00304 	addi	sp,sp,12
811257a8:	f800283a 	ret
811257ac:	80c00017 	ldw	r3,0(r16)
811257b0:	183ff926 	beq	r3,zero,81125798 <__reset+0xfb105798>
811257b4:	88c00015 	stw	r3,0(r17)
811257b8:	003ff706 	br	81125798 <__reset+0xfb105798>

811257bc <_mbrtowc_r>:
811257bc:	defff704 	addi	sp,sp,-36
811257c0:	00a04574 	movhi	r2,33045
811257c4:	de00012e 	bgeu	sp,et,811257cc <_mbrtowc_r+0x10>
811257c8:	003b68fa 	trap	3
811257cc:	10b08604 	addi	r2,r2,-15848
811257d0:	dc800715 	stw	r18,28(sp)
811257d4:	dc400615 	stw	r17,24(sp)
811257d8:	dc000515 	stw	r16,20(sp)
811257dc:	dfc00815 	stw	ra,32(sp)
811257e0:	2021883a 	mov	r16,r4
811257e4:	dc400917 	ldw	r17,36(sp)
811257e8:	14800017 	ldw	r18,0(r2)
811257ec:	30001626 	beq	r6,zero,81125848 <_mbrtowc_r+0x8c>
811257f0:	d9400215 	stw	r5,8(sp)
811257f4:	d9800315 	stw	r6,12(sp)
811257f8:	d9c00415 	stw	r7,16(sp)
811257fc:	11256f40 	call	811256f4 <__locale_charset>
81125800:	d9c00417 	ldw	r7,16(sp)
81125804:	d9800317 	ldw	r6,12(sp)
81125808:	d9400217 	ldw	r5,8(sp)
8112580c:	d8800015 	stw	r2,0(sp)
81125810:	dc400115 	stw	r17,4(sp)
81125814:	8009883a 	mov	r4,r16
81125818:	903ee83a 	callr	r18
8112581c:	00ffffc4 	movi	r3,-1
81125820:	10c0031e 	bne	r2,r3,81125830 <_mbrtowc_r+0x74>
81125824:	88000015 	stw	zero,0(r17)
81125828:	00c02284 	movi	r3,138
8112582c:	80c00015 	stw	r3,0(r16)
81125830:	dfc00817 	ldw	ra,32(sp)
81125834:	dc800717 	ldw	r18,28(sp)
81125838:	dc400617 	ldw	r17,24(sp)
8112583c:	dc000517 	ldw	r16,20(sp)
81125840:	dec00904 	addi	sp,sp,36
81125844:	f800283a 	ret
81125848:	11256f40 	call	811256f4 <__locale_charset>
8112584c:	01a04574 	movhi	r6,33045
81125850:	31a6b204 	addi	r6,r6,-25912
81125854:	dc400115 	stw	r17,4(sp)
81125858:	d8800015 	stw	r2,0(sp)
8112585c:	01c00044 	movi	r7,1
81125860:	000b883a 	mov	r5,zero
81125864:	8009883a 	mov	r4,r16
81125868:	903ee83a 	callr	r18
8112586c:	003feb06 	br	8112581c <__reset+0xfb10581c>

81125870 <mbrtowc>:
81125870:	defff704 	addi	sp,sp,-36
81125874:	00a04574 	movhi	r2,33045
81125878:	de00012e 	bgeu	sp,et,81125880 <mbrtowc+0x10>
8112587c:	003b68fa 	trap	3
81125880:	10b08204 	addi	r2,r2,-15864
81125884:	dc800415 	stw	r18,16(sp)
81125888:	dc400315 	stw	r17,12(sp)
8112588c:	dfc00815 	stw	ra,32(sp)
81125890:	dd400715 	stw	r21,28(sp)
81125894:	dd000615 	stw	r20,24(sp)
81125898:	dcc00515 	stw	r19,20(sp)
8112589c:	dc000215 	stw	r16,8(sp)
811258a0:	3825883a 	mov	r18,r7
811258a4:	14400017 	ldw	r17,0(r2)
811258a8:	28001c26 	beq	r5,zero,8112591c <mbrtowc+0xac>
811258ac:	00a04574 	movhi	r2,33045
811258b0:	10b08604 	addi	r2,r2,-15848
811258b4:	15400017 	ldw	r21,0(r2)
811258b8:	2821883a 	mov	r16,r5
811258bc:	2027883a 	mov	r19,r4
811258c0:	3029883a 	mov	r20,r6
811258c4:	11256f40 	call	811256f4 <__locale_charset>
811258c8:	d8800015 	stw	r2,0(sp)
811258cc:	dc800115 	stw	r18,4(sp)
811258d0:	a00f883a 	mov	r7,r20
811258d4:	800d883a 	mov	r6,r16
811258d8:	980b883a 	mov	r5,r19
811258dc:	8809883a 	mov	r4,r17
811258e0:	a83ee83a 	callr	r21
811258e4:	00ffffc4 	movi	r3,-1
811258e8:	10c0031e 	bne	r2,r3,811258f8 <mbrtowc+0x88>
811258ec:	90000015 	stw	zero,0(r18)
811258f0:	00c02284 	movi	r3,138
811258f4:	88c00015 	stw	r3,0(r17)
811258f8:	dfc00817 	ldw	ra,32(sp)
811258fc:	dd400717 	ldw	r21,28(sp)
81125900:	dd000617 	ldw	r20,24(sp)
81125904:	dcc00517 	ldw	r19,20(sp)
81125908:	dc800417 	ldw	r18,16(sp)
8112590c:	dc400317 	ldw	r17,12(sp)
81125910:	dc000217 	ldw	r16,8(sp)
81125914:	dec00904 	addi	sp,sp,36
81125918:	f800283a 	ret
8112591c:	00a04574 	movhi	r2,33045
81125920:	10b08604 	addi	r2,r2,-15848
81125924:	14000017 	ldw	r16,0(r2)
81125928:	11256f40 	call	811256f4 <__locale_charset>
8112592c:	01a04574 	movhi	r6,33045
81125930:	31a6b204 	addi	r6,r6,-25912
81125934:	dc800115 	stw	r18,4(sp)
81125938:	d8800015 	stw	r2,0(sp)
8112593c:	01c00044 	movi	r7,1
81125940:	000b883a 	mov	r5,zero
81125944:	8809883a 	mov	r4,r17
81125948:	803ee83a 	callr	r16
8112594c:	003fe506 	br	811258e4 <__reset+0xfb1058e4>

81125950 <__ascii_mbtowc>:
81125950:	deffff04 	addi	sp,sp,-4
81125954:	de00012e 	bgeu	sp,et,8112595c <__ascii_mbtowc+0xc>
81125958:	003b68fa 	trap	3
8112595c:	28000826 	beq	r5,zero,81125980 <__ascii_mbtowc+0x30>
81125960:	30000926 	beq	r6,zero,81125988 <__ascii_mbtowc+0x38>
81125964:	38000b26 	beq	r7,zero,81125994 <__ascii_mbtowc+0x44>
81125968:	30800003 	ldbu	r2,0(r6)
8112596c:	28800015 	stw	r2,0(r5)
81125970:	30800003 	ldbu	r2,0(r6)
81125974:	1004c03a 	cmpne	r2,r2,zero
81125978:	dec00104 	addi	sp,sp,4
8112597c:	f800283a 	ret
81125980:	d80b883a 	mov	r5,sp
81125984:	303ff71e 	bne	r6,zero,81125964 <__reset+0xfb105964>
81125988:	0005883a 	mov	r2,zero
8112598c:	dec00104 	addi	sp,sp,4
81125990:	f800283a 	ret
81125994:	00bfff84 	movi	r2,-2
81125998:	003ff706 	br	81125978 <__reset+0xfb105978>

8112599c <_mbtowc_r>:
8112599c:	00a04574 	movhi	r2,33045
811259a0:	defff804 	addi	sp,sp,-32
811259a4:	10b08604 	addi	r2,r2,-15848
811259a8:	de00012e 	bgeu	sp,et,811259b0 <_mbtowc_r+0x14>
811259ac:	003b68fa 	trap	3
811259b0:	dfc00715 	stw	ra,28(sp)
811259b4:	dc000615 	stw	r16,24(sp)
811259b8:	14000017 	ldw	r16,0(r2)
811259bc:	d9000215 	stw	r4,8(sp)
811259c0:	d9400315 	stw	r5,12(sp)
811259c4:	d9800415 	stw	r6,16(sp)
811259c8:	d9c00515 	stw	r7,20(sp)
811259cc:	11256f40 	call	811256f4 <__locale_charset>
811259d0:	d8800015 	stw	r2,0(sp)
811259d4:	d8800817 	ldw	r2,32(sp)
811259d8:	d9c00517 	ldw	r7,20(sp)
811259dc:	d9800417 	ldw	r6,16(sp)
811259e0:	d9400317 	ldw	r5,12(sp)
811259e4:	d9000217 	ldw	r4,8(sp)
811259e8:	d8800115 	stw	r2,4(sp)
811259ec:	803ee83a 	callr	r16
811259f0:	dfc00717 	ldw	ra,28(sp)
811259f4:	dc000617 	ldw	r16,24(sp)
811259f8:	dec00804 	addi	sp,sp,32
811259fc:	f800283a 	ret

81125a00 <memchr>:
81125a00:	208000cc 	andi	r2,r4,3
81125a04:	280f883a 	mov	r7,r5
81125a08:	10003426 	beq	r2,zero,81125adc <memchr+0xdc>
81125a0c:	30bfffc4 	addi	r2,r6,-1
81125a10:	30001a26 	beq	r6,zero,81125a7c <memchr+0x7c>
81125a14:	20c00003 	ldbu	r3,0(r4)
81125a18:	29803fcc 	andi	r6,r5,255
81125a1c:	30c0051e 	bne	r6,r3,81125a34 <memchr+0x34>
81125a20:	00001806 	br	81125a84 <memchr+0x84>
81125a24:	10001526 	beq	r2,zero,81125a7c <memchr+0x7c>
81125a28:	20c00003 	ldbu	r3,0(r4)
81125a2c:	10bfffc4 	addi	r2,r2,-1
81125a30:	30c01426 	beq	r6,r3,81125a84 <memchr+0x84>
81125a34:	21000044 	addi	r4,r4,1
81125a38:	20c000cc 	andi	r3,r4,3
81125a3c:	183ff91e 	bne	r3,zero,81125a24 <__reset+0xfb105a24>
81125a40:	020000c4 	movi	r8,3
81125a44:	40801136 	bltu	r8,r2,81125a8c <memchr+0x8c>
81125a48:	10000c26 	beq	r2,zero,81125a7c <memchr+0x7c>
81125a4c:	20c00003 	ldbu	r3,0(r4)
81125a50:	29403fcc 	andi	r5,r5,255
81125a54:	28c00b26 	beq	r5,r3,81125a84 <memchr+0x84>
81125a58:	20c00044 	addi	r3,r4,1
81125a5c:	39803fcc 	andi	r6,r7,255
81125a60:	2089883a 	add	r4,r4,r2
81125a64:	00000306 	br	81125a74 <memchr+0x74>
81125a68:	18c00044 	addi	r3,r3,1
81125a6c:	197fffc3 	ldbu	r5,-1(r3)
81125a70:	31400526 	beq	r6,r5,81125a88 <memchr+0x88>
81125a74:	1805883a 	mov	r2,r3
81125a78:	20fffb1e 	bne	r4,r3,81125a68 <__reset+0xfb105a68>
81125a7c:	0005883a 	mov	r2,zero
81125a80:	f800283a 	ret
81125a84:	2005883a 	mov	r2,r4
81125a88:	f800283a 	ret
81125a8c:	28c03fcc 	andi	r3,r5,255
81125a90:	1812923a 	slli	r9,r3,8
81125a94:	02ffbff4 	movhi	r11,65279
81125a98:	02a02074 	movhi	r10,32897
81125a9c:	48d2b03a 	or	r9,r9,r3
81125aa0:	4806943a 	slli	r3,r9,16
81125aa4:	5affbfc4 	addi	r11,r11,-257
81125aa8:	52a02004 	addi	r10,r10,-32640
81125aac:	48d2b03a 	or	r9,r9,r3
81125ab0:	20c00017 	ldw	r3,0(r4)
81125ab4:	48c6f03a 	xor	r3,r9,r3
81125ab8:	1acd883a 	add	r6,r3,r11
81125abc:	00c6303a 	nor	r3,zero,r3
81125ac0:	30c6703a 	and	r3,r6,r3
81125ac4:	1a86703a 	and	r3,r3,r10
81125ac8:	183fe01e 	bne	r3,zero,81125a4c <__reset+0xfb105a4c>
81125acc:	10bfff04 	addi	r2,r2,-4
81125ad0:	21000104 	addi	r4,r4,4
81125ad4:	40bff636 	bltu	r8,r2,81125ab0 <__reset+0xfb105ab0>
81125ad8:	003fdb06 	br	81125a48 <__reset+0xfb105a48>
81125adc:	3005883a 	mov	r2,r6
81125ae0:	003fd706 	br	81125a40 <__reset+0xfb105a40>

81125ae4 <memmove>:
81125ae4:	2005883a 	mov	r2,r4
81125ae8:	29000b2e 	bgeu	r5,r4,81125b18 <memmove+0x34>
81125aec:	298f883a 	add	r7,r5,r6
81125af0:	21c0092e 	bgeu	r4,r7,81125b18 <memmove+0x34>
81125af4:	2187883a 	add	r3,r4,r6
81125af8:	198bc83a 	sub	r5,r3,r6
81125afc:	30004826 	beq	r6,zero,81125c20 <memmove+0x13c>
81125b00:	39ffffc4 	addi	r7,r7,-1
81125b04:	39000003 	ldbu	r4,0(r7)
81125b08:	18ffffc4 	addi	r3,r3,-1
81125b0c:	19000005 	stb	r4,0(r3)
81125b10:	28fffb1e 	bne	r5,r3,81125b00 <__reset+0xfb105b00>
81125b14:	f800283a 	ret
81125b18:	00c003c4 	movi	r3,15
81125b1c:	1980412e 	bgeu	r3,r6,81125c24 <memmove+0x140>
81125b20:	2886b03a 	or	r3,r5,r2
81125b24:	18c000cc 	andi	r3,r3,3
81125b28:	1800401e 	bne	r3,zero,81125c2c <memmove+0x148>
81125b2c:	33fffc04 	addi	r15,r6,-16
81125b30:	781ed13a 	srli	r15,r15,4
81125b34:	28c00104 	addi	r3,r5,4
81125b38:	13400104 	addi	r13,r2,4
81125b3c:	781c913a 	slli	r14,r15,4
81125b40:	2b000204 	addi	r12,r5,8
81125b44:	12c00204 	addi	r11,r2,8
81125b48:	73800504 	addi	r14,r14,20
81125b4c:	2a800304 	addi	r10,r5,12
81125b50:	12400304 	addi	r9,r2,12
81125b54:	2b9d883a 	add	r14,r5,r14
81125b58:	2811883a 	mov	r8,r5
81125b5c:	100f883a 	mov	r7,r2
81125b60:	41000017 	ldw	r4,0(r8)
81125b64:	39c00404 	addi	r7,r7,16
81125b68:	18c00404 	addi	r3,r3,16
81125b6c:	393ffc15 	stw	r4,-16(r7)
81125b70:	193ffc17 	ldw	r4,-16(r3)
81125b74:	6b400404 	addi	r13,r13,16
81125b78:	5ac00404 	addi	r11,r11,16
81125b7c:	693ffc15 	stw	r4,-16(r13)
81125b80:	61000017 	ldw	r4,0(r12)
81125b84:	4a400404 	addi	r9,r9,16
81125b88:	42000404 	addi	r8,r8,16
81125b8c:	593ffc15 	stw	r4,-16(r11)
81125b90:	51000017 	ldw	r4,0(r10)
81125b94:	63000404 	addi	r12,r12,16
81125b98:	52800404 	addi	r10,r10,16
81125b9c:	493ffc15 	stw	r4,-16(r9)
81125ba0:	1bbfef1e 	bne	r3,r14,81125b60 <__reset+0xfb105b60>
81125ba4:	79000044 	addi	r4,r15,1
81125ba8:	2008913a 	slli	r4,r4,4
81125bac:	328003cc 	andi	r10,r6,15
81125bb0:	02c000c4 	movi	r11,3
81125bb4:	1107883a 	add	r3,r2,r4
81125bb8:	290b883a 	add	r5,r5,r4
81125bbc:	5a801e2e 	bgeu	r11,r10,81125c38 <memmove+0x154>
81125bc0:	1813883a 	mov	r9,r3
81125bc4:	2811883a 	mov	r8,r5
81125bc8:	500f883a 	mov	r7,r10
81125bcc:	41000017 	ldw	r4,0(r8)
81125bd0:	4a400104 	addi	r9,r9,4
81125bd4:	39ffff04 	addi	r7,r7,-4
81125bd8:	493fff15 	stw	r4,-4(r9)
81125bdc:	42000104 	addi	r8,r8,4
81125be0:	59fffa36 	bltu	r11,r7,81125bcc <__reset+0xfb105bcc>
81125be4:	513fff04 	addi	r4,r10,-4
81125be8:	2008d0ba 	srli	r4,r4,2
81125bec:	318000cc 	andi	r6,r6,3
81125bf0:	21000044 	addi	r4,r4,1
81125bf4:	2109883a 	add	r4,r4,r4
81125bf8:	2109883a 	add	r4,r4,r4
81125bfc:	1907883a 	add	r3,r3,r4
81125c00:	290b883a 	add	r5,r5,r4
81125c04:	30000b26 	beq	r6,zero,81125c34 <memmove+0x150>
81125c08:	198d883a 	add	r6,r3,r6
81125c0c:	29c00003 	ldbu	r7,0(r5)
81125c10:	18c00044 	addi	r3,r3,1
81125c14:	29400044 	addi	r5,r5,1
81125c18:	19ffffc5 	stb	r7,-1(r3)
81125c1c:	19bffb1e 	bne	r3,r6,81125c0c <__reset+0xfb105c0c>
81125c20:	f800283a 	ret
81125c24:	1007883a 	mov	r3,r2
81125c28:	003ff606 	br	81125c04 <__reset+0xfb105c04>
81125c2c:	1007883a 	mov	r3,r2
81125c30:	003ff506 	br	81125c08 <__reset+0xfb105c08>
81125c34:	f800283a 	ret
81125c38:	500d883a 	mov	r6,r10
81125c3c:	003ff106 	br	81125c04 <__reset+0xfb105c04>

81125c40 <_Balloc>:
81125c40:	defffc04 	addi	sp,sp,-16
81125c44:	de00012e 	bgeu	sp,et,81125c4c <_Balloc+0xc>
81125c48:	003b68fa 	trap	3
81125c4c:	20801317 	ldw	r2,76(r4)
81125c50:	dc400115 	stw	r17,4(sp)
81125c54:	dc000015 	stw	r16,0(sp)
81125c58:	dfc00315 	stw	ra,12(sp)
81125c5c:	dc800215 	stw	r18,8(sp)
81125c60:	2023883a 	mov	r17,r4
81125c64:	2821883a 	mov	r16,r5
81125c68:	10000f26 	beq	r2,zero,81125ca8 <_Balloc+0x68>
81125c6c:	8407883a 	add	r3,r16,r16
81125c70:	18c7883a 	add	r3,r3,r3
81125c74:	10c7883a 	add	r3,r2,r3
81125c78:	18800017 	ldw	r2,0(r3)
81125c7c:	10001126 	beq	r2,zero,81125cc4 <_Balloc+0x84>
81125c80:	11000017 	ldw	r4,0(r2)
81125c84:	19000015 	stw	r4,0(r3)
81125c88:	10000415 	stw	zero,16(r2)
81125c8c:	10000315 	stw	zero,12(r2)
81125c90:	dfc00317 	ldw	ra,12(sp)
81125c94:	dc800217 	ldw	r18,8(sp)
81125c98:	dc400117 	ldw	r17,4(sp)
81125c9c:	dc000017 	ldw	r16,0(sp)
81125ca0:	dec00404 	addi	sp,sp,16
81125ca4:	f800283a 	ret
81125ca8:	01800844 	movi	r6,33
81125cac:	01400104 	movi	r5,4
81125cb0:	112c1680 	call	8112c168 <_calloc_r>
81125cb4:	88801315 	stw	r2,76(r17)
81125cb8:	103fec1e 	bne	r2,zero,81125c6c <__reset+0xfb105c6c>
81125cbc:	0005883a 	mov	r2,zero
81125cc0:	003ff306 	br	81125c90 <__reset+0xfb105c90>
81125cc4:	01400044 	movi	r5,1
81125cc8:	2c24983a 	sll	r18,r5,r16
81125ccc:	8809883a 	mov	r4,r17
81125cd0:	91800144 	addi	r6,r18,5
81125cd4:	318d883a 	add	r6,r6,r6
81125cd8:	318d883a 	add	r6,r6,r6
81125cdc:	112c1680 	call	8112c168 <_calloc_r>
81125ce0:	103ff626 	beq	r2,zero,81125cbc <__reset+0xfb105cbc>
81125ce4:	14000115 	stw	r16,4(r2)
81125ce8:	14800215 	stw	r18,8(r2)
81125cec:	003fe606 	br	81125c88 <__reset+0xfb105c88>

81125cf0 <_Bfree>:
81125cf0:	28000826 	beq	r5,zero,81125d14 <_Bfree+0x24>
81125cf4:	28c00117 	ldw	r3,4(r5)
81125cf8:	20801317 	ldw	r2,76(r4)
81125cfc:	18c7883a 	add	r3,r3,r3
81125d00:	18c7883a 	add	r3,r3,r3
81125d04:	10c5883a 	add	r2,r2,r3
81125d08:	10c00017 	ldw	r3,0(r2)
81125d0c:	28c00015 	stw	r3,0(r5)
81125d10:	11400015 	stw	r5,0(r2)
81125d14:	f800283a 	ret

81125d18 <__multadd>:
81125d18:	defffa04 	addi	sp,sp,-24
81125d1c:	de00012e 	bgeu	sp,et,81125d24 <__multadd+0xc>
81125d20:	003b68fa 	trap	3
81125d24:	0011883a 	mov	r8,zero
81125d28:	dc800315 	stw	r18,12(sp)
81125d2c:	dc400215 	stw	r17,8(sp)
81125d30:	dc000115 	stw	r16,4(sp)
81125d34:	2823883a 	mov	r17,r5
81125d38:	2c000417 	ldw	r16,16(r5)
81125d3c:	dfc00515 	stw	ra,20(sp)
81125d40:	dcc00415 	stw	r19,16(sp)
81125d44:	2025883a 	mov	r18,r4
81125d48:	29400504 	addi	r5,r5,20
81125d4c:	28c00017 	ldw	r3,0(r5)
81125d50:	29400104 	addi	r5,r5,4
81125d54:	42000044 	addi	r8,r8,1
81125d58:	18bfffcc 	andi	r2,r3,65535
81125d5c:	1185383a 	mul	r2,r2,r6
81125d60:	1806d43a 	srli	r3,r3,16
81125d64:	11cf883a 	add	r7,r2,r7
81125d68:	3808d43a 	srli	r4,r7,16
81125d6c:	1987383a 	mul	r3,r3,r6
81125d70:	38bfffcc 	andi	r2,r7,65535
81125d74:	1907883a 	add	r3,r3,r4
81125d78:	1808943a 	slli	r4,r3,16
81125d7c:	180ed43a 	srli	r7,r3,16
81125d80:	2085883a 	add	r2,r4,r2
81125d84:	28bfff15 	stw	r2,-4(r5)
81125d88:	443ff016 	blt	r8,r16,81125d4c <__reset+0xfb105d4c>
81125d8c:	38000926 	beq	r7,zero,81125db4 <__multadd+0x9c>
81125d90:	88800217 	ldw	r2,8(r17)
81125d94:	80800f0e 	bge	r16,r2,81125dd4 <__multadd+0xbc>
81125d98:	80800144 	addi	r2,r16,5
81125d9c:	1085883a 	add	r2,r2,r2
81125da0:	1085883a 	add	r2,r2,r2
81125da4:	8885883a 	add	r2,r17,r2
81125da8:	11c00015 	stw	r7,0(r2)
81125dac:	84000044 	addi	r16,r16,1
81125db0:	8c000415 	stw	r16,16(r17)
81125db4:	8805883a 	mov	r2,r17
81125db8:	dfc00517 	ldw	ra,20(sp)
81125dbc:	dcc00417 	ldw	r19,16(sp)
81125dc0:	dc800317 	ldw	r18,12(sp)
81125dc4:	dc400217 	ldw	r17,8(sp)
81125dc8:	dc000117 	ldw	r16,4(sp)
81125dcc:	dec00604 	addi	sp,sp,24
81125dd0:	f800283a 	ret
81125dd4:	89400117 	ldw	r5,4(r17)
81125dd8:	9009883a 	mov	r4,r18
81125ddc:	d9c00015 	stw	r7,0(sp)
81125de0:	29400044 	addi	r5,r5,1
81125de4:	1125c400 	call	81125c40 <_Balloc>
81125de8:	89800417 	ldw	r6,16(r17)
81125dec:	89400304 	addi	r5,r17,12
81125df0:	11000304 	addi	r4,r2,12
81125df4:	31800084 	addi	r6,r6,2
81125df8:	318d883a 	add	r6,r6,r6
81125dfc:	318d883a 	add	r6,r6,r6
81125e00:	1027883a 	mov	r19,r2
81125e04:	111ba100 	call	8111ba10 <memcpy>
81125e08:	d9c00017 	ldw	r7,0(sp)
81125e0c:	88000a26 	beq	r17,zero,81125e38 <__multadd+0x120>
81125e10:	88c00117 	ldw	r3,4(r17)
81125e14:	90801317 	ldw	r2,76(r18)
81125e18:	18c7883a 	add	r3,r3,r3
81125e1c:	18c7883a 	add	r3,r3,r3
81125e20:	10c5883a 	add	r2,r2,r3
81125e24:	10c00017 	ldw	r3,0(r2)
81125e28:	88c00015 	stw	r3,0(r17)
81125e2c:	14400015 	stw	r17,0(r2)
81125e30:	9823883a 	mov	r17,r19
81125e34:	003fd806 	br	81125d98 <__reset+0xfb105d98>
81125e38:	9823883a 	mov	r17,r19
81125e3c:	003fd606 	br	81125d98 <__reset+0xfb105d98>

81125e40 <__s2b>:
81125e40:	defff904 	addi	sp,sp,-28
81125e44:	de00012e 	bgeu	sp,et,81125e4c <__s2b+0xc>
81125e48:	003b68fa 	trap	3
81125e4c:	dc400115 	stw	r17,4(sp)
81125e50:	dc000015 	stw	r16,0(sp)
81125e54:	2023883a 	mov	r17,r4
81125e58:	2821883a 	mov	r16,r5
81125e5c:	39000204 	addi	r4,r7,8
81125e60:	01400244 	movi	r5,9
81125e64:	dcc00315 	stw	r19,12(sp)
81125e68:	dc800215 	stw	r18,8(sp)
81125e6c:	dfc00615 	stw	ra,24(sp)
81125e70:	dd400515 	stw	r21,20(sp)
81125e74:	dd000415 	stw	r20,16(sp)
81125e78:	3825883a 	mov	r18,r7
81125e7c:	3027883a 	mov	r19,r6
81125e80:	112df000 	call	8112df00 <__divsi3>
81125e84:	00c00044 	movi	r3,1
81125e88:	000b883a 	mov	r5,zero
81125e8c:	1880030e 	bge	r3,r2,81125e9c <__s2b+0x5c>
81125e90:	18c7883a 	add	r3,r3,r3
81125e94:	29400044 	addi	r5,r5,1
81125e98:	18bffd16 	blt	r3,r2,81125e90 <__reset+0xfb105e90>
81125e9c:	8809883a 	mov	r4,r17
81125ea0:	1125c400 	call	81125c40 <_Balloc>
81125ea4:	d8c00717 	ldw	r3,28(sp)
81125ea8:	10c00515 	stw	r3,20(r2)
81125eac:	00c00044 	movi	r3,1
81125eb0:	10c00415 	stw	r3,16(r2)
81125eb4:	00c00244 	movi	r3,9
81125eb8:	1cc0210e 	bge	r3,r19,81125f40 <__s2b+0x100>
81125ebc:	80eb883a 	add	r21,r16,r3
81125ec0:	a829883a 	mov	r20,r21
81125ec4:	84e1883a 	add	r16,r16,r19
81125ec8:	a1c00007 	ldb	r7,0(r20)
81125ecc:	01800284 	movi	r6,10
81125ed0:	a5000044 	addi	r20,r20,1
81125ed4:	100b883a 	mov	r5,r2
81125ed8:	39fff404 	addi	r7,r7,-48
81125edc:	8809883a 	mov	r4,r17
81125ee0:	1125d180 	call	81125d18 <__multadd>
81125ee4:	a43ff81e 	bne	r20,r16,81125ec8 <__reset+0xfb105ec8>
81125ee8:	ace1883a 	add	r16,r21,r19
81125eec:	843ffe04 	addi	r16,r16,-8
81125ef0:	9c800a0e 	bge	r19,r18,81125f1c <__s2b+0xdc>
81125ef4:	94e5c83a 	sub	r18,r18,r19
81125ef8:	84a5883a 	add	r18,r16,r18
81125efc:	81c00007 	ldb	r7,0(r16)
81125f00:	01800284 	movi	r6,10
81125f04:	84000044 	addi	r16,r16,1
81125f08:	100b883a 	mov	r5,r2
81125f0c:	39fff404 	addi	r7,r7,-48
81125f10:	8809883a 	mov	r4,r17
81125f14:	1125d180 	call	81125d18 <__multadd>
81125f18:	84bff81e 	bne	r16,r18,81125efc <__reset+0xfb105efc>
81125f1c:	dfc00617 	ldw	ra,24(sp)
81125f20:	dd400517 	ldw	r21,20(sp)
81125f24:	dd000417 	ldw	r20,16(sp)
81125f28:	dcc00317 	ldw	r19,12(sp)
81125f2c:	dc800217 	ldw	r18,8(sp)
81125f30:	dc400117 	ldw	r17,4(sp)
81125f34:	dc000017 	ldw	r16,0(sp)
81125f38:	dec00704 	addi	sp,sp,28
81125f3c:	f800283a 	ret
81125f40:	84000284 	addi	r16,r16,10
81125f44:	1827883a 	mov	r19,r3
81125f48:	003fe906 	br	81125ef0 <__reset+0xfb105ef0>

81125f4c <__hi0bits>:
81125f4c:	20bfffec 	andhi	r2,r4,65535
81125f50:	1000141e 	bne	r2,zero,81125fa4 <__hi0bits+0x58>
81125f54:	2008943a 	slli	r4,r4,16
81125f58:	00800404 	movi	r2,16
81125f5c:	20ffc02c 	andhi	r3,r4,65280
81125f60:	1800021e 	bne	r3,zero,81125f6c <__hi0bits+0x20>
81125f64:	2008923a 	slli	r4,r4,8
81125f68:	10800204 	addi	r2,r2,8
81125f6c:	20fc002c 	andhi	r3,r4,61440
81125f70:	1800021e 	bne	r3,zero,81125f7c <__hi0bits+0x30>
81125f74:	2008913a 	slli	r4,r4,4
81125f78:	10800104 	addi	r2,r2,4
81125f7c:	20f0002c 	andhi	r3,r4,49152
81125f80:	1800031e 	bne	r3,zero,81125f90 <__hi0bits+0x44>
81125f84:	2109883a 	add	r4,r4,r4
81125f88:	10800084 	addi	r2,r2,2
81125f8c:	2109883a 	add	r4,r4,r4
81125f90:	20000316 	blt	r4,zero,81125fa0 <__hi0bits+0x54>
81125f94:	2110002c 	andhi	r4,r4,16384
81125f98:	2000041e 	bne	r4,zero,81125fac <__hi0bits+0x60>
81125f9c:	00800804 	movi	r2,32
81125fa0:	f800283a 	ret
81125fa4:	0005883a 	mov	r2,zero
81125fa8:	003fec06 	br	81125f5c <__reset+0xfb105f5c>
81125fac:	10800044 	addi	r2,r2,1
81125fb0:	f800283a 	ret

81125fb4 <__lo0bits>:
81125fb4:	20c00017 	ldw	r3,0(r4)
81125fb8:	188001cc 	andi	r2,r3,7
81125fbc:	10000826 	beq	r2,zero,81125fe0 <__lo0bits+0x2c>
81125fc0:	1880004c 	andi	r2,r3,1
81125fc4:	1000211e 	bne	r2,zero,8112604c <__lo0bits+0x98>
81125fc8:	1880008c 	andi	r2,r3,2
81125fcc:	1000211e 	bne	r2,zero,81126054 <__lo0bits+0xa0>
81125fd0:	1806d0ba 	srli	r3,r3,2
81125fd4:	00800084 	movi	r2,2
81125fd8:	20c00015 	stw	r3,0(r4)
81125fdc:	f800283a 	ret
81125fe0:	18bfffcc 	andi	r2,r3,65535
81125fe4:	10001326 	beq	r2,zero,81126034 <__lo0bits+0x80>
81125fe8:	0005883a 	mov	r2,zero
81125fec:	19403fcc 	andi	r5,r3,255
81125ff0:	2800021e 	bne	r5,zero,81125ffc <__lo0bits+0x48>
81125ff4:	1806d23a 	srli	r3,r3,8
81125ff8:	10800204 	addi	r2,r2,8
81125ffc:	194003cc 	andi	r5,r3,15
81126000:	2800021e 	bne	r5,zero,8112600c <__lo0bits+0x58>
81126004:	1806d13a 	srli	r3,r3,4
81126008:	10800104 	addi	r2,r2,4
8112600c:	194000cc 	andi	r5,r3,3
81126010:	2800021e 	bne	r5,zero,8112601c <__lo0bits+0x68>
81126014:	1806d0ba 	srli	r3,r3,2
81126018:	10800084 	addi	r2,r2,2
8112601c:	1940004c 	andi	r5,r3,1
81126020:	2800081e 	bne	r5,zero,81126044 <__lo0bits+0x90>
81126024:	1806d07a 	srli	r3,r3,1
81126028:	1800051e 	bne	r3,zero,81126040 <__lo0bits+0x8c>
8112602c:	00800804 	movi	r2,32
81126030:	f800283a 	ret
81126034:	1806d43a 	srli	r3,r3,16
81126038:	00800404 	movi	r2,16
8112603c:	003feb06 	br	81125fec <__reset+0xfb105fec>
81126040:	10800044 	addi	r2,r2,1
81126044:	20c00015 	stw	r3,0(r4)
81126048:	f800283a 	ret
8112604c:	0005883a 	mov	r2,zero
81126050:	f800283a 	ret
81126054:	1806d07a 	srli	r3,r3,1
81126058:	00800044 	movi	r2,1
8112605c:	20c00015 	stw	r3,0(r4)
81126060:	f800283a 	ret

81126064 <__i2b>:
81126064:	defffd04 	addi	sp,sp,-12
81126068:	de00012e 	bgeu	sp,et,81126070 <__i2b+0xc>
8112606c:	003b68fa 	trap	3
81126070:	dc000015 	stw	r16,0(sp)
81126074:	04000044 	movi	r16,1
81126078:	dc400115 	stw	r17,4(sp)
8112607c:	2823883a 	mov	r17,r5
81126080:	800b883a 	mov	r5,r16
81126084:	dfc00215 	stw	ra,8(sp)
81126088:	1125c400 	call	81125c40 <_Balloc>
8112608c:	14400515 	stw	r17,20(r2)
81126090:	14000415 	stw	r16,16(r2)
81126094:	dfc00217 	ldw	ra,8(sp)
81126098:	dc400117 	ldw	r17,4(sp)
8112609c:	dc000017 	ldw	r16,0(sp)
811260a0:	dec00304 	addi	sp,sp,12
811260a4:	f800283a 	ret

811260a8 <__multiply>:
811260a8:	defffa04 	addi	sp,sp,-24
811260ac:	de00012e 	bgeu	sp,et,811260b4 <__multiply+0xc>
811260b0:	003b68fa 	trap	3
811260b4:	dcc00315 	stw	r19,12(sp)
811260b8:	dc800215 	stw	r18,8(sp)
811260bc:	34c00417 	ldw	r19,16(r6)
811260c0:	2c800417 	ldw	r18,16(r5)
811260c4:	dd000415 	stw	r20,16(sp)
811260c8:	dc400115 	stw	r17,4(sp)
811260cc:	dfc00515 	stw	ra,20(sp)
811260d0:	dc000015 	stw	r16,0(sp)
811260d4:	2829883a 	mov	r20,r5
811260d8:	3023883a 	mov	r17,r6
811260dc:	94c0050e 	bge	r18,r19,811260f4 <__multiply+0x4c>
811260e0:	9007883a 	mov	r3,r18
811260e4:	3029883a 	mov	r20,r6
811260e8:	9825883a 	mov	r18,r19
811260ec:	2823883a 	mov	r17,r5
811260f0:	1827883a 	mov	r19,r3
811260f4:	a0800217 	ldw	r2,8(r20)
811260f8:	94e1883a 	add	r16,r18,r19
811260fc:	a1400117 	ldw	r5,4(r20)
81126100:	1400010e 	bge	r2,r16,81126108 <__multiply+0x60>
81126104:	29400044 	addi	r5,r5,1
81126108:	1125c400 	call	81125c40 <_Balloc>
8112610c:	8415883a 	add	r10,r16,r16
81126110:	12c00504 	addi	r11,r2,20
81126114:	5295883a 	add	r10,r10,r10
81126118:	5a95883a 	add	r10,r11,r10
8112611c:	5807883a 	mov	r3,r11
81126120:	5a80032e 	bgeu	r11,r10,81126130 <__multiply+0x88>
81126124:	18000015 	stw	zero,0(r3)
81126128:	18c00104 	addi	r3,r3,4
8112612c:	1abffd36 	bltu	r3,r10,81126124 <__reset+0xfb106124>
81126130:	9ce7883a 	add	r19,r19,r19
81126134:	94a5883a 	add	r18,r18,r18
81126138:	89800504 	addi	r6,r17,20
8112613c:	9ce7883a 	add	r19,r19,r19
81126140:	a3400504 	addi	r13,r20,20
81126144:	94a5883a 	add	r18,r18,r18
81126148:	34d9883a 	add	r12,r6,r19
8112614c:	6c93883a 	add	r9,r13,r18
81126150:	3300422e 	bgeu	r6,r12,8112625c <__multiply+0x1b4>
81126154:	37c00017 	ldw	ra,0(r6)
81126158:	fbffffcc 	andi	r15,ra,65535
8112615c:	78001b26 	beq	r15,zero,811261cc <__multiply+0x124>
81126160:	5811883a 	mov	r8,r11
81126164:	681d883a 	mov	r14,r13
81126168:	000f883a 	mov	r7,zero
8112616c:	71000017 	ldw	r4,0(r14)
81126170:	40c00017 	ldw	r3,0(r8)
81126174:	73800104 	addi	r14,r14,4
81126178:	217fffcc 	andi	r5,r4,65535
8112617c:	2bcb383a 	mul	r5,r5,r15
81126180:	2008d43a 	srli	r4,r4,16
81126184:	1c7fffcc 	andi	r17,r3,65535
81126188:	2c4b883a 	add	r5,r5,r17
8112618c:	29cb883a 	add	r5,r5,r7
81126190:	23c9383a 	mul	r4,r4,r15
81126194:	1806d43a 	srli	r3,r3,16
81126198:	280ed43a 	srli	r7,r5,16
8112619c:	297fffcc 	andi	r5,r5,65535
811261a0:	20c7883a 	add	r3,r4,r3
811261a4:	19c7883a 	add	r3,r3,r7
811261a8:	1808943a 	slli	r4,r3,16
811261ac:	4023883a 	mov	r17,r8
811261b0:	180ed43a 	srli	r7,r3,16
811261b4:	214ab03a 	or	r5,r4,r5
811261b8:	41400015 	stw	r5,0(r8)
811261bc:	42000104 	addi	r8,r8,4
811261c0:	727fea36 	bltu	r14,r9,8112616c <__reset+0xfb10616c>
811261c4:	89c00115 	stw	r7,4(r17)
811261c8:	37c00017 	ldw	ra,0(r6)
811261cc:	f83ed43a 	srli	ra,ra,16
811261d0:	f8001f26 	beq	ra,zero,81126250 <__multiply+0x1a8>
811261d4:	58c00017 	ldw	r3,0(r11)
811261d8:	681d883a 	mov	r14,r13
811261dc:	581f883a 	mov	r15,r11
811261e0:	1811883a 	mov	r8,r3
811261e4:	5825883a 	mov	r18,r11
811261e8:	000f883a 	mov	r7,zero
811261ec:	00000106 	br	811261f4 <__multiply+0x14c>
811261f0:	8825883a 	mov	r18,r17
811261f4:	7140000b 	ldhu	r5,0(r14)
811261f8:	4010d43a 	srli	r8,r8,16
811261fc:	193fffcc 	andi	r4,r3,65535
81126200:	2fcb383a 	mul	r5,r5,ra
81126204:	7bc00104 	addi	r15,r15,4
81126208:	73800104 	addi	r14,r14,4
8112620c:	2a0b883a 	add	r5,r5,r8
81126210:	29cb883a 	add	r5,r5,r7
81126214:	2806943a 	slli	r3,r5,16
81126218:	94400104 	addi	r17,r18,4
8112621c:	280ad43a 	srli	r5,r5,16
81126220:	1908b03a 	or	r4,r3,r4
81126224:	793fff15 	stw	r4,-4(r15)
81126228:	70ffff17 	ldw	r3,-4(r14)
8112622c:	8a000017 	ldw	r8,0(r17)
81126230:	1806d43a 	srli	r3,r3,16
81126234:	413fffcc 	andi	r4,r8,65535
81126238:	1fc7383a 	mul	r3,r3,ra
8112623c:	1907883a 	add	r3,r3,r4
81126240:	1947883a 	add	r3,r3,r5
81126244:	180ed43a 	srli	r7,r3,16
81126248:	727fe936 	bltu	r14,r9,811261f0 <__reset+0xfb1061f0>
8112624c:	90c00115 	stw	r3,4(r18)
81126250:	31800104 	addi	r6,r6,4
81126254:	5ac00104 	addi	r11,r11,4
81126258:	333fbe36 	bltu	r6,r12,81126154 <__reset+0xfb106154>
8112625c:	0400090e 	bge	zero,r16,81126284 <__multiply+0x1dc>
81126260:	50ffff17 	ldw	r3,-4(r10)
81126264:	52bfff04 	addi	r10,r10,-4
81126268:	18000326 	beq	r3,zero,81126278 <__multiply+0x1d0>
8112626c:	00000506 	br	81126284 <__multiply+0x1dc>
81126270:	50c00017 	ldw	r3,0(r10)
81126274:	1800031e 	bne	r3,zero,81126284 <__multiply+0x1dc>
81126278:	843fffc4 	addi	r16,r16,-1
8112627c:	52bfff04 	addi	r10,r10,-4
81126280:	803ffb1e 	bne	r16,zero,81126270 <__reset+0xfb106270>
81126284:	14000415 	stw	r16,16(r2)
81126288:	dfc00517 	ldw	ra,20(sp)
8112628c:	dd000417 	ldw	r20,16(sp)
81126290:	dcc00317 	ldw	r19,12(sp)
81126294:	dc800217 	ldw	r18,8(sp)
81126298:	dc400117 	ldw	r17,4(sp)
8112629c:	dc000017 	ldw	r16,0(sp)
811262a0:	dec00604 	addi	sp,sp,24
811262a4:	f800283a 	ret

811262a8 <__pow5mult>:
811262a8:	defffa04 	addi	sp,sp,-24
811262ac:	de00012e 	bgeu	sp,et,811262b4 <__pow5mult+0xc>
811262b0:	003b68fa 	trap	3
811262b4:	308000cc 	andi	r2,r6,3
811262b8:	dcc00315 	stw	r19,12(sp)
811262bc:	dc000015 	stw	r16,0(sp)
811262c0:	dfc00515 	stw	ra,20(sp)
811262c4:	dd000415 	stw	r20,16(sp)
811262c8:	dc800215 	stw	r18,8(sp)
811262cc:	dc400115 	stw	r17,4(sp)
811262d0:	3021883a 	mov	r16,r6
811262d4:	2027883a 	mov	r19,r4
811262d8:	10002f1e 	bne	r2,zero,81126398 <__pow5mult+0xf0>
811262dc:	2825883a 	mov	r18,r5
811262e0:	8021d0ba 	srai	r16,r16,2
811262e4:	80001a26 	beq	r16,zero,81126350 <__pow5mult+0xa8>
811262e8:	9c401217 	ldw	r17,72(r19)
811262ec:	8800061e 	bne	r17,zero,81126308 <__pow5mult+0x60>
811262f0:	00003406 	br	811263c4 <__pow5mult+0x11c>
811262f4:	8021d07a 	srai	r16,r16,1
811262f8:	80001526 	beq	r16,zero,81126350 <__pow5mult+0xa8>
811262fc:	88800017 	ldw	r2,0(r17)
81126300:	10001c26 	beq	r2,zero,81126374 <__pow5mult+0xcc>
81126304:	1023883a 	mov	r17,r2
81126308:	8080004c 	andi	r2,r16,1
8112630c:	103ff926 	beq	r2,zero,811262f4 <__reset+0xfb1062f4>
81126310:	880d883a 	mov	r6,r17
81126314:	900b883a 	mov	r5,r18
81126318:	9809883a 	mov	r4,r19
8112631c:	11260a80 	call	811260a8 <__multiply>
81126320:	90001b26 	beq	r18,zero,81126390 <__pow5mult+0xe8>
81126324:	91000117 	ldw	r4,4(r18)
81126328:	98c01317 	ldw	r3,76(r19)
8112632c:	8021d07a 	srai	r16,r16,1
81126330:	2109883a 	add	r4,r4,r4
81126334:	2109883a 	add	r4,r4,r4
81126338:	1907883a 	add	r3,r3,r4
8112633c:	19000017 	ldw	r4,0(r3)
81126340:	91000015 	stw	r4,0(r18)
81126344:	1c800015 	stw	r18,0(r3)
81126348:	1025883a 	mov	r18,r2
8112634c:	803feb1e 	bne	r16,zero,811262fc <__reset+0xfb1062fc>
81126350:	9005883a 	mov	r2,r18
81126354:	dfc00517 	ldw	ra,20(sp)
81126358:	dd000417 	ldw	r20,16(sp)
8112635c:	dcc00317 	ldw	r19,12(sp)
81126360:	dc800217 	ldw	r18,8(sp)
81126364:	dc400117 	ldw	r17,4(sp)
81126368:	dc000017 	ldw	r16,0(sp)
8112636c:	dec00604 	addi	sp,sp,24
81126370:	f800283a 	ret
81126374:	880d883a 	mov	r6,r17
81126378:	880b883a 	mov	r5,r17
8112637c:	9809883a 	mov	r4,r19
81126380:	11260a80 	call	811260a8 <__multiply>
81126384:	88800015 	stw	r2,0(r17)
81126388:	10000015 	stw	zero,0(r2)
8112638c:	003fdd06 	br	81126304 <__reset+0xfb106304>
81126390:	1025883a 	mov	r18,r2
81126394:	003fd706 	br	811262f4 <__reset+0xfb1062f4>
81126398:	10bfffc4 	addi	r2,r2,-1
8112639c:	1085883a 	add	r2,r2,r2
811263a0:	00e04574 	movhi	r3,33045
811263a4:	18e6dc04 	addi	r3,r3,-25744
811263a8:	1085883a 	add	r2,r2,r2
811263ac:	1885883a 	add	r2,r3,r2
811263b0:	11800017 	ldw	r6,0(r2)
811263b4:	000f883a 	mov	r7,zero
811263b8:	1125d180 	call	81125d18 <__multadd>
811263bc:	1025883a 	mov	r18,r2
811263c0:	003fc706 	br	811262e0 <__reset+0xfb1062e0>
811263c4:	05000044 	movi	r20,1
811263c8:	a00b883a 	mov	r5,r20
811263cc:	9809883a 	mov	r4,r19
811263d0:	1125c400 	call	81125c40 <_Balloc>
811263d4:	1023883a 	mov	r17,r2
811263d8:	00809c44 	movi	r2,625
811263dc:	88800515 	stw	r2,20(r17)
811263e0:	8d000415 	stw	r20,16(r17)
811263e4:	9c401215 	stw	r17,72(r19)
811263e8:	88000015 	stw	zero,0(r17)
811263ec:	003fc606 	br	81126308 <__reset+0xfb106308>

811263f0 <__lshift>:
811263f0:	defff904 	addi	sp,sp,-28
811263f4:	de00012e 	bgeu	sp,et,811263fc <__lshift+0xc>
811263f8:	003b68fa 	trap	3
811263fc:	dd400515 	stw	r21,20(sp)
81126400:	dcc00315 	stw	r19,12(sp)
81126404:	302bd17a 	srai	r21,r6,5
81126408:	2cc00417 	ldw	r19,16(r5)
8112640c:	28800217 	ldw	r2,8(r5)
81126410:	dd000415 	stw	r20,16(sp)
81126414:	ace7883a 	add	r19,r21,r19
81126418:	dc800215 	stw	r18,8(sp)
8112641c:	dc400115 	stw	r17,4(sp)
81126420:	dc000015 	stw	r16,0(sp)
81126424:	dfc00615 	stw	ra,24(sp)
81126428:	9c000044 	addi	r16,r19,1
8112642c:	2823883a 	mov	r17,r5
81126430:	3029883a 	mov	r20,r6
81126434:	2025883a 	mov	r18,r4
81126438:	29400117 	ldw	r5,4(r5)
8112643c:	1400030e 	bge	r2,r16,8112644c <__lshift+0x5c>
81126440:	1085883a 	add	r2,r2,r2
81126444:	29400044 	addi	r5,r5,1
81126448:	143ffd16 	blt	r2,r16,81126440 <__reset+0xfb106440>
8112644c:	9009883a 	mov	r4,r18
81126450:	1125c400 	call	81125c40 <_Balloc>
81126454:	10c00504 	addi	r3,r2,20
81126458:	0540070e 	bge	zero,r21,81126478 <__lshift+0x88>
8112645c:	ad6b883a 	add	r21,r21,r21
81126460:	ad6b883a 	add	r21,r21,r21
81126464:	1809883a 	mov	r4,r3
81126468:	1d47883a 	add	r3,r3,r21
8112646c:	20000015 	stw	zero,0(r4)
81126470:	21000104 	addi	r4,r4,4
81126474:	193ffd1e 	bne	r3,r4,8112646c <__reset+0xfb10646c>
81126478:	8a000417 	ldw	r8,16(r17)
8112647c:	89000504 	addi	r4,r17,20
81126480:	a18007cc 	andi	r6,r20,31
81126484:	4211883a 	add	r8,r8,r8
81126488:	4211883a 	add	r8,r8,r8
8112648c:	2211883a 	add	r8,r4,r8
81126490:	30002326 	beq	r6,zero,81126520 <__lshift+0x130>
81126494:	02400804 	movi	r9,32
81126498:	4993c83a 	sub	r9,r9,r6
8112649c:	000b883a 	mov	r5,zero
811264a0:	21c00017 	ldw	r7,0(r4)
811264a4:	1815883a 	mov	r10,r3
811264a8:	18c00104 	addi	r3,r3,4
811264ac:	398e983a 	sll	r7,r7,r6
811264b0:	21000104 	addi	r4,r4,4
811264b4:	394ab03a 	or	r5,r7,r5
811264b8:	197fff15 	stw	r5,-4(r3)
811264bc:	217fff17 	ldw	r5,-4(r4)
811264c0:	2a4ad83a 	srl	r5,r5,r9
811264c4:	223ff636 	bltu	r4,r8,811264a0 <__reset+0xfb1064a0>
811264c8:	51400115 	stw	r5,4(r10)
811264cc:	28001a1e 	bne	r5,zero,81126538 <__lshift+0x148>
811264d0:	843fffc4 	addi	r16,r16,-1
811264d4:	14000415 	stw	r16,16(r2)
811264d8:	88000826 	beq	r17,zero,811264fc <__lshift+0x10c>
811264dc:	89000117 	ldw	r4,4(r17)
811264e0:	90c01317 	ldw	r3,76(r18)
811264e4:	2109883a 	add	r4,r4,r4
811264e8:	2109883a 	add	r4,r4,r4
811264ec:	1907883a 	add	r3,r3,r4
811264f0:	19000017 	ldw	r4,0(r3)
811264f4:	89000015 	stw	r4,0(r17)
811264f8:	1c400015 	stw	r17,0(r3)
811264fc:	dfc00617 	ldw	ra,24(sp)
81126500:	dd400517 	ldw	r21,20(sp)
81126504:	dd000417 	ldw	r20,16(sp)
81126508:	dcc00317 	ldw	r19,12(sp)
8112650c:	dc800217 	ldw	r18,8(sp)
81126510:	dc400117 	ldw	r17,4(sp)
81126514:	dc000017 	ldw	r16,0(sp)
81126518:	dec00704 	addi	sp,sp,28
8112651c:	f800283a 	ret
81126520:	21400017 	ldw	r5,0(r4)
81126524:	18c00104 	addi	r3,r3,4
81126528:	21000104 	addi	r4,r4,4
8112652c:	197fff15 	stw	r5,-4(r3)
81126530:	223ffb36 	bltu	r4,r8,81126520 <__reset+0xfb106520>
81126534:	003fe606 	br	811264d0 <__reset+0xfb1064d0>
81126538:	9c000084 	addi	r16,r19,2
8112653c:	003fe406 	br	811264d0 <__reset+0xfb1064d0>

81126540 <__mcmp>:
81126540:	20800417 	ldw	r2,16(r4)
81126544:	28c00417 	ldw	r3,16(r5)
81126548:	10c5c83a 	sub	r2,r2,r3
8112654c:	1000111e 	bne	r2,zero,81126594 <__mcmp+0x54>
81126550:	18c7883a 	add	r3,r3,r3
81126554:	18c7883a 	add	r3,r3,r3
81126558:	21000504 	addi	r4,r4,20
8112655c:	29400504 	addi	r5,r5,20
81126560:	20c5883a 	add	r2,r4,r3
81126564:	28cb883a 	add	r5,r5,r3
81126568:	00000106 	br	81126570 <__mcmp+0x30>
8112656c:	20800a2e 	bgeu	r4,r2,81126598 <__mcmp+0x58>
81126570:	10bfff04 	addi	r2,r2,-4
81126574:	297fff04 	addi	r5,r5,-4
81126578:	11800017 	ldw	r6,0(r2)
8112657c:	28c00017 	ldw	r3,0(r5)
81126580:	30fffa26 	beq	r6,r3,8112656c <__reset+0xfb10656c>
81126584:	30c00236 	bltu	r6,r3,81126590 <__mcmp+0x50>
81126588:	00800044 	movi	r2,1
8112658c:	f800283a 	ret
81126590:	00bfffc4 	movi	r2,-1
81126594:	f800283a 	ret
81126598:	0005883a 	mov	r2,zero
8112659c:	f800283a 	ret

811265a0 <__mdiff>:
811265a0:	defffa04 	addi	sp,sp,-24
811265a4:	de00012e 	bgeu	sp,et,811265ac <__mdiff+0xc>
811265a8:	003b68fa 	trap	3
811265ac:	28c00417 	ldw	r3,16(r5)
811265b0:	30800417 	ldw	r2,16(r6)
811265b4:	dcc00315 	stw	r19,12(sp)
811265b8:	dc800215 	stw	r18,8(sp)
811265bc:	dfc00515 	stw	ra,20(sp)
811265c0:	dd000415 	stw	r20,16(sp)
811265c4:	dc400115 	stw	r17,4(sp)
811265c8:	dc000015 	stw	r16,0(sp)
811265cc:	1887c83a 	sub	r3,r3,r2
811265d0:	2825883a 	mov	r18,r5
811265d4:	3027883a 	mov	r19,r6
811265d8:	1800141e 	bne	r3,zero,8112662c <__mdiff+0x8c>
811265dc:	1085883a 	add	r2,r2,r2
811265e0:	1085883a 	add	r2,r2,r2
811265e4:	2a000504 	addi	r8,r5,20
811265e8:	34000504 	addi	r16,r6,20
811265ec:	4087883a 	add	r3,r8,r2
811265f0:	8085883a 	add	r2,r16,r2
811265f4:	00000106 	br	811265fc <__mdiff+0x5c>
811265f8:	40c0592e 	bgeu	r8,r3,81126760 <__mdiff+0x1c0>
811265fc:	18ffff04 	addi	r3,r3,-4
81126600:	10bfff04 	addi	r2,r2,-4
81126604:	19c00017 	ldw	r7,0(r3)
81126608:	11400017 	ldw	r5,0(r2)
8112660c:	397ffa26 	beq	r7,r5,811265f8 <__reset+0xfb1065f8>
81126610:	3940592e 	bgeu	r7,r5,81126778 <__mdiff+0x1d8>
81126614:	9005883a 	mov	r2,r18
81126618:	4023883a 	mov	r17,r8
8112661c:	9825883a 	mov	r18,r19
81126620:	05000044 	movi	r20,1
81126624:	1027883a 	mov	r19,r2
81126628:	00000406 	br	8112663c <__mdiff+0x9c>
8112662c:	18005616 	blt	r3,zero,81126788 <__mdiff+0x1e8>
81126630:	34400504 	addi	r17,r6,20
81126634:	2c000504 	addi	r16,r5,20
81126638:	0029883a 	mov	r20,zero
8112663c:	91400117 	ldw	r5,4(r18)
81126640:	1125c400 	call	81125c40 <_Balloc>
81126644:	92400417 	ldw	r9,16(r18)
81126648:	9b000417 	ldw	r12,16(r19)
8112664c:	12c00504 	addi	r11,r2,20
81126650:	4a51883a 	add	r8,r9,r9
81126654:	6319883a 	add	r12,r12,r12
81126658:	4211883a 	add	r8,r8,r8
8112665c:	6319883a 	add	r12,r12,r12
81126660:	15000315 	stw	r20,12(r2)
81126664:	8211883a 	add	r8,r16,r8
81126668:	8b19883a 	add	r12,r17,r12
8112666c:	0007883a 	mov	r3,zero
81126670:	81400017 	ldw	r5,0(r16)
81126674:	89c00017 	ldw	r7,0(r17)
81126678:	59800104 	addi	r6,r11,4
8112667c:	293fffcc 	andi	r4,r5,65535
81126680:	20c7883a 	add	r3,r4,r3
81126684:	393fffcc 	andi	r4,r7,65535
81126688:	1909c83a 	sub	r4,r3,r4
8112668c:	280ad43a 	srli	r5,r5,16
81126690:	380ed43a 	srli	r7,r7,16
81126694:	2007d43a 	srai	r3,r4,16
81126698:	213fffcc 	andi	r4,r4,65535
8112669c:	29cbc83a 	sub	r5,r5,r7
811266a0:	28c7883a 	add	r3,r5,r3
811266a4:	180a943a 	slli	r5,r3,16
811266a8:	8c400104 	addi	r17,r17,4
811266ac:	84000104 	addi	r16,r16,4
811266b0:	2908b03a 	or	r4,r5,r4
811266b4:	59000015 	stw	r4,0(r11)
811266b8:	1807d43a 	srai	r3,r3,16
811266bc:	3015883a 	mov	r10,r6
811266c0:	3017883a 	mov	r11,r6
811266c4:	8b3fea36 	bltu	r17,r12,81126670 <__reset+0xfb106670>
811266c8:	8200162e 	bgeu	r16,r8,81126724 <__mdiff+0x184>
811266cc:	8017883a 	mov	r11,r16
811266d0:	59400017 	ldw	r5,0(r11)
811266d4:	31800104 	addi	r6,r6,4
811266d8:	5ac00104 	addi	r11,r11,4
811266dc:	293fffcc 	andi	r4,r5,65535
811266e0:	20c7883a 	add	r3,r4,r3
811266e4:	280ed43a 	srli	r7,r5,16
811266e8:	180bd43a 	srai	r5,r3,16
811266ec:	193fffcc 	andi	r4,r3,65535
811266f0:	3947883a 	add	r3,r7,r5
811266f4:	180a943a 	slli	r5,r3,16
811266f8:	1807d43a 	srai	r3,r3,16
811266fc:	2908b03a 	or	r4,r5,r4
81126700:	313fff15 	stw	r4,-4(r6)
81126704:	5a3ff236 	bltu	r11,r8,811266d0 <__reset+0xfb1066d0>
81126708:	0406303a 	nor	r3,zero,r16
8112670c:	1a07883a 	add	r3,r3,r8
81126710:	1806d0ba 	srli	r3,r3,2
81126714:	18c00044 	addi	r3,r3,1
81126718:	18c7883a 	add	r3,r3,r3
8112671c:	18c7883a 	add	r3,r3,r3
81126720:	50d5883a 	add	r10,r10,r3
81126724:	50ffff04 	addi	r3,r10,-4
81126728:	2000041e 	bne	r4,zero,8112673c <__mdiff+0x19c>
8112672c:	18ffff04 	addi	r3,r3,-4
81126730:	19000017 	ldw	r4,0(r3)
81126734:	4a7fffc4 	addi	r9,r9,-1
81126738:	203ffc26 	beq	r4,zero,8112672c <__reset+0xfb10672c>
8112673c:	12400415 	stw	r9,16(r2)
81126740:	dfc00517 	ldw	ra,20(sp)
81126744:	dd000417 	ldw	r20,16(sp)
81126748:	dcc00317 	ldw	r19,12(sp)
8112674c:	dc800217 	ldw	r18,8(sp)
81126750:	dc400117 	ldw	r17,4(sp)
81126754:	dc000017 	ldw	r16,0(sp)
81126758:	dec00604 	addi	sp,sp,24
8112675c:	f800283a 	ret
81126760:	000b883a 	mov	r5,zero
81126764:	1125c400 	call	81125c40 <_Balloc>
81126768:	00c00044 	movi	r3,1
8112676c:	10c00415 	stw	r3,16(r2)
81126770:	10000515 	stw	zero,20(r2)
81126774:	003ff206 	br	81126740 <__reset+0xfb106740>
81126778:	8023883a 	mov	r17,r16
8112677c:	0029883a 	mov	r20,zero
81126780:	4021883a 	mov	r16,r8
81126784:	003fad06 	br	8112663c <__reset+0xfb10663c>
81126788:	9005883a 	mov	r2,r18
8112678c:	94400504 	addi	r17,r18,20
81126790:	9c000504 	addi	r16,r19,20
81126794:	9825883a 	mov	r18,r19
81126798:	05000044 	movi	r20,1
8112679c:	1027883a 	mov	r19,r2
811267a0:	003fa606 	br	8112663c <__reset+0xfb10663c>

811267a4 <__ulp>:
811267a4:	295ffc2c 	andhi	r5,r5,32752
811267a8:	00bf3034 	movhi	r2,64704
811267ac:	2887883a 	add	r3,r5,r2
811267b0:	00c0020e 	bge	zero,r3,811267bc <__ulp+0x18>
811267b4:	0005883a 	mov	r2,zero
811267b8:	f800283a 	ret
811267bc:	00c7c83a 	sub	r3,zero,r3
811267c0:	1807d53a 	srai	r3,r3,20
811267c4:	008004c4 	movi	r2,19
811267c8:	10c00b0e 	bge	r2,r3,811267f8 <__ulp+0x54>
811267cc:	18bffb04 	addi	r2,r3,-20
811267d0:	01000784 	movi	r4,30
811267d4:	0007883a 	mov	r3,zero
811267d8:	20800516 	blt	r4,r2,811267f0 <__ulp+0x4c>
811267dc:	010007c4 	movi	r4,31
811267e0:	2089c83a 	sub	r4,r4,r2
811267e4:	00800044 	movi	r2,1
811267e8:	1104983a 	sll	r2,r2,r4
811267ec:	f800283a 	ret
811267f0:	00800044 	movi	r2,1
811267f4:	f800283a 	ret
811267f8:	01400234 	movhi	r5,8
811267fc:	28c7d83a 	sra	r3,r5,r3
81126800:	0005883a 	mov	r2,zero
81126804:	f800283a 	ret

81126808 <__b2d>:
81126808:	defffa04 	addi	sp,sp,-24
8112680c:	de00012e 	bgeu	sp,et,81126814 <__b2d+0xc>
81126810:	003b68fa 	trap	3
81126814:	dc000015 	stw	r16,0(sp)
81126818:	24000417 	ldw	r16,16(r4)
8112681c:	dc400115 	stw	r17,4(sp)
81126820:	24400504 	addi	r17,r4,20
81126824:	8421883a 	add	r16,r16,r16
81126828:	8421883a 	add	r16,r16,r16
8112682c:	8c21883a 	add	r16,r17,r16
81126830:	dc800215 	stw	r18,8(sp)
81126834:	84bfff17 	ldw	r18,-4(r16)
81126838:	dd000415 	stw	r20,16(sp)
8112683c:	dcc00315 	stw	r19,12(sp)
81126840:	9009883a 	mov	r4,r18
81126844:	2829883a 	mov	r20,r5
81126848:	dfc00515 	stw	ra,20(sp)
8112684c:	1125f4c0 	call	81125f4c <__hi0bits>
81126850:	00c00804 	movi	r3,32
81126854:	1889c83a 	sub	r4,r3,r2
81126858:	a1000015 	stw	r4,0(r20)
8112685c:	01000284 	movi	r4,10
81126860:	84ffff04 	addi	r19,r16,-4
81126864:	20801216 	blt	r4,r2,811268b0 <__b2d+0xa8>
81126868:	018002c4 	movi	r6,11
8112686c:	308dc83a 	sub	r6,r6,r2
81126870:	9186d83a 	srl	r3,r18,r6
81126874:	18cffc34 	orhi	r3,r3,16368
81126878:	8cc0212e 	bgeu	r17,r19,81126900 <__b2d+0xf8>
8112687c:	813ffe17 	ldw	r4,-8(r16)
81126880:	218cd83a 	srl	r6,r4,r6
81126884:	10800544 	addi	r2,r2,21
81126888:	9084983a 	sll	r2,r18,r2
8112688c:	1184b03a 	or	r2,r2,r6
81126890:	dfc00517 	ldw	ra,20(sp)
81126894:	dd000417 	ldw	r20,16(sp)
81126898:	dcc00317 	ldw	r19,12(sp)
8112689c:	dc800217 	ldw	r18,8(sp)
811268a0:	dc400117 	ldw	r17,4(sp)
811268a4:	dc000017 	ldw	r16,0(sp)
811268a8:	dec00604 	addi	sp,sp,24
811268ac:	f800283a 	ret
811268b0:	8cc00f2e 	bgeu	r17,r19,811268f0 <__b2d+0xe8>
811268b4:	117ffd44 	addi	r5,r2,-11
811268b8:	80bffe17 	ldw	r2,-8(r16)
811268bc:	28000e26 	beq	r5,zero,811268f8 <__b2d+0xf0>
811268c0:	1949c83a 	sub	r4,r3,r5
811268c4:	9164983a 	sll	r18,r18,r5
811268c8:	1106d83a 	srl	r3,r2,r4
811268cc:	81bffe04 	addi	r6,r16,-8
811268d0:	948ffc34 	orhi	r18,r18,16368
811268d4:	90c6b03a 	or	r3,r18,r3
811268d8:	89800e2e 	bgeu	r17,r6,81126914 <__b2d+0x10c>
811268dc:	81bffd17 	ldw	r6,-12(r16)
811268e0:	1144983a 	sll	r2,r2,r5
811268e4:	310ad83a 	srl	r5,r6,r4
811268e8:	2884b03a 	or	r2,r5,r2
811268ec:	003fe806 	br	81126890 <__reset+0xfb106890>
811268f0:	10bffd44 	addi	r2,r2,-11
811268f4:	1000041e 	bne	r2,zero,81126908 <__b2d+0x100>
811268f8:	90cffc34 	orhi	r3,r18,16368
811268fc:	003fe406 	br	81126890 <__reset+0xfb106890>
81126900:	000d883a 	mov	r6,zero
81126904:	003fdf06 	br	81126884 <__reset+0xfb106884>
81126908:	90a4983a 	sll	r18,r18,r2
8112690c:	0005883a 	mov	r2,zero
81126910:	003ff906 	br	811268f8 <__reset+0xfb1068f8>
81126914:	1144983a 	sll	r2,r2,r5
81126918:	003fdd06 	br	81126890 <__reset+0xfb106890>

8112691c <__d2b>:
8112691c:	defff804 	addi	sp,sp,-32
81126920:	de00012e 	bgeu	sp,et,81126928 <__d2b+0xc>
81126924:	003b68fa 	trap	3
81126928:	dc000215 	stw	r16,8(sp)
8112692c:	3021883a 	mov	r16,r6
81126930:	dc400315 	stw	r17,12(sp)
81126934:	8022907a 	slli	r17,r16,1
81126938:	dd000615 	stw	r20,24(sp)
8112693c:	2829883a 	mov	r20,r5
81126940:	01400044 	movi	r5,1
81126944:	dcc00515 	stw	r19,20(sp)
81126948:	dc800415 	stw	r18,16(sp)
8112694c:	dfc00715 	stw	ra,28(sp)
81126950:	3825883a 	mov	r18,r7
81126954:	8822d57a 	srli	r17,r17,21
81126958:	1125c400 	call	81125c40 <_Balloc>
8112695c:	1027883a 	mov	r19,r2
81126960:	00800434 	movhi	r2,16
81126964:	10bfffc4 	addi	r2,r2,-1
81126968:	808c703a 	and	r6,r16,r2
8112696c:	88000126 	beq	r17,zero,81126974 <__d2b+0x58>
81126970:	31800434 	orhi	r6,r6,16
81126974:	d9800015 	stw	r6,0(sp)
81126978:	a0002426 	beq	r20,zero,81126a0c <__d2b+0xf0>
8112697c:	d9000104 	addi	r4,sp,4
81126980:	dd000115 	stw	r20,4(sp)
81126984:	1125fb40 	call	81125fb4 <__lo0bits>
81126988:	d8c00017 	ldw	r3,0(sp)
8112698c:	10002f1e 	bne	r2,zero,81126a4c <__d2b+0x130>
81126990:	d9000117 	ldw	r4,4(sp)
81126994:	99000515 	stw	r4,20(r19)
81126998:	1821003a 	cmpeq	r16,r3,zero
8112699c:	01000084 	movi	r4,2
811269a0:	2421c83a 	sub	r16,r4,r16
811269a4:	98c00615 	stw	r3,24(r19)
811269a8:	9c000415 	stw	r16,16(r19)
811269ac:	88001f1e 	bne	r17,zero,81126a2c <__d2b+0x110>
811269b0:	10bef384 	addi	r2,r2,-1074
811269b4:	90800015 	stw	r2,0(r18)
811269b8:	00900034 	movhi	r2,16384
811269bc:	10bfffc4 	addi	r2,r2,-1
811269c0:	8085883a 	add	r2,r16,r2
811269c4:	1085883a 	add	r2,r2,r2
811269c8:	1085883a 	add	r2,r2,r2
811269cc:	9885883a 	add	r2,r19,r2
811269d0:	11000517 	ldw	r4,20(r2)
811269d4:	8020917a 	slli	r16,r16,5
811269d8:	1125f4c0 	call	81125f4c <__hi0bits>
811269dc:	d8c00817 	ldw	r3,32(sp)
811269e0:	8085c83a 	sub	r2,r16,r2
811269e4:	18800015 	stw	r2,0(r3)
811269e8:	9805883a 	mov	r2,r19
811269ec:	dfc00717 	ldw	ra,28(sp)
811269f0:	dd000617 	ldw	r20,24(sp)
811269f4:	dcc00517 	ldw	r19,20(sp)
811269f8:	dc800417 	ldw	r18,16(sp)
811269fc:	dc400317 	ldw	r17,12(sp)
81126a00:	dc000217 	ldw	r16,8(sp)
81126a04:	dec00804 	addi	sp,sp,32
81126a08:	f800283a 	ret
81126a0c:	d809883a 	mov	r4,sp
81126a10:	1125fb40 	call	81125fb4 <__lo0bits>
81126a14:	d8c00017 	ldw	r3,0(sp)
81126a18:	04000044 	movi	r16,1
81126a1c:	9c000415 	stw	r16,16(r19)
81126a20:	98c00515 	stw	r3,20(r19)
81126a24:	10800804 	addi	r2,r2,32
81126a28:	883fe126 	beq	r17,zero,811269b0 <__reset+0xfb1069b0>
81126a2c:	00c00d44 	movi	r3,53
81126a30:	8c7ef344 	addi	r17,r17,-1075
81126a34:	88a3883a 	add	r17,r17,r2
81126a38:	1885c83a 	sub	r2,r3,r2
81126a3c:	d8c00817 	ldw	r3,32(sp)
81126a40:	94400015 	stw	r17,0(r18)
81126a44:	18800015 	stw	r2,0(r3)
81126a48:	003fe706 	br	811269e8 <__reset+0xfb1069e8>
81126a4c:	01000804 	movi	r4,32
81126a50:	2089c83a 	sub	r4,r4,r2
81126a54:	1908983a 	sll	r4,r3,r4
81126a58:	d9400117 	ldw	r5,4(sp)
81126a5c:	1886d83a 	srl	r3,r3,r2
81126a60:	2148b03a 	or	r4,r4,r5
81126a64:	99000515 	stw	r4,20(r19)
81126a68:	d8c00015 	stw	r3,0(sp)
81126a6c:	003fca06 	br	81126998 <__reset+0xfb106998>

81126a70 <__ratio>:
81126a70:	defff904 	addi	sp,sp,-28
81126a74:	de00012e 	bgeu	sp,et,81126a7c <__ratio+0xc>
81126a78:	003b68fa 	trap	3
81126a7c:	dc400315 	stw	r17,12(sp)
81126a80:	2823883a 	mov	r17,r5
81126a84:	d9400104 	addi	r5,sp,4
81126a88:	dfc00615 	stw	ra,24(sp)
81126a8c:	dcc00515 	stw	r19,20(sp)
81126a90:	dc800415 	stw	r18,16(sp)
81126a94:	2027883a 	mov	r19,r4
81126a98:	dc000215 	stw	r16,8(sp)
81126a9c:	11268080 	call	81126808 <__b2d>
81126aa0:	d80b883a 	mov	r5,sp
81126aa4:	8809883a 	mov	r4,r17
81126aa8:	1025883a 	mov	r18,r2
81126aac:	1821883a 	mov	r16,r3
81126ab0:	11268080 	call	81126808 <__b2d>
81126ab4:	8a000417 	ldw	r8,16(r17)
81126ab8:	99000417 	ldw	r4,16(r19)
81126abc:	d9400117 	ldw	r5,4(sp)
81126ac0:	2209c83a 	sub	r4,r4,r8
81126ac4:	2010917a 	slli	r8,r4,5
81126ac8:	d9000017 	ldw	r4,0(sp)
81126acc:	2909c83a 	sub	r4,r5,r4
81126ad0:	4109883a 	add	r4,r8,r4
81126ad4:	01000e0e 	bge	zero,r4,81126b10 <__ratio+0xa0>
81126ad8:	2008953a 	slli	r4,r4,20
81126adc:	2421883a 	add	r16,r4,r16
81126ae0:	100d883a 	mov	r6,r2
81126ae4:	180f883a 	mov	r7,r3
81126ae8:	9009883a 	mov	r4,r18
81126aec:	800b883a 	mov	r5,r16
81126af0:	112eb640 	call	8112eb64 <__divdf3>
81126af4:	dfc00617 	ldw	ra,24(sp)
81126af8:	dcc00517 	ldw	r19,20(sp)
81126afc:	dc800417 	ldw	r18,16(sp)
81126b00:	dc400317 	ldw	r17,12(sp)
81126b04:	dc000217 	ldw	r16,8(sp)
81126b08:	dec00704 	addi	sp,sp,28
81126b0c:	f800283a 	ret
81126b10:	2008953a 	slli	r4,r4,20
81126b14:	1907c83a 	sub	r3,r3,r4
81126b18:	003ff106 	br	81126ae0 <__reset+0xfb106ae0>

81126b1c <_mprec_log10>:
81126b1c:	defffe04 	addi	sp,sp,-8
81126b20:	de00012e 	bgeu	sp,et,81126b28 <_mprec_log10+0xc>
81126b24:	003b68fa 	trap	3
81126b28:	008005c4 	movi	r2,23
81126b2c:	dc000015 	stw	r16,0(sp)
81126b30:	dfc00115 	stw	ra,4(sp)
81126b34:	2021883a 	mov	r16,r4
81126b38:	11000d0e 	bge	r2,r4,81126b70 <_mprec_log10+0x54>
81126b3c:	0005883a 	mov	r2,zero
81126b40:	00cffc34 	movhi	r3,16368
81126b44:	843fffc4 	addi	r16,r16,-1
81126b48:	000d883a 	mov	r6,zero
81126b4c:	01d00934 	movhi	r7,16420
81126b50:	1009883a 	mov	r4,r2
81126b54:	180b883a 	mov	r5,r3
81126b58:	1119dc00 	call	81119dc0 <__muldf3>
81126b5c:	803ff91e 	bne	r16,zero,81126b44 <__reset+0xfb106b44>
81126b60:	dfc00117 	ldw	ra,4(sp)
81126b64:	dc000017 	ldw	r16,0(sp)
81126b68:	dec00204 	addi	sp,sp,8
81126b6c:	f800283a 	ret
81126b70:	202090fa 	slli	r16,r4,3
81126b74:	00a04574 	movhi	r2,33045
81126b78:	10a6f304 	addi	r2,r2,-25652
81126b7c:	1421883a 	add	r16,r2,r16
81126b80:	80800017 	ldw	r2,0(r16)
81126b84:	80c00117 	ldw	r3,4(r16)
81126b88:	dfc00117 	ldw	ra,4(sp)
81126b8c:	dc000017 	ldw	r16,0(sp)
81126b90:	dec00204 	addi	sp,sp,8
81126b94:	f800283a 	ret

81126b98 <__copybits>:
81126b98:	297fffc4 	addi	r5,r5,-1
81126b9c:	280fd17a 	srai	r7,r5,5
81126ba0:	30c00417 	ldw	r3,16(r6)
81126ba4:	30800504 	addi	r2,r6,20
81126ba8:	39c00044 	addi	r7,r7,1
81126bac:	18c7883a 	add	r3,r3,r3
81126bb0:	39cf883a 	add	r7,r7,r7
81126bb4:	18c7883a 	add	r3,r3,r3
81126bb8:	39cf883a 	add	r7,r7,r7
81126bbc:	10c7883a 	add	r3,r2,r3
81126bc0:	21cf883a 	add	r7,r4,r7
81126bc4:	10c00d2e 	bgeu	r2,r3,81126bfc <__copybits+0x64>
81126bc8:	200b883a 	mov	r5,r4
81126bcc:	12000017 	ldw	r8,0(r2)
81126bd0:	29400104 	addi	r5,r5,4
81126bd4:	10800104 	addi	r2,r2,4
81126bd8:	2a3fff15 	stw	r8,-4(r5)
81126bdc:	10fffb36 	bltu	r2,r3,81126bcc <__reset+0xfb106bcc>
81126be0:	1985c83a 	sub	r2,r3,r6
81126be4:	10bffac4 	addi	r2,r2,-21
81126be8:	1004d0ba 	srli	r2,r2,2
81126bec:	10800044 	addi	r2,r2,1
81126bf0:	1085883a 	add	r2,r2,r2
81126bf4:	1085883a 	add	r2,r2,r2
81126bf8:	2089883a 	add	r4,r4,r2
81126bfc:	21c0032e 	bgeu	r4,r7,81126c0c <__copybits+0x74>
81126c00:	20000015 	stw	zero,0(r4)
81126c04:	21000104 	addi	r4,r4,4
81126c08:	21fffd36 	bltu	r4,r7,81126c00 <__reset+0xfb106c00>
81126c0c:	f800283a 	ret

81126c10 <__any_on>:
81126c10:	20c00417 	ldw	r3,16(r4)
81126c14:	2805d17a 	srai	r2,r5,5
81126c18:	21000504 	addi	r4,r4,20
81126c1c:	18800d0e 	bge	r3,r2,81126c54 <__any_on+0x44>
81126c20:	18c7883a 	add	r3,r3,r3
81126c24:	18c7883a 	add	r3,r3,r3
81126c28:	20c7883a 	add	r3,r4,r3
81126c2c:	20c0192e 	bgeu	r4,r3,81126c94 <__any_on+0x84>
81126c30:	18bfff17 	ldw	r2,-4(r3)
81126c34:	18ffff04 	addi	r3,r3,-4
81126c38:	1000041e 	bne	r2,zero,81126c4c <__any_on+0x3c>
81126c3c:	20c0142e 	bgeu	r4,r3,81126c90 <__any_on+0x80>
81126c40:	18ffff04 	addi	r3,r3,-4
81126c44:	19400017 	ldw	r5,0(r3)
81126c48:	283ffc26 	beq	r5,zero,81126c3c <__reset+0xfb106c3c>
81126c4c:	00800044 	movi	r2,1
81126c50:	f800283a 	ret
81126c54:	10c00a0e 	bge	r2,r3,81126c80 <__any_on+0x70>
81126c58:	1085883a 	add	r2,r2,r2
81126c5c:	1085883a 	add	r2,r2,r2
81126c60:	294007cc 	andi	r5,r5,31
81126c64:	2087883a 	add	r3,r4,r2
81126c68:	283ff026 	beq	r5,zero,81126c2c <__reset+0xfb106c2c>
81126c6c:	19800017 	ldw	r6,0(r3)
81126c70:	3144d83a 	srl	r2,r6,r5
81126c74:	114a983a 	sll	r5,r2,r5
81126c78:	317ff41e 	bne	r6,r5,81126c4c <__reset+0xfb106c4c>
81126c7c:	003feb06 	br	81126c2c <__reset+0xfb106c2c>
81126c80:	1085883a 	add	r2,r2,r2
81126c84:	1085883a 	add	r2,r2,r2
81126c88:	2087883a 	add	r3,r4,r2
81126c8c:	003fe706 	br	81126c2c <__reset+0xfb106c2c>
81126c90:	f800283a 	ret
81126c94:	0005883a 	mov	r2,zero
81126c98:	f800283a 	ret

81126c9c <_read_r>:
81126c9c:	defffd04 	addi	sp,sp,-12
81126ca0:	de00012e 	bgeu	sp,et,81126ca8 <_read_r+0xc>
81126ca4:	003b68fa 	trap	3
81126ca8:	2805883a 	mov	r2,r5
81126cac:	dc000015 	stw	r16,0(sp)
81126cb0:	04204574 	movhi	r16,33045
81126cb4:	dc400115 	stw	r17,4(sp)
81126cb8:	300b883a 	mov	r5,r6
81126cbc:	8430fa04 	addi	r16,r16,-15384
81126cc0:	2023883a 	mov	r17,r4
81126cc4:	380d883a 	mov	r6,r7
81126cc8:	1009883a 	mov	r4,r2
81126ccc:	dfc00215 	stw	ra,8(sp)
81126cd0:	80000015 	stw	zero,0(r16)
81126cd4:	11318180 	call	81131818 <read>
81126cd8:	00ffffc4 	movi	r3,-1
81126cdc:	10c00526 	beq	r2,r3,81126cf4 <_read_r+0x58>
81126ce0:	dfc00217 	ldw	ra,8(sp)
81126ce4:	dc400117 	ldw	r17,4(sp)
81126ce8:	dc000017 	ldw	r16,0(sp)
81126cec:	dec00304 	addi	sp,sp,12
81126cf0:	f800283a 	ret
81126cf4:	80c00017 	ldw	r3,0(r16)
81126cf8:	183ff926 	beq	r3,zero,81126ce0 <__reset+0xfb106ce0>
81126cfc:	88c00015 	stw	r3,0(r17)
81126d00:	003ff706 	br	81126ce0 <__reset+0xfb106ce0>

81126d04 <_realloc_r>:
81126d04:	defff604 	addi	sp,sp,-40
81126d08:	de00012e 	bgeu	sp,et,81126d10 <_realloc_r+0xc>
81126d0c:	003b68fa 	trap	3
81126d10:	dc800215 	stw	r18,8(sp)
81126d14:	dfc00915 	stw	ra,36(sp)
81126d18:	df000815 	stw	fp,32(sp)
81126d1c:	ddc00715 	stw	r23,28(sp)
81126d20:	dd800615 	stw	r22,24(sp)
81126d24:	dd400515 	stw	r21,20(sp)
81126d28:	dd000415 	stw	r20,16(sp)
81126d2c:	dcc00315 	stw	r19,12(sp)
81126d30:	dc400115 	stw	r17,4(sp)
81126d34:	dc000015 	stw	r16,0(sp)
81126d38:	3025883a 	mov	r18,r6
81126d3c:	2800b726 	beq	r5,zero,8112701c <_realloc_r+0x318>
81126d40:	282b883a 	mov	r21,r5
81126d44:	2029883a 	mov	r20,r4
81126d48:	1131ff80 	call	81131ff8 <__malloc_lock>
81126d4c:	a8bfff17 	ldw	r2,-4(r21)
81126d50:	043fff04 	movi	r16,-4
81126d54:	90c002c4 	addi	r3,r18,11
81126d58:	01000584 	movi	r4,22
81126d5c:	acfffe04 	addi	r19,r21,-8
81126d60:	1420703a 	and	r16,r2,r16
81126d64:	20c0332e 	bgeu	r4,r3,81126e34 <_realloc_r+0x130>
81126d68:	047ffe04 	movi	r17,-8
81126d6c:	1c62703a 	and	r17,r3,r17
81126d70:	8807883a 	mov	r3,r17
81126d74:	88005816 	blt	r17,zero,81126ed8 <_realloc_r+0x1d4>
81126d78:	8c805736 	bltu	r17,r18,81126ed8 <_realloc_r+0x1d4>
81126d7c:	80c0300e 	bge	r16,r3,81126e40 <_realloc_r+0x13c>
81126d80:	07204574 	movhi	fp,33045
81126d84:	e72a4004 	addi	fp,fp,-22272
81126d88:	e1c00217 	ldw	r7,8(fp)
81126d8c:	9c09883a 	add	r4,r19,r16
81126d90:	22000117 	ldw	r8,4(r4)
81126d94:	21c06326 	beq	r4,r7,81126f24 <_realloc_r+0x220>
81126d98:	017fff84 	movi	r5,-2
81126d9c:	414a703a 	and	r5,r8,r5
81126da0:	214b883a 	add	r5,r4,r5
81126da4:	29800117 	ldw	r6,4(r5)
81126da8:	3180004c 	andi	r6,r6,1
81126dac:	30003f26 	beq	r6,zero,81126eac <_realloc_r+0x1a8>
81126db0:	1080004c 	andi	r2,r2,1
81126db4:	10008326 	beq	r2,zero,81126fc4 <_realloc_r+0x2c0>
81126db8:	900b883a 	mov	r5,r18
81126dbc:	a009883a 	mov	r4,r20
81126dc0:	111b1fc0 	call	8111b1fc <_malloc_r>
81126dc4:	1025883a 	mov	r18,r2
81126dc8:	10011e26 	beq	r2,zero,81127244 <_realloc_r+0x540>
81126dcc:	a93fff17 	ldw	r4,-4(r21)
81126dd0:	10fffe04 	addi	r3,r2,-8
81126dd4:	00bfff84 	movi	r2,-2
81126dd8:	2084703a 	and	r2,r4,r2
81126ddc:	9885883a 	add	r2,r19,r2
81126de0:	1880ee26 	beq	r3,r2,8112719c <_realloc_r+0x498>
81126de4:	81bfff04 	addi	r6,r16,-4
81126de8:	00800904 	movi	r2,36
81126dec:	1180b836 	bltu	r2,r6,811270d0 <_realloc_r+0x3cc>
81126df0:	00c004c4 	movi	r3,19
81126df4:	19809636 	bltu	r3,r6,81127050 <_realloc_r+0x34c>
81126df8:	9005883a 	mov	r2,r18
81126dfc:	a807883a 	mov	r3,r21
81126e00:	19000017 	ldw	r4,0(r3)
81126e04:	11000015 	stw	r4,0(r2)
81126e08:	19000117 	ldw	r4,4(r3)
81126e0c:	11000115 	stw	r4,4(r2)
81126e10:	18c00217 	ldw	r3,8(r3)
81126e14:	10c00215 	stw	r3,8(r2)
81126e18:	a80b883a 	mov	r5,r21
81126e1c:	a009883a 	mov	r4,r20
81126e20:	1124c700 	call	81124c70 <_free_r>
81126e24:	a009883a 	mov	r4,r20
81126e28:	11321200 	call	81132120 <__malloc_unlock>
81126e2c:	9005883a 	mov	r2,r18
81126e30:	00001206 	br	81126e7c <_realloc_r+0x178>
81126e34:	00c00404 	movi	r3,16
81126e38:	1823883a 	mov	r17,r3
81126e3c:	003fce06 	br	81126d78 <__reset+0xfb106d78>
81126e40:	a825883a 	mov	r18,r21
81126e44:	8445c83a 	sub	r2,r16,r17
81126e48:	00c003c4 	movi	r3,15
81126e4c:	18802636 	bltu	r3,r2,81126ee8 <_realloc_r+0x1e4>
81126e50:	99800117 	ldw	r6,4(r19)
81126e54:	9c07883a 	add	r3,r19,r16
81126e58:	3180004c 	andi	r6,r6,1
81126e5c:	3420b03a 	or	r16,r6,r16
81126e60:	9c000115 	stw	r16,4(r19)
81126e64:	18800117 	ldw	r2,4(r3)
81126e68:	10800054 	ori	r2,r2,1
81126e6c:	18800115 	stw	r2,4(r3)
81126e70:	a009883a 	mov	r4,r20
81126e74:	11321200 	call	81132120 <__malloc_unlock>
81126e78:	9005883a 	mov	r2,r18
81126e7c:	dfc00917 	ldw	ra,36(sp)
81126e80:	df000817 	ldw	fp,32(sp)
81126e84:	ddc00717 	ldw	r23,28(sp)
81126e88:	dd800617 	ldw	r22,24(sp)
81126e8c:	dd400517 	ldw	r21,20(sp)
81126e90:	dd000417 	ldw	r20,16(sp)
81126e94:	dcc00317 	ldw	r19,12(sp)
81126e98:	dc800217 	ldw	r18,8(sp)
81126e9c:	dc400117 	ldw	r17,4(sp)
81126ea0:	dc000017 	ldw	r16,0(sp)
81126ea4:	dec00a04 	addi	sp,sp,40
81126ea8:	f800283a 	ret
81126eac:	017fff04 	movi	r5,-4
81126eb0:	414a703a 	and	r5,r8,r5
81126eb4:	814d883a 	add	r6,r16,r5
81126eb8:	30c01f16 	blt	r6,r3,81126f38 <_realloc_r+0x234>
81126ebc:	20800317 	ldw	r2,12(r4)
81126ec0:	20c00217 	ldw	r3,8(r4)
81126ec4:	a825883a 	mov	r18,r21
81126ec8:	3021883a 	mov	r16,r6
81126ecc:	18800315 	stw	r2,12(r3)
81126ed0:	10c00215 	stw	r3,8(r2)
81126ed4:	003fdb06 	br	81126e44 <__reset+0xfb106e44>
81126ed8:	00800304 	movi	r2,12
81126edc:	a0800015 	stw	r2,0(r20)
81126ee0:	0005883a 	mov	r2,zero
81126ee4:	003fe506 	br	81126e7c <__reset+0xfb106e7c>
81126ee8:	98c00117 	ldw	r3,4(r19)
81126eec:	9c4b883a 	add	r5,r19,r17
81126ef0:	11000054 	ori	r4,r2,1
81126ef4:	18c0004c 	andi	r3,r3,1
81126ef8:	1c62b03a 	or	r17,r3,r17
81126efc:	9c400115 	stw	r17,4(r19)
81126f00:	29000115 	stw	r4,4(r5)
81126f04:	2885883a 	add	r2,r5,r2
81126f08:	10c00117 	ldw	r3,4(r2)
81126f0c:	29400204 	addi	r5,r5,8
81126f10:	a009883a 	mov	r4,r20
81126f14:	18c00054 	ori	r3,r3,1
81126f18:	10c00115 	stw	r3,4(r2)
81126f1c:	1124c700 	call	81124c70 <_free_r>
81126f20:	003fd306 	br	81126e70 <__reset+0xfb106e70>
81126f24:	017fff04 	movi	r5,-4
81126f28:	414a703a 	and	r5,r8,r5
81126f2c:	89800404 	addi	r6,r17,16
81126f30:	8151883a 	add	r8,r16,r5
81126f34:	4180590e 	bge	r8,r6,8112709c <_realloc_r+0x398>
81126f38:	1080004c 	andi	r2,r2,1
81126f3c:	103f9e1e 	bne	r2,zero,81126db8 <__reset+0xfb106db8>
81126f40:	adbffe17 	ldw	r22,-8(r21)
81126f44:	00bfff04 	movi	r2,-4
81126f48:	9dadc83a 	sub	r22,r19,r22
81126f4c:	b1800117 	ldw	r6,4(r22)
81126f50:	3084703a 	and	r2,r6,r2
81126f54:	20002026 	beq	r4,zero,81126fd8 <_realloc_r+0x2d4>
81126f58:	80af883a 	add	r23,r16,r2
81126f5c:	b96f883a 	add	r23,r23,r5
81126f60:	21c05f26 	beq	r4,r7,811270e0 <_realloc_r+0x3dc>
81126f64:	b8c01c16 	blt	r23,r3,81126fd8 <_realloc_r+0x2d4>
81126f68:	20800317 	ldw	r2,12(r4)
81126f6c:	20c00217 	ldw	r3,8(r4)
81126f70:	81bfff04 	addi	r6,r16,-4
81126f74:	01000904 	movi	r4,36
81126f78:	18800315 	stw	r2,12(r3)
81126f7c:	10c00215 	stw	r3,8(r2)
81126f80:	b0c00217 	ldw	r3,8(r22)
81126f84:	b0800317 	ldw	r2,12(r22)
81126f88:	b4800204 	addi	r18,r22,8
81126f8c:	18800315 	stw	r2,12(r3)
81126f90:	10c00215 	stw	r3,8(r2)
81126f94:	21801b36 	bltu	r4,r6,81127004 <_realloc_r+0x300>
81126f98:	008004c4 	movi	r2,19
81126f9c:	1180352e 	bgeu	r2,r6,81127074 <_realloc_r+0x370>
81126fa0:	a8800017 	ldw	r2,0(r21)
81126fa4:	b0800215 	stw	r2,8(r22)
81126fa8:	a8800117 	ldw	r2,4(r21)
81126fac:	b0800315 	stw	r2,12(r22)
81126fb0:	008006c4 	movi	r2,27
81126fb4:	11807f36 	bltu	r2,r6,811271b4 <_realloc_r+0x4b0>
81126fb8:	b0800404 	addi	r2,r22,16
81126fbc:	ad400204 	addi	r21,r21,8
81126fc0:	00002d06 	br	81127078 <_realloc_r+0x374>
81126fc4:	adbffe17 	ldw	r22,-8(r21)
81126fc8:	00bfff04 	movi	r2,-4
81126fcc:	9dadc83a 	sub	r22,r19,r22
81126fd0:	b1000117 	ldw	r4,4(r22)
81126fd4:	2084703a 	and	r2,r4,r2
81126fd8:	b03f7726 	beq	r22,zero,81126db8 <__reset+0xfb106db8>
81126fdc:	80af883a 	add	r23,r16,r2
81126fe0:	b8ff7516 	blt	r23,r3,81126db8 <__reset+0xfb106db8>
81126fe4:	b0800317 	ldw	r2,12(r22)
81126fe8:	b0c00217 	ldw	r3,8(r22)
81126fec:	81bfff04 	addi	r6,r16,-4
81126ff0:	01000904 	movi	r4,36
81126ff4:	18800315 	stw	r2,12(r3)
81126ff8:	10c00215 	stw	r3,8(r2)
81126ffc:	b4800204 	addi	r18,r22,8
81127000:	21bfe52e 	bgeu	r4,r6,81126f98 <__reset+0xfb106f98>
81127004:	a80b883a 	mov	r5,r21
81127008:	9009883a 	mov	r4,r18
8112700c:	1125ae40 	call	81125ae4 <memmove>
81127010:	b821883a 	mov	r16,r23
81127014:	b027883a 	mov	r19,r22
81127018:	003f8a06 	br	81126e44 <__reset+0xfb106e44>
8112701c:	300b883a 	mov	r5,r6
81127020:	dfc00917 	ldw	ra,36(sp)
81127024:	df000817 	ldw	fp,32(sp)
81127028:	ddc00717 	ldw	r23,28(sp)
8112702c:	dd800617 	ldw	r22,24(sp)
81127030:	dd400517 	ldw	r21,20(sp)
81127034:	dd000417 	ldw	r20,16(sp)
81127038:	dcc00317 	ldw	r19,12(sp)
8112703c:	dc800217 	ldw	r18,8(sp)
81127040:	dc400117 	ldw	r17,4(sp)
81127044:	dc000017 	ldw	r16,0(sp)
81127048:	dec00a04 	addi	sp,sp,40
8112704c:	111b1fc1 	jmpi	8111b1fc <_malloc_r>
81127050:	a8c00017 	ldw	r3,0(r21)
81127054:	90c00015 	stw	r3,0(r18)
81127058:	a8c00117 	ldw	r3,4(r21)
8112705c:	90c00115 	stw	r3,4(r18)
81127060:	00c006c4 	movi	r3,27
81127064:	19804536 	bltu	r3,r6,8112717c <_realloc_r+0x478>
81127068:	90800204 	addi	r2,r18,8
8112706c:	a8c00204 	addi	r3,r21,8
81127070:	003f6306 	br	81126e00 <__reset+0xfb106e00>
81127074:	9005883a 	mov	r2,r18
81127078:	a8c00017 	ldw	r3,0(r21)
8112707c:	b821883a 	mov	r16,r23
81127080:	b027883a 	mov	r19,r22
81127084:	10c00015 	stw	r3,0(r2)
81127088:	a8c00117 	ldw	r3,4(r21)
8112708c:	10c00115 	stw	r3,4(r2)
81127090:	a8c00217 	ldw	r3,8(r21)
81127094:	10c00215 	stw	r3,8(r2)
81127098:	003f6a06 	br	81126e44 <__reset+0xfb106e44>
8112709c:	9c67883a 	add	r19,r19,r17
811270a0:	4445c83a 	sub	r2,r8,r17
811270a4:	e4c00215 	stw	r19,8(fp)
811270a8:	10800054 	ori	r2,r2,1
811270ac:	98800115 	stw	r2,4(r19)
811270b0:	a8bfff17 	ldw	r2,-4(r21)
811270b4:	a009883a 	mov	r4,r20
811270b8:	1080004c 	andi	r2,r2,1
811270bc:	1462b03a 	or	r17,r2,r17
811270c0:	ac7fff15 	stw	r17,-4(r21)
811270c4:	11321200 	call	81132120 <__malloc_unlock>
811270c8:	a805883a 	mov	r2,r21
811270cc:	003f6b06 	br	81126e7c <__reset+0xfb106e7c>
811270d0:	a80b883a 	mov	r5,r21
811270d4:	9009883a 	mov	r4,r18
811270d8:	1125ae40 	call	81125ae4 <memmove>
811270dc:	003f4e06 	br	81126e18 <__reset+0xfb106e18>
811270e0:	89000404 	addi	r4,r17,16
811270e4:	b93fbc16 	blt	r23,r4,81126fd8 <__reset+0xfb106fd8>
811270e8:	b0800317 	ldw	r2,12(r22)
811270ec:	b0c00217 	ldw	r3,8(r22)
811270f0:	81bfff04 	addi	r6,r16,-4
811270f4:	01000904 	movi	r4,36
811270f8:	18800315 	stw	r2,12(r3)
811270fc:	10c00215 	stw	r3,8(r2)
81127100:	b4800204 	addi	r18,r22,8
81127104:	21804336 	bltu	r4,r6,81127214 <_realloc_r+0x510>
81127108:	008004c4 	movi	r2,19
8112710c:	11803f2e 	bgeu	r2,r6,8112720c <_realloc_r+0x508>
81127110:	a8800017 	ldw	r2,0(r21)
81127114:	b0800215 	stw	r2,8(r22)
81127118:	a8800117 	ldw	r2,4(r21)
8112711c:	b0800315 	stw	r2,12(r22)
81127120:	008006c4 	movi	r2,27
81127124:	11803f36 	bltu	r2,r6,81127224 <_realloc_r+0x520>
81127128:	b0800404 	addi	r2,r22,16
8112712c:	ad400204 	addi	r21,r21,8
81127130:	a8c00017 	ldw	r3,0(r21)
81127134:	10c00015 	stw	r3,0(r2)
81127138:	a8c00117 	ldw	r3,4(r21)
8112713c:	10c00115 	stw	r3,4(r2)
81127140:	a8c00217 	ldw	r3,8(r21)
81127144:	10c00215 	stw	r3,8(r2)
81127148:	b447883a 	add	r3,r22,r17
8112714c:	bc45c83a 	sub	r2,r23,r17
81127150:	e0c00215 	stw	r3,8(fp)
81127154:	10800054 	ori	r2,r2,1
81127158:	18800115 	stw	r2,4(r3)
8112715c:	b0800117 	ldw	r2,4(r22)
81127160:	a009883a 	mov	r4,r20
81127164:	1080004c 	andi	r2,r2,1
81127168:	1462b03a 	or	r17,r2,r17
8112716c:	b4400115 	stw	r17,4(r22)
81127170:	11321200 	call	81132120 <__malloc_unlock>
81127174:	9005883a 	mov	r2,r18
81127178:	003f4006 	br	81126e7c <__reset+0xfb106e7c>
8112717c:	a8c00217 	ldw	r3,8(r21)
81127180:	90c00215 	stw	r3,8(r18)
81127184:	a8c00317 	ldw	r3,12(r21)
81127188:	90c00315 	stw	r3,12(r18)
8112718c:	30801126 	beq	r6,r2,811271d4 <_realloc_r+0x4d0>
81127190:	90800404 	addi	r2,r18,16
81127194:	a8c00404 	addi	r3,r21,16
81127198:	003f1906 	br	81126e00 <__reset+0xfb106e00>
8112719c:	90ffff17 	ldw	r3,-4(r18)
811271a0:	00bfff04 	movi	r2,-4
811271a4:	a825883a 	mov	r18,r21
811271a8:	1884703a 	and	r2,r3,r2
811271ac:	80a1883a 	add	r16,r16,r2
811271b0:	003f2406 	br	81126e44 <__reset+0xfb106e44>
811271b4:	a8800217 	ldw	r2,8(r21)
811271b8:	b0800415 	stw	r2,16(r22)
811271bc:	a8800317 	ldw	r2,12(r21)
811271c0:	b0800515 	stw	r2,20(r22)
811271c4:	31000a26 	beq	r6,r4,811271f0 <_realloc_r+0x4ec>
811271c8:	b0800604 	addi	r2,r22,24
811271cc:	ad400404 	addi	r21,r21,16
811271d0:	003fa906 	br	81127078 <__reset+0xfb107078>
811271d4:	a9000417 	ldw	r4,16(r21)
811271d8:	90800604 	addi	r2,r18,24
811271dc:	a8c00604 	addi	r3,r21,24
811271e0:	91000415 	stw	r4,16(r18)
811271e4:	a9000517 	ldw	r4,20(r21)
811271e8:	91000515 	stw	r4,20(r18)
811271ec:	003f0406 	br	81126e00 <__reset+0xfb106e00>
811271f0:	a8c00417 	ldw	r3,16(r21)
811271f4:	ad400604 	addi	r21,r21,24
811271f8:	b0800804 	addi	r2,r22,32
811271fc:	b0c00615 	stw	r3,24(r22)
81127200:	a8ffff17 	ldw	r3,-4(r21)
81127204:	b0c00715 	stw	r3,28(r22)
81127208:	003f9b06 	br	81127078 <__reset+0xfb107078>
8112720c:	9005883a 	mov	r2,r18
81127210:	003fc706 	br	81127130 <__reset+0xfb107130>
81127214:	a80b883a 	mov	r5,r21
81127218:	9009883a 	mov	r4,r18
8112721c:	1125ae40 	call	81125ae4 <memmove>
81127220:	003fc906 	br	81127148 <__reset+0xfb107148>
81127224:	a8800217 	ldw	r2,8(r21)
81127228:	b0800415 	stw	r2,16(r22)
8112722c:	a8800317 	ldw	r2,12(r21)
81127230:	b0800515 	stw	r2,20(r22)
81127234:	31000726 	beq	r6,r4,81127254 <_realloc_r+0x550>
81127238:	b0800604 	addi	r2,r22,24
8112723c:	ad400404 	addi	r21,r21,16
81127240:	003fbb06 	br	81127130 <__reset+0xfb107130>
81127244:	a009883a 	mov	r4,r20
81127248:	11321200 	call	81132120 <__malloc_unlock>
8112724c:	0005883a 	mov	r2,zero
81127250:	003f0a06 	br	81126e7c <__reset+0xfb106e7c>
81127254:	a8c00417 	ldw	r3,16(r21)
81127258:	ad400604 	addi	r21,r21,24
8112725c:	b0800804 	addi	r2,r22,32
81127260:	b0c00615 	stw	r3,24(r22)
81127264:	a8ffff17 	ldw	r3,-4(r21)
81127268:	b0c00715 	stw	r3,28(r22)
8112726c:	003fb006 	br	81127130 <__reset+0xfb107130>

81127270 <__fpclassifyd>:
81127270:	00a00034 	movhi	r2,32768
81127274:	10bfffc4 	addi	r2,r2,-1
81127278:	2884703a 	and	r2,r5,r2
8112727c:	10000726 	beq	r2,zero,8112729c <__fpclassifyd+0x2c>
81127280:	00fffc34 	movhi	r3,65520
81127284:	019ff834 	movhi	r6,32736
81127288:	28c7883a 	add	r3,r5,r3
8112728c:	31bfffc4 	addi	r6,r6,-1
81127290:	30c00536 	bltu	r6,r3,811272a8 <__fpclassifyd+0x38>
81127294:	00800104 	movi	r2,4
81127298:	f800283a 	ret
8112729c:	2000021e 	bne	r4,zero,811272a8 <__fpclassifyd+0x38>
811272a0:	00800084 	movi	r2,2
811272a4:	f800283a 	ret
811272a8:	00dffc34 	movhi	r3,32752
811272ac:	019ff834 	movhi	r6,32736
811272b0:	28cb883a 	add	r5,r5,r3
811272b4:	31bfffc4 	addi	r6,r6,-1
811272b8:	317ff62e 	bgeu	r6,r5,81127294 <__reset+0xfb107294>
811272bc:	01400434 	movhi	r5,16
811272c0:	297fffc4 	addi	r5,r5,-1
811272c4:	28800236 	bltu	r5,r2,811272d0 <__fpclassifyd+0x60>
811272c8:	008000c4 	movi	r2,3
811272cc:	f800283a 	ret
811272d0:	10c00226 	beq	r2,r3,811272dc <__fpclassifyd+0x6c>
811272d4:	0005883a 	mov	r2,zero
811272d8:	f800283a 	ret
811272dc:	2005003a 	cmpeq	r2,r4,zero
811272e0:	f800283a 	ret

811272e4 <__sccl>:
811272e4:	2a000003 	ldbu	r8,0(r5)
811272e8:	00801784 	movi	r2,94
811272ec:	40802a26 	beq	r8,r2,81127398 <__sccl+0xb4>
811272f0:	29400044 	addi	r5,r5,1
811272f4:	000f883a 	mov	r7,zero
811272f8:	0013883a 	mov	r9,zero
811272fc:	2007883a 	mov	r3,r4
81127300:	21804004 	addi	r6,r4,256
81127304:	19c00005 	stb	r7,0(r3)
81127308:	18c00044 	addi	r3,r3,1
8112730c:	19bffd1e 	bne	r3,r6,81127304 <__reset+0xfb107304>
81127310:	40001126 	beq	r8,zero,81127358 <__sccl+0x74>
81127314:	00800044 	movi	r2,1
81127318:	124fc83a 	sub	r7,r2,r9
8112731c:	02800b44 	movi	r10,45
81127320:	02c01744 	movi	r11,93
81127324:	2205883a 	add	r2,r4,r8
81127328:	11c00005 	stb	r7,0(r2)
8112732c:	28800044 	addi	r2,r5,1
81127330:	28c00003 	ldbu	r3,0(r5)
81127334:	1a800a26 	beq	r3,r10,81127360 <__sccl+0x7c>
81127338:	1ac00426 	beq	r3,r11,8112734c <__sccl+0x68>
8112733c:	18000426 	beq	r3,zero,81127350 <__sccl+0x6c>
81127340:	1811883a 	mov	r8,r3
81127344:	100b883a 	mov	r5,r2
81127348:	003ff606 	br	81127324 <__reset+0xfb107324>
8112734c:	f800283a 	ret
81127350:	2805883a 	mov	r2,r5
81127354:	f800283a 	ret
81127358:	28bfffc4 	addi	r2,r5,-1
8112735c:	f800283a 	ret
81127360:	12400003 	ldbu	r9,0(r2)
81127364:	4ac01126 	beq	r9,r11,811273ac <__sccl+0xc8>
81127368:	4a001016 	blt	r9,r8,811273ac <__sccl+0xc8>
8112736c:	41800044 	addi	r6,r8,1
81127370:	29400084 	addi	r5,r5,2
81127374:	2187883a 	add	r3,r4,r6
81127378:	00000106 	br	81127380 <__sccl+0x9c>
8112737c:	31800044 	addi	r6,r6,1
81127380:	19c00005 	stb	r7,0(r3)
81127384:	3011883a 	mov	r8,r6
81127388:	18c00044 	addi	r3,r3,1
8112738c:	327ffb16 	blt	r6,r9,8112737c <__reset+0xfb10737c>
81127390:	10800084 	addi	r2,r2,2
81127394:	003fe606 	br	81127330 <__reset+0xfb107330>
81127398:	2a000043 	ldbu	r8,1(r5)
8112739c:	01c00044 	movi	r7,1
811273a0:	29400084 	addi	r5,r5,2
811273a4:	02400044 	movi	r9,1
811273a8:	003fd406 	br	811272fc <__reset+0xfb1072fc>
811273ac:	5011883a 	mov	r8,r10
811273b0:	003fe406 	br	81127344 <__reset+0xfb107344>

811273b4 <nanf>:
811273b4:	009ff034 	movhi	r2,32704
811273b8:	f800283a 	ret

811273bc <strcmp>:
811273bc:	2144b03a 	or	r2,r4,r5
811273c0:	108000cc 	andi	r2,r2,3
811273c4:	1000171e 	bne	r2,zero,81127424 <strcmp+0x68>
811273c8:	20800017 	ldw	r2,0(r4)
811273cc:	28c00017 	ldw	r3,0(r5)
811273d0:	10c0141e 	bne	r2,r3,81127424 <strcmp+0x68>
811273d4:	027fbff4 	movhi	r9,65279
811273d8:	4a7fbfc4 	addi	r9,r9,-257
811273dc:	0086303a 	nor	r3,zero,r2
811273e0:	02202074 	movhi	r8,32897
811273e4:	1245883a 	add	r2,r2,r9
811273e8:	42202004 	addi	r8,r8,-32640
811273ec:	10c4703a 	and	r2,r2,r3
811273f0:	1204703a 	and	r2,r2,r8
811273f4:	10000226 	beq	r2,zero,81127400 <strcmp+0x44>
811273f8:	00002306 	br	81127488 <strcmp+0xcc>
811273fc:	1000221e 	bne	r2,zero,81127488 <strcmp+0xcc>
81127400:	21000104 	addi	r4,r4,4
81127404:	20c00017 	ldw	r3,0(r4)
81127408:	29400104 	addi	r5,r5,4
8112740c:	29800017 	ldw	r6,0(r5)
81127410:	1a4f883a 	add	r7,r3,r9
81127414:	00c4303a 	nor	r2,zero,r3
81127418:	3884703a 	and	r2,r7,r2
8112741c:	1204703a 	and	r2,r2,r8
81127420:	19bff626 	beq	r3,r6,811273fc <__reset+0xfb1073fc>
81127424:	20800003 	ldbu	r2,0(r4)
81127428:	10c03fcc 	andi	r3,r2,255
8112742c:	18c0201c 	xori	r3,r3,128
81127430:	18ffe004 	addi	r3,r3,-128
81127434:	18000c26 	beq	r3,zero,81127468 <strcmp+0xac>
81127438:	29800007 	ldb	r6,0(r5)
8112743c:	19800326 	beq	r3,r6,8112744c <strcmp+0x90>
81127440:	00001306 	br	81127490 <strcmp+0xd4>
81127444:	29800007 	ldb	r6,0(r5)
81127448:	11800b1e 	bne	r2,r6,81127478 <strcmp+0xbc>
8112744c:	21000044 	addi	r4,r4,1
81127450:	20c00003 	ldbu	r3,0(r4)
81127454:	29400044 	addi	r5,r5,1
81127458:	18803fcc 	andi	r2,r3,255
8112745c:	1080201c 	xori	r2,r2,128
81127460:	10bfe004 	addi	r2,r2,-128
81127464:	103ff71e 	bne	r2,zero,81127444 <__reset+0xfb107444>
81127468:	0007883a 	mov	r3,zero
8112746c:	28800003 	ldbu	r2,0(r5)
81127470:	1885c83a 	sub	r2,r3,r2
81127474:	f800283a 	ret
81127478:	28800003 	ldbu	r2,0(r5)
8112747c:	18c03fcc 	andi	r3,r3,255
81127480:	1885c83a 	sub	r2,r3,r2
81127484:	f800283a 	ret
81127488:	0005883a 	mov	r2,zero
8112748c:	f800283a 	ret
81127490:	10c03fcc 	andi	r3,r2,255
81127494:	003ff506 	br	8112746c <__reset+0xfb10746c>

81127498 <sulp>:
81127498:	defffd04 	addi	sp,sp,-12
8112749c:	de00012e 	bgeu	sp,et,811274a4 <sulp+0xc>
811274a0:	003b68fa 	trap	3
811274a4:	dc400115 	stw	r17,4(sp)
811274a8:	3023883a 	mov	r17,r6
811274ac:	dc000015 	stw	r16,0(sp)
811274b0:	dfc00215 	stw	ra,8(sp)
811274b4:	2821883a 	mov	r16,r5
811274b8:	11267a40 	call	811267a4 <__ulp>
811274bc:	88000c26 	beq	r17,zero,811274f0 <sulp+0x58>
811274c0:	841ffc2c 	andhi	r16,r16,32752
811274c4:	8020d53a 	srli	r16,r16,20
811274c8:	01c01ac4 	movi	r7,107
811274cc:	3c21c83a 	sub	r16,r7,r16
811274d0:	0400070e 	bge	zero,r16,811274f0 <sulp+0x58>
811274d4:	8020953a 	slli	r16,r16,20
811274d8:	01cffc34 	movhi	r7,16368
811274dc:	000d883a 	mov	r6,zero
811274e0:	81cf883a 	add	r7,r16,r7
811274e4:	1009883a 	mov	r4,r2
811274e8:	180b883a 	mov	r5,r3
811274ec:	1119dc00 	call	81119dc0 <__muldf3>
811274f0:	dfc00217 	ldw	ra,8(sp)
811274f4:	dc400117 	ldw	r17,4(sp)
811274f8:	dc000017 	ldw	r16,0(sp)
811274fc:	dec00304 	addi	sp,sp,12
81127500:	f800283a 	ret

81127504 <_strtod_r>:
81127504:	deffe204 	addi	sp,sp,-120
81127508:	de00012e 	bgeu	sp,et,81127510 <_strtod_r+0xc>
8112750c:	003b68fa 	trap	3
81127510:	ddc01b15 	stw	r23,108(sp)
81127514:	dd001815 	stw	r20,96(sp)
81127518:	dc801615 	stw	r18,88(sp)
8112751c:	dc401515 	stw	r17,84(sp)
81127520:	dc001415 	stw	r16,80(sp)
81127524:	d9400615 	stw	r5,24(sp)
81127528:	dfc01d15 	stw	ra,116(sp)
8112752c:	df001c15 	stw	fp,112(sp)
81127530:	dd801a15 	stw	r22,104(sp)
81127534:	dd401915 	stw	r21,100(sp)
81127538:	dcc01715 	stw	r19,92(sp)
8112753c:	2021883a 	mov	r16,r4
81127540:	d8000515 	stw	zero,20(sp)
81127544:	2809883a 	mov	r4,r5
81127548:	20800003 	ldbu	r2,0(r4)
8112754c:	01e044b4 	movhi	r7,33042
81127550:	282f883a 	mov	r23,r5
81127554:	10c03fcc 	andi	r3,r2,255
81127558:	01400b44 	movi	r5,45
8112755c:	39dd6004 	addi	r7,r7,30080
81127560:	3029883a 	mov	r20,r6
81127564:	0025883a 	mov	r18,zero
81127568:	0023883a 	mov	r17,zero
8112756c:	28c0ba36 	bltu	r5,r3,81127858 <_strtod_r+0x354>
81127570:	180690ba 	slli	r3,r3,2
81127574:	19c7883a 	add	r3,r3,r7
81127578:	18c00017 	ldw	r3,0(r3)
8112757c:	1800683a 	jmp	r3
81127580:	81127640 	call	88112764 <__reset+0x20f2764>
81127584:	81127858 	cmpnei	r4,r16,18913
81127588:	81127858 	cmpnei	r4,r16,18913
8112758c:	81127858 	cmpnei	r4,r16,18913
81127590:	81127858 	cmpnei	r4,r16,18913
81127594:	81127858 	cmpnei	r4,r16,18913
81127598:	81127858 	cmpnei	r4,r16,18913
8112759c:	81127858 	cmpnei	r4,r16,18913
811275a0:	81127858 	cmpnei	r4,r16,18913
811275a4:	81127844 	addi	r4,r16,18913
811275a8:	81127844 	addi	r4,r16,18913
811275ac:	81127844 	addi	r4,r16,18913
811275b0:	81127844 	addi	r4,r16,18913
811275b4:	81127844 	addi	r4,r16,18913
811275b8:	81127858 	cmpnei	r4,r16,18913
811275bc:	81127858 	cmpnei	r4,r16,18913
811275c0:	81127858 	cmpnei	r4,r16,18913
811275c4:	81127858 	cmpnei	r4,r16,18913
811275c8:	81127858 	cmpnei	r4,r16,18913
811275cc:	81127858 	cmpnei	r4,r16,18913
811275d0:	81127858 	cmpnei	r4,r16,18913
811275d4:	81127858 	cmpnei	r4,r16,18913
811275d8:	81127858 	cmpnei	r4,r16,18913
811275dc:	81127858 	cmpnei	r4,r16,18913
811275e0:	81127858 	cmpnei	r4,r16,18913
811275e4:	81127858 	cmpnei	r4,r16,18913
811275e8:	81127858 	cmpnei	r4,r16,18913
811275ec:	81127858 	cmpnei	r4,r16,18913
811275f0:	81127858 	cmpnei	r4,r16,18913
811275f4:	81127858 	cmpnei	r4,r16,18913
811275f8:	81127858 	cmpnei	r4,r16,18913
811275fc:	81127858 	cmpnei	r4,r16,18913
81127600:	81127844 	addi	r4,r16,18913
81127604:	81127858 	cmpnei	r4,r16,18913
81127608:	81127858 	cmpnei	r4,r16,18913
8112760c:	81127858 	cmpnei	r4,r16,18913
81127610:	81127858 	cmpnei	r4,r16,18913
81127614:	81127858 	cmpnei	r4,r16,18913
81127618:	81127858 	cmpnei	r4,r16,18913
8112761c:	81127858 	cmpnei	r4,r16,18913
81127620:	81127858 	cmpnei	r4,r16,18913
81127624:	81127858 	cmpnei	r4,r16,18913
81127628:	81127858 	cmpnei	r4,r16,18913
8112762c:	81127698 	cmpnei	r4,r16,18906
81127630:	81127858 	cmpnei	r4,r16,18913
81127634:	81127838 	rdprs	r4,r16,18912
81127638:	00801244 	movi	r2,73
8112763c:	88843526 	beq	r17,r2,81128714 <_strtod_r+0x1210>
81127640:	002b883a 	mov	r21,zero
81127644:	002d883a 	mov	r22,zero
81127648:	a0000526 	beq	r20,zero,81127660 <_strtod_r+0x15c>
8112764c:	d8000715 	stw	zero,28(sp)
81127650:	a5c00015 	stw	r23,0(r20)
81127654:	d9000717 	ldw	r4,28(sp)
81127658:	20000126 	beq	r4,zero,81127660 <_strtod_r+0x15c>
8112765c:	b5a0003c 	xorhi	r22,r22,32768
81127660:	a805883a 	mov	r2,r21
81127664:	b007883a 	mov	r3,r22
81127668:	dfc01d17 	ldw	ra,116(sp)
8112766c:	df001c17 	ldw	fp,112(sp)
81127670:	ddc01b17 	ldw	r23,108(sp)
81127674:	dd801a17 	ldw	r22,104(sp)
81127678:	dd401917 	ldw	r21,100(sp)
8112767c:	dd001817 	ldw	r20,96(sp)
81127680:	dcc01717 	ldw	r19,92(sp)
81127684:	dc801617 	ldw	r18,88(sp)
81127688:	dc401517 	ldw	r17,84(sp)
8112768c:	dc001417 	ldw	r16,80(sp)
81127690:	dec01e04 	addi	sp,sp,120
81127694:	f800283a 	ret
81127698:	d8000715 	stw	zero,28(sp)
8112769c:	24c00044 	addi	r19,r4,1
811276a0:	dcc00615 	stw	r19,24(sp)
811276a4:	20800043 	ldbu	r2,1(r4)
811276a8:	10c03fcc 	andi	r3,r2,255
811276ac:	18c0201c 	xori	r3,r3,128
811276b0:	18ffe004 	addi	r3,r3,-128
811276b4:	183fe226 	beq	r3,zero,81127640 <__reset+0xfb107640>
811276b8:	11403fcc 	andi	r5,r2,255
811276bc:	2940201c 	xori	r5,r5,128
811276c0:	297fe004 	addi	r5,r5,-128
811276c4:	00c00c04 	movi	r3,48
811276c8:	28c0e526 	beq	r5,r3,81127a60 <_strtod_r+0x55c>
811276cc:	dcc00815 	stw	r19,32(sp)
811276d0:	0025883a 	mov	r18,zero
811276d4:	10fff404 	addi	r3,r2,-48
811276d8:	18c03fcc 	andi	r3,r3,255
811276dc:	01000244 	movi	r4,9
811276e0:	20c37536 	bltu	r4,r3,811284b8 <_strtod_r+0xfb4>
811276e4:	dd400817 	ldw	r21,32(sp)
811276e8:	0027883a 	mov	r19,zero
811276ec:	0039883a 	mov	fp,zero
811276f0:	002d883a 	mov	r22,zero
811276f4:	01400204 	movi	r5,8
811276f8:	2d805a16 	blt	r5,r22,81127864 <_strtod_r+0x360>
811276fc:	e70002a4 	muli	fp,fp,10
81127700:	10c03fcc 	andi	r3,r2,255
81127704:	18c0201c 	xori	r3,r3,128
81127708:	18ffe004 	addi	r3,r3,-128
8112770c:	e0f9883a 	add	fp,fp,r3
81127710:	e73ff404 	addi	fp,fp,-48
81127714:	ad400044 	addi	r21,r21,1
81127718:	dd400615 	stw	r21,24(sp)
8112771c:	a8800003 	ldbu	r2,0(r21)
81127720:	b5800044 	addi	r22,r22,1
81127724:	10fff404 	addi	r3,r2,-48
81127728:	18c03fcc 	andi	r3,r3,255
8112772c:	20fff22e 	bgeu	r4,r3,811276f8 <__reset+0xfb1076f8>
81127730:	14403fcc 	andi	r17,r2,255
81127734:	8c40201c 	xori	r17,r17,128
81127738:	8c7fe004 	addi	r17,r17,-128
8112773c:	8009883a 	mov	r4,r16
81127740:	11257240 	call	81125724 <_localeconv_r>
81127744:	11400017 	ldw	r5,0(r2)
81127748:	8009883a 	mov	r4,r16
8112774c:	d9401315 	stw	r5,76(sp)
81127750:	11257240 	call	81125724 <_localeconv_r>
81127754:	11000017 	ldw	r4,0(r2)
81127758:	111c5040 	call	8111c504 <strlen>
8112775c:	d9401317 	ldw	r5,76(sp)
81127760:	100d883a 	mov	r6,r2
81127764:	a809883a 	mov	r4,r21
81127768:	112d0f40 	call	8112d0f4 <strncmp>
8112776c:	1000ce26 	beq	r2,zero,81127aa8 <_strtod_r+0x5a4>
81127770:	b013883a 	mov	r9,r22
81127774:	000b883a 	mov	r5,zero
81127778:	0015883a 	mov	r10,zero
8112777c:	0017883a 	mov	r11,zero
81127780:	00801944 	movi	r2,101
81127784:	88807826 	beq	r17,r2,81127968 <_strtod_r+0x464>
81127788:	00801144 	movi	r2,69
8112778c:	88807626 	beq	r17,r2,81127968 <_strtod_r+0x464>
81127790:	002b883a 	mov	r21,zero
81127794:	48003d1e 	bne	r9,zero,8112788c <_strtod_r+0x388>
81127798:	2800391e 	bne	r5,zero,81127880 <_strtod_r+0x37c>
8112779c:	9000381e 	bne	r18,zero,81127880 <_strtod_r+0x37c>
811277a0:	583fa71e 	bne	r11,zero,81127640 <__reset+0xfb107640>
811277a4:	00801384 	movi	r2,78
811277a8:	88800526 	beq	r17,r2,811277c0 <_strtod_r+0x2bc>
811277ac:	147fa20e 	bge	r2,r17,81127638 <__reset+0xfb107638>
811277b0:	00801a44 	movi	r2,105
811277b4:	8883d726 	beq	r17,r2,81128714 <_strtod_r+0x1210>
811277b8:	00801b84 	movi	r2,110
811277bc:	88bfa01e 	bne	r17,r2,81127640 <__reset+0xfb107640>
811277c0:	01604574 	movhi	r5,33045
811277c4:	d9000617 	ldw	r4,24(sp)
811277c8:	29672804 	addi	r5,r5,-25440
811277cc:	01c00644 	movi	r7,25
811277d0:	00000b06 	br	81127800 <_strtod_r+0x2fc>
811277d4:	21000044 	addi	r4,r4,1
811277d8:	20800003 	ldbu	r2,0(r4)
811277dc:	10ffefc4 	addi	r3,r2,-65
811277e0:	10803fcc 	andi	r2,r2,255
811277e4:	1080201c 	xori	r2,r2,128
811277e8:	18c03fcc 	andi	r3,r3,255
811277ec:	10bfe004 	addi	r2,r2,-128
811277f0:	38c00136 	bltu	r7,r3,811277f8 <_strtod_r+0x2f4>
811277f4:	10800804 	addi	r2,r2,32
811277f8:	29400044 	addi	r5,r5,1
811277fc:	11bf901e 	bne	r2,r6,81127640 <__reset+0xfb107640>
81127800:	29800007 	ldb	r6,0(r5)
81127804:	303ff31e 	bne	r6,zero,811277d4 <__reset+0xfb1077d4>
81127808:	20800044 	addi	r2,r4,1
8112780c:	d8800615 	stw	r2,24(sp)
81127810:	20c00047 	ldb	r3,1(r4)
81127814:	00800a04 	movi	r2,40
81127818:	18849d26 	beq	r3,r2,81128a90 <_strtod_r+0x158c>
8112781c:	047ffe34 	movhi	r17,65528
81127820:	0025883a 	mov	r18,zero
81127824:	902b883a 	mov	r21,r18
81127828:	882d883a 	mov	r22,r17
8112782c:	a03f8926 	beq	r20,zero,81127654 <__reset+0xfb107654>
81127830:	ddc00617 	ldw	r23,24(sp)
81127834:	003f8606 	br	81127650 <__reset+0xfb107650>
81127838:	00800044 	movi	r2,1
8112783c:	d8800715 	stw	r2,28(sp)
81127840:	003f9606 	br	8112769c <__reset+0xfb10769c>
81127844:	21000044 	addi	r4,r4,1
81127848:	d9000615 	stw	r4,24(sp)
8112784c:	20800003 	ldbu	r2,0(r4)
81127850:	10c03fcc 	andi	r3,r2,255
81127854:	28ff462e 	bgeu	r5,r3,81127570 <__reset+0xfb107570>
81127858:	2027883a 	mov	r19,r4
8112785c:	d8000715 	stw	zero,28(sp)
81127860:	003f9506 	br	811276b8 <__reset+0xfb1076b8>
81127864:	9cc002a4 	muli	r19,r19,10
81127868:	10803fcc 	andi	r2,r2,255
8112786c:	1080201c 	xori	r2,r2,128
81127870:	10bfe004 	addi	r2,r2,-128
81127874:	9885883a 	add	r2,r19,r2
81127878:	14fff404 	addi	r19,r2,-48
8112787c:	003fa506 	br	81127714 <__reset+0xfb107714>
81127880:	002b883a 	mov	r21,zero
81127884:	002d883a 	mov	r22,zero
81127888:	003fe806 	br	8112782c <__reset+0xfb10782c>
8112788c:	aaabc83a 	sub	r21,r21,r10
81127890:	b000011e 	bne	r22,zero,81127898 <_strtod_r+0x394>
81127894:	482d883a 	mov	r22,r9
81127898:	00800404 	movi	r2,16
8112789c:	482f883a 	mov	r23,r9
811278a0:	1240010e 	bge	r2,r9,811278a8 <_strtod_r+0x3a4>
811278a4:	102f883a 	mov	r23,r2
811278a8:	e009883a 	mov	r4,fp
811278ac:	da401315 	stw	r9,76(sp)
811278b0:	11301140 	call	81130114 <__floatunsidf>
811278b4:	1025883a 	mov	r18,r2
811278b8:	00800244 	movi	r2,9
811278bc:	1823883a 	mov	r17,r3
811278c0:	da401317 	ldw	r9,76(sp)
811278c4:	15c0160e 	bge	r2,r23,81127920 <_strtod_r+0x41c>
811278c8:	b8bffdc4 	addi	r2,r23,-9
811278cc:	100490fa 	slli	r2,r2,3
811278d0:	180b883a 	mov	r5,r3
811278d4:	00e04574 	movhi	r3,33045
811278d8:	18e6f304 	addi	r3,r3,-25652
811278dc:	1885883a 	add	r2,r3,r2
811278e0:	11800017 	ldw	r6,0(r2)
811278e4:	11c00117 	ldw	r7,4(r2)
811278e8:	9009883a 	mov	r4,r18
811278ec:	1119dc00 	call	81119dc0 <__muldf3>
811278f0:	9809883a 	mov	r4,r19
811278f4:	1025883a 	mov	r18,r2
811278f8:	1823883a 	mov	r17,r3
811278fc:	11301140 	call	81130114 <__floatunsidf>
81127900:	9009883a 	mov	r4,r18
81127904:	880b883a 	mov	r5,r17
81127908:	100d883a 	mov	r6,r2
8112790c:	180f883a 	mov	r7,r3
81127910:	112e2b00 	call	8112e2b0 <__adddf3>
81127914:	da401317 	ldw	r9,76(sp)
81127918:	1025883a 	mov	r18,r2
8112791c:	1823883a 	mov	r17,r3
81127920:	008003c4 	movi	r2,15
81127924:	12407b16 	blt	r2,r9,81127b14 <_strtod_r+0x610>
81127928:	a83fbe26 	beq	r21,zero,81127824 <__reset+0xfb107824>
8112792c:	0543670e 	bge	zero,r21,811286cc <_strtod_r+0x11c8>
81127930:	00c00584 	movi	r3,22
81127934:	1d42e816 	blt	r3,r21,811284d8 <_strtod_r+0xfd4>
81127938:	a82a90fa 	slli	r21,r21,3
8112793c:	00a04574 	movhi	r2,33045
81127940:	10a6f304 	addi	r2,r2,-25652
81127944:	1545883a 	add	r2,r2,r21
81127948:	11000017 	ldw	r4,0(r2)
8112794c:	11400117 	ldw	r5,4(r2)
81127950:	900d883a 	mov	r6,r18
81127954:	880f883a 	mov	r7,r17
81127958:	1119dc00 	call	81119dc0 <__muldf3>
8112795c:	102b883a 	mov	r21,r2
81127960:	182d883a 	mov	r22,r3
81127964:	003fb106 	br	8112782c <__reset+0xfb10782c>
81127968:	4801b526 	beq	r9,zero,81128040 <_strtod_r+0xb3c>
8112796c:	ddc00617 	ldw	r23,24(sp)
81127970:	00c00ac4 	movi	r3,43
81127974:	b8800044 	addi	r2,r23,1
81127978:	d8800615 	stw	r2,24(sp)
8112797c:	b8800047 	ldb	r2,1(r23)
81127980:	10c1e926 	beq	r2,r3,81128128 <_strtod_r+0xc24>
81127984:	00c00b44 	movi	r3,45
81127988:	10c1ec26 	beq	r2,r3,8112813c <_strtod_r+0xc38>
8112798c:	1023883a 	mov	r17,r2
81127990:	0019883a 	mov	r12,zero
81127994:	88bff404 	addi	r2,r17,-48
81127998:	00c00244 	movi	r3,9
8112799c:	1881b736 	bltu	r3,r2,8112807c <_strtod_r+0xb78>
811279a0:	00800c04 	movi	r2,48
811279a4:	8880071e 	bne	r17,r2,811279c4 <_strtod_r+0x4c0>
811279a8:	d8800617 	ldw	r2,24(sp)
811279ac:	8807883a 	mov	r3,r17
811279b0:	10800044 	addi	r2,r2,1
811279b4:	d8800615 	stw	r2,24(sp)
811279b8:	14400007 	ldb	r17,0(r2)
811279bc:	10800044 	addi	r2,r2,1
811279c0:	88fffc26 	beq	r17,r3,811279b4 <__reset+0xfb1079b4>
811279c4:	88bff3c4 	addi	r2,r17,-49
811279c8:	00c00204 	movi	r3,8
811279cc:	18bf7036 	bltu	r3,r2,81127790 <__reset+0xfb107790>
811279d0:	db800617 	ldw	r14,24(sp)
811279d4:	88bff404 	addi	r2,r17,-48
811279d8:	03400244 	movi	r13,9
811279dc:	71c00044 	addi	r7,r14,1
811279e0:	d9c00615 	stw	r7,24(sp)
811279e4:	74400043 	ldbu	r17,1(r14)
811279e8:	88fff404 	addi	r3,r17,-48
811279ec:	8c403fcc 	andi	r17,r17,255
811279f0:	8c40201c 	xori	r17,r17,128
811279f4:	18c03fcc 	andi	r3,r3,255
811279f8:	8c7fe004 	addi	r17,r17,-128
811279fc:	68c00e36 	bltu	r13,r3,81127a38 <_strtod_r+0x534>
81127a00:	71000084 	addi	r4,r14,2
81127a04:	d9000615 	stw	r4,24(sp)
81127a08:	108002a4 	muli	r2,r2,10
81127a0c:	21800003 	ldbu	r6,0(r4)
81127a10:	200f883a 	mov	r7,r4
81127a14:	1463883a 	add	r17,r2,r17
81127a18:	30fff404 	addi	r3,r6,-48
81127a1c:	88bff404 	addi	r2,r17,-48
81127a20:	34403fcc 	andi	r17,r6,255
81127a24:	8c40201c 	xori	r17,r17,128
81127a28:	18c03fcc 	andi	r3,r3,255
81127a2c:	8c7fe004 	addi	r17,r17,-128
81127a30:	21000044 	addi	r4,r4,1
81127a34:	68fff32e 	bgeu	r13,r3,81127a04 <__reset+0xfb107a04>
81127a38:	3b8fc83a 	sub	r7,r7,r14
81127a3c:	00c00204 	movi	r3,8
81127a40:	19c29716 	blt	r3,r7,811284a0 <_strtod_r+0xf9c>
81127a44:	102b883a 	mov	r21,r2
81127a48:	009387c4 	movi	r2,19999
81127a4c:	1540010e 	bge	r2,r21,81127a54 <_strtod_r+0x550>
81127a50:	102b883a 	mov	r21,r2
81127a54:	603f4f26 	beq	r12,zero,81127794 <__reset+0xfb107794>
81127a58:	056bc83a 	sub	r21,zero,r21
81127a5c:	003f4d06 	br	81127794 <__reset+0xfb107794>
81127a60:	98800047 	ldb	r2,1(r19)
81127a64:	00c01604 	movi	r3,88
81127a68:	10c1de26 	beq	r2,r3,811281e4 <_strtod_r+0xce0>
81127a6c:	00c01e04 	movi	r3,120
81127a70:	10c1dc26 	beq	r2,r3,811281e4 <_strtod_r+0xce0>
81127a74:	98c00044 	addi	r3,r19,1
81127a78:	1827883a 	mov	r19,r3
81127a7c:	d8c00615 	stw	r3,24(sp)
81127a80:	18c00044 	addi	r3,r3,1
81127a84:	18bfffc3 	ldbu	r2,-1(r3)
81127a88:	11003fcc 	andi	r4,r2,255
81127a8c:	2100201c 	xori	r4,r4,128
81127a90:	213fe004 	addi	r4,r4,-128
81127a94:	217ff826 	beq	r4,r5,81127a78 <__reset+0xfb107a78>
81127a98:	203f7926 	beq	r4,zero,81127880 <__reset+0xfb107880>
81127a9c:	dcc00815 	stw	r19,32(sp)
81127aa0:	04800044 	movi	r18,1
81127aa4:	003f0b06 	br	811276d4 <__reset+0xfb1076d4>
81127aa8:	8009883a 	mov	r4,r16
81127aac:	11257240 	call	81125724 <_localeconv_r>
81127ab0:	11000017 	ldw	r4,0(r2)
81127ab4:	111c5040 	call	8111c504 <strlen>
81127ab8:	d8c00617 	ldw	r3,24(sp)
81127abc:	1885883a 	add	r2,r3,r2
81127ac0:	d8800615 	stw	r2,24(sp)
81127ac4:	14400007 	ldb	r17,0(r2)
81127ac8:	b001881e 	bne	r22,zero,811280ec <_strtod_r+0xbe8>
81127acc:	00c00c04 	movi	r3,48
81127ad0:	88c3391e 	bne	r17,r3,811287b8 <_strtod_r+0x12b4>
81127ad4:	10c00044 	addi	r3,r2,1
81127ad8:	8809883a 	mov	r4,r17
81127adc:	d8c00615 	stw	r3,24(sp)
81127ae0:	1c400007 	ldb	r17,0(r3)
81127ae4:	188bc83a 	sub	r5,r3,r2
81127ae8:	18c00044 	addi	r3,r3,1
81127aec:	893ffb26 	beq	r17,r4,81127adc <__reset+0xfb107adc>
81127af0:	88bff3c4 	addi	r2,r17,-49
81127af4:	00c00204 	movi	r3,8
81127af8:	1882e72e 	bgeu	r3,r2,81128698 <_strtod_r+0x1194>
81127afc:	00801944 	movi	r2,101
81127b00:	88814d26 	beq	r17,r2,81128038 <_strtod_r+0xb34>
81127b04:	0013883a 	mov	r9,zero
81127b08:	0015883a 	mov	r10,zero
81127b0c:	02c00044 	movi	r11,1
81127b10:	003f1d06 	br	81127788 <__reset+0xfb107788>
81127b14:	4defc83a 	sub	r23,r9,r23
81127b18:	bd6f883a 	add	r23,r23,r21
81127b1c:	05c21e0e 	bge	zero,r23,81128398 <_strtod_r+0xe94>
81127b20:	b88003cc 	andi	r2,r23,15
81127b24:	10000d26 	beq	r2,zero,81127b5c <_strtod_r+0x658>
81127b28:	100490fa 	slli	r2,r2,3
81127b2c:	00e04574 	movhi	r3,33045
81127b30:	18e6f304 	addi	r3,r3,-25652
81127b34:	1885883a 	add	r2,r3,r2
81127b38:	11000017 	ldw	r4,0(r2)
81127b3c:	11400117 	ldw	r5,4(r2)
81127b40:	900d883a 	mov	r6,r18
81127b44:	880f883a 	mov	r7,r17
81127b48:	da401315 	stw	r9,76(sp)
81127b4c:	1119dc00 	call	81119dc0 <__muldf3>
81127b50:	da401317 	ldw	r9,76(sp)
81127b54:	1025883a 	mov	r18,r2
81127b58:	1823883a 	mov	r17,r3
81127b5c:	023ffc04 	movi	r8,-16
81127b60:	ba10703a 	and	r8,r23,r8
81127b64:	40003c26 	beq	r8,zero,81127c58 <_strtod_r+0x754>
81127b68:	00804d04 	movi	r2,308
81127b6c:	1201cd16 	blt	r2,r8,811282a4 <_strtod_r+0xda0>
81127b70:	4011d13a 	srai	r8,r8,4
81127b74:	03000044 	movi	r12,1
81127b78:	62037c0e 	bge	r12,r8,8112896c <_strtod_r+0x1468>
81127b7c:	01204574 	movhi	r4,33045
81127b80:	2126e904 	addi	r4,r4,-25692
81127b84:	2015883a 	mov	r10,r4
81127b88:	0027883a 	mov	r19,zero
81127b8c:	d9000915 	stw	r4,36(sp)
81127b90:	9005883a 	mov	r2,r18
81127b94:	8807883a 	mov	r3,r17
81127b98:	dc000c15 	stw	r16,48(sp)
81127b9c:	dc800e15 	stw	r18,56(sp)
81127ba0:	9821883a 	mov	r16,r19
81127ba4:	0009883a 	mov	r4,zero
81127ba8:	8827883a 	mov	r19,r17
81127bac:	602f883a 	mov	r23,r12
81127bb0:	da400a15 	stw	r9,40(sp)
81127bb4:	5025883a 	mov	r18,r10
81127bb8:	4023883a 	mov	r17,r8
81127bbc:	8980004c 	andi	r6,r17,1
81127bc0:	30000626 	beq	r6,zero,81127bdc <_strtod_r+0x6d8>
81127bc4:	91800017 	ldw	r6,0(r18)
81127bc8:	91c00117 	ldw	r7,4(r18)
81127bcc:	1009883a 	mov	r4,r2
81127bd0:	180b883a 	mov	r5,r3
81127bd4:	1119dc00 	call	81119dc0 <__muldf3>
81127bd8:	01000044 	movi	r4,1
81127bdc:	8823d07a 	srai	r17,r17,1
81127be0:	84000044 	addi	r16,r16,1
81127be4:	94800204 	addi	r18,r18,8
81127be8:	8dfff41e 	bne	r17,r23,81127bbc <__reset+0xfb107bbc>
81127bec:	21003fcc 	andi	r4,r4,255
81127bf0:	9823883a 	mov	r17,r19
81127bf4:	da400a17 	ldw	r9,40(sp)
81127bf8:	8027883a 	mov	r19,r16
81127bfc:	dc800e17 	ldw	r18,56(sp)
81127c00:	dc000c17 	ldw	r16,48(sp)
81127c04:	2003b11e 	bne	r4,zero,81128acc <_strtod_r+0x15c8>
81127c08:	981690fa 	slli	r11,r19,3
81127c0c:	d8800917 	ldw	r2,36(sp)
81127c10:	01ff2c34 	movhi	r7,64688
81127c14:	900d883a 	mov	r6,r18
81127c18:	12ef883a 	add	r23,r2,r11
81127c1c:	b9000017 	ldw	r4,0(r23)
81127c20:	b9400117 	ldw	r5,4(r23)
81127c24:	89cf883a 	add	r7,r17,r7
81127c28:	da401315 	stw	r9,76(sp)
81127c2c:	1119dc00 	call	81119dc0 <__muldf3>
81127c30:	1025883a 	mov	r18,r2
81127c34:	011f2834 	movhi	r4,31904
81127c38:	189ffc2c 	andhi	r2,r3,32752
81127c3c:	da401317 	ldw	r9,76(sp)
81127c40:	20819836 	bltu	r4,r2,811282a4 <_strtod_r+0xda0>
81127c44:	011f2434 	movhi	r4,31888
81127c48:	2083382e 	bgeu	r4,r2,8112892c <_strtod_r+0x1428>
81127c4c:	045ffc34 	movhi	r17,32752
81127c50:	8c7fffc4 	addi	r17,r17,-1
81127c54:	04bfffc4 	movi	r18,-1
81127c58:	d8000915 	stw	zero,36(sp)
81127c5c:	d9400817 	ldw	r5,32(sp)
81127c60:	df000015 	stw	fp,0(sp)
81127c64:	480f883a 	mov	r7,r9
81127c68:	b00d883a 	mov	r6,r22
81127c6c:	8009883a 	mov	r4,r16
81127c70:	1125e400 	call	81125e40 <__s2b>
81127c74:	d8800815 	stw	r2,32(sp)
81127c78:	10018a26 	beq	r2,zero,811282a4 <_strtod_r+0xda0>
81127c7c:	a807d7fa 	srai	r3,r21,31
81127c80:	0545c83a 	sub	r2,zero,r21
81127c84:	dd400a15 	stw	r21,40(sp)
81127c88:	1886703a 	and	r3,r3,r2
81127c8c:	d8c00c15 	stw	r3,48(sp)
81127c90:	a8013516 	blt	r21,zero,81128168 <_strtod_r+0xc64>
81127c94:	d9400817 	ldw	r5,32(sp)
81127c98:	0011883a 	mov	r8,zero
81127c9c:	0027883a 	mov	r19,zero
81127ca0:	29400304 	addi	r5,r5,12
81127ca4:	d9400f15 	stw	r5,60(sp)
81127ca8:	402b883a 	mov	r21,r8
81127cac:	dd001215 	stw	r20,72(sp)
81127cb0:	d8800817 	ldw	r2,32(sp)
81127cb4:	8009883a 	mov	r4,r16
81127cb8:	11400117 	ldw	r5,4(r2)
81127cbc:	1125c400 	call	81125c40 <_Balloc>
81127cc0:	1029883a 	mov	r20,r2
81127cc4:	10012d26 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127cc8:	d8c00817 	ldw	r3,32(sp)
81127ccc:	d9400f17 	ldw	r5,60(sp)
81127cd0:	11000304 	addi	r4,r2,12
81127cd4:	19800417 	ldw	r6,16(r3)
81127cd8:	31800084 	addi	r6,r6,2
81127cdc:	318d883a 	add	r6,r6,r6
81127ce0:	318d883a 	add	r6,r6,r6
81127ce4:	111ba100 	call	8111ba10 <memcpy>
81127ce8:	d9000204 	addi	r4,sp,8
81127cec:	d9000015 	stw	r4,0(sp)
81127cf0:	d9c00404 	addi	r7,sp,16
81127cf4:	900b883a 	mov	r5,r18
81127cf8:	880d883a 	mov	r6,r17
81127cfc:	8009883a 	mov	r4,r16
81127d00:	112691c0 	call	8112691c <__d2b>
81127d04:	d8800515 	stw	r2,20(sp)
81127d08:	dc801115 	stw	r18,68(sp)
81127d0c:	dc401015 	stw	r17,64(sp)
81127d10:	10027c26 	beq	r2,zero,81128704 <_strtod_r+0x1200>
81127d14:	01400044 	movi	r5,1
81127d18:	8009883a 	mov	r4,r16
81127d1c:	11260640 	call	81126064 <__i2b>
81127d20:	1027883a 	mov	r19,r2
81127d24:	10011526 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127d28:	d8800417 	ldw	r2,16(sp)
81127d2c:	1000c816 	blt	r2,zero,81128050 <_strtod_r+0xb4c>
81127d30:	d9400c17 	ldw	r5,48(sp)
81127d34:	d9000a17 	ldw	r4,40(sp)
81127d38:	28ad883a 	add	r22,r5,r2
81127d3c:	d9400917 	ldw	r5,36(sp)
81127d40:	df000217 	ldw	fp,8(sp)
81127d44:	05ff0084 	movi	r23,-1022
81127d48:	1147c83a 	sub	r3,r2,r5
81127d4c:	1f07883a 	add	r3,r3,fp
81127d50:	00800d84 	movi	r2,54
81127d54:	18ffffc4 	addi	r3,r3,-1
81127d58:	1739c83a 	sub	fp,r2,fp
81127d5c:	1dc0a50e 	bge	r3,r23,81127ff4 <_strtod_r+0xaf0>
81127d60:	b8efc83a 	sub	r23,r23,r3
81127d64:	008007c4 	movi	r2,31
81127d68:	e5f9c83a 	sub	fp,fp,r23
81127d6c:	15c0bc16 	blt	r2,r23,81128060 <_strtod_r+0xb5c>
81127d70:	00800044 	movi	r2,1
81127d74:	15c4983a 	sll	r2,r2,r23
81127d78:	d8000b15 	stw	zero,44(sp)
81127d7c:	d8800d15 	stw	r2,52(sp)
81127d80:	2707883a 	add	r3,r4,fp
81127d84:	d9000917 	ldw	r4,36(sp)
81127d88:	b739883a 	add	fp,r22,fp
81127d8c:	20ef883a 	add	r23,r4,r3
81127d90:	b009883a 	mov	r4,r22
81127d94:	e580010e 	bge	fp,r22,81127d9c <_strtod_r+0x898>
81127d98:	e009883a 	mov	r4,fp
81127d9c:	b805883a 	mov	r2,r23
81127da0:	25c0010e 	bge	r4,r23,81127da8 <_strtod_r+0x8a4>
81127da4:	2005883a 	mov	r2,r4
81127da8:	0080030e 	bge	zero,r2,81127db8 <_strtod_r+0x8b4>
81127dac:	e0b9c83a 	sub	fp,fp,r2
81127db0:	b8afc83a 	sub	r23,r23,r2
81127db4:	b0adc83a 	sub	r22,r22,r2
81127db8:	d9400c17 	ldw	r5,48(sp)
81127dbc:	28001126 	beq	r5,zero,81127e04 <_strtod_r+0x900>
81127dc0:	280d883a 	mov	r6,r5
81127dc4:	8009883a 	mov	r4,r16
81127dc8:	980b883a 	mov	r5,r19
81127dcc:	11262a80 	call	811262a8 <__pow5mult>
81127dd0:	1027883a 	mov	r19,r2
81127dd4:	1000e926 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127dd8:	d9800517 	ldw	r6,20(sp)
81127ddc:	100b883a 	mov	r5,r2
81127de0:	8009883a 	mov	r4,r16
81127de4:	11260a80 	call	811260a8 <__multiply>
81127de8:	1000e426 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127dec:	d9400517 	ldw	r5,20(sp)
81127df0:	8009883a 	mov	r4,r16
81127df4:	d8801315 	stw	r2,76(sp)
81127df8:	1125cf00 	call	81125cf0 <_Bfree>
81127dfc:	d8801317 	ldw	r2,76(sp)
81127e00:	d8800515 	stw	r2,20(sp)
81127e04:	0700060e 	bge	zero,fp,81127e20 <_strtod_r+0x91c>
81127e08:	d9400517 	ldw	r5,20(sp)
81127e0c:	e00d883a 	mov	r6,fp
81127e10:	8009883a 	mov	r4,r16
81127e14:	11263f00 	call	811263f0 <__lshift>
81127e18:	d8800515 	stw	r2,20(sp)
81127e1c:	10023926 	beq	r2,zero,81128704 <_strtod_r+0x1200>
81127e20:	d8800a17 	ldw	r2,40(sp)
81127e24:	10000626 	beq	r2,zero,81127e40 <_strtod_r+0x93c>
81127e28:	d9800a17 	ldw	r6,40(sp)
81127e2c:	a00b883a 	mov	r5,r20
81127e30:	8009883a 	mov	r4,r16
81127e34:	11262a80 	call	811262a8 <__pow5mult>
81127e38:	1029883a 	mov	r20,r2
81127e3c:	1000cf26 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127e40:	05c0060e 	bge	zero,r23,81127e5c <_strtod_r+0x958>
81127e44:	a00b883a 	mov	r5,r20
81127e48:	b80d883a 	mov	r6,r23
81127e4c:	8009883a 	mov	r4,r16
81127e50:	11263f00 	call	811263f0 <__lshift>
81127e54:	1029883a 	mov	r20,r2
81127e58:	1000c826 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127e5c:	0580060e 	bge	zero,r22,81127e78 <_strtod_r+0x974>
81127e60:	980b883a 	mov	r5,r19
81127e64:	b00d883a 	mov	r6,r22
81127e68:	8009883a 	mov	r4,r16
81127e6c:	11263f00 	call	811263f0 <__lshift>
81127e70:	1027883a 	mov	r19,r2
81127e74:	1000c126 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127e78:	d9400517 	ldw	r5,20(sp)
81127e7c:	a00d883a 	mov	r6,r20
81127e80:	8009883a 	mov	r4,r16
81127e84:	11265a00 	call	811265a0 <__mdiff>
81127e88:	102b883a 	mov	r21,r2
81127e8c:	1000bb26 	beq	r2,zero,8112817c <_strtod_r+0xc78>
81127e90:	10c00317 	ldw	r3,12(r2)
81127e94:	980b883a 	mov	r5,r19
81127e98:	10000315 	stw	zero,12(r2)
81127e9c:	1009883a 	mov	r4,r2
81127ea0:	d8c00e15 	stw	r3,56(sp)
81127ea4:	11265400 	call	81126540 <__mcmp>
81127ea8:	10027616 	blt	r2,zero,81128884 <_strtod_r+0x1380>
81127eac:	10024426 	beq	r2,zero,811287c0 <_strtod_r+0x12bc>
81127eb0:	980b883a 	mov	r5,r19
81127eb4:	a809883a 	mov	r4,r21
81127eb8:	1126a700 	call	81126a70 <__ratio>
81127ebc:	000d883a 	mov	r6,zero
81127ec0:	01d00034 	movhi	r7,16384
81127ec4:	1009883a 	mov	r4,r2
81127ec8:	180b883a 	mov	r5,r3
81127ecc:	102f883a 	mov	r23,r2
81127ed0:	182d883a 	mov	r22,r3
81127ed4:	112f5b80 	call	8112f5b8 <__ledf2>
81127ed8:	00804a16 	blt	zero,r2,81128004 <_strtod_r+0xb00>
81127edc:	d9400e17 	ldw	r5,56(sp)
81127ee0:	28006b26 	beq	r5,zero,81128090 <_strtod_r+0xb8c>
81127ee4:	058ffc34 	movhi	r22,16368
81127ee8:	d8000b15 	stw	zero,44(sp)
81127eec:	d8000d15 	stw	zero,52(sp)
81127ef0:	b02f883a 	mov	r23,r22
81127ef4:	8f1ffc2c 	andhi	fp,r17,32752
81127ef8:	009ff834 	movhi	r2,32736
81127efc:	e080cd26 	beq	fp,r2,81128234 <_strtod_r+0xd30>
81127f00:	d9400917 	ldw	r5,36(sp)
81127f04:	28001a26 	beq	r5,zero,81127f70 <_strtod_r+0xa6c>
81127f08:	0081a834 	movhi	r2,1696
81127f0c:	17001836 	bltu	r2,fp,81127f70 <_strtod_r+0xa6c>
81127f10:	d9000d17 	ldw	r4,52(sp)
81127f14:	01d07834 	movhi	r7,16864
81127f18:	39ffffc4 	addi	r7,r7,-1
81127f1c:	01bff034 	movhi	r6,65472
81127f20:	b80b883a 	mov	r5,r23
81127f24:	112f5b80 	call	8112f5b8 <__ledf2>
81127f28:	00800e16 	blt	zero,r2,81127f64 <_strtod_r+0xa60>
81127f2c:	d9000d17 	ldw	r4,52(sp)
81127f30:	b80b883a 	mov	r5,r23
81127f34:	112d3c40 	call	8112d3c4 <__fixunsdfsi>
81127f38:	10018126 	beq	r2,zero,81128540 <_strtod_r+0x103c>
81127f3c:	1009883a 	mov	r4,r2
81127f40:	11301140 	call	81130114 <__floatunsidf>
81127f44:	d8800d15 	stw	r2,52(sp)
81127f48:	182f883a 	mov	r23,r3
81127f4c:	d8800e17 	ldw	r2,56(sp)
81127f50:	1001791e 	bne	r2,zero,81128538 <_strtod_r+0x1034>
81127f54:	ba20003c 	xorhi	r8,r23,32768
81127f58:	d8c00d17 	ldw	r3,52(sp)
81127f5c:	402d883a 	mov	r22,r8
81127f60:	d8c00b15 	stw	r3,44(sp)
81127f64:	0081ac34 	movhi	r2,1712
81127f68:	b091883a 	add	r8,r22,r2
81127f6c:	472dc83a 	sub	r22,r8,fp
81127f70:	9009883a 	mov	r4,r18
81127f74:	880b883a 	mov	r5,r17
81127f78:	11267a40 	call	811267a4 <__ulp>
81127f7c:	d9000b17 	ldw	r4,44(sp)
81127f80:	b00b883a 	mov	r5,r22
81127f84:	100d883a 	mov	r6,r2
81127f88:	180f883a 	mov	r7,r3
81127f8c:	1119dc00 	call	81119dc0 <__muldf3>
81127f90:	900d883a 	mov	r6,r18
81127f94:	880f883a 	mov	r7,r17
81127f98:	1009883a 	mov	r4,r2
81127f9c:	180b883a 	mov	r5,r3
81127fa0:	112e2b00 	call	8112e2b0 <__adddf3>
81127fa4:	1025883a 	mov	r18,r2
81127fa8:	1823883a 	mov	r17,r3
81127fac:	182d883a 	mov	r22,r3
81127fb0:	d9000917 	ldw	r4,36(sp)
81127fb4:	2000021e 	bne	r4,zero,81127fc0 <_strtod_r+0xabc>
81127fb8:	b09ffc2c 	andhi	r2,r22,32752
81127fbc:	e080be26 	beq	fp,r2,811282b8 <_strtod_r+0xdb4>
81127fc0:	d9400517 	ldw	r5,20(sp)
81127fc4:	8009883a 	mov	r4,r16
81127fc8:	1125cf00 	call	81125cf0 <_Bfree>
81127fcc:	a00b883a 	mov	r5,r20
81127fd0:	8009883a 	mov	r4,r16
81127fd4:	1125cf00 	call	81125cf0 <_Bfree>
81127fd8:	980b883a 	mov	r5,r19
81127fdc:	8009883a 	mov	r4,r16
81127fe0:	1125cf00 	call	81125cf0 <_Bfree>
81127fe4:	a80b883a 	mov	r5,r21
81127fe8:	8009883a 	mov	r4,r16
81127fec:	1125cf00 	call	81125cf0 <_Bfree>
81127ff0:	003f2f06 	br	81127cb0 <__reset+0xfb107cb0>
81127ff4:	00c00044 	movi	r3,1
81127ff8:	d8000b15 	stw	zero,44(sp)
81127ffc:	d8c00d15 	stw	r3,52(sp)
81128000:	003f5f06 	br	81127d80 <__reset+0xfb107d80>
81128004:	b809883a 	mov	r4,r23
81128008:	000d883a 	mov	r6,zero
8112800c:	01cff834 	movhi	r7,16352
81128010:	b00b883a 	mov	r5,r22
81128014:	1119dc00 	call	81119dc0 <__muldf3>
81128018:	d9000e17 	ldw	r4,56(sp)
8112801c:	d8800d15 	stw	r2,52(sp)
81128020:	182f883a 	mov	r23,r3
81128024:	2000181e 	bne	r4,zero,81128088 <_strtod_r+0xb84>
81128028:	1a20003c 	xorhi	r8,r3,32768
8112802c:	d8800b15 	stw	r2,44(sp)
81128030:	402d883a 	mov	r22,r8
81128034:	003faf06 	br	81127ef4 <__reset+0xfb107ef4>
81128038:	0015883a 	mov	r10,zero
8112803c:	02c00044 	movi	r11,1
81128040:	2800011e 	bne	r5,zero,81128048 <_strtod_r+0xb44>
81128044:	903d7e26 	beq	r18,zero,81127640 <__reset+0xfb107640>
81128048:	0013883a 	mov	r9,zero
8112804c:	003e4706 	br	8112796c <__reset+0xfb10796c>
81128050:	d8c00a17 	ldw	r3,40(sp)
81128054:	dd800c17 	ldw	r22,48(sp)
81128058:	1889c83a 	sub	r4,r3,r2
8112805c:	003f3706 	br	81127d3c <__reset+0xfb107d3c>
81128060:	00bef884 	movi	r2,-1054
81128064:	05c00044 	movi	r23,1
81128068:	10c5c83a 	sub	r2,r2,r3
8112806c:	b884983a 	sll	r2,r23,r2
81128070:	ddc00d15 	stw	r23,52(sp)
81128074:	d8800b15 	stw	r2,44(sp)
81128078:	003f4106 	br	81127d80 <__reset+0xfb107d80>
8112807c:	ddc00615 	stw	r23,24(sp)
81128080:	002b883a 	mov	r21,zero
81128084:	003dc306 	br	81127794 <__reset+0xfb107794>
81128088:	1811883a 	mov	r8,r3
8112808c:	003fe706 	br	8112802c <__reset+0xfb10802c>
81128090:	90002e1e 	bne	r18,zero,8112814c <_strtod_r+0xc48>
81128094:	00c00434 	movhi	r3,16
81128098:	18ffffc4 	addi	r3,r3,-1
8112809c:	88c4703a 	and	r2,r17,r3
811280a0:	10002c1e 	bne	r2,zero,81128154 <_strtod_r+0xc50>
811280a4:	000d883a 	mov	r6,zero
811280a8:	01cffc34 	movhi	r7,16368
811280ac:	b809883a 	mov	r4,r23
811280b0:	b00b883a 	mov	r5,r22
811280b4:	112f5b80 	call	8112f5b8 <__ledf2>
811280b8:	10021716 	blt	r2,zero,81128918 <_strtod_r+0x1414>
811280bc:	b809883a 	mov	r4,r23
811280c0:	b00b883a 	mov	r5,r22
811280c4:	000d883a 	mov	r6,zero
811280c8:	01cff834 	movhi	r7,16352
811280cc:	1119dc00 	call	81119dc0 <__muldf3>
811280d0:	d8800d15 	stw	r2,52(sp)
811280d4:	182f883a 	mov	r23,r3
811280d8:	102d883a 	mov	r22,r2
811280dc:	1a20003c 	xorhi	r8,r3,32768
811280e0:	dd800b15 	stw	r22,44(sp)
811280e4:	402d883a 	mov	r22,r8
811280e8:	003f8206 	br	81127ef4 <__reset+0xfb107ef4>
811280ec:	b013883a 	mov	r9,r22
811280f0:	000b883a 	mov	r5,zero
811280f4:	0015883a 	mov	r10,zero
811280f8:	893ff404 	addi	r4,r17,-48
811280fc:	00800244 	movi	r2,9
81128100:	11001036 	bltu	r2,r4,81128144 <_strtod_r+0xc40>
81128104:	28c00044 	addi	r3,r5,1
81128108:	2023883a 	mov	r17,r4
8112810c:	20014d1e 	bne	r4,zero,81128644 <_strtod_r+0x1140>
81128110:	d9800617 	ldw	r6,24(sp)
81128114:	180b883a 	mov	r5,r3
81128118:	30800044 	addi	r2,r6,1
8112811c:	d8800615 	stw	r2,24(sp)
81128120:	34400047 	ldb	r17,1(r6)
81128124:	003ff406 	br	811280f8 <__reset+0xfb1080f8>
81128128:	0019883a 	mov	r12,zero
8112812c:	b8800084 	addi	r2,r23,2
81128130:	d8800615 	stw	r2,24(sp)
81128134:	bc400087 	ldb	r17,2(r23)
81128138:	003e1606 	br	81127994 <__reset+0xfb107994>
8112813c:	03000044 	movi	r12,1
81128140:	003ffa06 	br	8112812c <__reset+0xfb10812c>
81128144:	02c00044 	movi	r11,1
81128148:	003d8d06 	br	81127780 <__reset+0xfb107780>
8112814c:	00800044 	movi	r2,1
81128150:	9080fe26 	beq	r18,r2,8112854c <_strtod_r+0x1048>
81128154:	d8000b15 	stw	zero,44(sp)
81128158:	05affc34 	movhi	r22,49136
8112815c:	d8000d15 	stw	zero,52(sp)
81128160:	05cffc34 	movhi	r23,16368
81128164:	003f6306 	br	81127ef4 <__reset+0xfb107ef4>
81128168:	d8000a15 	stw	zero,40(sp)
8112816c:	003ec906 	br	81127c94 <__reset+0xfb107c94>
81128170:	d9001117 	ldw	r4,68(sp)
81128174:	00bfffc4 	movi	r2,-1
81128178:	2080461e 	bne	r4,r2,81128294 <_strtod_r+0xd90>
8112817c:	dd000a15 	stw	r20,40(sp)
81128180:	dd001217 	ldw	r20,72(sp)
81128184:	a811883a 	mov	r8,r21
81128188:	d8800517 	ldw	r2,20(sp)
8112818c:	00c00884 	movi	r3,34
81128190:	80c00015 	stw	r3,0(r16)
81128194:	002b883a 	mov	r21,zero
81128198:	059ffc34 	movhi	r22,32752
8112819c:	100b883a 	mov	r5,r2
811281a0:	8009883a 	mov	r4,r16
811281a4:	da001315 	stw	r8,76(sp)
811281a8:	1125cf00 	call	81125cf0 <_Bfree>
811281ac:	d9400a17 	ldw	r5,40(sp)
811281b0:	8009883a 	mov	r4,r16
811281b4:	1125cf00 	call	81125cf0 <_Bfree>
811281b8:	980b883a 	mov	r5,r19
811281bc:	8009883a 	mov	r4,r16
811281c0:	1125cf00 	call	81125cf0 <_Bfree>
811281c4:	d9400817 	ldw	r5,32(sp)
811281c8:	8009883a 	mov	r4,r16
811281cc:	1125cf00 	call	81125cf0 <_Bfree>
811281d0:	da001317 	ldw	r8,76(sp)
811281d4:	8009883a 	mov	r4,r16
811281d8:	400b883a 	mov	r5,r8
811281dc:	1125cf00 	call	81125cf0 <_Bfree>
811281e0:	003d9206 	br	8112782c <__reset+0xfb10782c>
811281e4:	d8c00717 	ldw	r3,28(sp)
811281e8:	d8800504 	addi	r2,sp,20
811281ec:	01a04574 	movhi	r6,33045
811281f0:	31a72e04 	addi	r6,r6,-25416
811281f4:	d8c00115 	stw	r3,4(sp)
811281f8:	d8800015 	stw	r2,0(sp)
811281fc:	d9c00404 	addi	r7,sp,16
81128200:	d9400604 	addi	r5,sp,24
81128204:	8009883a 	mov	r4,r16
81128208:	112c6580 	call	8112c658 <__gethex>
8112820c:	154001cc 	andi	r21,r2,7
81128210:	a83d9b26 	beq	r21,zero,81127880 <__reset+0xfb107880>
81128214:	00c00184 	movi	r3,6
81128218:	a8c0d61e 	bne	r21,r3,81128574 <_strtod_r+0x1070>
8112821c:	9cc00044 	addi	r19,r19,1
81128220:	dcc00615 	stw	r19,24(sp)
81128224:	002b883a 	mov	r21,zero
81128228:	002d883a 	mov	r22,zero
8112822c:	d8000715 	stw	zero,28(sp)
81128230:	003d7e06 	br	8112782c <__reset+0xfb10782c>
81128234:	00bf2c34 	movhi	r2,64688
81128238:	88a3883a 	add	r17,r17,r2
8112823c:	9009883a 	mov	r4,r18
81128240:	880b883a 	mov	r5,r17
81128244:	11267a40 	call	811267a4 <__ulp>
81128248:	d9000b17 	ldw	r4,44(sp)
8112824c:	100d883a 	mov	r6,r2
81128250:	180f883a 	mov	r7,r3
81128254:	b00b883a 	mov	r5,r22
81128258:	1119dc00 	call	81119dc0 <__muldf3>
8112825c:	900d883a 	mov	r6,r18
81128260:	180b883a 	mov	r5,r3
81128264:	880f883a 	mov	r7,r17
81128268:	1009883a 	mov	r4,r2
8112826c:	112e2b00 	call	8112e2b0 <__adddf3>
81128270:	015f2834 	movhi	r5,31904
81128274:	1025883a 	mov	r18,r2
81128278:	297fffc4 	addi	r5,r5,-1
8112827c:	189ffc2c 	andhi	r2,r3,32752
81128280:	2880892e 	bgeu	r5,r2,811284a8 <_strtod_r+0xfa4>
81128284:	d8801017 	ldw	r2,64(sp)
81128288:	00dffc34 	movhi	r3,32752
8112828c:	18ffffc4 	addi	r3,r3,-1
81128290:	10ffb726 	beq	r2,r3,81128170 <__reset+0xfb108170>
81128294:	045ffc34 	movhi	r17,32752
81128298:	8c7fffc4 	addi	r17,r17,-1
8112829c:	04bfffc4 	movi	r18,-1
811282a0:	003f4706 	br	81127fc0 <__reset+0xfb107fc0>
811282a4:	00800884 	movi	r2,34
811282a8:	80800015 	stw	r2,0(r16)
811282ac:	002b883a 	mov	r21,zero
811282b0:	059ffc34 	movhi	r22,32752
811282b4:	003d5d06 	br	8112782c <__reset+0xfb10782c>
811282b8:	d9000d17 	ldw	r4,52(sp)
811282bc:	b80b883a 	mov	r5,r23
811282c0:	112ffb00 	call	8112ffb0 <__fixdfsi>
811282c4:	1009883a 	mov	r4,r2
811282c8:	11300300 	call	81130030 <__floatsidf>
811282cc:	d9000d17 	ldw	r4,52(sp)
811282d0:	b80b883a 	mov	r5,r23
811282d4:	100d883a 	mov	r6,r2
811282d8:	180f883a 	mov	r7,r3
811282dc:	112f6ac0 	call	8112f6ac <__subdf3>
811282e0:	d9400e17 	ldw	r5,56(sp)
811282e4:	1039883a 	mov	fp,r2
811282e8:	182f883a 	mov	r23,r3
811282ec:	2800141e 	bne	r5,zero,81128340 <_strtod_r+0xe3c>
811282f0:	9000131e 	bne	r18,zero,81128340 <_strtod_r+0xe3c>
811282f4:	00800434 	movhi	r2,16
811282f8:	10bfffc4 	addi	r2,r2,-1
811282fc:	b0ac703a 	and	r22,r22,r2
81128300:	b0000f1e 	bne	r22,zero,81128340 <_strtod_r+0xe3c>
81128304:	01a52834 	movhi	r6,38048
81128308:	01cff434 	movhi	r7,16336
8112830c:	318d6544 	addi	r6,r6,13717
81128310:	39ffffc4 	addi	r7,r7,-1
81128314:	e009883a 	mov	r4,fp
81128318:	180b883a 	mov	r5,r3
8112831c:	112f5b80 	call	8112f5b8 <__ledf2>
81128320:	103f270e 	bge	r2,zero,81127fc0 <__reset+0xfb107fc0>
81128324:	dd000a15 	stw	r20,40(sp)
81128328:	a811883a 	mov	r8,r21
8112832c:	dd001217 	ldw	r20,72(sp)
81128330:	d8800517 	ldw	r2,20(sp)
81128334:	002b883a 	mov	r21,zero
81128338:	882d883a 	mov	r22,r17
8112833c:	003f9706 	br	8112819c <__reset+0xfb10819c>
81128340:	01a52834 	movhi	r6,38048
81128344:	01cff834 	movhi	r7,16352
81128348:	318d6544 	addi	r6,r6,13717
8112834c:	39ffffc4 	addi	r7,r7,-1
81128350:	e009883a 	mov	r4,fp
81128354:	b80b883a 	mov	r5,r23
81128358:	112f5b80 	call	8112f5b8 <__ledf2>
8112835c:	10000716 	blt	r2,zero,8112837c <_strtod_r+0xe78>
81128360:	018d6c34 	movhi	r6,13744
81128364:	31b94d44 	addi	r6,r6,-6859
81128368:	01cff834 	movhi	r7,16352
8112836c:	e009883a 	mov	r4,fp
81128370:	b80b883a 	mov	r5,r23
81128374:	112f4dc0 	call	8112f4dc <__gedf2>
81128378:	00bf110e 	bge	zero,r2,81127fc0 <__reset+0xfb107fc0>
8112837c:	dd000a15 	stw	r20,40(sp)
81128380:	a811883a 	mov	r8,r21
81128384:	dd001217 	ldw	r20,72(sp)
81128388:	d8800517 	ldw	r2,20(sp)
8112838c:	902b883a 	mov	r21,r18
81128390:	882d883a 	mov	r22,r17
81128394:	003f8106 	br	8112819c <__reset+0xfb10819c>
81128398:	b83e2f26 	beq	r23,zero,81127c58 <__reset+0xfb107c58>
8112839c:	05efc83a 	sub	r23,zero,r23
811283a0:	b88003cc 	andi	r2,r23,15
811283a4:	10000d26 	beq	r2,zero,811283dc <_strtod_r+0xed8>
811283a8:	100490fa 	slli	r2,r2,3
811283ac:	00e04574 	movhi	r3,33045
811283b0:	18e6f304 	addi	r3,r3,-25652
811283b4:	1885883a 	add	r2,r3,r2
811283b8:	11800017 	ldw	r6,0(r2)
811283bc:	11c00117 	ldw	r7,4(r2)
811283c0:	9009883a 	mov	r4,r18
811283c4:	880b883a 	mov	r5,r17
811283c8:	da401315 	stw	r9,76(sp)
811283cc:	112eb640 	call	8112eb64 <__divdf3>
811283d0:	da401317 	ldw	r9,76(sp)
811283d4:	1025883a 	mov	r18,r2
811283d8:	1823883a 	mov	r17,r3
811283dc:	b82fd13a 	srai	r23,r23,4
811283e0:	b83e1d26 	beq	r23,zero,81127c58 <__reset+0xfb107c58>
811283e4:	008007c4 	movi	r2,31
811283e8:	15c02816 	blt	r2,r23,8112848c <_strtod_r+0xf88>
811283ec:	b880040c 	andi	r2,r23,16
811283f0:	10019726 	beq	r2,zero,81128a50 <_strtod_r+0x154c>
811283f4:	05c1880e 	bge	zero,r23,81128a18 <_strtod_r+0x1514>
811283f8:	00c01a84 	movi	r3,106
811283fc:	d8c00915 	stw	r3,36(sp)
81128400:	04e04574 	movhi	r19,33045
81128404:	9ce73304 	addi	r19,r19,-25396
81128408:	8807883a 	mov	r3,r17
8112840c:	9005883a 	mov	r2,r18
81128410:	8023883a 	mov	r17,r16
81128414:	0009883a 	mov	r4,zero
81128418:	9821883a 	mov	r16,r19
8112841c:	da400a15 	stw	r9,40(sp)
81128420:	1827883a 	mov	r19,r3
81128424:	b980004c 	andi	r6,r23,1
81128428:	30000626 	beq	r6,zero,81128444 <_strtod_r+0xf40>
8112842c:	81800017 	ldw	r6,0(r16)
81128430:	81c00117 	ldw	r7,4(r16)
81128434:	1009883a 	mov	r4,r2
81128438:	180b883a 	mov	r5,r3
8112843c:	1119dc00 	call	81119dc0 <__muldf3>
81128440:	01000044 	movi	r4,1
81128444:	b82fd07a 	srai	r23,r23,1
81128448:	84000204 	addi	r16,r16,8
8112844c:	b83ff51e 	bne	r23,zero,81128424 <__reset+0xfb108424>
81128450:	21003fcc 	andi	r4,r4,255
81128454:	8821883a 	mov	r16,r17
81128458:	da400a17 	ldw	r9,40(sp)
8112845c:	9823883a 	mov	r17,r19
81128460:	2001a51e 	bne	r4,zero,81128af8 <_strtod_r+0x15f4>
81128464:	d9000917 	ldw	r4,36(sp)
81128468:	20016d1e 	bne	r4,zero,81128a20 <_strtod_r+0x151c>
8112846c:	000d883a 	mov	r6,zero
81128470:	000f883a 	mov	r7,zero
81128474:	9009883a 	mov	r4,r18
81128478:	880b883a 	mov	r5,r17
8112847c:	da401315 	stw	r9,76(sp)
81128480:	112f4540 	call	8112f454 <__eqdf2>
81128484:	da401317 	ldw	r9,76(sp)
81128488:	103df41e 	bne	r2,zero,81127c5c <__reset+0xfb107c5c>
8112848c:	00800884 	movi	r2,34
81128490:	80800015 	stw	r2,0(r16)
81128494:	002b883a 	mov	r21,zero
81128498:	002d883a 	mov	r22,zero
8112849c:	003ce306 	br	8112782c <__reset+0xfb10782c>
811284a0:	055387c4 	movi	r21,19999
811284a4:	003d6b06 	br	81127a54 <__reset+0xfb107a54>
811284a8:	0440d434 	movhi	r17,848
811284ac:	1c63883a 	add	r17,r3,r17
811284b0:	882d883a 	mov	r22,r17
811284b4:	003ebe06 	br	81127fb0 <__reset+0xfb107fb0>
811284b8:	14403fcc 	andi	r17,r2,255
811284bc:	8c40201c 	xori	r17,r17,128
811284c0:	8c7fe004 	addi	r17,r17,-128
811284c4:	dd400817 	ldw	r21,32(sp)
811284c8:	0027883a 	mov	r19,zero
811284cc:	0039883a 	mov	fp,zero
811284d0:	002d883a 	mov	r22,zero
811284d4:	003c9906 	br	8112773c <__reset+0xfb10773c>
811284d8:	00c00944 	movi	r3,37
811284dc:	1a47c83a 	sub	r3,r3,r9
811284e0:	1d7d8c16 	blt	r3,r21,81127b14 <__reset+0xfb107b14>
811284e4:	1261c83a 	sub	r16,r2,r9
811284e8:	800490fa 	slli	r2,r16,3
811284ec:	04e04574 	movhi	r19,33045
811284f0:	9ce6f304 	addi	r19,r19,-25652
811284f4:	9885883a 	add	r2,r19,r2
811284f8:	11000017 	ldw	r4,0(r2)
811284fc:	11400117 	ldw	r5,4(r2)
81128500:	900d883a 	mov	r6,r18
81128504:	880f883a 	mov	r7,r17
81128508:	1119dc00 	call	81119dc0 <__muldf3>
8112850c:	ac0dc83a 	sub	r6,r21,r16
81128510:	300c90fa 	slli	r6,r6,3
81128514:	1009883a 	mov	r4,r2
81128518:	180b883a 	mov	r5,r3
8112851c:	9985883a 	add	r2,r19,r6
81128520:	11800017 	ldw	r6,0(r2)
81128524:	11c00117 	ldw	r7,4(r2)
81128528:	1119dc00 	call	81119dc0 <__muldf3>
8112852c:	102b883a 	mov	r21,r2
81128530:	182d883a 	mov	r22,r3
81128534:	003cbd06 	br	8112782c <__reset+0xfb10782c>
81128538:	b811883a 	mov	r8,r23
8112853c:	003e8606 	br	81127f58 <__reset+0xfb107f58>
81128540:	d8000d15 	stw	zero,52(sp)
81128544:	05cffc34 	movhi	r23,16368
81128548:	003e8006 	br	81127f4c <__reset+0xfb107f4c>
8112854c:	883f011e 	bne	r17,zero,81128154 <__reset+0xfb108154>
81128550:	dd000a15 	stw	r20,40(sp)
81128554:	dd001217 	ldw	r20,72(sp)
81128558:	a811883a 	mov	r8,r21
8112855c:	00800884 	movi	r2,34
81128560:	80800015 	stw	r2,0(r16)
81128564:	002b883a 	mov	r21,zero
81128568:	d8800517 	ldw	r2,20(sp)
8112856c:	002d883a 	mov	r22,zero
81128570:	003f0a06 	br	8112819c <__reset+0xfb10819c>
81128574:	d9800517 	ldw	r6,20(sp)
81128578:	30000826 	beq	r6,zero,8112859c <_strtod_r+0x1098>
8112857c:	01400d44 	movi	r5,53
81128580:	d9000204 	addi	r4,sp,8
81128584:	d8801315 	stw	r2,76(sp)
81128588:	1126b980 	call	81126b98 <__copybits>
8112858c:	d9400517 	ldw	r5,20(sp)
81128590:	8009883a 	mov	r4,r16
81128594:	1125cf00 	call	81125cf0 <_Bfree>
81128598:	d8801317 	ldw	r2,76(sp)
8112859c:	00c00184 	movi	r3,6
811285a0:	1d400f36 	bltu	r3,r21,811285e0 <_strtod_r+0x10dc>
811285a4:	a82a90ba 	slli	r21,r21,2
811285a8:	00e044f4 	movhi	r3,33043
811285ac:	18e16f04 	addi	r3,r3,-31300
811285b0:	a8eb883a 	add	r21,r21,r3
811285b4:	a8c00017 	ldw	r3,0(r21)
811285b8:	1800683a 	jmp	r3
811285bc:	81128638 	rdprs	r4,r16,18968
811285c0:	81128610 	cmplti	r4,r16,18968
811285c4:	811285f4 	orhi	r4,r16,18967
811285c8:	811285d8 	cmpnei	r4,r16,18967
811285cc:	81128600 	call	88112860 <__reset+0x20f2860>
811285d0:	81128610 	cmplti	r4,r16,18968
811285d4:	81128638 	rdprs	r4,r16,18968
811285d8:	045ffc34 	movhi	r17,32752
811285dc:	0025883a 	mov	r18,zero
811285e0:	1080020c 	andi	r2,r2,8
811285e4:	902b883a 	mov	r21,r18
811285e8:	103c8f26 	beq	r2,zero,81127828 <__reset+0xfb107828>
811285ec:	8da00034 	orhi	r22,r17,32768
811285f0:	003c8e06 	br	8112782c <__reset+0xfb10782c>
811285f4:	dc800217 	ldw	r18,8(sp)
811285f8:	dc400317 	ldw	r17,12(sp)
811285fc:	003ff806 	br	811285e0 <__reset+0xfb1085e0>
81128600:	04600034 	movhi	r17,32768
81128604:	8c7fffc4 	addi	r17,r17,-1
81128608:	04bfffc4 	movi	r18,-1
8112860c:	003ff406 	br	811285e0 <__reset+0xfb1085e0>
81128610:	d8c00417 	ldw	r3,16(sp)
81128614:	dc400317 	ldw	r17,12(sp)
81128618:	013ffc34 	movhi	r4,65520
8112861c:	18c10cc4 	addi	r3,r3,1075
81128620:	1806953a 	slli	r3,r3,20
81128624:	213fffc4 	addi	r4,r4,-1
81128628:	8922703a 	and	r17,r17,r4
8112862c:	dc800217 	ldw	r18,8(sp)
81128630:	88e2b03a 	or	r17,r17,r3
81128634:	003fea06 	br	811285e0 <__reset+0xfb1085e0>
81128638:	0023883a 	mov	r17,zero
8112863c:	0025883a 	mov	r18,zero
81128640:	003fe706 	br	811285e0 <__reset+0xfb1085e0>
81128644:	01800044 	movi	r6,1
81128648:	50d5883a 	add	r10,r10,r3
8112864c:	2a4b883a 	add	r5,r5,r9
81128650:	19811a26 	beq	r3,r6,81128abc <_strtod_r+0x15b8>
81128654:	01800204 	movi	r6,8
81128658:	01c00404 	movi	r7,16
8112865c:	4a400044 	addi	r9,r9,1
81128660:	48bfffc4 	addi	r2,r9,-1
81128664:	30801616 	blt	r6,r2,811286c0 <_strtod_r+0x11bc>
81128668:	e70002a4 	muli	fp,fp,10
8112866c:	497ffb1e 	bne	r9,r5,8112865c <__reset+0xfb10865c>
81128670:	d9800617 	ldw	r6,24(sp)
81128674:	4a400044 	addi	r9,r9,1
81128678:	00c00204 	movi	r3,8
8112867c:	19400c0e 	bge	r3,r5,811286b0 <_strtod_r+0x11ac>
81128680:	00800404 	movi	r2,16
81128684:	000b883a 	mov	r5,zero
81128688:	127ea316 	blt	r2,r9,81128118 <__reset+0xfb108118>
8112868c:	988002a4 	muli	r2,r19,10
81128690:	20a7883a 	add	r19,r4,r2
81128694:	003ea006 	br	81128118 <__reset+0xfb108118>
81128698:	d8800617 	ldw	r2,24(sp)
8112869c:	8c7ff404 	addi	r17,r17,-48
811286a0:	2a800044 	addi	r10,r5,1
811286a4:	d8800815 	stw	r2,32(sp)
811286a8:	100d883a 	mov	r6,r2
811286ac:	02400044 	movi	r9,1
811286b0:	e08002a4 	muli	r2,fp,10
811286b4:	000b883a 	mov	r5,zero
811286b8:	88b9883a 	add	fp,r17,r2
811286bc:	003e9606 	br	81128118 <__reset+0xfb108118>
811286c0:	3a7fea16 	blt	r7,r9,8112866c <__reset+0xfb10866c>
811286c4:	9cc002a4 	muli	r19,r19,10
811286c8:	003fe806 	br	8112866c <__reset+0xfb10866c>
811286cc:	00bffa84 	movi	r2,-22
811286d0:	a8bd1016 	blt	r21,r2,81127b14 <__reset+0xfb107b14>
811286d4:	a82a90fa 	slli	r21,r21,3
811286d8:	00a04574 	movhi	r2,33045
811286dc:	10a6f304 	addi	r2,r2,-25652
811286e0:	1545c83a 	sub	r2,r2,r21
811286e4:	11800017 	ldw	r6,0(r2)
811286e8:	11c00117 	ldw	r7,4(r2)
811286ec:	9009883a 	mov	r4,r18
811286f0:	880b883a 	mov	r5,r17
811286f4:	112eb640 	call	8112eb64 <__divdf3>
811286f8:	102b883a 	mov	r21,r2
811286fc:	182d883a 	mov	r22,r3
81128700:	003c4a06 	br	8112782c <__reset+0xfb10782c>
81128704:	dd000a15 	stw	r20,40(sp)
81128708:	a811883a 	mov	r8,r21
8112870c:	dd001217 	ldw	r20,72(sp)
81128710:	003e9e06 	br	8112818c <__reset+0xfb10818c>
81128714:	01604574 	movhi	r5,33045
81128718:	d9000617 	ldw	r4,24(sp)
8112871c:	29672504 	addi	r5,r5,-25452
81128720:	01c00644 	movi	r7,25
81128724:	00000b06 	br	81128754 <_strtod_r+0x1250>
81128728:	21000044 	addi	r4,r4,1
8112872c:	20800003 	ldbu	r2,0(r4)
81128730:	10ffefc4 	addi	r3,r2,-65
81128734:	10803fcc 	andi	r2,r2,255
81128738:	1080201c 	xori	r2,r2,128
8112873c:	18c03fcc 	andi	r3,r3,255
81128740:	10bfe004 	addi	r2,r2,-128
81128744:	38c00136 	bltu	r7,r3,8112874c <_strtod_r+0x1248>
81128748:	10800804 	addi	r2,r2,32
8112874c:	29400044 	addi	r5,r5,1
81128750:	11bbbb1e 	bne	r2,r6,81127640 <__reset+0xfb107640>
81128754:	29800007 	ldb	r6,0(r5)
81128758:	303ff31e 	bne	r6,zero,81128728 <__reset+0xfb108728>
8112875c:	01a04574 	movhi	r6,33045
81128760:	d9000615 	stw	r4,24(sp)
81128764:	31a72604 	addi	r6,r6,-25448
81128768:	200b883a 	mov	r5,r4
8112876c:	02000644 	movi	r8,25
81128770:	00000a06 	br	8112879c <_strtod_r+0x1298>
81128774:	28800003 	ldbu	r2,0(r5)
81128778:	10ffefc4 	addi	r3,r2,-65
8112877c:	10803fcc 	andi	r2,r2,255
81128780:	1080201c 	xori	r2,r2,128
81128784:	18c03fcc 	andi	r3,r3,255
81128788:	10bfe004 	addi	r2,r2,-128
8112878c:	40c00136 	bltu	r8,r3,81128794 <_strtod_r+0x1290>
81128790:	10800804 	addi	r2,r2,32
81128794:	31800044 	addi	r6,r6,1
81128798:	11c0711e 	bne	r2,r7,81128960 <_strtod_r+0x145c>
8112879c:	31c00007 	ldb	r7,0(r6)
811287a0:	29400044 	addi	r5,r5,1
811287a4:	383ff31e 	bne	r7,zero,81128774 <__reset+0xfb108774>
811287a8:	d9400615 	stw	r5,24(sp)
811287ac:	045ffc34 	movhi	r17,32752
811287b0:	0025883a 	mov	r18,zero
811287b4:	003c1b06 	br	81127824 <__reset+0xfb107824>
811287b8:	000b883a 	mov	r5,zero
811287bc:	003ccc06 	br	81127af0 <__reset+0xfb107af0>
811287c0:	d9400e17 	ldw	r5,56(sp)
811287c4:	dd000a15 	stw	r20,40(sp)
811287c8:	00800434 	movhi	r2,16
811287cc:	a811883a 	mov	r8,r21
811287d0:	dd001217 	ldw	r20,72(sp)
811287d4:	dd401117 	ldw	r21,68(sp)
811287d8:	dd801017 	ldw	r22,64(sp)
811287dc:	10bfffc4 	addi	r2,r2,-1
811287e0:	28005626 	beq	r5,zero,8112893c <_strtod_r+0x1438>
811287e4:	8886703a 	and	r3,r17,r2
811287e8:	18807826 	beq	r3,r2,811289cc <_strtod_r+0x14c8>
811287ec:	d8c00b17 	ldw	r3,44(sp)
811287f0:	18005726 	beq	r3,zero,81128950 <_strtod_r+0x144c>
811287f4:	1c44703a 	and	r2,r3,r17
811287f8:	10000f26 	beq	r2,zero,81128838 <_strtod_r+0x1334>
811287fc:	d9000e17 	ldw	r4,56(sp)
81128800:	d9800917 	ldw	r6,36(sp)
81128804:	20005e26 	beq	r4,zero,81128980 <_strtod_r+0x147c>
81128808:	9009883a 	mov	r4,r18
8112880c:	880b883a 	mov	r5,r17
81128810:	da001315 	stw	r8,76(sp)
81128814:	11274980 	call	81127498 <sulp>
81128818:	100d883a 	mov	r6,r2
8112881c:	180f883a 	mov	r7,r3
81128820:	9009883a 	mov	r4,r18
81128824:	880b883a 	mov	r5,r17
81128828:	112e2b00 	call	8112e2b0 <__adddf3>
8112882c:	da001317 	ldw	r8,76(sp)
81128830:	102b883a 	mov	r21,r2
81128834:	182d883a 	mov	r22,r3
81128838:	d8c00917 	ldw	r3,36(sp)
8112883c:	18000f26 	beq	r3,zero,8112887c <_strtod_r+0x1378>
81128840:	a809883a 	mov	r4,r21
81128844:	b00b883a 	mov	r5,r22
81128848:	000d883a 	mov	r6,zero
8112884c:	01ce5434 	movhi	r7,14672
81128850:	da001315 	stw	r8,76(sp)
81128854:	1119dc00 	call	81119dc0 <__muldf3>
81128858:	102b883a 	mov	r21,r2
8112885c:	182d883a 	mov	r22,r3
81128860:	da001317 	ldw	r8,76(sp)
81128864:	1800051e 	bne	r3,zero,8112887c <_strtod_r+0x1378>
81128868:	d8800517 	ldw	r2,20(sp)
8112886c:	a83e4b1e 	bne	r21,zero,8112819c <__reset+0xfb10819c>
81128870:	00c00884 	movi	r3,34
81128874:	80c00015 	stw	r3,0(r16)
81128878:	003e4806 	br	8112819c <__reset+0xfb10819c>
8112887c:	d8800517 	ldw	r2,20(sp)
81128880:	003e4606 	br	8112819c <__reset+0xfb10819c>
81128884:	d9000e17 	ldw	r4,56(sp)
81128888:	dd000a15 	stw	r20,40(sp)
8112888c:	a811883a 	mov	r8,r21
81128890:	dd001217 	ldw	r20,72(sp)
81128894:	dd401117 	ldw	r21,68(sp)
81128898:	dd801017 	ldw	r22,64(sp)
8112889c:	203fe61e 	bne	r4,zero,81128838 <__reset+0xfb108838>
811288a0:	903fe51e 	bne	r18,zero,81128838 <__reset+0xfb108838>
811288a4:	00800434 	movhi	r2,16
811288a8:	10bfffc4 	addi	r2,r2,-1
811288ac:	8884703a 	and	r2,r17,r2
811288b0:	103fe11e 	bne	r2,zero,81128838 <__reset+0xfb108838>
811288b4:	8ddffc2c 	andhi	r23,r17,32752
811288b8:	0081ac34 	movhi	r2,1712
811288bc:	15ffde2e 	bgeu	r2,r23,81128838 <__reset+0xfb108838>
811288c0:	40800517 	ldw	r2,20(r8)
811288c4:	1000031e 	bne	r2,zero,811288d4 <_strtod_r+0x13d0>
811288c8:	40800417 	ldw	r2,16(r8)
811288cc:	00c00044 	movi	r3,1
811288d0:	18bfd90e 	bge	r3,r2,81128838 <__reset+0xfb108838>
811288d4:	400b883a 	mov	r5,r8
811288d8:	01800044 	movi	r6,1
811288dc:	8009883a 	mov	r4,r16
811288e0:	11263f00 	call	811263f0 <__lshift>
811288e4:	980b883a 	mov	r5,r19
811288e8:	1009883a 	mov	r4,r2
811288ec:	d8801315 	stw	r2,76(sp)
811288f0:	11265400 	call	81126540 <__mcmp>
811288f4:	da001317 	ldw	r8,76(sp)
811288f8:	00bfcf0e 	bge	zero,r2,81128838 <__reset+0xfb108838>
811288fc:	d8c00917 	ldw	r3,36(sp)
81128900:	18005c26 	beq	r3,zero,81128a74 <_strtod_r+0x1570>
81128904:	0081ac34 	movhi	r2,1712
81128908:	15c05a16 	blt	r2,r23,81128a74 <_strtod_r+0x1570>
8112890c:	0080dc34 	movhi	r2,880
81128910:	15ffcb16 	blt	r2,r23,81128840 <__reset+0xfb108840>
81128914:	003f1106 	br	8112855c <__reset+0xfb10855c>
81128918:	002d883a 	mov	r22,zero
8112891c:	022ff834 	movhi	r8,49120
81128920:	d8000d15 	stw	zero,52(sp)
81128924:	05cff834 	movhi	r23,16352
81128928:	003ded06 	br	811280e0 <__reset+0xfb1080e0>
8112892c:	0440d434 	movhi	r17,848
81128930:	1c63883a 	add	r17,r3,r17
81128934:	d8000915 	stw	zero,36(sp)
81128938:	003cc806 	br	81127c5c <__reset+0xfb107c5c>
8112893c:	8884703a 	and	r2,r17,r2
81128940:	103faa1e 	bne	r2,zero,811287ec <__reset+0xfb1087ec>
81128944:	903fa91e 	bne	r18,zero,811287ec <__reset+0xfb1087ec>
81128948:	8ddffc2c 	andhi	r23,r17,32752
8112894c:	003feb06 	br	811288fc <__reset+0xfb1088fc>
81128950:	d8c00d17 	ldw	r3,52(sp)
81128954:	1cae703a 	and	r23,r3,r18
81128958:	b83fb726 	beq	r23,zero,81128838 <__reset+0xfb108838>
8112895c:	003fa706 	br	811287fc <__reset+0xfb1087fc>
81128960:	21000044 	addi	r4,r4,1
81128964:	d9000615 	stw	r4,24(sp)
81128968:	003f9006 	br	811287ac <__reset+0xfb1087ac>
8112896c:	01604574 	movhi	r5,33045
81128970:	2966e904 	addi	r5,r5,-25692
81128974:	d9400915 	stw	r5,36(sp)
81128978:	0027883a 	mov	r19,zero
8112897c:	003ca206 	br	81127c08 <__reset+0xfb107c08>
81128980:	9009883a 	mov	r4,r18
81128984:	880b883a 	mov	r5,r17
81128988:	da001315 	stw	r8,76(sp)
8112898c:	11274980 	call	81127498 <sulp>
81128990:	100d883a 	mov	r6,r2
81128994:	180f883a 	mov	r7,r3
81128998:	9009883a 	mov	r4,r18
8112899c:	880b883a 	mov	r5,r17
811289a0:	112f6ac0 	call	8112f6ac <__subdf3>
811289a4:	000d883a 	mov	r6,zero
811289a8:	000f883a 	mov	r7,zero
811289ac:	1009883a 	mov	r4,r2
811289b0:	180b883a 	mov	r5,r3
811289b4:	102b883a 	mov	r21,r2
811289b8:	182d883a 	mov	r22,r3
811289bc:	112f4540 	call	8112f454 <__eqdf2>
811289c0:	da001317 	ldw	r8,76(sp)
811289c4:	103ee526 	beq	r2,zero,8112855c <__reset+0xfb10855c>
811289c8:	003f9b06 	br	81128838 <__reset+0xfb108838>
811289cc:	d8800917 	ldw	r2,36(sp)
811289d0:	10002226 	beq	r2,zero,81128a5c <_strtod_r+0x1558>
811289d4:	889ffc2c 	andhi	r2,r17,32752
811289d8:	00c1a834 	movhi	r3,1696
811289dc:	18801f36 	bltu	r3,r2,81128a5c <_strtod_r+0x1558>
811289e0:	1004d53a 	srli	r2,r2,20
811289e4:	00c01ac4 	movi	r3,107
811289e8:	1887c83a 	sub	r3,r3,r2
811289ec:	00bfffc4 	movi	r2,-1
811289f0:	10c4983a 	sll	r2,r2,r3
811289f4:	14bf7d1e 	bne	r2,r18,811287ec <__reset+0xfb1087ec>
811289f8:	00dffc34 	movhi	r3,32752
811289fc:	18ffffc4 	addi	r3,r3,-1
81128a00:	88c03526 	beq	r17,r3,81128ad8 <_strtod_r+0x15d4>
81128a04:	8c5ffc2c 	andhi	r17,r17,32752
81128a08:	00800434 	movhi	r2,16
81128a0c:	002b883a 	mov	r21,zero
81128a10:	88ad883a 	add	r22,r17,r2
81128a14:	003f8806 	br	81128838 <__reset+0xfb108838>
81128a18:	01401a84 	movi	r5,106
81128a1c:	d9400915 	stw	r5,36(sp)
81128a20:	8ddffc2c 	andhi	r23,r17,32752
81128a24:	b82ed53a 	srli	r23,r23,20
81128a28:	00801ac4 	movi	r2,107
81128a2c:	15c5c83a 	sub	r2,r2,r23
81128a30:	00be8e0e 	bge	zero,r2,8112846c <__reset+0xfb10846c>
81128a34:	00c007c4 	movi	r3,31
81128a38:	18800a0e 	bge	r3,r2,81128a64 <_strtod_r+0x1560>
81128a3c:	00c00d04 	movi	r3,52
81128a40:	0025883a 	mov	r18,zero
81128a44:	1880270e 	bge	r3,r2,81128ae4 <_strtod_r+0x15e0>
81128a48:	0440dc34 	movhi	r17,880
81128a4c:	003e8706 	br	8112846c <__reset+0xfb10846c>
81128a50:	d8000915 	stw	zero,36(sp)
81128a54:	05fe6a16 	blt	zero,r23,81128400 <__reset+0xfb108400>
81128a58:	003e8406 	br	8112846c <__reset+0xfb10846c>
81128a5c:	00bfffc4 	movi	r2,-1
81128a60:	003fe406 	br	811289f4 <__reset+0xfb1089f4>
81128a64:	00ffffc4 	movi	r3,-1
81128a68:	1884983a 	sll	r2,r3,r2
81128a6c:	14a4703a 	and	r18,r2,r18
81128a70:	003e7e06 	br	8112846c <__reset+0xfb10846c>
81128a74:	00bffc34 	movhi	r2,65520
81128a78:	b8af883a 	add	r23,r23,r2
81128a7c:	057fffc4 	movi	r21,-1
81128a80:	00800434 	movhi	r2,16
81128a84:	1545883a 	add	r2,r2,r21
81128a88:	b8acb03a 	or	r22,r23,r2
81128a8c:	003f6a06 	br	81128838 <__reset+0xfb108838>
81128a90:	01604574 	movhi	r5,33045
81128a94:	29672904 	addi	r5,r5,-25436
81128a98:	d9800204 	addi	r6,sp,8
81128a9c:	d9000604 	addi	r4,sp,24
81128aa0:	112ce900 	call	8112ce90 <__hexnan>
81128aa4:	00c00144 	movi	r3,5
81128aa8:	10fb5c1e 	bne	r2,r3,8112781c <__reset+0xfb10781c>
81128aac:	dc400317 	ldw	r17,12(sp)
81128ab0:	dc800217 	ldw	r18,8(sp)
81128ab4:	8c5ffc34 	orhi	r17,r17,32752
81128ab8:	003b5a06 	br	81127824 <__reset+0xfb107824>
81128abc:	480b883a 	mov	r5,r9
81128ac0:	d9800617 	ldw	r6,24(sp)
81128ac4:	4a400044 	addi	r9,r9,1
81128ac8:	003eeb06 	br	81128678 <__reset+0xfb108678>
81128acc:	1025883a 	mov	r18,r2
81128ad0:	1823883a 	mov	r17,r3
81128ad4:	003c4c06 	br	81127c08 <__reset+0xfb107c08>
81128ad8:	00ffffc4 	movi	r3,-1
81128adc:	10ffc91e 	bne	r2,r3,81128a04 <__reset+0xfb108a04>
81128ae0:	003da906 	br	81128188 <__reset+0xfb108188>
81128ae4:	10bff804 	addi	r2,r2,-32
81128ae8:	00ffffc4 	movi	r3,-1
81128aec:	1884983a 	sll	r2,r3,r2
81128af0:	1462703a 	and	r17,r2,r17
81128af4:	003e5d06 	br	8112846c <__reset+0xfb10846c>
81128af8:	1025883a 	mov	r18,r2
81128afc:	1823883a 	mov	r17,r3
81128b00:	003e5806 	br	81128464 <__reset+0xfb108464>

81128b04 <strtod>:
81128b04:	00a04574 	movhi	r2,33045
81128b08:	10b08204 	addi	r2,r2,-15864
81128b0c:	280d883a 	mov	r6,r5
81128b10:	200b883a 	mov	r5,r4
81128b14:	11000017 	ldw	r4,0(r2)
81128b18:	11275041 	jmpi	81127504 <_strtod_r>

81128b1c <strtof>:
81128b1c:	defffb04 	addi	sp,sp,-20
81128b20:	de00012e 	bgeu	sp,et,81128b28 <strtof+0xc>
81128b24:	003b68fa 	trap	3
81128b28:	dcc00315 	stw	r19,12(sp)
81128b2c:	04e04574 	movhi	r19,33045
81128b30:	9cf08204 	addi	r19,r19,-15864
81128b34:	280d883a 	mov	r6,r5
81128b38:	200b883a 	mov	r5,r4
81128b3c:	99000017 	ldw	r4,0(r19)
81128b40:	dfc00415 	stw	ra,16(sp)
81128b44:	dc800215 	stw	r18,8(sp)
81128b48:	dc400115 	stw	r17,4(sp)
81128b4c:	dc000015 	stw	r16,0(sp)
81128b50:	11275040 	call	81127504 <_strtod_r>
81128b54:	1009883a 	mov	r4,r2
81128b58:	180b883a 	mov	r5,r3
81128b5c:	1025883a 	mov	r18,r2
81128b60:	1823883a 	mov	r17,r3
81128b64:	111a5f80 	call	8111a5f8 <__truncdfsf2>
81128b68:	000b883a 	mov	r5,zero
81128b6c:	1009883a 	mov	r4,r2
81128b70:	1021883a 	mov	r16,r2
81128b74:	112e0b40 	call	8112e0b4 <__eqsf2>
81128b78:	1000111e 	bne	r2,zero,81128bc0 <strtof+0xa4>
81128b7c:	000d883a 	mov	r6,zero
81128b80:	000f883a 	mov	r7,zero
81128b84:	9009883a 	mov	r4,r18
81128b88:	880b883a 	mov	r5,r17
81128b8c:	112f4540 	call	8112f454 <__eqdf2>
81128b90:	10000b26 	beq	r2,zero,81128bc0 <strtof+0xa4>
81128b94:	98800017 	ldw	r2,0(r19)
81128b98:	00c00884 	movi	r3,34
81128b9c:	10c00015 	stw	r3,0(r2)
81128ba0:	8005883a 	mov	r2,r16
81128ba4:	dfc00417 	ldw	ra,16(sp)
81128ba8:	dcc00317 	ldw	r19,12(sp)
81128bac:	dc800217 	ldw	r18,8(sp)
81128bb0:	dc400117 	ldw	r17,4(sp)
81128bb4:	dc000017 	ldw	r16,0(sp)
81128bb8:	dec00504 	addi	sp,sp,20
81128bbc:	f800283a 	ret
81128bc0:	015fe034 	movhi	r5,32640
81128bc4:	297fffc4 	addi	r5,r5,-1
81128bc8:	8009883a 	mov	r4,r16
81128bcc:	112e12c0 	call	8112e12c <__gesf2>
81128bd0:	0080070e 	bge	zero,r2,81128bf0 <strtof+0xd4>
81128bd4:	01dffc34 	movhi	r7,32752
81128bd8:	39ffffc4 	addi	r7,r7,-1
81128bdc:	01bfffc4 	movi	r6,-1
81128be0:	9009883a 	mov	r4,r18
81128be4:	880b883a 	mov	r5,r17
81128be8:	112f4dc0 	call	8112f4dc <__gedf2>
81128bec:	00bfe90e 	bge	zero,r2,81128b94 <__reset+0xfb108b94>
81128bf0:	017fe034 	movhi	r5,65408
81128bf4:	297fffc4 	addi	r5,r5,-1
81128bf8:	8009883a 	mov	r4,r16
81128bfc:	112e1e80 	call	8112e1e8 <__lesf2>
81128c00:	103fe70e 	bge	r2,zero,81128ba0 <__reset+0xfb108ba0>
81128c04:	01fffc34 	movhi	r7,65520
81128c08:	39ffffc4 	addi	r7,r7,-1
81128c0c:	01bfffc4 	movi	r6,-1
81128c10:	9009883a 	mov	r4,r18
81128c14:	880b883a 	mov	r5,r17
81128c18:	112f5b80 	call	8112f5b8 <__ledf2>
81128c1c:	103fdd0e 	bge	r2,zero,81128b94 <__reset+0xfb108b94>
81128c20:	003fdf06 	br	81128ba0 <__reset+0xfb108ba0>

81128c24 <_strtoll_r>:
81128c24:	00a04574 	movhi	r2,33045
81128c28:	defff304 	addi	sp,sp,-52
81128c2c:	10b08004 	addi	r2,r2,-15872
81128c30:	de00012e 	bgeu	sp,et,81128c38 <_strtoll_r+0x14>
81128c34:	003b68fa 	trap	3
81128c38:	dc800515 	stw	r18,20(sp)
81128c3c:	14800017 	ldw	r18,0(r2)
81128c40:	dd800915 	stw	r22,36(sp)
81128c44:	dd400815 	stw	r21,32(sp)
81128c48:	dcc00615 	stw	r19,24(sp)
81128c4c:	d9000015 	stw	r4,0(sp)
81128c50:	dfc00c15 	stw	ra,48(sp)
81128c54:	df000b15 	stw	fp,44(sp)
81128c58:	ddc00a15 	stw	r23,40(sp)
81128c5c:	dd000715 	stw	r20,28(sp)
81128c60:	dc400415 	stw	r17,16(sp)
81128c64:	dc000315 	stw	r16,12(sp)
81128c68:	282d883a 	mov	r22,r5
81128c6c:	302b883a 	mov	r21,r6
81128c70:	3827883a 	mov	r19,r7
81128c74:	2809883a 	mov	r4,r5
81128c78:	24000003 	ldbu	r16,0(r4)
81128c7c:	24400044 	addi	r17,r4,1
81128c80:	2007883a 	mov	r3,r4
81128c84:	9405883a 	add	r2,r18,r16
81128c88:	10800043 	ldbu	r2,1(r2)
81128c8c:	8809883a 	mov	r4,r17
81128c90:	1080020c 	andi	r2,r2,8
81128c94:	103ff81e 	bne	r2,zero,81128c78 <__reset+0xfb108c78>
81128c98:	00800b44 	movi	r2,45
81128c9c:	80807826 	beq	r16,r2,81128e80 <_strtoll_r+0x25c>
81128ca0:	00800ac4 	movi	r2,43
81128ca4:	80807a26 	beq	r16,r2,81128e90 <_strtoll_r+0x26c>
81128ca8:	0039883a 	mov	fp,zero
81128cac:	98004e26 	beq	r19,zero,81128de8 <_strtoll_r+0x1c4>
81128cb0:	00800404 	movi	r2,16
81128cb4:	98808226 	beq	r19,r2,81128ec0 <_strtoll_r+0x29c>
81128cb8:	982fd7fa 	srai	r23,r19,31
81128cbc:	9829883a 	mov	r20,r19
81128cc0:	e0004f26 	beq	fp,zero,81128e00 <_strtoll_r+0x1dc>
81128cc4:	0017883a 	mov	r11,zero
81128cc8:	02a00034 	movhi	r10,32768
81128ccc:	5809883a 	mov	r4,r11
81128cd0:	500b883a 	mov	r5,r10
81128cd4:	a00d883a 	mov	r6,r20
81128cd8:	b80f883a 	mov	r7,r23
81128cdc:	da800215 	stw	r10,8(sp)
81128ce0:	dac00115 	stw	r11,4(sp)
81128ce4:	112d9c00 	call	8112d9c0 <__umoddi3>
81128ce8:	dac00117 	ldw	r11,4(sp)
81128cec:	da800217 	ldw	r10,8(sp)
81128cf0:	a00d883a 	mov	r6,r20
81128cf4:	5809883a 	mov	r4,r11
81128cf8:	500b883a 	mov	r5,r10
81128cfc:	b80f883a 	mov	r7,r23
81128d00:	d8800115 	stw	r2,4(sp)
81128d04:	112d4400 	call	8112d440 <__udivdi3>
81128d08:	9409883a 	add	r4,r18,r16
81128d0c:	21000043 	ldbu	r4,1(r4)
81128d10:	1019883a 	mov	r12,r2
81128d14:	880b883a 	mov	r5,r17
81128d18:	2240010c 	andi	r9,r4,4
81128d1c:	0015883a 	mov	r10,zero
81128d20:	000d883a 	mov	r6,zero
81128d24:	000f883a 	mov	r7,zero
81128d28:	03400044 	movi	r13,1
81128d2c:	02ffffc4 	movi	r11,-1
81128d30:	da000117 	ldw	r8,4(sp)
81128d34:	48000d26 	beq	r9,zero,81128d6c <_strtoll_r+0x148>
81128d38:	843ff404 	addi	r16,r16,-48
81128d3c:	84c0110e 	bge	r16,r19,81128d84 <_strtoll_r+0x160>
81128d40:	52c00426 	beq	r10,r11,81128d54 <_strtoll_r+0x130>
81128d44:	19c00236 	bltu	r3,r7,81128d50 <_strtoll_r+0x12c>
81128d48:	38c0311e 	bne	r7,r3,81128e10 <_strtoll_r+0x1ec>
81128d4c:	6180302e 	bgeu	r12,r6,81128e10 <_strtoll_r+0x1ec>
81128d50:	02bfffc4 	movi	r10,-1
81128d54:	2c000003 	ldbu	r16,0(r5)
81128d58:	29400044 	addi	r5,r5,1
81128d5c:	9409883a 	add	r4,r18,r16
81128d60:	21000043 	ldbu	r4,1(r4)
81128d64:	2240010c 	andi	r9,r4,4
81128d68:	483ff31e 	bne	r9,zero,81128d38 <__reset+0xfb108d38>
81128d6c:	210000cc 	andi	r4,r4,3
81128d70:	20000426 	beq	r4,zero,81128d84 <_strtoll_r+0x160>
81128d74:	23403426 	beq	r4,r13,81128e48 <_strtoll_r+0x224>
81128d78:	008015c4 	movi	r2,87
81128d7c:	80a1c83a 	sub	r16,r16,r2
81128d80:	84ffef16 	blt	r16,r19,81128d40 <__reset+0xfb108d40>
81128d84:	00bfffc4 	movi	r2,-1
81128d88:	50803426 	beq	r10,r2,81128e5c <_strtoll_r+0x238>
81128d8c:	e0000426 	beq	fp,zero,81128da0 <_strtoll_r+0x17c>
81128d90:	018dc83a 	sub	r6,zero,r6
81128d94:	3004c03a 	cmpne	r2,r6,zero
81128d98:	01e1c83a 	sub	r16,zero,r7
81128d9c:	808fc83a 	sub	r7,r16,r2
81128da0:	3005883a 	mov	r2,r6
81128da4:	3807883a 	mov	r3,r7
81128da8:	a8000326 	beq	r21,zero,81128db8 <_strtoll_r+0x194>
81128dac:	5000321e 	bne	r10,zero,81128e78 <_strtoll_r+0x254>
81128db0:	b00b883a 	mov	r5,r22
81128db4:	a9400015 	stw	r5,0(r21)
81128db8:	dfc00c17 	ldw	ra,48(sp)
81128dbc:	df000b17 	ldw	fp,44(sp)
81128dc0:	ddc00a17 	ldw	r23,40(sp)
81128dc4:	dd800917 	ldw	r22,36(sp)
81128dc8:	dd400817 	ldw	r21,32(sp)
81128dcc:	dd000717 	ldw	r20,28(sp)
81128dd0:	dcc00617 	ldw	r19,24(sp)
81128dd4:	dc800517 	ldw	r18,20(sp)
81128dd8:	dc400417 	ldw	r17,16(sp)
81128ddc:	dc000317 	ldw	r16,12(sp)
81128de0:	dec00d04 	addi	sp,sp,52
81128de4:	f800283a 	ret
81128de8:	00800c04 	movi	r2,48
81128dec:	80802c26 	beq	r16,r2,81128ea0 <_strtoll_r+0x27c>
81128df0:	05000284 	movi	r20,10
81128df4:	002f883a 	mov	r23,zero
81128df8:	a027883a 	mov	r19,r20
81128dfc:	e03fb11e 	bne	fp,zero,81128cc4 <__reset+0xfb108cc4>
81128e00:	02a00034 	movhi	r10,32768
81128e04:	52bfffc4 	addi	r10,r10,-1
81128e08:	02ffffc4 	movi	r11,-1
81128e0c:	003faf06 	br	81128ccc <__reset+0xfb108ccc>
81128e10:	33000f26 	beq	r6,r12,81128e50 <_strtoll_r+0x22c>
81128e14:	b985383a 	mul	r2,r23,r6
81128e18:	3d0f383a 	mul	r7,r7,r20
81128e1c:	3508383a 	mulxuu	r4,r6,r20
81128e20:	350d383a 	mul	r6,r6,r20
81128e24:	8013d7fa 	srai	r9,r16,31
81128e28:	388f883a 	add	r7,r7,r2
81128e2c:	818d883a 	add	r6,r16,r6
81128e30:	390f883a 	add	r7,r7,r4
81128e34:	3421803a 	cmpltu	r16,r6,r16
81128e38:	49cf883a 	add	r7,r9,r7
81128e3c:	81cf883a 	add	r7,r16,r7
81128e40:	02800044 	movi	r10,1
81128e44:	003fc306 	br	81128d54 <__reset+0xfb108d54>
81128e48:	00800dc4 	movi	r2,55
81128e4c:	003fcb06 	br	81128d7c <__reset+0xfb108d7c>
81128e50:	38fff01e 	bne	r7,r3,81128e14 <__reset+0xfb108e14>
81128e54:	443fbe16 	blt	r8,r16,81128d50 <__reset+0xfb108d50>
81128e58:	003fee06 	br	81128e14 <__reset+0xfb108e14>
81128e5c:	e0002426 	beq	fp,zero,81128ef0 <_strtoll_r+0x2cc>
81128e60:	0005883a 	mov	r2,zero
81128e64:	00e00034 	movhi	r3,32768
81128e68:	d9800017 	ldw	r6,0(sp)
81128e6c:	01000884 	movi	r4,34
81128e70:	31000015 	stw	r4,0(r6)
81128e74:	a83fd026 	beq	r21,zero,81128db8 <__reset+0xfb108db8>
81128e78:	297fffc4 	addi	r5,r5,-1
81128e7c:	003fcd06 	br	81128db4 <__reset+0xfb108db4>
81128e80:	1c400084 	addi	r17,r3,2
81128e84:	1c000043 	ldbu	r16,1(r3)
81128e88:	07000044 	movi	fp,1
81128e8c:	003f8706 	br	81128cac <__reset+0xfb108cac>
81128e90:	1c400084 	addi	r17,r3,2
81128e94:	1c000043 	ldbu	r16,1(r3)
81128e98:	0039883a 	mov	fp,zero
81128e9c:	003f8306 	br	81128cac <__reset+0xfb108cac>
81128ea0:	88800003 	ldbu	r2,0(r17)
81128ea4:	00c01604 	movi	r3,88
81128ea8:	108037cc 	andi	r2,r2,223
81128eac:	10c00a26 	beq	r2,r3,81128ed8 <_strtoll_r+0x2b4>
81128eb0:	05000204 	movi	r20,8
81128eb4:	002f883a 	mov	r23,zero
81128eb8:	a027883a 	mov	r19,r20
81128ebc:	003f8006 	br	81128cc0 <__reset+0xfb108cc0>
81128ec0:	00800c04 	movi	r2,48
81128ec4:	80800e1e 	bne	r16,r2,81128f00 <_strtoll_r+0x2dc>
81128ec8:	88800003 	ldbu	r2,0(r17)
81128ecc:	00c01604 	movi	r3,88
81128ed0:	108037cc 	andi	r2,r2,223
81128ed4:	10c00a1e 	bne	r2,r3,81128f00 <_strtoll_r+0x2dc>
81128ed8:	05000404 	movi	r20,16
81128edc:	8c000043 	ldbu	r16,1(r17)
81128ee0:	002f883a 	mov	r23,zero
81128ee4:	8c400084 	addi	r17,r17,2
81128ee8:	a027883a 	mov	r19,r20
81128eec:	003f7406 	br	81128cc0 <__reset+0xfb108cc0>
81128ef0:	00e00034 	movhi	r3,32768
81128ef4:	18ffffc4 	addi	r3,r3,-1
81128ef8:	5005883a 	mov	r2,r10
81128efc:	003fda06 	br	81128e68 <__reset+0xfb108e68>
81128f00:	9829883a 	mov	r20,r19
81128f04:	002f883a 	mov	r23,zero
81128f08:	003f6d06 	br	81128cc0 <__reset+0xfb108cc0>

81128f0c <_strtoul_r>:
81128f0c:	00a04574 	movhi	r2,33045
81128f10:	defff604 	addi	sp,sp,-40
81128f14:	10b08004 	addi	r2,r2,-15872
81128f18:	de00012e 	bgeu	sp,et,81128f20 <_strtoul_r+0x14>
81128f1c:	003b68fa 	trap	3
81128f20:	dc800315 	stw	r18,12(sp)
81128f24:	14800017 	ldw	r18,0(r2)
81128f28:	dd400615 	stw	r21,24(sp)
81128f2c:	dd000515 	stw	r20,20(sp)
81128f30:	dcc00415 	stw	r19,16(sp)
81128f34:	2029883a 	mov	r20,r4
81128f38:	dfc00915 	stw	ra,36(sp)
81128f3c:	ddc00815 	stw	r23,32(sp)
81128f40:	dd800715 	stw	r22,28(sp)
81128f44:	dc400215 	stw	r17,8(sp)
81128f48:	dc000115 	stw	r16,4(sp)
81128f4c:	2827883a 	mov	r19,r5
81128f50:	382b883a 	mov	r21,r7
81128f54:	2809883a 	mov	r4,r5
81128f58:	24000003 	ldbu	r16,0(r4)
81128f5c:	24400044 	addi	r17,r4,1
81128f60:	2007883a 	mov	r3,r4
81128f64:	9405883a 	add	r2,r18,r16
81128f68:	10800043 	ldbu	r2,1(r2)
81128f6c:	8809883a 	mov	r4,r17
81128f70:	1080020c 	andi	r2,r2,8
81128f74:	103ff81e 	bne	r2,zero,81128f58 <__reset+0xfb108f58>
81128f78:	00800b44 	movi	r2,45
81128f7c:	80805326 	beq	r16,r2,811290cc <_strtoul_r+0x1c0>
81128f80:	00800ac4 	movi	r2,43
81128f84:	80805526 	beq	r16,r2,811290dc <_strtoul_r+0x1d0>
81128f88:	002f883a 	mov	r23,zero
81128f8c:	a8000f26 	beq	r21,zero,81128fcc <_strtoul_r+0xc0>
81128f90:	00800404 	movi	r2,16
81128f94:	a8805f26 	beq	r21,r2,81129114 <_strtoul_r+0x208>
81128f98:	013fffc4 	movi	r4,-1
81128f9c:	a80b883a 	mov	r5,r21
81128fa0:	d9800015 	stw	r6,0(sp)
81128fa4:	112dff80 	call	8112dff8 <__udivsi3>
81128fa8:	a80b883a 	mov	r5,r21
81128fac:	013fffc4 	movi	r4,-1
81128fb0:	102d883a 	mov	r22,r2
81128fb4:	112e05c0 	call	8112e05c <__umodsi3>
81128fb8:	d9800017 	ldw	r6,0(sp)
81128fbc:	1019883a 	mov	r12,r2
81128fc0:	a817883a 	mov	r11,r21
81128fc4:	b00f883a 	mov	r7,r22
81128fc8:	00000706 	br	81128fe8 <_strtoul_r+0xdc>
81128fcc:	00800c04 	movi	r2,48
81128fd0:	80804626 	beq	r16,r2,811290ec <_strtoul_r+0x1e0>
81128fd4:	05400284 	movi	r21,10
81128fd8:	01c666b4 	movhi	r7,6554
81128fdc:	03000144 	movi	r12,5
81128fe0:	39e66644 	addi	r7,r7,-26215
81128fe4:	a817883a 	mov	r11,r21
81128fe8:	9407883a 	add	r3,r18,r16
81128fec:	18c00043 	ldbu	r3,1(r3)
81128ff0:	8809883a 	mov	r4,r17
81128ff4:	0011883a 	mov	r8,zero
81128ff8:	1940010c 	andi	r5,r3,4
81128ffc:	0005883a 	mov	r2,zero
81129000:	02800044 	movi	r10,1
81129004:	027fffc4 	movi	r9,-1
81129008:	28000e26 	beq	r5,zero,81129044 <_strtoul_r+0x138>
8112900c:	843ff404 	addi	r16,r16,-48
81129010:	8540120e 	bge	r16,r21,8112905c <_strtoul_r+0x150>
81129014:	42400526 	beq	r8,r9,8112902c <_strtoul_r+0x120>
81129018:	38802236 	bltu	r7,r2,811290a4 <_strtoul_r+0x198>
8112901c:	11c02026 	beq	r2,r7,811290a0 <_strtoul_r+0x194>
81129020:	12c5383a 	mul	r2,r2,r11
81129024:	02000044 	movi	r8,1
81129028:	8085883a 	add	r2,r16,r2
8112902c:	24000003 	ldbu	r16,0(r4)
81129030:	21000044 	addi	r4,r4,1
81129034:	9407883a 	add	r3,r18,r16
81129038:	18c00043 	ldbu	r3,1(r3)
8112903c:	1940010c 	andi	r5,r3,4
81129040:	283ff21e 	bne	r5,zero,8112900c <__reset+0xfb10900c>
81129044:	18c000cc 	andi	r3,r3,3
81129048:	18000426 	beq	r3,zero,8112905c <_strtoul_r+0x150>
8112904c:	1a801726 	beq	r3,r10,811290ac <_strtoul_r+0x1a0>
81129050:	00c015c4 	movi	r3,87
81129054:	80e1c83a 	sub	r16,r16,r3
81129058:	857fee16 	blt	r16,r21,81129014 <__reset+0xfb109014>
8112905c:	40001516 	blt	r8,zero,811290b4 <_strtoul_r+0x1a8>
81129060:	b8000126 	beq	r23,zero,81129068 <_strtoul_r+0x15c>
81129064:	0085c83a 	sub	r2,zero,r2
81129068:	30000226 	beq	r6,zero,81129074 <_strtoul_r+0x168>
8112906c:	4000151e 	bne	r8,zero,811290c4 <_strtoul_r+0x1b8>
81129070:	34c00015 	stw	r19,0(r6)
81129074:	dfc00917 	ldw	ra,36(sp)
81129078:	ddc00817 	ldw	r23,32(sp)
8112907c:	dd800717 	ldw	r22,28(sp)
81129080:	dd400617 	ldw	r21,24(sp)
81129084:	dd000517 	ldw	r20,20(sp)
81129088:	dcc00417 	ldw	r19,16(sp)
8112908c:	dc800317 	ldw	r18,12(sp)
81129090:	dc400217 	ldw	r17,8(sp)
81129094:	dc000117 	ldw	r16,4(sp)
81129098:	dec00a04 	addi	sp,sp,40
8112909c:	f800283a 	ret
811290a0:	643fdf0e 	bge	r12,r16,81129020 <__reset+0xfb109020>
811290a4:	023fffc4 	movi	r8,-1
811290a8:	003fe006 	br	8112902c <__reset+0xfb10902c>
811290ac:	00c00dc4 	movi	r3,55
811290b0:	003fe806 	br	81129054 <__reset+0xfb109054>
811290b4:	00800884 	movi	r2,34
811290b8:	a0800015 	stw	r2,0(r20)
811290bc:	00bfffc4 	movi	r2,-1
811290c0:	303fec26 	beq	r6,zero,81129074 <__reset+0xfb109074>
811290c4:	24ffffc4 	addi	r19,r4,-1
811290c8:	003fe906 	br	81129070 <__reset+0xfb109070>
811290cc:	1c400084 	addi	r17,r3,2
811290d0:	1c000043 	ldbu	r16,1(r3)
811290d4:	05c00044 	movi	r23,1
811290d8:	003fac06 	br	81128f8c <__reset+0xfb108f8c>
811290dc:	1c400084 	addi	r17,r3,2
811290e0:	1c000043 	ldbu	r16,1(r3)
811290e4:	002f883a 	mov	r23,zero
811290e8:	003fa806 	br	81128f8c <__reset+0xfb108f8c>
811290ec:	88800003 	ldbu	r2,0(r17)
811290f0:	00c01604 	movi	r3,88
811290f4:	108037cc 	andi	r2,r2,223
811290f8:	10c00c26 	beq	r2,r3,8112912c <_strtoul_r+0x220>
811290fc:	05400204 	movi	r21,8
81129100:	01c80034 	movhi	r7,8192
81129104:	030001c4 	movi	r12,7
81129108:	39ffffc4 	addi	r7,r7,-1
8112910c:	a817883a 	mov	r11,r21
81129110:	003fb506 	br	81128fe8 <__reset+0xfb108fe8>
81129114:	00800c04 	movi	r2,48
81129118:	80800c1e 	bne	r16,r2,8112914c <_strtoul_r+0x240>
8112911c:	88800003 	ldbu	r2,0(r17)
81129120:	00c01604 	movi	r3,88
81129124:	108037cc 	andi	r2,r2,223
81129128:	10c0081e 	bne	r2,r3,8112914c <_strtoul_r+0x240>
8112912c:	02c00404 	movi	r11,16
81129130:	05840034 	movhi	r22,4096
81129134:	8c000043 	ldbu	r16,1(r17)
81129138:	030003c4 	movi	r12,15
8112913c:	8c400084 	addi	r17,r17,2
81129140:	b5bfffc4 	addi	r22,r22,-1
81129144:	582b883a 	mov	r21,r11
81129148:	003f9e06 	br	81128fc4 <__reset+0xfb108fc4>
8112914c:	01c40034 	movhi	r7,4096
81129150:	030003c4 	movi	r12,15
81129154:	39ffffc4 	addi	r7,r7,-1
81129158:	a817883a 	mov	r11,r21
8112915c:	003fa206 	br	81128fe8 <__reset+0xfb108fe8>

81129160 <strtoul>:
81129160:	00a04574 	movhi	r2,33045
81129164:	10b08204 	addi	r2,r2,-15864
81129168:	300f883a 	mov	r7,r6
8112916c:	280d883a 	mov	r6,r5
81129170:	200b883a 	mov	r5,r4
81129174:	11000017 	ldw	r4,0(r2)
81129178:	1128f0c1 	jmpi	81128f0c <_strtoul_r>

8112917c <_strtoull_r>:
8112917c:	00a04574 	movhi	r2,33045
81129180:	defff404 	addi	sp,sp,-48
81129184:	10b08004 	addi	r2,r2,-15872
81129188:	de00012e 	bgeu	sp,et,81129190 <_strtoull_r+0x14>
8112918c:	003b68fa 	trap	3
81129190:	dc400315 	stw	r17,12(sp)
81129194:	14400017 	ldw	r17,0(r2)
81129198:	dd400715 	stw	r21,28(sp)
8112919c:	dd000615 	stw	r20,24(sp)
811291a0:	dcc00515 	stw	r19,20(sp)
811291a4:	dc800415 	stw	r18,16(sp)
811291a8:	dfc00b15 	stw	ra,44(sp)
811291ac:	df000a15 	stw	fp,40(sp)
811291b0:	ddc00915 	stw	r23,36(sp)
811291b4:	dd800815 	stw	r22,32(sp)
811291b8:	dc000215 	stw	r16,8(sp)
811291bc:	2827883a 	mov	r19,r5
811291c0:	202b883a 	mov	r21,r4
811291c4:	3029883a 	mov	r20,r6
811291c8:	3825883a 	mov	r18,r7
811291cc:	2807883a 	mov	r3,r5
811291d0:	1c000003 	ldbu	r16,0(r3)
811291d4:	1f000044 	addi	fp,r3,1
811291d8:	1809883a 	mov	r4,r3
811291dc:	8c05883a 	add	r2,r17,r16
811291e0:	10800043 	ldbu	r2,1(r2)
811291e4:	e007883a 	mov	r3,fp
811291e8:	1080020c 	andi	r2,r2,8
811291ec:	103ff81e 	bne	r2,zero,811291d0 <__reset+0xfb1091d0>
811291f0:	00800b44 	movi	r2,45
811291f4:	80806e26 	beq	r16,r2,811293b0 <_strtoull_r+0x234>
811291f8:	00800ac4 	movi	r2,43
811291fc:	80807026 	beq	r16,r2,811293c0 <_strtoull_r+0x244>
81129200:	002f883a 	mov	r23,zero
81129204:	90001426 	beq	r18,zero,81129258 <_strtoull_r+0xdc>
81129208:	00800404 	movi	r2,16
8112920c:	90807c26 	beq	r18,r2,81129400 <_strtoull_r+0x284>
81129210:	902dd7fa 	srai	r22,r18,31
81129214:	013fffc4 	movi	r4,-1
81129218:	200b883a 	mov	r5,r4
8112921c:	900d883a 	mov	r6,r18
81129220:	b00f883a 	mov	r7,r22
81129224:	112d4400 	call	8112d440 <__udivdi3>
81129228:	013fffc4 	movi	r4,-1
8112922c:	900d883a 	mov	r6,r18
81129230:	b00f883a 	mov	r7,r22
81129234:	200b883a 	mov	r5,r4
81129238:	d8c00115 	stw	r3,4(sp)
8112923c:	d8800015 	stw	r2,0(sp)
81129240:	112d9c00 	call	8112d9c0 <__umoddi3>
81129244:	101b883a 	mov	r13,r2
81129248:	9015883a 	mov	r10,r18
8112924c:	dac00017 	ldw	r11,0(sp)
81129250:	da000117 	ldw	r8,4(sp)
81129254:	00000a06 	br	81129280 <_strtoull_r+0x104>
81129258:	00800c04 	movi	r2,48
8112925c:	80805c26 	beq	r16,r2,811293d0 <_strtoull_r+0x254>
81129260:	02800284 	movi	r10,10
81129264:	02e666b4 	movhi	r11,39322
81129268:	020666b4 	movhi	r8,6554
8112926c:	03400144 	movi	r13,5
81129270:	5ae66644 	addi	r11,r11,-26215
81129274:	42266644 	addi	r8,r8,-26215
81129278:	002d883a 	mov	r22,zero
8112927c:	5025883a 	mov	r18,r10
81129280:	8c0b883a 	add	r5,r17,r16
81129284:	29400043 	ldbu	r5,1(r5)
81129288:	e009883a 	mov	r4,fp
8112928c:	000f883a 	mov	r7,zero
81129290:	2980010c 	andi	r6,r5,4
81129294:	0005883a 	mov	r2,zero
81129298:	0007883a 	mov	r3,zero
8112929c:	03000044 	movi	r12,1
811292a0:	027fffc4 	movi	r9,-1
811292a4:	30000d26 	beq	r6,zero,811292dc <_strtoull_r+0x160>
811292a8:	843ff404 	addi	r16,r16,-48
811292ac:	8480110e 	bge	r16,r18,811292f4 <_strtoull_r+0x178>
811292b0:	3a400426 	beq	r7,r9,811292c4 <_strtoull_r+0x148>
811292b4:	40c00236 	bltu	r8,r3,811292c0 <_strtoull_r+0x144>
811292b8:	1a00231e 	bne	r3,r8,81129348 <_strtoull_r+0x1cc>
811292bc:	5880222e 	bgeu	r11,r2,81129348 <_strtoull_r+0x1cc>
811292c0:	01ffffc4 	movi	r7,-1
811292c4:	24000003 	ldbu	r16,0(r4)
811292c8:	21000044 	addi	r4,r4,1
811292cc:	8c0b883a 	add	r5,r17,r16
811292d0:	29400043 	ldbu	r5,1(r5)
811292d4:	2980010c 	andi	r6,r5,4
811292d8:	303ff31e 	bne	r6,zero,811292a8 <__reset+0xfb1092a8>
811292dc:	294000cc 	andi	r5,r5,3
811292e0:	28000426 	beq	r5,zero,811292f4 <_strtoull_r+0x178>
811292e4:	2b002626 	beq	r5,r12,81129380 <_strtoull_r+0x204>
811292e8:	014015c4 	movi	r5,87
811292ec:	8161c83a 	sub	r16,r16,r5
811292f0:	84bfef16 	blt	r16,r18,811292b0 <__reset+0xfb1092b0>
811292f4:	38002716 	blt	r7,zero,81129394 <_strtoull_r+0x218>
811292f8:	b8000426 	beq	r23,zero,8112930c <_strtoull_r+0x190>
811292fc:	0085c83a 	sub	r2,zero,r2
81129300:	100ac03a 	cmpne	r5,r2,zero
81129304:	00e1c83a 	sub	r16,zero,r3
81129308:	8147c83a 	sub	r3,r16,r5
8112930c:	a0000226 	beq	r20,zero,81129318 <_strtoull_r+0x19c>
81129310:	3800251e 	bne	r7,zero,811293a8 <_strtoull_r+0x22c>
81129314:	a4c00015 	stw	r19,0(r20)
81129318:	dfc00b17 	ldw	ra,44(sp)
8112931c:	df000a17 	ldw	fp,40(sp)
81129320:	ddc00917 	ldw	r23,36(sp)
81129324:	dd800817 	ldw	r22,32(sp)
81129328:	dd400717 	ldw	r21,28(sp)
8112932c:	dd000617 	ldw	r20,24(sp)
81129330:	dcc00517 	ldw	r19,20(sp)
81129334:	dc800417 	ldw	r18,16(sp)
81129338:	dc400317 	ldw	r17,12(sp)
8112933c:	dc000217 	ldw	r16,8(sp)
81129340:	dec00c04 	addi	sp,sp,48
81129344:	f800283a 	ret
81129348:	12c00f26 	beq	r2,r11,81129388 <_strtoull_r+0x20c>
8112934c:	b08d383a 	mul	r6,r22,r2
81129350:	1a87383a 	mul	r3,r3,r10
81129354:	128a383a 	mulxuu	r5,r2,r10
81129358:	1285383a 	mul	r2,r2,r10
8112935c:	800fd7fa 	srai	r7,r16,31
81129360:	1987883a 	add	r3,r3,r6
81129364:	8085883a 	add	r2,r16,r2
81129368:	1947883a 	add	r3,r3,r5
8112936c:	38c7883a 	add	r3,r7,r3
81129370:	1421803a 	cmpltu	r16,r2,r16
81129374:	80c7883a 	add	r3,r16,r3
81129378:	01c00044 	movi	r7,1
8112937c:	003fd106 	br	811292c4 <__reset+0xfb1092c4>
81129380:	01400dc4 	movi	r5,55
81129384:	003fd906 	br	811292ec <__reset+0xfb1092ec>
81129388:	1a3ff01e 	bne	r3,r8,8112934c <__reset+0xfb10934c>
8112938c:	6c3fcc16 	blt	r13,r16,811292c0 <__reset+0xfb1092c0>
81129390:	003fee06 	br	8112934c <__reset+0xfb10934c>
81129394:	00800884 	movi	r2,34
81129398:	a8800015 	stw	r2,0(r21)
8112939c:	00bfffc4 	movi	r2,-1
811293a0:	1007883a 	mov	r3,r2
811293a4:	a03fdc26 	beq	r20,zero,81129318 <__reset+0xfb109318>
811293a8:	24ffffc4 	addi	r19,r4,-1
811293ac:	003fd906 	br	81129314 <__reset+0xfb109314>
811293b0:	27000084 	addi	fp,r4,2
811293b4:	24000043 	ldbu	r16,1(r4)
811293b8:	05c00044 	movi	r23,1
811293bc:	003f9106 	br	81129204 <__reset+0xfb109204>
811293c0:	27000084 	addi	fp,r4,2
811293c4:	24000043 	ldbu	r16,1(r4)
811293c8:	002f883a 	mov	r23,zero
811293cc:	003f8d06 	br	81129204 <__reset+0xfb109204>
811293d0:	e0800003 	ldbu	r2,0(fp)
811293d4:	00c01604 	movi	r3,88
811293d8:	108037cc 	andi	r2,r2,223
811293dc:	10c00e26 	beq	r2,r3,81129418 <_strtoull_r+0x29c>
811293e0:	02800204 	movi	r10,8
811293e4:	02ffffc4 	movi	r11,-1
811293e8:	02080034 	movhi	r8,8192
811293ec:	034001c4 	movi	r13,7
811293f0:	42d1883a 	add	r8,r8,r11
811293f4:	002d883a 	mov	r22,zero
811293f8:	5025883a 	mov	r18,r10
811293fc:	003fa006 	br	81129280 <__reset+0xfb109280>
81129400:	00800c04 	movi	r2,48
81129404:	80800e1e 	bne	r16,r2,81129440 <_strtoull_r+0x2c4>
81129408:	e0800003 	ldbu	r2,0(fp)
8112940c:	00c01604 	movi	r3,88
81129410:	108037cc 	andi	r2,r2,223
81129414:	10c00a1e 	bne	r2,r3,81129440 <_strtoull_r+0x2c4>
81129418:	02800404 	movi	r10,16
8112941c:	02ffffc4 	movi	r11,-1
81129420:	02040034 	movhi	r8,4096
81129424:	e4000043 	ldbu	r16,1(fp)
81129428:	034003c4 	movi	r13,15
8112942c:	e7000084 	addi	fp,fp,2
81129430:	42d1883a 	add	r8,r8,r11
81129434:	002d883a 	mov	r22,zero
81129438:	5025883a 	mov	r18,r10
8112943c:	003f9006 	br	81129280 <__reset+0xfb109280>
81129440:	02ffffc4 	movi	r11,-1
81129444:	02040034 	movhi	r8,4096
81129448:	034003c4 	movi	r13,15
8112944c:	42d1883a 	add	r8,r8,r11
81129450:	9015883a 	mov	r10,r18
81129454:	002d883a 	mov	r22,zero
81129458:	003f8906 	br	81129280 <__reset+0xfb109280>

8112945c <__ssprint_r>:
8112945c:	defff604 	addi	sp,sp,-40
81129460:	de00012e 	bgeu	sp,et,81129468 <__ssprint_r+0xc>
81129464:	003b68fa 	trap	3
81129468:	30800217 	ldw	r2,8(r6)
8112946c:	dc800215 	stw	r18,8(sp)
81129470:	dfc00915 	stw	ra,36(sp)
81129474:	df000815 	stw	fp,32(sp)
81129478:	ddc00715 	stw	r23,28(sp)
8112947c:	dd800615 	stw	r22,24(sp)
81129480:	dd400515 	stw	r21,20(sp)
81129484:	dd000415 	stw	r20,16(sp)
81129488:	dcc00315 	stw	r19,12(sp)
8112948c:	dc400115 	stw	r17,4(sp)
81129490:	dc000015 	stw	r16,0(sp)
81129494:	3025883a 	mov	r18,r6
81129498:	10005826 	beq	r2,zero,811295fc <__ssprint_r+0x1a0>
8112949c:	2027883a 	mov	r19,r4
811294a0:	35c00017 	ldw	r23,0(r6)
811294a4:	29000017 	ldw	r4,0(r5)
811294a8:	28800217 	ldw	r2,8(r5)
811294ac:	2823883a 	mov	r17,r5
811294b0:	0039883a 	mov	fp,zero
811294b4:	0021883a 	mov	r16,zero
811294b8:	80003926 	beq	r16,zero,811295a0 <__ssprint_r+0x144>
811294bc:	102b883a 	mov	r21,r2
811294c0:	102d883a 	mov	r22,r2
811294c4:	80803a36 	bltu	r16,r2,811295b0 <__ssprint_r+0x154>
811294c8:	88c0030b 	ldhu	r3,12(r17)
811294cc:	1881200c 	andi	r2,r3,1152
811294d0:	10002626 	beq	r2,zero,8112956c <__ssprint_r+0x110>
811294d4:	88800517 	ldw	r2,20(r17)
811294d8:	89400417 	ldw	r5,16(r17)
811294dc:	81800044 	addi	r6,r16,1
811294e0:	108f883a 	add	r7,r2,r2
811294e4:	3885883a 	add	r2,r7,r2
811294e8:	100ed7fa 	srli	r7,r2,31
811294ec:	216dc83a 	sub	r22,r4,r5
811294f0:	3589883a 	add	r4,r6,r22
811294f4:	3885883a 	add	r2,r7,r2
811294f8:	102bd07a 	srai	r21,r2,1
811294fc:	a80d883a 	mov	r6,r21
81129500:	a900022e 	bgeu	r21,r4,8112950c <__ssprint_r+0xb0>
81129504:	202b883a 	mov	r21,r4
81129508:	200d883a 	mov	r6,r4
8112950c:	18c1000c 	andi	r3,r3,1024
81129510:	18002a26 	beq	r3,zero,811295bc <__ssprint_r+0x160>
81129514:	300b883a 	mov	r5,r6
81129518:	9809883a 	mov	r4,r19
8112951c:	111b1fc0 	call	8111b1fc <_malloc_r>
81129520:	1029883a 	mov	r20,r2
81129524:	10002c26 	beq	r2,zero,811295d8 <__ssprint_r+0x17c>
81129528:	89400417 	ldw	r5,16(r17)
8112952c:	b00d883a 	mov	r6,r22
81129530:	1009883a 	mov	r4,r2
81129534:	111ba100 	call	8111ba10 <memcpy>
81129538:	8880030b 	ldhu	r2,12(r17)
8112953c:	00fedfc4 	movi	r3,-1153
81129540:	10c4703a 	and	r2,r2,r3
81129544:	10802014 	ori	r2,r2,128
81129548:	8880030d 	sth	r2,12(r17)
8112954c:	a589883a 	add	r4,r20,r22
81129550:	adadc83a 	sub	r22,r21,r22
81129554:	8d400515 	stw	r21,20(r17)
81129558:	8d800215 	stw	r22,8(r17)
8112955c:	8d000415 	stw	r20,16(r17)
81129560:	89000015 	stw	r4,0(r17)
81129564:	802b883a 	mov	r21,r16
81129568:	802d883a 	mov	r22,r16
8112956c:	b00d883a 	mov	r6,r22
81129570:	e00b883a 	mov	r5,fp
81129574:	1125ae40 	call	81125ae4 <memmove>
81129578:	88800217 	ldw	r2,8(r17)
8112957c:	89000017 	ldw	r4,0(r17)
81129580:	90c00217 	ldw	r3,8(r18)
81129584:	1545c83a 	sub	r2,r2,r21
81129588:	2589883a 	add	r4,r4,r22
8112958c:	88800215 	stw	r2,8(r17)
81129590:	89000015 	stw	r4,0(r17)
81129594:	1c21c83a 	sub	r16,r3,r16
81129598:	94000215 	stw	r16,8(r18)
8112959c:	80001726 	beq	r16,zero,811295fc <__ssprint_r+0x1a0>
811295a0:	bf000017 	ldw	fp,0(r23)
811295a4:	bc000117 	ldw	r16,4(r23)
811295a8:	bdc00204 	addi	r23,r23,8
811295ac:	003fc206 	br	811294b8 <__reset+0xfb1094b8>
811295b0:	802b883a 	mov	r21,r16
811295b4:	802d883a 	mov	r22,r16
811295b8:	003fec06 	br	8112956c <__reset+0xfb10956c>
811295bc:	9809883a 	mov	r4,r19
811295c0:	1126d040 	call	81126d04 <_realloc_r>
811295c4:	1029883a 	mov	r20,r2
811295c8:	103fe01e 	bne	r2,zero,8112954c <__reset+0xfb10954c>
811295cc:	89400417 	ldw	r5,16(r17)
811295d0:	9809883a 	mov	r4,r19
811295d4:	1124c700 	call	81124c70 <_free_r>
811295d8:	88c0030b 	ldhu	r3,12(r17)
811295dc:	00800304 	movi	r2,12
811295e0:	98800015 	stw	r2,0(r19)
811295e4:	18c01014 	ori	r3,r3,64
811295e8:	88c0030d 	sth	r3,12(r17)
811295ec:	00bfffc4 	movi	r2,-1
811295f0:	90000215 	stw	zero,8(r18)
811295f4:	90000115 	stw	zero,4(r18)
811295f8:	00000206 	br	81129604 <__ssprint_r+0x1a8>
811295fc:	90000115 	stw	zero,4(r18)
81129600:	0005883a 	mov	r2,zero
81129604:	dfc00917 	ldw	ra,36(sp)
81129608:	df000817 	ldw	fp,32(sp)
8112960c:	ddc00717 	ldw	r23,28(sp)
81129610:	dd800617 	ldw	r22,24(sp)
81129614:	dd400517 	ldw	r21,20(sp)
81129618:	dd000417 	ldw	r20,16(sp)
8112961c:	dcc00317 	ldw	r19,12(sp)
81129620:	dc800217 	ldw	r18,8(sp)
81129624:	dc400117 	ldw	r17,4(sp)
81129628:	dc000017 	ldw	r16,0(sp)
8112962c:	dec00a04 	addi	sp,sp,40
81129630:	f800283a 	ret

81129634 <___svfiprintf_internal_r>:
81129634:	deffc804 	addi	sp,sp,-224
81129638:	de00012e 	bgeu	sp,et,81129640 <___svfiprintf_internal_r+0xc>
8112963c:	003b68fa 	trap	3
81129640:	2880030b 	ldhu	r2,12(r5)
81129644:	dcc03115 	stw	r19,196(sp)
81129648:	dfc03715 	stw	ra,220(sp)
8112964c:	df003615 	stw	fp,216(sp)
81129650:	ddc03515 	stw	r23,212(sp)
81129654:	dd803415 	stw	r22,208(sp)
81129658:	dd403315 	stw	r21,204(sp)
8112965c:	dd003215 	stw	r20,200(sp)
81129660:	dc803015 	stw	r18,192(sp)
81129664:	dc402f15 	stw	r17,188(sp)
81129668:	dc002e15 	stw	r16,184(sp)
8112966c:	d9402715 	stw	r5,156(sp)
81129670:	d9002a15 	stw	r4,168(sp)
81129674:	1080200c 	andi	r2,r2,128
81129678:	d9c02315 	stw	r7,140(sp)
8112967c:	3027883a 	mov	r19,r6
81129680:	10000226 	beq	r2,zero,8112968c <___svfiprintf_internal_r+0x58>
81129684:	28800417 	ldw	r2,16(r5)
81129688:	10041d26 	beq	r2,zero,8112a700 <___svfiprintf_internal_r+0x10cc>
8112968c:	dac01a04 	addi	r11,sp,104
81129690:	dac01e15 	stw	r11,120(sp)
81129694:	d8801e17 	ldw	r2,120(sp)
81129698:	dac019c4 	addi	r11,sp,103
8112969c:	dd402a17 	ldw	r21,168(sp)
811296a0:	ddc02717 	ldw	r23,156(sp)
811296a4:	05a04574 	movhi	r22,33045
811296a8:	05204574 	movhi	r20,33045
811296ac:	dac01f15 	stw	r11,124(sp)
811296b0:	12d7c83a 	sub	r11,r2,r11
811296b4:	b5a74104 	addi	r22,r22,-25340
811296b8:	a5273d04 	addi	r20,r20,-25356
811296bc:	dec01a15 	stw	sp,104(sp)
811296c0:	d8001c15 	stw	zero,112(sp)
811296c4:	d8001b15 	stw	zero,108(sp)
811296c8:	d811883a 	mov	r8,sp
811296cc:	d8002915 	stw	zero,164(sp)
811296d0:	d8002515 	stw	zero,148(sp)
811296d4:	dac02b15 	stw	r11,172(sp)
811296d8:	98800007 	ldb	r2,0(r19)
811296dc:	1002dd26 	beq	r2,zero,8112a254 <___svfiprintf_internal_r+0xc20>
811296e0:	00c00944 	movi	r3,37
811296e4:	9823883a 	mov	r17,r19
811296e8:	10c0021e 	bne	r2,r3,811296f4 <___svfiprintf_internal_r+0xc0>
811296ec:	00001406 	br	81129740 <___svfiprintf_internal_r+0x10c>
811296f0:	10c00326 	beq	r2,r3,81129700 <___svfiprintf_internal_r+0xcc>
811296f4:	8c400044 	addi	r17,r17,1
811296f8:	88800007 	ldb	r2,0(r17)
811296fc:	103ffc1e 	bne	r2,zero,811296f0 <__reset+0xfb1096f0>
81129700:	8ce1c83a 	sub	r16,r17,r19
81129704:	80000e26 	beq	r16,zero,81129740 <___svfiprintf_internal_r+0x10c>
81129708:	d8c01c17 	ldw	r3,112(sp)
8112970c:	d8801b17 	ldw	r2,108(sp)
81129710:	44c00015 	stw	r19,0(r8)
81129714:	1c07883a 	add	r3,r3,r16
81129718:	10800044 	addi	r2,r2,1
8112971c:	d8c01c15 	stw	r3,112(sp)
81129720:	44000115 	stw	r16,4(r8)
81129724:	d8801b15 	stw	r2,108(sp)
81129728:	00c001c4 	movi	r3,7
8112972c:	18831e16 	blt	r3,r2,8112a3a8 <___svfiprintf_internal_r+0xd74>
81129730:	42000204 	addi	r8,r8,8
81129734:	dac02517 	ldw	r11,148(sp)
81129738:	5c17883a 	add	r11,r11,r16
8112973c:	dac02515 	stw	r11,148(sp)
81129740:	88800007 	ldb	r2,0(r17)
81129744:	1002c526 	beq	r2,zero,8112a25c <___svfiprintf_internal_r+0xc28>
81129748:	88c00047 	ldb	r3,1(r17)
8112974c:	8cc00044 	addi	r19,r17,1
81129750:	d8001d85 	stb	zero,118(sp)
81129754:	0009883a 	mov	r4,zero
81129758:	000f883a 	mov	r7,zero
8112975c:	043fffc4 	movi	r16,-1
81129760:	d8002415 	stw	zero,144(sp)
81129764:	0025883a 	mov	r18,zero
81129768:	01401604 	movi	r5,88
8112976c:	01800244 	movi	r6,9
81129770:	02800a84 	movi	r10,42
81129774:	02401b04 	movi	r9,108
81129778:	9cc00044 	addi	r19,r19,1
8112977c:	18bff804 	addi	r2,r3,-32
81129780:	2881dd36 	bltu	r5,r2,81129ef8 <___svfiprintf_internal_r+0x8c4>
81129784:	100490ba 	slli	r2,r2,2
81129788:	02e044f4 	movhi	r11,33043
8112978c:	5ae5e704 	addi	r11,r11,-26724
81129790:	12c5883a 	add	r2,r2,r11
81129794:	10800017 	ldw	r2,0(r2)
81129798:	1000683a 	jmp	r2
8112979c:	81129998 	cmpnei	r4,r16,19046
811297a0:	81129ef8 	rdprs	r4,r16,19067
811297a4:	81129ef8 	rdprs	r4,r16,19067
811297a8:	8112998c 	andi	r4,r16,19046
811297ac:	81129ef8 	rdprs	r4,r16,19067
811297b0:	81129ef8 	rdprs	r4,r16,19067
811297b4:	81129ef8 	rdprs	r4,r16,19067
811297b8:	81129ef8 	rdprs	r4,r16,19067
811297bc:	81129ef8 	rdprs	r4,r16,19067
811297c0:	81129ef8 	rdprs	r4,r16,19067
811297c4:	81129900 	call	88112990 <__reset+0x20f2990>
811297c8:	81129adc 	xori	r4,r16,19051
811297cc:	81129ef8 	rdprs	r4,r16,19067
811297d0:	8112992c 	andhi	r4,r16,19044
811297d4:	81129f2c 	andhi	r4,r16,19068
811297d8:	81129ef8 	rdprs	r4,r16,19067
811297dc:	81129f20 	cmpeqi	r4,r16,19068
811297e0:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297e4:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297e8:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297ec:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297f0:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297f4:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297f8:	81129ec0 	call	881129ec <__reset+0x20f29ec>
811297fc:	81129ec0 	call	881129ec <__reset+0x20f29ec>
81129800:	81129ec0 	call	881129ec <__reset+0x20f29ec>
81129804:	81129ef8 	rdprs	r4,r16,19067
81129808:	81129ef8 	rdprs	r4,r16,19067
8112980c:	81129ef8 	rdprs	r4,r16,19067
81129810:	81129ef8 	rdprs	r4,r16,19067
81129814:	81129ef8 	rdprs	r4,r16,19067
81129818:	81129ef8 	rdprs	r4,r16,19067
8112981c:	81129ef8 	rdprs	r4,r16,19067
81129820:	81129ef8 	rdprs	r4,r16,19067
81129824:	81129ef8 	rdprs	r4,r16,19067
81129828:	81129ef8 	rdprs	r4,r16,19067
8112982c:	81129e5c 	xori	r4,r16,19065
81129830:	81129ef8 	rdprs	r4,r16,19067
81129834:	81129ef8 	rdprs	r4,r16,19067
81129838:	81129ef8 	rdprs	r4,r16,19067
8112983c:	81129ef8 	rdprs	r4,r16,19067
81129840:	81129ef8 	rdprs	r4,r16,19067
81129844:	81129ef8 	rdprs	r4,r16,19067
81129848:	81129ef8 	rdprs	r4,r16,19067
8112984c:	81129ef8 	rdprs	r4,r16,19067
81129850:	81129ef8 	rdprs	r4,r16,19067
81129854:	81129ef8 	rdprs	r4,r16,19067
81129858:	81129fd4 	ori	r4,r16,19071
8112985c:	81129ef8 	rdprs	r4,r16,19067
81129860:	81129ef8 	rdprs	r4,r16,19067
81129864:	81129ef8 	rdprs	r4,r16,19067
81129868:	81129ef8 	rdprs	r4,r16,19067
8112986c:	81129ef8 	rdprs	r4,r16,19067
81129870:	81129f6c 	andhi	r4,r16,19069
81129874:	81129ef8 	rdprs	r4,r16,19067
81129878:	81129ef8 	rdprs	r4,r16,19067
8112987c:	81129ca0 	cmpeqi	r4,r16,19058
81129880:	81129ef8 	rdprs	r4,r16,19067
81129884:	81129ef8 	rdprs	r4,r16,19067
81129888:	81129ef8 	rdprs	r4,r16,19067
8112988c:	81129ef8 	rdprs	r4,r16,19067
81129890:	81129ef8 	rdprs	r4,r16,19067
81129894:	81129ef8 	rdprs	r4,r16,19067
81129898:	81129ef8 	rdprs	r4,r16,19067
8112989c:	81129ef8 	rdprs	r4,r16,19067
811298a0:	81129ef8 	rdprs	r4,r16,19067
811298a4:	81129ef8 	rdprs	r4,r16,19067
811298a8:	81129b90 	cmplti	r4,r16,19054
811298ac:	81129d3c 	xorhi	r4,r16,19060
811298b0:	81129ef8 	rdprs	r4,r16,19067
811298b4:	81129ef8 	rdprs	r4,r16,19067
811298b8:	81129ef8 	rdprs	r4,r16,19067
811298bc:	81129d30 	cmpltui	r4,r16,19060
811298c0:	81129d3c 	xorhi	r4,r16,19060
811298c4:	81129ef8 	rdprs	r4,r16,19067
811298c8:	81129ef8 	rdprs	r4,r16,19067
811298cc:	81129d20 	cmpeqi	r4,r16,19060
811298d0:	81129ef8 	rdprs	r4,r16,19067
811298d4:	81129ce4 	muli	r4,r16,19059
811298d8:	81129aec 	andhi	r4,r16,19051
811298dc:	81129938 	rdprs	r4,r16,19044
811298e0:	81129e50 	cmplti	r4,r16,19065
811298e4:	81129ef8 	rdprs	r4,r16,19067
811298e8:	81129e04 	addi	r4,r16,19064
811298ec:	81129ef8 	rdprs	r4,r16,19067
811298f0:	81129a5c 	xori	r4,r16,19049
811298f4:	81129ef8 	rdprs	r4,r16,19067
811298f8:	81129ef8 	rdprs	r4,r16,19067
811298fc:	811299b8 	rdprs	r4,r16,19046
81129900:	dac02317 	ldw	r11,140(sp)
81129904:	5ac00017 	ldw	r11,0(r11)
81129908:	dac02415 	stw	r11,144(sp)
8112990c:	dac02317 	ldw	r11,140(sp)
81129910:	58800104 	addi	r2,r11,4
81129914:	dac02417 	ldw	r11,144(sp)
81129918:	5802e90e 	bge	r11,zero,8112a4c0 <___svfiprintf_internal_r+0xe8c>
8112991c:	dac02417 	ldw	r11,144(sp)
81129920:	d8802315 	stw	r2,140(sp)
81129924:	02d7c83a 	sub	r11,zero,r11
81129928:	dac02415 	stw	r11,144(sp)
8112992c:	94800114 	ori	r18,r18,4
81129930:	98c00007 	ldb	r3,0(r19)
81129934:	003f9006 	br	81129778 <__reset+0xfb109778>
81129938:	00800c04 	movi	r2,48
8112993c:	dac02317 	ldw	r11,140(sp)
81129940:	d8801d05 	stb	r2,116(sp)
81129944:	00801e04 	movi	r2,120
81129948:	d8801d45 	stb	r2,117(sp)
8112994c:	d8001d85 	stb	zero,118(sp)
81129950:	58c00104 	addi	r3,r11,4
81129954:	5f000017 	ldw	fp,0(r11)
81129958:	0013883a 	mov	r9,zero
8112995c:	90800094 	ori	r2,r18,2
81129960:	80032b16 	blt	r16,zero,8112a610 <___svfiprintf_internal_r+0xfdc>
81129964:	00bfdfc4 	movi	r2,-129
81129968:	90a4703a 	and	r18,r18,r2
8112996c:	d8c02315 	stw	r3,140(sp)
81129970:	94800094 	ori	r18,r18,2
81129974:	e002dc26 	beq	fp,zero,8112a4e8 <___svfiprintf_internal_r+0xeb4>
81129978:	01204574 	movhi	r4,33045
8112997c:	2126b304 	addi	r4,r4,-25908
81129980:	0015883a 	mov	r10,zero
81129984:	d9002915 	stw	r4,164(sp)
81129988:	00002306 	br	81129a18 <___svfiprintf_internal_r+0x3e4>
8112998c:	94800054 	ori	r18,r18,1
81129990:	98c00007 	ldb	r3,0(r19)
81129994:	003f7806 	br	81129778 <__reset+0xfb109778>
81129998:	38803fcc 	andi	r2,r7,255
8112999c:	1080201c 	xori	r2,r2,128
811299a0:	10bfe004 	addi	r2,r2,-128
811299a4:	1002f31e 	bne	r2,zero,8112a574 <___svfiprintf_internal_r+0xf40>
811299a8:	01000044 	movi	r4,1
811299ac:	01c00804 	movi	r7,32
811299b0:	98c00007 	ldb	r3,0(r19)
811299b4:	003f7006 	br	81129778 <__reset+0xfb109778>
811299b8:	21003fcc 	andi	r4,r4,255
811299bc:	2003aa1e 	bne	r4,zero,8112a868 <___svfiprintf_internal_r+0x1234>
811299c0:	00a04574 	movhi	r2,33045
811299c4:	10a6b304 	addi	r2,r2,-25908
811299c8:	d8802915 	stw	r2,164(sp)
811299cc:	9080080c 	andi	r2,r18,32
811299d0:	1000ba26 	beq	r2,zero,81129cbc <___svfiprintf_internal_r+0x688>
811299d4:	dac02317 	ldw	r11,140(sp)
811299d8:	5f000017 	ldw	fp,0(r11)
811299dc:	5a400117 	ldw	r9,4(r11)
811299e0:	5ac00204 	addi	r11,r11,8
811299e4:	dac02315 	stw	r11,140(sp)
811299e8:	9080004c 	andi	r2,r18,1
811299ec:	10029026 	beq	r2,zero,8112a430 <___svfiprintf_internal_r+0xdfc>
811299f0:	e244b03a 	or	r2,fp,r9
811299f4:	1002d41e 	bne	r2,zero,8112a548 <___svfiprintf_internal_r+0xf14>
811299f8:	d8001d85 	stb	zero,118(sp)
811299fc:	80030b16 	blt	r16,zero,8112a62c <___svfiprintf_internal_r+0xff8>
81129a00:	00bfdfc4 	movi	r2,-129
81129a04:	90a4703a 	and	r18,r18,r2
81129a08:	0015883a 	mov	r10,zero
81129a0c:	80002426 	beq	r16,zero,81129aa0 <___svfiprintf_internal_r+0x46c>
81129a10:	0039883a 	mov	fp,zero
81129a14:	0013883a 	mov	r9,zero
81129a18:	d9002917 	ldw	r4,164(sp)
81129a1c:	dc401a04 	addi	r17,sp,104
81129a20:	e08003cc 	andi	r2,fp,15
81129a24:	4806973a 	slli	r3,r9,28
81129a28:	2085883a 	add	r2,r4,r2
81129a2c:	e038d13a 	srli	fp,fp,4
81129a30:	10800003 	ldbu	r2,0(r2)
81129a34:	4812d13a 	srli	r9,r9,4
81129a38:	8c7fffc4 	addi	r17,r17,-1
81129a3c:	1f38b03a 	or	fp,r3,fp
81129a40:	88800005 	stb	r2,0(r17)
81129a44:	e244b03a 	or	r2,fp,r9
81129a48:	103ff51e 	bne	r2,zero,81129a20 <__reset+0xfb109a20>
81129a4c:	dac01e17 	ldw	r11,120(sp)
81129a50:	5c57c83a 	sub	r11,r11,r17
81129a54:	dac02115 	stw	r11,132(sp)
81129a58:	00001406 	br	81129aac <___svfiprintf_internal_r+0x478>
81129a5c:	21003fcc 	andi	r4,r4,255
81129a60:	2003741e 	bne	r4,zero,8112a834 <___svfiprintf_internal_r+0x1200>
81129a64:	9080080c 	andi	r2,r18,32
81129a68:	10014526 	beq	r2,zero,81129f80 <___svfiprintf_internal_r+0x94c>
81129a6c:	dac02317 	ldw	r11,140(sp)
81129a70:	d8001d85 	stb	zero,118(sp)
81129a74:	58c00204 	addi	r3,r11,8
81129a78:	5f000017 	ldw	fp,0(r11)
81129a7c:	5a400117 	ldw	r9,4(r11)
81129a80:	8002d916 	blt	r16,zero,8112a5e8 <___svfiprintf_internal_r+0xfb4>
81129a84:	013fdfc4 	movi	r4,-129
81129a88:	e244b03a 	or	r2,fp,r9
81129a8c:	d8c02315 	stw	r3,140(sp)
81129a90:	9124703a 	and	r18,r18,r4
81129a94:	0015883a 	mov	r10,zero
81129a98:	1000b91e 	bne	r2,zero,81129d80 <___svfiprintf_internal_r+0x74c>
81129a9c:	8002e61e 	bne	r16,zero,8112a638 <___svfiprintf_internal_r+0x1004>
81129aa0:	0021883a 	mov	r16,zero
81129aa4:	d8002115 	stw	zero,132(sp)
81129aa8:	dc401a04 	addi	r17,sp,104
81129aac:	d8c02117 	ldw	r3,132(sp)
81129ab0:	dc002015 	stw	r16,128(sp)
81129ab4:	80c0010e 	bge	r16,r3,81129abc <___svfiprintf_internal_r+0x488>
81129ab8:	d8c02015 	stw	r3,128(sp)
81129abc:	52803fcc 	andi	r10,r10,255
81129ac0:	5280201c 	xori	r10,r10,128
81129ac4:	52bfe004 	addi	r10,r10,-128
81129ac8:	50003c26 	beq	r10,zero,81129bbc <___svfiprintf_internal_r+0x588>
81129acc:	dac02017 	ldw	r11,128(sp)
81129ad0:	5ac00044 	addi	r11,r11,1
81129ad4:	dac02015 	stw	r11,128(sp)
81129ad8:	00003806 	br	81129bbc <___svfiprintf_internal_r+0x588>
81129adc:	01000044 	movi	r4,1
81129ae0:	01c00ac4 	movi	r7,43
81129ae4:	98c00007 	ldb	r3,0(r19)
81129ae8:	003f2306 	br	81129778 <__reset+0xfb109778>
81129aec:	21003fcc 	andi	r4,r4,255
81129af0:	2003481e 	bne	r4,zero,8112a814 <___svfiprintf_internal_r+0x11e0>
81129af4:	9080080c 	andi	r2,r18,32
81129af8:	10013b26 	beq	r2,zero,81129fe8 <___svfiprintf_internal_r+0x9b4>
81129afc:	dac02317 	ldw	r11,140(sp)
81129b00:	d8001d85 	stb	zero,118(sp)
81129b04:	58800204 	addi	r2,r11,8
81129b08:	5f000017 	ldw	fp,0(r11)
81129b0c:	5a400117 	ldw	r9,4(r11)
81129b10:	8002a816 	blt	r16,zero,8112a5b4 <___svfiprintf_internal_r+0xf80>
81129b14:	013fdfc4 	movi	r4,-129
81129b18:	e246b03a 	or	r3,fp,r9
81129b1c:	d8802315 	stw	r2,140(sp)
81129b20:	9124703a 	and	r18,r18,r4
81129b24:	18013c26 	beq	r3,zero,8112a018 <___svfiprintf_internal_r+0x9e4>
81129b28:	0015883a 	mov	r10,zero
81129b2c:	dc401a04 	addi	r17,sp,104
81129b30:	e006d0fa 	srli	r3,fp,3
81129b34:	4808977a 	slli	r4,r9,29
81129b38:	4812d0fa 	srli	r9,r9,3
81129b3c:	e70001cc 	andi	fp,fp,7
81129b40:	e0800c04 	addi	r2,fp,48
81129b44:	8c7fffc4 	addi	r17,r17,-1
81129b48:	20f8b03a 	or	fp,r4,r3
81129b4c:	88800005 	stb	r2,0(r17)
81129b50:	e246b03a 	or	r3,fp,r9
81129b54:	183ff61e 	bne	r3,zero,81129b30 <__reset+0xfb109b30>
81129b58:	90c0004c 	andi	r3,r18,1
81129b5c:	1800a526 	beq	r3,zero,81129df4 <___svfiprintf_internal_r+0x7c0>
81129b60:	10803fcc 	andi	r2,r2,255
81129b64:	1080201c 	xori	r2,r2,128
81129b68:	10bfe004 	addi	r2,r2,-128
81129b6c:	00c00c04 	movi	r3,48
81129b70:	10ffb626 	beq	r2,r3,81129a4c <__reset+0xfb109a4c>
81129b74:	88ffffc5 	stb	r3,-1(r17)
81129b78:	d8c01e17 	ldw	r3,120(sp)
81129b7c:	88bfffc4 	addi	r2,r17,-1
81129b80:	1023883a 	mov	r17,r2
81129b84:	1887c83a 	sub	r3,r3,r2
81129b88:	d8c02115 	stw	r3,132(sp)
81129b8c:	003fc706 	br	81129aac <__reset+0xfb109aac>
81129b90:	dac02317 	ldw	r11,140(sp)
81129b94:	00c00044 	movi	r3,1
81129b98:	d8c02015 	stw	r3,128(sp)
81129b9c:	58800017 	ldw	r2,0(r11)
81129ba0:	5ac00104 	addi	r11,r11,4
81129ba4:	d8001d85 	stb	zero,118(sp)
81129ba8:	d8801005 	stb	r2,64(sp)
81129bac:	dac02315 	stw	r11,140(sp)
81129bb0:	d8c02115 	stw	r3,132(sp)
81129bb4:	dc401004 	addi	r17,sp,64
81129bb8:	0021883a 	mov	r16,zero
81129bbc:	90c0008c 	andi	r3,r18,2
81129bc0:	d8c02215 	stw	r3,136(sp)
81129bc4:	18000326 	beq	r3,zero,81129bd4 <___svfiprintf_internal_r+0x5a0>
81129bc8:	dac02017 	ldw	r11,128(sp)
81129bcc:	5ac00084 	addi	r11,r11,2
81129bd0:	dac02015 	stw	r11,128(sp)
81129bd4:	90c0210c 	andi	r3,r18,132
81129bd8:	d8c02615 	stw	r3,152(sp)
81129bdc:	1801131e 	bne	r3,zero,8112a02c <___svfiprintf_internal_r+0x9f8>
81129be0:	dac02417 	ldw	r11,144(sp)
81129be4:	d8c02017 	ldw	r3,128(sp)
81129be8:	58f9c83a 	sub	fp,r11,r3
81129bec:	07010f0e 	bge	zero,fp,8112a02c <___svfiprintf_internal_r+0x9f8>
81129bf0:	02400404 	movi	r9,16
81129bf4:	d8c01c17 	ldw	r3,112(sp)
81129bf8:	d8801b17 	ldw	r2,108(sp)
81129bfc:	4f02d60e 	bge	r9,fp,8112a758 <___svfiprintf_internal_r+0x1124>
81129c00:	01604574 	movhi	r5,33045
81129c04:	29674104 	addi	r5,r5,-25340
81129c08:	d9402815 	stw	r5,160(sp)
81129c0c:	028001c4 	movi	r10,7
81129c10:	00000306 	br	81129c20 <___svfiprintf_internal_r+0x5ec>
81129c14:	e73ffc04 	addi	fp,fp,-16
81129c18:	42000204 	addi	r8,r8,8
81129c1c:	4f00150e 	bge	r9,fp,81129c74 <___svfiprintf_internal_r+0x640>
81129c20:	18c00404 	addi	r3,r3,16
81129c24:	10800044 	addi	r2,r2,1
81129c28:	45800015 	stw	r22,0(r8)
81129c2c:	42400115 	stw	r9,4(r8)
81129c30:	d8c01c15 	stw	r3,112(sp)
81129c34:	d8801b15 	stw	r2,108(sp)
81129c38:	50bff60e 	bge	r10,r2,81129c14 <__reset+0xfb109c14>
81129c3c:	d9801a04 	addi	r6,sp,104
81129c40:	b80b883a 	mov	r5,r23
81129c44:	a809883a 	mov	r4,r21
81129c48:	da402c15 	stw	r9,176(sp)
81129c4c:	da802d15 	stw	r10,180(sp)
81129c50:	112945c0 	call	8112945c <__ssprint_r>
81129c54:	da402c17 	ldw	r9,176(sp)
81129c58:	da802d17 	ldw	r10,180(sp)
81129c5c:	1001851e 	bne	r2,zero,8112a274 <___svfiprintf_internal_r+0xc40>
81129c60:	e73ffc04 	addi	fp,fp,-16
81129c64:	d8c01c17 	ldw	r3,112(sp)
81129c68:	d8801b17 	ldw	r2,108(sp)
81129c6c:	d811883a 	mov	r8,sp
81129c70:	4f3feb16 	blt	r9,fp,81129c20 <__reset+0xfb109c20>
81129c74:	dac02817 	ldw	r11,160(sp)
81129c78:	e0c7883a 	add	r3,fp,r3
81129c7c:	10800044 	addi	r2,r2,1
81129c80:	42c00015 	stw	r11,0(r8)
81129c84:	47000115 	stw	fp,4(r8)
81129c88:	d8c01c15 	stw	r3,112(sp)
81129c8c:	d8801b15 	stw	r2,108(sp)
81129c90:	010001c4 	movi	r4,7
81129c94:	2081ee16 	blt	r4,r2,8112a450 <___svfiprintf_internal_r+0xe1c>
81129c98:	42000204 	addi	r8,r8,8
81129c9c:	0000e506 	br	8112a034 <___svfiprintf_internal_r+0xa00>
81129ca0:	21003fcc 	andi	r4,r4,255
81129ca4:	2002dd1e 	bne	r4,zero,8112a81c <___svfiprintf_internal_r+0x11e8>
81129ca8:	00a04574 	movhi	r2,33045
81129cac:	10a6ae04 	addi	r2,r2,-25928
81129cb0:	d8802915 	stw	r2,164(sp)
81129cb4:	9080080c 	andi	r2,r18,32
81129cb8:	103f461e 	bne	r2,zero,811299d4 <__reset+0xfb1099d4>
81129cbc:	9080040c 	andi	r2,r18,16
81129cc0:	10022e1e 	bne	r2,zero,8112a57c <___svfiprintf_internal_r+0xf48>
81129cc4:	9080100c 	andi	r2,r18,64
81129cc8:	dac02317 	ldw	r11,140(sp)
81129ccc:	10027326 	beq	r2,zero,8112a69c <___svfiprintf_internal_r+0x1068>
81129cd0:	5f00000b 	ldhu	fp,0(r11)
81129cd4:	5ac00104 	addi	r11,r11,4
81129cd8:	0013883a 	mov	r9,zero
81129cdc:	dac02315 	stw	r11,140(sp)
81129ce0:	003f4106 	br	811299e8 <__reset+0xfb1099e8>
81129ce4:	21003fcc 	andi	r4,r4,255
81129ce8:	2002e11e 	bne	r4,zero,8112a870 <___svfiprintf_internal_r+0x123c>
81129cec:	9080080c 	andi	r2,r18,32
81129cf0:	1002011e 	bne	r2,zero,8112a4f8 <___svfiprintf_internal_r+0xec4>
81129cf4:	9080040c 	andi	r2,r18,16
81129cf8:	10023e1e 	bne	r2,zero,8112a5f4 <___svfiprintf_internal_r+0xfc0>
81129cfc:	9480100c 	andi	r18,r18,64
81129d00:	90023c26 	beq	r18,zero,8112a5f4 <___svfiprintf_internal_r+0xfc0>
81129d04:	dac02317 	ldw	r11,140(sp)
81129d08:	58800017 	ldw	r2,0(r11)
81129d0c:	5ac00104 	addi	r11,r11,4
81129d10:	dac02315 	stw	r11,140(sp)
81129d14:	dac02517 	ldw	r11,148(sp)
81129d18:	12c0000d 	sth	r11,0(r2)
81129d1c:	003e6e06 	br	811296d8 <__reset+0xfb1096d8>
81129d20:	98c00007 	ldb	r3,0(r19)
81129d24:	1a422926 	beq	r3,r9,8112a5cc <___svfiprintf_internal_r+0xf98>
81129d28:	94800414 	ori	r18,r18,16
81129d2c:	003e9206 	br	81129778 <__reset+0xfb109778>
81129d30:	94801014 	ori	r18,r18,64
81129d34:	98c00007 	ldb	r3,0(r19)
81129d38:	003e8f06 	br	81129778 <__reset+0xfb109778>
81129d3c:	21003fcc 	andi	r4,r4,255
81129d40:	2002c71e 	bne	r4,zero,8112a860 <___svfiprintf_internal_r+0x122c>
81129d44:	9080080c 	andi	r2,r18,32
81129d48:	10004926 	beq	r2,zero,81129e70 <___svfiprintf_internal_r+0x83c>
81129d4c:	dac02317 	ldw	r11,140(sp)
81129d50:	58800117 	ldw	r2,4(r11)
81129d54:	5f000017 	ldw	fp,0(r11)
81129d58:	5ac00204 	addi	r11,r11,8
81129d5c:	dac02315 	stw	r11,140(sp)
81129d60:	1013883a 	mov	r9,r2
81129d64:	10004b16 	blt	r2,zero,81129e94 <___svfiprintf_internal_r+0x860>
81129d68:	da801d83 	ldbu	r10,118(sp)
81129d6c:	8001cb16 	blt	r16,zero,8112a49c <___svfiprintf_internal_r+0xe68>
81129d70:	00ffdfc4 	movi	r3,-129
81129d74:	e244b03a 	or	r2,fp,r9
81129d78:	90e4703a 	and	r18,r18,r3
81129d7c:	103f4726 	beq	r2,zero,81129a9c <__reset+0xfb109a9c>
81129d80:	48008c26 	beq	r9,zero,81129fb4 <___svfiprintf_internal_r+0x980>
81129d84:	dc802015 	stw	r18,128(sp)
81129d88:	dc002115 	stw	r16,132(sp)
81129d8c:	dc401a04 	addi	r17,sp,104
81129d90:	e021883a 	mov	r16,fp
81129d94:	da002215 	stw	r8,136(sp)
81129d98:	5039883a 	mov	fp,r10
81129d9c:	4825883a 	mov	r18,r9
81129da0:	8009883a 	mov	r4,r16
81129da4:	900b883a 	mov	r5,r18
81129da8:	01800284 	movi	r6,10
81129dac:	000f883a 	mov	r7,zero
81129db0:	112d9c00 	call	8112d9c0 <__umoddi3>
81129db4:	10800c04 	addi	r2,r2,48
81129db8:	8c7fffc4 	addi	r17,r17,-1
81129dbc:	8009883a 	mov	r4,r16
81129dc0:	900b883a 	mov	r5,r18
81129dc4:	88800005 	stb	r2,0(r17)
81129dc8:	01800284 	movi	r6,10
81129dcc:	000f883a 	mov	r7,zero
81129dd0:	112d4400 	call	8112d440 <__udivdi3>
81129dd4:	1021883a 	mov	r16,r2
81129dd8:	10c4b03a 	or	r2,r2,r3
81129ddc:	1825883a 	mov	r18,r3
81129de0:	103fef1e 	bne	r2,zero,81129da0 <__reset+0xfb109da0>
81129de4:	dc802017 	ldw	r18,128(sp)
81129de8:	dc002117 	ldw	r16,132(sp)
81129dec:	da002217 	ldw	r8,136(sp)
81129df0:	e015883a 	mov	r10,fp
81129df4:	d8c01e17 	ldw	r3,120(sp)
81129df8:	1c47c83a 	sub	r3,r3,r17
81129dfc:	d8c02115 	stw	r3,132(sp)
81129e00:	003f2a06 	br	81129aac <__reset+0xfb109aac>
81129e04:	dac02317 	ldw	r11,140(sp)
81129e08:	d8001d85 	stb	zero,118(sp)
81129e0c:	5c400017 	ldw	r17,0(r11)
81129e10:	5f000104 	addi	fp,r11,4
81129e14:	88022f26 	beq	r17,zero,8112a6d4 <___svfiprintf_internal_r+0x10a0>
81129e18:	80022516 	blt	r16,zero,8112a6b0 <___svfiprintf_internal_r+0x107c>
81129e1c:	800d883a 	mov	r6,r16
81129e20:	000b883a 	mov	r5,zero
81129e24:	8809883a 	mov	r4,r17
81129e28:	da002c15 	stw	r8,176(sp)
81129e2c:	1125a000 	call	81125a00 <memchr>
81129e30:	da002c17 	ldw	r8,176(sp)
81129e34:	10026426 	beq	r2,zero,8112a7c8 <___svfiprintf_internal_r+0x1194>
81129e38:	1445c83a 	sub	r2,r2,r17
81129e3c:	d8802115 	stw	r2,132(sp)
81129e40:	da801d83 	ldbu	r10,118(sp)
81129e44:	df002315 	stw	fp,140(sp)
81129e48:	0021883a 	mov	r16,zero
81129e4c:	003f1706 	br	81129aac <__reset+0xfb109aac>
81129e50:	94800814 	ori	r18,r18,32
81129e54:	98c00007 	ldb	r3,0(r19)
81129e58:	003e4706 	br	81129778 <__reset+0xfb109778>
81129e5c:	21003fcc 	andi	r4,r4,255
81129e60:	2002701e 	bne	r4,zero,8112a824 <___svfiprintf_internal_r+0x11f0>
81129e64:	94800414 	ori	r18,r18,16
81129e68:	9080080c 	andi	r2,r18,32
81129e6c:	103fb71e 	bne	r2,zero,81129d4c <__reset+0xfb109d4c>
81129e70:	9080040c 	andi	r2,r18,16
81129e74:	1001ab26 	beq	r2,zero,8112a524 <___svfiprintf_internal_r+0xef0>
81129e78:	dac02317 	ldw	r11,140(sp)
81129e7c:	5f000017 	ldw	fp,0(r11)
81129e80:	5ac00104 	addi	r11,r11,4
81129e84:	dac02315 	stw	r11,140(sp)
81129e88:	e013d7fa 	srai	r9,fp,31
81129e8c:	4805883a 	mov	r2,r9
81129e90:	103fb50e 	bge	r2,zero,81129d68 <__reset+0xfb109d68>
81129e94:	0739c83a 	sub	fp,zero,fp
81129e98:	02800b44 	movi	r10,45
81129e9c:	e004c03a 	cmpne	r2,fp,zero
81129ea0:	0253c83a 	sub	r9,zero,r9
81129ea4:	da801d85 	stb	r10,118(sp)
81129ea8:	4893c83a 	sub	r9,r9,r2
81129eac:	80023016 	blt	r16,zero,8112a770 <___svfiprintf_internal_r+0x113c>
81129eb0:	00bfdfc4 	movi	r2,-129
81129eb4:	90a4703a 	and	r18,r18,r2
81129eb8:	483fb21e 	bne	r9,zero,81129d84 <__reset+0xfb109d84>
81129ebc:	00003d06 	br	81129fb4 <___svfiprintf_internal_r+0x980>
81129ec0:	9817883a 	mov	r11,r19
81129ec4:	d8002415 	stw	zero,144(sp)
81129ec8:	18bff404 	addi	r2,r3,-48
81129ecc:	0019883a 	mov	r12,zero
81129ed0:	58c00007 	ldb	r3,0(r11)
81129ed4:	630002a4 	muli	r12,r12,10
81129ed8:	9cc00044 	addi	r19,r19,1
81129edc:	9817883a 	mov	r11,r19
81129ee0:	1319883a 	add	r12,r2,r12
81129ee4:	18bff404 	addi	r2,r3,-48
81129ee8:	30bff92e 	bgeu	r6,r2,81129ed0 <__reset+0xfb109ed0>
81129eec:	db002415 	stw	r12,144(sp)
81129ef0:	18bff804 	addi	r2,r3,-32
81129ef4:	28be232e 	bgeu	r5,r2,81129784 <__reset+0xfb109784>
81129ef8:	21003fcc 	andi	r4,r4,255
81129efc:	20024b1e 	bne	r4,zero,8112a82c <___svfiprintf_internal_r+0x11f8>
81129f00:	1800d626 	beq	r3,zero,8112a25c <___svfiprintf_internal_r+0xc28>
81129f04:	02c00044 	movi	r11,1
81129f08:	dac02015 	stw	r11,128(sp)
81129f0c:	d8c01005 	stb	r3,64(sp)
81129f10:	d8001d85 	stb	zero,118(sp)
81129f14:	dac02115 	stw	r11,132(sp)
81129f18:	dc401004 	addi	r17,sp,64
81129f1c:	003f2606 	br	81129bb8 <__reset+0xfb109bb8>
81129f20:	94802014 	ori	r18,r18,128
81129f24:	98c00007 	ldb	r3,0(r19)
81129f28:	003e1306 	br	81129778 <__reset+0xfb109778>
81129f2c:	98c00007 	ldb	r3,0(r19)
81129f30:	9ac00044 	addi	r11,r19,1
81129f34:	1a822b26 	beq	r3,r10,8112a7e4 <___svfiprintf_internal_r+0x11b0>
81129f38:	18bff404 	addi	r2,r3,-48
81129f3c:	0021883a 	mov	r16,zero
81129f40:	30821e36 	bltu	r6,r2,8112a7bc <___svfiprintf_internal_r+0x1188>
81129f44:	58c00007 	ldb	r3,0(r11)
81129f48:	840002a4 	muli	r16,r16,10
81129f4c:	5cc00044 	addi	r19,r11,1
81129f50:	9817883a 	mov	r11,r19
81129f54:	80a1883a 	add	r16,r16,r2
81129f58:	18bff404 	addi	r2,r3,-48
81129f5c:	30bff92e 	bgeu	r6,r2,81129f44 <__reset+0xfb109f44>
81129f60:	803e060e 	bge	r16,zero,8112977c <__reset+0xfb10977c>
81129f64:	043fffc4 	movi	r16,-1
81129f68:	003e0406 	br	8112977c <__reset+0xfb10977c>
81129f6c:	21003fcc 	andi	r4,r4,255
81129f70:	2002371e 	bne	r4,zero,8112a850 <___svfiprintf_internal_r+0x121c>
81129f74:	94800414 	ori	r18,r18,16
81129f78:	9080080c 	andi	r2,r18,32
81129f7c:	103ebb1e 	bne	r2,zero,81129a6c <__reset+0xfb109a6c>
81129f80:	9080040c 	andi	r2,r18,16
81129f84:	10013b26 	beq	r2,zero,8112a474 <___svfiprintf_internal_r+0xe40>
81129f88:	dac02317 	ldw	r11,140(sp)
81129f8c:	d8001d85 	stb	zero,118(sp)
81129f90:	0013883a 	mov	r9,zero
81129f94:	58800104 	addi	r2,r11,4
81129f98:	5f000017 	ldw	fp,0(r11)
81129f9c:	80013d16 	blt	r16,zero,8112a494 <___svfiprintf_internal_r+0xe60>
81129fa0:	00ffdfc4 	movi	r3,-129
81129fa4:	d8802315 	stw	r2,140(sp)
81129fa8:	90e4703a 	and	r18,r18,r3
81129fac:	0015883a 	mov	r10,zero
81129fb0:	e03eba26 	beq	fp,zero,81129a9c <__reset+0xfb109a9c>
81129fb4:	00800244 	movi	r2,9
81129fb8:	173f7236 	bltu	r2,fp,81129d84 <__reset+0xfb109d84>
81129fbc:	dac02b17 	ldw	r11,172(sp)
81129fc0:	e7000c04 	addi	fp,fp,48
81129fc4:	df0019c5 	stb	fp,103(sp)
81129fc8:	dac02115 	stw	r11,132(sp)
81129fcc:	dc4019c4 	addi	r17,sp,103
81129fd0:	003eb606 	br	81129aac <__reset+0xfb109aac>
81129fd4:	21003fcc 	andi	r4,r4,255
81129fd8:	20021f1e 	bne	r4,zero,8112a858 <___svfiprintf_internal_r+0x1224>
81129fdc:	94800414 	ori	r18,r18,16
81129fe0:	9080080c 	andi	r2,r18,32
81129fe4:	103ec51e 	bne	r2,zero,81129afc <__reset+0xfb109afc>
81129fe8:	9080040c 	andi	r2,r18,16
81129fec:	10016926 	beq	r2,zero,8112a594 <___svfiprintf_internal_r+0xf60>
81129ff0:	dac02317 	ldw	r11,140(sp)
81129ff4:	d8001d85 	stb	zero,118(sp)
81129ff8:	0013883a 	mov	r9,zero
81129ffc:	58800104 	addi	r2,r11,4
8112a000:	5f000017 	ldw	fp,0(r11)
8112a004:	80016b16 	blt	r16,zero,8112a5b4 <___svfiprintf_internal_r+0xf80>
8112a008:	00ffdfc4 	movi	r3,-129
8112a00c:	d8802315 	stw	r2,140(sp)
8112a010:	90e4703a 	and	r18,r18,r3
8112a014:	e03ec41e 	bne	fp,zero,81129b28 <__reset+0xfb109b28>
8112a018:	0015883a 	mov	r10,zero
8112a01c:	8001c226 	beq	r16,zero,8112a728 <___svfiprintf_internal_r+0x10f4>
8112a020:	0039883a 	mov	fp,zero
8112a024:	0013883a 	mov	r9,zero
8112a028:	003ec006 	br	81129b2c <__reset+0xfb109b2c>
8112a02c:	d8c01c17 	ldw	r3,112(sp)
8112a030:	d8801b17 	ldw	r2,108(sp)
8112a034:	d9001d87 	ldb	r4,118(sp)
8112a038:	20000b26 	beq	r4,zero,8112a068 <___svfiprintf_internal_r+0xa34>
8112a03c:	d9001d84 	addi	r4,sp,118
8112a040:	18c00044 	addi	r3,r3,1
8112a044:	10800044 	addi	r2,r2,1
8112a048:	41000015 	stw	r4,0(r8)
8112a04c:	01000044 	movi	r4,1
8112a050:	41000115 	stw	r4,4(r8)
8112a054:	d8c01c15 	stw	r3,112(sp)
8112a058:	d8801b15 	stw	r2,108(sp)
8112a05c:	010001c4 	movi	r4,7
8112a060:	2080e116 	blt	r4,r2,8112a3e8 <___svfiprintf_internal_r+0xdb4>
8112a064:	42000204 	addi	r8,r8,8
8112a068:	dac02217 	ldw	r11,136(sp)
8112a06c:	58000b26 	beq	r11,zero,8112a09c <___svfiprintf_internal_r+0xa68>
8112a070:	d9001d04 	addi	r4,sp,116
8112a074:	18c00084 	addi	r3,r3,2
8112a078:	10800044 	addi	r2,r2,1
8112a07c:	41000015 	stw	r4,0(r8)
8112a080:	01000084 	movi	r4,2
8112a084:	41000115 	stw	r4,4(r8)
8112a088:	d8c01c15 	stw	r3,112(sp)
8112a08c:	d8801b15 	stw	r2,108(sp)
8112a090:	010001c4 	movi	r4,7
8112a094:	2080dd16 	blt	r4,r2,8112a40c <___svfiprintf_internal_r+0xdd8>
8112a098:	42000204 	addi	r8,r8,8
8112a09c:	dac02617 	ldw	r11,152(sp)
8112a0a0:	01002004 	movi	r4,128
8112a0a4:	59008426 	beq	r11,r4,8112a2b8 <___svfiprintf_internal_r+0xc84>
8112a0a8:	dac02117 	ldw	r11,132(sp)
8112a0ac:	82e1c83a 	sub	r16,r16,r11
8112a0b0:	0400270e 	bge	zero,r16,8112a150 <___svfiprintf_internal_r+0xb1c>
8112a0b4:	01c00404 	movi	r7,16
8112a0b8:	3c016a0e 	bge	r7,r16,8112a664 <___svfiprintf_internal_r+0x1030>
8112a0bc:	01604574 	movhi	r5,33045
8112a0c0:	29673d04 	addi	r5,r5,-25356
8112a0c4:	d9402215 	stw	r5,136(sp)
8112a0c8:	070001c4 	movi	fp,7
8112a0cc:	00000306 	br	8112a0dc <___svfiprintf_internal_r+0xaa8>
8112a0d0:	843ffc04 	addi	r16,r16,-16
8112a0d4:	42000204 	addi	r8,r8,8
8112a0d8:	3c00130e 	bge	r7,r16,8112a128 <___svfiprintf_internal_r+0xaf4>
8112a0dc:	18c00404 	addi	r3,r3,16
8112a0e0:	10800044 	addi	r2,r2,1
8112a0e4:	45000015 	stw	r20,0(r8)
8112a0e8:	41c00115 	stw	r7,4(r8)
8112a0ec:	d8c01c15 	stw	r3,112(sp)
8112a0f0:	d8801b15 	stw	r2,108(sp)
8112a0f4:	e0bff60e 	bge	fp,r2,8112a0d0 <__reset+0xfb10a0d0>
8112a0f8:	d9801a04 	addi	r6,sp,104
8112a0fc:	b80b883a 	mov	r5,r23
8112a100:	a809883a 	mov	r4,r21
8112a104:	d9c02c15 	stw	r7,176(sp)
8112a108:	112945c0 	call	8112945c <__ssprint_r>
8112a10c:	d9c02c17 	ldw	r7,176(sp)
8112a110:	1000581e 	bne	r2,zero,8112a274 <___svfiprintf_internal_r+0xc40>
8112a114:	843ffc04 	addi	r16,r16,-16
8112a118:	d8c01c17 	ldw	r3,112(sp)
8112a11c:	d8801b17 	ldw	r2,108(sp)
8112a120:	d811883a 	mov	r8,sp
8112a124:	3c3fed16 	blt	r7,r16,8112a0dc <__reset+0xfb10a0dc>
8112a128:	dac02217 	ldw	r11,136(sp)
8112a12c:	1c07883a 	add	r3,r3,r16
8112a130:	10800044 	addi	r2,r2,1
8112a134:	42c00015 	stw	r11,0(r8)
8112a138:	44000115 	stw	r16,4(r8)
8112a13c:	d8c01c15 	stw	r3,112(sp)
8112a140:	d8801b15 	stw	r2,108(sp)
8112a144:	010001c4 	movi	r4,7
8112a148:	20809e16 	blt	r4,r2,8112a3c4 <___svfiprintf_internal_r+0xd90>
8112a14c:	42000204 	addi	r8,r8,8
8112a150:	dac02117 	ldw	r11,132(sp)
8112a154:	10800044 	addi	r2,r2,1
8112a158:	44400015 	stw	r17,0(r8)
8112a15c:	58c7883a 	add	r3,r11,r3
8112a160:	42c00115 	stw	r11,4(r8)
8112a164:	d8c01c15 	stw	r3,112(sp)
8112a168:	d8801b15 	stw	r2,108(sp)
8112a16c:	010001c4 	movi	r4,7
8112a170:	20807f16 	blt	r4,r2,8112a370 <___svfiprintf_internal_r+0xd3c>
8112a174:	42000204 	addi	r8,r8,8
8112a178:	9480010c 	andi	r18,r18,4
8112a17c:	90002926 	beq	r18,zero,8112a224 <___svfiprintf_internal_r+0xbf0>
8112a180:	dac02417 	ldw	r11,144(sp)
8112a184:	d8802017 	ldw	r2,128(sp)
8112a188:	58a1c83a 	sub	r16,r11,r2
8112a18c:	0400250e 	bge	zero,r16,8112a224 <___svfiprintf_internal_r+0xbf0>
8112a190:	04400404 	movi	r17,16
8112a194:	d8801b17 	ldw	r2,108(sp)
8112a198:	8c017c0e 	bge	r17,r16,8112a78c <___svfiprintf_internal_r+0x1158>
8112a19c:	01604574 	movhi	r5,33045
8112a1a0:	29674104 	addi	r5,r5,-25340
8112a1a4:	d9402815 	stw	r5,160(sp)
8112a1a8:	048001c4 	movi	r18,7
8112a1ac:	00000306 	br	8112a1bc <___svfiprintf_internal_r+0xb88>
8112a1b0:	843ffc04 	addi	r16,r16,-16
8112a1b4:	42000204 	addi	r8,r8,8
8112a1b8:	8c00110e 	bge	r17,r16,8112a200 <___svfiprintf_internal_r+0xbcc>
8112a1bc:	18c00404 	addi	r3,r3,16
8112a1c0:	10800044 	addi	r2,r2,1
8112a1c4:	45800015 	stw	r22,0(r8)
8112a1c8:	44400115 	stw	r17,4(r8)
8112a1cc:	d8c01c15 	stw	r3,112(sp)
8112a1d0:	d8801b15 	stw	r2,108(sp)
8112a1d4:	90bff60e 	bge	r18,r2,8112a1b0 <__reset+0xfb10a1b0>
8112a1d8:	d9801a04 	addi	r6,sp,104
8112a1dc:	b80b883a 	mov	r5,r23
8112a1e0:	a809883a 	mov	r4,r21
8112a1e4:	112945c0 	call	8112945c <__ssprint_r>
8112a1e8:	1000221e 	bne	r2,zero,8112a274 <___svfiprintf_internal_r+0xc40>
8112a1ec:	843ffc04 	addi	r16,r16,-16
8112a1f0:	d8c01c17 	ldw	r3,112(sp)
8112a1f4:	d8801b17 	ldw	r2,108(sp)
8112a1f8:	d811883a 	mov	r8,sp
8112a1fc:	8c3fef16 	blt	r17,r16,8112a1bc <__reset+0xfb10a1bc>
8112a200:	dac02817 	ldw	r11,160(sp)
8112a204:	1c07883a 	add	r3,r3,r16
8112a208:	10800044 	addi	r2,r2,1
8112a20c:	42c00015 	stw	r11,0(r8)
8112a210:	44000115 	stw	r16,4(r8)
8112a214:	d8c01c15 	stw	r3,112(sp)
8112a218:	d8801b15 	stw	r2,108(sp)
8112a21c:	010001c4 	movi	r4,7
8112a220:	2080aa16 	blt	r4,r2,8112a4cc <___svfiprintf_internal_r+0xe98>
8112a224:	d8802417 	ldw	r2,144(sp)
8112a228:	dac02017 	ldw	r11,128(sp)
8112a22c:	12c0010e 	bge	r2,r11,8112a234 <___svfiprintf_internal_r+0xc00>
8112a230:	5805883a 	mov	r2,r11
8112a234:	dac02517 	ldw	r11,148(sp)
8112a238:	5897883a 	add	r11,r11,r2
8112a23c:	dac02515 	stw	r11,148(sp)
8112a240:	1800531e 	bne	r3,zero,8112a390 <___svfiprintf_internal_r+0xd5c>
8112a244:	98800007 	ldb	r2,0(r19)
8112a248:	d8001b15 	stw	zero,108(sp)
8112a24c:	d811883a 	mov	r8,sp
8112a250:	103d231e 	bne	r2,zero,811296e0 <__reset+0xfb1096e0>
8112a254:	9823883a 	mov	r17,r19
8112a258:	003d3906 	br	81129740 <__reset+0xfb109740>
8112a25c:	d8801c17 	ldw	r2,112(sp)
8112a260:	10000426 	beq	r2,zero,8112a274 <___svfiprintf_internal_r+0xc40>
8112a264:	d9402717 	ldw	r5,156(sp)
8112a268:	d9002a17 	ldw	r4,168(sp)
8112a26c:	d9801a04 	addi	r6,sp,104
8112a270:	112945c0 	call	8112945c <__ssprint_r>
8112a274:	dac02717 	ldw	r11,156(sp)
8112a278:	d8802517 	ldw	r2,148(sp)
8112a27c:	58c0030b 	ldhu	r3,12(r11)
8112a280:	18c0100c 	andi	r3,r3,64
8112a284:	1801381e 	bne	r3,zero,8112a768 <___svfiprintf_internal_r+0x1134>
8112a288:	dfc03717 	ldw	ra,220(sp)
8112a28c:	df003617 	ldw	fp,216(sp)
8112a290:	ddc03517 	ldw	r23,212(sp)
8112a294:	dd803417 	ldw	r22,208(sp)
8112a298:	dd403317 	ldw	r21,204(sp)
8112a29c:	dd003217 	ldw	r20,200(sp)
8112a2a0:	dcc03117 	ldw	r19,196(sp)
8112a2a4:	dc803017 	ldw	r18,192(sp)
8112a2a8:	dc402f17 	ldw	r17,188(sp)
8112a2ac:	dc002e17 	ldw	r16,184(sp)
8112a2b0:	dec03804 	addi	sp,sp,224
8112a2b4:	f800283a 	ret
8112a2b8:	dac02417 	ldw	r11,144(sp)
8112a2bc:	d9002017 	ldw	r4,128(sp)
8112a2c0:	5939c83a 	sub	fp,r11,r4
8112a2c4:	073f780e 	bge	zero,fp,8112a0a8 <__reset+0xfb10a0a8>
8112a2c8:	02400404 	movi	r9,16
8112a2cc:	4f01370e 	bge	r9,fp,8112a7ac <___svfiprintf_internal_r+0x1178>
8112a2d0:	02e04574 	movhi	r11,33045
8112a2d4:	5ae73d04 	addi	r11,r11,-25356
8112a2d8:	dac02215 	stw	r11,136(sp)
8112a2dc:	028001c4 	movi	r10,7
8112a2e0:	00000306 	br	8112a2f0 <___svfiprintf_internal_r+0xcbc>
8112a2e4:	e73ffc04 	addi	fp,fp,-16
8112a2e8:	42000204 	addi	r8,r8,8
8112a2ec:	4f00150e 	bge	r9,fp,8112a344 <___svfiprintf_internal_r+0xd10>
8112a2f0:	18c00404 	addi	r3,r3,16
8112a2f4:	10800044 	addi	r2,r2,1
8112a2f8:	45000015 	stw	r20,0(r8)
8112a2fc:	42400115 	stw	r9,4(r8)
8112a300:	d8c01c15 	stw	r3,112(sp)
8112a304:	d8801b15 	stw	r2,108(sp)
8112a308:	50bff60e 	bge	r10,r2,8112a2e4 <__reset+0xfb10a2e4>
8112a30c:	d9801a04 	addi	r6,sp,104
8112a310:	b80b883a 	mov	r5,r23
8112a314:	a809883a 	mov	r4,r21
8112a318:	da402c15 	stw	r9,176(sp)
8112a31c:	da802d15 	stw	r10,180(sp)
8112a320:	112945c0 	call	8112945c <__ssprint_r>
8112a324:	da402c17 	ldw	r9,176(sp)
8112a328:	da802d17 	ldw	r10,180(sp)
8112a32c:	103fd11e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a330:	e73ffc04 	addi	fp,fp,-16
8112a334:	d8c01c17 	ldw	r3,112(sp)
8112a338:	d8801b17 	ldw	r2,108(sp)
8112a33c:	d811883a 	mov	r8,sp
8112a340:	4f3feb16 	blt	r9,fp,8112a2f0 <__reset+0xfb10a2f0>
8112a344:	dac02217 	ldw	r11,136(sp)
8112a348:	1f07883a 	add	r3,r3,fp
8112a34c:	10800044 	addi	r2,r2,1
8112a350:	42c00015 	stw	r11,0(r8)
8112a354:	47000115 	stw	fp,4(r8)
8112a358:	d8c01c15 	stw	r3,112(sp)
8112a35c:	d8801b15 	stw	r2,108(sp)
8112a360:	010001c4 	movi	r4,7
8112a364:	2080b616 	blt	r4,r2,8112a640 <___svfiprintf_internal_r+0x100c>
8112a368:	42000204 	addi	r8,r8,8
8112a36c:	003f4e06 	br	8112a0a8 <__reset+0xfb10a0a8>
8112a370:	d9801a04 	addi	r6,sp,104
8112a374:	b80b883a 	mov	r5,r23
8112a378:	a809883a 	mov	r4,r21
8112a37c:	112945c0 	call	8112945c <__ssprint_r>
8112a380:	103fbc1e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a384:	d8c01c17 	ldw	r3,112(sp)
8112a388:	d811883a 	mov	r8,sp
8112a38c:	003f7a06 	br	8112a178 <__reset+0xfb10a178>
8112a390:	d9801a04 	addi	r6,sp,104
8112a394:	b80b883a 	mov	r5,r23
8112a398:	a809883a 	mov	r4,r21
8112a39c:	112945c0 	call	8112945c <__ssprint_r>
8112a3a0:	103fa826 	beq	r2,zero,8112a244 <__reset+0xfb10a244>
8112a3a4:	003fb306 	br	8112a274 <__reset+0xfb10a274>
8112a3a8:	d9801a04 	addi	r6,sp,104
8112a3ac:	b80b883a 	mov	r5,r23
8112a3b0:	a809883a 	mov	r4,r21
8112a3b4:	112945c0 	call	8112945c <__ssprint_r>
8112a3b8:	103fae1e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a3bc:	d811883a 	mov	r8,sp
8112a3c0:	003cdc06 	br	81129734 <__reset+0xfb109734>
8112a3c4:	d9801a04 	addi	r6,sp,104
8112a3c8:	b80b883a 	mov	r5,r23
8112a3cc:	a809883a 	mov	r4,r21
8112a3d0:	112945c0 	call	8112945c <__ssprint_r>
8112a3d4:	103fa71e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a3d8:	d8c01c17 	ldw	r3,112(sp)
8112a3dc:	d8801b17 	ldw	r2,108(sp)
8112a3e0:	d811883a 	mov	r8,sp
8112a3e4:	003f5a06 	br	8112a150 <__reset+0xfb10a150>
8112a3e8:	d9801a04 	addi	r6,sp,104
8112a3ec:	b80b883a 	mov	r5,r23
8112a3f0:	a809883a 	mov	r4,r21
8112a3f4:	112945c0 	call	8112945c <__ssprint_r>
8112a3f8:	103f9e1e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a3fc:	d8c01c17 	ldw	r3,112(sp)
8112a400:	d8801b17 	ldw	r2,108(sp)
8112a404:	d811883a 	mov	r8,sp
8112a408:	003f1706 	br	8112a068 <__reset+0xfb10a068>
8112a40c:	d9801a04 	addi	r6,sp,104
8112a410:	b80b883a 	mov	r5,r23
8112a414:	a809883a 	mov	r4,r21
8112a418:	112945c0 	call	8112945c <__ssprint_r>
8112a41c:	103f951e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a420:	d8c01c17 	ldw	r3,112(sp)
8112a424:	d8801b17 	ldw	r2,108(sp)
8112a428:	d811883a 	mov	r8,sp
8112a42c:	003f1b06 	br	8112a09c <__reset+0xfb10a09c>
8112a430:	d8001d85 	stb	zero,118(sp)
8112a434:	80007b16 	blt	r16,zero,8112a624 <___svfiprintf_internal_r+0xff0>
8112a438:	00ffdfc4 	movi	r3,-129
8112a43c:	e244b03a 	or	r2,fp,r9
8112a440:	90e4703a 	and	r18,r18,r3
8112a444:	103d7026 	beq	r2,zero,81129a08 <__reset+0xfb109a08>
8112a448:	0015883a 	mov	r10,zero
8112a44c:	003d7206 	br	81129a18 <__reset+0xfb109a18>
8112a450:	d9801a04 	addi	r6,sp,104
8112a454:	b80b883a 	mov	r5,r23
8112a458:	a809883a 	mov	r4,r21
8112a45c:	112945c0 	call	8112945c <__ssprint_r>
8112a460:	103f841e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a464:	d8c01c17 	ldw	r3,112(sp)
8112a468:	d8801b17 	ldw	r2,108(sp)
8112a46c:	d811883a 	mov	r8,sp
8112a470:	003ef006 	br	8112a034 <__reset+0xfb10a034>
8112a474:	9080100c 	andi	r2,r18,64
8112a478:	d8001d85 	stb	zero,118(sp)
8112a47c:	dac02317 	ldw	r11,140(sp)
8112a480:	10008126 	beq	r2,zero,8112a688 <___svfiprintf_internal_r+0x1054>
8112a484:	58800104 	addi	r2,r11,4
8112a488:	5f00000b 	ldhu	fp,0(r11)
8112a48c:	0013883a 	mov	r9,zero
8112a490:	803ec30e 	bge	r16,zero,81129fa0 <__reset+0xfb109fa0>
8112a494:	d8802315 	stw	r2,140(sp)
8112a498:	0015883a 	mov	r10,zero
8112a49c:	e244b03a 	or	r2,fp,r9
8112a4a0:	103e371e 	bne	r2,zero,81129d80 <__reset+0xfb109d80>
8112a4a4:	00800044 	movi	r2,1
8112a4a8:	10803fcc 	andi	r2,r2,255
8112a4ac:	00c00044 	movi	r3,1
8112a4b0:	10c06126 	beq	r2,r3,8112a638 <___svfiprintf_internal_r+0x1004>
8112a4b4:	00c00084 	movi	r3,2
8112a4b8:	10fd5526 	beq	r2,r3,81129a10 <__reset+0xfb109a10>
8112a4bc:	003ed806 	br	8112a020 <__reset+0xfb10a020>
8112a4c0:	d8802315 	stw	r2,140(sp)
8112a4c4:	98c00007 	ldb	r3,0(r19)
8112a4c8:	003cab06 	br	81129778 <__reset+0xfb109778>
8112a4cc:	d9801a04 	addi	r6,sp,104
8112a4d0:	b80b883a 	mov	r5,r23
8112a4d4:	a809883a 	mov	r4,r21
8112a4d8:	112945c0 	call	8112945c <__ssprint_r>
8112a4dc:	103f651e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a4e0:	d8c01c17 	ldw	r3,112(sp)
8112a4e4:	003f4f06 	br	8112a224 <__reset+0xfb10a224>
8112a4e8:	00a04574 	movhi	r2,33045
8112a4ec:	10a6b304 	addi	r2,r2,-25908
8112a4f0:	d8802915 	stw	r2,164(sp)
8112a4f4:	003d4406 	br	81129a08 <__reset+0xfb109a08>
8112a4f8:	dac02317 	ldw	r11,140(sp)
8112a4fc:	58800017 	ldw	r2,0(r11)
8112a500:	dac02517 	ldw	r11,148(sp)
8112a504:	5807d7fa 	srai	r3,r11,31
8112a508:	dac02317 	ldw	r11,140(sp)
8112a50c:	10c00115 	stw	r3,4(r2)
8112a510:	5ac00104 	addi	r11,r11,4
8112a514:	dac02315 	stw	r11,140(sp)
8112a518:	dac02517 	ldw	r11,148(sp)
8112a51c:	12c00015 	stw	r11,0(r2)
8112a520:	003c6d06 	br	811296d8 <__reset+0xfb1096d8>
8112a524:	9080100c 	andi	r2,r18,64
8112a528:	dac02317 	ldw	r11,140(sp)
8112a52c:	103e5326 	beq	r2,zero,81129e7c <__reset+0xfb109e7c>
8112a530:	5f00000f 	ldh	fp,0(r11)
8112a534:	5ac00104 	addi	r11,r11,4
8112a538:	dac02315 	stw	r11,140(sp)
8112a53c:	e013d7fa 	srai	r9,fp,31
8112a540:	4805883a 	mov	r2,r9
8112a544:	003e0706 	br	81129d64 <__reset+0xfb109d64>
8112a548:	00800c04 	movi	r2,48
8112a54c:	d8801d05 	stb	r2,116(sp)
8112a550:	d8c01d45 	stb	r3,117(sp)
8112a554:	d8001d85 	stb	zero,118(sp)
8112a558:	90800094 	ori	r2,r18,2
8112a55c:	80008f16 	blt	r16,zero,8112a79c <___svfiprintf_internal_r+0x1168>
8112a560:	00bfdfc4 	movi	r2,-129
8112a564:	90a4703a 	and	r18,r18,r2
8112a568:	94800094 	ori	r18,r18,2
8112a56c:	0015883a 	mov	r10,zero
8112a570:	003d2906 	br	81129a18 <__reset+0xfb109a18>
8112a574:	98c00007 	ldb	r3,0(r19)
8112a578:	003c7f06 	br	81129778 <__reset+0xfb109778>
8112a57c:	dac02317 	ldw	r11,140(sp)
8112a580:	0013883a 	mov	r9,zero
8112a584:	5f000017 	ldw	fp,0(r11)
8112a588:	5ac00104 	addi	r11,r11,4
8112a58c:	dac02315 	stw	r11,140(sp)
8112a590:	003d1506 	br	811299e8 <__reset+0xfb1099e8>
8112a594:	9080100c 	andi	r2,r18,64
8112a598:	d8001d85 	stb	zero,118(sp)
8112a59c:	dac02317 	ldw	r11,140(sp)
8112a5a0:	10003426 	beq	r2,zero,8112a674 <___svfiprintf_internal_r+0x1040>
8112a5a4:	58800104 	addi	r2,r11,4
8112a5a8:	5f00000b 	ldhu	fp,0(r11)
8112a5ac:	0013883a 	mov	r9,zero
8112a5b0:	803e950e 	bge	r16,zero,8112a008 <__reset+0xfb10a008>
8112a5b4:	e246b03a 	or	r3,fp,r9
8112a5b8:	d8802315 	stw	r2,140(sp)
8112a5bc:	183d5a1e 	bne	r3,zero,81129b28 <__reset+0xfb109b28>
8112a5c0:	0015883a 	mov	r10,zero
8112a5c4:	0005883a 	mov	r2,zero
8112a5c8:	003fb706 	br	8112a4a8 <__reset+0xfb10a4a8>
8112a5cc:	98c00043 	ldbu	r3,1(r19)
8112a5d0:	94800814 	ori	r18,r18,32
8112a5d4:	9cc00044 	addi	r19,r19,1
8112a5d8:	18c03fcc 	andi	r3,r3,255
8112a5dc:	18c0201c 	xori	r3,r3,128
8112a5e0:	18ffe004 	addi	r3,r3,-128
8112a5e4:	003c6406 	br	81129778 <__reset+0xfb109778>
8112a5e8:	d8c02315 	stw	r3,140(sp)
8112a5ec:	0015883a 	mov	r10,zero
8112a5f0:	003faa06 	br	8112a49c <__reset+0xfb10a49c>
8112a5f4:	dac02317 	ldw	r11,140(sp)
8112a5f8:	58800017 	ldw	r2,0(r11)
8112a5fc:	5ac00104 	addi	r11,r11,4
8112a600:	dac02315 	stw	r11,140(sp)
8112a604:	dac02517 	ldw	r11,148(sp)
8112a608:	12c00015 	stw	r11,0(r2)
8112a60c:	003c3206 	br	811296d8 <__reset+0xfb1096d8>
8112a610:	01204574 	movhi	r4,33045
8112a614:	2126b304 	addi	r4,r4,-25908
8112a618:	d9002915 	stw	r4,164(sp)
8112a61c:	d8c02315 	stw	r3,140(sp)
8112a620:	1025883a 	mov	r18,r2
8112a624:	e244b03a 	or	r2,fp,r9
8112a628:	103f871e 	bne	r2,zero,8112a448 <__reset+0xfb10a448>
8112a62c:	0015883a 	mov	r10,zero
8112a630:	00800084 	movi	r2,2
8112a634:	003f9c06 	br	8112a4a8 <__reset+0xfb10a4a8>
8112a638:	0039883a 	mov	fp,zero
8112a63c:	003e5f06 	br	81129fbc <__reset+0xfb109fbc>
8112a640:	d9801a04 	addi	r6,sp,104
8112a644:	b80b883a 	mov	r5,r23
8112a648:	a809883a 	mov	r4,r21
8112a64c:	112945c0 	call	8112945c <__ssprint_r>
8112a650:	103f081e 	bne	r2,zero,8112a274 <__reset+0xfb10a274>
8112a654:	d8c01c17 	ldw	r3,112(sp)
8112a658:	d8801b17 	ldw	r2,108(sp)
8112a65c:	d811883a 	mov	r8,sp
8112a660:	003e9106 	br	8112a0a8 <__reset+0xfb10a0a8>
8112a664:	01204574 	movhi	r4,33045
8112a668:	21273d04 	addi	r4,r4,-25356
8112a66c:	d9002215 	stw	r4,136(sp)
8112a670:	003ead06 	br	8112a128 <__reset+0xfb10a128>
8112a674:	58800104 	addi	r2,r11,4
8112a678:	5f000017 	ldw	fp,0(r11)
8112a67c:	0013883a 	mov	r9,zero
8112a680:	803e610e 	bge	r16,zero,8112a008 <__reset+0xfb10a008>
8112a684:	003fcb06 	br	8112a5b4 <__reset+0xfb10a5b4>
8112a688:	58800104 	addi	r2,r11,4
8112a68c:	5f000017 	ldw	fp,0(r11)
8112a690:	0013883a 	mov	r9,zero
8112a694:	803e420e 	bge	r16,zero,81129fa0 <__reset+0xfb109fa0>
8112a698:	003f7e06 	br	8112a494 <__reset+0xfb10a494>
8112a69c:	5f000017 	ldw	fp,0(r11)
8112a6a0:	5ac00104 	addi	r11,r11,4
8112a6a4:	0013883a 	mov	r9,zero
8112a6a8:	dac02315 	stw	r11,140(sp)
8112a6ac:	003cce06 	br	811299e8 <__reset+0xfb1099e8>
8112a6b0:	8809883a 	mov	r4,r17
8112a6b4:	da002c15 	stw	r8,176(sp)
8112a6b8:	111c5040 	call	8111c504 <strlen>
8112a6bc:	d8802115 	stw	r2,132(sp)
8112a6c0:	da801d83 	ldbu	r10,118(sp)
8112a6c4:	df002315 	stw	fp,140(sp)
8112a6c8:	0021883a 	mov	r16,zero
8112a6cc:	da002c17 	ldw	r8,176(sp)
8112a6d0:	003cf606 	br	81129aac <__reset+0xfb109aac>
8112a6d4:	00800184 	movi	r2,6
8112a6d8:	1400012e 	bgeu	r2,r16,8112a6e0 <___svfiprintf_internal_r+0x10ac>
8112a6dc:	1021883a 	mov	r16,r2
8112a6e0:	dc002115 	stw	r16,132(sp)
8112a6e4:	8005883a 	mov	r2,r16
8112a6e8:	80003c16 	blt	r16,zero,8112a7dc <___svfiprintf_internal_r+0x11a8>
8112a6ec:	04604574 	movhi	r17,33045
8112a6f0:	d8802015 	stw	r2,128(sp)
8112a6f4:	df002315 	stw	fp,140(sp)
8112a6f8:	8c66b804 	addi	r17,r17,-25888
8112a6fc:	003d2e06 	br	81129bb8 <__reset+0xfb109bb8>
8112a700:	04001004 	movi	r16,64
8112a704:	800b883a 	mov	r5,r16
8112a708:	111b1fc0 	call	8111b1fc <_malloc_r>
8112a70c:	dac02717 	ldw	r11,156(sp)
8112a710:	58800015 	stw	r2,0(r11)
8112a714:	58800415 	stw	r2,16(r11)
8112a718:	10004826 	beq	r2,zero,8112a83c <___svfiprintf_internal_r+0x1208>
8112a71c:	dac02717 	ldw	r11,156(sp)
8112a720:	5c000515 	stw	r16,20(r11)
8112a724:	003bd906 	br	8112968c <__reset+0xfb10968c>
8112a728:	9080004c 	andi	r2,r18,1
8112a72c:	0015883a 	mov	r10,zero
8112a730:	10000626 	beq	r2,zero,8112a74c <___svfiprintf_internal_r+0x1118>
8112a734:	dac02b17 	ldw	r11,172(sp)
8112a738:	00800c04 	movi	r2,48
8112a73c:	d88019c5 	stb	r2,103(sp)
8112a740:	dac02115 	stw	r11,132(sp)
8112a744:	dc4019c4 	addi	r17,sp,103
8112a748:	003cd806 	br	81129aac <__reset+0xfb109aac>
8112a74c:	d8002115 	stw	zero,132(sp)
8112a750:	dc401a04 	addi	r17,sp,104
8112a754:	003cd506 	br	81129aac <__reset+0xfb109aac>
8112a758:	01204574 	movhi	r4,33045
8112a75c:	21274104 	addi	r4,r4,-25340
8112a760:	d9002815 	stw	r4,160(sp)
8112a764:	003d4306 	br	81129c74 <__reset+0xfb109c74>
8112a768:	00bfffc4 	movi	r2,-1
8112a76c:	003ec606 	br	8112a288 <__reset+0xfb10a288>
8112a770:	00800044 	movi	r2,1
8112a774:	10803fcc 	andi	r2,r2,255
8112a778:	00c00044 	movi	r3,1
8112a77c:	10fd8026 	beq	r2,r3,81129d80 <__reset+0xfb109d80>
8112a780:	00c00084 	movi	r3,2
8112a784:	10fca426 	beq	r2,r3,81129a18 <__reset+0xfb109a18>
8112a788:	003ce806 	br	81129b2c <__reset+0xfb109b2c>
8112a78c:	01204574 	movhi	r4,33045
8112a790:	21274104 	addi	r4,r4,-25340
8112a794:	d9002815 	stw	r4,160(sp)
8112a798:	003e9906 	br	8112a200 <__reset+0xfb10a200>
8112a79c:	1025883a 	mov	r18,r2
8112a7a0:	0015883a 	mov	r10,zero
8112a7a4:	00800084 	movi	r2,2
8112a7a8:	003ff206 	br	8112a774 <__reset+0xfb10a774>
8112a7ac:	01604574 	movhi	r5,33045
8112a7b0:	29673d04 	addi	r5,r5,-25356
8112a7b4:	d9402215 	stw	r5,136(sp)
8112a7b8:	003ee206 	br	8112a344 <__reset+0xfb10a344>
8112a7bc:	5827883a 	mov	r19,r11
8112a7c0:	0021883a 	mov	r16,zero
8112a7c4:	003bed06 	br	8112977c <__reset+0xfb10977c>
8112a7c8:	dc002115 	stw	r16,132(sp)
8112a7cc:	da801d83 	ldbu	r10,118(sp)
8112a7d0:	df002315 	stw	fp,140(sp)
8112a7d4:	0021883a 	mov	r16,zero
8112a7d8:	003cb406 	br	81129aac <__reset+0xfb109aac>
8112a7dc:	0005883a 	mov	r2,zero
8112a7e0:	003fc206 	br	8112a6ec <__reset+0xfb10a6ec>
8112a7e4:	d8802317 	ldw	r2,140(sp)
8112a7e8:	98c00043 	ldbu	r3,1(r19)
8112a7ec:	5827883a 	mov	r19,r11
8112a7f0:	14000017 	ldw	r16,0(r2)
8112a7f4:	10800104 	addi	r2,r2,4
8112a7f8:	d8802315 	stw	r2,140(sp)
8112a7fc:	803f760e 	bge	r16,zero,8112a5d8 <__reset+0xfb10a5d8>
8112a800:	18c03fcc 	andi	r3,r3,255
8112a804:	18c0201c 	xori	r3,r3,128
8112a808:	043fffc4 	movi	r16,-1
8112a80c:	18ffe004 	addi	r3,r3,-128
8112a810:	003bd906 	br	81129778 <__reset+0xfb109778>
8112a814:	d9c01d85 	stb	r7,118(sp)
8112a818:	003cb606 	br	81129af4 <__reset+0xfb109af4>
8112a81c:	d9c01d85 	stb	r7,118(sp)
8112a820:	003d2106 	br	81129ca8 <__reset+0xfb109ca8>
8112a824:	d9c01d85 	stb	r7,118(sp)
8112a828:	003d8e06 	br	81129e64 <__reset+0xfb109e64>
8112a82c:	d9c01d85 	stb	r7,118(sp)
8112a830:	003db306 	br	81129f00 <__reset+0xfb109f00>
8112a834:	d9c01d85 	stb	r7,118(sp)
8112a838:	003c8a06 	br	81129a64 <__reset+0xfb109a64>
8112a83c:	dac02a17 	ldw	r11,168(sp)
8112a840:	00800304 	movi	r2,12
8112a844:	58800015 	stw	r2,0(r11)
8112a848:	00bfffc4 	movi	r2,-1
8112a84c:	003e8e06 	br	8112a288 <__reset+0xfb10a288>
8112a850:	d9c01d85 	stb	r7,118(sp)
8112a854:	003dc706 	br	81129f74 <__reset+0xfb109f74>
8112a858:	d9c01d85 	stb	r7,118(sp)
8112a85c:	003ddf06 	br	81129fdc <__reset+0xfb109fdc>
8112a860:	d9c01d85 	stb	r7,118(sp)
8112a864:	003d3706 	br	81129d44 <__reset+0xfb109d44>
8112a868:	d9c01d85 	stb	r7,118(sp)
8112a86c:	003c5406 	br	811299c0 <__reset+0xfb1099c0>
8112a870:	d9c01d85 	stb	r7,118(sp)
8112a874:	003d1d06 	br	81129cec <__reset+0xfb109cec>

8112a878 <__submore>:
8112a878:	defffa04 	addi	sp,sp,-24
8112a87c:	de00012e 	bgeu	sp,et,8112a884 <__submore+0xc>
8112a880:	003b68fa 	trap	3
8112a884:	dc000015 	stw	r16,0(sp)
8112a888:	2821883a 	mov	r16,r5
8112a88c:	29400c17 	ldw	r5,48(r5)
8112a890:	dfc00515 	stw	ra,20(sp)
8112a894:	dd000415 	stw	r20,16(sp)
8112a898:	dcc00315 	stw	r19,12(sp)
8112a89c:	dc800215 	stw	r18,8(sp)
8112a8a0:	dc400115 	stw	r17,4(sp)
8112a8a4:	80801004 	addi	r2,r16,64
8112a8a8:	28801726 	beq	r5,r2,8112a908 <__submore+0x90>
8112a8ac:	84400d17 	ldw	r17,52(r16)
8112a8b0:	8c67883a 	add	r19,r17,r17
8112a8b4:	980d883a 	mov	r6,r19
8112a8b8:	1126d040 	call	81126d04 <_realloc_r>
8112a8bc:	1025883a 	mov	r18,r2
8112a8c0:	10002226 	beq	r2,zero,8112a94c <__submore+0xd4>
8112a8c4:	1469883a 	add	r20,r2,r17
8112a8c8:	880d883a 	mov	r6,r17
8112a8cc:	100b883a 	mov	r5,r2
8112a8d0:	a009883a 	mov	r4,r20
8112a8d4:	111ba100 	call	8111ba10 <memcpy>
8112a8d8:	0005883a 	mov	r2,zero
8112a8dc:	85000015 	stw	r20,0(r16)
8112a8e0:	84800c15 	stw	r18,48(r16)
8112a8e4:	84c00d15 	stw	r19,52(r16)
8112a8e8:	dfc00517 	ldw	ra,20(sp)
8112a8ec:	dd000417 	ldw	r20,16(sp)
8112a8f0:	dcc00317 	ldw	r19,12(sp)
8112a8f4:	dc800217 	ldw	r18,8(sp)
8112a8f8:	dc400117 	ldw	r17,4(sp)
8112a8fc:	dc000017 	ldw	r16,0(sp)
8112a900:	dec00604 	addi	sp,sp,24
8112a904:	f800283a 	ret
8112a908:	04410004 	movi	r17,1024
8112a90c:	880b883a 	mov	r5,r17
8112a910:	111b1fc0 	call	8111b1fc <_malloc_r>
8112a914:	1007883a 	mov	r3,r2
8112a918:	10000c26 	beq	r2,zero,8112a94c <__submore+0xd4>
8112a91c:	80801083 	ldbu	r2,66(r16)
8112a920:	80c00c15 	stw	r3,48(r16)
8112a924:	84400d15 	stw	r17,52(r16)
8112a928:	1880ffc5 	stb	r2,1023(r3)
8112a92c:	81401043 	ldbu	r5,65(r16)
8112a930:	1900ff44 	addi	r4,r3,1021
8112a934:	0005883a 	mov	r2,zero
8112a938:	1940ff85 	stb	r5,1022(r3)
8112a93c:	81401003 	ldbu	r5,64(r16)
8112a940:	1940ff45 	stb	r5,1021(r3)
8112a944:	81000015 	stw	r4,0(r16)
8112a948:	003fe706 	br	8112a8e8 <__reset+0xfb10a8e8>
8112a94c:	00bfffc4 	movi	r2,-1
8112a950:	003fe506 	br	8112a8e8 <__reset+0xfb10a8e8>

8112a954 <_ungetc_r>:
8112a954:	00bfffc4 	movi	r2,-1
8112a958:	28806326 	beq	r5,r2,8112aae8 <_ungetc_r+0x194>
8112a95c:	defffb04 	addi	sp,sp,-20
8112a960:	de00012e 	bgeu	sp,et,8112a968 <_ungetc_r+0x14>
8112a964:	003b68fa 	trap	3
8112a968:	dcc00315 	stw	r19,12(sp)
8112a96c:	dc400115 	stw	r17,4(sp)
8112a970:	dc000015 	stw	r16,0(sp)
8112a974:	dfc00415 	stw	ra,16(sp)
8112a978:	dc800215 	stw	r18,8(sp)
8112a97c:	2023883a 	mov	r17,r4
8112a980:	3021883a 	mov	r16,r6
8112a984:	2827883a 	mov	r19,r5
8112a988:	20000226 	beq	r4,zero,8112a994 <_ungetc_r+0x40>
8112a98c:	20800e17 	ldw	r2,56(r4)
8112a990:	10002e26 	beq	r2,zero,8112aa4c <_ungetc_r+0xf8>
8112a994:	80c0030b 	ldhu	r3,12(r16)
8112a998:	1888000c 	andi	r2,r3,8192
8112a99c:	1000051e 	bne	r2,zero,8112a9b4 <_ungetc_r+0x60>
8112a9a0:	81001917 	ldw	r4,100(r16)
8112a9a4:	00b7ffc4 	movi	r2,-8193
8112a9a8:	18c80014 	ori	r3,r3,8192
8112a9ac:	2084703a 	and	r2,r4,r2
8112a9b0:	80801915 	stw	r2,100(r16)
8112a9b4:	00bff7c4 	movi	r2,-33
8112a9b8:	1884703a 	and	r2,r3,r2
8112a9bc:	8080030d 	sth	r2,12(r16)
8112a9c0:	1900010c 	andi	r4,r3,4
8112a9c4:	2000061e 	bne	r4,zero,8112a9e0 <_ungetc_r+0x8c>
8112a9c8:	1900040c 	andi	r4,r3,16
8112a9cc:	20001d26 	beq	r4,zero,8112aa44 <_ungetc_r+0xf0>
8112a9d0:	18c0020c 	andi	r3,r3,8
8112a9d4:	1800331e 	bne	r3,zero,8112aaa4 <_ungetc_r+0x150>
8112a9d8:	10800114 	ori	r2,r2,4
8112a9dc:	8080030d 	sth	r2,12(r16)
8112a9e0:	80800c17 	ldw	r2,48(r16)
8112a9e4:	9c803fcc 	andi	r18,r19,255
8112a9e8:	10001a26 	beq	r2,zero,8112aa54 <_ungetc_r+0x100>
8112a9ec:	80c00117 	ldw	r3,4(r16)
8112a9f0:	80800d17 	ldw	r2,52(r16)
8112a9f4:	18800f0e 	bge	r3,r2,8112aa34 <_ungetc_r+0xe0>
8112a9f8:	80c00017 	ldw	r3,0(r16)
8112a9fc:	9005883a 	mov	r2,r18
8112aa00:	193fffc4 	addi	r4,r3,-1
8112aa04:	81000015 	stw	r4,0(r16)
8112aa08:	1cffffc5 	stb	r19,-1(r3)
8112aa0c:	80c00117 	ldw	r3,4(r16)
8112aa10:	18c00044 	addi	r3,r3,1
8112aa14:	80c00115 	stw	r3,4(r16)
8112aa18:	dfc00417 	ldw	ra,16(sp)
8112aa1c:	dcc00317 	ldw	r19,12(sp)
8112aa20:	dc800217 	ldw	r18,8(sp)
8112aa24:	dc400117 	ldw	r17,4(sp)
8112aa28:	dc000017 	ldw	r16,0(sp)
8112aa2c:	dec00504 	addi	sp,sp,20
8112aa30:	f800283a 	ret
8112aa34:	800b883a 	mov	r5,r16
8112aa38:	8809883a 	mov	r4,r17
8112aa3c:	112a8780 	call	8112a878 <__submore>
8112aa40:	103fed26 	beq	r2,zero,8112a9f8 <__reset+0xfb10a9f8>
8112aa44:	00bfffc4 	movi	r2,-1
8112aa48:	003ff306 	br	8112aa18 <__reset+0xfb10aa18>
8112aa4c:	11247d80 	call	811247d8 <__sinit>
8112aa50:	003fd006 	br	8112a994 <__reset+0xfb10a994>
8112aa54:	80c00417 	ldw	r3,16(r16)
8112aa58:	80800017 	ldw	r2,0(r16)
8112aa5c:	18000326 	beq	r3,zero,8112aa6c <_ungetc_r+0x118>
8112aa60:	1880022e 	bgeu	r3,r2,8112aa6c <_ungetc_r+0x118>
8112aa64:	10ffffc3 	ldbu	r3,-1(r2)
8112aa68:	90c01826 	beq	r18,r3,8112aacc <_ungetc_r+0x178>
8112aa6c:	81400117 	ldw	r5,4(r16)
8112aa70:	80800e15 	stw	r2,56(r16)
8112aa74:	008000c4 	movi	r2,3
8112aa78:	81001004 	addi	r4,r16,64
8112aa7c:	80c01084 	addi	r3,r16,66
8112aa80:	80800d15 	stw	r2,52(r16)
8112aa84:	00800044 	movi	r2,1
8112aa88:	80800115 	stw	r2,4(r16)
8112aa8c:	81400f15 	stw	r5,60(r16)
8112aa90:	81000c15 	stw	r4,48(r16)
8112aa94:	84c01085 	stb	r19,66(r16)
8112aa98:	80c00015 	stw	r3,0(r16)
8112aa9c:	9005883a 	mov	r2,r18
8112aaa0:	003fdd06 	br	8112aa18 <__reset+0xfb10aa18>
8112aaa4:	800b883a 	mov	r5,r16
8112aaa8:	8809883a 	mov	r4,r17
8112aaac:	11243dc0 	call	811243dc <_fflush_r>
8112aab0:	103fe41e 	bne	r2,zero,8112aa44 <__reset+0xfb10aa44>
8112aab4:	8080030b 	ldhu	r2,12(r16)
8112aab8:	00fffdc4 	movi	r3,-9
8112aabc:	80000215 	stw	zero,8(r16)
8112aac0:	1884703a 	and	r2,r3,r2
8112aac4:	80000615 	stw	zero,24(r16)
8112aac8:	003fc306 	br	8112a9d8 <__reset+0xfb10a9d8>
8112aacc:	80c00117 	ldw	r3,4(r16)
8112aad0:	10bfffc4 	addi	r2,r2,-1
8112aad4:	80800015 	stw	r2,0(r16)
8112aad8:	18800044 	addi	r2,r3,1
8112aadc:	80800115 	stw	r2,4(r16)
8112aae0:	9005883a 	mov	r2,r18
8112aae4:	003fcc06 	br	8112aa18 <__reset+0xfb10aa18>
8112aae8:	00bfffc4 	movi	r2,-1
8112aaec:	f800283a 	ret

8112aaf0 <ungetc>:
8112aaf0:	00a04574 	movhi	r2,33045
8112aaf4:	10b08204 	addi	r2,r2,-15864
8112aaf8:	280d883a 	mov	r6,r5
8112aafc:	200b883a 	mov	r5,r4
8112ab00:	11000017 	ldw	r4,0(r2)
8112ab04:	112a9541 	jmpi	8112a954 <_ungetc_r>

8112ab08 <__sprint_r.part.0>:
8112ab08:	defff604 	addi	sp,sp,-40
8112ab0c:	de00012e 	bgeu	sp,et,8112ab14 <__sprint_r.part.0+0xc>
8112ab10:	003b68fa 	trap	3
8112ab14:	28801917 	ldw	r2,100(r5)
8112ab18:	dd400515 	stw	r21,20(sp)
8112ab1c:	dfc00915 	stw	ra,36(sp)
8112ab20:	df000815 	stw	fp,32(sp)
8112ab24:	ddc00715 	stw	r23,28(sp)
8112ab28:	dd800615 	stw	r22,24(sp)
8112ab2c:	dd000415 	stw	r20,16(sp)
8112ab30:	dcc00315 	stw	r19,12(sp)
8112ab34:	dc800215 	stw	r18,8(sp)
8112ab38:	dc400115 	stw	r17,4(sp)
8112ab3c:	dc000015 	stw	r16,0(sp)
8112ab40:	1088000c 	andi	r2,r2,8192
8112ab44:	302b883a 	mov	r21,r6
8112ab48:	10002e26 	beq	r2,zero,8112ac04 <__sprint_r.part.0+0xfc>
8112ab4c:	30800217 	ldw	r2,8(r6)
8112ab50:	35800017 	ldw	r22,0(r6)
8112ab54:	10002926 	beq	r2,zero,8112abfc <__sprint_r.part.0+0xf4>
8112ab58:	2827883a 	mov	r19,r5
8112ab5c:	2029883a 	mov	r20,r4
8112ab60:	b5c00104 	addi	r23,r22,4
8112ab64:	04bfffc4 	movi	r18,-1
8112ab68:	bc400017 	ldw	r17,0(r23)
8112ab6c:	b4000017 	ldw	r16,0(r22)
8112ab70:	0039883a 	mov	fp,zero
8112ab74:	8822d0ba 	srli	r17,r17,2
8112ab78:	8800031e 	bne	r17,zero,8112ab88 <__sprint_r.part.0+0x80>
8112ab7c:	00001806 	br	8112abe0 <__sprint_r.part.0+0xd8>
8112ab80:	84000104 	addi	r16,r16,4
8112ab84:	8f001526 	beq	r17,fp,8112abdc <__sprint_r.part.0+0xd4>
8112ab88:	81400017 	ldw	r5,0(r16)
8112ab8c:	980d883a 	mov	r6,r19
8112ab90:	a009883a 	mov	r4,r20
8112ab94:	112c4ac0 	call	8112c4ac <_fputwc_r>
8112ab98:	e7000044 	addi	fp,fp,1
8112ab9c:	14bff81e 	bne	r2,r18,8112ab80 <__reset+0xfb10ab80>
8112aba0:	9005883a 	mov	r2,r18
8112aba4:	a8000215 	stw	zero,8(r21)
8112aba8:	a8000115 	stw	zero,4(r21)
8112abac:	dfc00917 	ldw	ra,36(sp)
8112abb0:	df000817 	ldw	fp,32(sp)
8112abb4:	ddc00717 	ldw	r23,28(sp)
8112abb8:	dd800617 	ldw	r22,24(sp)
8112abbc:	dd400517 	ldw	r21,20(sp)
8112abc0:	dd000417 	ldw	r20,16(sp)
8112abc4:	dcc00317 	ldw	r19,12(sp)
8112abc8:	dc800217 	ldw	r18,8(sp)
8112abcc:	dc400117 	ldw	r17,4(sp)
8112abd0:	dc000017 	ldw	r16,0(sp)
8112abd4:	dec00a04 	addi	sp,sp,40
8112abd8:	f800283a 	ret
8112abdc:	a8800217 	ldw	r2,8(r21)
8112abe0:	8c63883a 	add	r17,r17,r17
8112abe4:	8c63883a 	add	r17,r17,r17
8112abe8:	1445c83a 	sub	r2,r2,r17
8112abec:	a8800215 	stw	r2,8(r21)
8112abf0:	b5800204 	addi	r22,r22,8
8112abf4:	bdc00204 	addi	r23,r23,8
8112abf8:	103fdb1e 	bne	r2,zero,8112ab68 <__reset+0xfb10ab68>
8112abfc:	0005883a 	mov	r2,zero
8112ac00:	003fe806 	br	8112aba4 <__reset+0xfb10aba4>
8112ac04:	1124f880 	call	81124f88 <__sfvwrite_r>
8112ac08:	003fe606 	br	8112aba4 <__reset+0xfb10aba4>

8112ac0c <__sprint_r>:
8112ac0c:	30c00217 	ldw	r3,8(r6)
8112ac10:	18000126 	beq	r3,zero,8112ac18 <__sprint_r+0xc>
8112ac14:	112ab081 	jmpi	8112ab08 <__sprint_r.part.0>
8112ac18:	30000115 	stw	zero,4(r6)
8112ac1c:	0005883a 	mov	r2,zero
8112ac20:	f800283a 	ret

8112ac24 <___vfiprintf_internal_r>:
8112ac24:	deffc904 	addi	sp,sp,-220
8112ac28:	de00012e 	bgeu	sp,et,8112ac30 <___vfiprintf_internal_r+0xc>
8112ac2c:	003b68fa 	trap	3
8112ac30:	df003515 	stw	fp,212(sp)
8112ac34:	dd003115 	stw	r20,196(sp)
8112ac38:	dfc03615 	stw	ra,216(sp)
8112ac3c:	ddc03415 	stw	r23,208(sp)
8112ac40:	dd803315 	stw	r22,204(sp)
8112ac44:	dd403215 	stw	r21,200(sp)
8112ac48:	dcc03015 	stw	r19,192(sp)
8112ac4c:	dc802f15 	stw	r18,188(sp)
8112ac50:	dc402e15 	stw	r17,184(sp)
8112ac54:	dc002d15 	stw	r16,180(sp)
8112ac58:	d9002015 	stw	r4,128(sp)
8112ac5c:	d9c02215 	stw	r7,136(sp)
8112ac60:	2829883a 	mov	r20,r5
8112ac64:	3039883a 	mov	fp,r6
8112ac68:	20000226 	beq	r4,zero,8112ac74 <___vfiprintf_internal_r+0x50>
8112ac6c:	20800e17 	ldw	r2,56(r4)
8112ac70:	1000cf26 	beq	r2,zero,8112afb0 <___vfiprintf_internal_r+0x38c>
8112ac74:	a080030b 	ldhu	r2,12(r20)
8112ac78:	10c8000c 	andi	r3,r2,8192
8112ac7c:	1800061e 	bne	r3,zero,8112ac98 <___vfiprintf_internal_r+0x74>
8112ac80:	a1001917 	ldw	r4,100(r20)
8112ac84:	00f7ffc4 	movi	r3,-8193
8112ac88:	10880014 	ori	r2,r2,8192
8112ac8c:	20c6703a 	and	r3,r4,r3
8112ac90:	a080030d 	sth	r2,12(r20)
8112ac94:	a0c01915 	stw	r3,100(r20)
8112ac98:	10c0020c 	andi	r3,r2,8
8112ac9c:	1800a926 	beq	r3,zero,8112af44 <___vfiprintf_internal_r+0x320>
8112aca0:	a0c00417 	ldw	r3,16(r20)
8112aca4:	1800a726 	beq	r3,zero,8112af44 <___vfiprintf_internal_r+0x320>
8112aca8:	1080068c 	andi	r2,r2,26
8112acac:	00c00284 	movi	r3,10
8112acb0:	10c0ac26 	beq	r2,r3,8112af64 <___vfiprintf_internal_r+0x340>
8112acb4:	da801a04 	addi	r10,sp,104
8112acb8:	da801e15 	stw	r10,120(sp)
8112acbc:	d8801e17 	ldw	r2,120(sp)
8112acc0:	da8019c4 	addi	r10,sp,103
8112acc4:	05a04574 	movhi	r22,33045
8112acc8:	05e04574 	movhi	r23,33045
8112accc:	da801f15 	stw	r10,124(sp)
8112acd0:	1295c83a 	sub	r10,r2,r10
8112acd4:	b5a74904 	addi	r22,r22,-25308
8112acd8:	bde74504 	addi	r23,r23,-25324
8112acdc:	dec01a15 	stw	sp,104(sp)
8112ace0:	d8001c15 	stw	zero,112(sp)
8112ace4:	d8001b15 	stw	zero,108(sp)
8112ace8:	d8002615 	stw	zero,152(sp)
8112acec:	d8002315 	stw	zero,140(sp)
8112acf0:	da802715 	stw	r10,156(sp)
8112acf4:	d811883a 	mov	r8,sp
8112acf8:	dd002115 	stw	r20,132(sp)
8112acfc:	e021883a 	mov	r16,fp
8112ad00:	80800007 	ldb	r2,0(r16)
8112ad04:	1003ea26 	beq	r2,zero,8112bcb0 <___vfiprintf_internal_r+0x108c>
8112ad08:	00c00944 	movi	r3,37
8112ad0c:	8025883a 	mov	r18,r16
8112ad10:	10c0021e 	bne	r2,r3,8112ad1c <___vfiprintf_internal_r+0xf8>
8112ad14:	00001606 	br	8112ad70 <___vfiprintf_internal_r+0x14c>
8112ad18:	10c00326 	beq	r2,r3,8112ad28 <___vfiprintf_internal_r+0x104>
8112ad1c:	94800044 	addi	r18,r18,1
8112ad20:	90800007 	ldb	r2,0(r18)
8112ad24:	103ffc1e 	bne	r2,zero,8112ad18 <__reset+0xfb10ad18>
8112ad28:	9423c83a 	sub	r17,r18,r16
8112ad2c:	88001026 	beq	r17,zero,8112ad70 <___vfiprintf_internal_r+0x14c>
8112ad30:	d8c01c17 	ldw	r3,112(sp)
8112ad34:	d8801b17 	ldw	r2,108(sp)
8112ad38:	44000015 	stw	r16,0(r8)
8112ad3c:	88c7883a 	add	r3,r17,r3
8112ad40:	10800044 	addi	r2,r2,1
8112ad44:	44400115 	stw	r17,4(r8)
8112ad48:	d8c01c15 	stw	r3,112(sp)
8112ad4c:	d8801b15 	stw	r2,108(sp)
8112ad50:	010001c4 	movi	r4,7
8112ad54:	2080760e 	bge	r4,r2,8112af30 <___vfiprintf_internal_r+0x30c>
8112ad58:	1803821e 	bne	r3,zero,8112bb64 <___vfiprintf_internal_r+0xf40>
8112ad5c:	da802317 	ldw	r10,140(sp)
8112ad60:	d8001b15 	stw	zero,108(sp)
8112ad64:	d811883a 	mov	r8,sp
8112ad68:	5455883a 	add	r10,r10,r17
8112ad6c:	da802315 	stw	r10,140(sp)
8112ad70:	90800007 	ldb	r2,0(r18)
8112ad74:	10044626 	beq	r2,zero,8112be90 <___vfiprintf_internal_r+0x126c>
8112ad78:	90c00047 	ldb	r3,1(r18)
8112ad7c:	94000044 	addi	r16,r18,1
8112ad80:	d8001d85 	stb	zero,118(sp)
8112ad84:	0009883a 	mov	r4,zero
8112ad88:	000f883a 	mov	r7,zero
8112ad8c:	027fffc4 	movi	r9,-1
8112ad90:	0023883a 	mov	r17,zero
8112ad94:	0029883a 	mov	r20,zero
8112ad98:	01401604 	movi	r5,88
8112ad9c:	01800244 	movi	r6,9
8112ada0:	03400a84 	movi	r13,42
8112ada4:	03001b04 	movi	r12,108
8112ada8:	84000044 	addi	r16,r16,1
8112adac:	18bff804 	addi	r2,r3,-32
8112adb0:	28827336 	bltu	r5,r2,8112b780 <___vfiprintf_internal_r+0xb5c>
8112adb4:	100490ba 	slli	r2,r2,2
8112adb8:	02a044f4 	movhi	r10,33043
8112adbc:	52ab7304 	addi	r10,r10,-21044
8112adc0:	1285883a 	add	r2,r2,r10
8112adc4:	10800017 	ldw	r2,0(r2)
8112adc8:	1000683a 	jmp	r2
8112adcc:	8112b4b4 	orhi	r4,r16,19154
8112add0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112add4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112add8:	8112b4d4 	ori	r4,r16,19155
8112addc:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ade0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ade4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ade8:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112adec:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112adf0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112adf4:	8112b6bc 	xorhi	r4,r16,19162
8112adf8:	8112b6d8 	cmpnei	r4,r16,19163
8112adfc:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae00:	8112afc0 	call	88112afc <__reset+0x20f2afc>
8112ae04:	8112b6e8 	cmpgeui	r4,r16,19163
8112ae08:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae0c:	8112b4e0 	cmpeqi	r4,r16,19155
8112ae10:	8112b4ec 	andhi	r4,r16,19155
8112ae14:	8112b4ec 	andhi	r4,r16,19155
8112ae18:	8112b4ec 	andhi	r4,r16,19155
8112ae1c:	8112b4ec 	andhi	r4,r16,19155
8112ae20:	8112b4ec 	andhi	r4,r16,19155
8112ae24:	8112b4ec 	andhi	r4,r16,19155
8112ae28:	8112b4ec 	andhi	r4,r16,19155
8112ae2c:	8112b4ec 	andhi	r4,r16,19155
8112ae30:	8112b4ec 	andhi	r4,r16,19155
8112ae34:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae38:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae3c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae40:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae44:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae48:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae4c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae50:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae54:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae58:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae5c:	8112b518 	cmpnei	r4,r16,19156
8112ae60:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae64:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae68:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae6c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae70:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae74:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae78:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae7c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae80:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae84:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae88:	8112b550 	cmplti	r4,r16,19157
8112ae8c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae90:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae94:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae98:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112ae9c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aea0:	8112b5a8 	cmpgeui	r4,r16,19158
8112aea4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aea8:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aeac:	8112b618 	cmpnei	r4,r16,19160
8112aeb0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aeb4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aeb8:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aebc:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aec0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aec4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aec8:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aecc:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aed0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aed4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aed8:	8112b3c4 	addi	r4,r16,19151
8112aedc:	8112b3f0 	cmpltui	r4,r16,19151
8112aee0:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aee4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aee8:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aeec:	8112b728 	cmpgeui	r4,r16,19164
8112aef0:	8112b3f0 	cmpltui	r4,r16,19151
8112aef4:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aef8:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112aefc:	8112b284 	addi	r4,r16,19146
8112af00:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112af04:	8112b294 	ori	r4,r16,19146
8112af08:	8112b2d0 	cmplti	r4,r16,19147
8112af0c:	8112afcc 	andi	r4,r16,19135
8112af10:	8112b278 	rdprs	r4,r16,19145
8112af14:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112af18:	8112b654 	ori	r4,r16,19161
8112af1c:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112af20:	8112b6ac 	andhi	r4,r16,19162
8112af24:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112af28:	8112b780 	call	88112b78 <__reset+0x20f2b78>
8112af2c:	8112b370 	cmpltui	r4,r16,19149
8112af30:	42000204 	addi	r8,r8,8
8112af34:	da802317 	ldw	r10,140(sp)
8112af38:	5455883a 	add	r10,r10,r17
8112af3c:	da802315 	stw	r10,140(sp)
8112af40:	003f8b06 	br	8112ad70 <__reset+0xfb10ad70>
8112af44:	d9002017 	ldw	r4,128(sp)
8112af48:	a00b883a 	mov	r5,r20
8112af4c:	11227680 	call	81122768 <__swsetup_r>
8112af50:	1003b11e 	bne	r2,zero,8112be18 <___vfiprintf_internal_r+0x11f4>
8112af54:	a080030b 	ldhu	r2,12(r20)
8112af58:	00c00284 	movi	r3,10
8112af5c:	1080068c 	andi	r2,r2,26
8112af60:	10ff541e 	bne	r2,r3,8112acb4 <__reset+0xfb10acb4>
8112af64:	a080038f 	ldh	r2,14(r20)
8112af68:	103f5216 	blt	r2,zero,8112acb4 <__reset+0xfb10acb4>
8112af6c:	d9c02217 	ldw	r7,136(sp)
8112af70:	d9002017 	ldw	r4,128(sp)
8112af74:	e00d883a 	mov	r6,fp
8112af78:	a00b883a 	mov	r5,r20
8112af7c:	112c0a40 	call	8112c0a4 <__sbprintf>
8112af80:	dfc03617 	ldw	ra,216(sp)
8112af84:	df003517 	ldw	fp,212(sp)
8112af88:	ddc03417 	ldw	r23,208(sp)
8112af8c:	dd803317 	ldw	r22,204(sp)
8112af90:	dd403217 	ldw	r21,200(sp)
8112af94:	dd003117 	ldw	r20,196(sp)
8112af98:	dcc03017 	ldw	r19,192(sp)
8112af9c:	dc802f17 	ldw	r18,188(sp)
8112afa0:	dc402e17 	ldw	r17,184(sp)
8112afa4:	dc002d17 	ldw	r16,180(sp)
8112afa8:	dec03704 	addi	sp,sp,220
8112afac:	f800283a 	ret
8112afb0:	11247d80 	call	811247d8 <__sinit>
8112afb4:	003f2f06 	br	8112ac74 <__reset+0xfb10ac74>
8112afb8:	0463c83a 	sub	r17,zero,r17
8112afbc:	d8802215 	stw	r2,136(sp)
8112afc0:	a5000114 	ori	r20,r20,4
8112afc4:	80c00007 	ldb	r3,0(r16)
8112afc8:	003f7706 	br	8112ada8 <__reset+0xfb10ada8>
8112afcc:	00800c04 	movi	r2,48
8112afd0:	da802217 	ldw	r10,136(sp)
8112afd4:	d8801d05 	stb	r2,116(sp)
8112afd8:	00801e04 	movi	r2,120
8112afdc:	d8801d45 	stb	r2,117(sp)
8112afe0:	d8001d85 	stb	zero,118(sp)
8112afe4:	50c00104 	addi	r3,r10,4
8112afe8:	54800017 	ldw	r18,0(r10)
8112afec:	0027883a 	mov	r19,zero
8112aff0:	a0800094 	ori	r2,r20,2
8112aff4:	48030b16 	blt	r9,zero,8112bc24 <___vfiprintf_internal_r+0x1000>
8112aff8:	00bfdfc4 	movi	r2,-129
8112affc:	a096703a 	and	r11,r20,r2
8112b000:	d8c02215 	stw	r3,136(sp)
8112b004:	5d000094 	ori	r20,r11,2
8112b008:	90032b1e 	bne	r18,zero,8112bcb8 <___vfiprintf_internal_r+0x1094>
8112b00c:	00a04574 	movhi	r2,33045
8112b010:	10a6b304 	addi	r2,r2,-25908
8112b014:	d8802615 	stw	r2,152(sp)
8112b018:	0039883a 	mov	fp,zero
8112b01c:	48017b1e 	bne	r9,zero,8112b60c <___vfiprintf_internal_r+0x9e8>
8112b020:	0013883a 	mov	r9,zero
8112b024:	0027883a 	mov	r19,zero
8112b028:	dd401a04 	addi	r21,sp,104
8112b02c:	4825883a 	mov	r18,r9
8112b030:	4cc0010e 	bge	r9,r19,8112b038 <___vfiprintf_internal_r+0x414>
8112b034:	9825883a 	mov	r18,r19
8112b038:	e7003fcc 	andi	fp,fp,255
8112b03c:	e700201c 	xori	fp,fp,128
8112b040:	e73fe004 	addi	fp,fp,-128
8112b044:	e0000126 	beq	fp,zero,8112b04c <___vfiprintf_internal_r+0x428>
8112b048:	94800044 	addi	r18,r18,1
8112b04c:	a380008c 	andi	r14,r20,2
8112b050:	70000126 	beq	r14,zero,8112b058 <___vfiprintf_internal_r+0x434>
8112b054:	94800084 	addi	r18,r18,2
8112b058:	a700210c 	andi	fp,r20,132
8112b05c:	e001df1e 	bne	fp,zero,8112b7dc <___vfiprintf_internal_r+0xbb8>
8112b060:	8c87c83a 	sub	r3,r17,r18
8112b064:	00c1dd0e 	bge	zero,r3,8112b7dc <___vfiprintf_internal_r+0xbb8>
8112b068:	01c00404 	movi	r7,16
8112b06c:	d8801c17 	ldw	r2,112(sp)
8112b070:	38c3ad0e 	bge	r7,r3,8112bf28 <___vfiprintf_internal_r+0x1304>
8112b074:	02a04574 	movhi	r10,33045
8112b078:	52a74904 	addi	r10,r10,-25308
8112b07c:	dc002915 	stw	r16,164(sp)
8112b080:	d9801b17 	ldw	r6,108(sp)
8112b084:	da802415 	stw	r10,144(sp)
8112b088:	03c001c4 	movi	r15,7
8112b08c:	da402515 	stw	r9,148(sp)
8112b090:	db802815 	stw	r14,160(sp)
8112b094:	1821883a 	mov	r16,r3
8112b098:	00000506 	br	8112b0b0 <___vfiprintf_internal_r+0x48c>
8112b09c:	31400084 	addi	r5,r6,2
8112b0a0:	42000204 	addi	r8,r8,8
8112b0a4:	200d883a 	mov	r6,r4
8112b0a8:	843ffc04 	addi	r16,r16,-16
8112b0ac:	3c000d0e 	bge	r7,r16,8112b0e4 <___vfiprintf_internal_r+0x4c0>
8112b0b0:	10800404 	addi	r2,r2,16
8112b0b4:	31000044 	addi	r4,r6,1
8112b0b8:	45800015 	stw	r22,0(r8)
8112b0bc:	41c00115 	stw	r7,4(r8)
8112b0c0:	d8801c15 	stw	r2,112(sp)
8112b0c4:	d9001b15 	stw	r4,108(sp)
8112b0c8:	793ff40e 	bge	r15,r4,8112b09c <__reset+0xfb10b09c>
8112b0cc:	1001b51e 	bne	r2,zero,8112b7a4 <___vfiprintf_internal_r+0xb80>
8112b0d0:	843ffc04 	addi	r16,r16,-16
8112b0d4:	000d883a 	mov	r6,zero
8112b0d8:	01400044 	movi	r5,1
8112b0dc:	d811883a 	mov	r8,sp
8112b0e0:	3c3ff316 	blt	r7,r16,8112b0b0 <__reset+0xfb10b0b0>
8112b0e4:	8007883a 	mov	r3,r16
8112b0e8:	da402517 	ldw	r9,148(sp)
8112b0ec:	db802817 	ldw	r14,160(sp)
8112b0f0:	dc002917 	ldw	r16,164(sp)
8112b0f4:	da802417 	ldw	r10,144(sp)
8112b0f8:	1885883a 	add	r2,r3,r2
8112b0fc:	40c00115 	stw	r3,4(r8)
8112b100:	42800015 	stw	r10,0(r8)
8112b104:	d8801c15 	stw	r2,112(sp)
8112b108:	d9401b15 	stw	r5,108(sp)
8112b10c:	00c001c4 	movi	r3,7
8112b110:	19426016 	blt	r3,r5,8112ba94 <___vfiprintf_internal_r+0xe70>
8112b114:	d8c01d87 	ldb	r3,118(sp)
8112b118:	42000204 	addi	r8,r8,8
8112b11c:	29000044 	addi	r4,r5,1
8112b120:	1801b31e 	bne	r3,zero,8112b7f0 <___vfiprintf_internal_r+0xbcc>
8112b124:	7001c026 	beq	r14,zero,8112b828 <___vfiprintf_internal_r+0xc04>
8112b128:	d8c01d04 	addi	r3,sp,116
8112b12c:	10800084 	addi	r2,r2,2
8112b130:	40c00015 	stw	r3,0(r8)
8112b134:	00c00084 	movi	r3,2
8112b138:	40c00115 	stw	r3,4(r8)
8112b13c:	d8801c15 	stw	r2,112(sp)
8112b140:	d9001b15 	stw	r4,108(sp)
8112b144:	00c001c4 	movi	r3,7
8112b148:	1902650e 	bge	r3,r4,8112bae0 <___vfiprintf_internal_r+0xebc>
8112b14c:	10029a1e 	bne	r2,zero,8112bbb8 <___vfiprintf_internal_r+0xf94>
8112b150:	00c02004 	movi	r3,128
8112b154:	01000044 	movi	r4,1
8112b158:	000b883a 	mov	r5,zero
8112b15c:	d811883a 	mov	r8,sp
8112b160:	e0c1b31e 	bne	fp,r3,8112b830 <___vfiprintf_internal_r+0xc0c>
8112b164:	8cb9c83a 	sub	fp,r17,r18
8112b168:	0701b10e 	bge	zero,fp,8112b830 <___vfiprintf_internal_r+0xc0c>
8112b16c:	01c00404 	movi	r7,16
8112b170:	3f03890e 	bge	r7,fp,8112bf98 <___vfiprintf_internal_r+0x1374>
8112b174:	00e04574 	movhi	r3,33045
8112b178:	18e74504 	addi	r3,r3,-25324
8112b17c:	d8c02415 	stw	r3,144(sp)
8112b180:	8007883a 	mov	r3,r16
8112b184:	034001c4 	movi	r13,7
8112b188:	e021883a 	mov	r16,fp
8112b18c:	da402515 	stw	r9,148(sp)
8112b190:	1839883a 	mov	fp,r3
8112b194:	00000506 	br	8112b1ac <___vfiprintf_internal_r+0x588>
8112b198:	29800084 	addi	r6,r5,2
8112b19c:	42000204 	addi	r8,r8,8
8112b1a0:	180b883a 	mov	r5,r3
8112b1a4:	843ffc04 	addi	r16,r16,-16
8112b1a8:	3c000d0e 	bge	r7,r16,8112b1e0 <___vfiprintf_internal_r+0x5bc>
8112b1ac:	10800404 	addi	r2,r2,16
8112b1b0:	28c00044 	addi	r3,r5,1
8112b1b4:	45c00015 	stw	r23,0(r8)
8112b1b8:	41c00115 	stw	r7,4(r8)
8112b1bc:	d8801c15 	stw	r2,112(sp)
8112b1c0:	d8c01b15 	stw	r3,108(sp)
8112b1c4:	68fff40e 	bge	r13,r3,8112b198 <__reset+0xfb10b198>
8112b1c8:	1002241e 	bne	r2,zero,8112ba5c <___vfiprintf_internal_r+0xe38>
8112b1cc:	843ffc04 	addi	r16,r16,-16
8112b1d0:	01800044 	movi	r6,1
8112b1d4:	000b883a 	mov	r5,zero
8112b1d8:	d811883a 	mov	r8,sp
8112b1dc:	3c3ff316 	blt	r7,r16,8112b1ac <__reset+0xfb10b1ac>
8112b1e0:	da402517 	ldw	r9,148(sp)
8112b1e4:	e007883a 	mov	r3,fp
8112b1e8:	8039883a 	mov	fp,r16
8112b1ec:	1821883a 	mov	r16,r3
8112b1f0:	d8c02417 	ldw	r3,144(sp)
8112b1f4:	1705883a 	add	r2,r2,fp
8112b1f8:	47000115 	stw	fp,4(r8)
8112b1fc:	40c00015 	stw	r3,0(r8)
8112b200:	d8801c15 	stw	r2,112(sp)
8112b204:	d9801b15 	stw	r6,108(sp)
8112b208:	00c001c4 	movi	r3,7
8112b20c:	19827616 	blt	r3,r6,8112bbe8 <___vfiprintf_internal_r+0xfc4>
8112b210:	4cf9c83a 	sub	fp,r9,r19
8112b214:	42000204 	addi	r8,r8,8
8112b218:	31000044 	addi	r4,r6,1
8112b21c:	300b883a 	mov	r5,r6
8112b220:	07018516 	blt	zero,fp,8112b838 <___vfiprintf_internal_r+0xc14>
8112b224:	9885883a 	add	r2,r19,r2
8112b228:	45400015 	stw	r21,0(r8)
8112b22c:	44c00115 	stw	r19,4(r8)
8112b230:	d8801c15 	stw	r2,112(sp)
8112b234:	d9001b15 	stw	r4,108(sp)
8112b238:	00c001c4 	movi	r3,7
8112b23c:	1901dd0e 	bge	r3,r4,8112b9b4 <___vfiprintf_internal_r+0xd90>
8112b240:	1002401e 	bne	r2,zero,8112bb44 <___vfiprintf_internal_r+0xf20>
8112b244:	d8001b15 	stw	zero,108(sp)
8112b248:	a2c0010c 	andi	r11,r20,4
8112b24c:	58000226 	beq	r11,zero,8112b258 <___vfiprintf_internal_r+0x634>
8112b250:	8ca7c83a 	sub	r19,r17,r18
8112b254:	04c2f216 	blt	zero,r19,8112be20 <___vfiprintf_internal_r+0x11fc>
8112b258:	8c80010e 	bge	r17,r18,8112b260 <___vfiprintf_internal_r+0x63c>
8112b25c:	9023883a 	mov	r17,r18
8112b260:	da802317 	ldw	r10,140(sp)
8112b264:	5455883a 	add	r10,r10,r17
8112b268:	da802315 	stw	r10,140(sp)
8112b26c:	d8001b15 	stw	zero,108(sp)
8112b270:	d811883a 	mov	r8,sp
8112b274:	003ea206 	br	8112ad00 <__reset+0xfb10ad00>
8112b278:	a5000814 	ori	r20,r20,32
8112b27c:	80c00007 	ldb	r3,0(r16)
8112b280:	003ec906 	br	8112ada8 <__reset+0xfb10ada8>
8112b284:	80c00007 	ldb	r3,0(r16)
8112b288:	1b030926 	beq	r3,r12,8112beb0 <___vfiprintf_internal_r+0x128c>
8112b28c:	a5000414 	ori	r20,r20,16
8112b290:	003ec506 	br	8112ada8 <__reset+0xfb10ada8>
8112b294:	21003fcc 	andi	r4,r4,255
8112b298:	20035e1e 	bne	r4,zero,8112c014 <___vfiprintf_internal_r+0x13f0>
8112b29c:	a080080c 	andi	r2,r20,32
8112b2a0:	1002a526 	beq	r2,zero,8112bd38 <___vfiprintf_internal_r+0x1114>
8112b2a4:	da802217 	ldw	r10,136(sp)
8112b2a8:	50800017 	ldw	r2,0(r10)
8112b2ac:	da802317 	ldw	r10,140(sp)
8112b2b0:	5007d7fa 	srai	r3,r10,31
8112b2b4:	da802217 	ldw	r10,136(sp)
8112b2b8:	10c00115 	stw	r3,4(r2)
8112b2bc:	52800104 	addi	r10,r10,4
8112b2c0:	da802215 	stw	r10,136(sp)
8112b2c4:	da802317 	ldw	r10,140(sp)
8112b2c8:	12800015 	stw	r10,0(r2)
8112b2cc:	003e8c06 	br	8112ad00 <__reset+0xfb10ad00>
8112b2d0:	21003fcc 	andi	r4,r4,255
8112b2d4:	2003511e 	bne	r4,zero,8112c01c <___vfiprintf_internal_r+0x13f8>
8112b2d8:	a080080c 	andi	r2,r20,32
8112b2dc:	1000a126 	beq	r2,zero,8112b564 <___vfiprintf_internal_r+0x940>
8112b2e0:	da802217 	ldw	r10,136(sp)
8112b2e4:	d8001d85 	stb	zero,118(sp)
8112b2e8:	50800204 	addi	r2,r10,8
8112b2ec:	54800017 	ldw	r18,0(r10)
8112b2f0:	54c00117 	ldw	r19,4(r10)
8112b2f4:	4802b416 	blt	r9,zero,8112bdc8 <___vfiprintf_internal_r+0x11a4>
8112b2f8:	013fdfc4 	movi	r4,-129
8112b2fc:	94c6b03a 	or	r3,r18,r19
8112b300:	d8802215 	stw	r2,136(sp)
8112b304:	a128703a 	and	r20,r20,r4
8112b308:	1800a226 	beq	r3,zero,8112b594 <___vfiprintf_internal_r+0x970>
8112b30c:	0039883a 	mov	fp,zero
8112b310:	dd401a04 	addi	r21,sp,104
8112b314:	9006d0fa 	srli	r3,r18,3
8112b318:	9808977a 	slli	r4,r19,29
8112b31c:	9826d0fa 	srli	r19,r19,3
8112b320:	948001cc 	andi	r18,r18,7
8112b324:	90800c04 	addi	r2,r18,48
8112b328:	ad7fffc4 	addi	r21,r21,-1
8112b32c:	20e4b03a 	or	r18,r4,r3
8112b330:	a8800005 	stb	r2,0(r21)
8112b334:	94c6b03a 	or	r3,r18,r19
8112b338:	183ff61e 	bne	r3,zero,8112b314 <__reset+0xfb10b314>
8112b33c:	a0c0004c 	andi	r3,r20,1
8112b340:	18005926 	beq	r3,zero,8112b4a8 <___vfiprintf_internal_r+0x884>
8112b344:	10803fcc 	andi	r2,r2,255
8112b348:	1080201c 	xori	r2,r2,128
8112b34c:	10bfe004 	addi	r2,r2,-128
8112b350:	00c00c04 	movi	r3,48
8112b354:	10c05426 	beq	r2,r3,8112b4a8 <___vfiprintf_internal_r+0x884>
8112b358:	da801e17 	ldw	r10,120(sp)
8112b35c:	a8bfffc4 	addi	r2,r21,-1
8112b360:	a8ffffc5 	stb	r3,-1(r21)
8112b364:	50a7c83a 	sub	r19,r10,r2
8112b368:	102b883a 	mov	r21,r2
8112b36c:	003f2f06 	br	8112b02c <__reset+0xfb10b02c>
8112b370:	21003fcc 	andi	r4,r4,255
8112b374:	2003421e 	bne	r4,zero,8112c080 <___vfiprintf_internal_r+0x145c>
8112b378:	00a04574 	movhi	r2,33045
8112b37c:	10a6b304 	addi	r2,r2,-25908
8112b380:	d8802615 	stw	r2,152(sp)
8112b384:	a080080c 	andi	r2,r20,32
8112b388:	1000aa26 	beq	r2,zero,8112b634 <___vfiprintf_internal_r+0xa10>
8112b38c:	da802217 	ldw	r10,136(sp)
8112b390:	54800017 	ldw	r18,0(r10)
8112b394:	54c00117 	ldw	r19,4(r10)
8112b398:	52800204 	addi	r10,r10,8
8112b39c:	da802215 	stw	r10,136(sp)
8112b3a0:	a080004c 	andi	r2,r20,1
8112b3a4:	1001d226 	beq	r2,zero,8112baf0 <___vfiprintf_internal_r+0xecc>
8112b3a8:	94c4b03a 	or	r2,r18,r19
8112b3ac:	1002351e 	bne	r2,zero,8112bc84 <___vfiprintf_internal_r+0x1060>
8112b3b0:	d8001d85 	stb	zero,118(sp)
8112b3b4:	48022216 	blt	r9,zero,8112bc40 <___vfiprintf_internal_r+0x101c>
8112b3b8:	00bfdfc4 	movi	r2,-129
8112b3bc:	a0a8703a 	and	r20,r20,r2
8112b3c0:	003f1506 	br	8112b018 <__reset+0xfb10b018>
8112b3c4:	da802217 	ldw	r10,136(sp)
8112b3c8:	04800044 	movi	r18,1
8112b3cc:	d8001d85 	stb	zero,118(sp)
8112b3d0:	50800017 	ldw	r2,0(r10)
8112b3d4:	52800104 	addi	r10,r10,4
8112b3d8:	da802215 	stw	r10,136(sp)
8112b3dc:	d8801005 	stb	r2,64(sp)
8112b3e0:	9027883a 	mov	r19,r18
8112b3e4:	dd401004 	addi	r21,sp,64
8112b3e8:	0013883a 	mov	r9,zero
8112b3ec:	003f1706 	br	8112b04c <__reset+0xfb10b04c>
8112b3f0:	21003fcc 	andi	r4,r4,255
8112b3f4:	2003201e 	bne	r4,zero,8112c078 <___vfiprintf_internal_r+0x1454>
8112b3f8:	a080080c 	andi	r2,r20,32
8112b3fc:	10004b26 	beq	r2,zero,8112b52c <___vfiprintf_internal_r+0x908>
8112b400:	da802217 	ldw	r10,136(sp)
8112b404:	50800117 	ldw	r2,4(r10)
8112b408:	54800017 	ldw	r18,0(r10)
8112b40c:	52800204 	addi	r10,r10,8
8112b410:	da802215 	stw	r10,136(sp)
8112b414:	1027883a 	mov	r19,r2
8112b418:	10022c16 	blt	r2,zero,8112bccc <___vfiprintf_internal_r+0x10a8>
8112b41c:	df001d83 	ldbu	fp,118(sp)
8112b420:	48007216 	blt	r9,zero,8112b5ec <___vfiprintf_internal_r+0x9c8>
8112b424:	00ffdfc4 	movi	r3,-129
8112b428:	94c4b03a 	or	r2,r18,r19
8112b42c:	a0e8703a 	and	r20,r20,r3
8112b430:	1000cc26 	beq	r2,zero,8112b764 <___vfiprintf_internal_r+0xb40>
8112b434:	98021026 	beq	r19,zero,8112bc78 <___vfiprintf_internal_r+0x1054>
8112b438:	dc402415 	stw	r17,144(sp)
8112b43c:	dc002515 	stw	r16,148(sp)
8112b440:	9823883a 	mov	r17,r19
8112b444:	9021883a 	mov	r16,r18
8112b448:	dd401a04 	addi	r21,sp,104
8112b44c:	4825883a 	mov	r18,r9
8112b450:	4027883a 	mov	r19,r8
8112b454:	8009883a 	mov	r4,r16
8112b458:	880b883a 	mov	r5,r17
8112b45c:	01800284 	movi	r6,10
8112b460:	000f883a 	mov	r7,zero
8112b464:	112d9c00 	call	8112d9c0 <__umoddi3>
8112b468:	10800c04 	addi	r2,r2,48
8112b46c:	ad7fffc4 	addi	r21,r21,-1
8112b470:	8009883a 	mov	r4,r16
8112b474:	880b883a 	mov	r5,r17
8112b478:	a8800005 	stb	r2,0(r21)
8112b47c:	01800284 	movi	r6,10
8112b480:	000f883a 	mov	r7,zero
8112b484:	112d4400 	call	8112d440 <__udivdi3>
8112b488:	1021883a 	mov	r16,r2
8112b48c:	10c4b03a 	or	r2,r2,r3
8112b490:	1823883a 	mov	r17,r3
8112b494:	103fef1e 	bne	r2,zero,8112b454 <__reset+0xfb10b454>
8112b498:	dc402417 	ldw	r17,144(sp)
8112b49c:	dc002517 	ldw	r16,148(sp)
8112b4a0:	9013883a 	mov	r9,r18
8112b4a4:	9811883a 	mov	r8,r19
8112b4a8:	da801e17 	ldw	r10,120(sp)
8112b4ac:	5567c83a 	sub	r19,r10,r21
8112b4b0:	003ede06 	br	8112b02c <__reset+0xfb10b02c>
8112b4b4:	38803fcc 	andi	r2,r7,255
8112b4b8:	1080201c 	xori	r2,r2,128
8112b4bc:	10bfe004 	addi	r2,r2,-128
8112b4c0:	1002371e 	bne	r2,zero,8112bda0 <___vfiprintf_internal_r+0x117c>
8112b4c4:	01000044 	movi	r4,1
8112b4c8:	01c00804 	movi	r7,32
8112b4cc:	80c00007 	ldb	r3,0(r16)
8112b4d0:	003e3506 	br	8112ada8 <__reset+0xfb10ada8>
8112b4d4:	a5000054 	ori	r20,r20,1
8112b4d8:	80c00007 	ldb	r3,0(r16)
8112b4dc:	003e3206 	br	8112ada8 <__reset+0xfb10ada8>
8112b4e0:	a5002014 	ori	r20,r20,128
8112b4e4:	80c00007 	ldb	r3,0(r16)
8112b4e8:	003e2f06 	br	8112ada8 <__reset+0xfb10ada8>
8112b4ec:	8015883a 	mov	r10,r16
8112b4f0:	0023883a 	mov	r17,zero
8112b4f4:	18bff404 	addi	r2,r3,-48
8112b4f8:	50c00007 	ldb	r3,0(r10)
8112b4fc:	8c4002a4 	muli	r17,r17,10
8112b500:	84000044 	addi	r16,r16,1
8112b504:	8015883a 	mov	r10,r16
8112b508:	1463883a 	add	r17,r2,r17
8112b50c:	18bff404 	addi	r2,r3,-48
8112b510:	30bff92e 	bgeu	r6,r2,8112b4f8 <__reset+0xfb10b4f8>
8112b514:	003e2506 	br	8112adac <__reset+0xfb10adac>
8112b518:	21003fcc 	andi	r4,r4,255
8112b51c:	2002d41e 	bne	r4,zero,8112c070 <___vfiprintf_internal_r+0x144c>
8112b520:	a5000414 	ori	r20,r20,16
8112b524:	a080080c 	andi	r2,r20,32
8112b528:	103fb51e 	bne	r2,zero,8112b400 <__reset+0xfb10b400>
8112b52c:	a080040c 	andi	r2,r20,16
8112b530:	1001f826 	beq	r2,zero,8112bd14 <___vfiprintf_internal_r+0x10f0>
8112b534:	da802217 	ldw	r10,136(sp)
8112b538:	54800017 	ldw	r18,0(r10)
8112b53c:	52800104 	addi	r10,r10,4
8112b540:	da802215 	stw	r10,136(sp)
8112b544:	9027d7fa 	srai	r19,r18,31
8112b548:	9805883a 	mov	r2,r19
8112b54c:	003fb206 	br	8112b418 <__reset+0xfb10b418>
8112b550:	21003fcc 	andi	r4,r4,255
8112b554:	2002c41e 	bne	r4,zero,8112c068 <___vfiprintf_internal_r+0x1444>
8112b558:	a5000414 	ori	r20,r20,16
8112b55c:	a080080c 	andi	r2,r20,32
8112b560:	103f5f1e 	bne	r2,zero,8112b2e0 <__reset+0xfb10b2e0>
8112b564:	a080040c 	andi	r2,r20,16
8112b568:	10020f26 	beq	r2,zero,8112bda8 <___vfiprintf_internal_r+0x1184>
8112b56c:	da802217 	ldw	r10,136(sp)
8112b570:	d8001d85 	stb	zero,118(sp)
8112b574:	0027883a 	mov	r19,zero
8112b578:	50800104 	addi	r2,r10,4
8112b57c:	54800017 	ldw	r18,0(r10)
8112b580:	48021116 	blt	r9,zero,8112bdc8 <___vfiprintf_internal_r+0x11a4>
8112b584:	00ffdfc4 	movi	r3,-129
8112b588:	d8802215 	stw	r2,136(sp)
8112b58c:	a0e8703a 	and	r20,r20,r3
8112b590:	903f5e1e 	bne	r18,zero,8112b30c <__reset+0xfb10b30c>
8112b594:	0039883a 	mov	fp,zero
8112b598:	4802a626 	beq	r9,zero,8112c034 <___vfiprintf_internal_r+0x1410>
8112b59c:	0025883a 	mov	r18,zero
8112b5a0:	0027883a 	mov	r19,zero
8112b5a4:	003f5a06 	br	8112b310 <__reset+0xfb10b310>
8112b5a8:	21003fcc 	andi	r4,r4,255
8112b5ac:	20029f1e 	bne	r4,zero,8112c02c <___vfiprintf_internal_r+0x1408>
8112b5b0:	a5000414 	ori	r20,r20,16
8112b5b4:	a080080c 	andi	r2,r20,32
8112b5b8:	10005e1e 	bne	r2,zero,8112b734 <___vfiprintf_internal_r+0xb10>
8112b5bc:	a080040c 	andi	r2,r20,16
8112b5c0:	1001a21e 	bne	r2,zero,8112bc4c <___vfiprintf_internal_r+0x1028>
8112b5c4:	a080100c 	andi	r2,r20,64
8112b5c8:	d8001d85 	stb	zero,118(sp)
8112b5cc:	da802217 	ldw	r10,136(sp)
8112b5d0:	1002231e 	bne	r2,zero,8112be60 <___vfiprintf_internal_r+0x123c>
8112b5d4:	50800104 	addi	r2,r10,4
8112b5d8:	54800017 	ldw	r18,0(r10)
8112b5dc:	0027883a 	mov	r19,zero
8112b5e0:	4801a00e 	bge	r9,zero,8112bc64 <___vfiprintf_internal_r+0x1040>
8112b5e4:	d8802215 	stw	r2,136(sp)
8112b5e8:	0039883a 	mov	fp,zero
8112b5ec:	94c4b03a 	or	r2,r18,r19
8112b5f0:	103f901e 	bne	r2,zero,8112b434 <__reset+0xfb10b434>
8112b5f4:	00800044 	movi	r2,1
8112b5f8:	10803fcc 	andi	r2,r2,255
8112b5fc:	00c00044 	movi	r3,1
8112b600:	10c05926 	beq	r2,r3,8112b768 <___vfiprintf_internal_r+0xb44>
8112b604:	00c00084 	movi	r3,2
8112b608:	10ffe41e 	bne	r2,r3,8112b59c <__reset+0xfb10b59c>
8112b60c:	0025883a 	mov	r18,zero
8112b610:	0027883a 	mov	r19,zero
8112b614:	00013d06 	br	8112bb0c <___vfiprintf_internal_r+0xee8>
8112b618:	21003fcc 	andi	r4,r4,255
8112b61c:	2002811e 	bne	r4,zero,8112c024 <___vfiprintf_internal_r+0x1400>
8112b620:	00a04574 	movhi	r2,33045
8112b624:	10a6ae04 	addi	r2,r2,-25928
8112b628:	d8802615 	stw	r2,152(sp)
8112b62c:	a080080c 	andi	r2,r20,32
8112b630:	103f561e 	bne	r2,zero,8112b38c <__reset+0xfb10b38c>
8112b634:	a080040c 	andi	r2,r20,16
8112b638:	1001d126 	beq	r2,zero,8112bd80 <___vfiprintf_internal_r+0x115c>
8112b63c:	da802217 	ldw	r10,136(sp)
8112b640:	0027883a 	mov	r19,zero
8112b644:	54800017 	ldw	r18,0(r10)
8112b648:	52800104 	addi	r10,r10,4
8112b64c:	da802215 	stw	r10,136(sp)
8112b650:	003f5306 	br	8112b3a0 <__reset+0xfb10b3a0>
8112b654:	da802217 	ldw	r10,136(sp)
8112b658:	d8001d85 	stb	zero,118(sp)
8112b65c:	55400017 	ldw	r21,0(r10)
8112b660:	50c00104 	addi	r3,r10,4
8112b664:	a8024226 	beq	r21,zero,8112bf70 <___vfiprintf_internal_r+0x134c>
8112b668:	48021816 	blt	r9,zero,8112becc <___vfiprintf_internal_r+0x12a8>
8112b66c:	480d883a 	mov	r6,r9
8112b670:	000b883a 	mov	r5,zero
8112b674:	a809883a 	mov	r4,r21
8112b678:	d8c02a15 	stw	r3,168(sp)
8112b67c:	da002b15 	stw	r8,172(sp)
8112b680:	da402c15 	stw	r9,176(sp)
8112b684:	1125a000 	call	81125a00 <memchr>
8112b688:	d8c02a17 	ldw	r3,168(sp)
8112b68c:	da002b17 	ldw	r8,172(sp)
8112b690:	da402c17 	ldw	r9,176(sp)
8112b694:	10024826 	beq	r2,zero,8112bfb8 <___vfiprintf_internal_r+0x1394>
8112b698:	1567c83a 	sub	r19,r2,r21
8112b69c:	df001d83 	ldbu	fp,118(sp)
8112b6a0:	d8c02215 	stw	r3,136(sp)
8112b6a4:	0013883a 	mov	r9,zero
8112b6a8:	003e6006 	br	8112b02c <__reset+0xfb10b02c>
8112b6ac:	21003fcc 	andi	r4,r4,255
8112b6b0:	203fc026 	beq	r4,zero,8112b5b4 <__reset+0xfb10b5b4>
8112b6b4:	d9c01d85 	stb	r7,118(sp)
8112b6b8:	003fbe06 	br	8112b5b4 <__reset+0xfb10b5b4>
8112b6bc:	da802217 	ldw	r10,136(sp)
8112b6c0:	54400017 	ldw	r17,0(r10)
8112b6c4:	50800104 	addi	r2,r10,4
8112b6c8:	883e3b16 	blt	r17,zero,8112afb8 <__reset+0xfb10afb8>
8112b6cc:	d8802215 	stw	r2,136(sp)
8112b6d0:	80c00007 	ldb	r3,0(r16)
8112b6d4:	003db406 	br	8112ada8 <__reset+0xfb10ada8>
8112b6d8:	01000044 	movi	r4,1
8112b6dc:	01c00ac4 	movi	r7,43
8112b6e0:	80c00007 	ldb	r3,0(r16)
8112b6e4:	003db006 	br	8112ada8 <__reset+0xfb10ada8>
8112b6e8:	80c00007 	ldb	r3,0(r16)
8112b6ec:	82800044 	addi	r10,r16,1
8112b6f0:	1b423c26 	beq	r3,r13,8112bfe4 <___vfiprintf_internal_r+0x13c0>
8112b6f4:	18bff404 	addi	r2,r3,-48
8112b6f8:	0013883a 	mov	r9,zero
8112b6fc:	30822b36 	bltu	r6,r2,8112bfac <___vfiprintf_internal_r+0x1388>
8112b700:	50c00007 	ldb	r3,0(r10)
8112b704:	4a4002a4 	muli	r9,r9,10
8112b708:	54000044 	addi	r16,r10,1
8112b70c:	8015883a 	mov	r10,r16
8112b710:	4893883a 	add	r9,r9,r2
8112b714:	18bff404 	addi	r2,r3,-48
8112b718:	30bff92e 	bgeu	r6,r2,8112b700 <__reset+0xfb10b700>
8112b71c:	483da30e 	bge	r9,zero,8112adac <__reset+0xfb10adac>
8112b720:	027fffc4 	movi	r9,-1
8112b724:	003da106 	br	8112adac <__reset+0xfb10adac>
8112b728:	a5001014 	ori	r20,r20,64
8112b72c:	80c00007 	ldb	r3,0(r16)
8112b730:	003d9d06 	br	8112ada8 <__reset+0xfb10ada8>
8112b734:	da802217 	ldw	r10,136(sp)
8112b738:	d8001d85 	stb	zero,118(sp)
8112b73c:	50c00204 	addi	r3,r10,8
8112b740:	54800017 	ldw	r18,0(r10)
8112b744:	54c00117 	ldw	r19,4(r10)
8112b748:	4801ca16 	blt	r9,zero,8112be74 <___vfiprintf_internal_r+0x1250>
8112b74c:	013fdfc4 	movi	r4,-129
8112b750:	94c4b03a 	or	r2,r18,r19
8112b754:	d8c02215 	stw	r3,136(sp)
8112b758:	a128703a 	and	r20,r20,r4
8112b75c:	0039883a 	mov	fp,zero
8112b760:	103f341e 	bne	r2,zero,8112b434 <__reset+0xfb10b434>
8112b764:	483e2e26 	beq	r9,zero,8112b020 <__reset+0xfb10b020>
8112b768:	0025883a 	mov	r18,zero
8112b76c:	94800c04 	addi	r18,r18,48
8112b770:	dc8019c5 	stb	r18,103(sp)
8112b774:	dcc02717 	ldw	r19,156(sp)
8112b778:	dd4019c4 	addi	r21,sp,103
8112b77c:	003e2b06 	br	8112b02c <__reset+0xfb10b02c>
8112b780:	21003fcc 	andi	r4,r4,255
8112b784:	2002361e 	bne	r4,zero,8112c060 <___vfiprintf_internal_r+0x143c>
8112b788:	1801c126 	beq	r3,zero,8112be90 <___vfiprintf_internal_r+0x126c>
8112b78c:	04800044 	movi	r18,1
8112b790:	d8c01005 	stb	r3,64(sp)
8112b794:	d8001d85 	stb	zero,118(sp)
8112b798:	9027883a 	mov	r19,r18
8112b79c:	dd401004 	addi	r21,sp,64
8112b7a0:	003f1106 	br	8112b3e8 <__reset+0xfb10b3e8>
8112b7a4:	d9402117 	ldw	r5,132(sp)
8112b7a8:	d9002017 	ldw	r4,128(sp)
8112b7ac:	d9801a04 	addi	r6,sp,104
8112b7b0:	d9c02b15 	stw	r7,172(sp)
8112b7b4:	dbc02a15 	stw	r15,168(sp)
8112b7b8:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112b7bc:	d9c02b17 	ldw	r7,172(sp)
8112b7c0:	dbc02a17 	ldw	r15,168(sp)
8112b7c4:	10006d1e 	bne	r2,zero,8112b97c <___vfiprintf_internal_r+0xd58>
8112b7c8:	d9801b17 	ldw	r6,108(sp)
8112b7cc:	d8801c17 	ldw	r2,112(sp)
8112b7d0:	d811883a 	mov	r8,sp
8112b7d4:	31400044 	addi	r5,r6,1
8112b7d8:	003e3306 	br	8112b0a8 <__reset+0xfb10b0a8>
8112b7dc:	d9401b17 	ldw	r5,108(sp)
8112b7e0:	d8801c17 	ldw	r2,112(sp)
8112b7e4:	29000044 	addi	r4,r5,1
8112b7e8:	d8c01d87 	ldb	r3,118(sp)
8112b7ec:	183e4d26 	beq	r3,zero,8112b124 <__reset+0xfb10b124>
8112b7f0:	00c00044 	movi	r3,1
8112b7f4:	d9401d84 	addi	r5,sp,118
8112b7f8:	10c5883a 	add	r2,r2,r3
8112b7fc:	41400015 	stw	r5,0(r8)
8112b800:	40c00115 	stw	r3,4(r8)
8112b804:	d8801c15 	stw	r2,112(sp)
8112b808:	d9001b15 	stw	r4,108(sp)
8112b80c:	014001c4 	movi	r5,7
8112b810:	2900a90e 	bge	r5,r4,8112bab8 <___vfiprintf_internal_r+0xe94>
8112b814:	1000da1e 	bne	r2,zero,8112bb80 <___vfiprintf_internal_r+0xf5c>
8112b818:	7000ab1e 	bne	r14,zero,8112bac8 <___vfiprintf_internal_r+0xea4>
8112b81c:	000b883a 	mov	r5,zero
8112b820:	1809883a 	mov	r4,r3
8112b824:	d811883a 	mov	r8,sp
8112b828:	00c02004 	movi	r3,128
8112b82c:	e0fe4d26 	beq	fp,r3,8112b164 <__reset+0xfb10b164>
8112b830:	4cf9c83a 	sub	fp,r9,r19
8112b834:	073e7b0e 	bge	zero,fp,8112b224 <__reset+0xfb10b224>
8112b838:	01c00404 	movi	r7,16
8112b83c:	3f01900e 	bge	r7,fp,8112be80 <___vfiprintf_internal_r+0x125c>
8112b840:	00e04574 	movhi	r3,33045
8112b844:	18e74504 	addi	r3,r3,-25324
8112b848:	d8c02415 	stw	r3,144(sp)
8112b84c:	034001c4 	movi	r13,7
8112b850:	00000506 	br	8112b868 <___vfiprintf_internal_r+0xc44>
8112b854:	29000084 	addi	r4,r5,2
8112b858:	42000204 	addi	r8,r8,8
8112b85c:	180b883a 	mov	r5,r3
8112b860:	e73ffc04 	addi	fp,fp,-16
8112b864:	3f000d0e 	bge	r7,fp,8112b89c <___vfiprintf_internal_r+0xc78>
8112b868:	10800404 	addi	r2,r2,16
8112b86c:	28c00044 	addi	r3,r5,1
8112b870:	45c00015 	stw	r23,0(r8)
8112b874:	41c00115 	stw	r7,4(r8)
8112b878:	d8801c15 	stw	r2,112(sp)
8112b87c:	d8c01b15 	stw	r3,108(sp)
8112b880:	68fff40e 	bge	r13,r3,8112b854 <__reset+0xfb10b854>
8112b884:	1000101e 	bne	r2,zero,8112b8c8 <___vfiprintf_internal_r+0xca4>
8112b888:	e73ffc04 	addi	fp,fp,-16
8112b88c:	01000044 	movi	r4,1
8112b890:	000b883a 	mov	r5,zero
8112b894:	d811883a 	mov	r8,sp
8112b898:	3f3ff316 	blt	r7,fp,8112b868 <__reset+0xfb10b868>
8112b89c:	da802417 	ldw	r10,144(sp)
8112b8a0:	1705883a 	add	r2,r2,fp
8112b8a4:	47000115 	stw	fp,4(r8)
8112b8a8:	42800015 	stw	r10,0(r8)
8112b8ac:	d8801c15 	stw	r2,112(sp)
8112b8b0:	d9001b15 	stw	r4,108(sp)
8112b8b4:	00c001c4 	movi	r3,7
8112b8b8:	19003616 	blt	r3,r4,8112b994 <___vfiprintf_internal_r+0xd70>
8112b8bc:	42000204 	addi	r8,r8,8
8112b8c0:	21000044 	addi	r4,r4,1
8112b8c4:	003e5706 	br	8112b224 <__reset+0xfb10b224>
8112b8c8:	d9402117 	ldw	r5,132(sp)
8112b8cc:	d9002017 	ldw	r4,128(sp)
8112b8d0:	d9801a04 	addi	r6,sp,104
8112b8d4:	d9c02b15 	stw	r7,172(sp)
8112b8d8:	db402a15 	stw	r13,168(sp)
8112b8dc:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112b8e0:	d9c02b17 	ldw	r7,172(sp)
8112b8e4:	db402a17 	ldw	r13,168(sp)
8112b8e8:	1000241e 	bne	r2,zero,8112b97c <___vfiprintf_internal_r+0xd58>
8112b8ec:	d9401b17 	ldw	r5,108(sp)
8112b8f0:	d8801c17 	ldw	r2,112(sp)
8112b8f4:	d811883a 	mov	r8,sp
8112b8f8:	29000044 	addi	r4,r5,1
8112b8fc:	003fd806 	br	8112b860 <__reset+0xfb10b860>
8112b900:	d9401b17 	ldw	r5,108(sp)
8112b904:	00e04574 	movhi	r3,33045
8112b908:	18e74904 	addi	r3,r3,-25308
8112b90c:	d8c02415 	stw	r3,144(sp)
8112b910:	29400044 	addi	r5,r5,1
8112b914:	d8c02417 	ldw	r3,144(sp)
8112b918:	14c5883a 	add	r2,r2,r19
8112b91c:	44c00115 	stw	r19,4(r8)
8112b920:	40c00015 	stw	r3,0(r8)
8112b924:	d8801c15 	stw	r2,112(sp)
8112b928:	d9401b15 	stw	r5,108(sp)
8112b92c:	00c001c4 	movi	r3,7
8112b930:	1940070e 	bge	r3,r5,8112b950 <___vfiprintf_internal_r+0xd2c>
8112b934:	103e4826 	beq	r2,zero,8112b258 <__reset+0xfb10b258>
8112b938:	d9402117 	ldw	r5,132(sp)
8112b93c:	d9002017 	ldw	r4,128(sp)
8112b940:	d9801a04 	addi	r6,sp,104
8112b944:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112b948:	10000c1e 	bne	r2,zero,8112b97c <___vfiprintf_internal_r+0xd58>
8112b94c:	d8801c17 	ldw	r2,112(sp)
8112b950:	8c80010e 	bge	r17,r18,8112b958 <___vfiprintf_internal_r+0xd34>
8112b954:	9023883a 	mov	r17,r18
8112b958:	da802317 	ldw	r10,140(sp)
8112b95c:	5455883a 	add	r10,r10,r17
8112b960:	da802315 	stw	r10,140(sp)
8112b964:	103e4126 	beq	r2,zero,8112b26c <__reset+0xfb10b26c>
8112b968:	d9402117 	ldw	r5,132(sp)
8112b96c:	d9002017 	ldw	r4,128(sp)
8112b970:	d9801a04 	addi	r6,sp,104
8112b974:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112b978:	103e3c26 	beq	r2,zero,8112b26c <__reset+0xfb10b26c>
8112b97c:	dd002117 	ldw	r20,132(sp)
8112b980:	a080030b 	ldhu	r2,12(r20)
8112b984:	1080100c 	andi	r2,r2,64
8112b988:	1001231e 	bne	r2,zero,8112be18 <___vfiprintf_internal_r+0x11f4>
8112b98c:	d8802317 	ldw	r2,140(sp)
8112b990:	003d7b06 	br	8112af80 <__reset+0xfb10af80>
8112b994:	1000991e 	bne	r2,zero,8112bbfc <___vfiprintf_internal_r+0xfd8>
8112b998:	00c00044 	movi	r3,1
8112b99c:	9805883a 	mov	r2,r19
8112b9a0:	dd400015 	stw	r21,0(sp)
8112b9a4:	dcc00115 	stw	r19,4(sp)
8112b9a8:	dcc01c15 	stw	r19,112(sp)
8112b9ac:	d8c01b15 	stw	r3,108(sp)
8112b9b0:	d811883a 	mov	r8,sp
8112b9b4:	42000204 	addi	r8,r8,8
8112b9b8:	a2c0010c 	andi	r11,r20,4
8112b9bc:	583fe426 	beq	r11,zero,8112b950 <__reset+0xfb10b950>
8112b9c0:	8ca7c83a 	sub	r19,r17,r18
8112b9c4:	04ffe20e 	bge	zero,r19,8112b950 <__reset+0xfb10b950>
8112b9c8:	01c00404 	movi	r7,16
8112b9cc:	3cffcc0e 	bge	r7,r19,8112b900 <__reset+0xfb10b900>
8112b9d0:	02a04574 	movhi	r10,33045
8112b9d4:	52a74904 	addi	r10,r10,-25308
8112b9d8:	d9001b17 	ldw	r4,108(sp)
8112b9dc:	da802415 	stw	r10,144(sp)
8112b9e0:	382b883a 	mov	r21,r7
8112b9e4:	050001c4 	movi	r20,7
8112b9e8:	df002017 	ldw	fp,128(sp)
8112b9ec:	00000506 	br	8112ba04 <___vfiprintf_internal_r+0xde0>
8112b9f0:	21400084 	addi	r5,r4,2
8112b9f4:	42000204 	addi	r8,r8,8
8112b9f8:	1809883a 	mov	r4,r3
8112b9fc:	9cfffc04 	addi	r19,r19,-16
8112ba00:	acffc40e 	bge	r21,r19,8112b914 <__reset+0xfb10b914>
8112ba04:	10800404 	addi	r2,r2,16
8112ba08:	20c00044 	addi	r3,r4,1
8112ba0c:	45800015 	stw	r22,0(r8)
8112ba10:	45400115 	stw	r21,4(r8)
8112ba14:	d8801c15 	stw	r2,112(sp)
8112ba18:	d8c01b15 	stw	r3,108(sp)
8112ba1c:	a0fff40e 	bge	r20,r3,8112b9f0 <__reset+0xfb10b9f0>
8112ba20:	1000041e 	bne	r2,zero,8112ba34 <___vfiprintf_internal_r+0xe10>
8112ba24:	01400044 	movi	r5,1
8112ba28:	0009883a 	mov	r4,zero
8112ba2c:	d811883a 	mov	r8,sp
8112ba30:	003ff206 	br	8112b9fc <__reset+0xfb10b9fc>
8112ba34:	d9402117 	ldw	r5,132(sp)
8112ba38:	d9801a04 	addi	r6,sp,104
8112ba3c:	e009883a 	mov	r4,fp
8112ba40:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112ba44:	103fcd1e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112ba48:	d9001b17 	ldw	r4,108(sp)
8112ba4c:	d8801c17 	ldw	r2,112(sp)
8112ba50:	d811883a 	mov	r8,sp
8112ba54:	21400044 	addi	r5,r4,1
8112ba58:	003fe806 	br	8112b9fc <__reset+0xfb10b9fc>
8112ba5c:	d9402117 	ldw	r5,132(sp)
8112ba60:	d9002017 	ldw	r4,128(sp)
8112ba64:	d9801a04 	addi	r6,sp,104
8112ba68:	d9c02b15 	stw	r7,172(sp)
8112ba6c:	db402a15 	stw	r13,168(sp)
8112ba70:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112ba74:	d9c02b17 	ldw	r7,172(sp)
8112ba78:	db402a17 	ldw	r13,168(sp)
8112ba7c:	103fbf1e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112ba80:	d9401b17 	ldw	r5,108(sp)
8112ba84:	d8801c17 	ldw	r2,112(sp)
8112ba88:	d811883a 	mov	r8,sp
8112ba8c:	29800044 	addi	r6,r5,1
8112ba90:	003dc406 	br	8112b1a4 <__reset+0xfb10b1a4>
8112ba94:	1000d21e 	bne	r2,zero,8112bde0 <___vfiprintf_internal_r+0x11bc>
8112ba98:	d8c01d87 	ldb	r3,118(sp)
8112ba9c:	18009526 	beq	r3,zero,8112bcf4 <___vfiprintf_internal_r+0x10d0>
8112baa0:	00800044 	movi	r2,1
8112baa4:	d8c01d84 	addi	r3,sp,118
8112baa8:	1009883a 	mov	r4,r2
8112baac:	d8c00015 	stw	r3,0(sp)
8112bab0:	d8800115 	stw	r2,4(sp)
8112bab4:	d811883a 	mov	r8,sp
8112bab8:	200b883a 	mov	r5,r4
8112babc:	42000204 	addi	r8,r8,8
8112bac0:	21000044 	addi	r4,r4,1
8112bac4:	003d9706 	br	8112b124 <__reset+0xfb10b124>
8112bac8:	d9001d04 	addi	r4,sp,116
8112bacc:	00800084 	movi	r2,2
8112bad0:	d9000015 	stw	r4,0(sp)
8112bad4:	d8800115 	stw	r2,4(sp)
8112bad8:	1809883a 	mov	r4,r3
8112badc:	d811883a 	mov	r8,sp
8112bae0:	200b883a 	mov	r5,r4
8112bae4:	42000204 	addi	r8,r8,8
8112bae8:	21000044 	addi	r4,r4,1
8112baec:	003f4e06 	br	8112b828 <__reset+0xfb10b828>
8112baf0:	d8001d85 	stb	zero,118(sp)
8112baf4:	48005016 	blt	r9,zero,8112bc38 <___vfiprintf_internal_r+0x1014>
8112baf8:	00ffdfc4 	movi	r3,-129
8112bafc:	94c4b03a 	or	r2,r18,r19
8112bb00:	a0e8703a 	and	r20,r20,r3
8112bb04:	103d4426 	beq	r2,zero,8112b018 <__reset+0xfb10b018>
8112bb08:	0039883a 	mov	fp,zero
8112bb0c:	d9002617 	ldw	r4,152(sp)
8112bb10:	dd401a04 	addi	r21,sp,104
8112bb14:	908003cc 	andi	r2,r18,15
8112bb18:	9806973a 	slli	r3,r19,28
8112bb1c:	2085883a 	add	r2,r4,r2
8112bb20:	9024d13a 	srli	r18,r18,4
8112bb24:	10800003 	ldbu	r2,0(r2)
8112bb28:	9826d13a 	srli	r19,r19,4
8112bb2c:	ad7fffc4 	addi	r21,r21,-1
8112bb30:	1ca4b03a 	or	r18,r3,r18
8112bb34:	a8800005 	stb	r2,0(r21)
8112bb38:	94c4b03a 	or	r2,r18,r19
8112bb3c:	103ff51e 	bne	r2,zero,8112bb14 <__reset+0xfb10bb14>
8112bb40:	003e5906 	br	8112b4a8 <__reset+0xfb10b4a8>
8112bb44:	d9402117 	ldw	r5,132(sp)
8112bb48:	d9002017 	ldw	r4,128(sp)
8112bb4c:	d9801a04 	addi	r6,sp,104
8112bb50:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bb54:	103f891e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112bb58:	d8801c17 	ldw	r2,112(sp)
8112bb5c:	d811883a 	mov	r8,sp
8112bb60:	003f9506 	br	8112b9b8 <__reset+0xfb10b9b8>
8112bb64:	d9402117 	ldw	r5,132(sp)
8112bb68:	d9002017 	ldw	r4,128(sp)
8112bb6c:	d9801a04 	addi	r6,sp,104
8112bb70:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bb74:	103f811e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112bb78:	d811883a 	mov	r8,sp
8112bb7c:	003ced06 	br	8112af34 <__reset+0xfb10af34>
8112bb80:	d9402117 	ldw	r5,132(sp)
8112bb84:	d9002017 	ldw	r4,128(sp)
8112bb88:	d9801a04 	addi	r6,sp,104
8112bb8c:	da402c15 	stw	r9,176(sp)
8112bb90:	db802a15 	stw	r14,168(sp)
8112bb94:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bb98:	da402c17 	ldw	r9,176(sp)
8112bb9c:	db802a17 	ldw	r14,168(sp)
8112bba0:	103f761e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112bba4:	d9401b17 	ldw	r5,108(sp)
8112bba8:	d8801c17 	ldw	r2,112(sp)
8112bbac:	d811883a 	mov	r8,sp
8112bbb0:	29000044 	addi	r4,r5,1
8112bbb4:	003d5b06 	br	8112b124 <__reset+0xfb10b124>
8112bbb8:	d9402117 	ldw	r5,132(sp)
8112bbbc:	d9002017 	ldw	r4,128(sp)
8112bbc0:	d9801a04 	addi	r6,sp,104
8112bbc4:	da402c15 	stw	r9,176(sp)
8112bbc8:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bbcc:	da402c17 	ldw	r9,176(sp)
8112bbd0:	103f6a1e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112bbd4:	d9401b17 	ldw	r5,108(sp)
8112bbd8:	d8801c17 	ldw	r2,112(sp)
8112bbdc:	d811883a 	mov	r8,sp
8112bbe0:	29000044 	addi	r4,r5,1
8112bbe4:	003f1006 	br	8112b828 <__reset+0xfb10b828>
8112bbe8:	1000c31e 	bne	r2,zero,8112bef8 <___vfiprintf_internal_r+0x12d4>
8112bbec:	01000044 	movi	r4,1
8112bbf0:	000b883a 	mov	r5,zero
8112bbf4:	d811883a 	mov	r8,sp
8112bbf8:	003f0d06 	br	8112b830 <__reset+0xfb10b830>
8112bbfc:	d9402117 	ldw	r5,132(sp)
8112bc00:	d9002017 	ldw	r4,128(sp)
8112bc04:	d9801a04 	addi	r6,sp,104
8112bc08:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bc0c:	103f5b1e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112bc10:	d9001b17 	ldw	r4,108(sp)
8112bc14:	d8801c17 	ldw	r2,112(sp)
8112bc18:	d811883a 	mov	r8,sp
8112bc1c:	21000044 	addi	r4,r4,1
8112bc20:	003d8006 	br	8112b224 <__reset+0xfb10b224>
8112bc24:	01204574 	movhi	r4,33045
8112bc28:	2126b304 	addi	r4,r4,-25908
8112bc2c:	d9002615 	stw	r4,152(sp)
8112bc30:	d8c02215 	stw	r3,136(sp)
8112bc34:	1029883a 	mov	r20,r2
8112bc38:	94c4b03a 	or	r2,r18,r19
8112bc3c:	103fb21e 	bne	r2,zero,8112bb08 <__reset+0xfb10bb08>
8112bc40:	0039883a 	mov	fp,zero
8112bc44:	00800084 	movi	r2,2
8112bc48:	003e6b06 	br	8112b5f8 <__reset+0xfb10b5f8>
8112bc4c:	da802217 	ldw	r10,136(sp)
8112bc50:	d8001d85 	stb	zero,118(sp)
8112bc54:	0027883a 	mov	r19,zero
8112bc58:	50800104 	addi	r2,r10,4
8112bc5c:	54800017 	ldw	r18,0(r10)
8112bc60:	483e6016 	blt	r9,zero,8112b5e4 <__reset+0xfb10b5e4>
8112bc64:	00ffdfc4 	movi	r3,-129
8112bc68:	d8802215 	stw	r2,136(sp)
8112bc6c:	a0e8703a 	and	r20,r20,r3
8112bc70:	0039883a 	mov	fp,zero
8112bc74:	903ebb26 	beq	r18,zero,8112b764 <__reset+0xfb10b764>
8112bc78:	00800244 	movi	r2,9
8112bc7c:	14bdee36 	bltu	r2,r18,8112b438 <__reset+0xfb10b438>
8112bc80:	003eba06 	br	8112b76c <__reset+0xfb10b76c>
8112bc84:	00800c04 	movi	r2,48
8112bc88:	d8c01d45 	stb	r3,117(sp)
8112bc8c:	d8801d05 	stb	r2,116(sp)
8112bc90:	d8001d85 	stb	zero,118(sp)
8112bc94:	a0c00094 	ori	r3,r20,2
8112bc98:	4800a916 	blt	r9,zero,8112bf40 <___vfiprintf_internal_r+0x131c>
8112bc9c:	00bfdfc4 	movi	r2,-129
8112bca0:	a096703a 	and	r11,r20,r2
8112bca4:	5d000094 	ori	r20,r11,2
8112bca8:	0039883a 	mov	fp,zero
8112bcac:	003f9706 	br	8112bb0c <__reset+0xfb10bb0c>
8112bcb0:	8025883a 	mov	r18,r16
8112bcb4:	003c2e06 	br	8112ad70 <__reset+0xfb10ad70>
8112bcb8:	00a04574 	movhi	r2,33045
8112bcbc:	10a6b304 	addi	r2,r2,-25908
8112bcc0:	0039883a 	mov	fp,zero
8112bcc4:	d8802615 	stw	r2,152(sp)
8112bcc8:	003f9006 	br	8112bb0c <__reset+0xfb10bb0c>
8112bccc:	04a5c83a 	sub	r18,zero,r18
8112bcd0:	07000b44 	movi	fp,45
8112bcd4:	9004c03a 	cmpne	r2,r18,zero
8112bcd8:	04e7c83a 	sub	r19,zero,r19
8112bcdc:	df001d85 	stb	fp,118(sp)
8112bce0:	98a7c83a 	sub	r19,r19,r2
8112bce4:	48009f16 	blt	r9,zero,8112bf64 <___vfiprintf_internal_r+0x1340>
8112bce8:	00bfdfc4 	movi	r2,-129
8112bcec:	a0a8703a 	and	r20,r20,r2
8112bcf0:	003dd006 	br	8112b434 <__reset+0xfb10b434>
8112bcf4:	70004c26 	beq	r14,zero,8112be28 <___vfiprintf_internal_r+0x1204>
8112bcf8:	00800084 	movi	r2,2
8112bcfc:	d8c01d04 	addi	r3,sp,116
8112bd00:	d8c00015 	stw	r3,0(sp)
8112bd04:	d8800115 	stw	r2,4(sp)
8112bd08:	01000044 	movi	r4,1
8112bd0c:	d811883a 	mov	r8,sp
8112bd10:	003f7306 	br	8112bae0 <__reset+0xfb10bae0>
8112bd14:	a080100c 	andi	r2,r20,64
8112bd18:	da802217 	ldw	r10,136(sp)
8112bd1c:	103e0626 	beq	r2,zero,8112b538 <__reset+0xfb10b538>
8112bd20:	5480000f 	ldh	r18,0(r10)
8112bd24:	52800104 	addi	r10,r10,4
8112bd28:	da802215 	stw	r10,136(sp)
8112bd2c:	9027d7fa 	srai	r19,r18,31
8112bd30:	9805883a 	mov	r2,r19
8112bd34:	003db806 	br	8112b418 <__reset+0xfb10b418>
8112bd38:	a080040c 	andi	r2,r20,16
8112bd3c:	1000091e 	bne	r2,zero,8112bd64 <___vfiprintf_internal_r+0x1140>
8112bd40:	a2c0100c 	andi	r11,r20,64
8112bd44:	58000726 	beq	r11,zero,8112bd64 <___vfiprintf_internal_r+0x1140>
8112bd48:	da802217 	ldw	r10,136(sp)
8112bd4c:	50800017 	ldw	r2,0(r10)
8112bd50:	52800104 	addi	r10,r10,4
8112bd54:	da802215 	stw	r10,136(sp)
8112bd58:	da802317 	ldw	r10,140(sp)
8112bd5c:	1280000d 	sth	r10,0(r2)
8112bd60:	003be706 	br	8112ad00 <__reset+0xfb10ad00>
8112bd64:	da802217 	ldw	r10,136(sp)
8112bd68:	50800017 	ldw	r2,0(r10)
8112bd6c:	52800104 	addi	r10,r10,4
8112bd70:	da802215 	stw	r10,136(sp)
8112bd74:	da802317 	ldw	r10,140(sp)
8112bd78:	12800015 	stw	r10,0(r2)
8112bd7c:	003be006 	br	8112ad00 <__reset+0xfb10ad00>
8112bd80:	a080100c 	andi	r2,r20,64
8112bd84:	da802217 	ldw	r10,136(sp)
8112bd88:	10003026 	beq	r2,zero,8112be4c <___vfiprintf_internal_r+0x1228>
8112bd8c:	5480000b 	ldhu	r18,0(r10)
8112bd90:	52800104 	addi	r10,r10,4
8112bd94:	0027883a 	mov	r19,zero
8112bd98:	da802215 	stw	r10,136(sp)
8112bd9c:	003d8006 	br	8112b3a0 <__reset+0xfb10b3a0>
8112bda0:	80c00007 	ldb	r3,0(r16)
8112bda4:	003c0006 	br	8112ada8 <__reset+0xfb10ada8>
8112bda8:	a080100c 	andi	r2,r20,64
8112bdac:	d8001d85 	stb	zero,118(sp)
8112bdb0:	da802217 	ldw	r10,136(sp)
8112bdb4:	1000201e 	bne	r2,zero,8112be38 <___vfiprintf_internal_r+0x1214>
8112bdb8:	50800104 	addi	r2,r10,4
8112bdbc:	54800017 	ldw	r18,0(r10)
8112bdc0:	0027883a 	mov	r19,zero
8112bdc4:	483def0e 	bge	r9,zero,8112b584 <__reset+0xfb10b584>
8112bdc8:	94c6b03a 	or	r3,r18,r19
8112bdcc:	d8802215 	stw	r2,136(sp)
8112bdd0:	183d4e1e 	bne	r3,zero,8112b30c <__reset+0xfb10b30c>
8112bdd4:	0039883a 	mov	fp,zero
8112bdd8:	0005883a 	mov	r2,zero
8112bddc:	003e0606 	br	8112b5f8 <__reset+0xfb10b5f8>
8112bde0:	d9402117 	ldw	r5,132(sp)
8112bde4:	d9002017 	ldw	r4,128(sp)
8112bde8:	d9801a04 	addi	r6,sp,104
8112bdec:	da402c15 	stw	r9,176(sp)
8112bdf0:	db802a15 	stw	r14,168(sp)
8112bdf4:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bdf8:	da402c17 	ldw	r9,176(sp)
8112bdfc:	db802a17 	ldw	r14,168(sp)
8112be00:	103ede1e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112be04:	d9401b17 	ldw	r5,108(sp)
8112be08:	d8801c17 	ldw	r2,112(sp)
8112be0c:	d811883a 	mov	r8,sp
8112be10:	29000044 	addi	r4,r5,1
8112be14:	003e7406 	br	8112b7e8 <__reset+0xfb10b7e8>
8112be18:	00bfffc4 	movi	r2,-1
8112be1c:	003c5806 	br	8112af80 <__reset+0xfb10af80>
8112be20:	d811883a 	mov	r8,sp
8112be24:	003ee806 	br	8112b9c8 <__reset+0xfb10b9c8>
8112be28:	000b883a 	mov	r5,zero
8112be2c:	01000044 	movi	r4,1
8112be30:	d811883a 	mov	r8,sp
8112be34:	003e7c06 	br	8112b828 <__reset+0xfb10b828>
8112be38:	50800104 	addi	r2,r10,4
8112be3c:	5480000b 	ldhu	r18,0(r10)
8112be40:	0027883a 	mov	r19,zero
8112be44:	483dcf0e 	bge	r9,zero,8112b584 <__reset+0xfb10b584>
8112be48:	003fdf06 	br	8112bdc8 <__reset+0xfb10bdc8>
8112be4c:	54800017 	ldw	r18,0(r10)
8112be50:	52800104 	addi	r10,r10,4
8112be54:	0027883a 	mov	r19,zero
8112be58:	da802215 	stw	r10,136(sp)
8112be5c:	003d5006 	br	8112b3a0 <__reset+0xfb10b3a0>
8112be60:	50800104 	addi	r2,r10,4
8112be64:	5480000b 	ldhu	r18,0(r10)
8112be68:	0027883a 	mov	r19,zero
8112be6c:	483f7d0e 	bge	r9,zero,8112bc64 <__reset+0xfb10bc64>
8112be70:	003ddc06 	br	8112b5e4 <__reset+0xfb10b5e4>
8112be74:	d8c02215 	stw	r3,136(sp)
8112be78:	0039883a 	mov	fp,zero
8112be7c:	003ddb06 	br	8112b5ec <__reset+0xfb10b5ec>
8112be80:	02a04574 	movhi	r10,33045
8112be84:	52a74504 	addi	r10,r10,-25324
8112be88:	da802415 	stw	r10,144(sp)
8112be8c:	003e8306 	br	8112b89c <__reset+0xfb10b89c>
8112be90:	d8801c17 	ldw	r2,112(sp)
8112be94:	dd002117 	ldw	r20,132(sp)
8112be98:	103eb926 	beq	r2,zero,8112b980 <__reset+0xfb10b980>
8112be9c:	d9002017 	ldw	r4,128(sp)
8112bea0:	d9801a04 	addi	r6,sp,104
8112bea4:	a00b883a 	mov	r5,r20
8112bea8:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112beac:	003eb406 	br	8112b980 <__reset+0xfb10b980>
8112beb0:	80c00043 	ldbu	r3,1(r16)
8112beb4:	a5000814 	ori	r20,r20,32
8112beb8:	84000044 	addi	r16,r16,1
8112bebc:	18c03fcc 	andi	r3,r3,255
8112bec0:	18c0201c 	xori	r3,r3,128
8112bec4:	18ffe004 	addi	r3,r3,-128
8112bec8:	003bb706 	br	8112ada8 <__reset+0xfb10ada8>
8112becc:	a809883a 	mov	r4,r21
8112bed0:	d8c02a15 	stw	r3,168(sp)
8112bed4:	da002b15 	stw	r8,172(sp)
8112bed8:	111c5040 	call	8111c504 <strlen>
8112bedc:	d8c02a17 	ldw	r3,168(sp)
8112bee0:	1027883a 	mov	r19,r2
8112bee4:	df001d83 	ldbu	fp,118(sp)
8112bee8:	d8c02215 	stw	r3,136(sp)
8112beec:	0013883a 	mov	r9,zero
8112bef0:	da002b17 	ldw	r8,172(sp)
8112bef4:	003c4d06 	br	8112b02c <__reset+0xfb10b02c>
8112bef8:	d9402117 	ldw	r5,132(sp)
8112befc:	d9002017 	ldw	r4,128(sp)
8112bf00:	d9801a04 	addi	r6,sp,104
8112bf04:	da402c15 	stw	r9,176(sp)
8112bf08:	112ab080 	call	8112ab08 <__sprint_r.part.0>
8112bf0c:	da402c17 	ldw	r9,176(sp)
8112bf10:	103e9a1e 	bne	r2,zero,8112b97c <__reset+0xfb10b97c>
8112bf14:	d9401b17 	ldw	r5,108(sp)
8112bf18:	d8801c17 	ldw	r2,112(sp)
8112bf1c:	d811883a 	mov	r8,sp
8112bf20:	29000044 	addi	r4,r5,1
8112bf24:	003e4206 	br	8112b830 <__reset+0xfb10b830>
8112bf28:	d9401b17 	ldw	r5,108(sp)
8112bf2c:	01204574 	movhi	r4,33045
8112bf30:	21274904 	addi	r4,r4,-25308
8112bf34:	d9002415 	stw	r4,144(sp)
8112bf38:	29400044 	addi	r5,r5,1
8112bf3c:	003c6d06 	br	8112b0f4 <__reset+0xfb10b0f4>
8112bf40:	0039883a 	mov	fp,zero
8112bf44:	00800084 	movi	r2,2
8112bf48:	10803fcc 	andi	r2,r2,255
8112bf4c:	01000044 	movi	r4,1
8112bf50:	11001e26 	beq	r2,r4,8112bfcc <___vfiprintf_internal_r+0x13a8>
8112bf54:	01000084 	movi	r4,2
8112bf58:	11001e1e 	bne	r2,r4,8112bfd4 <___vfiprintf_internal_r+0x13b0>
8112bf5c:	1829883a 	mov	r20,r3
8112bf60:	003eea06 	br	8112bb0c <__reset+0xfb10bb0c>
8112bf64:	a007883a 	mov	r3,r20
8112bf68:	00800044 	movi	r2,1
8112bf6c:	003ff606 	br	8112bf48 <__reset+0xfb10bf48>
8112bf70:	00800184 	movi	r2,6
8112bf74:	1240012e 	bgeu	r2,r9,8112bf7c <___vfiprintf_internal_r+0x1358>
8112bf78:	1013883a 	mov	r9,r2
8112bf7c:	4827883a 	mov	r19,r9
8112bf80:	4825883a 	mov	r18,r9
8112bf84:	48001516 	blt	r9,zero,8112bfdc <___vfiprintf_internal_r+0x13b8>
8112bf88:	05604574 	movhi	r21,33045
8112bf8c:	d8c02215 	stw	r3,136(sp)
8112bf90:	ad66b804 	addi	r21,r21,-25888
8112bf94:	003d1406 	br	8112b3e8 <__reset+0xfb10b3e8>
8112bf98:	02a04574 	movhi	r10,33045
8112bf9c:	52a74504 	addi	r10,r10,-25324
8112bfa0:	da802415 	stw	r10,144(sp)
8112bfa4:	200d883a 	mov	r6,r4
8112bfa8:	003c9106 	br	8112b1f0 <__reset+0xfb10b1f0>
8112bfac:	5021883a 	mov	r16,r10
8112bfb0:	0013883a 	mov	r9,zero
8112bfb4:	003b7d06 	br	8112adac <__reset+0xfb10adac>
8112bfb8:	4827883a 	mov	r19,r9
8112bfbc:	df001d83 	ldbu	fp,118(sp)
8112bfc0:	d8c02215 	stw	r3,136(sp)
8112bfc4:	0013883a 	mov	r9,zero
8112bfc8:	003c1806 	br	8112b02c <__reset+0xfb10b02c>
8112bfcc:	1829883a 	mov	r20,r3
8112bfd0:	003d1806 	br	8112b434 <__reset+0xfb10b434>
8112bfd4:	1829883a 	mov	r20,r3
8112bfd8:	003ccd06 	br	8112b310 <__reset+0xfb10b310>
8112bfdc:	0025883a 	mov	r18,zero
8112bfe0:	003fe906 	br	8112bf88 <__reset+0xfb10bf88>
8112bfe4:	d8802217 	ldw	r2,136(sp)
8112bfe8:	80c00043 	ldbu	r3,1(r16)
8112bfec:	5021883a 	mov	r16,r10
8112bff0:	12400017 	ldw	r9,0(r2)
8112bff4:	10800104 	addi	r2,r2,4
8112bff8:	d8802215 	stw	r2,136(sp)
8112bffc:	483faf0e 	bge	r9,zero,8112bebc <__reset+0xfb10bebc>
8112c000:	18c03fcc 	andi	r3,r3,255
8112c004:	18c0201c 	xori	r3,r3,128
8112c008:	027fffc4 	movi	r9,-1
8112c00c:	18ffe004 	addi	r3,r3,-128
8112c010:	003b6506 	br	8112ada8 <__reset+0xfb10ada8>
8112c014:	d9c01d85 	stb	r7,118(sp)
8112c018:	003ca006 	br	8112b29c <__reset+0xfb10b29c>
8112c01c:	d9c01d85 	stb	r7,118(sp)
8112c020:	003cad06 	br	8112b2d8 <__reset+0xfb10b2d8>
8112c024:	d9c01d85 	stb	r7,118(sp)
8112c028:	003d7d06 	br	8112b620 <__reset+0xfb10b620>
8112c02c:	d9c01d85 	stb	r7,118(sp)
8112c030:	003d5f06 	br	8112b5b0 <__reset+0xfb10b5b0>
8112c034:	a080004c 	andi	r2,r20,1
8112c038:	0039883a 	mov	fp,zero
8112c03c:	10000526 	beq	r2,zero,8112c054 <___vfiprintf_internal_r+0x1430>
8112c040:	00800c04 	movi	r2,48
8112c044:	d88019c5 	stb	r2,103(sp)
8112c048:	dcc02717 	ldw	r19,156(sp)
8112c04c:	dd4019c4 	addi	r21,sp,103
8112c050:	003bf606 	br	8112b02c <__reset+0xfb10b02c>
8112c054:	0027883a 	mov	r19,zero
8112c058:	dd401a04 	addi	r21,sp,104
8112c05c:	003bf306 	br	8112b02c <__reset+0xfb10b02c>
8112c060:	d9c01d85 	stb	r7,118(sp)
8112c064:	003dc806 	br	8112b788 <__reset+0xfb10b788>
8112c068:	d9c01d85 	stb	r7,118(sp)
8112c06c:	003d3a06 	br	8112b558 <__reset+0xfb10b558>
8112c070:	d9c01d85 	stb	r7,118(sp)
8112c074:	003d2a06 	br	8112b520 <__reset+0xfb10b520>
8112c078:	d9c01d85 	stb	r7,118(sp)
8112c07c:	003cde06 	br	8112b3f8 <__reset+0xfb10b3f8>
8112c080:	d9c01d85 	stb	r7,118(sp)
8112c084:	003cbc06 	br	8112b378 <__reset+0xfb10b378>

8112c088 <__vfiprintf_internal>:
8112c088:	00a04574 	movhi	r2,33045
8112c08c:	10b08204 	addi	r2,r2,-15864
8112c090:	300f883a 	mov	r7,r6
8112c094:	280d883a 	mov	r6,r5
8112c098:	200b883a 	mov	r5,r4
8112c09c:	11000017 	ldw	r4,0(r2)
8112c0a0:	112ac241 	jmpi	8112ac24 <___vfiprintf_internal_r>

8112c0a4 <__sbprintf>:
8112c0a4:	defee204 	addi	sp,sp,-1144
8112c0a8:	de00012e 	bgeu	sp,et,8112c0b0 <__sbprintf+0xc>
8112c0ac:	003b68fa 	trap	3
8112c0b0:	2880030b 	ldhu	r2,12(r5)
8112c0b4:	2ac01917 	ldw	r11,100(r5)
8112c0b8:	2a80038b 	ldhu	r10,14(r5)
8112c0bc:	2a400717 	ldw	r9,28(r5)
8112c0c0:	2a000917 	ldw	r8,36(r5)
8112c0c4:	00c10004 	movi	r3,1024
8112c0c8:	dc011a15 	stw	r16,1128(sp)
8112c0cc:	10bfff4c 	andi	r2,r2,65533
8112c0d0:	2821883a 	mov	r16,r5
8112c0d4:	d8cb883a 	add	r5,sp,r3
8112c0d8:	dc811c15 	stw	r18,1136(sp)
8112c0dc:	dc411b15 	stw	r17,1132(sp)
8112c0e0:	dfc11d15 	stw	ra,1140(sp)
8112c0e4:	2025883a 	mov	r18,r4
8112c0e8:	d881030d 	sth	r2,1036(sp)
8112c0ec:	dac11915 	stw	r11,1124(sp)
8112c0f0:	da81038d 	sth	r10,1038(sp)
8112c0f4:	da410715 	stw	r9,1052(sp)
8112c0f8:	da010915 	stw	r8,1060(sp)
8112c0fc:	dec10015 	stw	sp,1024(sp)
8112c100:	dec10415 	stw	sp,1040(sp)
8112c104:	d8c10215 	stw	r3,1032(sp)
8112c108:	d8c10515 	stw	r3,1044(sp)
8112c10c:	d8010615 	stw	zero,1048(sp)
8112c110:	112ac240 	call	8112ac24 <___vfiprintf_internal_r>
8112c114:	1023883a 	mov	r17,r2
8112c118:	10000416 	blt	r2,zero,8112c12c <__sbprintf+0x88>
8112c11c:	d9410004 	addi	r5,sp,1024
8112c120:	9009883a 	mov	r4,r18
8112c124:	11243dc0 	call	811243dc <_fflush_r>
8112c128:	10000d1e 	bne	r2,zero,8112c160 <__sbprintf+0xbc>
8112c12c:	d881030b 	ldhu	r2,1036(sp)
8112c130:	1080100c 	andi	r2,r2,64
8112c134:	10000326 	beq	r2,zero,8112c144 <__sbprintf+0xa0>
8112c138:	8080030b 	ldhu	r2,12(r16)
8112c13c:	10801014 	ori	r2,r2,64
8112c140:	8080030d 	sth	r2,12(r16)
8112c144:	8805883a 	mov	r2,r17
8112c148:	dfc11d17 	ldw	ra,1140(sp)
8112c14c:	dc811c17 	ldw	r18,1136(sp)
8112c150:	dc411b17 	ldw	r17,1132(sp)
8112c154:	dc011a17 	ldw	r16,1128(sp)
8112c158:	dec11e04 	addi	sp,sp,1144
8112c15c:	f800283a 	ret
8112c160:	047fffc4 	movi	r17,-1
8112c164:	003ff106 	br	8112c12c <__reset+0xfb10c12c>

8112c168 <_calloc_r>:
8112c168:	298b383a 	mul	r5,r5,r6
8112c16c:	defffe04 	addi	sp,sp,-8
8112c170:	de00012e 	bgeu	sp,et,8112c178 <_calloc_r+0x10>
8112c174:	003b68fa 	trap	3
8112c178:	dfc00115 	stw	ra,4(sp)
8112c17c:	dc000015 	stw	r16,0(sp)
8112c180:	111b1fc0 	call	8111b1fc <_malloc_r>
8112c184:	10002926 	beq	r2,zero,8112c22c <_calloc_r+0xc4>
8112c188:	11bfff17 	ldw	r6,-4(r2)
8112c18c:	1021883a 	mov	r16,r2
8112c190:	00bfff04 	movi	r2,-4
8112c194:	308c703a 	and	r6,r6,r2
8112c198:	00c00904 	movi	r3,36
8112c19c:	308d883a 	add	r6,r6,r2
8112c1a0:	19801636 	bltu	r3,r6,8112c1fc <_calloc_r+0x94>
8112c1a4:	008004c4 	movi	r2,19
8112c1a8:	11800b2e 	bgeu	r2,r6,8112c1d8 <_calloc_r+0x70>
8112c1ac:	80000015 	stw	zero,0(r16)
8112c1b0:	80000115 	stw	zero,4(r16)
8112c1b4:	008006c4 	movi	r2,27
8112c1b8:	11801a2e 	bgeu	r2,r6,8112c224 <_calloc_r+0xbc>
8112c1bc:	80000215 	stw	zero,8(r16)
8112c1c0:	80000315 	stw	zero,12(r16)
8112c1c4:	30c0151e 	bne	r6,r3,8112c21c <_calloc_r+0xb4>
8112c1c8:	80000415 	stw	zero,16(r16)
8112c1cc:	80800604 	addi	r2,r16,24
8112c1d0:	80000515 	stw	zero,20(r16)
8112c1d4:	00000106 	br	8112c1dc <_calloc_r+0x74>
8112c1d8:	8005883a 	mov	r2,r16
8112c1dc:	10000015 	stw	zero,0(r2)
8112c1e0:	10000115 	stw	zero,4(r2)
8112c1e4:	10000215 	stw	zero,8(r2)
8112c1e8:	8005883a 	mov	r2,r16
8112c1ec:	dfc00117 	ldw	ra,4(sp)
8112c1f0:	dc000017 	ldw	r16,0(sp)
8112c1f4:	dec00204 	addi	sp,sp,8
8112c1f8:	f800283a 	ret
8112c1fc:	000b883a 	mov	r5,zero
8112c200:	8009883a 	mov	r4,r16
8112c204:	111bb600 	call	8111bb60 <memset>
8112c208:	8005883a 	mov	r2,r16
8112c20c:	dfc00117 	ldw	ra,4(sp)
8112c210:	dc000017 	ldw	r16,0(sp)
8112c214:	dec00204 	addi	sp,sp,8
8112c218:	f800283a 	ret
8112c21c:	80800404 	addi	r2,r16,16
8112c220:	003fee06 	br	8112c1dc <__reset+0xfb10c1dc>
8112c224:	80800204 	addi	r2,r16,8
8112c228:	003fec06 	br	8112c1dc <__reset+0xfb10c1dc>
8112c22c:	0005883a 	mov	r2,zero
8112c230:	003fee06 	br	8112c1ec <__reset+0xfb10c1ec>

8112c234 <_fclose_r>:
8112c234:	28003b26 	beq	r5,zero,8112c324 <_fclose_r+0xf0>
8112c238:	defffc04 	addi	sp,sp,-16
8112c23c:	de00012e 	bgeu	sp,et,8112c244 <_fclose_r+0x10>
8112c240:	003b68fa 	trap	3
8112c244:	dc400115 	stw	r17,4(sp)
8112c248:	dc000015 	stw	r16,0(sp)
8112c24c:	dfc00315 	stw	ra,12(sp)
8112c250:	dc800215 	stw	r18,8(sp)
8112c254:	2023883a 	mov	r17,r4
8112c258:	2821883a 	mov	r16,r5
8112c25c:	20000226 	beq	r4,zero,8112c268 <_fclose_r+0x34>
8112c260:	20800e17 	ldw	r2,56(r4)
8112c264:	10002726 	beq	r2,zero,8112c304 <_fclose_r+0xd0>
8112c268:	8080030f 	ldh	r2,12(r16)
8112c26c:	1000071e 	bne	r2,zero,8112c28c <_fclose_r+0x58>
8112c270:	0005883a 	mov	r2,zero
8112c274:	dfc00317 	ldw	ra,12(sp)
8112c278:	dc800217 	ldw	r18,8(sp)
8112c27c:	dc400117 	ldw	r17,4(sp)
8112c280:	dc000017 	ldw	r16,0(sp)
8112c284:	dec00404 	addi	sp,sp,16
8112c288:	f800283a 	ret
8112c28c:	800b883a 	mov	r5,r16
8112c290:	8809883a 	mov	r4,r17
8112c294:	11241b80 	call	811241b8 <__sflush_r>
8112c298:	1025883a 	mov	r18,r2
8112c29c:	80800b17 	ldw	r2,44(r16)
8112c2a0:	10000426 	beq	r2,zero,8112c2b4 <_fclose_r+0x80>
8112c2a4:	81400717 	ldw	r5,28(r16)
8112c2a8:	8809883a 	mov	r4,r17
8112c2ac:	103ee83a 	callr	r2
8112c2b0:	10001616 	blt	r2,zero,8112c30c <_fclose_r+0xd8>
8112c2b4:	8080030b 	ldhu	r2,12(r16)
8112c2b8:	1080200c 	andi	r2,r2,128
8112c2bc:	1000151e 	bne	r2,zero,8112c314 <_fclose_r+0xe0>
8112c2c0:	81400c17 	ldw	r5,48(r16)
8112c2c4:	28000526 	beq	r5,zero,8112c2dc <_fclose_r+0xa8>
8112c2c8:	80801004 	addi	r2,r16,64
8112c2cc:	28800226 	beq	r5,r2,8112c2d8 <_fclose_r+0xa4>
8112c2d0:	8809883a 	mov	r4,r17
8112c2d4:	1124c700 	call	81124c70 <_free_r>
8112c2d8:	80000c15 	stw	zero,48(r16)
8112c2dc:	81401117 	ldw	r5,68(r16)
8112c2e0:	28000326 	beq	r5,zero,8112c2f0 <_fclose_r+0xbc>
8112c2e4:	8809883a 	mov	r4,r17
8112c2e8:	1124c700 	call	81124c70 <_free_r>
8112c2ec:	80001115 	stw	zero,68(r16)
8112c2f0:	11247e80 	call	811247e8 <__sfp_lock_acquire>
8112c2f4:	8000030d 	sth	zero,12(r16)
8112c2f8:	11247ec0 	call	811247ec <__sfp_lock_release>
8112c2fc:	9005883a 	mov	r2,r18
8112c300:	003fdc06 	br	8112c274 <__reset+0xfb10c274>
8112c304:	11247d80 	call	811247d8 <__sinit>
8112c308:	003fd706 	br	8112c268 <__reset+0xfb10c268>
8112c30c:	04bfffc4 	movi	r18,-1
8112c310:	003fe806 	br	8112c2b4 <__reset+0xfb10c2b4>
8112c314:	81400417 	ldw	r5,16(r16)
8112c318:	8809883a 	mov	r4,r17
8112c31c:	1124c700 	call	81124c70 <_free_r>
8112c320:	003fe706 	br	8112c2c0 <__reset+0xfb10c2c0>
8112c324:	0005883a 	mov	r2,zero
8112c328:	f800283a 	ret

8112c32c <fclose>:
8112c32c:	00a04574 	movhi	r2,33045
8112c330:	10b08204 	addi	r2,r2,-15864
8112c334:	200b883a 	mov	r5,r4
8112c338:	11000017 	ldw	r4,0(r2)
8112c33c:	112c2341 	jmpi	8112c234 <_fclose_r>

8112c340 <__fputwc>:
8112c340:	defff804 	addi	sp,sp,-32
8112c344:	de00012e 	bgeu	sp,et,8112c34c <__fputwc+0xc>
8112c348:	003b68fa 	trap	3
8112c34c:	dcc00415 	stw	r19,16(sp)
8112c350:	dc800315 	stw	r18,12(sp)
8112c354:	dc000115 	stw	r16,4(sp)
8112c358:	dfc00715 	stw	ra,28(sp)
8112c35c:	dd400615 	stw	r21,24(sp)
8112c360:	dd000515 	stw	r20,20(sp)
8112c364:	dc400215 	stw	r17,8(sp)
8112c368:	2027883a 	mov	r19,r4
8112c36c:	2825883a 	mov	r18,r5
8112c370:	3021883a 	mov	r16,r6
8112c374:	11257000 	call	81125700 <__locale_mb_cur_max>
8112c378:	00c00044 	movi	r3,1
8112c37c:	10c03e26 	beq	r2,r3,8112c478 <__fputwc+0x138>
8112c380:	81c01704 	addi	r7,r16,92
8112c384:	900d883a 	mov	r6,r18
8112c388:	d80b883a 	mov	r5,sp
8112c38c:	9809883a 	mov	r4,r19
8112c390:	112d1c40 	call	8112d1c4 <_wcrtomb_r>
8112c394:	1029883a 	mov	r20,r2
8112c398:	00bfffc4 	movi	r2,-1
8112c39c:	a0802026 	beq	r20,r2,8112c420 <__fputwc+0xe0>
8112c3a0:	d9400003 	ldbu	r5,0(sp)
8112c3a4:	a0001c26 	beq	r20,zero,8112c418 <__fputwc+0xd8>
8112c3a8:	0023883a 	mov	r17,zero
8112c3ac:	05400284 	movi	r21,10
8112c3b0:	00000906 	br	8112c3d8 <__fputwc+0x98>
8112c3b4:	80800017 	ldw	r2,0(r16)
8112c3b8:	11400005 	stb	r5,0(r2)
8112c3bc:	80c00017 	ldw	r3,0(r16)
8112c3c0:	18c00044 	addi	r3,r3,1
8112c3c4:	80c00015 	stw	r3,0(r16)
8112c3c8:	8c400044 	addi	r17,r17,1
8112c3cc:	dc45883a 	add	r2,sp,r17
8112c3d0:	8d00112e 	bgeu	r17,r20,8112c418 <__fputwc+0xd8>
8112c3d4:	11400003 	ldbu	r5,0(r2)
8112c3d8:	80c00217 	ldw	r3,8(r16)
8112c3dc:	18ffffc4 	addi	r3,r3,-1
8112c3e0:	80c00215 	stw	r3,8(r16)
8112c3e4:	183ff30e 	bge	r3,zero,8112c3b4 <__reset+0xfb10c3b4>
8112c3e8:	80800617 	ldw	r2,24(r16)
8112c3ec:	18801916 	blt	r3,r2,8112c454 <__fputwc+0x114>
8112c3f0:	80800017 	ldw	r2,0(r16)
8112c3f4:	11400005 	stb	r5,0(r2)
8112c3f8:	80800017 	ldw	r2,0(r16)
8112c3fc:	10c00003 	ldbu	r3,0(r2)
8112c400:	10800044 	addi	r2,r2,1
8112c404:	1d402326 	beq	r3,r21,8112c494 <__fputwc+0x154>
8112c408:	80800015 	stw	r2,0(r16)
8112c40c:	8c400044 	addi	r17,r17,1
8112c410:	dc45883a 	add	r2,sp,r17
8112c414:	8d3fef36 	bltu	r17,r20,8112c3d4 <__reset+0xfb10c3d4>
8112c418:	9005883a 	mov	r2,r18
8112c41c:	00000406 	br	8112c430 <__fputwc+0xf0>
8112c420:	80c0030b 	ldhu	r3,12(r16)
8112c424:	a005883a 	mov	r2,r20
8112c428:	18c01014 	ori	r3,r3,64
8112c42c:	80c0030d 	sth	r3,12(r16)
8112c430:	dfc00717 	ldw	ra,28(sp)
8112c434:	dd400617 	ldw	r21,24(sp)
8112c438:	dd000517 	ldw	r20,20(sp)
8112c43c:	dcc00417 	ldw	r19,16(sp)
8112c440:	dc800317 	ldw	r18,12(sp)
8112c444:	dc400217 	ldw	r17,8(sp)
8112c448:	dc000117 	ldw	r16,4(sp)
8112c44c:	dec00804 	addi	sp,sp,32
8112c450:	f800283a 	ret
8112c454:	800d883a 	mov	r6,r16
8112c458:	29403fcc 	andi	r5,r5,255
8112c45c:	9809883a 	mov	r4,r19
8112c460:	11225a00 	call	811225a0 <__swbuf_r>
8112c464:	10bfffe0 	cmpeqi	r2,r2,-1
8112c468:	10803fcc 	andi	r2,r2,255
8112c46c:	103fd626 	beq	r2,zero,8112c3c8 <__reset+0xfb10c3c8>
8112c470:	00bfffc4 	movi	r2,-1
8112c474:	003fee06 	br	8112c430 <__reset+0xfb10c430>
8112c478:	90ffffc4 	addi	r3,r18,-1
8112c47c:	01003f84 	movi	r4,254
8112c480:	20ffbf36 	bltu	r4,r3,8112c380 <__reset+0xfb10c380>
8112c484:	900b883a 	mov	r5,r18
8112c488:	dc800005 	stb	r18,0(sp)
8112c48c:	1029883a 	mov	r20,r2
8112c490:	003fc506 	br	8112c3a8 <__reset+0xfb10c3a8>
8112c494:	800d883a 	mov	r6,r16
8112c498:	a80b883a 	mov	r5,r21
8112c49c:	9809883a 	mov	r4,r19
8112c4a0:	11225a00 	call	811225a0 <__swbuf_r>
8112c4a4:	10bfffe0 	cmpeqi	r2,r2,-1
8112c4a8:	003fef06 	br	8112c468 <__reset+0xfb10c468>

8112c4ac <_fputwc_r>:
8112c4ac:	3080030b 	ldhu	r2,12(r6)
8112c4b0:	10c8000c 	andi	r3,r2,8192
8112c4b4:	1800051e 	bne	r3,zero,8112c4cc <_fputwc_r+0x20>
8112c4b8:	30c01917 	ldw	r3,100(r6)
8112c4bc:	10880014 	ori	r2,r2,8192
8112c4c0:	3080030d 	sth	r2,12(r6)
8112c4c4:	18880014 	ori	r2,r3,8192
8112c4c8:	30801915 	stw	r2,100(r6)
8112c4cc:	112c3401 	jmpi	8112c340 <__fputwc>

8112c4d0 <fputwc>:
8112c4d0:	00a04574 	movhi	r2,33045
8112c4d4:	defffc04 	addi	sp,sp,-16
8112c4d8:	10b08204 	addi	r2,r2,-15864
8112c4dc:	de00012e 	bgeu	sp,et,8112c4e4 <fputwc+0x14>
8112c4e0:	003b68fa 	trap	3
8112c4e4:	dc000115 	stw	r16,4(sp)
8112c4e8:	14000017 	ldw	r16,0(r2)
8112c4ec:	dc400215 	stw	r17,8(sp)
8112c4f0:	dfc00315 	stw	ra,12(sp)
8112c4f4:	2023883a 	mov	r17,r4
8112c4f8:	80000226 	beq	r16,zero,8112c504 <fputwc+0x34>
8112c4fc:	80800e17 	ldw	r2,56(r16)
8112c500:	10001026 	beq	r2,zero,8112c544 <fputwc+0x74>
8112c504:	2880030b 	ldhu	r2,12(r5)
8112c508:	10c8000c 	andi	r3,r2,8192
8112c50c:	1800051e 	bne	r3,zero,8112c524 <fputwc+0x54>
8112c510:	28c01917 	ldw	r3,100(r5)
8112c514:	10880014 	ori	r2,r2,8192
8112c518:	2880030d 	sth	r2,12(r5)
8112c51c:	18880014 	ori	r2,r3,8192
8112c520:	28801915 	stw	r2,100(r5)
8112c524:	280d883a 	mov	r6,r5
8112c528:	8009883a 	mov	r4,r16
8112c52c:	880b883a 	mov	r5,r17
8112c530:	dfc00317 	ldw	ra,12(sp)
8112c534:	dc400217 	ldw	r17,8(sp)
8112c538:	dc000117 	ldw	r16,4(sp)
8112c53c:	dec00404 	addi	sp,sp,16
8112c540:	112c3401 	jmpi	8112c340 <__fputwc>
8112c544:	8009883a 	mov	r4,r16
8112c548:	d9400015 	stw	r5,0(sp)
8112c54c:	11247d80 	call	811247d8 <__sinit>
8112c550:	d9400017 	ldw	r5,0(sp)
8112c554:	003feb06 	br	8112c504 <__reset+0xfb10c504>

8112c558 <rshift>:
8112c558:	2807d17a 	srai	r3,r5,5
8112c55c:	20800417 	ldw	r2,16(r4)
8112c560:	22000504 	addi	r8,r4,20
8112c564:	1880250e 	bge	r3,r2,8112c5fc <rshift+0xa4>
8112c568:	1085883a 	add	r2,r2,r2
8112c56c:	18c7883a 	add	r3,r3,r3
8112c570:	1085883a 	add	r2,r2,r2
8112c574:	18c7883a 	add	r3,r3,r3
8112c578:	294007cc 	andi	r5,r5,31
8112c57c:	4085883a 	add	r2,r8,r2
8112c580:	40c7883a 	add	r3,r8,r3
8112c584:	28002026 	beq	r5,zero,8112c608 <rshift+0xb0>
8112c588:	19800017 	ldw	r6,0(r3)
8112c58c:	02c00804 	movi	r11,32
8112c590:	19c00104 	addi	r7,r3,4
8112c594:	5957c83a 	sub	r11,r11,r5
8112c598:	314cd83a 	srl	r6,r6,r5
8112c59c:	38802c2e 	bgeu	r7,r2,8112c650 <rshift+0xf8>
8112c5a0:	4015883a 	mov	r10,r8
8112c5a4:	3a400017 	ldw	r9,0(r7)
8112c5a8:	52800104 	addi	r10,r10,4
8112c5ac:	39c00104 	addi	r7,r7,4
8112c5b0:	4ad2983a 	sll	r9,r9,r11
8112c5b4:	498cb03a 	or	r6,r9,r6
8112c5b8:	51bfff15 	stw	r6,-4(r10)
8112c5bc:	39bfff17 	ldw	r6,-4(r7)
8112c5c0:	314cd83a 	srl	r6,r6,r5
8112c5c4:	38bff736 	bltu	r7,r2,8112c5a4 <__reset+0xfb10c5a4>
8112c5c8:	10c7c83a 	sub	r3,r2,r3
8112c5cc:	18fffec4 	addi	r3,r3,-5
8112c5d0:	1806d0ba 	srli	r3,r3,2
8112c5d4:	18c00044 	addi	r3,r3,1
8112c5d8:	18c7883a 	add	r3,r3,r3
8112c5dc:	18c7883a 	add	r3,r3,r3
8112c5e0:	40c7883a 	add	r3,r8,r3
8112c5e4:	19800015 	stw	r6,0(r3)
8112c5e8:	30000126 	beq	r6,zero,8112c5f0 <rshift+0x98>
8112c5ec:	18c00104 	addi	r3,r3,4
8112c5f0:	1a05c83a 	sub	r2,r3,r8
8112c5f4:	1005d0ba 	srai	r2,r2,2
8112c5f8:	00001206 	br	8112c644 <rshift+0xec>
8112c5fc:	20000415 	stw	zero,16(r4)
8112c600:	20000515 	stw	zero,20(r4)
8112c604:	f800283a 	ret
8112c608:	18bffc2e 	bgeu	r3,r2,8112c5fc <__reset+0xfb10c5fc>
8112c60c:	180d883a 	mov	r6,r3
8112c610:	400b883a 	mov	r5,r8
8112c614:	31c00017 	ldw	r7,0(r6)
8112c618:	29400104 	addi	r5,r5,4
8112c61c:	31800104 	addi	r6,r6,4
8112c620:	29ffff15 	stw	r7,-4(r5)
8112c624:	30bffb36 	bltu	r6,r2,8112c614 <__reset+0xfb10c614>
8112c628:	00c6303a 	nor	r3,zero,r3
8112c62c:	1885883a 	add	r2,r3,r2
8112c630:	1004d0ba 	srli	r2,r2,2
8112c634:	10800044 	addi	r2,r2,1
8112c638:	1085883a 	add	r2,r2,r2
8112c63c:	1085883a 	add	r2,r2,r2
8112c640:	1005d0ba 	srai	r2,r2,2
8112c644:	20800415 	stw	r2,16(r4)
8112c648:	103fed26 	beq	r2,zero,8112c600 <__reset+0xfb10c600>
8112c64c:	f800283a 	ret
8112c650:	4007883a 	mov	r3,r8
8112c654:	003fe306 	br	8112c5e4 <__reset+0xfb10c5e4>

8112c658 <__gethex>:
8112c658:	deffeb04 	addi	sp,sp,-84
8112c65c:	de00012e 	bgeu	sp,et,8112c664 <__gethex+0xc>
8112c660:	003b68fa 	trap	3
8112c664:	dfc01415 	stw	ra,80(sp)
8112c668:	dd801115 	stw	r22,68(sp)
8112c66c:	dcc00e15 	stw	r19,56(sp)
8112c670:	dc800d15 	stw	r18,52(sp)
8112c674:	2827883a 	mov	r19,r5
8112c678:	d9000115 	stw	r4,4(sp)
8112c67c:	d9800015 	stw	r6,0(sp)
8112c680:	d9c00415 	stw	r7,16(sp)
8112c684:	df001315 	stw	fp,76(sp)
8112c688:	ddc01215 	stw	r23,72(sp)
8112c68c:	dd401015 	stw	r21,64(sp)
8112c690:	dd000f15 	stw	r20,60(sp)
8112c694:	dc400c15 	stw	r17,48(sp)
8112c698:	dc000b15 	stw	r16,44(sp)
8112c69c:	11257240 	call	81125724 <_localeconv_r>
8112c6a0:	14800017 	ldw	r18,0(r2)
8112c6a4:	9009883a 	mov	r4,r18
8112c6a8:	111c5040 	call	8111c504 <strlen>
8112c6ac:	98c00017 	ldw	r3,0(r19)
8112c6b0:	102d883a 	mov	r22,r2
8112c6b4:	9085883a 	add	r2,r18,r2
8112c6b8:	10bfffc3 	ldbu	r2,-1(r2)
8112c6bc:	19000083 	ldbu	r4,2(r3)
8112c6c0:	d8800305 	stb	r2,12(sp)
8112c6c4:	00800c04 	movi	r2,48
8112c6c8:	2081521e 	bne	r4,r2,8112cc14 <__gethex+0x5bc>
8112c6cc:	017fff84 	movi	r5,-2
8112c6d0:	188000c4 	addi	r2,r3,3
8112c6d4:	28cbc83a 	sub	r5,r5,r3
8112c6d8:	200d883a 	mov	r6,r4
8112c6dc:	28a3883a 	add	r17,r5,r2
8112c6e0:	102b883a 	mov	r21,r2
8112c6e4:	10800044 	addi	r2,r2,1
8112c6e8:	113fffc3 	ldbu	r4,-1(r2)
8112c6ec:	21bffb26 	beq	r4,r6,8112c6dc <__reset+0xfb10c6dc>
8112c6f0:	05204574 	movhi	r20,33045
8112c6f4:	a5274d04 	addi	r20,r20,-25292
8112c6f8:	a109883a 	add	r4,r20,r4
8112c6fc:	20800003 	ldbu	r2,0(r4)
8112c700:	10008826 	beq	r2,zero,8112c924 <__gethex+0x2cc>
8112c704:	a8800003 	ldbu	r2,0(r21)
8112c708:	0015883a 	mov	r10,zero
8112c70c:	002f883a 	mov	r23,zero
8112c710:	a085883a 	add	r2,r20,r2
8112c714:	10800003 	ldbu	r2,0(r2)
8112c718:	a821883a 	mov	r16,r21
8112c71c:	10000526 	beq	r2,zero,8112c734 <__gethex+0xdc>
8112c720:	84000044 	addi	r16,r16,1
8112c724:	80800003 	ldbu	r2,0(r16)
8112c728:	a085883a 	add	r2,r20,r2
8112c72c:	10800003 	ldbu	r2,0(r2)
8112c730:	103ffb1e 	bne	r2,zero,8112c720 <__reset+0xfb10c720>
8112c734:	b00d883a 	mov	r6,r22
8112c738:	900b883a 	mov	r5,r18
8112c73c:	8009883a 	mov	r4,r16
8112c740:	da800a15 	stw	r10,40(sp)
8112c744:	112d0f40 	call	8112d0f4 <strncmp>
8112c748:	da800a17 	ldw	r10,40(sp)
8112c74c:	1000031e 	bne	r2,zero,8112c75c <__gethex+0x104>
8112c750:	b8015226 	beq	r23,zero,8112cc9c <__gethex+0x644>
8112c754:	80800003 	ldbu	r2,0(r16)
8112c758:	00000206 	br	8112c764 <__gethex+0x10c>
8112c75c:	80800003 	ldbu	r2,0(r16)
8112c760:	b8011f26 	beq	r23,zero,8112cbe0 <__gethex+0x588>
8112c764:	85efc83a 	sub	r23,r16,r23
8112c768:	bdef883a 	add	r23,r23,r23
8112c76c:	bdef883a 	add	r23,r23,r23
8112c770:	05efc83a 	sub	r23,zero,r23
8112c774:	10803fcc 	andi	r2,r2,255
8112c778:	01001404 	movi	r4,80
8112c77c:	11008626 	beq	r2,r4,8112c998 <__gethex+0x340>
8112c780:	01001c04 	movi	r4,112
8112c784:	11008426 	beq	r2,r4,8112c998 <__gethex+0x340>
8112c788:	8039883a 	mov	fp,r16
8112c78c:	9c000015 	stw	r16,0(r19)
8112c790:	5000711e 	bne	r10,zero,8112c958 <__gethex+0x300>
8112c794:	e545c83a 	sub	r2,fp,r21
8112c798:	10bfffc4 	addi	r2,r2,-1
8112c79c:	010001c4 	movi	r4,7
8112c7a0:	000b883a 	mov	r5,zero
8112c7a4:	2080030e 	bge	r4,r2,8112c7b4 <__gethex+0x15c>
8112c7a8:	1005d07a 	srai	r2,r2,1
8112c7ac:	29400044 	addi	r5,r5,1
8112c7b0:	20bffd16 	blt	r4,r2,8112c7a8 <__reset+0xfb10c7a8>
8112c7b4:	d9000117 	ldw	r4,4(sp)
8112c7b8:	1125c400 	call	81125c40 <_Balloc>
8112c7bc:	10c00504 	addi	r3,r2,20
8112c7c0:	d8c00215 	stw	r3,8(sp)
8112c7c4:	1021883a 	mov	r16,r2
8112c7c8:	af01732e 	bgeu	r21,fp,8112cd98 <__gethex+0x740>
8112c7cc:	dc400303 	ldbu	r17,12(sp)
8112c7d0:	03400044 	movi	r13,1
8112c7d4:	1815883a 	mov	r10,r3
8112c7d8:	0013883a 	mov	r9,zero
8112c7dc:	0027883a 	mov	r19,zero
8112c7e0:	6d9bc83a 	sub	r13,r13,r22
8112c7e4:	02c00804 	movi	r11,32
8112c7e8:	e0bfffc3 	ldbu	r2,-1(fp)
8112c7ec:	e3bfffc4 	addi	r14,fp,-1
8112c7f0:	88803026 	beq	r17,r2,8112c8b4 <__gethex+0x25c>
8112c7f4:	9ac04526 	beq	r19,r11,8112c90c <__gethex+0x2b4>
8112c7f8:	980b883a 	mov	r5,r19
8112c7fc:	9cc00104 	addi	r19,r19,4
8112c800:	e13fffc3 	ldbu	r4,-1(fp)
8112c804:	7039883a 	mov	fp,r14
8112c808:	a109883a 	add	r4,r20,r4
8112c80c:	20800003 	ldbu	r2,0(r4)
8112c810:	108003cc 	andi	r2,r2,15
8112c814:	1144983a 	sll	r2,r2,r5
8112c818:	4892b03a 	or	r9,r9,r2
8112c81c:	af3ff236 	bltu	r21,fp,8112c7e8 <__reset+0xfb10c7e8>
8112c820:	d8c00217 	ldw	r3,8(sp)
8112c824:	50800104 	addi	r2,r10,4
8112c828:	52400015 	stw	r9,0(r10)
8112c82c:	10c5c83a 	sub	r2,r2,r3
8112c830:	1005d0ba 	srai	r2,r2,2
8112c834:	4809883a 	mov	r4,r9
8112c838:	80800415 	stw	r2,16(r16)
8112c83c:	1022917a 	slli	r17,r2,5
8112c840:	1125f4c0 	call	81125f4c <__hi0bits>
8112c844:	d8c00017 	ldw	r3,0(sp)
8112c848:	8885c83a 	sub	r2,r17,r2
8112c84c:	1c800017 	ldw	r18,0(r3)
8112c850:	9080c716 	blt	r18,r2,8112cb70 <__gethex+0x518>
8112c854:	1480e416 	blt	r2,r18,8112cbe8 <__gethex+0x590>
8112c858:	0027883a 	mov	r19,zero
8112c85c:	d8c00017 	ldw	r3,0(sp)
8112c860:	18800217 	ldw	r2,8(r3)
8112c864:	15c08d16 	blt	r2,r23,8112ca9c <__gethex+0x444>
8112c868:	d8c00017 	ldw	r3,0(sp)
8112c86c:	18800117 	ldw	r2,4(r3)
8112c870:	b880aa0e 	bge	r23,r2,8112cb1c <__gethex+0x4c4>
8112c874:	15efc83a 	sub	r23,r2,r23
8112c878:	bc80ed16 	blt	r23,r18,8112cc30 <__gethex+0x5d8>
8112c87c:	18c00317 	ldw	r3,12(r3)
8112c880:	01000084 	movi	r4,2
8112c884:	19014926 	beq	r3,r4,8112cdac <__gethex+0x754>
8112c888:	010000c4 	movi	r4,3
8112c88c:	19012e26 	beq	r3,r4,8112cd48 <__gethex+0x6f0>
8112c890:	01000044 	movi	r4,1
8112c894:	19014826 	beq	r3,r4,8112cdb8 <__gethex+0x760>
8112c898:	d9000117 	ldw	r4,4(sp)
8112c89c:	800b883a 	mov	r5,r16
8112c8a0:	1125cf00 	call	81125cf0 <_Bfree>
8112c8a4:	d8801517 	ldw	r2,84(sp)
8112c8a8:	10000015 	stw	zero,0(r2)
8112c8ac:	00801404 	movi	r2,80
8112c8b0:	00002b06 	br	8112c960 <__gethex+0x308>
8112c8b4:	735f883a 	add	r15,r14,r13
8112c8b8:	7d7fce36 	bltu	r15,r21,8112c7f4 <__reset+0xfb10c7f4>
8112c8bc:	7809883a 	mov	r4,r15
8112c8c0:	b00d883a 	mov	r6,r22
8112c8c4:	900b883a 	mov	r5,r18
8112c8c8:	da400515 	stw	r9,20(sp)
8112c8cc:	da800a15 	stw	r10,40(sp)
8112c8d0:	dac00915 	stw	r11,36(sp)
8112c8d4:	db400815 	stw	r13,32(sp)
8112c8d8:	db800615 	stw	r14,24(sp)
8112c8dc:	dbc00715 	stw	r15,28(sp)
8112c8e0:	112d0f40 	call	8112d0f4 <strncmp>
8112c8e4:	da400517 	ldw	r9,20(sp)
8112c8e8:	da800a17 	ldw	r10,40(sp)
8112c8ec:	dac00917 	ldw	r11,36(sp)
8112c8f0:	db400817 	ldw	r13,32(sp)
8112c8f4:	db800617 	ldw	r14,24(sp)
8112c8f8:	dbc00717 	ldw	r15,28(sp)
8112c8fc:	103fbd1e 	bne	r2,zero,8112c7f4 <__reset+0xfb10c7f4>
8112c900:	7839883a 	mov	fp,r15
8112c904:	af3fb836 	bltu	r21,fp,8112c7e8 <__reset+0xfb10c7e8>
8112c908:	003fc506 	br	8112c820 <__reset+0xfb10c820>
8112c90c:	04c00104 	movi	r19,4
8112c910:	52400015 	stw	r9,0(r10)
8112c914:	000b883a 	mov	r5,zero
8112c918:	54d5883a 	add	r10,r10,r19
8112c91c:	0013883a 	mov	r9,zero
8112c920:	003fb706 	br	8112c800 <__reset+0xfb10c800>
8112c924:	b00d883a 	mov	r6,r22
8112c928:	900b883a 	mov	r5,r18
8112c92c:	a809883a 	mov	r4,r21
8112c930:	112d0f40 	call	8112d0f4 <strncmp>
8112c934:	10006426 	beq	r2,zero,8112cac8 <__gethex+0x470>
8112c938:	a8800003 	ldbu	r2,0(r21)
8112c93c:	a821883a 	mov	r16,r21
8112c940:	10803fcc 	andi	r2,r2,255
8112c944:	01001404 	movi	r4,80
8112c948:	11001126 	beq	r2,r4,8112c990 <__gethex+0x338>
8112c94c:	01001c04 	movi	r4,112
8112c950:	11000f26 	beq	r2,r4,8112c990 <__gethex+0x338>
8112c954:	9c000015 	stw	r16,0(r19)
8112c958:	8800831e 	bne	r17,zero,8112cb68 <__gethex+0x510>
8112c95c:	00800184 	movi	r2,6
8112c960:	dfc01417 	ldw	ra,80(sp)
8112c964:	df001317 	ldw	fp,76(sp)
8112c968:	ddc01217 	ldw	r23,72(sp)
8112c96c:	dd801117 	ldw	r22,68(sp)
8112c970:	dd401017 	ldw	r21,64(sp)
8112c974:	dd000f17 	ldw	r20,60(sp)
8112c978:	dcc00e17 	ldw	r19,56(sp)
8112c97c:	dc800d17 	ldw	r18,52(sp)
8112c980:	dc400c17 	ldw	r17,48(sp)
8112c984:	dc000b17 	ldw	r16,44(sp)
8112c988:	dec01504 	addi	sp,sp,84
8112c98c:	f800283a 	ret
8112c990:	002f883a 	mov	r23,zero
8112c994:	02800044 	movi	r10,1
8112c998:	80800043 	ldbu	r2,1(r16)
8112c99c:	01400ac4 	movi	r5,43
8112c9a0:	11003fcc 	andi	r4,r2,255
8112c9a4:	21406e26 	beq	r4,r5,8112cb60 <__gethex+0x508>
8112c9a8:	01400b44 	movi	r5,45
8112c9ac:	21404226 	beq	r4,r5,8112cab8 <__gethex+0x460>
8112c9b0:	81400044 	addi	r5,r16,1
8112c9b4:	000d883a 	mov	r6,zero
8112c9b8:	10803fcc 	andi	r2,r2,255
8112c9bc:	a085883a 	add	r2,r20,r2
8112c9c0:	11000003 	ldbu	r4,0(r2)
8112c9c4:	03000604 	movi	r12,24
8112c9c8:	20bfffc4 	addi	r2,r4,-1
8112c9cc:	10803fcc 	andi	r2,r2,255
8112c9d0:	60bf6d36 	bltu	r12,r2,8112c788 <__reset+0xfb10c788>
8112c9d4:	2ac00043 	ldbu	r11,1(r5)
8112c9d8:	20803fcc 	andi	r2,r4,255
8112c9dc:	01204574 	movhi	r4,33045
8112c9e0:	21274d04 	addi	r4,r4,-25292
8112c9e4:	22c9883a 	add	r4,r4,r11
8112c9e8:	23400003 	ldbu	r13,0(r4)
8112c9ec:	10bffc04 	addi	r2,r2,-16
8112c9f0:	29400044 	addi	r5,r5,1
8112c9f4:	693fffc4 	addi	r4,r13,-1
8112c9f8:	21003fcc 	andi	r4,r4,255
8112c9fc:	6b403fcc 	andi	r13,r13,255
8112ca00:	61000b36 	bltu	r12,r4,8112ca30 <__gethex+0x3d8>
8112ca04:	29400044 	addi	r5,r5,1
8112ca08:	29000003 	ldbu	r4,0(r5)
8112ca0c:	108002a4 	muli	r2,r2,10
8112ca10:	a109883a 	add	r4,r20,r4
8112ca14:	22c00003 	ldbu	r11,0(r4)
8112ca18:	1345883a 	add	r2,r2,r13
8112ca1c:	10bffc04 	addi	r2,r2,-16
8112ca20:	593fffc4 	addi	r4,r11,-1
8112ca24:	21003fcc 	andi	r4,r4,255
8112ca28:	5b403fcc 	andi	r13,r11,255
8112ca2c:	613ff52e 	bgeu	r12,r4,8112ca04 <__reset+0xfb10ca04>
8112ca30:	30000126 	beq	r6,zero,8112ca38 <__gethex+0x3e0>
8112ca34:	0085c83a 	sub	r2,zero,r2
8112ca38:	8039883a 	mov	fp,r16
8112ca3c:	b8af883a 	add	r23,r23,r2
8112ca40:	2821883a 	mov	r16,r5
8112ca44:	003f5106 	br	8112c78c <__reset+0xfb10c78c>
8112ca48:	80800217 	ldw	r2,8(r16)
8112ca4c:	e080f00e 	bge	fp,r2,8112ce10 <__gethex+0x7b8>
8112ca50:	e007883a 	mov	r3,fp
8112ca54:	18800144 	addi	r2,r3,5
8112ca58:	1085883a 	add	r2,r2,r2
8112ca5c:	18c00044 	addi	r3,r3,1
8112ca60:	1085883a 	add	r2,r2,r2
8112ca64:	8085883a 	add	r2,r16,r2
8112ca68:	80c00415 	stw	r3,16(r16)
8112ca6c:	01000044 	movi	r4,1
8112ca70:	11000015 	stw	r4,0(r2)
8112ca74:	00800084 	movi	r2,2
8112ca78:	8880d826 	beq	r17,r2,8112cddc <__gethex+0x784>
8112ca7c:	e0c0ac0e 	bge	fp,r3,8112cd30 <__gethex+0x6d8>
8112ca80:	01400044 	movi	r5,1
8112ca84:	8009883a 	mov	r4,r16
8112ca88:	112c5580 	call	8112c558 <rshift>
8112ca8c:	d8c00017 	ldw	r3,0(sp)
8112ca90:	bdc00044 	addi	r23,r23,1
8112ca94:	18800217 	ldw	r2,8(r3)
8112ca98:	15c0a70e 	bge	r2,r23,8112cd38 <__gethex+0x6e0>
8112ca9c:	d9000117 	ldw	r4,4(sp)
8112caa0:	800b883a 	mov	r5,r16
8112caa4:	1125cf00 	call	81125cf0 <_Bfree>
8112caa8:	d9001517 	ldw	r4,84(sp)
8112caac:	008028c4 	movi	r2,163
8112cab0:	20000015 	stw	zero,0(r4)
8112cab4:	003faa06 	br	8112c960 <__reset+0xfb10c960>
8112cab8:	01800044 	movi	r6,1
8112cabc:	80800083 	ldbu	r2,2(r16)
8112cac0:	81400084 	addi	r5,r16,2
8112cac4:	003fbc06 	br	8112c9b8 <__reset+0xfb10c9b8>
8112cac8:	ada1883a 	add	r16,r21,r22
8112cacc:	81000003 	ldbu	r4,0(r16)
8112cad0:	21403fcc 	andi	r5,r4,255
8112cad4:	a145883a 	add	r2,r20,r5
8112cad8:	10800003 	ldbu	r2,0(r2)
8112cadc:	11803fcc 	andi	r6,r2,255
8112cae0:	30004f26 	beq	r6,zero,8112cc20 <__gethex+0x5c8>
8112cae4:	00c00c04 	movi	r3,48
8112cae8:	802b883a 	mov	r21,r16
8112caec:	28c0061e 	bne	r5,r3,8112cb08 <__gethex+0x4b0>
8112caf0:	2809883a 	mov	r4,r5
8112caf4:	ad400044 	addi	r21,r21,1
8112caf8:	a8800003 	ldbu	r2,0(r21)
8112cafc:	113ffd26 	beq	r2,r4,8112caf4 <__reset+0xfb10caf4>
8112cb00:	a085883a 	add	r2,r20,r2
8112cb04:	10800003 	ldbu	r2,0(r2)
8112cb08:	10803fcc 	andi	r2,r2,255
8112cb0c:	1015003a 	cmpeq	r10,r2,zero
8112cb10:	802f883a 	mov	r23,r16
8112cb14:	04400044 	movi	r17,1
8112cb18:	003eff06 	br	8112c718 <__reset+0xfb10c718>
8112cb1c:	04400044 	movi	r17,1
8112cb20:	98000926 	beq	r19,zero,8112cb48 <__gethex+0x4f0>
8112cb24:	d8c00017 	ldw	r3,0(sp)
8112cb28:	18800317 	ldw	r2,12(r3)
8112cb2c:	00c00084 	movi	r3,2
8112cb30:	10c06826 	beq	r2,r3,8112ccd4 <__gethex+0x67c>
8112cb34:	00c000c4 	movi	r3,3
8112cb38:	10c06a26 	beq	r2,r3,8112cce4 <__gethex+0x68c>
8112cb3c:	00c00044 	movi	r3,1
8112cb40:	10c08d26 	beq	r2,r3,8112cd78 <__gethex+0x720>
8112cb44:	8c400414 	ori	r17,r17,16
8112cb48:	d9001517 	ldw	r4,84(sp)
8112cb4c:	d8c00417 	ldw	r3,16(sp)
8112cb50:	8805883a 	mov	r2,r17
8112cb54:	24000015 	stw	r16,0(r4)
8112cb58:	1dc00015 	stw	r23,0(r3)
8112cb5c:	003f8006 	br	8112c960 <__reset+0xfb10c960>
8112cb60:	000d883a 	mov	r6,zero
8112cb64:	003fd506 	br	8112cabc <__reset+0xfb10cabc>
8112cb68:	0005883a 	mov	r2,zero
8112cb6c:	003f7c06 	br	8112c960 <__reset+0xfb10c960>
8112cb70:	14a3c83a 	sub	r17,r2,r18
8112cb74:	880b883a 	mov	r5,r17
8112cb78:	8009883a 	mov	r4,r16
8112cb7c:	1126c100 	call	81126c10 <__any_on>
8112cb80:	10002926 	beq	r2,zero,8112cc28 <__gethex+0x5d0>
8112cb84:	897fffc4 	addi	r5,r17,-1
8112cb88:	2807d17a 	srai	r3,r5,5
8112cb8c:	d8800217 	ldw	r2,8(sp)
8112cb90:	290007cc 	andi	r4,r5,31
8112cb94:	18c7883a 	add	r3,r3,r3
8112cb98:	18c7883a 	add	r3,r3,r3
8112cb9c:	04c00044 	movi	r19,1
8112cba0:	10c7883a 	add	r3,r2,r3
8112cba4:	9908983a 	sll	r4,r19,r4
8112cba8:	18c00017 	ldw	r3,0(r3)
8112cbac:	20c6703a 	and	r3,r4,r3
8112cbb0:	18000626 	beq	r3,zero,8112cbcc <__gethex+0x574>
8112cbb4:	99407b0e 	bge	r19,r5,8112cda4 <__gethex+0x74c>
8112cbb8:	897fff84 	addi	r5,r17,-2
8112cbbc:	8009883a 	mov	r4,r16
8112cbc0:	1126c100 	call	81126c10 <__any_on>
8112cbc4:	10007726 	beq	r2,zero,8112cda4 <__gethex+0x74c>
8112cbc8:	04c000c4 	movi	r19,3
8112cbcc:	880b883a 	mov	r5,r17
8112cbd0:	8009883a 	mov	r4,r16
8112cbd4:	112c5580 	call	8112c558 <rshift>
8112cbd8:	bc6f883a 	add	r23,r23,r17
8112cbdc:	003f1f06 	br	8112c85c <__reset+0xfb10c85c>
8112cbe0:	002f883a 	mov	r23,zero
8112cbe4:	003ee306 	br	8112c774 <__reset+0xfb10c774>
8112cbe8:	d9000117 	ldw	r4,4(sp)
8112cbec:	90a3c83a 	sub	r17,r18,r2
8112cbf0:	800b883a 	mov	r5,r16
8112cbf4:	880d883a 	mov	r6,r17
8112cbf8:	11263f00 	call	811263f0 <__lshift>
8112cbfc:	10c00504 	addi	r3,r2,20
8112cc00:	1021883a 	mov	r16,r2
8112cc04:	bc6fc83a 	sub	r23,r23,r17
8112cc08:	d8c00215 	stw	r3,8(sp)
8112cc0c:	0027883a 	mov	r19,zero
8112cc10:	003f1206 	br	8112c85c <__reset+0xfb10c85c>
8112cc14:	1d400084 	addi	r21,r3,2
8112cc18:	0023883a 	mov	r17,zero
8112cc1c:	003eb406 	br	8112c6f0 <__reset+0xfb10c6f0>
8112cc20:	2005883a 	mov	r2,r4
8112cc24:	003f4606 	br	8112c940 <__reset+0xfb10c940>
8112cc28:	0027883a 	mov	r19,zero
8112cc2c:	003fe706 	br	8112cbcc <__reset+0xfb10cbcc>
8112cc30:	bc7fffc4 	addi	r17,r23,-1
8112cc34:	9800421e 	bne	r19,zero,8112cd40 <__gethex+0x6e8>
8112cc38:	88000426 	beq	r17,zero,8112cc4c <__gethex+0x5f4>
8112cc3c:	880b883a 	mov	r5,r17
8112cc40:	8009883a 	mov	r4,r16
8112cc44:	1126c100 	call	81126c10 <__any_on>
8112cc48:	1027883a 	mov	r19,r2
8112cc4c:	8805d17a 	srai	r2,r17,5
8112cc50:	d8c00217 	ldw	r3,8(sp)
8112cc54:	8c4007cc 	andi	r17,r17,31
8112cc58:	1085883a 	add	r2,r2,r2
8112cc5c:	1085883a 	add	r2,r2,r2
8112cc60:	1885883a 	add	r2,r3,r2
8112cc64:	00c00044 	movi	r3,1
8112cc68:	1c62983a 	sll	r17,r3,r17
8112cc6c:	10800017 	ldw	r2,0(r2)
8112cc70:	8884703a 	and	r2,r17,r2
8112cc74:	10000126 	beq	r2,zero,8112cc7c <__gethex+0x624>
8112cc78:	9cc00094 	ori	r19,r19,2
8112cc7c:	b80b883a 	mov	r5,r23
8112cc80:	8009883a 	mov	r4,r16
8112cc84:	112c5580 	call	8112c558 <rshift>
8112cc88:	d8c00017 	ldw	r3,0(sp)
8112cc8c:	95e5c83a 	sub	r18,r18,r23
8112cc90:	04400084 	movi	r17,2
8112cc94:	1dc00117 	ldw	r23,4(r3)
8112cc98:	003fa106 	br	8112cb20 <__reset+0xfb10cb20>
8112cc9c:	85af883a 	add	r23,r16,r22
8112cca0:	b8800003 	ldbu	r2,0(r23)
8112cca4:	b821883a 	mov	r16,r23
8112cca8:	11003fcc 	andi	r4,r2,255
8112ccac:	a109883a 	add	r4,r20,r4
8112ccb0:	21000003 	ldbu	r4,0(r4)
8112ccb4:	203eaa26 	beq	r4,zero,8112c760 <__reset+0xfb10c760>
8112ccb8:	84000044 	addi	r16,r16,1
8112ccbc:	80800003 	ldbu	r2,0(r16)
8112ccc0:	11003fcc 	andi	r4,r2,255
8112ccc4:	a109883a 	add	r4,r20,r4
8112ccc8:	21000003 	ldbu	r4,0(r4)
8112cccc:	203ffa1e 	bne	r4,zero,8112ccb8 <__reset+0xfb10ccb8>
8112ccd0:	003ea306 	br	8112c760 <__reset+0xfb10c760>
8112ccd4:	d9001617 	ldw	r4,88(sp)
8112ccd8:	00800044 	movi	r2,1
8112ccdc:	1109c83a 	sub	r4,r2,r4
8112cce0:	d9001615 	stw	r4,88(sp)
8112cce4:	d8801617 	ldw	r2,88(sp)
8112cce8:	103f9626 	beq	r2,zero,8112cb44 <__reset+0xfb10cb44>
8112ccec:	87000417 	ldw	fp,16(r16)
8112ccf0:	d9800217 	ldw	r6,8(sp)
8112ccf4:	013fffc4 	movi	r4,-1
8112ccf8:	e727883a 	add	r19,fp,fp
8112ccfc:	9ce7883a 	add	r19,r19,r19
8112cd00:	3005883a 	mov	r2,r6
8112cd04:	34cb883a 	add	r5,r6,r19
8112cd08:	00000306 	br	8112cd18 <__gethex+0x6c0>
8112cd0c:	10000015 	stw	zero,0(r2)
8112cd10:	10800104 	addi	r2,r2,4
8112cd14:	117f4c2e 	bgeu	r2,r5,8112ca48 <__reset+0xfb10ca48>
8112cd18:	10c00017 	ldw	r3,0(r2)
8112cd1c:	193ffb26 	beq	r3,r4,8112cd0c <__reset+0xfb10cd0c>
8112cd20:	18c00044 	addi	r3,r3,1
8112cd24:	10c00015 	stw	r3,0(r2)
8112cd28:	00800084 	movi	r2,2
8112cd2c:	88802b26 	beq	r17,r2,8112cddc <__gethex+0x784>
8112cd30:	948007cc 	andi	r18,r18,31
8112cd34:	90002f1e 	bne	r18,zero,8112cdf4 <__gethex+0x79c>
8112cd38:	04400844 	movi	r17,33
8112cd3c:	003f8206 	br	8112cb48 <__reset+0xfb10cb48>
8112cd40:	04c00044 	movi	r19,1
8112cd44:	003fc106 	br	8112cc4c <__reset+0xfb10cc4c>
8112cd48:	d8c01617 	ldw	r3,88(sp)
8112cd4c:	183ed226 	beq	r3,zero,8112c898 <__reset+0xfb10c898>
8112cd50:	d8c00417 	ldw	r3,16(sp)
8112cd54:	d9001517 	ldw	r4,84(sp)
8112cd58:	18800015 	stw	r2,0(r3)
8112cd5c:	d8c00217 	ldw	r3,8(sp)
8112cd60:	00800044 	movi	r2,1
8112cd64:	80800415 	stw	r2,16(r16)
8112cd68:	18800015 	stw	r2,0(r3)
8112cd6c:	24000015 	stw	r16,0(r4)
8112cd70:	00801884 	movi	r2,98
8112cd74:	003efa06 	br	8112c960 <__reset+0xfb10c960>
8112cd78:	9880008c 	andi	r2,r19,2
8112cd7c:	103f7126 	beq	r2,zero,8112cb44 <__reset+0xfb10cb44>
8112cd80:	d8c00217 	ldw	r3,8(sp)
8112cd84:	18800017 	ldw	r2,0(r3)
8112cd88:	9884b03a 	or	r2,r19,r2
8112cd8c:	1080004c 	andi	r2,r2,1
8112cd90:	103fd61e 	bne	r2,zero,8112ccec <__reset+0xfb10ccec>
8112cd94:	003f6b06 	br	8112cb44 <__reset+0xfb10cb44>
8112cd98:	da800217 	ldw	r10,8(sp)
8112cd9c:	0013883a 	mov	r9,zero
8112cda0:	003e9f06 	br	8112c820 <__reset+0xfb10c820>
8112cda4:	04c00084 	movi	r19,2
8112cda8:	003f8806 	br	8112cbcc <__reset+0xfb10cbcc>
8112cdac:	d9001617 	ldw	r4,88(sp)
8112cdb0:	203fe726 	beq	r4,zero,8112cd50 <__reset+0xfb10cd50>
8112cdb4:	003eb806 	br	8112c898 <__reset+0xfb10c898>
8112cdb8:	95feb71e 	bne	r18,r23,8112c898 <__reset+0xfb10c898>
8112cdbc:	1cbfe40e 	bge	r3,r18,8112cd50 <__reset+0xfb10cd50>
8112cdc0:	917fffc4 	addi	r5,r18,-1
8112cdc4:	8009883a 	mov	r4,r16
8112cdc8:	1126c100 	call	81126c10 <__any_on>
8112cdcc:	103eb226 	beq	r2,zero,8112c898 <__reset+0xfb10c898>
8112cdd0:	d8c00017 	ldw	r3,0(sp)
8112cdd4:	18800117 	ldw	r2,4(r3)
8112cdd8:	003fdd06 	br	8112cd50 <__reset+0xfb10cd50>
8112cddc:	d8c00017 	ldw	r3,0(sp)
8112cde0:	18800017 	ldw	r2,0(r3)
8112cde4:	10bfffc4 	addi	r2,r2,-1
8112cde8:	90801c26 	beq	r18,r2,8112ce5c <__gethex+0x804>
8112cdec:	04400884 	movi	r17,34
8112cdf0:	003f5506 	br	8112cb48 <__reset+0xfb10cb48>
8112cdf4:	34c5883a 	add	r2,r6,r19
8112cdf8:	113fff17 	ldw	r4,-4(r2)
8112cdfc:	1125f4c0 	call	81125f4c <__hi0bits>
8112ce00:	00c00804 	movi	r3,32
8112ce04:	1ca5c83a 	sub	r18,r3,r18
8112ce08:	14bfcb0e 	bge	r2,r18,8112cd38 <__reset+0xfb10cd38>
8112ce0c:	003f1c06 	br	8112ca80 <__reset+0xfb10ca80>
8112ce10:	81400117 	ldw	r5,4(r16)
8112ce14:	d9000117 	ldw	r4,4(sp)
8112ce18:	29400044 	addi	r5,r5,1
8112ce1c:	1125c400 	call	81125c40 <_Balloc>
8112ce20:	81800417 	ldw	r6,16(r16)
8112ce24:	81400304 	addi	r5,r16,12
8112ce28:	11000304 	addi	r4,r2,12
8112ce2c:	31800084 	addi	r6,r6,2
8112ce30:	318d883a 	add	r6,r6,r6
8112ce34:	318d883a 	add	r6,r6,r6
8112ce38:	1029883a 	mov	r20,r2
8112ce3c:	111ba100 	call	8111ba10 <memcpy>
8112ce40:	d9000117 	ldw	r4,4(sp)
8112ce44:	800b883a 	mov	r5,r16
8112ce48:	a021883a 	mov	r16,r20
8112ce4c:	1125cf00 	call	81125cf0 <_Bfree>
8112ce50:	a0c00417 	ldw	r3,16(r20)
8112ce54:	a1800504 	addi	r6,r20,20
8112ce58:	003efe06 	br	8112ca54 <__reset+0xfb10ca54>
8112ce5c:	9005d17a 	srai	r2,r18,5
8112ce60:	944007cc 	andi	r17,r18,31
8112ce64:	1085883a 	add	r2,r2,r2
8112ce68:	1085883a 	add	r2,r2,r2
8112ce6c:	3087883a 	add	r3,r6,r2
8112ce70:	00800044 	movi	r2,1
8112ce74:	1462983a 	sll	r17,r2,r17
8112ce78:	18800017 	ldw	r2,0(r3)
8112ce7c:	8884703a 	and	r2,r17,r2
8112ce80:	1022c03a 	cmpne	r17,r2,zero
8112ce84:	00800884 	movi	r2,34
8112ce88:	1463c83a 	sub	r17,r2,r17
8112ce8c:	003f2e06 	br	8112cb48 <__reset+0xfb10cb48>

8112ce90 <__hexnan>:
8112ce90:	defff904 	addi	sp,sp,-28
8112ce94:	de00012e 	bgeu	sp,et,8112ce9c <__hexnan+0xc>
8112ce98:	003b68fa 	trap	3
8112ce9c:	dc800215 	stw	r18,8(sp)
8112cea0:	2c800017 	ldw	r18,0(r5)
8112cea4:	dfc00615 	stw	ra,24(sp)
8112cea8:	dd400515 	stw	r21,20(sp)
8112ceac:	901fd17a 	srai	r15,r18,5
8112ceb0:	dd000415 	stw	r20,16(sp)
8112ceb4:	dcc00315 	stw	r19,12(sp)
8112ceb8:	7bdf883a 	add	r15,r15,r15
8112cebc:	7bdf883a 	add	r15,r15,r15
8112cec0:	dc400115 	stw	r17,4(sp)
8112cec4:	dc000015 	stw	r16,0(sp)
8112cec8:	948007cc 	andi	r18,r18,31
8112cecc:	33df883a 	add	r15,r6,r15
8112ced0:	90000126 	beq	r18,zero,8112ced8 <__hexnan+0x48>
8112ced4:	7bc00104 	addi	r15,r15,4
8112ced8:	22000017 	ldw	r8,0(r4)
8112cedc:	7affff04 	addi	r11,r15,-4
8112cee0:	03a04574 	movhi	r14,33045
8112cee4:	783fff15 	stw	zero,-4(r15)
8112cee8:	581b883a 	mov	r13,r11
8112ceec:	580b883a 	mov	r5,r11
8112cef0:	000f883a 	mov	r7,zero
8112cef4:	003f883a 	mov	ra,zero
8112cef8:	0019883a 	mov	r12,zero
8112cefc:	73a74d04 	addi	r14,r14,-25292
8112cf00:	04400204 	movi	r17,8
8112cf04:	04000804 	movi	r16,32
8112cf08:	04c001c4 	movi	r19,7
8112cf0c:	42000044 	addi	r8,r8,1
8112cf10:	40c00003 	ldbu	r3,0(r8)
8112cf14:	18001d26 	beq	r3,zero,8112cf8c <__hexnan+0xfc>
8112cf18:	70c5883a 	add	r2,r14,r3
8112cf1c:	10800003 	ldbu	r2,0(r2)
8112cf20:	12403fcc 	andi	r9,r2,255
8112cf24:	4800301e 	bne	r9,zero,8112cfe8 <__hexnan+0x158>
8112cf28:	80c04236 	bltu	r16,r3,8112d034 <__hexnan+0x1a4>
8112cf2c:	fb3ff70e 	bge	ra,r12,8112cf0c <__reset+0xfb10cf0c>
8112cf30:	2b40112e 	bgeu	r5,r13,8112cf78 <__hexnan+0xe8>
8112cf34:	99c01016 	blt	r19,r7,8112cf78 <__hexnan+0xe8>
8112cf38:	89e9c83a 	sub	r20,r17,r7
8112cf3c:	a529883a 	add	r20,r20,r20
8112cf40:	2a800017 	ldw	r10,0(r5)
8112cf44:	a529883a 	add	r20,r20,r20
8112cf48:	852bc83a 	sub	r21,r16,r20
8112cf4c:	28c00104 	addi	r3,r5,4
8112cf50:	2805883a 	mov	r2,r5
8112cf54:	19c00017 	ldw	r7,0(r3)
8112cf58:	10800104 	addi	r2,r2,4
8112cf5c:	18c00104 	addi	r3,r3,4
8112cf60:	3d52983a 	sll	r9,r7,r21
8112cf64:	4a92b03a 	or	r9,r9,r10
8112cf68:	3d14d83a 	srl	r10,r7,r20
8112cf6c:	127fff15 	stw	r9,-4(r2)
8112cf70:	1abfff15 	stw	r10,-4(r3)
8112cf74:	137ff736 	bltu	r2,r13,8112cf54 <__reset+0xfb10cf54>
8112cf78:	31402836 	bltu	r6,r5,8112d01c <__hexnan+0x18c>
8112cf7c:	42000044 	addi	r8,r8,1
8112cf80:	40c00003 	ldbu	r3,0(r8)
8112cf84:	01c00204 	movi	r7,8
8112cf88:	183fe31e 	bne	r3,zero,8112cf18 <__reset+0xfb10cf18>
8112cf8c:	60002b26 	beq	r12,zero,8112d03c <__hexnan+0x1ac>
8112cf90:	2b40022e 	bgeu	r5,r13,8112cf9c <__hexnan+0x10c>
8112cf94:	008001c4 	movi	r2,7
8112cf98:	11c0430e 	bge	r2,r7,8112d0a8 <__hexnan+0x218>
8112cf9c:	3140312e 	bgeu	r6,r5,8112d064 <__hexnan+0x1d4>
8112cfa0:	3007883a 	mov	r3,r6
8112cfa4:	29000017 	ldw	r4,0(r5)
8112cfa8:	18800104 	addi	r2,r3,4
8112cfac:	29400104 	addi	r5,r5,4
8112cfb0:	19000015 	stw	r4,0(r3)
8112cfb4:	1007883a 	mov	r3,r2
8112cfb8:	597ffa2e 	bgeu	r11,r5,8112cfa4 <__reset+0xfb10cfa4>
8112cfbc:	10000015 	stw	zero,0(r2)
8112cfc0:	10800104 	addi	r2,r2,4
8112cfc4:	58bffd2e 	bgeu	r11,r2,8112cfbc <__reset+0xfb10cfbc>
8112cfc8:	78bfff17 	ldw	r2,-4(r15)
8112cfcc:	1000041e 	bne	r2,zero,8112cfe0 <__hexnan+0x150>
8112cfd0:	32c02d26 	beq	r6,r11,8112d088 <__hexnan+0x1f8>
8112cfd4:	5affff04 	addi	r11,r11,-4
8112cfd8:	58800017 	ldw	r2,0(r11)
8112cfdc:	103ffc26 	beq	r2,zero,8112cfd0 <__reset+0xfb10cfd0>
8112cfe0:	00800144 	movi	r2,5
8112cfe4:	00001606 	br	8112d040 <__hexnan+0x1b0>
8112cfe8:	39c00044 	addi	r7,r7,1
8112cfec:	63000044 	addi	r12,r12,1
8112cff0:	89c0040e 	bge	r17,r7,8112d004 <__hexnan+0x174>
8112cff4:	317fc52e 	bgeu	r6,r5,8112cf0c <__reset+0xfb10cf0c>
8112cff8:	283fff15 	stw	zero,-4(r5)
8112cffc:	01c00044 	movi	r7,1
8112d000:	297fff04 	addi	r5,r5,-4
8112d004:	28c00017 	ldw	r3,0(r5)
8112d008:	108003cc 	andi	r2,r2,15
8112d00c:	1806913a 	slli	r3,r3,4
8112d010:	1884b03a 	or	r2,r3,r2
8112d014:	28800015 	stw	r2,0(r5)
8112d018:	003fbc06 	br	8112cf0c <__reset+0xfb10cf0c>
8112d01c:	2b7fff04 	addi	r13,r5,-4
8112d020:	283fff15 	stw	zero,-4(r5)
8112d024:	603f883a 	mov	ra,r12
8112d028:	680b883a 	mov	r5,r13
8112d02c:	000f883a 	mov	r7,zero
8112d030:	003fb606 	br	8112cf0c <__reset+0xfb10cf0c>
8112d034:	00800a44 	movi	r2,41
8112d038:	18801726 	beq	r3,r2,8112d098 <__hexnan+0x208>
8112d03c:	00800104 	movi	r2,4
8112d040:	dfc00617 	ldw	ra,24(sp)
8112d044:	dd400517 	ldw	r21,20(sp)
8112d048:	dd000417 	ldw	r20,16(sp)
8112d04c:	dcc00317 	ldw	r19,12(sp)
8112d050:	dc800217 	ldw	r18,8(sp)
8112d054:	dc400117 	ldw	r17,4(sp)
8112d058:	dc000017 	ldw	r16,0(sp)
8112d05c:	dec00704 	addi	sp,sp,28
8112d060:	f800283a 	ret
8112d064:	903fd826 	beq	r18,zero,8112cfc8 <__reset+0xfb10cfc8>
8112d068:	00c00804 	movi	r3,32
8112d06c:	1ca5c83a 	sub	r18,r3,r18
8112d070:	00ffffc4 	movi	r3,-1
8112d074:	78bfff17 	ldw	r2,-4(r15)
8112d078:	1c86d83a 	srl	r3,r3,r18
8112d07c:	1884703a 	and	r2,r3,r2
8112d080:	78bfff15 	stw	r2,-4(r15)
8112d084:	003fd106 	br	8112cfcc <__reset+0xfb10cfcc>
8112d088:	00800044 	movi	r2,1
8112d08c:	58800015 	stw	r2,0(r11)
8112d090:	00800144 	movi	r2,5
8112d094:	003fea06 	br	8112d040 <__reset+0xfb10d040>
8112d098:	42000044 	addi	r8,r8,1
8112d09c:	22000015 	stw	r8,0(r4)
8112d0a0:	603fbb1e 	bne	r12,zero,8112cf90 <__reset+0xfb10cf90>
8112d0a4:	003fe506 	br	8112d03c <__reset+0xfb10d03c>
8112d0a8:	02400204 	movi	r9,8
8112d0ac:	49d3c83a 	sub	r9,r9,r7
8112d0b0:	4a53883a 	add	r9,r9,r9
8112d0b4:	2a000017 	ldw	r8,0(r5)
8112d0b8:	4a53883a 	add	r9,r9,r9
8112d0bc:	02800804 	movi	r10,32
8112d0c0:	5255c83a 	sub	r10,r10,r9
8112d0c4:	28c00104 	addi	r3,r5,4
8112d0c8:	2805883a 	mov	r2,r5
8112d0cc:	19c00017 	ldw	r7,0(r3)
8112d0d0:	10800104 	addi	r2,r2,4
8112d0d4:	18c00104 	addi	r3,r3,4
8112d0d8:	3a88983a 	sll	r4,r7,r10
8112d0dc:	2208b03a 	or	r4,r4,r8
8112d0e0:	3a50d83a 	srl	r8,r7,r9
8112d0e4:	113fff15 	stw	r4,-4(r2)
8112d0e8:	1a3fff15 	stw	r8,-4(r3)
8112d0ec:	137ff736 	bltu	r2,r13,8112d0cc <__reset+0xfb10d0cc>
8112d0f0:	003faa06 	br	8112cf9c <__reset+0xfb10cf9c>

8112d0f4 <strncmp>:
8112d0f4:	30003126 	beq	r6,zero,8112d1bc <strncmp+0xc8>
8112d0f8:	2144b03a 	or	r2,r4,r5
8112d0fc:	108000cc 	andi	r2,r2,3
8112d100:	10001e1e 	bne	r2,zero,8112d17c <strncmp+0x88>
8112d104:	024000c4 	movi	r9,3
8112d108:	49801c2e 	bgeu	r9,r6,8112d17c <strncmp+0x88>
8112d10c:	20800017 	ldw	r2,0(r4)
8112d110:	28c00017 	ldw	r3,0(r5)
8112d114:	10c0191e 	bne	r2,r3,8112d17c <strncmp+0x88>
8112d118:	31bfff04 	addi	r6,r6,-4
8112d11c:	30002726 	beq	r6,zero,8112d1bc <strncmp+0xc8>
8112d120:	02ffbff4 	movhi	r11,65279
8112d124:	5affbfc4 	addi	r11,r11,-257
8112d128:	0086303a 	nor	r3,zero,r2
8112d12c:	02a02074 	movhi	r10,32897
8112d130:	12c5883a 	add	r2,r2,r11
8112d134:	52a02004 	addi	r10,r10,-32640
8112d138:	10c4703a 	and	r2,r2,r3
8112d13c:	1284703a 	and	r2,r2,r10
8112d140:	10000b26 	beq	r2,zero,8112d170 <strncmp+0x7c>
8112d144:	00001d06 	br	8112d1bc <strncmp+0xc8>
8112d148:	20c00017 	ldw	r3,0(r4)
8112d14c:	29c00017 	ldw	r7,0(r5)
8112d150:	1ad1883a 	add	r8,r3,r11
8112d154:	00c4303a 	nor	r2,zero,r3
8112d158:	4084703a 	and	r2,r8,r2
8112d15c:	1284703a 	and	r2,r2,r10
8112d160:	19c0061e 	bne	r3,r7,8112d17c <strncmp+0x88>
8112d164:	31bfff04 	addi	r6,r6,-4
8112d168:	30001426 	beq	r6,zero,8112d1bc <strncmp+0xc8>
8112d16c:	1000131e 	bne	r2,zero,8112d1bc <strncmp+0xc8>
8112d170:	21000104 	addi	r4,r4,4
8112d174:	29400104 	addi	r5,r5,4
8112d178:	49bff336 	bltu	r9,r6,8112d148 <__reset+0xfb10d148>
8112d17c:	28800007 	ldb	r2,0(r5)
8112d180:	20c00007 	ldb	r3,0(r4)
8112d184:	31bfffc4 	addi	r6,r6,-1
8112d188:	10c0081e 	bne	r2,r3,8112d1ac <strncmp+0xb8>
8112d18c:	30000b26 	beq	r6,zero,8112d1bc <strncmp+0xc8>
8112d190:	10000a26 	beq	r2,zero,8112d1bc <strncmp+0xc8>
8112d194:	21000044 	addi	r4,r4,1
8112d198:	29400044 	addi	r5,r5,1
8112d19c:	20800007 	ldb	r2,0(r4)
8112d1a0:	28c00007 	ldb	r3,0(r5)
8112d1a4:	31bfffc4 	addi	r6,r6,-1
8112d1a8:	10fff826 	beq	r2,r3,8112d18c <__reset+0xfb10d18c>
8112d1ac:	20800003 	ldbu	r2,0(r4)
8112d1b0:	28c00003 	ldbu	r3,0(r5)
8112d1b4:	10c5c83a 	sub	r2,r2,r3
8112d1b8:	f800283a 	ret
8112d1bc:	0005883a 	mov	r2,zero
8112d1c0:	f800283a 	ret

8112d1c4 <_wcrtomb_r>:
8112d1c4:	defff604 	addi	sp,sp,-40
8112d1c8:	00a04574 	movhi	r2,33045
8112d1cc:	de00012e 	bgeu	sp,et,8112d1d4 <_wcrtomb_r+0x10>
8112d1d0:	003b68fa 	trap	3
8112d1d4:	10b08704 	addi	r2,r2,-15844
8112d1d8:	dc800815 	stw	r18,32(sp)
8112d1dc:	dc400715 	stw	r17,28(sp)
8112d1e0:	dc000615 	stw	r16,24(sp)
8112d1e4:	dfc00915 	stw	ra,36(sp)
8112d1e8:	2021883a 	mov	r16,r4
8112d1ec:	3823883a 	mov	r17,r7
8112d1f0:	14800017 	ldw	r18,0(r2)
8112d1f4:	28001426 	beq	r5,zero,8112d248 <_wcrtomb_r+0x84>
8112d1f8:	d9400415 	stw	r5,16(sp)
8112d1fc:	d9800515 	stw	r6,20(sp)
8112d200:	11256f40 	call	811256f4 <__locale_charset>
8112d204:	d9800517 	ldw	r6,20(sp)
8112d208:	d9400417 	ldw	r5,16(sp)
8112d20c:	100f883a 	mov	r7,r2
8112d210:	dc400015 	stw	r17,0(sp)
8112d214:	8009883a 	mov	r4,r16
8112d218:	903ee83a 	callr	r18
8112d21c:	00ffffc4 	movi	r3,-1
8112d220:	10c0031e 	bne	r2,r3,8112d230 <_wcrtomb_r+0x6c>
8112d224:	88000015 	stw	zero,0(r17)
8112d228:	00c02284 	movi	r3,138
8112d22c:	80c00015 	stw	r3,0(r16)
8112d230:	dfc00917 	ldw	ra,36(sp)
8112d234:	dc800817 	ldw	r18,32(sp)
8112d238:	dc400717 	ldw	r17,28(sp)
8112d23c:	dc000617 	ldw	r16,24(sp)
8112d240:	dec00a04 	addi	sp,sp,40
8112d244:	f800283a 	ret
8112d248:	11256f40 	call	811256f4 <__locale_charset>
8112d24c:	100f883a 	mov	r7,r2
8112d250:	dc400015 	stw	r17,0(sp)
8112d254:	000d883a 	mov	r6,zero
8112d258:	d9400104 	addi	r5,sp,4
8112d25c:	8009883a 	mov	r4,r16
8112d260:	903ee83a 	callr	r18
8112d264:	003fed06 	br	8112d21c <__reset+0xfb10d21c>

8112d268 <wcrtomb>:
8112d268:	defff604 	addi	sp,sp,-40
8112d26c:	00a04574 	movhi	r2,33045
8112d270:	de00012e 	bgeu	sp,et,8112d278 <wcrtomb+0x10>
8112d274:	003b68fa 	trap	3
8112d278:	10b08204 	addi	r2,r2,-15864
8112d27c:	dc800615 	stw	r18,24(sp)
8112d280:	dc400515 	stw	r17,20(sp)
8112d284:	dfc00915 	stw	ra,36(sp)
8112d288:	dd000815 	stw	r20,32(sp)
8112d28c:	dcc00715 	stw	r19,28(sp)
8112d290:	dc000415 	stw	r16,16(sp)
8112d294:	3025883a 	mov	r18,r6
8112d298:	14400017 	ldw	r17,0(r2)
8112d29c:	20001926 	beq	r4,zero,8112d304 <wcrtomb+0x9c>
8112d2a0:	00a04574 	movhi	r2,33045
8112d2a4:	10b08704 	addi	r2,r2,-15844
8112d2a8:	15000017 	ldw	r20,0(r2)
8112d2ac:	2021883a 	mov	r16,r4
8112d2b0:	2827883a 	mov	r19,r5
8112d2b4:	11256f40 	call	811256f4 <__locale_charset>
8112d2b8:	100f883a 	mov	r7,r2
8112d2bc:	dc800015 	stw	r18,0(sp)
8112d2c0:	980d883a 	mov	r6,r19
8112d2c4:	800b883a 	mov	r5,r16
8112d2c8:	8809883a 	mov	r4,r17
8112d2cc:	a03ee83a 	callr	r20
8112d2d0:	00ffffc4 	movi	r3,-1
8112d2d4:	10c0031e 	bne	r2,r3,8112d2e4 <wcrtomb+0x7c>
8112d2d8:	90000015 	stw	zero,0(r18)
8112d2dc:	00c02284 	movi	r3,138
8112d2e0:	88c00015 	stw	r3,0(r17)
8112d2e4:	dfc00917 	ldw	ra,36(sp)
8112d2e8:	dd000817 	ldw	r20,32(sp)
8112d2ec:	dcc00717 	ldw	r19,28(sp)
8112d2f0:	dc800617 	ldw	r18,24(sp)
8112d2f4:	dc400517 	ldw	r17,20(sp)
8112d2f8:	dc000417 	ldw	r16,16(sp)
8112d2fc:	dec00a04 	addi	sp,sp,40
8112d300:	f800283a 	ret
8112d304:	00a04574 	movhi	r2,33045
8112d308:	10b08704 	addi	r2,r2,-15844
8112d30c:	14000017 	ldw	r16,0(r2)
8112d310:	11256f40 	call	811256f4 <__locale_charset>
8112d314:	100f883a 	mov	r7,r2
8112d318:	dc800015 	stw	r18,0(sp)
8112d31c:	000d883a 	mov	r6,zero
8112d320:	d9400104 	addi	r5,sp,4
8112d324:	8809883a 	mov	r4,r17
8112d328:	803ee83a 	callr	r16
8112d32c:	003fe806 	br	8112d2d0 <__reset+0xfb10d2d0>

8112d330 <__ascii_wctomb>:
8112d330:	28000526 	beq	r5,zero,8112d348 <__ascii_wctomb+0x18>
8112d334:	00803fc4 	movi	r2,255
8112d338:	11800536 	bltu	r2,r6,8112d350 <__ascii_wctomb+0x20>
8112d33c:	29800005 	stb	r6,0(r5)
8112d340:	00800044 	movi	r2,1
8112d344:	f800283a 	ret
8112d348:	0005883a 	mov	r2,zero
8112d34c:	f800283a 	ret
8112d350:	00802284 	movi	r2,138
8112d354:	20800015 	stw	r2,0(r4)
8112d358:	00bfffc4 	movi	r2,-1
8112d35c:	f800283a 	ret

8112d360 <_wctomb_r>:
8112d360:	00a04574 	movhi	r2,33045
8112d364:	defff904 	addi	sp,sp,-28
8112d368:	10b08704 	addi	r2,r2,-15844
8112d36c:	de00012e 	bgeu	sp,et,8112d374 <_wctomb_r+0x14>
8112d370:	003b68fa 	trap	3
8112d374:	dfc00615 	stw	ra,24(sp)
8112d378:	dc400515 	stw	r17,20(sp)
8112d37c:	dc000415 	stw	r16,16(sp)
8112d380:	3823883a 	mov	r17,r7
8112d384:	14000017 	ldw	r16,0(r2)
8112d388:	d9000115 	stw	r4,4(sp)
8112d38c:	d9400215 	stw	r5,8(sp)
8112d390:	d9800315 	stw	r6,12(sp)
8112d394:	11256f40 	call	811256f4 <__locale_charset>
8112d398:	d9800317 	ldw	r6,12(sp)
8112d39c:	d9400217 	ldw	r5,8(sp)
8112d3a0:	d9000117 	ldw	r4,4(sp)
8112d3a4:	100f883a 	mov	r7,r2
8112d3a8:	dc400015 	stw	r17,0(sp)
8112d3ac:	803ee83a 	callr	r16
8112d3b0:	dfc00617 	ldw	ra,24(sp)
8112d3b4:	dc400517 	ldw	r17,20(sp)
8112d3b8:	dc000417 	ldw	r16,16(sp)
8112d3bc:	dec00704 	addi	sp,sp,28
8112d3c0:	f800283a 	ret

8112d3c4 <__fixunsdfsi>:
8112d3c4:	defffd04 	addi	sp,sp,-12
8112d3c8:	000d883a 	mov	r6,zero
8112d3cc:	01d07834 	movhi	r7,16864
8112d3d0:	de00012e 	bgeu	sp,et,8112d3d8 <__fixunsdfsi+0x14>
8112d3d4:	003b68fa 	trap	3
8112d3d8:	dc400115 	stw	r17,4(sp)
8112d3dc:	dc000015 	stw	r16,0(sp)
8112d3e0:	dfc00215 	stw	ra,8(sp)
8112d3e4:	2023883a 	mov	r17,r4
8112d3e8:	2821883a 	mov	r16,r5
8112d3ec:	112f4dc0 	call	8112f4dc <__gedf2>
8112d3f0:	1000080e 	bge	r2,zero,8112d414 <__fixunsdfsi+0x50>
8112d3f4:	8809883a 	mov	r4,r17
8112d3f8:	800b883a 	mov	r5,r16
8112d3fc:	112ffb00 	call	8112ffb0 <__fixdfsi>
8112d400:	dfc00217 	ldw	ra,8(sp)
8112d404:	dc400117 	ldw	r17,4(sp)
8112d408:	dc000017 	ldw	r16,0(sp)
8112d40c:	dec00304 	addi	sp,sp,12
8112d410:	f800283a 	ret
8112d414:	000d883a 	mov	r6,zero
8112d418:	01d07834 	movhi	r7,16864
8112d41c:	8809883a 	mov	r4,r17
8112d420:	800b883a 	mov	r5,r16
8112d424:	112f6ac0 	call	8112f6ac <__subdf3>
8112d428:	180b883a 	mov	r5,r3
8112d42c:	1009883a 	mov	r4,r2
8112d430:	112ffb00 	call	8112ffb0 <__fixdfsi>
8112d434:	00e00034 	movhi	r3,32768
8112d438:	10c5883a 	add	r2,r2,r3
8112d43c:	003ff006 	br	8112d400 <__reset+0xfb10d400>

8112d440 <__udivdi3>:
8112d440:	defff504 	addi	sp,sp,-44
8112d444:	de00012e 	bgeu	sp,et,8112d44c <__udivdi3+0xc>
8112d448:	003b68fa 	trap	3
8112d44c:	dcc00415 	stw	r19,16(sp)
8112d450:	dc000115 	stw	r16,4(sp)
8112d454:	dfc00a15 	stw	ra,40(sp)
8112d458:	df000915 	stw	fp,36(sp)
8112d45c:	ddc00815 	stw	r23,32(sp)
8112d460:	dd800715 	stw	r22,28(sp)
8112d464:	dd400615 	stw	r21,24(sp)
8112d468:	dd000515 	stw	r20,20(sp)
8112d46c:	dc800315 	stw	r18,12(sp)
8112d470:	dc400215 	stw	r17,8(sp)
8112d474:	2027883a 	mov	r19,r4
8112d478:	2821883a 	mov	r16,r5
8112d47c:	3800411e 	bne	r7,zero,8112d584 <__udivdi3+0x144>
8112d480:	3023883a 	mov	r17,r6
8112d484:	2025883a 	mov	r18,r4
8112d488:	2980522e 	bgeu	r5,r6,8112d5d4 <__udivdi3+0x194>
8112d48c:	00bfffd4 	movui	r2,65535
8112d490:	282d883a 	mov	r22,r5
8112d494:	1180a836 	bltu	r2,r6,8112d738 <__udivdi3+0x2f8>
8112d498:	00803fc4 	movi	r2,255
8112d49c:	1185803a 	cmpltu	r2,r2,r6
8112d4a0:	100490fa 	slli	r2,r2,3
8112d4a4:	3086d83a 	srl	r3,r6,r2
8112d4a8:	01204574 	movhi	r4,33045
8112d4ac:	2125c704 	addi	r4,r4,-26852
8112d4b0:	20c7883a 	add	r3,r4,r3
8112d4b4:	18c00003 	ldbu	r3,0(r3)
8112d4b8:	1885883a 	add	r2,r3,r2
8112d4bc:	00c00804 	movi	r3,32
8112d4c0:	1887c83a 	sub	r3,r3,r2
8112d4c4:	18000526 	beq	r3,zero,8112d4dc <__udivdi3+0x9c>
8112d4c8:	80e0983a 	sll	r16,r16,r3
8112d4cc:	9884d83a 	srl	r2,r19,r2
8112d4d0:	30e2983a 	sll	r17,r6,r3
8112d4d4:	98e4983a 	sll	r18,r19,r3
8112d4d8:	142cb03a 	or	r22,r2,r16
8112d4dc:	882ad43a 	srli	r21,r17,16
8112d4e0:	b009883a 	mov	r4,r22
8112d4e4:	8d3fffcc 	andi	r20,r17,65535
8112d4e8:	a80b883a 	mov	r5,r21
8112d4ec:	112e05c0 	call	8112e05c <__umodsi3>
8112d4f0:	b009883a 	mov	r4,r22
8112d4f4:	a80b883a 	mov	r5,r21
8112d4f8:	1027883a 	mov	r19,r2
8112d4fc:	112dff80 	call	8112dff8 <__udivsi3>
8112d500:	102d883a 	mov	r22,r2
8112d504:	9826943a 	slli	r19,r19,16
8112d508:	9004d43a 	srli	r2,r18,16
8112d50c:	a5a1383a 	mul	r16,r20,r22
8112d510:	14c4b03a 	or	r2,r2,r19
8112d514:	1400052e 	bgeu	r2,r16,8112d52c <__udivdi3+0xec>
8112d518:	1445883a 	add	r2,r2,r17
8112d51c:	b0ffffc4 	addi	r3,r22,-1
8112d520:	14400136 	bltu	r2,r17,8112d528 <__udivdi3+0xe8>
8112d524:	14012336 	bltu	r2,r16,8112d9b4 <__udivdi3+0x574>
8112d528:	182d883a 	mov	r22,r3
8112d52c:	1421c83a 	sub	r16,r2,r16
8112d530:	a80b883a 	mov	r5,r21
8112d534:	8009883a 	mov	r4,r16
8112d538:	112e05c0 	call	8112e05c <__umodsi3>
8112d53c:	1027883a 	mov	r19,r2
8112d540:	a80b883a 	mov	r5,r21
8112d544:	8009883a 	mov	r4,r16
8112d548:	112dff80 	call	8112dff8 <__udivsi3>
8112d54c:	9826943a 	slli	r19,r19,16
8112d550:	a0a9383a 	mul	r20,r20,r2
8112d554:	94bfffcc 	andi	r18,r18,65535
8112d558:	94e4b03a 	or	r18,r18,r19
8112d55c:	9500052e 	bgeu	r18,r20,8112d574 <__udivdi3+0x134>
8112d560:	8ca5883a 	add	r18,r17,r18
8112d564:	10ffffc4 	addi	r3,r2,-1
8112d568:	9440f136 	bltu	r18,r17,8112d930 <__udivdi3+0x4f0>
8112d56c:	9500f02e 	bgeu	r18,r20,8112d930 <__udivdi3+0x4f0>
8112d570:	10bfff84 	addi	r2,r2,-2
8112d574:	b00c943a 	slli	r6,r22,16
8112d578:	0007883a 	mov	r3,zero
8112d57c:	3084b03a 	or	r2,r6,r2
8112d580:	00005906 	br	8112d6e8 <__udivdi3+0x2a8>
8112d584:	29c05636 	bltu	r5,r7,8112d6e0 <__udivdi3+0x2a0>
8112d588:	00bfffd4 	movui	r2,65535
8112d58c:	11c0622e 	bgeu	r2,r7,8112d718 <__udivdi3+0x2d8>
8112d590:	00804034 	movhi	r2,256
8112d594:	10bfffc4 	addi	r2,r2,-1
8112d598:	11c0ee36 	bltu	r2,r7,8112d954 <__udivdi3+0x514>
8112d59c:	00800404 	movi	r2,16
8112d5a0:	3886d83a 	srl	r3,r7,r2
8112d5a4:	01204574 	movhi	r4,33045
8112d5a8:	2125c704 	addi	r4,r4,-26852
8112d5ac:	20c7883a 	add	r3,r4,r3
8112d5b0:	18c00003 	ldbu	r3,0(r3)
8112d5b4:	05400804 	movi	r21,32
8112d5b8:	1885883a 	add	r2,r3,r2
8112d5bc:	a8abc83a 	sub	r21,r21,r2
8112d5c0:	a800621e 	bne	r21,zero,8112d74c <__udivdi3+0x30c>
8112d5c4:	3c00e936 	bltu	r7,r16,8112d96c <__udivdi3+0x52c>
8112d5c8:	9985403a 	cmpgeu	r2,r19,r6
8112d5cc:	0007883a 	mov	r3,zero
8112d5d0:	00004506 	br	8112d6e8 <__udivdi3+0x2a8>
8112d5d4:	3000041e 	bne	r6,zero,8112d5e8 <__udivdi3+0x1a8>
8112d5d8:	000b883a 	mov	r5,zero
8112d5dc:	01000044 	movi	r4,1
8112d5e0:	112dff80 	call	8112dff8 <__udivsi3>
8112d5e4:	1023883a 	mov	r17,r2
8112d5e8:	00bfffd4 	movui	r2,65535
8112d5ec:	14404e2e 	bgeu	r2,r17,8112d728 <__udivdi3+0x2e8>
8112d5f0:	00804034 	movhi	r2,256
8112d5f4:	10bfffc4 	addi	r2,r2,-1
8112d5f8:	1440d836 	bltu	r2,r17,8112d95c <__udivdi3+0x51c>
8112d5fc:	00800404 	movi	r2,16
8112d600:	8886d83a 	srl	r3,r17,r2
8112d604:	01204574 	movhi	r4,33045
8112d608:	2125c704 	addi	r4,r4,-26852
8112d60c:	20c7883a 	add	r3,r4,r3
8112d610:	18c00003 	ldbu	r3,0(r3)
8112d614:	1885883a 	add	r2,r3,r2
8112d618:	00c00804 	movi	r3,32
8112d61c:	1887c83a 	sub	r3,r3,r2
8112d620:	18008f1e 	bne	r3,zero,8112d860 <__udivdi3+0x420>
8112d624:	882ad43a 	srli	r21,r17,16
8112d628:	8461c83a 	sub	r16,r16,r17
8112d62c:	8d3fffcc 	andi	r20,r17,65535
8112d630:	00c00044 	movi	r3,1
8112d634:	8009883a 	mov	r4,r16
8112d638:	a80b883a 	mov	r5,r21
8112d63c:	d8c00015 	stw	r3,0(sp)
8112d640:	112e05c0 	call	8112e05c <__umodsi3>
8112d644:	8009883a 	mov	r4,r16
8112d648:	a80b883a 	mov	r5,r21
8112d64c:	1027883a 	mov	r19,r2
8112d650:	112dff80 	call	8112dff8 <__udivsi3>
8112d654:	9826943a 	slli	r19,r19,16
8112d658:	9008d43a 	srli	r4,r18,16
8112d65c:	1521383a 	mul	r16,r2,r20
8112d660:	102d883a 	mov	r22,r2
8112d664:	24c8b03a 	or	r4,r4,r19
8112d668:	d8c00017 	ldw	r3,0(sp)
8112d66c:	2400052e 	bgeu	r4,r16,8112d684 <__udivdi3+0x244>
8112d670:	2449883a 	add	r4,r4,r17
8112d674:	b0bfffc4 	addi	r2,r22,-1
8112d678:	24400136 	bltu	r4,r17,8112d680 <__udivdi3+0x240>
8112d67c:	2400ca36 	bltu	r4,r16,8112d9a8 <__udivdi3+0x568>
8112d680:	102d883a 	mov	r22,r2
8112d684:	2421c83a 	sub	r16,r4,r16
8112d688:	a80b883a 	mov	r5,r21
8112d68c:	8009883a 	mov	r4,r16
8112d690:	d8c00015 	stw	r3,0(sp)
8112d694:	112e05c0 	call	8112e05c <__umodsi3>
8112d698:	1027883a 	mov	r19,r2
8112d69c:	a80b883a 	mov	r5,r21
8112d6a0:	8009883a 	mov	r4,r16
8112d6a4:	112dff80 	call	8112dff8 <__udivsi3>
8112d6a8:	9826943a 	slli	r19,r19,16
8112d6ac:	1529383a 	mul	r20,r2,r20
8112d6b0:	94bfffcc 	andi	r18,r18,65535
8112d6b4:	94e4b03a 	or	r18,r18,r19
8112d6b8:	d8c00017 	ldw	r3,0(sp)
8112d6bc:	9500052e 	bgeu	r18,r20,8112d6d4 <__udivdi3+0x294>
8112d6c0:	8ca5883a 	add	r18,r17,r18
8112d6c4:	113fffc4 	addi	r4,r2,-1
8112d6c8:	94409736 	bltu	r18,r17,8112d928 <__udivdi3+0x4e8>
8112d6cc:	9500962e 	bgeu	r18,r20,8112d928 <__udivdi3+0x4e8>
8112d6d0:	10bfff84 	addi	r2,r2,-2
8112d6d4:	b00c943a 	slli	r6,r22,16
8112d6d8:	3084b03a 	or	r2,r6,r2
8112d6dc:	00000206 	br	8112d6e8 <__udivdi3+0x2a8>
8112d6e0:	0007883a 	mov	r3,zero
8112d6e4:	0005883a 	mov	r2,zero
8112d6e8:	dfc00a17 	ldw	ra,40(sp)
8112d6ec:	df000917 	ldw	fp,36(sp)
8112d6f0:	ddc00817 	ldw	r23,32(sp)
8112d6f4:	dd800717 	ldw	r22,28(sp)
8112d6f8:	dd400617 	ldw	r21,24(sp)
8112d6fc:	dd000517 	ldw	r20,20(sp)
8112d700:	dcc00417 	ldw	r19,16(sp)
8112d704:	dc800317 	ldw	r18,12(sp)
8112d708:	dc400217 	ldw	r17,8(sp)
8112d70c:	dc000117 	ldw	r16,4(sp)
8112d710:	dec00b04 	addi	sp,sp,44
8112d714:	f800283a 	ret
8112d718:	00803fc4 	movi	r2,255
8112d71c:	11c5803a 	cmpltu	r2,r2,r7
8112d720:	100490fa 	slli	r2,r2,3
8112d724:	003f9e06 	br	8112d5a0 <__reset+0xfb10d5a0>
8112d728:	00803fc4 	movi	r2,255
8112d72c:	1445803a 	cmpltu	r2,r2,r17
8112d730:	100490fa 	slli	r2,r2,3
8112d734:	003fb206 	br	8112d600 <__reset+0xfb10d600>
8112d738:	00804034 	movhi	r2,256
8112d73c:	10bfffc4 	addi	r2,r2,-1
8112d740:	11808836 	bltu	r2,r6,8112d964 <__udivdi3+0x524>
8112d744:	00800404 	movi	r2,16
8112d748:	003f5606 	br	8112d4a4 <__reset+0xfb10d4a4>
8112d74c:	30aed83a 	srl	r23,r6,r2
8112d750:	3d4e983a 	sll	r7,r7,r21
8112d754:	80acd83a 	srl	r22,r16,r2
8112d758:	9884d83a 	srl	r2,r19,r2
8112d75c:	3deeb03a 	or	r23,r7,r23
8112d760:	b824d43a 	srli	r18,r23,16
8112d764:	8560983a 	sll	r16,r16,r21
8112d768:	b009883a 	mov	r4,r22
8112d76c:	900b883a 	mov	r5,r18
8112d770:	3568983a 	sll	r20,r6,r21
8112d774:	1420b03a 	or	r16,r2,r16
8112d778:	112e05c0 	call	8112e05c <__umodsi3>
8112d77c:	b009883a 	mov	r4,r22
8112d780:	900b883a 	mov	r5,r18
8112d784:	1023883a 	mov	r17,r2
8112d788:	112dff80 	call	8112dff8 <__udivsi3>
8112d78c:	8808943a 	slli	r4,r17,16
8112d790:	bf3fffcc 	andi	fp,r23,65535
8112d794:	8006d43a 	srli	r3,r16,16
8112d798:	e0a3383a 	mul	r17,fp,r2
8112d79c:	100d883a 	mov	r6,r2
8112d7a0:	1906b03a 	or	r3,r3,r4
8112d7a4:	1c40042e 	bgeu	r3,r17,8112d7b8 <__udivdi3+0x378>
8112d7a8:	1dc7883a 	add	r3,r3,r23
8112d7ac:	10bfffc4 	addi	r2,r2,-1
8112d7b0:	1dc0752e 	bgeu	r3,r23,8112d988 <__udivdi3+0x548>
8112d7b4:	100d883a 	mov	r6,r2
8112d7b8:	1c63c83a 	sub	r17,r3,r17
8112d7bc:	900b883a 	mov	r5,r18
8112d7c0:	8809883a 	mov	r4,r17
8112d7c4:	d9800015 	stw	r6,0(sp)
8112d7c8:	112e05c0 	call	8112e05c <__umodsi3>
8112d7cc:	102d883a 	mov	r22,r2
8112d7d0:	8809883a 	mov	r4,r17
8112d7d4:	900b883a 	mov	r5,r18
8112d7d8:	112dff80 	call	8112dff8 <__udivsi3>
8112d7dc:	b02c943a 	slli	r22,r22,16
8112d7e0:	e089383a 	mul	r4,fp,r2
8112d7e4:	843fffcc 	andi	r16,r16,65535
8112d7e8:	85a0b03a 	or	r16,r16,r22
8112d7ec:	d9800017 	ldw	r6,0(sp)
8112d7f0:	8100042e 	bgeu	r16,r4,8112d804 <__udivdi3+0x3c4>
8112d7f4:	85e1883a 	add	r16,r16,r23
8112d7f8:	10ffffc4 	addi	r3,r2,-1
8112d7fc:	85c05e2e 	bgeu	r16,r23,8112d978 <__udivdi3+0x538>
8112d800:	1805883a 	mov	r2,r3
8112d804:	300c943a 	slli	r6,r6,16
8112d808:	a17fffcc 	andi	r5,r20,65535
8112d80c:	a028d43a 	srli	r20,r20,16
8112d810:	3084b03a 	or	r2,r6,r2
8112d814:	10ffffcc 	andi	r3,r2,65535
8112d818:	100cd43a 	srli	r6,r2,16
8112d81c:	194f383a 	mul	r7,r3,r5
8112d820:	1d07383a 	mul	r3,r3,r20
8112d824:	314b383a 	mul	r5,r6,r5
8112d828:	3810d43a 	srli	r8,r7,16
8112d82c:	8121c83a 	sub	r16,r16,r4
8112d830:	1947883a 	add	r3,r3,r5
8112d834:	40c7883a 	add	r3,r8,r3
8112d838:	350d383a 	mul	r6,r6,r20
8112d83c:	1940022e 	bgeu	r3,r5,8112d848 <__udivdi3+0x408>
8112d840:	01000074 	movhi	r4,1
8112d844:	310d883a 	add	r6,r6,r4
8112d848:	1828d43a 	srli	r20,r3,16
8112d84c:	a18d883a 	add	r6,r20,r6
8112d850:	81803e36 	bltu	r16,r6,8112d94c <__udivdi3+0x50c>
8112d854:	81803826 	beq	r16,r6,8112d938 <__udivdi3+0x4f8>
8112d858:	0007883a 	mov	r3,zero
8112d85c:	003fa206 	br	8112d6e8 <__reset+0xfb10d6e8>
8112d860:	88e2983a 	sll	r17,r17,r3
8112d864:	80a8d83a 	srl	r20,r16,r2
8112d868:	80e0983a 	sll	r16,r16,r3
8112d86c:	882ad43a 	srli	r21,r17,16
8112d870:	9884d83a 	srl	r2,r19,r2
8112d874:	a009883a 	mov	r4,r20
8112d878:	a80b883a 	mov	r5,r21
8112d87c:	142eb03a 	or	r23,r2,r16
8112d880:	98e4983a 	sll	r18,r19,r3
8112d884:	112e05c0 	call	8112e05c <__umodsi3>
8112d888:	a009883a 	mov	r4,r20
8112d88c:	a80b883a 	mov	r5,r21
8112d890:	1021883a 	mov	r16,r2
8112d894:	112dff80 	call	8112dff8 <__udivsi3>
8112d898:	1039883a 	mov	fp,r2
8112d89c:	8d3fffcc 	andi	r20,r17,65535
8112d8a0:	8020943a 	slli	r16,r16,16
8112d8a4:	b804d43a 	srli	r2,r23,16
8112d8a8:	a72d383a 	mul	r22,r20,fp
8112d8ac:	1404b03a 	or	r2,r2,r16
8112d8b0:	1580062e 	bgeu	r2,r22,8112d8cc <__udivdi3+0x48c>
8112d8b4:	1445883a 	add	r2,r2,r17
8112d8b8:	e0ffffc4 	addi	r3,fp,-1
8112d8bc:	14403836 	bltu	r2,r17,8112d9a0 <__udivdi3+0x560>
8112d8c0:	1580372e 	bgeu	r2,r22,8112d9a0 <__udivdi3+0x560>
8112d8c4:	e73fff84 	addi	fp,fp,-2
8112d8c8:	1445883a 	add	r2,r2,r17
8112d8cc:	15adc83a 	sub	r22,r2,r22
8112d8d0:	a80b883a 	mov	r5,r21
8112d8d4:	b009883a 	mov	r4,r22
8112d8d8:	112e05c0 	call	8112e05c <__umodsi3>
8112d8dc:	1027883a 	mov	r19,r2
8112d8e0:	b009883a 	mov	r4,r22
8112d8e4:	a80b883a 	mov	r5,r21
8112d8e8:	112dff80 	call	8112dff8 <__udivsi3>
8112d8ec:	9826943a 	slli	r19,r19,16
8112d8f0:	a0a1383a 	mul	r16,r20,r2
8112d8f4:	b93fffcc 	andi	r4,r23,65535
8112d8f8:	24c8b03a 	or	r4,r4,r19
8112d8fc:	2400062e 	bgeu	r4,r16,8112d918 <__udivdi3+0x4d8>
8112d900:	2449883a 	add	r4,r4,r17
8112d904:	10ffffc4 	addi	r3,r2,-1
8112d908:	24402336 	bltu	r4,r17,8112d998 <__udivdi3+0x558>
8112d90c:	2400222e 	bgeu	r4,r16,8112d998 <__udivdi3+0x558>
8112d910:	10bfff84 	addi	r2,r2,-2
8112d914:	2449883a 	add	r4,r4,r17
8112d918:	e038943a 	slli	fp,fp,16
8112d91c:	2421c83a 	sub	r16,r4,r16
8112d920:	e086b03a 	or	r3,fp,r2
8112d924:	003f4306 	br	8112d634 <__reset+0xfb10d634>
8112d928:	2005883a 	mov	r2,r4
8112d92c:	003f6906 	br	8112d6d4 <__reset+0xfb10d6d4>
8112d930:	1805883a 	mov	r2,r3
8112d934:	003f0f06 	br	8112d574 <__reset+0xfb10d574>
8112d938:	1806943a 	slli	r3,r3,16
8112d93c:	9d66983a 	sll	r19,r19,r21
8112d940:	39ffffcc 	andi	r7,r7,65535
8112d944:	19c7883a 	add	r3,r3,r7
8112d948:	98ffc32e 	bgeu	r19,r3,8112d858 <__reset+0xfb10d858>
8112d94c:	10bfffc4 	addi	r2,r2,-1
8112d950:	003fc106 	br	8112d858 <__reset+0xfb10d858>
8112d954:	00800604 	movi	r2,24
8112d958:	003f1106 	br	8112d5a0 <__reset+0xfb10d5a0>
8112d95c:	00800604 	movi	r2,24
8112d960:	003f2706 	br	8112d600 <__reset+0xfb10d600>
8112d964:	00800604 	movi	r2,24
8112d968:	003ece06 	br	8112d4a4 <__reset+0xfb10d4a4>
8112d96c:	0007883a 	mov	r3,zero
8112d970:	00800044 	movi	r2,1
8112d974:	003f5c06 	br	8112d6e8 <__reset+0xfb10d6e8>
8112d978:	813fa12e 	bgeu	r16,r4,8112d800 <__reset+0xfb10d800>
8112d97c:	10bfff84 	addi	r2,r2,-2
8112d980:	85e1883a 	add	r16,r16,r23
8112d984:	003f9f06 	br	8112d804 <__reset+0xfb10d804>
8112d988:	1c7f8a2e 	bgeu	r3,r17,8112d7b4 <__reset+0xfb10d7b4>
8112d98c:	31bfff84 	addi	r6,r6,-2
8112d990:	1dc7883a 	add	r3,r3,r23
8112d994:	003f8806 	br	8112d7b8 <__reset+0xfb10d7b8>
8112d998:	1805883a 	mov	r2,r3
8112d99c:	003fde06 	br	8112d918 <__reset+0xfb10d918>
8112d9a0:	1839883a 	mov	fp,r3
8112d9a4:	003fc906 	br	8112d8cc <__reset+0xfb10d8cc>
8112d9a8:	b5bfff84 	addi	r22,r22,-2
8112d9ac:	2449883a 	add	r4,r4,r17
8112d9b0:	003f3406 	br	8112d684 <__reset+0xfb10d684>
8112d9b4:	b5bfff84 	addi	r22,r22,-2
8112d9b8:	1445883a 	add	r2,r2,r17
8112d9bc:	003edb06 	br	8112d52c <__reset+0xfb10d52c>

8112d9c0 <__umoddi3>:
8112d9c0:	defff404 	addi	sp,sp,-48
8112d9c4:	de00012e 	bgeu	sp,et,8112d9cc <__umoddi3+0xc>
8112d9c8:	003b68fa 	trap	3
8112d9cc:	df000a15 	stw	fp,40(sp)
8112d9d0:	dc400315 	stw	r17,12(sp)
8112d9d4:	dc000215 	stw	r16,8(sp)
8112d9d8:	dfc00b15 	stw	ra,44(sp)
8112d9dc:	ddc00915 	stw	r23,36(sp)
8112d9e0:	dd800815 	stw	r22,32(sp)
8112d9e4:	dd400715 	stw	r21,28(sp)
8112d9e8:	dd000615 	stw	r20,24(sp)
8112d9ec:	dcc00515 	stw	r19,20(sp)
8112d9f0:	dc800415 	stw	r18,16(sp)
8112d9f4:	2021883a 	mov	r16,r4
8112d9f8:	2823883a 	mov	r17,r5
8112d9fc:	2839883a 	mov	fp,r5
8112da00:	38003c1e 	bne	r7,zero,8112daf4 <__umoddi3+0x134>
8112da04:	3027883a 	mov	r19,r6
8112da08:	2029883a 	mov	r20,r4
8112da0c:	2980512e 	bgeu	r5,r6,8112db54 <__umoddi3+0x194>
8112da10:	00bfffd4 	movui	r2,65535
8112da14:	11809a36 	bltu	r2,r6,8112dc80 <__umoddi3+0x2c0>
8112da18:	01003fc4 	movi	r4,255
8112da1c:	2189803a 	cmpltu	r4,r4,r6
8112da20:	200890fa 	slli	r4,r4,3
8112da24:	3104d83a 	srl	r2,r6,r4
8112da28:	00e04574 	movhi	r3,33045
8112da2c:	18e5c704 	addi	r3,r3,-26852
8112da30:	1885883a 	add	r2,r3,r2
8112da34:	10c00003 	ldbu	r3,0(r2)
8112da38:	00800804 	movi	r2,32
8112da3c:	1909883a 	add	r4,r3,r4
8112da40:	1125c83a 	sub	r18,r2,r4
8112da44:	90000526 	beq	r18,zero,8112da5c <__umoddi3+0x9c>
8112da48:	8ca2983a 	sll	r17,r17,r18
8112da4c:	8108d83a 	srl	r4,r16,r4
8112da50:	34a6983a 	sll	r19,r6,r18
8112da54:	84a8983a 	sll	r20,r16,r18
8112da58:	2478b03a 	or	fp,r4,r17
8112da5c:	982ed43a 	srli	r23,r19,16
8112da60:	e009883a 	mov	r4,fp
8112da64:	9dbfffcc 	andi	r22,r19,65535
8112da68:	b80b883a 	mov	r5,r23
8112da6c:	112e05c0 	call	8112e05c <__umodsi3>
8112da70:	e009883a 	mov	r4,fp
8112da74:	b80b883a 	mov	r5,r23
8112da78:	102b883a 	mov	r21,r2
8112da7c:	112dff80 	call	8112dff8 <__udivsi3>
8112da80:	a806943a 	slli	r3,r21,16
8112da84:	a008d43a 	srli	r4,r20,16
8112da88:	b085383a 	mul	r2,r22,r2
8112da8c:	20c8b03a 	or	r4,r4,r3
8112da90:	2080032e 	bgeu	r4,r2,8112daa0 <__umoddi3+0xe0>
8112da94:	24c9883a 	add	r4,r4,r19
8112da98:	24c00136 	bltu	r4,r19,8112daa0 <__umoddi3+0xe0>
8112da9c:	20811036 	bltu	r4,r2,8112dee0 <__umoddi3+0x520>
8112daa0:	20abc83a 	sub	r21,r4,r2
8112daa4:	b80b883a 	mov	r5,r23
8112daa8:	a809883a 	mov	r4,r21
8112daac:	112e05c0 	call	8112e05c <__umodsi3>
8112dab0:	1023883a 	mov	r17,r2
8112dab4:	b80b883a 	mov	r5,r23
8112dab8:	a809883a 	mov	r4,r21
8112dabc:	112dff80 	call	8112dff8 <__udivsi3>
8112dac0:	8822943a 	slli	r17,r17,16
8112dac4:	b085383a 	mul	r2,r22,r2
8112dac8:	a0ffffcc 	andi	r3,r20,65535
8112dacc:	1c46b03a 	or	r3,r3,r17
8112dad0:	1880042e 	bgeu	r3,r2,8112dae4 <__umoddi3+0x124>
8112dad4:	1cc7883a 	add	r3,r3,r19
8112dad8:	1cc00236 	bltu	r3,r19,8112dae4 <__umoddi3+0x124>
8112dadc:	1880012e 	bgeu	r3,r2,8112dae4 <__umoddi3+0x124>
8112dae0:	1cc7883a 	add	r3,r3,r19
8112dae4:	1885c83a 	sub	r2,r3,r2
8112dae8:	1484d83a 	srl	r2,r2,r18
8112daec:	0007883a 	mov	r3,zero
8112daf0:	00004f06 	br	8112dc30 <__umoddi3+0x270>
8112daf4:	29c04c36 	bltu	r5,r7,8112dc28 <__umoddi3+0x268>
8112daf8:	00bfffd4 	movui	r2,65535
8112dafc:	11c0582e 	bgeu	r2,r7,8112dc60 <__umoddi3+0x2a0>
8112db00:	00804034 	movhi	r2,256
8112db04:	10bfffc4 	addi	r2,r2,-1
8112db08:	11c0e736 	bltu	r2,r7,8112dea8 <__umoddi3+0x4e8>
8112db0c:	01000404 	movi	r4,16
8112db10:	3904d83a 	srl	r2,r7,r4
8112db14:	00e04574 	movhi	r3,33045
8112db18:	18e5c704 	addi	r3,r3,-26852
8112db1c:	1885883a 	add	r2,r3,r2
8112db20:	14c00003 	ldbu	r19,0(r2)
8112db24:	00c00804 	movi	r3,32
8112db28:	9927883a 	add	r19,r19,r4
8112db2c:	1ce9c83a 	sub	r20,r3,r19
8112db30:	a000581e 	bne	r20,zero,8112dc94 <__umoddi3+0x2d4>
8112db34:	3c400136 	bltu	r7,r17,8112db3c <__umoddi3+0x17c>
8112db38:	8180eb36 	bltu	r16,r6,8112dee8 <__umoddi3+0x528>
8112db3c:	8185c83a 	sub	r2,r16,r6
8112db40:	89e3c83a 	sub	r17,r17,r7
8112db44:	8089803a 	cmpltu	r4,r16,r2
8112db48:	8939c83a 	sub	fp,r17,r4
8112db4c:	e007883a 	mov	r3,fp
8112db50:	00003706 	br	8112dc30 <__umoddi3+0x270>
8112db54:	3000041e 	bne	r6,zero,8112db68 <__umoddi3+0x1a8>
8112db58:	000b883a 	mov	r5,zero
8112db5c:	01000044 	movi	r4,1
8112db60:	112dff80 	call	8112dff8 <__udivsi3>
8112db64:	1027883a 	mov	r19,r2
8112db68:	00bfffd4 	movui	r2,65535
8112db6c:	14c0402e 	bgeu	r2,r19,8112dc70 <__umoddi3+0x2b0>
8112db70:	00804034 	movhi	r2,256
8112db74:	10bfffc4 	addi	r2,r2,-1
8112db78:	14c0cd36 	bltu	r2,r19,8112deb0 <__umoddi3+0x4f0>
8112db7c:	00800404 	movi	r2,16
8112db80:	9886d83a 	srl	r3,r19,r2
8112db84:	01204574 	movhi	r4,33045
8112db88:	2125c704 	addi	r4,r4,-26852
8112db8c:	20c7883a 	add	r3,r4,r3
8112db90:	18c00003 	ldbu	r3,0(r3)
8112db94:	1887883a 	add	r3,r3,r2
8112db98:	00800804 	movi	r2,32
8112db9c:	10e5c83a 	sub	r18,r2,r3
8112dba0:	9000901e 	bne	r18,zero,8112dde4 <__umoddi3+0x424>
8112dba4:	982cd43a 	srli	r22,r19,16
8112dba8:	8ce3c83a 	sub	r17,r17,r19
8112dbac:	9d7fffcc 	andi	r21,r19,65535
8112dbb0:	b00b883a 	mov	r5,r22
8112dbb4:	8809883a 	mov	r4,r17
8112dbb8:	112e05c0 	call	8112e05c <__umodsi3>
8112dbbc:	8809883a 	mov	r4,r17
8112dbc0:	b00b883a 	mov	r5,r22
8112dbc4:	1021883a 	mov	r16,r2
8112dbc8:	112dff80 	call	8112dff8 <__udivsi3>
8112dbcc:	8006943a 	slli	r3,r16,16
8112dbd0:	a008d43a 	srli	r4,r20,16
8112dbd4:	1545383a 	mul	r2,r2,r21
8112dbd8:	20c8b03a 	or	r4,r4,r3
8112dbdc:	2080042e 	bgeu	r4,r2,8112dbf0 <__umoddi3+0x230>
8112dbe0:	24c9883a 	add	r4,r4,r19
8112dbe4:	24c00236 	bltu	r4,r19,8112dbf0 <__umoddi3+0x230>
8112dbe8:	2080012e 	bgeu	r4,r2,8112dbf0 <__umoddi3+0x230>
8112dbec:	24c9883a 	add	r4,r4,r19
8112dbf0:	20a1c83a 	sub	r16,r4,r2
8112dbf4:	b00b883a 	mov	r5,r22
8112dbf8:	8009883a 	mov	r4,r16
8112dbfc:	112e05c0 	call	8112e05c <__umodsi3>
8112dc00:	1023883a 	mov	r17,r2
8112dc04:	b00b883a 	mov	r5,r22
8112dc08:	8009883a 	mov	r4,r16
8112dc0c:	112dff80 	call	8112dff8 <__udivsi3>
8112dc10:	8822943a 	slli	r17,r17,16
8112dc14:	1545383a 	mul	r2,r2,r21
8112dc18:	a53fffcc 	andi	r20,r20,65535
8112dc1c:	a446b03a 	or	r3,r20,r17
8112dc20:	18bfb02e 	bgeu	r3,r2,8112dae4 <__reset+0xfb10dae4>
8112dc24:	003fab06 	br	8112dad4 <__reset+0xfb10dad4>
8112dc28:	2005883a 	mov	r2,r4
8112dc2c:	2807883a 	mov	r3,r5
8112dc30:	dfc00b17 	ldw	ra,44(sp)
8112dc34:	df000a17 	ldw	fp,40(sp)
8112dc38:	ddc00917 	ldw	r23,36(sp)
8112dc3c:	dd800817 	ldw	r22,32(sp)
8112dc40:	dd400717 	ldw	r21,28(sp)
8112dc44:	dd000617 	ldw	r20,24(sp)
8112dc48:	dcc00517 	ldw	r19,20(sp)
8112dc4c:	dc800417 	ldw	r18,16(sp)
8112dc50:	dc400317 	ldw	r17,12(sp)
8112dc54:	dc000217 	ldw	r16,8(sp)
8112dc58:	dec00c04 	addi	sp,sp,48
8112dc5c:	f800283a 	ret
8112dc60:	04c03fc4 	movi	r19,255
8112dc64:	99c9803a 	cmpltu	r4,r19,r7
8112dc68:	200890fa 	slli	r4,r4,3
8112dc6c:	003fa806 	br	8112db10 <__reset+0xfb10db10>
8112dc70:	00803fc4 	movi	r2,255
8112dc74:	14c5803a 	cmpltu	r2,r2,r19
8112dc78:	100490fa 	slli	r2,r2,3
8112dc7c:	003fc006 	br	8112db80 <__reset+0xfb10db80>
8112dc80:	00804034 	movhi	r2,256
8112dc84:	10bfffc4 	addi	r2,r2,-1
8112dc88:	11808b36 	bltu	r2,r6,8112deb8 <__umoddi3+0x4f8>
8112dc8c:	01000404 	movi	r4,16
8112dc90:	003f6406 	br	8112da24 <__reset+0xfb10da24>
8112dc94:	34c4d83a 	srl	r2,r6,r19
8112dc98:	3d0e983a 	sll	r7,r7,r20
8112dc9c:	8cf8d83a 	srl	fp,r17,r19
8112dca0:	8d10983a 	sll	r8,r17,r20
8112dca4:	38aab03a 	or	r21,r7,r2
8112dca8:	a82cd43a 	srli	r22,r21,16
8112dcac:	84e2d83a 	srl	r17,r16,r19
8112dcb0:	e009883a 	mov	r4,fp
8112dcb4:	b00b883a 	mov	r5,r22
8112dcb8:	8a22b03a 	or	r17,r17,r8
8112dcbc:	3524983a 	sll	r18,r6,r20
8112dcc0:	112e05c0 	call	8112e05c <__umodsi3>
8112dcc4:	e009883a 	mov	r4,fp
8112dcc8:	b00b883a 	mov	r5,r22
8112dccc:	102f883a 	mov	r23,r2
8112dcd0:	112dff80 	call	8112dff8 <__udivsi3>
8112dcd4:	100d883a 	mov	r6,r2
8112dcd8:	b808943a 	slli	r4,r23,16
8112dcdc:	aa3fffcc 	andi	r8,r21,65535
8112dce0:	8804d43a 	srli	r2,r17,16
8112dce4:	41af383a 	mul	r23,r8,r6
8112dce8:	8520983a 	sll	r16,r16,r20
8112dcec:	1104b03a 	or	r2,r2,r4
8112dcf0:	15c0042e 	bgeu	r2,r23,8112dd04 <__umoddi3+0x344>
8112dcf4:	1545883a 	add	r2,r2,r21
8112dcf8:	30ffffc4 	addi	r3,r6,-1
8112dcfc:	1540742e 	bgeu	r2,r21,8112ded0 <__umoddi3+0x510>
8112dd00:	180d883a 	mov	r6,r3
8112dd04:	15efc83a 	sub	r23,r2,r23
8112dd08:	b00b883a 	mov	r5,r22
8112dd0c:	b809883a 	mov	r4,r23
8112dd10:	d9800115 	stw	r6,4(sp)
8112dd14:	da000015 	stw	r8,0(sp)
8112dd18:	112e05c0 	call	8112e05c <__umodsi3>
8112dd1c:	b00b883a 	mov	r5,r22
8112dd20:	b809883a 	mov	r4,r23
8112dd24:	1039883a 	mov	fp,r2
8112dd28:	112dff80 	call	8112dff8 <__udivsi3>
8112dd2c:	da000017 	ldw	r8,0(sp)
8112dd30:	e038943a 	slli	fp,fp,16
8112dd34:	100b883a 	mov	r5,r2
8112dd38:	4089383a 	mul	r4,r8,r2
8112dd3c:	8a3fffcc 	andi	r8,r17,65535
8112dd40:	4710b03a 	or	r8,r8,fp
8112dd44:	d9800117 	ldw	r6,4(sp)
8112dd48:	4100042e 	bgeu	r8,r4,8112dd5c <__umoddi3+0x39c>
8112dd4c:	4551883a 	add	r8,r8,r21
8112dd50:	10bfffc4 	addi	r2,r2,-1
8112dd54:	45405a2e 	bgeu	r8,r21,8112dec0 <__umoddi3+0x500>
8112dd58:	100b883a 	mov	r5,r2
8112dd5c:	300c943a 	slli	r6,r6,16
8112dd60:	91ffffcc 	andi	r7,r18,65535
8112dd64:	9004d43a 	srli	r2,r18,16
8112dd68:	314cb03a 	or	r6,r6,r5
8112dd6c:	317fffcc 	andi	r5,r6,65535
8112dd70:	300cd43a 	srli	r6,r6,16
8112dd74:	29d3383a 	mul	r9,r5,r7
8112dd78:	288b383a 	mul	r5,r5,r2
8112dd7c:	31cf383a 	mul	r7,r6,r7
8112dd80:	4806d43a 	srli	r3,r9,16
8112dd84:	4111c83a 	sub	r8,r8,r4
8112dd88:	29cb883a 	add	r5,r5,r7
8112dd8c:	194b883a 	add	r5,r3,r5
8112dd90:	3085383a 	mul	r2,r6,r2
8112dd94:	29c0022e 	bgeu	r5,r7,8112dda0 <__umoddi3+0x3e0>
8112dd98:	00c00074 	movhi	r3,1
8112dd9c:	10c5883a 	add	r2,r2,r3
8112dda0:	2808d43a 	srli	r4,r5,16
8112dda4:	280a943a 	slli	r5,r5,16
8112dda8:	4a7fffcc 	andi	r9,r9,65535
8112ddac:	2085883a 	add	r2,r4,r2
8112ddb0:	2a4b883a 	add	r5,r5,r9
8112ddb4:	40803636 	bltu	r8,r2,8112de90 <__umoddi3+0x4d0>
8112ddb8:	40804d26 	beq	r8,r2,8112def0 <__umoddi3+0x530>
8112ddbc:	4089c83a 	sub	r4,r8,r2
8112ddc0:	280f883a 	mov	r7,r5
8112ddc4:	81cfc83a 	sub	r7,r16,r7
8112ddc8:	81c7803a 	cmpltu	r3,r16,r7
8112ddcc:	20c7c83a 	sub	r3,r4,r3
8112ddd0:	1cc4983a 	sll	r2,r3,r19
8112ddd4:	3d0ed83a 	srl	r7,r7,r20
8112ddd8:	1d06d83a 	srl	r3,r3,r20
8112dddc:	11c4b03a 	or	r2,r2,r7
8112dde0:	003f9306 	br	8112dc30 <__reset+0xfb10dc30>
8112dde4:	9ca6983a 	sll	r19,r19,r18
8112dde8:	88e8d83a 	srl	r20,r17,r3
8112ddec:	80c4d83a 	srl	r2,r16,r3
8112ddf0:	982cd43a 	srli	r22,r19,16
8112ddf4:	8ca2983a 	sll	r17,r17,r18
8112ddf8:	a009883a 	mov	r4,r20
8112ddfc:	b00b883a 	mov	r5,r22
8112de00:	1478b03a 	or	fp,r2,r17
8112de04:	112e05c0 	call	8112e05c <__umodsi3>
8112de08:	a009883a 	mov	r4,r20
8112de0c:	b00b883a 	mov	r5,r22
8112de10:	1023883a 	mov	r17,r2
8112de14:	112dff80 	call	8112dff8 <__udivsi3>
8112de18:	9d7fffcc 	andi	r21,r19,65535
8112de1c:	880a943a 	slli	r5,r17,16
8112de20:	e008d43a 	srli	r4,fp,16
8112de24:	a885383a 	mul	r2,r21,r2
8112de28:	84a8983a 	sll	r20,r16,r18
8112de2c:	2148b03a 	or	r4,r4,r5
8112de30:	2080042e 	bgeu	r4,r2,8112de44 <__umoddi3+0x484>
8112de34:	24c9883a 	add	r4,r4,r19
8112de38:	24c00236 	bltu	r4,r19,8112de44 <__umoddi3+0x484>
8112de3c:	2080012e 	bgeu	r4,r2,8112de44 <__umoddi3+0x484>
8112de40:	24c9883a 	add	r4,r4,r19
8112de44:	20a3c83a 	sub	r17,r4,r2
8112de48:	b00b883a 	mov	r5,r22
8112de4c:	8809883a 	mov	r4,r17
8112de50:	112e05c0 	call	8112e05c <__umodsi3>
8112de54:	102f883a 	mov	r23,r2
8112de58:	8809883a 	mov	r4,r17
8112de5c:	b00b883a 	mov	r5,r22
8112de60:	112dff80 	call	8112dff8 <__udivsi3>
8112de64:	b82e943a 	slli	r23,r23,16
8112de68:	a885383a 	mul	r2,r21,r2
8112de6c:	e13fffcc 	andi	r4,fp,65535
8112de70:	25c8b03a 	or	r4,r4,r23
8112de74:	2080042e 	bgeu	r4,r2,8112de88 <__umoddi3+0x4c8>
8112de78:	24c9883a 	add	r4,r4,r19
8112de7c:	24c00236 	bltu	r4,r19,8112de88 <__umoddi3+0x4c8>
8112de80:	2080012e 	bgeu	r4,r2,8112de88 <__umoddi3+0x4c8>
8112de84:	24c9883a 	add	r4,r4,r19
8112de88:	20a3c83a 	sub	r17,r4,r2
8112de8c:	003f4806 	br	8112dbb0 <__reset+0xfb10dbb0>
8112de90:	2c8fc83a 	sub	r7,r5,r18
8112de94:	1545c83a 	sub	r2,r2,r21
8112de98:	29cb803a 	cmpltu	r5,r5,r7
8112de9c:	1145c83a 	sub	r2,r2,r5
8112dea0:	4089c83a 	sub	r4,r8,r2
8112dea4:	003fc706 	br	8112ddc4 <__reset+0xfb10ddc4>
8112dea8:	01000604 	movi	r4,24
8112deac:	003f1806 	br	8112db10 <__reset+0xfb10db10>
8112deb0:	00800604 	movi	r2,24
8112deb4:	003f3206 	br	8112db80 <__reset+0xfb10db80>
8112deb8:	01000604 	movi	r4,24
8112debc:	003ed906 	br	8112da24 <__reset+0xfb10da24>
8112dec0:	413fa52e 	bgeu	r8,r4,8112dd58 <__reset+0xfb10dd58>
8112dec4:	297fff84 	addi	r5,r5,-2
8112dec8:	4551883a 	add	r8,r8,r21
8112decc:	003fa306 	br	8112dd5c <__reset+0xfb10dd5c>
8112ded0:	15ff8b2e 	bgeu	r2,r23,8112dd00 <__reset+0xfb10dd00>
8112ded4:	31bfff84 	addi	r6,r6,-2
8112ded8:	1545883a 	add	r2,r2,r21
8112dedc:	003f8906 	br	8112dd04 <__reset+0xfb10dd04>
8112dee0:	24c9883a 	add	r4,r4,r19
8112dee4:	003eee06 	br	8112daa0 <__reset+0xfb10daa0>
8112dee8:	8005883a 	mov	r2,r16
8112deec:	003f1706 	br	8112db4c <__reset+0xfb10db4c>
8112def0:	817fe736 	bltu	r16,r5,8112de90 <__reset+0xfb10de90>
8112def4:	280f883a 	mov	r7,r5
8112def8:	0009883a 	mov	r4,zero
8112defc:	003fb106 	br	8112ddc4 <__reset+0xfb10ddc4>

8112df00 <__divsi3>:
8112df00:	20001b16 	blt	r4,zero,8112df70 <__divsi3+0x70>
8112df04:	000f883a 	mov	r7,zero
8112df08:	28001616 	blt	r5,zero,8112df64 <__divsi3+0x64>
8112df0c:	200d883a 	mov	r6,r4
8112df10:	29001a2e 	bgeu	r5,r4,8112df7c <__divsi3+0x7c>
8112df14:	00800804 	movi	r2,32
8112df18:	00c00044 	movi	r3,1
8112df1c:	00000106 	br	8112df24 <__divsi3+0x24>
8112df20:	10000d26 	beq	r2,zero,8112df58 <__divsi3+0x58>
8112df24:	294b883a 	add	r5,r5,r5
8112df28:	10bfffc4 	addi	r2,r2,-1
8112df2c:	18c7883a 	add	r3,r3,r3
8112df30:	293ffb36 	bltu	r5,r4,8112df20 <__reset+0xfb10df20>
8112df34:	0005883a 	mov	r2,zero
8112df38:	18000726 	beq	r3,zero,8112df58 <__divsi3+0x58>
8112df3c:	0005883a 	mov	r2,zero
8112df40:	31400236 	bltu	r6,r5,8112df4c <__divsi3+0x4c>
8112df44:	314dc83a 	sub	r6,r6,r5
8112df48:	10c4b03a 	or	r2,r2,r3
8112df4c:	1806d07a 	srli	r3,r3,1
8112df50:	280ad07a 	srli	r5,r5,1
8112df54:	183ffa1e 	bne	r3,zero,8112df40 <__reset+0xfb10df40>
8112df58:	38000126 	beq	r7,zero,8112df60 <__divsi3+0x60>
8112df5c:	0085c83a 	sub	r2,zero,r2
8112df60:	f800283a 	ret
8112df64:	014bc83a 	sub	r5,zero,r5
8112df68:	39c0005c 	xori	r7,r7,1
8112df6c:	003fe706 	br	8112df0c <__reset+0xfb10df0c>
8112df70:	0109c83a 	sub	r4,zero,r4
8112df74:	01c00044 	movi	r7,1
8112df78:	003fe306 	br	8112df08 <__reset+0xfb10df08>
8112df7c:	00c00044 	movi	r3,1
8112df80:	003fee06 	br	8112df3c <__reset+0xfb10df3c>

8112df84 <__modsi3>:
8112df84:	20001716 	blt	r4,zero,8112dfe4 <__modsi3+0x60>
8112df88:	000f883a 	mov	r7,zero
8112df8c:	2005883a 	mov	r2,r4
8112df90:	28001216 	blt	r5,zero,8112dfdc <__modsi3+0x58>
8112df94:	2900162e 	bgeu	r5,r4,8112dff0 <__modsi3+0x6c>
8112df98:	01800804 	movi	r6,32
8112df9c:	00c00044 	movi	r3,1
8112dfa0:	00000106 	br	8112dfa8 <__modsi3+0x24>
8112dfa4:	30000a26 	beq	r6,zero,8112dfd0 <__modsi3+0x4c>
8112dfa8:	294b883a 	add	r5,r5,r5
8112dfac:	31bfffc4 	addi	r6,r6,-1
8112dfb0:	18c7883a 	add	r3,r3,r3
8112dfb4:	293ffb36 	bltu	r5,r4,8112dfa4 <__reset+0xfb10dfa4>
8112dfb8:	18000526 	beq	r3,zero,8112dfd0 <__modsi3+0x4c>
8112dfbc:	1806d07a 	srli	r3,r3,1
8112dfc0:	11400136 	bltu	r2,r5,8112dfc8 <__modsi3+0x44>
8112dfc4:	1145c83a 	sub	r2,r2,r5
8112dfc8:	280ad07a 	srli	r5,r5,1
8112dfcc:	183ffb1e 	bne	r3,zero,8112dfbc <__reset+0xfb10dfbc>
8112dfd0:	38000126 	beq	r7,zero,8112dfd8 <__modsi3+0x54>
8112dfd4:	0085c83a 	sub	r2,zero,r2
8112dfd8:	f800283a 	ret
8112dfdc:	014bc83a 	sub	r5,zero,r5
8112dfe0:	003fec06 	br	8112df94 <__reset+0xfb10df94>
8112dfe4:	0109c83a 	sub	r4,zero,r4
8112dfe8:	01c00044 	movi	r7,1
8112dfec:	003fe706 	br	8112df8c <__reset+0xfb10df8c>
8112dff0:	00c00044 	movi	r3,1
8112dff4:	003ff106 	br	8112dfbc <__reset+0xfb10dfbc>

8112dff8 <__udivsi3>:
8112dff8:	200d883a 	mov	r6,r4
8112dffc:	2900152e 	bgeu	r5,r4,8112e054 <__udivsi3+0x5c>
8112e000:	28001416 	blt	r5,zero,8112e054 <__udivsi3+0x5c>
8112e004:	00800804 	movi	r2,32
8112e008:	00c00044 	movi	r3,1
8112e00c:	00000206 	br	8112e018 <__udivsi3+0x20>
8112e010:	10000e26 	beq	r2,zero,8112e04c <__udivsi3+0x54>
8112e014:	28000516 	blt	r5,zero,8112e02c <__udivsi3+0x34>
8112e018:	294b883a 	add	r5,r5,r5
8112e01c:	10bfffc4 	addi	r2,r2,-1
8112e020:	18c7883a 	add	r3,r3,r3
8112e024:	293ffa36 	bltu	r5,r4,8112e010 <__reset+0xfb10e010>
8112e028:	18000826 	beq	r3,zero,8112e04c <__udivsi3+0x54>
8112e02c:	0005883a 	mov	r2,zero
8112e030:	31400236 	bltu	r6,r5,8112e03c <__udivsi3+0x44>
8112e034:	314dc83a 	sub	r6,r6,r5
8112e038:	10c4b03a 	or	r2,r2,r3
8112e03c:	1806d07a 	srli	r3,r3,1
8112e040:	280ad07a 	srli	r5,r5,1
8112e044:	183ffa1e 	bne	r3,zero,8112e030 <__reset+0xfb10e030>
8112e048:	f800283a 	ret
8112e04c:	0005883a 	mov	r2,zero
8112e050:	f800283a 	ret
8112e054:	00c00044 	movi	r3,1
8112e058:	003ff406 	br	8112e02c <__reset+0xfb10e02c>

8112e05c <__umodsi3>:
8112e05c:	2005883a 	mov	r2,r4
8112e060:	2900122e 	bgeu	r5,r4,8112e0ac <__umodsi3+0x50>
8112e064:	28001116 	blt	r5,zero,8112e0ac <__umodsi3+0x50>
8112e068:	01800804 	movi	r6,32
8112e06c:	00c00044 	movi	r3,1
8112e070:	00000206 	br	8112e07c <__umodsi3+0x20>
8112e074:	30000c26 	beq	r6,zero,8112e0a8 <__umodsi3+0x4c>
8112e078:	28000516 	blt	r5,zero,8112e090 <__umodsi3+0x34>
8112e07c:	294b883a 	add	r5,r5,r5
8112e080:	31bfffc4 	addi	r6,r6,-1
8112e084:	18c7883a 	add	r3,r3,r3
8112e088:	293ffa36 	bltu	r5,r4,8112e074 <__reset+0xfb10e074>
8112e08c:	18000626 	beq	r3,zero,8112e0a8 <__umodsi3+0x4c>
8112e090:	1806d07a 	srli	r3,r3,1
8112e094:	11400136 	bltu	r2,r5,8112e09c <__umodsi3+0x40>
8112e098:	1145c83a 	sub	r2,r2,r5
8112e09c:	280ad07a 	srli	r5,r5,1
8112e0a0:	183ffb1e 	bne	r3,zero,8112e090 <__reset+0xfb10e090>
8112e0a4:	f800283a 	ret
8112e0a8:	f800283a 	ret
8112e0ac:	00c00044 	movi	r3,1
8112e0b0:	003ff706 	br	8112e090 <__reset+0xfb10e090>

8112e0b4 <__eqsf2>:
8112e0b4:	2006d5fa 	srli	r3,r4,23
8112e0b8:	280cd5fa 	srli	r6,r5,23
8112e0bc:	01c02034 	movhi	r7,128
8112e0c0:	39ffffc4 	addi	r7,r7,-1
8112e0c4:	18c03fcc 	andi	r3,r3,255
8112e0c8:	02003fc4 	movi	r8,255
8112e0cc:	3904703a 	and	r2,r7,r4
8112e0d0:	31803fcc 	andi	r6,r6,255
8112e0d4:	394e703a 	and	r7,r7,r5
8112e0d8:	2008d7fa 	srli	r4,r4,31
8112e0dc:	280ad7fa 	srli	r5,r5,31
8112e0e0:	1a000d26 	beq	r3,r8,8112e118 <__eqsf2+0x64>
8112e0e4:	02003fc4 	movi	r8,255
8112e0e8:	32000826 	beq	r6,r8,8112e10c <__eqsf2+0x58>
8112e0ec:	19800226 	beq	r3,r6,8112e0f8 <__eqsf2+0x44>
8112e0f0:	00800044 	movi	r2,1
8112e0f4:	f800283a 	ret
8112e0f8:	11fffd1e 	bne	r2,r7,8112e0f0 <__reset+0xfb10e0f0>
8112e0fc:	21400926 	beq	r4,r5,8112e124 <__eqsf2+0x70>
8112e100:	183ffb1e 	bne	r3,zero,8112e0f0 <__reset+0xfb10e0f0>
8112e104:	1004c03a 	cmpne	r2,r2,zero
8112e108:	f800283a 	ret
8112e10c:	383ff726 	beq	r7,zero,8112e0ec <__reset+0xfb10e0ec>
8112e110:	00800044 	movi	r2,1
8112e114:	f800283a 	ret
8112e118:	103ff226 	beq	r2,zero,8112e0e4 <__reset+0xfb10e0e4>
8112e11c:	00800044 	movi	r2,1
8112e120:	f800283a 	ret
8112e124:	0005883a 	mov	r2,zero
8112e128:	f800283a 	ret

8112e12c <__gesf2>:
8112e12c:	2004d5fa 	srli	r2,r4,23
8112e130:	2806d5fa 	srli	r3,r5,23
8112e134:	01802034 	movhi	r6,128
8112e138:	31bfffc4 	addi	r6,r6,-1
8112e13c:	10803fcc 	andi	r2,r2,255
8112e140:	01c03fc4 	movi	r7,255
8112e144:	3110703a 	and	r8,r6,r4
8112e148:	18c03fcc 	andi	r3,r3,255
8112e14c:	314c703a 	and	r6,r6,r5
8112e150:	2008d7fa 	srli	r4,r4,31
8112e154:	280ad7fa 	srli	r5,r5,31
8112e158:	11c01926 	beq	r2,r7,8112e1c0 <__gesf2+0x94>
8112e15c:	01c03fc4 	movi	r7,255
8112e160:	19c00f26 	beq	r3,r7,8112e1a0 <__gesf2+0x74>
8112e164:	1000061e 	bne	r2,zero,8112e180 <__gesf2+0x54>
8112e168:	400f003a 	cmpeq	r7,r8,zero
8112e16c:	1800071e 	bne	r3,zero,8112e18c <__gesf2+0x60>
8112e170:	3000061e 	bne	r6,zero,8112e18c <__gesf2+0x60>
8112e174:	0005883a 	mov	r2,zero
8112e178:	40000e1e 	bne	r8,zero,8112e1b4 <__gesf2+0x88>
8112e17c:	f800283a 	ret
8112e180:	18000a1e 	bne	r3,zero,8112e1ac <__gesf2+0x80>
8112e184:	30000b26 	beq	r6,zero,8112e1b4 <__gesf2+0x88>
8112e188:	000f883a 	mov	r7,zero
8112e18c:	29403fcc 	andi	r5,r5,255
8112e190:	38000726 	beq	r7,zero,8112e1b0 <__gesf2+0x84>
8112e194:	28000826 	beq	r5,zero,8112e1b8 <__gesf2+0x8c>
8112e198:	00800044 	movi	r2,1
8112e19c:	f800283a 	ret
8112e1a0:	303ff026 	beq	r6,zero,8112e164 <__reset+0xfb10e164>
8112e1a4:	00bfff84 	movi	r2,-2
8112e1a8:	f800283a 	ret
8112e1ac:	29403fcc 	andi	r5,r5,255
8112e1b0:	21400526 	beq	r4,r5,8112e1c8 <__gesf2+0x9c>
8112e1b4:	203ff826 	beq	r4,zero,8112e198 <__reset+0xfb10e198>
8112e1b8:	00bfffc4 	movi	r2,-1
8112e1bc:	f800283a 	ret
8112e1c0:	403fe626 	beq	r8,zero,8112e15c <__reset+0xfb10e15c>
8112e1c4:	003ff706 	br	8112e1a4 <__reset+0xfb10e1a4>
8112e1c8:	18bffa16 	blt	r3,r2,8112e1b4 <__reset+0xfb10e1b4>
8112e1cc:	10c00216 	blt	r2,r3,8112e1d8 <__gesf2+0xac>
8112e1d0:	323ff836 	bltu	r6,r8,8112e1b4 <__reset+0xfb10e1b4>
8112e1d4:	4180022e 	bgeu	r8,r6,8112e1e0 <__gesf2+0xb4>
8112e1d8:	203fef1e 	bne	r4,zero,8112e198 <__reset+0xfb10e198>
8112e1dc:	003ff606 	br	8112e1b8 <__reset+0xfb10e1b8>
8112e1e0:	0005883a 	mov	r2,zero
8112e1e4:	f800283a 	ret

8112e1e8 <__lesf2>:
8112e1e8:	2004d5fa 	srli	r2,r4,23
8112e1ec:	280cd5fa 	srli	r6,r5,23
8112e1f0:	00c02034 	movhi	r3,128
8112e1f4:	18ffffc4 	addi	r3,r3,-1
8112e1f8:	10803fcc 	andi	r2,r2,255
8112e1fc:	01c03fc4 	movi	r7,255
8112e200:	1910703a 	and	r8,r3,r4
8112e204:	31803fcc 	andi	r6,r6,255
8112e208:	1946703a 	and	r3,r3,r5
8112e20c:	2008d7fa 	srli	r4,r4,31
8112e210:	280ad7fa 	srli	r5,r5,31
8112e214:	11c01b26 	beq	r2,r7,8112e284 <__lesf2+0x9c>
8112e218:	01c03fc4 	movi	r7,255
8112e21c:	31c01126 	beq	r6,r7,8112e264 <__lesf2+0x7c>
8112e220:	1000071e 	bne	r2,zero,8112e240 <__lesf2+0x58>
8112e224:	400f003a 	cmpeq	r7,r8,zero
8112e228:	21003fcc 	andi	r4,r4,255
8112e22c:	3000081e 	bne	r6,zero,8112e250 <__lesf2+0x68>
8112e230:	1800071e 	bne	r3,zero,8112e250 <__lesf2+0x68>
8112e234:	0005883a 	mov	r2,zero
8112e238:	40000f1e 	bne	r8,zero,8112e278 <__lesf2+0x90>
8112e23c:	f800283a 	ret
8112e240:	21003fcc 	andi	r4,r4,255
8112e244:	30000a1e 	bne	r6,zero,8112e270 <__lesf2+0x88>
8112e248:	18000b26 	beq	r3,zero,8112e278 <__lesf2+0x90>
8112e24c:	000f883a 	mov	r7,zero
8112e250:	29403fcc 	andi	r5,r5,255
8112e254:	38000726 	beq	r7,zero,8112e274 <__lesf2+0x8c>
8112e258:	28000826 	beq	r5,zero,8112e27c <__lesf2+0x94>
8112e25c:	00800044 	movi	r2,1
8112e260:	f800283a 	ret
8112e264:	183fee26 	beq	r3,zero,8112e220 <__reset+0xfb10e220>
8112e268:	00800084 	movi	r2,2
8112e26c:	f800283a 	ret
8112e270:	29403fcc 	andi	r5,r5,255
8112e274:	21400626 	beq	r4,r5,8112e290 <__lesf2+0xa8>
8112e278:	203ff826 	beq	r4,zero,8112e25c <__reset+0xfb10e25c>
8112e27c:	00bfffc4 	movi	r2,-1
8112e280:	f800283a 	ret
8112e284:	403fe426 	beq	r8,zero,8112e218 <__reset+0xfb10e218>
8112e288:	00800084 	movi	r2,2
8112e28c:	f800283a 	ret
8112e290:	30bff916 	blt	r6,r2,8112e278 <__reset+0xfb10e278>
8112e294:	11800216 	blt	r2,r6,8112e2a0 <__lesf2+0xb8>
8112e298:	1a3ff736 	bltu	r3,r8,8112e278 <__reset+0xfb10e278>
8112e29c:	40c0022e 	bgeu	r8,r3,8112e2a8 <__lesf2+0xc0>
8112e2a0:	203fee1e 	bne	r4,zero,8112e25c <__reset+0xfb10e25c>
8112e2a4:	003ff506 	br	8112e27c <__reset+0xfb10e27c>
8112e2a8:	0005883a 	mov	r2,zero
8112e2ac:	f800283a 	ret

8112e2b0 <__adddf3>:
8112e2b0:	02c00434 	movhi	r11,16
8112e2b4:	5affffc4 	addi	r11,r11,-1
8112e2b8:	2806d7fa 	srli	r3,r5,31
8112e2bc:	2ad4703a 	and	r10,r5,r11
8112e2c0:	3ad2703a 	and	r9,r7,r11
8112e2c4:	3804d53a 	srli	r2,r7,20
8112e2c8:	3018d77a 	srli	r12,r6,29
8112e2cc:	280ad53a 	srli	r5,r5,20
8112e2d0:	501490fa 	slli	r10,r10,3
8112e2d4:	2010d77a 	srli	r8,r4,29
8112e2d8:	481290fa 	slli	r9,r9,3
8112e2dc:	380ed7fa 	srli	r7,r7,31
8112e2e0:	defffb04 	addi	sp,sp,-20
8112e2e4:	de00012e 	bgeu	sp,et,8112e2ec <__adddf3+0x3c>
8112e2e8:	003b68fa 	trap	3
8112e2ec:	dc800215 	stw	r18,8(sp)
8112e2f0:	dc400115 	stw	r17,4(sp)
8112e2f4:	dc000015 	stw	r16,0(sp)
8112e2f8:	dfc00415 	stw	ra,16(sp)
8112e2fc:	dcc00315 	stw	r19,12(sp)
8112e300:	1c803fcc 	andi	r18,r3,255
8112e304:	2c01ffcc 	andi	r16,r5,2047
8112e308:	5210b03a 	or	r8,r10,r8
8112e30c:	202290fa 	slli	r17,r4,3
8112e310:	1081ffcc 	andi	r2,r2,2047
8112e314:	4b12b03a 	or	r9,r9,r12
8112e318:	300c90fa 	slli	r6,r6,3
8112e31c:	91c07526 	beq	r18,r7,8112e4f4 <__adddf3+0x244>
8112e320:	8087c83a 	sub	r3,r16,r2
8112e324:	00c0ab0e 	bge	zero,r3,8112e5d4 <__adddf3+0x324>
8112e328:	10002a1e 	bne	r2,zero,8112e3d4 <__adddf3+0x124>
8112e32c:	4984b03a 	or	r2,r9,r6
8112e330:	1000961e 	bne	r2,zero,8112e58c <__adddf3+0x2dc>
8112e334:	888001cc 	andi	r2,r17,7
8112e338:	10000726 	beq	r2,zero,8112e358 <__adddf3+0xa8>
8112e33c:	888003cc 	andi	r2,r17,15
8112e340:	00c00104 	movi	r3,4
8112e344:	10c00426 	beq	r2,r3,8112e358 <__adddf3+0xa8>
8112e348:	88c7883a 	add	r3,r17,r3
8112e34c:	1c63803a 	cmpltu	r17,r3,r17
8112e350:	4451883a 	add	r8,r8,r17
8112e354:	1823883a 	mov	r17,r3
8112e358:	4080202c 	andhi	r2,r8,128
8112e35c:	10005926 	beq	r2,zero,8112e4c4 <__adddf3+0x214>
8112e360:	84000044 	addi	r16,r16,1
8112e364:	0081ffc4 	movi	r2,2047
8112e368:	8080ba26 	beq	r16,r2,8112e654 <__adddf3+0x3a4>
8112e36c:	00bfe034 	movhi	r2,65408
8112e370:	10bfffc4 	addi	r2,r2,-1
8112e374:	4090703a 	and	r8,r8,r2
8112e378:	4004977a 	slli	r2,r8,29
8112e37c:	4010927a 	slli	r8,r8,9
8112e380:	8822d0fa 	srli	r17,r17,3
8112e384:	8401ffcc 	andi	r16,r16,2047
8112e388:	4010d33a 	srli	r8,r8,12
8112e38c:	9007883a 	mov	r3,r18
8112e390:	1444b03a 	or	r2,r2,r17
8112e394:	8401ffcc 	andi	r16,r16,2047
8112e398:	8020953a 	slli	r16,r16,20
8112e39c:	18c03fcc 	andi	r3,r3,255
8112e3a0:	01000434 	movhi	r4,16
8112e3a4:	213fffc4 	addi	r4,r4,-1
8112e3a8:	180697fa 	slli	r3,r3,31
8112e3ac:	4110703a 	and	r8,r8,r4
8112e3b0:	4410b03a 	or	r8,r8,r16
8112e3b4:	40c6b03a 	or	r3,r8,r3
8112e3b8:	dfc00417 	ldw	ra,16(sp)
8112e3bc:	dcc00317 	ldw	r19,12(sp)
8112e3c0:	dc800217 	ldw	r18,8(sp)
8112e3c4:	dc400117 	ldw	r17,4(sp)
8112e3c8:	dc000017 	ldw	r16,0(sp)
8112e3cc:	dec00504 	addi	sp,sp,20
8112e3d0:	f800283a 	ret
8112e3d4:	0081ffc4 	movi	r2,2047
8112e3d8:	80bfd626 	beq	r16,r2,8112e334 <__reset+0xfb10e334>
8112e3dc:	4a402034 	orhi	r9,r9,128
8112e3e0:	00800e04 	movi	r2,56
8112e3e4:	10c09f16 	blt	r2,r3,8112e664 <__adddf3+0x3b4>
8112e3e8:	008007c4 	movi	r2,31
8112e3ec:	10c0c216 	blt	r2,r3,8112e6f8 <__adddf3+0x448>
8112e3f0:	00800804 	movi	r2,32
8112e3f4:	10c5c83a 	sub	r2,r2,r3
8112e3f8:	488a983a 	sll	r5,r9,r2
8112e3fc:	30c8d83a 	srl	r4,r6,r3
8112e400:	3084983a 	sll	r2,r6,r2
8112e404:	48c6d83a 	srl	r3,r9,r3
8112e408:	290cb03a 	or	r6,r5,r4
8112e40c:	1004c03a 	cmpne	r2,r2,zero
8112e410:	308cb03a 	or	r6,r6,r2
8112e414:	898dc83a 	sub	r6,r17,r6
8112e418:	89a3803a 	cmpltu	r17,r17,r6
8112e41c:	40d1c83a 	sub	r8,r8,r3
8112e420:	4451c83a 	sub	r8,r8,r17
8112e424:	3023883a 	mov	r17,r6
8112e428:	4080202c 	andhi	r2,r8,128
8112e42c:	10002326 	beq	r2,zero,8112e4bc <__adddf3+0x20c>
8112e430:	04c02034 	movhi	r19,128
8112e434:	9cffffc4 	addi	r19,r19,-1
8112e438:	44e6703a 	and	r19,r8,r19
8112e43c:	98007626 	beq	r19,zero,8112e618 <__adddf3+0x368>
8112e440:	9809883a 	mov	r4,r19
8112e444:	111a7a00 	call	8111a7a0 <__clzsi2>
8112e448:	10fffe04 	addi	r3,r2,-8
8112e44c:	010007c4 	movi	r4,31
8112e450:	20c07716 	blt	r4,r3,8112e630 <__adddf3+0x380>
8112e454:	00800804 	movi	r2,32
8112e458:	10c5c83a 	sub	r2,r2,r3
8112e45c:	8884d83a 	srl	r2,r17,r2
8112e460:	98d0983a 	sll	r8,r19,r3
8112e464:	88e2983a 	sll	r17,r17,r3
8112e468:	1204b03a 	or	r2,r2,r8
8112e46c:	1c007416 	blt	r3,r16,8112e640 <__adddf3+0x390>
8112e470:	1c21c83a 	sub	r16,r3,r16
8112e474:	82000044 	addi	r8,r16,1
8112e478:	00c007c4 	movi	r3,31
8112e47c:	1a009116 	blt	r3,r8,8112e6c4 <__adddf3+0x414>
8112e480:	00c00804 	movi	r3,32
8112e484:	1a07c83a 	sub	r3,r3,r8
8112e488:	8a08d83a 	srl	r4,r17,r8
8112e48c:	88e2983a 	sll	r17,r17,r3
8112e490:	10c6983a 	sll	r3,r2,r3
8112e494:	1210d83a 	srl	r8,r2,r8
8112e498:	8804c03a 	cmpne	r2,r17,zero
8112e49c:	1906b03a 	or	r3,r3,r4
8112e4a0:	18a2b03a 	or	r17,r3,r2
8112e4a4:	0021883a 	mov	r16,zero
8112e4a8:	003fa206 	br	8112e334 <__reset+0xfb10e334>
8112e4ac:	1890b03a 	or	r8,r3,r2
8112e4b0:	40017d26 	beq	r8,zero,8112eaa8 <__adddf3+0x7f8>
8112e4b4:	1011883a 	mov	r8,r2
8112e4b8:	1823883a 	mov	r17,r3
8112e4bc:	888001cc 	andi	r2,r17,7
8112e4c0:	103f9e1e 	bne	r2,zero,8112e33c <__reset+0xfb10e33c>
8112e4c4:	4004977a 	slli	r2,r8,29
8112e4c8:	8822d0fa 	srli	r17,r17,3
8112e4cc:	4010d0fa 	srli	r8,r8,3
8112e4d0:	9007883a 	mov	r3,r18
8112e4d4:	1444b03a 	or	r2,r2,r17
8112e4d8:	0101ffc4 	movi	r4,2047
8112e4dc:	81002426 	beq	r16,r4,8112e570 <__adddf3+0x2c0>
8112e4e0:	8120703a 	and	r16,r16,r4
8112e4e4:	01000434 	movhi	r4,16
8112e4e8:	213fffc4 	addi	r4,r4,-1
8112e4ec:	4110703a 	and	r8,r8,r4
8112e4f0:	003fa806 	br	8112e394 <__reset+0xfb10e394>
8112e4f4:	8089c83a 	sub	r4,r16,r2
8112e4f8:	01005e0e 	bge	zero,r4,8112e674 <__adddf3+0x3c4>
8112e4fc:	10002b26 	beq	r2,zero,8112e5ac <__adddf3+0x2fc>
8112e500:	0081ffc4 	movi	r2,2047
8112e504:	80bf8b26 	beq	r16,r2,8112e334 <__reset+0xfb10e334>
8112e508:	4a402034 	orhi	r9,r9,128
8112e50c:	00800e04 	movi	r2,56
8112e510:	1100a40e 	bge	r2,r4,8112e7a4 <__adddf3+0x4f4>
8112e514:	498cb03a 	or	r6,r9,r6
8112e518:	300ac03a 	cmpne	r5,r6,zero
8112e51c:	0013883a 	mov	r9,zero
8112e520:	2c4b883a 	add	r5,r5,r17
8112e524:	2c63803a 	cmpltu	r17,r5,r17
8112e528:	4a11883a 	add	r8,r9,r8
8112e52c:	8a11883a 	add	r8,r17,r8
8112e530:	2823883a 	mov	r17,r5
8112e534:	4080202c 	andhi	r2,r8,128
8112e538:	103fe026 	beq	r2,zero,8112e4bc <__reset+0xfb10e4bc>
8112e53c:	84000044 	addi	r16,r16,1
8112e540:	0081ffc4 	movi	r2,2047
8112e544:	8080d226 	beq	r16,r2,8112e890 <__adddf3+0x5e0>
8112e548:	00bfe034 	movhi	r2,65408
8112e54c:	10bfffc4 	addi	r2,r2,-1
8112e550:	4090703a 	and	r8,r8,r2
8112e554:	880ad07a 	srli	r5,r17,1
8112e558:	400897fa 	slli	r4,r8,31
8112e55c:	88c0004c 	andi	r3,r17,1
8112e560:	28e2b03a 	or	r17,r5,r3
8112e564:	4010d07a 	srli	r8,r8,1
8112e568:	2462b03a 	or	r17,r4,r17
8112e56c:	003f7106 	br	8112e334 <__reset+0xfb10e334>
8112e570:	4088b03a 	or	r4,r8,r2
8112e574:	20014526 	beq	r4,zero,8112ea8c <__adddf3+0x7dc>
8112e578:	01000434 	movhi	r4,16
8112e57c:	42000234 	orhi	r8,r8,8
8112e580:	213fffc4 	addi	r4,r4,-1
8112e584:	4110703a 	and	r8,r8,r4
8112e588:	003f8206 	br	8112e394 <__reset+0xfb10e394>
8112e58c:	18ffffc4 	addi	r3,r3,-1
8112e590:	1800491e 	bne	r3,zero,8112e6b8 <__adddf3+0x408>
8112e594:	898bc83a 	sub	r5,r17,r6
8112e598:	8963803a 	cmpltu	r17,r17,r5
8112e59c:	4251c83a 	sub	r8,r8,r9
8112e5a0:	4451c83a 	sub	r8,r8,r17
8112e5a4:	2823883a 	mov	r17,r5
8112e5a8:	003f9f06 	br	8112e428 <__reset+0xfb10e428>
8112e5ac:	4984b03a 	or	r2,r9,r6
8112e5b0:	103f6026 	beq	r2,zero,8112e334 <__reset+0xfb10e334>
8112e5b4:	213fffc4 	addi	r4,r4,-1
8112e5b8:	2000931e 	bne	r4,zero,8112e808 <__adddf3+0x558>
8112e5bc:	898d883a 	add	r6,r17,r6
8112e5c0:	3463803a 	cmpltu	r17,r6,r17
8112e5c4:	4251883a 	add	r8,r8,r9
8112e5c8:	8a11883a 	add	r8,r17,r8
8112e5cc:	3023883a 	mov	r17,r6
8112e5d0:	003fd806 	br	8112e534 <__reset+0xfb10e534>
8112e5d4:	1800541e 	bne	r3,zero,8112e728 <__adddf3+0x478>
8112e5d8:	80800044 	addi	r2,r16,1
8112e5dc:	1081ffcc 	andi	r2,r2,2047
8112e5e0:	00c00044 	movi	r3,1
8112e5e4:	1880a00e 	bge	r3,r2,8112e868 <__adddf3+0x5b8>
8112e5e8:	8989c83a 	sub	r4,r17,r6
8112e5ec:	8905803a 	cmpltu	r2,r17,r4
8112e5f0:	4267c83a 	sub	r19,r8,r9
8112e5f4:	98a7c83a 	sub	r19,r19,r2
8112e5f8:	9880202c 	andhi	r2,r19,128
8112e5fc:	10006326 	beq	r2,zero,8112e78c <__adddf3+0x4dc>
8112e600:	3463c83a 	sub	r17,r6,r17
8112e604:	4a07c83a 	sub	r3,r9,r8
8112e608:	344d803a 	cmpltu	r6,r6,r17
8112e60c:	19a7c83a 	sub	r19,r3,r6
8112e610:	3825883a 	mov	r18,r7
8112e614:	983f8a1e 	bne	r19,zero,8112e440 <__reset+0xfb10e440>
8112e618:	8809883a 	mov	r4,r17
8112e61c:	111a7a00 	call	8111a7a0 <__clzsi2>
8112e620:	10800804 	addi	r2,r2,32
8112e624:	10fffe04 	addi	r3,r2,-8
8112e628:	010007c4 	movi	r4,31
8112e62c:	20ff890e 	bge	r4,r3,8112e454 <__reset+0xfb10e454>
8112e630:	10bff604 	addi	r2,r2,-40
8112e634:	8884983a 	sll	r2,r17,r2
8112e638:	0023883a 	mov	r17,zero
8112e63c:	1c3f8c0e 	bge	r3,r16,8112e470 <__reset+0xfb10e470>
8112e640:	023fe034 	movhi	r8,65408
8112e644:	423fffc4 	addi	r8,r8,-1
8112e648:	80e1c83a 	sub	r16,r16,r3
8112e64c:	1210703a 	and	r8,r2,r8
8112e650:	003f3806 	br	8112e334 <__reset+0xfb10e334>
8112e654:	9007883a 	mov	r3,r18
8112e658:	0011883a 	mov	r8,zero
8112e65c:	0005883a 	mov	r2,zero
8112e660:	003f4c06 	br	8112e394 <__reset+0xfb10e394>
8112e664:	498cb03a 	or	r6,r9,r6
8112e668:	300cc03a 	cmpne	r6,r6,zero
8112e66c:	0007883a 	mov	r3,zero
8112e670:	003f6806 	br	8112e414 <__reset+0xfb10e414>
8112e674:	20009c1e 	bne	r4,zero,8112e8e8 <__adddf3+0x638>
8112e678:	80800044 	addi	r2,r16,1
8112e67c:	1141ffcc 	andi	r5,r2,2047
8112e680:	01000044 	movi	r4,1
8112e684:	2140670e 	bge	r4,r5,8112e824 <__adddf3+0x574>
8112e688:	0101ffc4 	movi	r4,2047
8112e68c:	11007f26 	beq	r2,r4,8112e88c <__adddf3+0x5dc>
8112e690:	898d883a 	add	r6,r17,r6
8112e694:	4247883a 	add	r3,r8,r9
8112e698:	3451803a 	cmpltu	r8,r6,r17
8112e69c:	40d1883a 	add	r8,r8,r3
8112e6a0:	402297fa 	slli	r17,r8,31
8112e6a4:	300cd07a 	srli	r6,r6,1
8112e6a8:	4010d07a 	srli	r8,r8,1
8112e6ac:	1021883a 	mov	r16,r2
8112e6b0:	89a2b03a 	or	r17,r17,r6
8112e6b4:	003f1f06 	br	8112e334 <__reset+0xfb10e334>
8112e6b8:	0081ffc4 	movi	r2,2047
8112e6bc:	80bf481e 	bne	r16,r2,8112e3e0 <__reset+0xfb10e3e0>
8112e6c0:	003f1c06 	br	8112e334 <__reset+0xfb10e334>
8112e6c4:	843ff844 	addi	r16,r16,-31
8112e6c8:	01000804 	movi	r4,32
8112e6cc:	1406d83a 	srl	r3,r2,r16
8112e6d0:	41005026 	beq	r8,r4,8112e814 <__adddf3+0x564>
8112e6d4:	01001004 	movi	r4,64
8112e6d8:	2211c83a 	sub	r8,r4,r8
8112e6dc:	1204983a 	sll	r2,r2,r8
8112e6e0:	88a2b03a 	or	r17,r17,r2
8112e6e4:	8822c03a 	cmpne	r17,r17,zero
8112e6e8:	1c62b03a 	or	r17,r3,r17
8112e6ec:	0011883a 	mov	r8,zero
8112e6f0:	0021883a 	mov	r16,zero
8112e6f4:	003f7106 	br	8112e4bc <__reset+0xfb10e4bc>
8112e6f8:	193ff804 	addi	r4,r3,-32
8112e6fc:	00800804 	movi	r2,32
8112e700:	4908d83a 	srl	r4,r9,r4
8112e704:	18804526 	beq	r3,r2,8112e81c <__adddf3+0x56c>
8112e708:	00801004 	movi	r2,64
8112e70c:	10c5c83a 	sub	r2,r2,r3
8112e710:	4886983a 	sll	r3,r9,r2
8112e714:	198cb03a 	or	r6,r3,r6
8112e718:	300cc03a 	cmpne	r6,r6,zero
8112e71c:	218cb03a 	or	r6,r4,r6
8112e720:	0007883a 	mov	r3,zero
8112e724:	003f3b06 	br	8112e414 <__reset+0xfb10e414>
8112e728:	80002a26 	beq	r16,zero,8112e7d4 <__adddf3+0x524>
8112e72c:	0101ffc4 	movi	r4,2047
8112e730:	11006826 	beq	r2,r4,8112e8d4 <__adddf3+0x624>
8112e734:	00c7c83a 	sub	r3,zero,r3
8112e738:	42002034 	orhi	r8,r8,128
8112e73c:	01000e04 	movi	r4,56
8112e740:	20c07c16 	blt	r4,r3,8112e934 <__adddf3+0x684>
8112e744:	010007c4 	movi	r4,31
8112e748:	20c0da16 	blt	r4,r3,8112eab4 <__adddf3+0x804>
8112e74c:	01000804 	movi	r4,32
8112e750:	20c9c83a 	sub	r4,r4,r3
8112e754:	4114983a 	sll	r10,r8,r4
8112e758:	88cad83a 	srl	r5,r17,r3
8112e75c:	8908983a 	sll	r4,r17,r4
8112e760:	40c6d83a 	srl	r3,r8,r3
8112e764:	5162b03a 	or	r17,r10,r5
8112e768:	2008c03a 	cmpne	r4,r4,zero
8112e76c:	8922b03a 	or	r17,r17,r4
8112e770:	3463c83a 	sub	r17,r6,r17
8112e774:	48c7c83a 	sub	r3,r9,r3
8112e778:	344d803a 	cmpltu	r6,r6,r17
8112e77c:	1991c83a 	sub	r8,r3,r6
8112e780:	1021883a 	mov	r16,r2
8112e784:	3825883a 	mov	r18,r7
8112e788:	003f2706 	br	8112e428 <__reset+0xfb10e428>
8112e78c:	24d0b03a 	or	r8,r4,r19
8112e790:	40001b1e 	bne	r8,zero,8112e800 <__adddf3+0x550>
8112e794:	0005883a 	mov	r2,zero
8112e798:	0007883a 	mov	r3,zero
8112e79c:	0021883a 	mov	r16,zero
8112e7a0:	003f4d06 	br	8112e4d8 <__reset+0xfb10e4d8>
8112e7a4:	008007c4 	movi	r2,31
8112e7a8:	11003c16 	blt	r2,r4,8112e89c <__adddf3+0x5ec>
8112e7ac:	00800804 	movi	r2,32
8112e7b0:	1105c83a 	sub	r2,r2,r4
8112e7b4:	488e983a 	sll	r7,r9,r2
8112e7b8:	310ad83a 	srl	r5,r6,r4
8112e7bc:	3084983a 	sll	r2,r6,r2
8112e7c0:	4912d83a 	srl	r9,r9,r4
8112e7c4:	394ab03a 	or	r5,r7,r5
8112e7c8:	1004c03a 	cmpne	r2,r2,zero
8112e7cc:	288ab03a 	or	r5,r5,r2
8112e7d0:	003f5306 	br	8112e520 <__reset+0xfb10e520>
8112e7d4:	4448b03a 	or	r4,r8,r17
8112e7d8:	20003e26 	beq	r4,zero,8112e8d4 <__adddf3+0x624>
8112e7dc:	00c6303a 	nor	r3,zero,r3
8112e7e0:	18003a1e 	bne	r3,zero,8112e8cc <__adddf3+0x61c>
8112e7e4:	3463c83a 	sub	r17,r6,r17
8112e7e8:	4a07c83a 	sub	r3,r9,r8
8112e7ec:	344d803a 	cmpltu	r6,r6,r17
8112e7f0:	1991c83a 	sub	r8,r3,r6
8112e7f4:	1021883a 	mov	r16,r2
8112e7f8:	3825883a 	mov	r18,r7
8112e7fc:	003f0a06 	br	8112e428 <__reset+0xfb10e428>
8112e800:	2023883a 	mov	r17,r4
8112e804:	003f0d06 	br	8112e43c <__reset+0xfb10e43c>
8112e808:	0081ffc4 	movi	r2,2047
8112e80c:	80bf3f1e 	bne	r16,r2,8112e50c <__reset+0xfb10e50c>
8112e810:	003ec806 	br	8112e334 <__reset+0xfb10e334>
8112e814:	0005883a 	mov	r2,zero
8112e818:	003fb106 	br	8112e6e0 <__reset+0xfb10e6e0>
8112e81c:	0007883a 	mov	r3,zero
8112e820:	003fbc06 	br	8112e714 <__reset+0xfb10e714>
8112e824:	4444b03a 	or	r2,r8,r17
8112e828:	8000871e 	bne	r16,zero,8112ea48 <__adddf3+0x798>
8112e82c:	1000ba26 	beq	r2,zero,8112eb18 <__adddf3+0x868>
8112e830:	4984b03a 	or	r2,r9,r6
8112e834:	103ebf26 	beq	r2,zero,8112e334 <__reset+0xfb10e334>
8112e838:	8985883a 	add	r2,r17,r6
8112e83c:	4247883a 	add	r3,r8,r9
8112e840:	1451803a 	cmpltu	r8,r2,r17
8112e844:	40d1883a 	add	r8,r8,r3
8112e848:	40c0202c 	andhi	r3,r8,128
8112e84c:	1023883a 	mov	r17,r2
8112e850:	183f1a26 	beq	r3,zero,8112e4bc <__reset+0xfb10e4bc>
8112e854:	00bfe034 	movhi	r2,65408
8112e858:	10bfffc4 	addi	r2,r2,-1
8112e85c:	2021883a 	mov	r16,r4
8112e860:	4090703a 	and	r8,r8,r2
8112e864:	003eb306 	br	8112e334 <__reset+0xfb10e334>
8112e868:	4444b03a 	or	r2,r8,r17
8112e86c:	8000291e 	bne	r16,zero,8112e914 <__adddf3+0x664>
8112e870:	10004b1e 	bne	r2,zero,8112e9a0 <__adddf3+0x6f0>
8112e874:	4990b03a 	or	r8,r9,r6
8112e878:	40008b26 	beq	r8,zero,8112eaa8 <__adddf3+0x7f8>
8112e87c:	4811883a 	mov	r8,r9
8112e880:	3023883a 	mov	r17,r6
8112e884:	3825883a 	mov	r18,r7
8112e888:	003eaa06 	br	8112e334 <__reset+0xfb10e334>
8112e88c:	1021883a 	mov	r16,r2
8112e890:	0011883a 	mov	r8,zero
8112e894:	0005883a 	mov	r2,zero
8112e898:	003f0f06 	br	8112e4d8 <__reset+0xfb10e4d8>
8112e89c:	217ff804 	addi	r5,r4,-32
8112e8a0:	00800804 	movi	r2,32
8112e8a4:	494ad83a 	srl	r5,r9,r5
8112e8a8:	20807d26 	beq	r4,r2,8112eaa0 <__adddf3+0x7f0>
8112e8ac:	00801004 	movi	r2,64
8112e8b0:	1109c83a 	sub	r4,r2,r4
8112e8b4:	4912983a 	sll	r9,r9,r4
8112e8b8:	498cb03a 	or	r6,r9,r6
8112e8bc:	300cc03a 	cmpne	r6,r6,zero
8112e8c0:	298ab03a 	or	r5,r5,r6
8112e8c4:	0013883a 	mov	r9,zero
8112e8c8:	003f1506 	br	8112e520 <__reset+0xfb10e520>
8112e8cc:	0101ffc4 	movi	r4,2047
8112e8d0:	113f9a1e 	bne	r2,r4,8112e73c <__reset+0xfb10e73c>
8112e8d4:	4811883a 	mov	r8,r9
8112e8d8:	3023883a 	mov	r17,r6
8112e8dc:	1021883a 	mov	r16,r2
8112e8e0:	3825883a 	mov	r18,r7
8112e8e4:	003e9306 	br	8112e334 <__reset+0xfb10e334>
8112e8e8:	8000161e 	bne	r16,zero,8112e944 <__adddf3+0x694>
8112e8ec:	444ab03a 	or	r5,r8,r17
8112e8f0:	28005126 	beq	r5,zero,8112ea38 <__adddf3+0x788>
8112e8f4:	0108303a 	nor	r4,zero,r4
8112e8f8:	20004d1e 	bne	r4,zero,8112ea30 <__adddf3+0x780>
8112e8fc:	89a3883a 	add	r17,r17,r6
8112e900:	4253883a 	add	r9,r8,r9
8112e904:	898d803a 	cmpltu	r6,r17,r6
8112e908:	3251883a 	add	r8,r6,r9
8112e90c:	1021883a 	mov	r16,r2
8112e910:	003f0806 	br	8112e534 <__reset+0xfb10e534>
8112e914:	1000301e 	bne	r2,zero,8112e9d8 <__adddf3+0x728>
8112e918:	4984b03a 	or	r2,r9,r6
8112e91c:	10007126 	beq	r2,zero,8112eae4 <__adddf3+0x834>
8112e920:	4811883a 	mov	r8,r9
8112e924:	3023883a 	mov	r17,r6
8112e928:	3825883a 	mov	r18,r7
8112e92c:	0401ffc4 	movi	r16,2047
8112e930:	003e8006 	br	8112e334 <__reset+0xfb10e334>
8112e934:	4462b03a 	or	r17,r8,r17
8112e938:	8822c03a 	cmpne	r17,r17,zero
8112e93c:	0007883a 	mov	r3,zero
8112e940:	003f8b06 	br	8112e770 <__reset+0xfb10e770>
8112e944:	0141ffc4 	movi	r5,2047
8112e948:	11403b26 	beq	r2,r5,8112ea38 <__adddf3+0x788>
8112e94c:	0109c83a 	sub	r4,zero,r4
8112e950:	42002034 	orhi	r8,r8,128
8112e954:	01400e04 	movi	r5,56
8112e958:	29006716 	blt	r5,r4,8112eaf8 <__adddf3+0x848>
8112e95c:	014007c4 	movi	r5,31
8112e960:	29007016 	blt	r5,r4,8112eb24 <__adddf3+0x874>
8112e964:	01400804 	movi	r5,32
8112e968:	290bc83a 	sub	r5,r5,r4
8112e96c:	4154983a 	sll	r10,r8,r5
8112e970:	890ed83a 	srl	r7,r17,r4
8112e974:	894a983a 	sll	r5,r17,r5
8112e978:	4108d83a 	srl	r4,r8,r4
8112e97c:	51e2b03a 	or	r17,r10,r7
8112e980:	280ac03a 	cmpne	r5,r5,zero
8112e984:	8962b03a 	or	r17,r17,r5
8112e988:	89a3883a 	add	r17,r17,r6
8112e98c:	2253883a 	add	r9,r4,r9
8112e990:	898d803a 	cmpltu	r6,r17,r6
8112e994:	3251883a 	add	r8,r6,r9
8112e998:	1021883a 	mov	r16,r2
8112e99c:	003ee506 	br	8112e534 <__reset+0xfb10e534>
8112e9a0:	4984b03a 	or	r2,r9,r6
8112e9a4:	103e6326 	beq	r2,zero,8112e334 <__reset+0xfb10e334>
8112e9a8:	8987c83a 	sub	r3,r17,r6
8112e9ac:	88c9803a 	cmpltu	r4,r17,r3
8112e9b0:	4245c83a 	sub	r2,r8,r9
8112e9b4:	1105c83a 	sub	r2,r2,r4
8112e9b8:	1100202c 	andhi	r4,r2,128
8112e9bc:	203ebb26 	beq	r4,zero,8112e4ac <__reset+0xfb10e4ac>
8112e9c0:	3463c83a 	sub	r17,r6,r17
8112e9c4:	4a07c83a 	sub	r3,r9,r8
8112e9c8:	344d803a 	cmpltu	r6,r6,r17
8112e9cc:	1991c83a 	sub	r8,r3,r6
8112e9d0:	3825883a 	mov	r18,r7
8112e9d4:	003e5706 	br	8112e334 <__reset+0xfb10e334>
8112e9d8:	4984b03a 	or	r2,r9,r6
8112e9dc:	10002e26 	beq	r2,zero,8112ea98 <__adddf3+0x7e8>
8112e9e0:	4004d0fa 	srli	r2,r8,3
8112e9e4:	8822d0fa 	srli	r17,r17,3
8112e9e8:	4010977a 	slli	r8,r8,29
8112e9ec:	10c0022c 	andhi	r3,r2,8
8112e9f0:	4462b03a 	or	r17,r8,r17
8112e9f4:	18000826 	beq	r3,zero,8112ea18 <__adddf3+0x768>
8112e9f8:	4808d0fa 	srli	r4,r9,3
8112e9fc:	20c0022c 	andhi	r3,r4,8
8112ea00:	1800051e 	bne	r3,zero,8112ea18 <__adddf3+0x768>
8112ea04:	300cd0fa 	srli	r6,r6,3
8112ea08:	4806977a 	slli	r3,r9,29
8112ea0c:	2005883a 	mov	r2,r4
8112ea10:	3825883a 	mov	r18,r7
8112ea14:	19a2b03a 	or	r17,r3,r6
8112ea18:	8810d77a 	srli	r8,r17,29
8112ea1c:	100490fa 	slli	r2,r2,3
8112ea20:	882290fa 	slli	r17,r17,3
8112ea24:	0401ffc4 	movi	r16,2047
8112ea28:	4090b03a 	or	r8,r8,r2
8112ea2c:	003e4106 	br	8112e334 <__reset+0xfb10e334>
8112ea30:	0141ffc4 	movi	r5,2047
8112ea34:	117fc71e 	bne	r2,r5,8112e954 <__reset+0xfb10e954>
8112ea38:	4811883a 	mov	r8,r9
8112ea3c:	3023883a 	mov	r17,r6
8112ea40:	1021883a 	mov	r16,r2
8112ea44:	003e3b06 	br	8112e334 <__reset+0xfb10e334>
8112ea48:	10002f26 	beq	r2,zero,8112eb08 <__adddf3+0x858>
8112ea4c:	4984b03a 	or	r2,r9,r6
8112ea50:	10001126 	beq	r2,zero,8112ea98 <__adddf3+0x7e8>
8112ea54:	4004d0fa 	srli	r2,r8,3
8112ea58:	8822d0fa 	srli	r17,r17,3
8112ea5c:	4010977a 	slli	r8,r8,29
8112ea60:	10c0022c 	andhi	r3,r2,8
8112ea64:	4462b03a 	or	r17,r8,r17
8112ea68:	183feb26 	beq	r3,zero,8112ea18 <__reset+0xfb10ea18>
8112ea6c:	4808d0fa 	srli	r4,r9,3
8112ea70:	20c0022c 	andhi	r3,r4,8
8112ea74:	183fe81e 	bne	r3,zero,8112ea18 <__reset+0xfb10ea18>
8112ea78:	300cd0fa 	srli	r6,r6,3
8112ea7c:	4806977a 	slli	r3,r9,29
8112ea80:	2005883a 	mov	r2,r4
8112ea84:	19a2b03a 	or	r17,r3,r6
8112ea88:	003fe306 	br	8112ea18 <__reset+0xfb10ea18>
8112ea8c:	0011883a 	mov	r8,zero
8112ea90:	0005883a 	mov	r2,zero
8112ea94:	003e3f06 	br	8112e394 <__reset+0xfb10e394>
8112ea98:	0401ffc4 	movi	r16,2047
8112ea9c:	003e2506 	br	8112e334 <__reset+0xfb10e334>
8112eaa0:	0013883a 	mov	r9,zero
8112eaa4:	003f8406 	br	8112e8b8 <__reset+0xfb10e8b8>
8112eaa8:	0005883a 	mov	r2,zero
8112eaac:	0007883a 	mov	r3,zero
8112eab0:	003e8906 	br	8112e4d8 <__reset+0xfb10e4d8>
8112eab4:	197ff804 	addi	r5,r3,-32
8112eab8:	01000804 	movi	r4,32
8112eabc:	414ad83a 	srl	r5,r8,r5
8112eac0:	19002426 	beq	r3,r4,8112eb54 <__adddf3+0x8a4>
8112eac4:	01001004 	movi	r4,64
8112eac8:	20c7c83a 	sub	r3,r4,r3
8112eacc:	40c6983a 	sll	r3,r8,r3
8112ead0:	1c46b03a 	or	r3,r3,r17
8112ead4:	1806c03a 	cmpne	r3,r3,zero
8112ead8:	28e2b03a 	or	r17,r5,r3
8112eadc:	0007883a 	mov	r3,zero
8112eae0:	003f2306 	br	8112e770 <__reset+0xfb10e770>
8112eae4:	0007883a 	mov	r3,zero
8112eae8:	5811883a 	mov	r8,r11
8112eaec:	00bfffc4 	movi	r2,-1
8112eaf0:	0401ffc4 	movi	r16,2047
8112eaf4:	003e7806 	br	8112e4d8 <__reset+0xfb10e4d8>
8112eaf8:	4462b03a 	or	r17,r8,r17
8112eafc:	8822c03a 	cmpne	r17,r17,zero
8112eb00:	0009883a 	mov	r4,zero
8112eb04:	003fa006 	br	8112e988 <__reset+0xfb10e988>
8112eb08:	4811883a 	mov	r8,r9
8112eb0c:	3023883a 	mov	r17,r6
8112eb10:	0401ffc4 	movi	r16,2047
8112eb14:	003e0706 	br	8112e334 <__reset+0xfb10e334>
8112eb18:	4811883a 	mov	r8,r9
8112eb1c:	3023883a 	mov	r17,r6
8112eb20:	003e0406 	br	8112e334 <__reset+0xfb10e334>
8112eb24:	21fff804 	addi	r7,r4,-32
8112eb28:	01400804 	movi	r5,32
8112eb2c:	41ced83a 	srl	r7,r8,r7
8112eb30:	21400a26 	beq	r4,r5,8112eb5c <__adddf3+0x8ac>
8112eb34:	01401004 	movi	r5,64
8112eb38:	2909c83a 	sub	r4,r5,r4
8112eb3c:	4108983a 	sll	r4,r8,r4
8112eb40:	2448b03a 	or	r4,r4,r17
8112eb44:	2008c03a 	cmpne	r4,r4,zero
8112eb48:	3922b03a 	or	r17,r7,r4
8112eb4c:	0009883a 	mov	r4,zero
8112eb50:	003f8d06 	br	8112e988 <__reset+0xfb10e988>
8112eb54:	0007883a 	mov	r3,zero
8112eb58:	003fdd06 	br	8112ead0 <__reset+0xfb10ead0>
8112eb5c:	0009883a 	mov	r4,zero
8112eb60:	003ff706 	br	8112eb40 <__reset+0xfb10eb40>

8112eb64 <__divdf3>:
8112eb64:	defff204 	addi	sp,sp,-56
8112eb68:	de00012e 	bgeu	sp,et,8112eb70 <__divdf3+0xc>
8112eb6c:	003b68fa 	trap	3
8112eb70:	dd400915 	stw	r21,36(sp)
8112eb74:	282ad53a 	srli	r21,r5,20
8112eb78:	dd000815 	stw	r20,32(sp)
8112eb7c:	2828d7fa 	srli	r20,r5,31
8112eb80:	dc000415 	stw	r16,16(sp)
8112eb84:	04000434 	movhi	r16,16
8112eb88:	df000c15 	stw	fp,48(sp)
8112eb8c:	843fffc4 	addi	r16,r16,-1
8112eb90:	dfc00d15 	stw	ra,52(sp)
8112eb94:	ddc00b15 	stw	r23,44(sp)
8112eb98:	dd800a15 	stw	r22,40(sp)
8112eb9c:	dcc00715 	stw	r19,28(sp)
8112eba0:	dc800615 	stw	r18,24(sp)
8112eba4:	dc400515 	stw	r17,20(sp)
8112eba8:	ad41ffcc 	andi	r21,r21,2047
8112ebac:	2c20703a 	and	r16,r5,r16
8112ebb0:	a7003fcc 	andi	fp,r20,255
8112ebb4:	a8006126 	beq	r21,zero,8112ed3c <__divdf3+0x1d8>
8112ebb8:	0081ffc4 	movi	r2,2047
8112ebbc:	2025883a 	mov	r18,r4
8112ebc0:	a8803726 	beq	r21,r2,8112eca0 <__divdf3+0x13c>
8112ebc4:	80800434 	orhi	r2,r16,16
8112ebc8:	100490fa 	slli	r2,r2,3
8112ebcc:	2020d77a 	srli	r16,r4,29
8112ebd0:	202490fa 	slli	r18,r4,3
8112ebd4:	ad7f0044 	addi	r21,r21,-1023
8112ebd8:	80a0b03a 	or	r16,r16,r2
8112ebdc:	0027883a 	mov	r19,zero
8112ebe0:	0013883a 	mov	r9,zero
8112ebe4:	3804d53a 	srli	r2,r7,20
8112ebe8:	382cd7fa 	srli	r22,r7,31
8112ebec:	04400434 	movhi	r17,16
8112ebf0:	8c7fffc4 	addi	r17,r17,-1
8112ebf4:	1081ffcc 	andi	r2,r2,2047
8112ebf8:	3011883a 	mov	r8,r6
8112ebfc:	3c62703a 	and	r17,r7,r17
8112ec00:	b5c03fcc 	andi	r23,r22,255
8112ec04:	10006c26 	beq	r2,zero,8112edb8 <__divdf3+0x254>
8112ec08:	00c1ffc4 	movi	r3,2047
8112ec0c:	10c06426 	beq	r2,r3,8112eda0 <__divdf3+0x23c>
8112ec10:	88c00434 	orhi	r3,r17,16
8112ec14:	180690fa 	slli	r3,r3,3
8112ec18:	3022d77a 	srli	r17,r6,29
8112ec1c:	301090fa 	slli	r8,r6,3
8112ec20:	10bf0044 	addi	r2,r2,-1023
8112ec24:	88e2b03a 	or	r17,r17,r3
8112ec28:	000f883a 	mov	r7,zero
8112ec2c:	a58cf03a 	xor	r6,r20,r22
8112ec30:	3cc8b03a 	or	r4,r7,r19
8112ec34:	a8abc83a 	sub	r21,r21,r2
8112ec38:	008003c4 	movi	r2,15
8112ec3c:	3007883a 	mov	r3,r6
8112ec40:	34c03fcc 	andi	r19,r6,255
8112ec44:	11009036 	bltu	r2,r4,8112ee88 <__divdf3+0x324>
8112ec48:	200890ba 	slli	r4,r4,2
8112ec4c:	00a044f4 	movhi	r2,33043
8112ec50:	10bb1804 	addi	r2,r2,-5024
8112ec54:	2089883a 	add	r4,r4,r2
8112ec58:	20800017 	ldw	r2,0(r4)
8112ec5c:	1000683a 	jmp	r2
8112ec60:	8112ee88 	cmpgei	r4,r16,19386
8112ec64:	8112ecd8 	cmpnei	r4,r16,19379
8112ec68:	8112ee78 	rdprs	r4,r16,19385
8112ec6c:	8112eccc 	andi	r4,r16,19379
8112ec70:	8112ee78 	rdprs	r4,r16,19385
8112ec74:	8112ee4c 	andi	r4,r16,19385
8112ec78:	8112ee78 	rdprs	r4,r16,19385
8112ec7c:	8112eccc 	andi	r4,r16,19379
8112ec80:	8112ecd8 	cmpnei	r4,r16,19379
8112ec84:	8112ecd8 	cmpnei	r4,r16,19379
8112ec88:	8112ee4c 	andi	r4,r16,19385
8112ec8c:	8112eccc 	andi	r4,r16,19379
8112ec90:	8112ecbc 	xorhi	r4,r16,19378
8112ec94:	8112ecbc 	xorhi	r4,r16,19378
8112ec98:	8112ecbc 	xorhi	r4,r16,19378
8112ec9c:	8112f16c 	andhi	r4,r16,19397
8112eca0:	2404b03a 	or	r2,r4,r16
8112eca4:	1000661e 	bne	r2,zero,8112ee40 <__divdf3+0x2dc>
8112eca8:	04c00204 	movi	r19,8
8112ecac:	0021883a 	mov	r16,zero
8112ecb0:	0025883a 	mov	r18,zero
8112ecb4:	02400084 	movi	r9,2
8112ecb8:	003fca06 	br	8112ebe4 <__reset+0xfb10ebe4>
8112ecbc:	8023883a 	mov	r17,r16
8112ecc0:	9011883a 	mov	r8,r18
8112ecc4:	e02f883a 	mov	r23,fp
8112ecc8:	480f883a 	mov	r7,r9
8112eccc:	00800084 	movi	r2,2
8112ecd0:	3881311e 	bne	r7,r2,8112f198 <__divdf3+0x634>
8112ecd4:	b827883a 	mov	r19,r23
8112ecd8:	98c0004c 	andi	r3,r19,1
8112ecdc:	0081ffc4 	movi	r2,2047
8112ece0:	000b883a 	mov	r5,zero
8112ece4:	0025883a 	mov	r18,zero
8112ece8:	1004953a 	slli	r2,r2,20
8112ecec:	18c03fcc 	andi	r3,r3,255
8112ecf0:	04400434 	movhi	r17,16
8112ecf4:	8c7fffc4 	addi	r17,r17,-1
8112ecf8:	180697fa 	slli	r3,r3,31
8112ecfc:	2c4a703a 	and	r5,r5,r17
8112ed00:	288ab03a 	or	r5,r5,r2
8112ed04:	28c6b03a 	or	r3,r5,r3
8112ed08:	9005883a 	mov	r2,r18
8112ed0c:	dfc00d17 	ldw	ra,52(sp)
8112ed10:	df000c17 	ldw	fp,48(sp)
8112ed14:	ddc00b17 	ldw	r23,44(sp)
8112ed18:	dd800a17 	ldw	r22,40(sp)
8112ed1c:	dd400917 	ldw	r21,36(sp)
8112ed20:	dd000817 	ldw	r20,32(sp)
8112ed24:	dcc00717 	ldw	r19,28(sp)
8112ed28:	dc800617 	ldw	r18,24(sp)
8112ed2c:	dc400517 	ldw	r17,20(sp)
8112ed30:	dc000417 	ldw	r16,16(sp)
8112ed34:	dec00e04 	addi	sp,sp,56
8112ed38:	f800283a 	ret
8112ed3c:	2404b03a 	or	r2,r4,r16
8112ed40:	2027883a 	mov	r19,r4
8112ed44:	10003926 	beq	r2,zero,8112ee2c <__divdf3+0x2c8>
8112ed48:	80012e26 	beq	r16,zero,8112f204 <__divdf3+0x6a0>
8112ed4c:	8009883a 	mov	r4,r16
8112ed50:	d9800315 	stw	r6,12(sp)
8112ed54:	d9c00215 	stw	r7,8(sp)
8112ed58:	111a7a00 	call	8111a7a0 <__clzsi2>
8112ed5c:	d9800317 	ldw	r6,12(sp)
8112ed60:	d9c00217 	ldw	r7,8(sp)
8112ed64:	113ffd44 	addi	r4,r2,-11
8112ed68:	00c00704 	movi	r3,28
8112ed6c:	19012116 	blt	r3,r4,8112f1f4 <__divdf3+0x690>
8112ed70:	00c00744 	movi	r3,29
8112ed74:	147ffe04 	addi	r17,r2,-8
8112ed78:	1907c83a 	sub	r3,r3,r4
8112ed7c:	8460983a 	sll	r16,r16,r17
8112ed80:	98c6d83a 	srl	r3,r19,r3
8112ed84:	9c64983a 	sll	r18,r19,r17
8112ed88:	1c20b03a 	or	r16,r3,r16
8112ed8c:	1080fcc4 	addi	r2,r2,1011
8112ed90:	00abc83a 	sub	r21,zero,r2
8112ed94:	0027883a 	mov	r19,zero
8112ed98:	0013883a 	mov	r9,zero
8112ed9c:	003f9106 	br	8112ebe4 <__reset+0xfb10ebe4>
8112eda0:	3446b03a 	or	r3,r6,r17
8112eda4:	18001f1e 	bne	r3,zero,8112ee24 <__divdf3+0x2c0>
8112eda8:	0023883a 	mov	r17,zero
8112edac:	0011883a 	mov	r8,zero
8112edb0:	01c00084 	movi	r7,2
8112edb4:	003f9d06 	br	8112ec2c <__reset+0xfb10ec2c>
8112edb8:	3446b03a 	or	r3,r6,r17
8112edbc:	18001526 	beq	r3,zero,8112ee14 <__divdf3+0x2b0>
8112edc0:	88011b26 	beq	r17,zero,8112f230 <__divdf3+0x6cc>
8112edc4:	8809883a 	mov	r4,r17
8112edc8:	d9800315 	stw	r6,12(sp)
8112edcc:	da400115 	stw	r9,4(sp)
8112edd0:	111a7a00 	call	8111a7a0 <__clzsi2>
8112edd4:	d9800317 	ldw	r6,12(sp)
8112edd8:	da400117 	ldw	r9,4(sp)
8112eddc:	113ffd44 	addi	r4,r2,-11
8112ede0:	00c00704 	movi	r3,28
8112ede4:	19010e16 	blt	r3,r4,8112f220 <__divdf3+0x6bc>
8112ede8:	00c00744 	movi	r3,29
8112edec:	123ffe04 	addi	r8,r2,-8
8112edf0:	1907c83a 	sub	r3,r3,r4
8112edf4:	8a22983a 	sll	r17,r17,r8
8112edf8:	30c6d83a 	srl	r3,r6,r3
8112edfc:	3210983a 	sll	r8,r6,r8
8112ee00:	1c62b03a 	or	r17,r3,r17
8112ee04:	1080fcc4 	addi	r2,r2,1011
8112ee08:	0085c83a 	sub	r2,zero,r2
8112ee0c:	000f883a 	mov	r7,zero
8112ee10:	003f8606 	br	8112ec2c <__reset+0xfb10ec2c>
8112ee14:	0023883a 	mov	r17,zero
8112ee18:	0011883a 	mov	r8,zero
8112ee1c:	01c00044 	movi	r7,1
8112ee20:	003f8206 	br	8112ec2c <__reset+0xfb10ec2c>
8112ee24:	01c000c4 	movi	r7,3
8112ee28:	003f8006 	br	8112ec2c <__reset+0xfb10ec2c>
8112ee2c:	04c00104 	movi	r19,4
8112ee30:	0021883a 	mov	r16,zero
8112ee34:	0025883a 	mov	r18,zero
8112ee38:	02400044 	movi	r9,1
8112ee3c:	003f6906 	br	8112ebe4 <__reset+0xfb10ebe4>
8112ee40:	04c00304 	movi	r19,12
8112ee44:	024000c4 	movi	r9,3
8112ee48:	003f6606 	br	8112ebe4 <__reset+0xfb10ebe4>
8112ee4c:	01400434 	movhi	r5,16
8112ee50:	0007883a 	mov	r3,zero
8112ee54:	297fffc4 	addi	r5,r5,-1
8112ee58:	04bfffc4 	movi	r18,-1
8112ee5c:	0081ffc4 	movi	r2,2047
8112ee60:	003fa106 	br	8112ece8 <__reset+0xfb10ece8>
8112ee64:	00c00044 	movi	r3,1
8112ee68:	1887c83a 	sub	r3,r3,r2
8112ee6c:	01000e04 	movi	r4,56
8112ee70:	20c1210e 	bge	r4,r3,8112f2f8 <__divdf3+0x794>
8112ee74:	98c0004c 	andi	r3,r19,1
8112ee78:	0005883a 	mov	r2,zero
8112ee7c:	000b883a 	mov	r5,zero
8112ee80:	0025883a 	mov	r18,zero
8112ee84:	003f9806 	br	8112ece8 <__reset+0xfb10ece8>
8112ee88:	8c00fd36 	bltu	r17,r16,8112f280 <__divdf3+0x71c>
8112ee8c:	8440fb26 	beq	r16,r17,8112f27c <__divdf3+0x718>
8112ee90:	8007883a 	mov	r3,r16
8112ee94:	ad7fffc4 	addi	r21,r21,-1
8112ee98:	0021883a 	mov	r16,zero
8112ee9c:	4004d63a 	srli	r2,r8,24
8112eea0:	8822923a 	slli	r17,r17,8
8112eea4:	1809883a 	mov	r4,r3
8112eea8:	402c923a 	slli	r22,r8,8
8112eeac:	88b8b03a 	or	fp,r17,r2
8112eeb0:	e028d43a 	srli	r20,fp,16
8112eeb4:	d8c00015 	stw	r3,0(sp)
8112eeb8:	e5ffffcc 	andi	r23,fp,65535
8112eebc:	a00b883a 	mov	r5,r20
8112eec0:	112dff80 	call	8112dff8 <__udivsi3>
8112eec4:	d8c00017 	ldw	r3,0(sp)
8112eec8:	a00b883a 	mov	r5,r20
8112eecc:	d8800315 	stw	r2,12(sp)
8112eed0:	1809883a 	mov	r4,r3
8112eed4:	112e05c0 	call	8112e05c <__umodsi3>
8112eed8:	d9800317 	ldw	r6,12(sp)
8112eedc:	1006943a 	slli	r3,r2,16
8112eee0:	9004d43a 	srli	r2,r18,16
8112eee4:	b9a3383a 	mul	r17,r23,r6
8112eee8:	10c4b03a 	or	r2,r2,r3
8112eeec:	1440062e 	bgeu	r2,r17,8112ef08 <__divdf3+0x3a4>
8112eef0:	1705883a 	add	r2,r2,fp
8112eef4:	30ffffc4 	addi	r3,r6,-1
8112eef8:	1700ee36 	bltu	r2,fp,8112f2b4 <__divdf3+0x750>
8112eefc:	1440ed2e 	bgeu	r2,r17,8112f2b4 <__divdf3+0x750>
8112ef00:	31bfff84 	addi	r6,r6,-2
8112ef04:	1705883a 	add	r2,r2,fp
8112ef08:	1463c83a 	sub	r17,r2,r17
8112ef0c:	a00b883a 	mov	r5,r20
8112ef10:	8809883a 	mov	r4,r17
8112ef14:	d9800315 	stw	r6,12(sp)
8112ef18:	112dff80 	call	8112dff8 <__udivsi3>
8112ef1c:	a00b883a 	mov	r5,r20
8112ef20:	8809883a 	mov	r4,r17
8112ef24:	d8800215 	stw	r2,8(sp)
8112ef28:	112e05c0 	call	8112e05c <__umodsi3>
8112ef2c:	d9c00217 	ldw	r7,8(sp)
8112ef30:	1004943a 	slli	r2,r2,16
8112ef34:	94bfffcc 	andi	r18,r18,65535
8112ef38:	b9d1383a 	mul	r8,r23,r7
8112ef3c:	90a4b03a 	or	r18,r18,r2
8112ef40:	d9800317 	ldw	r6,12(sp)
8112ef44:	9200062e 	bgeu	r18,r8,8112ef60 <__divdf3+0x3fc>
8112ef48:	9725883a 	add	r18,r18,fp
8112ef4c:	38bfffc4 	addi	r2,r7,-1
8112ef50:	9700d636 	bltu	r18,fp,8112f2ac <__divdf3+0x748>
8112ef54:	9200d52e 	bgeu	r18,r8,8112f2ac <__divdf3+0x748>
8112ef58:	39ffff84 	addi	r7,r7,-2
8112ef5c:	9725883a 	add	r18,r18,fp
8112ef60:	3004943a 	slli	r2,r6,16
8112ef64:	b012d43a 	srli	r9,r22,16
8112ef68:	b1bfffcc 	andi	r6,r22,65535
8112ef6c:	11e2b03a 	or	r17,r2,r7
8112ef70:	8806d43a 	srli	r3,r17,16
8112ef74:	893fffcc 	andi	r4,r17,65535
8112ef78:	218b383a 	mul	r5,r4,r6
8112ef7c:	30c5383a 	mul	r2,r6,r3
8112ef80:	2249383a 	mul	r4,r4,r9
8112ef84:	280ed43a 	srli	r7,r5,16
8112ef88:	9225c83a 	sub	r18,r18,r8
8112ef8c:	2089883a 	add	r4,r4,r2
8112ef90:	3909883a 	add	r4,r7,r4
8112ef94:	1a47383a 	mul	r3,r3,r9
8112ef98:	2080022e 	bgeu	r4,r2,8112efa4 <__divdf3+0x440>
8112ef9c:	00800074 	movhi	r2,1
8112efa0:	1887883a 	add	r3,r3,r2
8112efa4:	2004d43a 	srli	r2,r4,16
8112efa8:	2008943a 	slli	r4,r4,16
8112efac:	297fffcc 	andi	r5,r5,65535
8112efb0:	10c7883a 	add	r3,r2,r3
8112efb4:	2149883a 	add	r4,r4,r5
8112efb8:	90c0a536 	bltu	r18,r3,8112f250 <__divdf3+0x6ec>
8112efbc:	90c0bf26 	beq	r18,r3,8112f2bc <__divdf3+0x758>
8112efc0:	90c7c83a 	sub	r3,r18,r3
8112efc4:	810fc83a 	sub	r7,r16,r4
8112efc8:	81e5803a 	cmpltu	r18,r16,r7
8112efcc:	1ca5c83a 	sub	r18,r3,r18
8112efd0:	e480c126 	beq	fp,r18,8112f2d8 <__divdf3+0x774>
8112efd4:	a00b883a 	mov	r5,r20
8112efd8:	9009883a 	mov	r4,r18
8112efdc:	d9800315 	stw	r6,12(sp)
8112efe0:	d9c00215 	stw	r7,8(sp)
8112efe4:	da400115 	stw	r9,4(sp)
8112efe8:	112dff80 	call	8112dff8 <__udivsi3>
8112efec:	a00b883a 	mov	r5,r20
8112eff0:	9009883a 	mov	r4,r18
8112eff4:	d8800015 	stw	r2,0(sp)
8112eff8:	112e05c0 	call	8112e05c <__umodsi3>
8112effc:	d9c00217 	ldw	r7,8(sp)
8112f000:	da000017 	ldw	r8,0(sp)
8112f004:	1006943a 	slli	r3,r2,16
8112f008:	3804d43a 	srli	r2,r7,16
8112f00c:	ba21383a 	mul	r16,r23,r8
8112f010:	d9800317 	ldw	r6,12(sp)
8112f014:	10c4b03a 	or	r2,r2,r3
8112f018:	da400117 	ldw	r9,4(sp)
8112f01c:	1400062e 	bgeu	r2,r16,8112f038 <__divdf3+0x4d4>
8112f020:	1705883a 	add	r2,r2,fp
8112f024:	40ffffc4 	addi	r3,r8,-1
8112f028:	1700ad36 	bltu	r2,fp,8112f2e0 <__divdf3+0x77c>
8112f02c:	1400ac2e 	bgeu	r2,r16,8112f2e0 <__divdf3+0x77c>
8112f030:	423fff84 	addi	r8,r8,-2
8112f034:	1705883a 	add	r2,r2,fp
8112f038:	1421c83a 	sub	r16,r2,r16
8112f03c:	a00b883a 	mov	r5,r20
8112f040:	8009883a 	mov	r4,r16
8112f044:	d9800315 	stw	r6,12(sp)
8112f048:	d9c00215 	stw	r7,8(sp)
8112f04c:	da000015 	stw	r8,0(sp)
8112f050:	da400115 	stw	r9,4(sp)
8112f054:	112dff80 	call	8112dff8 <__udivsi3>
8112f058:	8009883a 	mov	r4,r16
8112f05c:	a00b883a 	mov	r5,r20
8112f060:	1025883a 	mov	r18,r2
8112f064:	112e05c0 	call	8112e05c <__umodsi3>
8112f068:	d9c00217 	ldw	r7,8(sp)
8112f06c:	1004943a 	slli	r2,r2,16
8112f070:	bcaf383a 	mul	r23,r23,r18
8112f074:	393fffcc 	andi	r4,r7,65535
8112f078:	2088b03a 	or	r4,r4,r2
8112f07c:	d9800317 	ldw	r6,12(sp)
8112f080:	da000017 	ldw	r8,0(sp)
8112f084:	da400117 	ldw	r9,4(sp)
8112f088:	25c0062e 	bgeu	r4,r23,8112f0a4 <__divdf3+0x540>
8112f08c:	2709883a 	add	r4,r4,fp
8112f090:	90bfffc4 	addi	r2,r18,-1
8112f094:	27009436 	bltu	r4,fp,8112f2e8 <__divdf3+0x784>
8112f098:	25c0932e 	bgeu	r4,r23,8112f2e8 <__divdf3+0x784>
8112f09c:	94bfff84 	addi	r18,r18,-2
8112f0a0:	2709883a 	add	r4,r4,fp
8112f0a4:	4004943a 	slli	r2,r8,16
8112f0a8:	25efc83a 	sub	r23,r4,r23
8112f0ac:	1490b03a 	or	r8,r2,r18
8112f0b0:	4008d43a 	srli	r4,r8,16
8112f0b4:	40ffffcc 	andi	r3,r8,65535
8112f0b8:	30c5383a 	mul	r2,r6,r3
8112f0bc:	1a47383a 	mul	r3,r3,r9
8112f0c0:	310d383a 	mul	r6,r6,r4
8112f0c4:	100ad43a 	srli	r5,r2,16
8112f0c8:	4913383a 	mul	r9,r9,r4
8112f0cc:	1987883a 	add	r3,r3,r6
8112f0d0:	28c7883a 	add	r3,r5,r3
8112f0d4:	1980022e 	bgeu	r3,r6,8112f0e0 <__divdf3+0x57c>
8112f0d8:	01000074 	movhi	r4,1
8112f0dc:	4913883a 	add	r9,r9,r4
8112f0e0:	1808d43a 	srli	r4,r3,16
8112f0e4:	1806943a 	slli	r3,r3,16
8112f0e8:	10bfffcc 	andi	r2,r2,65535
8112f0ec:	2253883a 	add	r9,r4,r9
8112f0f0:	1887883a 	add	r3,r3,r2
8112f0f4:	ba403836 	bltu	r23,r9,8112f1d8 <__divdf3+0x674>
8112f0f8:	ba403626 	beq	r23,r9,8112f1d4 <__divdf3+0x670>
8112f0fc:	42000054 	ori	r8,r8,1
8112f100:	a880ffc4 	addi	r2,r21,1023
8112f104:	00bf570e 	bge	zero,r2,8112ee64 <__reset+0xfb10ee64>
8112f108:	40c001cc 	andi	r3,r8,7
8112f10c:	18000726 	beq	r3,zero,8112f12c <__divdf3+0x5c8>
8112f110:	40c003cc 	andi	r3,r8,15
8112f114:	01000104 	movi	r4,4
8112f118:	19000426 	beq	r3,r4,8112f12c <__divdf3+0x5c8>
8112f11c:	4107883a 	add	r3,r8,r4
8112f120:	1a11803a 	cmpltu	r8,r3,r8
8112f124:	8a23883a 	add	r17,r17,r8
8112f128:	1811883a 	mov	r8,r3
8112f12c:	88c0402c 	andhi	r3,r17,256
8112f130:	18000426 	beq	r3,zero,8112f144 <__divdf3+0x5e0>
8112f134:	00ffc034 	movhi	r3,65280
8112f138:	18ffffc4 	addi	r3,r3,-1
8112f13c:	a8810004 	addi	r2,r21,1024
8112f140:	88e2703a 	and	r17,r17,r3
8112f144:	00c1ff84 	movi	r3,2046
8112f148:	18bee316 	blt	r3,r2,8112ecd8 <__reset+0xfb10ecd8>
8112f14c:	8824977a 	slli	r18,r17,29
8112f150:	4010d0fa 	srli	r8,r8,3
8112f154:	8822927a 	slli	r17,r17,9
8112f158:	1081ffcc 	andi	r2,r2,2047
8112f15c:	9224b03a 	or	r18,r18,r8
8112f160:	880ad33a 	srli	r5,r17,12
8112f164:	98c0004c 	andi	r3,r19,1
8112f168:	003edf06 	br	8112ece8 <__reset+0xfb10ece8>
8112f16c:	8080022c 	andhi	r2,r16,8
8112f170:	10001226 	beq	r2,zero,8112f1bc <__divdf3+0x658>
8112f174:	8880022c 	andhi	r2,r17,8
8112f178:	1000101e 	bne	r2,zero,8112f1bc <__divdf3+0x658>
8112f17c:	00800434 	movhi	r2,16
8112f180:	89400234 	orhi	r5,r17,8
8112f184:	10bfffc4 	addi	r2,r2,-1
8112f188:	b007883a 	mov	r3,r22
8112f18c:	288a703a 	and	r5,r5,r2
8112f190:	4025883a 	mov	r18,r8
8112f194:	003f3106 	br	8112ee5c <__reset+0xfb10ee5c>
8112f198:	008000c4 	movi	r2,3
8112f19c:	3880a626 	beq	r7,r2,8112f438 <__divdf3+0x8d4>
8112f1a0:	00800044 	movi	r2,1
8112f1a4:	3880521e 	bne	r7,r2,8112f2f0 <__divdf3+0x78c>
8112f1a8:	b807883a 	mov	r3,r23
8112f1ac:	0005883a 	mov	r2,zero
8112f1b0:	000b883a 	mov	r5,zero
8112f1b4:	0025883a 	mov	r18,zero
8112f1b8:	003ecb06 	br	8112ece8 <__reset+0xfb10ece8>
8112f1bc:	00800434 	movhi	r2,16
8112f1c0:	81400234 	orhi	r5,r16,8
8112f1c4:	10bfffc4 	addi	r2,r2,-1
8112f1c8:	a007883a 	mov	r3,r20
8112f1cc:	288a703a 	and	r5,r5,r2
8112f1d0:	003f2206 	br	8112ee5c <__reset+0xfb10ee5c>
8112f1d4:	183fca26 	beq	r3,zero,8112f100 <__reset+0xfb10f100>
8112f1d8:	e5ef883a 	add	r23,fp,r23
8112f1dc:	40bfffc4 	addi	r2,r8,-1
8112f1e0:	bf00392e 	bgeu	r23,fp,8112f2c8 <__divdf3+0x764>
8112f1e4:	1011883a 	mov	r8,r2
8112f1e8:	ba7fc41e 	bne	r23,r9,8112f0fc <__reset+0xfb10f0fc>
8112f1ec:	b0ffc31e 	bne	r22,r3,8112f0fc <__reset+0xfb10f0fc>
8112f1f0:	003fc306 	br	8112f100 <__reset+0xfb10f100>
8112f1f4:	143ff604 	addi	r16,r2,-40
8112f1f8:	9c20983a 	sll	r16,r19,r16
8112f1fc:	0025883a 	mov	r18,zero
8112f200:	003ee206 	br	8112ed8c <__reset+0xfb10ed8c>
8112f204:	d9800315 	stw	r6,12(sp)
8112f208:	d9c00215 	stw	r7,8(sp)
8112f20c:	111a7a00 	call	8111a7a0 <__clzsi2>
8112f210:	10800804 	addi	r2,r2,32
8112f214:	d9c00217 	ldw	r7,8(sp)
8112f218:	d9800317 	ldw	r6,12(sp)
8112f21c:	003ed106 	br	8112ed64 <__reset+0xfb10ed64>
8112f220:	147ff604 	addi	r17,r2,-40
8112f224:	3462983a 	sll	r17,r6,r17
8112f228:	0011883a 	mov	r8,zero
8112f22c:	003ef506 	br	8112ee04 <__reset+0xfb10ee04>
8112f230:	3009883a 	mov	r4,r6
8112f234:	d9800315 	stw	r6,12(sp)
8112f238:	da400115 	stw	r9,4(sp)
8112f23c:	111a7a00 	call	8111a7a0 <__clzsi2>
8112f240:	10800804 	addi	r2,r2,32
8112f244:	da400117 	ldw	r9,4(sp)
8112f248:	d9800317 	ldw	r6,12(sp)
8112f24c:	003ee306 	br	8112eddc <__reset+0xfb10eddc>
8112f250:	85a1883a 	add	r16,r16,r22
8112f254:	8585803a 	cmpltu	r2,r16,r22
8112f258:	1705883a 	add	r2,r2,fp
8112f25c:	14a5883a 	add	r18,r2,r18
8112f260:	88bfffc4 	addi	r2,r17,-1
8112f264:	e4800c2e 	bgeu	fp,r18,8112f298 <__divdf3+0x734>
8112f268:	90c03e36 	bltu	r18,r3,8112f364 <__divdf3+0x800>
8112f26c:	1c806926 	beq	r3,r18,8112f414 <__divdf3+0x8b0>
8112f270:	90c7c83a 	sub	r3,r18,r3
8112f274:	1023883a 	mov	r17,r2
8112f278:	003f5206 	br	8112efc4 <__reset+0xfb10efc4>
8112f27c:	923f0436 	bltu	r18,r8,8112ee90 <__reset+0xfb10ee90>
8112f280:	800897fa 	slli	r4,r16,31
8112f284:	9004d07a 	srli	r2,r18,1
8112f288:	8006d07a 	srli	r3,r16,1
8112f28c:	902097fa 	slli	r16,r18,31
8112f290:	20a4b03a 	or	r18,r4,r2
8112f294:	003f0106 	br	8112ee9c <__reset+0xfb10ee9c>
8112f298:	e4bff51e 	bne	fp,r18,8112f270 <__reset+0xfb10f270>
8112f29c:	85bff22e 	bgeu	r16,r22,8112f268 <__reset+0xfb10f268>
8112f2a0:	e0c7c83a 	sub	r3,fp,r3
8112f2a4:	1023883a 	mov	r17,r2
8112f2a8:	003f4606 	br	8112efc4 <__reset+0xfb10efc4>
8112f2ac:	100f883a 	mov	r7,r2
8112f2b0:	003f2b06 	br	8112ef60 <__reset+0xfb10ef60>
8112f2b4:	180d883a 	mov	r6,r3
8112f2b8:	003f1306 	br	8112ef08 <__reset+0xfb10ef08>
8112f2bc:	813fe436 	bltu	r16,r4,8112f250 <__reset+0xfb10f250>
8112f2c0:	0007883a 	mov	r3,zero
8112f2c4:	003f3f06 	br	8112efc4 <__reset+0xfb10efc4>
8112f2c8:	ba402c36 	bltu	r23,r9,8112f37c <__divdf3+0x818>
8112f2cc:	4dc05426 	beq	r9,r23,8112f420 <__divdf3+0x8bc>
8112f2d0:	1011883a 	mov	r8,r2
8112f2d4:	003f8906 	br	8112f0fc <__reset+0xfb10f0fc>
8112f2d8:	023fffc4 	movi	r8,-1
8112f2dc:	003f8806 	br	8112f100 <__reset+0xfb10f100>
8112f2e0:	1811883a 	mov	r8,r3
8112f2e4:	003f5406 	br	8112f038 <__reset+0xfb10f038>
8112f2e8:	1025883a 	mov	r18,r2
8112f2ec:	003f6d06 	br	8112f0a4 <__reset+0xfb10f0a4>
8112f2f0:	b827883a 	mov	r19,r23
8112f2f4:	003f8206 	br	8112f100 <__reset+0xfb10f100>
8112f2f8:	010007c4 	movi	r4,31
8112f2fc:	20c02616 	blt	r4,r3,8112f398 <__divdf3+0x834>
8112f300:	00800804 	movi	r2,32
8112f304:	10c5c83a 	sub	r2,r2,r3
8112f308:	888a983a 	sll	r5,r17,r2
8112f30c:	40c8d83a 	srl	r4,r8,r3
8112f310:	4084983a 	sll	r2,r8,r2
8112f314:	88e2d83a 	srl	r17,r17,r3
8112f318:	2906b03a 	or	r3,r5,r4
8112f31c:	1004c03a 	cmpne	r2,r2,zero
8112f320:	1886b03a 	or	r3,r3,r2
8112f324:	188001cc 	andi	r2,r3,7
8112f328:	10000726 	beq	r2,zero,8112f348 <__divdf3+0x7e4>
8112f32c:	188003cc 	andi	r2,r3,15
8112f330:	01000104 	movi	r4,4
8112f334:	11000426 	beq	r2,r4,8112f348 <__divdf3+0x7e4>
8112f338:	1805883a 	mov	r2,r3
8112f33c:	10c00104 	addi	r3,r2,4
8112f340:	1885803a 	cmpltu	r2,r3,r2
8112f344:	88a3883a 	add	r17,r17,r2
8112f348:	8880202c 	andhi	r2,r17,128
8112f34c:	10002726 	beq	r2,zero,8112f3ec <__divdf3+0x888>
8112f350:	98c0004c 	andi	r3,r19,1
8112f354:	00800044 	movi	r2,1
8112f358:	000b883a 	mov	r5,zero
8112f35c:	0025883a 	mov	r18,zero
8112f360:	003e6106 	br	8112ece8 <__reset+0xfb10ece8>
8112f364:	85a1883a 	add	r16,r16,r22
8112f368:	8585803a 	cmpltu	r2,r16,r22
8112f36c:	1705883a 	add	r2,r2,fp
8112f370:	14a5883a 	add	r18,r2,r18
8112f374:	8c7fff84 	addi	r17,r17,-2
8112f378:	003f1106 	br	8112efc0 <__reset+0xfb10efc0>
8112f37c:	b589883a 	add	r4,r22,r22
8112f380:	25ad803a 	cmpltu	r22,r4,r22
8112f384:	b739883a 	add	fp,r22,fp
8112f388:	40bfff84 	addi	r2,r8,-2
8112f38c:	bf2f883a 	add	r23,r23,fp
8112f390:	202d883a 	mov	r22,r4
8112f394:	003f9306 	br	8112f1e4 <__reset+0xfb10f1e4>
8112f398:	013ff844 	movi	r4,-31
8112f39c:	2085c83a 	sub	r2,r4,r2
8112f3a0:	8888d83a 	srl	r4,r17,r2
8112f3a4:	00800804 	movi	r2,32
8112f3a8:	18802126 	beq	r3,r2,8112f430 <__divdf3+0x8cc>
8112f3ac:	00801004 	movi	r2,64
8112f3b0:	10c5c83a 	sub	r2,r2,r3
8112f3b4:	8884983a 	sll	r2,r17,r2
8112f3b8:	1204b03a 	or	r2,r2,r8
8112f3bc:	1004c03a 	cmpne	r2,r2,zero
8112f3c0:	2084b03a 	or	r2,r4,r2
8112f3c4:	144001cc 	andi	r17,r2,7
8112f3c8:	88000d1e 	bne	r17,zero,8112f400 <__divdf3+0x89c>
8112f3cc:	000b883a 	mov	r5,zero
8112f3d0:	1024d0fa 	srli	r18,r2,3
8112f3d4:	98c0004c 	andi	r3,r19,1
8112f3d8:	0005883a 	mov	r2,zero
8112f3dc:	9464b03a 	or	r18,r18,r17
8112f3e0:	003e4106 	br	8112ece8 <__reset+0xfb10ece8>
8112f3e4:	1007883a 	mov	r3,r2
8112f3e8:	0023883a 	mov	r17,zero
8112f3ec:	880a927a 	slli	r5,r17,9
8112f3f0:	1805883a 	mov	r2,r3
8112f3f4:	8822977a 	slli	r17,r17,29
8112f3f8:	280ad33a 	srli	r5,r5,12
8112f3fc:	003ff406 	br	8112f3d0 <__reset+0xfb10f3d0>
8112f400:	10c003cc 	andi	r3,r2,15
8112f404:	01000104 	movi	r4,4
8112f408:	193ff626 	beq	r3,r4,8112f3e4 <__reset+0xfb10f3e4>
8112f40c:	0023883a 	mov	r17,zero
8112f410:	003fca06 	br	8112f33c <__reset+0xfb10f33c>
8112f414:	813fd336 	bltu	r16,r4,8112f364 <__reset+0xfb10f364>
8112f418:	1023883a 	mov	r17,r2
8112f41c:	003fa806 	br	8112f2c0 <__reset+0xfb10f2c0>
8112f420:	b0ffd636 	bltu	r22,r3,8112f37c <__reset+0xfb10f37c>
8112f424:	1011883a 	mov	r8,r2
8112f428:	b0ff341e 	bne	r22,r3,8112f0fc <__reset+0xfb10f0fc>
8112f42c:	003f3406 	br	8112f100 <__reset+0xfb10f100>
8112f430:	0005883a 	mov	r2,zero
8112f434:	003fe006 	br	8112f3b8 <__reset+0xfb10f3b8>
8112f438:	00800434 	movhi	r2,16
8112f43c:	89400234 	orhi	r5,r17,8
8112f440:	10bfffc4 	addi	r2,r2,-1
8112f444:	b807883a 	mov	r3,r23
8112f448:	288a703a 	and	r5,r5,r2
8112f44c:	4025883a 	mov	r18,r8
8112f450:	003e8206 	br	8112ee5c <__reset+0xfb10ee5c>

8112f454 <__eqdf2>:
8112f454:	2804d53a 	srli	r2,r5,20
8112f458:	3806d53a 	srli	r3,r7,20
8112f45c:	02000434 	movhi	r8,16
8112f460:	423fffc4 	addi	r8,r8,-1
8112f464:	1081ffcc 	andi	r2,r2,2047
8112f468:	0281ffc4 	movi	r10,2047
8112f46c:	2a12703a 	and	r9,r5,r8
8112f470:	18c1ffcc 	andi	r3,r3,2047
8112f474:	3a10703a 	and	r8,r7,r8
8112f478:	280ad7fa 	srli	r5,r5,31
8112f47c:	380ed7fa 	srli	r7,r7,31
8112f480:	12801026 	beq	r2,r10,8112f4c4 <__eqdf2+0x70>
8112f484:	0281ffc4 	movi	r10,2047
8112f488:	1a800a26 	beq	r3,r10,8112f4b4 <__eqdf2+0x60>
8112f48c:	10c00226 	beq	r2,r3,8112f498 <__eqdf2+0x44>
8112f490:	00800044 	movi	r2,1
8112f494:	f800283a 	ret
8112f498:	4a3ffd1e 	bne	r9,r8,8112f490 <__reset+0xfb10f490>
8112f49c:	21bffc1e 	bne	r4,r6,8112f490 <__reset+0xfb10f490>
8112f4a0:	29c00c26 	beq	r5,r7,8112f4d4 <__eqdf2+0x80>
8112f4a4:	103ffa1e 	bne	r2,zero,8112f490 <__reset+0xfb10f490>
8112f4a8:	2244b03a 	or	r2,r4,r9
8112f4ac:	1004c03a 	cmpne	r2,r2,zero
8112f4b0:	f800283a 	ret
8112f4b4:	3214b03a 	or	r10,r6,r8
8112f4b8:	503ff426 	beq	r10,zero,8112f48c <__reset+0xfb10f48c>
8112f4bc:	00800044 	movi	r2,1
8112f4c0:	f800283a 	ret
8112f4c4:	2254b03a 	or	r10,r4,r9
8112f4c8:	503fee26 	beq	r10,zero,8112f484 <__reset+0xfb10f484>
8112f4cc:	00800044 	movi	r2,1
8112f4d0:	f800283a 	ret
8112f4d4:	0005883a 	mov	r2,zero
8112f4d8:	f800283a 	ret

8112f4dc <__gedf2>:
8112f4dc:	2804d53a 	srli	r2,r5,20
8112f4e0:	3806d53a 	srli	r3,r7,20
8112f4e4:	02000434 	movhi	r8,16
8112f4e8:	423fffc4 	addi	r8,r8,-1
8112f4ec:	1081ffcc 	andi	r2,r2,2047
8112f4f0:	0241ffc4 	movi	r9,2047
8112f4f4:	2a14703a 	and	r10,r5,r8
8112f4f8:	18c1ffcc 	andi	r3,r3,2047
8112f4fc:	3a10703a 	and	r8,r7,r8
8112f500:	280ad7fa 	srli	r5,r5,31
8112f504:	380ed7fa 	srli	r7,r7,31
8112f508:	12401d26 	beq	r2,r9,8112f580 <__gedf2+0xa4>
8112f50c:	0241ffc4 	movi	r9,2047
8112f510:	1a401226 	beq	r3,r9,8112f55c <__gedf2+0x80>
8112f514:	1000081e 	bne	r2,zero,8112f538 <__gedf2+0x5c>
8112f518:	2296b03a 	or	r11,r4,r10
8112f51c:	5813003a 	cmpeq	r9,r11,zero
8112f520:	1800091e 	bne	r3,zero,8112f548 <__gedf2+0x6c>
8112f524:	3218b03a 	or	r12,r6,r8
8112f528:	6000071e 	bne	r12,zero,8112f548 <__gedf2+0x6c>
8112f52c:	0005883a 	mov	r2,zero
8112f530:	5800101e 	bne	r11,zero,8112f574 <__gedf2+0x98>
8112f534:	f800283a 	ret
8112f538:	18000c1e 	bne	r3,zero,8112f56c <__gedf2+0x90>
8112f53c:	3212b03a 	or	r9,r6,r8
8112f540:	48000c26 	beq	r9,zero,8112f574 <__gedf2+0x98>
8112f544:	0013883a 	mov	r9,zero
8112f548:	39c03fcc 	andi	r7,r7,255
8112f54c:	48000826 	beq	r9,zero,8112f570 <__gedf2+0x94>
8112f550:	38000926 	beq	r7,zero,8112f578 <__gedf2+0x9c>
8112f554:	00800044 	movi	r2,1
8112f558:	f800283a 	ret
8112f55c:	3212b03a 	or	r9,r6,r8
8112f560:	483fec26 	beq	r9,zero,8112f514 <__reset+0xfb10f514>
8112f564:	00bfff84 	movi	r2,-2
8112f568:	f800283a 	ret
8112f56c:	39c03fcc 	andi	r7,r7,255
8112f570:	29c00626 	beq	r5,r7,8112f58c <__gedf2+0xb0>
8112f574:	283ff726 	beq	r5,zero,8112f554 <__reset+0xfb10f554>
8112f578:	00bfffc4 	movi	r2,-1
8112f57c:	f800283a 	ret
8112f580:	2292b03a 	or	r9,r4,r10
8112f584:	483fe126 	beq	r9,zero,8112f50c <__reset+0xfb10f50c>
8112f588:	003ff606 	br	8112f564 <__reset+0xfb10f564>
8112f58c:	18bff916 	blt	r3,r2,8112f574 <__reset+0xfb10f574>
8112f590:	10c00316 	blt	r2,r3,8112f5a0 <__gedf2+0xc4>
8112f594:	42bff736 	bltu	r8,r10,8112f574 <__reset+0xfb10f574>
8112f598:	52000326 	beq	r10,r8,8112f5a8 <__gedf2+0xcc>
8112f59c:	5200042e 	bgeu	r10,r8,8112f5b0 <__gedf2+0xd4>
8112f5a0:	283fec1e 	bne	r5,zero,8112f554 <__reset+0xfb10f554>
8112f5a4:	003ff406 	br	8112f578 <__reset+0xfb10f578>
8112f5a8:	313ff236 	bltu	r6,r4,8112f574 <__reset+0xfb10f574>
8112f5ac:	21bffc36 	bltu	r4,r6,8112f5a0 <__reset+0xfb10f5a0>
8112f5b0:	0005883a 	mov	r2,zero
8112f5b4:	f800283a 	ret

8112f5b8 <__ledf2>:
8112f5b8:	2804d53a 	srli	r2,r5,20
8112f5bc:	3810d53a 	srli	r8,r7,20
8112f5c0:	00c00434 	movhi	r3,16
8112f5c4:	18ffffc4 	addi	r3,r3,-1
8112f5c8:	1081ffcc 	andi	r2,r2,2047
8112f5cc:	0241ffc4 	movi	r9,2047
8112f5d0:	28d4703a 	and	r10,r5,r3
8112f5d4:	4201ffcc 	andi	r8,r8,2047
8112f5d8:	38c6703a 	and	r3,r7,r3
8112f5dc:	280ad7fa 	srli	r5,r5,31
8112f5e0:	380ed7fa 	srli	r7,r7,31
8112f5e4:	12401f26 	beq	r2,r9,8112f664 <__ledf2+0xac>
8112f5e8:	0241ffc4 	movi	r9,2047
8112f5ec:	42401426 	beq	r8,r9,8112f640 <__ledf2+0x88>
8112f5f0:	1000091e 	bne	r2,zero,8112f618 <__ledf2+0x60>
8112f5f4:	2296b03a 	or	r11,r4,r10
8112f5f8:	5813003a 	cmpeq	r9,r11,zero
8112f5fc:	29403fcc 	andi	r5,r5,255
8112f600:	40000a1e 	bne	r8,zero,8112f62c <__ledf2+0x74>
8112f604:	30d8b03a 	or	r12,r6,r3
8112f608:	6000081e 	bne	r12,zero,8112f62c <__ledf2+0x74>
8112f60c:	0005883a 	mov	r2,zero
8112f610:	5800111e 	bne	r11,zero,8112f658 <__ledf2+0xa0>
8112f614:	f800283a 	ret
8112f618:	29403fcc 	andi	r5,r5,255
8112f61c:	40000c1e 	bne	r8,zero,8112f650 <__ledf2+0x98>
8112f620:	30d2b03a 	or	r9,r6,r3
8112f624:	48000c26 	beq	r9,zero,8112f658 <__ledf2+0xa0>
8112f628:	0013883a 	mov	r9,zero
8112f62c:	39c03fcc 	andi	r7,r7,255
8112f630:	48000826 	beq	r9,zero,8112f654 <__ledf2+0x9c>
8112f634:	38001126 	beq	r7,zero,8112f67c <__ledf2+0xc4>
8112f638:	00800044 	movi	r2,1
8112f63c:	f800283a 	ret
8112f640:	30d2b03a 	or	r9,r6,r3
8112f644:	483fea26 	beq	r9,zero,8112f5f0 <__reset+0xfb10f5f0>
8112f648:	00800084 	movi	r2,2
8112f64c:	f800283a 	ret
8112f650:	39c03fcc 	andi	r7,r7,255
8112f654:	39400726 	beq	r7,r5,8112f674 <__ledf2+0xbc>
8112f658:	2800081e 	bne	r5,zero,8112f67c <__ledf2+0xc4>
8112f65c:	00800044 	movi	r2,1
8112f660:	f800283a 	ret
8112f664:	2292b03a 	or	r9,r4,r10
8112f668:	483fdf26 	beq	r9,zero,8112f5e8 <__reset+0xfb10f5e8>
8112f66c:	00800084 	movi	r2,2
8112f670:	f800283a 	ret
8112f674:	4080030e 	bge	r8,r2,8112f684 <__ledf2+0xcc>
8112f678:	383fef26 	beq	r7,zero,8112f638 <__reset+0xfb10f638>
8112f67c:	00bfffc4 	movi	r2,-1
8112f680:	f800283a 	ret
8112f684:	123feb16 	blt	r2,r8,8112f634 <__reset+0xfb10f634>
8112f688:	1abff336 	bltu	r3,r10,8112f658 <__reset+0xfb10f658>
8112f68c:	50c00326 	beq	r10,r3,8112f69c <__ledf2+0xe4>
8112f690:	50c0042e 	bgeu	r10,r3,8112f6a4 <__ledf2+0xec>
8112f694:	283fe81e 	bne	r5,zero,8112f638 <__reset+0xfb10f638>
8112f698:	003ff806 	br	8112f67c <__reset+0xfb10f67c>
8112f69c:	313fee36 	bltu	r6,r4,8112f658 <__reset+0xfb10f658>
8112f6a0:	21bffc36 	bltu	r4,r6,8112f694 <__reset+0xfb10f694>
8112f6a4:	0005883a 	mov	r2,zero
8112f6a8:	f800283a 	ret

8112f6ac <__subdf3>:
8112f6ac:	02000434 	movhi	r8,16
8112f6b0:	423fffc4 	addi	r8,r8,-1
8112f6b4:	defffb04 	addi	sp,sp,-20
8112f6b8:	2a14703a 	and	r10,r5,r8
8112f6bc:	3812d53a 	srli	r9,r7,20
8112f6c0:	3a10703a 	and	r8,r7,r8
8112f6c4:	de00012e 	bgeu	sp,et,8112f6cc <__subdf3+0x20>
8112f6c8:	003b68fa 	trap	3
8112f6cc:	2006d77a 	srli	r3,r4,29
8112f6d0:	3004d77a 	srli	r2,r6,29
8112f6d4:	dc000015 	stw	r16,0(sp)
8112f6d8:	501490fa 	slli	r10,r10,3
8112f6dc:	2820d53a 	srli	r16,r5,20
8112f6e0:	401090fa 	slli	r8,r8,3
8112f6e4:	dc800215 	stw	r18,8(sp)
8112f6e8:	dc400115 	stw	r17,4(sp)
8112f6ec:	dfc00415 	stw	ra,16(sp)
8112f6f0:	202290fa 	slli	r17,r4,3
8112f6f4:	dcc00315 	stw	r19,12(sp)
8112f6f8:	4a41ffcc 	andi	r9,r9,2047
8112f6fc:	0101ffc4 	movi	r4,2047
8112f700:	2824d7fa 	srli	r18,r5,31
8112f704:	8401ffcc 	andi	r16,r16,2047
8112f708:	50c6b03a 	or	r3,r10,r3
8112f70c:	380ed7fa 	srli	r7,r7,31
8112f710:	408ab03a 	or	r5,r8,r2
8112f714:	300c90fa 	slli	r6,r6,3
8112f718:	49009626 	beq	r9,r4,8112f974 <__subdf3+0x2c8>
8112f71c:	39c0005c 	xori	r7,r7,1
8112f720:	8245c83a 	sub	r2,r16,r9
8112f724:	3c807426 	beq	r7,r18,8112f8f8 <__subdf3+0x24c>
8112f728:	0080af0e 	bge	zero,r2,8112f9e8 <__subdf3+0x33c>
8112f72c:	48002a1e 	bne	r9,zero,8112f7d8 <__subdf3+0x12c>
8112f730:	2988b03a 	or	r4,r5,r6
8112f734:	20009a1e 	bne	r4,zero,8112f9a0 <__subdf3+0x2f4>
8112f738:	888001cc 	andi	r2,r17,7
8112f73c:	10000726 	beq	r2,zero,8112f75c <__subdf3+0xb0>
8112f740:	888003cc 	andi	r2,r17,15
8112f744:	01000104 	movi	r4,4
8112f748:	11000426 	beq	r2,r4,8112f75c <__subdf3+0xb0>
8112f74c:	890b883a 	add	r5,r17,r4
8112f750:	2c63803a 	cmpltu	r17,r5,r17
8112f754:	1c47883a 	add	r3,r3,r17
8112f758:	2823883a 	mov	r17,r5
8112f75c:	1880202c 	andhi	r2,r3,128
8112f760:	10005926 	beq	r2,zero,8112f8c8 <__subdf3+0x21c>
8112f764:	84000044 	addi	r16,r16,1
8112f768:	0081ffc4 	movi	r2,2047
8112f76c:	8080be26 	beq	r16,r2,8112fa68 <__subdf3+0x3bc>
8112f770:	017fe034 	movhi	r5,65408
8112f774:	297fffc4 	addi	r5,r5,-1
8112f778:	1946703a 	and	r3,r3,r5
8112f77c:	1804977a 	slli	r2,r3,29
8112f780:	1806927a 	slli	r3,r3,9
8112f784:	8822d0fa 	srli	r17,r17,3
8112f788:	8401ffcc 	andi	r16,r16,2047
8112f78c:	180ad33a 	srli	r5,r3,12
8112f790:	9100004c 	andi	r4,r18,1
8112f794:	1444b03a 	or	r2,r2,r17
8112f798:	80c1ffcc 	andi	r3,r16,2047
8112f79c:	1820953a 	slli	r16,r3,20
8112f7a0:	20c03fcc 	andi	r3,r4,255
8112f7a4:	180897fa 	slli	r4,r3,31
8112f7a8:	00c00434 	movhi	r3,16
8112f7ac:	18ffffc4 	addi	r3,r3,-1
8112f7b0:	28c6703a 	and	r3,r5,r3
8112f7b4:	1c06b03a 	or	r3,r3,r16
8112f7b8:	1906b03a 	or	r3,r3,r4
8112f7bc:	dfc00417 	ldw	ra,16(sp)
8112f7c0:	dcc00317 	ldw	r19,12(sp)
8112f7c4:	dc800217 	ldw	r18,8(sp)
8112f7c8:	dc400117 	ldw	r17,4(sp)
8112f7cc:	dc000017 	ldw	r16,0(sp)
8112f7d0:	dec00504 	addi	sp,sp,20
8112f7d4:	f800283a 	ret
8112f7d8:	0101ffc4 	movi	r4,2047
8112f7dc:	813fd626 	beq	r16,r4,8112f738 <__reset+0xfb10f738>
8112f7e0:	29402034 	orhi	r5,r5,128
8112f7e4:	01000e04 	movi	r4,56
8112f7e8:	2080a316 	blt	r4,r2,8112fa78 <__subdf3+0x3cc>
8112f7ec:	010007c4 	movi	r4,31
8112f7f0:	2080c616 	blt	r4,r2,8112fb0c <__subdf3+0x460>
8112f7f4:	01000804 	movi	r4,32
8112f7f8:	2089c83a 	sub	r4,r4,r2
8112f7fc:	2910983a 	sll	r8,r5,r4
8112f800:	308ed83a 	srl	r7,r6,r2
8112f804:	3108983a 	sll	r4,r6,r4
8112f808:	2884d83a 	srl	r2,r5,r2
8112f80c:	41ccb03a 	or	r6,r8,r7
8112f810:	2008c03a 	cmpne	r4,r4,zero
8112f814:	310cb03a 	or	r6,r6,r4
8112f818:	898dc83a 	sub	r6,r17,r6
8112f81c:	89a3803a 	cmpltu	r17,r17,r6
8112f820:	1887c83a 	sub	r3,r3,r2
8112f824:	1c47c83a 	sub	r3,r3,r17
8112f828:	3023883a 	mov	r17,r6
8112f82c:	1880202c 	andhi	r2,r3,128
8112f830:	10002326 	beq	r2,zero,8112f8c0 <__subdf3+0x214>
8112f834:	04c02034 	movhi	r19,128
8112f838:	9cffffc4 	addi	r19,r19,-1
8112f83c:	1ce6703a 	and	r19,r3,r19
8112f840:	98007a26 	beq	r19,zero,8112fa2c <__subdf3+0x380>
8112f844:	9809883a 	mov	r4,r19
8112f848:	111a7a00 	call	8111a7a0 <__clzsi2>
8112f84c:	113ffe04 	addi	r4,r2,-8
8112f850:	00c007c4 	movi	r3,31
8112f854:	19007b16 	blt	r3,r4,8112fa44 <__subdf3+0x398>
8112f858:	00800804 	movi	r2,32
8112f85c:	1105c83a 	sub	r2,r2,r4
8112f860:	8884d83a 	srl	r2,r17,r2
8112f864:	9906983a 	sll	r3,r19,r4
8112f868:	8922983a 	sll	r17,r17,r4
8112f86c:	10c4b03a 	or	r2,r2,r3
8112f870:	24007816 	blt	r4,r16,8112fa54 <__subdf3+0x3a8>
8112f874:	2421c83a 	sub	r16,r4,r16
8112f878:	80c00044 	addi	r3,r16,1
8112f87c:	010007c4 	movi	r4,31
8112f880:	20c09516 	blt	r4,r3,8112fad8 <__subdf3+0x42c>
8112f884:	01400804 	movi	r5,32
8112f888:	28cbc83a 	sub	r5,r5,r3
8112f88c:	88c8d83a 	srl	r4,r17,r3
8112f890:	8962983a 	sll	r17,r17,r5
8112f894:	114a983a 	sll	r5,r2,r5
8112f898:	10c6d83a 	srl	r3,r2,r3
8112f89c:	8804c03a 	cmpne	r2,r17,zero
8112f8a0:	290ab03a 	or	r5,r5,r4
8112f8a4:	28a2b03a 	or	r17,r5,r2
8112f8a8:	0021883a 	mov	r16,zero
8112f8ac:	003fa206 	br	8112f738 <__reset+0xfb10f738>
8112f8b0:	2090b03a 	or	r8,r4,r2
8112f8b4:	40018e26 	beq	r8,zero,8112fef0 <__subdf3+0x844>
8112f8b8:	1007883a 	mov	r3,r2
8112f8bc:	2023883a 	mov	r17,r4
8112f8c0:	888001cc 	andi	r2,r17,7
8112f8c4:	103f9e1e 	bne	r2,zero,8112f740 <__reset+0xfb10f740>
8112f8c8:	1804977a 	slli	r2,r3,29
8112f8cc:	8822d0fa 	srli	r17,r17,3
8112f8d0:	1810d0fa 	srli	r8,r3,3
8112f8d4:	9100004c 	andi	r4,r18,1
8112f8d8:	1444b03a 	or	r2,r2,r17
8112f8dc:	00c1ffc4 	movi	r3,2047
8112f8e0:	80c02826 	beq	r16,r3,8112f984 <__subdf3+0x2d8>
8112f8e4:	01400434 	movhi	r5,16
8112f8e8:	297fffc4 	addi	r5,r5,-1
8112f8ec:	80e0703a 	and	r16,r16,r3
8112f8f0:	414a703a 	and	r5,r8,r5
8112f8f4:	003fa806 	br	8112f798 <__reset+0xfb10f798>
8112f8f8:	0080630e 	bge	zero,r2,8112fa88 <__subdf3+0x3dc>
8112f8fc:	48003026 	beq	r9,zero,8112f9c0 <__subdf3+0x314>
8112f900:	0101ffc4 	movi	r4,2047
8112f904:	813f8c26 	beq	r16,r4,8112f738 <__reset+0xfb10f738>
8112f908:	29402034 	orhi	r5,r5,128
8112f90c:	01000e04 	movi	r4,56
8112f910:	2080a90e 	bge	r4,r2,8112fbb8 <__subdf3+0x50c>
8112f914:	298cb03a 	or	r6,r5,r6
8112f918:	3012c03a 	cmpne	r9,r6,zero
8112f91c:	0005883a 	mov	r2,zero
8112f920:	4c53883a 	add	r9,r9,r17
8112f924:	4c63803a 	cmpltu	r17,r9,r17
8112f928:	10c7883a 	add	r3,r2,r3
8112f92c:	88c7883a 	add	r3,r17,r3
8112f930:	4823883a 	mov	r17,r9
8112f934:	1880202c 	andhi	r2,r3,128
8112f938:	1000d026 	beq	r2,zero,8112fc7c <__subdf3+0x5d0>
8112f93c:	84000044 	addi	r16,r16,1
8112f940:	0081ffc4 	movi	r2,2047
8112f944:	8080fe26 	beq	r16,r2,8112fd40 <__subdf3+0x694>
8112f948:	00bfe034 	movhi	r2,65408
8112f94c:	10bfffc4 	addi	r2,r2,-1
8112f950:	1886703a 	and	r3,r3,r2
8112f954:	880ad07a 	srli	r5,r17,1
8112f958:	180497fa 	slli	r2,r3,31
8112f95c:	8900004c 	andi	r4,r17,1
8112f960:	2922b03a 	or	r17,r5,r4
8112f964:	1806d07a 	srli	r3,r3,1
8112f968:	1462b03a 	or	r17,r2,r17
8112f96c:	3825883a 	mov	r18,r7
8112f970:	003f7106 	br	8112f738 <__reset+0xfb10f738>
8112f974:	2984b03a 	or	r2,r5,r6
8112f978:	103f6826 	beq	r2,zero,8112f71c <__reset+0xfb10f71c>
8112f97c:	39c03fcc 	andi	r7,r7,255
8112f980:	003f6706 	br	8112f720 <__reset+0xfb10f720>
8112f984:	4086b03a 	or	r3,r8,r2
8112f988:	18015226 	beq	r3,zero,8112fed4 <__subdf3+0x828>
8112f98c:	00c00434 	movhi	r3,16
8112f990:	41400234 	orhi	r5,r8,8
8112f994:	18ffffc4 	addi	r3,r3,-1
8112f998:	28ca703a 	and	r5,r5,r3
8112f99c:	003f7e06 	br	8112f798 <__reset+0xfb10f798>
8112f9a0:	10bfffc4 	addi	r2,r2,-1
8112f9a4:	1000491e 	bne	r2,zero,8112facc <__subdf3+0x420>
8112f9a8:	898fc83a 	sub	r7,r17,r6
8112f9ac:	89e3803a 	cmpltu	r17,r17,r7
8112f9b0:	1947c83a 	sub	r3,r3,r5
8112f9b4:	1c47c83a 	sub	r3,r3,r17
8112f9b8:	3823883a 	mov	r17,r7
8112f9bc:	003f9b06 	br	8112f82c <__reset+0xfb10f82c>
8112f9c0:	2988b03a 	or	r4,r5,r6
8112f9c4:	203f5c26 	beq	r4,zero,8112f738 <__reset+0xfb10f738>
8112f9c8:	10bfffc4 	addi	r2,r2,-1
8112f9cc:	1000931e 	bne	r2,zero,8112fc1c <__subdf3+0x570>
8112f9d0:	898d883a 	add	r6,r17,r6
8112f9d4:	3463803a 	cmpltu	r17,r6,r17
8112f9d8:	1947883a 	add	r3,r3,r5
8112f9dc:	88c7883a 	add	r3,r17,r3
8112f9e0:	3023883a 	mov	r17,r6
8112f9e4:	003fd306 	br	8112f934 <__reset+0xfb10f934>
8112f9e8:	1000541e 	bne	r2,zero,8112fb3c <__subdf3+0x490>
8112f9ec:	80800044 	addi	r2,r16,1
8112f9f0:	1081ffcc 	andi	r2,r2,2047
8112f9f4:	01000044 	movi	r4,1
8112f9f8:	2080a20e 	bge	r4,r2,8112fc84 <__subdf3+0x5d8>
8112f9fc:	8989c83a 	sub	r4,r17,r6
8112fa00:	8905803a 	cmpltu	r2,r17,r4
8112fa04:	1967c83a 	sub	r19,r3,r5
8112fa08:	98a7c83a 	sub	r19,r19,r2
8112fa0c:	9880202c 	andhi	r2,r19,128
8112fa10:	10006326 	beq	r2,zero,8112fba0 <__subdf3+0x4f4>
8112fa14:	3463c83a 	sub	r17,r6,r17
8112fa18:	28c7c83a 	sub	r3,r5,r3
8112fa1c:	344d803a 	cmpltu	r6,r6,r17
8112fa20:	19a7c83a 	sub	r19,r3,r6
8112fa24:	3825883a 	mov	r18,r7
8112fa28:	983f861e 	bne	r19,zero,8112f844 <__reset+0xfb10f844>
8112fa2c:	8809883a 	mov	r4,r17
8112fa30:	111a7a00 	call	8111a7a0 <__clzsi2>
8112fa34:	10800804 	addi	r2,r2,32
8112fa38:	113ffe04 	addi	r4,r2,-8
8112fa3c:	00c007c4 	movi	r3,31
8112fa40:	193f850e 	bge	r3,r4,8112f858 <__reset+0xfb10f858>
8112fa44:	10bff604 	addi	r2,r2,-40
8112fa48:	8884983a 	sll	r2,r17,r2
8112fa4c:	0023883a 	mov	r17,zero
8112fa50:	243f880e 	bge	r4,r16,8112f874 <__reset+0xfb10f874>
8112fa54:	00ffe034 	movhi	r3,65408
8112fa58:	18ffffc4 	addi	r3,r3,-1
8112fa5c:	8121c83a 	sub	r16,r16,r4
8112fa60:	10c6703a 	and	r3,r2,r3
8112fa64:	003f3406 	br	8112f738 <__reset+0xfb10f738>
8112fa68:	9100004c 	andi	r4,r18,1
8112fa6c:	000b883a 	mov	r5,zero
8112fa70:	0005883a 	mov	r2,zero
8112fa74:	003f4806 	br	8112f798 <__reset+0xfb10f798>
8112fa78:	298cb03a 	or	r6,r5,r6
8112fa7c:	300cc03a 	cmpne	r6,r6,zero
8112fa80:	0005883a 	mov	r2,zero
8112fa84:	003f6406 	br	8112f818 <__reset+0xfb10f818>
8112fa88:	10009a1e 	bne	r2,zero,8112fcf4 <__subdf3+0x648>
8112fa8c:	82400044 	addi	r9,r16,1
8112fa90:	4881ffcc 	andi	r2,r9,2047
8112fa94:	02800044 	movi	r10,1
8112fa98:	5080670e 	bge	r10,r2,8112fc38 <__subdf3+0x58c>
8112fa9c:	0081ffc4 	movi	r2,2047
8112faa0:	4880af26 	beq	r9,r2,8112fd60 <__subdf3+0x6b4>
8112faa4:	898d883a 	add	r6,r17,r6
8112faa8:	1945883a 	add	r2,r3,r5
8112faac:	3447803a 	cmpltu	r3,r6,r17
8112fab0:	1887883a 	add	r3,r3,r2
8112fab4:	182297fa 	slli	r17,r3,31
8112fab8:	300cd07a 	srli	r6,r6,1
8112fabc:	1806d07a 	srli	r3,r3,1
8112fac0:	4821883a 	mov	r16,r9
8112fac4:	89a2b03a 	or	r17,r17,r6
8112fac8:	003f1b06 	br	8112f738 <__reset+0xfb10f738>
8112facc:	0101ffc4 	movi	r4,2047
8112fad0:	813f441e 	bne	r16,r4,8112f7e4 <__reset+0xfb10f7e4>
8112fad4:	003f1806 	br	8112f738 <__reset+0xfb10f738>
8112fad8:	843ff844 	addi	r16,r16,-31
8112fadc:	01400804 	movi	r5,32
8112fae0:	1408d83a 	srl	r4,r2,r16
8112fae4:	19405026 	beq	r3,r5,8112fc28 <__subdf3+0x57c>
8112fae8:	01401004 	movi	r5,64
8112faec:	28c7c83a 	sub	r3,r5,r3
8112faf0:	10c4983a 	sll	r2,r2,r3
8112faf4:	88a2b03a 	or	r17,r17,r2
8112faf8:	8822c03a 	cmpne	r17,r17,zero
8112fafc:	2462b03a 	or	r17,r4,r17
8112fb00:	0007883a 	mov	r3,zero
8112fb04:	0021883a 	mov	r16,zero
8112fb08:	003f6d06 	br	8112f8c0 <__reset+0xfb10f8c0>
8112fb0c:	11fff804 	addi	r7,r2,-32
8112fb10:	01000804 	movi	r4,32
8112fb14:	29ced83a 	srl	r7,r5,r7
8112fb18:	11004526 	beq	r2,r4,8112fc30 <__subdf3+0x584>
8112fb1c:	01001004 	movi	r4,64
8112fb20:	2089c83a 	sub	r4,r4,r2
8112fb24:	2904983a 	sll	r2,r5,r4
8112fb28:	118cb03a 	or	r6,r2,r6
8112fb2c:	300cc03a 	cmpne	r6,r6,zero
8112fb30:	398cb03a 	or	r6,r7,r6
8112fb34:	0005883a 	mov	r2,zero
8112fb38:	003f3706 	br	8112f818 <__reset+0xfb10f818>
8112fb3c:	80002a26 	beq	r16,zero,8112fbe8 <__subdf3+0x53c>
8112fb40:	0101ffc4 	movi	r4,2047
8112fb44:	49006626 	beq	r9,r4,8112fce0 <__subdf3+0x634>
8112fb48:	0085c83a 	sub	r2,zero,r2
8112fb4c:	18c02034 	orhi	r3,r3,128
8112fb50:	01000e04 	movi	r4,56
8112fb54:	20807e16 	blt	r4,r2,8112fd50 <__subdf3+0x6a4>
8112fb58:	010007c4 	movi	r4,31
8112fb5c:	2080e716 	blt	r4,r2,8112fefc <__subdf3+0x850>
8112fb60:	01000804 	movi	r4,32
8112fb64:	2089c83a 	sub	r4,r4,r2
8112fb68:	1914983a 	sll	r10,r3,r4
8112fb6c:	8890d83a 	srl	r8,r17,r2
8112fb70:	8908983a 	sll	r4,r17,r4
8112fb74:	1884d83a 	srl	r2,r3,r2
8112fb78:	5222b03a 	or	r17,r10,r8
8112fb7c:	2006c03a 	cmpne	r3,r4,zero
8112fb80:	88e2b03a 	or	r17,r17,r3
8112fb84:	3463c83a 	sub	r17,r6,r17
8112fb88:	2885c83a 	sub	r2,r5,r2
8112fb8c:	344d803a 	cmpltu	r6,r6,r17
8112fb90:	1187c83a 	sub	r3,r2,r6
8112fb94:	4821883a 	mov	r16,r9
8112fb98:	3825883a 	mov	r18,r7
8112fb9c:	003f2306 	br	8112f82c <__reset+0xfb10f82c>
8112fba0:	24d0b03a 	or	r8,r4,r19
8112fba4:	40001b1e 	bne	r8,zero,8112fc14 <__subdf3+0x568>
8112fba8:	0005883a 	mov	r2,zero
8112fbac:	0009883a 	mov	r4,zero
8112fbb0:	0021883a 	mov	r16,zero
8112fbb4:	003f4906 	br	8112f8dc <__reset+0xfb10f8dc>
8112fbb8:	010007c4 	movi	r4,31
8112fbbc:	20803a16 	blt	r4,r2,8112fca8 <__subdf3+0x5fc>
8112fbc0:	01000804 	movi	r4,32
8112fbc4:	2089c83a 	sub	r4,r4,r2
8112fbc8:	2912983a 	sll	r9,r5,r4
8112fbcc:	3090d83a 	srl	r8,r6,r2
8112fbd0:	3108983a 	sll	r4,r6,r4
8112fbd4:	2884d83a 	srl	r2,r5,r2
8112fbd8:	4a12b03a 	or	r9,r9,r8
8112fbdc:	2008c03a 	cmpne	r4,r4,zero
8112fbe0:	4912b03a 	or	r9,r9,r4
8112fbe4:	003f4e06 	br	8112f920 <__reset+0xfb10f920>
8112fbe8:	1c48b03a 	or	r4,r3,r17
8112fbec:	20003c26 	beq	r4,zero,8112fce0 <__subdf3+0x634>
8112fbf0:	0084303a 	nor	r2,zero,r2
8112fbf4:	1000381e 	bne	r2,zero,8112fcd8 <__subdf3+0x62c>
8112fbf8:	3463c83a 	sub	r17,r6,r17
8112fbfc:	28c5c83a 	sub	r2,r5,r3
8112fc00:	344d803a 	cmpltu	r6,r6,r17
8112fc04:	1187c83a 	sub	r3,r2,r6
8112fc08:	4821883a 	mov	r16,r9
8112fc0c:	3825883a 	mov	r18,r7
8112fc10:	003f0606 	br	8112f82c <__reset+0xfb10f82c>
8112fc14:	2023883a 	mov	r17,r4
8112fc18:	003f0906 	br	8112f840 <__reset+0xfb10f840>
8112fc1c:	0101ffc4 	movi	r4,2047
8112fc20:	813f3a1e 	bne	r16,r4,8112f90c <__reset+0xfb10f90c>
8112fc24:	003ec406 	br	8112f738 <__reset+0xfb10f738>
8112fc28:	0005883a 	mov	r2,zero
8112fc2c:	003fb106 	br	8112faf4 <__reset+0xfb10faf4>
8112fc30:	0005883a 	mov	r2,zero
8112fc34:	003fbc06 	br	8112fb28 <__reset+0xfb10fb28>
8112fc38:	1c44b03a 	or	r2,r3,r17
8112fc3c:	80008e1e 	bne	r16,zero,8112fe78 <__subdf3+0x7cc>
8112fc40:	1000c826 	beq	r2,zero,8112ff64 <__subdf3+0x8b8>
8112fc44:	2984b03a 	or	r2,r5,r6
8112fc48:	103ebb26 	beq	r2,zero,8112f738 <__reset+0xfb10f738>
8112fc4c:	8989883a 	add	r4,r17,r6
8112fc50:	1945883a 	add	r2,r3,r5
8112fc54:	2447803a 	cmpltu	r3,r4,r17
8112fc58:	1887883a 	add	r3,r3,r2
8112fc5c:	1880202c 	andhi	r2,r3,128
8112fc60:	2023883a 	mov	r17,r4
8112fc64:	103f1626 	beq	r2,zero,8112f8c0 <__reset+0xfb10f8c0>
8112fc68:	00bfe034 	movhi	r2,65408
8112fc6c:	10bfffc4 	addi	r2,r2,-1
8112fc70:	5021883a 	mov	r16,r10
8112fc74:	1886703a 	and	r3,r3,r2
8112fc78:	003eaf06 	br	8112f738 <__reset+0xfb10f738>
8112fc7c:	3825883a 	mov	r18,r7
8112fc80:	003f0f06 	br	8112f8c0 <__reset+0xfb10f8c0>
8112fc84:	1c44b03a 	or	r2,r3,r17
8112fc88:	8000251e 	bne	r16,zero,8112fd20 <__subdf3+0x674>
8112fc8c:	1000661e 	bne	r2,zero,8112fe28 <__subdf3+0x77c>
8112fc90:	2990b03a 	or	r8,r5,r6
8112fc94:	40009626 	beq	r8,zero,8112fef0 <__subdf3+0x844>
8112fc98:	2807883a 	mov	r3,r5
8112fc9c:	3023883a 	mov	r17,r6
8112fca0:	3825883a 	mov	r18,r7
8112fca4:	003ea406 	br	8112f738 <__reset+0xfb10f738>
8112fca8:	127ff804 	addi	r9,r2,-32
8112fcac:	01000804 	movi	r4,32
8112fcb0:	2a52d83a 	srl	r9,r5,r9
8112fcb4:	11008c26 	beq	r2,r4,8112fee8 <__subdf3+0x83c>
8112fcb8:	01001004 	movi	r4,64
8112fcbc:	2085c83a 	sub	r2,r4,r2
8112fcc0:	2884983a 	sll	r2,r5,r2
8112fcc4:	118cb03a 	or	r6,r2,r6
8112fcc8:	300cc03a 	cmpne	r6,r6,zero
8112fccc:	4992b03a 	or	r9,r9,r6
8112fcd0:	0005883a 	mov	r2,zero
8112fcd4:	003f1206 	br	8112f920 <__reset+0xfb10f920>
8112fcd8:	0101ffc4 	movi	r4,2047
8112fcdc:	493f9c1e 	bne	r9,r4,8112fb50 <__reset+0xfb10fb50>
8112fce0:	2807883a 	mov	r3,r5
8112fce4:	3023883a 	mov	r17,r6
8112fce8:	4821883a 	mov	r16,r9
8112fcec:	3825883a 	mov	r18,r7
8112fcf0:	003e9106 	br	8112f738 <__reset+0xfb10f738>
8112fcf4:	80001f1e 	bne	r16,zero,8112fd74 <__subdf3+0x6c8>
8112fcf8:	1c48b03a 	or	r4,r3,r17
8112fcfc:	20005a26 	beq	r4,zero,8112fe68 <__subdf3+0x7bc>
8112fd00:	0084303a 	nor	r2,zero,r2
8112fd04:	1000561e 	bne	r2,zero,8112fe60 <__subdf3+0x7b4>
8112fd08:	89a3883a 	add	r17,r17,r6
8112fd0c:	1945883a 	add	r2,r3,r5
8112fd10:	898d803a 	cmpltu	r6,r17,r6
8112fd14:	3087883a 	add	r3,r6,r2
8112fd18:	4821883a 	mov	r16,r9
8112fd1c:	003f0506 	br	8112f934 <__reset+0xfb10f934>
8112fd20:	10002b1e 	bne	r2,zero,8112fdd0 <__subdf3+0x724>
8112fd24:	2984b03a 	or	r2,r5,r6
8112fd28:	10008026 	beq	r2,zero,8112ff2c <__subdf3+0x880>
8112fd2c:	2807883a 	mov	r3,r5
8112fd30:	3023883a 	mov	r17,r6
8112fd34:	3825883a 	mov	r18,r7
8112fd38:	0401ffc4 	movi	r16,2047
8112fd3c:	003e7e06 	br	8112f738 <__reset+0xfb10f738>
8112fd40:	3809883a 	mov	r4,r7
8112fd44:	0011883a 	mov	r8,zero
8112fd48:	0005883a 	mov	r2,zero
8112fd4c:	003ee306 	br	8112f8dc <__reset+0xfb10f8dc>
8112fd50:	1c62b03a 	or	r17,r3,r17
8112fd54:	8822c03a 	cmpne	r17,r17,zero
8112fd58:	0005883a 	mov	r2,zero
8112fd5c:	003f8906 	br	8112fb84 <__reset+0xfb10fb84>
8112fd60:	3809883a 	mov	r4,r7
8112fd64:	4821883a 	mov	r16,r9
8112fd68:	0011883a 	mov	r8,zero
8112fd6c:	0005883a 	mov	r2,zero
8112fd70:	003eda06 	br	8112f8dc <__reset+0xfb10f8dc>
8112fd74:	0101ffc4 	movi	r4,2047
8112fd78:	49003b26 	beq	r9,r4,8112fe68 <__subdf3+0x7bc>
8112fd7c:	0085c83a 	sub	r2,zero,r2
8112fd80:	18c02034 	orhi	r3,r3,128
8112fd84:	01000e04 	movi	r4,56
8112fd88:	20806e16 	blt	r4,r2,8112ff44 <__subdf3+0x898>
8112fd8c:	010007c4 	movi	r4,31
8112fd90:	20807716 	blt	r4,r2,8112ff70 <__subdf3+0x8c4>
8112fd94:	01000804 	movi	r4,32
8112fd98:	2089c83a 	sub	r4,r4,r2
8112fd9c:	1914983a 	sll	r10,r3,r4
8112fda0:	8890d83a 	srl	r8,r17,r2
8112fda4:	8908983a 	sll	r4,r17,r4
8112fda8:	1884d83a 	srl	r2,r3,r2
8112fdac:	5222b03a 	or	r17,r10,r8
8112fdb0:	2006c03a 	cmpne	r3,r4,zero
8112fdb4:	88e2b03a 	or	r17,r17,r3
8112fdb8:	89a3883a 	add	r17,r17,r6
8112fdbc:	1145883a 	add	r2,r2,r5
8112fdc0:	898d803a 	cmpltu	r6,r17,r6
8112fdc4:	3087883a 	add	r3,r6,r2
8112fdc8:	4821883a 	mov	r16,r9
8112fdcc:	003ed906 	br	8112f934 <__reset+0xfb10f934>
8112fdd0:	2984b03a 	or	r2,r5,r6
8112fdd4:	10004226 	beq	r2,zero,8112fee0 <__subdf3+0x834>
8112fdd8:	1808d0fa 	srli	r4,r3,3
8112fddc:	8822d0fa 	srli	r17,r17,3
8112fde0:	1806977a 	slli	r3,r3,29
8112fde4:	2080022c 	andhi	r2,r4,8
8112fde8:	1c62b03a 	or	r17,r3,r17
8112fdec:	10000826 	beq	r2,zero,8112fe10 <__subdf3+0x764>
8112fdf0:	2812d0fa 	srli	r9,r5,3
8112fdf4:	4880022c 	andhi	r2,r9,8
8112fdf8:	1000051e 	bne	r2,zero,8112fe10 <__subdf3+0x764>
8112fdfc:	300cd0fa 	srli	r6,r6,3
8112fe00:	2804977a 	slli	r2,r5,29
8112fe04:	4809883a 	mov	r4,r9
8112fe08:	3825883a 	mov	r18,r7
8112fe0c:	11a2b03a 	or	r17,r2,r6
8112fe10:	8806d77a 	srli	r3,r17,29
8112fe14:	200890fa 	slli	r4,r4,3
8112fe18:	882290fa 	slli	r17,r17,3
8112fe1c:	0401ffc4 	movi	r16,2047
8112fe20:	1906b03a 	or	r3,r3,r4
8112fe24:	003e4406 	br	8112f738 <__reset+0xfb10f738>
8112fe28:	2984b03a 	or	r2,r5,r6
8112fe2c:	103e4226 	beq	r2,zero,8112f738 <__reset+0xfb10f738>
8112fe30:	8989c83a 	sub	r4,r17,r6
8112fe34:	8911803a 	cmpltu	r8,r17,r4
8112fe38:	1945c83a 	sub	r2,r3,r5
8112fe3c:	1205c83a 	sub	r2,r2,r8
8112fe40:	1200202c 	andhi	r8,r2,128
8112fe44:	403e9a26 	beq	r8,zero,8112f8b0 <__reset+0xfb10f8b0>
8112fe48:	3463c83a 	sub	r17,r6,r17
8112fe4c:	28c5c83a 	sub	r2,r5,r3
8112fe50:	344d803a 	cmpltu	r6,r6,r17
8112fe54:	1187c83a 	sub	r3,r2,r6
8112fe58:	3825883a 	mov	r18,r7
8112fe5c:	003e3606 	br	8112f738 <__reset+0xfb10f738>
8112fe60:	0101ffc4 	movi	r4,2047
8112fe64:	493fc71e 	bne	r9,r4,8112fd84 <__reset+0xfb10fd84>
8112fe68:	2807883a 	mov	r3,r5
8112fe6c:	3023883a 	mov	r17,r6
8112fe70:	4821883a 	mov	r16,r9
8112fe74:	003e3006 	br	8112f738 <__reset+0xfb10f738>
8112fe78:	10003626 	beq	r2,zero,8112ff54 <__subdf3+0x8a8>
8112fe7c:	2984b03a 	or	r2,r5,r6
8112fe80:	10001726 	beq	r2,zero,8112fee0 <__subdf3+0x834>
8112fe84:	1808d0fa 	srli	r4,r3,3
8112fe88:	8822d0fa 	srli	r17,r17,3
8112fe8c:	1806977a 	slli	r3,r3,29
8112fe90:	2080022c 	andhi	r2,r4,8
8112fe94:	1c62b03a 	or	r17,r3,r17
8112fe98:	10000726 	beq	r2,zero,8112feb8 <__subdf3+0x80c>
8112fe9c:	2812d0fa 	srli	r9,r5,3
8112fea0:	4880022c 	andhi	r2,r9,8
8112fea4:	1000041e 	bne	r2,zero,8112feb8 <__subdf3+0x80c>
8112fea8:	300cd0fa 	srli	r6,r6,3
8112feac:	2804977a 	slli	r2,r5,29
8112feb0:	4809883a 	mov	r4,r9
8112feb4:	11a2b03a 	or	r17,r2,r6
8112feb8:	8806d77a 	srli	r3,r17,29
8112febc:	200890fa 	slli	r4,r4,3
8112fec0:	882290fa 	slli	r17,r17,3
8112fec4:	3825883a 	mov	r18,r7
8112fec8:	1906b03a 	or	r3,r3,r4
8112fecc:	0401ffc4 	movi	r16,2047
8112fed0:	003e1906 	br	8112f738 <__reset+0xfb10f738>
8112fed4:	000b883a 	mov	r5,zero
8112fed8:	0005883a 	mov	r2,zero
8112fedc:	003e2e06 	br	8112f798 <__reset+0xfb10f798>
8112fee0:	0401ffc4 	movi	r16,2047
8112fee4:	003e1406 	br	8112f738 <__reset+0xfb10f738>
8112fee8:	0005883a 	mov	r2,zero
8112feec:	003f7506 	br	8112fcc4 <__reset+0xfb10fcc4>
8112fef0:	0005883a 	mov	r2,zero
8112fef4:	0009883a 	mov	r4,zero
8112fef8:	003e7806 	br	8112f8dc <__reset+0xfb10f8dc>
8112fefc:	123ff804 	addi	r8,r2,-32
8112ff00:	01000804 	movi	r4,32
8112ff04:	1a10d83a 	srl	r8,r3,r8
8112ff08:	11002526 	beq	r2,r4,8112ffa0 <__subdf3+0x8f4>
8112ff0c:	01001004 	movi	r4,64
8112ff10:	2085c83a 	sub	r2,r4,r2
8112ff14:	1884983a 	sll	r2,r3,r2
8112ff18:	1444b03a 	or	r2,r2,r17
8112ff1c:	1004c03a 	cmpne	r2,r2,zero
8112ff20:	40a2b03a 	or	r17,r8,r2
8112ff24:	0005883a 	mov	r2,zero
8112ff28:	003f1606 	br	8112fb84 <__reset+0xfb10fb84>
8112ff2c:	02000434 	movhi	r8,16
8112ff30:	0009883a 	mov	r4,zero
8112ff34:	423fffc4 	addi	r8,r8,-1
8112ff38:	00bfffc4 	movi	r2,-1
8112ff3c:	0401ffc4 	movi	r16,2047
8112ff40:	003e6606 	br	8112f8dc <__reset+0xfb10f8dc>
8112ff44:	1c62b03a 	or	r17,r3,r17
8112ff48:	8822c03a 	cmpne	r17,r17,zero
8112ff4c:	0005883a 	mov	r2,zero
8112ff50:	003f9906 	br	8112fdb8 <__reset+0xfb10fdb8>
8112ff54:	2807883a 	mov	r3,r5
8112ff58:	3023883a 	mov	r17,r6
8112ff5c:	0401ffc4 	movi	r16,2047
8112ff60:	003df506 	br	8112f738 <__reset+0xfb10f738>
8112ff64:	2807883a 	mov	r3,r5
8112ff68:	3023883a 	mov	r17,r6
8112ff6c:	003df206 	br	8112f738 <__reset+0xfb10f738>
8112ff70:	123ff804 	addi	r8,r2,-32
8112ff74:	01000804 	movi	r4,32
8112ff78:	1a10d83a 	srl	r8,r3,r8
8112ff7c:	11000a26 	beq	r2,r4,8112ffa8 <__subdf3+0x8fc>
8112ff80:	01001004 	movi	r4,64
8112ff84:	2085c83a 	sub	r2,r4,r2
8112ff88:	1884983a 	sll	r2,r3,r2
8112ff8c:	1444b03a 	or	r2,r2,r17
8112ff90:	1004c03a 	cmpne	r2,r2,zero
8112ff94:	40a2b03a 	or	r17,r8,r2
8112ff98:	0005883a 	mov	r2,zero
8112ff9c:	003f8606 	br	8112fdb8 <__reset+0xfb10fdb8>
8112ffa0:	0005883a 	mov	r2,zero
8112ffa4:	003fdc06 	br	8112ff18 <__reset+0xfb10ff18>
8112ffa8:	0005883a 	mov	r2,zero
8112ffac:	003ff706 	br	8112ff8c <__reset+0xfb10ff8c>

8112ffb0 <__fixdfsi>:
8112ffb0:	280cd53a 	srli	r6,r5,20
8112ffb4:	00c00434 	movhi	r3,16
8112ffb8:	18ffffc4 	addi	r3,r3,-1
8112ffbc:	3181ffcc 	andi	r6,r6,2047
8112ffc0:	01c0ff84 	movi	r7,1022
8112ffc4:	28c6703a 	and	r3,r5,r3
8112ffc8:	280ad7fa 	srli	r5,r5,31
8112ffcc:	3980120e 	bge	r7,r6,81130018 <__fixdfsi+0x68>
8112ffd0:	00810744 	movi	r2,1053
8112ffd4:	11800c16 	blt	r2,r6,81130008 <__fixdfsi+0x58>
8112ffd8:	00810cc4 	movi	r2,1075
8112ffdc:	1185c83a 	sub	r2,r2,r6
8112ffe0:	01c007c4 	movi	r7,31
8112ffe4:	18c00434 	orhi	r3,r3,16
8112ffe8:	38800d16 	blt	r7,r2,81130020 <__fixdfsi+0x70>
8112ffec:	31befb44 	addi	r6,r6,-1043
8112fff0:	2084d83a 	srl	r2,r4,r2
8112fff4:	1986983a 	sll	r3,r3,r6
8112fff8:	1884b03a 	or	r2,r3,r2
8112fffc:	28000726 	beq	r5,zero,8113001c <__fixdfsi+0x6c>
81130000:	0085c83a 	sub	r2,zero,r2
81130004:	f800283a 	ret
81130008:	00a00034 	movhi	r2,32768
8113000c:	10bfffc4 	addi	r2,r2,-1
81130010:	2885883a 	add	r2,r5,r2
81130014:	f800283a 	ret
81130018:	0005883a 	mov	r2,zero
8113001c:	f800283a 	ret
81130020:	008104c4 	movi	r2,1043
81130024:	1185c83a 	sub	r2,r2,r6
81130028:	1884d83a 	srl	r2,r3,r2
8113002c:	003ff306 	br	8112fffc <__reset+0xfb10fffc>

81130030 <__floatsidf>:
81130030:	defffd04 	addi	sp,sp,-12
81130034:	de00012e 	bgeu	sp,et,8113003c <__floatsidf+0xc>
81130038:	003b68fa 	trap	3
8113003c:	dfc00215 	stw	ra,8(sp)
81130040:	dc400115 	stw	r17,4(sp)
81130044:	dc000015 	stw	r16,0(sp)
81130048:	20002b26 	beq	r4,zero,811300f8 <__floatsidf+0xc8>
8113004c:	2023883a 	mov	r17,r4
81130050:	2020d7fa 	srli	r16,r4,31
81130054:	20002d16 	blt	r4,zero,8113010c <__floatsidf+0xdc>
81130058:	8809883a 	mov	r4,r17
8113005c:	111a7a00 	call	8111a7a0 <__clzsi2>
81130060:	01410784 	movi	r5,1054
81130064:	288bc83a 	sub	r5,r5,r2
81130068:	01010cc4 	movi	r4,1075
8113006c:	2149c83a 	sub	r4,r4,r5
81130070:	00c007c4 	movi	r3,31
81130074:	1900160e 	bge	r3,r4,811300d0 <__floatsidf+0xa0>
81130078:	00c104c4 	movi	r3,1043
8113007c:	1947c83a 	sub	r3,r3,r5
81130080:	88c6983a 	sll	r3,r17,r3
81130084:	00800434 	movhi	r2,16
81130088:	10bfffc4 	addi	r2,r2,-1
8113008c:	1886703a 	and	r3,r3,r2
81130090:	2941ffcc 	andi	r5,r5,2047
81130094:	800d883a 	mov	r6,r16
81130098:	0005883a 	mov	r2,zero
8113009c:	280a953a 	slli	r5,r5,20
811300a0:	31803fcc 	andi	r6,r6,255
811300a4:	01000434 	movhi	r4,16
811300a8:	300c97fa 	slli	r6,r6,31
811300ac:	213fffc4 	addi	r4,r4,-1
811300b0:	1906703a 	and	r3,r3,r4
811300b4:	1946b03a 	or	r3,r3,r5
811300b8:	1986b03a 	or	r3,r3,r6
811300bc:	dfc00217 	ldw	ra,8(sp)
811300c0:	dc400117 	ldw	r17,4(sp)
811300c4:	dc000017 	ldw	r16,0(sp)
811300c8:	dec00304 	addi	sp,sp,12
811300cc:	f800283a 	ret
811300d0:	00c002c4 	movi	r3,11
811300d4:	1887c83a 	sub	r3,r3,r2
811300d8:	88c6d83a 	srl	r3,r17,r3
811300dc:	8904983a 	sll	r2,r17,r4
811300e0:	01000434 	movhi	r4,16
811300e4:	213fffc4 	addi	r4,r4,-1
811300e8:	2941ffcc 	andi	r5,r5,2047
811300ec:	1906703a 	and	r3,r3,r4
811300f0:	800d883a 	mov	r6,r16
811300f4:	003fe906 	br	8113009c <__reset+0xfb11009c>
811300f8:	000d883a 	mov	r6,zero
811300fc:	000b883a 	mov	r5,zero
81130100:	0007883a 	mov	r3,zero
81130104:	0005883a 	mov	r2,zero
81130108:	003fe406 	br	8113009c <__reset+0xfb11009c>
8113010c:	0123c83a 	sub	r17,zero,r4
81130110:	003fd106 	br	81130058 <__reset+0xfb110058>

81130114 <__floatunsidf>:
81130114:	defffe04 	addi	sp,sp,-8
81130118:	de00012e 	bgeu	sp,et,81130120 <__floatunsidf+0xc>
8113011c:	003b68fa 	trap	3
81130120:	dc000015 	stw	r16,0(sp)
81130124:	dfc00115 	stw	ra,4(sp)
81130128:	2021883a 	mov	r16,r4
8113012c:	20002226 	beq	r4,zero,811301b8 <__floatunsidf+0xa4>
81130130:	111a7a00 	call	8111a7a0 <__clzsi2>
81130134:	01010784 	movi	r4,1054
81130138:	2089c83a 	sub	r4,r4,r2
8113013c:	01810cc4 	movi	r6,1075
81130140:	310dc83a 	sub	r6,r6,r4
81130144:	00c007c4 	movi	r3,31
81130148:	1980120e 	bge	r3,r6,81130194 <__floatunsidf+0x80>
8113014c:	00c104c4 	movi	r3,1043
81130150:	1907c83a 	sub	r3,r3,r4
81130154:	80ca983a 	sll	r5,r16,r3
81130158:	00800434 	movhi	r2,16
8113015c:	10bfffc4 	addi	r2,r2,-1
81130160:	2101ffcc 	andi	r4,r4,2047
81130164:	0021883a 	mov	r16,zero
81130168:	288a703a 	and	r5,r5,r2
8113016c:	2008953a 	slli	r4,r4,20
81130170:	00c00434 	movhi	r3,16
81130174:	18ffffc4 	addi	r3,r3,-1
81130178:	28c6703a 	and	r3,r5,r3
8113017c:	8005883a 	mov	r2,r16
81130180:	1906b03a 	or	r3,r3,r4
81130184:	dfc00117 	ldw	ra,4(sp)
81130188:	dc000017 	ldw	r16,0(sp)
8113018c:	dec00204 	addi	sp,sp,8
81130190:	f800283a 	ret
81130194:	00c002c4 	movi	r3,11
81130198:	188bc83a 	sub	r5,r3,r2
8113019c:	814ad83a 	srl	r5,r16,r5
811301a0:	00c00434 	movhi	r3,16
811301a4:	18ffffc4 	addi	r3,r3,-1
811301a8:	81a0983a 	sll	r16,r16,r6
811301ac:	2101ffcc 	andi	r4,r4,2047
811301b0:	28ca703a 	and	r5,r5,r3
811301b4:	003fed06 	br	8113016c <__reset+0xfb11016c>
811301b8:	0009883a 	mov	r4,zero
811301bc:	000b883a 	mov	r5,zero
811301c0:	003fea06 	br	8113016c <__reset+0xfb11016c>

811301c4 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
811301c4:	defffb04 	addi	sp,sp,-20
811301c8:	de00012e 	bgeu	sp,et,811301d0 <alt_busy_sleep+0xc>
811301cc:	003b68fa 	trap	3
811301d0:	df000415 	stw	fp,16(sp)
811301d4:	df000404 	addi	fp,sp,16
811301d8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
811301dc:	008000c4 	movi	r2,3
811301e0:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
811301e4:	e0fffd17 	ldw	r3,-12(fp)
811301e8:	008003f4 	movhi	r2,15
811301ec:	10909004 	addi	r2,r2,16960
811301f0:	1887383a 	mul	r3,r3,r2
811301f4:	00817db4 	movhi	r2,1526
811301f8:	10b84004 	addi	r2,r2,-7936
811301fc:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81130200:	00a00034 	movhi	r2,32768
81130204:	10bfffc4 	addi	r2,r2,-1
81130208:	10c5203a 	divu	r2,r2,r3
8113020c:	e0ffff17 	ldw	r3,-4(fp)
81130210:	1885203a 	divu	r2,r3,r2
81130214:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
81130218:	e0bffe17 	ldw	r2,-8(fp)
8113021c:	10002526 	beq	r2,zero,811302b4 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
81130220:	e03ffc15 	stw	zero,-16(fp)
81130224:	00001406 	br	81130278 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81130228:	00a00034 	movhi	r2,32768
8113022c:	10bfffc4 	addi	r2,r2,-1
81130230:	10bfffc4 	addi	r2,r2,-1
81130234:	103ffe1e 	bne	r2,zero,81130230 <__reset+0xfb110230>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81130238:	e0fffd17 	ldw	r3,-12(fp)
8113023c:	008003f4 	movhi	r2,15
81130240:	10909004 	addi	r2,r2,16960
81130244:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81130248:	00817db4 	movhi	r2,1526
8113024c:	10b84004 	addi	r2,r2,-7936
81130250:	10c7203a 	divu	r3,r2,r3
81130254:	00a00034 	movhi	r2,32768
81130258:	10bfffc4 	addi	r2,r2,-1
8113025c:	10c5203a 	divu	r2,r2,r3
81130260:	e0ffff17 	ldw	r3,-4(fp)
81130264:	1885c83a 	sub	r2,r3,r2
81130268:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
8113026c:	e0bffc17 	ldw	r2,-16(fp)
81130270:	10800044 	addi	r2,r2,1
81130274:	e0bffc15 	stw	r2,-16(fp)
81130278:	e0fffc17 	ldw	r3,-16(fp)
8113027c:	e0bffe17 	ldw	r2,-8(fp)
81130280:	18bfe916 	blt	r3,r2,81130228 <__reset+0xfb110228>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81130284:	e0fffd17 	ldw	r3,-12(fp)
81130288:	008003f4 	movhi	r2,15
8113028c:	10909004 	addi	r2,r2,16960
81130290:	1887383a 	mul	r3,r3,r2
81130294:	00817db4 	movhi	r2,1526
81130298:	10b84004 	addi	r2,r2,-7936
8113029c:	10c7203a 	divu	r3,r2,r3
811302a0:	e0bfff17 	ldw	r2,-4(fp)
811302a4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811302a8:	10bfffc4 	addi	r2,r2,-1
811302ac:	103ffe1e 	bne	r2,zero,811302a8 <__reset+0xfb1102a8>
811302b0:	00000b06 	br	811302e0 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
811302b4:	e0fffd17 	ldw	r3,-12(fp)
811302b8:	008003f4 	movhi	r2,15
811302bc:	10909004 	addi	r2,r2,16960
811302c0:	1887383a 	mul	r3,r3,r2
811302c4:	00817db4 	movhi	r2,1526
811302c8:	10b84004 	addi	r2,r2,-7936
811302cc:	10c7203a 	divu	r3,r2,r3
811302d0:	e0bfff17 	ldw	r2,-4(fp)
811302d4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811302d8:	10bfffc4 	addi	r2,r2,-1
811302dc:	00bffe16 	blt	zero,r2,811302d8 <__reset+0xfb1102d8>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
811302e0:	0005883a 	mov	r2,zero
}
811302e4:	e037883a 	mov	sp,fp
811302e8:	df000017 	ldw	fp,0(sp)
811302ec:	dec00104 	addi	sp,sp,4
811302f0:	f800283a 	ret

811302f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811302f4:	defffe04 	addi	sp,sp,-8
811302f8:	de00012e 	bgeu	sp,et,81130300 <alt_get_errno+0xc>
811302fc:	003b68fa 	trap	3
81130300:	dfc00115 	stw	ra,4(sp)
81130304:	df000015 	stw	fp,0(sp)
81130308:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113030c:	d0a01017 	ldw	r2,-32704(gp)
81130310:	10000326 	beq	r2,zero,81130320 <alt_get_errno+0x2c>
81130314:	d0a01017 	ldw	r2,-32704(gp)
81130318:	103ee83a 	callr	r2
8113031c:	00000106 	br	81130324 <alt_get_errno+0x30>
81130320:	d0a07d04 	addi	r2,gp,-32268
}
81130324:	e037883a 	mov	sp,fp
81130328:	dfc00117 	ldw	ra,4(sp)
8113032c:	df000017 	ldw	fp,0(sp)
81130330:	dec00204 	addi	sp,sp,8
81130334:	f800283a 	ret

81130338 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81130338:	defffb04 	addi	sp,sp,-20
8113033c:	de00012e 	bgeu	sp,et,81130344 <close+0xc>
81130340:	003b68fa 	trap	3
81130344:	dfc00415 	stw	ra,16(sp)
81130348:	df000315 	stw	fp,12(sp)
8113034c:	df000304 	addi	fp,sp,12
81130350:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81130354:	e0bfff17 	ldw	r2,-4(fp)
81130358:	10000616 	blt	r2,zero,81130374 <close+0x3c>
8113035c:	e0bfff17 	ldw	r2,-4(fp)
81130360:	10c00324 	muli	r3,r2,12
81130364:	00a04574 	movhi	r2,33045
81130368:	10ab6a04 	addi	r2,r2,-21080
8113036c:	1885883a 	add	r2,r3,r2
81130370:	00000106 	br	81130378 <close+0x40>
81130374:	0005883a 	mov	r2,zero
81130378:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8113037c:	e0bffd17 	ldw	r2,-12(fp)
81130380:	10001926 	beq	r2,zero,811303e8 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81130384:	e0bffd17 	ldw	r2,-12(fp)
81130388:	10800017 	ldw	r2,0(r2)
8113038c:	10800417 	ldw	r2,16(r2)
81130390:	10000626 	beq	r2,zero,811303ac <close+0x74>
81130394:	e0bffd17 	ldw	r2,-12(fp)
81130398:	10800017 	ldw	r2,0(r2)
8113039c:	10800417 	ldw	r2,16(r2)
811303a0:	e13ffd17 	ldw	r4,-12(fp)
811303a4:	103ee83a 	callr	r2
811303a8:	00000106 	br	811303b0 <close+0x78>
811303ac:	0005883a 	mov	r2,zero
811303b0:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
811303b4:	e13fff17 	ldw	r4,-4(fp)
811303b8:	113191c0 	call	8113191c <alt_release_fd>
    if (rval < 0)
811303bc:	e0bffe17 	ldw	r2,-8(fp)
811303c0:	1000070e 	bge	r2,zero,811303e0 <close+0xa8>
    {
      ALT_ERRNO = -rval;
811303c4:	11302f40 	call	811302f4 <alt_get_errno>
811303c8:	1007883a 	mov	r3,r2
811303cc:	e0bffe17 	ldw	r2,-8(fp)
811303d0:	0085c83a 	sub	r2,zero,r2
811303d4:	18800015 	stw	r2,0(r3)
      return -1;
811303d8:	00bfffc4 	movi	r2,-1
811303dc:	00000706 	br	811303fc <close+0xc4>
    }
    return 0;
811303e0:	0005883a 	mov	r2,zero
811303e4:	00000506 	br	811303fc <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
811303e8:	11302f40 	call	811302f4 <alt_get_errno>
811303ec:	1007883a 	mov	r3,r2
811303f0:	00801444 	movi	r2,81
811303f4:	18800015 	stw	r2,0(r3)
    return -1;
811303f8:	00bfffc4 	movi	r2,-1
  }
}
811303fc:	e037883a 	mov	sp,fp
81130400:	dfc00117 	ldw	ra,4(sp)
81130404:	df000017 	ldw	fp,0(sp)
81130408:	dec00204 	addi	sp,sp,8
8113040c:	f800283a 	ret

81130410 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
81130410:	deffff04 	addi	sp,sp,-4
81130414:	de00012e 	bgeu	sp,et,8113041c <alt_dcache_flush_all+0xc>
81130418:	003b68fa 	trap	3
8113041c:	df000015 	stw	fp,0(sp)
81130420:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81130424:	0001883a 	nop
81130428:	e037883a 	mov	sp,fp
8113042c:	df000017 	ldw	fp,0(sp)
81130430:	dec00104 	addi	sp,sp,4
81130434:	f800283a 	ret

81130438 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81130438:	defffc04 	addi	sp,sp,-16
8113043c:	de00012e 	bgeu	sp,et,81130444 <alt_dev_null_write+0xc>
81130440:	003b68fa 	trap	3
81130444:	df000315 	stw	fp,12(sp)
81130448:	df000304 	addi	fp,sp,12
8113044c:	e13ffd15 	stw	r4,-12(fp)
81130450:	e17ffe15 	stw	r5,-8(fp)
81130454:	e1bfff15 	stw	r6,-4(fp)
  return len;
81130458:	e0bfff17 	ldw	r2,-4(fp)
}
8113045c:	e037883a 	mov	sp,fp
81130460:	df000017 	ldw	fp,0(sp)
81130464:	dec00104 	addi	sp,sp,4
81130468:	f800283a 	ret

8113046c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113046c:	defffe04 	addi	sp,sp,-8
81130470:	de00012e 	bgeu	sp,et,81130478 <alt_get_errno+0xc>
81130474:	003b68fa 	trap	3
81130478:	dfc00115 	stw	ra,4(sp)
8113047c:	df000015 	stw	fp,0(sp)
81130480:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81130484:	d0a01017 	ldw	r2,-32704(gp)
81130488:	10000326 	beq	r2,zero,81130498 <alt_get_errno+0x2c>
8113048c:	d0a01017 	ldw	r2,-32704(gp)
81130490:	103ee83a 	callr	r2
81130494:	00000106 	br	8113049c <alt_get_errno+0x30>
81130498:	d0a07d04 	addi	r2,gp,-32268
}
8113049c:	e037883a 	mov	sp,fp
811304a0:	dfc00117 	ldw	ra,4(sp)
811304a4:	df000017 	ldw	fp,0(sp)
811304a8:	dec00204 	addi	sp,sp,8
811304ac:	f800283a 	ret

811304b0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
811304b0:	defffb04 	addi	sp,sp,-20
811304b4:	de00012e 	bgeu	sp,et,811304bc <fstat+0xc>
811304b8:	003b68fa 	trap	3
811304bc:	dfc00415 	stw	ra,16(sp)
811304c0:	df000315 	stw	fp,12(sp)
811304c4:	df000304 	addi	fp,sp,12
811304c8:	e13ffe15 	stw	r4,-8(fp)
811304cc:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811304d0:	e0bffe17 	ldw	r2,-8(fp)
811304d4:	10000616 	blt	r2,zero,811304f0 <fstat+0x40>
811304d8:	e0bffe17 	ldw	r2,-8(fp)
811304dc:	10c00324 	muli	r3,r2,12
811304e0:	00a04574 	movhi	r2,33045
811304e4:	10ab6a04 	addi	r2,r2,-21080
811304e8:	1885883a 	add	r2,r3,r2
811304ec:	00000106 	br	811304f4 <fstat+0x44>
811304f0:	0005883a 	mov	r2,zero
811304f4:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811304f8:	e0bffd17 	ldw	r2,-12(fp)
811304fc:	10001026 	beq	r2,zero,81130540 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81130500:	e0bffd17 	ldw	r2,-12(fp)
81130504:	10800017 	ldw	r2,0(r2)
81130508:	10800817 	ldw	r2,32(r2)
8113050c:	10000726 	beq	r2,zero,8113052c <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
81130510:	e0bffd17 	ldw	r2,-12(fp)
81130514:	10800017 	ldw	r2,0(r2)
81130518:	10800817 	ldw	r2,32(r2)
8113051c:	e17fff17 	ldw	r5,-4(fp)
81130520:	e13ffd17 	ldw	r4,-12(fp)
81130524:	103ee83a 	callr	r2
81130528:	00000a06 	br	81130554 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
8113052c:	e0bfff17 	ldw	r2,-4(fp)
81130530:	00c80004 	movi	r3,8192
81130534:	10c00115 	stw	r3,4(r2)
      return 0;
81130538:	0005883a 	mov	r2,zero
8113053c:	00000506 	br	81130554 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81130540:	113046c0 	call	8113046c <alt_get_errno>
81130544:	1007883a 	mov	r3,r2
81130548:	00801444 	movi	r2,81
8113054c:	18800015 	stw	r2,0(r3)
    return -1;
81130550:	00bfffc4 	movi	r2,-1
  }
}
81130554:	e037883a 	mov	sp,fp
81130558:	dfc00117 	ldw	ra,4(sp)
8113055c:	df000017 	ldw	fp,0(sp)
81130560:	dec00204 	addi	sp,sp,8
81130564:	f800283a 	ret

81130568 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81130568:	defff004 	addi	sp,sp,-64
8113056c:	de00012e 	bgeu	sp,et,81130574 <alt_irq_register+0xc>
81130570:	003b68fa 	trap	3
81130574:	df000f15 	stw	fp,60(sp)
81130578:	df000f04 	addi	fp,sp,60
8113057c:	e13ffd15 	stw	r4,-12(fp)
81130580:	e17ffe15 	stw	r5,-8(fp)
81130584:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81130588:	00bffa84 	movi	r2,-22
8113058c:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81130590:	e0bffd17 	ldw	r2,-12(fp)
81130594:	10800828 	cmpgeui	r2,r2,32
81130598:	1000501e 	bne	r2,zero,811306dc <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113059c:	0005303a 	rdctl	r2,status
811305a0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811305a4:	e0fff617 	ldw	r3,-40(fp)
811305a8:	00bfff84 	movi	r2,-2
811305ac:	1884703a 	and	r2,r3,r2
811305b0:	1001703a 	wrctl	status,r2
  
  return context;
811305b4:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
811305b8:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
811305bc:	00a045b4 	movhi	r2,33046
811305c0:	10965004 	addi	r2,r2,22848
811305c4:	e0fffd17 	ldw	r3,-12(fp)
811305c8:	180690fa 	slli	r3,r3,3
811305cc:	10c5883a 	add	r2,r2,r3
811305d0:	e0ffff17 	ldw	r3,-4(fp)
811305d4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
811305d8:	00a045b4 	movhi	r2,33046
811305dc:	10965004 	addi	r2,r2,22848
811305e0:	e0fffd17 	ldw	r3,-12(fp)
811305e4:	180690fa 	slli	r3,r3,3
811305e8:	10c5883a 	add	r2,r2,r3
811305ec:	10800104 	addi	r2,r2,4
811305f0:	e0fffe17 	ldw	r3,-8(fp)
811305f4:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811305f8:	e0bfff17 	ldw	r2,-4(fp)
811305fc:	10001926 	beq	r2,zero,81130664 <alt_irq_register+0xfc>
81130600:	e0bffd17 	ldw	r2,-12(fp)
81130604:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130608:	0005303a 	rdctl	r2,status
8113060c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130610:	e0fff717 	ldw	r3,-36(fp)
81130614:	00bfff84 	movi	r2,-2
81130618:	1884703a 	and	r2,r3,r2
8113061c:	1001703a 	wrctl	status,r2
  
  return context;
81130620:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81130624:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81130628:	00c00044 	movi	r3,1
8113062c:	e0bff217 	ldw	r2,-56(fp)
81130630:	1884983a 	sll	r2,r3,r2
81130634:	1007883a 	mov	r3,r2
81130638:	d0a08517 	ldw	r2,-32236(gp)
8113063c:	1884b03a 	or	r2,r3,r2
81130640:	d0a08515 	stw	r2,-32236(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81130644:	d0a08517 	ldw	r2,-32236(gp)
81130648:	100170fa 	wrctl	ienable,r2
8113064c:	e0bff817 	ldw	r2,-32(fp)
81130650:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130654:	e0bff917 	ldw	r2,-28(fp)
81130658:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113065c:	0005883a 	mov	r2,zero
81130660:	00001906 	br	811306c8 <alt_irq_register+0x160>
81130664:	e0bffd17 	ldw	r2,-12(fp)
81130668:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113066c:	0005303a 	rdctl	r2,status
81130670:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130674:	e0fffa17 	ldw	r3,-24(fp)
81130678:	00bfff84 	movi	r2,-2
8113067c:	1884703a 	and	r2,r3,r2
81130680:	1001703a 	wrctl	status,r2
  
  return context;
81130684:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81130688:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
8113068c:	00c00044 	movi	r3,1
81130690:	e0bff417 	ldw	r2,-48(fp)
81130694:	1884983a 	sll	r2,r3,r2
81130698:	0084303a 	nor	r2,zero,r2
8113069c:	1007883a 	mov	r3,r2
811306a0:	d0a08517 	ldw	r2,-32236(gp)
811306a4:	1884703a 	and	r2,r3,r2
811306a8:	d0a08515 	stw	r2,-32236(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811306ac:	d0a08517 	ldw	r2,-32236(gp)
811306b0:	100170fa 	wrctl	ienable,r2
811306b4:	e0bffb17 	ldw	r2,-20(fp)
811306b8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811306bc:	e0bffc17 	ldw	r2,-16(fp)
811306c0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811306c4:	0005883a 	mov	r2,zero
811306c8:	e0bff115 	stw	r2,-60(fp)
811306cc:	e0bff317 	ldw	r2,-52(fp)
811306d0:	e0bff515 	stw	r2,-44(fp)
811306d4:	e0bff517 	ldw	r2,-44(fp)
811306d8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
811306dc:	e0bff117 	ldw	r2,-60(fp)
}
811306e0:	e037883a 	mov	sp,fp
811306e4:	df000017 	ldw	fp,0(sp)
811306e8:	dec00104 	addi	sp,sp,4
811306ec:	f800283a 	ret

811306f0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811306f0:	defffe04 	addi	sp,sp,-8
811306f4:	de00012e 	bgeu	sp,et,811306fc <alt_get_errno+0xc>
811306f8:	003b68fa 	trap	3
811306fc:	dfc00115 	stw	ra,4(sp)
81130700:	df000015 	stw	fp,0(sp)
81130704:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81130708:	d0a01017 	ldw	r2,-32704(gp)
8113070c:	10000326 	beq	r2,zero,8113071c <alt_get_errno+0x2c>
81130710:	d0a01017 	ldw	r2,-32704(gp)
81130714:	103ee83a 	callr	r2
81130718:	00000106 	br	81130720 <alt_get_errno+0x30>
8113071c:	d0a07d04 	addi	r2,gp,-32268
}
81130720:	e037883a 	mov	sp,fp
81130724:	dfc00117 	ldw	ra,4(sp)
81130728:	df000017 	ldw	fp,0(sp)
8113072c:	dec00204 	addi	sp,sp,8
81130730:	f800283a 	ret

81130734 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81130734:	deffed04 	addi	sp,sp,-76
81130738:	de00012e 	bgeu	sp,et,81130740 <isatty+0xc>
8113073c:	003b68fa 	trap	3
81130740:	dfc01215 	stw	ra,72(sp)
81130744:	df001115 	stw	fp,68(sp)
81130748:	df001104 	addi	fp,sp,68
8113074c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81130750:	e0bfff17 	ldw	r2,-4(fp)
81130754:	10000616 	blt	r2,zero,81130770 <isatty+0x3c>
81130758:	e0bfff17 	ldw	r2,-4(fp)
8113075c:	10c00324 	muli	r3,r2,12
81130760:	00a04574 	movhi	r2,33045
81130764:	10ab6a04 	addi	r2,r2,-21080
81130768:	1885883a 	add	r2,r3,r2
8113076c:	00000106 	br	81130774 <isatty+0x40>
81130770:	0005883a 	mov	r2,zero
81130774:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81130778:	e0bfef17 	ldw	r2,-68(fp)
8113077c:	10000e26 	beq	r2,zero,811307b8 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81130780:	e0bfef17 	ldw	r2,-68(fp)
81130784:	10800017 	ldw	r2,0(r2)
81130788:	10800817 	ldw	r2,32(r2)
8113078c:	1000021e 	bne	r2,zero,81130798 <isatty+0x64>
    {
      return 1;
81130790:	00800044 	movi	r2,1
81130794:	00000d06 	br	811307cc <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81130798:	e0bff004 	addi	r2,fp,-64
8113079c:	100b883a 	mov	r5,r2
811307a0:	e13fff17 	ldw	r4,-4(fp)
811307a4:	11304b00 	call	811304b0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
811307a8:	e0bff117 	ldw	r2,-60(fp)
811307ac:	10880020 	cmpeqi	r2,r2,8192
811307b0:	10803fcc 	andi	r2,r2,255
811307b4:	00000506 	br	811307cc <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811307b8:	11306f00 	call	811306f0 <alt_get_errno>
811307bc:	1007883a 	mov	r3,r2
811307c0:	00801444 	movi	r2,81
811307c4:	18800015 	stw	r2,0(r3)
    return 0;
811307c8:	0005883a 	mov	r2,zero
  }
}
811307cc:	e037883a 	mov	sp,fp
811307d0:	dfc00117 	ldw	ra,4(sp)
811307d4:	df000017 	ldw	fp,0(sp)
811307d8:	dec00204 	addi	sp,sp,8
811307dc:	f800283a 	ret

811307e0 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
811307e0:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
811307e4:	318c2404 	addi	r6,r6,12432

811307e8 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
811307e8:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
811307ec:	01c00826 	beq	zero,r7,81130810 <end_tx>

811307f0 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
811307f0:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
811307f4:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
811307f8:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
811307fc:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81130800:	283ffb26 	beq	r5,zero,811307f0 <__reset+0xfb1107f0>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81130804:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81130808:	21000044 	addi	r4,r4,1
	br tx_next_char
8113080c:	003ff606 	br	811307e8 <__reset+0xfb1107e8>

81130810 <end_tx>:
end_tx:	
        ret
81130810:	f800283a 	ret

81130814 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81130814:	defffd04 	addi	sp,sp,-12
81130818:	de00012e 	bgeu	sp,et,81130820 <alt_log_txchar+0xc>
8113081c:	003b68fa 	trap	3
81130820:	df000215 	stw	fp,8(sp)
81130824:	df000204 	addi	fp,sp,8
81130828:	e13ffe15 	stw	r4,-8(fp)
8113082c:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81130830:	0001883a 	nop
81130834:	e0bfff17 	ldw	r2,-4(fp)
81130838:	10800104 	addi	r2,r2,4
8113083c:	10800037 	ldwio	r2,0(r2)
81130840:	10bfffec 	andhi	r2,r2,65535
81130844:	103ffb26 	beq	r2,zero,81130834 <__reset+0xfb110834>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81130848:	e0bfff17 	ldw	r2,-4(fp)
8113084c:	e0fffe17 	ldw	r3,-8(fp)
81130850:	10c00035 	stwio	r3,0(r2)
}
81130854:	0001883a 	nop
81130858:	e037883a 	mov	sp,fp
8113085c:	df000017 	ldw	fp,0(sp)
81130860:	dec00104 	addi	sp,sp,4
81130864:	f800283a 	ret

81130868 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81130868:	defffb04 	addi	sp,sp,-20
8113086c:	de00012e 	bgeu	sp,et,81130874 <alt_log_repchar+0xc>
81130870:	003b68fa 	trap	3
81130874:	dfc00415 	stw	ra,16(sp)
81130878:	df000315 	stw	fp,12(sp)
8113087c:	df000304 	addi	fp,sp,12
81130880:	2005883a 	mov	r2,r4
81130884:	e17ffe15 	stw	r5,-8(fp)
81130888:	e1bfff15 	stw	r6,-4(fp)
8113088c:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81130890:	00000506 	br	811308a8 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81130894:	e0bffd07 	ldb	r2,-12(fp)
81130898:	e0ffff17 	ldw	r3,-4(fp)
8113089c:	180b883a 	mov	r5,r3
811308a0:	1009883a 	mov	r4,r2
811308a4:	11308140 	call	81130814 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
811308a8:	e0bffe17 	ldw	r2,-8(fp)
811308ac:	10ffffc4 	addi	r3,r2,-1
811308b0:	e0fffe15 	stw	r3,-8(fp)
811308b4:	00bff716 	blt	zero,r2,81130894 <__reset+0xfb110894>
    alt_log_txchar(c,(char*) base);
}
811308b8:	0001883a 	nop
811308bc:	e037883a 	mov	sp,fp
811308c0:	dfc00117 	ldw	ra,4(sp)
811308c4:	df000017 	ldw	fp,0(sp)
811308c8:	dec00204 	addi	sp,sp,8
811308cc:	f800283a 	ret

811308d0 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
811308d0:	deffe904 	addi	sp,sp,-92
811308d4:	de00012e 	bgeu	sp,et,811308dc <alt_log_private_printf+0xc>
811308d8:	003b68fa 	trap	3
811308dc:	dfc01615 	stw	ra,88(sp)
811308e0:	df001515 	stw	fp,84(sp)
811308e4:	dc001415 	stw	r16,80(sp)
811308e8:	df001504 	addi	fp,sp,84
811308ec:	e13ffc15 	stw	r4,-16(fp)
811308f0:	e17ffd15 	stw	r5,-12(fp)
811308f4:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811308f8:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811308fc:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81130900:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81130904:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81130908:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8113090c:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81130910:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81130914:	e0bffc17 	ldw	r2,-16(fp)
81130918:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8113091c:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81130920:	00014b06 	br	81130e50 <alt_log_private_printf+0x580>
    {
    switch(state)
81130924:	e0bfec17 	ldw	r2,-80(fp)
81130928:	10c00060 	cmpeqi	r3,r2,1
8113092c:	18001b1e 	bne	r3,zero,8113099c <alt_log_private_printf+0xcc>
81130930:	10c000a0 	cmpeqi	r3,r2,2
81130934:	18002d1e 	bne	r3,zero,811309ec <alt_log_private_printf+0x11c>
81130938:	10000126 	beq	r2,zero,81130940 <alt_log_private_printf+0x70>
8113093c:	00014406 	br	81130e50 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81130940:	e0bffb07 	ldb	r2,-20(fp)
81130944:	10800958 	cmpnei	r2,r2,37
81130948:	10000e1e 	bne	r2,zero,81130984 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8113094c:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81130950:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81130954:	00800284 	movi	r2,10
81130958:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8113095c:	00800044 	movi	r2,1
81130960:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81130964:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81130968:	00bfffc4 	movi	r2,-1
8113096c:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81130970:	00bfffc4 	movi	r2,-1
81130974:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81130978:	00800044 	movi	r2,1
8113097c:	e0bfec15 	stw	r2,-80(fp)
81130980:	00013306 	br	81130e50 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81130984:	e0bffb07 	ldb	r2,-20(fp)
81130988:	e0fffd17 	ldw	r3,-12(fp)
8113098c:	180b883a 	mov	r5,r3
81130990:	1009883a 	mov	r4,r2
81130994:	11308140 	call	81130814 <alt_log_txchar>
        }
        break;
81130998:	00012d06 	br	81130e50 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
8113099c:	e0bffb07 	ldb	r2,-20(fp)
811309a0:	10800c18 	cmpnei	r2,r2,48
811309a4:	1000051e 	bne	r2,zero,811309bc <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
811309a8:	00800044 	movi	r2,1
811309ac:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
811309b0:	00800084 	movi	r2,2
811309b4:	e0bfec15 	stw	r2,-80(fp)
811309b8:	00012506 	br	81130e50 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
811309bc:	e0bffb07 	ldb	r2,-20(fp)
811309c0:	10800958 	cmpnei	r2,r2,37
811309c4:	1000071e 	bne	r2,zero,811309e4 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
811309c8:	e0bffb07 	ldb	r2,-20(fp)
811309cc:	e0fffd17 	ldw	r3,-12(fp)
811309d0:	180b883a 	mov	r5,r3
811309d4:	1009883a 	mov	r4,r2
811309d8:	11308140 	call	81130814 <alt_log_txchar>
          state = pfState_chars;
811309dc:	e03fec15 	stw	zero,-80(fp)
811309e0:	00011b06 	br	81130e50 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
811309e4:	00800084 	movi	r2,2
811309e8:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
811309ec:	e0bffb07 	ldb	r2,-20(fp)
811309f0:	10800b98 	cmpnei	r2,r2,46
811309f4:	1000021e 	bne	r2,zero,81130a00 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
811309f8:	e03ff015 	stw	zero,-64(fp)
811309fc:	00011306 	br	81130e4c <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81130a00:	e0bffb07 	ldb	r2,-20(fp)
81130a04:	10800c10 	cmplti	r2,r2,48
81130a08:	10001a1e 	bne	r2,zero,81130a74 <alt_log_private_printf+0x1a4>
81130a0c:	e0bffb07 	ldb	r2,-20(fp)
81130a10:	10800e88 	cmpgei	r2,r2,58
81130a14:	1000171e 	bne	r2,zero,81130a74 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81130a18:	e0bffb03 	ldbu	r2,-20(fp)
81130a1c:	10bff404 	addi	r2,r2,-48
81130a20:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81130a24:	e0bff017 	ldw	r2,-64(fp)
81130a28:	10000c0e 	bge	r2,zero,81130a5c <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81130a2c:	e0bfef17 	ldw	r2,-68(fp)
81130a30:	1000020e 	bge	r2,zero,81130a3c <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81130a34:	e03fef15 	stw	zero,-68(fp)
81130a38:	00000306 	br	81130a48 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81130a3c:	e0bfef17 	ldw	r2,-68(fp)
81130a40:	108002a4 	muli	r2,r2,10
81130a44:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81130a48:	e0bffb07 	ldb	r2,-20(fp)
81130a4c:	e0ffef17 	ldw	r3,-68(fp)
81130a50:	1885883a 	add	r2,r3,r2
81130a54:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81130a58:	0000fc06 	br	81130e4c <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81130a5c:	e0bff017 	ldw	r2,-64(fp)
81130a60:	10c002a4 	muli	r3,r2,10
81130a64:	e0bffb07 	ldb	r2,-20(fp)
81130a68:	1885883a 	add	r2,r3,r2
81130a6c:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81130a70:	0000f606 	br	81130e4c <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81130a74:	e0bffb07 	ldb	r2,-20(fp)
81130a78:	10801b18 	cmpnei	r2,r2,108
81130a7c:	1000031e 	bne	r2,zero,81130a8c <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81130a80:	00800044 	movi	r2,1
81130a84:	e0bfee15 	stw	r2,-72(fp)
81130a88:	0000f006 	br	81130e4c <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81130a8c:	e0bffb07 	ldb	r2,-20(fp)
81130a90:	10bfea04 	addi	r2,r2,-88
81130a94:	10c00868 	cmpgeui	r3,r2,33
81130a98:	1800eb1e 	bne	r3,zero,81130e48 <alt_log_private_printf+0x578>
81130a9c:	100690ba 	slli	r3,r2,2
81130aa0:	00a044f4 	movhi	r2,33043
81130aa4:	1082ad04 	addi	r2,r2,2740
81130aa8:	1885883a 	add	r2,r3,r2
81130aac:	10800017 	ldw	r2,0(r2)
81130ab0:	1000683a 	jmp	r2
81130ab4:	81130d74 	orhi	r4,r16,19509
81130ab8:	81130e48 	cmpgei	r4,r16,19513
81130abc:	81130e48 	cmpgei	r4,r16,19513
81130ac0:	81130e48 	cmpgei	r4,r16,19513
81130ac4:	81130e48 	cmpgei	r4,r16,19513
81130ac8:	81130e48 	cmpgei	r4,r16,19513
81130acc:	81130e48 	cmpgei	r4,r16,19513
81130ad0:	81130e48 	cmpgei	r4,r16,19513
81130ad4:	81130e48 	cmpgei	r4,r16,19513
81130ad8:	81130e48 	cmpgei	r4,r16,19513
81130adc:	81130e48 	cmpgei	r4,r16,19513
81130ae0:	81130d8c 	andi	r4,r16,19510
81130ae4:	81130b38 	rdprs	r4,r16,19500
81130ae8:	81130e48 	cmpgei	r4,r16,19513
81130aec:	81130e48 	cmpgei	r4,r16,19513
81130af0:	81130e48 	cmpgei	r4,r16,19513
81130af4:	81130e48 	cmpgei	r4,r16,19513
81130af8:	81130b38 	rdprs	r4,r16,19500
81130afc:	81130e48 	cmpgei	r4,r16,19513
81130b00:	81130e48 	cmpgei	r4,r16,19513
81130b04:	81130e48 	cmpgei	r4,r16,19513
81130b08:	81130e48 	cmpgei	r4,r16,19513
81130b0c:	81130e48 	cmpgei	r4,r16,19513
81130b10:	81130d54 	ori	r4,r16,19509
81130b14:	81130e48 	cmpgei	r4,r16,19513
81130b18:	81130e48 	cmpgei	r4,r16,19513
81130b1c:	81130e48 	cmpgei	r4,r16,19513
81130b20:	81130dc8 	cmpgei	r4,r16,19511
81130b24:	81130e48 	cmpgei	r4,r16,19513
81130b28:	81130d4c 	andi	r4,r16,19509
81130b2c:	81130e48 	cmpgei	r4,r16,19513
81130b30:	81130e48 	cmpgei	r4,r16,19513
81130b34:	81130d64 	muli	r4,r16,19509
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81130b38:	e0bfee17 	ldw	r2,-72(fp)
81130b3c:	10000e26 	beq	r2,zero,81130b78 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81130b40:	e0bff217 	ldw	r2,-56(fp)
81130b44:	10000626 	beq	r2,zero,81130b60 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81130b48:	e0bffe17 	ldw	r2,-8(fp)
81130b4c:	10c00104 	addi	r3,r2,4
81130b50:	e0fffe15 	stw	r3,-8(fp)
81130b54:	10800017 	ldw	r2,0(r2)
81130b58:	e0bff415 	stw	r2,-48(fp)
81130b5c:	00001306 	br	81130bac <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81130b60:	e0bffe17 	ldw	r2,-8(fp)
81130b64:	10c00104 	addi	r3,r2,4
81130b68:	e0fffe15 	stw	r3,-8(fp)
81130b6c:	10800017 	ldw	r2,0(r2)
81130b70:	e0bff415 	stw	r2,-48(fp)
81130b74:	00000d06 	br	81130bac <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81130b78:	e0bff217 	ldw	r2,-56(fp)
81130b7c:	10000626 	beq	r2,zero,81130b98 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81130b80:	e0bffe17 	ldw	r2,-8(fp)
81130b84:	10c00104 	addi	r3,r2,4
81130b88:	e0fffe15 	stw	r3,-8(fp)
81130b8c:	10800017 	ldw	r2,0(r2)
81130b90:	e0bff415 	stw	r2,-48(fp)
81130b94:	00000506 	br	81130bac <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81130b98:	e0bffe17 	ldw	r2,-8(fp)
81130b9c:	10c00104 	addi	r3,r2,4
81130ba0:	e0fffe15 	stw	r3,-8(fp)
81130ba4:	10800017 	ldw	r2,0(r2)
81130ba8:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81130bac:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81130bb0:	e0bff217 	ldw	r2,-56(fp)
81130bb4:	10000726 	beq	r2,zero,81130bd4 <alt_log_private_printf+0x304>
81130bb8:	e0bff417 	ldw	r2,-48(fp)
81130bbc:	1000050e 	bge	r2,zero,81130bd4 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81130bc0:	e0bff417 	ldw	r2,-48(fp)
81130bc4:	0085c83a 	sub	r2,zero,r2
81130bc8:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81130bcc:	00800044 	movi	r2,1
81130bd0:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81130bd4:	e0bff417 	ldw	r2,-48(fp)
81130bd8:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81130bdc:	00800044 	movi	r2,1
81130be0:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81130be4:	00800044 	movi	r2,1
81130be8:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81130bec:	00000706 	br	81130c0c <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81130bf0:	e0bff817 	ldw	r2,-32(fp)
81130bf4:	10800044 	addi	r2,r2,1
81130bf8:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81130bfc:	e0bff117 	ldw	r2,-60(fp)
81130c00:	e0fff517 	ldw	r3,-44(fp)
81130c04:	1885383a 	mul	r2,r3,r2
81130c08:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81130c0c:	e0bff117 	ldw	r2,-60(fp)
81130c10:	e0fff617 	ldw	r3,-40(fp)
81130c14:	1885203a 	divu	r2,r3,r2
81130c18:	e0bff615 	stw	r2,-40(fp)
81130c1c:	e0bff617 	ldw	r2,-40(fp)
81130c20:	103ff31e 	bne	r2,zero,81130bf0 <__reset+0xfb110bf0>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81130c24:	e0ffef17 	ldw	r3,-68(fp)
81130c28:	e0bff817 	ldw	r2,-32(fp)
81130c2c:	1885c83a 	sub	r2,r3,r2
81130c30:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81130c34:	e0bfed17 	ldw	r2,-76(fp)
81130c38:	10000e26 	beq	r2,zero,81130c74 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81130c3c:	e0bff717 	ldw	r2,-36(fp)
81130c40:	10000726 	beq	r2,zero,81130c60 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81130c44:	e0bffd17 	ldw	r2,-12(fp)
81130c48:	100b883a 	mov	r5,r2
81130c4c:	01000b44 	movi	r4,45
81130c50:	11308140 	call	81130814 <alt_log_txchar>
                    fmtBeforeDecimal--;
81130c54:	e0bfef17 	ldw	r2,-68(fp)
81130c58:	10bfffc4 	addi	r2,r2,-1
81130c5c:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81130c60:	e1bffd17 	ldw	r6,-12(fp)
81130c64:	e17fef17 	ldw	r5,-68(fp)
81130c68:	01000c04 	movi	r4,48
81130c6c:	11308680 	call	81130868 <alt_log_repchar>
81130c70:	00003206 	br	81130d3c <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81130c74:	e0bff717 	ldw	r2,-36(fp)
81130c78:	10000326 	beq	r2,zero,81130c88 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81130c7c:	e0bfef17 	ldw	r2,-68(fp)
81130c80:	10bfffc4 	addi	r2,r2,-1
81130c84:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81130c88:	e1bffd17 	ldw	r6,-12(fp)
81130c8c:	e17fef17 	ldw	r5,-68(fp)
81130c90:	01000804 	movi	r4,32
81130c94:	11308680 	call	81130868 <alt_log_repchar>
                    if(sign)
81130c98:	e0bff717 	ldw	r2,-36(fp)
81130c9c:	10002726 	beq	r2,zero,81130d3c <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81130ca0:	e0bffd17 	ldw	r2,-12(fp)
81130ca4:	100b883a 	mov	r5,r2
81130ca8:	01000b44 	movi	r4,45
81130cac:	11308140 	call	81130814 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81130cb0:	00002206 	br	81130d3c <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81130cb4:	e0fff417 	ldw	r3,-48(fp)
81130cb8:	e0bff517 	ldw	r2,-44(fp)
81130cbc:	1885203a 	divu	r2,r3,r2
81130cc0:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81130cc4:	e0bff903 	ldbu	r2,-28(fp)
81130cc8:	10800c04 	addi	r2,r2,48
81130ccc:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81130cd0:	e0bff903 	ldbu	r2,-28(fp)
81130cd4:	10800eb0 	cmpltui	r2,r2,58
81130cd8:	1000081e 	bne	r2,zero,81130cfc <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81130cdc:	e0bff317 	ldw	r2,-52(fp)
81130ce0:	10000226 	beq	r2,zero,81130cec <alt_log_private_printf+0x41c>
81130ce4:	008001c4 	movi	r2,7
81130ce8:	00000106 	br	81130cf0 <alt_log_private_printf+0x420>
81130cec:	008009c4 	movi	r2,39
81130cf0:	e0fff903 	ldbu	r3,-28(fp)
81130cf4:	10c5883a 	add	r2,r2,r3
81130cf8:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81130cfc:	e0bff903 	ldbu	r2,-28(fp)
81130d00:	e0fffd17 	ldw	r3,-12(fp)
81130d04:	180b883a 	mov	r5,r3
81130d08:	1009883a 	mov	r4,r2
81130d0c:	11308140 	call	81130814 <alt_log_txchar>

                  v = v % p;
81130d10:	e0bff417 	ldw	r2,-48(fp)
81130d14:	e0fff517 	ldw	r3,-44(fp)
81130d18:	10c9203a 	divu	r4,r2,r3
81130d1c:	e0fff517 	ldw	r3,-44(fp)
81130d20:	20c7383a 	mul	r3,r4,r3
81130d24:	10c5c83a 	sub	r2,r2,r3
81130d28:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81130d2c:	e0bff117 	ldw	r2,-60(fp)
81130d30:	e0fff517 	ldw	r3,-44(fp)
81130d34:	1885203a 	divu	r2,r3,r2
81130d38:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81130d3c:	e0bff517 	ldw	r2,-44(fp)
81130d40:	103fdc1e 	bne	r2,zero,81130cb4 <__reset+0xfb110cb4>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81130d44:	e03fec15 	stw	zero,-80(fp)
              break;
81130d48:	00003f06 	br	81130e48 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81130d4c:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81130d50:	003f7906 	br	81130b38 <__reset+0xfb110b38>
            case 'o':
              fmtSigned = 0;
81130d54:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81130d58:	00800204 	movi	r2,8
81130d5c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81130d60:	003f7506 	br	81130b38 <__reset+0xfb110b38>
            case 'x':
              fmtSigned = 0;
81130d64:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81130d68:	00800404 	movi	r2,16
81130d6c:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81130d70:	003f7106 	br	81130b38 <__reset+0xfb110b38>
            case 'X':
              fmtSigned = 0;
81130d74:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81130d78:	00800404 	movi	r2,16
81130d7c:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81130d80:	00800044 	movi	r2,1
81130d84:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81130d88:	003f6b06 	br	81130b38 <__reset+0xfb110b38>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81130d8c:	e0bfef17 	ldw	r2,-68(fp)
81130d90:	10bfffc4 	addi	r2,r2,-1
81130d94:	e1bffd17 	ldw	r6,-12(fp)
81130d98:	100b883a 	mov	r5,r2
81130d9c:	01000804 	movi	r4,32
81130da0:	11308680 	call	81130868 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81130da4:	e0bffe17 	ldw	r2,-8(fp)
81130da8:	10c00104 	addi	r3,r2,4
81130dac:	e0fffe15 	stw	r3,-8(fp)
81130db0:	10800017 	ldw	r2,0(r2)
81130db4:	e0fffd17 	ldw	r3,-12(fp)
81130db8:	180b883a 	mov	r5,r3
81130dbc:	1009883a 	mov	r4,r2
81130dc0:	11308140 	call	81130814 <alt_log_txchar>
              break;
81130dc4:	00002006 	br	81130e48 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81130dc8:	e0bffe17 	ldw	r2,-8(fp)
81130dcc:	10c00104 	addi	r3,r2,4
81130dd0:	e0fffe15 	stw	r3,-8(fp)
81130dd4:	10800017 	ldw	r2,0(r2)
81130dd8:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81130ddc:	e43fef17 	ldw	r16,-68(fp)
81130de0:	e13ffa17 	ldw	r4,-24(fp)
81130de4:	111c5040 	call	8111c504 <strlen>
81130de8:	8085c83a 	sub	r2,r16,r2
81130dec:	e1bffd17 	ldw	r6,-12(fp)
81130df0:	100b883a 	mov	r5,r2
81130df4:	01000804 	movi	r4,32
81130df8:	11308680 	call	81130868 <alt_log_repchar>

                while(*s)
81130dfc:	00000b06 	br	81130e2c <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81130e00:	e0bffa17 	ldw	r2,-24(fp)
81130e04:	10c00044 	addi	r3,r2,1
81130e08:	e0fffa15 	stw	r3,-24(fp)
81130e0c:	10800003 	ldbu	r2,0(r2)
81130e10:	10803fcc 	andi	r2,r2,255
81130e14:	1080201c 	xori	r2,r2,128
81130e18:	10bfe004 	addi	r2,r2,-128
81130e1c:	e0fffd17 	ldw	r3,-12(fp)
81130e20:	180b883a 	mov	r5,r3
81130e24:	1009883a 	mov	r4,r2
81130e28:	11308140 	call	81130814 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81130e2c:	e0bffa17 	ldw	r2,-24(fp)
81130e30:	10800003 	ldbu	r2,0(r2)
81130e34:	10803fcc 	andi	r2,r2,255
81130e38:	1080201c 	xori	r2,r2,128
81130e3c:	10bfe004 	addi	r2,r2,-128
81130e40:	103fef1e 	bne	r2,zero,81130e00 <__reset+0xfb110e00>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81130e44:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81130e48:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81130e4c:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81130e50:	e0bfeb17 	ldw	r2,-84(fp)
81130e54:	10c00044 	addi	r3,r2,1
81130e58:	e0ffeb15 	stw	r3,-84(fp)
81130e5c:	10800003 	ldbu	r2,0(r2)
81130e60:	e0bffb05 	stb	r2,-20(fp)
81130e64:	e0bffb07 	ldb	r2,-20(fp)
81130e68:	103eae1e 	bne	r2,zero,81130924 <__reset+0xfb110924>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81130e6c:	0001883a 	nop
81130e70:	e6ffff04 	addi	sp,fp,-4
81130e74:	dfc00217 	ldw	ra,8(sp)
81130e78:	df000117 	ldw	fp,4(sp)
81130e7c:	dc000017 	ldw	r16,0(sp)
81130e80:	dec00304 	addi	sp,sp,12
81130e84:	f800283a 	ret

81130e88 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81130e88:	defff904 	addi	sp,sp,-28
81130e8c:	de00012e 	bgeu	sp,et,81130e94 <alt_log_printf_proc+0xc>
81130e90:	003b68fa 	trap	3
81130e94:	dfc00315 	stw	ra,12(sp)
81130e98:	df000215 	stw	fp,8(sp)
81130e9c:	df000204 	addi	fp,sp,8
81130ea0:	e13fff15 	stw	r4,-4(fp)
81130ea4:	e1400215 	stw	r5,8(fp)
81130ea8:	e1800315 	stw	r6,12(fp)
81130eac:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81130eb0:	e0800204 	addi	r2,fp,8
81130eb4:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81130eb8:	e0bffe17 	ldw	r2,-8(fp)
81130ebc:	100d883a 	mov	r6,r2
81130ec0:	01604834 	movhi	r5,33056
81130ec4:	294c2404 	addi	r5,r5,12432
81130ec8:	e13fff17 	ldw	r4,-4(fp)
81130ecc:	11308d00 	call	811308d0 <alt_log_private_printf>
    return (0);
81130ed0:	0005883a 	mov	r2,zero
}
81130ed4:	e037883a 	mov	sp,fp
81130ed8:	dfc00117 	ldw	ra,4(sp)
81130edc:	df000017 	ldw	fp,0(sp)
81130ee0:	dec00504 	addi	sp,sp,20
81130ee4:	f800283a 	ret

81130ee8 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81130ee8:	defff904 	addi	sp,sp,-28
81130eec:	de00012e 	bgeu	sp,et,81130ef4 <altera_avalon_jtag_uart_report_log+0xc>
81130ef0:	003b68fa 	trap	3
81130ef4:	dfc00615 	stw	ra,24(sp)
81130ef8:	df000515 	stw	fp,20(sp)
81130efc:	dc400415 	stw	r17,16(sp)
81130f00:	dc000315 	stw	r16,12(sp)
81130f04:	df000504 	addi	fp,sp,20
81130f08:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81130f0c:	d0a08683 	ldbu	r2,-32230(gp)
81130f10:	10803fcc 	andi	r2,r2,255
81130f14:	10001426 	beq	r2,zero,81130f68 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81130f18:	e0bffd17 	ldw	r2,-12(fp)
81130f1c:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81130f20:	00a04574 	movhi	r2,33045
81130f24:	10a79004 	addi	r2,r2,-25024
81130f28:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81130f2c:	e0bffb17 	ldw	r2,-20(fp)
81130f30:	10800017 	ldw	r2,0(r2)
81130f34:	e1bffc17 	ldw	r6,-16(fp)
81130f38:	100b883a 	mov	r5,r2
81130f3c:	e13ffb17 	ldw	r4,-20(fp)
81130f40:	1130f880 	call	81130f88 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81130f44:	d0e08d17 	ldw	r3,-32204(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81130f48:	00b33374 	movhi	r2,52429
81130f4c:	10b33344 	addi	r2,r2,-13107
81130f50:	1888383a 	mulxuu	r4,r3,r2
81130f54:	1885383a 	mul	r2,r3,r2
81130f58:	1021883a 	mov	r16,r2
81130f5c:	2023883a 	mov	r17,r4
81130f60:	8804d0fa 	srli	r2,r17,3
81130f64:	00000106 	br	81130f6c <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81130f68:	0005883a 	mov	r2,zero
    }
}
81130f6c:	e6fffe04 	addi	sp,fp,-8
81130f70:	dfc00317 	ldw	ra,12(sp)
81130f74:	df000217 	ldw	fp,8(sp)
81130f78:	dc400117 	ldw	r17,4(sp)
81130f7c:	dc000017 	ldw	r16,0(sp)
81130f80:	dec00404 	addi	sp,sp,16
81130f84:	f800283a 	ret

81130f88 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81130f88:	deffef04 	addi	sp,sp,-68
81130f8c:	de00012e 	bgeu	sp,et,81130f94 <alt_log_jtag_uart_print_control_reg+0xc>
81130f90:	003b68fa 	trap	3
81130f94:	dfc01015 	stw	ra,64(sp)
81130f98:	df000f15 	stw	fp,60(sp)
81130f9c:	df000f04 	addi	fp,sp,60
81130fa0:	e13ffd15 	stw	r4,-12(fp)
81130fa4:	e17ffe15 	stw	r5,-8(fp)
81130fa8:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81130fac:	e0bffe17 	ldw	r2,-8(fp)
81130fb0:	10800104 	addi	r2,r2,4
81130fb4:	10800037 	ldwio	r2,0(r2)
81130fb8:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81130fbc:	e0bff617 	ldw	r2,-40(fp)
81130fc0:	1004d43a 	srli	r2,r2,16
81130fc4:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81130fc8:	e0bff617 	ldw	r2,-40(fp)
81130fcc:	1080008c 	andi	r2,r2,2
81130fd0:	1004d07a 	srli	r2,r2,1
81130fd4:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81130fd8:	e0bff617 	ldw	r2,-40(fp)
81130fdc:	1080004c 	andi	r2,r2,1
81130fe0:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
81130fe4:	e0bff617 	ldw	r2,-40(fp)
81130fe8:	1080400c 	andi	r2,r2,256
81130fec:	1004d23a 	srli	r2,r2,8
81130ff0:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
81130ff4:	e0bff617 	ldw	r2,-40(fp)
81130ff8:	1080800c 	andi	r2,r2,512
81130ffc:	1004d27a 	srli	r2,r2,9
81131000:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
81131004:	e0bff617 	ldw	r2,-40(fp)
81131008:	1081000c 	andi	r2,r2,1024
8113100c:	1004d2ba 	srli	r2,r2,10
81131010:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
81131014:	e0bffd17 	ldw	r2,-12(fp)
81131018:	10c01017 	ldw	r3,64(r2)
8113101c:	e0bffd17 	ldw	r2,-12(fp)
81131020:	10800f17 	ldw	r2,60(r2)
81131024:	1887c83a 	sub	r3,r3,r2
81131028:	e0bff917 	ldw	r2,-28(fp)
8113102c:	d8800415 	stw	r2,16(sp)
81131030:	e0bff817 	ldw	r2,-32(fp)
81131034:	d8800315 	stw	r2,12(sp)
81131038:	e0bffa17 	ldw	r2,-24(fp)
8113103c:	d8800215 	stw	r2,8(sp)
81131040:	e0bffb17 	ldw	r2,-20(fp)
81131044:	d8800115 	stw	r2,4(sp)
81131048:	e0bffc17 	ldw	r2,-16(fp)
8113104c:	d8800015 	stw	r2,0(sp)
81131050:	e1fff717 	ldw	r7,-36(fp)
81131054:	180d883a 	mov	r6,r3
81131058:	e17fff17 	ldw	r5,-4(fp)
8113105c:	01204574 	movhi	r4,33045
81131060:	21279304 	addi	r4,r4,-25012
81131064:	1130e880 	call	81130e88 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81131068:	0001883a 	nop

}
8113106c:	e037883a 	mov	sp,fp
81131070:	dfc00117 	ldw	ra,4(sp)
81131074:	df000017 	ldw	fp,0(sp)
81131078:	dec00204 	addi	sp,sp,8
8113107c:	f800283a 	ret

81131080 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81131080:	defffb04 	addi	sp,sp,-20
81131084:	de00012e 	bgeu	sp,et,8113108c <alt_log_jtag_uart_startup_info+0xc>
81131088:	003b68fa 	trap	3
8113108c:	dfc00415 	stw	ra,16(sp)
81131090:	df000315 	stw	fp,12(sp)
81131094:	df000304 	addi	fp,sp,12
81131098:	e13ffe15 	stw	r4,-8(fp)
8113109c:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
811310a0:	00a04574 	movhi	r2,33045
811310a4:	10a7a504 	addi	r2,r2,-24940
811310a8:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
811310ac:	e1bffd17 	ldw	r6,-12(fp)
811310b0:	e17fff17 	ldw	r5,-4(fp)
811310b4:	e13ffe17 	ldw	r4,-8(fp)
811310b8:	1130f880 	call	81130f88 <alt_log_jtag_uart_print_control_reg>
     return;
811310bc:	0001883a 	nop
}
811310c0:	e037883a 	mov	sp,fp
811310c4:	dfc00117 	ldw	ra,4(sp)
811310c8:	df000017 	ldw	fp,0(sp)
811310cc:	dec00204 	addi	sp,sp,8
811310d0:	f800283a 	ret

811310d4 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
811310d4:	defffb04 	addi	sp,sp,-20
811310d8:	de00012e 	bgeu	sp,et,811310e0 <alt_log_jtag_uart_isr_proc+0xc>
811310dc:	003b68fa 	trap	3
811310e0:	dfc00415 	stw	ra,16(sp)
811310e4:	df000315 	stw	fp,12(sp)
811310e8:	df000304 	addi	fp,sp,12
811310ec:	e13ffe15 	stw	r4,-8(fp)
811310f0:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811310f4:	d0a086c3 	ldbu	r2,-32229(gp)
811310f8:	10803fcc 	andi	r2,r2,255
811310fc:	10000826 	beq	r2,zero,81131120 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81131100:	00a04574 	movhi	r2,33045
81131104:	10a7aa04 	addi	r2,r2,-24920
81131108:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
8113110c:	e1bffd17 	ldw	r6,-12(fp)
81131110:	e17ffe17 	ldw	r5,-8(fp)
81131114:	e13fff17 	ldw	r4,-4(fp)
81131118:	1130f880 	call	81130f88 <alt_log_jtag_uart_print_control_reg>
    }
    return;
8113111c:	0001883a 	nop
81131120:	0001883a 	nop
}
81131124:	e037883a 	mov	sp,fp
81131128:	dfc00117 	ldw	ra,4(sp)
8113112c:	df000017 	ldw	fp,0(sp)
81131130:	dec00204 	addi	sp,sp,8
81131134:	f800283a 	ret

81131138 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81131138:	defffa04 	addi	sp,sp,-24
8113113c:	de00012e 	bgeu	sp,et,81131144 <alt_log_write+0xc>
81131140:	003b68fa 	trap	3
81131144:	dfc00515 	stw	ra,20(sp)
81131148:	df000415 	stw	fp,16(sp)
8113114c:	df000404 	addi	fp,sp,16
81131150:	e13ffe15 	stw	r4,-8(fp)
81131154:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81131158:	d0a08603 	ldbu	r2,-32232(gp)
8113115c:	10803fcc 	andi	r2,r2,255
81131160:	10004026 	beq	r2,zero,81131264 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81131164:	e0bfff17 	ldw	r2,-4(fp)
81131168:	10c00430 	cmpltui	r3,r2,16
8113116c:	1800011e 	bne	r3,zero,81131174 <alt_log_write+0x3c>
81131170:	008003c4 	movi	r2,15
81131174:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81131178:	e0bffd17 	ldw	r2,-12(fp)
8113117c:	10800088 	cmpgei	r2,r2,2
81131180:	10003726 	beq	r2,zero,81131260 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81131184:	e0bffd17 	ldw	r2,-12(fp)
81131188:	100d883a 	mov	r6,r2
8113118c:	e17ffe17 	ldw	r5,-8(fp)
81131190:	012045b4 	movhi	r4,33046
81131194:	213eb404 	addi	r4,r4,-1328
81131198:	1144f500 	call	81144f50 <strncpy>
    alt_log_write_buf[length-1]='\n';
8113119c:	e0bffd17 	ldw	r2,-12(fp)
811311a0:	10ffffc4 	addi	r3,r2,-1
811311a4:	00a045b4 	movhi	r2,33046
811311a8:	10beb404 	addi	r2,r2,-1328
811311ac:	10c5883a 	add	r2,r2,r3
811311b0:	00c00284 	movi	r3,10
811311b4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
811311b8:	00a045b4 	movhi	r2,33046
811311bc:	10beb404 	addi	r2,r2,-1328
811311c0:	e0fffd17 	ldw	r3,-12(fp)
811311c4:	10c5883a 	add	r2,r2,r3
811311c8:	00c00344 	movi	r3,13
811311cc:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
811311d0:	e0bffd17 	ldw	r2,-12(fp)
811311d4:	10c00044 	addi	r3,r2,1
811311d8:	00a045b4 	movhi	r2,33046
811311dc:	10beb404 	addi	r2,r2,-1328
811311e0:	10c5883a 	add	r2,r2,r3
811311e4:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811311e8:	e03ffc15 	stw	zero,-16(fp)
811311ec:	00001306 	br	8113123c <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811311f0:	00a045b4 	movhi	r2,33046
811311f4:	10beb404 	addi	r2,r2,-1328
811311f8:	e0fffc17 	ldw	r3,-16(fp)
811311fc:	10c5883a 	add	r2,r2,r3
81131200:	10800003 	ldbu	r2,0(r2)
81131204:	10803fcc 	andi	r2,r2,255
81131208:	1080201c 	xori	r2,r2,128
8113120c:	10bfe004 	addi	r2,r2,-128
81131210:	10800118 	cmpnei	r2,r2,4
81131214:	1000061e 	bne	r2,zero,81131230 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
81131218:	00a045b4 	movhi	r2,33046
8113121c:	10beb404 	addi	r2,r2,-1328
81131220:	e0fffc17 	ldw	r3,-16(fp)
81131224:	10c5883a 	add	r2,r2,r3
81131228:	00c01104 	movi	r3,68
8113122c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81131230:	e0bffc17 	ldw	r2,-16(fp)
81131234:	10800044 	addi	r2,r2,1
81131238:	e0bffc15 	stw	r2,-16(fp)
8113123c:	e0fffc17 	ldw	r3,-16(fp)
81131240:	e0bffd17 	ldw	r2,-12(fp)
81131244:	18bfea16 	blt	r3,r2,811311f0 <__reset+0xfb1111f0>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81131248:	016045b4 	movhi	r5,33046
8113124c:	297eb404 	addi	r5,r5,-1328
81131250:	01204574 	movhi	r4,33045
81131254:	2127ad04 	addi	r4,r4,-24908
81131258:	1130e880 	call	81130e88 <alt_log_printf_proc>
8113125c:	00000106 	br	81131264 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81131260:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81131264:	e037883a 	mov	sp,fp
81131268:	dfc00117 	ldw	ra,4(sp)
8113126c:	df000017 	ldw	fp,0(sp)
81131270:	dec00204 	addi	sp,sp,8
81131274:	f800283a 	ret

81131278 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81131278:	defffe04 	addi	sp,sp,-8
8113127c:	de00012e 	bgeu	sp,et,81131284 <alt_log_system_clock+0xc>
81131280:	003b68fa 	trap	3
81131284:	dfc00115 	stw	ra,4(sp)
81131288:	df000015 	stw	fp,0(sp)
8113128c:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81131290:	d0a08643 	ldbu	r2,-32231(gp)
81131294:	10803fcc 	andi	r2,r2,255
81131298:	10000e26 	beq	r2,zero,811312d4 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
8113129c:	d0a08917 	ldw	r2,-32220(gp)
811312a0:	10800044 	addi	r2,r2,1
811312a4:	d0a08915 	stw	r2,-32220(gp)
811312a8:	d0a08d17 	ldw	r2,-32204(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
811312ac:	d0e08917 	ldw	r3,-32220(gp)
811312b0:	10c0082e 	bgeu	r2,r3,811312d4 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
811312b4:	d0208915 	stw	zero,-32220(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
811312b8:	d0a08817 	ldw	r2,-32224(gp)
811312bc:	10c00044 	addi	r3,r2,1
811312c0:	d0e08815 	stw	r3,-32224(gp)
811312c4:	100b883a 	mov	r5,r2
811312c8:	01204574 	movhi	r4,33045
811312cc:	2127b104 	addi	r4,r4,-24892
811312d0:	1130e880 	call	81130e88 <alt_log_printf_proc>
        }
    }
}
811312d4:	0001883a 	nop
811312d8:	e037883a 	mov	sp,fp
811312dc:	dfc00117 	ldw	ra,4(sp)
811312e0:	df000017 	ldw	fp,0(sp)
811312e4:	dec00204 	addi	sp,sp,8
811312e8:	f800283a 	ret

811312ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811312ec:	defffe04 	addi	sp,sp,-8
811312f0:	de00012e 	bgeu	sp,et,811312f8 <alt_get_errno+0xc>
811312f4:	003b68fa 	trap	3
811312f8:	dfc00115 	stw	ra,4(sp)
811312fc:	df000015 	stw	fp,0(sp)
81131300:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131304:	d0a01017 	ldw	r2,-32704(gp)
81131308:	10000326 	beq	r2,zero,81131318 <alt_get_errno+0x2c>
8113130c:	d0a01017 	ldw	r2,-32704(gp)
81131310:	103ee83a 	callr	r2
81131314:	00000106 	br	8113131c <alt_get_errno+0x30>
81131318:	d0a07d04 	addi	r2,gp,-32268
}
8113131c:	e037883a 	mov	sp,fp
81131320:	dfc00117 	ldw	ra,4(sp)
81131324:	df000017 	ldw	fp,0(sp)
81131328:	dec00204 	addi	sp,sp,8
8113132c:	f800283a 	ret

81131330 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
81131330:	defff904 	addi	sp,sp,-28
81131334:	de00012e 	bgeu	sp,et,8113133c <lseek+0xc>
81131338:	003b68fa 	trap	3
8113133c:	dfc00615 	stw	ra,24(sp)
81131340:	df000515 	stw	fp,20(sp)
81131344:	df000504 	addi	fp,sp,20
81131348:	e13ffd15 	stw	r4,-12(fp)
8113134c:	e17ffe15 	stw	r5,-8(fp)
81131350:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81131354:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81131358:	e0bffd17 	ldw	r2,-12(fp)
8113135c:	10000616 	blt	r2,zero,81131378 <lseek+0x48>
81131360:	e0bffd17 	ldw	r2,-12(fp)
81131364:	10c00324 	muli	r3,r2,12
81131368:	00a04574 	movhi	r2,33045
8113136c:	10ab6a04 	addi	r2,r2,-21080
81131370:	1885883a 	add	r2,r3,r2
81131374:	00000106 	br	8113137c <lseek+0x4c>
81131378:	0005883a 	mov	r2,zero
8113137c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81131380:	e0bffc17 	ldw	r2,-16(fp)
81131384:	10001026 	beq	r2,zero,811313c8 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81131388:	e0bffc17 	ldw	r2,-16(fp)
8113138c:	10800017 	ldw	r2,0(r2)
81131390:	10800717 	ldw	r2,28(r2)
81131394:	10000926 	beq	r2,zero,811313bc <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81131398:	e0bffc17 	ldw	r2,-16(fp)
8113139c:	10800017 	ldw	r2,0(r2)
811313a0:	10800717 	ldw	r2,28(r2)
811313a4:	e1bfff17 	ldw	r6,-4(fp)
811313a8:	e17ffe17 	ldw	r5,-8(fp)
811313ac:	e13ffc17 	ldw	r4,-16(fp)
811313b0:	103ee83a 	callr	r2
811313b4:	e0bffb15 	stw	r2,-20(fp)
811313b8:	00000506 	br	811313d0 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
811313bc:	00bfde84 	movi	r2,-134
811313c0:	e0bffb15 	stw	r2,-20(fp)
811313c4:	00000206 	br	811313d0 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
811313c8:	00bfebc4 	movi	r2,-81
811313cc:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
811313d0:	e0bffb17 	ldw	r2,-20(fp)
811313d4:	1000070e 	bge	r2,zero,811313f4 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
811313d8:	11312ec0 	call	811312ec <alt_get_errno>
811313dc:	1007883a 	mov	r3,r2
811313e0:	e0bffb17 	ldw	r2,-20(fp)
811313e4:	0085c83a 	sub	r2,zero,r2
811313e8:	18800015 	stw	r2,0(r3)
    rc = -1;
811313ec:	00bfffc4 	movi	r2,-1
811313f0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811313f4:	e0bffb17 	ldw	r2,-20(fp)
}
811313f8:	e037883a 	mov	sp,fp
811313fc:	dfc00117 	ldw	ra,4(sp)
81131400:	df000017 	ldw	fp,0(sp)
81131404:	dec00204 	addi	sp,sp,8
81131408:	f800283a 	ret

8113140c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
8113140c:	defff904 	addi	sp,sp,-28
81131410:	de00012e 	bgeu	sp,et,81131418 <alt_main+0xc>
81131414:	003b68fa 	trap	3
81131418:	dfc00615 	stw	ra,24(sp)
8113141c:	df000515 	stw	fp,20(sp)
81131420:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81131424:	d0a01217 	ldw	r2,-32696(gp)
81131428:	10800058 	cmpnei	r2,r2,1
8113142c:	1000031e 	bne	r2,zero,8113143c <alt_main+0x30>
81131430:	01204574 	movhi	r4,33045
81131434:	2127b704 	addi	r4,r4,-24868
81131438:	1130e880 	call	81130e88 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
8113143c:	0009883a 	mov	r4,zero
81131440:	113bdb00 	call	8113bdb0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81131444:	d0a01217 	ldw	r2,-32696(gp)
81131448:	10800058 	cmpnei	r2,r2,1
8113144c:	1000031e 	bne	r2,zero,8113145c <alt_main+0x50>
81131450:	01204574 	movhi	r4,33045
81131454:	2127c504 	addi	r4,r4,-24812
81131458:	1130e880 	call	81130e88 <alt_log_printf_proc>
  ALT_OS_INIT();
8113145c:	11329f80 	call	811329f8 <OSInit>
81131460:	01000044 	movi	r4,1
81131464:	11387140 	call	81138714 <OSSemCreate>
81131468:	d0a09015 	stw	r2,-32192(gp)
8113146c:	01000044 	movi	r4,1
81131470:	11387140 	call	81138714 <OSSemCreate>
81131474:	d0a09215 	stw	r2,-32184(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81131478:	d0a01217 	ldw	r2,-32696(gp)
8113147c:	10800058 	cmpnei	r2,r2,1
81131480:	1000031e 	bne	r2,zero,81131490 <alt_main+0x84>
81131484:	01204574 	movhi	r4,33045
81131488:	2127d304 	addi	r4,r4,-24756
8113148c:	1130e880 	call	81130e88 <alt_log_printf_proc>
81131490:	d0a08404 	addi	r2,gp,-32240
81131494:	e0bffc15 	stw	r2,-16(fp)
81131498:	00800044 	movi	r2,1
8113149c:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811314a0:	e0bffd0b 	ldhu	r2,-12(fp)
811314a4:	1009883a 	mov	r4,r2
811314a8:	11387140 	call	81138714 <OSSemCreate>
811314ac:	1007883a 	mov	r3,r2
811314b0:	e0bffc17 	ldw	r2,-16(fp)
811314b4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
811314b8:	d0a01217 	ldw	r2,-32696(gp)
811314bc:	10800058 	cmpnei	r2,r2,1
811314c0:	1000031e 	bne	r2,zero,811314d0 <alt_main+0xc4>
811314c4:	01204574 	movhi	r4,33045
811314c8:	2127e104 	addi	r4,r4,-24700
811314cc:	1130e880 	call	81130e88 <alt_log_printf_proc>
  alt_sys_init();
811314d0:	113bdf00 	call	8113bdf0 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
811314d4:	d0a01217 	ldw	r2,-32696(gp)
811314d8:	10800058 	cmpnei	r2,r2,1
811314dc:	1000031e 	bne	r2,zero,811314ec <alt_main+0xe0>
811314e0:	01204574 	movhi	r4,33045
811314e4:	2127eb04 	addi	r4,r4,-24660
811314e8:	1130e880 	call	81130e88 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811314ec:	d0a01217 	ldw	r2,-32696(gp)
811314f0:	10800058 	cmpnei	r2,r2,1
811314f4:	1000031e 	bne	r2,zero,81131504 <alt_main+0xf8>
811314f8:	01204574 	movhi	r4,33045
811314fc:	2127f404 	addi	r4,r4,-24624
81131500:	1130e880 	call	81130e88 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
81131504:	01a04574 	movhi	r6,33045
81131508:	31a7fc04 	addi	r6,r6,-24592
8113150c:	01604574 	movhi	r5,33045
81131510:	29680104 	addi	r5,r5,-24572
81131514:	01204574 	movhi	r4,33045
81131518:	21280104 	addi	r4,r4,-24572
8113151c:	11446e00 	call	811446e0 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
81131520:	d0a01217 	ldw	r2,-32696(gp)
81131524:	10800058 	cmpnei	r2,r2,1
81131528:	1000031e 	bne	r2,zero,81131538 <alt_main+0x12c>
8113152c:	01204574 	movhi	r4,33045
81131530:	21280504 	addi	r4,r4,-24556
81131534:	1130e880 	call	81130e88 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81131538:	d0a08a17 	ldw	r2,-32216(gp)
8113153c:	d0e08b17 	ldw	r3,-32212(gp)
81131540:	d1208c17 	ldw	r4,-32208(gp)
81131544:	200d883a 	mov	r6,r4
81131548:	180b883a 	mov	r5,r3
8113154c:	1009883a 	mov	r4,r2
81131550:	11133600 	call	81113360 <main>
81131554:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81131558:	01000044 	movi	r4,1
8113155c:	11303380 	call	81130338 <close>
  exit (result);
81131560:	e13ffb17 	ldw	r4,-20(fp)
81131564:	1144e940 	call	81144e94 <exit>

81131568 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131568:	defffe04 	addi	sp,sp,-8
8113156c:	de00012e 	bgeu	sp,et,81131574 <alt_get_errno+0xc>
81131570:	003b68fa 	trap	3
81131574:	dfc00115 	stw	ra,4(sp)
81131578:	df000015 	stw	fp,0(sp)
8113157c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131580:	d0a01017 	ldw	r2,-32704(gp)
81131584:	10000326 	beq	r2,zero,81131594 <alt_get_errno+0x2c>
81131588:	d0a01017 	ldw	r2,-32704(gp)
8113158c:	103ee83a 	callr	r2
81131590:	00000106 	br	81131598 <alt_get_errno+0x30>
81131594:	d0a07d04 	addi	r2,gp,-32268
}
81131598:	e037883a 	mov	sp,fp
8113159c:	dfc00117 	ldw	ra,4(sp)
811315a0:	df000017 	ldw	fp,0(sp)
811315a4:	dec00204 	addi	sp,sp,8
811315a8:	f800283a 	ret

811315ac <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
811315ac:	defffd04 	addi	sp,sp,-12
811315b0:	de00012e 	bgeu	sp,et,811315b8 <alt_file_locked+0xc>
811315b4:	003b68fa 	trap	3
811315b8:	df000215 	stw	fp,8(sp)
811315bc:	df000204 	addi	fp,sp,8
811315c0:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
811315c4:	e0bfff17 	ldw	r2,-4(fp)
811315c8:	10800217 	ldw	r2,8(r2)
811315cc:	10d00034 	orhi	r3,r2,16384
811315d0:	e0bfff17 	ldw	r2,-4(fp)
811315d4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811315d8:	e03ffe15 	stw	zero,-8(fp)
811315dc:	00001d06 	br	81131654 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811315e0:	00a04574 	movhi	r2,33045
811315e4:	10ab6a04 	addi	r2,r2,-21080
811315e8:	e0fffe17 	ldw	r3,-8(fp)
811315ec:	18c00324 	muli	r3,r3,12
811315f0:	10c5883a 	add	r2,r2,r3
811315f4:	10c00017 	ldw	r3,0(r2)
811315f8:	e0bfff17 	ldw	r2,-4(fp)
811315fc:	10800017 	ldw	r2,0(r2)
81131600:	1880111e 	bne	r3,r2,81131648 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81131604:	00a04574 	movhi	r2,33045
81131608:	10ab6a04 	addi	r2,r2,-21080
8113160c:	e0fffe17 	ldw	r3,-8(fp)
81131610:	18c00324 	muli	r3,r3,12
81131614:	10c5883a 	add	r2,r2,r3
81131618:	10800204 	addi	r2,r2,8
8113161c:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81131620:	1000090e 	bge	r2,zero,81131648 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81131624:	e0bffe17 	ldw	r2,-8(fp)
81131628:	10c00324 	muli	r3,r2,12
8113162c:	00a04574 	movhi	r2,33045
81131630:	10ab6a04 	addi	r2,r2,-21080
81131634:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81131638:	e0bfff17 	ldw	r2,-4(fp)
8113163c:	18800226 	beq	r3,r2,81131648 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81131640:	00bffcc4 	movi	r2,-13
81131644:	00000806 	br	81131668 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81131648:	e0bffe17 	ldw	r2,-8(fp)
8113164c:	10800044 	addi	r2,r2,1
81131650:	e0bffe15 	stw	r2,-8(fp)
81131654:	d0a00f17 	ldw	r2,-32708(gp)
81131658:	1007883a 	mov	r3,r2
8113165c:	e0bffe17 	ldw	r2,-8(fp)
81131660:	18bfdf2e 	bgeu	r3,r2,811315e0 <__reset+0xfb1115e0>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81131664:	0005883a 	mov	r2,zero
}
81131668:	e037883a 	mov	sp,fp
8113166c:	df000017 	ldw	fp,0(sp)
81131670:	dec00104 	addi	sp,sp,4
81131674:	f800283a 	ret

81131678 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81131678:	defff604 	addi	sp,sp,-40
8113167c:	de00012e 	bgeu	sp,et,81131684 <open+0xc>
81131680:	003b68fa 	trap	3
81131684:	dfc00915 	stw	ra,36(sp)
81131688:	df000815 	stw	fp,32(sp)
8113168c:	df000804 	addi	fp,sp,32
81131690:	e13ffd15 	stw	r4,-12(fp)
81131694:	e17ffe15 	stw	r5,-8(fp)
81131698:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
8113169c:	00bfffc4 	movi	r2,-1
811316a0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
811316a4:	00bffb44 	movi	r2,-19
811316a8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
811316ac:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
811316b0:	d1600d04 	addi	r5,gp,-32716
811316b4:	e13ffd17 	ldw	r4,-12(fp)
811316b8:	11440c00 	call	811440c0 <alt_find_dev>
811316bc:	e0bff815 	stw	r2,-32(fp)
811316c0:	e0bff817 	ldw	r2,-32(fp)
811316c4:	1000051e 	bne	r2,zero,811316dc <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
811316c8:	e13ffd17 	ldw	r4,-12(fp)
811316cc:	11441580 	call	81144158 <alt_find_file>
811316d0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
811316d4:	00800044 	movi	r2,1
811316d8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
811316dc:	e0bff817 	ldw	r2,-32(fp)
811316e0:	10002926 	beq	r2,zero,81131788 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
811316e4:	e13ff817 	ldw	r4,-32(fp)
811316e8:	11442680 	call	81144268 <alt_get_fd>
811316ec:	e0bff915 	stw	r2,-28(fp)
811316f0:	e0bff917 	ldw	r2,-28(fp)
811316f4:	1000030e 	bge	r2,zero,81131704 <open+0x8c>
    {
      status = index;
811316f8:	e0bff917 	ldw	r2,-28(fp)
811316fc:	e0bffa15 	stw	r2,-24(fp)
81131700:	00002306 	br	81131790 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
81131704:	e0bff917 	ldw	r2,-28(fp)
81131708:	10c00324 	muli	r3,r2,12
8113170c:	00a04574 	movhi	r2,33045
81131710:	10ab6a04 	addi	r2,r2,-21080
81131714:	1885883a 	add	r2,r3,r2
81131718:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
8113171c:	e0fffe17 	ldw	r3,-8(fp)
81131720:	00900034 	movhi	r2,16384
81131724:	10bfffc4 	addi	r2,r2,-1
81131728:	1886703a 	and	r3,r3,r2
8113172c:	e0bffc17 	ldw	r2,-16(fp)
81131730:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81131734:	e0bffb17 	ldw	r2,-20(fp)
81131738:	1000051e 	bne	r2,zero,81131750 <open+0xd8>
8113173c:	e13ffc17 	ldw	r4,-16(fp)
81131740:	11315ac0 	call	811315ac <alt_file_locked>
81131744:	e0bffa15 	stw	r2,-24(fp)
81131748:	e0bffa17 	ldw	r2,-24(fp)
8113174c:	10001016 	blt	r2,zero,81131790 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81131750:	e0bff817 	ldw	r2,-32(fp)
81131754:	10800317 	ldw	r2,12(r2)
81131758:	10000826 	beq	r2,zero,8113177c <open+0x104>
8113175c:	e0bff817 	ldw	r2,-32(fp)
81131760:	10800317 	ldw	r2,12(r2)
81131764:	e1ffff17 	ldw	r7,-4(fp)
81131768:	e1bffe17 	ldw	r6,-8(fp)
8113176c:	e17ffd17 	ldw	r5,-12(fp)
81131770:	e13ffc17 	ldw	r4,-16(fp)
81131774:	103ee83a 	callr	r2
81131778:	00000106 	br	81131780 <open+0x108>
8113177c:	0005883a 	mov	r2,zero
81131780:	e0bffa15 	stw	r2,-24(fp)
81131784:	00000206 	br	81131790 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81131788:	00bffb44 	movi	r2,-19
8113178c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81131790:	e0bffa17 	ldw	r2,-24(fp)
81131794:	1000090e 	bge	r2,zero,811317bc <open+0x144>
  {
    alt_release_fd (index);  
81131798:	e13ff917 	ldw	r4,-28(fp)
8113179c:	113191c0 	call	8113191c <alt_release_fd>
    ALT_ERRNO = -status;
811317a0:	11315680 	call	81131568 <alt_get_errno>
811317a4:	1007883a 	mov	r3,r2
811317a8:	e0bffa17 	ldw	r2,-24(fp)
811317ac:	0085c83a 	sub	r2,zero,r2
811317b0:	18800015 	stw	r2,0(r3)
    return -1;
811317b4:	00bfffc4 	movi	r2,-1
811317b8:	00000106 	br	811317c0 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
811317bc:	e0bff917 	ldw	r2,-28(fp)
}
811317c0:	e037883a 	mov	sp,fp
811317c4:	dfc00117 	ldw	ra,4(sp)
811317c8:	df000017 	ldw	fp,0(sp)
811317cc:	dec00204 	addi	sp,sp,8
811317d0:	f800283a 	ret

811317d4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811317d4:	defffe04 	addi	sp,sp,-8
811317d8:	de00012e 	bgeu	sp,et,811317e0 <alt_get_errno+0xc>
811317dc:	003b68fa 	trap	3
811317e0:	dfc00115 	stw	ra,4(sp)
811317e4:	df000015 	stw	fp,0(sp)
811317e8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811317ec:	d0a01017 	ldw	r2,-32704(gp)
811317f0:	10000326 	beq	r2,zero,81131800 <alt_get_errno+0x2c>
811317f4:	d0a01017 	ldw	r2,-32704(gp)
811317f8:	103ee83a 	callr	r2
811317fc:	00000106 	br	81131804 <alt_get_errno+0x30>
81131800:	d0a07d04 	addi	r2,gp,-32268
}
81131804:	e037883a 	mov	sp,fp
81131808:	dfc00117 	ldw	ra,4(sp)
8113180c:	df000017 	ldw	fp,0(sp)
81131810:	dec00204 	addi	sp,sp,8
81131814:	f800283a 	ret

81131818 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81131818:	defff904 	addi	sp,sp,-28
8113181c:	de00012e 	bgeu	sp,et,81131824 <read+0xc>
81131820:	003b68fa 	trap	3
81131824:	dfc00615 	stw	ra,24(sp)
81131828:	df000515 	stw	fp,20(sp)
8113182c:	df000504 	addi	fp,sp,20
81131830:	e13ffd15 	stw	r4,-12(fp)
81131834:	e17ffe15 	stw	r5,-8(fp)
81131838:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113183c:	e0bffd17 	ldw	r2,-12(fp)
81131840:	10000616 	blt	r2,zero,8113185c <read+0x44>
81131844:	e0bffd17 	ldw	r2,-12(fp)
81131848:	10c00324 	muli	r3,r2,12
8113184c:	00a04574 	movhi	r2,33045
81131850:	10ab6a04 	addi	r2,r2,-21080
81131854:	1885883a 	add	r2,r3,r2
81131858:	00000106 	br	81131860 <read+0x48>
8113185c:	0005883a 	mov	r2,zero
81131860:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81131864:	e0bffb17 	ldw	r2,-20(fp)
81131868:	10002226 	beq	r2,zero,811318f4 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8113186c:	e0bffb17 	ldw	r2,-20(fp)
81131870:	10800217 	ldw	r2,8(r2)
81131874:	108000cc 	andi	r2,r2,3
81131878:	10800060 	cmpeqi	r2,r2,1
8113187c:	1000181e 	bne	r2,zero,811318e0 <read+0xc8>
        (fd->dev->read))
81131880:	e0bffb17 	ldw	r2,-20(fp)
81131884:	10800017 	ldw	r2,0(r2)
81131888:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
8113188c:	10001426 	beq	r2,zero,811318e0 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81131890:	e0bffb17 	ldw	r2,-20(fp)
81131894:	10800017 	ldw	r2,0(r2)
81131898:	10800517 	ldw	r2,20(r2)
8113189c:	e0ffff17 	ldw	r3,-4(fp)
811318a0:	180d883a 	mov	r6,r3
811318a4:	e17ffe17 	ldw	r5,-8(fp)
811318a8:	e13ffb17 	ldw	r4,-20(fp)
811318ac:	103ee83a 	callr	r2
811318b0:	e0bffc15 	stw	r2,-16(fp)
811318b4:	e0bffc17 	ldw	r2,-16(fp)
811318b8:	1000070e 	bge	r2,zero,811318d8 <read+0xc0>
        {
          ALT_ERRNO = -rval;
811318bc:	11317d40 	call	811317d4 <alt_get_errno>
811318c0:	1007883a 	mov	r3,r2
811318c4:	e0bffc17 	ldw	r2,-16(fp)
811318c8:	0085c83a 	sub	r2,zero,r2
811318cc:	18800015 	stw	r2,0(r3)
          return -1;
811318d0:	00bfffc4 	movi	r2,-1
811318d4:	00000c06 	br	81131908 <read+0xf0>
        }
        return rval;
811318d8:	e0bffc17 	ldw	r2,-16(fp)
811318dc:	00000a06 	br	81131908 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
811318e0:	11317d40 	call	811317d4 <alt_get_errno>
811318e4:	1007883a 	mov	r3,r2
811318e8:	00800344 	movi	r2,13
811318ec:	18800015 	stw	r2,0(r3)
811318f0:	00000406 	br	81131904 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811318f4:	11317d40 	call	811317d4 <alt_get_errno>
811318f8:	1007883a 	mov	r3,r2
811318fc:	00801444 	movi	r2,81
81131900:	18800015 	stw	r2,0(r3)
  }
  return -1;
81131904:	00bfffc4 	movi	r2,-1
}
81131908:	e037883a 	mov	sp,fp
8113190c:	dfc00117 	ldw	ra,4(sp)
81131910:	df000017 	ldw	fp,0(sp)
81131914:	dec00204 	addi	sp,sp,8
81131918:	f800283a 	ret

8113191c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
8113191c:	defffe04 	addi	sp,sp,-8
81131920:	de00012e 	bgeu	sp,et,81131928 <alt_release_fd+0xc>
81131924:	003b68fa 	trap	3
81131928:	df000115 	stw	fp,4(sp)
8113192c:	df000104 	addi	fp,sp,4
81131930:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81131934:	e0bfff17 	ldw	r2,-4(fp)
81131938:	108000d0 	cmplti	r2,r2,3
8113193c:	10000d1e 	bne	r2,zero,81131974 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81131940:	00a04574 	movhi	r2,33045
81131944:	10ab6a04 	addi	r2,r2,-21080
81131948:	e0ffff17 	ldw	r3,-4(fp)
8113194c:	18c00324 	muli	r3,r3,12
81131950:	10c5883a 	add	r2,r2,r3
81131954:	10800204 	addi	r2,r2,8
81131958:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
8113195c:	00a04574 	movhi	r2,33045
81131960:	10ab6a04 	addi	r2,r2,-21080
81131964:	e0ffff17 	ldw	r3,-4(fp)
81131968:	18c00324 	muli	r3,r3,12
8113196c:	10c5883a 	add	r2,r2,r3
81131970:	10000015 	stw	zero,0(r2)
  }
}
81131974:	0001883a 	nop
81131978:	e037883a 	mov	sp,fp
8113197c:	df000017 	ldw	fp,0(sp)
81131980:	dec00104 	addi	sp,sp,4
81131984:	f800283a 	ret

81131988 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81131988:	defff604 	addi	sp,sp,-40
8113198c:	de00012e 	bgeu	sp,et,81131994 <sbrk+0xc>
81131990:	003b68fa 	trap	3
81131994:	df000915 	stw	fp,36(sp)
81131998:	df000904 	addi	fp,sp,36
8113199c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811319a0:	0005303a 	rdctl	r2,status
811319a4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811319a8:	e0fffe17 	ldw	r3,-8(fp)
811319ac:	00bfff84 	movi	r2,-2
811319b0:	1884703a 	and	r2,r3,r2
811319b4:	1001703a 	wrctl	status,r2
  
  return context;
811319b8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
811319bc:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
811319c0:	d0a01317 	ldw	r2,-32692(gp)
811319c4:	10c000c4 	addi	r3,r2,3
811319c8:	00bfff04 	movi	r2,-4
811319cc:	1884703a 	and	r2,r3,r2
811319d0:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
811319d4:	d0e01317 	ldw	r3,-32692(gp)
811319d8:	e0bfff17 	ldw	r2,-4(fp)
811319dc:	1887883a 	add	r3,r3,r2
811319e0:	00a04834 	movhi	r2,33056
811319e4:	10a80004 	addi	r2,r2,-24576
811319e8:	10c0062e 	bgeu	r2,r3,81131a04 <sbrk+0x7c>
811319ec:	e0bff817 	ldw	r2,-32(fp)
811319f0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811319f4:	e0bff717 	ldw	r2,-36(fp)
811319f8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
811319fc:	00bfffc4 	movi	r2,-1
81131a00:	00001c06 	br	81131a74 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81131a04:	d0a01317 	ldw	r2,-32692(gp)
81131a08:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81131a0c:	d0e01317 	ldw	r3,-32692(gp)
81131a10:	e0bfff17 	ldw	r2,-4(fp)
81131a14:	1885883a 	add	r2,r3,r2
81131a18:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81131a1c:	c005883a 	mov	r2,et
81131a20:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81131a24:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81131a28:	e0bffa17 	ldw	r2,-24(fp)
81131a2c:	18800c1e 	bne	r3,r2,81131a60 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81131a30:	d805883a 	mov	r2,sp
81131a34:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81131a38:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81131a3c:	d0e01317 	ldw	r3,-32692(gp)
81131a40:	18800136 	bltu	r3,r2,81131a48 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81131a44:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81131a48:	d0a01317 	ldw	r2,-32692(gp)
81131a4c:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81131a50:	e0bffc17 	ldw	r2,-16(fp)
81131a54:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81131a58:	e0bffc17 	ldw	r2,-16(fp)
81131a5c:	1031883a 	mov	et,r2
81131a60:	e0bff817 	ldw	r2,-32(fp)
81131a64:	e0bffd15 	stw	r2,-12(fp)
81131a68:	e0bffd17 	ldw	r2,-12(fp)
81131a6c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81131a70:	e0bffa17 	ldw	r2,-24(fp)
} 
81131a74:	e037883a 	mov	sp,fp
81131a78:	df000017 	ldw	fp,0(sp)
81131a7c:	dec00104 	addi	sp,sp,4
81131a80:	f800283a 	ret

81131a84 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81131a84:	defffa04 	addi	sp,sp,-24
81131a88:	de00012e 	bgeu	sp,et,81131a90 <alt_alarm_stop+0xc>
81131a8c:	003b68fa 	trap	3
81131a90:	df000515 	stw	fp,20(sp)
81131a94:	df000504 	addi	fp,sp,20
81131a98:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131a9c:	0005303a 	rdctl	r2,status
81131aa0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131aa4:	e0fffc17 	ldw	r3,-16(fp)
81131aa8:	00bfff84 	movi	r2,-2
81131aac:	1884703a 	and	r2,r3,r2
81131ab0:	1001703a 	wrctl	status,r2
  
  return context;
81131ab4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81131ab8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81131abc:	e0bfff17 	ldw	r2,-4(fp)
81131ac0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81131ac4:	e0bffd17 	ldw	r2,-12(fp)
81131ac8:	10800017 	ldw	r2,0(r2)
81131acc:	e0fffd17 	ldw	r3,-12(fp)
81131ad0:	18c00117 	ldw	r3,4(r3)
81131ad4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81131ad8:	e0bffd17 	ldw	r2,-12(fp)
81131adc:	10800117 	ldw	r2,4(r2)
81131ae0:	e0fffd17 	ldw	r3,-12(fp)
81131ae4:	18c00017 	ldw	r3,0(r3)
81131ae8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81131aec:	e0bffd17 	ldw	r2,-12(fp)
81131af0:	e0fffd17 	ldw	r3,-12(fp)
81131af4:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81131af8:	e0bffd17 	ldw	r2,-12(fp)
81131afc:	e0fffd17 	ldw	r3,-12(fp)
81131b00:	10c00015 	stw	r3,0(r2)
81131b04:	e0bffb17 	ldw	r2,-20(fp)
81131b08:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131b0c:	e0bffe17 	ldw	r2,-8(fp)
81131b10:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81131b14:	0001883a 	nop
81131b18:	e037883a 	mov	sp,fp
81131b1c:	df000017 	ldw	fp,0(sp)
81131b20:	dec00104 	addi	sp,sp,4
81131b24:	f800283a 	ret

81131b28 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81131b28:	defffb04 	addi	sp,sp,-20
81131b2c:	de00012e 	bgeu	sp,et,81131b34 <alt_tick+0xc>
81131b30:	003b68fa 	trap	3
81131b34:	dfc00415 	stw	ra,16(sp)
81131b38:	df000315 	stw	fp,12(sp)
81131b3c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81131b40:	d0a01417 	ldw	r2,-32688(gp)
81131b44:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81131b48:	d0a08e17 	ldw	r2,-32200(gp)
81131b4c:	10800044 	addi	r2,r2,1
81131b50:	d0a08e15 	stw	r2,-32200(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81131b54:	00002e06 	br	81131c10 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81131b58:	e0bffd17 	ldw	r2,-12(fp)
81131b5c:	10800017 	ldw	r2,0(r2)
81131b60:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81131b64:	e0bffd17 	ldw	r2,-12(fp)
81131b68:	10800403 	ldbu	r2,16(r2)
81131b6c:	10803fcc 	andi	r2,r2,255
81131b70:	10000426 	beq	r2,zero,81131b84 <alt_tick+0x5c>
81131b74:	d0a08e17 	ldw	r2,-32200(gp)
81131b78:	1000021e 	bne	r2,zero,81131b84 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81131b7c:	e0bffd17 	ldw	r2,-12(fp)
81131b80:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81131b84:	e0bffd17 	ldw	r2,-12(fp)
81131b88:	10800217 	ldw	r2,8(r2)
81131b8c:	d0e08e17 	ldw	r3,-32200(gp)
81131b90:	18801d36 	bltu	r3,r2,81131c08 <alt_tick+0xe0>
81131b94:	e0bffd17 	ldw	r2,-12(fp)
81131b98:	10800403 	ldbu	r2,16(r2)
81131b9c:	10803fcc 	andi	r2,r2,255
81131ba0:	1000191e 	bne	r2,zero,81131c08 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81131ba4:	e0bffd17 	ldw	r2,-12(fp)
81131ba8:	10800317 	ldw	r2,12(r2)
81131bac:	e0fffd17 	ldw	r3,-12(fp)
81131bb0:	18c00517 	ldw	r3,20(r3)
81131bb4:	1809883a 	mov	r4,r3
81131bb8:	103ee83a 	callr	r2
81131bbc:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81131bc0:	e0bfff17 	ldw	r2,-4(fp)
81131bc4:	1000031e 	bne	r2,zero,81131bd4 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81131bc8:	e13ffd17 	ldw	r4,-12(fp)
81131bcc:	1131a840 	call	81131a84 <alt_alarm_stop>
81131bd0:	00000d06 	br	81131c08 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81131bd4:	e0bffd17 	ldw	r2,-12(fp)
81131bd8:	10c00217 	ldw	r3,8(r2)
81131bdc:	e0bfff17 	ldw	r2,-4(fp)
81131be0:	1887883a 	add	r3,r3,r2
81131be4:	e0bffd17 	ldw	r2,-12(fp)
81131be8:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81131bec:	e0bffd17 	ldw	r2,-12(fp)
81131bf0:	10c00217 	ldw	r3,8(r2)
81131bf4:	d0a08e17 	ldw	r2,-32200(gp)
81131bf8:	1880032e 	bgeu	r3,r2,81131c08 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81131bfc:	e0bffd17 	ldw	r2,-12(fp)
81131c00:	00c00044 	movi	r3,1
81131c04:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81131c08:	e0bffe17 	ldw	r2,-8(fp)
81131c0c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81131c10:	e0fffd17 	ldw	r3,-12(fp)
81131c14:	d0a01404 	addi	r2,gp,-32688
81131c18:	18bfcf1e 	bne	r3,r2,81131b58 <__reset+0xfb111b58>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81131c1c:	1132e580 	call	81132e58 <OSTimeTick>
}
81131c20:	0001883a 	nop
81131c24:	e037883a 	mov	sp,fp
81131c28:	dfc00117 	ldw	ra,4(sp)
81131c2c:	df000017 	ldw	fp,0(sp)
81131c30:	dec00204 	addi	sp,sp,8
81131c34:	f800283a 	ret

81131c38 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81131c38:	defffb04 	addi	sp,sp,-20
81131c3c:	de00012e 	bgeu	sp,et,81131c44 <usleep+0xc>
81131c40:	003b68fa 	trap	3
81131c44:	dfc00415 	stw	ra,16(sp)
81131c48:	df000315 	stw	fp,12(sp)
81131c4c:	df000304 	addi	fp,sp,12
81131c50:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81131c54:	d0a09603 	ldbu	r2,-32168(gp)
81131c58:	10803fcc 	andi	r2,r2,255
81131c5c:	1000031e 	bne	r2,zero,81131c6c <usleep+0x34>
  {
    return alt_busy_sleep (us);
81131c60:	e13fff17 	ldw	r4,-4(fp)
81131c64:	11301c40 	call	811301c4 <alt_busy_sleep>
81131c68:	00003d06 	br	81131d60 <usleep+0x128>
81131c6c:	d0a08d17 	ldw	r2,-32204(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81131c70:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81131c74:	e0ffff17 	ldw	r3,-4(fp)
81131c78:	0090c734 	movhi	r2,17180
81131c7c:	10b7a0c4 	addi	r2,r2,-8573
81131c80:	1888383a 	mulxuu	r4,r3,r2
81131c84:	1885383a 	mul	r2,r3,r2
81131c88:	1013883a 	mov	r9,r2
81131c8c:	2015883a 	mov	r10,r4
81131c90:	5006d4ba 	srli	r3,r10,18
81131c94:	e0bffe17 	ldw	r2,-8(fp)
81131c98:	1893383a 	mul	r9,r3,r2
81131c9c:	e0ffff17 	ldw	r3,-4(fp)
81131ca0:	0090c734 	movhi	r2,17180
81131ca4:	10b7a0c4 	addi	r2,r2,-8573
81131ca8:	1888383a 	mulxuu	r4,r3,r2
81131cac:	1885383a 	mul	r2,r3,r2
81131cb0:	100f883a 	mov	r7,r2
81131cb4:	2011883a 	mov	r8,r4
81131cb8:	4004d4ba 	srli	r2,r8,18
81131cbc:	010003f4 	movhi	r4,15
81131cc0:	21109004 	addi	r4,r4,16960
81131cc4:	1105383a 	mul	r2,r2,r4
81131cc8:	1885c83a 	sub	r2,r3,r2
81131ccc:	e0fffe17 	ldw	r3,-8(fp)
81131cd0:	10c7383a 	mul	r3,r2,r3
81131cd4:	0090c734 	movhi	r2,17180
81131cd8:	10b7a0c4 	addi	r2,r2,-8573
81131cdc:	1888383a 	mulxuu	r4,r3,r2
81131ce0:	1885383a 	mul	r2,r3,r2
81131ce4:	100b883a 	mov	r5,r2
81131ce8:	200d883a 	mov	r6,r4
81131cec:	3004d4ba 	srli	r2,r6,18
81131cf0:	4885883a 	add	r2,r9,r2
81131cf4:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81131cf8:	00000706 	br	81131d18 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81131cfc:	013fffd4 	movui	r4,65535
81131d00:	113a7140 	call	8113a714 <OSTimeDly>
    ticks -= 0xffff;
81131d04:	e0fffd17 	ldw	r3,-12(fp)
81131d08:	00bffff4 	movhi	r2,65535
81131d0c:	10800044 	addi	r2,r2,1
81131d10:	1885883a 	add	r2,r3,r2
81131d14:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81131d18:	e0bffd17 	ldw	r2,-12(fp)
81131d1c:	00ffffd4 	movui	r3,65535
81131d20:	18bff636 	bltu	r3,r2,81131cfc <__reset+0xfb111cfc>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81131d24:	e0bffd17 	ldw	r2,-12(fp)
81131d28:	10bfffcc 	andi	r2,r2,65535
81131d2c:	1009883a 	mov	r4,r2
81131d30:	113a7140 	call	8113a714 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81131d34:	008003f4 	movhi	r2,15
81131d38:	10909004 	addi	r2,r2,16960
81131d3c:	e0fffe17 	ldw	r3,-8(fp)
81131d40:	10c7203a 	divu	r3,r2,r3
81131d44:	e0bfff17 	ldw	r2,-4(fp)
81131d48:	10c9203a 	divu	r4,r2,r3
81131d4c:	20c7383a 	mul	r3,r4,r3
81131d50:	10c5c83a 	sub	r2,r2,r3
81131d54:	1009883a 	mov	r4,r2
81131d58:	11301c40 	call	811301c4 <alt_busy_sleep>

  return 0;  
81131d5c:	0005883a 	mov	r2,zero
}
81131d60:	e037883a 	mov	sp,fp
81131d64:	dfc00117 	ldw	ra,4(sp)
81131d68:	df000017 	ldw	fp,0(sp)
81131d6c:	dec00204 	addi	sp,sp,8
81131d70:	f800283a 	ret

81131d74 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81131d74:	defffe04 	addi	sp,sp,-8
81131d78:	de00012e 	bgeu	sp,et,81131d80 <alt_get_errno+0xc>
81131d7c:	003b68fa 	trap	3
81131d80:	dfc00115 	stw	ra,4(sp)
81131d84:	df000015 	stw	fp,0(sp)
81131d88:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81131d8c:	d0a01017 	ldw	r2,-32704(gp)
81131d90:	10000326 	beq	r2,zero,81131da0 <alt_get_errno+0x2c>
81131d94:	d0a01017 	ldw	r2,-32704(gp)
81131d98:	103ee83a 	callr	r2
81131d9c:	00000106 	br	81131da4 <alt_get_errno+0x30>
81131da0:	d0a07d04 	addi	r2,gp,-32268
}
81131da4:	e037883a 	mov	sp,fp
81131da8:	dfc00117 	ldw	ra,4(sp)
81131dac:	df000017 	ldw	fp,0(sp)
81131db0:	dec00204 	addi	sp,sp,8
81131db4:	f800283a 	ret

81131db8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81131db8:	defff904 	addi	sp,sp,-28
81131dbc:	de00012e 	bgeu	sp,et,81131dc4 <write+0xc>
81131dc0:	003b68fa 	trap	3
81131dc4:	dfc00615 	stw	ra,24(sp)
81131dc8:	df000515 	stw	fp,20(sp)
81131dcc:	df000504 	addi	fp,sp,20
81131dd0:	e13ffd15 	stw	r4,-12(fp)
81131dd4:	e17ffe15 	stw	r5,-8(fp)
81131dd8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81131ddc:	e0bffd17 	ldw	r2,-12(fp)
81131de0:	10000616 	blt	r2,zero,81131dfc <write+0x44>
81131de4:	e0bffd17 	ldw	r2,-12(fp)
81131de8:	10c00324 	muli	r3,r2,12
81131dec:	00a04574 	movhi	r2,33045
81131df0:	10ab6a04 	addi	r2,r2,-21080
81131df4:	1885883a 	add	r2,r3,r2
81131df8:	00000106 	br	81131e00 <write+0x48>
81131dfc:	0005883a 	mov	r2,zero
81131e00:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81131e04:	e0bffb17 	ldw	r2,-20(fp)
81131e08:	10002426 	beq	r2,zero,81131e9c <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81131e0c:	e0bffb17 	ldw	r2,-20(fp)
81131e10:	10800217 	ldw	r2,8(r2)
81131e14:	108000cc 	andi	r2,r2,3
81131e18:	10001b26 	beq	r2,zero,81131e88 <write+0xd0>
81131e1c:	e0bffb17 	ldw	r2,-20(fp)
81131e20:	10800017 	ldw	r2,0(r2)
81131e24:	10800617 	ldw	r2,24(r2)
81131e28:	10001726 	beq	r2,zero,81131e88 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81131e2c:	e17fff17 	ldw	r5,-4(fp)
81131e30:	e13ffe17 	ldw	r4,-8(fp)
81131e34:	11311380 	call	81131138 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81131e38:	e0bffb17 	ldw	r2,-20(fp)
81131e3c:	10800017 	ldw	r2,0(r2)
81131e40:	10800617 	ldw	r2,24(r2)
81131e44:	e0ffff17 	ldw	r3,-4(fp)
81131e48:	180d883a 	mov	r6,r3
81131e4c:	e17ffe17 	ldw	r5,-8(fp)
81131e50:	e13ffb17 	ldw	r4,-20(fp)
81131e54:	103ee83a 	callr	r2
81131e58:	e0bffc15 	stw	r2,-16(fp)
81131e5c:	e0bffc17 	ldw	r2,-16(fp)
81131e60:	1000070e 	bge	r2,zero,81131e80 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81131e64:	1131d740 	call	81131d74 <alt_get_errno>
81131e68:	1007883a 	mov	r3,r2
81131e6c:	e0bffc17 	ldw	r2,-16(fp)
81131e70:	0085c83a 	sub	r2,zero,r2
81131e74:	18800015 	stw	r2,0(r3)
        return -1;
81131e78:	00bfffc4 	movi	r2,-1
81131e7c:	00000c06 	br	81131eb0 <write+0xf8>
      }
      return rval;
81131e80:	e0bffc17 	ldw	r2,-16(fp)
81131e84:	00000a06 	br	81131eb0 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81131e88:	1131d740 	call	81131d74 <alt_get_errno>
81131e8c:	1007883a 	mov	r3,r2
81131e90:	00800344 	movi	r2,13
81131e94:	18800015 	stw	r2,0(r3)
81131e98:	00000406 	br	81131eac <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81131e9c:	1131d740 	call	81131d74 <alt_get_errno>
81131ea0:	1007883a 	mov	r3,r2
81131ea4:	00801444 	movi	r2,81
81131ea8:	18800015 	stw	r2,0(r3)
  }
  return -1;
81131eac:	00bfffc4 	movi	r2,-1
}
81131eb0:	e037883a 	mov	sp,fp
81131eb4:	dfc00117 	ldw	ra,4(sp)
81131eb8:	df000017 	ldw	fp,0(sp)
81131ebc:	dec00204 	addi	sp,sp,8
81131ec0:	f800283a 	ret

81131ec4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81131ec4:	deffde04 	addi	sp,sp,-136
81131ec8:	de00012e 	bgeu	sp,et,81131ed0 <__env_lock+0xc>
81131ecc:	003b68fa 	trap	3
81131ed0:	dfc02115 	stw	ra,132(sp)
81131ed4:	df002015 	stw	fp,128(sp)
81131ed8:	df002004 	addi	fp,sp,128
81131edc:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81131ee0:	e0bfe104 	addi	r2,fp,-124
81131ee4:	100b883a 	mov	r5,r2
81131ee8:	01003fc4 	movi	r4,255
81131eec:	113a5700 	call	8113a570 <OSTaskQuery>
81131ef0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81131ef4:	e0bffe83 	ldbu	r2,-6(fp)
81131ef8:	10803fcc 	andi	r2,r2,255
81131efc:	10001e1e 	bne	r2,zero,81131f78 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81131f00:	e0bfed83 	ldbu	r2,-74(fp)
81131f04:	10803fcc 	andi	r2,r2,255
81131f08:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81131f0c:	d0a09017 	ldw	r2,-32192(gp)
81131f10:	e0fffc04 	addi	r3,fp,-16
81131f14:	180b883a 	mov	r5,r3
81131f18:	1009883a 	mov	r4,r2
81131f1c:	1138edc0 	call	81138edc <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81131f20:	e0bffe03 	ldbu	r2,-8(fp)
81131f24:	10803fcc 	andi	r2,r2,255
81131f28:	10000726 	beq	r2,zero,81131f48 <__env_lock+0x84>
81131f2c:	d0a01617 	ldw	r2,-32680(gp)
81131f30:	e0ffe017 	ldw	r3,-128(fp)
81131f34:	1880041e 	bne	r3,r2,81131f48 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81131f38:	d0a08f17 	ldw	r2,-32196(gp)
81131f3c:	10800044 	addi	r2,r2,1
81131f40:	d0a08f15 	stw	r2,-32196(gp)
81131f44:	00000a06 	br	81131f70 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81131f48:	d0a09017 	ldw	r2,-32192(gp)
81131f4c:	e0fffe84 	addi	r3,fp,-6
81131f50:	180d883a 	mov	r6,r3
81131f54:	000b883a 	mov	r5,zero
81131f58:	1009883a 	mov	r4,r2
81131f5c:	1138a3c0 	call	81138a3c <OSSemPend>
    locks  = 1;
81131f60:	00800044 	movi	r2,1
81131f64:	d0a08f15 	stw	r2,-32196(gp)
    lockid = id;
81131f68:	e0bfe017 	ldw	r2,-128(fp)
81131f6c:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81131f70:	0001883a 	nop
81131f74:	00000106 	br	81131f7c <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81131f78:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81131f7c:	e037883a 	mov	sp,fp
81131f80:	dfc00117 	ldw	ra,4(sp)
81131f84:	df000017 	ldw	fp,0(sp)
81131f88:	dec00204 	addi	sp,sp,8
81131f8c:	f800283a 	ret

81131f90 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81131f90:	defffd04 	addi	sp,sp,-12
81131f94:	de00012e 	bgeu	sp,et,81131f9c <__env_unlock+0xc>
81131f98:	003b68fa 	trap	3
81131f9c:	dfc00215 	stw	ra,8(sp)
81131fa0:	df000115 	stw	fp,4(sp)
81131fa4:	df000104 	addi	fp,sp,4
81131fa8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81131fac:	d0a08f17 	ldw	r2,-32196(gp)
81131fb0:	10000b26 	beq	r2,zero,81131fe0 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81131fb4:	d0a08f17 	ldw	r2,-32196(gp)
81131fb8:	10bfffc4 	addi	r2,r2,-1
81131fbc:	d0a08f15 	stw	r2,-32196(gp)
81131fc0:	d0a08f17 	ldw	r2,-32196(gp)
81131fc4:	1000071e 	bne	r2,zero,81131fe4 <__env_unlock+0x54>
  {
    lockid = -1;
81131fc8:	00bfffc4 	movi	r2,-1
81131fcc:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81131fd0:	d0a09017 	ldw	r2,-32192(gp)
81131fd4:	1009883a 	mov	r4,r2
81131fd8:	1138dc40 	call	81138dc4 <OSSemPost>
81131fdc:	00000106 	br	81131fe4 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81131fe0:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81131fe4:	e037883a 	mov	sp,fp
81131fe8:	dfc00117 	ldw	ra,4(sp)
81131fec:	df000017 	ldw	fp,0(sp)
81131ff0:	dec00204 	addi	sp,sp,8
81131ff4:	f800283a 	ret

81131ff8 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81131ff8:	deffda04 	addi	sp,sp,-152
81131ffc:	de00012e 	bgeu	sp,et,81132004 <__malloc_lock+0xc>
81132000:	003b68fa 	trap	3
81132004:	dfc02515 	stw	ra,148(sp)
81132008:	df002415 	stw	fp,144(sp)
8113200c:	df002404 	addi	fp,sp,144
81132010:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132014:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81132018:	d0a09603 	ldbu	r2,-32168(gp)
8113201c:	10803fcc 	andi	r2,r2,255
81132020:	10800060 	cmpeqi	r2,r2,1
81132024:	10003626 	beq	r2,zero,81132100 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81132028:	e0bfe104 	addi	r2,fp,-124
8113202c:	100b883a 	mov	r5,r2
81132030:	01003fc4 	movi	r4,255
81132034:	113a5700 	call	8113a570 <OSTaskQuery>
81132038:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8113203c:	e0bffe83 	ldbu	r2,-6(fp)
81132040:	10803fcc 	andi	r2,r2,255
81132044:	1000301e 	bne	r2,zero,81132108 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81132048:	e0bfed83 	ldbu	r2,-74(fp)
8113204c:	10803fcc 	andi	r2,r2,255
81132050:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81132054:	d0a09217 	ldw	r2,-32184(gp)
81132058:	e0fffc04 	addi	r3,fp,-16
8113205c:	180b883a 	mov	r5,r3
81132060:	1009883a 	mov	r4,r2
81132064:	1138edc0 	call	81138edc <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132068:	0005303a 	rdctl	r2,status
8113206c:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132070:	e0ffe017 	ldw	r3,-128(fp)
81132074:	00bfff84 	movi	r2,-2
81132078:	1884703a 	and	r2,r3,r2
8113207c:	1001703a 	wrctl	status,r2
  
  return context;
81132080:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81132084:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81132088:	e0bffc0b 	ldhu	r2,-16(fp)
8113208c:	10bfffcc 	andi	r2,r2,65535
81132090:	10000b1e 	bne	r2,zero,811320c0 <__malloc_lock+0xc8>
81132094:	d0a01717 	ldw	r2,-32676(gp)
81132098:	e0ffdd17 	ldw	r3,-140(fp)
8113209c:	1880081e 	bne	r3,r2,811320c0 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
811320a0:	d0a09117 	ldw	r2,-32188(gp)
811320a4:	10800044 	addi	r2,r2,1
811320a8:	d0a09115 	stw	r2,-32188(gp)
811320ac:	e0bfdc17 	ldw	r2,-144(fp)
811320b0:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811320b4:	e0bfde17 	ldw	r2,-136(fp)
811320b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
811320bc:	00000e06 	br	811320f8 <__malloc_lock+0x100>
811320c0:	e0bfdc17 	ldw	r2,-144(fp)
811320c4:	e0bfdf15 	stw	r2,-132(fp)
811320c8:	e0bfdf17 	ldw	r2,-132(fp)
811320cc:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
811320d0:	d0a09217 	ldw	r2,-32184(gp)
811320d4:	e0fffe84 	addi	r3,fp,-6
811320d8:	180d883a 	mov	r6,r3
811320dc:	000b883a 	mov	r5,zero
811320e0:	1009883a 	mov	r4,r2
811320e4:	1138a3c0 	call	81138a3c <OSSemPend>
    locks  = 1;
811320e8:	00800044 	movi	r2,1
811320ec:	d0a09115 	stw	r2,-32188(gp)
    lockid = id;
811320f0:	e0bfdd17 	ldw	r2,-140(fp)
811320f4:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811320f8:	0001883a 	nop
811320fc:	00000306 	br	8113210c <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81132100:	0001883a 	nop
81132104:	00000106 	br	8113210c <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81132108:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
8113210c:	e037883a 	mov	sp,fp
81132110:	dfc00117 	ldw	ra,4(sp)
81132114:	df000017 	ldw	fp,0(sp)
81132118:	dec00204 	addi	sp,sp,8
8113211c:	f800283a 	ret

81132120 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81132120:	defff804 	addi	sp,sp,-32
81132124:	de00012e 	bgeu	sp,et,8113212c <__malloc_unlock+0xc>
81132128:	003b68fa 	trap	3
8113212c:	dfc00715 	stw	ra,28(sp)
81132130:	df000615 	stw	fp,24(sp)
81132134:	df000604 	addi	fp,sp,24
81132138:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113213c:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81132140:	d0a09603 	ldbu	r2,-32168(gp)
81132144:	10803fcc 	andi	r2,r2,255
81132148:	10800060 	cmpeqi	r2,r2,1
8113214c:	10002326 	beq	r2,zero,811321dc <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132150:	0005303a 	rdctl	r2,status
81132154:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132158:	e0fffe17 	ldw	r3,-8(fp)
8113215c:	00bfff84 	movi	r2,-2
81132160:	1884703a 	and	r2,r3,r2
81132164:	1001703a 	wrctl	status,r2
  
  return context;
81132168:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
8113216c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81132170:	d0a09117 	ldw	r2,-32188(gp)
81132174:	1000051e 	bne	r2,zero,8113218c <__malloc_unlock+0x6c>
81132178:	e0bffa17 	ldw	r2,-24(fp)
8113217c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132180:	e0bffb17 	ldw	r2,-20(fp)
81132184:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81132188:	00001506 	br	811321e0 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
8113218c:	d0a09117 	ldw	r2,-32188(gp)
81132190:	10bfffc4 	addi	r2,r2,-1
81132194:	d0a09115 	stw	r2,-32188(gp)
81132198:	d0a09117 	ldw	r2,-32188(gp)
8113219c:	10000a1e 	bne	r2,zero,811321c8 <__malloc_unlock+0xa8>
  {
    lockid = -1;
811321a0:	00bfffc4 	movi	r2,-1
811321a4:	d0a01715 	stw	r2,-32676(gp)
811321a8:	e0bffa17 	ldw	r2,-24(fp)
811321ac:	e0bffc15 	stw	r2,-16(fp)
811321b0:	e0bffc17 	ldw	r2,-16(fp)
811321b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
811321b8:	d0a09217 	ldw	r2,-32184(gp)
811321bc:	1009883a 	mov	r4,r2
811321c0:	1138dc40 	call	81138dc4 <OSSemPost>
811321c4:	00000606 	br	811321e0 <__malloc_unlock+0xc0>
811321c8:	e0bffa17 	ldw	r2,-24(fp)
811321cc:	e0bffd15 	stw	r2,-12(fp)
811321d0:	e0bffd17 	ldw	r2,-12(fp)
811321d4:	1001703a 	wrctl	status,r2
811321d8:	00000106 	br	811321e0 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
811321dc:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811321e0:	e037883a 	mov	sp,fp
811321e4:	dfc00117 	ldw	ra,4(sp)
811321e8:	df000017 	ldw	fp,0(sp)
811321ec:	dec00204 	addi	sp,sp,8
811321f0:	f800283a 	ret

811321f4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811321f4:	defff704 	addi	sp,sp,-36
811321f8:	de00012e 	bgeu	sp,et,81132200 <OSEventNameGet+0xc>
811321fc:	003b68fa 	trap	3
81132200:	dfc00815 	stw	ra,32(sp)
81132204:	df000715 	stw	fp,28(sp)
81132208:	df000704 	addi	fp,sp,28
8113220c:	e13ffd15 	stw	r4,-12(fp)
81132210:	e17ffe15 	stw	r5,-8(fp)
81132214:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132218:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113221c:	e0bfff17 	ldw	r2,-4(fp)
81132220:	1000021e 	bne	r2,zero,8113222c <OSEventNameGet+0x38>
        return (0);
81132224:	0005883a 	mov	r2,zero
81132228:	00003706 	br	81132308 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113222c:	e0bffd17 	ldw	r2,-12(fp)
81132230:	1000051e 	bne	r2,zero,81132248 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81132234:	e0bfff17 	ldw	r2,-4(fp)
81132238:	00c00104 	movi	r3,4
8113223c:	10c00005 	stb	r3,0(r2)
        return (0);
81132240:	0005883a 	mov	r2,zero
81132244:	00003006 	br	81132308 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81132248:	e0bffe17 	ldw	r2,-8(fp)
8113224c:	1000051e 	bne	r2,zero,81132264 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81132250:	e0bfff17 	ldw	r2,-4(fp)
81132254:	00c00304 	movi	r3,12
81132258:	10c00005 	stb	r3,0(r2)
        return (0);
8113225c:	0005883a 	mov	r2,zero
81132260:	00002906 	br	81132308 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81132264:	d0a0a603 	ldbu	r2,-32104(gp)
81132268:	10803fcc 	andi	r2,r2,255
8113226c:	10000526 	beq	r2,zero,81132284 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81132270:	e0bfff17 	ldw	r2,-4(fp)
81132274:	00c00444 	movi	r3,17
81132278:	10c00005 	stb	r3,0(r2)
        return (0);
8113227c:	0005883a 	mov	r2,zero
81132280:	00002106 	br	81132308 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81132284:	e0bffd17 	ldw	r2,-12(fp)
81132288:	10800003 	ldbu	r2,0(r2)
8113228c:	10803fcc 	andi	r2,r2,255
81132290:	10bfffc4 	addi	r2,r2,-1
81132294:	10800128 	cmpgeui	r2,r2,4
81132298:	10000526 	beq	r2,zero,811322b0 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113229c:	e0bfff17 	ldw	r2,-4(fp)
811322a0:	00c00044 	movi	r3,1
811322a4:	10c00005 	stb	r3,0(r2)
             return (0);
811322a8:	0005883a 	mov	r2,zero
811322ac:	00001606 	br	81132308 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811322b0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811322b4:	0005303a 	rdctl	r2,status
811322b8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811322bc:	e0fffb17 	ldw	r3,-20(fp)
811322c0:	00bfff84 	movi	r2,-2
811322c4:	1884703a 	and	r2,r3,r2
811322c8:	1001703a 	wrctl	status,r2
  
  return context;
811322cc:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
811322d0:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
811322d4:	e0bffd17 	ldw	r2,-12(fp)
811322d8:	10800444 	addi	r2,r2,17
811322dc:	100b883a 	mov	r5,r2
811322e0:	e13ffe17 	ldw	r4,-8(fp)
811322e4:	1133ce00 	call	81133ce0 <OS_StrCopy>
811322e8:	e0bffa05 	stb	r2,-24(fp)
811322ec:	e0bff917 	ldw	r2,-28(fp)
811322f0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811322f4:	e0bffc17 	ldw	r2,-16(fp)
811322f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811322fc:	e0bfff17 	ldw	r2,-4(fp)
81132300:	10000005 	stb	zero,0(r2)
    return (len);
81132304:	e0bffa03 	ldbu	r2,-24(fp)
}
81132308:	e037883a 	mov	sp,fp
8113230c:	dfc00117 	ldw	ra,4(sp)
81132310:	df000017 	ldw	fp,0(sp)
81132314:	dec00204 	addi	sp,sp,8
81132318:	f800283a 	ret

8113231c <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8113231c:	defff604 	addi	sp,sp,-40
81132320:	de00012e 	bgeu	sp,et,81132328 <OSEventNameSet+0xc>
81132324:	003b68fa 	trap	3
81132328:	dfc00915 	stw	ra,36(sp)
8113232c:	df000815 	stw	fp,32(sp)
81132330:	df000804 	addi	fp,sp,32
81132334:	e13ffd15 	stw	r4,-12(fp)
81132338:	e17ffe15 	stw	r5,-8(fp)
8113233c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132340:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81132344:	e0bfff17 	ldw	r2,-4(fp)
81132348:	10004026 	beq	r2,zero,8113244c <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
8113234c:	e0bffd17 	ldw	r2,-12(fp)
81132350:	1000041e 	bne	r2,zero,81132364 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81132354:	e0bfff17 	ldw	r2,-4(fp)
81132358:	00c00104 	movi	r3,4
8113235c:	10c00005 	stb	r3,0(r2)
        return;
81132360:	00003b06 	br	81132450 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81132364:	e0bffe17 	ldw	r2,-8(fp)
81132368:	1000041e 	bne	r2,zero,8113237c <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113236c:	e0bfff17 	ldw	r2,-4(fp)
81132370:	00c00304 	movi	r3,12
81132374:	10c00005 	stb	r3,0(r2)
        return;
81132378:	00003506 	br	81132450 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113237c:	d0a0a603 	ldbu	r2,-32104(gp)
81132380:	10803fcc 	andi	r2,r2,255
81132384:	10000426 	beq	r2,zero,81132398 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81132388:	e0bfff17 	ldw	r2,-4(fp)
8113238c:	00c00484 	movi	r3,18
81132390:	10c00005 	stb	r3,0(r2)
        return;
81132394:	00002e06 	br	81132450 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81132398:	e0bffd17 	ldw	r2,-12(fp)
8113239c:	10800003 	ldbu	r2,0(r2)
811323a0:	10803fcc 	andi	r2,r2,255
811323a4:	10bfffc4 	addi	r2,r2,-1
811323a8:	10800128 	cmpgeui	r2,r2,4
811323ac:	10000426 	beq	r2,zero,811323c0 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
811323b0:	e0bfff17 	ldw	r2,-4(fp)
811323b4:	00c00044 	movi	r3,1
811323b8:	10c00005 	stb	r3,0(r2)
             return;
811323bc:	00002406 	br	81132450 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
811323c0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811323c4:	0005303a 	rdctl	r2,status
811323c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811323cc:	e0fffc17 	ldw	r3,-16(fp)
811323d0:	00bfff84 	movi	r2,-2
811323d4:	1884703a 	and	r2,r3,r2
811323d8:	1001703a 	wrctl	status,r2
  
  return context;
811323dc:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
811323e0:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
811323e4:	e13ffe17 	ldw	r4,-8(fp)
811323e8:	1133d5c0 	call	81133d5c <OS_StrLen>
811323ec:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
811323f0:	e0bffa03 	ldbu	r2,-24(fp)
811323f4:	10800830 	cmpltui	r2,r2,32
811323f8:	1000081e 	bne	r2,zero,8113241c <OSEventNameSet+0x100>
811323fc:	e0bff817 	ldw	r2,-32(fp)
81132400:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132404:	e0bff917 	ldw	r2,-28(fp)
81132408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
8113240c:	e0bfff17 	ldw	r2,-4(fp)
81132410:	00c002c4 	movi	r3,11
81132414:	10c00005 	stb	r3,0(r2)
        return;
81132418:	00000d06 	br	81132450 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
8113241c:	e0bffd17 	ldw	r2,-12(fp)
81132420:	10800444 	addi	r2,r2,17
81132424:	e17ffe17 	ldw	r5,-8(fp)
81132428:	1009883a 	mov	r4,r2
8113242c:	1133ce00 	call	81133ce0 <OS_StrCopy>
81132430:	e0bff817 	ldw	r2,-32(fp)
81132434:	e0bffb15 	stw	r2,-20(fp)
81132438:	e0bffb17 	ldw	r2,-20(fp)
8113243c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81132440:	e0bfff17 	ldw	r2,-4(fp)
81132444:	10000005 	stb	zero,0(r2)
81132448:	00000106 	br	81132450 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113244c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81132450:	e037883a 	mov	sp,fp
81132454:	dfc00117 	ldw	ra,4(sp)
81132458:	df000017 	ldw	fp,0(sp)
8113245c:	dec00204 	addi	sp,sp,8
81132460:	f800283a 	ret

81132464 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81132464:	deffed04 	addi	sp,sp,-76
81132468:	de00012e 	bgeu	sp,et,81132470 <OSEventPendMulti+0xc>
8113246c:	003b68fa 	trap	3
81132470:	dfc01215 	stw	ra,72(sp)
81132474:	df001115 	stw	fp,68(sp)
81132478:	df001104 	addi	fp,sp,68
8113247c:	e13ffc15 	stw	r4,-16(fp)
81132480:	e17ffd15 	stw	r5,-12(fp)
81132484:	e1bffe15 	stw	r6,-8(fp)
81132488:	3805883a 	mov	r2,r7
8113248c:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81132490:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81132494:	e0800217 	ldw	r2,8(fp)
81132498:	1000021e 	bne	r2,zero,811324a4 <OSEventPendMulti+0x40>
        return (0);
8113249c:	0005883a 	mov	r2,zero
811324a0:	00015006 	br	811329e4 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
811324a4:	e0bffc17 	ldw	r2,-16(fp)
811324a8:	1000051e 	bne	r2,zero,811324c0 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
811324ac:	e0800217 	ldw	r2,8(fp)
811324b0:	00c00104 	movi	r3,4
811324b4:	10c00005 	stb	r3,0(r2)
        return (0);
811324b8:	0005883a 	mov	r2,zero
811324bc:	00014906 	br	811329e4 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
811324c0:	e0bffd17 	ldw	r2,-12(fp)
811324c4:	1000051e 	bne	r2,zero,811324dc <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
811324c8:	e0800217 	ldw	r2,8(fp)
811324cc:	00c00104 	movi	r3,4
811324d0:	10c00005 	stb	r3,0(r2)
        return (0);
811324d4:	0005883a 	mov	r2,zero
811324d8:	00014206 	br	811329e4 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
811324dc:	e0bffe17 	ldw	r2,-8(fp)
811324e0:	1000051e 	bne	r2,zero,811324f8 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
811324e4:	e0800217 	ldw	r2,8(fp)
811324e8:	00c00104 	movi	r3,4
811324ec:	10c00005 	stb	r3,0(r2)
        return (0);
811324f0:	0005883a 	mov	r2,zero
811324f4:	00013b06 	br	811329e4 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811324f8:	e0bffd17 	ldw	r2,-12(fp)
811324fc:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81132500:	e0bffc17 	ldw	r2,-16(fp)
81132504:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81132508:	e0bfef17 	ldw	r2,-68(fp)
8113250c:	10800017 	ldw	r2,0(r2)
81132510:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81132514:	00001506 	br	8113256c <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81132518:	e0bff017 	ldw	r2,-64(fp)
8113251c:	10800003 	ldbu	r2,0(r2)
81132520:	10803fcc 	andi	r2,r2,255
81132524:	10c000a0 	cmpeqi	r3,r2,2
81132528:	1800071e 	bne	r3,zero,81132548 <OSEventPendMulti+0xe4>
8113252c:	108000e0 	cmpeqi	r2,r2,3
81132530:	1000071e 	bne	r2,zero,81132550 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81132534:	e0800217 	ldw	r2,8(fp)
81132538:	00c00044 	movi	r3,1
8113253c:	10c00005 	stb	r3,0(r2)
                 return (0);
81132540:	0005883a 	mov	r2,zero
81132544:	00012706 	br	811329e4 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81132548:	0001883a 	nop
8113254c:	00000106 	br	81132554 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81132550:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81132554:	e0bfef17 	ldw	r2,-68(fp)
81132558:	10800104 	addi	r2,r2,4
8113255c:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81132560:	e0bfef17 	ldw	r2,-68(fp)
81132564:	10800017 	ldw	r2,0(r2)
81132568:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
8113256c:	e0bff017 	ldw	r2,-64(fp)
81132570:	103fe91e 	bne	r2,zero,81132518 <__reset+0xfb112518>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81132574:	d0a0a603 	ldbu	r2,-32104(gp)
81132578:	10803fcc 	andi	r2,r2,255
8113257c:	10000526 	beq	r2,zero,81132594 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81132580:	e0800217 	ldw	r2,8(fp)
81132584:	00c00084 	movi	r3,2
81132588:	10c00005 	stb	r3,0(r2)
        return (0);
8113258c:	0005883a 	mov	r2,zero
81132590:	00011406 	br	811329e4 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81132594:	d0a09403 	ldbu	r2,-32176(gp)
81132598:	10803fcc 	andi	r2,r2,255
8113259c:	10000526 	beq	r2,zero,811325b4 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
811325a0:	e0800217 	ldw	r2,8(fp)
811325a4:	00c00344 	movi	r3,13
811325a8:	10c00005 	stb	r3,0(r2)
        return (0);
811325ac:	0005883a 	mov	r2,zero
811325b0:	00010c06 	br	811329e4 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811325b4:	0005303a 	rdctl	r2,status
811325b8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811325bc:	e0fffb17 	ldw	r3,-20(fp)
811325c0:	00bfff84 	movi	r2,-2
811325c4:	1884703a 	and	r2,r3,r2
811325c8:	1001703a 	wrctl	status,r2
  
  return context;
811325cc:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
811325d0:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
811325d4:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
811325d8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
811325dc:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
811325e0:	e0bffc17 	ldw	r2,-16(fp)
811325e4:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
811325e8:	e0bfef17 	ldw	r2,-68(fp)
811325ec:	10800017 	ldw	r2,0(r2)
811325f0:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811325f4:	00006406 	br	81132788 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
811325f8:	e0bff017 	ldw	r2,-64(fp)
811325fc:	10800003 	ldbu	r2,0(r2)
81132600:	10803fcc 	andi	r2,r2,255
81132604:	10c000a0 	cmpeqi	r3,r2,2
81132608:	18001f1e 	bne	r3,zero,81132688 <OSEventPendMulti+0x224>
8113260c:	108000e0 	cmpeqi	r2,r2,3
81132610:	10004c26 	beq	r2,zero,81132744 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81132614:	e0bff017 	ldw	r2,-64(fp)
81132618:	1080020b 	ldhu	r2,8(r2)
8113261c:	10bfffcc 	andi	r2,r2,65535
81132620:	10001526 	beq	r2,zero,81132678 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81132624:	e0bff017 	ldw	r2,-64(fp)
81132628:	1080020b 	ldhu	r2,8(r2)
8113262c:	10bfffc4 	addi	r2,r2,-1
81132630:	1007883a 	mov	r3,r2
81132634:	e0bff017 	ldw	r2,-64(fp)
81132638:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
8113263c:	e0bffd17 	ldw	r2,-12(fp)
81132640:	10c00104 	addi	r3,r2,4
81132644:	e0fffd15 	stw	r3,-12(fp)
81132648:	e0fff017 	ldw	r3,-64(fp)
8113264c:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81132650:	00800044 	movi	r2,1
81132654:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81132658:	e0bffe17 	ldw	r2,-8(fp)
8113265c:	10c00104 	addi	r3,r2,4
81132660:	e0fffe15 	stw	r3,-8(fp)
81132664:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81132668:	e0bff18b 	ldhu	r2,-58(fp)
8113266c:	10800044 	addi	r2,r2,1
81132670:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81132674:	00003e06 	br	81132770 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81132678:	e0bff203 	ldbu	r2,-56(fp)
8113267c:	10800054 	ori	r2,r2,1
81132680:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81132684:	00003a06 	br	81132770 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81132688:	e0bff017 	ldw	r2,-64(fp)
8113268c:	10800117 	ldw	r2,4(r2)
81132690:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81132694:	e0bff517 	ldw	r2,-44(fp)
81132698:	1080058b 	ldhu	r2,22(r2)
8113269c:	10bfffcc 	andi	r2,r2,65535
811326a0:	10002426 	beq	r2,zero,81132734 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
811326a4:	e0bffe17 	ldw	r2,-8(fp)
811326a8:	10c00104 	addi	r3,r2,4
811326ac:	e0fffe15 	stw	r3,-8(fp)
811326b0:	e0fff517 	ldw	r3,-44(fp)
811326b4:	18c00417 	ldw	r3,16(r3)
811326b8:	19400104 	addi	r5,r3,4
811326bc:	e13ff517 	ldw	r4,-44(fp)
811326c0:	21400415 	stw	r5,16(r4)
811326c4:	18c00017 	ldw	r3,0(r3)
811326c8:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
811326cc:	e0bff517 	ldw	r2,-44(fp)
811326d0:	10c00417 	ldw	r3,16(r2)
811326d4:	e0bff517 	ldw	r2,-44(fp)
811326d8:	10800217 	ldw	r2,8(r2)
811326dc:	1880041e 	bne	r3,r2,811326f0 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
811326e0:	e0bff517 	ldw	r2,-44(fp)
811326e4:	10c00117 	ldw	r3,4(r2)
811326e8:	e0bff517 	ldw	r2,-44(fp)
811326ec:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
811326f0:	e0bff517 	ldw	r2,-44(fp)
811326f4:	1080058b 	ldhu	r2,22(r2)
811326f8:	10bfffc4 	addi	r2,r2,-1
811326fc:	1007883a 	mov	r3,r2
81132700:	e0bff517 	ldw	r2,-44(fp)
81132704:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81132708:	e0bffd17 	ldw	r2,-12(fp)
8113270c:	10c00104 	addi	r3,r2,4
81132710:	e0fffd15 	stw	r3,-12(fp)
81132714:	e0fff017 	ldw	r3,-64(fp)
81132718:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
8113271c:	00800044 	movi	r2,1
81132720:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81132724:	e0bff18b 	ldhu	r2,-58(fp)
81132728:	10800044 	addi	r2,r2,1
8113272c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
81132730:	00000f06 	br	81132770 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81132734:	e0bff203 	ldbu	r2,-56(fp)
81132738:	10800114 	ori	r2,r2,4
8113273c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81132740:	00000b06 	br	81132770 <OSEventPendMulti+0x30c>
81132744:	e0bff317 	ldw	r2,-52(fp)
81132748:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113274c:	e0bff417 	ldw	r2,-48(fp)
81132750:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81132754:	e0bffd17 	ldw	r2,-12(fp)
81132758:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
8113275c:	e0800217 	ldw	r2,8(fp)
81132760:	00c00044 	movi	r3,1
81132764:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81132768:	e0bff18b 	ldhu	r2,-58(fp)
8113276c:	00009d06 	br	811329e4 <OSEventPendMulti+0x580>
        }
        pevents++;
81132770:	e0bfef17 	ldw	r2,-68(fp)
81132774:	10800104 	addi	r2,r2,4
81132778:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113277c:	e0bfef17 	ldw	r2,-68(fp)
81132780:	10800017 	ldw	r2,0(r2)
81132784:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81132788:	e0bff017 	ldw	r2,-64(fp)
8113278c:	103f9a1e 	bne	r2,zero,811325f8 <__reset+0xfb1125f8>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81132790:	e0bff103 	ldbu	r2,-60(fp)
81132794:	10800058 	cmpnei	r2,r2,1
81132798:	10000a1e 	bne	r2,zero,811327c4 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
8113279c:	e0bffd17 	ldw	r2,-12(fp)
811327a0:	10000015 	stw	zero,0(r2)
811327a4:	e0bff317 	ldw	r2,-52(fp)
811327a8:	e0bff615 	stw	r2,-40(fp)
811327ac:	e0bff617 	ldw	r2,-40(fp)
811327b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
811327b4:	e0800217 	ldw	r2,8(fp)
811327b8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
811327bc:	e0bff18b 	ldhu	r2,-58(fp)
811327c0:	00008806 	br	811329e4 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
811327c4:	d0a0a717 	ldw	r2,-32100(gp)
811327c8:	d0e0a717 	ldw	r3,-32100(gp)
811327cc:	19000c03 	ldbu	r4,48(r3)
811327d0:	e0fff203 	ldbu	r3,-56(fp)
811327d4:	20c6b03a 	or	r3,r4,r3
811327d8:	1809883a 	mov	r4,r3
811327dc:	00ffe004 	movi	r3,-128
811327e0:	20c6b03a 	or	r3,r4,r3
811327e4:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811327e8:	d0a0a717 	ldw	r2,-32100(gp)
811327ec:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
811327f0:	d0a0a717 	ldw	r2,-32100(gp)
811327f4:	e0ffff0b 	ldhu	r3,-4(fp)
811327f8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
811327fc:	e13ffc17 	ldw	r4,-16(fp)
81132800:	11333880 	call	81133388 <OS_EventTaskWaitMulti>
81132804:	e0bff317 	ldw	r2,-52(fp)
81132808:	e0bff915 	stw	r2,-28(fp)
8113280c:	e0bff917 	ldw	r2,-28(fp)
81132810:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81132814:	1133b8c0 	call	81133b8c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132818:	0005303a 	rdctl	r2,status
8113281c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132820:	e0fff717 	ldw	r3,-36(fp)
81132824:	00bfff84 	movi	r2,-2
81132828:	1884703a 	and	r2,r3,r2
8113282c:	1001703a 	wrctl	status,r2
  
  return context;
81132830:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81132834:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81132838:	d0a0a717 	ldw	r2,-32100(gp)
8113283c:	10800c43 	ldbu	r2,49(r2)
81132840:	10803fcc 	andi	r2,r2,255
81132844:	10000226 	beq	r2,zero,81132850 <OSEventPendMulti+0x3ec>
81132848:	108000a0 	cmpeqi	r2,r2,2
8113284c:	10001826 	beq	r2,zero,811328b0 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81132850:	d0a0a717 	ldw	r2,-32100(gp)
81132854:	10800717 	ldw	r2,28(r2)
81132858:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
8113285c:	e0bff017 	ldw	r2,-64(fp)
81132860:	10000b26 	beq	r2,zero,81132890 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81132864:	e0bffd17 	ldw	r2,-12(fp)
81132868:	10c00104 	addi	r3,r2,4
8113286c:	e0fffd15 	stw	r3,-12(fp)
81132870:	e0fff017 	ldw	r3,-64(fp)
81132874:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81132878:	e0bffd17 	ldw	r2,-12(fp)
8113287c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81132880:	e0bff18b 	ldhu	r2,-58(fp)
81132884:	10800044 	addi	r2,r2,1
81132888:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
8113288c:	00000d06 	br	811328c4 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81132890:	d0a0a717 	ldw	r2,-32100(gp)
81132894:	00c00044 	movi	r3,1
81132898:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113289c:	d0a0a717 	ldw	r2,-32100(gp)
811328a0:	e17ffc17 	ldw	r5,-16(fp)
811328a4:	1009883a 	mov	r4,r2
811328a8:	11335a00 	call	811335a0 <OS_EventTaskRemoveMulti>
             }
			 break;
811328ac:	00000506 	br	811328c4 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811328b0:	d0a0a717 	ldw	r2,-32100(gp)
811328b4:	e17ffc17 	ldw	r5,-16(fp)
811328b8:	1009883a 	mov	r4,r2
811328bc:	11335a00 	call	811335a0 <OS_EventTaskRemoveMulti>
             break;
811328c0:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
811328c4:	d0a0a717 	ldw	r2,-32100(gp)
811328c8:	10800c43 	ldbu	r2,49(r2)
811328cc:	10803fcc 	andi	r2,r2,255
811328d0:	10000326 	beq	r2,zero,811328e0 <OSEventPendMulti+0x47c>
811328d4:	108000a0 	cmpeqi	r2,r2,2
811328d8:	1000231e 	bne	r2,zero,81132968 <OSEventPendMulti+0x504>
811328dc:	00002a06 	br	81132988 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
811328e0:	e0bff017 	ldw	r2,-64(fp)
811328e4:	10800003 	ldbu	r2,0(r2)
811328e8:	10803fcc 	andi	r2,r2,255
811328ec:	0080100e 	bge	zero,r2,81132930 <OSEventPendMulti+0x4cc>
811328f0:	10c000d0 	cmplti	r3,r2,3
811328f4:	1800071e 	bne	r3,zero,81132914 <OSEventPendMulti+0x4b0>
811328f8:	108000e0 	cmpeqi	r2,r2,3
811328fc:	10000c26 	beq	r2,zero,81132930 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81132900:	e0bffe17 	ldw	r2,-8(fp)
81132904:	10c00104 	addi	r3,r2,4
81132908:	e0fffe15 	stw	r3,-8(fp)
8113290c:	10000015 	stw	zero,0(r2)
                      break;
81132910:	00001206 	br	8113295c <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81132914:	e0bffe17 	ldw	r2,-8(fp)
81132918:	10c00104 	addi	r3,r2,4
8113291c:	e0fffe15 	stw	r3,-8(fp)
81132920:	d0e0a717 	ldw	r3,-32100(gp)
81132924:	18c00917 	ldw	r3,36(r3)
81132928:	10c00015 	stw	r3,0(r2)
                      break;
8113292c:	00000b06 	br	8113295c <OSEventPendMulti+0x4f8>
81132930:	e0bff317 	ldw	r2,-52(fp)
81132934:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132938:	e0bff817 	ldw	r2,-32(fp)
8113293c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81132940:	e0bffd17 	ldw	r2,-12(fp)
81132944:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81132948:	e0800217 	ldw	r2,8(fp)
8113294c:	00c00044 	movi	r3,1
81132950:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81132954:	e0bff18b 	ldhu	r2,-58(fp)
81132958:	00002206 	br	811329e4 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
8113295c:	e0800217 	ldw	r2,8(fp)
81132960:	10000005 	stb	zero,0(r2)
             break;
81132964:	00001006 	br	811329a8 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81132968:	e0bffe17 	ldw	r2,-8(fp)
8113296c:	10c00104 	addi	r3,r2,4
81132970:	e0fffe15 	stw	r3,-8(fp)
81132974:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81132978:	e0800217 	ldw	r2,8(fp)
8113297c:	00c00384 	movi	r3,14
81132980:	10c00005 	stb	r3,0(r2)
             break;
81132984:	00000806 	br	811329a8 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81132988:	e0bffe17 	ldw	r2,-8(fp)
8113298c:	10c00104 	addi	r3,r2,4
81132990:	e0fffe15 	stw	r3,-8(fp)
81132994:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81132998:	e0800217 	ldw	r2,8(fp)
8113299c:	00c00284 	movi	r3,10
811329a0:	10c00005 	stb	r3,0(r2)
             break;
811329a4:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
811329a8:	d0a0a717 	ldw	r2,-32100(gp)
811329ac:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
811329b0:	d0a0a717 	ldw	r2,-32100(gp)
811329b4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
811329b8:	d0a0a717 	ldw	r2,-32100(gp)
811329bc:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811329c0:	d0a0a717 	ldw	r2,-32100(gp)
811329c4:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
811329c8:	d0a0a717 	ldw	r2,-32100(gp)
811329cc:	10000915 	stw	zero,36(r2)
811329d0:	e0bff317 	ldw	r2,-52(fp)
811329d4:	e0bffa15 	stw	r2,-24(fp)
811329d8:	e0bffa17 	ldw	r2,-24(fp)
811329dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
811329e0:	e0bff18b 	ldhu	r2,-58(fp)
}
811329e4:	e037883a 	mov	sp,fp
811329e8:	dfc00117 	ldw	ra,4(sp)
811329ec:	df000017 	ldw	fp,0(sp)
811329f0:	dec00204 	addi	sp,sp,8
811329f4:	f800283a 	ret

811329f8 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
811329f8:	defffe04 	addi	sp,sp,-8
811329fc:	de00012e 	bgeu	sp,et,81132a04 <OSInit+0xc>
81132a00:	003b68fa 	trap	3
81132a04:	dfc00115 	stw	ra,4(sp)
81132a08:	df000015 	stw	fp,0(sp)
81132a0c:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81132a10:	1144d480 	call	81144d48 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81132a14:	11338000 	call	81133800 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81132a18:	11338500 	call	81133850 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81132a1c:	11339d40 	call	811339d4 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81132a20:	11337180 	call	81133718 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81132a24:	11359940 	call	81135994 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81132a28:	11362dc0 	call	811362dc <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81132a2c:	11385ac0 	call	811385ac <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81132a30:	11338c40 	call	811338c4 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81132a34:	113394c0 	call	8113394c <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81132a38:	113b79c0 	call	8113b79c <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81132a3c:	1144d740 	call	81144d74 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81132a40:	11342b00 	call	811342b0 <OSDebugInit>
#endif
}
81132a44:	0001883a 	nop
81132a48:	e037883a 	mov	sp,fp
81132a4c:	dfc00117 	ldw	ra,4(sp)
81132a50:	df000017 	ldw	fp,0(sp)
81132a54:	dec00204 	addi	sp,sp,8
81132a58:	f800283a 	ret

81132a5c <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81132a5c:	deffff04 	addi	sp,sp,-4
81132a60:	de00012e 	bgeu	sp,et,81132a68 <OSIntEnter+0xc>
81132a64:	003b68fa 	trap	3
81132a68:	df000015 	stw	fp,0(sp)
81132a6c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81132a70:	d0a09603 	ldbu	r2,-32168(gp)
81132a74:	10803fcc 	andi	r2,r2,255
81132a78:	10800058 	cmpnei	r2,r2,1
81132a7c:	1000071e 	bne	r2,zero,81132a9c <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81132a80:	d0a0a603 	ldbu	r2,-32104(gp)
81132a84:	10803fcc 	andi	r2,r2,255
81132a88:	10803fe0 	cmpeqi	r2,r2,255
81132a8c:	1000031e 	bne	r2,zero,81132a9c <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81132a90:	d0a0a603 	ldbu	r2,-32104(gp)
81132a94:	10800044 	addi	r2,r2,1
81132a98:	d0a0a605 	stb	r2,-32104(gp)
        }
    }
}
81132a9c:	0001883a 	nop
81132aa0:	e037883a 	mov	sp,fp
81132aa4:	df000017 	ldw	fp,0(sp)
81132aa8:	dec00104 	addi	sp,sp,4
81132aac:	f800283a 	ret

81132ab0 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81132ab0:	defffb04 	addi	sp,sp,-20
81132ab4:	de00012e 	bgeu	sp,et,81132abc <OSIntExit+0xc>
81132ab8:	003b68fa 	trap	3
81132abc:	dfc00415 	stw	ra,16(sp)
81132ac0:	df000315 	stw	fp,12(sp)
81132ac4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132ac8:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81132acc:	d0a09603 	ldbu	r2,-32168(gp)
81132ad0:	10803fcc 	andi	r2,r2,255
81132ad4:	10800058 	cmpnei	r2,r2,1
81132ad8:	10002f1e 	bne	r2,zero,81132b98 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132adc:	0005303a 	rdctl	r2,status
81132ae0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132ae4:	e0ffff17 	ldw	r3,-4(fp)
81132ae8:	00bfff84 	movi	r2,-2
81132aec:	1884703a 	and	r2,r3,r2
81132af0:	1001703a 	wrctl	status,r2
  
  return context;
81132af4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81132af8:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81132afc:	d0a0a603 	ldbu	r2,-32104(gp)
81132b00:	10803fcc 	andi	r2,r2,255
81132b04:	10000326 	beq	r2,zero,81132b14 <OSIntExit+0x64>
            OSIntNesting--;
81132b08:	d0a0a603 	ldbu	r2,-32104(gp)
81132b0c:	10bfffc4 	addi	r2,r2,-1
81132b10:	d0a0a605 	stb	r2,-32104(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81132b14:	d0a0a603 	ldbu	r2,-32104(gp)
81132b18:	10803fcc 	andi	r2,r2,255
81132b1c:	10001a1e 	bne	r2,zero,81132b88 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81132b20:	d0a09403 	ldbu	r2,-32176(gp)
81132b24:	10803fcc 	andi	r2,r2,255
81132b28:	1000171e 	bne	r2,zero,81132b88 <OSIntExit+0xd8>
                OS_SchedNew();
81132b2c:	1133c640 	call	81133c64 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81132b30:	d0e09883 	ldbu	r3,-32158(gp)
81132b34:	d0a098c3 	ldbu	r2,-32157(gp)
81132b38:	18c03fcc 	andi	r3,r3,255
81132b3c:	10803fcc 	andi	r2,r2,255
81132b40:	18801126 	beq	r3,r2,81132b88 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81132b44:	d0a09883 	ldbu	r2,-32158(gp)
81132b48:	10c03fcc 	andi	r3,r2,255
81132b4c:	00a045b4 	movhi	r2,33046
81132b50:	1094cd04 	addi	r2,r2,21300
81132b54:	18c7883a 	add	r3,r3,r3
81132b58:	18c7883a 	add	r3,r3,r3
81132b5c:	10c5883a 	add	r2,r2,r3
81132b60:	10800017 	ldw	r2,0(r2)
81132b64:	d0a0a115 	stw	r2,-32124(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81132b68:	d0a0a117 	ldw	r2,-32124(gp)
81132b6c:	10c00e17 	ldw	r3,56(r2)
81132b70:	18c00044 	addi	r3,r3,1
81132b74:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81132b78:	d0a09b17 	ldw	r2,-32148(gp)
81132b7c:	10800044 	addi	r2,r2,1
81132b80:	d0a09b15 	stw	r2,-32148(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81132b84:	1144a080 	call	81144a08 <OSCtxSw>
81132b88:	e0bffd17 	ldw	r2,-12(fp)
81132b8c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132b90:	e0bffe17 	ldw	r2,-8(fp)
81132b94:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81132b98:	0001883a 	nop
81132b9c:	e037883a 	mov	sp,fp
81132ba0:	dfc00117 	ldw	ra,4(sp)
81132ba4:	df000017 	ldw	fp,0(sp)
81132ba8:	dec00204 	addi	sp,sp,8
81132bac:	f800283a 	ret

81132bb0 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81132bb0:	defffc04 	addi	sp,sp,-16
81132bb4:	de00012e 	bgeu	sp,et,81132bbc <OSSchedLock+0xc>
81132bb8:	003b68fa 	trap	3
81132bbc:	df000315 	stw	fp,12(sp)
81132bc0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132bc4:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81132bc8:	d0a09603 	ldbu	r2,-32168(gp)
81132bcc:	10803fcc 	andi	r2,r2,255
81132bd0:	10800058 	cmpnei	r2,r2,1
81132bd4:	1000161e 	bne	r2,zero,81132c30 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132bd8:	0005303a 	rdctl	r2,status
81132bdc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132be0:	e0ffff17 	ldw	r3,-4(fp)
81132be4:	00bfff84 	movi	r2,-2
81132be8:	1884703a 	and	r2,r3,r2
81132bec:	1001703a 	wrctl	status,r2
  
  return context;
81132bf0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81132bf4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81132bf8:	d0a0a603 	ldbu	r2,-32104(gp)
81132bfc:	10803fcc 	andi	r2,r2,255
81132c00:	1000071e 	bne	r2,zero,81132c20 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81132c04:	d0a09403 	ldbu	r2,-32176(gp)
81132c08:	10803fcc 	andi	r2,r2,255
81132c0c:	10803fe0 	cmpeqi	r2,r2,255
81132c10:	1000031e 	bne	r2,zero,81132c20 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81132c14:	d0a09403 	ldbu	r2,-32176(gp)
81132c18:	10800044 	addi	r2,r2,1
81132c1c:	d0a09405 	stb	r2,-32176(gp)
81132c20:	e0bffd17 	ldw	r2,-12(fp)
81132c24:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132c28:	e0bffe17 	ldw	r2,-8(fp)
81132c2c:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81132c30:	0001883a 	nop
81132c34:	e037883a 	mov	sp,fp
81132c38:	df000017 	ldw	fp,0(sp)
81132c3c:	dec00104 	addi	sp,sp,4
81132c40:	f800283a 	ret

81132c44 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81132c44:	defff804 	addi	sp,sp,-32
81132c48:	de00012e 	bgeu	sp,et,81132c50 <OSSchedUnlock+0xc>
81132c4c:	003b68fa 	trap	3
81132c50:	dfc00715 	stw	ra,28(sp)
81132c54:	df000615 	stw	fp,24(sp)
81132c58:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132c5c:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81132c60:	d0a09603 	ldbu	r2,-32168(gp)
81132c64:	10803fcc 	andi	r2,r2,255
81132c68:	10800058 	cmpnei	r2,r2,1
81132c6c:	1000281e 	bne	r2,zero,81132d10 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132c70:	0005303a 	rdctl	r2,status
81132c74:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132c78:	e0ffff17 	ldw	r3,-4(fp)
81132c7c:	00bfff84 	movi	r2,-2
81132c80:	1884703a 	and	r2,r3,r2
81132c84:	1001703a 	wrctl	status,r2
  
  return context;
81132c88:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81132c8c:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81132c90:	d0a09403 	ldbu	r2,-32176(gp)
81132c94:	10803fcc 	andi	r2,r2,255
81132c98:	10001926 	beq	r2,zero,81132d00 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81132c9c:	d0a09403 	ldbu	r2,-32176(gp)
81132ca0:	10bfffc4 	addi	r2,r2,-1
81132ca4:	d0a09405 	stb	r2,-32176(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81132ca8:	d0a09403 	ldbu	r2,-32176(gp)
81132cac:	10803fcc 	andi	r2,r2,255
81132cb0:	10000e1e 	bne	r2,zero,81132cec <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81132cb4:	d0a0a603 	ldbu	r2,-32104(gp)
81132cb8:	10803fcc 	andi	r2,r2,255
81132cbc:	1000061e 	bne	r2,zero,81132cd8 <OSSchedUnlock+0x94>
81132cc0:	e0bffa17 	ldw	r2,-24(fp)
81132cc4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132cc8:	e0bffb17 	ldw	r2,-20(fp)
81132ccc:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81132cd0:	1133b8c0 	call	81133b8c <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81132cd4:	00000e06 	br	81132d10 <OSSchedUnlock+0xcc>
81132cd8:	e0bffa17 	ldw	r2,-24(fp)
81132cdc:	e0bffc15 	stw	r2,-16(fp)
81132ce0:	e0bffc17 	ldw	r2,-16(fp)
81132ce4:	1001703a 	wrctl	status,r2
81132ce8:	00000906 	br	81132d10 <OSSchedUnlock+0xcc>
81132cec:	e0bffa17 	ldw	r2,-24(fp)
81132cf0:	e0bffd15 	stw	r2,-12(fp)
81132cf4:	e0bffd17 	ldw	r2,-12(fp)
81132cf8:	1001703a 	wrctl	status,r2
81132cfc:	00000406 	br	81132d10 <OSSchedUnlock+0xcc>
81132d00:	e0bffa17 	ldw	r2,-24(fp)
81132d04:	e0bffe15 	stw	r2,-8(fp)
81132d08:	e0bffe17 	ldw	r2,-8(fp)
81132d0c:	1001703a 	wrctl	status,r2
81132d10:	0001883a 	nop
81132d14:	e037883a 	mov	sp,fp
81132d18:	dfc00117 	ldw	ra,4(sp)
81132d1c:	df000017 	ldw	fp,0(sp)
81132d20:	dec00204 	addi	sp,sp,8
81132d24:	f800283a 	ret

81132d28 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81132d28:	defffe04 	addi	sp,sp,-8
81132d2c:	de00012e 	bgeu	sp,et,81132d34 <OSStart+0xc>
81132d30:	003b68fa 	trap	3
81132d34:	dfc00115 	stw	ra,4(sp)
81132d38:	df000015 	stw	fp,0(sp)
81132d3c:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81132d40:	d0a09603 	ldbu	r2,-32168(gp)
81132d44:	10803fcc 	andi	r2,r2,255
81132d48:	10000f1e 	bne	r2,zero,81132d88 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81132d4c:	1133c640 	call	81133c64 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81132d50:	d0a09883 	ldbu	r2,-32158(gp)
81132d54:	d0a098c5 	stb	r2,-32157(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81132d58:	d0a09883 	ldbu	r2,-32158(gp)
81132d5c:	10c03fcc 	andi	r3,r2,255
81132d60:	00a045b4 	movhi	r2,33046
81132d64:	1094cd04 	addi	r2,r2,21300
81132d68:	18c7883a 	add	r3,r3,r3
81132d6c:	18c7883a 	add	r3,r3,r3
81132d70:	10c5883a 	add	r2,r2,r3
81132d74:	10800017 	ldw	r2,0(r2)
81132d78:	d0a0a115 	stw	r2,-32124(gp)
        OSTCBCur      = OSTCBHighRdy;
81132d7c:	d0a0a117 	ldw	r2,-32124(gp)
81132d80:	d0a0a715 	stw	r2,-32100(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81132d84:	1144aa40 	call	81144aa4 <OSStartHighRdy>
    }
}
81132d88:	0001883a 	nop
81132d8c:	e037883a 	mov	sp,fp
81132d90:	dfc00117 	ldw	ra,4(sp)
81132d94:	df000017 	ldw	fp,0(sp)
81132d98:	dec00204 	addi	sp,sp,8
81132d9c:	f800283a 	ret

81132da0 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81132da0:	defff904 	addi	sp,sp,-28
81132da4:	de00012e 	bgeu	sp,et,81132dac <OSStatInit+0xc>
81132da8:	003b68fa 	trap	3
81132dac:	dfc00615 	stw	ra,24(sp)
81132db0:	df000515 	stw	fp,20(sp)
81132db4:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132db8:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81132dbc:	01000084 	movi	r4,2
81132dc0:	113a7140 	call	8113a714 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132dc4:	0005303a 	rdctl	r2,status
81132dc8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132dcc:	e0fffc17 	ldw	r3,-16(fp)
81132dd0:	00bfff84 	movi	r2,-2
81132dd4:	1884703a 	and	r2,r3,r2
81132dd8:	1001703a 	wrctl	status,r2
  
  return context;
81132ddc:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81132de0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81132de4:	d0209715 	stw	zero,-32164(gp)
81132de8:	e0bffb17 	ldw	r2,-20(fp)
81132dec:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132df0:	e0bffd17 	ldw	r2,-12(fp)
81132df4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81132df8:	01001904 	movi	r4,100
81132dfc:	113a7140 	call	8113a714 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132e00:	0005303a 	rdctl	r2,status
81132e04:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132e08:	e0fffe17 	ldw	r3,-8(fp)
81132e0c:	00bfff84 	movi	r2,-2
81132e10:	1884703a 	and	r2,r3,r2
81132e14:	1001703a 	wrctl	status,r2
  
  return context;
81132e18:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81132e1c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81132e20:	d0a09717 	ldw	r2,-32164(gp)
81132e24:	d0a09d15 	stw	r2,-32140(gp)
    OSStatRdy    = OS_TRUE;
81132e28:	00800044 	movi	r2,1
81132e2c:	d0a0ac05 	stb	r2,-32080(gp)
81132e30:	e0bffb17 	ldw	r2,-20(fp)
81132e34:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132e38:	e0bfff17 	ldw	r2,-4(fp)
81132e3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81132e40:	0001883a 	nop
81132e44:	e037883a 	mov	sp,fp
81132e48:	dfc00117 	ldw	ra,4(sp)
81132e4c:	df000017 	ldw	fp,0(sp)
81132e50:	dec00204 	addi	sp,sp,8
81132e54:	f800283a 	ret

81132e58 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81132e58:	defff704 	addi	sp,sp,-36
81132e5c:	de00012e 	bgeu	sp,et,81132e64 <OSTimeTick+0xc>
81132e60:	003b68fa 	trap	3
81132e64:	dfc00815 	stw	ra,32(sp)
81132e68:	df000715 	stw	fp,28(sp)
81132e6c:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81132e70:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81132e74:	1144cf40 	call	81144cf4 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132e78:	0005303a 	rdctl	r2,status
81132e7c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132e80:	e0fffd17 	ldw	r3,-12(fp)
81132e84:	00bfff84 	movi	r2,-2
81132e88:	1884703a 	and	r2,r3,r2
81132e8c:	1001703a 	wrctl	status,r2
  
  return context;
81132e90:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81132e94:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81132e98:	d0a0a917 	ldw	r2,-32092(gp)
81132e9c:	10800044 	addi	r2,r2,1
81132ea0:	d0a0a915 	stw	r2,-32092(gp)
81132ea4:	e0bffb17 	ldw	r2,-20(fp)
81132ea8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132eac:	e0bfff17 	ldw	r2,-4(fp)
81132eb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81132eb4:	d0a09603 	ldbu	r2,-32168(gp)
81132eb8:	10803fcc 	andi	r2,r2,255
81132ebc:	10800058 	cmpnei	r2,r2,1
81132ec0:	10006a1e 	bne	r2,zero,8113306c <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81132ec4:	d0a09a03 	ldbu	r2,-32152(gp)
81132ec8:	10803fcc 	andi	r2,r2,255
81132ecc:	10c00060 	cmpeqi	r3,r2,1
81132ed0:	1800061e 	bne	r3,zero,81132eec <OSTimeTick+0x94>
81132ed4:	10c000a0 	cmpeqi	r3,r2,2
81132ed8:	1800061e 	bne	r3,zero,81132ef4 <OSTimeTick+0x9c>
81132edc:	10000a1e 	bne	r2,zero,81132f08 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81132ee0:	00800044 	movi	r2,1
81132ee4:	e0bffa05 	stb	r2,-24(fp)
                 break;
81132ee8:	00000b06 	br	81132f18 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81132eec:	e03ffa05 	stb	zero,-24(fp)
                 break;
81132ef0:	00000906 	br	81132f18 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81132ef4:	00800044 	movi	r2,1
81132ef8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81132efc:	00800044 	movi	r2,1
81132f00:	d0a09a05 	stb	r2,-32152(gp)
                 break;
81132f04:	00000406 	br	81132f18 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81132f08:	00800044 	movi	r2,1
81132f0c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81132f10:	d0209a05 	stb	zero,-32152(gp)
                 break;
81132f14:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81132f18:	e0bffa03 	ldbu	r2,-24(fp)
81132f1c:	10005226 	beq	r2,zero,81133068 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81132f20:	d0a09917 	ldw	r2,-32156(gp)
81132f24:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81132f28:	00004906 	br	81133050 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132f2c:	0005303a 	rdctl	r2,status
81132f30:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132f34:	e0fffc17 	ldw	r3,-16(fp)
81132f38:	00bfff84 	movi	r2,-2
81132f3c:	1884703a 	and	r2,r3,r2
81132f40:	1001703a 	wrctl	status,r2
  
  return context;
81132f44:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81132f48:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81132f4c:	e0bff917 	ldw	r2,-28(fp)
81132f50:	10800b8b 	ldhu	r2,46(r2)
81132f54:	10bfffcc 	andi	r2,r2,65535
81132f58:	10003626 	beq	r2,zero,81133034 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81132f5c:	e0bff917 	ldw	r2,-28(fp)
81132f60:	10800b8b 	ldhu	r2,46(r2)
81132f64:	10bfffc4 	addi	r2,r2,-1
81132f68:	1007883a 	mov	r3,r2
81132f6c:	e0bff917 	ldw	r2,-28(fp)
81132f70:	10c00b8d 	sth	r3,46(r2)
81132f74:	e0bff917 	ldw	r2,-28(fp)
81132f78:	10800b8b 	ldhu	r2,46(r2)
81132f7c:	10bfffcc 	andi	r2,r2,65535
81132f80:	10002c1e 	bne	r2,zero,81133034 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81132f84:	e0bff917 	ldw	r2,-28(fp)
81132f88:	10800c03 	ldbu	r2,48(r2)
81132f8c:	10803fcc 	andi	r2,r2,255
81132f90:	10800dcc 	andi	r2,r2,55
81132f94:	10000b26 	beq	r2,zero,81132fc4 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81132f98:	e0bff917 	ldw	r2,-28(fp)
81132f9c:	10c00c03 	ldbu	r3,48(r2)
81132fa0:	00bff204 	movi	r2,-56
81132fa4:	1884703a 	and	r2,r3,r2
81132fa8:	1007883a 	mov	r3,r2
81132fac:	e0bff917 	ldw	r2,-28(fp)
81132fb0:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81132fb4:	e0bff917 	ldw	r2,-28(fp)
81132fb8:	00c00044 	movi	r3,1
81132fbc:	10c00c45 	stb	r3,49(r2)
81132fc0:	00000206 	br	81132fcc <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81132fc4:	e0bff917 	ldw	r2,-28(fp)
81132fc8:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81132fcc:	e0bff917 	ldw	r2,-28(fp)
81132fd0:	10800c03 	ldbu	r2,48(r2)
81132fd4:	10803fcc 	andi	r2,r2,255
81132fd8:	1080020c 	andi	r2,r2,8
81132fdc:	1000151e 	bne	r2,zero,81133034 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81132fe0:	e0bff917 	ldw	r2,-28(fp)
81132fe4:	10c00d83 	ldbu	r3,54(r2)
81132fe8:	d0a0a303 	ldbu	r2,-32116(gp)
81132fec:	1884b03a 	or	r2,r3,r2
81132ff0:	d0a0a305 	stb	r2,-32116(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81132ff4:	e0bff917 	ldw	r2,-28(fp)
81132ff8:	10800d03 	ldbu	r2,52(r2)
81132ffc:	10c03fcc 	andi	r3,r2,255
81133000:	e0bff917 	ldw	r2,-28(fp)
81133004:	10800d03 	ldbu	r2,52(r2)
81133008:	11003fcc 	andi	r4,r2,255
8113300c:	d0a0a344 	addi	r2,gp,-32115
81133010:	2085883a 	add	r2,r4,r2
81133014:	11000003 	ldbu	r4,0(r2)
81133018:	e0bff917 	ldw	r2,-28(fp)
8113301c:	10800d43 	ldbu	r2,53(r2)
81133020:	2084b03a 	or	r2,r4,r2
81133024:	1009883a 	mov	r4,r2
81133028:	d0a0a344 	addi	r2,gp,-32115
8113302c:	1885883a 	add	r2,r3,r2
81133030:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81133034:	e0bff917 	ldw	r2,-28(fp)
81133038:	10800517 	ldw	r2,20(r2)
8113303c:	e0bff915 	stw	r2,-28(fp)
81133040:	e0bffb17 	ldw	r2,-20(fp)
81133044:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133048:	e0bffe17 	ldw	r2,-8(fp)
8113304c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81133050:	e0bff917 	ldw	r2,-28(fp)
81133054:	10800c83 	ldbu	r2,50(r2)
81133058:	10803fcc 	andi	r2,r2,255
8113305c:	10800a18 	cmpnei	r2,r2,40
81133060:	103fb21e 	bne	r2,zero,81132f2c <__reset+0xfb112f2c>
81133064:	00000106 	br	8113306c <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81133068:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
8113306c:	e037883a 	mov	sp,fp
81133070:	dfc00117 	ldw	ra,4(sp)
81133074:	df000017 	ldw	fp,0(sp)
81133078:	dec00204 	addi	sp,sp,8
8113307c:	f800283a 	ret

81133080 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81133080:	deffff04 	addi	sp,sp,-4
81133084:	de00012e 	bgeu	sp,et,8113308c <OSVersion+0xc>
81133088:	003b68fa 	trap	3
8113308c:	df000015 	stw	fp,0(sp)
81133090:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81133094:	00804784 	movi	r2,286
}
81133098:	e037883a 	mov	sp,fp
8113309c:	df000017 	ldw	fp,0(sp)
811330a0:	dec00104 	addi	sp,sp,4
811330a4:	f800283a 	ret

811330a8 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
811330a8:	deffff04 	addi	sp,sp,-4
811330ac:	de00012e 	bgeu	sp,et,811330b4 <OS_Dummy+0xc>
811330b0:	003b68fa 	trap	3
811330b4:	df000015 	stw	fp,0(sp)
811330b8:	d839883a 	mov	fp,sp
}
811330bc:	0001883a 	nop
811330c0:	e037883a 	mov	sp,fp
811330c4:	df000017 	ldw	fp,0(sp)
811330c8:	dec00104 	addi	sp,sp,4
811330cc:	f800283a 	ret

811330d0 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
811330d0:	defff804 	addi	sp,sp,-32
811330d4:	de00012e 	bgeu	sp,et,811330dc <OS_EventTaskRdy+0xc>
811330d8:	003b68fa 	trap	3
811330dc:	dfc00715 	stw	ra,28(sp)
811330e0:	df000615 	stw	fp,24(sp)
811330e4:	df000604 	addi	fp,sp,24
811330e8:	e13ffc15 	stw	r4,-16(fp)
811330ec:	e17ffd15 	stw	r5,-12(fp)
811330f0:	3007883a 	mov	r3,r6
811330f4:	3805883a 	mov	r2,r7
811330f8:	e0fffe05 	stb	r3,-8(fp)
811330fc:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81133100:	e0bffc17 	ldw	r2,-16(fp)
81133104:	10800283 	ldbu	r2,10(r2)
81133108:	10c03fcc 	andi	r3,r2,255
8113310c:	00a04574 	movhi	r2,33045
81133110:	10a80d04 	addi	r2,r2,-24524
81133114:	10c5883a 	add	r2,r2,r3
81133118:	10800003 	ldbu	r2,0(r2)
8113311c:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
81133120:	e0bffa03 	ldbu	r2,-24(fp)
81133124:	e0fffc17 	ldw	r3,-16(fp)
81133128:	1885883a 	add	r2,r3,r2
8113312c:	108002c4 	addi	r2,r2,11
81133130:	10800003 	ldbu	r2,0(r2)
81133134:	10c03fcc 	andi	r3,r2,255
81133138:	00a04574 	movhi	r2,33045
8113313c:	10a80d04 	addi	r2,r2,-24524
81133140:	10c5883a 	add	r2,r2,r3
81133144:	10800003 	ldbu	r2,0(r2)
81133148:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
8113314c:	e0bffa03 	ldbu	r2,-24(fp)
81133150:	100490fa 	slli	r2,r2,3
81133154:	1007883a 	mov	r3,r2
81133158:	e0bffa43 	ldbu	r2,-23(fp)
8113315c:	1885883a 	add	r2,r3,r2
81133160:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81133164:	e0fffa83 	ldbu	r3,-22(fp)
81133168:	00a045b4 	movhi	r2,33046
8113316c:	1094cd04 	addi	r2,r2,21300
81133170:	18c7883a 	add	r3,r3,r3
81133174:	18c7883a 	add	r3,r3,r3
81133178:	10c5883a 	add	r2,r2,r3
8113317c:	10800017 	ldw	r2,0(r2)
81133180:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81133184:	e0bffb17 	ldw	r2,-20(fp)
81133188:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
8113318c:	e0bffb17 	ldw	r2,-20(fp)
81133190:	e0fffd17 	ldw	r3,-12(fp)
81133194:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81133198:	e0bffb17 	ldw	r2,-20(fp)
8113319c:	10800c03 	ldbu	r2,48(r2)
811331a0:	1007883a 	mov	r3,r2
811331a4:	e0bffe03 	ldbu	r2,-8(fp)
811331a8:	0084303a 	nor	r2,zero,r2
811331ac:	1884703a 	and	r2,r3,r2
811331b0:	1007883a 	mov	r3,r2
811331b4:	e0bffb17 	ldw	r2,-20(fp)
811331b8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
811331bc:	e0bffb17 	ldw	r2,-20(fp)
811331c0:	e0ffff03 	ldbu	r3,-4(fp)
811331c4:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
811331c8:	e0bffb17 	ldw	r2,-20(fp)
811331cc:	10800c03 	ldbu	r2,48(r2)
811331d0:	10803fcc 	andi	r2,r2,255
811331d4:	1080020c 	andi	r2,r2,8
811331d8:	1000111e 	bne	r2,zero,81133220 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
811331dc:	e0bffb17 	ldw	r2,-20(fp)
811331e0:	10c00d83 	ldbu	r3,54(r2)
811331e4:	d0a0a303 	ldbu	r2,-32116(gp)
811331e8:	1884b03a 	or	r2,r3,r2
811331ec:	d0a0a305 	stb	r2,-32116(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
811331f0:	e0fffa03 	ldbu	r3,-24(fp)
811331f4:	e13ffa03 	ldbu	r4,-24(fp)
811331f8:	d0a0a344 	addi	r2,gp,-32115
811331fc:	2085883a 	add	r2,r4,r2
81133200:	11000003 	ldbu	r4,0(r2)
81133204:	e0bffb17 	ldw	r2,-20(fp)
81133208:	10800d43 	ldbu	r2,53(r2)
8113320c:	2084b03a 	or	r2,r4,r2
81133210:	1009883a 	mov	r4,r2
81133214:	d0a0a344 	addi	r2,gp,-32115
81133218:	1885883a 	add	r2,r3,r2
8113321c:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
81133220:	e17ffc17 	ldw	r5,-16(fp)
81133224:	e13ffb17 	ldw	r4,-20(fp)
81133228:	11334e00 	call	811334e0 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
8113322c:	e0bffb17 	ldw	r2,-20(fp)
81133230:	10800817 	ldw	r2,32(r2)
81133234:	10000826 	beq	r2,zero,81133258 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81133238:	e0bffb17 	ldw	r2,-20(fp)
8113323c:	10800817 	ldw	r2,32(r2)
81133240:	100b883a 	mov	r5,r2
81133244:	e13ffb17 	ldw	r4,-20(fp)
81133248:	11335a00 	call	811335a0 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
8113324c:	e0bffb17 	ldw	r2,-20(fp)
81133250:	e0fffc17 	ldw	r3,-16(fp)
81133254:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81133258:	e0bffa83 	ldbu	r2,-22(fp)
}
8113325c:	e037883a 	mov	sp,fp
81133260:	dfc00117 	ldw	ra,4(sp)
81133264:	df000017 	ldw	fp,0(sp)
81133268:	dec00204 	addi	sp,sp,8
8113326c:	f800283a 	ret

81133270 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81133270:	defffd04 	addi	sp,sp,-12
81133274:	de00012e 	bgeu	sp,et,8113327c <OS_EventTaskWait+0xc>
81133278:	003b68fa 	trap	3
8113327c:	df000215 	stw	fp,8(sp)
81133280:	df000204 	addi	fp,sp,8
81133284:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81133288:	d0a0a717 	ldw	r2,-32100(gp)
8113328c:	e0ffff17 	ldw	r3,-4(fp)
81133290:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81133294:	d0a0a717 	ldw	r2,-32100(gp)
81133298:	10800d03 	ldbu	r2,52(r2)
8113329c:	10803fcc 	andi	r2,r2,255
811332a0:	d0e0a717 	ldw	r3,-32100(gp)
811332a4:	18c00d03 	ldbu	r3,52(r3)
811332a8:	18c03fcc 	andi	r3,r3,255
811332ac:	e13fff17 	ldw	r4,-4(fp)
811332b0:	20c7883a 	add	r3,r4,r3
811332b4:	18c002c4 	addi	r3,r3,11
811332b8:	19000003 	ldbu	r4,0(r3)
811332bc:	d0e0a717 	ldw	r3,-32100(gp)
811332c0:	18c00d43 	ldbu	r3,53(r3)
811332c4:	20c6b03a 	or	r3,r4,r3
811332c8:	1809883a 	mov	r4,r3
811332cc:	e0ffff17 	ldw	r3,-4(fp)
811332d0:	1885883a 	add	r2,r3,r2
811332d4:	108002c4 	addi	r2,r2,11
811332d8:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811332dc:	e0bfff17 	ldw	r2,-4(fp)
811332e0:	10c00283 	ldbu	r3,10(r2)
811332e4:	d0a0a717 	ldw	r2,-32100(gp)
811332e8:	10800d83 	ldbu	r2,54(r2)
811332ec:	1884b03a 	or	r2,r3,r2
811332f0:	1007883a 	mov	r3,r2
811332f4:	e0bfff17 	ldw	r2,-4(fp)
811332f8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
811332fc:	d0a0a717 	ldw	r2,-32100(gp)
81133300:	10800d03 	ldbu	r2,52(r2)
81133304:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81133308:	e0fffe03 	ldbu	r3,-8(fp)
8113330c:	e13ffe03 	ldbu	r4,-8(fp)
81133310:	d0a0a344 	addi	r2,gp,-32115
81133314:	2085883a 	add	r2,r4,r2
81133318:	10800003 	ldbu	r2,0(r2)
8113331c:	1009883a 	mov	r4,r2
81133320:	d0a0a717 	ldw	r2,-32100(gp)
81133324:	10800d43 	ldbu	r2,53(r2)
81133328:	0084303a 	nor	r2,zero,r2
8113332c:	2084703a 	and	r2,r4,r2
81133330:	1009883a 	mov	r4,r2
81133334:	d0a0a344 	addi	r2,gp,-32115
81133338:	1885883a 	add	r2,r3,r2
8113333c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81133340:	e0fffe03 	ldbu	r3,-8(fp)
81133344:	d0a0a344 	addi	r2,gp,-32115
81133348:	1885883a 	add	r2,r3,r2
8113334c:	10800003 	ldbu	r2,0(r2)
81133350:	10803fcc 	andi	r2,r2,255
81133354:	1000071e 	bne	r2,zero,81133374 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81133358:	d0a0a717 	ldw	r2,-32100(gp)
8113335c:	10800d83 	ldbu	r2,54(r2)
81133360:	0084303a 	nor	r2,zero,r2
81133364:	1007883a 	mov	r3,r2
81133368:	d0a0a303 	ldbu	r2,-32116(gp)
8113336c:	1884703a 	and	r2,r3,r2
81133370:	d0a0a305 	stb	r2,-32116(gp)
    }
}
81133374:	0001883a 	nop
81133378:	e037883a 	mov	sp,fp
8113337c:	df000017 	ldw	fp,0(sp)
81133380:	dec00104 	addi	sp,sp,4
81133384:	f800283a 	ret

81133388 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81133388:	defffb04 	addi	sp,sp,-20
8113338c:	de00012e 	bgeu	sp,et,81133394 <OS_EventTaskWaitMulti+0xc>
81133390:	003b68fa 	trap	3
81133394:	df000415 	stw	fp,16(sp)
81133398:	df000404 	addi	fp,sp,16
8113339c:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
811333a0:	d0a0a717 	ldw	r2,-32100(gp)
811333a4:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
811333a8:	d0a0a717 	ldw	r2,-32100(gp)
811333ac:	e0ffff17 	ldw	r3,-4(fp)
811333b0:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
811333b4:	e0bfff17 	ldw	r2,-4(fp)
811333b8:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
811333bc:	e0bffc17 	ldw	r2,-16(fp)
811333c0:	10800017 	ldw	r2,0(r2)
811333c4:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
811333c8:	00002006 	br	8113344c <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
811333cc:	d0a0a717 	ldw	r2,-32100(gp)
811333d0:	10800d03 	ldbu	r2,52(r2)
811333d4:	10803fcc 	andi	r2,r2,255
811333d8:	d0e0a717 	ldw	r3,-32100(gp)
811333dc:	18c00d03 	ldbu	r3,52(r3)
811333e0:	18c03fcc 	andi	r3,r3,255
811333e4:	e13ffd17 	ldw	r4,-12(fp)
811333e8:	20c7883a 	add	r3,r4,r3
811333ec:	18c002c4 	addi	r3,r3,11
811333f0:	19000003 	ldbu	r4,0(r3)
811333f4:	d0e0a717 	ldw	r3,-32100(gp)
811333f8:	18c00d43 	ldbu	r3,53(r3)
811333fc:	20c6b03a 	or	r3,r4,r3
81133400:	1809883a 	mov	r4,r3
81133404:	e0fffd17 	ldw	r3,-12(fp)
81133408:	1885883a 	add	r2,r3,r2
8113340c:	108002c4 	addi	r2,r2,11
81133410:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81133414:	e0bffd17 	ldw	r2,-12(fp)
81133418:	10c00283 	ldbu	r3,10(r2)
8113341c:	d0a0a717 	ldw	r2,-32100(gp)
81133420:	10800d83 	ldbu	r2,54(r2)
81133424:	1884b03a 	or	r2,r3,r2
81133428:	1007883a 	mov	r3,r2
8113342c:	e0bffd17 	ldw	r2,-12(fp)
81133430:	10c00285 	stb	r3,10(r2)
        pevents++;
81133434:	e0bffc17 	ldw	r2,-16(fp)
81133438:	10800104 	addi	r2,r2,4
8113343c:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
81133440:	e0bffc17 	ldw	r2,-16(fp)
81133444:	10800017 	ldw	r2,0(r2)
81133448:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
8113344c:	e0bffd17 	ldw	r2,-12(fp)
81133450:	103fde1e 	bne	r2,zero,811333cc <__reset+0xfb1133cc>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81133454:	d0a0a717 	ldw	r2,-32100(gp)
81133458:	10800d03 	ldbu	r2,52(r2)
8113345c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81133460:	e0fffe03 	ldbu	r3,-8(fp)
81133464:	e13ffe03 	ldbu	r4,-8(fp)
81133468:	d0a0a344 	addi	r2,gp,-32115
8113346c:	2085883a 	add	r2,r4,r2
81133470:	10800003 	ldbu	r2,0(r2)
81133474:	1009883a 	mov	r4,r2
81133478:	d0a0a717 	ldw	r2,-32100(gp)
8113347c:	10800d43 	ldbu	r2,53(r2)
81133480:	0084303a 	nor	r2,zero,r2
81133484:	2084703a 	and	r2,r4,r2
81133488:	1009883a 	mov	r4,r2
8113348c:	d0a0a344 	addi	r2,gp,-32115
81133490:	1885883a 	add	r2,r3,r2
81133494:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81133498:	e0fffe03 	ldbu	r3,-8(fp)
8113349c:	d0a0a344 	addi	r2,gp,-32115
811334a0:	1885883a 	add	r2,r3,r2
811334a4:	10800003 	ldbu	r2,0(r2)
811334a8:	10803fcc 	andi	r2,r2,255
811334ac:	1000071e 	bne	r2,zero,811334cc <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
811334b0:	d0a0a717 	ldw	r2,-32100(gp)
811334b4:	10800d83 	ldbu	r2,54(r2)
811334b8:	0084303a 	nor	r2,zero,r2
811334bc:	1007883a 	mov	r3,r2
811334c0:	d0a0a303 	ldbu	r2,-32116(gp)
811334c4:	1884703a 	and	r2,r3,r2
811334c8:	d0a0a305 	stb	r2,-32116(gp)
    }
}
811334cc:	0001883a 	nop
811334d0:	e037883a 	mov	sp,fp
811334d4:	df000017 	ldw	fp,0(sp)
811334d8:	dec00104 	addi	sp,sp,4
811334dc:	f800283a 	ret

811334e0 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
811334e0:	defffc04 	addi	sp,sp,-16
811334e4:	de00012e 	bgeu	sp,et,811334ec <OS_EventTaskRemove+0xc>
811334e8:	003b68fa 	trap	3
811334ec:	df000315 	stw	fp,12(sp)
811334f0:	df000304 	addi	fp,sp,12
811334f4:	e13ffe15 	stw	r4,-8(fp)
811334f8:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
811334fc:	e0bffe17 	ldw	r2,-8(fp)
81133500:	10800d03 	ldbu	r2,52(r2)
81133504:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81133508:	e0bffd03 	ldbu	r2,-12(fp)
8113350c:	e0fffd03 	ldbu	r3,-12(fp)
81133510:	e13fff17 	ldw	r4,-4(fp)
81133514:	20c7883a 	add	r3,r4,r3
81133518:	18c002c4 	addi	r3,r3,11
8113351c:	18c00003 	ldbu	r3,0(r3)
81133520:	1809883a 	mov	r4,r3
81133524:	e0fffe17 	ldw	r3,-8(fp)
81133528:	18c00d43 	ldbu	r3,53(r3)
8113352c:	00c6303a 	nor	r3,zero,r3
81133530:	20c6703a 	and	r3,r4,r3
81133534:	1809883a 	mov	r4,r3
81133538:	e0ffff17 	ldw	r3,-4(fp)
8113353c:	1885883a 	add	r2,r3,r2
81133540:	108002c4 	addi	r2,r2,11
81133544:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81133548:	e0bffd03 	ldbu	r2,-12(fp)
8113354c:	e0ffff17 	ldw	r3,-4(fp)
81133550:	1885883a 	add	r2,r3,r2
81133554:	108002c4 	addi	r2,r2,11
81133558:	10800003 	ldbu	r2,0(r2)
8113355c:	10803fcc 	andi	r2,r2,255
81133560:	10000a1e 	bne	r2,zero,8113358c <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81133564:	e0bfff17 	ldw	r2,-4(fp)
81133568:	10800283 	ldbu	r2,10(r2)
8113356c:	1007883a 	mov	r3,r2
81133570:	e0bffe17 	ldw	r2,-8(fp)
81133574:	10800d83 	ldbu	r2,54(r2)
81133578:	0084303a 	nor	r2,zero,r2
8113357c:	1884703a 	and	r2,r3,r2
81133580:	1007883a 	mov	r3,r2
81133584:	e0bfff17 	ldw	r2,-4(fp)
81133588:	10c00285 	stb	r3,10(r2)
    }
}
8113358c:	0001883a 	nop
81133590:	e037883a 	mov	sp,fp
81133594:	df000017 	ldw	fp,0(sp)
81133598:	dec00104 	addi	sp,sp,4
8113359c:	f800283a 	ret

811335a0 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
811335a0:	defffa04 	addi	sp,sp,-24
811335a4:	de00012e 	bgeu	sp,et,811335ac <OS_EventTaskRemoveMulti+0xc>
811335a8:	003b68fa 	trap	3
811335ac:	df000515 	stw	fp,20(sp)
811335b0:	df000504 	addi	fp,sp,20
811335b4:	e13ffe15 	stw	r4,-8(fp)
811335b8:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
811335bc:	e0bffe17 	ldw	r2,-8(fp)
811335c0:	10800d03 	ldbu	r2,52(r2)
811335c4:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
811335c8:	e0bffe17 	ldw	r2,-8(fp)
811335cc:	10800d83 	ldbu	r2,54(r2)
811335d0:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
811335d4:	e0bffe17 	ldw	r2,-8(fp)
811335d8:	10800d43 	ldbu	r2,53(r2)
811335dc:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
811335e0:	e0bfff17 	ldw	r2,-4(fp)
811335e4:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
811335e8:	e0bffb17 	ldw	r2,-20(fp)
811335ec:	10800017 	ldw	r2,0(r2)
811335f0:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811335f4:	00002506 	br	8113368c <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
811335f8:	e0bffd03 	ldbu	r2,-12(fp)
811335fc:	e0fffd03 	ldbu	r3,-12(fp)
81133600:	e13ffc17 	ldw	r4,-16(fp)
81133604:	20c7883a 	add	r3,r4,r3
81133608:	18c002c4 	addi	r3,r3,11
8113360c:	18c00003 	ldbu	r3,0(r3)
81133610:	1809883a 	mov	r4,r3
81133614:	e0fffd83 	ldbu	r3,-10(fp)
81133618:	00c6303a 	nor	r3,zero,r3
8113361c:	20c6703a 	and	r3,r4,r3
81133620:	1809883a 	mov	r4,r3
81133624:	e0fffc17 	ldw	r3,-16(fp)
81133628:	1885883a 	add	r2,r3,r2
8113362c:	108002c4 	addi	r2,r2,11
81133630:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81133634:	e0bffd03 	ldbu	r2,-12(fp)
81133638:	e0fffc17 	ldw	r3,-16(fp)
8113363c:	1885883a 	add	r2,r3,r2
81133640:	108002c4 	addi	r2,r2,11
81133644:	10800003 	ldbu	r2,0(r2)
81133648:	10803fcc 	andi	r2,r2,255
8113364c:	1000091e 	bne	r2,zero,81133674 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
81133650:	e0bffc17 	ldw	r2,-16(fp)
81133654:	10800283 	ldbu	r2,10(r2)
81133658:	1007883a 	mov	r3,r2
8113365c:	e0bffd43 	ldbu	r2,-11(fp)
81133660:	0084303a 	nor	r2,zero,r2
81133664:	1884703a 	and	r2,r3,r2
81133668:	1007883a 	mov	r3,r2
8113366c:	e0bffc17 	ldw	r2,-16(fp)
81133670:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
81133674:	e0bffb17 	ldw	r2,-20(fp)
81133678:	10800104 	addi	r2,r2,4
8113367c:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
81133680:	e0bffb17 	ldw	r2,-20(fp)
81133684:	10800017 	ldw	r2,0(r2)
81133688:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113368c:	e0bffc17 	ldw	r2,-16(fp)
81133690:	103fd91e 	bne	r2,zero,811335f8 <__reset+0xfb1135f8>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
81133694:	0001883a 	nop
81133698:	e037883a 	mov	sp,fp
8113369c:	df000017 	ldw	fp,0(sp)
811336a0:	dec00104 	addi	sp,sp,4
811336a4:	f800283a 	ret

811336a8 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
811336a8:	defffc04 	addi	sp,sp,-16
811336ac:	de00012e 	bgeu	sp,et,811336b4 <OS_EventWaitListInit+0xc>
811336b0:	003b68fa 	trap	3
811336b4:	df000315 	stw	fp,12(sp)
811336b8:	df000304 	addi	fp,sp,12
811336bc:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
811336c0:	e0bfff17 	ldw	r2,-4(fp)
811336c4:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
811336c8:	e0bfff17 	ldw	r2,-4(fp)
811336cc:	108002c4 	addi	r2,r2,11
811336d0:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811336d4:	e03ffe05 	stb	zero,-8(fp)
811336d8:	00000706 	br	811336f8 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
811336dc:	e0bffd17 	ldw	r2,-12(fp)
811336e0:	10c00044 	addi	r3,r2,1
811336e4:	e0fffd15 	stw	r3,-12(fp)
811336e8:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811336ec:	e0bffe03 	ldbu	r2,-8(fp)
811336f0:	10800044 	addi	r2,r2,1
811336f4:	e0bffe05 	stb	r2,-8(fp)
811336f8:	e0bffe03 	ldbu	r2,-8(fp)
811336fc:	108001b0 	cmpltui	r2,r2,6
81133700:	103ff61e 	bne	r2,zero,811336dc <__reset+0xfb1136dc>
        *ptbl++ = 0;
    }
}
81133704:	0001883a 	nop
81133708:	e037883a 	mov	sp,fp
8113370c:	df000017 	ldw	fp,0(sp)
81133710:	dec00104 	addi	sp,sp,4
81133714:	f800283a 	ret

81133718 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
81133718:	defffb04 	addi	sp,sp,-20
8113371c:	de00012e 	bgeu	sp,et,81133724 <OS_InitEventList+0xc>
81133720:	003b68fa 	trap	3
81133724:	dfc00415 	stw	ra,16(sp)
81133728:	df000315 	stw	fp,12(sp)
8113372c:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
81133730:	01434004 	movi	r5,3328
81133734:	012045b4 	movhi	r4,33046
81133738:	210df704 	addi	r4,r4,14300
8113373c:	1133ac00 	call	81133ac0 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
81133740:	00a045b4 	movhi	r2,33046
81133744:	108df704 	addi	r2,r2,14300
81133748:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
8113374c:	00a045b4 	movhi	r2,33046
81133750:	108e0404 	addi	r2,r2,14352
81133754:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81133758:	e03ffd0d 	sth	zero,-12(fp)
8113375c:	00001306 	br	811337ac <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
81133760:	e0bffe17 	ldw	r2,-8(fp)
81133764:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81133768:	e0bffe17 	ldw	r2,-8(fp)
8113376c:	e0ffff17 	ldw	r3,-4(fp)
81133770:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
81133774:	e0bffe17 	ldw	r2,-8(fp)
81133778:	00c00fc4 	movi	r3,63
8113377c:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
81133780:	e0bffe17 	ldw	r2,-8(fp)
81133784:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
81133788:	e0bffe17 	ldw	r2,-8(fp)
8113378c:	10800d04 	addi	r2,r2,52
81133790:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81133794:	e0bfff17 	ldw	r2,-4(fp)
81133798:	10800d04 	addi	r2,r2,52
8113379c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811337a0:	e0bffd0b 	ldhu	r2,-12(fp)
811337a4:	10800044 	addi	r2,r2,1
811337a8:	e0bffd0d 	sth	r2,-12(fp)
811337ac:	e0bffd0b 	ldhu	r2,-12(fp)
811337b0:	10800ff0 	cmpltui	r2,r2,63
811337b4:	103fea1e 	bne	r2,zero,81133760 <__reset+0xfb113760>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
811337b8:	e0bffe17 	ldw	r2,-8(fp)
811337bc:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
811337c0:	e0bffe17 	ldw	r2,-8(fp)
811337c4:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
811337c8:	e0bffe17 	ldw	r2,-8(fp)
811337cc:	00c00fc4 	movi	r3,63
811337d0:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
811337d4:	e0bffe17 	ldw	r2,-8(fp)
811337d8:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
811337dc:	00a045b4 	movhi	r2,33046
811337e0:	108df704 	addi	r2,r2,14300
811337e4:	d0a0a515 	stw	r2,-32108(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
811337e8:	0001883a 	nop
811337ec:	e037883a 	mov	sp,fp
811337f0:	dfc00117 	ldw	ra,4(sp)
811337f4:	df000017 	ldw	fp,0(sp)
811337f8:	dec00204 	addi	sp,sp,8
811337fc:	f800283a 	ret

81133800 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
81133800:	deffff04 	addi	sp,sp,-4
81133804:	de00012e 	bgeu	sp,et,8113380c <OS_InitMisc+0xc>
81133808:	003b68fa 	trap	3
8113380c:	df000015 	stw	fp,0(sp)
81133810:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81133814:	d020a915 	stw	zero,-32092(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81133818:	d020a605 	stb	zero,-32104(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
8113381c:	d0209405 	stb	zero,-32176(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
81133820:	d0209f45 	stb	zero,-32131(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81133824:	d0209605 	stb	zero,-32168(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81133828:	d0209b15 	stw	zero,-32148(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
8113382c:	d0209715 	stw	zero,-32164(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
81133830:	d020ad15 	stw	zero,-32076(gp)
    OSIdleCtrMax  = 0L;
81133834:	d0209d15 	stw	zero,-32140(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81133838:	d020ac05 	stb	zero,-32080(gp)
#endif
}
8113383c:	0001883a 	nop
81133840:	e037883a 	mov	sp,fp
81133844:	df000017 	ldw	fp,0(sp)
81133848:	dec00104 	addi	sp,sp,4
8113384c:	f800283a 	ret

81133850 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
81133850:	defffd04 	addi	sp,sp,-12
81133854:	de00012e 	bgeu	sp,et,8113385c <OS_InitRdyList+0xc>
81133858:	003b68fa 	trap	3
8113385c:	df000215 	stw	fp,8(sp)
81133860:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81133864:	d020a305 	stb	zero,-32116(gp)
    prdytbl       = &OSRdyTbl[0];
81133868:	d0a0a344 	addi	r2,gp,-32115
8113386c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81133870:	e03ffe05 	stb	zero,-8(fp)
81133874:	00000706 	br	81133894 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
81133878:	e0bfff17 	ldw	r2,-4(fp)
8113387c:	10c00044 	addi	r3,r2,1
81133880:	e0ffff15 	stw	r3,-4(fp)
81133884:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81133888:	e0bffe03 	ldbu	r2,-8(fp)
8113388c:	10800044 	addi	r2,r2,1
81133890:	e0bffe05 	stb	r2,-8(fp)
81133894:	e0bffe03 	ldbu	r2,-8(fp)
81133898:	108001b0 	cmpltui	r2,r2,6
8113389c:	103ff61e 	bne	r2,zero,81133878 <__reset+0xfb113878>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
811338a0:	d02098c5 	stb	zero,-32157(gp)
    OSPrioHighRdy = 0;
811338a4:	d0209885 	stb	zero,-32158(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
811338a8:	d020a115 	stw	zero,-32124(gp)
    OSTCBCur      = (OS_TCB *)0;
811338ac:	d020a715 	stw	zero,-32100(gp)
}
811338b0:	0001883a 	nop
811338b4:	e037883a 	mov	sp,fp
811338b8:	df000017 	ldw	fp,0(sp)
811338bc:	dec00104 	addi	sp,sp,4
811338c0:	f800283a 	ret

811338c4 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
811338c4:	defff804 	addi	sp,sp,-32
811338c8:	de00012e 	bgeu	sp,et,811338d0 <OS_InitTaskIdle+0xc>
811338cc:	003b68fa 	trap	3
811338d0:	dfc00715 	stw	ra,28(sp)
811338d4:	df000615 	stw	fp,24(sp)
811338d8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
811338dc:	008000c4 	movi	r2,3
811338e0:	d8800415 	stw	r2,16(sp)
811338e4:	d8000315 	stw	zero,12(sp)
811338e8:	00810004 	movi	r2,1024
811338ec:	d8800215 	stw	r2,8(sp)
811338f0:	00a045b4 	movhi	r2,33046
811338f4:	1089f704 	addi	r2,r2,10204
811338f8:	d8800115 	stw	r2,4(sp)
811338fc:	00bfffd4 	movui	r2,65535
81133900:	d8800015 	stw	r2,0(sp)
81133904:	01c00a04 	movi	r7,40
81133908:	01a045b4 	movhi	r6,33046
8113390c:	318df604 	addi	r6,r6,14296
81133910:	000b883a 	mov	r5,zero
81133914:	012044f4 	movhi	r4,33043
81133918:	210f6e04 	addi	r4,r4,15800
8113391c:	11395f40 	call	811395f4 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
81133920:	e1bfff04 	addi	r6,fp,-4
81133924:	01604574 	movhi	r5,33045
81133928:	29684d04 	addi	r5,r5,-24268
8113392c:	01000a04 	movi	r4,40
81133930:	1139e240 	call	81139e24 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81133934:	0001883a 	nop
81133938:	e037883a 	mov	sp,fp
8113393c:	dfc00117 	ldw	ra,4(sp)
81133940:	df000017 	ldw	fp,0(sp)
81133944:	dec00204 	addi	sp,sp,8
81133948:	f800283a 	ret

8113394c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
8113394c:	defff804 	addi	sp,sp,-32
81133950:	de00012e 	bgeu	sp,et,81133958 <OS_InitTaskStat+0xc>
81133954:	003b68fa 	trap	3
81133958:	dfc00715 	stw	ra,28(sp)
8113395c:	df000615 	stw	fp,24(sp)
81133960:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81133964:	008000c4 	movi	r2,3
81133968:	d8800415 	stw	r2,16(sp)
8113396c:	d8000315 	stw	zero,12(sp)
81133970:	00810004 	movi	r2,1024
81133974:	d8800215 	stw	r2,8(sp)
81133978:	00a045b4 	movhi	r2,33046
8113397c:	10839704 	addi	r2,r2,3676
81133980:	d8800115 	stw	r2,4(sp)
81133984:	00bfff94 	movui	r2,65534
81133988:	d8800015 	stw	r2,0(sp)
8113398c:	01c009c4 	movi	r7,39
81133990:	01a045b4 	movhi	r6,33046
81133994:	31879604 	addi	r6,r6,7768
81133998:	000b883a 	mov	r5,zero
8113399c:	012044f4 	movhi	r4,33043
811339a0:	210f8704 	addi	r4,r4,15900
811339a4:	11395f40 	call	811395f4 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
811339a8:	e1bfff04 	addi	r6,fp,-4
811339ac:	01604574 	movhi	r5,33045
811339b0:	29685104 	addi	r5,r5,-24252
811339b4:	010009c4 	movi	r4,39
811339b8:	1139e240 	call	81139e24 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
811339bc:	0001883a 	nop
811339c0:	e037883a 	mov	sp,fp
811339c4:	dfc00117 	ldw	ra,4(sp)
811339c8:	df000017 	ldw	fp,0(sp)
811339cc:	dec00204 	addi	sp,sp,8
811339d0:	f800283a 	ret

811339d4 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
811339d4:	defffb04 	addi	sp,sp,-20
811339d8:	de00012e 	bgeu	sp,et,811339e0 <OS_InitTCBList+0xc>
811339dc:	003b68fa 	trap	3
811339e0:	dfc00415 	stw	ra,16(sp)
811339e4:	df000315 	stw	fp,12(sp)
811339e8:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
811339ec:	01439604 	movi	r5,3672
811339f0:	012045b4 	movhi	r4,33046
811339f4:	21113704 	addi	r4,r4,17628
811339f8:	1133ac00 	call	81133ac0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
811339fc:	01402904 	movi	r5,164
81133a00:	012045b4 	movhi	r4,33046
81133a04:	2114cd04 	addi	r4,r4,21300
81133a08:	1133ac00 	call	81133ac0 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81133a0c:	00a045b4 	movhi	r2,33046
81133a10:	10913704 	addi	r2,r2,17628
81133a14:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81133a18:	00a045b4 	movhi	r2,33046
81133a1c:	10915204 	addi	r2,r2,17736
81133a20:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81133a24:	e03ffd05 	stb	zero,-12(fp)
81133a28:	00001106 	br	81133a70 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81133a2c:	e0bffe17 	ldw	r2,-8(fp)
81133a30:	e0ffff17 	ldw	r3,-4(fp)
81133a34:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81133a38:	e0bffe17 	ldw	r2,-8(fp)
81133a3c:	00c00fc4 	movi	r3,63
81133a40:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81133a44:	e0bffe17 	ldw	r2,-8(fp)
81133a48:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81133a4c:	e0bffe17 	ldw	r2,-8(fp)
81133a50:	10801b04 	addi	r2,r2,108
81133a54:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81133a58:	e0bfff17 	ldw	r2,-4(fp)
81133a5c:	10801b04 	addi	r2,r2,108
81133a60:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81133a64:	e0bffd03 	ldbu	r2,-12(fp)
81133a68:	10800044 	addi	r2,r2,1
81133a6c:	e0bffd05 	stb	r2,-12(fp)
81133a70:	e0bffd03 	ldbu	r2,-12(fp)
81133a74:	10800870 	cmpltui	r2,r2,33
81133a78:	103fec1e 	bne	r2,zero,81133a2c <__reset+0xfb113a2c>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81133a7c:	e0bffe17 	ldw	r2,-8(fp)
81133a80:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81133a84:	e0bffe17 	ldw	r2,-8(fp)
81133a88:	00c00fc4 	movi	r3,63
81133a8c:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81133a90:	e0bffe17 	ldw	r2,-8(fp)
81133a94:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81133a98:	d0209915 	stw	zero,-32156(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81133a9c:	00a045b4 	movhi	r2,33046
81133aa0:	10913704 	addi	r2,r2,17628
81133aa4:	d0a09e15 	stw	r2,-32136(gp)
}
81133aa8:	0001883a 	nop
81133aac:	e037883a 	mov	sp,fp
81133ab0:	dfc00117 	ldw	ra,4(sp)
81133ab4:	df000017 	ldw	fp,0(sp)
81133ab8:	dec00204 	addi	sp,sp,8
81133abc:	f800283a 	ret

81133ac0 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81133ac0:	defffd04 	addi	sp,sp,-12
81133ac4:	de00012e 	bgeu	sp,et,81133acc <OS_MemClr+0xc>
81133ac8:	003b68fa 	trap	3
81133acc:	df000215 	stw	fp,8(sp)
81133ad0:	df000204 	addi	fp,sp,8
81133ad4:	e13ffe15 	stw	r4,-8(fp)
81133ad8:	2805883a 	mov	r2,r5
81133adc:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81133ae0:	00000706 	br	81133b00 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81133ae4:	e0bffe17 	ldw	r2,-8(fp)
81133ae8:	10c00044 	addi	r3,r2,1
81133aec:	e0fffe15 	stw	r3,-8(fp)
81133af0:	10000005 	stb	zero,0(r2)
        size--;
81133af4:	e0bfff0b 	ldhu	r2,-4(fp)
81133af8:	10bfffc4 	addi	r2,r2,-1
81133afc:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81133b00:	e0bfff0b 	ldhu	r2,-4(fp)
81133b04:	103ff71e 	bne	r2,zero,81133ae4 <__reset+0xfb113ae4>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81133b08:	0001883a 	nop
81133b0c:	e037883a 	mov	sp,fp
81133b10:	df000017 	ldw	fp,0(sp)
81133b14:	dec00104 	addi	sp,sp,4
81133b18:	f800283a 	ret

81133b1c <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81133b1c:	defffc04 	addi	sp,sp,-16
81133b20:	de00012e 	bgeu	sp,et,81133b28 <OS_MemCopy+0xc>
81133b24:	003b68fa 	trap	3
81133b28:	df000315 	stw	fp,12(sp)
81133b2c:	df000304 	addi	fp,sp,12
81133b30:	e13ffd15 	stw	r4,-12(fp)
81133b34:	e17ffe15 	stw	r5,-8(fp)
81133b38:	3005883a 	mov	r2,r6
81133b3c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81133b40:	00000b06 	br	81133b70 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81133b44:	e0bffd17 	ldw	r2,-12(fp)
81133b48:	10c00044 	addi	r3,r2,1
81133b4c:	e0fffd15 	stw	r3,-12(fp)
81133b50:	e0fffe17 	ldw	r3,-8(fp)
81133b54:	19000044 	addi	r4,r3,1
81133b58:	e13ffe15 	stw	r4,-8(fp)
81133b5c:	18c00003 	ldbu	r3,0(r3)
81133b60:	10c00005 	stb	r3,0(r2)
        size--;
81133b64:	e0bfff0b 	ldhu	r2,-4(fp)
81133b68:	10bfffc4 	addi	r2,r2,-1
81133b6c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81133b70:	e0bfff0b 	ldhu	r2,-4(fp)
81133b74:	103ff31e 	bne	r2,zero,81133b44 <__reset+0xfb113b44>
        *pdest++ = *psrc++;
        size--;
    }
}
81133b78:	0001883a 	nop
81133b7c:	e037883a 	mov	sp,fp
81133b80:	df000017 	ldw	fp,0(sp)
81133b84:	dec00104 	addi	sp,sp,4
81133b88:	f800283a 	ret

81133b8c <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81133b8c:	defffb04 	addi	sp,sp,-20
81133b90:	de00012e 	bgeu	sp,et,81133b98 <OS_Sched+0xc>
81133b94:	003b68fa 	trap	3
81133b98:	dfc00415 	stw	ra,16(sp)
81133b9c:	df000315 	stw	fp,12(sp)
81133ba0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81133ba4:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133ba8:	0005303a 	rdctl	r2,status
81133bac:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133bb0:	e0ffff17 	ldw	r3,-4(fp)
81133bb4:	00bfff84 	movi	r2,-2
81133bb8:	1884703a 	and	r2,r3,r2
81133bbc:	1001703a 	wrctl	status,r2
  
  return context;
81133bc0:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81133bc4:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81133bc8:	d0a0a603 	ldbu	r2,-32104(gp)
81133bcc:	10803fcc 	andi	r2,r2,255
81133bd0:	10001a1e 	bne	r2,zero,81133c3c <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81133bd4:	d0a09403 	ldbu	r2,-32176(gp)
81133bd8:	10803fcc 	andi	r2,r2,255
81133bdc:	1000171e 	bne	r2,zero,81133c3c <OS_Sched+0xb0>
            OS_SchedNew();
81133be0:	1133c640 	call	81133c64 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81133be4:	d0e09883 	ldbu	r3,-32158(gp)
81133be8:	d0a098c3 	ldbu	r2,-32157(gp)
81133bec:	18c03fcc 	andi	r3,r3,255
81133bf0:	10803fcc 	andi	r2,r2,255
81133bf4:	18801126 	beq	r3,r2,81133c3c <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81133bf8:	d0a09883 	ldbu	r2,-32158(gp)
81133bfc:	10c03fcc 	andi	r3,r2,255
81133c00:	00a045b4 	movhi	r2,33046
81133c04:	1094cd04 	addi	r2,r2,21300
81133c08:	18c7883a 	add	r3,r3,r3
81133c0c:	18c7883a 	add	r3,r3,r3
81133c10:	10c5883a 	add	r2,r2,r3
81133c14:	10800017 	ldw	r2,0(r2)
81133c18:	d0a0a115 	stw	r2,-32124(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81133c1c:	d0a0a117 	ldw	r2,-32124(gp)
81133c20:	10c00e17 	ldw	r3,56(r2)
81133c24:	18c00044 	addi	r3,r3,1
81133c28:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81133c2c:	d0a09b17 	ldw	r2,-32148(gp)
81133c30:	10800044 	addi	r2,r2,1
81133c34:	d0a09b15 	stw	r2,-32148(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81133c38:	1144a080 	call	81144a08 <OSCtxSw>
81133c3c:	e0bffd17 	ldw	r2,-12(fp)
81133c40:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133c44:	e0bffe17 	ldw	r2,-8(fp)
81133c48:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81133c4c:	0001883a 	nop
81133c50:	e037883a 	mov	sp,fp
81133c54:	dfc00117 	ldw	ra,4(sp)
81133c58:	df000017 	ldw	fp,0(sp)
81133c5c:	dec00204 	addi	sp,sp,8
81133c60:	f800283a 	ret

81133c64 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81133c64:	defffe04 	addi	sp,sp,-8
81133c68:	de00012e 	bgeu	sp,et,81133c70 <OS_SchedNew+0xc>
81133c6c:	003b68fa 	trap	3
81133c70:	df000115 	stw	fp,4(sp)
81133c74:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81133c78:	d0a0a303 	ldbu	r2,-32116(gp)
81133c7c:	10c03fcc 	andi	r3,r2,255
81133c80:	00a04574 	movhi	r2,33045
81133c84:	10a80d04 	addi	r2,r2,-24524
81133c88:	10c5883a 	add	r2,r2,r3
81133c8c:	10800003 	ldbu	r2,0(r2)
81133c90:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81133c94:	e0bfff03 	ldbu	r2,-4(fp)
81133c98:	100490fa 	slli	r2,r2,3
81133c9c:	1009883a 	mov	r4,r2
81133ca0:	e0ffff03 	ldbu	r3,-4(fp)
81133ca4:	d0a0a344 	addi	r2,gp,-32115
81133ca8:	1885883a 	add	r2,r3,r2
81133cac:	10800003 	ldbu	r2,0(r2)
81133cb0:	10c03fcc 	andi	r3,r2,255
81133cb4:	00a04574 	movhi	r2,33045
81133cb8:	10a80d04 	addi	r2,r2,-24524
81133cbc:	10c5883a 	add	r2,r2,r3
81133cc0:	10800003 	ldbu	r2,0(r2)
81133cc4:	2085883a 	add	r2,r4,r2
81133cc8:	d0a09885 	stb	r2,-32158(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81133ccc:	0001883a 	nop
81133cd0:	e037883a 	mov	sp,fp
81133cd4:	df000017 	ldw	fp,0(sp)
81133cd8:	dec00104 	addi	sp,sp,4
81133cdc:	f800283a 	ret

81133ce0 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81133ce0:	defffc04 	addi	sp,sp,-16
81133ce4:	de00012e 	bgeu	sp,et,81133cec <OS_StrCopy+0xc>
81133ce8:	003b68fa 	trap	3
81133cec:	df000315 	stw	fp,12(sp)
81133cf0:	df000304 	addi	fp,sp,12
81133cf4:	e13ffe15 	stw	r4,-8(fp)
81133cf8:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81133cfc:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81133d00:	00000b06 	br	81133d30 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81133d04:	e0bffe17 	ldw	r2,-8(fp)
81133d08:	10c00044 	addi	r3,r2,1
81133d0c:	e0fffe15 	stw	r3,-8(fp)
81133d10:	e0ffff17 	ldw	r3,-4(fp)
81133d14:	19000044 	addi	r4,r3,1
81133d18:	e13fff15 	stw	r4,-4(fp)
81133d1c:	18c00003 	ldbu	r3,0(r3)
81133d20:	10c00005 	stb	r3,0(r2)
        len++;
81133d24:	e0bffd03 	ldbu	r2,-12(fp)
81133d28:	10800044 	addi	r2,r2,1
81133d2c:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81133d30:	e0bfff17 	ldw	r2,-4(fp)
81133d34:	10800003 	ldbu	r2,0(r2)
81133d38:	10803fcc 	andi	r2,r2,255
81133d3c:	103ff11e 	bne	r2,zero,81133d04 <__reset+0xfb113d04>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81133d40:	e0bffe17 	ldw	r2,-8(fp)
81133d44:	10000005 	stb	zero,0(r2)
    return (len);
81133d48:	e0bffd03 	ldbu	r2,-12(fp)
}
81133d4c:	e037883a 	mov	sp,fp
81133d50:	df000017 	ldw	fp,0(sp)
81133d54:	dec00104 	addi	sp,sp,4
81133d58:	f800283a 	ret

81133d5c <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81133d5c:	defffd04 	addi	sp,sp,-12
81133d60:	de00012e 	bgeu	sp,et,81133d68 <OS_StrLen+0xc>
81133d64:	003b68fa 	trap	3
81133d68:	df000215 	stw	fp,8(sp)
81133d6c:	df000204 	addi	fp,sp,8
81133d70:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81133d74:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81133d78:	00000606 	br	81133d94 <OS_StrLen+0x38>
        psrc++;
81133d7c:	e0bfff17 	ldw	r2,-4(fp)
81133d80:	10800044 	addi	r2,r2,1
81133d84:	e0bfff15 	stw	r2,-4(fp)
        len++;
81133d88:	e0bffe03 	ldbu	r2,-8(fp)
81133d8c:	10800044 	addi	r2,r2,1
81133d90:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81133d94:	e0bfff17 	ldw	r2,-4(fp)
81133d98:	10800003 	ldbu	r2,0(r2)
81133d9c:	10803fcc 	andi	r2,r2,255
81133da0:	103ff61e 	bne	r2,zero,81133d7c <__reset+0xfb113d7c>
        psrc++;
        len++;
    }
    return (len);
81133da4:	e0bffe03 	ldbu	r2,-8(fp)
}
81133da8:	e037883a 	mov	sp,fp
81133dac:	df000017 	ldw	fp,0(sp)
81133db0:	dec00104 	addi	sp,sp,4
81133db4:	f800283a 	ret

81133db8 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81133db8:	defffa04 	addi	sp,sp,-24
81133dbc:	de00012e 	bgeu	sp,et,81133dc4 <OS_TaskIdle+0xc>
81133dc0:	003b68fa 	trap	3
81133dc4:	dfc00515 	stw	ra,20(sp)
81133dc8:	df000415 	stw	fp,16(sp)
81133dcc:	df000404 	addi	fp,sp,16
81133dd0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133dd4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133dd8:	0005303a 	rdctl	r2,status
81133ddc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133de0:	e0fffd17 	ldw	r3,-12(fp)
81133de4:	00bfff84 	movi	r2,-2
81133de8:	1884703a 	and	r2,r3,r2
81133dec:	1001703a 	wrctl	status,r2
  
  return context;
81133df0:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81133df4:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81133df8:	d0a09717 	ldw	r2,-32164(gp)
81133dfc:	10800044 	addi	r2,r2,1
81133e00:	d0a09715 	stw	r2,-32164(gp)
81133e04:	e0bffc17 	ldw	r2,-16(fp)
81133e08:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133e0c:	e0bffe17 	ldw	r2,-8(fp)
81133e10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81133e14:	1144d9c0 	call	81144d9c <OSTaskIdleHook>
    }
81133e18:	003fef06 	br	81133dd8 <__reset+0xfb113dd8>

81133e1c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81133e1c:	defff804 	addi	sp,sp,-32
81133e20:	de00012e 	bgeu	sp,et,81133e28 <OS_TaskStat+0xc>
81133e24:	003b68fa 	trap	3
81133e28:	dfc00715 	stw	ra,28(sp)
81133e2c:	df000615 	stw	fp,24(sp)
81133e30:	dc400515 	stw	r17,20(sp)
81133e34:	dc000415 	stw	r16,16(sp)
81133e38:	df000604 	addi	fp,sp,24
81133e3c:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133e40:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81133e44:	00000206 	br	81133e50 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81133e48:	01003204 	movi	r4,200
81133e4c:	113a7140 	call	8113a714 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81133e50:	d0a0ac03 	ldbu	r2,-32080(gp)
81133e54:	10803fcc 	andi	r2,r2,255
81133e58:	103ffb26 	beq	r2,zero,81133e48 <__reset+0xfb113e48>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81133e5c:	d0e09d17 	ldw	r3,-32140(gp)
81133e60:	00947b34 	movhi	r2,20972
81133e64:	10a147c4 	addi	r2,r2,-31457
81133e68:	1888383a 	mulxuu	r4,r3,r2
81133e6c:	1885383a 	mul	r2,r3,r2
81133e70:	1021883a 	mov	r16,r2
81133e74:	2023883a 	mov	r17,r4
81133e78:	8804d17a 	srli	r2,r17,5
81133e7c:	d0a09d15 	stw	r2,-32140(gp)
    if (OSIdleCtrMax == 0L) {
81133e80:	d0a09d17 	ldw	r2,-32140(gp)
81133e84:	1000031e 	bne	r2,zero,81133e94 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81133e88:	d0209f05 	stb	zero,-32132(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81133e8c:	01003fc4 	movi	r4,255
81133e90:	113a3840 	call	8113a384 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133e94:	0005303a 	rdctl	r2,status
81133e98:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133e9c:	e0fffb17 	ldw	r3,-20(fp)
81133ea0:	00bfff84 	movi	r2,-2
81133ea4:	1884703a 	and	r2,r3,r2
81133ea8:	1001703a 	wrctl	status,r2
  
  return context;
81133eac:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81133eb0:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81133eb4:	d0a09717 	ldw	r2,-32164(gp)
81133eb8:	d0a0ad15 	stw	r2,-32076(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81133ebc:	d0209715 	stw	zero,-32164(gp)
81133ec0:	e0bffa17 	ldw	r2,-24(fp)
81133ec4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133ec8:	e0bffc17 	ldw	r2,-16(fp)
81133ecc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81133ed0:	d0e0ad17 	ldw	r3,-32076(gp)
81133ed4:	d0a09d17 	ldw	r2,-32140(gp)
81133ed8:	1885203a 	divu	r2,r3,r2
81133edc:	1007883a 	mov	r3,r2
81133ee0:	00801904 	movi	r2,100
81133ee4:	10c5c83a 	sub	r2,r2,r3
81133ee8:	d0a09f05 	stb	r2,-32132(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81133eec:	1144ccc0 	call	81144ccc <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81133ef0:	1133f000 	call	81133f00 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81133ef4:	01001904 	movi	r4,100
81133ef8:	113a7140 	call	8113a714 <OSTimeDly>
    }
81133efc:	003fe506 	br	81133e94 <__reset+0xfb113e94>

81133f00 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81133f00:	defffa04 	addi	sp,sp,-24
81133f04:	de00012e 	bgeu	sp,et,81133f0c <OS_TaskStatStkChk+0xc>
81133f08:	003b68fa 	trap	3
81133f0c:	dfc00515 	stw	ra,20(sp)
81133f10:	df000415 	stw	fp,16(sp)
81133f14:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81133f18:	e03ffc05 	stb	zero,-16(fp)
81133f1c:	00002406 	br	81133fb0 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81133f20:	e0bffc03 	ldbu	r2,-16(fp)
81133f24:	e0fffe04 	addi	r3,fp,-8
81133f28:	180b883a 	mov	r5,r3
81133f2c:	1009883a 	mov	r4,r2
81133f30:	113a1bc0 	call	8113a1bc <OSTaskStkChk>
81133f34:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81133f38:	e0bffc43 	ldbu	r2,-15(fp)
81133f3c:	1000191e 	bne	r2,zero,81133fa4 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
81133f40:	e0fffc03 	ldbu	r3,-16(fp)
81133f44:	00a045b4 	movhi	r2,33046
81133f48:	1094cd04 	addi	r2,r2,21300
81133f4c:	18c7883a 	add	r3,r3,r3
81133f50:	18c7883a 	add	r3,r3,r3
81133f54:	10c5883a 	add	r2,r2,r3
81133f58:	10800017 	ldw	r2,0(r2)
81133f5c:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
81133f60:	e0bffd17 	ldw	r2,-12(fp)
81133f64:	10000f26 	beq	r2,zero,81133fa4 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81133f68:	e0bffd17 	ldw	r2,-12(fp)
81133f6c:	10800060 	cmpeqi	r2,r2,1
81133f70:	10000c1e 	bne	r2,zero,81133fa4 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81133f74:	e0bffd17 	ldw	r2,-12(fp)
81133f78:	10c00217 	ldw	r3,8(r2)
81133f7c:	e0bffd17 	ldw	r2,-12(fp)
81133f80:	10800317 	ldw	r2,12(r2)
81133f84:	1085883a 	add	r2,r2,r2
81133f88:	1085883a 	add	r2,r2,r2
81133f8c:	1887883a 	add	r3,r3,r2
81133f90:	e0bffd17 	ldw	r2,-12(fp)
81133f94:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81133f98:	e0ffff17 	ldw	r3,-4(fp)
81133f9c:	e0bffd17 	ldw	r2,-12(fp)
81133fa0:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81133fa4:	e0bffc03 	ldbu	r2,-16(fp)
81133fa8:	10800044 	addi	r2,r2,1
81133fac:	e0bffc05 	stb	r2,-16(fp)
81133fb0:	e0bffc03 	ldbu	r2,-16(fp)
81133fb4:	10800a70 	cmpltui	r2,r2,41
81133fb8:	103fd91e 	bne	r2,zero,81133f20 <__reset+0xfb113f20>
#endif
                }
            }
        }
    }
}
81133fbc:	0001883a 	nop
81133fc0:	e037883a 	mov	sp,fp
81133fc4:	dfc00117 	ldw	ra,4(sp)
81133fc8:	df000017 	ldw	fp,0(sp)
81133fcc:	dec00204 	addi	sp,sp,8
81133fd0:	f800283a 	ret

81133fd4 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81133fd4:	defff204 	addi	sp,sp,-56
81133fd8:	de00012e 	bgeu	sp,et,81133fe0 <OS_TCBInit+0xc>
81133fdc:	003b68fa 	trap	3
81133fe0:	dfc00d15 	stw	ra,52(sp)
81133fe4:	df000c15 	stw	fp,48(sp)
81133fe8:	df000c04 	addi	fp,sp,48
81133fec:	e17ffc15 	stw	r5,-16(fp)
81133ff0:	e1bffd15 	stw	r6,-12(fp)
81133ff4:	3807883a 	mov	r3,r7
81133ff8:	e0800417 	ldw	r2,16(fp)
81133ffc:	e13ffb05 	stb	r4,-20(fp)
81134000:	e0fffe0d 	sth	r3,-8(fp)
81134004:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134008:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113400c:	0005303a 	rdctl	r2,status
81134010:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134014:	e0fffa17 	ldw	r3,-24(fp)
81134018:	00bfff84 	movi	r2,-2
8113401c:	1884703a 	and	r2,r3,r2
81134020:	1001703a 	wrctl	status,r2
  
  return context;
81134024:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81134028:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
8113402c:	d0a09e17 	ldw	r2,-32136(gp)
81134030:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81134034:	e0bff617 	ldw	r2,-40(fp)
81134038:	10009326 	beq	r2,zero,81134288 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
8113403c:	e0bff617 	ldw	r2,-40(fp)
81134040:	10800517 	ldw	r2,20(r2)
81134044:	d0a09e15 	stw	r2,-32136(gp)
81134048:	e0bff417 	ldw	r2,-48(fp)
8113404c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134050:	e0bff817 	ldw	r2,-32(fp)
81134054:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81134058:	e0bff617 	ldw	r2,-40(fp)
8113405c:	e0fffc17 	ldw	r3,-16(fp)
81134060:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81134064:	e0bff617 	ldw	r2,-40(fp)
81134068:	e0fffb03 	ldbu	r3,-20(fp)
8113406c:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81134070:	e0bff617 	ldw	r2,-40(fp)
81134074:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81134078:	e0bff617 	ldw	r2,-40(fp)
8113407c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81134080:	e0bff617 	ldw	r2,-40(fp)
81134084:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81134088:	e0bff617 	ldw	r2,-40(fp)
8113408c:	e0c00317 	ldw	r3,12(fp)
81134090:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81134094:	e0bff617 	ldw	r2,-40(fp)
81134098:	e0c00217 	ldw	r3,8(fp)
8113409c:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
811340a0:	e0bff617 	ldw	r2,-40(fp)
811340a4:	e0fffd17 	ldw	r3,-12(fp)
811340a8:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
811340ac:	e0bff617 	ldw	r2,-40(fp)
811340b0:	e0ffff0b 	ldhu	r3,-4(fp)
811340b4:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
811340b8:	e0bff617 	ldw	r2,-40(fp)
811340bc:	e0fffe0b 	ldhu	r3,-8(fp)
811340c0:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
811340c4:	e0bff617 	ldw	r2,-40(fp)
811340c8:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
811340cc:	e0bffb03 	ldbu	r2,-20(fp)
811340d0:	1004d0fa 	srli	r2,r2,3
811340d4:	1007883a 	mov	r3,r2
811340d8:	e0bff617 	ldw	r2,-40(fp)
811340dc:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
811340e0:	e0bffb03 	ldbu	r2,-20(fp)
811340e4:	108001cc 	andi	r2,r2,7
811340e8:	1007883a 	mov	r3,r2
811340ec:	e0bff617 	ldw	r2,-40(fp)
811340f0:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
811340f4:	e0bff617 	ldw	r2,-40(fp)
811340f8:	10800d03 	ldbu	r2,52(r2)
811340fc:	10803fcc 	andi	r2,r2,255
81134100:	00c00044 	movi	r3,1
81134104:	1884983a 	sll	r2,r3,r2
81134108:	1007883a 	mov	r3,r2
8113410c:	e0bff617 	ldw	r2,-40(fp)
81134110:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81134114:	e0bff617 	ldw	r2,-40(fp)
81134118:	10800cc3 	ldbu	r2,51(r2)
8113411c:	10803fcc 	andi	r2,r2,255
81134120:	00c00044 	movi	r3,1
81134124:	1884983a 	sll	r2,r3,r2
81134128:	1007883a 	mov	r3,r2
8113412c:	e0bff617 	ldw	r2,-40(fp)
81134130:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81134134:	e0bff617 	ldw	r2,-40(fp)
81134138:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
8113413c:	e0bff617 	ldw	r2,-40(fp)
81134140:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81134144:	e0bff617 	ldw	r2,-40(fp)
81134148:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
8113414c:	e0bff617 	ldw	r2,-40(fp)
81134150:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81134154:	e0bff617 	ldw	r2,-40(fp)
81134158:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
8113415c:	e0bff617 	ldw	r2,-40(fp)
81134160:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81134164:	e0bff617 	ldw	r2,-40(fp)
81134168:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
8113416c:	e0bff617 	ldw	r2,-40(fp)
81134170:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81134174:	e0bff617 	ldw	r2,-40(fp)
81134178:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
8113417c:	e0bff617 	ldw	r2,-40(fp)
81134180:	00c00fc4 	movi	r3,63
81134184:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81134188:	e0bff617 	ldw	r2,-40(fp)
8113418c:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81134190:	e13ff617 	ldw	r4,-40(fp)
81134194:	1144dc40 	call	81144dc4 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81134198:	e13ff617 	ldw	r4,-40(fp)
8113419c:	1144c4c0 	call	81144c4c <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811341a0:	0005303a 	rdctl	r2,status
811341a4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811341a8:	e0fff517 	ldw	r3,-44(fp)
811341ac:	00bfff84 	movi	r2,-2
811341b0:	1884703a 	and	r2,r3,r2
811341b4:	1001703a 	wrctl	status,r2
  
  return context;
811341b8:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
811341bc:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
811341c0:	e0fffb03 	ldbu	r3,-20(fp)
811341c4:	00a045b4 	movhi	r2,33046
811341c8:	1094cd04 	addi	r2,r2,21300
811341cc:	18c7883a 	add	r3,r3,r3
811341d0:	18c7883a 	add	r3,r3,r3
811341d4:	10c5883a 	add	r2,r2,r3
811341d8:	e0fff617 	ldw	r3,-40(fp)
811341dc:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
811341e0:	d0e09917 	ldw	r3,-32156(gp)
811341e4:	e0bff617 	ldw	r2,-40(fp)
811341e8:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
811341ec:	e0bff617 	ldw	r2,-40(fp)
811341f0:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
811341f4:	d0a09917 	ldw	r2,-32156(gp)
811341f8:	10000326 	beq	r2,zero,81134208 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
811341fc:	d0a09917 	ldw	r2,-32156(gp)
81134200:	e0fff617 	ldw	r3,-40(fp)
81134204:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
81134208:	e0bff617 	ldw	r2,-40(fp)
8113420c:	d0a09915 	stw	r2,-32156(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
81134210:	e0bff617 	ldw	r2,-40(fp)
81134214:	10c00d83 	ldbu	r3,54(r2)
81134218:	d0a0a303 	ldbu	r2,-32116(gp)
8113421c:	1884b03a 	or	r2,r3,r2
81134220:	d0a0a305 	stb	r2,-32116(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81134224:	e0bff617 	ldw	r2,-40(fp)
81134228:	10800d03 	ldbu	r2,52(r2)
8113422c:	10c03fcc 	andi	r3,r2,255
81134230:	e0bff617 	ldw	r2,-40(fp)
81134234:	10800d03 	ldbu	r2,52(r2)
81134238:	11003fcc 	andi	r4,r2,255
8113423c:	d0a0a344 	addi	r2,gp,-32115
81134240:	2085883a 	add	r2,r4,r2
81134244:	11000003 	ldbu	r4,0(r2)
81134248:	e0bff617 	ldw	r2,-40(fp)
8113424c:	10800d43 	ldbu	r2,53(r2)
81134250:	2084b03a 	or	r2,r4,r2
81134254:	1009883a 	mov	r4,r2
81134258:	d0a0a344 	addi	r2,gp,-32115
8113425c:	1885883a 	add	r2,r3,r2
81134260:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81134264:	d0a09f43 	ldbu	r2,-32131(gp)
81134268:	10800044 	addi	r2,r2,1
8113426c:	d0a09f45 	stb	r2,-32131(gp)
81134270:	e0bff417 	ldw	r2,-48(fp)
81134274:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134278:	e0bff717 	ldw	r2,-36(fp)
8113427c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81134280:	0005883a 	mov	r2,zero
81134284:	00000506 	br	8113429c <OS_TCBInit+0x2c8>
81134288:	e0bff417 	ldw	r2,-48(fp)
8113428c:	e0bff915 	stw	r2,-28(fp)
81134290:	e0bff917 	ldw	r2,-28(fp)
81134294:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81134298:	00801084 	movi	r2,66
}
8113429c:	e037883a 	mov	sp,fp
811342a0:	dfc00117 	ldw	ra,4(sp)
811342a4:	df000017 	ldw	fp,0(sp)
811342a8:	dec00204 	addi	sp,sp,8
811342ac:	f800283a 	ret

811342b0 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
811342b0:	defffe04 	addi	sp,sp,-8
811342b4:	de00012e 	bgeu	sp,et,811342bc <OSDebugInit+0xc>
811342b8:	003b68fa 	trap	3
811342bc:	df000115 	stw	fp,4(sp)
811342c0:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
811342c4:	d0a01804 	addi	r2,gp,-32672
811342c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
811342cc:	d0a01904 	addi	r2,gp,-32668
811342d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
811342d4:	d0a01a84 	addi	r2,gp,-32662
811342d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
811342dc:	d0a01b04 	addi	r2,gp,-32660
811342e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
811342e4:	d0a01a04 	addi	r2,gp,-32664
811342e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
811342ec:	d0a01b84 	addi	r2,gp,-32658
811342f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
811342f4:	d0a01c04 	addi	r2,gp,-32656
811342f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
811342fc:	d0a01c84 	addi	r2,gp,-32654
81134300:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81134304:	d0a01d04 	addi	r2,gp,-32652
81134308:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
8113430c:	d0a01d84 	addi	r2,gp,-32650
81134310:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81134314:	d0a01e04 	addi	r2,gp,-32648
81134318:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
8113431c:	d0a01e84 	addi	r2,gp,-32646
81134320:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81134324:	d0a01f04 	addi	r2,gp,-32644
81134328:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
8113432c:	d0a01f84 	addi	r2,gp,-32642
81134330:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81134334:	d0a02004 	addi	r2,gp,-32640
81134338:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
8113433c:	d0a02084 	addi	r2,gp,-32638
81134340:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81134344:	d0a02104 	addi	r2,gp,-32636
81134348:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
8113434c:	d0a02184 	addi	r2,gp,-32634
81134350:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81134354:	d0a02204 	addi	r2,gp,-32632
81134358:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
8113435c:	d0a02284 	addi	r2,gp,-32630
81134360:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81134364:	d0a02304 	addi	r2,gp,-32628
81134368:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
8113436c:	d0a02384 	addi	r2,gp,-32626
81134370:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81134374:	d0a02404 	addi	r2,gp,-32624
81134378:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
8113437c:	d0a02484 	addi	r2,gp,-32622
81134380:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81134384:	d0a02504 	addi	r2,gp,-32620
81134388:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
8113438c:	d0a02584 	addi	r2,gp,-32618
81134390:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81134394:	d0a02604 	addi	r2,gp,-32616
81134398:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
8113439c:	d0a02684 	addi	r2,gp,-32614
811343a0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
811343a4:	d0a02704 	addi	r2,gp,-32612
811343a8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
811343ac:	d0a02784 	addi	r2,gp,-32610
811343b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
811343b4:	d0a02804 	addi	r2,gp,-32608
811343b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
811343bc:	d0a02884 	addi	r2,gp,-32606
811343c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
811343c4:	d0a02904 	addi	r2,gp,-32604
811343c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
811343cc:	d0a02984 	addi	r2,gp,-32602
811343d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
811343d4:	d0a02a04 	addi	r2,gp,-32600
811343d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
811343dc:	d0a02a84 	addi	r2,gp,-32598
811343e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
811343e4:	d0a02b04 	addi	r2,gp,-32596
811343e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
811343ec:	d0a02b84 	addi	r2,gp,-32594
811343f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
811343f4:	d0a02c04 	addi	r2,gp,-32592
811343f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
811343fc:	d0a02c84 	addi	r2,gp,-32590
81134400:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
81134404:	d0a02d04 	addi	r2,gp,-32588
81134408:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
8113440c:	d0a02d84 	addi	r2,gp,-32586
81134410:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
81134414:	d0a02e04 	addi	r2,gp,-32584
81134418:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
8113441c:	d0a02e84 	addi	r2,gp,-32582
81134420:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81134424:	00a045b4 	movhi	r2,33046
81134428:	10802304 	addi	r2,r2,140
8113442c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
81134430:	00a045b4 	movhi	r2,33046
81134434:	10bebf04 	addi	r2,r2,-1284
81134438:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
8113443c:	d0a02f84 	addi	r2,gp,-32578
81134440:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81134444:	d0a03004 	addi	r2,gp,-32576
81134448:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
8113444c:	d0a03084 	addi	r2,gp,-32574
81134450:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81134454:	d0a03104 	addi	r2,gp,-32572
81134458:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
8113445c:	d0a03184 	addi	r2,gp,-32570
81134460:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81134464:	d0a03204 	addi	r2,gp,-32568
81134468:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
8113446c:	d0a03284 	addi	r2,gp,-32566
81134470:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81134474:	d0a03304 	addi	r2,gp,-32564
81134478:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
8113447c:	d0a03384 	addi	r2,gp,-32562
81134480:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81134484:	d0a02f04 	addi	r2,gp,-32580
81134488:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
8113448c:	d0a03404 	addi	r2,gp,-32560
81134490:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81134494:	0001883a 	nop
81134498:	e037883a 	mov	sp,fp
8113449c:	df000017 	ldw	fp,0(sp)
811344a0:	dec00104 	addi	sp,sp,4
811344a4:	f800283a 	ret

811344a8 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
811344a8:	defff204 	addi	sp,sp,-56
811344ac:	de00012e 	bgeu	sp,et,811344b4 <OSFlagAccept+0xc>
811344b0:	003b68fa 	trap	3
811344b4:	df000d15 	stw	fp,52(sp)
811344b8:	df000d04 	addi	fp,sp,52
811344bc:	e13ffc15 	stw	r4,-16(fp)
811344c0:	2807883a 	mov	r3,r5
811344c4:	3005883a 	mov	r2,r6
811344c8:	e1ffff15 	stw	r7,-4(fp)
811344cc:	e0fffd0d 	sth	r3,-12(fp)
811344d0:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811344d4:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811344d8:	e0bfff17 	ldw	r2,-4(fp)
811344dc:	1000021e 	bne	r2,zero,811344e8 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
811344e0:	0005883a 	mov	r2,zero
811344e4:	0000b006 	br	811347a8 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811344e8:	e0bffc17 	ldw	r2,-16(fp)
811344ec:	1000051e 	bne	r2,zero,81134504 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811344f0:	e0bfff17 	ldw	r2,-4(fp)
811344f4:	00c01b84 	movi	r3,110
811344f8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811344fc:	0005883a 	mov	r2,zero
81134500:	0000a906 	br	811347a8 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81134504:	e0bffc17 	ldw	r2,-16(fp)
81134508:	10800003 	ldbu	r2,0(r2)
8113450c:	10803fcc 	andi	r2,r2,255
81134510:	10800160 	cmpeqi	r2,r2,5
81134514:	1000051e 	bne	r2,zero,8113452c <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
81134518:	e0bfff17 	ldw	r2,-4(fp)
8113451c:	00c00044 	movi	r3,1
81134520:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134524:	0005883a 	mov	r2,zero
81134528:	00009f06 	br	811347a8 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113452c:	e0fffe03 	ldbu	r3,-8(fp)
81134530:	00bfe004 	movi	r2,-128
81134534:	1884703a 	and	r2,r3,r2
81134538:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
8113453c:	e0bff503 	ldbu	r2,-44(fp)
81134540:	10000626 	beq	r2,zero,8113455c <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81134544:	e0bffe03 	ldbu	r2,-8(fp)
81134548:	10801fcc 	andi	r2,r2,127
8113454c:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81134550:	00800044 	movi	r2,1
81134554:	e0bff385 	stb	r2,-50(fp)
81134558:	00000106 	br	81134560 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
8113455c:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
81134560:	e0bfff17 	ldw	r2,-4(fp)
81134564:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134568:	0005303a 	rdctl	r2,status
8113456c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134570:	e0fffb17 	ldw	r3,-20(fp)
81134574:	00bfff84 	movi	r2,-2
81134578:	1884703a 	and	r2,r3,r2
8113457c:	1001703a 	wrctl	status,r2
  
  return context;
81134580:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
81134584:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81134588:	e0bffe03 	ldbu	r2,-8(fp)
8113458c:	10c00060 	cmpeqi	r3,r2,1
81134590:	18005f1e 	bne	r3,zero,81134710 <OSFlagAccept+0x268>
81134594:	10c00088 	cmpgei	r3,r2,2
81134598:	1800021e 	bne	r3,zero,811345a4 <OSFlagAccept+0xfc>
8113459c:	10003f26 	beq	r2,zero,8113469c <OSFlagAccept+0x1f4>
811345a0:	00007706 	br	81134780 <OSFlagAccept+0x2d8>
811345a4:	10c000a0 	cmpeqi	r3,r2,2
811345a8:	1800031e 	bne	r3,zero,811345b8 <OSFlagAccept+0x110>
811345ac:	108000e0 	cmpeqi	r2,r2,3
811345b0:	10001e1e 	bne	r2,zero,8113462c <OSFlagAccept+0x184>
811345b4:	00007206 	br	81134780 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811345b8:	e0bffc17 	ldw	r2,-16(fp)
811345bc:	10c0020b 	ldhu	r3,8(r2)
811345c0:	e0bffd0b 	ldhu	r2,-12(fp)
811345c4:	1884703a 	and	r2,r3,r2
811345c8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811345cc:	e0fff30b 	ldhu	r3,-52(fp)
811345d0:	e0bffd0b 	ldhu	r2,-12(fp)
811345d4:	18800d1e 	bne	r3,r2,8113460c <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811345d8:	e0bff383 	ldbu	r2,-50(fp)
811345dc:	10800058 	cmpnei	r2,r2,1
811345e0:	10000d1e 	bne	r2,zero,81134618 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
811345e4:	e0bffc17 	ldw	r2,-16(fp)
811345e8:	1080020b 	ldhu	r2,8(r2)
811345ec:	1007883a 	mov	r3,r2
811345f0:	e0bff30b 	ldhu	r2,-52(fp)
811345f4:	0084303a 	nor	r2,zero,r2
811345f8:	1884703a 	and	r2,r3,r2
811345fc:	1007883a 	mov	r3,r2
81134600:	e0bffc17 	ldw	r2,-16(fp)
81134604:	10c0020d 	sth	r3,8(r2)
81134608:	00000306 	br	81134618 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113460c:	e0bfff17 	ldw	r2,-4(fp)
81134610:	00c01c04 	movi	r3,112
81134614:	10c00005 	stb	r3,0(r2)
81134618:	e0bff417 	ldw	r2,-48(fp)
8113461c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134620:	e0bff617 	ldw	r2,-40(fp)
81134624:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81134628:	00005e06 	br	811347a4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
8113462c:	e0bffc17 	ldw	r2,-16(fp)
81134630:	10c0020b 	ldhu	r3,8(r2)
81134634:	e0bffd0b 	ldhu	r2,-12(fp)
81134638:	1884703a 	and	r2,r3,r2
8113463c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81134640:	e0bff30b 	ldhu	r2,-52(fp)
81134644:	10000d26 	beq	r2,zero,8113467c <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81134648:	e0bff383 	ldbu	r2,-50(fp)
8113464c:	10800058 	cmpnei	r2,r2,1
81134650:	10000d1e 	bne	r2,zero,81134688 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81134654:	e0bffc17 	ldw	r2,-16(fp)
81134658:	1080020b 	ldhu	r2,8(r2)
8113465c:	1007883a 	mov	r3,r2
81134660:	e0bff30b 	ldhu	r2,-52(fp)
81134664:	0084303a 	nor	r2,zero,r2
81134668:	1884703a 	and	r2,r3,r2
8113466c:	1007883a 	mov	r3,r2
81134670:	e0bffc17 	ldw	r2,-16(fp)
81134674:	10c0020d 	sth	r3,8(r2)
81134678:	00000306 	br	81134688 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113467c:	e0bfff17 	ldw	r2,-4(fp)
81134680:	00c01c04 	movi	r3,112
81134684:	10c00005 	stb	r3,0(r2)
81134688:	e0bff417 	ldw	r2,-48(fp)
8113468c:	e0bff715 	stw	r2,-36(fp)
81134690:	e0bff717 	ldw	r2,-36(fp)
81134694:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81134698:	00004206 	br	811347a4 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113469c:	e0bffc17 	ldw	r2,-16(fp)
811346a0:	1080020b 	ldhu	r2,8(r2)
811346a4:	0084303a 	nor	r2,zero,r2
811346a8:	1007883a 	mov	r3,r2
811346ac:	e0bffd0b 	ldhu	r2,-12(fp)
811346b0:	1884703a 	and	r2,r3,r2
811346b4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811346b8:	e0fff30b 	ldhu	r3,-52(fp)
811346bc:	e0bffd0b 	ldhu	r2,-12(fp)
811346c0:	18800b1e 	bne	r3,r2,811346f0 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811346c4:	e0bff383 	ldbu	r2,-50(fp)
811346c8:	10800058 	cmpnei	r2,r2,1
811346cc:	10000b1e 	bne	r2,zero,811346fc <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
811346d0:	e0bffc17 	ldw	r2,-16(fp)
811346d4:	10c0020b 	ldhu	r3,8(r2)
811346d8:	e0bff30b 	ldhu	r2,-52(fp)
811346dc:	1884b03a 	or	r2,r3,r2
811346e0:	1007883a 	mov	r3,r2
811346e4:	e0bffc17 	ldw	r2,-16(fp)
811346e8:	10c0020d 	sth	r3,8(r2)
811346ec:	00000306 	br	811346fc <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811346f0:	e0bfff17 	ldw	r2,-4(fp)
811346f4:	00c01c04 	movi	r3,112
811346f8:	10c00005 	stb	r3,0(r2)
811346fc:	e0bff417 	ldw	r2,-48(fp)
81134700:	e0bff815 	stw	r2,-32(fp)
81134704:	e0bff817 	ldw	r2,-32(fp)
81134708:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113470c:	00002506 	br	811347a4 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81134710:	e0bffc17 	ldw	r2,-16(fp)
81134714:	1080020b 	ldhu	r2,8(r2)
81134718:	0084303a 	nor	r2,zero,r2
8113471c:	1007883a 	mov	r3,r2
81134720:	e0bffd0b 	ldhu	r2,-12(fp)
81134724:	1884703a 	and	r2,r3,r2
81134728:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113472c:	e0bff30b 	ldhu	r2,-52(fp)
81134730:	10000b26 	beq	r2,zero,81134760 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81134734:	e0bff383 	ldbu	r2,-50(fp)
81134738:	10800058 	cmpnei	r2,r2,1
8113473c:	10000b1e 	bne	r2,zero,8113476c <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81134740:	e0bffc17 	ldw	r2,-16(fp)
81134744:	10c0020b 	ldhu	r3,8(r2)
81134748:	e0bff30b 	ldhu	r2,-52(fp)
8113474c:	1884b03a 	or	r2,r3,r2
81134750:	1007883a 	mov	r3,r2
81134754:	e0bffc17 	ldw	r2,-16(fp)
81134758:	10c0020d 	sth	r3,8(r2)
8113475c:	00000306 	br	8113476c <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81134760:	e0bfff17 	ldw	r2,-4(fp)
81134764:	00c01c04 	movi	r3,112
81134768:	10c00005 	stb	r3,0(r2)
8113476c:	e0bff417 	ldw	r2,-48(fp)
81134770:	e0bff915 	stw	r2,-28(fp)
81134774:	e0bff917 	ldw	r2,-28(fp)
81134778:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
8113477c:	00000906 	br	811347a4 <OSFlagAccept+0x2fc>
81134780:	e0bff417 	ldw	r2,-48(fp)
81134784:	e0bffa15 	stw	r2,-24(fp)
81134788:	e0bffa17 	ldw	r2,-24(fp)
8113478c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81134790:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
81134794:	e0bfff17 	ldw	r2,-4(fp)
81134798:	00c01bc4 	movi	r3,111
8113479c:	10c00005 	stb	r3,0(r2)
             break;
811347a0:	0001883a 	nop
    }
    return (flags_rdy);
811347a4:	e0bff30b 	ldhu	r2,-52(fp)
}
811347a8:	e037883a 	mov	sp,fp
811347ac:	df000017 	ldw	fp,0(sp)
811347b0:	dec00104 	addi	sp,sp,4
811347b4:	f800283a 	ret

811347b8 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
811347b8:	defff804 	addi	sp,sp,-32
811347bc:	de00012e 	bgeu	sp,et,811347c4 <OSFlagCreate+0xc>
811347c0:	003b68fa 	trap	3
811347c4:	df000715 	stw	fp,28(sp)
811347c8:	df000704 	addi	fp,sp,28
811347cc:	2005883a 	mov	r2,r4
811347d0:	e17fff15 	stw	r5,-4(fp)
811347d4:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
811347d8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
811347dc:	e0bfff17 	ldw	r2,-4(fp)
811347e0:	1000021e 	bne	r2,zero,811347ec <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
811347e4:	0005883a 	mov	r2,zero
811347e8:	00003306 	br	811348b8 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
811347ec:	d0a0a603 	ldbu	r2,-32104(gp)
811347f0:	10803fcc 	andi	r2,r2,255
811347f4:	10000526 	beq	r2,zero,8113480c <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
811347f8:	e0bfff17 	ldw	r2,-4(fp)
811347fc:	00c00404 	movi	r3,16
81134800:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81134804:	0005883a 	mov	r2,zero
81134808:	00002b06 	br	811348b8 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113480c:	0005303a 	rdctl	r2,status
81134810:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134814:	e0fffd17 	ldw	r3,-12(fp)
81134818:	00bfff84 	movi	r2,-2
8113481c:	1884703a 	and	r2,r3,r2
81134820:	1001703a 	wrctl	status,r2
  
  return context;
81134824:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81134828:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
8113482c:	d0a0ab17 	ldw	r2,-32084(gp)
81134830:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81134834:	e0bffb17 	ldw	r2,-20(fp)
81134838:	10001726 	beq	r2,zero,81134898 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
8113483c:	d0a0ab17 	ldw	r2,-32084(gp)
81134840:	10800117 	ldw	r2,4(r2)
81134844:	d0a0ab15 	stw	r2,-32084(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81134848:	e0bffb17 	ldw	r2,-20(fp)
8113484c:	00c00144 	movi	r3,5
81134850:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81134854:	e0bffb17 	ldw	r2,-20(fp)
81134858:	e0fffe0b 	ldhu	r3,-8(fp)
8113485c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
81134860:	e0bffb17 	ldw	r2,-20(fp)
81134864:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81134868:	e0bffb17 	ldw	r2,-20(fp)
8113486c:	00c00fc4 	movi	r3,63
81134870:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81134874:	e0bffb17 	ldw	r2,-20(fp)
81134878:	100002c5 	stb	zero,11(r2)
8113487c:	e0bff917 	ldw	r2,-28(fp)
81134880:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134884:	e0bffa17 	ldw	r2,-24(fp)
81134888:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
8113488c:	e0bfff17 	ldw	r2,-4(fp)
81134890:	10000005 	stb	zero,0(r2)
81134894:	00000706 	br	811348b4 <OSFlagCreate+0xfc>
81134898:	e0bff917 	ldw	r2,-28(fp)
8113489c:	e0bffc15 	stw	r2,-16(fp)
811348a0:	e0bffc17 	ldw	r2,-16(fp)
811348a4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
811348a8:	e0bfff17 	ldw	r2,-4(fp)
811348ac:	00c01c84 	movi	r3,114
811348b0:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
811348b4:	e0bffb17 	ldw	r2,-20(fp)
}
811348b8:	e037883a 	mov	sp,fp
811348bc:	df000017 	ldw	fp,0(sp)
811348c0:	dec00104 	addi	sp,sp,4
811348c4:	f800283a 	ret

811348c8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
811348c8:	defff204 	addi	sp,sp,-56
811348cc:	de00012e 	bgeu	sp,et,811348d4 <OSFlagDel+0xc>
811348d0:	003b68fa 	trap	3
811348d4:	dfc00d15 	stw	ra,52(sp)
811348d8:	df000c15 	stw	fp,48(sp)
811348dc:	df000c04 	addi	fp,sp,48
811348e0:	e13ffd15 	stw	r4,-12(fp)
811348e4:	2805883a 	mov	r2,r5
811348e8:	e1bfff15 	stw	r6,-4(fp)
811348ec:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811348f0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811348f4:	e0bfff17 	ldw	r2,-4(fp)
811348f8:	1000021e 	bne	r2,zero,81134904 <OSFlagDel+0x3c>
        return (pgrp);
811348fc:	e0bffd17 	ldw	r2,-12(fp)
81134900:	00008006 	br	81134b04 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81134904:	e0bffd17 	ldw	r2,-12(fp)
81134908:	1000051e 	bne	r2,zero,81134920 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113490c:	e0bfff17 	ldw	r2,-4(fp)
81134910:	00c01b84 	movi	r3,110
81134914:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81134918:	e0bffd17 	ldw	r2,-12(fp)
8113491c:	00007906 	br	81134b04 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81134920:	d0a0a603 	ldbu	r2,-32104(gp)
81134924:	10803fcc 	andi	r2,r2,255
81134928:	10000526 	beq	r2,zero,81134940 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113492c:	e0bfff17 	ldw	r2,-4(fp)
81134930:	00c003c4 	movi	r3,15
81134934:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81134938:	e0bffd17 	ldw	r2,-12(fp)
8113493c:	00007106 	br	81134b04 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
81134940:	e0bffd17 	ldw	r2,-12(fp)
81134944:	10800003 	ldbu	r2,0(r2)
81134948:	10803fcc 	andi	r2,r2,255
8113494c:	10800160 	cmpeqi	r2,r2,5
81134950:	1000051e 	bne	r2,zero,81134968 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81134954:	e0bfff17 	ldw	r2,-4(fp)
81134958:	00c00044 	movi	r3,1
8113495c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81134960:	e0bffd17 	ldw	r2,-12(fp)
81134964:	00006706 	br	81134b04 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134968:	0005303a 	rdctl	r2,status
8113496c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134970:	e0fffc17 	ldw	r3,-16(fp)
81134974:	00bfff84 	movi	r2,-2
81134978:	1884703a 	and	r2,r3,r2
8113497c:	1001703a 	wrctl	status,r2
  
  return context;
81134980:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134984:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81134988:	e0bffd17 	ldw	r2,-12(fp)
8113498c:	10800117 	ldw	r2,4(r2)
81134990:	10000326 	beq	r2,zero,811349a0 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81134994:	00800044 	movi	r2,1
81134998:	e0bff405 	stb	r2,-48(fp)
8113499c:	00000106 	br	811349a4 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811349a0:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
811349a4:	e0bffe03 	ldbu	r2,-8(fp)
811349a8:	10000326 	beq	r2,zero,811349b8 <OSFlagDel+0xf0>
811349ac:	10800060 	cmpeqi	r2,r2,1
811349b0:	1000231e 	bne	r2,zero,81134a40 <OSFlagDel+0x178>
811349b4:	00004806 	br	81134ad8 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
811349b8:	e0bff403 	ldbu	r2,-48(fp)
811349bc:	1000161e 	bne	r2,zero,81134a18 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
811349c0:	e0bffd17 	ldw	r2,-12(fp)
811349c4:	00c00fc4 	movi	r3,63
811349c8:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811349cc:	e0bffd17 	ldw	r2,-12(fp)
811349d0:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
811349d4:	e0bffd17 	ldw	r2,-12(fp)
811349d8:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
811349dc:	d0e0ab17 	ldw	r3,-32084(gp)
811349e0:	e0bffd17 	ldw	r2,-12(fp)
811349e4:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
811349e8:	e0bffd17 	ldw	r2,-12(fp)
811349ec:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
811349f0:	e0bffd17 	ldw	r2,-12(fp)
811349f4:	d0a0ab15 	stw	r2,-32084(gp)
811349f8:	e0bff717 	ldw	r2,-36(fp)
811349fc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134a00:	e0bff817 	ldw	r2,-32(fp)
81134a04:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81134a08:	e0bfff17 	ldw	r2,-4(fp)
81134a0c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81134a10:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81134a14:	00003a06 	br	81134b00 <OSFlagDel+0x238>
81134a18:	e0bff717 	ldw	r2,-36(fp)
81134a1c:	e0bff915 	stw	r2,-28(fp)
81134a20:	e0bff917 	ldw	r2,-28(fp)
81134a24:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81134a28:	e0bfff17 	ldw	r2,-4(fp)
81134a2c:	00c01244 	movi	r3,73
81134a30:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81134a34:	e0bffd17 	ldw	r2,-12(fp)
81134a38:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81134a3c:	00003006 	br	81134b00 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81134a40:	e0bffd17 	ldw	r2,-12(fp)
81134a44:	10800117 	ldw	r2,4(r2)
81134a48:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81134a4c:	00000606 	br	81134a68 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81134a50:	000b883a 	mov	r5,zero
81134a54:	e13ff517 	ldw	r4,-44(fp)
81134a58:	1135a7c0 	call	81135a7c <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81134a5c:	e0bff517 	ldw	r2,-44(fp)
81134a60:	10800017 	ldw	r2,0(r2)
81134a64:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81134a68:	e0bff517 	ldw	r2,-44(fp)
81134a6c:	103ff81e 	bne	r2,zero,81134a50 <__reset+0xfb114a50>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81134a70:	e0bffd17 	ldw	r2,-12(fp)
81134a74:	00c00fc4 	movi	r3,63
81134a78:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81134a7c:	e0bffd17 	ldw	r2,-12(fp)
81134a80:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81134a84:	e0bffd17 	ldw	r2,-12(fp)
81134a88:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81134a8c:	d0e0ab17 	ldw	r3,-32084(gp)
81134a90:	e0bffd17 	ldw	r2,-12(fp)
81134a94:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81134a98:	e0bffd17 	ldw	r2,-12(fp)
81134a9c:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81134aa0:	e0bffd17 	ldw	r2,-12(fp)
81134aa4:	d0a0ab15 	stw	r2,-32084(gp)
81134aa8:	e0bff717 	ldw	r2,-36(fp)
81134aac:	e0bffa15 	stw	r2,-24(fp)
81134ab0:	e0bffa17 	ldw	r2,-24(fp)
81134ab4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81134ab8:	e0bff403 	ldbu	r2,-48(fp)
81134abc:	10800058 	cmpnei	r2,r2,1
81134ac0:	1000011e 	bne	r2,zero,81134ac8 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81134ac4:	1133b8c0 	call	81133b8c <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81134ac8:	e0bfff17 	ldw	r2,-4(fp)
81134acc:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81134ad0:	e03ff615 	stw	zero,-40(fp)
             break;
81134ad4:	00000a06 	br	81134b00 <OSFlagDel+0x238>
81134ad8:	e0bff717 	ldw	r2,-36(fp)
81134adc:	e0bffb15 	stw	r2,-20(fp)
81134ae0:	e0bffb17 	ldw	r2,-20(fp)
81134ae4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81134ae8:	e0bfff17 	ldw	r2,-4(fp)
81134aec:	00c001c4 	movi	r3,7
81134af0:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81134af4:	e0bffd17 	ldw	r2,-12(fp)
81134af8:	e0bff615 	stw	r2,-40(fp)
             break;
81134afc:	0001883a 	nop
    }
    return (pgrp_return);
81134b00:	e0bff617 	ldw	r2,-40(fp)
}
81134b04:	e037883a 	mov	sp,fp
81134b08:	dfc00117 	ldw	ra,4(sp)
81134b0c:	df000017 	ldw	fp,0(sp)
81134b10:	dec00204 	addi	sp,sp,8
81134b14:	f800283a 	ret

81134b18 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81134b18:	defff604 	addi	sp,sp,-40
81134b1c:	de00012e 	bgeu	sp,et,81134b24 <OSFlagNameGet+0xc>
81134b20:	003b68fa 	trap	3
81134b24:	dfc00915 	stw	ra,36(sp)
81134b28:	df000815 	stw	fp,32(sp)
81134b2c:	df000804 	addi	fp,sp,32
81134b30:	e13ffd15 	stw	r4,-12(fp)
81134b34:	e17ffe15 	stw	r5,-8(fp)
81134b38:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134b3c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81134b40:	e0bfff17 	ldw	r2,-4(fp)
81134b44:	1000021e 	bne	r2,zero,81134b50 <OSFlagNameGet+0x38>
        return (0);
81134b48:	0005883a 	mov	r2,zero
81134b4c:	00003906 	br	81134c34 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81134b50:	e0bffd17 	ldw	r2,-12(fp)
81134b54:	1000051e 	bne	r2,zero,81134b6c <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81134b58:	e0bfff17 	ldw	r2,-4(fp)
81134b5c:	00c01b84 	movi	r3,110
81134b60:	10c00005 	stb	r3,0(r2)
        return (0);
81134b64:	0005883a 	mov	r2,zero
81134b68:	00003206 	br	81134c34 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81134b6c:	e0bffe17 	ldw	r2,-8(fp)
81134b70:	1000051e 	bne	r2,zero,81134b88 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81134b74:	e0bfff17 	ldw	r2,-4(fp)
81134b78:	00c00304 	movi	r3,12
81134b7c:	10c00005 	stb	r3,0(r2)
        return (0);
81134b80:	0005883a 	mov	r2,zero
81134b84:	00002b06 	br	81134c34 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81134b88:	d0a0a603 	ldbu	r2,-32104(gp)
81134b8c:	10803fcc 	andi	r2,r2,255
81134b90:	10000526 	beq	r2,zero,81134ba8 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81134b94:	e0bfff17 	ldw	r2,-4(fp)
81134b98:	00c00444 	movi	r3,17
81134b9c:	10c00005 	stb	r3,0(r2)
        return (0);
81134ba0:	0005883a 	mov	r2,zero
81134ba4:	00002306 	br	81134c34 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134ba8:	0005303a 	rdctl	r2,status
81134bac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134bb0:	e0fffc17 	ldw	r3,-16(fp)
81134bb4:	00bfff84 	movi	r2,-2
81134bb8:	1884703a 	and	r2,r3,r2
81134bbc:	1001703a 	wrctl	status,r2
  
  return context;
81134bc0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134bc4:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81134bc8:	e0bffd17 	ldw	r2,-12(fp)
81134bcc:	10800003 	ldbu	r2,0(r2)
81134bd0:	10803fcc 	andi	r2,r2,255
81134bd4:	10800160 	cmpeqi	r2,r2,5
81134bd8:	1000091e 	bne	r2,zero,81134c00 <OSFlagNameGet+0xe8>
81134bdc:	e0bff817 	ldw	r2,-32(fp)
81134be0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134be4:	e0bff917 	ldw	r2,-28(fp)
81134be8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81134bec:	e0bfff17 	ldw	r2,-4(fp)
81134bf0:	00c00044 	movi	r3,1
81134bf4:	10c00005 	stb	r3,0(r2)
        return (0);
81134bf8:	0005883a 	mov	r2,zero
81134bfc:	00000d06 	br	81134c34 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81134c00:	e0bffd17 	ldw	r2,-12(fp)
81134c04:	10800284 	addi	r2,r2,10
81134c08:	100b883a 	mov	r5,r2
81134c0c:	e13ffe17 	ldw	r4,-8(fp)
81134c10:	1133ce00 	call	81133ce0 <OS_StrCopy>
81134c14:	e0bffb05 	stb	r2,-20(fp)
81134c18:	e0bff817 	ldw	r2,-32(fp)
81134c1c:	e0bffa15 	stw	r2,-24(fp)
81134c20:	e0bffa17 	ldw	r2,-24(fp)
81134c24:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134c28:	e0bfff17 	ldw	r2,-4(fp)
81134c2c:	10000005 	stb	zero,0(r2)
    return (len);
81134c30:	e0bffb03 	ldbu	r2,-20(fp)
}
81134c34:	e037883a 	mov	sp,fp
81134c38:	dfc00117 	ldw	ra,4(sp)
81134c3c:	df000017 	ldw	fp,0(sp)
81134c40:	dec00204 	addi	sp,sp,8
81134c44:	f800283a 	ret

81134c48 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81134c48:	defff504 	addi	sp,sp,-44
81134c4c:	de00012e 	bgeu	sp,et,81134c54 <OSFlagNameSet+0xc>
81134c50:	003b68fa 	trap	3
81134c54:	dfc00a15 	stw	ra,40(sp)
81134c58:	df000915 	stw	fp,36(sp)
81134c5c:	df000904 	addi	fp,sp,36
81134c60:	e13ffd15 	stw	r4,-12(fp)
81134c64:	e17ffe15 	stw	r5,-8(fp)
81134c68:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134c6c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81134c70:	e0bfff17 	ldw	r2,-4(fp)
81134c74:	10004326 	beq	r2,zero,81134d84 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81134c78:	e0bffd17 	ldw	r2,-12(fp)
81134c7c:	1000041e 	bne	r2,zero,81134c90 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81134c80:	e0bfff17 	ldw	r2,-4(fp)
81134c84:	00c01b84 	movi	r3,110
81134c88:	10c00005 	stb	r3,0(r2)
        return;
81134c8c:	00003e06 	br	81134d88 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81134c90:	e0bffe17 	ldw	r2,-8(fp)
81134c94:	1000041e 	bne	r2,zero,81134ca8 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81134c98:	e0bfff17 	ldw	r2,-4(fp)
81134c9c:	00c00304 	movi	r3,12
81134ca0:	10c00005 	stb	r3,0(r2)
        return;
81134ca4:	00003806 	br	81134d88 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81134ca8:	d0a0a603 	ldbu	r2,-32104(gp)
81134cac:	10803fcc 	andi	r2,r2,255
81134cb0:	10000426 	beq	r2,zero,81134cc4 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81134cb4:	e0bfff17 	ldw	r2,-4(fp)
81134cb8:	00c00484 	movi	r3,18
81134cbc:	10c00005 	stb	r3,0(r2)
        return;
81134cc0:	00003106 	br	81134d88 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134cc4:	0005303a 	rdctl	r2,status
81134cc8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134ccc:	e0fffc17 	ldw	r3,-16(fp)
81134cd0:	00bfff84 	movi	r2,-2
81134cd4:	1884703a 	and	r2,r3,r2
81134cd8:	1001703a 	wrctl	status,r2
  
  return context;
81134cdc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134ce0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81134ce4:	e0bffd17 	ldw	r2,-12(fp)
81134ce8:	10800003 	ldbu	r2,0(r2)
81134cec:	10803fcc 	andi	r2,r2,255
81134cf0:	10800160 	cmpeqi	r2,r2,5
81134cf4:	1000081e 	bne	r2,zero,81134d18 <OSFlagNameSet+0xd0>
81134cf8:	e0bff717 	ldw	r2,-36(fp)
81134cfc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134d00:	e0bff817 	ldw	r2,-32(fp)
81134d04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81134d08:	e0bfff17 	ldw	r2,-4(fp)
81134d0c:	00c00044 	movi	r3,1
81134d10:	10c00005 	stb	r3,0(r2)
        return;
81134d14:	00001c06 	br	81134d88 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81134d18:	e13ffe17 	ldw	r4,-8(fp)
81134d1c:	1133d5c0 	call	81133d5c <OS_StrLen>
81134d20:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81134d24:	e0bffa03 	ldbu	r2,-24(fp)
81134d28:	10800830 	cmpltui	r2,r2,32
81134d2c:	1000081e 	bne	r2,zero,81134d50 <OSFlagNameSet+0x108>
81134d30:	e0bff717 	ldw	r2,-36(fp)
81134d34:	e0bff915 	stw	r2,-28(fp)
81134d38:	e0bff917 	ldw	r2,-28(fp)
81134d3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81134d40:	e0bfff17 	ldw	r2,-4(fp)
81134d44:	00c01cc4 	movi	r3,115
81134d48:	10c00005 	stb	r3,0(r2)
        return;
81134d4c:	00000e06 	br	81134d88 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81134d50:	e0bffd17 	ldw	r2,-12(fp)
81134d54:	10800284 	addi	r2,r2,10
81134d58:	e17ffe17 	ldw	r5,-8(fp)
81134d5c:	1009883a 	mov	r4,r2
81134d60:	1133ce00 	call	81133ce0 <OS_StrCopy>
81134d64:	e0bff717 	ldw	r2,-36(fp)
81134d68:	e0bffb15 	stw	r2,-20(fp)
81134d6c:	e0bffb17 	ldw	r2,-20(fp)
81134d70:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134d74:	e0bfff17 	ldw	r2,-4(fp)
81134d78:	10000005 	stb	zero,0(r2)
    return;
81134d7c:	0001883a 	nop
81134d80:	00000106 	br	81134d88 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81134d84:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81134d88:	e037883a 	mov	sp,fp
81134d8c:	dfc00117 	ldw	ra,4(sp)
81134d90:	df000017 	ldw	fp,0(sp)
81134d94:	dec00204 	addi	sp,sp,8
81134d98:	f800283a 	ret

81134d9c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81134d9c:	deffe104 	addi	sp,sp,-124
81134da0:	de00012e 	bgeu	sp,et,81134da8 <OSFlagPend+0xc>
81134da4:	003b68fa 	trap	3
81134da8:	dfc01e15 	stw	ra,120(sp)
81134dac:	df001d15 	stw	fp,116(sp)
81134db0:	df001d04 	addi	fp,sp,116
81134db4:	e13ffc15 	stw	r4,-16(fp)
81134db8:	2809883a 	mov	r4,r5
81134dbc:	3007883a 	mov	r3,r6
81134dc0:	3805883a 	mov	r2,r7
81134dc4:	e13ffd0d 	sth	r4,-12(fp)
81134dc8:	e0fffe05 	stb	r3,-8(fp)
81134dcc:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81134dd0:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81134dd4:	e0800217 	ldw	r2,8(fp)
81134dd8:	1000021e 	bne	r2,zero,81134de4 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81134ddc:	0005883a 	mov	r2,zero
81134de0:	00015906 	br	81135348 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81134de4:	e0bffc17 	ldw	r2,-16(fp)
81134de8:	1000051e 	bne	r2,zero,81134e00 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81134dec:	e0800217 	ldw	r2,8(fp)
81134df0:	00c01b84 	movi	r3,110
81134df4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134df8:	0005883a 	mov	r2,zero
81134dfc:	00015206 	br	81135348 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81134e00:	d0a0a603 	ldbu	r2,-32104(gp)
81134e04:	10803fcc 	andi	r2,r2,255
81134e08:	10000526 	beq	r2,zero,81134e20 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81134e0c:	e0800217 	ldw	r2,8(fp)
81134e10:	00c00084 	movi	r3,2
81134e14:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134e18:	0005883a 	mov	r2,zero
81134e1c:	00014a06 	br	81135348 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81134e20:	d0a09403 	ldbu	r2,-32176(gp)
81134e24:	10803fcc 	andi	r2,r2,255
81134e28:	10000526 	beq	r2,zero,81134e40 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81134e2c:	e0800217 	ldw	r2,8(fp)
81134e30:	00c00344 	movi	r3,13
81134e34:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134e38:	0005883a 	mov	r2,zero
81134e3c:	00014206 	br	81135348 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81134e40:	e0bffc17 	ldw	r2,-16(fp)
81134e44:	10800003 	ldbu	r2,0(r2)
81134e48:	10803fcc 	andi	r2,r2,255
81134e4c:	10800160 	cmpeqi	r2,r2,5
81134e50:	1000051e 	bne	r2,zero,81134e68 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81134e54:	e0800217 	ldw	r2,8(fp)
81134e58:	00c00044 	movi	r3,1
81134e5c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134e60:	0005883a 	mov	r2,zero
81134e64:	00013806 	br	81135348 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81134e68:	e0fffe03 	ldbu	r3,-8(fp)
81134e6c:	00bfe004 	movi	r2,-128
81134e70:	1884703a 	and	r2,r3,r2
81134e74:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81134e78:	e0bfe603 	ldbu	r2,-104(fp)
81134e7c:	10000626 	beq	r2,zero,81134e98 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
81134e80:	e0bffe03 	ldbu	r2,-8(fp)
81134e84:	10801fcc 	andi	r2,r2,127
81134e88:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81134e8c:	00800044 	movi	r2,1
81134e90:	e0bfe405 	stb	r2,-112(fp)
81134e94:	00000106 	br	81134e9c <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81134e98:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134e9c:	0005303a 	rdctl	r2,status
81134ea0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134ea4:	e0fff617 	ldw	r3,-40(fp)
81134ea8:	00bfff84 	movi	r2,-2
81134eac:	1884703a 	and	r2,r3,r2
81134eb0:	1001703a 	wrctl	status,r2
  
  return context;
81134eb4:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81134eb8:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81134ebc:	e0bffe03 	ldbu	r2,-8(fp)
81134ec0:	10c00060 	cmpeqi	r3,r2,1
81134ec4:	1800921e 	bne	r3,zero,81135110 <OSFlagPend+0x374>
81134ec8:	10c00088 	cmpgei	r3,r2,2
81134ecc:	1800021e 	bne	r3,zero,81134ed8 <OSFlagPend+0x13c>
81134ed0:	10006126 	beq	r2,zero,81135058 <OSFlagPend+0x2bc>
81134ed4:	0000bb06 	br	811351c4 <OSFlagPend+0x428>
81134ed8:	10c000a0 	cmpeqi	r3,r2,2
81134edc:	1800031e 	bne	r3,zero,81134eec <OSFlagPend+0x150>
81134ee0:	108000e0 	cmpeqi	r2,r2,3
81134ee4:	10002f1e 	bne	r2,zero,81134fa4 <OSFlagPend+0x208>
81134ee8:	0000b606 	br	811351c4 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
81134eec:	e0bffc17 	ldw	r2,-16(fp)
81134ef0:	10c0020b 	ldhu	r3,8(r2)
81134ef4:	e0bffd0b 	ldhu	r2,-12(fp)
81134ef8:	1884703a 	and	r2,r3,r2
81134efc:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81134f00:	e0ffe80b 	ldhu	r3,-96(fp)
81134f04:	e0bffd0b 	ldhu	r2,-12(fp)
81134f08:	1880171e 	bne	r3,r2,81134f68 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81134f0c:	e0bfe403 	ldbu	r2,-112(fp)
81134f10:	10800058 	cmpnei	r2,r2,1
81134f14:	1000091e 	bne	r2,zero,81134f3c <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81134f18:	e0bffc17 	ldw	r2,-16(fp)
81134f1c:	1080020b 	ldhu	r2,8(r2)
81134f20:	1007883a 	mov	r3,r2
81134f24:	e0bfe80b 	ldhu	r2,-96(fp)
81134f28:	0084303a 	nor	r2,zero,r2
81134f2c:	1884703a 	and	r2,r3,r2
81134f30:	1007883a 	mov	r3,r2
81134f34:	e0bffc17 	ldw	r2,-16(fp)
81134f38:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81134f3c:	d0a0a717 	ldw	r2,-32100(gp)
81134f40:	e0ffe80b 	ldhu	r3,-96(fp)
81134f44:	10c00b0d 	sth	r3,44(r2)
81134f48:	e0bfe517 	ldw	r2,-108(fp)
81134f4c:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134f50:	e0bfe717 	ldw	r2,-100(fp)
81134f54:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81134f58:	e0800217 	ldw	r2,8(fp)
81134f5c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81134f60:	e0bfe80b 	ldhu	r2,-96(fp)
81134f64:	0000f806 	br	81135348 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81134f68:	e13ffd0b 	ldhu	r4,-12(fp)
81134f6c:	e17ffe03 	ldbu	r5,-8(fp)
81134f70:	e0bfff0b 	ldhu	r2,-4(fp)
81134f74:	e0fff704 	addi	r3,fp,-36
81134f78:	d8800015 	stw	r2,0(sp)
81134f7c:	280f883a 	mov	r7,r5
81134f80:	200d883a 	mov	r6,r4
81134f84:	180b883a 	mov	r5,r3
81134f88:	e13ffc17 	ldw	r4,-16(fp)
81134f8c:	113582c0 	call	8113582c <OS_FlagBlock>
81134f90:	e0bfe517 	ldw	r2,-108(fp)
81134f94:	e0bfe915 	stw	r2,-92(fp)
81134f98:	e0bfe917 	ldw	r2,-92(fp)
81134f9c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81134fa0:	00009206 	br	811351ec <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
81134fa4:	e0bffc17 	ldw	r2,-16(fp)
81134fa8:	10c0020b 	ldhu	r3,8(r2)
81134fac:	e0bffd0b 	ldhu	r2,-12(fp)
81134fb0:	1884703a 	and	r2,r3,r2
81134fb4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81134fb8:	e0bfe80b 	ldhu	r2,-96(fp)
81134fbc:	10001726 	beq	r2,zero,8113501c <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81134fc0:	e0bfe403 	ldbu	r2,-112(fp)
81134fc4:	10800058 	cmpnei	r2,r2,1
81134fc8:	1000091e 	bne	r2,zero,81134ff0 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81134fcc:	e0bffc17 	ldw	r2,-16(fp)
81134fd0:	1080020b 	ldhu	r2,8(r2)
81134fd4:	1007883a 	mov	r3,r2
81134fd8:	e0bfe80b 	ldhu	r2,-96(fp)
81134fdc:	0084303a 	nor	r2,zero,r2
81134fe0:	1884703a 	and	r2,r3,r2
81134fe4:	1007883a 	mov	r3,r2
81134fe8:	e0bffc17 	ldw	r2,-16(fp)
81134fec:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81134ff0:	d0a0a717 	ldw	r2,-32100(gp)
81134ff4:	e0ffe80b 	ldhu	r3,-96(fp)
81134ff8:	10c00b0d 	sth	r3,44(r2)
81134ffc:	e0bfe517 	ldw	r2,-108(fp)
81135000:	e0bfea15 	stw	r2,-88(fp)
81135004:	e0bfea17 	ldw	r2,-88(fp)
81135008:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113500c:	e0800217 	ldw	r2,8(fp)
81135010:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81135014:	e0bfe80b 	ldhu	r2,-96(fp)
81135018:	0000cb06 	br	81135348 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113501c:	e13ffd0b 	ldhu	r4,-12(fp)
81135020:	e17ffe03 	ldbu	r5,-8(fp)
81135024:	e0bfff0b 	ldhu	r2,-4(fp)
81135028:	e0fff704 	addi	r3,fp,-36
8113502c:	d8800015 	stw	r2,0(sp)
81135030:	280f883a 	mov	r7,r5
81135034:	200d883a 	mov	r6,r4
81135038:	180b883a 	mov	r5,r3
8113503c:	e13ffc17 	ldw	r4,-16(fp)
81135040:	113582c0 	call	8113582c <OS_FlagBlock>
81135044:	e0bfe517 	ldw	r2,-108(fp)
81135048:	e0bfeb15 	stw	r2,-84(fp)
8113504c:	e0bfeb17 	ldw	r2,-84(fp)
81135050:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81135054:	00006506 	br	811351ec <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81135058:	e0bffc17 	ldw	r2,-16(fp)
8113505c:	1080020b 	ldhu	r2,8(r2)
81135060:	0084303a 	nor	r2,zero,r2
81135064:	1007883a 	mov	r3,r2
81135068:	e0bffd0b 	ldhu	r2,-12(fp)
8113506c:	1884703a 	and	r2,r3,r2
81135070:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81135074:	e0ffe80b 	ldhu	r3,-96(fp)
81135078:	e0bffd0b 	ldhu	r2,-12(fp)
8113507c:	1880151e 	bne	r3,r2,811350d4 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135080:	e0bfe403 	ldbu	r2,-112(fp)
81135084:	10800058 	cmpnei	r2,r2,1
81135088:	1000071e 	bne	r2,zero,811350a8 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113508c:	e0bffc17 	ldw	r2,-16(fp)
81135090:	10c0020b 	ldhu	r3,8(r2)
81135094:	e0bfe80b 	ldhu	r2,-96(fp)
81135098:	1884b03a 	or	r2,r3,r2
8113509c:	1007883a 	mov	r3,r2
811350a0:	e0bffc17 	ldw	r2,-16(fp)
811350a4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811350a8:	d0a0a717 	ldw	r2,-32100(gp)
811350ac:	e0ffe80b 	ldhu	r3,-96(fp)
811350b0:	10c00b0d 	sth	r3,44(r2)
811350b4:	e0bfe517 	ldw	r2,-108(fp)
811350b8:	e0bfec15 	stw	r2,-80(fp)
811350bc:	e0bfec17 	ldw	r2,-80(fp)
811350c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811350c4:	e0800217 	ldw	r2,8(fp)
811350c8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811350cc:	e0bfe80b 	ldhu	r2,-96(fp)
811350d0:	00009d06 	br	81135348 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811350d4:	e13ffd0b 	ldhu	r4,-12(fp)
811350d8:	e17ffe03 	ldbu	r5,-8(fp)
811350dc:	e0bfff0b 	ldhu	r2,-4(fp)
811350e0:	e0fff704 	addi	r3,fp,-36
811350e4:	d8800015 	stw	r2,0(sp)
811350e8:	280f883a 	mov	r7,r5
811350ec:	200d883a 	mov	r6,r4
811350f0:	180b883a 	mov	r5,r3
811350f4:	e13ffc17 	ldw	r4,-16(fp)
811350f8:	113582c0 	call	8113582c <OS_FlagBlock>
811350fc:	e0bfe517 	ldw	r2,-108(fp)
81135100:	e0bfed15 	stw	r2,-76(fp)
81135104:	e0bfed17 	ldw	r2,-76(fp)
81135108:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113510c:	00003706 	br	811351ec <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81135110:	e0bffc17 	ldw	r2,-16(fp)
81135114:	1080020b 	ldhu	r2,8(r2)
81135118:	0084303a 	nor	r2,zero,r2
8113511c:	1007883a 	mov	r3,r2
81135120:	e0bffd0b 	ldhu	r2,-12(fp)
81135124:	1884703a 	and	r2,r3,r2
81135128:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113512c:	e0bfe80b 	ldhu	r2,-96(fp)
81135130:	10001526 	beq	r2,zero,81135188 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81135134:	e0bfe403 	ldbu	r2,-112(fp)
81135138:	10800058 	cmpnei	r2,r2,1
8113513c:	1000071e 	bne	r2,zero,8113515c <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81135140:	e0bffc17 	ldw	r2,-16(fp)
81135144:	10c0020b 	ldhu	r3,8(r2)
81135148:	e0bfe80b 	ldhu	r2,-96(fp)
8113514c:	1884b03a 	or	r2,r3,r2
81135150:	1007883a 	mov	r3,r2
81135154:	e0bffc17 	ldw	r2,-16(fp)
81135158:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113515c:	d0a0a717 	ldw	r2,-32100(gp)
81135160:	e0ffe80b 	ldhu	r3,-96(fp)
81135164:	10c00b0d 	sth	r3,44(r2)
81135168:	e0bfe517 	ldw	r2,-108(fp)
8113516c:	e0bfee15 	stw	r2,-72(fp)
81135170:	e0bfee17 	ldw	r2,-72(fp)
81135174:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81135178:	e0800217 	ldw	r2,8(fp)
8113517c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81135180:	e0bfe80b 	ldhu	r2,-96(fp)
81135184:	00007006 	br	81135348 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81135188:	e13ffd0b 	ldhu	r4,-12(fp)
8113518c:	e17ffe03 	ldbu	r5,-8(fp)
81135190:	e0bfff0b 	ldhu	r2,-4(fp)
81135194:	e0fff704 	addi	r3,fp,-36
81135198:	d8800015 	stw	r2,0(sp)
8113519c:	280f883a 	mov	r7,r5
811351a0:	200d883a 	mov	r6,r4
811351a4:	180b883a 	mov	r5,r3
811351a8:	e13ffc17 	ldw	r4,-16(fp)
811351ac:	113582c0 	call	8113582c <OS_FlagBlock>
811351b0:	e0bfe517 	ldw	r2,-108(fp)
811351b4:	e0bfef15 	stw	r2,-68(fp)
811351b8:	e0bfef17 	ldw	r2,-68(fp)
811351bc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811351c0:	00000a06 	br	811351ec <OSFlagPend+0x450>
811351c4:	e0bfe517 	ldw	r2,-108(fp)
811351c8:	e0bff015 	stw	r2,-64(fp)
811351cc:	e0bff017 	ldw	r2,-64(fp)
811351d0:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
811351d4:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
811351d8:	e0800217 	ldw	r2,8(fp)
811351dc:	00c01bc4 	movi	r3,111
811351e0:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
811351e4:	e0bfe80b 	ldhu	r2,-96(fp)
811351e8:	00005706 	br	81135348 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
811351ec:	1133b8c0 	call	81133b8c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811351f0:	0005303a 	rdctl	r2,status
811351f4:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811351f8:	e0fff117 	ldw	r3,-60(fp)
811351fc:	00bfff84 	movi	r2,-2
81135200:	1884703a 	and	r2,r3,r2
81135204:	1001703a 	wrctl	status,r2
  
  return context;
81135208:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113520c:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
81135210:	d0a0a717 	ldw	r2,-32100(gp)
81135214:	10800c43 	ldbu	r2,49(r2)
81135218:	10803fcc 	andi	r2,r2,255
8113521c:	10001c26 	beq	r2,zero,81135290 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
81135220:	d0a0a717 	ldw	r2,-32100(gp)
81135224:	10800c43 	ldbu	r2,49(r2)
81135228:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113522c:	d0a0a717 	ldw	r2,-32100(gp)
81135230:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
81135234:	e0bff704 	addi	r2,fp,-36
81135238:	1009883a 	mov	r4,r2
8113523c:	1135b780 	call	81135b78 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
81135240:	d0a0a717 	ldw	r2,-32100(gp)
81135244:	10000c05 	stb	zero,48(r2)
81135248:	e0bfe517 	ldw	r2,-108(fp)
8113524c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135250:	e0bff217 	ldw	r2,-56(fp)
81135254:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81135258:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113525c:	e0bff303 	ldbu	r2,-52(fp)
81135260:	108000a0 	cmpeqi	r2,r2,2
81135264:	10000426 	beq	r2,zero,81135278 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81135268:	e0800217 	ldw	r2,8(fp)
8113526c:	00c00384 	movi	r3,14
81135270:	10c00005 	stb	r3,0(r2)
                 break;
81135274:	00000406 	br	81135288 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81135278:	e0800217 	ldw	r2,8(fp)
8113527c:	00c00284 	movi	r3,10
81135280:	10c00005 	stb	r3,0(r2)
                 break;
81135284:	0001883a 	nop
        }
        return (flags_rdy);
81135288:	e0bfe80b 	ldhu	r2,-96(fp)
8113528c:	00002e06 	br	81135348 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
81135290:	d0a0a717 	ldw	r2,-32100(gp)
81135294:	10800b0b 	ldhu	r2,44(r2)
81135298:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113529c:	e0bfe403 	ldbu	r2,-112(fp)
811352a0:	10800058 	cmpnei	r2,r2,1
811352a4:	1000211e 	bne	r2,zero,8113532c <OSFlagPend+0x590>
        switch (wait_type) {
811352a8:	e0bffe03 	ldbu	r2,-8(fp)
811352ac:	10001616 	blt	r2,zero,81135308 <OSFlagPend+0x56c>
811352b0:	10c00090 	cmplti	r3,r2,2
811352b4:	18000c1e 	bne	r3,zero,811352e8 <OSFlagPend+0x54c>
811352b8:	10800108 	cmpgei	r2,r2,4
811352bc:	1000121e 	bne	r2,zero,81135308 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
811352c0:	e0bffc17 	ldw	r2,-16(fp)
811352c4:	1080020b 	ldhu	r2,8(r2)
811352c8:	1007883a 	mov	r3,r2
811352cc:	e0bfe80b 	ldhu	r2,-96(fp)
811352d0:	0084303a 	nor	r2,zero,r2
811352d4:	1884703a 	and	r2,r3,r2
811352d8:	1007883a 	mov	r3,r2
811352dc:	e0bffc17 	ldw	r2,-16(fp)
811352e0:	10c0020d 	sth	r3,8(r2)
                 break;
811352e4:	00001106 	br	8113532c <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
811352e8:	e0bffc17 	ldw	r2,-16(fp)
811352ec:	10c0020b 	ldhu	r3,8(r2)
811352f0:	e0bfe80b 	ldhu	r2,-96(fp)
811352f4:	1884b03a 	or	r2,r3,r2
811352f8:	1007883a 	mov	r3,r2
811352fc:	e0bffc17 	ldw	r2,-16(fp)
81135300:	10c0020d 	sth	r3,8(r2)
                 break;
81135304:	00000906 	br	8113532c <OSFlagPend+0x590>
81135308:	e0bfe517 	ldw	r2,-108(fp)
8113530c:	e0bff415 	stw	r2,-48(fp)
81135310:	e0bff417 	ldw	r2,-48(fp)
81135314:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81135318:	e0800217 	ldw	r2,8(fp)
8113531c:	00c01bc4 	movi	r3,111
81135320:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81135324:	0005883a 	mov	r2,zero
81135328:	00000706 	br	81135348 <OSFlagPend+0x5ac>
8113532c:	e0bfe517 	ldw	r2,-108(fp)
81135330:	e0bff515 	stw	r2,-44(fp)
81135334:	e0bff517 	ldw	r2,-44(fp)
81135338:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113533c:	e0800217 	ldw	r2,8(fp)
81135340:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81135344:	e0bfe80b 	ldhu	r2,-96(fp)
}
81135348:	e037883a 	mov	sp,fp
8113534c:	dfc00117 	ldw	ra,4(sp)
81135350:	df000017 	ldw	fp,0(sp)
81135354:	dec00204 	addi	sp,sp,8
81135358:	f800283a 	ret

8113535c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113535c:	defffb04 	addi	sp,sp,-20
81135360:	de00012e 	bgeu	sp,et,81135368 <OSFlagPendGetFlagsRdy+0xc>
81135364:	003b68fa 	trap	3
81135368:	df000415 	stw	fp,16(sp)
8113536c:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81135370:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135374:	0005303a 	rdctl	r2,status
81135378:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113537c:	e0fffe17 	ldw	r3,-8(fp)
81135380:	00bfff84 	movi	r2,-2
81135384:	1884703a 	and	r2,r3,r2
81135388:	1001703a 	wrctl	status,r2
  
  return context;
8113538c:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81135390:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81135394:	d0a0a717 	ldw	r2,-32100(gp)
81135398:	10800b0b 	ldhu	r2,44(r2)
8113539c:	e0bffd0d 	sth	r2,-12(fp)
811353a0:	e0bffc17 	ldw	r2,-16(fp)
811353a4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811353a8:	e0bfff17 	ldw	r2,-4(fp)
811353ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
811353b0:	e0bffd0b 	ldhu	r2,-12(fp)
}
811353b4:	e037883a 	mov	sp,fp
811353b8:	df000017 	ldw	fp,0(sp)
811353bc:	dec00104 	addi	sp,sp,4
811353c0:	f800283a 	ret

811353c4 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
811353c4:	deffef04 	addi	sp,sp,-68
811353c8:	de00012e 	bgeu	sp,et,811353d0 <OSFlagPost+0xc>
811353cc:	003b68fa 	trap	3
811353d0:	dfc01015 	stw	ra,64(sp)
811353d4:	df000f15 	stw	fp,60(sp)
811353d8:	df000f04 	addi	fp,sp,60
811353dc:	e13ffc15 	stw	r4,-16(fp)
811353e0:	2807883a 	mov	r3,r5
811353e4:	3005883a 	mov	r2,r6
811353e8:	e1ffff15 	stw	r7,-4(fp)
811353ec:	e0fffd0d 	sth	r3,-12(fp)
811353f0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
811353f4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811353f8:	e0bfff17 	ldw	r2,-4(fp)
811353fc:	1000021e 	bne	r2,zero,81135408 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
81135400:	0005883a 	mov	r2,zero
81135404:	0000d106 	br	8113574c <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
81135408:	e0bffc17 	ldw	r2,-16(fp)
8113540c:	1000051e 	bne	r2,zero,81135424 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135410:	e0bfff17 	ldw	r2,-4(fp)
81135414:	00c01b84 	movi	r3,110
81135418:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113541c:	0005883a 	mov	r2,zero
81135420:	0000ca06 	br	8113574c <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81135424:	e0bffc17 	ldw	r2,-16(fp)
81135428:	10800003 	ldbu	r2,0(r2)
8113542c:	10803fcc 	andi	r2,r2,255
81135430:	10800160 	cmpeqi	r2,r2,5
81135434:	1000051e 	bne	r2,zero,8113544c <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
81135438:	e0bfff17 	ldw	r2,-4(fp)
8113543c:	00c00044 	movi	r3,1
81135440:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81135444:	0005883a 	mov	r2,zero
81135448:	0000c006 	br	8113574c <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113544c:	0005303a 	rdctl	r2,status
81135450:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135454:	e0fffb17 	ldw	r3,-20(fp)
81135458:	00bfff84 	movi	r2,-2
8113545c:	1884703a 	and	r2,r3,r2
81135460:	1001703a 	wrctl	status,r2
  
  return context;
81135464:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81135468:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113546c:	e0bffe03 	ldbu	r2,-8(fp)
81135470:	10000326 	beq	r2,zero,81135480 <OSFlagPost+0xbc>
81135474:	10800060 	cmpeqi	r2,r2,1
81135478:	10000b1e 	bne	r2,zero,811354a8 <OSFlagPost+0xe4>
8113547c:	00001206 	br	811354c8 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
81135480:	e0bffc17 	ldw	r2,-16(fp)
81135484:	1080020b 	ldhu	r2,8(r2)
81135488:	1007883a 	mov	r3,r2
8113548c:	e0bffd0b 	ldhu	r2,-12(fp)
81135490:	0084303a 	nor	r2,zero,r2
81135494:	1884703a 	and	r2,r3,r2
81135498:	1007883a 	mov	r3,r2
8113549c:	e0bffc17 	ldw	r2,-16(fp)
811354a0:	10c0020d 	sth	r3,8(r2)
             break;
811354a4:	00001106 	br	811354ec <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
811354a8:	e0bffc17 	ldw	r2,-16(fp)
811354ac:	10c0020b 	ldhu	r3,8(r2)
811354b0:	e0bffd0b 	ldhu	r2,-12(fp)
811354b4:	1884b03a 	or	r2,r3,r2
811354b8:	1007883a 	mov	r3,r2
811354bc:	e0bffc17 	ldw	r2,-16(fp)
811354c0:	10c0020d 	sth	r3,8(r2)
             break;
811354c4:	00000906 	br	811354ec <OSFlagPost+0x128>
811354c8:	e0bff317 	ldw	r2,-52(fp)
811354cc:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811354d0:	e0bff417 	ldw	r2,-48(fp)
811354d4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
811354d8:	e0bfff17 	ldw	r2,-4(fp)
811354dc:	00c01c44 	movi	r3,113
811354e0:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
811354e4:	0005883a 	mov	r2,zero
811354e8:	00009806 	br	8113574c <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
811354ec:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811354f0:	e0bffc17 	ldw	r2,-16(fp)
811354f4:	10800117 	ldw	r2,4(r2)
811354f8:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811354fc:	00007706 	br	811356dc <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
81135500:	e0bff117 	ldw	r2,-60(fp)
81135504:	10800483 	ldbu	r2,18(r2)
81135508:	10803fcc 	andi	r2,r2,255
8113550c:	10c00060 	cmpeqi	r3,r2,1
81135510:	18004a1e 	bne	r3,zero,8113563c <OSFlagPost+0x278>
81135514:	10c00088 	cmpgei	r3,r2,2
81135518:	1800021e 	bne	r3,zero,81135524 <OSFlagPost+0x160>
8113551c:	10002f26 	beq	r2,zero,811355dc <OSFlagPost+0x218>
81135520:	00005b06 	br	81135690 <OSFlagPost+0x2cc>
81135524:	10c000a0 	cmpeqi	r3,r2,2
81135528:	1800031e 	bne	r3,zero,81135538 <OSFlagPost+0x174>
8113552c:	108000e0 	cmpeqi	r2,r2,3
81135530:	1000171e 	bne	r2,zero,81135590 <OSFlagPost+0x1cc>
81135534:	00005606 	br	81135690 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81135538:	e0bffc17 	ldw	r2,-16(fp)
8113553c:	10c0020b 	ldhu	r3,8(r2)
81135540:	e0bff117 	ldw	r2,-60(fp)
81135544:	1080040b 	ldhu	r2,16(r2)
81135548:	1884703a 	and	r2,r3,r2
8113554c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81135550:	e0bff117 	ldw	r2,-60(fp)
81135554:	1080040b 	ldhu	r2,16(r2)
81135558:	10ffffcc 	andi	r3,r2,65535
8113555c:	e0bff60b 	ldhu	r2,-40(fp)
81135560:	1880541e 	bne	r3,r2,811356b4 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81135564:	e0bff60b 	ldhu	r2,-40(fp)
81135568:	100b883a 	mov	r5,r2
8113556c:	e13ff117 	ldw	r4,-60(fp)
81135570:	1135a7c0 	call	81135a7c <OS_FlagTaskRdy>
81135574:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81135578:	e0bff683 	ldbu	r2,-38(fp)
8113557c:	10800058 	cmpnei	r2,r2,1
81135580:	10004c1e 	bne	r2,zero,811356b4 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81135584:	00800044 	movi	r2,1
81135588:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113558c:	00004906 	br	811356b4 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81135590:	e0bffc17 	ldw	r2,-16(fp)
81135594:	10c0020b 	ldhu	r3,8(r2)
81135598:	e0bff117 	ldw	r2,-60(fp)
8113559c:	1080040b 	ldhu	r2,16(r2)
811355a0:	1884703a 	and	r2,r3,r2
811355a4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
811355a8:	e0bff60b 	ldhu	r2,-40(fp)
811355ac:	10004326 	beq	r2,zero,811356bc <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811355b0:	e0bff60b 	ldhu	r2,-40(fp)
811355b4:	100b883a 	mov	r5,r2
811355b8:	e13ff117 	ldw	r4,-60(fp)
811355bc:	1135a7c0 	call	81135a7c <OS_FlagTaskRdy>
811355c0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811355c4:	e0bff683 	ldbu	r2,-38(fp)
811355c8:	10800058 	cmpnei	r2,r2,1
811355cc:	10003b1e 	bne	r2,zero,811356bc <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811355d0:	00800044 	movi	r2,1
811355d4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811355d8:	00003806 	br	811356bc <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811355dc:	e0bffc17 	ldw	r2,-16(fp)
811355e0:	1080020b 	ldhu	r2,8(r2)
811355e4:	0084303a 	nor	r2,zero,r2
811355e8:	1007883a 	mov	r3,r2
811355ec:	e0bff117 	ldw	r2,-60(fp)
811355f0:	1080040b 	ldhu	r2,16(r2)
811355f4:	1884703a 	and	r2,r3,r2
811355f8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
811355fc:	e0bff117 	ldw	r2,-60(fp)
81135600:	1080040b 	ldhu	r2,16(r2)
81135604:	10ffffcc 	andi	r3,r2,65535
81135608:	e0bff60b 	ldhu	r2,-40(fp)
8113560c:	18802d1e 	bne	r3,r2,811356c4 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81135610:	e0bff60b 	ldhu	r2,-40(fp)
81135614:	100b883a 	mov	r5,r2
81135618:	e13ff117 	ldw	r4,-60(fp)
8113561c:	1135a7c0 	call	81135a7c <OS_FlagTaskRdy>
81135620:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81135624:	e0bff683 	ldbu	r2,-38(fp)
81135628:	10800058 	cmpnei	r2,r2,1
8113562c:	1000251e 	bne	r2,zero,811356c4 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81135630:	00800044 	movi	r2,1
81135634:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81135638:	00002206 	br	811356c4 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113563c:	e0bffc17 	ldw	r2,-16(fp)
81135640:	1080020b 	ldhu	r2,8(r2)
81135644:	0084303a 	nor	r2,zero,r2
81135648:	1007883a 	mov	r3,r2
8113564c:	e0bff117 	ldw	r2,-60(fp)
81135650:	1080040b 	ldhu	r2,16(r2)
81135654:	1884703a 	and	r2,r3,r2
81135658:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113565c:	e0bff60b 	ldhu	r2,-40(fp)
81135660:	10001a26 	beq	r2,zero,811356cc <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81135664:	e0bff60b 	ldhu	r2,-40(fp)
81135668:	100b883a 	mov	r5,r2
8113566c:	e13ff117 	ldw	r4,-60(fp)
81135670:	1135a7c0 	call	81135a7c <OS_FlagTaskRdy>
81135674:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81135678:	e0bff683 	ldbu	r2,-38(fp)
8113567c:	10800058 	cmpnei	r2,r2,1
81135680:	1000121e 	bne	r2,zero,811356cc <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81135684:	00800044 	movi	r2,1
81135688:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113568c:	00000f06 	br	811356cc <OSFlagPost+0x308>
81135690:	e0bff317 	ldw	r2,-52(fp)
81135694:	e0bff515 	stw	r2,-44(fp)
81135698:	e0bff517 	ldw	r2,-44(fp)
8113569c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811356a0:	e0bfff17 	ldw	r2,-4(fp)
811356a4:	00c01bc4 	movi	r3,111
811356a8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811356ac:	0005883a 	mov	r2,zero
811356b0:	00002606 	br	8113574c <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811356b4:	0001883a 	nop
811356b8:	00000506 	br	811356d0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811356bc:	0001883a 	nop
811356c0:	00000306 	br	811356d0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811356c4:	0001883a 	nop
811356c8:	00000106 	br	811356d0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811356cc:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
811356d0:	e0bff117 	ldw	r2,-60(fp)
811356d4:	10800017 	ldw	r2,0(r2)
811356d8:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811356dc:	e0bff117 	ldw	r2,-60(fp)
811356e0:	103f871e 	bne	r2,zero,81135500 <__reset+0xfb115500>
811356e4:	e0bff317 	ldw	r2,-52(fp)
811356e8:	e0bff715 	stw	r2,-36(fp)
811356ec:	e0bff717 	ldw	r2,-36(fp)
811356f0:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
811356f4:	e0bff203 	ldbu	r2,-56(fp)
811356f8:	10800058 	cmpnei	r2,r2,1
811356fc:	1000011e 	bne	r2,zero,81135704 <OSFlagPost+0x340>
        OS_Sched();
81135700:	1133b8c0 	call	81133b8c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135704:	0005303a 	rdctl	r2,status
81135708:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113570c:	e0fffa17 	ldw	r3,-24(fp)
81135710:	00bfff84 	movi	r2,-2
81135714:	1884703a 	and	r2,r3,r2
81135718:	1001703a 	wrctl	status,r2
  
  return context;
8113571c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
81135720:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81135724:	e0bffc17 	ldw	r2,-16(fp)
81135728:	1080020b 	ldhu	r2,8(r2)
8113572c:	e0bff90d 	sth	r2,-28(fp)
81135730:	e0bff317 	ldw	r2,-52(fp)
81135734:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135738:	e0bff817 	ldw	r2,-32(fp)
8113573c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
81135740:	e0bfff17 	ldw	r2,-4(fp)
81135744:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81135748:	e0bff90b 	ldhu	r2,-28(fp)
}
8113574c:	e037883a 	mov	sp,fp
81135750:	dfc00117 	ldw	ra,4(sp)
81135754:	df000017 	ldw	fp,0(sp)
81135758:	dec00204 	addi	sp,sp,8
8113575c:	f800283a 	ret

81135760 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81135760:	defff904 	addi	sp,sp,-28
81135764:	de00012e 	bgeu	sp,et,8113576c <OSFlagQuery+0xc>
81135768:	003b68fa 	trap	3
8113576c:	df000615 	stw	fp,24(sp)
81135770:	df000604 	addi	fp,sp,24
81135774:	e13ffe15 	stw	r4,-8(fp)
81135778:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113577c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
81135780:	e0bfff17 	ldw	r2,-4(fp)
81135784:	1000021e 	bne	r2,zero,81135790 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
81135788:	0005883a 	mov	r2,zero
8113578c:	00002306 	br	8113581c <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
81135790:	e0bffe17 	ldw	r2,-8(fp)
81135794:	1000051e 	bne	r2,zero,811357ac <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81135798:	e0bfff17 	ldw	r2,-4(fp)
8113579c:	00c01b84 	movi	r3,110
811357a0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811357a4:	0005883a 	mov	r2,zero
811357a8:	00001c06 	br	8113581c <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
811357ac:	e0bffe17 	ldw	r2,-8(fp)
811357b0:	10800003 	ldbu	r2,0(r2)
811357b4:	10803fcc 	andi	r2,r2,255
811357b8:	10800160 	cmpeqi	r2,r2,5
811357bc:	1000051e 	bne	r2,zero,811357d4 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811357c0:	e0bfff17 	ldw	r2,-4(fp)
811357c4:	00c00044 	movi	r3,1
811357c8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811357cc:	0005883a 	mov	r2,zero
811357d0:	00001206 	br	8113581c <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811357d4:	0005303a 	rdctl	r2,status
811357d8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811357dc:	e0fffc17 	ldw	r3,-16(fp)
811357e0:	00bfff84 	movi	r2,-2
811357e4:	1884703a 	and	r2,r3,r2
811357e8:	1001703a 	wrctl	status,r2
  
  return context;
811357ec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811357f0:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
811357f4:	e0bffe17 	ldw	r2,-8(fp)
811357f8:	1080020b 	ldhu	r2,8(r2)
811357fc:	e0bffb0d 	sth	r2,-20(fp)
81135800:	e0bffa17 	ldw	r2,-24(fp)
81135804:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135808:	e0bffd17 	ldw	r2,-12(fp)
8113580c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81135810:	e0bfff17 	ldw	r2,-4(fp)
81135814:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
81135818:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113581c:	e037883a 	mov	sp,fp
81135820:	df000017 	ldw	fp,0(sp)
81135824:	dec00104 	addi	sp,sp,4
81135828:	f800283a 	ret

8113582c <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113582c:	defff804 	addi	sp,sp,-32
81135830:	de00012e 	bgeu	sp,et,81135838 <OS_FlagBlock+0xc>
81135834:	003b68fa 	trap	3
81135838:	df000715 	stw	fp,28(sp)
8113583c:	df000704 	addi	fp,sp,28
81135840:	e13ffb15 	stw	r4,-20(fp)
81135844:	e17ffc15 	stw	r5,-16(fp)
81135848:	3009883a 	mov	r4,r6
8113584c:	3807883a 	mov	r3,r7
81135850:	e0800117 	ldw	r2,4(fp)
81135854:	e13ffd0d 	sth	r4,-12(fp)
81135858:	e0fffe05 	stb	r3,-8(fp)
8113585c:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
81135860:	d0a0a717 	ldw	r2,-32100(gp)
81135864:	d0e0a717 	ldw	r3,-32100(gp)
81135868:	18c00c03 	ldbu	r3,48(r3)
8113586c:	18c00814 	ori	r3,r3,32
81135870:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
81135874:	d0a0a717 	ldw	r2,-32100(gp)
81135878:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113587c:	d0a0a717 	ldw	r2,-32100(gp)
81135880:	e0ffff0b 	ldhu	r3,-4(fp)
81135884:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
81135888:	d0a0a717 	ldw	r2,-32100(gp)
8113588c:	e0fffc17 	ldw	r3,-16(fp)
81135890:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
81135894:	e0bffc17 	ldw	r2,-16(fp)
81135898:	e0fffd0b 	ldhu	r3,-12(fp)
8113589c:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
811358a0:	e0bffc17 	ldw	r2,-16(fp)
811358a4:	e0fffe03 	ldbu	r3,-8(fp)
811358a8:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
811358ac:	d0e0a717 	ldw	r3,-32100(gp)
811358b0:	e0bffc17 	ldw	r2,-16(fp)
811358b4:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
811358b8:	e0bffb17 	ldw	r2,-20(fp)
811358bc:	10c00117 	ldw	r3,4(r2)
811358c0:	e0bffc17 	ldw	r2,-16(fp)
811358c4:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
811358c8:	e0bffc17 	ldw	r2,-16(fp)
811358cc:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
811358d0:	e0bffc17 	ldw	r2,-16(fp)
811358d4:	e0fffb17 	ldw	r3,-20(fp)
811358d8:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811358dc:	e0bffb17 	ldw	r2,-20(fp)
811358e0:	10800117 	ldw	r2,4(r2)
811358e4:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
811358e8:	e0bff917 	ldw	r2,-28(fp)
811358ec:	10000326 	beq	r2,zero,811358fc <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
811358f0:	e0bff917 	ldw	r2,-28(fp)
811358f4:	e0fffc17 	ldw	r3,-16(fp)
811358f8:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
811358fc:	e0bffb17 	ldw	r2,-20(fp)
81135900:	e0fffc17 	ldw	r3,-16(fp)
81135904:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
81135908:	d0a0a717 	ldw	r2,-32100(gp)
8113590c:	10800d03 	ldbu	r2,52(r2)
81135910:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81135914:	e0fffa03 	ldbu	r3,-24(fp)
81135918:	e13ffa03 	ldbu	r4,-24(fp)
8113591c:	d0a0a344 	addi	r2,gp,-32115
81135920:	2085883a 	add	r2,r4,r2
81135924:	10800003 	ldbu	r2,0(r2)
81135928:	1009883a 	mov	r4,r2
8113592c:	d0a0a717 	ldw	r2,-32100(gp)
81135930:	10800d43 	ldbu	r2,53(r2)
81135934:	0084303a 	nor	r2,zero,r2
81135938:	2084703a 	and	r2,r4,r2
8113593c:	1009883a 	mov	r4,r2
81135940:	d0a0a344 	addi	r2,gp,-32115
81135944:	1885883a 	add	r2,r3,r2
81135948:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113594c:	e0fffa03 	ldbu	r3,-24(fp)
81135950:	d0a0a344 	addi	r2,gp,-32115
81135954:	1885883a 	add	r2,r3,r2
81135958:	10800003 	ldbu	r2,0(r2)
8113595c:	10803fcc 	andi	r2,r2,255
81135960:	1000071e 	bne	r2,zero,81135980 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81135964:	d0a0a717 	ldw	r2,-32100(gp)
81135968:	10800d83 	ldbu	r2,54(r2)
8113596c:	0084303a 	nor	r2,zero,r2
81135970:	1007883a 	mov	r3,r2
81135974:	d0a0a303 	ldbu	r2,-32116(gp)
81135978:	1884703a 	and	r2,r3,r2
8113597c:	d0a0a305 	stb	r2,-32116(gp)
    }
}
81135980:	0001883a 	nop
81135984:	e037883a 	mov	sp,fp
81135988:	df000017 	ldw	fp,0(sp)
8113598c:	dec00104 	addi	sp,sp,4
81135990:	f800283a 	ret

81135994 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81135994:	defffb04 	addi	sp,sp,-20
81135998:	de00012e 	bgeu	sp,et,811359a0 <OS_FlagInit+0xc>
8113599c:	003b68fa 	trap	3
811359a0:	dfc00415 	stw	ra,16(sp)
811359a4:	df000315 	stw	fp,12(sp)
811359a8:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
811359ac:	01416004 	movi	r5,1408
811359b0:	012045b4 	movhi	r4,33046
811359b4:	213ec304 	addi	r4,r4,-1268
811359b8:	1133ac00 	call	81133ac0 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
811359bc:	00a045b4 	movhi	r2,33046
811359c0:	10bec304 	addi	r2,r2,-1268
811359c4:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
811359c8:	00a045b4 	movhi	r2,33046
811359cc:	10bece04 	addi	r2,r2,-1224
811359d0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
811359d4:	e03ffd0d 	sth	zero,-12(fp)
811359d8:	00001306 	br	81135a28 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
811359dc:	e0bffe17 	ldw	r2,-8(fp)
811359e0:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
811359e4:	e0bffe17 	ldw	r2,-8(fp)
811359e8:	e0ffff17 	ldw	r3,-4(fp)
811359ec:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
811359f0:	e0bffe17 	ldw	r2,-8(fp)
811359f4:	00c00fc4 	movi	r3,63
811359f8:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
811359fc:	e0bffe17 	ldw	r2,-8(fp)
81135a00:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81135a04:	e0bffe17 	ldw	r2,-8(fp)
81135a08:	10800b04 	addi	r2,r2,44
81135a0c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81135a10:	e0bfff17 	ldw	r2,-4(fp)
81135a14:	10800b04 	addi	r2,r2,44
81135a18:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81135a1c:	e0bffd0b 	ldhu	r2,-12(fp)
81135a20:	10800044 	addi	r2,r2,1
81135a24:	e0bffd0d 	sth	r2,-12(fp)
81135a28:	e0bffd0b 	ldhu	r2,-12(fp)
81135a2c:	108007f0 	cmpltui	r2,r2,31
81135a30:	103fea1e 	bne	r2,zero,811359dc <__reset+0xfb1159dc>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81135a34:	e0bffe17 	ldw	r2,-8(fp)
81135a38:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81135a3c:	e0bffe17 	ldw	r2,-8(fp)
81135a40:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81135a44:	e0bffe17 	ldw	r2,-8(fp)
81135a48:	00c00fc4 	movi	r3,63
81135a4c:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81135a50:	e0bffe17 	ldw	r2,-8(fp)
81135a54:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81135a58:	00a045b4 	movhi	r2,33046
81135a5c:	10bec304 	addi	r2,r2,-1268
81135a60:	d0a0ab15 	stw	r2,-32084(gp)
#endif
}
81135a64:	0001883a 	nop
81135a68:	e037883a 	mov	sp,fp
81135a6c:	dfc00117 	ldw	ra,4(sp)
81135a70:	df000017 	ldw	fp,0(sp)
81135a74:	dec00204 	addi	sp,sp,8
81135a78:	f800283a 	ret

81135a7c <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81135a7c:	defffa04 	addi	sp,sp,-24
81135a80:	de00012e 	bgeu	sp,et,81135a88 <OS_FlagTaskRdy+0xc>
81135a84:	003b68fa 	trap	3
81135a88:	dfc00515 	stw	ra,20(sp)
81135a8c:	df000415 	stw	fp,16(sp)
81135a90:	df000404 	addi	fp,sp,16
81135a94:	e13ffe15 	stw	r4,-8(fp)
81135a98:	2805883a 	mov	r2,r5
81135a9c:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
81135aa0:	e0bffe17 	ldw	r2,-8(fp)
81135aa4:	10800217 	ldw	r2,8(r2)
81135aa8:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81135aac:	e0bffd17 	ldw	r2,-12(fp)
81135ab0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81135ab4:	e0bffd17 	ldw	r2,-12(fp)
81135ab8:	e0ffff0b 	ldhu	r3,-4(fp)
81135abc:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
81135ac0:	e0bffd17 	ldw	r2,-12(fp)
81135ac4:	10c00c03 	ldbu	r3,48(r2)
81135ac8:	00bff7c4 	movi	r2,-33
81135acc:	1884703a 	and	r2,r3,r2
81135ad0:	1007883a 	mov	r3,r2
81135ad4:	e0bffd17 	ldw	r2,-12(fp)
81135ad8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81135adc:	e0bffd17 	ldw	r2,-12(fp)
81135ae0:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81135ae4:	e0bffd17 	ldw	r2,-12(fp)
81135ae8:	10800c03 	ldbu	r2,48(r2)
81135aec:	10803fcc 	andi	r2,r2,255
81135af0:	1000181e 	bne	r2,zero,81135b54 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81135af4:	e0bffd17 	ldw	r2,-12(fp)
81135af8:	10c00d83 	ldbu	r3,54(r2)
81135afc:	d0a0a303 	ldbu	r2,-32116(gp)
81135b00:	1884b03a 	or	r2,r3,r2
81135b04:	d0a0a305 	stb	r2,-32116(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81135b08:	e0bffd17 	ldw	r2,-12(fp)
81135b0c:	10800d03 	ldbu	r2,52(r2)
81135b10:	10c03fcc 	andi	r3,r2,255
81135b14:	e0bffd17 	ldw	r2,-12(fp)
81135b18:	10800d03 	ldbu	r2,52(r2)
81135b1c:	11003fcc 	andi	r4,r2,255
81135b20:	d0a0a344 	addi	r2,gp,-32115
81135b24:	2085883a 	add	r2,r4,r2
81135b28:	11000003 	ldbu	r4,0(r2)
81135b2c:	e0bffd17 	ldw	r2,-12(fp)
81135b30:	10800d43 	ldbu	r2,53(r2)
81135b34:	2084b03a 	or	r2,r4,r2
81135b38:	1009883a 	mov	r4,r2
81135b3c:	d0a0a344 	addi	r2,gp,-32115
81135b40:	1885883a 	add	r2,r3,r2
81135b44:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81135b48:	00800044 	movi	r2,1
81135b4c:	e0bffc05 	stb	r2,-16(fp)
81135b50:	00000106 	br	81135b58 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81135b54:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81135b58:	e13ffe17 	ldw	r4,-8(fp)
81135b5c:	1135b780 	call	81135b78 <OS_FlagUnlink>
    return (sched);
81135b60:	e0bffc03 	ldbu	r2,-16(fp)
}
81135b64:	e037883a 	mov	sp,fp
81135b68:	dfc00117 	ldw	ra,4(sp)
81135b6c:	df000017 	ldw	fp,0(sp)
81135b70:	dec00204 	addi	sp,sp,8
81135b74:	f800283a 	ret

81135b78 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
81135b78:	defffa04 	addi	sp,sp,-24
81135b7c:	de00012e 	bgeu	sp,et,81135b84 <OS_FlagUnlink+0xc>
81135b80:	003b68fa 	trap	3
81135b84:	df000515 	stw	fp,20(sp)
81135b88:	df000504 	addi	fp,sp,20
81135b8c:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
81135b90:	e0bfff17 	ldw	r2,-4(fp)
81135b94:	10800117 	ldw	r2,4(r2)
81135b98:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81135b9c:	e0bfff17 	ldw	r2,-4(fp)
81135ba0:	10800017 	ldw	r2,0(r2)
81135ba4:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
81135ba8:	e0bffb17 	ldw	r2,-20(fp)
81135bac:	10000b1e 	bne	r2,zero,81135bdc <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
81135bb0:	e0bfff17 	ldw	r2,-4(fp)
81135bb4:	10800317 	ldw	r2,12(r2)
81135bb8:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81135bbc:	e0bffd17 	ldw	r2,-12(fp)
81135bc0:	e0fffc17 	ldw	r3,-16(fp)
81135bc4:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81135bc8:	e0bffc17 	ldw	r2,-16(fp)
81135bcc:	10000b26 	beq	r2,zero,81135bfc <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81135bd0:	e0bffc17 	ldw	r2,-16(fp)
81135bd4:	10000115 	stw	zero,4(r2)
81135bd8:	00000806 	br	81135bfc <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81135bdc:	e0bffb17 	ldw	r2,-20(fp)
81135be0:	e0fffc17 	ldw	r3,-16(fp)
81135be4:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81135be8:	e0bffc17 	ldw	r2,-16(fp)
81135bec:	10000326 	beq	r2,zero,81135bfc <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81135bf0:	e0bffc17 	ldw	r2,-16(fp)
81135bf4:	e0fffb17 	ldw	r3,-20(fp)
81135bf8:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81135bfc:	e0bfff17 	ldw	r2,-4(fp)
81135c00:	10800217 	ldw	r2,8(r2)
81135c04:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81135c08:	e0bffe17 	ldw	r2,-8(fp)
81135c0c:	10000a15 	stw	zero,40(r2)
#endif
}
81135c10:	0001883a 	nop
81135c14:	e037883a 	mov	sp,fp
81135c18:	df000017 	ldw	fp,0(sp)
81135c1c:	dec00104 	addi	sp,sp,4
81135c20:	f800283a 	ret

81135c24 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81135c24:	defff404 	addi	sp,sp,-48
81135c28:	de00012e 	bgeu	sp,et,81135c30 <OSMemCreate+0xc>
81135c2c:	003b68fa 	trap	3
81135c30:	df000b15 	stw	fp,44(sp)
81135c34:	df000b04 	addi	fp,sp,44
81135c38:	e13ffc15 	stw	r4,-16(fp)
81135c3c:	e17ffd15 	stw	r5,-12(fp)
81135c40:	e1bffe15 	stw	r6,-8(fp)
81135c44:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81135c48:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81135c4c:	e0bfff17 	ldw	r2,-4(fp)
81135c50:	1000021e 	bne	r2,zero,81135c5c <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81135c54:	0005883a 	mov	r2,zero
81135c58:	00006506 	br	81135df0 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81135c5c:	e0bffc17 	ldw	r2,-16(fp)
81135c60:	1000051e 	bne	r2,zero,81135c78 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81135c64:	e0bfff17 	ldw	r2,-4(fp)
81135c68:	00c01884 	movi	r3,98
81135c6c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81135c70:	0005883a 	mov	r2,zero
81135c74:	00005e06 	br	81135df0 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
81135c78:	e0bffc17 	ldw	r2,-16(fp)
81135c7c:	108000cc 	andi	r2,r2,3
81135c80:	10000526 	beq	r2,zero,81135c98 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81135c84:	e0bfff17 	ldw	r2,-4(fp)
81135c88:	00c01884 	movi	r3,98
81135c8c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81135c90:	0005883a 	mov	r2,zero
81135c94:	00005606 	br	81135df0 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
81135c98:	e0bffd17 	ldw	r2,-12(fp)
81135c9c:	108000a8 	cmpgeui	r2,r2,2
81135ca0:	1000051e 	bne	r2,zero,81135cb8 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81135ca4:	e0bfff17 	ldw	r2,-4(fp)
81135ca8:	00c016c4 	movi	r3,91
81135cac:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81135cb0:	0005883a 	mov	r2,zero
81135cb4:	00004e06 	br	81135df0 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
81135cb8:	e0bffe17 	ldw	r2,-8(fp)
81135cbc:	10800128 	cmpgeui	r2,r2,4
81135cc0:	1000051e 	bne	r2,zero,81135cd8 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81135cc4:	e0bfff17 	ldw	r2,-4(fp)
81135cc8:	00c01704 	movi	r3,92
81135ccc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81135cd0:	0005883a 	mov	r2,zero
81135cd4:	00004606 	br	81135df0 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135cd8:	0005303a 	rdctl	r2,status
81135cdc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135ce0:	e0fffb17 	ldw	r3,-20(fp)
81135ce4:	00bfff84 	movi	r2,-2
81135ce8:	1884703a 	and	r2,r3,r2
81135cec:	1001703a 	wrctl	status,r2
  
  return context;
81135cf0:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81135cf4:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81135cf8:	d0a0a017 	ldw	r2,-32128(gp)
81135cfc:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81135d00:	d0a0a017 	ldw	r2,-32128(gp)
81135d04:	10000326 	beq	r2,zero,81135d14 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81135d08:	d0a0a017 	ldw	r2,-32128(gp)
81135d0c:	10800117 	ldw	r2,4(r2)
81135d10:	d0a0a015 	stw	r2,-32128(gp)
81135d14:	e0bff817 	ldw	r2,-32(fp)
81135d18:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135d1c:	e0bff917 	ldw	r2,-28(fp)
81135d20:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81135d24:	e0bffa17 	ldw	r2,-24(fp)
81135d28:	1000051e 	bne	r2,zero,81135d40 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81135d2c:	e0bfff17 	ldw	r2,-4(fp)
81135d30:	00c01684 	movi	r3,90
81135d34:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81135d38:	0005883a 	mov	r2,zero
81135d3c:	00002c06 	br	81135df0 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81135d40:	e0bffc17 	ldw	r2,-16(fp)
81135d44:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81135d48:	e0fffc17 	ldw	r3,-16(fp)
81135d4c:	e0bffe17 	ldw	r2,-8(fp)
81135d50:	1885883a 	add	r2,r3,r2
81135d54:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81135d58:	e03ff715 	stw	zero,-36(fp)
81135d5c:	00000c06 	br	81135d90 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81135d60:	e0bff617 	ldw	r2,-40(fp)
81135d64:	e0fff517 	ldw	r3,-44(fp)
81135d68:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81135d6c:	e0bff517 	ldw	r2,-44(fp)
81135d70:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81135d74:	e0fff517 	ldw	r3,-44(fp)
81135d78:	e0bffe17 	ldw	r2,-8(fp)
81135d7c:	1885883a 	add	r2,r3,r2
81135d80:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81135d84:	e0bff717 	ldw	r2,-36(fp)
81135d88:	10800044 	addi	r2,r2,1
81135d8c:	e0bff715 	stw	r2,-36(fp)
81135d90:	e0bffd17 	ldw	r2,-12(fp)
81135d94:	10bfffc4 	addi	r2,r2,-1
81135d98:	e0fff717 	ldw	r3,-36(fp)
81135d9c:	18bff036 	bltu	r3,r2,81135d60 <__reset+0xfb115d60>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
81135da0:	e0bff617 	ldw	r2,-40(fp)
81135da4:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81135da8:	e0bffa17 	ldw	r2,-24(fp)
81135dac:	e0fffc17 	ldw	r3,-16(fp)
81135db0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81135db4:	e0bffa17 	ldw	r2,-24(fp)
81135db8:	e0fffc17 	ldw	r3,-16(fp)
81135dbc:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
81135dc0:	e0bffa17 	ldw	r2,-24(fp)
81135dc4:	e0fffd17 	ldw	r3,-12(fp)
81135dc8:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81135dcc:	e0bffa17 	ldw	r2,-24(fp)
81135dd0:	e0fffd17 	ldw	r3,-12(fp)
81135dd4:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81135dd8:	e0bffa17 	ldw	r2,-24(fp)
81135ddc:	e0fffe17 	ldw	r3,-8(fp)
81135de0:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81135de4:	e0bfff17 	ldw	r2,-4(fp)
81135de8:	10000005 	stb	zero,0(r2)
    return (pmem);
81135dec:	e0bffa17 	ldw	r2,-24(fp)
}
81135df0:	e037883a 	mov	sp,fp
81135df4:	df000017 	ldw	fp,0(sp)
81135df8:	dec00104 	addi	sp,sp,4
81135dfc:	f800283a 	ret

81135e00 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81135e00:	defff804 	addi	sp,sp,-32
81135e04:	de00012e 	bgeu	sp,et,81135e0c <OSMemGet+0xc>
81135e08:	003b68fa 	trap	3
81135e0c:	df000715 	stw	fp,28(sp)
81135e10:	df000704 	addi	fp,sp,28
81135e14:	e13ffe15 	stw	r4,-8(fp)
81135e18:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81135e1c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81135e20:	e0bfff17 	ldw	r2,-4(fp)
81135e24:	1000021e 	bne	r2,zero,81135e30 <OSMemGet+0x30>
        return ((void *)0);
81135e28:	0005883a 	mov	r2,zero
81135e2c:	00002e06 	br	81135ee8 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81135e30:	e0bffe17 	ldw	r2,-8(fp)
81135e34:	1000051e 	bne	r2,zero,81135e4c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81135e38:	e0bfff17 	ldw	r2,-4(fp)
81135e3c:	00c01804 	movi	r3,96
81135e40:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81135e44:	0005883a 	mov	r2,zero
81135e48:	00002706 	br	81135ee8 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135e4c:	0005303a 	rdctl	r2,status
81135e50:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135e54:	e0fffd17 	ldw	r3,-12(fp)
81135e58:	00bfff84 	movi	r2,-2
81135e5c:	1884703a 	and	r2,r3,r2
81135e60:	1001703a 	wrctl	status,r2
  
  return context;
81135e64:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81135e68:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81135e6c:	e0bffe17 	ldw	r2,-8(fp)
81135e70:	10800417 	ldw	r2,16(r2)
81135e74:	10001426 	beq	r2,zero,81135ec8 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81135e78:	e0bffe17 	ldw	r2,-8(fp)
81135e7c:	10800117 	ldw	r2,4(r2)
81135e80:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81135e84:	e0bffb17 	ldw	r2,-20(fp)
81135e88:	10c00017 	ldw	r3,0(r2)
81135e8c:	e0bffe17 	ldw	r2,-8(fp)
81135e90:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81135e94:	e0bffe17 	ldw	r2,-8(fp)
81135e98:	10800417 	ldw	r2,16(r2)
81135e9c:	10ffffc4 	addi	r3,r2,-1
81135ea0:	e0bffe17 	ldw	r2,-8(fp)
81135ea4:	10c00415 	stw	r3,16(r2)
81135ea8:	e0bff917 	ldw	r2,-28(fp)
81135eac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135eb0:	e0bffa17 	ldw	r2,-24(fp)
81135eb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81135eb8:	e0bfff17 	ldw	r2,-4(fp)
81135ebc:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
81135ec0:	e0bffb17 	ldw	r2,-20(fp)
81135ec4:	00000806 	br	81135ee8 <OSMemGet+0xe8>
81135ec8:	e0bff917 	ldw	r2,-28(fp)
81135ecc:	e0bffc15 	stw	r2,-16(fp)
81135ed0:	e0bffc17 	ldw	r2,-16(fp)
81135ed4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81135ed8:	e0bfff17 	ldw	r2,-4(fp)
81135edc:	00c01744 	movi	r3,93
81135ee0:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81135ee4:	0005883a 	mov	r2,zero
}
81135ee8:	e037883a 	mov	sp,fp
81135eec:	df000017 	ldw	fp,0(sp)
81135ef0:	dec00104 	addi	sp,sp,4
81135ef4:	f800283a 	ret

81135ef8 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81135ef8:	defff704 	addi	sp,sp,-36
81135efc:	de00012e 	bgeu	sp,et,81135f04 <OSMemNameGet+0xc>
81135f00:	003b68fa 	trap	3
81135f04:	dfc00815 	stw	ra,32(sp)
81135f08:	df000715 	stw	fp,28(sp)
81135f0c:	df000704 	addi	fp,sp,28
81135f10:	e13ffd15 	stw	r4,-12(fp)
81135f14:	e17ffe15 	stw	r5,-8(fp)
81135f18:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135f1c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81135f20:	e0bfff17 	ldw	r2,-4(fp)
81135f24:	1000021e 	bne	r2,zero,81135f30 <OSMemNameGet+0x38>
        return (0);
81135f28:	0005883a 	mov	r2,zero
81135f2c:	00002b06 	br	81135fdc <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81135f30:	e0bffd17 	ldw	r2,-12(fp)
81135f34:	1000051e 	bne	r2,zero,81135f4c <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81135f38:	e0bfff17 	ldw	r2,-4(fp)
81135f3c:	00c01804 	movi	r3,96
81135f40:	10c00005 	stb	r3,0(r2)
        return (0);
81135f44:	0005883a 	mov	r2,zero
81135f48:	00002406 	br	81135fdc <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81135f4c:	e0bffe17 	ldw	r2,-8(fp)
81135f50:	1000051e 	bne	r2,zero,81135f68 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81135f54:	e0bfff17 	ldw	r2,-4(fp)
81135f58:	00c00304 	movi	r3,12
81135f5c:	10c00005 	stb	r3,0(r2)
        return (0);
81135f60:	0005883a 	mov	r2,zero
81135f64:	00001d06 	br	81135fdc <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81135f68:	d0a0a603 	ldbu	r2,-32104(gp)
81135f6c:	10803fcc 	andi	r2,r2,255
81135f70:	10000526 	beq	r2,zero,81135f88 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81135f74:	e0bfff17 	ldw	r2,-4(fp)
81135f78:	00c00444 	movi	r3,17
81135f7c:	10c00005 	stb	r3,0(r2)
        return (0);
81135f80:	0005883a 	mov	r2,zero
81135f84:	00001506 	br	81135fdc <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135f88:	0005303a 	rdctl	r2,status
81135f8c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135f90:	e0fffb17 	ldw	r3,-20(fp)
81135f94:	00bfff84 	movi	r2,-2
81135f98:	1884703a 	and	r2,r3,r2
81135f9c:	1001703a 	wrctl	status,r2
  
  return context;
81135fa0:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
81135fa4:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81135fa8:	e0bffd17 	ldw	r2,-12(fp)
81135fac:	10800504 	addi	r2,r2,20
81135fb0:	100b883a 	mov	r5,r2
81135fb4:	e13ffe17 	ldw	r4,-8(fp)
81135fb8:	1133ce00 	call	81133ce0 <OS_StrCopy>
81135fbc:	e0bffa05 	stb	r2,-24(fp)
81135fc0:	e0bff917 	ldw	r2,-28(fp)
81135fc4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135fc8:	e0bffc17 	ldw	r2,-16(fp)
81135fcc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81135fd0:	e0bfff17 	ldw	r2,-4(fp)
81135fd4:	10000005 	stb	zero,0(r2)
    return (len);
81135fd8:	e0bffa03 	ldbu	r2,-24(fp)
}
81135fdc:	e037883a 	mov	sp,fp
81135fe0:	dfc00117 	ldw	ra,4(sp)
81135fe4:	df000017 	ldw	fp,0(sp)
81135fe8:	dec00204 	addi	sp,sp,8
81135fec:	f800283a 	ret

81135ff0 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81135ff0:	defff604 	addi	sp,sp,-40
81135ff4:	de00012e 	bgeu	sp,et,81135ffc <OSMemNameSet+0xc>
81135ff8:	003b68fa 	trap	3
81135ffc:	dfc00915 	stw	ra,36(sp)
81136000:	df000815 	stw	fp,32(sp)
81136004:	df000804 	addi	fp,sp,32
81136008:	e13ffd15 	stw	r4,-12(fp)
8113600c:	e17ffe15 	stw	r5,-8(fp)
81136010:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136014:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81136018:	e0bfff17 	ldw	r2,-4(fp)
8113601c:	10003526 	beq	r2,zero,811360f4 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81136020:	e0bffd17 	ldw	r2,-12(fp)
81136024:	1000041e 	bne	r2,zero,81136038 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81136028:	e0bfff17 	ldw	r2,-4(fp)
8113602c:	00c01804 	movi	r3,96
81136030:	10c00005 	stb	r3,0(r2)
        return;
81136034:	00003006 	br	811360f8 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136038:	e0bffe17 	ldw	r2,-8(fp)
8113603c:	1000041e 	bne	r2,zero,81136050 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81136040:	e0bfff17 	ldw	r2,-4(fp)
81136044:	00c00304 	movi	r3,12
81136048:	10c00005 	stb	r3,0(r2)
        return;
8113604c:	00002a06 	br	811360f8 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136050:	d0a0a603 	ldbu	r2,-32104(gp)
81136054:	10803fcc 	andi	r2,r2,255
81136058:	10000426 	beq	r2,zero,8113606c <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113605c:	e0bfff17 	ldw	r2,-4(fp)
81136060:	00c00484 	movi	r3,18
81136064:	10c00005 	stb	r3,0(r2)
        return;
81136068:	00002306 	br	811360f8 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113606c:	0005303a 	rdctl	r2,status
81136070:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136074:	e0fffc17 	ldw	r3,-16(fp)
81136078:	00bfff84 	movi	r2,-2
8113607c:	1884703a 	and	r2,r3,r2
81136080:	1001703a 	wrctl	status,r2
  
  return context;
81136084:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136088:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113608c:	e13ffe17 	ldw	r4,-8(fp)
81136090:	1133d5c0 	call	81133d5c <OS_StrLen>
81136094:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81136098:	e0bffa03 	ldbu	r2,-24(fp)
8113609c:	10800830 	cmpltui	r2,r2,32
811360a0:	1000081e 	bne	r2,zero,811360c4 <OSMemNameSet+0xd4>
811360a4:	e0bff817 	ldw	r2,-32(fp)
811360a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811360ac:	e0bff917 	ldw	r2,-28(fp)
811360b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
811360b4:	e0bfff17 	ldw	r2,-4(fp)
811360b8:	00c018c4 	movi	r3,99
811360bc:	10c00005 	stb	r3,0(r2)
        return;
811360c0:	00000d06 	br	811360f8 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
811360c4:	e0bffd17 	ldw	r2,-12(fp)
811360c8:	10800504 	addi	r2,r2,20
811360cc:	e17ffe17 	ldw	r5,-8(fp)
811360d0:	1009883a 	mov	r4,r2
811360d4:	1133ce00 	call	81133ce0 <OS_StrCopy>
811360d8:	e0bff817 	ldw	r2,-32(fp)
811360dc:	e0bffb15 	stw	r2,-20(fp)
811360e0:	e0bffb17 	ldw	r2,-20(fp)
811360e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811360e8:	e0bfff17 	ldw	r2,-4(fp)
811360ec:	10000005 	stb	zero,0(r2)
811360f0:	00000106 	br	811360f8 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811360f4:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811360f8:	e037883a 	mov	sp,fp
811360fc:	dfc00117 	ldw	ra,4(sp)
81136100:	df000017 	ldw	fp,0(sp)
81136104:	dec00204 	addi	sp,sp,8
81136108:	f800283a 	ret

8113610c <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113610c:	defff904 	addi	sp,sp,-28
81136110:	de00012e 	bgeu	sp,et,81136118 <OSMemPut+0xc>
81136114:	003b68fa 	trap	3
81136118:	df000615 	stw	fp,24(sp)
8113611c:	df000604 	addi	fp,sp,24
81136120:	e13ffe15 	stw	r4,-8(fp)
81136124:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136128:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113612c:	e0bffe17 	ldw	r2,-8(fp)
81136130:	1000021e 	bne	r2,zero,8113613c <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81136134:	00801804 	movi	r2,96
81136138:	00002806 	br	811361dc <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113613c:	e0bfff17 	ldw	r2,-4(fp)
81136140:	1000021e 	bne	r2,zero,8113614c <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81136144:	008017c4 	movi	r2,95
81136148:	00002406 	br	811361dc <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113614c:	0005303a 	rdctl	r2,status
81136150:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136154:	e0fffd17 	ldw	r3,-12(fp)
81136158:	00bfff84 	movi	r2,-2
8113615c:	1884703a 	and	r2,r3,r2
81136160:	1001703a 	wrctl	status,r2
  
  return context;
81136164:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136168:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113616c:	e0bffe17 	ldw	r2,-8(fp)
81136170:	10c00417 	ldw	r3,16(r2)
81136174:	e0bffe17 	ldw	r2,-8(fp)
81136178:	10800317 	ldw	r2,12(r2)
8113617c:	18800636 	bltu	r3,r2,81136198 <OSMemPut+0x8c>
81136180:	e0bffa17 	ldw	r2,-24(fp)
81136184:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136188:	e0bffb17 	ldw	r2,-20(fp)
8113618c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
81136190:	00801784 	movi	r2,94
81136194:	00001106 	br	811361dc <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81136198:	e0bffe17 	ldw	r2,-8(fp)
8113619c:	10c00117 	ldw	r3,4(r2)
811361a0:	e0bfff17 	ldw	r2,-4(fp)
811361a4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
811361a8:	e0bffe17 	ldw	r2,-8(fp)
811361ac:	e0ffff17 	ldw	r3,-4(fp)
811361b0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
811361b4:	e0bffe17 	ldw	r2,-8(fp)
811361b8:	10800417 	ldw	r2,16(r2)
811361bc:	10c00044 	addi	r3,r2,1
811361c0:	e0bffe17 	ldw	r2,-8(fp)
811361c4:	10c00415 	stw	r3,16(r2)
811361c8:	e0bffa17 	ldw	r2,-24(fp)
811361cc:	e0bffc15 	stw	r2,-16(fp)
811361d0:	e0bffc17 	ldw	r2,-16(fp)
811361d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
811361d8:	0005883a 	mov	r2,zero
}
811361dc:	e037883a 	mov	sp,fp
811361e0:	df000017 	ldw	fp,0(sp)
811361e4:	dec00104 	addi	sp,sp,4
811361e8:	f800283a 	ret

811361ec <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
811361ec:	defffa04 	addi	sp,sp,-24
811361f0:	de00012e 	bgeu	sp,et,811361f8 <OSMemQuery+0xc>
811361f4:	003b68fa 	trap	3
811361f8:	df000515 	stw	fp,20(sp)
811361fc:	df000504 	addi	fp,sp,20
81136200:	e13ffe15 	stw	r4,-8(fp)
81136204:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136208:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113620c:	e0bffe17 	ldw	r2,-8(fp)
81136210:	1000021e 	bne	r2,zero,8113621c <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81136214:	00801804 	movi	r2,96
81136218:	00002c06 	br	811362cc <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113621c:	e0bfff17 	ldw	r2,-4(fp)
81136220:	1000021e 	bne	r2,zero,8113622c <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
81136224:	00801844 	movi	r2,97
81136228:	00002806 	br	811362cc <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113622c:	0005303a 	rdctl	r2,status
81136230:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136234:	e0fffc17 	ldw	r3,-16(fp)
81136238:	00bfff84 	movi	r2,-2
8113623c:	1884703a 	and	r2,r3,r2
81136240:	1001703a 	wrctl	status,r2
  
  return context;
81136244:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136248:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113624c:	e0bffe17 	ldw	r2,-8(fp)
81136250:	10c00017 	ldw	r3,0(r2)
81136254:	e0bfff17 	ldw	r2,-4(fp)
81136258:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113625c:	e0bffe17 	ldw	r2,-8(fp)
81136260:	10c00117 	ldw	r3,4(r2)
81136264:	e0bfff17 	ldw	r2,-4(fp)
81136268:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113626c:	e0bffe17 	ldw	r2,-8(fp)
81136270:	10c00217 	ldw	r3,8(r2)
81136274:	e0bfff17 	ldw	r2,-4(fp)
81136278:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113627c:	e0bffe17 	ldw	r2,-8(fp)
81136280:	10c00317 	ldw	r3,12(r2)
81136284:	e0bfff17 	ldw	r2,-4(fp)
81136288:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113628c:	e0bffe17 	ldw	r2,-8(fp)
81136290:	10c00417 	ldw	r3,16(r2)
81136294:	e0bfff17 	ldw	r2,-4(fp)
81136298:	10c00415 	stw	r3,16(r2)
8113629c:	e0bffb17 	ldw	r2,-20(fp)
811362a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811362a4:	e0bffd17 	ldw	r2,-12(fp)
811362a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
811362ac:	e0bfff17 	ldw	r2,-4(fp)
811362b0:	10c00317 	ldw	r3,12(r2)
811362b4:	e0bfff17 	ldw	r2,-4(fp)
811362b8:	10800417 	ldw	r2,16(r2)
811362bc:	1887c83a 	sub	r3,r3,r2
811362c0:	e0bfff17 	ldw	r2,-4(fp)
811362c4:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
811362c8:	0005883a 	mov	r2,zero
}
811362cc:	e037883a 	mov	sp,fp
811362d0:	df000017 	ldw	fp,0(sp)
811362d4:	dec00104 	addi	sp,sp,4
811362d8:	f800283a 	ret

811362dc <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
811362dc:	defffc04 	addi	sp,sp,-16
811362e0:	de00012e 	bgeu	sp,et,811362e8 <OS_MemInit+0xc>
811362e4:	003b68fa 	trap	3
811362e8:	dfc00315 	stw	ra,12(sp)
811362ec:	df000215 	stw	fp,8(sp)
811362f0:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
811362f4:	01430c04 	movi	r5,3120
811362f8:	012045b4 	movhi	r4,33046
811362fc:	21008b04 	addi	r4,r4,556
81136300:	1133ac00 	call	81133ac0 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81136304:	00a045b4 	movhi	r2,33046
81136308:	10808b04 	addi	r2,r2,556
8113630c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81136310:	e03fff0d 	sth	zero,-4(fp)
81136314:	00001306 	br	81136364 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
81136318:	e0bfff0b 	ldhu	r2,-4(fp)
8113631c:	10800044 	addi	r2,r2,1
81136320:	10c00d24 	muli	r3,r2,52
81136324:	00a045b4 	movhi	r2,33046
81136328:	10808b04 	addi	r2,r2,556
8113632c:	1887883a 	add	r3,r3,r2
81136330:	e0bffe17 	ldw	r2,-8(fp)
81136334:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
81136338:	e0bffe17 	ldw	r2,-8(fp)
8113633c:	00c00fc4 	movi	r3,63
81136340:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81136344:	e0bffe17 	ldw	r2,-8(fp)
81136348:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113634c:	e0bffe17 	ldw	r2,-8(fp)
81136350:	10800d04 	addi	r2,r2,52
81136354:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81136358:	e0bfff0b 	ldhu	r2,-4(fp)
8113635c:	10800044 	addi	r2,r2,1
81136360:	e0bfff0d 	sth	r2,-4(fp)
81136364:	e0bfff0b 	ldhu	r2,-4(fp)
81136368:	10800ef0 	cmpltui	r2,r2,59
8113636c:	103fea1e 	bne	r2,zero,81136318 <__reset+0xfb116318>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81136370:	e0bffe17 	ldw	r2,-8(fp)
81136374:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
81136378:	e0bffe17 	ldw	r2,-8(fp)
8113637c:	00c00fc4 	movi	r3,63
81136380:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
81136384:	e0bffe17 	ldw	r2,-8(fp)
81136388:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113638c:	00a045b4 	movhi	r2,33046
81136390:	10808b04 	addi	r2,r2,556
81136394:	d0a0a015 	stw	r2,-32128(gp)
#endif
}
81136398:	0001883a 	nop
8113639c:	e037883a 	mov	sp,fp
811363a0:	dfc00117 	ldw	ra,4(sp)
811363a4:	df000017 	ldw	fp,0(sp)
811363a8:	dec00204 	addi	sp,sp,8
811363ac:	f800283a 	ret

811363b0 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
811363b0:	defff704 	addi	sp,sp,-36
811363b4:	de00012e 	bgeu	sp,et,811363bc <OSMutexAccept+0xc>
811363b8:	003b68fa 	trap	3
811363bc:	df000815 	stw	fp,32(sp)
811363c0:	df000804 	addi	fp,sp,32
811363c4:	e13ffe15 	stw	r4,-8(fp)
811363c8:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811363cc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
811363d0:	e0bfff17 	ldw	r2,-4(fp)
811363d4:	1000021e 	bne	r2,zero,811363e0 <OSMutexAccept+0x30>
        return (OS_FALSE);
811363d8:	0005883a 	mov	r2,zero
811363dc:	00005b06 	br	8113654c <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
811363e0:	e0bffe17 	ldw	r2,-8(fp)
811363e4:	1000051e 	bne	r2,zero,811363fc <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811363e8:	e0bfff17 	ldw	r2,-4(fp)
811363ec:	00c00104 	movi	r3,4
811363f0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811363f4:	0005883a 	mov	r2,zero
811363f8:	00005406 	br	8113654c <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
811363fc:	e0bffe17 	ldw	r2,-8(fp)
81136400:	10800003 	ldbu	r2,0(r2)
81136404:	10803fcc 	andi	r2,r2,255
81136408:	10800120 	cmpeqi	r2,r2,4
8113640c:	1000051e 	bne	r2,zero,81136424 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81136410:	e0bfff17 	ldw	r2,-4(fp)
81136414:	00c00044 	movi	r3,1
81136418:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113641c:	0005883a 	mov	r2,zero
81136420:	00004a06 	br	8113654c <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
81136424:	d0a0a603 	ldbu	r2,-32104(gp)
81136428:	10803fcc 	andi	r2,r2,255
8113642c:	10000526 	beq	r2,zero,81136444 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
81136430:	e0bfff17 	ldw	r2,-4(fp)
81136434:	00c00084 	movi	r3,2
81136438:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113643c:	0005883a 	mov	r2,zero
81136440:	00004206 	br	8113654c <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136444:	0005303a 	rdctl	r2,status
81136448:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113644c:	e0fffd17 	ldw	r3,-12(fp)
81136450:	00bfff84 	movi	r2,-2
81136454:	1884703a 	and	r2,r3,r2
81136458:	1001703a 	wrctl	status,r2
  
  return context;
8113645c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81136460:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81136464:	e0bffe17 	ldw	r2,-8(fp)
81136468:	1080020b 	ldhu	r2,8(r2)
8113646c:	10bfffcc 	andi	r2,r2,65535
81136470:	1004d23a 	srli	r2,r2,8
81136474:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81136478:	e0bffe17 	ldw	r2,-8(fp)
8113647c:	1080020b 	ldhu	r2,8(r2)
81136480:	10bfffcc 	andi	r2,r2,65535
81136484:	10803fcc 	andi	r2,r2,255
81136488:	10803fd8 	cmpnei	r2,r2,255
8113648c:	1000281e 	bne	r2,zero,81136530 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
81136490:	e0bffe17 	ldw	r2,-8(fp)
81136494:	10c0020b 	ldhu	r3,8(r2)
81136498:	00bfc004 	movi	r2,-256
8113649c:	1884703a 	and	r2,r3,r2
811364a0:	1007883a 	mov	r3,r2
811364a4:	e0bffe17 	ldw	r2,-8(fp)
811364a8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
811364ac:	e0bffe17 	ldw	r2,-8(fp)
811364b0:	10c0020b 	ldhu	r3,8(r2)
811364b4:	d0a0a717 	ldw	r2,-32100(gp)
811364b8:	10800c83 	ldbu	r2,50(r2)
811364bc:	10803fcc 	andi	r2,r2,255
811364c0:	1884b03a 	or	r2,r3,r2
811364c4:	1007883a 	mov	r3,r2
811364c8:	e0bffe17 	ldw	r2,-8(fp)
811364cc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
811364d0:	d0e0a717 	ldw	r3,-32100(gp)
811364d4:	e0bffe17 	ldw	r2,-8(fp)
811364d8:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
811364dc:	d0a0a717 	ldw	r2,-32100(gp)
811364e0:	10800c83 	ldbu	r2,50(r2)
811364e4:	10803fcc 	andi	r2,r2,255
811364e8:	e0fffa03 	ldbu	r3,-24(fp)
811364ec:	18800836 	bltu	r3,r2,81136510 <OSMutexAccept+0x160>
811364f0:	e0bff817 	ldw	r2,-32(fp)
811364f4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811364f8:	e0bff917 	ldw	r2,-28(fp)
811364fc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
81136500:	e0bfff17 	ldw	r2,-4(fp)
81136504:	00c01e04 	movi	r3,120
81136508:	10c00005 	stb	r3,0(r2)
8113650c:	00000606 	br	81136528 <OSMutexAccept+0x178>
81136510:	e0bff817 	ldw	r2,-32(fp)
81136514:	e0bffb15 	stw	r2,-20(fp)
81136518:	e0bffb17 	ldw	r2,-20(fp)
8113651c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81136520:	e0bfff17 	ldw	r2,-4(fp)
81136524:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
81136528:	00800044 	movi	r2,1
8113652c:	00000706 	br	8113654c <OSMutexAccept+0x19c>
81136530:	e0bff817 	ldw	r2,-32(fp)
81136534:	e0bffc15 	stw	r2,-16(fp)
81136538:	e0bffc17 	ldw	r2,-16(fp)
8113653c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136540:	e0bfff17 	ldw	r2,-4(fp)
81136544:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81136548:	0005883a 	mov	r2,zero
}
8113654c:	e037883a 	mov	sp,fp
81136550:	df000017 	ldw	fp,0(sp)
81136554:	dec00104 	addi	sp,sp,4
81136558:	f800283a 	ret

8113655c <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113655c:	defff604 	addi	sp,sp,-40
81136560:	de00012e 	bgeu	sp,et,81136568 <OSMutexCreate+0xc>
81136564:	003b68fa 	trap	3
81136568:	dfc00915 	stw	ra,36(sp)
8113656c:	df000815 	stw	fp,32(sp)
81136570:	df000804 	addi	fp,sp,32
81136574:	2005883a 	mov	r2,r4
81136578:	e17fff15 	stw	r5,-4(fp)
8113657c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136580:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136584:	e0bfff17 	ldw	r2,-4(fp)
81136588:	1000021e 	bne	r2,zero,81136594 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113658c:	0005883a 	mov	r2,zero
81136590:	00006106 	br	81136718 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
81136594:	e0bffe03 	ldbu	r2,-8(fp)
81136598:	10800a30 	cmpltui	r2,r2,40
8113659c:	1000051e 	bne	r2,zero,811365b4 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
811365a0:	e0bfff17 	ldw	r2,-4(fp)
811365a4:	00c00a84 	movi	r3,42
811365a8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811365ac:	0005883a 	mov	r2,zero
811365b0:	00005906 	br	81136718 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811365b4:	d0a0a603 	ldbu	r2,-32104(gp)
811365b8:	10803fcc 	andi	r2,r2,255
811365bc:	10000526 	beq	r2,zero,811365d4 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
811365c0:	e0bfff17 	ldw	r2,-4(fp)
811365c4:	00c00404 	movi	r3,16
811365c8:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811365cc:	0005883a 	mov	r2,zero
811365d0:	00005106 	br	81136718 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811365d4:	0005303a 	rdctl	r2,status
811365d8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811365dc:	e0fffd17 	ldw	r3,-12(fp)
811365e0:	00bfff84 	movi	r2,-2
811365e4:	1884703a 	and	r2,r3,r2
811365e8:	1001703a 	wrctl	status,r2
  
  return context;
811365ec:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811365f0:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
811365f4:	e0fffe03 	ldbu	r3,-8(fp)
811365f8:	00a045b4 	movhi	r2,33046
811365fc:	1094cd04 	addi	r2,r2,21300
81136600:	18c7883a 	add	r3,r3,r3
81136604:	18c7883a 	add	r3,r3,r3
81136608:	10c5883a 	add	r2,r2,r3
8113660c:	10800017 	ldw	r2,0(r2)
81136610:	10000926 	beq	r2,zero,81136638 <OSMutexCreate+0xdc>
81136614:	e0bff817 	ldw	r2,-32(fp)
81136618:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113661c:	e0bff917 	ldw	r2,-28(fp)
81136620:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
81136624:	e0bfff17 	ldw	r2,-4(fp)
81136628:	00c00a04 	movi	r3,40
8113662c:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81136630:	0005883a 	mov	r2,zero
81136634:	00003806 	br	81136718 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
81136638:	e0fffe03 	ldbu	r3,-8(fp)
8113663c:	00a045b4 	movhi	r2,33046
81136640:	1094cd04 	addi	r2,r2,21300
81136644:	18c7883a 	add	r3,r3,r3
81136648:	18c7883a 	add	r3,r3,r3
8113664c:	10c5883a 	add	r2,r2,r3
81136650:	00c00044 	movi	r3,1
81136654:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81136658:	d0a0a517 	ldw	r2,-32108(gp)
8113665c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
81136660:	e0bffb17 	ldw	r2,-20(fp)
81136664:	1000101e 	bne	r2,zero,811366a8 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
81136668:	e0fffe03 	ldbu	r3,-8(fp)
8113666c:	00a045b4 	movhi	r2,33046
81136670:	1094cd04 	addi	r2,r2,21300
81136674:	18c7883a 	add	r3,r3,r3
81136678:	18c7883a 	add	r3,r3,r3
8113667c:	10c5883a 	add	r2,r2,r3
81136680:	10000015 	stw	zero,0(r2)
81136684:	e0bff817 	ldw	r2,-32(fp)
81136688:	e0bffa15 	stw	r2,-24(fp)
8113668c:	e0bffa17 	ldw	r2,-24(fp)
81136690:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
81136694:	e0bfff17 	ldw	r2,-4(fp)
81136698:	00c00104 	movi	r3,4
8113669c:	10c00005 	stb	r3,0(r2)
        return (pevent);
811366a0:	e0bffb17 	ldw	r2,-20(fp)
811366a4:	00001c06 	br	81136718 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
811366a8:	d0a0a517 	ldw	r2,-32108(gp)
811366ac:	10800117 	ldw	r2,4(r2)
811366b0:	d0a0a515 	stw	r2,-32108(gp)
811366b4:	e0bff817 	ldw	r2,-32(fp)
811366b8:	e0bffc15 	stw	r2,-16(fp)
811366bc:	e0bffc17 	ldw	r2,-16(fp)
811366c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
811366c4:	e0bffb17 	ldw	r2,-20(fp)
811366c8:	00c00104 	movi	r3,4
811366cc:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
811366d0:	e0bffe03 	ldbu	r2,-8(fp)
811366d4:	1004923a 	slli	r2,r2,8
811366d8:	10803fd4 	ori	r2,r2,255
811366dc:	1007883a 	mov	r3,r2
811366e0:	e0bffb17 	ldw	r2,-20(fp)
811366e4:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
811366e8:	e0bffb17 	ldw	r2,-20(fp)
811366ec:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
811366f0:	e0bffb17 	ldw	r2,-20(fp)
811366f4:	00c00fc4 	movi	r3,63
811366f8:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
811366fc:	e0bffb17 	ldw	r2,-20(fp)
81136700:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
81136704:	e13ffb17 	ldw	r4,-20(fp)
81136708:	11336a80 	call	811336a8 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113670c:	e0bfff17 	ldw	r2,-4(fp)
81136710:	10000005 	stb	zero,0(r2)
    return (pevent);
81136714:	e0bffb17 	ldw	r2,-20(fp)
}
81136718:	e037883a 	mov	sp,fp
8113671c:	dfc00117 	ldw	ra,4(sp)
81136720:	df000017 	ldw	fp,0(sp)
81136724:	dec00204 	addi	sp,sp,8
81136728:	f800283a 	ret

8113672c <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113672c:	defff004 	addi	sp,sp,-64
81136730:	de00012e 	bgeu	sp,et,81136738 <OSMutexDel+0xc>
81136734:	003b68fa 	trap	3
81136738:	dfc00f15 	stw	ra,60(sp)
8113673c:	df000e15 	stw	fp,56(sp)
81136740:	df000e04 	addi	fp,sp,56
81136744:	e13ffd15 	stw	r4,-12(fp)
81136748:	2805883a 	mov	r2,r5
8113674c:	e1bfff15 	stw	r6,-4(fp)
81136750:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136754:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136758:	e0bfff17 	ldw	r2,-4(fp)
8113675c:	1000021e 	bne	r2,zero,81136768 <OSMutexDel+0x3c>
        return (pevent);
81136760:	e0bffd17 	ldw	r2,-12(fp)
81136764:	0000ad06 	br	81136a1c <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81136768:	e0bffd17 	ldw	r2,-12(fp)
8113676c:	1000051e 	bne	r2,zero,81136784 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81136770:	e0bfff17 	ldw	r2,-4(fp)
81136774:	00c00104 	movi	r3,4
81136778:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113677c:	e0bffd17 	ldw	r2,-12(fp)
81136780:	0000a606 	br	81136a1c <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81136784:	e0bffd17 	ldw	r2,-12(fp)
81136788:	10800003 	ldbu	r2,0(r2)
8113678c:	10803fcc 	andi	r2,r2,255
81136790:	10800120 	cmpeqi	r2,r2,4
81136794:	1000051e 	bne	r2,zero,811367ac <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81136798:	e0bfff17 	ldw	r2,-4(fp)
8113679c:	00c00044 	movi	r3,1
811367a0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811367a4:	e0bffd17 	ldw	r2,-12(fp)
811367a8:	00009c06 	br	81136a1c <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811367ac:	d0a0a603 	ldbu	r2,-32104(gp)
811367b0:	10803fcc 	andi	r2,r2,255
811367b4:	10000526 	beq	r2,zero,811367cc <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811367b8:	e0bfff17 	ldw	r2,-4(fp)
811367bc:	00c003c4 	movi	r3,15
811367c0:	10c00005 	stb	r3,0(r2)
        return (pevent);
811367c4:	e0bffd17 	ldw	r2,-12(fp)
811367c8:	00009406 	br	81136a1c <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811367cc:	0005303a 	rdctl	r2,status
811367d0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811367d4:	e0fffc17 	ldw	r3,-16(fp)
811367d8:	00bfff84 	movi	r2,-2
811367dc:	1884703a 	and	r2,r3,r2
811367e0:	1001703a 	wrctl	status,r2
  
  return context;
811367e4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811367e8:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
811367ec:	e0bffd17 	ldw	r2,-12(fp)
811367f0:	10800283 	ldbu	r2,10(r2)
811367f4:	10803fcc 	andi	r2,r2,255
811367f8:	10000326 	beq	r2,zero,81136808 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811367fc:	00800044 	movi	r2,1
81136800:	e0bff205 	stb	r2,-56(fp)
81136804:	00000106 	br	8113680c <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81136808:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113680c:	e0bffe03 	ldbu	r2,-8(fp)
81136810:	10000326 	beq	r2,zero,81136820 <OSMutexDel+0xf4>
81136814:	10800060 	cmpeqi	r2,r2,1
81136818:	10002f1e 	bne	r2,zero,811368d8 <OSMutexDel+0x1ac>
8113681c:	00007406 	br	811369f0 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
81136820:	e0bff203 	ldbu	r2,-56(fp)
81136824:	1000221e 	bne	r2,zero,811368b0 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81136828:	e0bffd17 	ldw	r2,-12(fp)
8113682c:	00c00fc4 	movi	r3,63
81136830:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81136834:	e0bffd17 	ldw	r2,-12(fp)
81136838:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113683c:	e0bffd17 	ldw	r2,-12(fp)
81136840:	1080020b 	ldhu	r2,8(r2)
81136844:	10bfffcc 	andi	r2,r2,65535
81136848:	1004d23a 	srli	r2,r2,8
8113684c:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
81136850:	e0fff603 	ldbu	r3,-40(fp)
81136854:	00a045b4 	movhi	r2,33046
81136858:	1094cd04 	addi	r2,r2,21300
8113685c:	18c7883a 	add	r3,r3,r3
81136860:	18c7883a 	add	r3,r3,r3
81136864:	10c5883a 	add	r2,r2,r3
81136868:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113686c:	e0bffd17 	ldw	r2,-12(fp)
81136870:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
81136874:	d0e0a517 	ldw	r3,-32108(gp)
81136878:	e0bffd17 	ldw	r2,-12(fp)
8113687c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
81136880:	e0bffd17 	ldw	r2,-12(fp)
81136884:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
81136888:	e0bffd17 	ldw	r2,-12(fp)
8113688c:	d0a0a515 	stw	r2,-32108(gp)
81136890:	e0bff417 	ldw	r2,-48(fp)
81136894:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136898:	e0bff517 	ldw	r2,-44(fp)
8113689c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
811368a0:	e0bfff17 	ldw	r2,-4(fp)
811368a4:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
811368a8:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
811368ac:	00005a06 	br	81136a18 <OSMutexDel+0x2ec>
811368b0:	e0bff417 	ldw	r2,-48(fp)
811368b4:	e0bff715 	stw	r2,-36(fp)
811368b8:	e0bff717 	ldw	r2,-36(fp)
811368bc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
811368c0:	e0bfff17 	ldw	r2,-4(fp)
811368c4:	00c01244 	movi	r3,73
811368c8:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
811368cc:	e0bffd17 	ldw	r2,-12(fp)
811368d0:	e0bff315 	stw	r2,-52(fp)
             }
             break;
811368d4:	00005006 	br	81136a18 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
811368d8:	e0bffd17 	ldw	r2,-12(fp)
811368dc:	1080020b 	ldhu	r2,8(r2)
811368e0:	10bfffcc 	andi	r2,r2,65535
811368e4:	1004d23a 	srli	r2,r2,8
811368e8:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
811368ec:	e0bffd17 	ldw	r2,-12(fp)
811368f0:	1080020b 	ldhu	r2,8(r2)
811368f4:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
811368f8:	e0bffd17 	ldw	r2,-12(fp)
811368fc:	10800117 	ldw	r2,4(r2)
81136900:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
81136904:	e0bffa17 	ldw	r2,-24(fp)
81136908:	10000f26 	beq	r2,zero,81136948 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113690c:	e0bffa17 	ldw	r2,-24(fp)
81136910:	10800c83 	ldbu	r2,50(r2)
81136914:	10c03fcc 	andi	r3,r2,255
81136918:	e0bff603 	ldbu	r2,-40(fp)
8113691c:	18800a1e 	bne	r3,r2,81136948 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
81136920:	e0bff903 	ldbu	r2,-28(fp)
81136924:	100b883a 	mov	r5,r2
81136928:	e13ffa17 	ldw	r4,-24(fp)
8113692c:	11373680 	call	81137368 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81136930:	00000506 	br	81136948 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81136934:	000f883a 	mov	r7,zero
81136938:	01800404 	movi	r6,16
8113693c:	000b883a 	mov	r5,zero
81136940:	e13ffd17 	ldw	r4,-12(fp)
81136944:	11330d00 	call	811330d0 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81136948:	e0bffd17 	ldw	r2,-12(fp)
8113694c:	10800283 	ldbu	r2,10(r2)
81136950:	10803fcc 	andi	r2,r2,255
81136954:	103ff71e 	bne	r2,zero,81136934 <__reset+0xfb116934>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81136958:	e0bffd17 	ldw	r2,-12(fp)
8113695c:	00c00fc4 	movi	r3,63
81136960:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81136964:	e0bffd17 	ldw	r2,-12(fp)
81136968:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113696c:	e0bffd17 	ldw	r2,-12(fp)
81136970:	1080020b 	ldhu	r2,8(r2)
81136974:	10bfffcc 	andi	r2,r2,65535
81136978:	1004d23a 	srli	r2,r2,8
8113697c:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
81136980:	e0fff603 	ldbu	r3,-40(fp)
81136984:	00a045b4 	movhi	r2,33046
81136988:	1094cd04 	addi	r2,r2,21300
8113698c:	18c7883a 	add	r3,r3,r3
81136990:	18c7883a 	add	r3,r3,r3
81136994:	10c5883a 	add	r2,r2,r3
81136998:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113699c:	e0bffd17 	ldw	r2,-12(fp)
811369a0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
811369a4:	d0e0a517 	ldw	r3,-32108(gp)
811369a8:	e0bffd17 	ldw	r2,-12(fp)
811369ac:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
811369b0:	e0bffd17 	ldw	r2,-12(fp)
811369b4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
811369b8:	e0bffd17 	ldw	r2,-12(fp)
811369bc:	d0a0a515 	stw	r2,-32108(gp)
811369c0:	e0bff417 	ldw	r2,-48(fp)
811369c4:	e0bff815 	stw	r2,-32(fp)
811369c8:	e0bff817 	ldw	r2,-32(fp)
811369cc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811369d0:	e0bff203 	ldbu	r2,-56(fp)
811369d4:	10800058 	cmpnei	r2,r2,1
811369d8:	1000011e 	bne	r2,zero,811369e0 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
811369dc:	1133b8c0 	call	81133b8c <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
811369e0:	e0bfff17 	ldw	r2,-4(fp)
811369e4:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
811369e8:	e03ff315 	stw	zero,-52(fp)
             break;
811369ec:	00000a06 	br	81136a18 <OSMutexDel+0x2ec>
811369f0:	e0bff417 	ldw	r2,-48(fp)
811369f4:	e0bffb15 	stw	r2,-20(fp)
811369f8:	e0bffb17 	ldw	r2,-20(fp)
811369fc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
81136a00:	e0bfff17 	ldw	r2,-4(fp)
81136a04:	00c001c4 	movi	r3,7
81136a08:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
81136a0c:	e0bffd17 	ldw	r2,-12(fp)
81136a10:	e0bff315 	stw	r2,-52(fp)
             break;
81136a14:	0001883a 	nop
    }
    return (pevent_return);
81136a18:	e0bff317 	ldw	r2,-52(fp)
}
81136a1c:	e037883a 	mov	sp,fp
81136a20:	dfc00117 	ldw	ra,4(sp)
81136a24:	df000017 	ldw	fp,0(sp)
81136a28:	dec00204 	addi	sp,sp,8
81136a2c:	f800283a 	ret

81136a30 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81136a30:	deffee04 	addi	sp,sp,-72
81136a34:	de00012e 	bgeu	sp,et,81136a3c <OSMutexPend+0xc>
81136a38:	003b68fa 	trap	3
81136a3c:	dfc01115 	stw	ra,68(sp)
81136a40:	df001015 	stw	fp,64(sp)
81136a44:	df001004 	addi	fp,sp,64
81136a48:	e13ffd15 	stw	r4,-12(fp)
81136a4c:	2805883a 	mov	r2,r5
81136a50:	e1bfff15 	stw	r6,-4(fp)
81136a54:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136a58:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136a5c:	e0bfff17 	ldw	r2,-4(fp)
81136a60:	10015626 	beq	r2,zero,81136fbc <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81136a64:	e0bffd17 	ldw	r2,-12(fp)
81136a68:	1000041e 	bne	r2,zero,81136a7c <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81136a6c:	e0bfff17 	ldw	r2,-4(fp)
81136a70:	00c00104 	movi	r3,4
81136a74:	10c00005 	stb	r3,0(r2)
        return;
81136a78:	00015106 	br	81136fc0 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81136a7c:	e0bffd17 	ldw	r2,-12(fp)
81136a80:	10800003 	ldbu	r2,0(r2)
81136a84:	10803fcc 	andi	r2,r2,255
81136a88:	10800120 	cmpeqi	r2,r2,4
81136a8c:	1000041e 	bne	r2,zero,81136aa0 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81136a90:	e0bfff17 	ldw	r2,-4(fp)
81136a94:	00c00044 	movi	r3,1
81136a98:	10c00005 	stb	r3,0(r2)
        return;
81136a9c:	00014806 	br	81136fc0 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81136aa0:	d0a0a603 	ldbu	r2,-32104(gp)
81136aa4:	10803fcc 	andi	r2,r2,255
81136aa8:	10000426 	beq	r2,zero,81136abc <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81136aac:	e0bfff17 	ldw	r2,-4(fp)
81136ab0:	00c00084 	movi	r3,2
81136ab4:	10c00005 	stb	r3,0(r2)
        return;
81136ab8:	00014106 	br	81136fc0 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81136abc:	d0a09403 	ldbu	r2,-32176(gp)
81136ac0:	10803fcc 	andi	r2,r2,255
81136ac4:	10000426 	beq	r2,zero,81136ad8 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81136ac8:	e0bfff17 	ldw	r2,-4(fp)
81136acc:	00c00344 	movi	r3,13
81136ad0:	10c00005 	stb	r3,0(r2)
        return;
81136ad4:	00013a06 	br	81136fc0 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136ad8:	0005303a 	rdctl	r2,status
81136adc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136ae0:	e0fffc17 	ldw	r3,-16(fp)
81136ae4:	00bfff84 	movi	r2,-2
81136ae8:	1884703a 	and	r2,r3,r2
81136aec:	1001703a 	wrctl	status,r2
  
  return context;
81136af0:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81136af4:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
81136af8:	e0bffd17 	ldw	r2,-12(fp)
81136afc:	1080020b 	ldhu	r2,8(r2)
81136b00:	10bfffcc 	andi	r2,r2,65535
81136b04:	1004d23a 	srli	r2,r2,8
81136b08:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81136b0c:	e0bffd17 	ldw	r2,-12(fp)
81136b10:	1080020b 	ldhu	r2,8(r2)
81136b14:	10803fcc 	andi	r2,r2,255
81136b18:	10803fd8 	cmpnei	r2,r2,255
81136b1c:	1000271e 	bne	r2,zero,81136bbc <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
81136b20:	e0bffd17 	ldw	r2,-12(fp)
81136b24:	10c0020b 	ldhu	r3,8(r2)
81136b28:	00bfc004 	movi	r2,-256
81136b2c:	1884703a 	and	r2,r3,r2
81136b30:	1007883a 	mov	r3,r2
81136b34:	e0bffd17 	ldw	r2,-12(fp)
81136b38:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
81136b3c:	e0bffd17 	ldw	r2,-12(fp)
81136b40:	10c0020b 	ldhu	r3,8(r2)
81136b44:	d0a0a717 	ldw	r2,-32100(gp)
81136b48:	10800c83 	ldbu	r2,50(r2)
81136b4c:	10803fcc 	andi	r2,r2,255
81136b50:	1884b03a 	or	r2,r3,r2
81136b54:	1007883a 	mov	r3,r2
81136b58:	e0bffd17 	ldw	r2,-12(fp)
81136b5c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81136b60:	d0e0a717 	ldw	r3,-32100(gp)
81136b64:	e0bffd17 	ldw	r2,-12(fp)
81136b68:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81136b6c:	d0a0a717 	ldw	r2,-32100(gp)
81136b70:	10800c83 	ldbu	r2,50(r2)
81136b74:	10803fcc 	andi	r2,r2,255
81136b78:	e0fff303 	ldbu	r3,-52(fp)
81136b7c:	18800836 	bltu	r3,r2,81136ba0 <OSMutexPend+0x170>
81136b80:	e0bff117 	ldw	r2,-60(fp)
81136b84:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136b88:	e0bff217 	ldw	r2,-56(fp)
81136b8c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
81136b90:	e0bfff17 	ldw	r2,-4(fp)
81136b94:	00c01e04 	movi	r3,120
81136b98:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
81136b9c:	00010806 	br	81136fc0 <OSMutexPend+0x590>
81136ba0:	e0bff117 	ldw	r2,-60(fp)
81136ba4:	e0bff415 	stw	r2,-48(fp)
81136ba8:	e0bff417 	ldw	r2,-48(fp)
81136bac:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81136bb0:	e0bfff17 	ldw	r2,-4(fp)
81136bb4:	10000005 	stb	zero,0(r2)
        }
        return;
81136bb8:	00010106 	br	81136fc0 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
81136bbc:	e0bffd17 	ldw	r2,-12(fp)
81136bc0:	1080020b 	ldhu	r2,8(r2)
81136bc4:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
81136bc8:	e0bffd17 	ldw	r2,-12(fp)
81136bcc:	10800117 	ldw	r2,4(r2)
81136bd0:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81136bd4:	e0bff717 	ldw	r2,-36(fp)
81136bd8:	10800c83 	ldbu	r2,50(r2)
81136bdc:	10803fcc 	andi	r2,r2,255
81136be0:	e0fff303 	ldbu	r3,-52(fp)
81136be4:	1880b92e 	bgeu	r3,r2,81136ecc <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
81136be8:	d0a0a717 	ldw	r2,-32100(gp)
81136bec:	10800c83 	ldbu	r2,50(r2)
81136bf0:	10c03fcc 	andi	r3,r2,255
81136bf4:	e0bff603 	ldbu	r2,-40(fp)
81136bf8:	1880b42e 	bgeu	r3,r2,81136ecc <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
81136bfc:	e0bff717 	ldw	r2,-36(fp)
81136c00:	10800d03 	ldbu	r2,52(r2)
81136c04:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
81136c08:	e0fff803 	ldbu	r3,-32(fp)
81136c0c:	d0a0a344 	addi	r2,gp,-32115
81136c10:	1885883a 	add	r2,r3,r2
81136c14:	10c00003 	ldbu	r3,0(r2)
81136c18:	e0bff717 	ldw	r2,-36(fp)
81136c1c:	10800d43 	ldbu	r2,53(r2)
81136c20:	1884703a 	and	r2,r3,r2
81136c24:	10803fcc 	andi	r2,r2,255
81136c28:	10001e26 	beq	r2,zero,81136ca4 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
81136c2c:	e0fff803 	ldbu	r3,-32(fp)
81136c30:	e13ff803 	ldbu	r4,-32(fp)
81136c34:	d0a0a344 	addi	r2,gp,-32115
81136c38:	2085883a 	add	r2,r4,r2
81136c3c:	10800003 	ldbu	r2,0(r2)
81136c40:	1009883a 	mov	r4,r2
81136c44:	e0bff717 	ldw	r2,-36(fp)
81136c48:	10800d43 	ldbu	r2,53(r2)
81136c4c:	0084303a 	nor	r2,zero,r2
81136c50:	2084703a 	and	r2,r4,r2
81136c54:	1009883a 	mov	r4,r2
81136c58:	d0a0a344 	addi	r2,gp,-32115
81136c5c:	1885883a 	add	r2,r3,r2
81136c60:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81136c64:	e0fff803 	ldbu	r3,-32(fp)
81136c68:	d0a0a344 	addi	r2,gp,-32115
81136c6c:	1885883a 	add	r2,r3,r2
81136c70:	10800003 	ldbu	r2,0(r2)
81136c74:	10803fcc 	andi	r2,r2,255
81136c78:	1000071e 	bne	r2,zero,81136c98 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
81136c7c:	e0bff717 	ldw	r2,-36(fp)
81136c80:	10800d83 	ldbu	r2,54(r2)
81136c84:	0084303a 	nor	r2,zero,r2
81136c88:	1007883a 	mov	r3,r2
81136c8c:	d0a0a303 	ldbu	r2,-32116(gp)
81136c90:	1884703a 	and	r2,r3,r2
81136c94:	d0a0a305 	stb	r2,-32116(gp)
                }
                rdy = OS_TRUE;
81136c98:	00800044 	movi	r2,1
81136c9c:	e0bff005 	stb	r2,-64(fp)
81136ca0:	00002a06 	br	81136d4c <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81136ca4:	e0bff717 	ldw	r2,-36(fp)
81136ca8:	10800717 	ldw	r2,28(r2)
81136cac:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
81136cb0:	e0bff917 	ldw	r2,-28(fp)
81136cb4:	10002426 	beq	r2,zero,81136d48 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
81136cb8:	e0bff717 	ldw	r2,-36(fp)
81136cbc:	10800d03 	ldbu	r2,52(r2)
81136cc0:	10803fcc 	andi	r2,r2,255
81136cc4:	e0fff717 	ldw	r3,-36(fp)
81136cc8:	18c00d03 	ldbu	r3,52(r3)
81136ccc:	18c03fcc 	andi	r3,r3,255
81136cd0:	e13ff917 	ldw	r4,-28(fp)
81136cd4:	20c7883a 	add	r3,r4,r3
81136cd8:	18c002c4 	addi	r3,r3,11
81136cdc:	18c00003 	ldbu	r3,0(r3)
81136ce0:	1809883a 	mov	r4,r3
81136ce4:	e0fff717 	ldw	r3,-36(fp)
81136ce8:	18c00d43 	ldbu	r3,53(r3)
81136cec:	00c6303a 	nor	r3,zero,r3
81136cf0:	20c6703a 	and	r3,r4,r3
81136cf4:	1809883a 	mov	r4,r3
81136cf8:	e0fff917 	ldw	r3,-28(fp)
81136cfc:	1887883a 	add	r3,r3,r2
81136d00:	18c002c4 	addi	r3,r3,11
81136d04:	19000005 	stb	r4,0(r3)
81136d08:	e0fff917 	ldw	r3,-28(fp)
81136d0c:	1885883a 	add	r2,r3,r2
81136d10:	108002c4 	addi	r2,r2,11
81136d14:	10800003 	ldbu	r2,0(r2)
81136d18:	10803fcc 	andi	r2,r2,255
81136d1c:	10000a1e 	bne	r2,zero,81136d48 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
81136d20:	e0bff917 	ldw	r2,-28(fp)
81136d24:	10800283 	ldbu	r2,10(r2)
81136d28:	1007883a 	mov	r3,r2
81136d2c:	e0bff717 	ldw	r2,-36(fp)
81136d30:	10800d83 	ldbu	r2,54(r2)
81136d34:	0084303a 	nor	r2,zero,r2
81136d38:	1884703a 	and	r2,r3,r2
81136d3c:	1007883a 	mov	r3,r2
81136d40:	e0bff917 	ldw	r2,-28(fp)
81136d44:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81136d48:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81136d4c:	e0bff717 	ldw	r2,-36(fp)
81136d50:	e0fff303 	ldbu	r3,-52(fp)
81136d54:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81136d58:	e0bff717 	ldw	r2,-36(fp)
81136d5c:	10800c83 	ldbu	r2,50(r2)
81136d60:	10803fcc 	andi	r2,r2,255
81136d64:	1004d0fa 	srli	r2,r2,3
81136d68:	1007883a 	mov	r3,r2
81136d6c:	e0bff717 	ldw	r2,-36(fp)
81136d70:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81136d74:	e0bff717 	ldw	r2,-36(fp)
81136d78:	10800c83 	ldbu	r2,50(r2)
81136d7c:	108001cc 	andi	r2,r2,7
81136d80:	1007883a 	mov	r3,r2
81136d84:	e0bff717 	ldw	r2,-36(fp)
81136d88:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81136d8c:	e0bff717 	ldw	r2,-36(fp)
81136d90:	10800d03 	ldbu	r2,52(r2)
81136d94:	10803fcc 	andi	r2,r2,255
81136d98:	00c00044 	movi	r3,1
81136d9c:	1884983a 	sll	r2,r3,r2
81136da0:	1007883a 	mov	r3,r2
81136da4:	e0bff717 	ldw	r2,-36(fp)
81136da8:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81136dac:	e0bff717 	ldw	r2,-36(fp)
81136db0:	10800cc3 	ldbu	r2,51(r2)
81136db4:	10803fcc 	andi	r2,r2,255
81136db8:	00c00044 	movi	r3,1
81136dbc:	1884983a 	sll	r2,r3,r2
81136dc0:	1007883a 	mov	r3,r2
81136dc4:	e0bff717 	ldw	r2,-36(fp)
81136dc8:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81136dcc:	e0bff003 	ldbu	r2,-64(fp)
81136dd0:	10800058 	cmpnei	r2,r2,1
81136dd4:	1000161e 	bne	r2,zero,81136e30 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81136dd8:	e0bff717 	ldw	r2,-36(fp)
81136ddc:	10c00d83 	ldbu	r3,54(r2)
81136de0:	d0a0a303 	ldbu	r2,-32116(gp)
81136de4:	1884b03a 	or	r2,r3,r2
81136de8:	d0a0a305 	stb	r2,-32116(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81136dec:	e0bff717 	ldw	r2,-36(fp)
81136df0:	10800d03 	ldbu	r2,52(r2)
81136df4:	10c03fcc 	andi	r3,r2,255
81136df8:	e0bff717 	ldw	r2,-36(fp)
81136dfc:	10800d03 	ldbu	r2,52(r2)
81136e00:	11003fcc 	andi	r4,r2,255
81136e04:	d0a0a344 	addi	r2,gp,-32115
81136e08:	2085883a 	add	r2,r4,r2
81136e0c:	11000003 	ldbu	r4,0(r2)
81136e10:	e0bff717 	ldw	r2,-36(fp)
81136e14:	10800d43 	ldbu	r2,53(r2)
81136e18:	2084b03a 	or	r2,r4,r2
81136e1c:	1009883a 	mov	r4,r2
81136e20:	d0a0a344 	addi	r2,gp,-32115
81136e24:	1885883a 	add	r2,r3,r2
81136e28:	11000005 	stb	r4,0(r2)
81136e2c:	00001f06 	br	81136eac <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81136e30:	e0bff717 	ldw	r2,-36(fp)
81136e34:	10800717 	ldw	r2,28(r2)
81136e38:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
81136e3c:	e0bff917 	ldw	r2,-28(fp)
81136e40:	10001a26 	beq	r2,zero,81136eac <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81136e44:	e0bff917 	ldw	r2,-28(fp)
81136e48:	10c00283 	ldbu	r3,10(r2)
81136e4c:	e0bff717 	ldw	r2,-36(fp)
81136e50:	10800d83 	ldbu	r2,54(r2)
81136e54:	1884b03a 	or	r2,r3,r2
81136e58:	1007883a 	mov	r3,r2
81136e5c:	e0bff917 	ldw	r2,-28(fp)
81136e60:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81136e64:	e0bff717 	ldw	r2,-36(fp)
81136e68:	10800d03 	ldbu	r2,52(r2)
81136e6c:	10803fcc 	andi	r2,r2,255
81136e70:	e0fff717 	ldw	r3,-36(fp)
81136e74:	18c00d03 	ldbu	r3,52(r3)
81136e78:	18c03fcc 	andi	r3,r3,255
81136e7c:	e13ff917 	ldw	r4,-28(fp)
81136e80:	20c7883a 	add	r3,r4,r3
81136e84:	18c002c4 	addi	r3,r3,11
81136e88:	19000003 	ldbu	r4,0(r3)
81136e8c:	e0fff717 	ldw	r3,-36(fp)
81136e90:	18c00d43 	ldbu	r3,53(r3)
81136e94:	20c6b03a 	or	r3,r4,r3
81136e98:	1809883a 	mov	r4,r3
81136e9c:	e0fff917 	ldw	r3,-28(fp)
81136ea0:	1885883a 	add	r2,r3,r2
81136ea4:	108002c4 	addi	r2,r2,11
81136ea8:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81136eac:	e0fff303 	ldbu	r3,-52(fp)
81136eb0:	00a045b4 	movhi	r2,33046
81136eb4:	1094cd04 	addi	r2,r2,21300
81136eb8:	18c7883a 	add	r3,r3,r3
81136ebc:	18c7883a 	add	r3,r3,r3
81136ec0:	10c5883a 	add	r2,r2,r3
81136ec4:	e0fff717 	ldw	r3,-36(fp)
81136ec8:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81136ecc:	d0a0a717 	ldw	r2,-32100(gp)
81136ed0:	d0e0a717 	ldw	r3,-32100(gp)
81136ed4:	18c00c03 	ldbu	r3,48(r3)
81136ed8:	18c00414 	ori	r3,r3,16
81136edc:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81136ee0:	d0a0a717 	ldw	r2,-32100(gp)
81136ee4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81136ee8:	d0a0a717 	ldw	r2,-32100(gp)
81136eec:	e0fffe0b 	ldhu	r3,-8(fp)
81136ef0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81136ef4:	e13ffd17 	ldw	r4,-12(fp)
81136ef8:	11332700 	call	81133270 <OS_EventTaskWait>
81136efc:	e0bff117 	ldw	r2,-60(fp)
81136f00:	e0bffb15 	stw	r2,-20(fp)
81136f04:	e0bffb17 	ldw	r2,-20(fp)
81136f08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81136f0c:	1133b8c0 	call	81133b8c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136f10:	0005303a 	rdctl	r2,status
81136f14:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136f18:	e0fff517 	ldw	r3,-44(fp)
81136f1c:	00bfff84 	movi	r2,-2
81136f20:	1884703a 	and	r2,r3,r2
81136f24:	1001703a 	wrctl	status,r2
  
  return context;
81136f28:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
81136f2c:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81136f30:	d0a0a717 	ldw	r2,-32100(gp)
81136f34:	10800c43 	ldbu	r2,49(r2)
81136f38:	10803fcc 	andi	r2,r2,255
81136f3c:	10000326 	beq	r2,zero,81136f4c <OSMutexPend+0x51c>
81136f40:	108000a0 	cmpeqi	r2,r2,2
81136f44:	1000041e 	bne	r2,zero,81136f58 <OSMutexPend+0x528>
81136f48:	00000706 	br	81136f68 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81136f4c:	e0bfff17 	ldw	r2,-4(fp)
81136f50:	10000005 	stb	zero,0(r2)
             break;
81136f54:	00000c06 	br	81136f88 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81136f58:	e0bfff17 	ldw	r2,-4(fp)
81136f5c:	00c00384 	movi	r3,14
81136f60:	10c00005 	stb	r3,0(r2)
             break;
81136f64:	00000806 	br	81136f88 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81136f68:	d0a0a717 	ldw	r2,-32100(gp)
81136f6c:	e17ffd17 	ldw	r5,-12(fp)
81136f70:	1009883a 	mov	r4,r2
81136f74:	11334e00 	call	811334e0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81136f78:	e0bfff17 	ldw	r2,-4(fp)
81136f7c:	00c00284 	movi	r3,10
81136f80:	10c00005 	stb	r3,0(r2)
             break;
81136f84:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81136f88:	d0a0a717 	ldw	r2,-32100(gp)
81136f8c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81136f90:	d0a0a717 	ldw	r2,-32100(gp)
81136f94:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81136f98:	d0a0a717 	ldw	r2,-32100(gp)
81136f9c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81136fa0:	d0a0a717 	ldw	r2,-32100(gp)
81136fa4:	10000815 	stw	zero,32(r2)
81136fa8:	e0bff117 	ldw	r2,-60(fp)
81136fac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136fb0:	e0bffa17 	ldw	r2,-24(fp)
81136fb4:	1001703a 	wrctl	status,r2
81136fb8:	00000106 	br	81136fc0 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81136fbc:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81136fc0:	e037883a 	mov	sp,fp
81136fc4:	dfc00117 	ldw	ra,4(sp)
81136fc8:	df000017 	ldw	fp,0(sp)
81136fcc:	dec00204 	addi	sp,sp,8
81136fd0:	f800283a 	ret

81136fd4 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81136fd4:	defff604 	addi	sp,sp,-40
81136fd8:	de00012e 	bgeu	sp,et,81136fe0 <OSMutexPost+0xc>
81136fdc:	003b68fa 	trap	3
81136fe0:	dfc00915 	stw	ra,36(sp)
81136fe4:	df000815 	stw	fp,32(sp)
81136fe8:	df000804 	addi	fp,sp,32
81136fec:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136ff0:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81136ff4:	d0a0a603 	ldbu	r2,-32104(gp)
81136ff8:	10803fcc 	andi	r2,r2,255
81136ffc:	10000226 	beq	r2,zero,81137008 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
81137000:	00800144 	movi	r2,5
81137004:	00007606 	br	811371e0 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81137008:	e0bfff17 	ldw	r2,-4(fp)
8113700c:	1000021e 	bne	r2,zero,81137018 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
81137010:	00800104 	movi	r2,4
81137014:	00007206 	br	811371e0 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
81137018:	e0bfff17 	ldw	r2,-4(fp)
8113701c:	10800003 	ldbu	r2,0(r2)
81137020:	10803fcc 	andi	r2,r2,255
81137024:	10800120 	cmpeqi	r2,r2,4
81137028:	1000021e 	bne	r2,zero,81137034 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113702c:	00800044 	movi	r2,1
81137030:	00006b06 	br	811371e0 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137034:	0005303a 	rdctl	r2,status
81137038:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113703c:	e0fffe17 	ldw	r3,-8(fp)
81137040:	00bfff84 	movi	r2,-2
81137044:	1884703a 	and	r2,r3,r2
81137048:	1001703a 	wrctl	status,r2
  
  return context;
8113704c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81137050:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81137054:	e0bfff17 	ldw	r2,-4(fp)
81137058:	1080020b 	ldhu	r2,8(r2)
8113705c:	10bfffcc 	andi	r2,r2,65535
81137060:	1004d23a 	srli	r2,r2,8
81137064:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81137068:	e0bfff17 	ldw	r2,-4(fp)
8113706c:	1080020b 	ldhu	r2,8(r2)
81137070:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81137074:	e0bfff17 	ldw	r2,-4(fp)
81137078:	10c00117 	ldw	r3,4(r2)
8113707c:	d0a0a717 	ldw	r2,-32100(gp)
81137080:	18800626 	beq	r3,r2,8113709c <OSMutexPost+0xc8>
81137084:	e0bff817 	ldw	r2,-32(fp)
81137088:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113708c:	e0bff917 	ldw	r2,-28(fp)
81137090:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81137094:	00801904 	movi	r2,100
81137098:	00005106 	br	811371e0 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113709c:	d0a0a717 	ldw	r2,-32100(gp)
811370a0:	10800c83 	ldbu	r2,50(r2)
811370a4:	10c03fcc 	andi	r3,r2,255
811370a8:	e0bffa03 	ldbu	r2,-24(fp)
811370ac:	1880051e 	bne	r3,r2,811370c4 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
811370b0:	d0a0a717 	ldw	r2,-32100(gp)
811370b4:	e0fffa43 	ldbu	r3,-23(fp)
811370b8:	180b883a 	mov	r5,r3
811370bc:	1009883a 	mov	r4,r2
811370c0:	11373680 	call	81137368 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
811370c4:	e0fffa03 	ldbu	r3,-24(fp)
811370c8:	00a045b4 	movhi	r2,33046
811370cc:	1094cd04 	addi	r2,r2,21300
811370d0:	18c7883a 	add	r3,r3,r3
811370d4:	18c7883a 	add	r3,r3,r3
811370d8:	10c5883a 	add	r2,r2,r3
811370dc:	00c00044 	movi	r3,1
811370e0:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
811370e4:	e0bfff17 	ldw	r2,-4(fp)
811370e8:	10800283 	ldbu	r2,10(r2)
811370ec:	10803fcc 	andi	r2,r2,255
811370f0:	10002e26 	beq	r2,zero,811371ac <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811370f4:	000f883a 	mov	r7,zero
811370f8:	01800404 	movi	r6,16
811370fc:	000b883a 	mov	r5,zero
81137100:	e13fff17 	ldw	r4,-4(fp)
81137104:	11330d00 	call	811330d0 <OS_EventTaskRdy>
81137108:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113710c:	e0bfff17 	ldw	r2,-4(fp)
81137110:	10c0020b 	ldhu	r3,8(r2)
81137114:	00bfc004 	movi	r2,-256
81137118:	1884703a 	and	r2,r3,r2
8113711c:	1007883a 	mov	r3,r2
81137120:	e0bfff17 	ldw	r2,-4(fp)
81137124:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
81137128:	e0bfff17 	ldw	r2,-4(fp)
8113712c:	10c0020b 	ldhu	r3,8(r2)
81137130:	e0bffa43 	ldbu	r2,-23(fp)
81137134:	1884b03a 	or	r2,r3,r2
81137138:	1007883a 	mov	r3,r2
8113713c:	e0bfff17 	ldw	r2,-4(fp)
81137140:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81137144:	e0fffa43 	ldbu	r3,-23(fp)
81137148:	00a045b4 	movhi	r2,33046
8113714c:	1094cd04 	addi	r2,r2,21300
81137150:	18c7883a 	add	r3,r3,r3
81137154:	18c7883a 	add	r3,r3,r3
81137158:	10c5883a 	add	r2,r2,r3
8113715c:	10c00017 	ldw	r3,0(r2)
81137160:	e0bfff17 	ldw	r2,-4(fp)
81137164:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81137168:	e0bffa43 	ldbu	r2,-23(fp)
8113716c:	e0fffa03 	ldbu	r3,-24(fp)
81137170:	18800736 	bltu	r3,r2,81137190 <OSMutexPost+0x1bc>
81137174:	e0bff817 	ldw	r2,-32(fp)
81137178:	e0bffb15 	stw	r2,-20(fp)
8113717c:	e0bffb17 	ldw	r2,-20(fp)
81137180:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81137184:	1133b8c0 	call	81133b8c <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81137188:	00801e04 	movi	r2,120
8113718c:	00001406 	br	811371e0 <OSMutexPost+0x20c>
81137190:	e0bff817 	ldw	r2,-32(fp)
81137194:	e0bffc15 	stw	r2,-16(fp)
81137198:	e0bffc17 	ldw	r2,-16(fp)
8113719c:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
811371a0:	1133b8c0 	call	81133b8c <OS_Sched>
            return (OS_ERR_NONE);
811371a4:	0005883a 	mov	r2,zero
811371a8:	00000d06 	br	811371e0 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
811371ac:	e0bfff17 	ldw	r2,-4(fp)
811371b0:	1080020b 	ldhu	r2,8(r2)
811371b4:	10803fd4 	ori	r2,r2,255
811371b8:	1007883a 	mov	r3,r2
811371bc:	e0bfff17 	ldw	r2,-4(fp)
811371c0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
811371c4:	e0bfff17 	ldw	r2,-4(fp)
811371c8:	10000115 	stw	zero,4(r2)
811371cc:	e0bff817 	ldw	r2,-32(fp)
811371d0:	e0bffd15 	stw	r2,-12(fp)
811371d4:	e0bffd17 	ldw	r2,-12(fp)
811371d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811371dc:	0005883a 	mov	r2,zero
}
811371e0:	e037883a 	mov	sp,fp
811371e4:	dfc00117 	ldw	ra,4(sp)
811371e8:	df000017 	ldw	fp,0(sp)
811371ec:	dec00204 	addi	sp,sp,8
811371f0:	f800283a 	ret

811371f4 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
811371f4:	defff704 	addi	sp,sp,-36
811371f8:	de00012e 	bgeu	sp,et,81137200 <OSMutexQuery+0xc>
811371fc:	003b68fa 	trap	3
81137200:	df000815 	stw	fp,32(sp)
81137204:	df000804 	addi	fp,sp,32
81137208:	e13ffe15 	stw	r4,-8(fp)
8113720c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137210:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137214:	d0a0a603 	ldbu	r2,-32104(gp)
81137218:	10803fcc 	andi	r2,r2,255
8113721c:	10000226 	beq	r2,zero,81137228 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
81137220:	00800184 	movi	r2,6
81137224:	00004c06 	br	81137358 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137228:	e0bffe17 	ldw	r2,-8(fp)
8113722c:	1000021e 	bne	r2,zero,81137238 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
81137230:	00800104 	movi	r2,4
81137234:	00004806 	br	81137358 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
81137238:	e0bfff17 	ldw	r2,-4(fp)
8113723c:	1000021e 	bne	r2,zero,81137248 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
81137240:	00800244 	movi	r2,9
81137244:	00004406 	br	81137358 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81137248:	e0bffe17 	ldw	r2,-8(fp)
8113724c:	10800003 	ldbu	r2,0(r2)
81137250:	10803fcc 	andi	r2,r2,255
81137254:	10800120 	cmpeqi	r2,r2,4
81137258:	1000021e 	bne	r2,zero,81137264 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113725c:	00800044 	movi	r2,1
81137260:	00003d06 	br	81137358 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137264:	0005303a 	rdctl	r2,status
81137268:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113726c:	e0fffd17 	ldw	r3,-12(fp)
81137270:	00bfff84 	movi	r2,-2
81137274:	1884703a 	and	r2,r3,r2
81137278:	1001703a 	wrctl	status,r2
  
  return context;
8113727c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137280:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81137284:	e0bffe17 	ldw	r2,-8(fp)
81137288:	1080020b 	ldhu	r2,8(r2)
8113728c:	10bfffcc 	andi	r2,r2,65535
81137290:	1004d23a 	srli	r2,r2,8
81137294:	1007883a 	mov	r3,r2
81137298:	e0bfff17 	ldw	r2,-4(fp)
8113729c:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
811372a0:	e0bffe17 	ldw	r2,-8(fp)
811372a4:	1080020b 	ldhu	r2,8(r2)
811372a8:	1007883a 	mov	r3,r2
811372ac:	e0bfff17 	ldw	r2,-4(fp)
811372b0:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
811372b4:	e0bfff17 	ldw	r2,-4(fp)
811372b8:	10800203 	ldbu	r2,8(r2)
811372bc:	10803fcc 	andi	r2,r2,255
811372c0:	10803fd8 	cmpnei	r2,r2,255
811372c4:	1000041e 	bne	r2,zero,811372d8 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
811372c8:	e0bfff17 	ldw	r2,-4(fp)
811372cc:	00c00044 	movi	r3,1
811372d0:	10c001c5 	stb	r3,7(r2)
811372d4:	00000206 	br	811372e0 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
811372d8:	e0bfff17 	ldw	r2,-4(fp)
811372dc:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
811372e0:	e0bffe17 	ldw	r2,-8(fp)
811372e4:	10c00283 	ldbu	r3,10(r2)
811372e8:	e0bfff17 	ldw	r2,-4(fp)
811372ec:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
811372f0:	e0bffe17 	ldw	r2,-8(fp)
811372f4:	108002c4 	addi	r2,r2,11
811372f8:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
811372fc:	e0bfff17 	ldw	r2,-4(fp)
81137300:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137304:	e03ff805 	stb	zero,-32(fp)
81137308:	00000b06 	br	81137338 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113730c:	e0bffa17 	ldw	r2,-24(fp)
81137310:	10c00044 	addi	r3,r2,1
81137314:	e0fffa15 	stw	r3,-24(fp)
81137318:	e0fff917 	ldw	r3,-28(fp)
8113731c:	19000044 	addi	r4,r3,1
81137320:	e13ff915 	stw	r4,-28(fp)
81137324:	18c00003 	ldbu	r3,0(r3)
81137328:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113732c:	e0bff803 	ldbu	r2,-32(fp)
81137330:	10800044 	addi	r2,r2,1
81137334:	e0bff805 	stb	r2,-32(fp)
81137338:	e0bff803 	ldbu	r2,-32(fp)
8113733c:	108001b0 	cmpltui	r2,r2,6
81137340:	103ff21e 	bne	r2,zero,8113730c <__reset+0xfb11730c>
81137344:	e0bffb17 	ldw	r2,-20(fp)
81137348:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113734c:	e0bffc17 	ldw	r2,-16(fp)
81137350:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81137354:	0005883a 	mov	r2,zero
}
81137358:	e037883a 	mov	sp,fp
8113735c:	df000017 	ldw	fp,0(sp)
81137360:	dec00104 	addi	sp,sp,4
81137364:	f800283a 	ret

81137368 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
81137368:	defffc04 	addi	sp,sp,-16
8113736c:	de00012e 	bgeu	sp,et,81137374 <OSMutex_RdyAtPrio+0xc>
81137370:	003b68fa 	trap	3
81137374:	df000315 	stw	fp,12(sp)
81137378:	df000304 	addi	fp,sp,12
8113737c:	e13ffe15 	stw	r4,-8(fp)
81137380:	2805883a 	mov	r2,r5
81137384:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
81137388:	e0bffe17 	ldw	r2,-8(fp)
8113738c:	10800d03 	ldbu	r2,52(r2)
81137390:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
81137394:	e0fffd03 	ldbu	r3,-12(fp)
81137398:	e13ffd03 	ldbu	r4,-12(fp)
8113739c:	d0a0a344 	addi	r2,gp,-32115
811373a0:	2085883a 	add	r2,r4,r2
811373a4:	10800003 	ldbu	r2,0(r2)
811373a8:	1009883a 	mov	r4,r2
811373ac:	e0bffe17 	ldw	r2,-8(fp)
811373b0:	10800d43 	ldbu	r2,53(r2)
811373b4:	0084303a 	nor	r2,zero,r2
811373b8:	2084703a 	and	r2,r4,r2
811373bc:	1009883a 	mov	r4,r2
811373c0:	d0a0a344 	addi	r2,gp,-32115
811373c4:	1885883a 	add	r2,r3,r2
811373c8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811373cc:	e0fffd03 	ldbu	r3,-12(fp)
811373d0:	d0a0a344 	addi	r2,gp,-32115
811373d4:	1885883a 	add	r2,r3,r2
811373d8:	10800003 	ldbu	r2,0(r2)
811373dc:	10803fcc 	andi	r2,r2,255
811373e0:	1000071e 	bne	r2,zero,81137400 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811373e4:	e0bffe17 	ldw	r2,-8(fp)
811373e8:	10800d83 	ldbu	r2,54(r2)
811373ec:	0084303a 	nor	r2,zero,r2
811373f0:	1007883a 	mov	r3,r2
811373f4:	d0a0a303 	ldbu	r2,-32116(gp)
811373f8:	1884703a 	and	r2,r3,r2
811373fc:	d0a0a305 	stb	r2,-32116(gp)
    }
    ptcb->OSTCBPrio         = prio;
81137400:	e0bffe17 	ldw	r2,-8(fp)
81137404:	e0ffff03 	ldbu	r3,-4(fp)
81137408:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113740c:	e0bfff03 	ldbu	r2,-4(fp)
81137410:	1004d0fa 	srli	r2,r2,3
81137414:	108001cc 	andi	r2,r2,7
81137418:	1007883a 	mov	r3,r2
8113741c:	e0bffe17 	ldw	r2,-8(fp)
81137420:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
81137424:	e0bfff03 	ldbu	r2,-4(fp)
81137428:	108001cc 	andi	r2,r2,7
8113742c:	1007883a 	mov	r3,r2
81137430:	e0bffe17 	ldw	r2,-8(fp)
81137434:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
81137438:	e0bffe17 	ldw	r2,-8(fp)
8113743c:	10800d03 	ldbu	r2,52(r2)
81137440:	10803fcc 	andi	r2,r2,255
81137444:	00c00044 	movi	r3,1
81137448:	1884983a 	sll	r2,r3,r2
8113744c:	1007883a 	mov	r3,r2
81137450:	e0bffe17 	ldw	r2,-8(fp)
81137454:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81137458:	e0bffe17 	ldw	r2,-8(fp)
8113745c:	10800cc3 	ldbu	r2,51(r2)
81137460:	10803fcc 	andi	r2,r2,255
81137464:	00c00044 	movi	r3,1
81137468:	1884983a 	sll	r2,r3,r2
8113746c:	1007883a 	mov	r3,r2
81137470:	e0bffe17 	ldw	r2,-8(fp)
81137474:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
81137478:	e0bffe17 	ldw	r2,-8(fp)
8113747c:	10c00d83 	ldbu	r3,54(r2)
81137480:	d0a0a303 	ldbu	r2,-32116(gp)
81137484:	1884b03a 	or	r2,r3,r2
81137488:	d0a0a305 	stb	r2,-32116(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113748c:	e0bffe17 	ldw	r2,-8(fp)
81137490:	10800d03 	ldbu	r2,52(r2)
81137494:	10c03fcc 	andi	r3,r2,255
81137498:	e0bffe17 	ldw	r2,-8(fp)
8113749c:	10800d03 	ldbu	r2,52(r2)
811374a0:	11003fcc 	andi	r4,r2,255
811374a4:	d0a0a344 	addi	r2,gp,-32115
811374a8:	2085883a 	add	r2,r4,r2
811374ac:	11000003 	ldbu	r4,0(r2)
811374b0:	e0bffe17 	ldw	r2,-8(fp)
811374b4:	10800d43 	ldbu	r2,53(r2)
811374b8:	2084b03a 	or	r2,r4,r2
811374bc:	1009883a 	mov	r4,r2
811374c0:	d0a0a344 	addi	r2,gp,-32115
811374c4:	1885883a 	add	r2,r3,r2
811374c8:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
811374cc:	e0ffff03 	ldbu	r3,-4(fp)
811374d0:	00a045b4 	movhi	r2,33046
811374d4:	1094cd04 	addi	r2,r2,21300
811374d8:	18c7883a 	add	r3,r3,r3
811374dc:	18c7883a 	add	r3,r3,r3
811374e0:	10c5883a 	add	r2,r2,r3
811374e4:	e0fffe17 	ldw	r3,-8(fp)
811374e8:	10c00015 	stw	r3,0(r2)
}
811374ec:	0001883a 	nop
811374f0:	e037883a 	mov	sp,fp
811374f4:	df000017 	ldw	fp,0(sp)
811374f8:	dec00104 	addi	sp,sp,4
811374fc:	f800283a 	ret

81137500 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
81137500:	defff804 	addi	sp,sp,-32
81137504:	de00012e 	bgeu	sp,et,8113750c <OSQAccept+0xc>
81137508:	003b68fa 	trap	3
8113750c:	df000715 	stw	fp,28(sp)
81137510:	df000704 	addi	fp,sp,28
81137514:	e13ffe15 	stw	r4,-8(fp)
81137518:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113751c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137520:	e0bfff17 	ldw	r2,-4(fp)
81137524:	1000021e 	bne	r2,zero,81137530 <OSQAccept+0x30>
        return ((void *)0);
81137528:	0005883a 	mov	r2,zero
8113752c:	00004206 	br	81137638 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81137530:	e0bffe17 	ldw	r2,-8(fp)
81137534:	1000051e 	bne	r2,zero,8113754c <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81137538:	e0bfff17 	ldw	r2,-4(fp)
8113753c:	00c00104 	movi	r3,4
81137540:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137544:	0005883a 	mov	r2,zero
81137548:	00003b06 	br	81137638 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113754c:	e0bffe17 	ldw	r2,-8(fp)
81137550:	10800003 	ldbu	r2,0(r2)
81137554:	10803fcc 	andi	r2,r2,255
81137558:	108000a0 	cmpeqi	r2,r2,2
8113755c:	1000051e 	bne	r2,zero,81137574 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81137560:	e0bfff17 	ldw	r2,-4(fp)
81137564:	00c00044 	movi	r3,1
81137568:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113756c:	0005883a 	mov	r2,zero
81137570:	00003106 	br	81137638 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137574:	0005303a 	rdctl	r2,status
81137578:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113757c:	e0fffd17 	ldw	r3,-12(fp)
81137580:	00bfff84 	movi	r2,-2
81137584:	1884703a 	and	r2,r3,r2
81137588:	1001703a 	wrctl	status,r2
  
  return context;
8113758c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137590:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81137594:	e0bffe17 	ldw	r2,-8(fp)
81137598:	10800117 	ldw	r2,4(r2)
8113759c:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
811375a0:	e0bffc17 	ldw	r2,-16(fp)
811375a4:	1080058b 	ldhu	r2,22(r2)
811375a8:	10bfffcc 	andi	r2,r2,65535
811375ac:	10001926 	beq	r2,zero,81137614 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
811375b0:	e0bffc17 	ldw	r2,-16(fp)
811375b4:	10800417 	ldw	r2,16(r2)
811375b8:	11000104 	addi	r4,r2,4
811375bc:	e0fffc17 	ldw	r3,-16(fp)
811375c0:	19000415 	stw	r4,16(r3)
811375c4:	10800017 	ldw	r2,0(r2)
811375c8:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
811375cc:	e0bffc17 	ldw	r2,-16(fp)
811375d0:	1080058b 	ldhu	r2,22(r2)
811375d4:	10bfffc4 	addi	r2,r2,-1
811375d8:	1007883a 	mov	r3,r2
811375dc:	e0bffc17 	ldw	r2,-16(fp)
811375e0:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
811375e4:	e0bffc17 	ldw	r2,-16(fp)
811375e8:	10c00417 	ldw	r3,16(r2)
811375ec:	e0bffc17 	ldw	r2,-16(fp)
811375f0:	10800217 	ldw	r2,8(r2)
811375f4:	1880041e 	bne	r3,r2,81137608 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
811375f8:	e0bffc17 	ldw	r2,-16(fp)
811375fc:	10c00117 	ldw	r3,4(r2)
81137600:	e0bffc17 	ldw	r2,-16(fp)
81137604:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
81137608:	e0bfff17 	ldw	r2,-4(fp)
8113760c:	10000005 	stb	zero,0(r2)
81137610:	00000406 	br	81137624 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
81137614:	e0bfff17 	ldw	r2,-4(fp)
81137618:	00c007c4 	movi	r3,31
8113761c:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
81137620:	e03ff915 	stw	zero,-28(fp)
81137624:	e0bffa17 	ldw	r2,-24(fp)
81137628:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113762c:	e0bffb17 	ldw	r2,-20(fp)
81137630:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
81137634:	e0bff917 	ldw	r2,-28(fp)
}
81137638:	e037883a 	mov	sp,fp
8113763c:	df000017 	ldw	fp,0(sp)
81137640:	dec00104 	addi	sp,sp,4
81137644:	f800283a 	ret

81137648 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81137648:	defff404 	addi	sp,sp,-48
8113764c:	de00012e 	bgeu	sp,et,81137654 <OSQCreate+0xc>
81137650:	003b68fa 	trap	3
81137654:	dfc00b15 	stw	ra,44(sp)
81137658:	df000a15 	stw	fp,40(sp)
8113765c:	df000a04 	addi	fp,sp,40
81137660:	e13ffe15 	stw	r4,-8(fp)
81137664:	2805883a 	mov	r2,r5
81137668:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113766c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81137670:	d0a0a603 	ldbu	r2,-32104(gp)
81137674:	10803fcc 	andi	r2,r2,255
81137678:	10000226 	beq	r2,zero,81137684 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113767c:	0005883a 	mov	r2,zero
81137680:	00005906 	br	811377e8 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137684:	0005303a 	rdctl	r2,status
81137688:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113768c:	e0fffd17 	ldw	r3,-12(fp)
81137690:	00bfff84 	movi	r2,-2
81137694:	1884703a 	and	r2,r3,r2
81137698:	1001703a 	wrctl	status,r2
  
  return context;
8113769c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811376a0:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
811376a4:	d0a0a517 	ldw	r2,-32108(gp)
811376a8:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
811376ac:	d0a0a517 	ldw	r2,-32108(gp)
811376b0:	10000326 	beq	r2,zero,811376c0 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811376b4:	d0a0a517 	ldw	r2,-32108(gp)
811376b8:	10800117 	ldw	r2,4(r2)
811376bc:	d0a0a515 	stw	r2,-32108(gp)
811376c0:	e0bff717 	ldw	r2,-36(fp)
811376c4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811376c8:	e0bff817 	ldw	r2,-32(fp)
811376cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
811376d0:	e0bff617 	ldw	r2,-40(fp)
811376d4:	10004326 	beq	r2,zero,811377e4 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811376d8:	0005303a 	rdctl	r2,status
811376dc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811376e0:	e0fff917 	ldw	r3,-28(fp)
811376e4:	00bfff84 	movi	r2,-2
811376e8:	1884703a 	and	r2,r3,r2
811376ec:	1001703a 	wrctl	status,r2
  
  return context;
811376f0:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
811376f4:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
811376f8:	d0a0a217 	ldw	r2,-32120(gp)
811376fc:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
81137700:	e0bffb17 	ldw	r2,-20(fp)
81137704:	10002d26 	beq	r2,zero,811377bc <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
81137708:	d0a0a217 	ldw	r2,-32120(gp)
8113770c:	10800017 	ldw	r2,0(r2)
81137710:	d0a0a215 	stw	r2,-32120(gp)
81137714:	e0bff717 	ldw	r2,-36(fp)
81137718:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113771c:	e0bffa17 	ldw	r2,-24(fp)
81137720:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
81137724:	e0bffb17 	ldw	r2,-20(fp)
81137728:	e0fffe17 	ldw	r3,-8(fp)
8113772c:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
81137730:	e0bfff0b 	ldhu	r2,-4(fp)
81137734:	1085883a 	add	r2,r2,r2
81137738:	1085883a 	add	r2,r2,r2
8113773c:	1007883a 	mov	r3,r2
81137740:	e0bffe17 	ldw	r2,-8(fp)
81137744:	10c7883a 	add	r3,r2,r3
81137748:	e0bffb17 	ldw	r2,-20(fp)
8113774c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
81137750:	e0bffb17 	ldw	r2,-20(fp)
81137754:	e0fffe17 	ldw	r3,-8(fp)
81137758:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113775c:	e0bffb17 	ldw	r2,-20(fp)
81137760:	e0fffe17 	ldw	r3,-8(fp)
81137764:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
81137768:	e0bffb17 	ldw	r2,-20(fp)
8113776c:	e0ffff0b 	ldhu	r3,-4(fp)
81137770:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
81137774:	e0bffb17 	ldw	r2,-20(fp)
81137778:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113777c:	e0bff617 	ldw	r2,-40(fp)
81137780:	00c00084 	movi	r3,2
81137784:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
81137788:	e0bff617 	ldw	r2,-40(fp)
8113778c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
81137790:	e0bff617 	ldw	r2,-40(fp)
81137794:	e0fffb17 	ldw	r3,-20(fp)
81137798:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113779c:	e0bff617 	ldw	r2,-40(fp)
811377a0:	00c00fc4 	movi	r3,63
811377a4:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
811377a8:	e0bff617 	ldw	r2,-40(fp)
811377ac:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
811377b0:	e13ff617 	ldw	r4,-40(fp)
811377b4:	11336a80 	call	811336a8 <OS_EventWaitListInit>
811377b8:	00000a06 	br	811377e4 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
811377bc:	d0e0a517 	ldw	r3,-32108(gp)
811377c0:	e0bff617 	ldw	r2,-40(fp)
811377c4:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
811377c8:	e0bff617 	ldw	r2,-40(fp)
811377cc:	d0a0a515 	stw	r2,-32108(gp)
811377d0:	e0bff717 	ldw	r2,-36(fp)
811377d4:	e0bffc15 	stw	r2,-16(fp)
811377d8:	e0bffc17 	ldw	r2,-16(fp)
811377dc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
811377e0:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
811377e4:	e0bff617 	ldw	r2,-40(fp)
}
811377e8:	e037883a 	mov	sp,fp
811377ec:	dfc00117 	ldw	ra,4(sp)
811377f0:	df000017 	ldw	fp,0(sp)
811377f4:	dec00204 	addi	sp,sp,8
811377f8:	f800283a 	ret

811377fc <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811377fc:	defff204 	addi	sp,sp,-56
81137800:	de00012e 	bgeu	sp,et,81137808 <OSQDel+0xc>
81137804:	003b68fa 	trap	3
81137808:	dfc00d15 	stw	ra,52(sp)
8113780c:	df000c15 	stw	fp,48(sp)
81137810:	df000c04 	addi	fp,sp,48
81137814:	e13ffd15 	stw	r4,-12(fp)
81137818:	2805883a 	mov	r2,r5
8113781c:	e1bfff15 	stw	r6,-4(fp)
81137820:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137824:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137828:	e0bfff17 	ldw	r2,-4(fp)
8113782c:	1000021e 	bne	r2,zero,81137838 <OSQDel+0x3c>
        return (pevent);
81137830:	e0bffd17 	ldw	r2,-12(fp)
81137834:	00008e06 	br	81137a70 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137838:	e0bffd17 	ldw	r2,-12(fp)
8113783c:	1000051e 	bne	r2,zero,81137854 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81137840:	e0bfff17 	ldw	r2,-4(fp)
81137844:	00c00104 	movi	r3,4
81137848:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113784c:	e0bffd17 	ldw	r2,-12(fp)
81137850:	00008706 	br	81137a70 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81137854:	e0bffd17 	ldw	r2,-12(fp)
81137858:	10800003 	ldbu	r2,0(r2)
8113785c:	10803fcc 	andi	r2,r2,255
81137860:	108000a0 	cmpeqi	r2,r2,2
81137864:	1000051e 	bne	r2,zero,8113787c <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81137868:	e0bfff17 	ldw	r2,-4(fp)
8113786c:	00c00044 	movi	r3,1
81137870:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137874:	e0bffd17 	ldw	r2,-12(fp)
81137878:	00007d06 	br	81137a70 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113787c:	d0a0a603 	ldbu	r2,-32104(gp)
81137880:	10803fcc 	andi	r2,r2,255
81137884:	10000526 	beq	r2,zero,8113789c <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81137888:	e0bfff17 	ldw	r2,-4(fp)
8113788c:	00c003c4 	movi	r3,15
81137890:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137894:	e0bffd17 	ldw	r2,-12(fp)
81137898:	00007506 	br	81137a70 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113789c:	0005303a 	rdctl	r2,status
811378a0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811378a4:	e0fffc17 	ldw	r3,-16(fp)
811378a8:	00bfff84 	movi	r2,-2
811378ac:	1884703a 	and	r2,r3,r2
811378b0:	1001703a 	wrctl	status,r2
  
  return context;
811378b4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811378b8:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
811378bc:	e0bffd17 	ldw	r2,-12(fp)
811378c0:	10800283 	ldbu	r2,10(r2)
811378c4:	10803fcc 	andi	r2,r2,255
811378c8:	10000326 	beq	r2,zero,811378d8 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811378cc:	00800044 	movi	r2,1
811378d0:	e0bff405 	stb	r2,-48(fp)
811378d4:	00000106 	br	811378dc <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811378d8:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
811378dc:	e0bffe03 	ldbu	r2,-8(fp)
811378e0:	10000326 	beq	r2,zero,811378f0 <OSQDel+0xf4>
811378e4:	10800060 	cmpeqi	r2,r2,1
811378e8:	1000301e 	bne	r2,zero,811379ac <OSQDel+0x1b0>
811378ec:	00005506 	br	81137a44 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
811378f0:	e0bff403 	ldbu	r2,-48(fp)
811378f4:	10001e1e 	bne	r2,zero,81137970 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811378f8:	e0bffd17 	ldw	r2,-12(fp)
811378fc:	00c00fc4 	movi	r3,63
81137900:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81137904:	e0bffd17 	ldw	r2,-12(fp)
81137908:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113790c:	e0bffd17 	ldw	r2,-12(fp)
81137910:	10800117 	ldw	r2,4(r2)
81137914:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
81137918:	d0e0a217 	ldw	r3,-32120(gp)
8113791c:	e0bff817 	ldw	r2,-32(fp)
81137920:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
81137924:	e0bff817 	ldw	r2,-32(fp)
81137928:	d0a0a215 	stw	r2,-32120(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113792c:	e0bffd17 	ldw	r2,-12(fp)
81137930:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81137934:	d0e0a517 	ldw	r3,-32108(gp)
81137938:	e0bffd17 	ldw	r2,-12(fp)
8113793c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81137940:	e0bffd17 	ldw	r2,-12(fp)
81137944:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81137948:	e0bffd17 	ldw	r2,-12(fp)
8113794c:	d0a0a515 	stw	r2,-32108(gp)
81137950:	e0bff617 	ldw	r2,-40(fp)
81137954:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137958:	e0bff717 	ldw	r2,-36(fp)
8113795c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81137960:	e0bfff17 	ldw	r2,-4(fp)
81137964:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
81137968:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113796c:	00003f06 	br	81137a6c <OSQDel+0x270>
81137970:	e0bff617 	ldw	r2,-40(fp)
81137974:	e0bff915 	stw	r2,-28(fp)
81137978:	e0bff917 	ldw	r2,-28(fp)
8113797c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81137980:	e0bfff17 	ldw	r2,-4(fp)
81137984:	00c01244 	movi	r3,73
81137988:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113798c:	e0bffd17 	ldw	r2,-12(fp)
81137990:	e0bff515 	stw	r2,-44(fp)
             }
             break;
81137994:	00003506 	br	81137a6c <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
81137998:	000f883a 	mov	r7,zero
8113799c:	01800104 	movi	r6,4
811379a0:	000b883a 	mov	r5,zero
811379a4:	e13ffd17 	ldw	r4,-12(fp)
811379a8:	11330d00 	call	811330d0 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
811379ac:	e0bffd17 	ldw	r2,-12(fp)
811379b0:	10800283 	ldbu	r2,10(r2)
811379b4:	10803fcc 	andi	r2,r2,255
811379b8:	103ff71e 	bne	r2,zero,81137998 <__reset+0xfb117998>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811379bc:	e0bffd17 	ldw	r2,-12(fp)
811379c0:	00c00fc4 	movi	r3,63
811379c4:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811379c8:	e0bffd17 	ldw	r2,-12(fp)
811379cc:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
811379d0:	e0bffd17 	ldw	r2,-12(fp)
811379d4:	10800117 	ldw	r2,4(r2)
811379d8:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
811379dc:	d0e0a217 	ldw	r3,-32120(gp)
811379e0:	e0bff817 	ldw	r2,-32(fp)
811379e4:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
811379e8:	e0bff817 	ldw	r2,-32(fp)
811379ec:	d0a0a215 	stw	r2,-32120(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811379f0:	e0bffd17 	ldw	r2,-12(fp)
811379f4:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811379f8:	d0e0a517 	ldw	r3,-32108(gp)
811379fc:	e0bffd17 	ldw	r2,-12(fp)
81137a00:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81137a04:	e0bffd17 	ldw	r2,-12(fp)
81137a08:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81137a0c:	e0bffd17 	ldw	r2,-12(fp)
81137a10:	d0a0a515 	stw	r2,-32108(gp)
81137a14:	e0bff617 	ldw	r2,-40(fp)
81137a18:	e0bffa15 	stw	r2,-24(fp)
81137a1c:	e0bffa17 	ldw	r2,-24(fp)
81137a20:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81137a24:	e0bff403 	ldbu	r2,-48(fp)
81137a28:	10800058 	cmpnei	r2,r2,1
81137a2c:	1000011e 	bne	r2,zero,81137a34 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81137a30:	1133b8c0 	call	81133b8c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81137a34:	e0bfff17 	ldw	r2,-4(fp)
81137a38:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
81137a3c:	e03ff515 	stw	zero,-44(fp)
             break;
81137a40:	00000a06 	br	81137a6c <OSQDel+0x270>
81137a44:	e0bff617 	ldw	r2,-40(fp)
81137a48:	e0bffb15 	stw	r2,-20(fp)
81137a4c:	e0bffb17 	ldw	r2,-20(fp)
81137a50:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81137a54:	e0bfff17 	ldw	r2,-4(fp)
81137a58:	00c001c4 	movi	r3,7
81137a5c:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81137a60:	e0bffd17 	ldw	r2,-12(fp)
81137a64:	e0bff515 	stw	r2,-44(fp)
             break;
81137a68:	0001883a 	nop
    }
    return (pevent_return);
81137a6c:	e0bff517 	ldw	r2,-44(fp)
}
81137a70:	e037883a 	mov	sp,fp
81137a74:	dfc00117 	ldw	ra,4(sp)
81137a78:	df000017 	ldw	fp,0(sp)
81137a7c:	dec00204 	addi	sp,sp,8
81137a80:	f800283a 	ret

81137a84 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
81137a84:	defffa04 	addi	sp,sp,-24
81137a88:	de00012e 	bgeu	sp,et,81137a90 <OSQFlush+0xc>
81137a8c:	003b68fa 	trap	3
81137a90:	df000515 	stw	fp,20(sp)
81137a94:	df000504 	addi	fp,sp,20
81137a98:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81137a9c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81137aa0:	e0bfff17 	ldw	r2,-4(fp)
81137aa4:	1000021e 	bne	r2,zero,81137ab0 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
81137aa8:	00800104 	movi	r2,4
81137aac:	00002106 	br	81137b34 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81137ab0:	e0bfff17 	ldw	r2,-4(fp)
81137ab4:	10800003 	ldbu	r2,0(r2)
81137ab8:	10803fcc 	andi	r2,r2,255
81137abc:	108000a0 	cmpeqi	r2,r2,2
81137ac0:	1000021e 	bne	r2,zero,81137acc <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
81137ac4:	00800044 	movi	r2,1
81137ac8:	00001a06 	br	81137b34 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137acc:	0005303a 	rdctl	r2,status
81137ad0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137ad4:	e0fffd17 	ldw	r3,-12(fp)
81137ad8:	00bfff84 	movi	r2,-2
81137adc:	1884703a 	and	r2,r3,r2
81137ae0:	1001703a 	wrctl	status,r2
  
  return context;
81137ae4:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137ae8:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
81137aec:	e0bfff17 	ldw	r2,-4(fp)
81137af0:	10800117 	ldw	r2,4(r2)
81137af4:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
81137af8:	e0bffc17 	ldw	r2,-16(fp)
81137afc:	10c00117 	ldw	r3,4(r2)
81137b00:	e0bffc17 	ldw	r2,-16(fp)
81137b04:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
81137b08:	e0bffc17 	ldw	r2,-16(fp)
81137b0c:	10c00117 	ldw	r3,4(r2)
81137b10:	e0bffc17 	ldw	r2,-16(fp)
81137b14:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
81137b18:	e0bffc17 	ldw	r2,-16(fp)
81137b1c:	1000058d 	sth	zero,22(r2)
81137b20:	e0bffb17 	ldw	r2,-20(fp)
81137b24:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137b28:	e0bffe17 	ldw	r2,-8(fp)
81137b2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81137b30:	0005883a 	mov	r2,zero
}
81137b34:	e037883a 	mov	sp,fp
81137b38:	df000017 	ldw	fp,0(sp)
81137b3c:	dec00104 	addi	sp,sp,4
81137b40:	f800283a 	ret

81137b44 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81137b44:	defff304 	addi	sp,sp,-52
81137b48:	de00012e 	bgeu	sp,et,81137b50 <OSQPend+0xc>
81137b4c:	003b68fa 	trap	3
81137b50:	dfc00c15 	stw	ra,48(sp)
81137b54:	df000b15 	stw	fp,44(sp)
81137b58:	df000b04 	addi	fp,sp,44
81137b5c:	e13ffd15 	stw	r4,-12(fp)
81137b60:	2805883a 	mov	r2,r5
81137b64:	e1bfff15 	stw	r6,-4(fp)
81137b68:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137b6c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137b70:	e0bfff17 	ldw	r2,-4(fp)
81137b74:	1000021e 	bne	r2,zero,81137b80 <OSQPend+0x3c>
        return ((void *)0);
81137b78:	0005883a 	mov	r2,zero
81137b7c:	00009106 	br	81137dc4 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81137b80:	e0bffd17 	ldw	r2,-12(fp)
81137b84:	1000051e 	bne	r2,zero,81137b9c <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81137b88:	e0bfff17 	ldw	r2,-4(fp)
81137b8c:	00c00104 	movi	r3,4
81137b90:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137b94:	0005883a 	mov	r2,zero
81137b98:	00008a06 	br	81137dc4 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81137b9c:	e0bffd17 	ldw	r2,-12(fp)
81137ba0:	10800003 	ldbu	r2,0(r2)
81137ba4:	10803fcc 	andi	r2,r2,255
81137ba8:	108000a0 	cmpeqi	r2,r2,2
81137bac:	1000051e 	bne	r2,zero,81137bc4 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81137bb0:	e0bfff17 	ldw	r2,-4(fp)
81137bb4:	00c00044 	movi	r3,1
81137bb8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137bbc:	0005883a 	mov	r2,zero
81137bc0:	00008006 	br	81137dc4 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81137bc4:	d0a0a603 	ldbu	r2,-32104(gp)
81137bc8:	10803fcc 	andi	r2,r2,255
81137bcc:	10000526 	beq	r2,zero,81137be4 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
81137bd0:	e0bfff17 	ldw	r2,-4(fp)
81137bd4:	00c00084 	movi	r3,2
81137bd8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137bdc:	0005883a 	mov	r2,zero
81137be0:	00007806 	br	81137dc4 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81137be4:	d0a09403 	ldbu	r2,-32176(gp)
81137be8:	10803fcc 	andi	r2,r2,255
81137bec:	10000526 	beq	r2,zero,81137c04 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
81137bf0:	e0bfff17 	ldw	r2,-4(fp)
81137bf4:	00c00344 	movi	r3,13
81137bf8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137bfc:	0005883a 	mov	r2,zero
81137c00:	00007006 	br	81137dc4 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137c04:	0005303a 	rdctl	r2,status
81137c08:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137c0c:	e0fffc17 	ldw	r3,-16(fp)
81137c10:	00bfff84 	movi	r2,-2
81137c14:	1884703a 	and	r2,r3,r2
81137c18:	1001703a 	wrctl	status,r2
  
  return context;
81137c1c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137c20:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81137c24:	e0bffd17 	ldw	r2,-12(fp)
81137c28:	10800117 	ldw	r2,4(r2)
81137c2c:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81137c30:	e0bff817 	ldw	r2,-32(fp)
81137c34:	1080058b 	ldhu	r2,22(r2)
81137c38:	10bfffcc 	andi	r2,r2,65535
81137c3c:	10001e26 	beq	r2,zero,81137cb8 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81137c40:	e0bff817 	ldw	r2,-32(fp)
81137c44:	10800417 	ldw	r2,16(r2)
81137c48:	11000104 	addi	r4,r2,4
81137c4c:	e0fff817 	ldw	r3,-32(fp)
81137c50:	19000415 	stw	r4,16(r3)
81137c54:	10800017 	ldw	r2,0(r2)
81137c58:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81137c5c:	e0bff817 	ldw	r2,-32(fp)
81137c60:	1080058b 	ldhu	r2,22(r2)
81137c64:	10bfffc4 	addi	r2,r2,-1
81137c68:	1007883a 	mov	r3,r2
81137c6c:	e0bff817 	ldw	r2,-32(fp)
81137c70:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81137c74:	e0bff817 	ldw	r2,-32(fp)
81137c78:	10c00417 	ldw	r3,16(r2)
81137c7c:	e0bff817 	ldw	r2,-32(fp)
81137c80:	10800217 	ldw	r2,8(r2)
81137c84:	1880041e 	bne	r3,r2,81137c98 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
81137c88:	e0bff817 	ldw	r2,-32(fp)
81137c8c:	10c00117 	ldw	r3,4(r2)
81137c90:	e0bff817 	ldw	r2,-32(fp)
81137c94:	10c00415 	stw	r3,16(r2)
81137c98:	e0bff617 	ldw	r2,-40(fp)
81137c9c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ca0:	e0bff717 	ldw	r2,-36(fp)
81137ca4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81137ca8:	e0bfff17 	ldw	r2,-4(fp)
81137cac:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
81137cb0:	e0bff517 	ldw	r2,-44(fp)
81137cb4:	00004306 	br	81137dc4 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
81137cb8:	d0a0a717 	ldw	r2,-32100(gp)
81137cbc:	d0e0a717 	ldw	r3,-32100(gp)
81137cc0:	18c00c03 	ldbu	r3,48(r3)
81137cc4:	18c00114 	ori	r3,r3,4
81137cc8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81137ccc:	d0a0a717 	ldw	r2,-32100(gp)
81137cd0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81137cd4:	d0a0a717 	ldw	r2,-32100(gp)
81137cd8:	e0fffe0b 	ldhu	r3,-8(fp)
81137cdc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
81137ce0:	e13ffd17 	ldw	r4,-12(fp)
81137ce4:	11332700 	call	81133270 <OS_EventTaskWait>
81137ce8:	e0bff617 	ldw	r2,-40(fp)
81137cec:	e0bffb15 	stw	r2,-20(fp)
81137cf0:	e0bffb17 	ldw	r2,-20(fp)
81137cf4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81137cf8:	1133b8c0 	call	81133b8c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137cfc:	0005303a 	rdctl	r2,status
81137d00:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137d04:	e0fff917 	ldw	r3,-28(fp)
81137d08:	00bfff84 	movi	r2,-2
81137d0c:	1884703a 	and	r2,r3,r2
81137d10:	1001703a 	wrctl	status,r2
  
  return context;
81137d14:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81137d18:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81137d1c:	d0a0a717 	ldw	r2,-32100(gp)
81137d20:	10800c43 	ldbu	r2,49(r2)
81137d24:	10803fcc 	andi	r2,r2,255
81137d28:	10000326 	beq	r2,zero,81137d38 <OSQPend+0x1f4>
81137d2c:	108000a0 	cmpeqi	r2,r2,2
81137d30:	1000071e 	bne	r2,zero,81137d50 <OSQPend+0x20c>
81137d34:	00000b06 	br	81137d64 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81137d38:	d0a0a717 	ldw	r2,-32100(gp)
81137d3c:	10800917 	ldw	r2,36(r2)
81137d40:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81137d44:	e0bfff17 	ldw	r2,-4(fp)
81137d48:	10000005 	stb	zero,0(r2)
             break;
81137d4c:	00000e06 	br	81137d88 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
81137d50:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81137d54:	e0bfff17 	ldw	r2,-4(fp)
81137d58:	00c00384 	movi	r3,14
81137d5c:	10c00005 	stb	r3,0(r2)
             break;
81137d60:	00000906 	br	81137d88 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81137d64:	d0a0a717 	ldw	r2,-32100(gp)
81137d68:	e17ffd17 	ldw	r5,-12(fp)
81137d6c:	1009883a 	mov	r4,r2
81137d70:	11334e00 	call	811334e0 <OS_EventTaskRemove>
             pmsg = (void *)0;
81137d74:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81137d78:	e0bfff17 	ldw	r2,-4(fp)
81137d7c:	00c00284 	movi	r3,10
81137d80:	10c00005 	stb	r3,0(r2)
             break;
81137d84:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81137d88:	d0a0a717 	ldw	r2,-32100(gp)
81137d8c:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81137d90:	d0a0a717 	ldw	r2,-32100(gp)
81137d94:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81137d98:	d0a0a717 	ldw	r2,-32100(gp)
81137d9c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81137da0:	d0a0a717 	ldw	r2,-32100(gp)
81137da4:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
81137da8:	d0a0a717 	ldw	r2,-32100(gp)
81137dac:	10000915 	stw	zero,36(r2)
81137db0:	e0bff617 	ldw	r2,-40(fp)
81137db4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137db8:	e0bffa17 	ldw	r2,-24(fp)
81137dbc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
81137dc0:	e0bff517 	ldw	r2,-44(fp)
}
81137dc4:	e037883a 	mov	sp,fp
81137dc8:	dfc00117 	ldw	ra,4(sp)
81137dcc:	df000017 	ldw	fp,0(sp)
81137dd0:	dec00204 	addi	sp,sp,8
81137dd4:	f800283a 	ret

81137dd8 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81137dd8:	defff604 	addi	sp,sp,-40
81137ddc:	de00012e 	bgeu	sp,et,81137de4 <OSQPendAbort+0xc>
81137de0:	003b68fa 	trap	3
81137de4:	dfc00915 	stw	ra,36(sp)
81137de8:	df000815 	stw	fp,32(sp)
81137dec:	df000804 	addi	fp,sp,32
81137df0:	e13ffd15 	stw	r4,-12(fp)
81137df4:	2805883a 	mov	r2,r5
81137df8:	e1bfff15 	stw	r6,-4(fp)
81137dfc:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137e00:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81137e04:	e0bfff17 	ldw	r2,-4(fp)
81137e08:	1000021e 	bne	r2,zero,81137e14 <OSQPendAbort+0x3c>
        return (0);
81137e0c:	0005883a 	mov	r2,zero
81137e10:	00004906 	br	81137f38 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137e14:	e0bffd17 	ldw	r2,-12(fp)
81137e18:	1000051e 	bne	r2,zero,81137e30 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81137e1c:	e0bfff17 	ldw	r2,-4(fp)
81137e20:	00c00104 	movi	r3,4
81137e24:	10c00005 	stb	r3,0(r2)
        return (0);
81137e28:	0005883a 	mov	r2,zero
81137e2c:	00004206 	br	81137f38 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81137e30:	e0bffd17 	ldw	r2,-12(fp)
81137e34:	10800003 	ldbu	r2,0(r2)
81137e38:	10803fcc 	andi	r2,r2,255
81137e3c:	108000a0 	cmpeqi	r2,r2,2
81137e40:	1000051e 	bne	r2,zero,81137e58 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81137e44:	e0bfff17 	ldw	r2,-4(fp)
81137e48:	00c00044 	movi	r3,1
81137e4c:	10c00005 	stb	r3,0(r2)
        return (0);
81137e50:	0005883a 	mov	r2,zero
81137e54:	00003806 	br	81137f38 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137e58:	0005303a 	rdctl	r2,status
81137e5c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137e60:	e0fffc17 	ldw	r3,-16(fp)
81137e64:	00bfff84 	movi	r2,-2
81137e68:	1884703a 	and	r2,r3,r2
81137e6c:	1001703a 	wrctl	status,r2
  
  return context;
81137e70:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137e74:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
81137e78:	e0bffd17 	ldw	r2,-12(fp)
81137e7c:	10800283 	ldbu	r2,10(r2)
81137e80:	10803fcc 	andi	r2,r2,255
81137e84:	10002526 	beq	r2,zero,81137f1c <OSQPendAbort+0x144>
        nbr_tasks = 0;
81137e88:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81137e8c:	e0bffe03 	ldbu	r2,-8(fp)
81137e90:	10800060 	cmpeqi	r2,r2,1
81137e94:	10000e26 	beq	r2,zero,81137ed0 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81137e98:	00000806 	br	81137ebc <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81137e9c:	01c00084 	movi	r7,2
81137ea0:	01800104 	movi	r6,4
81137ea4:	000b883a 	mov	r5,zero
81137ea8:	e13ffd17 	ldw	r4,-12(fp)
81137eac:	11330d00 	call	811330d0 <OS_EventTaskRdy>
                     nbr_tasks++;
81137eb0:	e0bff803 	ldbu	r2,-32(fp)
81137eb4:	10800044 	addi	r2,r2,1
81137eb8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81137ebc:	e0bffd17 	ldw	r2,-12(fp)
81137ec0:	10800283 	ldbu	r2,10(r2)
81137ec4:	10803fcc 	andi	r2,r2,255
81137ec8:	103ff41e 	bne	r2,zero,81137e9c <__reset+0xfb117e9c>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81137ecc:	00000906 	br	81137ef4 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81137ed0:	01c00084 	movi	r7,2
81137ed4:	01800104 	movi	r6,4
81137ed8:	000b883a 	mov	r5,zero
81137edc:	e13ffd17 	ldw	r4,-12(fp)
81137ee0:	11330d00 	call	811330d0 <OS_EventTaskRdy>
                 nbr_tasks++;
81137ee4:	e0bff803 	ldbu	r2,-32(fp)
81137ee8:	10800044 	addi	r2,r2,1
81137eec:	e0bff805 	stb	r2,-32(fp)
                 break;
81137ef0:	0001883a 	nop
81137ef4:	e0bff917 	ldw	r2,-28(fp)
81137ef8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137efc:	e0bffa17 	ldw	r2,-24(fp)
81137f00:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
81137f04:	1133b8c0 	call	81133b8c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81137f08:	e0bfff17 	ldw	r2,-4(fp)
81137f0c:	00c00384 	movi	r3,14
81137f10:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81137f14:	e0bff803 	ldbu	r2,-32(fp)
81137f18:	00000706 	br	81137f38 <OSQPendAbort+0x160>
81137f1c:	e0bff917 	ldw	r2,-28(fp)
81137f20:	e0bffb15 	stw	r2,-20(fp)
81137f24:	e0bffb17 	ldw	r2,-20(fp)
81137f28:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137f2c:	e0bfff17 	ldw	r2,-4(fp)
81137f30:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81137f34:	0005883a 	mov	r2,zero
}
81137f38:	e037883a 	mov	sp,fp
81137f3c:	dfc00117 	ldw	ra,4(sp)
81137f40:	df000017 	ldw	fp,0(sp)
81137f44:	dec00204 	addi	sp,sp,8
81137f48:	f800283a 	ret

81137f4c <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
81137f4c:	defff604 	addi	sp,sp,-40
81137f50:	de00012e 	bgeu	sp,et,81137f58 <OSQPost+0xc>
81137f54:	003b68fa 	trap	3
81137f58:	dfc00915 	stw	ra,36(sp)
81137f5c:	df000815 	stw	fp,32(sp)
81137f60:	df000804 	addi	fp,sp,32
81137f64:	e13ffe15 	stw	r4,-8(fp)
81137f68:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81137f6c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81137f70:	e0bffe17 	ldw	r2,-8(fp)
81137f74:	1000021e 	bne	r2,zero,81137f80 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
81137f78:	00800104 	movi	r2,4
81137f7c:	00004a06 	br	811380a8 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81137f80:	e0bffe17 	ldw	r2,-8(fp)
81137f84:	10800003 	ldbu	r2,0(r2)
81137f88:	10803fcc 	andi	r2,r2,255
81137f8c:	108000a0 	cmpeqi	r2,r2,2
81137f90:	1000021e 	bne	r2,zero,81137f9c <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
81137f94:	00800044 	movi	r2,1
81137f98:	00004306 	br	811380a8 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137f9c:	0005303a 	rdctl	r2,status
81137fa0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137fa4:	e0fffd17 	ldw	r3,-12(fp)
81137fa8:	00bfff84 	movi	r2,-2
81137fac:	1884703a 	and	r2,r3,r2
81137fb0:	1001703a 	wrctl	status,r2
  
  return context;
81137fb4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137fb8:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
81137fbc:	e0bffe17 	ldw	r2,-8(fp)
81137fc0:	10800283 	ldbu	r2,10(r2)
81137fc4:	10803fcc 	andi	r2,r2,255
81137fc8:	10000c26 	beq	r2,zero,81137ffc <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81137fcc:	000f883a 	mov	r7,zero
81137fd0:	01800104 	movi	r6,4
81137fd4:	e17fff17 	ldw	r5,-4(fp)
81137fd8:	e13ffe17 	ldw	r4,-8(fp)
81137fdc:	11330d00 	call	811330d0 <OS_EventTaskRdy>
81137fe0:	e0bff817 	ldw	r2,-32(fp)
81137fe4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137fe8:	e0bff917 	ldw	r2,-28(fp)
81137fec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
81137ff0:	1133b8c0 	call	81133b8c <OS_Sched>
        return (OS_ERR_NONE);
81137ff4:	0005883a 	mov	r2,zero
81137ff8:	00002b06 	br	811380a8 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
81137ffc:	e0bffe17 	ldw	r2,-8(fp)
81138000:	10800117 	ldw	r2,4(r2)
81138004:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
81138008:	e0bffb17 	ldw	r2,-20(fp)
8113800c:	10c0058b 	ldhu	r3,22(r2)
81138010:	e0bffb17 	ldw	r2,-20(fp)
81138014:	1080050b 	ldhu	r2,20(r2)
81138018:	18ffffcc 	andi	r3,r3,65535
8113801c:	10bfffcc 	andi	r2,r2,65535
81138020:	18800636 	bltu	r3,r2,8113803c <OSQPost+0xf0>
81138024:	e0bff817 	ldw	r2,-32(fp)
81138028:	e0bffa15 	stw	r2,-24(fp)
8113802c:	e0bffa17 	ldw	r2,-24(fp)
81138030:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81138034:	00800784 	movi	r2,30
81138038:	00001b06 	br	811380a8 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113803c:	e0bffb17 	ldw	r2,-20(fp)
81138040:	10800317 	ldw	r2,12(r2)
81138044:	11000104 	addi	r4,r2,4
81138048:	e0fffb17 	ldw	r3,-20(fp)
8113804c:	19000315 	stw	r4,12(r3)
81138050:	e0ffff17 	ldw	r3,-4(fp)
81138054:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81138058:	e0bffb17 	ldw	r2,-20(fp)
8113805c:	1080058b 	ldhu	r2,22(r2)
81138060:	10800044 	addi	r2,r2,1
81138064:	1007883a 	mov	r3,r2
81138068:	e0bffb17 	ldw	r2,-20(fp)
8113806c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
81138070:	e0bffb17 	ldw	r2,-20(fp)
81138074:	10c00317 	ldw	r3,12(r2)
81138078:	e0bffb17 	ldw	r2,-20(fp)
8113807c:	10800217 	ldw	r2,8(r2)
81138080:	1880041e 	bne	r3,r2,81138094 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81138084:	e0bffb17 	ldw	r2,-20(fp)
81138088:	10c00117 	ldw	r3,4(r2)
8113808c:	e0bffb17 	ldw	r2,-20(fp)
81138090:	10c00315 	stw	r3,12(r2)
81138094:	e0bff817 	ldw	r2,-32(fp)
81138098:	e0bffc15 	stw	r2,-16(fp)
8113809c:	e0bffc17 	ldw	r2,-16(fp)
811380a0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811380a4:	0005883a 	mov	r2,zero
}
811380a8:	e037883a 	mov	sp,fp
811380ac:	dfc00117 	ldw	ra,4(sp)
811380b0:	df000017 	ldw	fp,0(sp)
811380b4:	dec00204 	addi	sp,sp,8
811380b8:	f800283a 	ret

811380bc <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
811380bc:	defff604 	addi	sp,sp,-40
811380c0:	de00012e 	bgeu	sp,et,811380c8 <OSQPostFront+0xc>
811380c4:	003b68fa 	trap	3
811380c8:	dfc00915 	stw	ra,36(sp)
811380cc:	df000815 	stw	fp,32(sp)
811380d0:	df000804 	addi	fp,sp,32
811380d4:	e13ffe15 	stw	r4,-8(fp)
811380d8:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811380dc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811380e0:	e0bffe17 	ldw	r2,-8(fp)
811380e4:	1000021e 	bne	r2,zero,811380f0 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
811380e8:	00800104 	movi	r2,4
811380ec:	00004c06 	br	81138220 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811380f0:	e0bffe17 	ldw	r2,-8(fp)
811380f4:	10800003 	ldbu	r2,0(r2)
811380f8:	10803fcc 	andi	r2,r2,255
811380fc:	108000a0 	cmpeqi	r2,r2,2
81138100:	1000021e 	bne	r2,zero,8113810c <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
81138104:	00800044 	movi	r2,1
81138108:	00004506 	br	81138220 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113810c:	0005303a 	rdctl	r2,status
81138110:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138114:	e0fffd17 	ldw	r3,-12(fp)
81138118:	00bfff84 	movi	r2,-2
8113811c:	1884703a 	and	r2,r3,r2
81138120:	1001703a 	wrctl	status,r2
  
  return context;
81138124:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138128:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113812c:	e0bffe17 	ldw	r2,-8(fp)
81138130:	10800283 	ldbu	r2,10(r2)
81138134:	10803fcc 	andi	r2,r2,255
81138138:	10000c26 	beq	r2,zero,8113816c <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113813c:	000f883a 	mov	r7,zero
81138140:	01800104 	movi	r6,4
81138144:	e17fff17 	ldw	r5,-4(fp)
81138148:	e13ffe17 	ldw	r4,-8(fp)
8113814c:	11330d00 	call	811330d0 <OS_EventTaskRdy>
81138150:	e0bff817 	ldw	r2,-32(fp)
81138154:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138158:	e0bff917 	ldw	r2,-28(fp)
8113815c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
81138160:	1133b8c0 	call	81133b8c <OS_Sched>
        return (OS_ERR_NONE);
81138164:	0005883a 	mov	r2,zero
81138168:	00002d06 	br	81138220 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113816c:	e0bffe17 	ldw	r2,-8(fp)
81138170:	10800117 	ldw	r2,4(r2)
81138174:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81138178:	e0bffb17 	ldw	r2,-20(fp)
8113817c:	10c0058b 	ldhu	r3,22(r2)
81138180:	e0bffb17 	ldw	r2,-20(fp)
81138184:	1080050b 	ldhu	r2,20(r2)
81138188:	18ffffcc 	andi	r3,r3,65535
8113818c:	10bfffcc 	andi	r2,r2,65535
81138190:	18800636 	bltu	r3,r2,811381ac <OSQPostFront+0xf0>
81138194:	e0bff817 	ldw	r2,-32(fp)
81138198:	e0bffa15 	stw	r2,-24(fp)
8113819c:	e0bffa17 	ldw	r2,-24(fp)
811381a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
811381a4:	00800784 	movi	r2,30
811381a8:	00001d06 	br	81138220 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
811381ac:	e0bffb17 	ldw	r2,-20(fp)
811381b0:	10c00417 	ldw	r3,16(r2)
811381b4:	e0bffb17 	ldw	r2,-20(fp)
811381b8:	10800117 	ldw	r2,4(r2)
811381bc:	1880041e 	bne	r3,r2,811381d0 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
811381c0:	e0bffb17 	ldw	r2,-20(fp)
811381c4:	10c00217 	ldw	r3,8(r2)
811381c8:	e0bffb17 	ldw	r2,-20(fp)
811381cc:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
811381d0:	e0bffb17 	ldw	r2,-20(fp)
811381d4:	10800417 	ldw	r2,16(r2)
811381d8:	10ffff04 	addi	r3,r2,-4
811381dc:	e0bffb17 	ldw	r2,-20(fp)
811381e0:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
811381e4:	e0bffb17 	ldw	r2,-20(fp)
811381e8:	10800417 	ldw	r2,16(r2)
811381ec:	e0ffff17 	ldw	r3,-4(fp)
811381f0:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
811381f4:	e0bffb17 	ldw	r2,-20(fp)
811381f8:	1080058b 	ldhu	r2,22(r2)
811381fc:	10800044 	addi	r2,r2,1
81138200:	1007883a 	mov	r3,r2
81138204:	e0bffb17 	ldw	r2,-20(fp)
81138208:	10c0058d 	sth	r3,22(r2)
8113820c:	e0bff817 	ldw	r2,-32(fp)
81138210:	e0bffc15 	stw	r2,-16(fp)
81138214:	e0bffc17 	ldw	r2,-16(fp)
81138218:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113821c:	0005883a 	mov	r2,zero
}
81138220:	e037883a 	mov	sp,fp
81138224:	dfc00117 	ldw	ra,4(sp)
81138228:	df000017 	ldw	fp,0(sp)
8113822c:	dec00204 	addi	sp,sp,8
81138230:	f800283a 	ret

81138234 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
81138234:	defff504 	addi	sp,sp,-44
81138238:	de00012e 	bgeu	sp,et,81138240 <OSQPostOpt+0xc>
8113823c:	003b68fa 	trap	3
81138240:	dfc00a15 	stw	ra,40(sp)
81138244:	df000915 	stw	fp,36(sp)
81138248:	df000904 	addi	fp,sp,36
8113824c:	e13ffd15 	stw	r4,-12(fp)
81138250:	e17ffe15 	stw	r5,-8(fp)
81138254:	3005883a 	mov	r2,r6
81138258:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113825c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138260:	e0bffd17 	ldw	r2,-12(fp)
81138264:	1000021e 	bne	r2,zero,81138270 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81138268:	00800104 	movi	r2,4
8113826c:	00007106 	br	81138434 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81138270:	e0bffd17 	ldw	r2,-12(fp)
81138274:	10800003 	ldbu	r2,0(r2)
81138278:	10803fcc 	andi	r2,r2,255
8113827c:	108000a0 	cmpeqi	r2,r2,2
81138280:	1000021e 	bne	r2,zero,8113828c <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81138284:	00800044 	movi	r2,1
81138288:	00006a06 	br	81138434 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113828c:	0005303a 	rdctl	r2,status
81138290:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138294:	e0fffc17 	ldw	r3,-16(fp)
81138298:	00bfff84 	movi	r2,-2
8113829c:	1884703a 	and	r2,r3,r2
811382a0:	1001703a 	wrctl	status,r2
  
  return context;
811382a4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811382a8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
811382ac:	e0bffd17 	ldw	r2,-12(fp)
811382b0:	10800283 	ldbu	r2,10(r2)
811382b4:	10803fcc 	andi	r2,r2,255
811382b8:	10001d26 	beq	r2,zero,81138330 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
811382bc:	e0bfff03 	ldbu	r2,-4(fp)
811382c0:	1080004c 	andi	r2,r2,1
811382c4:	10000b26 	beq	r2,zero,811382f4 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
811382c8:	00000506 	br	811382e0 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811382cc:	000f883a 	mov	r7,zero
811382d0:	01800104 	movi	r6,4
811382d4:	e17ffe17 	ldw	r5,-8(fp)
811382d8:	e13ffd17 	ldw	r4,-12(fp)
811382dc:	11330d00 	call	811330d0 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
811382e0:	e0bffd17 	ldw	r2,-12(fp)
811382e4:	10800283 	ldbu	r2,10(r2)
811382e8:	10803fcc 	andi	r2,r2,255
811382ec:	103ff71e 	bne	r2,zero,811382cc <__reset+0xfb1182cc>
811382f0:	00000506 	br	81138308 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
811382f4:	000f883a 	mov	r7,zero
811382f8:	01800104 	movi	r6,4
811382fc:	e17ffe17 	ldw	r5,-8(fp)
81138300:	e13ffd17 	ldw	r4,-12(fp)
81138304:	11330d00 	call	811330d0 <OS_EventTaskRdy>
81138308:	e0bff717 	ldw	r2,-36(fp)
8113830c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138310:	e0bff817 	ldw	r2,-32(fp)
81138314:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
81138318:	e0bfff03 	ldbu	r2,-4(fp)
8113831c:	1080010c 	andi	r2,r2,4
81138320:	1000011e 	bne	r2,zero,81138328 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81138324:	1133b8c0 	call	81133b8c <OS_Sched>
        }
        return (OS_ERR_NONE);
81138328:	0005883a 	mov	r2,zero
8113832c:	00004106 	br	81138434 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81138330:	e0bffd17 	ldw	r2,-12(fp)
81138334:	10800117 	ldw	r2,4(r2)
81138338:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113833c:	e0bffa17 	ldw	r2,-24(fp)
81138340:	10c0058b 	ldhu	r3,22(r2)
81138344:	e0bffa17 	ldw	r2,-24(fp)
81138348:	1080050b 	ldhu	r2,20(r2)
8113834c:	18ffffcc 	andi	r3,r3,65535
81138350:	10bfffcc 	andi	r2,r2,65535
81138354:	18800636 	bltu	r3,r2,81138370 <OSQPostOpt+0x13c>
81138358:	e0bff717 	ldw	r2,-36(fp)
8113835c:	e0bff915 	stw	r2,-28(fp)
81138360:	e0bff917 	ldw	r2,-28(fp)
81138364:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81138368:	00800784 	movi	r2,30
8113836c:	00003106 	br	81138434 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81138370:	e0bfff03 	ldbu	r2,-4(fp)
81138374:	1080008c 	andi	r2,r2,2
81138378:	10001326 	beq	r2,zero,811383c8 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113837c:	e0bffa17 	ldw	r2,-24(fp)
81138380:	10c00417 	ldw	r3,16(r2)
81138384:	e0bffa17 	ldw	r2,-24(fp)
81138388:	10800117 	ldw	r2,4(r2)
8113838c:	1880041e 	bne	r3,r2,811383a0 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
81138390:	e0bffa17 	ldw	r2,-24(fp)
81138394:	10c00217 	ldw	r3,8(r2)
81138398:	e0bffa17 	ldw	r2,-24(fp)
8113839c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
811383a0:	e0bffa17 	ldw	r2,-24(fp)
811383a4:	10800417 	ldw	r2,16(r2)
811383a8:	10ffff04 	addi	r3,r2,-4
811383ac:	e0bffa17 	ldw	r2,-24(fp)
811383b0:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
811383b4:	e0bffa17 	ldw	r2,-24(fp)
811383b8:	10800417 	ldw	r2,16(r2)
811383bc:	e0fffe17 	ldw	r3,-8(fp)
811383c0:	10c00015 	stw	r3,0(r2)
811383c4:	00001006 	br	81138408 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
811383c8:	e0bffa17 	ldw	r2,-24(fp)
811383cc:	10800317 	ldw	r2,12(r2)
811383d0:	11000104 	addi	r4,r2,4
811383d4:	e0fffa17 	ldw	r3,-24(fp)
811383d8:	19000315 	stw	r4,12(r3)
811383dc:	e0fffe17 	ldw	r3,-8(fp)
811383e0:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
811383e4:	e0bffa17 	ldw	r2,-24(fp)
811383e8:	10c00317 	ldw	r3,12(r2)
811383ec:	e0bffa17 	ldw	r2,-24(fp)
811383f0:	10800217 	ldw	r2,8(r2)
811383f4:	1880041e 	bne	r3,r2,81138408 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
811383f8:	e0bffa17 	ldw	r2,-24(fp)
811383fc:	10c00117 	ldw	r3,4(r2)
81138400:	e0bffa17 	ldw	r2,-24(fp)
81138404:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81138408:	e0bffa17 	ldw	r2,-24(fp)
8113840c:	1080058b 	ldhu	r2,22(r2)
81138410:	10800044 	addi	r2,r2,1
81138414:	1007883a 	mov	r3,r2
81138418:	e0bffa17 	ldw	r2,-24(fp)
8113841c:	10c0058d 	sth	r3,22(r2)
81138420:	e0bff717 	ldw	r2,-36(fp)
81138424:	e0bffb15 	stw	r2,-20(fp)
81138428:	e0bffb17 	ldw	r2,-20(fp)
8113842c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138430:	0005883a 	mov	r2,zero
}
81138434:	e037883a 	mov	sp,fp
81138438:	dfc00117 	ldw	ra,4(sp)
8113843c:	df000017 	ldw	fp,0(sp)
81138440:	dec00204 	addi	sp,sp,8
81138444:	f800283a 	ret

81138448 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81138448:	defff604 	addi	sp,sp,-40
8113844c:	de00012e 	bgeu	sp,et,81138454 <OSQQuery+0xc>
81138450:	003b68fa 	trap	3
81138454:	df000915 	stw	fp,36(sp)
81138458:	df000904 	addi	fp,sp,36
8113845c:	e13ffe15 	stw	r4,-8(fp)
81138460:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138464:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81138468:	e0bffe17 	ldw	r2,-8(fp)
8113846c:	1000021e 	bne	r2,zero,81138478 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81138470:	00800104 	movi	r2,4
81138474:	00004906 	br	8113859c <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81138478:	e0bfff17 	ldw	r2,-4(fp)
8113847c:	1000021e 	bne	r2,zero,81138488 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81138480:	00800244 	movi	r2,9
81138484:	00004506 	br	8113859c <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81138488:	e0bffe17 	ldw	r2,-8(fp)
8113848c:	10800003 	ldbu	r2,0(r2)
81138490:	10803fcc 	andi	r2,r2,255
81138494:	108000a0 	cmpeqi	r2,r2,2
81138498:	1000021e 	bne	r2,zero,811384a4 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113849c:	00800044 	movi	r2,1
811384a0:	00003e06 	br	8113859c <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811384a4:	0005303a 	rdctl	r2,status
811384a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811384ac:	e0fffd17 	ldw	r3,-12(fp)
811384b0:	00bfff84 	movi	r2,-2
811384b4:	1884703a 	and	r2,r3,r2
811384b8:	1001703a 	wrctl	status,r2
  
  return context;
811384bc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811384c0:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
811384c4:	e0bffe17 	ldw	r2,-8(fp)
811384c8:	10c00283 	ldbu	r3,10(r2)
811384cc:	e0bfff17 	ldw	r2,-4(fp)
811384d0:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
811384d4:	e0bffe17 	ldw	r2,-8(fp)
811384d8:	108002c4 	addi	r2,r2,11
811384dc:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
811384e0:	e0bfff17 	ldw	r2,-4(fp)
811384e4:	10800204 	addi	r2,r2,8
811384e8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811384ec:	e03ff705 	stb	zero,-36(fp)
811384f0:	00000b06 	br	81138520 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
811384f4:	e0bff917 	ldw	r2,-28(fp)
811384f8:	10c00044 	addi	r3,r2,1
811384fc:	e0fff915 	stw	r3,-28(fp)
81138500:	e0fff817 	ldw	r3,-32(fp)
81138504:	19000044 	addi	r4,r3,1
81138508:	e13ff815 	stw	r4,-32(fp)
8113850c:	18c00003 	ldbu	r3,0(r3)
81138510:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138514:	e0bff703 	ldbu	r2,-36(fp)
81138518:	10800044 	addi	r2,r2,1
8113851c:	e0bff705 	stb	r2,-36(fp)
81138520:	e0bff703 	ldbu	r2,-36(fp)
81138524:	108001b0 	cmpltui	r2,r2,6
81138528:	103ff21e 	bne	r2,zero,811384f4 <__reset+0xfb1184f4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113852c:	e0bffe17 	ldw	r2,-8(fp)
81138530:	10800117 	ldw	r2,4(r2)
81138534:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81138538:	e0bffc17 	ldw	r2,-16(fp)
8113853c:	1080058b 	ldhu	r2,22(r2)
81138540:	10bfffcc 	andi	r2,r2,65535
81138544:	10000626 	beq	r2,zero,81138560 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81138548:	e0bffc17 	ldw	r2,-16(fp)
8113854c:	10800417 	ldw	r2,16(r2)
81138550:	10c00017 	ldw	r3,0(r2)
81138554:	e0bfff17 	ldw	r2,-4(fp)
81138558:	10c00015 	stw	r3,0(r2)
8113855c:	00000206 	br	81138568 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
81138560:	e0bfff17 	ldw	r2,-4(fp)
81138564:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
81138568:	e0bffc17 	ldw	r2,-16(fp)
8113856c:	10c0058b 	ldhu	r3,22(r2)
81138570:	e0bfff17 	ldw	r2,-4(fp)
81138574:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
81138578:	e0bffc17 	ldw	r2,-16(fp)
8113857c:	10c0050b 	ldhu	r3,20(r2)
81138580:	e0bfff17 	ldw	r2,-4(fp)
81138584:	10c0018d 	sth	r3,6(r2)
81138588:	e0bffa17 	ldw	r2,-24(fp)
8113858c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138590:	e0bffb17 	ldw	r2,-20(fp)
81138594:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138598:	0005883a 	mov	r2,zero
}
8113859c:	e037883a 	mov	sp,fp
811385a0:	df000017 	ldw	fp,0(sp)
811385a4:	dec00104 	addi	sp,sp,4
811385a8:	f800283a 	ret

811385ac <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
811385ac:	defffb04 	addi	sp,sp,-20
811385b0:	de00012e 	bgeu	sp,et,811385b8 <OS_QInit+0xc>
811385b4:	003b68fa 	trap	3
811385b8:	dfc00415 	stw	ra,16(sp)
811385bc:	df000315 	stw	fp,12(sp)
811385c0:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
811385c4:	01406004 	movi	r5,384
811385c8:	012045b4 	movhi	r4,33046
811385cc:	21079704 	addi	r4,r4,7772
811385d0:	1133ac00 	call	81133ac0 <OS_MemClr>
    pq1 = &OSQTbl[0];
811385d4:	00a045b4 	movhi	r2,33046
811385d8:	10879704 	addi	r2,r2,7772
811385dc:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
811385e0:	00a045b4 	movhi	r2,33046
811385e4:	10879d04 	addi	r2,r2,7796
811385e8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
811385ec:	e03ffd0d 	sth	zero,-12(fp)
811385f0:	00000c06 	br	81138624 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
811385f4:	e0bffe17 	ldw	r2,-8(fp)
811385f8:	e0ffff17 	ldw	r3,-4(fp)
811385fc:	10c00015 	stw	r3,0(r2)
        pq1++;
81138600:	e0bffe17 	ldw	r2,-8(fp)
81138604:	10800604 	addi	r2,r2,24
81138608:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113860c:	e0bfff17 	ldw	r2,-4(fp)
81138610:	10800604 	addi	r2,r2,24
81138614:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81138618:	e0bffd0b 	ldhu	r2,-12(fp)
8113861c:	10800044 	addi	r2,r2,1
81138620:	e0bffd0d 	sth	r2,-12(fp)
81138624:	e0bffd0b 	ldhu	r2,-12(fp)
81138628:	108003f0 	cmpltui	r2,r2,15
8113862c:	103ff11e 	bne	r2,zero,811385f4 <__reset+0xfb1185f4>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
81138630:	e0bffe17 	ldw	r2,-8(fp)
81138634:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81138638:	00a045b4 	movhi	r2,33046
8113863c:	10879704 	addi	r2,r2,7772
81138640:	d0a0a215 	stw	r2,-32120(gp)
#endif
}
81138644:	0001883a 	nop
81138648:	e037883a 	mov	sp,fp
8113864c:	dfc00117 	ldw	ra,4(sp)
81138650:	df000017 	ldw	fp,0(sp)
81138654:	dec00204 	addi	sp,sp,8
81138658:	f800283a 	ret

8113865c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113865c:	defffa04 	addi	sp,sp,-24
81138660:	de00012e 	bgeu	sp,et,81138668 <OSSemAccept+0xc>
81138664:	003b68fa 	trap	3
81138668:	df000515 	stw	fp,20(sp)
8113866c:	df000504 	addi	fp,sp,20
81138670:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138674:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138678:	e0bfff17 	ldw	r2,-4(fp)
8113867c:	1000021e 	bne	r2,zero,81138688 <OSSemAccept+0x2c>
        return (0);
81138680:	0005883a 	mov	r2,zero
81138684:	00001f06 	br	81138704 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81138688:	e0bfff17 	ldw	r2,-4(fp)
8113868c:	10800003 	ldbu	r2,0(r2)
81138690:	10803fcc 	andi	r2,r2,255
81138694:	108000e0 	cmpeqi	r2,r2,3
81138698:	1000021e 	bne	r2,zero,811386a4 <OSSemAccept+0x48>
        return (0);
8113869c:	0005883a 	mov	r2,zero
811386a0:	00001806 	br	81138704 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811386a4:	0005303a 	rdctl	r2,status
811386a8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811386ac:	e0fffe17 	ldw	r3,-8(fp)
811386b0:	00bfff84 	movi	r2,-2
811386b4:	1884703a 	and	r2,r3,r2
811386b8:	1001703a 	wrctl	status,r2
  
  return context;
811386bc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811386c0:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
811386c4:	e0bfff17 	ldw	r2,-4(fp)
811386c8:	1080020b 	ldhu	r2,8(r2)
811386cc:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
811386d0:	e0bffd0b 	ldhu	r2,-12(fp)
811386d4:	10000626 	beq	r2,zero,811386f0 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
811386d8:	e0bfff17 	ldw	r2,-4(fp)
811386dc:	1080020b 	ldhu	r2,8(r2)
811386e0:	10bfffc4 	addi	r2,r2,-1
811386e4:	1007883a 	mov	r3,r2
811386e8:	e0bfff17 	ldw	r2,-4(fp)
811386ec:	10c0020d 	sth	r3,8(r2)
811386f0:	e0bffb17 	ldw	r2,-20(fp)
811386f4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811386f8:	e0bffc17 	ldw	r2,-16(fp)
811386fc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
81138700:	e0bffd0b 	ldhu	r2,-12(fp)
}
81138704:	e037883a 	mov	sp,fp
81138708:	df000017 	ldw	fp,0(sp)
8113870c:	dec00104 	addi	sp,sp,4
81138710:	f800283a 	ret

81138714 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81138714:	defff904 	addi	sp,sp,-28
81138718:	de00012e 	bgeu	sp,et,81138720 <OSSemCreate+0xc>
8113871c:	003b68fa 	trap	3
81138720:	dfc00615 	stw	ra,24(sp)
81138724:	df000515 	stw	fp,20(sp)
81138728:	df000504 	addi	fp,sp,20
8113872c:	2005883a 	mov	r2,r4
81138730:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138734:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81138738:	d0a0a603 	ldbu	r2,-32104(gp)
8113873c:	10803fcc 	andi	r2,r2,255
81138740:	10000226 	beq	r2,zero,8113874c <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81138744:	0005883a 	mov	r2,zero
81138748:	00002506 	br	811387e0 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113874c:	0005303a 	rdctl	r2,status
81138750:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138754:	e0fffe17 	ldw	r3,-8(fp)
81138758:	00bfff84 	movi	r2,-2
8113875c:	1884703a 	and	r2,r3,r2
81138760:	1001703a 	wrctl	status,r2
  
  return context;
81138764:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81138768:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113876c:	d0a0a517 	ldw	r2,-32108(gp)
81138770:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
81138774:	d0a0a517 	ldw	r2,-32108(gp)
81138778:	10000326 	beq	r2,zero,81138788 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113877c:	d0a0a517 	ldw	r2,-32108(gp)
81138780:	10800117 	ldw	r2,4(r2)
81138784:	d0a0a515 	stw	r2,-32108(gp)
81138788:	e0bffb17 	ldw	r2,-20(fp)
8113878c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138790:	e0bffc17 	ldw	r2,-16(fp)
81138794:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
81138798:	e0bffd17 	ldw	r2,-12(fp)
8113879c:	10000f26 	beq	r2,zero,811387dc <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
811387a0:	e0bffd17 	ldw	r2,-12(fp)
811387a4:	00c000c4 	movi	r3,3
811387a8:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
811387ac:	e0bffd17 	ldw	r2,-12(fp)
811387b0:	e0ffff0b 	ldhu	r3,-4(fp)
811387b4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
811387b8:	e0bffd17 	ldw	r2,-12(fp)
811387bc:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
811387c0:	e0bffd17 	ldw	r2,-12(fp)
811387c4:	00c00fc4 	movi	r3,63
811387c8:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
811387cc:	e0bffd17 	ldw	r2,-12(fp)
811387d0:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
811387d4:	e13ffd17 	ldw	r4,-12(fp)
811387d8:	11336a80 	call	811336a8 <OS_EventWaitListInit>
    }
    return (pevent);
811387dc:	e0bffd17 	ldw	r2,-12(fp)
}
811387e0:	e037883a 	mov	sp,fp
811387e4:	dfc00117 	ldw	ra,4(sp)
811387e8:	df000017 	ldw	fp,0(sp)
811387ec:	dec00204 	addi	sp,sp,8
811387f0:	f800283a 	ret

811387f4 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811387f4:	defff304 	addi	sp,sp,-52
811387f8:	de00012e 	bgeu	sp,et,81138800 <OSSemDel+0xc>
811387fc:	003b68fa 	trap	3
81138800:	dfc00c15 	stw	ra,48(sp)
81138804:	df000b15 	stw	fp,44(sp)
81138808:	df000b04 	addi	fp,sp,44
8113880c:	e13ffd15 	stw	r4,-12(fp)
81138810:	2805883a 	mov	r2,r5
81138814:	e1bfff15 	stw	r6,-4(fp)
81138818:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113881c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138820:	e0bfff17 	ldw	r2,-4(fp)
81138824:	1000021e 	bne	r2,zero,81138830 <OSSemDel+0x3c>
        return (pevent);
81138828:	e0bffd17 	ldw	r2,-12(fp)
8113882c:	00007e06 	br	81138a28 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138830:	e0bffd17 	ldw	r2,-12(fp)
81138834:	1000051e 	bne	r2,zero,8113884c <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138838:	e0bfff17 	ldw	r2,-4(fp)
8113883c:	00c00104 	movi	r3,4
81138840:	10c00005 	stb	r3,0(r2)
        return (pevent);
81138844:	e0bffd17 	ldw	r2,-12(fp)
81138848:	00007706 	br	81138a28 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113884c:	e0bffd17 	ldw	r2,-12(fp)
81138850:	10800003 	ldbu	r2,0(r2)
81138854:	10803fcc 	andi	r2,r2,255
81138858:	108000e0 	cmpeqi	r2,r2,3
8113885c:	1000051e 	bne	r2,zero,81138874 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138860:	e0bfff17 	ldw	r2,-4(fp)
81138864:	00c00044 	movi	r3,1
81138868:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113886c:	e0bffd17 	ldw	r2,-12(fp)
81138870:	00006d06 	br	81138a28 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81138874:	d0a0a603 	ldbu	r2,-32104(gp)
81138878:	10803fcc 	andi	r2,r2,255
8113887c:	10000526 	beq	r2,zero,81138894 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
81138880:	e0bfff17 	ldw	r2,-4(fp)
81138884:	00c003c4 	movi	r3,15
81138888:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113888c:	e0bffd17 	ldw	r2,-12(fp)
81138890:	00006506 	br	81138a28 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138894:	0005303a 	rdctl	r2,status
81138898:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113889c:	e0fffc17 	ldw	r3,-16(fp)
811388a0:	00bfff84 	movi	r2,-2
811388a4:	1884703a 	and	r2,r3,r2
811388a8:	1001703a 	wrctl	status,r2
  
  return context;
811388ac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811388b0:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
811388b4:	e0bffd17 	ldw	r2,-12(fp)
811388b8:	10800283 	ldbu	r2,10(r2)
811388bc:	10803fcc 	andi	r2,r2,255
811388c0:	10000326 	beq	r2,zero,811388d0 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811388c4:	00800044 	movi	r2,1
811388c8:	e0bff505 	stb	r2,-44(fp)
811388cc:	00000106 	br	811388d4 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811388d0:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
811388d4:	e0bffe03 	ldbu	r2,-8(fp)
811388d8:	10000326 	beq	r2,zero,811388e8 <OSSemDel+0xf4>
811388dc:	10800060 	cmpeqi	r2,r2,1
811388e0:	1000281e 	bne	r2,zero,81138984 <OSSemDel+0x190>
811388e4:	00004506 	br	811389fc <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
811388e8:	e0bff503 	ldbu	r2,-44(fp)
811388ec:	1000161e 	bne	r2,zero,81138948 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811388f0:	e0bffd17 	ldw	r2,-12(fp)
811388f4:	00c00fc4 	movi	r3,63
811388f8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
811388fc:	e0bffd17 	ldw	r2,-12(fp)
81138900:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81138904:	e0bffd17 	ldw	r2,-12(fp)
81138908:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113890c:	d0e0a517 	ldw	r3,-32108(gp)
81138910:	e0bffd17 	ldw	r2,-12(fp)
81138914:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81138918:	e0bffd17 	ldw	r2,-12(fp)
8113891c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81138920:	e0bffd17 	ldw	r2,-12(fp)
81138924:	d0a0a515 	stw	r2,-32108(gp)
81138928:	e0bff717 	ldw	r2,-36(fp)
8113892c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138930:	e0bff817 	ldw	r2,-32(fp)
81138934:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81138938:	e0bfff17 	ldw	r2,-4(fp)
8113893c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
81138940:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81138944:	00003706 	br	81138a24 <OSSemDel+0x230>
81138948:	e0bff717 	ldw	r2,-36(fp)
8113894c:	e0bff915 	stw	r2,-28(fp)
81138950:	e0bff917 	ldw	r2,-28(fp)
81138954:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81138958:	e0bfff17 	ldw	r2,-4(fp)
8113895c:	00c01244 	movi	r3,73
81138960:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81138964:	e0bffd17 	ldw	r2,-12(fp)
81138968:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113896c:	00002d06 	br	81138a24 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81138970:	000f883a 	mov	r7,zero
81138974:	01800044 	movi	r6,1
81138978:	000b883a 	mov	r5,zero
8113897c:	e13ffd17 	ldw	r4,-12(fp)
81138980:	11330d00 	call	811330d0 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
81138984:	e0bffd17 	ldw	r2,-12(fp)
81138988:	10800283 	ldbu	r2,10(r2)
8113898c:	10803fcc 	andi	r2,r2,255
81138990:	103ff71e 	bne	r2,zero,81138970 <__reset+0xfb118970>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81138994:	e0bffd17 	ldw	r2,-12(fp)
81138998:	00c00fc4 	movi	r3,63
8113899c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811389a0:	e0bffd17 	ldw	r2,-12(fp)
811389a4:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811389a8:	e0bffd17 	ldw	r2,-12(fp)
811389ac:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811389b0:	d0e0a517 	ldw	r3,-32108(gp)
811389b4:	e0bffd17 	ldw	r2,-12(fp)
811389b8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
811389bc:	e0bffd17 	ldw	r2,-12(fp)
811389c0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
811389c4:	e0bffd17 	ldw	r2,-12(fp)
811389c8:	d0a0a515 	stw	r2,-32108(gp)
811389cc:	e0bff717 	ldw	r2,-36(fp)
811389d0:	e0bffa15 	stw	r2,-24(fp)
811389d4:	e0bffa17 	ldw	r2,-24(fp)
811389d8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811389dc:	e0bff503 	ldbu	r2,-44(fp)
811389e0:	10800058 	cmpnei	r2,r2,1
811389e4:	1000011e 	bne	r2,zero,811389ec <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
811389e8:	1133b8c0 	call	81133b8c <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
811389ec:	e0bfff17 	ldw	r2,-4(fp)
811389f0:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
811389f4:	e03ff615 	stw	zero,-40(fp)
             break;
811389f8:	00000a06 	br	81138a24 <OSSemDel+0x230>
811389fc:	e0bff717 	ldw	r2,-36(fp)
81138a00:	e0bffb15 	stw	r2,-20(fp)
81138a04:	e0bffb17 	ldw	r2,-20(fp)
81138a08:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81138a0c:	e0bfff17 	ldw	r2,-4(fp)
81138a10:	00c001c4 	movi	r3,7
81138a14:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81138a18:	e0bffd17 	ldw	r2,-12(fp)
81138a1c:	e0bff615 	stw	r2,-40(fp)
             break;
81138a20:	0001883a 	nop
    }
    return (pevent_return);
81138a24:	e0bff617 	ldw	r2,-40(fp)
}
81138a28:	e037883a 	mov	sp,fp
81138a2c:	dfc00117 	ldw	ra,4(sp)
81138a30:	df000017 	ldw	fp,0(sp)
81138a34:	dec00204 	addi	sp,sp,8
81138a38:	f800283a 	ret

81138a3c <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81138a3c:	defff504 	addi	sp,sp,-44
81138a40:	de00012e 	bgeu	sp,et,81138a48 <OSSemPend+0xc>
81138a44:	003b68fa 	trap	3
81138a48:	dfc00a15 	stw	ra,40(sp)
81138a4c:	df000915 	stw	fp,36(sp)
81138a50:	df000904 	addi	fp,sp,36
81138a54:	e13ffd15 	stw	r4,-12(fp)
81138a58:	2805883a 	mov	r2,r5
81138a5c:	e1bfff15 	stw	r6,-4(fp)
81138a60:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138a64:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81138a68:	e0bfff17 	ldw	r2,-4(fp)
81138a6c:	10007226 	beq	r2,zero,81138c38 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138a70:	e0bffd17 	ldw	r2,-12(fp)
81138a74:	1000041e 	bne	r2,zero,81138a88 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81138a78:	e0bfff17 	ldw	r2,-4(fp)
81138a7c:	00c00104 	movi	r3,4
81138a80:	10c00005 	stb	r3,0(r2)
        return;
81138a84:	00006d06 	br	81138c3c <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81138a88:	e0bffd17 	ldw	r2,-12(fp)
81138a8c:	10800003 	ldbu	r2,0(r2)
81138a90:	10803fcc 	andi	r2,r2,255
81138a94:	108000e0 	cmpeqi	r2,r2,3
81138a98:	1000041e 	bne	r2,zero,81138aac <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81138a9c:	e0bfff17 	ldw	r2,-4(fp)
81138aa0:	00c00044 	movi	r3,1
81138aa4:	10c00005 	stb	r3,0(r2)
        return;
81138aa8:	00006406 	br	81138c3c <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81138aac:	d0a0a603 	ldbu	r2,-32104(gp)
81138ab0:	10803fcc 	andi	r2,r2,255
81138ab4:	10000426 	beq	r2,zero,81138ac8 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
81138ab8:	e0bfff17 	ldw	r2,-4(fp)
81138abc:	00c00084 	movi	r3,2
81138ac0:	10c00005 	stb	r3,0(r2)
        return;
81138ac4:	00005d06 	br	81138c3c <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
81138ac8:	d0a09403 	ldbu	r2,-32176(gp)
81138acc:	10803fcc 	andi	r2,r2,255
81138ad0:	10000426 	beq	r2,zero,81138ae4 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
81138ad4:	e0bfff17 	ldw	r2,-4(fp)
81138ad8:	00c00344 	movi	r3,13
81138adc:	10c00005 	stb	r3,0(r2)
        return;
81138ae0:	00005606 	br	81138c3c <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138ae4:	0005303a 	rdctl	r2,status
81138ae8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138aec:	e0fffc17 	ldw	r3,-16(fp)
81138af0:	00bfff84 	movi	r2,-2
81138af4:	1884703a 	and	r2,r3,r2
81138af8:	1001703a 	wrctl	status,r2
  
  return context;
81138afc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138b00:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81138b04:	e0bffd17 	ldw	r2,-12(fp)
81138b08:	1080020b 	ldhu	r2,8(r2)
81138b0c:	10bfffcc 	andi	r2,r2,65535
81138b10:	10000d26 	beq	r2,zero,81138b48 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81138b14:	e0bffd17 	ldw	r2,-12(fp)
81138b18:	1080020b 	ldhu	r2,8(r2)
81138b1c:	10bfffc4 	addi	r2,r2,-1
81138b20:	1007883a 	mov	r3,r2
81138b24:	e0bffd17 	ldw	r2,-12(fp)
81138b28:	10c0020d 	sth	r3,8(r2)
81138b2c:	e0bff717 	ldw	r2,-36(fp)
81138b30:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138b34:	e0bff817 	ldw	r2,-32(fp)
81138b38:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81138b3c:	e0bfff17 	ldw	r2,-4(fp)
81138b40:	10000005 	stb	zero,0(r2)
        return;
81138b44:	00003d06 	br	81138c3c <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81138b48:	d0a0a717 	ldw	r2,-32100(gp)
81138b4c:	d0e0a717 	ldw	r3,-32100(gp)
81138b50:	18c00c03 	ldbu	r3,48(r3)
81138b54:	18c00054 	ori	r3,r3,1
81138b58:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81138b5c:	d0a0a717 	ldw	r2,-32100(gp)
81138b60:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
81138b64:	d0a0a717 	ldw	r2,-32100(gp)
81138b68:	e0fffe0b 	ldhu	r3,-8(fp)
81138b6c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81138b70:	e13ffd17 	ldw	r4,-12(fp)
81138b74:	11332700 	call	81133270 <OS_EventTaskWait>
81138b78:	e0bff717 	ldw	r2,-36(fp)
81138b7c:	e0bffb15 	stw	r2,-20(fp)
81138b80:	e0bffb17 	ldw	r2,-20(fp)
81138b84:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81138b88:	1133b8c0 	call	81133b8c <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138b8c:	0005303a 	rdctl	r2,status
81138b90:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138b94:	e0fff917 	ldw	r3,-28(fp)
81138b98:	00bfff84 	movi	r2,-2
81138b9c:	1884703a 	and	r2,r3,r2
81138ba0:	1001703a 	wrctl	status,r2
  
  return context;
81138ba4:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81138ba8:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81138bac:	d0a0a717 	ldw	r2,-32100(gp)
81138bb0:	10800c43 	ldbu	r2,49(r2)
81138bb4:	10803fcc 	andi	r2,r2,255
81138bb8:	10000326 	beq	r2,zero,81138bc8 <OSSemPend+0x18c>
81138bbc:	108000a0 	cmpeqi	r2,r2,2
81138bc0:	1000041e 	bne	r2,zero,81138bd4 <OSSemPend+0x198>
81138bc4:	00000706 	br	81138be4 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81138bc8:	e0bfff17 	ldw	r2,-4(fp)
81138bcc:	10000005 	stb	zero,0(r2)
             break;
81138bd0:	00000c06 	br	81138c04 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81138bd4:	e0bfff17 	ldw	r2,-4(fp)
81138bd8:	00c00384 	movi	r3,14
81138bdc:	10c00005 	stb	r3,0(r2)
             break;
81138be0:	00000806 	br	81138c04 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81138be4:	d0a0a717 	ldw	r2,-32100(gp)
81138be8:	e17ffd17 	ldw	r5,-12(fp)
81138bec:	1009883a 	mov	r4,r2
81138bf0:	11334e00 	call	811334e0 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81138bf4:	e0bfff17 	ldw	r2,-4(fp)
81138bf8:	00c00284 	movi	r3,10
81138bfc:	10c00005 	stb	r3,0(r2)
             break;
81138c00:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81138c04:	d0a0a717 	ldw	r2,-32100(gp)
81138c08:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81138c0c:	d0a0a717 	ldw	r2,-32100(gp)
81138c10:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81138c14:	d0a0a717 	ldw	r2,-32100(gp)
81138c18:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81138c1c:	d0a0a717 	ldw	r2,-32100(gp)
81138c20:	10000815 	stw	zero,32(r2)
81138c24:	e0bff717 	ldw	r2,-36(fp)
81138c28:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c2c:	e0bffa17 	ldw	r2,-24(fp)
81138c30:	1001703a 	wrctl	status,r2
81138c34:	00000106 	br	81138c3c <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81138c38:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81138c3c:	e037883a 	mov	sp,fp
81138c40:	dfc00117 	ldw	ra,4(sp)
81138c44:	df000017 	ldw	fp,0(sp)
81138c48:	dec00204 	addi	sp,sp,8
81138c4c:	f800283a 	ret

81138c50 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81138c50:	defff604 	addi	sp,sp,-40
81138c54:	de00012e 	bgeu	sp,et,81138c5c <OSSemPendAbort+0xc>
81138c58:	003b68fa 	trap	3
81138c5c:	dfc00915 	stw	ra,36(sp)
81138c60:	df000815 	stw	fp,32(sp)
81138c64:	df000804 	addi	fp,sp,32
81138c68:	e13ffd15 	stw	r4,-12(fp)
81138c6c:	2805883a 	mov	r2,r5
81138c70:	e1bfff15 	stw	r6,-4(fp)
81138c74:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138c78:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81138c7c:	e0bfff17 	ldw	r2,-4(fp)
81138c80:	1000021e 	bne	r2,zero,81138c8c <OSSemPendAbort+0x3c>
        return (0);
81138c84:	0005883a 	mov	r2,zero
81138c88:	00004906 	br	81138db0 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138c8c:	e0bffd17 	ldw	r2,-12(fp)
81138c90:	1000051e 	bne	r2,zero,81138ca8 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138c94:	e0bfff17 	ldw	r2,-4(fp)
81138c98:	00c00104 	movi	r3,4
81138c9c:	10c00005 	stb	r3,0(r2)
        return (0);
81138ca0:	0005883a 	mov	r2,zero
81138ca4:	00004206 	br	81138db0 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81138ca8:	e0bffd17 	ldw	r2,-12(fp)
81138cac:	10800003 	ldbu	r2,0(r2)
81138cb0:	10803fcc 	andi	r2,r2,255
81138cb4:	108000e0 	cmpeqi	r2,r2,3
81138cb8:	1000051e 	bne	r2,zero,81138cd0 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138cbc:	e0bfff17 	ldw	r2,-4(fp)
81138cc0:	00c00044 	movi	r3,1
81138cc4:	10c00005 	stb	r3,0(r2)
        return (0);
81138cc8:	0005883a 	mov	r2,zero
81138ccc:	00003806 	br	81138db0 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138cd0:	0005303a 	rdctl	r2,status
81138cd4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138cd8:	e0fffc17 	ldw	r3,-16(fp)
81138cdc:	00bfff84 	movi	r2,-2
81138ce0:	1884703a 	and	r2,r3,r2
81138ce4:	1001703a 	wrctl	status,r2
  
  return context;
81138ce8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138cec:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
81138cf0:	e0bffd17 	ldw	r2,-12(fp)
81138cf4:	10800283 	ldbu	r2,10(r2)
81138cf8:	10803fcc 	andi	r2,r2,255
81138cfc:	10002526 	beq	r2,zero,81138d94 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
81138d00:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81138d04:	e0bffe03 	ldbu	r2,-8(fp)
81138d08:	10800060 	cmpeqi	r2,r2,1
81138d0c:	10000e26 	beq	r2,zero,81138d48 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81138d10:	00000806 	br	81138d34 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81138d14:	01c00084 	movi	r7,2
81138d18:	01800044 	movi	r6,1
81138d1c:	000b883a 	mov	r5,zero
81138d20:	e13ffd17 	ldw	r4,-12(fp)
81138d24:	11330d00 	call	811330d0 <OS_EventTaskRdy>
                     nbr_tasks++;
81138d28:	e0bff803 	ldbu	r2,-32(fp)
81138d2c:	10800044 	addi	r2,r2,1
81138d30:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81138d34:	e0bffd17 	ldw	r2,-12(fp)
81138d38:	10800283 	ldbu	r2,10(r2)
81138d3c:	10803fcc 	andi	r2,r2,255
81138d40:	103ff41e 	bne	r2,zero,81138d14 <__reset+0xfb118d14>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81138d44:	00000906 	br	81138d6c <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81138d48:	01c00084 	movi	r7,2
81138d4c:	01800044 	movi	r6,1
81138d50:	000b883a 	mov	r5,zero
81138d54:	e13ffd17 	ldw	r4,-12(fp)
81138d58:	11330d00 	call	811330d0 <OS_EventTaskRdy>
                 nbr_tasks++;
81138d5c:	e0bff803 	ldbu	r2,-32(fp)
81138d60:	10800044 	addi	r2,r2,1
81138d64:	e0bff805 	stb	r2,-32(fp)
                 break;
81138d68:	0001883a 	nop
81138d6c:	e0bff917 	ldw	r2,-28(fp)
81138d70:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d74:	e0bffa17 	ldw	r2,-24(fp)
81138d78:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81138d7c:	1133b8c0 	call	81133b8c <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81138d80:	e0bfff17 	ldw	r2,-4(fp)
81138d84:	00c00384 	movi	r3,14
81138d88:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81138d8c:	e0bff803 	ldbu	r2,-32(fp)
81138d90:	00000706 	br	81138db0 <OSSemPendAbort+0x160>
81138d94:	e0bff917 	ldw	r2,-28(fp)
81138d98:	e0bffb15 	stw	r2,-20(fp)
81138d9c:	e0bffb17 	ldw	r2,-20(fp)
81138da0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138da4:	e0bfff17 	ldw	r2,-4(fp)
81138da8:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
81138dac:	0005883a 	mov	r2,zero
}
81138db0:	e037883a 	mov	sp,fp
81138db4:	dfc00117 	ldw	ra,4(sp)
81138db8:	df000017 	ldw	fp,0(sp)
81138dbc:	dec00204 	addi	sp,sp,8
81138dc0:	f800283a 	ret

81138dc4 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81138dc4:	defff804 	addi	sp,sp,-32
81138dc8:	de00012e 	bgeu	sp,et,81138dd0 <OSSemPost+0xc>
81138dcc:	003b68fa 	trap	3
81138dd0:	dfc00715 	stw	ra,28(sp)
81138dd4:	df000615 	stw	fp,24(sp)
81138dd8:	df000604 	addi	fp,sp,24
81138ddc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81138de0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81138de4:	e0bfff17 	ldw	r2,-4(fp)
81138de8:	1000021e 	bne	r2,zero,81138df4 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
81138dec:	00800104 	movi	r2,4
81138df0:	00003506 	br	81138ec8 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81138df4:	e0bfff17 	ldw	r2,-4(fp)
81138df8:	10800003 	ldbu	r2,0(r2)
81138dfc:	10803fcc 	andi	r2,r2,255
81138e00:	108000e0 	cmpeqi	r2,r2,3
81138e04:	1000021e 	bne	r2,zero,81138e10 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81138e08:	00800044 	movi	r2,1
81138e0c:	00002e06 	br	81138ec8 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e10:	0005303a 	rdctl	r2,status
81138e14:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e18:	e0fffe17 	ldw	r3,-8(fp)
81138e1c:	00bfff84 	movi	r2,-2
81138e20:	1884703a 	and	r2,r3,r2
81138e24:	1001703a 	wrctl	status,r2
  
  return context;
81138e28:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81138e2c:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
81138e30:	e0bfff17 	ldw	r2,-4(fp)
81138e34:	10800283 	ldbu	r2,10(r2)
81138e38:	10803fcc 	andi	r2,r2,255
81138e3c:	10000c26 	beq	r2,zero,81138e70 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
81138e40:	000f883a 	mov	r7,zero
81138e44:	01800044 	movi	r6,1
81138e48:	000b883a 	mov	r5,zero
81138e4c:	e13fff17 	ldw	r4,-4(fp)
81138e50:	11330d00 	call	811330d0 <OS_EventTaskRdy>
81138e54:	e0bffa17 	ldw	r2,-24(fp)
81138e58:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138e5c:	e0bffb17 	ldw	r2,-20(fp)
81138e60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
81138e64:	1133b8c0 	call	81133b8c <OS_Sched>
        return (OS_ERR_NONE);
81138e68:	0005883a 	mov	r2,zero
81138e6c:	00001606 	br	81138ec8 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
81138e70:	e0bfff17 	ldw	r2,-4(fp)
81138e74:	1080020b 	ldhu	r2,8(r2)
81138e78:	10ffffcc 	andi	r3,r2,65535
81138e7c:	00bfffd4 	movui	r2,65535
81138e80:	18800c26 	beq	r3,r2,81138eb4 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
81138e84:	e0bfff17 	ldw	r2,-4(fp)
81138e88:	1080020b 	ldhu	r2,8(r2)
81138e8c:	10800044 	addi	r2,r2,1
81138e90:	1007883a 	mov	r3,r2
81138e94:	e0bfff17 	ldw	r2,-4(fp)
81138e98:	10c0020d 	sth	r3,8(r2)
81138e9c:	e0bffa17 	ldw	r2,-24(fp)
81138ea0:	e0bffc15 	stw	r2,-16(fp)
81138ea4:	e0bffc17 	ldw	r2,-16(fp)
81138ea8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81138eac:	0005883a 	mov	r2,zero
81138eb0:	00000506 	br	81138ec8 <OSSemPost+0x104>
81138eb4:	e0bffa17 	ldw	r2,-24(fp)
81138eb8:	e0bffd15 	stw	r2,-12(fp)
81138ebc:	e0bffd17 	ldw	r2,-12(fp)
81138ec0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81138ec4:	00800c84 	movi	r2,50
}
81138ec8:	e037883a 	mov	sp,fp
81138ecc:	dfc00117 	ldw	ra,4(sp)
81138ed0:	df000017 	ldw	fp,0(sp)
81138ed4:	dec00204 	addi	sp,sp,8
81138ed8:	f800283a 	ret

81138edc <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
81138edc:	defff704 	addi	sp,sp,-36
81138ee0:	de00012e 	bgeu	sp,et,81138ee8 <OSSemQuery+0xc>
81138ee4:	003b68fa 	trap	3
81138ee8:	df000815 	stw	fp,32(sp)
81138eec:	df000804 	addi	fp,sp,32
81138ef0:	e13ffe15 	stw	r4,-8(fp)
81138ef4:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138ef8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138efc:	e0bffe17 	ldw	r2,-8(fp)
81138f00:	1000021e 	bne	r2,zero,81138f0c <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81138f04:	00800104 	movi	r2,4
81138f08:	00003606 	br	81138fe4 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
81138f0c:	e0bfff17 	ldw	r2,-4(fp)
81138f10:	1000021e 	bne	r2,zero,81138f1c <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81138f14:	00800244 	movi	r2,9
81138f18:	00003206 	br	81138fe4 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81138f1c:	e0bffe17 	ldw	r2,-8(fp)
81138f20:	10800003 	ldbu	r2,0(r2)
81138f24:	10803fcc 	andi	r2,r2,255
81138f28:	108000e0 	cmpeqi	r2,r2,3
81138f2c:	1000021e 	bne	r2,zero,81138f38 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81138f30:	00800044 	movi	r2,1
81138f34:	00002b06 	br	81138fe4 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138f38:	0005303a 	rdctl	r2,status
81138f3c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138f40:	e0fffd17 	ldw	r3,-12(fp)
81138f44:	00bfff84 	movi	r2,-2
81138f48:	1884703a 	and	r2,r3,r2
81138f4c:	1001703a 	wrctl	status,r2
  
  return context;
81138f50:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138f54:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81138f58:	e0bffe17 	ldw	r2,-8(fp)
81138f5c:	10c00283 	ldbu	r3,10(r2)
81138f60:	e0bfff17 	ldw	r2,-4(fp)
81138f64:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81138f68:	e0bffe17 	ldw	r2,-8(fp)
81138f6c:	108002c4 	addi	r2,r2,11
81138f70:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81138f74:	e0bfff17 	ldw	r2,-4(fp)
81138f78:	10800084 	addi	r2,r2,2
81138f7c:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138f80:	e03ffa05 	stb	zero,-24(fp)
81138f84:	00000b06 	br	81138fb4 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81138f88:	e0bff917 	ldw	r2,-28(fp)
81138f8c:	10c00044 	addi	r3,r2,1
81138f90:	e0fff915 	stw	r3,-28(fp)
81138f94:	e0fff817 	ldw	r3,-32(fp)
81138f98:	19000044 	addi	r4,r3,1
81138f9c:	e13ff815 	stw	r4,-32(fp)
81138fa0:	18c00003 	ldbu	r3,0(r3)
81138fa4:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138fa8:	e0bffa03 	ldbu	r2,-24(fp)
81138fac:	10800044 	addi	r2,r2,1
81138fb0:	e0bffa05 	stb	r2,-24(fp)
81138fb4:	e0bffa03 	ldbu	r2,-24(fp)
81138fb8:	108001b0 	cmpltui	r2,r2,6
81138fbc:	103ff21e 	bne	r2,zero,81138f88 <__reset+0xfb118f88>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
81138fc0:	e0bffe17 	ldw	r2,-8(fp)
81138fc4:	10c0020b 	ldhu	r3,8(r2)
81138fc8:	e0bfff17 	ldw	r2,-4(fp)
81138fcc:	10c0000d 	sth	r3,0(r2)
81138fd0:	e0bffb17 	ldw	r2,-20(fp)
81138fd4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138fd8:	e0bffc17 	ldw	r2,-16(fp)
81138fdc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138fe0:	0005883a 	mov	r2,zero
}
81138fe4:	e037883a 	mov	sp,fp
81138fe8:	df000017 	ldw	fp,0(sp)
81138fec:	dec00104 	addi	sp,sp,4
81138ff0:	f800283a 	ret

81138ff4 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81138ff4:	defff904 	addi	sp,sp,-28
81138ff8:	de00012e 	bgeu	sp,et,81139000 <OSSemSet+0xc>
81138ffc:	003b68fa 	trap	3
81139000:	df000615 	stw	fp,24(sp)
81139004:	df000604 	addi	fp,sp,24
81139008:	e13ffd15 	stw	r4,-12(fp)
8113900c:	2805883a 	mov	r2,r5
81139010:	e1bfff15 	stw	r6,-4(fp)
81139014:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139018:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113901c:	e0bfff17 	ldw	r2,-4(fp)
81139020:	10003126 	beq	r2,zero,811390e8 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139024:	e0bffd17 	ldw	r2,-12(fp)
81139028:	1000041e 	bne	r2,zero,8113903c <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113902c:	e0bfff17 	ldw	r2,-4(fp)
81139030:	00c00104 	movi	r3,4
81139034:	10c00005 	stb	r3,0(r2)
        return;
81139038:	00002c06 	br	811390ec <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113903c:	e0bffd17 	ldw	r2,-12(fp)
81139040:	10800003 	ldbu	r2,0(r2)
81139044:	10803fcc 	andi	r2,r2,255
81139048:	108000e0 	cmpeqi	r2,r2,3
8113904c:	1000041e 	bne	r2,zero,81139060 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81139050:	e0bfff17 	ldw	r2,-4(fp)
81139054:	00c00044 	movi	r3,1
81139058:	10c00005 	stb	r3,0(r2)
        return;
8113905c:	00002306 	br	811390ec <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139060:	0005303a 	rdctl	r2,status
81139064:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139068:	e0fffc17 	ldw	r3,-16(fp)
8113906c:	00bfff84 	movi	r2,-2
81139070:	1884703a 	and	r2,r3,r2
81139074:	1001703a 	wrctl	status,r2
  
  return context;
81139078:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113907c:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81139080:	e0bfff17 	ldw	r2,-4(fp)
81139084:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81139088:	e0bffd17 	ldw	r2,-12(fp)
8113908c:	1080020b 	ldhu	r2,8(r2)
81139090:	10bfffcc 	andi	r2,r2,65535
81139094:	10000426 	beq	r2,zero,811390a8 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81139098:	e0bffd17 	ldw	r2,-12(fp)
8113909c:	e0fffe0b 	ldhu	r3,-8(fp)
811390a0:	10c0020d 	sth	r3,8(r2)
811390a4:	00000b06 	br	811390d4 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
811390a8:	e0bffd17 	ldw	r2,-12(fp)
811390ac:	10800283 	ldbu	r2,10(r2)
811390b0:	10803fcc 	andi	r2,r2,255
811390b4:	1000041e 	bne	r2,zero,811390c8 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
811390b8:	e0bffd17 	ldw	r2,-12(fp)
811390bc:	e0fffe0b 	ldhu	r3,-8(fp)
811390c0:	10c0020d 	sth	r3,8(r2)
811390c4:	00000306 	br	811390d4 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
811390c8:	e0bfff17 	ldw	r2,-4(fp)
811390cc:	00c01244 	movi	r3,73
811390d0:	10c00005 	stb	r3,0(r2)
811390d4:	e0bffa17 	ldw	r2,-24(fp)
811390d8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811390dc:	e0bffb17 	ldw	r2,-20(fp)
811390e0:	1001703a 	wrctl	status,r2
811390e4:	00000106 	br	811390ec <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
811390e8:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
811390ec:	e037883a 	mov	sp,fp
811390f0:	df000017 	ldw	fp,0(sp)
811390f4:	dec00104 	addi	sp,sp,4
811390f8:	f800283a 	ret

811390fc <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
811390fc:	defff104 	addi	sp,sp,-60
81139100:	de00012e 	bgeu	sp,et,81139108 <OSTaskChangePrio+0xc>
81139104:	003b68fa 	trap	3
81139108:	dfc00e15 	stw	ra,56(sp)
8113910c:	df000d15 	stw	fp,52(sp)
81139110:	df000d04 	addi	fp,sp,52
81139114:	2007883a 	mov	r3,r4
81139118:	2805883a 	mov	r2,r5
8113911c:	e0fffe05 	stb	r3,-8(fp)
81139120:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
81139124:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81139128:	e0bffe03 	ldbu	r2,-8(fp)
8113912c:	10800a30 	cmpltui	r2,r2,40
81139130:	1000051e 	bne	r2,zero,81139148 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81139134:	e0bffe03 	ldbu	r2,-8(fp)
81139138:	10803fe0 	cmpeqi	r2,r2,255
8113913c:	1000021e 	bne	r2,zero,81139148 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81139140:	00800a84 	movi	r2,42
81139144:	00012606 	br	811395e0 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81139148:	e0bfff03 	ldbu	r2,-4(fp)
8113914c:	10800a30 	cmpltui	r2,r2,40
81139150:	1000021e 	bne	r2,zero,8113915c <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81139154:	00800a84 	movi	r2,42
81139158:	00012106 	br	811395e0 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113915c:	0005303a 	rdctl	r2,status
81139160:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139164:	e0fffd17 	ldw	r3,-12(fp)
81139168:	00bfff84 	movi	r2,-2
8113916c:	1884703a 	and	r2,r3,r2
81139170:	1001703a 	wrctl	status,r2
  
  return context;
81139174:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81139178:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113917c:	e0ffff03 	ldbu	r3,-4(fp)
81139180:	00a045b4 	movhi	r2,33046
81139184:	1094cd04 	addi	r2,r2,21300
81139188:	18c7883a 	add	r3,r3,r3
8113918c:	18c7883a 	add	r3,r3,r3
81139190:	10c5883a 	add	r2,r2,r3
81139194:	10800017 	ldw	r2,0(r2)
81139198:	10000626 	beq	r2,zero,811391b4 <OSTaskChangePrio+0xb8>
8113919c:	e0bff517 	ldw	r2,-44(fp)
811391a0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811391a4:	e0bff617 	ldw	r2,-40(fp)
811391a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
811391ac:	00800a04 	movi	r2,40
811391b0:	00010b06 	br	811395e0 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
811391b4:	e0bffe03 	ldbu	r2,-8(fp)
811391b8:	10803fd8 	cmpnei	r2,r2,255
811391bc:	1000031e 	bne	r2,zero,811391cc <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
811391c0:	d0a0a717 	ldw	r2,-32100(gp)
811391c4:	10800c83 	ldbu	r2,50(r2)
811391c8:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
811391cc:	e0fffe03 	ldbu	r3,-8(fp)
811391d0:	00a045b4 	movhi	r2,33046
811391d4:	1094cd04 	addi	r2,r2,21300
811391d8:	18c7883a 	add	r3,r3,r3
811391dc:	18c7883a 	add	r3,r3,r3
811391e0:	10c5883a 	add	r2,r2,r3
811391e4:	10800017 	ldw	r2,0(r2)
811391e8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
811391ec:	e0bff817 	ldw	r2,-32(fp)
811391f0:	1000061e 	bne	r2,zero,8113920c <OSTaskChangePrio+0x110>
811391f4:	e0bff517 	ldw	r2,-44(fp)
811391f8:	e0bff715 	stw	r2,-36(fp)
811391fc:	e0bff717 	ldw	r2,-36(fp)
81139200:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81139204:	00800a44 	movi	r2,41
81139208:	0000f506 	br	811395e0 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113920c:	e0bff817 	ldw	r2,-32(fp)
81139210:	10800058 	cmpnei	r2,r2,1
81139214:	1000061e 	bne	r2,zero,81139230 <OSTaskChangePrio+0x134>
81139218:	e0bff517 	ldw	r2,-44(fp)
8113921c:	e0bff915 	stw	r2,-28(fp)
81139220:	e0bff917 	ldw	r2,-28(fp)
81139224:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81139228:	008010c4 	movi	r2,67
8113922c:	0000ec06 	br	811395e0 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81139230:	e0bfff03 	ldbu	r2,-4(fp)
81139234:	1004d0fa 	srli	r2,r2,3
81139238:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113923c:	e0bfff03 	ldbu	r2,-4(fp)
81139240:	108001cc 	andi	r2,r2,7
81139244:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81139248:	e0bffb03 	ldbu	r2,-20(fp)
8113924c:	00c00044 	movi	r3,1
81139250:	1884983a 	sll	r2,r3,r2
81139254:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81139258:	e0bffb43 	ldbu	r2,-19(fp)
8113925c:	00c00044 	movi	r3,1
81139260:	1884983a 	sll	r2,r3,r2
81139264:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81139268:	e0fffe03 	ldbu	r3,-8(fp)
8113926c:	00a045b4 	movhi	r2,33046
81139270:	1094cd04 	addi	r2,r2,21300
81139274:	18c7883a 	add	r3,r3,r3
81139278:	18c7883a 	add	r3,r3,r3
8113927c:	10c5883a 	add	r2,r2,r3
81139280:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81139284:	e0ffff03 	ldbu	r3,-4(fp)
81139288:	00a045b4 	movhi	r2,33046
8113928c:	1094cd04 	addi	r2,r2,21300
81139290:	18c7883a 	add	r3,r3,r3
81139294:	18c7883a 	add	r3,r3,r3
81139298:	10c5883a 	add	r2,r2,r3
8113929c:	e0fff817 	ldw	r3,-32(fp)
811392a0:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
811392a4:	e0bff817 	ldw	r2,-32(fp)
811392a8:	10800d03 	ldbu	r2,52(r2)
811392ac:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
811392b0:	e0bff817 	ldw	r2,-32(fp)
811392b4:	10800d83 	ldbu	r2,54(r2)
811392b8:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
811392bc:	e0bff817 	ldw	r2,-32(fp)
811392c0:	10800d43 	ldbu	r2,53(r2)
811392c4:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
811392c8:	e0fffc03 	ldbu	r3,-16(fp)
811392cc:	d0a0a344 	addi	r2,gp,-32115
811392d0:	1885883a 	add	r2,r3,r2
811392d4:	10c00003 	ldbu	r3,0(r2)
811392d8:	e0bffc83 	ldbu	r2,-14(fp)
811392dc:	1884703a 	and	r2,r3,r2
811392e0:	10803fcc 	andi	r2,r2,255
811392e4:	10002826 	beq	r2,zero,81139388 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
811392e8:	e0fffc03 	ldbu	r3,-16(fp)
811392ec:	e13ffc03 	ldbu	r4,-16(fp)
811392f0:	d0a0a344 	addi	r2,gp,-32115
811392f4:	2085883a 	add	r2,r4,r2
811392f8:	10800003 	ldbu	r2,0(r2)
811392fc:	1009883a 	mov	r4,r2
81139300:	e0bffc83 	ldbu	r2,-14(fp)
81139304:	0084303a 	nor	r2,zero,r2
81139308:	2084703a 	and	r2,r4,r2
8113930c:	1009883a 	mov	r4,r2
81139310:	d0a0a344 	addi	r2,gp,-32115
81139314:	1885883a 	add	r2,r3,r2
81139318:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113931c:	e0fffc03 	ldbu	r3,-16(fp)
81139320:	d0a0a344 	addi	r2,gp,-32115
81139324:	1885883a 	add	r2,r3,r2
81139328:	10800003 	ldbu	r2,0(r2)
8113932c:	10803fcc 	andi	r2,r2,255
81139330:	1000061e 	bne	r2,zero,8113934c <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81139334:	e0bffc43 	ldbu	r2,-15(fp)
81139338:	0084303a 	nor	r2,zero,r2
8113933c:	1007883a 	mov	r3,r2
81139340:	d0a0a303 	ldbu	r2,-32116(gp)
81139344:	1884703a 	and	r2,r3,r2
81139348:	d0a0a305 	stb	r2,-32116(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113934c:	d0e0a303 	ldbu	r3,-32116(gp)
81139350:	e0bffb83 	ldbu	r2,-18(fp)
81139354:	1884b03a 	or	r2,r3,r2
81139358:	d0a0a305 	stb	r2,-32116(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113935c:	e0fffb03 	ldbu	r3,-20(fp)
81139360:	e13ffb03 	ldbu	r4,-20(fp)
81139364:	d0a0a344 	addi	r2,gp,-32115
81139368:	2085883a 	add	r2,r4,r2
8113936c:	11000003 	ldbu	r4,0(r2)
81139370:	e0bffbc3 	ldbu	r2,-17(fp)
81139374:	2084b03a 	or	r2,r4,r2
81139378:	1009883a 	mov	r4,r2
8113937c:	d0a0a344 	addi	r2,gp,-32115
81139380:	1885883a 	add	r2,r3,r2
81139384:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81139388:	e0bff817 	ldw	r2,-32(fp)
8113938c:	10800717 	ldw	r2,28(r2)
81139390:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
81139394:	e0bff317 	ldw	r2,-52(fp)
81139398:	10003326 	beq	r2,zero,81139468 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113939c:	e0bffc03 	ldbu	r2,-16(fp)
811393a0:	e0fffc03 	ldbu	r3,-16(fp)
811393a4:	e13ff317 	ldw	r4,-52(fp)
811393a8:	20c7883a 	add	r3,r4,r3
811393ac:	18c002c4 	addi	r3,r3,11
811393b0:	18c00003 	ldbu	r3,0(r3)
811393b4:	1809883a 	mov	r4,r3
811393b8:	e0fffc83 	ldbu	r3,-14(fp)
811393bc:	00c6303a 	nor	r3,zero,r3
811393c0:	20c6703a 	and	r3,r4,r3
811393c4:	1809883a 	mov	r4,r3
811393c8:	e0fff317 	ldw	r3,-52(fp)
811393cc:	1885883a 	add	r2,r3,r2
811393d0:	108002c4 	addi	r2,r2,11
811393d4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
811393d8:	e0bffc03 	ldbu	r2,-16(fp)
811393dc:	e0fff317 	ldw	r3,-52(fp)
811393e0:	1885883a 	add	r2,r3,r2
811393e4:	108002c4 	addi	r2,r2,11
811393e8:	10800003 	ldbu	r2,0(r2)
811393ec:	10803fcc 	andi	r2,r2,255
811393f0:	1000091e 	bne	r2,zero,81139418 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
811393f4:	e0bff317 	ldw	r2,-52(fp)
811393f8:	10800283 	ldbu	r2,10(r2)
811393fc:	1007883a 	mov	r3,r2
81139400:	e0bffc43 	ldbu	r2,-15(fp)
81139404:	0084303a 	nor	r2,zero,r2
81139408:	1884703a 	and	r2,r3,r2
8113940c:	1007883a 	mov	r3,r2
81139410:	e0bff317 	ldw	r2,-52(fp)
81139414:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
81139418:	e0bff317 	ldw	r2,-52(fp)
8113941c:	10c00283 	ldbu	r3,10(r2)
81139420:	e0bffb83 	ldbu	r2,-18(fp)
81139424:	1884b03a 	or	r2,r3,r2
81139428:	1007883a 	mov	r3,r2
8113942c:	e0bff317 	ldw	r2,-52(fp)
81139430:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81139434:	e0bffb03 	ldbu	r2,-20(fp)
81139438:	e0fffb03 	ldbu	r3,-20(fp)
8113943c:	e13ff317 	ldw	r4,-52(fp)
81139440:	20c7883a 	add	r3,r4,r3
81139444:	18c002c4 	addi	r3,r3,11
81139448:	19000003 	ldbu	r4,0(r3)
8113944c:	e0fffbc3 	ldbu	r3,-17(fp)
81139450:	20c6b03a 	or	r3,r4,r3
81139454:	1809883a 	mov	r4,r3
81139458:	e0fff317 	ldw	r3,-52(fp)
8113945c:	1885883a 	add	r2,r3,r2
81139460:	108002c4 	addi	r2,r2,11
81139464:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81139468:	e0bff817 	ldw	r2,-32(fp)
8113946c:	10800817 	ldw	r2,32(r2)
81139470:	10004226 	beq	r2,zero,8113957c <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81139474:	e0bff817 	ldw	r2,-32(fp)
81139478:	10800817 	ldw	r2,32(r2)
8113947c:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
81139480:	e0bff417 	ldw	r2,-48(fp)
81139484:	10800017 	ldw	r2,0(r2)
81139488:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113948c:	00003906 	br	81139574 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
81139490:	e0bffc03 	ldbu	r2,-16(fp)
81139494:	e0fffc03 	ldbu	r3,-16(fp)
81139498:	e13ff317 	ldw	r4,-52(fp)
8113949c:	20c7883a 	add	r3,r4,r3
811394a0:	18c002c4 	addi	r3,r3,11
811394a4:	18c00003 	ldbu	r3,0(r3)
811394a8:	1809883a 	mov	r4,r3
811394ac:	e0fffc83 	ldbu	r3,-14(fp)
811394b0:	00c6303a 	nor	r3,zero,r3
811394b4:	20c6703a 	and	r3,r4,r3
811394b8:	1809883a 	mov	r4,r3
811394bc:	e0fff317 	ldw	r3,-52(fp)
811394c0:	1885883a 	add	r2,r3,r2
811394c4:	108002c4 	addi	r2,r2,11
811394c8:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
811394cc:	e0bffc03 	ldbu	r2,-16(fp)
811394d0:	e0fff317 	ldw	r3,-52(fp)
811394d4:	1885883a 	add	r2,r3,r2
811394d8:	108002c4 	addi	r2,r2,11
811394dc:	10800003 	ldbu	r2,0(r2)
811394e0:	10803fcc 	andi	r2,r2,255
811394e4:	1000091e 	bne	r2,zero,8113950c <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
811394e8:	e0bff317 	ldw	r2,-52(fp)
811394ec:	10800283 	ldbu	r2,10(r2)
811394f0:	1007883a 	mov	r3,r2
811394f4:	e0bffc43 	ldbu	r2,-15(fp)
811394f8:	0084303a 	nor	r2,zero,r2
811394fc:	1884703a 	and	r2,r3,r2
81139500:	1007883a 	mov	r3,r2
81139504:	e0bff317 	ldw	r2,-52(fp)
81139508:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113950c:	e0bff317 	ldw	r2,-52(fp)
81139510:	10c00283 	ldbu	r3,10(r2)
81139514:	e0bffb83 	ldbu	r2,-18(fp)
81139518:	1884b03a 	or	r2,r3,r2
8113951c:	1007883a 	mov	r3,r2
81139520:	e0bff317 	ldw	r2,-52(fp)
81139524:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
81139528:	e0bffb03 	ldbu	r2,-20(fp)
8113952c:	e0fffb03 	ldbu	r3,-20(fp)
81139530:	e13ff317 	ldw	r4,-52(fp)
81139534:	20c7883a 	add	r3,r4,r3
81139538:	18c002c4 	addi	r3,r3,11
8113953c:	19000003 	ldbu	r4,0(r3)
81139540:	e0fffbc3 	ldbu	r3,-17(fp)
81139544:	20c6b03a 	or	r3,r4,r3
81139548:	1809883a 	mov	r4,r3
8113954c:	e0fff317 	ldw	r3,-52(fp)
81139550:	1885883a 	add	r2,r3,r2
81139554:	108002c4 	addi	r2,r2,11
81139558:	11000005 	stb	r4,0(r2)
            pevents++;
8113955c:	e0bff417 	ldw	r2,-48(fp)
81139560:	10800104 	addi	r2,r2,4
81139564:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
81139568:	e0bff417 	ldw	r2,-48(fp)
8113956c:	10800017 	ldw	r2,0(r2)
81139570:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
81139574:	e0bff317 	ldw	r2,-52(fp)
81139578:	103fc51e 	bne	r2,zero,81139490 <__reset+0xfb119490>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113957c:	e0bff817 	ldw	r2,-32(fp)
81139580:	e0ffff03 	ldbu	r3,-4(fp)
81139584:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
81139588:	e0bff817 	ldw	r2,-32(fp)
8113958c:	e0fffb03 	ldbu	r3,-20(fp)
81139590:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
81139594:	e0bff817 	ldw	r2,-32(fp)
81139598:	e0fffb43 	ldbu	r3,-19(fp)
8113959c:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
811395a0:	e0bff817 	ldw	r2,-32(fp)
811395a4:	e0fffb83 	ldbu	r3,-18(fp)
811395a8:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
811395ac:	e0bff817 	ldw	r2,-32(fp)
811395b0:	e0fffbc3 	ldbu	r3,-17(fp)
811395b4:	10c00d45 	stb	r3,53(r2)
811395b8:	e0bff517 	ldw	r2,-44(fp)
811395bc:	e0bffa15 	stw	r2,-24(fp)
811395c0:	e0bffa17 	ldw	r2,-24(fp)
811395c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811395c8:	d0a09603 	ldbu	r2,-32168(gp)
811395cc:	10803fcc 	andi	r2,r2,255
811395d0:	10800058 	cmpnei	r2,r2,1
811395d4:	1000011e 	bne	r2,zero,811395dc <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
811395d8:	1133b8c0 	call	81133b8c <OS_Sched>
    }
    return (OS_ERR_NONE);
811395dc:	0005883a 	mov	r2,zero
}
811395e0:	e037883a 	mov	sp,fp
811395e4:	dfc00117 	ldw	ra,4(sp)
811395e8:	df000017 	ldw	fp,0(sp)
811395ec:	dec00204 	addi	sp,sp,8
811395f0:	f800283a 	ret

811395f4 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
811395f4:	deffec04 	addi	sp,sp,-80
811395f8:	de00012e 	bgeu	sp,et,81139600 <OSTaskCreateExt+0xc>
811395fc:	003b68fa 	trap	3
81139600:	dfc01315 	stw	ra,76(sp)
81139604:	df001215 	stw	fp,72(sp)
81139608:	df001204 	addi	fp,sp,72
8113960c:	e13ffa15 	stw	r4,-24(fp)
81139610:	e17ffb15 	stw	r5,-20(fp)
81139614:	e1bffc15 	stw	r6,-16(fp)
81139618:	3809883a 	mov	r4,r7
8113961c:	e0c00217 	ldw	r3,8(fp)
81139620:	e0800617 	ldw	r2,24(fp)
81139624:	e13ffd05 	stb	r4,-12(fp)
81139628:	e0fffe0d 	sth	r3,-8(fp)
8113962c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81139630:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81139634:	e0bffd03 	ldbu	r2,-12(fp)
81139638:	10800a70 	cmpltui	r2,r2,41
8113963c:	1000021e 	bne	r2,zero,81139648 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81139640:	00800a84 	movi	r2,42
81139644:	00006106 	br	811397cc <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139648:	0005303a 	rdctl	r2,status
8113964c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139650:	e0fff917 	ldw	r3,-28(fp)
81139654:	00bfff84 	movi	r2,-2
81139658:	1884703a 	and	r2,r3,r2
8113965c:	1001703a 	wrctl	status,r2
  
  return context;
81139660:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81139664:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81139668:	d0a0a603 	ldbu	r2,-32104(gp)
8113966c:	10803fcc 	andi	r2,r2,255
81139670:	10000626 	beq	r2,zero,8113968c <OSTaskCreateExt+0x98>
81139674:	e0bff117 	ldw	r2,-60(fp)
81139678:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113967c:	e0bff217 	ldw	r2,-56(fp)
81139680:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81139684:	00800f04 	movi	r2,60
81139688:	00005006 	br	811397cc <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113968c:	e0fffd03 	ldbu	r3,-12(fp)
81139690:	00a045b4 	movhi	r2,33046
81139694:	1094cd04 	addi	r2,r2,21300
81139698:	18c7883a 	add	r3,r3,r3
8113969c:	18c7883a 	add	r3,r3,r3
811396a0:	10c5883a 	add	r2,r2,r3
811396a4:	10800017 	ldw	r2,0(r2)
811396a8:	1000431e 	bne	r2,zero,811397b8 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
811396ac:	e0fffd03 	ldbu	r3,-12(fp)
811396b0:	00a045b4 	movhi	r2,33046
811396b4:	1094cd04 	addi	r2,r2,21300
811396b8:	18c7883a 	add	r3,r3,r3
811396bc:	18c7883a 	add	r3,r3,r3
811396c0:	10c5883a 	add	r2,r2,r3
811396c4:	00c00044 	movi	r3,1
811396c8:	10c00015 	stw	r3,0(r2)
811396cc:	e0bff117 	ldw	r2,-60(fp)
811396d0:	e0bff315 	stw	r2,-52(fp)
811396d4:	e0bff317 	ldw	r2,-52(fp)
811396d8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
811396dc:	e0bfff0b 	ldhu	r2,-4(fp)
811396e0:	100d883a 	mov	r6,r2
811396e4:	e1400417 	ldw	r5,16(fp)
811396e8:	e1000317 	ldw	r4,12(fp)
811396ec:	113a69c0 	call	8113a69c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
811396f0:	e0bfff0b 	ldhu	r2,-4(fp)
811396f4:	100f883a 	mov	r7,r2
811396f8:	e1bffc17 	ldw	r6,-16(fp)
811396fc:	e17ffb17 	ldw	r5,-20(fp)
81139700:	e13ffa17 	ldw	r4,-24(fp)
81139704:	1144ae80 	call	81144ae8 <OSTaskStkInit>
81139708:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113970c:	e0fffd03 	ldbu	r3,-12(fp)
81139710:	e13ffe0b 	ldhu	r4,-8(fp)
81139714:	e0bfff0b 	ldhu	r2,-4(fp)
81139718:	d8800215 	stw	r2,8(sp)
8113971c:	e0800517 	ldw	r2,20(fp)
81139720:	d8800115 	stw	r2,4(sp)
81139724:	e0800417 	ldw	r2,16(fp)
81139728:	d8800015 	stw	r2,0(sp)
8113972c:	200f883a 	mov	r7,r4
81139730:	e1800317 	ldw	r6,12(fp)
81139734:	e17ff517 	ldw	r5,-44(fp)
81139738:	1809883a 	mov	r4,r3
8113973c:	1133fd40 	call	81133fd4 <OS_TCBInit>
81139740:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81139744:	e0bff603 	ldbu	r2,-40(fp)
81139748:	1000061e 	bne	r2,zero,81139764 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113974c:	d0a09603 	ldbu	r2,-32168(gp)
81139750:	10803fcc 	andi	r2,r2,255
81139754:	10800058 	cmpnei	r2,r2,1
81139758:	1000151e 	bne	r2,zero,811397b0 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113975c:	1133b8c0 	call	81133b8c <OS_Sched>
81139760:	00001306 	br	811397b0 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139764:	0005303a 	rdctl	r2,status
81139768:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113976c:	e0fff817 	ldw	r3,-32(fp)
81139770:	00bfff84 	movi	r2,-2
81139774:	1884703a 	and	r2,r3,r2
81139778:	1001703a 	wrctl	status,r2
  
  return context;
8113977c:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81139780:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81139784:	e0fffd03 	ldbu	r3,-12(fp)
81139788:	00a045b4 	movhi	r2,33046
8113978c:	1094cd04 	addi	r2,r2,21300
81139790:	18c7883a 	add	r3,r3,r3
81139794:	18c7883a 	add	r3,r3,r3
81139798:	10c5883a 	add	r2,r2,r3
8113979c:	10000015 	stw	zero,0(r2)
811397a0:	e0bff117 	ldw	r2,-60(fp)
811397a4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811397a8:	e0bff417 	ldw	r2,-48(fp)
811397ac:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
811397b0:	e0bff603 	ldbu	r2,-40(fp)
811397b4:	00000506 	br	811397cc <OSTaskCreateExt+0x1d8>
811397b8:	e0bff117 	ldw	r2,-60(fp)
811397bc:	e0bff715 	stw	r2,-36(fp)
811397c0:	e0bff717 	ldw	r2,-36(fp)
811397c4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811397c8:	00800a04 	movi	r2,40
}
811397cc:	e037883a 	mov	sp,fp
811397d0:	dfc00117 	ldw	ra,4(sp)
811397d4:	df000017 	ldw	fp,0(sp)
811397d8:	dec00204 	addi	sp,sp,8
811397dc:	f800283a 	ret

811397e0 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
811397e0:	defff404 	addi	sp,sp,-48
811397e4:	de00012e 	bgeu	sp,et,811397ec <OSTaskDel+0xc>
811397e8:	003b68fa 	trap	3
811397ec:	dfc00b15 	stw	ra,44(sp)
811397f0:	df000a15 	stw	fp,40(sp)
811397f4:	df000a04 	addi	fp,sp,40
811397f8:	2005883a 	mov	r2,r4
811397fc:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
81139800:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
81139804:	d0a0a603 	ldbu	r2,-32104(gp)
81139808:	10803fcc 	andi	r2,r2,255
8113980c:	10000226 	beq	r2,zero,81139818 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81139810:	00801004 	movi	r2,64
81139814:	0000c006 	br	81139b18 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
81139818:	e0bfff03 	ldbu	r2,-4(fp)
8113981c:	10800a18 	cmpnei	r2,r2,40
81139820:	1000021e 	bne	r2,zero,8113982c <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81139824:	00800f84 	movi	r2,62
81139828:	0000bb06 	br	81139b18 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113982c:	e0bfff03 	ldbu	r2,-4(fp)
81139830:	10800a30 	cmpltui	r2,r2,40
81139834:	1000051e 	bne	r2,zero,8113984c <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81139838:	e0bfff03 	ldbu	r2,-4(fp)
8113983c:	10803fe0 	cmpeqi	r2,r2,255
81139840:	1000021e 	bne	r2,zero,8113984c <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81139844:	00800a84 	movi	r2,42
81139848:	0000b306 	br	81139b18 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113984c:	0005303a 	rdctl	r2,status
81139850:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139854:	e0fffe17 	ldw	r3,-8(fp)
81139858:	00bfff84 	movi	r2,-2
8113985c:	1884703a 	and	r2,r3,r2
81139860:	1001703a 	wrctl	status,r2
  
  return context;
81139864:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81139868:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113986c:	e0bfff03 	ldbu	r2,-4(fp)
81139870:	10803fd8 	cmpnei	r2,r2,255
81139874:	1000031e 	bne	r2,zero,81139884 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81139878:	d0a0a717 	ldw	r2,-32100(gp)
8113987c:	10800c83 	ldbu	r2,50(r2)
81139880:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81139884:	e0ffff03 	ldbu	r3,-4(fp)
81139888:	00a045b4 	movhi	r2,33046
8113988c:	1094cd04 	addi	r2,r2,21300
81139890:	18c7883a 	add	r3,r3,r3
81139894:	18c7883a 	add	r3,r3,r3
81139898:	10c5883a 	add	r2,r2,r3
8113989c:	10800017 	ldw	r2,0(r2)
811398a0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
811398a4:	e0bff817 	ldw	r2,-32(fp)
811398a8:	1000061e 	bne	r2,zero,811398c4 <OSTaskDel+0xe4>
811398ac:	e0bff617 	ldw	r2,-40(fp)
811398b0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811398b4:	e0bff717 	ldw	r2,-36(fp)
811398b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811398bc:	008010c4 	movi	r2,67
811398c0:	00009506 	br	81139b18 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
811398c4:	e0bff817 	ldw	r2,-32(fp)
811398c8:	10800058 	cmpnei	r2,r2,1
811398cc:	1000061e 	bne	r2,zero,811398e8 <OSTaskDel+0x108>
811398d0:	e0bff617 	ldw	r2,-40(fp)
811398d4:	e0bff915 	stw	r2,-28(fp)
811398d8:	e0bff917 	ldw	r2,-28(fp)
811398dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
811398e0:	00800f44 	movi	r2,61
811398e4:	00008c06 	br	81139b18 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
811398e8:	e0bff817 	ldw	r2,-32(fp)
811398ec:	10800d03 	ldbu	r2,52(r2)
811398f0:	10c03fcc 	andi	r3,r2,255
811398f4:	e0bff817 	ldw	r2,-32(fp)
811398f8:	10800d03 	ldbu	r2,52(r2)
811398fc:	11003fcc 	andi	r4,r2,255
81139900:	d0a0a344 	addi	r2,gp,-32115
81139904:	2085883a 	add	r2,r4,r2
81139908:	10800003 	ldbu	r2,0(r2)
8113990c:	1009883a 	mov	r4,r2
81139910:	e0bff817 	ldw	r2,-32(fp)
81139914:	10800d43 	ldbu	r2,53(r2)
81139918:	0084303a 	nor	r2,zero,r2
8113991c:	2084703a 	and	r2,r4,r2
81139920:	1009883a 	mov	r4,r2
81139924:	d0a0a344 	addi	r2,gp,-32115
81139928:	1885883a 	add	r2,r3,r2
8113992c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81139930:	e0bff817 	ldw	r2,-32(fp)
81139934:	10800d03 	ldbu	r2,52(r2)
81139938:	10c03fcc 	andi	r3,r2,255
8113993c:	d0a0a344 	addi	r2,gp,-32115
81139940:	1885883a 	add	r2,r3,r2
81139944:	10800003 	ldbu	r2,0(r2)
81139948:	10803fcc 	andi	r2,r2,255
8113994c:	1000071e 	bne	r2,zero,8113996c <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81139950:	e0bff817 	ldw	r2,-32(fp)
81139954:	10800d83 	ldbu	r2,54(r2)
81139958:	0084303a 	nor	r2,zero,r2
8113995c:	1007883a 	mov	r3,r2
81139960:	d0a0a303 	ldbu	r2,-32116(gp)
81139964:	1884703a 	and	r2,r3,r2
81139968:	d0a0a305 	stb	r2,-32116(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113996c:	e0bff817 	ldw	r2,-32(fp)
81139970:	10800717 	ldw	r2,28(r2)
81139974:	10000526 	beq	r2,zero,8113998c <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81139978:	e0bff817 	ldw	r2,-32(fp)
8113997c:	10800717 	ldw	r2,28(r2)
81139980:	100b883a 	mov	r5,r2
81139984:	e13ff817 	ldw	r4,-32(fp)
81139988:	11334e00 	call	811334e0 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113998c:	e0bff817 	ldw	r2,-32(fp)
81139990:	10800817 	ldw	r2,32(r2)
81139994:	10000526 	beq	r2,zero,811399ac <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81139998:	e0bff817 	ldw	r2,-32(fp)
8113999c:	10800817 	ldw	r2,32(r2)
811399a0:	100b883a 	mov	r5,r2
811399a4:	e13ff817 	ldw	r4,-32(fp)
811399a8:	11335a00 	call	811335a0 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
811399ac:	e0bff817 	ldw	r2,-32(fp)
811399b0:	10800a17 	ldw	r2,40(r2)
811399b4:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
811399b8:	e0bffb17 	ldw	r2,-20(fp)
811399bc:	10000226 	beq	r2,zero,811399c8 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
811399c0:	e13ffb17 	ldw	r4,-20(fp)
811399c4:	1135b780 	call	81135b78 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
811399c8:	e0bff817 	ldw	r2,-32(fp)
811399cc:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
811399d0:	e0bff817 	ldw	r2,-32(fp)
811399d4:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811399d8:	e0bff817 	ldw	r2,-32(fp)
811399dc:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
811399e0:	d0a09403 	ldbu	r2,-32176(gp)
811399e4:	10803fcc 	andi	r2,r2,255
811399e8:	10803fe0 	cmpeqi	r2,r2,255
811399ec:	1000031e 	bne	r2,zero,811399fc <OSTaskDel+0x21c>
        OSLockNesting++;
811399f0:	d0a09403 	ldbu	r2,-32176(gp)
811399f4:	10800044 	addi	r2,r2,1
811399f8:	d0a09405 	stb	r2,-32176(gp)
811399fc:	e0bff617 	ldw	r2,-40(fp)
81139a00:	e0bffd15 	stw	r2,-12(fp)
81139a04:	e0bffd17 	ldw	r2,-12(fp)
81139a08:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
81139a0c:	11330a80 	call	811330a8 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139a10:	0005303a 	rdctl	r2,status
81139a14:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139a18:	e0fffa17 	ldw	r3,-24(fp)
81139a1c:	00bfff84 	movi	r2,-2
81139a20:	1884703a 	and	r2,r3,r2
81139a24:	1001703a 	wrctl	status,r2
  
  return context;
81139a28:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
81139a2c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81139a30:	d0a09403 	ldbu	r2,-32176(gp)
81139a34:	10803fcc 	andi	r2,r2,255
81139a38:	10000326 	beq	r2,zero,81139a48 <OSTaskDel+0x268>
        OSLockNesting--;
81139a3c:	d0a09403 	ldbu	r2,-32176(gp)
81139a40:	10bfffc4 	addi	r2,r2,-1
81139a44:	d0a09405 	stb	r2,-32176(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81139a48:	e13ff817 	ldw	r4,-32(fp)
81139a4c:	1144c780 	call	81144c78 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81139a50:	d0a09f43 	ldbu	r2,-32131(gp)
81139a54:	10bfffc4 	addi	r2,r2,-1
81139a58:	d0a09f45 	stb	r2,-32131(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
81139a5c:	e0ffff03 	ldbu	r3,-4(fp)
81139a60:	00a045b4 	movhi	r2,33046
81139a64:	1094cd04 	addi	r2,r2,21300
81139a68:	18c7883a 	add	r3,r3,r3
81139a6c:	18c7883a 	add	r3,r3,r3
81139a70:	10c5883a 	add	r2,r2,r3
81139a74:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81139a78:	e0bff817 	ldw	r2,-32(fp)
81139a7c:	10800617 	ldw	r2,24(r2)
81139a80:	1000071e 	bne	r2,zero,81139aa0 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81139a84:	e0bff817 	ldw	r2,-32(fp)
81139a88:	10800517 	ldw	r2,20(r2)
81139a8c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81139a90:	e0bff817 	ldw	r2,-32(fp)
81139a94:	10800517 	ldw	r2,20(r2)
81139a98:	d0a09915 	stw	r2,-32156(gp)
81139a9c:	00000a06 	br	81139ac8 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81139aa0:	e0bff817 	ldw	r2,-32(fp)
81139aa4:	10800617 	ldw	r2,24(r2)
81139aa8:	e0fff817 	ldw	r3,-32(fp)
81139aac:	18c00517 	ldw	r3,20(r3)
81139ab0:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
81139ab4:	e0bff817 	ldw	r2,-32(fp)
81139ab8:	10800517 	ldw	r2,20(r2)
81139abc:	e0fff817 	ldw	r3,-32(fp)
81139ac0:	18c00617 	ldw	r3,24(r3)
81139ac4:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
81139ac8:	d0e09e17 	ldw	r3,-32136(gp)
81139acc:	e0bff817 	ldw	r2,-32(fp)
81139ad0:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
81139ad4:	e0bff817 	ldw	r2,-32(fp)
81139ad8:	d0a09e15 	stw	r2,-32136(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
81139adc:	e0bff817 	ldw	r2,-32(fp)
81139ae0:	00c00fc4 	movi	r3,63
81139ae4:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81139ae8:	e0bff817 	ldw	r2,-32(fp)
81139aec:	10001345 	stb	zero,77(r2)
81139af0:	e0bff617 	ldw	r2,-40(fp)
81139af4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139af8:	e0bffc17 	ldw	r2,-16(fp)
81139afc:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81139b00:	d0a09603 	ldbu	r2,-32168(gp)
81139b04:	10803fcc 	andi	r2,r2,255
81139b08:	10800058 	cmpnei	r2,r2,1
81139b0c:	1000011e 	bne	r2,zero,81139b14 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81139b10:	1133b8c0 	call	81133b8c <OS_Sched>
    }
    return (OS_ERR_NONE);
81139b14:	0005883a 	mov	r2,zero
}
81139b18:	e037883a 	mov	sp,fp
81139b1c:	dfc00117 	ldw	ra,4(sp)
81139b20:	df000017 	ldw	fp,0(sp)
81139b24:	dec00204 	addi	sp,sp,8
81139b28:	f800283a 	ret

81139b2c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
81139b2c:	defff504 	addi	sp,sp,-44
81139b30:	de00012e 	bgeu	sp,et,81139b38 <OSTaskDelReq+0xc>
81139b34:	003b68fa 	trap	3
81139b38:	df000a15 	stw	fp,40(sp)
81139b3c:	df000a04 	addi	fp,sp,40
81139b40:	2005883a 	mov	r2,r4
81139b44:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139b48:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
81139b4c:	e0bfff03 	ldbu	r2,-4(fp)
81139b50:	10800a18 	cmpnei	r2,r2,40
81139b54:	1000021e 	bne	r2,zero,81139b60 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81139b58:	00800f84 	movi	r2,62
81139b5c:	00004506 	br	81139c74 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81139b60:	e0bfff03 	ldbu	r2,-4(fp)
81139b64:	10800a30 	cmpltui	r2,r2,40
81139b68:	1000051e 	bne	r2,zero,81139b80 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
81139b6c:	e0bfff03 	ldbu	r2,-4(fp)
81139b70:	10803fe0 	cmpeqi	r2,r2,255
81139b74:	1000021e 	bne	r2,zero,81139b80 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81139b78:	00800a84 	movi	r2,42
81139b7c:	00003d06 	br	81139c74 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
81139b80:	e0bfff03 	ldbu	r2,-4(fp)
81139b84:	10803fd8 	cmpnei	r2,r2,255
81139b88:	1000111e 	bne	r2,zero,81139bd0 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139b8c:	0005303a 	rdctl	r2,status
81139b90:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139b94:	e0fff917 	ldw	r3,-28(fp)
81139b98:	00bfff84 	movi	r2,-2
81139b9c:	1884703a 	and	r2,r3,r2
81139ba0:	1001703a 	wrctl	status,r2
  
  return context;
81139ba4:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81139ba8:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
81139bac:	d0a0a717 	ldw	r2,-32100(gp)
81139bb0:	10800dc3 	ldbu	r2,55(r2)
81139bb4:	e0bff805 	stb	r2,-32(fp)
81139bb8:	e0bff617 	ldw	r2,-40(fp)
81139bbc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139bc0:	e0bffe17 	ldw	r2,-8(fp)
81139bc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
81139bc8:	e0bff803 	ldbu	r2,-32(fp)
81139bcc:	00002906 	br	81139c74 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139bd0:	0005303a 	rdctl	r2,status
81139bd4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139bd8:	e0fff717 	ldw	r3,-36(fp)
81139bdc:	00bfff84 	movi	r2,-2
81139be0:	1884703a 	and	r2,r3,r2
81139be4:	1001703a 	wrctl	status,r2
  
  return context;
81139be8:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
81139bec:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81139bf0:	e0ffff03 	ldbu	r3,-4(fp)
81139bf4:	00a045b4 	movhi	r2,33046
81139bf8:	1094cd04 	addi	r2,r2,21300
81139bfc:	18c7883a 	add	r3,r3,r3
81139c00:	18c7883a 	add	r3,r3,r3
81139c04:	10c5883a 	add	r2,r2,r3
81139c08:	10800017 	ldw	r2,0(r2)
81139c0c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81139c10:	e0bffb17 	ldw	r2,-20(fp)
81139c14:	1000061e 	bne	r2,zero,81139c30 <OSTaskDelReq+0x104>
81139c18:	e0bff617 	ldw	r2,-40(fp)
81139c1c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139c20:	e0bffa17 	ldw	r2,-24(fp)
81139c24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
81139c28:	008010c4 	movi	r2,67
81139c2c:	00001106 	br	81139c74 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81139c30:	e0bffb17 	ldw	r2,-20(fp)
81139c34:	10800058 	cmpnei	r2,r2,1
81139c38:	1000061e 	bne	r2,zero,81139c54 <OSTaskDelReq+0x128>
81139c3c:	e0bff617 	ldw	r2,-40(fp)
81139c40:	e0bffc15 	stw	r2,-16(fp)
81139c44:	e0bffc17 	ldw	r2,-16(fp)
81139c48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
81139c4c:	00800f44 	movi	r2,61
81139c50:	00000806 	br	81139c74 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81139c54:	e0bffb17 	ldw	r2,-20(fp)
81139c58:	00c00fc4 	movi	r3,63
81139c5c:	10c00dc5 	stb	r3,55(r2)
81139c60:	e0bff617 	ldw	r2,-40(fp)
81139c64:	e0bffd15 	stw	r2,-12(fp)
81139c68:	e0bffd17 	ldw	r2,-12(fp)
81139c6c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139c70:	0005883a 	mov	r2,zero
}
81139c74:	e037883a 	mov	sp,fp
81139c78:	df000017 	ldw	fp,0(sp)
81139c7c:	dec00104 	addi	sp,sp,4
81139c80:	f800283a 	ret

81139c84 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81139c84:	defff404 	addi	sp,sp,-48
81139c88:	de00012e 	bgeu	sp,et,81139c90 <OSTaskNameGet+0xc>
81139c8c:	003b68fa 	trap	3
81139c90:	dfc00b15 	stw	ra,44(sp)
81139c94:	df000a15 	stw	fp,40(sp)
81139c98:	df000a04 	addi	fp,sp,40
81139c9c:	2005883a 	mov	r2,r4
81139ca0:	e17ffe15 	stw	r5,-8(fp)
81139ca4:	e1bfff15 	stw	r6,-4(fp)
81139ca8:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
81139cac:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
81139cb0:	e0bfff17 	ldw	r2,-4(fp)
81139cb4:	1000021e 	bne	r2,zero,81139cc0 <OSTaskNameGet+0x3c>
        return (0);
81139cb8:	0005883a 	mov	r2,zero
81139cbc:	00005406 	br	81139e10 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
81139cc0:	e0bffd03 	ldbu	r2,-12(fp)
81139cc4:	10800a70 	cmpltui	r2,r2,41
81139cc8:	1000081e 	bne	r2,zero,81139cec <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
81139ccc:	e0bffd03 	ldbu	r2,-12(fp)
81139cd0:	10803fe0 	cmpeqi	r2,r2,255
81139cd4:	1000051e 	bne	r2,zero,81139cec <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
81139cd8:	e0bfff17 	ldw	r2,-4(fp)
81139cdc:	00c00a84 	movi	r3,42
81139ce0:	10c00005 	stb	r3,0(r2)
            return (0);
81139ce4:	0005883a 	mov	r2,zero
81139ce8:	00004906 	br	81139e10 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
81139cec:	e0bffe17 	ldw	r2,-8(fp)
81139cf0:	1000051e 	bne	r2,zero,81139d08 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
81139cf4:	e0bfff17 	ldw	r2,-4(fp)
81139cf8:	00c00304 	movi	r3,12
81139cfc:	10c00005 	stb	r3,0(r2)
        return (0);
81139d00:	0005883a 	mov	r2,zero
81139d04:	00004206 	br	81139e10 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
81139d08:	d0a0a603 	ldbu	r2,-32104(gp)
81139d0c:	10803fcc 	andi	r2,r2,255
81139d10:	10000526 	beq	r2,zero,81139d28 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81139d14:	e0bfff17 	ldw	r2,-4(fp)
81139d18:	00c00444 	movi	r3,17
81139d1c:	10c00005 	stb	r3,0(r2)
        return (0);
81139d20:	0005883a 	mov	r2,zero
81139d24:	00003a06 	br	81139e10 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139d28:	0005303a 	rdctl	r2,status
81139d2c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139d30:	e0fffc17 	ldw	r3,-16(fp)
81139d34:	00bfff84 	movi	r2,-2
81139d38:	1884703a 	and	r2,r3,r2
81139d3c:	1001703a 	wrctl	status,r2
  
  return context;
81139d40:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139d44:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81139d48:	e0bffd03 	ldbu	r2,-12(fp)
81139d4c:	10803fd8 	cmpnei	r2,r2,255
81139d50:	1000031e 	bne	r2,zero,81139d60 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81139d54:	d0a0a717 	ldw	r2,-32100(gp)
81139d58:	10800c83 	ldbu	r2,50(r2)
81139d5c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81139d60:	e0fffd03 	ldbu	r3,-12(fp)
81139d64:	00a045b4 	movhi	r2,33046
81139d68:	1094cd04 	addi	r2,r2,21300
81139d6c:	18c7883a 	add	r3,r3,r3
81139d70:	18c7883a 	add	r3,r3,r3
81139d74:	10c5883a 	add	r2,r2,r3
81139d78:	10800017 	ldw	r2,0(r2)
81139d7c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81139d80:	e0bff817 	ldw	r2,-32(fp)
81139d84:	1000091e 	bne	r2,zero,81139dac <OSTaskNameGet+0x128>
81139d88:	e0bff617 	ldw	r2,-40(fp)
81139d8c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d90:	e0bff717 	ldw	r2,-36(fp)
81139d94:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81139d98:	e0bfff17 	ldw	r2,-4(fp)
81139d9c:	00c010c4 	movi	r3,67
81139da0:	10c00005 	stb	r3,0(r2)
        return (0);
81139da4:	0005883a 	mov	r2,zero
81139da8:	00001906 	br	81139e10 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81139dac:	e0bff817 	ldw	r2,-32(fp)
81139db0:	10800058 	cmpnei	r2,r2,1
81139db4:	1000091e 	bne	r2,zero,81139ddc <OSTaskNameGet+0x158>
81139db8:	e0bff617 	ldw	r2,-40(fp)
81139dbc:	e0bff915 	stw	r2,-28(fp)
81139dc0:	e0bff917 	ldw	r2,-28(fp)
81139dc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81139dc8:	e0bfff17 	ldw	r2,-4(fp)
81139dcc:	00c010c4 	movi	r3,67
81139dd0:	10c00005 	stb	r3,0(r2)
        return (0);
81139dd4:	0005883a 	mov	r2,zero
81139dd8:	00000d06 	br	81139e10 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81139ddc:	e0bff817 	ldw	r2,-32(fp)
81139de0:	10801304 	addi	r2,r2,76
81139de4:	100b883a 	mov	r5,r2
81139de8:	e13ffe17 	ldw	r4,-8(fp)
81139dec:	1133ce00 	call	81133ce0 <OS_StrCopy>
81139df0:	e0bffb05 	stb	r2,-20(fp)
81139df4:	e0bff617 	ldw	r2,-40(fp)
81139df8:	e0bffa15 	stw	r2,-24(fp)
81139dfc:	e0bffa17 	ldw	r2,-24(fp)
81139e00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139e04:	e0bfff17 	ldw	r2,-4(fp)
81139e08:	10000005 	stb	zero,0(r2)
    return (len);
81139e0c:	e0bffb03 	ldbu	r2,-20(fp)
}
81139e10:	e037883a 	mov	sp,fp
81139e14:	dfc00117 	ldw	ra,4(sp)
81139e18:	df000017 	ldw	fp,0(sp)
81139e1c:	dec00204 	addi	sp,sp,8
81139e20:	f800283a 	ret

81139e24 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
81139e24:	defff304 	addi	sp,sp,-52
81139e28:	de00012e 	bgeu	sp,et,81139e30 <OSTaskNameSet+0xc>
81139e2c:	003b68fa 	trap	3
81139e30:	dfc00c15 	stw	ra,48(sp)
81139e34:	df000b15 	stw	fp,44(sp)
81139e38:	df000b04 	addi	fp,sp,44
81139e3c:	2005883a 	mov	r2,r4
81139e40:	e17ffe15 	stw	r5,-8(fp)
81139e44:	e1bfff15 	stw	r6,-4(fp)
81139e48:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81139e4c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81139e50:	e0bfff17 	ldw	r2,-4(fp)
81139e54:	10005c26 	beq	r2,zero,81139fc8 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81139e58:	e0bffd03 	ldbu	r2,-12(fp)
81139e5c:	10800a70 	cmpltui	r2,r2,41
81139e60:	1000071e 	bne	r2,zero,81139e80 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81139e64:	e0bffd03 	ldbu	r2,-12(fp)
81139e68:	10803fe0 	cmpeqi	r2,r2,255
81139e6c:	1000041e 	bne	r2,zero,81139e80 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
81139e70:	e0bfff17 	ldw	r2,-4(fp)
81139e74:	00c00a84 	movi	r3,42
81139e78:	10c00005 	stb	r3,0(r2)
            return;
81139e7c:	00005306 	br	81139fcc <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81139e80:	e0bffe17 	ldw	r2,-8(fp)
81139e84:	1000041e 	bne	r2,zero,81139e98 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81139e88:	e0bfff17 	ldw	r2,-4(fp)
81139e8c:	00c00304 	movi	r3,12
81139e90:	10c00005 	stb	r3,0(r2)
        return;
81139e94:	00004d06 	br	81139fcc <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81139e98:	d0a0a603 	ldbu	r2,-32104(gp)
81139e9c:	10803fcc 	andi	r2,r2,255
81139ea0:	10000426 	beq	r2,zero,81139eb4 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81139ea4:	e0bfff17 	ldw	r2,-4(fp)
81139ea8:	00c00484 	movi	r3,18
81139eac:	10c00005 	stb	r3,0(r2)
        return;
81139eb0:	00004606 	br	81139fcc <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139eb4:	0005303a 	rdctl	r2,status
81139eb8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139ebc:	e0fffc17 	ldw	r3,-16(fp)
81139ec0:	00bfff84 	movi	r2,-2
81139ec4:	1884703a 	and	r2,r3,r2
81139ec8:	1001703a 	wrctl	status,r2
  
  return context;
81139ecc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139ed0:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81139ed4:	e0bffd03 	ldbu	r2,-12(fp)
81139ed8:	10803fd8 	cmpnei	r2,r2,255
81139edc:	1000031e 	bne	r2,zero,81139eec <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81139ee0:	d0a0a717 	ldw	r2,-32100(gp)
81139ee4:	10800c83 	ldbu	r2,50(r2)
81139ee8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81139eec:	e0fffd03 	ldbu	r3,-12(fp)
81139ef0:	00a045b4 	movhi	r2,33046
81139ef4:	1094cd04 	addi	r2,r2,21300
81139ef8:	18c7883a 	add	r3,r3,r3
81139efc:	18c7883a 	add	r3,r3,r3
81139f00:	10c5883a 	add	r2,r2,r3
81139f04:	10800017 	ldw	r2,0(r2)
81139f08:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
81139f0c:	e0bff717 	ldw	r2,-36(fp)
81139f10:	1000081e 	bne	r2,zero,81139f34 <OSTaskNameSet+0x110>
81139f14:	e0bff517 	ldw	r2,-44(fp)
81139f18:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f1c:	e0bff617 	ldw	r2,-40(fp)
81139f20:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
81139f24:	e0bfff17 	ldw	r2,-4(fp)
81139f28:	00c010c4 	movi	r3,67
81139f2c:	10c00005 	stb	r3,0(r2)
        return;
81139f30:	00002606 	br	81139fcc <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
81139f34:	e0bff717 	ldw	r2,-36(fp)
81139f38:	10800058 	cmpnei	r2,r2,1
81139f3c:	1000081e 	bne	r2,zero,81139f60 <OSTaskNameSet+0x13c>
81139f40:	e0bff517 	ldw	r2,-44(fp)
81139f44:	e0bff815 	stw	r2,-32(fp)
81139f48:	e0bff817 	ldw	r2,-32(fp)
81139f4c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
81139f50:	e0bfff17 	ldw	r2,-4(fp)
81139f54:	00c010c4 	movi	r3,67
81139f58:	10c00005 	stb	r3,0(r2)
        return;
81139f5c:	00001b06 	br	81139fcc <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
81139f60:	e13ffe17 	ldw	r4,-8(fp)
81139f64:	1133d5c0 	call	81133d5c <OS_StrLen>
81139f68:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
81139f6c:	e0bffa03 	ldbu	r2,-24(fp)
81139f70:	10800830 	cmpltui	r2,r2,32
81139f74:	1000081e 	bne	r2,zero,81139f98 <OSTaskNameSet+0x174>
81139f78:	e0bff517 	ldw	r2,-44(fp)
81139f7c:	e0bff915 	stw	r2,-28(fp)
81139f80:	e0bff917 	ldw	r2,-28(fp)
81139f84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81139f88:	e0bfff17 	ldw	r2,-4(fp)
81139f8c:	00c01044 	movi	r3,65
81139f90:	10c00005 	stb	r3,0(r2)
        return;
81139f94:	00000d06 	br	81139fcc <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81139f98:	e0bff717 	ldw	r2,-36(fp)
81139f9c:	10801304 	addi	r2,r2,76
81139fa0:	e17ffe17 	ldw	r5,-8(fp)
81139fa4:	1009883a 	mov	r4,r2
81139fa8:	1133ce00 	call	81133ce0 <OS_StrCopy>
81139fac:	e0bff517 	ldw	r2,-44(fp)
81139fb0:	e0bffb15 	stw	r2,-20(fp)
81139fb4:	e0bffb17 	ldw	r2,-20(fp)
81139fb8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139fbc:	e0bfff17 	ldw	r2,-4(fp)
81139fc0:	10000005 	stb	zero,0(r2)
81139fc4:	00000106 	br	81139fcc <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81139fc8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81139fcc:	e037883a 	mov	sp,fp
81139fd0:	dfc00117 	ldw	ra,4(sp)
81139fd4:	df000017 	ldw	fp,0(sp)
81139fd8:	dec00204 	addi	sp,sp,8
81139fdc:	f800283a 	ret

81139fe0 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81139fe0:	defff404 	addi	sp,sp,-48
81139fe4:	de00012e 	bgeu	sp,et,81139fec <OSTaskResume+0xc>
81139fe8:	003b68fa 	trap	3
81139fec:	dfc00b15 	stw	ra,44(sp)
81139ff0:	df000a15 	stw	fp,40(sp)
81139ff4:	df000a04 	addi	fp,sp,40
81139ff8:	2005883a 	mov	r2,r4
81139ffc:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113a000:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113a004:	e0bfff03 	ldbu	r2,-4(fp)
8113a008:	10800a30 	cmpltui	r2,r2,40
8113a00c:	1000021e 	bne	r2,zero,8113a018 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113a010:	00800a84 	movi	r2,42
8113a014:	00006406 	br	8113a1a8 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a018:	0005303a 	rdctl	r2,status
8113a01c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a020:	e0fffe17 	ldw	r3,-8(fp)
8113a024:	00bfff84 	movi	r2,-2
8113a028:	1884703a 	and	r2,r3,r2
8113a02c:	1001703a 	wrctl	status,r2
  
  return context;
8113a030:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a034:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113a038:	e0ffff03 	ldbu	r3,-4(fp)
8113a03c:	00a045b4 	movhi	r2,33046
8113a040:	1094cd04 	addi	r2,r2,21300
8113a044:	18c7883a 	add	r3,r3,r3
8113a048:	18c7883a 	add	r3,r3,r3
8113a04c:	10c5883a 	add	r2,r2,r3
8113a050:	10800017 	ldw	r2,0(r2)
8113a054:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113a058:	e0bff817 	ldw	r2,-32(fp)
8113a05c:	1000061e 	bne	r2,zero,8113a078 <OSTaskResume+0x98>
8113a060:	e0bff617 	ldw	r2,-40(fp)
8113a064:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a068:	e0bff717 	ldw	r2,-36(fp)
8113a06c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113a070:	00801184 	movi	r2,70
8113a074:	00004c06 	br	8113a1a8 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113a078:	e0bff817 	ldw	r2,-32(fp)
8113a07c:	10800058 	cmpnei	r2,r2,1
8113a080:	1000061e 	bne	r2,zero,8113a09c <OSTaskResume+0xbc>
8113a084:	e0bff617 	ldw	r2,-40(fp)
8113a088:	e0bff915 	stw	r2,-28(fp)
8113a08c:	e0bff917 	ldw	r2,-28(fp)
8113a090:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a094:	008010c4 	movi	r2,67
8113a098:	00004306 	br	8113a1a8 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113a09c:	e0bff817 	ldw	r2,-32(fp)
8113a0a0:	10800c03 	ldbu	r2,48(r2)
8113a0a4:	10803fcc 	andi	r2,r2,255
8113a0a8:	1080020c 	andi	r2,r2,8
8113a0ac:	10003926 	beq	r2,zero,8113a194 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113a0b0:	e0bff817 	ldw	r2,-32(fp)
8113a0b4:	10c00c03 	ldbu	r3,48(r2)
8113a0b8:	00bffdc4 	movi	r2,-9
8113a0bc:	1884703a 	and	r2,r3,r2
8113a0c0:	1007883a 	mov	r3,r2
8113a0c4:	e0bff817 	ldw	r2,-32(fp)
8113a0c8:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113a0cc:	e0bff817 	ldw	r2,-32(fp)
8113a0d0:	10800c03 	ldbu	r2,48(r2)
8113a0d4:	10803fcc 	andi	r2,r2,255
8113a0d8:	1000281e 	bne	r2,zero,8113a17c <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113a0dc:	e0bff817 	ldw	r2,-32(fp)
8113a0e0:	10800b8b 	ldhu	r2,46(r2)
8113a0e4:	10bfffcc 	andi	r2,r2,65535
8113a0e8:	10001f1e 	bne	r2,zero,8113a168 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113a0ec:	e0bff817 	ldw	r2,-32(fp)
8113a0f0:	10c00d83 	ldbu	r3,54(r2)
8113a0f4:	d0a0a303 	ldbu	r2,-32116(gp)
8113a0f8:	1884b03a 	or	r2,r3,r2
8113a0fc:	d0a0a305 	stb	r2,-32116(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113a100:	e0bff817 	ldw	r2,-32(fp)
8113a104:	10800d03 	ldbu	r2,52(r2)
8113a108:	10c03fcc 	andi	r3,r2,255
8113a10c:	e0bff817 	ldw	r2,-32(fp)
8113a110:	10800d03 	ldbu	r2,52(r2)
8113a114:	11003fcc 	andi	r4,r2,255
8113a118:	d0a0a344 	addi	r2,gp,-32115
8113a11c:	2085883a 	add	r2,r4,r2
8113a120:	11000003 	ldbu	r4,0(r2)
8113a124:	e0bff817 	ldw	r2,-32(fp)
8113a128:	10800d43 	ldbu	r2,53(r2)
8113a12c:	2084b03a 	or	r2,r4,r2
8113a130:	1009883a 	mov	r4,r2
8113a134:	d0a0a344 	addi	r2,gp,-32115
8113a138:	1885883a 	add	r2,r3,r2
8113a13c:	11000005 	stb	r4,0(r2)
8113a140:	e0bff617 	ldw	r2,-40(fp)
8113a144:	e0bffa15 	stw	r2,-24(fp)
8113a148:	e0bffa17 	ldw	r2,-24(fp)
8113a14c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113a150:	d0a09603 	ldbu	r2,-32168(gp)
8113a154:	10803fcc 	andi	r2,r2,255
8113a158:	10800058 	cmpnei	r2,r2,1
8113a15c:	10000b1e 	bne	r2,zero,8113a18c <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113a160:	1133b8c0 	call	81133b8c <OS_Sched>
8113a164:	00000906 	br	8113a18c <OSTaskResume+0x1ac>
8113a168:	e0bff617 	ldw	r2,-40(fp)
8113a16c:	e0bffb15 	stw	r2,-20(fp)
8113a170:	e0bffb17 	ldw	r2,-20(fp)
8113a174:	1001703a 	wrctl	status,r2
8113a178:	00000406 	br	8113a18c <OSTaskResume+0x1ac>
8113a17c:	e0bff617 	ldw	r2,-40(fp)
8113a180:	e0bffc15 	stw	r2,-16(fp)
8113a184:	e0bffc17 	ldw	r2,-16(fp)
8113a188:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113a18c:	0005883a 	mov	r2,zero
8113a190:	00000506 	br	8113a1a8 <OSTaskResume+0x1c8>
8113a194:	e0bff617 	ldw	r2,-40(fp)
8113a198:	e0bffd15 	stw	r2,-12(fp)
8113a19c:	e0bffd17 	ldw	r2,-12(fp)
8113a1a0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113a1a4:	00801104 	movi	r2,68
}
8113a1a8:	e037883a 	mov	sp,fp
8113a1ac:	dfc00117 	ldw	ra,4(sp)
8113a1b0:	df000017 	ldw	fp,0(sp)
8113a1b4:	dec00204 	addi	sp,sp,8
8113a1b8:	f800283a 	ret

8113a1bc <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113a1bc:	defff304 	addi	sp,sp,-52
8113a1c0:	de00012e 	bgeu	sp,et,8113a1c8 <OSTaskStkChk+0xc>
8113a1c4:	003b68fa 	trap	3
8113a1c8:	df000c15 	stw	fp,48(sp)
8113a1cc:	df000c04 	addi	fp,sp,48
8113a1d0:	2005883a 	mov	r2,r4
8113a1d4:	e17fff15 	stw	r5,-4(fp)
8113a1d8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113a1dc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113a1e0:	e0bffe03 	ldbu	r2,-8(fp)
8113a1e4:	10800a70 	cmpltui	r2,r2,41
8113a1e8:	1000051e 	bne	r2,zero,8113a200 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113a1ec:	e0bffe03 	ldbu	r2,-8(fp)
8113a1f0:	10803fe0 	cmpeqi	r2,r2,255
8113a1f4:	1000021e 	bne	r2,zero,8113a200 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113a1f8:	00800a84 	movi	r2,42
8113a1fc:	00005d06 	br	8113a374 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113a200:	e0bfff17 	ldw	r2,-4(fp)
8113a204:	1000021e 	bne	r2,zero,8113a210 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113a208:	00800244 	movi	r2,9
8113a20c:	00005906 	br	8113a374 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113a210:	e0bfff17 	ldw	r2,-4(fp)
8113a214:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113a218:	e0bfff17 	ldw	r2,-4(fp)
8113a21c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a220:	0005303a 	rdctl	r2,status
8113a224:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a228:	e0fffd17 	ldw	r3,-12(fp)
8113a22c:	00bfff84 	movi	r2,-2
8113a230:	1884703a 	and	r2,r3,r2
8113a234:	1001703a 	wrctl	status,r2
  
  return context;
8113a238:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113a23c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113a240:	e0bffe03 	ldbu	r2,-8(fp)
8113a244:	10803fd8 	cmpnei	r2,r2,255
8113a248:	1000031e 	bne	r2,zero,8113a258 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113a24c:	d0a0a717 	ldw	r2,-32100(gp)
8113a250:	10800c83 	ldbu	r2,50(r2)
8113a254:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a258:	e0fffe03 	ldbu	r3,-8(fp)
8113a25c:	00a045b4 	movhi	r2,33046
8113a260:	1094cd04 	addi	r2,r2,21300
8113a264:	18c7883a 	add	r3,r3,r3
8113a268:	18c7883a 	add	r3,r3,r3
8113a26c:	10c5883a 	add	r2,r2,r3
8113a270:	10800017 	ldw	r2,0(r2)
8113a274:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113a278:	e0bff817 	ldw	r2,-32(fp)
8113a27c:	1000061e 	bne	r2,zero,8113a298 <OSTaskStkChk+0xdc>
8113a280:	e0bff617 	ldw	r2,-40(fp)
8113a284:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a288:	e0bff717 	ldw	r2,-36(fp)
8113a28c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a290:	008010c4 	movi	r2,67
8113a294:	00003706 	br	8113a374 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113a298:	e0bff817 	ldw	r2,-32(fp)
8113a29c:	10800058 	cmpnei	r2,r2,1
8113a2a0:	1000061e 	bne	r2,zero,8113a2bc <OSTaskStkChk+0x100>
8113a2a4:	e0bff617 	ldw	r2,-40(fp)
8113a2a8:	e0bff915 	stw	r2,-28(fp)
8113a2ac:	e0bff917 	ldw	r2,-28(fp)
8113a2b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a2b4:	008010c4 	movi	r2,67
8113a2b8:	00002e06 	br	8113a374 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113a2bc:	e0bff817 	ldw	r2,-32(fp)
8113a2c0:	1080040b 	ldhu	r2,16(r2)
8113a2c4:	10bfffcc 	andi	r2,r2,65535
8113a2c8:	1080004c 	andi	r2,r2,1
8113a2cc:	1000061e 	bne	r2,zero,8113a2e8 <OSTaskStkChk+0x12c>
8113a2d0:	e0bff617 	ldw	r2,-40(fp)
8113a2d4:	e0bffa15 	stw	r2,-24(fp)
8113a2d8:	e0bffa17 	ldw	r2,-24(fp)
8113a2dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113a2e0:	00801144 	movi	r2,69
8113a2e4:	00002306 	br	8113a374 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113a2e8:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113a2ec:	e0bff817 	ldw	r2,-32(fp)
8113a2f0:	10800317 	ldw	r2,12(r2)
8113a2f4:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113a2f8:	e0bff817 	ldw	r2,-32(fp)
8113a2fc:	10800217 	ldw	r2,8(r2)
8113a300:	e0bff415 	stw	r2,-48(fp)
8113a304:	e0bff617 	ldw	r2,-40(fp)
8113a308:	e0bffb15 	stw	r2,-20(fp)
8113a30c:	e0bffb17 	ldw	r2,-20(fp)
8113a310:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113a314:	00000306 	br	8113a324 <OSTaskStkChk+0x168>
        nfree++;
8113a318:	e0bff517 	ldw	r2,-44(fp)
8113a31c:	10800044 	addi	r2,r2,1
8113a320:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113a324:	e0bff417 	ldw	r2,-48(fp)
8113a328:	10c00104 	addi	r3,r2,4
8113a32c:	e0fff415 	stw	r3,-48(fp)
8113a330:	10800017 	ldw	r2,0(r2)
8113a334:	103ff826 	beq	r2,zero,8113a318 <__reset+0xfb11a318>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113a338:	e0bff517 	ldw	r2,-44(fp)
8113a33c:	1085883a 	add	r2,r2,r2
8113a340:	1085883a 	add	r2,r2,r2
8113a344:	1007883a 	mov	r3,r2
8113a348:	e0bfff17 	ldw	r2,-4(fp)
8113a34c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113a350:	e0fffc17 	ldw	r3,-16(fp)
8113a354:	e0bff517 	ldw	r2,-44(fp)
8113a358:	1885c83a 	sub	r2,r3,r2
8113a35c:	1085883a 	add	r2,r2,r2
8113a360:	1085883a 	add	r2,r2,r2
8113a364:	1007883a 	mov	r3,r2
8113a368:	e0bfff17 	ldw	r2,-4(fp)
8113a36c:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113a370:	0005883a 	mov	r2,zero
}
8113a374:	e037883a 	mov	sp,fp
8113a378:	df000017 	ldw	fp,0(sp)
8113a37c:	dec00104 	addi	sp,sp,4
8113a380:	f800283a 	ret

8113a384 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113a384:	defff504 	addi	sp,sp,-44
8113a388:	de00012e 	bgeu	sp,et,8113a390 <OSTaskSuspend+0xc>
8113a38c:	003b68fa 	trap	3
8113a390:	dfc00a15 	stw	ra,40(sp)
8113a394:	df000915 	stw	fp,36(sp)
8113a398:	df000904 	addi	fp,sp,36
8113a39c:	2005883a 	mov	r2,r4
8113a3a0:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a3a4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113a3a8:	e0bfff03 	ldbu	r2,-4(fp)
8113a3ac:	10800a18 	cmpnei	r2,r2,40
8113a3b0:	1000021e 	bne	r2,zero,8113a3bc <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113a3b4:	008011c4 	movi	r2,71
8113a3b8:	00006806 	br	8113a55c <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113a3bc:	e0bfff03 	ldbu	r2,-4(fp)
8113a3c0:	10800a30 	cmpltui	r2,r2,40
8113a3c4:	1000051e 	bne	r2,zero,8113a3dc <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113a3c8:	e0bfff03 	ldbu	r2,-4(fp)
8113a3cc:	10803fe0 	cmpeqi	r2,r2,255
8113a3d0:	1000021e 	bne	r2,zero,8113a3dc <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113a3d4:	00800a84 	movi	r2,42
8113a3d8:	00006006 	br	8113a55c <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a3dc:	0005303a 	rdctl	r2,status
8113a3e0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a3e4:	e0fffe17 	ldw	r3,-8(fp)
8113a3e8:	00bfff84 	movi	r2,-2
8113a3ec:	1884703a 	and	r2,r3,r2
8113a3f0:	1001703a 	wrctl	status,r2
  
  return context;
8113a3f4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113a3f8:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113a3fc:	e0bfff03 	ldbu	r2,-4(fp)
8113a400:	10803fd8 	cmpnei	r2,r2,255
8113a404:	1000061e 	bne	r2,zero,8113a420 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113a408:	d0a0a717 	ldw	r2,-32100(gp)
8113a40c:	10800c83 	ldbu	r2,50(r2)
8113a410:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113a414:	00800044 	movi	r2,1
8113a418:	e0bff705 	stb	r2,-36(fp)
8113a41c:	00000906 	br	8113a444 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113a420:	d0a0a717 	ldw	r2,-32100(gp)
8113a424:	10800c83 	ldbu	r2,50(r2)
8113a428:	10c03fcc 	andi	r3,r2,255
8113a42c:	e0bfff03 	ldbu	r2,-4(fp)
8113a430:	1880031e 	bne	r3,r2,8113a440 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113a434:	00800044 	movi	r2,1
8113a438:	e0bff705 	stb	r2,-36(fp)
8113a43c:	00000106 	br	8113a444 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113a440:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a444:	e0ffff03 	ldbu	r3,-4(fp)
8113a448:	00a045b4 	movhi	r2,33046
8113a44c:	1094cd04 	addi	r2,r2,21300
8113a450:	18c7883a 	add	r3,r3,r3
8113a454:	18c7883a 	add	r3,r3,r3
8113a458:	10c5883a 	add	r2,r2,r3
8113a45c:	10800017 	ldw	r2,0(r2)
8113a460:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113a464:	e0bffa17 	ldw	r2,-24(fp)
8113a468:	1000061e 	bne	r2,zero,8113a484 <OSTaskSuspend+0x100>
8113a46c:	e0bff817 	ldw	r2,-32(fp)
8113a470:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a474:	e0bff917 	ldw	r2,-28(fp)
8113a478:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113a47c:	00801204 	movi	r2,72
8113a480:	00003606 	br	8113a55c <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113a484:	e0bffa17 	ldw	r2,-24(fp)
8113a488:	10800058 	cmpnei	r2,r2,1
8113a48c:	1000061e 	bne	r2,zero,8113a4a8 <OSTaskSuspend+0x124>
8113a490:	e0bff817 	ldw	r2,-32(fp)
8113a494:	e0bffb15 	stw	r2,-20(fp)
8113a498:	e0bffb17 	ldw	r2,-20(fp)
8113a49c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a4a0:	008010c4 	movi	r2,67
8113a4a4:	00002d06 	br	8113a55c <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113a4a8:	e0bffa17 	ldw	r2,-24(fp)
8113a4ac:	10800d03 	ldbu	r2,52(r2)
8113a4b0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113a4b4:	e0fffd03 	ldbu	r3,-12(fp)
8113a4b8:	e13ffd03 	ldbu	r4,-12(fp)
8113a4bc:	d0a0a344 	addi	r2,gp,-32115
8113a4c0:	2085883a 	add	r2,r4,r2
8113a4c4:	10800003 	ldbu	r2,0(r2)
8113a4c8:	1009883a 	mov	r4,r2
8113a4cc:	e0bffa17 	ldw	r2,-24(fp)
8113a4d0:	10800d43 	ldbu	r2,53(r2)
8113a4d4:	0084303a 	nor	r2,zero,r2
8113a4d8:	2084703a 	and	r2,r4,r2
8113a4dc:	1009883a 	mov	r4,r2
8113a4e0:	d0a0a344 	addi	r2,gp,-32115
8113a4e4:	1885883a 	add	r2,r3,r2
8113a4e8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113a4ec:	e0fffd03 	ldbu	r3,-12(fp)
8113a4f0:	d0a0a344 	addi	r2,gp,-32115
8113a4f4:	1885883a 	add	r2,r3,r2
8113a4f8:	10800003 	ldbu	r2,0(r2)
8113a4fc:	10803fcc 	andi	r2,r2,255
8113a500:	1000071e 	bne	r2,zero,8113a520 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113a504:	e0bffa17 	ldw	r2,-24(fp)
8113a508:	10800d83 	ldbu	r2,54(r2)
8113a50c:	0084303a 	nor	r2,zero,r2
8113a510:	1007883a 	mov	r3,r2
8113a514:	d0a0a303 	ldbu	r2,-32116(gp)
8113a518:	1884703a 	and	r2,r3,r2
8113a51c:	d0a0a305 	stb	r2,-32116(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113a520:	e0bffa17 	ldw	r2,-24(fp)
8113a524:	10800c03 	ldbu	r2,48(r2)
8113a528:	10800214 	ori	r2,r2,8
8113a52c:	1007883a 	mov	r3,r2
8113a530:	e0bffa17 	ldw	r2,-24(fp)
8113a534:	10c00c05 	stb	r3,48(r2)
8113a538:	e0bff817 	ldw	r2,-32(fp)
8113a53c:	e0bffc15 	stw	r2,-16(fp)
8113a540:	e0bffc17 	ldw	r2,-16(fp)
8113a544:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113a548:	e0bff703 	ldbu	r2,-36(fp)
8113a54c:	10800058 	cmpnei	r2,r2,1
8113a550:	1000011e 	bne	r2,zero,8113a558 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113a554:	1133b8c0 	call	81133b8c <OS_Sched>
    }
    return (OS_ERR_NONE);
8113a558:	0005883a 	mov	r2,zero
}
8113a55c:	e037883a 	mov	sp,fp
8113a560:	dfc00117 	ldw	ra,4(sp)
8113a564:	df000017 	ldw	fp,0(sp)
8113a568:	dec00204 	addi	sp,sp,8
8113a56c:	f800283a 	ret

8113a570 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113a570:	defff604 	addi	sp,sp,-40
8113a574:	de00012e 	bgeu	sp,et,8113a57c <OSTaskQuery+0xc>
8113a578:	003b68fa 	trap	3
8113a57c:	dfc00915 	stw	ra,36(sp)
8113a580:	df000815 	stw	fp,32(sp)
8113a584:	df000804 	addi	fp,sp,32
8113a588:	2005883a 	mov	r2,r4
8113a58c:	e17fff15 	stw	r5,-4(fp)
8113a590:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a594:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113a598:	e0bffe03 	ldbu	r2,-8(fp)
8113a59c:	10800a70 	cmpltui	r2,r2,41
8113a5a0:	1000051e 	bne	r2,zero,8113a5b8 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113a5a4:	e0bffe03 	ldbu	r2,-8(fp)
8113a5a8:	10803fe0 	cmpeqi	r2,r2,255
8113a5ac:	1000021e 	bne	r2,zero,8113a5b8 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113a5b0:	00800a84 	movi	r2,42
8113a5b4:	00003406 	br	8113a688 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113a5b8:	e0bfff17 	ldw	r2,-4(fp)
8113a5bc:	1000021e 	bne	r2,zero,8113a5c8 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113a5c0:	00800244 	movi	r2,9
8113a5c4:	00003006 	br	8113a688 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a5c8:	0005303a 	rdctl	r2,status
8113a5cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a5d0:	e0fffd17 	ldw	r3,-12(fp)
8113a5d4:	00bfff84 	movi	r2,-2
8113a5d8:	1884703a 	and	r2,r3,r2
8113a5dc:	1001703a 	wrctl	status,r2
  
  return context;
8113a5e0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a5e4:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113a5e8:	e0bffe03 	ldbu	r2,-8(fp)
8113a5ec:	10803fd8 	cmpnei	r2,r2,255
8113a5f0:	1000031e 	bne	r2,zero,8113a600 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113a5f4:	d0a0a717 	ldw	r2,-32100(gp)
8113a5f8:	10800c83 	ldbu	r2,50(r2)
8113a5fc:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113a600:	e0fffe03 	ldbu	r3,-8(fp)
8113a604:	00a045b4 	movhi	r2,33046
8113a608:	1094cd04 	addi	r2,r2,21300
8113a60c:	18c7883a 	add	r3,r3,r3
8113a610:	18c7883a 	add	r3,r3,r3
8113a614:	10c5883a 	add	r2,r2,r3
8113a618:	10800017 	ldw	r2,0(r2)
8113a61c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113a620:	e0bffa17 	ldw	r2,-24(fp)
8113a624:	1000061e 	bne	r2,zero,8113a640 <OSTaskQuery+0xd0>
8113a628:	e0bff817 	ldw	r2,-32(fp)
8113a62c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a630:	e0bff917 	ldw	r2,-28(fp)
8113a634:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113a638:	00800a44 	movi	r2,41
8113a63c:	00001206 	br	8113a688 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113a640:	e0bffa17 	ldw	r2,-24(fp)
8113a644:	10800058 	cmpnei	r2,r2,1
8113a648:	1000061e 	bne	r2,zero,8113a664 <OSTaskQuery+0xf4>
8113a64c:	e0bff817 	ldw	r2,-32(fp)
8113a650:	e0bffb15 	stw	r2,-20(fp)
8113a654:	e0bffb17 	ldw	r2,-20(fp)
8113a658:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113a65c:	008010c4 	movi	r2,67
8113a660:	00000906 	br	8113a688 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113a664:	01801b04 	movi	r6,108
8113a668:	e17ffa17 	ldw	r5,-24(fp)
8113a66c:	e13fff17 	ldw	r4,-4(fp)
8113a670:	1133b1c0 	call	81133b1c <OS_MemCopy>
8113a674:	e0bff817 	ldw	r2,-32(fp)
8113a678:	e0bffc15 	stw	r2,-16(fp)
8113a67c:	e0bffc17 	ldw	r2,-16(fp)
8113a680:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a684:	0005883a 	mov	r2,zero
}
8113a688:	e037883a 	mov	sp,fp
8113a68c:	dfc00117 	ldw	ra,4(sp)
8113a690:	df000017 	ldw	fp,0(sp)
8113a694:	dec00204 	addi	sp,sp,8
8113a698:	f800283a 	ret

8113a69c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113a69c:	defffc04 	addi	sp,sp,-16
8113a6a0:	de00012e 	bgeu	sp,et,8113a6a8 <OS_TaskStkClr+0xc>
8113a6a4:	003b68fa 	trap	3
8113a6a8:	df000315 	stw	fp,12(sp)
8113a6ac:	df000304 	addi	fp,sp,12
8113a6b0:	e13ffd15 	stw	r4,-12(fp)
8113a6b4:	e17ffe15 	stw	r5,-8(fp)
8113a6b8:	3005883a 	mov	r2,r6
8113a6bc:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113a6c0:	e0bfff0b 	ldhu	r2,-4(fp)
8113a6c4:	1080004c 	andi	r2,r2,1
8113a6c8:	10000d26 	beq	r2,zero,8113a700 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113a6cc:	e0bfff0b 	ldhu	r2,-4(fp)
8113a6d0:	1080008c 	andi	r2,r2,2
8113a6d4:	10000a26 	beq	r2,zero,8113a700 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113a6d8:	00000706 	br	8113a6f8 <OS_TaskStkClr+0x5c>
                size--;
8113a6dc:	e0bffe17 	ldw	r2,-8(fp)
8113a6e0:	10bfffc4 	addi	r2,r2,-1
8113a6e4:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113a6e8:	e0bffd17 	ldw	r2,-12(fp)
8113a6ec:	10c00104 	addi	r3,r2,4
8113a6f0:	e0fffd15 	stw	r3,-12(fp)
8113a6f4:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113a6f8:	e0bffe17 	ldw	r2,-8(fp)
8113a6fc:	103ff71e 	bne	r2,zero,8113a6dc <__reset+0xfb11a6dc>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113a700:	0001883a 	nop
8113a704:	e037883a 	mov	sp,fp
8113a708:	df000017 	ldw	fp,0(sp)
8113a70c:	dec00104 	addi	sp,sp,4
8113a710:	f800283a 	ret

8113a714 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113a714:	defff904 	addi	sp,sp,-28
8113a718:	de00012e 	bgeu	sp,et,8113a720 <OSTimeDly+0xc>
8113a71c:	003b68fa 	trap	3
8113a720:	dfc00615 	stw	ra,24(sp)
8113a724:	df000515 	stw	fp,20(sp)
8113a728:	df000504 	addi	fp,sp,20
8113a72c:	2005883a 	mov	r2,r4
8113a730:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a734:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a738:	d0a0a603 	ldbu	r2,-32104(gp)
8113a73c:	10803fcc 	andi	r2,r2,255
8113a740:	1000311e 	bne	r2,zero,8113a808 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113a744:	e0bfff0b 	ldhu	r2,-4(fp)
8113a748:	10003026 	beq	r2,zero,8113a80c <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a74c:	0005303a 	rdctl	r2,status
8113a750:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a754:	e0fffe17 	ldw	r3,-8(fp)
8113a758:	00bfff84 	movi	r2,-2
8113a75c:	1884703a 	and	r2,r3,r2
8113a760:	1001703a 	wrctl	status,r2
  
  return context;
8113a764:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113a768:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113a76c:	d0a0a717 	ldw	r2,-32100(gp)
8113a770:	10800d03 	ldbu	r2,52(r2)
8113a774:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113a778:	e0fffd03 	ldbu	r3,-12(fp)
8113a77c:	e13ffd03 	ldbu	r4,-12(fp)
8113a780:	d0a0a344 	addi	r2,gp,-32115
8113a784:	2085883a 	add	r2,r4,r2
8113a788:	10800003 	ldbu	r2,0(r2)
8113a78c:	1009883a 	mov	r4,r2
8113a790:	d0a0a717 	ldw	r2,-32100(gp)
8113a794:	10800d43 	ldbu	r2,53(r2)
8113a798:	0084303a 	nor	r2,zero,r2
8113a79c:	2084703a 	and	r2,r4,r2
8113a7a0:	1009883a 	mov	r4,r2
8113a7a4:	d0a0a344 	addi	r2,gp,-32115
8113a7a8:	1885883a 	add	r2,r3,r2
8113a7ac:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113a7b0:	e0fffd03 	ldbu	r3,-12(fp)
8113a7b4:	d0a0a344 	addi	r2,gp,-32115
8113a7b8:	1885883a 	add	r2,r3,r2
8113a7bc:	10800003 	ldbu	r2,0(r2)
8113a7c0:	10803fcc 	andi	r2,r2,255
8113a7c4:	1000071e 	bne	r2,zero,8113a7e4 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113a7c8:	d0a0a717 	ldw	r2,-32100(gp)
8113a7cc:	10800d83 	ldbu	r2,54(r2)
8113a7d0:	0084303a 	nor	r2,zero,r2
8113a7d4:	1007883a 	mov	r3,r2
8113a7d8:	d0a0a303 	ldbu	r2,-32116(gp)
8113a7dc:	1884703a 	and	r2,r3,r2
8113a7e0:	d0a0a305 	stb	r2,-32116(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113a7e4:	d0a0a717 	ldw	r2,-32100(gp)
8113a7e8:	e0ffff0b 	ldhu	r3,-4(fp)
8113a7ec:	10c00b8d 	sth	r3,46(r2)
8113a7f0:	e0bffb17 	ldw	r2,-20(fp)
8113a7f4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a7f8:	e0bffc17 	ldw	r2,-16(fp)
8113a7fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113a800:	1133b8c0 	call	81133b8c <OS_Sched>
8113a804:	00000106 	br	8113a80c <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113a808:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113a80c:	e037883a 	mov	sp,fp
8113a810:	dfc00117 	ldw	ra,4(sp)
8113a814:	df000017 	ldw	fp,0(sp)
8113a818:	dec00204 	addi	sp,sp,8
8113a81c:	f800283a 	ret

8113a820 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113a820:	defff804 	addi	sp,sp,-32
8113a824:	de00012e 	bgeu	sp,et,8113a82c <OSTimeDlyHMSM+0xc>
8113a828:	003b68fa 	trap	3
8113a82c:	dfc00715 	stw	ra,28(sp)
8113a830:	df000615 	stw	fp,24(sp)
8113a834:	df000604 	addi	fp,sp,24
8113a838:	2015883a 	mov	r10,r4
8113a83c:	2809883a 	mov	r4,r5
8113a840:	3007883a 	mov	r3,r6
8113a844:	3805883a 	mov	r2,r7
8113a848:	e2bffc05 	stb	r10,-16(fp)
8113a84c:	e13ffd05 	stb	r4,-12(fp)
8113a850:	e0fffe05 	stb	r3,-8(fp)
8113a854:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a858:	d0a0a603 	ldbu	r2,-32104(gp)
8113a85c:	10803fcc 	andi	r2,r2,255
8113a860:	10000226 	beq	r2,zero,8113a86c <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113a864:	00801544 	movi	r2,85
8113a868:	00004106 	br	8113a970 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113a86c:	e0bffc03 	ldbu	r2,-16(fp)
8113a870:	1000081e 	bne	r2,zero,8113a894 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113a874:	e0bffd03 	ldbu	r2,-12(fp)
8113a878:	1000061e 	bne	r2,zero,8113a894 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113a87c:	e0bffe03 	ldbu	r2,-8(fp)
8113a880:	1000041e 	bne	r2,zero,8113a894 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113a884:	e0bfff0b 	ldhu	r2,-4(fp)
8113a888:	1000021e 	bne	r2,zero,8113a894 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113a88c:	00801504 	movi	r2,84
8113a890:	00003706 	br	8113a970 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113a894:	e0bffd03 	ldbu	r2,-12(fp)
8113a898:	10800f30 	cmpltui	r2,r2,60
8113a89c:	1000021e 	bne	r2,zero,8113a8a8 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113a8a0:	00801444 	movi	r2,81
8113a8a4:	00003206 	br	8113a970 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113a8a8:	e0bffe03 	ldbu	r2,-8(fp)
8113a8ac:	10800f30 	cmpltui	r2,r2,60
8113a8b0:	1000021e 	bne	r2,zero,8113a8bc <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113a8b4:	00801484 	movi	r2,82
8113a8b8:	00002d06 	br	8113a970 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113a8bc:	e0bfff0b 	ldhu	r2,-4(fp)
8113a8c0:	1080fa30 	cmpltui	r2,r2,1000
8113a8c4:	1000021e 	bne	r2,zero,8113a8d0 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113a8c8:	008014c4 	movi	r2,83
8113a8cc:	00002806 	br	8113a970 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113a8d0:	e0bffc03 	ldbu	r2,-16(fp)
8113a8d4:	10c38424 	muli	r3,r2,3600
8113a8d8:	e0bffd03 	ldbu	r2,-12(fp)
8113a8dc:	10800f24 	muli	r2,r2,60
8113a8e0:	1887883a 	add	r3,r3,r2
8113a8e4:	e0bffe03 	ldbu	r2,-8(fp)
8113a8e8:	1885883a 	add	r2,r3,r2
8113a8ec:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113a8f0:	e0bfff0b 	ldhu	r2,-4(fp)
8113a8f4:	10c0fa24 	muli	r3,r2,1000
8113a8f8:	008418b4 	movhi	r2,4194
8113a8fc:	109374c4 	addi	r2,r2,19923
8113a900:	188a383a 	mulxuu	r5,r3,r2
8113a904:	1885383a 	mul	r2,r3,r2
8113a908:	1011883a 	mov	r8,r2
8113a90c:	2813883a 	mov	r9,r5
8113a910:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113a914:	2085883a 	add	r2,r4,r2
8113a918:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113a91c:	e0bffb17 	ldw	r2,-20(fp)
8113a920:	1004d43a 	srli	r2,r2,16
8113a924:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113a928:	e0bffb17 	ldw	r2,-20(fp)
8113a92c:	10bfffcc 	andi	r2,r2,65535
8113a930:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113a934:	e0bffb17 	ldw	r2,-20(fp)
8113a938:	10bfffcc 	andi	r2,r2,65535
8113a93c:	1009883a 	mov	r4,r2
8113a940:	113a7140 	call	8113a714 <OSTimeDly>
    while (loops > 0) {
8113a944:	00000706 	br	8113a964 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113a948:	01200014 	movui	r4,32768
8113a94c:	113a7140 	call	8113a714 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113a950:	01200014 	movui	r4,32768
8113a954:	113a7140 	call	8113a714 <OSTimeDly>
        loops--;
8113a958:	e0bffa0b 	ldhu	r2,-24(fp)
8113a95c:	10bfffc4 	addi	r2,r2,-1
8113a960:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113a964:	e0bffa0b 	ldhu	r2,-24(fp)
8113a968:	103ff71e 	bne	r2,zero,8113a948 <__reset+0xfb11a948>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113a96c:	0005883a 	mov	r2,zero
}
8113a970:	e037883a 	mov	sp,fp
8113a974:	dfc00117 	ldw	ra,4(sp)
8113a978:	df000017 	ldw	fp,0(sp)
8113a97c:	dec00204 	addi	sp,sp,8
8113a980:	f800283a 	ret

8113a984 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113a984:	defff504 	addi	sp,sp,-44
8113a988:	de00012e 	bgeu	sp,et,8113a990 <OSTimeDlyResume+0xc>
8113a98c:	003b68fa 	trap	3
8113a990:	dfc00a15 	stw	ra,40(sp)
8113a994:	df000915 	stw	fp,36(sp)
8113a998:	df000904 	addi	fp,sp,36
8113a99c:	2005883a 	mov	r2,r4
8113a9a0:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a9a4:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113a9a8:	e0bfff03 	ldbu	r2,-4(fp)
8113a9ac:	10800a30 	cmpltui	r2,r2,40
8113a9b0:	1000021e 	bne	r2,zero,8113a9bc <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113a9b4:	00800a84 	movi	r2,42
8113a9b8:	00006406 	br	8113ab4c <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a9bc:	0005303a 	rdctl	r2,status
8113a9c0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a9c4:	e0fffe17 	ldw	r3,-8(fp)
8113a9c8:	00bfff84 	movi	r2,-2
8113a9cc:	1884703a 	and	r2,r3,r2
8113a9d0:	1001703a 	wrctl	status,r2
  
  return context;
8113a9d4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113a9d8:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113a9dc:	e0ffff03 	ldbu	r3,-4(fp)
8113a9e0:	00a045b4 	movhi	r2,33046
8113a9e4:	1094cd04 	addi	r2,r2,21300
8113a9e8:	18c7883a 	add	r3,r3,r3
8113a9ec:	18c7883a 	add	r3,r3,r3
8113a9f0:	10c5883a 	add	r2,r2,r3
8113a9f4:	10800017 	ldw	r2,0(r2)
8113a9f8:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113a9fc:	e0bff917 	ldw	r2,-28(fp)
8113aa00:	1000061e 	bne	r2,zero,8113aa1c <OSTimeDlyResume+0x98>
8113aa04:	e0bff717 	ldw	r2,-36(fp)
8113aa08:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aa0c:	e0bff817 	ldw	r2,-32(fp)
8113aa10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113aa14:	008010c4 	movi	r2,67
8113aa18:	00004c06 	br	8113ab4c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113aa1c:	e0bff917 	ldw	r2,-28(fp)
8113aa20:	10800058 	cmpnei	r2,r2,1
8113aa24:	1000061e 	bne	r2,zero,8113aa40 <OSTimeDlyResume+0xbc>
8113aa28:	e0bff717 	ldw	r2,-36(fp)
8113aa2c:	e0bffa15 	stw	r2,-24(fp)
8113aa30:	e0bffa17 	ldw	r2,-24(fp)
8113aa34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113aa38:	008010c4 	movi	r2,67
8113aa3c:	00004306 	br	8113ab4c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113aa40:	e0bff917 	ldw	r2,-28(fp)
8113aa44:	10800b8b 	ldhu	r2,46(r2)
8113aa48:	10bfffcc 	andi	r2,r2,65535
8113aa4c:	1000061e 	bne	r2,zero,8113aa68 <OSTimeDlyResume+0xe4>
8113aa50:	e0bff717 	ldw	r2,-36(fp)
8113aa54:	e0bffb15 	stw	r2,-20(fp)
8113aa58:	e0bffb17 	ldw	r2,-20(fp)
8113aa5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113aa60:	00801404 	movi	r2,80
8113aa64:	00003906 	br	8113ab4c <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113aa68:	e0bff917 	ldw	r2,-28(fp)
8113aa6c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113aa70:	e0bff917 	ldw	r2,-28(fp)
8113aa74:	10800c03 	ldbu	r2,48(r2)
8113aa78:	10803fcc 	andi	r2,r2,255
8113aa7c:	10800dcc 	andi	r2,r2,55
8113aa80:	10000b26 	beq	r2,zero,8113aab0 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113aa84:	e0bff917 	ldw	r2,-28(fp)
8113aa88:	10c00c03 	ldbu	r3,48(r2)
8113aa8c:	00bff204 	movi	r2,-56
8113aa90:	1884703a 	and	r2,r3,r2
8113aa94:	1007883a 	mov	r3,r2
8113aa98:	e0bff917 	ldw	r2,-28(fp)
8113aa9c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113aaa0:	e0bff917 	ldw	r2,-28(fp)
8113aaa4:	00c00044 	movi	r3,1
8113aaa8:	10c00c45 	stb	r3,49(r2)
8113aaac:	00000206 	br	8113aab8 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113aab0:	e0bff917 	ldw	r2,-28(fp)
8113aab4:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113aab8:	e0bff917 	ldw	r2,-28(fp)
8113aabc:	10800c03 	ldbu	r2,48(r2)
8113aac0:	10803fcc 	andi	r2,r2,255
8113aac4:	1080020c 	andi	r2,r2,8
8113aac8:	10001b1e 	bne	r2,zero,8113ab38 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113aacc:	e0bff917 	ldw	r2,-28(fp)
8113aad0:	10c00d83 	ldbu	r3,54(r2)
8113aad4:	d0a0a303 	ldbu	r2,-32116(gp)
8113aad8:	1884b03a 	or	r2,r3,r2
8113aadc:	d0a0a305 	stb	r2,-32116(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113aae0:	e0bff917 	ldw	r2,-28(fp)
8113aae4:	10800d03 	ldbu	r2,52(r2)
8113aae8:	10c03fcc 	andi	r3,r2,255
8113aaec:	e0bff917 	ldw	r2,-28(fp)
8113aaf0:	10800d03 	ldbu	r2,52(r2)
8113aaf4:	11003fcc 	andi	r4,r2,255
8113aaf8:	d0a0a344 	addi	r2,gp,-32115
8113aafc:	2085883a 	add	r2,r4,r2
8113ab00:	11000003 	ldbu	r4,0(r2)
8113ab04:	e0bff917 	ldw	r2,-28(fp)
8113ab08:	10800d43 	ldbu	r2,53(r2)
8113ab0c:	2084b03a 	or	r2,r4,r2
8113ab10:	1009883a 	mov	r4,r2
8113ab14:	d0a0a344 	addi	r2,gp,-32115
8113ab18:	1885883a 	add	r2,r3,r2
8113ab1c:	11000005 	stb	r4,0(r2)
8113ab20:	e0bff717 	ldw	r2,-36(fp)
8113ab24:	e0bffc15 	stw	r2,-16(fp)
8113ab28:	e0bffc17 	ldw	r2,-16(fp)
8113ab2c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113ab30:	1133b8c0 	call	81133b8c <OS_Sched>
8113ab34:	00000406 	br	8113ab48 <OSTimeDlyResume+0x1c4>
8113ab38:	e0bff717 	ldw	r2,-36(fp)
8113ab3c:	e0bffd15 	stw	r2,-12(fp)
8113ab40:	e0bffd17 	ldw	r2,-12(fp)
8113ab44:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113ab48:	0005883a 	mov	r2,zero
}
8113ab4c:	e037883a 	mov	sp,fp
8113ab50:	dfc00117 	ldw	ra,4(sp)
8113ab54:	df000017 	ldw	fp,0(sp)
8113ab58:	dec00204 	addi	sp,sp,8
8113ab5c:	f800283a 	ret

8113ab60 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113ab60:	defffb04 	addi	sp,sp,-20
8113ab64:	de00012e 	bgeu	sp,et,8113ab6c <OSTimeGet+0xc>
8113ab68:	003b68fa 	trap	3
8113ab6c:	df000415 	stw	fp,16(sp)
8113ab70:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ab74:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab78:	0005303a 	rdctl	r2,status
8113ab7c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ab80:	e0fffe17 	ldw	r3,-8(fp)
8113ab84:	00bfff84 	movi	r2,-2
8113ab88:	1884703a 	and	r2,r3,r2
8113ab8c:	1001703a 	wrctl	status,r2
  
  return context;
8113ab90:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113ab94:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113ab98:	d0a0a917 	ldw	r2,-32092(gp)
8113ab9c:	e0bffd15 	stw	r2,-12(fp)
8113aba0:	e0bffc17 	ldw	r2,-16(fp)
8113aba4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aba8:	e0bfff17 	ldw	r2,-4(fp)
8113abac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113abb0:	e0bffd17 	ldw	r2,-12(fp)
}
8113abb4:	e037883a 	mov	sp,fp
8113abb8:	df000017 	ldw	fp,0(sp)
8113abbc:	dec00104 	addi	sp,sp,4
8113abc0:	f800283a 	ret

8113abc4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113abc4:	defffb04 	addi	sp,sp,-20
8113abc8:	de00012e 	bgeu	sp,et,8113abd0 <OSTimeSet+0xc>
8113abcc:	003b68fa 	trap	3
8113abd0:	df000415 	stw	fp,16(sp)
8113abd4:	df000404 	addi	fp,sp,16
8113abd8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113abdc:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113abe0:	0005303a 	rdctl	r2,status
8113abe4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113abe8:	e0fffd17 	ldw	r3,-12(fp)
8113abec:	00bfff84 	movi	r2,-2
8113abf0:	1884703a 	and	r2,r3,r2
8113abf4:	1001703a 	wrctl	status,r2
  
  return context;
8113abf8:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113abfc:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113ac00:	e0bfff17 	ldw	r2,-4(fp)
8113ac04:	d0a0a915 	stw	r2,-32092(gp)
8113ac08:	e0bffc17 	ldw	r2,-16(fp)
8113ac0c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ac10:	e0bffe17 	ldw	r2,-8(fp)
8113ac14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113ac18:	0001883a 	nop
8113ac1c:	e037883a 	mov	sp,fp
8113ac20:	df000017 	ldw	fp,0(sp)
8113ac24:	dec00104 	addi	sp,sp,4
8113ac28:	f800283a 	ret

8113ac2c <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113ac2c:	defff804 	addi	sp,sp,-32
8113ac30:	de00012e 	bgeu	sp,et,8113ac38 <OSTmrCreate+0xc>
8113ac34:	003b68fa 	trap	3
8113ac38:	dfc00715 	stw	ra,28(sp)
8113ac3c:	df000615 	stw	fp,24(sp)
8113ac40:	df000604 	addi	fp,sp,24
8113ac44:	e13ffc15 	stw	r4,-16(fp)
8113ac48:	e17ffd15 	stw	r5,-12(fp)
8113ac4c:	3005883a 	mov	r2,r6
8113ac50:	e1ffff15 	stw	r7,-4(fp)
8113ac54:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113ac58:	e0800417 	ldw	r2,16(fp)
8113ac5c:	1000021e 	bne	r2,zero,8113ac68 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113ac60:	0005883a 	mov	r2,zero
8113ac64:	00005d06 	br	8113addc <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113ac68:	e0bffe03 	ldbu	r2,-8(fp)
8113ac6c:	10c00060 	cmpeqi	r3,r2,1
8113ac70:	1800091e 	bne	r3,zero,8113ac98 <OSTmrCreate+0x6c>
8113ac74:	108000a0 	cmpeqi	r2,r2,2
8113ac78:	10000e26 	beq	r2,zero,8113acb4 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113ac7c:	e0bffd17 	ldw	r2,-12(fp)
8113ac80:	1000111e 	bne	r2,zero,8113acc8 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113ac84:	e0800417 	ldw	r2,16(fp)
8113ac88:	00ffe0c4 	movi	r3,-125
8113ac8c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113ac90:	0005883a 	mov	r2,zero
8113ac94:	00005106 	br	8113addc <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113ac98:	e0bffc17 	ldw	r2,-16(fp)
8113ac9c:	10000c1e 	bne	r2,zero,8113acd0 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113aca0:	e0800417 	ldw	r2,16(fp)
8113aca4:	00ffe084 	movi	r3,-126
8113aca8:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113acac:	0005883a 	mov	r2,zero
8113acb0:	00004a06 	br	8113addc <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113acb4:	e0800417 	ldw	r2,16(fp)
8113acb8:	00ffe104 	movi	r3,-124
8113acbc:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113acc0:	0005883a 	mov	r2,zero
8113acc4:	00004506 	br	8113addc <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113acc8:	0001883a 	nop
8113accc:	00000106 	br	8113acd4 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113acd0:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113acd4:	d0a0a603 	ldbu	r2,-32104(gp)
8113acd8:	10803fcc 	andi	r2,r2,255
8113acdc:	10000526 	beq	r2,zero,8113acf4 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113ace0:	e0800417 	ldw	r2,16(fp)
8113ace4:	00ffe2c4 	movi	r3,-117
8113ace8:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113acec:	0005883a 	mov	r2,zero
8113acf0:	00003a06 	br	8113addc <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113acf4:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113acf8:	113b6840 	call	8113b684 <OSTmr_Alloc>
8113acfc:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113ad00:	e0bffa17 	ldw	r2,-24(fp)
8113ad04:	1000061e 	bne	r2,zero,8113ad20 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113ad08:	113bc280 	call	8113bc28 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113ad0c:	e0800417 	ldw	r2,16(fp)
8113ad10:	00ffe184 	movi	r3,-122
8113ad14:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113ad18:	0005883a 	mov	r2,zero
8113ad1c:	00002f06 	br	8113addc <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113ad20:	e0bffa17 	ldw	r2,-24(fp)
8113ad24:	00c00044 	movi	r3,1
8113ad28:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113ad2c:	e0bffa17 	ldw	r2,-24(fp)
8113ad30:	e0fffc17 	ldw	r3,-16(fp)
8113ad34:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113ad38:	e0bffa17 	ldw	r2,-24(fp)
8113ad3c:	e0fffd17 	ldw	r3,-12(fp)
8113ad40:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113ad44:	e0bffa17 	ldw	r2,-24(fp)
8113ad48:	e0fffe03 	ldbu	r3,-8(fp)
8113ad4c:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113ad50:	e0bffa17 	ldw	r2,-24(fp)
8113ad54:	e0ffff17 	ldw	r3,-4(fp)
8113ad58:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113ad5c:	e0bffa17 	ldw	r2,-24(fp)
8113ad60:	e0c00217 	ldw	r3,8(fp)
8113ad64:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113ad68:	e0800317 	ldw	r2,12(fp)
8113ad6c:	10001726 	beq	r2,zero,8113adcc <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113ad70:	e1000317 	ldw	r4,12(fp)
8113ad74:	1133d5c0 	call	81133d5c <OS_StrLen>
8113ad78:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113ad7c:	e0bffb03 	ldbu	r2,-20(fp)
8113ad80:	10800428 	cmpgeui	r2,r2,16
8113ad84:	1000061e 	bne	r2,zero,8113ada0 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113ad88:	e0bffa17 	ldw	r2,-24(fp)
8113ad8c:	10800804 	addi	r2,r2,32
8113ad90:	e1400317 	ldw	r5,12(fp)
8113ad94:	1009883a 	mov	r4,r2
8113ad98:	1133ce00 	call	81133ce0 <OS_StrCopy>
8113ad9c:	00000b06 	br	8113adcc <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113ada0:	e0bffa17 	ldw	r2,-24(fp)
8113ada4:	00c008c4 	movi	r3,35
8113ada8:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113adac:	e0bffa17 	ldw	r2,-24(fp)
8113adb0:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113adb4:	e0800417 	ldw	r2,16(fp)
8113adb8:	00ffe304 	movi	r3,-116
8113adbc:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113adc0:	113bc280 	call	8113bc28 <OSTmr_Unlock>
            return (ptmr);
8113adc4:	e0bffa17 	ldw	r2,-24(fp)
8113adc8:	00000406 	br	8113addc <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113adcc:	113bc280 	call	8113bc28 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113add0:	e0800417 	ldw	r2,16(fp)
8113add4:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113add8:	e0bffa17 	ldw	r2,-24(fp)
}
8113addc:	e037883a 	mov	sp,fp
8113ade0:	dfc00117 	ldw	ra,4(sp)
8113ade4:	df000017 	ldw	fp,0(sp)
8113ade8:	dec00204 	addi	sp,sp,8
8113adec:	f800283a 	ret

8113adf0 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113adf0:	defffc04 	addi	sp,sp,-16
8113adf4:	de00012e 	bgeu	sp,et,8113adfc <OSTmrDel+0xc>
8113adf8:	003b68fa 	trap	3
8113adfc:	dfc00315 	stw	ra,12(sp)
8113ae00:	df000215 	stw	fp,8(sp)
8113ae04:	df000204 	addi	fp,sp,8
8113ae08:	e13ffe15 	stw	r4,-8(fp)
8113ae0c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113ae10:	e0bfff17 	ldw	r2,-4(fp)
8113ae14:	1000021e 	bne	r2,zero,8113ae20 <OSTmrDel+0x30>
        return (OS_FALSE);
8113ae18:	0005883a 	mov	r2,zero
8113ae1c:	00003f06 	br	8113af1c <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113ae20:	e0bffe17 	ldw	r2,-8(fp)
8113ae24:	1000051e 	bne	r2,zero,8113ae3c <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113ae28:	e0bfff17 	ldw	r2,-4(fp)
8113ae2c:	00ffe284 	movi	r3,-118
8113ae30:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ae34:	0005883a 	mov	r2,zero
8113ae38:	00003806 	br	8113af1c <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113ae3c:	e0bffe17 	ldw	r2,-8(fp)
8113ae40:	10800003 	ldbu	r2,0(r2)
8113ae44:	10803fcc 	andi	r2,r2,255
8113ae48:	10801920 	cmpeqi	r2,r2,100
8113ae4c:	1000051e 	bne	r2,zero,8113ae64 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113ae50:	e0bfff17 	ldw	r2,-4(fp)
8113ae54:	00ffe244 	movi	r3,-119
8113ae58:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ae5c:	0005883a 	mov	r2,zero
8113ae60:	00002e06 	br	8113af1c <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113ae64:	d0a0a603 	ldbu	r2,-32104(gp)
8113ae68:	10803fcc 	andi	r2,r2,255
8113ae6c:	10000526 	beq	r2,zero,8113ae84 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113ae70:	e0bfff17 	ldw	r2,-4(fp)
8113ae74:	00ffe2c4 	movi	r3,-117
8113ae78:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113ae7c:	0005883a 	mov	r2,zero
8113ae80:	00002606 	br	8113af1c <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113ae84:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113ae88:	e0bffe17 	ldw	r2,-8(fp)
8113ae8c:	10800c43 	ldbu	r2,49(r2)
8113ae90:	10803fcc 	andi	r2,r2,255
8113ae94:	10c000c8 	cmpgei	r3,r2,3
8113ae98:	1800031e 	bne	r3,zero,8113aea8 <OSTmrDel+0xb8>
8113ae9c:	00800d16 	blt	zero,r2,8113aed4 <OSTmrDel+0xe4>
8113aea0:	10001326 	beq	r2,zero,8113aef0 <OSTmrDel+0x100>
8113aea4:	00001806 	br	8113af08 <OSTmrDel+0x118>
8113aea8:	108000e0 	cmpeqi	r2,r2,3
8113aeac:	10001626 	beq	r2,zero,8113af08 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113aeb0:	e13ffe17 	ldw	r4,-8(fp)
8113aeb4:	113bae80 	call	8113bae8 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113aeb8:	e13ffe17 	ldw	r4,-8(fp)
8113aebc:	113b6f80 	call	8113b6f8 <OSTmr_Free>
             OSTmr_Unlock();
8113aec0:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113aec4:	e0bfff17 	ldw	r2,-4(fp)
8113aec8:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113aecc:	00800044 	movi	r2,1
8113aed0:	00001206 	br	8113af1c <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113aed4:	e13ffe17 	ldw	r4,-8(fp)
8113aed8:	113b6f80 	call	8113b6f8 <OSTmr_Free>
             OSTmr_Unlock();
8113aedc:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113aee0:	e0bfff17 	ldw	r2,-4(fp)
8113aee4:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113aee8:	00800044 	movi	r2,1
8113aeec:	00000b06 	br	8113af1c <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113aef0:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113aef4:	e0bfff17 	ldw	r2,-4(fp)
8113aef8:	00ffe1c4 	movi	r3,-121
8113aefc:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113af00:	0005883a 	mov	r2,zero
8113af04:	00000506 	br	8113af1c <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113af08:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113af0c:	e0bfff17 	ldw	r2,-4(fp)
8113af10:	00ffe344 	movi	r3,-115
8113af14:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113af18:	0005883a 	mov	r2,zero
    }
}
8113af1c:	e037883a 	mov	sp,fp
8113af20:	dfc00117 	ldw	ra,4(sp)
8113af24:	df000017 	ldw	fp,0(sp)
8113af28:	dec00204 	addi	sp,sp,8
8113af2c:	f800283a 	ret

8113af30 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113af30:	defffa04 	addi	sp,sp,-24
8113af34:	de00012e 	bgeu	sp,et,8113af3c <OSTmrNameGet+0xc>
8113af38:	003b68fa 	trap	3
8113af3c:	dfc00515 	stw	ra,20(sp)
8113af40:	df000415 	stw	fp,16(sp)
8113af44:	df000404 	addi	fp,sp,16
8113af48:	e13ffd15 	stw	r4,-12(fp)
8113af4c:	e17ffe15 	stw	r5,-8(fp)
8113af50:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113af54:	e0bfff17 	ldw	r2,-4(fp)
8113af58:	1000021e 	bne	r2,zero,8113af64 <OSTmrNameGet+0x34>
        return (0);
8113af5c:	0005883a 	mov	r2,zero
8113af60:	00003e06 	br	8113b05c <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113af64:	e0bffe17 	ldw	r2,-8(fp)
8113af68:	1000051e 	bne	r2,zero,8113af80 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113af6c:	e0bfff17 	ldw	r2,-4(fp)
8113af70:	00ffe204 	movi	r3,-120
8113af74:	10c00005 	stb	r3,0(r2)
        return (0);
8113af78:	0005883a 	mov	r2,zero
8113af7c:	00003706 	br	8113b05c <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113af80:	e0bffd17 	ldw	r2,-12(fp)
8113af84:	1000051e 	bne	r2,zero,8113af9c <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113af88:	e0bfff17 	ldw	r2,-4(fp)
8113af8c:	00ffe284 	movi	r3,-118
8113af90:	10c00005 	stb	r3,0(r2)
        return (0);
8113af94:	0005883a 	mov	r2,zero
8113af98:	00003006 	br	8113b05c <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113af9c:	e0bffd17 	ldw	r2,-12(fp)
8113afa0:	10800003 	ldbu	r2,0(r2)
8113afa4:	10803fcc 	andi	r2,r2,255
8113afa8:	10801920 	cmpeqi	r2,r2,100
8113afac:	1000051e 	bne	r2,zero,8113afc4 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113afb0:	e0bfff17 	ldw	r2,-4(fp)
8113afb4:	00ffe244 	movi	r3,-119
8113afb8:	10c00005 	stb	r3,0(r2)
        return (0);
8113afbc:	0005883a 	mov	r2,zero
8113afc0:	00002606 	br	8113b05c <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113afc4:	d0a0a603 	ldbu	r2,-32104(gp)
8113afc8:	10803fcc 	andi	r2,r2,255
8113afcc:	10000526 	beq	r2,zero,8113afe4 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113afd0:	e0bfff17 	ldw	r2,-4(fp)
8113afd4:	00c00444 	movi	r3,17
8113afd8:	10c00005 	stb	r3,0(r2)
        return (0);
8113afdc:	0005883a 	mov	r2,zero
8113afe0:	00001e06 	br	8113b05c <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113afe4:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113afe8:	e0bffd17 	ldw	r2,-12(fp)
8113afec:	10800c43 	ldbu	r2,49(r2)
8113aff0:	10803fcc 	andi	r2,r2,255
8113aff4:	10000e26 	beq	r2,zero,8113b030 <OSTmrNameGet+0x100>
8113aff8:	10001316 	blt	r2,zero,8113b048 <OSTmrNameGet+0x118>
8113affc:	10800108 	cmpgei	r2,r2,4
8113b000:	1000111e 	bne	r2,zero,8113b048 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113b004:	e0bffd17 	ldw	r2,-12(fp)
8113b008:	10800804 	addi	r2,r2,32
8113b00c:	100b883a 	mov	r5,r2
8113b010:	e13ffe17 	ldw	r4,-8(fp)
8113b014:	1133ce00 	call	81133ce0 <OS_StrCopy>
8113b018:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113b01c:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113b020:	e0bfff17 	ldw	r2,-4(fp)
8113b024:	10000005 	stb	zero,0(r2)
             return (len);
8113b028:	e0bffc03 	ldbu	r2,-16(fp)
8113b02c:	00000b06 	br	8113b05c <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113b030:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113b034:	e0bfff17 	ldw	r2,-4(fp)
8113b038:	00ffe1c4 	movi	r3,-121
8113b03c:	10c00005 	stb	r3,0(r2)
             return (0);
8113b040:	0005883a 	mov	r2,zero
8113b044:	00000506 	br	8113b05c <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113b048:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113b04c:	e0bfff17 	ldw	r2,-4(fp)
8113b050:	00ffe344 	movi	r3,-115
8113b054:	10c00005 	stb	r3,0(r2)
             return (0);
8113b058:	0005883a 	mov	r2,zero
    }
}
8113b05c:	e037883a 	mov	sp,fp
8113b060:	dfc00117 	ldw	ra,4(sp)
8113b064:	df000017 	ldw	fp,0(sp)
8113b068:	dec00204 	addi	sp,sp,8
8113b06c:	f800283a 	ret

8113b070 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113b070:	defffb04 	addi	sp,sp,-20
8113b074:	de00012e 	bgeu	sp,et,8113b07c <OSTmrRemainGet+0xc>
8113b078:	003b68fa 	trap	3
8113b07c:	dfc00415 	stw	ra,16(sp)
8113b080:	df000315 	stw	fp,12(sp)
8113b084:	df000304 	addi	fp,sp,12
8113b088:	e13ffe15 	stw	r4,-8(fp)
8113b08c:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113b090:	e0bfff17 	ldw	r2,-4(fp)
8113b094:	1000021e 	bne	r2,zero,8113b0a0 <OSTmrRemainGet+0x30>
        return (0);
8113b098:	0005883a 	mov	r2,zero
8113b09c:	00005d06 	br	8113b214 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113b0a0:	e0bffe17 	ldw	r2,-8(fp)
8113b0a4:	1000051e 	bne	r2,zero,8113b0bc <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113b0a8:	e0bfff17 	ldw	r2,-4(fp)
8113b0ac:	00ffe284 	movi	r3,-118
8113b0b0:	10c00005 	stb	r3,0(r2)
        return (0);
8113b0b4:	0005883a 	mov	r2,zero
8113b0b8:	00005606 	br	8113b214 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113b0bc:	e0bffe17 	ldw	r2,-8(fp)
8113b0c0:	10800003 	ldbu	r2,0(r2)
8113b0c4:	10803fcc 	andi	r2,r2,255
8113b0c8:	10801920 	cmpeqi	r2,r2,100
8113b0cc:	1000051e 	bne	r2,zero,8113b0e4 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113b0d0:	e0bfff17 	ldw	r2,-4(fp)
8113b0d4:	00ffe244 	movi	r3,-119
8113b0d8:	10c00005 	stb	r3,0(r2)
        return (0);
8113b0dc:	0005883a 	mov	r2,zero
8113b0e0:	00004c06 	br	8113b214 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113b0e4:	d0a0a603 	ldbu	r2,-32104(gp)
8113b0e8:	10803fcc 	andi	r2,r2,255
8113b0ec:	10000526 	beq	r2,zero,8113b104 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113b0f0:	e0bfff17 	ldw	r2,-4(fp)
8113b0f4:	00ffe2c4 	movi	r3,-117
8113b0f8:	10c00005 	stb	r3,0(r2)
        return (0);
8113b0fc:	0005883a 	mov	r2,zero
8113b100:	00004406 	br	8113b214 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113b104:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113b108:	e0bffe17 	ldw	r2,-8(fp)
8113b10c:	10800c43 	ldbu	r2,49(r2)
8113b110:	10803fcc 	andi	r2,r2,255
8113b114:	10c00060 	cmpeqi	r3,r2,1
8113b118:	1800121e 	bne	r3,zero,8113b164 <OSTmrRemainGet+0xf4>
8113b11c:	10c00088 	cmpgei	r3,r2,2
8113b120:	1800021e 	bne	r3,zero,8113b12c <OSTmrRemainGet+0xbc>
8113b124:	10003026 	beq	r2,zero,8113b1e8 <OSTmrRemainGet+0x178>
8113b128:	00003506 	br	8113b200 <OSTmrRemainGet+0x190>
8113b12c:	10c000a0 	cmpeqi	r3,r2,2
8113b130:	1800281e 	bne	r3,zero,8113b1d4 <OSTmrRemainGet+0x164>
8113b134:	108000e0 	cmpeqi	r2,r2,3
8113b138:	10003126 	beq	r2,zero,8113b200 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113b13c:	e0bffe17 	ldw	r2,-8(fp)
8113b140:	10c00517 	ldw	r3,20(r2)
8113b144:	d0a0a817 	ldw	r2,-32096(gp)
8113b148:	1885c83a 	sub	r2,r3,r2
8113b14c:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113b150:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113b154:	e0bfff17 	ldw	r2,-4(fp)
8113b158:	10000005 	stb	zero,0(r2)
             return (remain);
8113b15c:	e0bffd17 	ldw	r2,-12(fp)
8113b160:	00002c06 	br	8113b214 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113b164:	e0bffe17 	ldw	r2,-8(fp)
8113b168:	10800c03 	ldbu	r2,48(r2)
8113b16c:	10803fcc 	andi	r2,r2,255
8113b170:	108000a0 	cmpeqi	r2,r2,2
8113b174:	10000e26 	beq	r2,zero,8113b1b0 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113b178:	e0bffe17 	ldw	r2,-8(fp)
8113b17c:	10800617 	ldw	r2,24(r2)
8113b180:	1000041e 	bne	r2,zero,8113b194 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113b184:	e0bffe17 	ldw	r2,-8(fp)
8113b188:	10800717 	ldw	r2,28(r2)
8113b18c:	e0bffd15 	stw	r2,-12(fp)
8113b190:	00000306 	br	8113b1a0 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113b194:	e0bffe17 	ldw	r2,-8(fp)
8113b198:	10800617 	ldw	r2,24(r2)
8113b19c:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113b1a0:	113bc280 	call	8113bc28 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113b1a4:	e0bfff17 	ldw	r2,-4(fp)
8113b1a8:	10000005 	stb	zero,0(r2)
                      break;
8113b1ac:	00000706 	br	8113b1cc <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113b1b0:	e0bffe17 	ldw	r2,-8(fp)
8113b1b4:	10800617 	ldw	r2,24(r2)
8113b1b8:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113b1bc:	113bc280 	call	8113bc28 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113b1c0:	e0bfff17 	ldw	r2,-4(fp)
8113b1c4:	10000005 	stb	zero,0(r2)
                      break;
8113b1c8:	0001883a 	nop
             }
             return (remain);
8113b1cc:	e0bffd17 	ldw	r2,-12(fp)
8113b1d0:	00001006 	br	8113b214 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113b1d4:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113b1d8:	e0bfff17 	ldw	r2,-4(fp)
8113b1dc:	10000005 	stb	zero,0(r2)
             return (0);
8113b1e0:	0005883a 	mov	r2,zero
8113b1e4:	00000b06 	br	8113b214 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113b1e8:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113b1ec:	e0bfff17 	ldw	r2,-4(fp)
8113b1f0:	00ffe1c4 	movi	r3,-121
8113b1f4:	10c00005 	stb	r3,0(r2)
             return (0);
8113b1f8:	0005883a 	mov	r2,zero
8113b1fc:	00000506 	br	8113b214 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113b200:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113b204:	e0bfff17 	ldw	r2,-4(fp)
8113b208:	00ffe344 	movi	r3,-115
8113b20c:	10c00005 	stb	r3,0(r2)
             return (0);
8113b210:	0005883a 	mov	r2,zero
    }
}
8113b214:	e037883a 	mov	sp,fp
8113b218:	dfc00117 	ldw	ra,4(sp)
8113b21c:	df000017 	ldw	fp,0(sp)
8113b220:	dec00204 	addi	sp,sp,8
8113b224:	f800283a 	ret

8113b228 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113b228:	defffb04 	addi	sp,sp,-20
8113b22c:	de00012e 	bgeu	sp,et,8113b234 <OSTmrStateGet+0xc>
8113b230:	003b68fa 	trap	3
8113b234:	dfc00415 	stw	ra,16(sp)
8113b238:	df000315 	stw	fp,12(sp)
8113b23c:	df000304 	addi	fp,sp,12
8113b240:	e13ffe15 	stw	r4,-8(fp)
8113b244:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113b248:	e0bfff17 	ldw	r2,-4(fp)
8113b24c:	1000021e 	bne	r2,zero,8113b258 <OSTmrStateGet+0x30>
        return (0);
8113b250:	0005883a 	mov	r2,zero
8113b254:	00002a06 	br	8113b300 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113b258:	e0bffe17 	ldw	r2,-8(fp)
8113b25c:	1000051e 	bne	r2,zero,8113b274 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113b260:	e0bfff17 	ldw	r2,-4(fp)
8113b264:	00ffe284 	movi	r3,-118
8113b268:	10c00005 	stb	r3,0(r2)
        return (0);
8113b26c:	0005883a 	mov	r2,zero
8113b270:	00002306 	br	8113b300 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113b274:	e0bffe17 	ldw	r2,-8(fp)
8113b278:	10800003 	ldbu	r2,0(r2)
8113b27c:	10803fcc 	andi	r2,r2,255
8113b280:	10801920 	cmpeqi	r2,r2,100
8113b284:	1000051e 	bne	r2,zero,8113b29c <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113b288:	e0bfff17 	ldw	r2,-4(fp)
8113b28c:	00ffe244 	movi	r3,-119
8113b290:	10c00005 	stb	r3,0(r2)
        return (0);
8113b294:	0005883a 	mov	r2,zero
8113b298:	00001906 	br	8113b300 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113b29c:	d0a0a603 	ldbu	r2,-32104(gp)
8113b2a0:	10803fcc 	andi	r2,r2,255
8113b2a4:	10000526 	beq	r2,zero,8113b2bc <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113b2a8:	e0bfff17 	ldw	r2,-4(fp)
8113b2ac:	00ffe2c4 	movi	r3,-117
8113b2b0:	10c00005 	stb	r3,0(r2)
        return (0);
8113b2b4:	0005883a 	mov	r2,zero
8113b2b8:	00001106 	br	8113b300 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113b2bc:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113b2c0:	e0bffe17 	ldw	r2,-8(fp)
8113b2c4:	10800c43 	ldbu	r2,49(r2)
8113b2c8:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113b2cc:	e0bffd03 	ldbu	r2,-12(fp)
8113b2d0:	1005883a 	mov	r2,r2
8113b2d4:	10800128 	cmpgeui	r2,r2,4
8113b2d8:	1000031e 	bne	r2,zero,8113b2e8 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113b2dc:	e0bfff17 	ldw	r2,-4(fp)
8113b2e0:	10000005 	stb	zero,0(r2)
             break;
8113b2e4:	00000406 	br	8113b2f8 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113b2e8:	e0bfff17 	ldw	r2,-4(fp)
8113b2ec:	00ffe344 	movi	r3,-115
8113b2f0:	10c00005 	stb	r3,0(r2)
             break;
8113b2f4:	0001883a 	nop
    }
    OSTmr_Unlock();
8113b2f8:	113bc280 	call	8113bc28 <OSTmr_Unlock>
    return (state);
8113b2fc:	e0bffd03 	ldbu	r2,-12(fp)
}
8113b300:	e037883a 	mov	sp,fp
8113b304:	dfc00117 	ldw	ra,4(sp)
8113b308:	df000017 	ldw	fp,0(sp)
8113b30c:	dec00204 	addi	sp,sp,8
8113b310:	f800283a 	ret

8113b314 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113b314:	defffc04 	addi	sp,sp,-16
8113b318:	de00012e 	bgeu	sp,et,8113b320 <OSTmrStart+0xc>
8113b31c:	003b68fa 	trap	3
8113b320:	dfc00315 	stw	ra,12(sp)
8113b324:	df000215 	stw	fp,8(sp)
8113b328:	df000204 	addi	fp,sp,8
8113b32c:	e13ffe15 	stw	r4,-8(fp)
8113b330:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113b334:	e0bfff17 	ldw	r2,-4(fp)
8113b338:	1000021e 	bne	r2,zero,8113b344 <OSTmrStart+0x30>
        return (OS_FALSE);
8113b33c:	0005883a 	mov	r2,zero
8113b340:	00004106 	br	8113b448 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113b344:	e0bffe17 	ldw	r2,-8(fp)
8113b348:	1000051e 	bne	r2,zero,8113b360 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113b34c:	e0bfff17 	ldw	r2,-4(fp)
8113b350:	00ffe284 	movi	r3,-118
8113b354:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b358:	0005883a 	mov	r2,zero
8113b35c:	00003a06 	br	8113b448 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113b360:	e0bffe17 	ldw	r2,-8(fp)
8113b364:	10800003 	ldbu	r2,0(r2)
8113b368:	10803fcc 	andi	r2,r2,255
8113b36c:	10801920 	cmpeqi	r2,r2,100
8113b370:	1000051e 	bne	r2,zero,8113b388 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113b374:	e0bfff17 	ldw	r2,-4(fp)
8113b378:	00ffe244 	movi	r3,-119
8113b37c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b380:	0005883a 	mov	r2,zero
8113b384:	00003006 	br	8113b448 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113b388:	d0a0a603 	ldbu	r2,-32104(gp)
8113b38c:	10803fcc 	andi	r2,r2,255
8113b390:	10000526 	beq	r2,zero,8113b3a8 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113b394:	e0bfff17 	ldw	r2,-4(fp)
8113b398:	00ffe2c4 	movi	r3,-117
8113b39c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b3a0:	0005883a 	mov	r2,zero
8113b3a4:	00002806 	br	8113b448 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113b3a8:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113b3ac:	e0bffe17 	ldw	r2,-8(fp)
8113b3b0:	10800c43 	ldbu	r2,49(r2)
8113b3b4:	10803fcc 	andi	r2,r2,255
8113b3b8:	10c000c8 	cmpgei	r3,r2,3
8113b3bc:	1800031e 	bne	r3,zero,8113b3cc <OSTmrStart+0xb8>
8113b3c0:	00800e16 	blt	zero,r2,8113b3fc <OSTmrStart+0xe8>
8113b3c4:	10001526 	beq	r2,zero,8113b41c <OSTmrStart+0x108>
8113b3c8:	00001a06 	br	8113b434 <OSTmrStart+0x120>
8113b3cc:	108000e0 	cmpeqi	r2,r2,3
8113b3d0:	10001826 	beq	r2,zero,8113b434 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113b3d4:	e13ffe17 	ldw	r4,-8(fp)
8113b3d8:	113bae80 	call	8113bae8 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113b3dc:	000b883a 	mov	r5,zero
8113b3e0:	e13ffe17 	ldw	r4,-8(fp)
8113b3e4:	113b9980 	call	8113b998 <OSTmr_Link>
             OSTmr_Unlock();
8113b3e8:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113b3ec:	e0bfff17 	ldw	r2,-4(fp)
8113b3f0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113b3f4:	00800044 	movi	r2,1
8113b3f8:	00001306 	br	8113b448 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113b3fc:	000b883a 	mov	r5,zero
8113b400:	e13ffe17 	ldw	r4,-8(fp)
8113b404:	113b9980 	call	8113b998 <OSTmr_Link>
             OSTmr_Unlock();
8113b408:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113b40c:	e0bfff17 	ldw	r2,-4(fp)
8113b410:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113b414:	00800044 	movi	r2,1
8113b418:	00000b06 	br	8113b448 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113b41c:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113b420:	e0bfff17 	ldw	r2,-4(fp)
8113b424:	00ffe1c4 	movi	r3,-121
8113b428:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113b42c:	0005883a 	mov	r2,zero
8113b430:	00000506 	br	8113b448 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113b434:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113b438:	e0bfff17 	ldw	r2,-4(fp)
8113b43c:	00ffe344 	movi	r3,-115
8113b440:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113b444:	0005883a 	mov	r2,zero
    }
}
8113b448:	e037883a 	mov	sp,fp
8113b44c:	dfc00117 	ldw	ra,4(sp)
8113b450:	df000017 	ldw	fp,0(sp)
8113b454:	dec00204 	addi	sp,sp,8
8113b458:	f800283a 	ret

8113b45c <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113b45c:	defff904 	addi	sp,sp,-28
8113b460:	de00012e 	bgeu	sp,et,8113b468 <OSTmrStop+0xc>
8113b464:	003b68fa 	trap	3
8113b468:	dfc00615 	stw	ra,24(sp)
8113b46c:	df000515 	stw	fp,20(sp)
8113b470:	df000504 	addi	fp,sp,20
8113b474:	e13ffc15 	stw	r4,-16(fp)
8113b478:	2805883a 	mov	r2,r5
8113b47c:	e1bffe15 	stw	r6,-8(fp)
8113b480:	e1ffff15 	stw	r7,-4(fp)
8113b484:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113b488:	e0bfff17 	ldw	r2,-4(fp)
8113b48c:	1000021e 	bne	r2,zero,8113b498 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113b490:	0005883a 	mov	r2,zero
8113b494:	00006606 	br	8113b630 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113b498:	e0bffc17 	ldw	r2,-16(fp)
8113b49c:	1000051e 	bne	r2,zero,8113b4b4 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113b4a0:	e0bfff17 	ldw	r2,-4(fp)
8113b4a4:	00ffe284 	movi	r3,-118
8113b4a8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b4ac:	0005883a 	mov	r2,zero
8113b4b0:	00005f06 	br	8113b630 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113b4b4:	e0bffc17 	ldw	r2,-16(fp)
8113b4b8:	10800003 	ldbu	r2,0(r2)
8113b4bc:	10803fcc 	andi	r2,r2,255
8113b4c0:	10801920 	cmpeqi	r2,r2,100
8113b4c4:	1000051e 	bne	r2,zero,8113b4dc <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113b4c8:	e0bfff17 	ldw	r2,-4(fp)
8113b4cc:	00ffe244 	movi	r3,-119
8113b4d0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b4d4:	0005883a 	mov	r2,zero
8113b4d8:	00005506 	br	8113b630 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113b4dc:	d0a0a603 	ldbu	r2,-32104(gp)
8113b4e0:	10803fcc 	andi	r2,r2,255
8113b4e4:	10000526 	beq	r2,zero,8113b4fc <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113b4e8:	e0bfff17 	ldw	r2,-4(fp)
8113b4ec:	00ffe2c4 	movi	r3,-117
8113b4f0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b4f4:	0005883a 	mov	r2,zero
8113b4f8:	00004d06 	br	8113b630 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113b4fc:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113b500:	e0bffc17 	ldw	r2,-16(fp)
8113b504:	10800c43 	ldbu	r2,49(r2)
8113b508:	10803fcc 	andi	r2,r2,255
8113b50c:	10c000c8 	cmpgei	r3,r2,3
8113b510:	1800031e 	bne	r3,zero,8113b520 <OSTmrStop+0xc4>
8113b514:	00803516 	blt	zero,r2,8113b5ec <OSTmrStop+0x190>
8113b518:	10003a26 	beq	r2,zero,8113b604 <OSTmrStop+0x1a8>
8113b51c:	00003f06 	br	8113b61c <OSTmrStop+0x1c0>
8113b520:	108000e0 	cmpeqi	r2,r2,3
8113b524:	10003d26 	beq	r2,zero,8113b61c <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113b528:	e13ffc17 	ldw	r4,-16(fp)
8113b52c:	113bae80 	call	8113bae8 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113b530:	e0bfff17 	ldw	r2,-4(fp)
8113b534:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113b538:	e0bffd03 	ldbu	r2,-12(fp)
8113b53c:	10c000e0 	cmpeqi	r3,r2,3
8113b540:	1800041e 	bne	r3,zero,8113b554 <OSTmrStop+0xf8>
8113b544:	10c00120 	cmpeqi	r3,r2,4
8113b548:	1800121e 	bne	r3,zero,8113b594 <OSTmrStop+0x138>
8113b54c:	10002326 	beq	r2,zero,8113b5dc <OSTmrStop+0x180>
8113b550:	00001e06 	br	8113b5cc <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113b554:	e0bffc17 	ldw	r2,-16(fp)
8113b558:	10800117 	ldw	r2,4(r2)
8113b55c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113b560:	e0bffb17 	ldw	r2,-20(fp)
8113b564:	10000726 	beq	r2,zero,8113b584 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113b568:	e0bffc17 	ldw	r2,-16(fp)
8113b56c:	10c00217 	ldw	r3,8(r2)
8113b570:	e0bffb17 	ldw	r2,-20(fp)
8113b574:	180b883a 	mov	r5,r3
8113b578:	e13ffc17 	ldw	r4,-16(fp)
8113b57c:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113b580:	00001706 	br	8113b5e0 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113b584:	e0bfff17 	ldw	r2,-4(fp)
8113b588:	00ffe3c4 	movi	r3,-113
8113b58c:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113b590:	00001306 	br	8113b5e0 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113b594:	e0bffc17 	ldw	r2,-16(fp)
8113b598:	10800117 	ldw	r2,4(r2)
8113b59c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113b5a0:	e0bffb17 	ldw	r2,-20(fp)
8113b5a4:	10000526 	beq	r2,zero,8113b5bc <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113b5a8:	e0bffb17 	ldw	r2,-20(fp)
8113b5ac:	e17ffe17 	ldw	r5,-8(fp)
8113b5b0:	e13ffc17 	ldw	r4,-16(fp)
8113b5b4:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113b5b8:	00000906 	br	8113b5e0 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113b5bc:	e0bfff17 	ldw	r2,-4(fp)
8113b5c0:	00ffe3c4 	movi	r3,-113
8113b5c4:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113b5c8:	00000506 	br	8113b5e0 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113b5cc:	e0bfff17 	ldw	r2,-4(fp)
8113b5d0:	00ffe104 	movi	r3,-124
8113b5d4:	10c00005 	stb	r3,0(r2)
                     break;
8113b5d8:	00000106 	br	8113b5e0 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113b5dc:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113b5e0:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             return (OS_TRUE);
8113b5e4:	00800044 	movi	r2,1
8113b5e8:	00001106 	br	8113b630 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113b5ec:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113b5f0:	e0bfff17 	ldw	r2,-4(fp)
8113b5f4:	00ffe384 	movi	r3,-114
8113b5f8:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113b5fc:	00800044 	movi	r2,1
8113b600:	00000b06 	br	8113b630 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113b604:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113b608:	e0bfff17 	ldw	r2,-4(fp)
8113b60c:	00ffe1c4 	movi	r3,-121
8113b610:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113b614:	0005883a 	mov	r2,zero
8113b618:	00000506 	br	8113b630 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113b61c:	113bc280 	call	8113bc28 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113b620:	e0bfff17 	ldw	r2,-4(fp)
8113b624:	00ffe344 	movi	r3,-115
8113b628:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113b62c:	0005883a 	mov	r2,zero
    }
}
8113b630:	e037883a 	mov	sp,fp
8113b634:	dfc00117 	ldw	ra,4(sp)
8113b638:	df000017 	ldw	fp,0(sp)
8113b63c:	dec00204 	addi	sp,sp,8
8113b640:	f800283a 	ret

8113b644 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113b644:	defffd04 	addi	sp,sp,-12
8113b648:	de00012e 	bgeu	sp,et,8113b650 <OSTmrSignal+0xc>
8113b64c:	003b68fa 	trap	3
8113b650:	dfc00215 	stw	ra,8(sp)
8113b654:	df000115 	stw	fp,4(sp)
8113b658:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113b65c:	d0a09517 	ldw	r2,-32172(gp)
8113b660:	1009883a 	mov	r4,r2
8113b664:	1138dc40 	call	81138dc4 <OSSemPost>
8113b668:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113b66c:	e0bfff03 	ldbu	r2,-4(fp)
}
8113b670:	e037883a 	mov	sp,fp
8113b674:	dfc00117 	ldw	ra,4(sp)
8113b678:	df000017 	ldw	fp,0(sp)
8113b67c:	dec00204 	addi	sp,sp,8
8113b680:	f800283a 	ret

8113b684 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113b684:	defffe04 	addi	sp,sp,-8
8113b688:	de00012e 	bgeu	sp,et,8113b690 <OSTmr_Alloc+0xc>
8113b68c:	003b68fa 	trap	3
8113b690:	df000115 	stw	fp,4(sp)
8113b694:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113b698:	d0a09317 	ldw	r2,-32180(gp)
8113b69c:	1000021e 	bne	r2,zero,8113b6a8 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113b6a0:	0005883a 	mov	r2,zero
8113b6a4:	00001006 	br	8113b6e8 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113b6a8:	d0a09317 	ldw	r2,-32180(gp)
8113b6ac:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113b6b0:	e0bfff17 	ldw	r2,-4(fp)
8113b6b4:	10800317 	ldw	r2,12(r2)
8113b6b8:	d0a09315 	stw	r2,-32180(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113b6bc:	e0bfff17 	ldw	r2,-4(fp)
8113b6c0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113b6c4:	e0bfff17 	ldw	r2,-4(fp)
8113b6c8:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113b6cc:	d0a0980b 	ldhu	r2,-32160(gp)
8113b6d0:	10800044 	addi	r2,r2,1
8113b6d4:	d0a0980d 	sth	r2,-32160(gp)
    OSTmrFree--;
8113b6d8:	d0a09c0b 	ldhu	r2,-32144(gp)
8113b6dc:	10bfffc4 	addi	r2,r2,-1
8113b6e0:	d0a09c0d 	sth	r2,-32144(gp)
    return (ptmr);
8113b6e4:	e0bfff17 	ldw	r2,-4(fp)
}
8113b6e8:	e037883a 	mov	sp,fp
8113b6ec:	df000017 	ldw	fp,0(sp)
8113b6f0:	dec00104 	addi	sp,sp,4
8113b6f4:	f800283a 	ret

8113b6f8 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113b6f8:	defffe04 	addi	sp,sp,-8
8113b6fc:	de00012e 	bgeu	sp,et,8113b704 <OSTmr_Free+0xc>
8113b700:	003b68fa 	trap	3
8113b704:	df000115 	stw	fp,4(sp)
8113b708:	df000104 	addi	fp,sp,4
8113b70c:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113b710:	e0bfff17 	ldw	r2,-4(fp)
8113b714:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113b718:	e0bfff17 	ldw	r2,-4(fp)
8113b71c:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113b720:	e0bfff17 	ldw	r2,-4(fp)
8113b724:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113b728:	e0bfff17 	ldw	r2,-4(fp)
8113b72c:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113b730:	e0bfff17 	ldw	r2,-4(fp)
8113b734:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113b738:	e0bfff17 	ldw	r2,-4(fp)
8113b73c:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113b740:	e0bfff17 	ldw	r2,-4(fp)
8113b744:	00c00fc4 	movi	r3,63
8113b748:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113b74c:	e0bfff17 	ldw	r2,-4(fp)
8113b750:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113b754:	e0bfff17 	ldw	r2,-4(fp)
8113b758:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113b75c:	d0e09317 	ldw	r3,-32180(gp)
8113b760:	e0bfff17 	ldw	r2,-4(fp)
8113b764:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113b768:	e0bfff17 	ldw	r2,-4(fp)
8113b76c:	d0a09315 	stw	r2,-32180(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113b770:	d0a0980b 	ldhu	r2,-32160(gp)
8113b774:	10bfffc4 	addi	r2,r2,-1
8113b778:	d0a0980d 	sth	r2,-32160(gp)
    OSTmrFree++;
8113b77c:	d0a09c0b 	ldhu	r2,-32144(gp)
8113b780:	10800044 	addi	r2,r2,1
8113b784:	d0a09c0d 	sth	r2,-32144(gp)
}
8113b788:	0001883a 	nop
8113b78c:	e037883a 	mov	sp,fp
8113b790:	df000017 	ldw	fp,0(sp)
8113b794:	dec00104 	addi	sp,sp,4
8113b798:	f800283a 	ret

8113b79c <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113b79c:	defffa04 	addi	sp,sp,-24
8113b7a0:	de00012e 	bgeu	sp,et,8113b7a8 <OSTmr_Init+0xc>
8113b7a4:	003b68fa 	trap	3
8113b7a8:	dfc00515 	stw	ra,20(sp)
8113b7ac:	df000415 	stw	fp,16(sp)
8113b7b0:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113b7b4:	01406804 	movi	r5,416
8113b7b8:	012045b4 	movhi	r4,33046
8113b7bc:	21002304 	addi	r4,r4,140
8113b7c0:	1133ac00 	call	81133ac0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113b7c4:	01400404 	movi	r5,16
8113b7c8:	012045b4 	movhi	r4,33046
8113b7cc:	213ebf04 	addi	r4,r4,-1284
8113b7d0:	1133ac00 	call	81133ac0 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113b7d4:	00a045b4 	movhi	r2,33046
8113b7d8:	10802304 	addi	r2,r2,140
8113b7dc:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113b7e0:	00a045b4 	movhi	r2,33046
8113b7e4:	10803004 	addi	r2,r2,192
8113b7e8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113b7ec:	e03ffc0d 	sth	zero,-16(fp)
8113b7f0:	00001606 	br	8113b84c <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113b7f4:	e0bffd17 	ldw	r2,-12(fp)
8113b7f8:	00c01904 	movi	r3,100
8113b7fc:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113b800:	e0bffd17 	ldw	r2,-12(fp)
8113b804:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113b808:	e0bffd17 	ldw	r2,-12(fp)
8113b80c:	e0fffe17 	ldw	r3,-8(fp)
8113b810:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113b814:	e0bffd17 	ldw	r2,-12(fp)
8113b818:	00c00fc4 	movi	r3,63
8113b81c:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113b820:	e0bffd17 	ldw	r2,-12(fp)
8113b824:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113b828:	e0bffd17 	ldw	r2,-12(fp)
8113b82c:	10800d04 	addi	r2,r2,52
8113b830:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113b834:	e0bffe17 	ldw	r2,-8(fp)
8113b838:	10800d04 	addi	r2,r2,52
8113b83c:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113b840:	e0bffc0b 	ldhu	r2,-16(fp)
8113b844:	10800044 	addi	r2,r2,1
8113b848:	e0bffc0d 	sth	r2,-16(fp)
8113b84c:	e0bffc0b 	ldhu	r2,-16(fp)
8113b850:	108001f0 	cmpltui	r2,r2,7
8113b854:	103fe71e 	bne	r2,zero,8113b7f4 <__reset+0xfb11b7f4>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113b858:	e0bffd17 	ldw	r2,-12(fp)
8113b85c:	00c01904 	movi	r3,100
8113b860:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113b864:	e0bffd17 	ldw	r2,-12(fp)
8113b868:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113b86c:	e0bffd17 	ldw	r2,-12(fp)
8113b870:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113b874:	e0bffd17 	ldw	r2,-12(fp)
8113b878:	00c00fc4 	movi	r3,63
8113b87c:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113b880:	e0bffd17 	ldw	r2,-12(fp)
8113b884:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113b888:	d020a815 	stw	zero,-32096(gp)
    OSTmrUsed           = 0;
8113b88c:	d020980d 	sth	zero,-32160(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113b890:	00800204 	movi	r2,8
8113b894:	d0a09c0d 	sth	r2,-32144(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113b898:	00a045b4 	movhi	r2,33046
8113b89c:	10802304 	addi	r2,r2,140
8113b8a0:	d0a09315 	stw	r2,-32180(gp)
    OSTmrSem            = OSSemCreate(1);
8113b8a4:	01000044 	movi	r4,1
8113b8a8:	11387140 	call	81138714 <OSSemCreate>
8113b8ac:	d0a0aa15 	stw	r2,-32088(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113b8b0:	0009883a 	mov	r4,zero
8113b8b4:	11387140 	call	81138714 <OSSemCreate>
8113b8b8:	d0a09515 	stw	r2,-32172(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113b8bc:	d0a0aa17 	ldw	r2,-32088(gp)
8113b8c0:	e0ffff04 	addi	r3,fp,-4
8113b8c4:	180d883a 	mov	r6,r3
8113b8c8:	01604574 	movhi	r5,33045
8113b8cc:	29685504 	addi	r5,r5,-24236
8113b8d0:	1009883a 	mov	r4,r2
8113b8d4:	113231c0 	call	8113231c <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113b8d8:	d0a09517 	ldw	r2,-32172(gp)
8113b8dc:	e0ffff04 	addi	r3,fp,-4
8113b8e0:	180d883a 	mov	r6,r3
8113b8e4:	01604574 	movhi	r5,33045
8113b8e8:	29685a04 	addi	r5,r5,-24216
8113b8ec:	1009883a 	mov	r4,r2
8113b8f0:	113231c0 	call	8113231c <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113b8f4:	113b9100 	call	8113b910 <OSTmr_InitTask>
}
8113b8f8:	0001883a 	nop
8113b8fc:	e037883a 	mov	sp,fp
8113b900:	dfc00117 	ldw	ra,4(sp)
8113b904:	df000017 	ldw	fp,0(sp)
8113b908:	dec00204 	addi	sp,sp,8
8113b90c:	f800283a 	ret

8113b910 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113b910:	defff804 	addi	sp,sp,-32
8113b914:	de00012e 	bgeu	sp,et,8113b91c <OSTmr_InitTask+0xc>
8113b918:	003b68fa 	trap	3
8113b91c:	dfc00715 	stw	ra,28(sp)
8113b920:	df000615 	stw	fp,24(sp)
8113b924:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113b928:	008000c4 	movi	r2,3
8113b92c:	d8800415 	stw	r2,16(sp)
8113b930:	d8000315 	stw	zero,12(sp)
8113b934:	00808004 	movi	r2,512
8113b938:	d8800215 	stw	r2,8(sp)
8113b93c:	00a045b4 	movhi	r2,33046
8113b940:	1087f704 	addi	r2,r2,8156
8113b944:	d8800115 	stw	r2,4(sp)
8113b948:	00bfff54 	movui	r2,65533
8113b94c:	d8800015 	stw	r2,0(sp)
8113b950:	01c00744 	movi	r7,29
8113b954:	01a045b4 	movhi	r6,33046
8113b958:	3189f604 	addi	r6,r6,10200
8113b95c:	000b883a 	mov	r5,zero
8113b960:	01204534 	movhi	r4,33044
8113b964:	212f1904 	addi	r4,r4,-17308
8113b968:	11395f40 	call	811395f4 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113b96c:	e1bfff04 	addi	r6,fp,-4
8113b970:	01604574 	movhi	r5,33045
8113b974:	29685f04 	addi	r5,r5,-24196
8113b978:	01000744 	movi	r4,29
8113b97c:	1139e240 	call	81139e24 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113b980:	0001883a 	nop
8113b984:	e037883a 	mov	sp,fp
8113b988:	dfc00117 	ldw	ra,4(sp)
8113b98c:	df000017 	ldw	fp,0(sp)
8113b990:	dec00204 	addi	sp,sp,8
8113b994:	f800283a 	ret

8113b998 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113b998:	defffa04 	addi	sp,sp,-24
8113b99c:	de00012e 	bgeu	sp,et,8113b9a4 <OSTmr_Link+0xc>
8113b9a0:	003b68fa 	trap	3
8113b9a4:	df000515 	stw	fp,20(sp)
8113b9a8:	df000504 	addi	fp,sp,20
8113b9ac:	e13ffe15 	stw	r4,-8(fp)
8113b9b0:	2805883a 	mov	r2,r5
8113b9b4:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113b9b8:	e0bffe17 	ldw	r2,-8(fp)
8113b9bc:	00c000c4 	movi	r3,3
8113b9c0:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113b9c4:	e0bfff03 	ldbu	r2,-4(fp)
8113b9c8:	10800058 	cmpnei	r2,r2,1
8113b9cc:	1000071e 	bne	r2,zero,8113b9ec <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113b9d0:	e0bffe17 	ldw	r2,-8(fp)
8113b9d4:	10c00717 	ldw	r3,28(r2)
8113b9d8:	d0a0a817 	ldw	r2,-32096(gp)
8113b9dc:	1887883a 	add	r3,r3,r2
8113b9e0:	e0bffe17 	ldw	r2,-8(fp)
8113b9e4:	10c00515 	stw	r3,20(r2)
8113b9e8:	00001006 	br	8113ba2c <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113b9ec:	e0bffe17 	ldw	r2,-8(fp)
8113b9f0:	10800617 	ldw	r2,24(r2)
8113b9f4:	1000071e 	bne	r2,zero,8113ba14 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113b9f8:	e0bffe17 	ldw	r2,-8(fp)
8113b9fc:	10c00717 	ldw	r3,28(r2)
8113ba00:	d0a0a817 	ldw	r2,-32096(gp)
8113ba04:	1887883a 	add	r3,r3,r2
8113ba08:	e0bffe17 	ldw	r2,-8(fp)
8113ba0c:	10c00515 	stw	r3,20(r2)
8113ba10:	00000606 	br	8113ba2c <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113ba14:	e0bffe17 	ldw	r2,-8(fp)
8113ba18:	10c00617 	ldw	r3,24(r2)
8113ba1c:	d0a0a817 	ldw	r2,-32096(gp)
8113ba20:	1887883a 	add	r3,r3,r2
8113ba24:	e0bffe17 	ldw	r2,-8(fp)
8113ba28:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113ba2c:	e0bffe17 	ldw	r2,-8(fp)
8113ba30:	10800517 	ldw	r2,20(r2)
8113ba34:	1080004c 	andi	r2,r2,1
8113ba38:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113ba3c:	e0bffb0b 	ldhu	r2,-20(fp)
8113ba40:	100690fa 	slli	r3,r2,3
8113ba44:	00a045b4 	movhi	r2,33046
8113ba48:	10bebf04 	addi	r2,r2,-1284
8113ba4c:	1885883a 	add	r2,r3,r2
8113ba50:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113ba54:	e0bffc17 	ldw	r2,-16(fp)
8113ba58:	10800017 	ldw	r2,0(r2)
8113ba5c:	1000091e 	bne	r2,zero,8113ba84 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113ba60:	e0bffc17 	ldw	r2,-16(fp)
8113ba64:	e0fffe17 	ldw	r3,-8(fp)
8113ba68:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113ba6c:	e0bffe17 	ldw	r2,-8(fp)
8113ba70:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113ba74:	e0bffc17 	ldw	r2,-16(fp)
8113ba78:	00c00044 	movi	r3,1
8113ba7c:	10c0010d 	sth	r3,4(r2)
8113ba80:	00001206 	br	8113bacc <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113ba84:	e0bffc17 	ldw	r2,-16(fp)
8113ba88:	10800017 	ldw	r2,0(r2)
8113ba8c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113ba90:	e0bffc17 	ldw	r2,-16(fp)
8113ba94:	e0fffe17 	ldw	r3,-8(fp)
8113ba98:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113ba9c:	e0bffe17 	ldw	r2,-8(fp)
8113baa0:	e0fffd17 	ldw	r3,-12(fp)
8113baa4:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113baa8:	e0bffd17 	ldw	r2,-12(fp)
8113baac:	e0fffe17 	ldw	r3,-8(fp)
8113bab0:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113bab4:	e0bffc17 	ldw	r2,-16(fp)
8113bab8:	1080010b 	ldhu	r2,4(r2)
8113babc:	10800044 	addi	r2,r2,1
8113bac0:	1007883a 	mov	r3,r2
8113bac4:	e0bffc17 	ldw	r2,-16(fp)
8113bac8:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113bacc:	e0bffe17 	ldw	r2,-8(fp)
8113bad0:	10000415 	stw	zero,16(r2)
}
8113bad4:	0001883a 	nop
8113bad8:	e037883a 	mov	sp,fp
8113badc:	df000017 	ldw	fp,0(sp)
8113bae0:	dec00104 	addi	sp,sp,4
8113bae4:	f800283a 	ret

8113bae8 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113bae8:	defffa04 	addi	sp,sp,-24
8113baec:	de00012e 	bgeu	sp,et,8113baf4 <OSTmr_Unlink+0xc>
8113baf0:	003b68fa 	trap	3
8113baf4:	df000515 	stw	fp,20(sp)
8113baf8:	df000504 	addi	fp,sp,20
8113bafc:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113bb00:	e0bfff17 	ldw	r2,-4(fp)
8113bb04:	10800517 	ldw	r2,20(r2)
8113bb08:	1080004c 	andi	r2,r2,1
8113bb0c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113bb10:	e0bffb0b 	ldhu	r2,-20(fp)
8113bb14:	100690fa 	slli	r3,r2,3
8113bb18:	00a045b4 	movhi	r2,33046
8113bb1c:	10bebf04 	addi	r2,r2,-1284
8113bb20:	1885883a 	add	r2,r3,r2
8113bb24:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113bb28:	e0bffc17 	ldw	r2,-16(fp)
8113bb2c:	10c00017 	ldw	r3,0(r2)
8113bb30:	e0bfff17 	ldw	r2,-4(fp)
8113bb34:	18800b1e 	bne	r3,r2,8113bb64 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113bb38:	e0bfff17 	ldw	r2,-4(fp)
8113bb3c:	10800317 	ldw	r2,12(r2)
8113bb40:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113bb44:	e0bffc17 	ldw	r2,-16(fp)
8113bb48:	e0fffd17 	ldw	r3,-12(fp)
8113bb4c:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113bb50:	e0bffd17 	ldw	r2,-12(fp)
8113bb54:	10001126 	beq	r2,zero,8113bb9c <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113bb58:	e0bffd17 	ldw	r2,-12(fp)
8113bb5c:	10000415 	stw	zero,16(r2)
8113bb60:	00000e06 	br	8113bb9c <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113bb64:	e0bfff17 	ldw	r2,-4(fp)
8113bb68:	10800417 	ldw	r2,16(r2)
8113bb6c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113bb70:	e0bfff17 	ldw	r2,-4(fp)
8113bb74:	10800317 	ldw	r2,12(r2)
8113bb78:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113bb7c:	e0bffd17 	ldw	r2,-12(fp)
8113bb80:	e0fffe17 	ldw	r3,-8(fp)
8113bb84:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113bb88:	e0bffe17 	ldw	r2,-8(fp)
8113bb8c:	10000326 	beq	r2,zero,8113bb9c <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113bb90:	e0bffe17 	ldw	r2,-8(fp)
8113bb94:	e0fffd17 	ldw	r3,-12(fp)
8113bb98:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113bb9c:	e0bfff17 	ldw	r2,-4(fp)
8113bba0:	00c00044 	movi	r3,1
8113bba4:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113bba8:	e0bfff17 	ldw	r2,-4(fp)
8113bbac:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113bbb0:	e0bfff17 	ldw	r2,-4(fp)
8113bbb4:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113bbb8:	e0bffc17 	ldw	r2,-16(fp)
8113bbbc:	1080010b 	ldhu	r2,4(r2)
8113bbc0:	10bfffc4 	addi	r2,r2,-1
8113bbc4:	1007883a 	mov	r3,r2
8113bbc8:	e0bffc17 	ldw	r2,-16(fp)
8113bbcc:	10c0010d 	sth	r3,4(r2)
}
8113bbd0:	0001883a 	nop
8113bbd4:	e037883a 	mov	sp,fp
8113bbd8:	df000017 	ldw	fp,0(sp)
8113bbdc:	dec00104 	addi	sp,sp,4
8113bbe0:	f800283a 	ret

8113bbe4 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113bbe4:	defffd04 	addi	sp,sp,-12
8113bbe8:	de00012e 	bgeu	sp,et,8113bbf0 <OSTmr_Lock+0xc>
8113bbec:	003b68fa 	trap	3
8113bbf0:	dfc00215 	stw	ra,8(sp)
8113bbf4:	df000115 	stw	fp,4(sp)
8113bbf8:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113bbfc:	d0a0aa17 	ldw	r2,-32088(gp)
8113bc00:	e1bfff04 	addi	r6,fp,-4
8113bc04:	000b883a 	mov	r5,zero
8113bc08:	1009883a 	mov	r4,r2
8113bc0c:	1138a3c0 	call	81138a3c <OSSemPend>
    (void)err;
}
8113bc10:	0001883a 	nop
8113bc14:	e037883a 	mov	sp,fp
8113bc18:	dfc00117 	ldw	ra,4(sp)
8113bc1c:	df000017 	ldw	fp,0(sp)
8113bc20:	dec00204 	addi	sp,sp,8
8113bc24:	f800283a 	ret

8113bc28 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113bc28:	defffe04 	addi	sp,sp,-8
8113bc2c:	de00012e 	bgeu	sp,et,8113bc34 <OSTmr_Unlock+0xc>
8113bc30:	003b68fa 	trap	3
8113bc34:	dfc00115 	stw	ra,4(sp)
8113bc38:	df000015 	stw	fp,0(sp)
8113bc3c:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113bc40:	d0a0aa17 	ldw	r2,-32088(gp)
8113bc44:	1009883a 	mov	r4,r2
8113bc48:	1138dc40 	call	81138dc4 <OSSemPost>
}
8113bc4c:	0001883a 	nop
8113bc50:	e037883a 	mov	sp,fp
8113bc54:	dfc00117 	ldw	ra,4(sp)
8113bc58:	df000017 	ldw	fp,0(sp)
8113bc5c:	dec00204 	addi	sp,sp,8
8113bc60:	f800283a 	ret

8113bc64 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113bc64:	defff704 	addi	sp,sp,-36
8113bc68:	de00012e 	bgeu	sp,et,8113bc70 <OSTmr_Task+0xc>
8113bc6c:	003b68fa 	trap	3
8113bc70:	dfc00815 	stw	ra,32(sp)
8113bc74:	df000715 	stw	fp,28(sp)
8113bc78:	df000704 	addi	fp,sp,28
8113bc7c:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113bc80:	d0a09517 	ldw	r2,-32172(gp)
8113bc84:	e0fffe04 	addi	r3,fp,-8
8113bc88:	180d883a 	mov	r6,r3
8113bc8c:	000b883a 	mov	r5,zero
8113bc90:	1009883a 	mov	r4,r2
8113bc94:	1138a3c0 	call	81138a3c <OSSemPend>
        OSTmr_Lock();
8113bc98:	113bbe40 	call	8113bbe4 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113bc9c:	d0a0a817 	ldw	r2,-32096(gp)
8113bca0:	10800044 	addi	r2,r2,1
8113bca4:	d0a0a815 	stw	r2,-32096(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113bca8:	d0a0a817 	ldw	r2,-32096(gp)
8113bcac:	1080004c 	andi	r2,r2,1
8113bcb0:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113bcb4:	e0bffa0b 	ldhu	r2,-24(fp)
8113bcb8:	100690fa 	slli	r3,r2,3
8113bcbc:	00a045b4 	movhi	r2,33046
8113bcc0:	10bebf04 	addi	r2,r2,-1284
8113bcc4:	1885883a 	add	r2,r3,r2
8113bcc8:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113bccc:	e0bffb17 	ldw	r2,-20(fp)
8113bcd0:	10800017 	ldw	r2,0(r2)
8113bcd4:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113bcd8:	00002206 	br	8113bd64 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113bcdc:	e0bff917 	ldw	r2,-28(fp)
8113bce0:	10800317 	ldw	r2,12(r2)
8113bce4:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113bce8:	e0bff917 	ldw	r2,-28(fp)
8113bcec:	10c00517 	ldw	r3,20(r2)
8113bcf0:	d0a0a817 	ldw	r2,-32096(gp)
8113bcf4:	1880191e 	bne	r3,r2,8113bd5c <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113bcf8:	e0bff917 	ldw	r2,-28(fp)
8113bcfc:	10800117 	ldw	r2,4(r2)
8113bd00:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113bd04:	e0bffd17 	ldw	r2,-12(fp)
8113bd08:	10000626 	beq	r2,zero,8113bd24 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113bd0c:	e0bff917 	ldw	r2,-28(fp)
8113bd10:	10c00217 	ldw	r3,8(r2)
8113bd14:	e0bffd17 	ldw	r2,-12(fp)
8113bd18:	180b883a 	mov	r5,r3
8113bd1c:	e13ff917 	ldw	r4,-28(fp)
8113bd20:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113bd24:	e13ff917 	ldw	r4,-28(fp)
8113bd28:	113bae80 	call	8113bae8 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113bd2c:	e0bff917 	ldw	r2,-28(fp)
8113bd30:	10800c03 	ldbu	r2,48(r2)
8113bd34:	10803fcc 	andi	r2,r2,255
8113bd38:	10800098 	cmpnei	r2,r2,2
8113bd3c:	1000041e 	bne	r2,zero,8113bd50 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113bd40:	01400044 	movi	r5,1
8113bd44:	e13ff917 	ldw	r4,-28(fp)
8113bd48:	113b9980 	call	8113b998 <OSTmr_Link>
8113bd4c:	00000306 	br	8113bd5c <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113bd50:	e0bff917 	ldw	r2,-28(fp)
8113bd54:	00c00084 	movi	r3,2
8113bd58:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113bd5c:	e0bffc17 	ldw	r2,-16(fp)
8113bd60:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113bd64:	e0bff917 	ldw	r2,-28(fp)
8113bd68:	103fdc1e 	bne	r2,zero,8113bcdc <__reset+0xfb11bcdc>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113bd6c:	113bc280 	call	8113bc28 <OSTmr_Unlock>
    }
8113bd70:	003fc306 	br	8113bc80 <__reset+0xfb11bc80>

8113bd74 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113bd74:	defffd04 	addi	sp,sp,-12
8113bd78:	de00012e 	bgeu	sp,et,8113bd80 <alt_dev_reg+0xc>
8113bd7c:	003b68fa 	trap	3
8113bd80:	dfc00215 	stw	ra,8(sp)
8113bd84:	df000115 	stw	fp,4(sp)
8113bd88:	df000104 	addi	fp,sp,4
8113bd8c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113bd90:	d1600d04 	addi	r5,gp,-32716
8113bd94:	e13fff17 	ldw	r4,-4(fp)
8113bd98:	11440140 	call	81144014 <alt_dev_llist_insert>
}
8113bd9c:	e037883a 	mov	sp,fp
8113bda0:	dfc00117 	ldw	ra,4(sp)
8113bda4:	df000017 	ldw	fp,0(sp)
8113bda8:	dec00204 	addi	sp,sp,8
8113bdac:	f800283a 	ret

8113bdb0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113bdb0:	defffd04 	addi	sp,sp,-12
8113bdb4:	de00012e 	bgeu	sp,et,8113bdbc <alt_irq_init+0xc>
8113bdb8:	003b68fa 	trap	3
8113bdbc:	dfc00215 	stw	ra,8(sp)
8113bdc0:	df000115 	stw	fp,4(sp)
8113bdc4:	df000104 	addi	fp,sp,4
8113bdc8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113bdcc:	11449dc0 	call	811449dc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113bdd0:	00800044 	movi	r2,1
8113bdd4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113bdd8:	0001883a 	nop
8113bddc:	e037883a 	mov	sp,fp
8113bde0:	dfc00117 	ldw	ra,4(sp)
8113bde4:	df000017 	ldw	fp,0(sp)
8113bde8:	dec00204 	addi	sp,sp,8
8113bdec:	f800283a 	ret

8113bdf0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113bdf0:	defffe04 	addi	sp,sp,-8
8113bdf4:	de00012e 	bgeu	sp,et,8113bdfc <alt_sys_init+0xc>
8113bdf8:	003b68fa 	trap	3
8113bdfc:	dfc00115 	stw	ra,4(sp)
8113be00:	df000015 	stw	fp,0(sp)
8113be04:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113be08:	01c0fa04 	movi	r7,1000
8113be0c:	01800304 	movi	r6,12
8113be10:	000b883a 	mov	r5,zero
8113be14:	01200034 	movhi	r4,32768
8113be18:	21022004 	addi	r4,r4,2176
8113be1c:	11411480 	call	81141148 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113be20:	018002c4 	movi	r6,11
8113be24:	000b883a 	mov	r5,zero
8113be28:	01204574 	movhi	r4,33045
8113be2c:	212bfb04 	addi	r4,r4,-20500
8113be30:	11404340 	call	81140434 <altera_avalon_jtag_uart_init>
8113be34:	01204574 	movhi	r4,33045
8113be38:	212bf104 	addi	r4,r4,-20540
8113be3c:	113bd740 	call	8113bd74 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113be40:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113be44:	018003c4 	movi	r6,15
8113be48:	000b883a 	mov	r5,zero
8113be4c:	01204574 	movhi	r4,33045
8113be50:	21301604 	addi	r4,r4,-16296
8113be54:	11412f40 	call	811412f4 <altera_avalon_uart_init>
8113be58:	01204574 	movhi	r4,33045
8113be5c:	21300c04 	addi	r4,r4,-16336
8113be60:	113bd740 	call	8113bd74 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113be64:	00a04574 	movhi	r2,33045
8113be68:	10b04004 	addi	r2,r2,-16128
8113be6c:	10c00717 	ldw	r3,28(r2)
8113be70:	00a04574 	movhi	r2,33045
8113be74:	10b04004 	addi	r2,r2,-16128
8113be78:	10800817 	ldw	r2,32(r2)
8113be7c:	100d883a 	mov	r6,r2
8113be80:	180b883a 	mov	r5,r3
8113be84:	01204574 	movhi	r4,33045
8113be88:	21304004 	addi	r4,r4,-16128
8113be8c:	1143b7c0 	call	81143b7c <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113be90:	00a04574 	movhi	r2,33045
8113be94:	10b05904 	addi	r2,r2,-16028
8113be98:	10c00717 	ldw	r3,28(r2)
8113be9c:	00a04574 	movhi	r2,33045
8113bea0:	10b05904 	addi	r2,r2,-16028
8113bea4:	10800817 	ldw	r2,32(r2)
8113bea8:	100d883a 	mov	r6,r2
8113beac:	180b883a 	mov	r5,r3
8113beb0:	01204574 	movhi	r4,33045
8113beb4:	21305904 	addi	r4,r4,-16028
8113beb8:	1143b7c0 	call	81143b7c <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113bebc:	01204574 	movhi	r4,33045
8113bec0:	21307204 	addi	r4,r4,-15928
8113bec4:	113bd740 	call	8113bd74 <alt_dev_reg>
}
8113bec8:	0001883a 	nop
8113becc:	e037883a 	mov	sp,fp
8113bed0:	dfc00117 	ldw	ra,4(sp)
8113bed4:	df000017 	ldw	fp,0(sp)
8113bed8:	dec00204 	addi	sp,sp,8
8113bedc:	f800283a 	ret

8113bee0 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113bee0:	defffa04 	addi	sp,sp,-24
8113bee4:	de00012e 	bgeu	sp,et,8113beec <Write_Sector_Data+0xc>
8113bee8:	003b68fa 	trap	3
8113beec:	dfc00515 	stw	ra,20(sp)
8113bef0:	df000415 	stw	fp,16(sp)
8113bef4:	df000404 	addi	fp,sp,16
8113bef8:	e13ffe15 	stw	r4,-8(fp)
8113befc:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113bf00:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113bf04:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113bf08:	10001e26 	beq	r2,zero,8113bf84 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113bf0c:	00803fc4 	movi	r2,255
8113bf10:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113bf14:	d0a0b417 	ldw	r2,-32048(gp)
8113bf18:	e13ffe17 	ldw	r4,-8(fp)
8113bf1c:	e0ffff17 	ldw	r3,-4(fp)
8113bf20:	20c7883a 	add	r3,r4,r3
8113bf24:	1806927a 	slli	r3,r3,9
8113bf28:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113bf2c:	d0a0b317 	ldw	r2,-32052(gp)
8113bf30:	00c00604 	movi	r3,24
8113bf34:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113bf38:	d0a0b017 	ldw	r2,-32064(gp)
8113bf3c:	1080002b 	ldhuio	r2,0(r2)
8113bf40:	10bfffcc 	andi	r2,r2,65535
8113bf44:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113bf48:	e0bffd0b 	ldhu	r2,-12(fp)
8113bf4c:	10bfffcc 	andi	r2,r2,65535
8113bf50:	1080010c 	andi	r2,r2,4
8113bf54:	103ff81e 	bne	r2,zero,8113bf38 <__reset+0xfb11bf38>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113bf58:	e0bffd0b 	ldhu	r2,-12(fp)
8113bf5c:	10bfffcc 	andi	r2,r2,65535
8113bf60:	1080040c 	andi	r2,r2,16
8113bf64:	1000071e 	bne	r2,zero,8113bf84 <Write_Sector_Data+0xa4>
        {
            result = true;
8113bf68:	00800044 	movi	r2,1
8113bf6c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113bf70:	d020b915 	stw	zero,-32028(gp)
            current_sector_index = sector_index+partition_offset;
8113bf74:	e0fffe17 	ldw	r3,-8(fp)
8113bf78:	e0bfff17 	ldw	r2,-4(fp)
8113bf7c:	1885883a 	add	r2,r3,r2
8113bf80:	d0a0ba15 	stw	r2,-32024(gp)
        }
    }
    return result;
8113bf84:	e0bffc17 	ldw	r2,-16(fp)
}
8113bf88:	e037883a 	mov	sp,fp
8113bf8c:	dfc00117 	ldw	ra,4(sp)
8113bf90:	df000017 	ldw	fp,0(sp)
8113bf94:	dec00204 	addi	sp,sp,8
8113bf98:	f800283a 	ret

8113bf9c <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113bf9c:	defffd04 	addi	sp,sp,-12
8113bfa0:	de00012e 	bgeu	sp,et,8113bfa8 <Save_Modified_Sector+0xc>
8113bfa4:	003b68fa 	trap	3
8113bfa8:	dfc00215 	stw	ra,8(sp)
8113bfac:	df000115 	stw	fp,4(sp)
8113bfb0:	df000104 	addi	fp,sp,4
    bool result = true;
8113bfb4:	00800044 	movi	r2,1
8113bfb8:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113bfbc:	d0a0b917 	ldw	r2,-32028(gp)
8113bfc0:	10000526 	beq	r2,zero,8113bfd8 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113bfc4:	d0a0ba17 	ldw	r2,-32024(gp)
8113bfc8:	000b883a 	mov	r5,zero
8113bfcc:	1009883a 	mov	r4,r2
8113bfd0:	113bee00 	call	8113bee0 <Write_Sector_Data>
8113bfd4:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113bfd8:	e0bfff17 	ldw	r2,-4(fp)
}
8113bfdc:	e037883a 	mov	sp,fp
8113bfe0:	dfc00117 	ldw	ra,4(sp)
8113bfe4:	df000017 	ldw	fp,0(sp)
8113bfe8:	dec00204 	addi	sp,sp,8
8113bfec:	f800283a 	ret

8113bff0 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113bff0:	defffa04 	addi	sp,sp,-24
8113bff4:	de00012e 	bgeu	sp,et,8113bffc <Read_Sector_Data+0xc>
8113bff8:	003b68fa 	trap	3
8113bffc:	dfc00515 	stw	ra,20(sp)
8113c000:	df000415 	stw	fp,16(sp)
8113c004:	df000404 	addi	fp,sp,16
8113c008:	e13ffe15 	stw	r4,-8(fp)
8113c00c:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113c010:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113c014:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113c018:	10002726 	beq	r2,zero,8113c0b8 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113c01c:	00803fc4 	movi	r2,255
8113c020:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113c024:	d0a0b917 	ldw	r2,-32028(gp)
8113c028:	10000726 	beq	r2,zero,8113c048 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113c02c:	d0a0ba17 	ldw	r2,-32024(gp)
8113c030:	000b883a 	mov	r5,zero
8113c034:	1009883a 	mov	r4,r2
8113c038:	113bee00 	call	8113bee0 <Write_Sector_Data>
8113c03c:	1000021e 	bne	r2,zero,8113c048 <Read_Sector_Data+0x58>
            {
                return false;
8113c040:	0005883a 	mov	r2,zero
8113c044:	00001d06 	br	8113c0bc <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113c048:	d0a0b417 	ldw	r2,-32048(gp)
8113c04c:	e13ffe17 	ldw	r4,-8(fp)
8113c050:	e0ffff17 	ldw	r3,-4(fp)
8113c054:	20c7883a 	add	r3,r4,r3
8113c058:	1806927a 	slli	r3,r3,9
8113c05c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113c060:	d0a0b317 	ldw	r2,-32052(gp)
8113c064:	00c00444 	movi	r3,17
8113c068:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113c06c:	d0a0b017 	ldw	r2,-32064(gp)
8113c070:	1080002b 	ldhuio	r2,0(r2)
8113c074:	10bfffcc 	andi	r2,r2,65535
8113c078:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113c07c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c080:	10bfffcc 	andi	r2,r2,65535
8113c084:	1080010c 	andi	r2,r2,4
8113c088:	103ff81e 	bne	r2,zero,8113c06c <__reset+0xfb11c06c>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113c08c:	e0bffd0b 	ldhu	r2,-12(fp)
8113c090:	10bfffcc 	andi	r2,r2,65535
8113c094:	1080040c 	andi	r2,r2,16
8113c098:	1000071e 	bne	r2,zero,8113c0b8 <Read_Sector_Data+0xc8>
		{
			result = true;
8113c09c:	00800044 	movi	r2,1
8113c0a0:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113c0a4:	d020b915 	stw	zero,-32028(gp)
            current_sector_index = sector_index+partition_offset;
8113c0a8:	e0fffe17 	ldw	r3,-8(fp)
8113c0ac:	e0bfff17 	ldw	r2,-4(fp)
8113c0b0:	1885883a 	add	r2,r3,r2
8113c0b4:	d0a0ba15 	stw	r2,-32024(gp)
		}
	}
	return result;
8113c0b8:	e0bffc17 	ldw	r2,-16(fp)
}
8113c0bc:	e037883a 	mov	sp,fp
8113c0c0:	dfc00117 	ldw	ra,4(sp)
8113c0c4:	df000017 	ldw	fp,0(sp)
8113c0c8:	dec00204 	addi	sp,sp,8
8113c0cc:	f800283a 	ret

8113c0d0 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113c0d0:	defffb04 	addi	sp,sp,-20
8113c0d4:	de00012e 	bgeu	sp,et,8113c0dc <get_cluster_flag+0xc>
8113c0d8:	003b68fa 	trap	3
8113c0dc:	dfc00415 	stw	ra,16(sp)
8113c0e0:	df000315 	stw	fp,12(sp)
8113c0e4:	df000304 	addi	fp,sp,12
8113c0e8:	e13ffe15 	stw	r4,-8(fp)
8113c0ec:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113c0f0:	e0bffe17 	ldw	r2,-8(fp)
8113c0f4:	1004d23a 	srli	r2,r2,8
8113c0f8:	d0e0b617 	ldw	r3,-32040(gp)
8113c0fc:	10c5883a 	add	r2,r2,r3
8113c100:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113c104:	00a045b4 	movhi	r2,33046
8113c108:	1094fb04 	addi	r2,r2,21484
8113c10c:	10801117 	ldw	r2,68(r2)
8113c110:	e0fffd17 	ldw	r3,-12(fp)
8113c114:	1885883a 	add	r2,r3,r2
8113c118:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113c11c:	d0a0ba17 	ldw	r2,-32024(gp)
8113c120:	e0fffd17 	ldw	r3,-12(fp)
8113c124:	18800726 	beq	r3,r2,8113c144 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113c128:	e0bffd17 	ldw	r2,-12(fp)
8113c12c:	000b883a 	mov	r5,zero
8113c130:	1009883a 	mov	r4,r2
8113c134:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113c138:	1000021e 	bne	r2,zero,8113c144 <get_cluster_flag+0x74>
        {
            return false;
8113c13c:	0005883a 	mov	r2,zero
8113c140:	00000d06 	br	8113c178 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113c144:	e0bffe17 	ldw	r2,-8(fp)
8113c148:	10803fcc 	andi	r2,r2,255
8113c14c:	1085883a 	add	r2,r2,r2
8113c150:	1007883a 	mov	r3,r2
8113c154:	d0a0b817 	ldw	r2,-32032(gp)
8113c158:	10800a17 	ldw	r2,40(r2)
8113c15c:	1885883a 	add	r2,r3,r2
8113c160:	1080002b 	ldhuio	r2,0(r2)
8113c164:	10bfffcc 	andi	r2,r2,65535
8113c168:	1007883a 	mov	r3,r2
8113c16c:	e0bfff17 	ldw	r2,-4(fp)
8113c170:	10c0000d 	sth	r3,0(r2)
    return true;
8113c174:	00800044 	movi	r2,1
}
8113c178:	e037883a 	mov	sp,fp
8113c17c:	dfc00117 	ldw	ra,4(sp)
8113c180:	df000017 	ldw	fp,0(sp)
8113c184:	dec00204 	addi	sp,sp,8
8113c188:	f800283a 	ret

8113c18c <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113c18c:	defffa04 	addi	sp,sp,-24
8113c190:	de00012e 	bgeu	sp,et,8113c198 <mark_cluster+0xc>
8113c194:	003b68fa 	trap	3
8113c198:	dfc00515 	stw	ra,20(sp)
8113c19c:	df000415 	stw	fp,16(sp)
8113c1a0:	df000404 	addi	fp,sp,16
8113c1a4:	e13ffd15 	stw	r4,-12(fp)
8113c1a8:	2805883a 	mov	r2,r5
8113c1ac:	e1bfff15 	stw	r6,-4(fp)
8113c1b0:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113c1b4:	e0bffd17 	ldw	r2,-12(fp)
8113c1b8:	1004d23a 	srli	r2,r2,8
8113c1bc:	d0e0b617 	ldw	r3,-32040(gp)
8113c1c0:	10c5883a 	add	r2,r2,r3
8113c1c4:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113c1c8:	e0bfff17 	ldw	r2,-4(fp)
8113c1cc:	10000726 	beq	r2,zero,8113c1ec <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113c1d0:	00a045b4 	movhi	r2,33046
8113c1d4:	1094fb04 	addi	r2,r2,21484
8113c1d8:	10801117 	ldw	r2,68(r2)
8113c1dc:	e0fffc17 	ldw	r3,-16(fp)
8113c1e0:	1885883a 	add	r2,r3,r2
8113c1e4:	e0bffc15 	stw	r2,-16(fp)
8113c1e8:	00000606 	br	8113c204 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113c1ec:	00a045b4 	movhi	r2,33046
8113c1f0:	1094fb04 	addi	r2,r2,21484
8113c1f4:	10801217 	ldw	r2,72(r2)
8113c1f8:	e0fffc17 	ldw	r3,-16(fp)
8113c1fc:	1885883a 	add	r2,r3,r2
8113c200:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113c204:	d0a0ba17 	ldw	r2,-32024(gp)
8113c208:	e0fffc17 	ldw	r3,-16(fp)
8113c20c:	18800726 	beq	r3,r2,8113c22c <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113c210:	e0bffc17 	ldw	r2,-16(fp)
8113c214:	000b883a 	mov	r5,zero
8113c218:	1009883a 	mov	r4,r2
8113c21c:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113c220:	1000021e 	bne	r2,zero,8113c22c <mark_cluster+0xa0>
        {
            return false;
8113c224:	0005883a 	mov	r2,zero
8113c228:	00000d06 	br	8113c260 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113c22c:	e0bffd17 	ldw	r2,-12(fp)
8113c230:	10803fcc 	andi	r2,r2,255
8113c234:	1085883a 	add	r2,r2,r2
8113c238:	1007883a 	mov	r3,r2
8113c23c:	d0a0b817 	ldw	r2,-32032(gp)
8113c240:	10800a17 	ldw	r2,40(r2)
8113c244:	1885883a 	add	r2,r3,r2
8113c248:	1007883a 	mov	r3,r2
8113c24c:	e0bffe0f 	ldh	r2,-8(fp)
8113c250:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113c254:	00800044 	movi	r2,1
8113c258:	d0a0b915 	stw	r2,-32028(gp)
    return true;
8113c25c:	00800044 	movi	r2,1
}
8113c260:	e037883a 	mov	sp,fp
8113c264:	dfc00117 	ldw	ra,4(sp)
8113c268:	df000017 	ldw	fp,0(sp)
8113c26c:	dec00204 	addi	sp,sp,8
8113c270:	f800283a 	ret

8113c274 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113c274:	defff704 	addi	sp,sp,-36
8113c278:	de00012e 	bgeu	sp,et,8113c280 <Check_for_Master_Boot_Record+0xc>
8113c27c:	003b68fa 	trap	3
8113c280:	dfc00815 	stw	ra,32(sp)
8113c284:	df000715 	stw	fp,28(sp)
8113c288:	df000704 	addi	fp,sp,28
	bool result = false;
8113c28c:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113c290:	000b883a 	mov	r5,zero
8113c294:	0009883a 	mov	r4,zero
8113c298:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113c29c:	10005a26 	beq	r2,zero,8113c408 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113c2a0:	d0a0b817 	ldw	r2,-32032(gp)
8113c2a4:	10800a17 	ldw	r2,40(r2)
8113c2a8:	10807f84 	addi	r2,r2,510
8113c2ac:	1080002b 	ldhuio	r2,0(r2)
8113c2b0:	10bfffcc 	andi	r2,r2,65535
8113c2b4:	10bfffcc 	andi	r2,r2,65535
8113c2b8:	10a0001c 	xori	r2,r2,32768
8113c2bc:	10a00004 	addi	r2,r2,-32768
8113c2c0:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113c2c4:	e0bffb17 	ldw	r2,-20(fp)
8113c2c8:	10ffffcc 	andi	r3,r2,65535
8113c2cc:	00aa9554 	movui	r2,43605
8113c2d0:	18804d1e 	bne	r3,r2,8113c408 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113c2d4:	e03ffa15 	stw	zero,-24(fp)
8113c2d8:	00004806 	br	8113c3fc <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113c2dc:	e0bffa17 	ldw	r2,-24(fp)
8113c2e0:	1004913a 	slli	r2,r2,4
8113c2e4:	10806f84 	addi	r2,r2,446
8113c2e8:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113c2ec:	d0a0b817 	ldw	r2,-32032(gp)
8113c2f0:	10c00a17 	ldw	r3,40(r2)
8113c2f4:	e0bffc17 	ldw	r2,-16(fp)
8113c2f8:	1885883a 	add	r2,r3,r2
8113c2fc:	10800104 	addi	r2,r2,4
8113c300:	10800023 	ldbuio	r2,0(r2)
8113c304:	10803fcc 	andi	r2,r2,255
8113c308:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113c30c:	e0bffd07 	ldb	r2,-12(fp)
8113c310:	10800060 	cmpeqi	r2,r2,1
8113c314:	1000091e 	bne	r2,zero,8113c33c <Check_for_Master_Boot_Record+0xc8>
8113c318:	e0bffd07 	ldb	r2,-12(fp)
8113c31c:	10800120 	cmpeqi	r2,r2,4
8113c320:	1000061e 	bne	r2,zero,8113c33c <Check_for_Master_Boot_Record+0xc8>
8113c324:	e0bffd07 	ldb	r2,-12(fp)
8113c328:	108001a0 	cmpeqi	r2,r2,6
8113c32c:	1000031e 	bne	r2,zero,8113c33c <Check_for_Master_Boot_Record+0xc8>
8113c330:	e0bffd07 	ldb	r2,-12(fp)
8113c334:	10800398 	cmpnei	r2,r2,14
8113c338:	10002d1e 	bne	r2,zero,8113c3f0 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113c33c:	d0a0b817 	ldw	r2,-32032(gp)
8113c340:	10c00a17 	ldw	r3,40(r2)
8113c344:	e0bffc17 	ldw	r2,-16(fp)
8113c348:	1885883a 	add	r2,r3,r2
8113c34c:	10800284 	addi	r2,r2,10
8113c350:	1080002b 	ldhuio	r2,0(r2)
8113c354:	10bfffcc 	andi	r2,r2,65535
8113c358:	1006943a 	slli	r3,r2,16
8113c35c:	d0a0b817 	ldw	r2,-32032(gp)
8113c360:	11000a17 	ldw	r4,40(r2)
8113c364:	e0bffc17 	ldw	r2,-16(fp)
8113c368:	2085883a 	add	r2,r4,r2
8113c36c:	10800204 	addi	r2,r2,8
8113c370:	1080002b 	ldhuio	r2,0(r2)
8113c374:	10bfffcc 	andi	r2,r2,65535
8113c378:	10bfffcc 	andi	r2,r2,65535
8113c37c:	1884b03a 	or	r2,r3,r2
8113c380:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113c384:	d0a0b817 	ldw	r2,-32032(gp)
8113c388:	10c00a17 	ldw	r3,40(r2)
8113c38c:	e0bffc17 	ldw	r2,-16(fp)
8113c390:	1885883a 	add	r2,r3,r2
8113c394:	10800384 	addi	r2,r2,14
8113c398:	1080002b 	ldhuio	r2,0(r2)
8113c39c:	10bfffcc 	andi	r2,r2,65535
8113c3a0:	1006943a 	slli	r3,r2,16
8113c3a4:	d0a0b817 	ldw	r2,-32032(gp)
8113c3a8:	11000a17 	ldw	r4,40(r2)
8113c3ac:	e0bffc17 	ldw	r2,-16(fp)
8113c3b0:	2085883a 	add	r2,r4,r2
8113c3b4:	10800304 	addi	r2,r2,12
8113c3b8:	1080002b 	ldhuio	r2,0(r2)
8113c3bc:	10bfffcc 	andi	r2,r2,65535
8113c3c0:	10bfffcc 	andi	r2,r2,65535
8113c3c4:	1884b03a 	or	r2,r3,r2
8113c3c8:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113c3cc:	e0bfff17 	ldw	r2,-4(fp)
8113c3d0:	0080070e 	bge	zero,r2,8113c3f0 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113c3d4:	00800044 	movi	r2,1
8113c3d8:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113c3dc:	e0bfff17 	ldw	r2,-4(fp)
8113c3e0:	d0a0b715 	stw	r2,-32036(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113c3e4:	e0bffe17 	ldw	r2,-8(fp)
8113c3e8:	d0a0b615 	stw	r2,-32040(gp)
						break;
8113c3ec:	00000606 	br	8113c408 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113c3f0:	e0bffa17 	ldw	r2,-24(fp)
8113c3f4:	10800044 	addi	r2,r2,1
8113c3f8:	e0bffa15 	stw	r2,-24(fp)
8113c3fc:	e0bffa17 	ldw	r2,-24(fp)
8113c400:	10800110 	cmplti	r2,r2,4
8113c404:	103fb51e 	bne	r2,zero,8113c2dc <__reset+0xfb11c2dc>
				}
			}
		}
	}

	return result;
8113c408:	e0bff917 	ldw	r2,-28(fp)
}
8113c40c:	e037883a 	mov	sp,fp
8113c410:	dfc00117 	ldw	ra,4(sp)
8113c414:	df000017 	ldw	fp,0(sp)
8113c418:	dec00204 	addi	sp,sp,8
8113c41c:	f800283a 	ret

8113c420 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113c420:	defff804 	addi	sp,sp,-32
8113c424:	de00012e 	bgeu	sp,et,8113c42c <Read_File_Record_At_Offset+0xc>
8113c428:	003b68fa 	trap	3
8113c42c:	dfc00715 	stw	ra,28(sp)
8113c430:	df000615 	stw	fp,24(sp)
8113c434:	df000604 	addi	fp,sp,24
8113c438:	e13ffc15 	stw	r4,-16(fp)
8113c43c:	e17ffd15 	stw	r5,-12(fp)
8113c440:	e1bffe15 	stw	r6,-8(fp)
8113c444:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113c448:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113c44c:	e0bffc17 	ldw	r2,-16(fp)
8113c450:	108007cc 	andi	r2,r2,31
8113c454:	10008d1e 	bne	r2,zero,8113c68c <Read_File_Record_At_Offset+0x26c>
8113c458:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113c45c:	10008b26 	beq	r2,zero,8113c68c <Read_File_Record_At_Offset+0x26c>
8113c460:	d0a0af17 	ldw	r2,-32068(gp)
8113c464:	10008926 	beq	r2,zero,8113c68c <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113c468:	e03ffb15 	stw	zero,-20(fp)
8113c46c:	00001106 	br	8113c4b4 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113c470:	e0fffc17 	ldw	r3,-16(fp)
8113c474:	e0bffb17 	ldw	r2,-20(fp)
8113c478:	1885883a 	add	r2,r3,r2
8113c47c:	1007883a 	mov	r3,r2
8113c480:	d0a0b817 	ldw	r2,-32032(gp)
8113c484:	10800a17 	ldw	r2,40(r2)
8113c488:	1885883a 	add	r2,r3,r2
8113c48c:	10800023 	ldbuio	r2,0(r2)
8113c490:	10803fcc 	andi	r2,r2,255
8113c494:	1009883a 	mov	r4,r2
8113c498:	e0fffd17 	ldw	r3,-12(fp)
8113c49c:	e0bffb17 	ldw	r2,-20(fp)
8113c4a0:	1885883a 	add	r2,r3,r2
8113c4a4:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113c4a8:	e0bffb17 	ldw	r2,-20(fp)
8113c4ac:	10800044 	addi	r2,r2,1
8113c4b0:	e0bffb15 	stw	r2,-20(fp)
8113c4b4:	e0bffb17 	ldw	r2,-20(fp)
8113c4b8:	10800210 	cmplti	r2,r2,8
8113c4bc:	103fec1e 	bne	r2,zero,8113c470 <__reset+0xfb11c470>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113c4c0:	e03ffb15 	stw	zero,-20(fp)
8113c4c4:	00001306 	br	8113c514 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113c4c8:	e0fffc17 	ldw	r3,-16(fp)
8113c4cc:	e0bffb17 	ldw	r2,-20(fp)
8113c4d0:	1885883a 	add	r2,r3,r2
8113c4d4:	1007883a 	mov	r3,r2
8113c4d8:	d0a0b817 	ldw	r2,-32032(gp)
8113c4dc:	10800a17 	ldw	r2,40(r2)
8113c4e0:	1885883a 	add	r2,r3,r2
8113c4e4:	10800204 	addi	r2,r2,8
8113c4e8:	10800023 	ldbuio	r2,0(r2)
8113c4ec:	10803fcc 	andi	r2,r2,255
8113c4f0:	1009883a 	mov	r4,r2
8113c4f4:	e0fffd17 	ldw	r3,-12(fp)
8113c4f8:	e0bffb17 	ldw	r2,-20(fp)
8113c4fc:	1885883a 	add	r2,r3,r2
8113c500:	10800204 	addi	r2,r2,8
8113c504:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113c508:	e0bffb17 	ldw	r2,-20(fp)
8113c50c:	10800044 	addi	r2,r2,1
8113c510:	e0bffb15 	stw	r2,-20(fp)
8113c514:	e0bffb17 	ldw	r2,-20(fp)
8113c518:	108000d0 	cmplti	r2,r2,3
8113c51c:	103fea1e 	bne	r2,zero,8113c4c8 <__reset+0xfb11c4c8>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113c520:	d0a0b817 	ldw	r2,-32032(gp)
8113c524:	10c00a17 	ldw	r3,40(r2)
8113c528:	e0bffc17 	ldw	r2,-16(fp)
8113c52c:	1885883a 	add	r2,r3,r2
8113c530:	108002c4 	addi	r2,r2,11
8113c534:	10800023 	ldbuio	r2,0(r2)
8113c538:	10803fcc 	andi	r2,r2,255
8113c53c:	1007883a 	mov	r3,r2
8113c540:	e0bffd17 	ldw	r2,-12(fp)
8113c544:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113c548:	d0a0b817 	ldw	r2,-32032(gp)
8113c54c:	10c00a17 	ldw	r3,40(r2)
8113c550:	e0bffc17 	ldw	r2,-16(fp)
8113c554:	1885883a 	add	r2,r3,r2
8113c558:	10800384 	addi	r2,r2,14
8113c55c:	1080002b 	ldhuio	r2,0(r2)
8113c560:	10bfffcc 	andi	r2,r2,65535
8113c564:	1007883a 	mov	r3,r2
8113c568:	e0bffd17 	ldw	r2,-12(fp)
8113c56c:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113c570:	d0a0b817 	ldw	r2,-32032(gp)
8113c574:	10c00a17 	ldw	r3,40(r2)
8113c578:	e0bffc17 	ldw	r2,-16(fp)
8113c57c:	1885883a 	add	r2,r3,r2
8113c580:	10800404 	addi	r2,r2,16
8113c584:	1080002b 	ldhuio	r2,0(r2)
8113c588:	10bfffcc 	andi	r2,r2,65535
8113c58c:	1007883a 	mov	r3,r2
8113c590:	e0bffd17 	ldw	r2,-12(fp)
8113c594:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113c598:	d0a0b817 	ldw	r2,-32032(gp)
8113c59c:	10c00a17 	ldw	r3,40(r2)
8113c5a0:	e0bffc17 	ldw	r2,-16(fp)
8113c5a4:	1885883a 	add	r2,r3,r2
8113c5a8:	10800484 	addi	r2,r2,18
8113c5ac:	1080002b 	ldhuio	r2,0(r2)
8113c5b0:	10bfffcc 	andi	r2,r2,65535
8113c5b4:	1007883a 	mov	r3,r2
8113c5b8:	e0bffd17 	ldw	r2,-12(fp)
8113c5bc:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113c5c0:	d0a0b817 	ldw	r2,-32032(gp)
8113c5c4:	10c00a17 	ldw	r3,40(r2)
8113c5c8:	e0bffc17 	ldw	r2,-16(fp)
8113c5cc:	1885883a 	add	r2,r3,r2
8113c5d0:	10800584 	addi	r2,r2,22
8113c5d4:	1080002b 	ldhuio	r2,0(r2)
8113c5d8:	10bfffcc 	andi	r2,r2,65535
8113c5dc:	1007883a 	mov	r3,r2
8113c5e0:	e0bffd17 	ldw	r2,-12(fp)
8113c5e4:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113c5e8:	d0a0b817 	ldw	r2,-32032(gp)
8113c5ec:	10c00a17 	ldw	r3,40(r2)
8113c5f0:	e0bffc17 	ldw	r2,-16(fp)
8113c5f4:	1885883a 	add	r2,r3,r2
8113c5f8:	10800604 	addi	r2,r2,24
8113c5fc:	1080002b 	ldhuio	r2,0(r2)
8113c600:	10bfffcc 	andi	r2,r2,65535
8113c604:	1007883a 	mov	r3,r2
8113c608:	e0bffd17 	ldw	r2,-12(fp)
8113c60c:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113c610:	d0a0b817 	ldw	r2,-32032(gp)
8113c614:	10c00a17 	ldw	r3,40(r2)
8113c618:	e0bffc17 	ldw	r2,-16(fp)
8113c61c:	1885883a 	add	r2,r3,r2
8113c620:	10800684 	addi	r2,r2,26
8113c624:	1080002b 	ldhuio	r2,0(r2)
8113c628:	10bfffcc 	andi	r2,r2,65535
8113c62c:	1007883a 	mov	r3,r2
8113c630:	e0bffd17 	ldw	r2,-12(fp)
8113c634:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113c638:	d0a0b817 	ldw	r2,-32032(gp)
8113c63c:	10c00a17 	ldw	r3,40(r2)
8113c640:	e0bffc17 	ldw	r2,-16(fp)
8113c644:	1885883a 	add	r2,r3,r2
8113c648:	10800704 	addi	r2,r2,28
8113c64c:	10800037 	ldwio	r2,0(r2)
8113c650:	1007883a 	mov	r3,r2
8113c654:	e0bffd17 	ldw	r2,-12(fp)
8113c658:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113c65c:	e0bffd17 	ldw	r2,-12(fp)
8113c660:	e0fffe17 	ldw	r3,-8(fp)
8113c664:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113c668:	e0bffd17 	ldw	r2,-12(fp)
8113c66c:	e0ffff17 	ldw	r3,-4(fp)
8113c670:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113c674:	e0bffc17 	ldw	r2,-16(fp)
8113c678:	1007883a 	mov	r3,r2
8113c67c:	e0bffd17 	ldw	r2,-12(fp)
8113c680:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113c684:	00800044 	movi	r2,1
8113c688:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113c68c:	e0bffa17 	ldw	r2,-24(fp)
}
8113c690:	e037883a 	mov	sp,fp
8113c694:	dfc00117 	ldw	ra,4(sp)
8113c698:	df000017 	ldw	fp,0(sp)
8113c69c:	dec00204 	addi	sp,sp,8
8113c6a0:	f800283a 	ret

8113c6a4 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113c6a4:	defff904 	addi	sp,sp,-28
8113c6a8:	de00012e 	bgeu	sp,et,8113c6b0 <Write_File_Record_At_Offset+0xc>
8113c6ac:	003b68fa 	trap	3
8113c6b0:	dfc00615 	stw	ra,24(sp)
8113c6b4:	df000515 	stw	fp,20(sp)
8113c6b8:	df000504 	addi	fp,sp,20
8113c6bc:	e13ffe15 	stw	r4,-8(fp)
8113c6c0:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113c6c4:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113c6c8:	e0bffe17 	ldw	r2,-8(fp)
8113c6cc:	108007cc 	andi	r2,r2,31
8113c6d0:	1000931e 	bne	r2,zero,8113c920 <Write_File_Record_At_Offset+0x27c>
8113c6d4:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113c6d8:	10009126 	beq	r2,zero,8113c920 <Write_File_Record_At_Offset+0x27c>
8113c6dc:	d0a0af17 	ldw	r2,-32068(gp)
8113c6e0:	10008f26 	beq	r2,zero,8113c920 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113c6e4:	e03ffc15 	stw	zero,-16(fp)
8113c6e8:	00001f06 	br	8113c768 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113c6ec:	e0bffc17 	ldw	r2,-16(fp)
8113c6f0:	10800044 	addi	r2,r2,1
8113c6f4:	e0ffff17 	ldw	r3,-4(fp)
8113c6f8:	1885883a 	add	r2,r3,r2
8113c6fc:	10800003 	ldbu	r2,0(r2)
8113c700:	10803fcc 	andi	r2,r2,255
8113c704:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113c708:	e0bffd0f 	ldh	r2,-12(fp)
8113c70c:	1004923a 	slli	r2,r2,8
8113c710:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113c714:	e0ffff17 	ldw	r3,-4(fp)
8113c718:	e0bffc17 	ldw	r2,-16(fp)
8113c71c:	1885883a 	add	r2,r3,r2
8113c720:	10800003 	ldbu	r2,0(r2)
8113c724:	10c03fcc 	andi	r3,r2,255
8113c728:	e0bffd0b 	ldhu	r2,-12(fp)
8113c72c:	1884b03a 	or	r2,r3,r2
8113c730:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113c734:	e0fffe17 	ldw	r3,-8(fp)
8113c738:	e0bffc17 	ldw	r2,-16(fp)
8113c73c:	1885883a 	add	r2,r3,r2
8113c740:	1007883a 	mov	r3,r2
8113c744:	d0a0b817 	ldw	r2,-32032(gp)
8113c748:	10800a17 	ldw	r2,40(r2)
8113c74c:	1885883a 	add	r2,r3,r2
8113c750:	1007883a 	mov	r3,r2
8113c754:	e0bffd0f 	ldh	r2,-12(fp)
8113c758:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113c75c:	e0bffc17 	ldw	r2,-16(fp)
8113c760:	10800084 	addi	r2,r2,2
8113c764:	e0bffc15 	stw	r2,-16(fp)
8113c768:	e0bffc17 	ldw	r2,-16(fp)
8113c76c:	10800210 	cmplti	r2,r2,8
8113c770:	103fde1e 	bne	r2,zero,8113c6ec <__reset+0xfb11c6ec>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113c774:	e03ffc15 	stw	zero,-16(fp)
8113c778:	00001306 	br	8113c7c8 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113c77c:	e0fffe17 	ldw	r3,-8(fp)
8113c780:	e0bffc17 	ldw	r2,-16(fp)
8113c784:	1885883a 	add	r2,r3,r2
8113c788:	1007883a 	mov	r3,r2
8113c78c:	d0a0b817 	ldw	r2,-32032(gp)
8113c790:	10800a17 	ldw	r2,40(r2)
8113c794:	1885883a 	add	r2,r3,r2
8113c798:	10800204 	addi	r2,r2,8
8113c79c:	1009883a 	mov	r4,r2
8113c7a0:	e0ffff17 	ldw	r3,-4(fp)
8113c7a4:	e0bffc17 	ldw	r2,-16(fp)
8113c7a8:	1885883a 	add	r2,r3,r2
8113c7ac:	10800204 	addi	r2,r2,8
8113c7b0:	10800003 	ldbu	r2,0(r2)
8113c7b4:	10803fcc 	andi	r2,r2,255
8113c7b8:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113c7bc:	e0bffc17 	ldw	r2,-16(fp)
8113c7c0:	10800044 	addi	r2,r2,1
8113c7c4:	e0bffc15 	stw	r2,-16(fp)
8113c7c8:	e0bffc17 	ldw	r2,-16(fp)
8113c7cc:	108000d0 	cmplti	r2,r2,3
8113c7d0:	103fea1e 	bne	r2,zero,8113c77c <__reset+0xfb11c77c>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113c7d4:	d0a0b817 	ldw	r2,-32032(gp)
8113c7d8:	10c00a17 	ldw	r3,40(r2)
8113c7dc:	e0bffe17 	ldw	r2,-8(fp)
8113c7e0:	1885883a 	add	r2,r3,r2
8113c7e4:	108002c4 	addi	r2,r2,11
8113c7e8:	1007883a 	mov	r3,r2
8113c7ec:	e0bfff17 	ldw	r2,-4(fp)
8113c7f0:	108002c3 	ldbu	r2,11(r2)
8113c7f4:	10803fcc 	andi	r2,r2,255
8113c7f8:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113c7fc:	d0a0b817 	ldw	r2,-32032(gp)
8113c800:	10c00a17 	ldw	r3,40(r2)
8113c804:	e0bffe17 	ldw	r2,-8(fp)
8113c808:	1885883a 	add	r2,r3,r2
8113c80c:	10800384 	addi	r2,r2,14
8113c810:	1007883a 	mov	r3,r2
8113c814:	e0bfff17 	ldw	r2,-4(fp)
8113c818:	1080030b 	ldhu	r2,12(r2)
8113c81c:	10bfffcc 	andi	r2,r2,65535
8113c820:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113c824:	d0a0b817 	ldw	r2,-32032(gp)
8113c828:	10c00a17 	ldw	r3,40(r2)
8113c82c:	e0bffe17 	ldw	r2,-8(fp)
8113c830:	1885883a 	add	r2,r3,r2
8113c834:	10800404 	addi	r2,r2,16
8113c838:	1007883a 	mov	r3,r2
8113c83c:	e0bfff17 	ldw	r2,-4(fp)
8113c840:	1080038b 	ldhu	r2,14(r2)
8113c844:	10bfffcc 	andi	r2,r2,65535
8113c848:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113c84c:	d0a0b817 	ldw	r2,-32032(gp)
8113c850:	10c00a17 	ldw	r3,40(r2)
8113c854:	e0bffe17 	ldw	r2,-8(fp)
8113c858:	1885883a 	add	r2,r3,r2
8113c85c:	10800484 	addi	r2,r2,18
8113c860:	1007883a 	mov	r3,r2
8113c864:	e0bfff17 	ldw	r2,-4(fp)
8113c868:	1080040b 	ldhu	r2,16(r2)
8113c86c:	10bfffcc 	andi	r2,r2,65535
8113c870:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113c874:	d0a0b817 	ldw	r2,-32032(gp)
8113c878:	10c00a17 	ldw	r3,40(r2)
8113c87c:	e0bffe17 	ldw	r2,-8(fp)
8113c880:	1885883a 	add	r2,r3,r2
8113c884:	10800584 	addi	r2,r2,22
8113c888:	1007883a 	mov	r3,r2
8113c88c:	e0bfff17 	ldw	r2,-4(fp)
8113c890:	1080048b 	ldhu	r2,18(r2)
8113c894:	10bfffcc 	andi	r2,r2,65535
8113c898:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113c89c:	d0a0b817 	ldw	r2,-32032(gp)
8113c8a0:	10c00a17 	ldw	r3,40(r2)
8113c8a4:	e0bffe17 	ldw	r2,-8(fp)
8113c8a8:	1885883a 	add	r2,r3,r2
8113c8ac:	10800604 	addi	r2,r2,24
8113c8b0:	1007883a 	mov	r3,r2
8113c8b4:	e0bfff17 	ldw	r2,-4(fp)
8113c8b8:	1080050b 	ldhu	r2,20(r2)
8113c8bc:	10bfffcc 	andi	r2,r2,65535
8113c8c0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113c8c4:	d0a0b817 	ldw	r2,-32032(gp)
8113c8c8:	10c00a17 	ldw	r3,40(r2)
8113c8cc:	e0bffe17 	ldw	r2,-8(fp)
8113c8d0:	1885883a 	add	r2,r3,r2
8113c8d4:	10800684 	addi	r2,r2,26
8113c8d8:	1007883a 	mov	r3,r2
8113c8dc:	e0bfff17 	ldw	r2,-4(fp)
8113c8e0:	1080058b 	ldhu	r2,22(r2)
8113c8e4:	10bfffcc 	andi	r2,r2,65535
8113c8e8:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113c8ec:	d0a0b817 	ldw	r2,-32032(gp)
8113c8f0:	10c00a17 	ldw	r3,40(r2)
8113c8f4:	e0bffe17 	ldw	r2,-8(fp)
8113c8f8:	1885883a 	add	r2,r3,r2
8113c8fc:	10800704 	addi	r2,r2,28
8113c900:	1007883a 	mov	r3,r2
8113c904:	e0bfff17 	ldw	r2,-4(fp)
8113c908:	10800617 	ldw	r2,24(r2)
8113c90c:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113c910:	00800044 	movi	r2,1
8113c914:	d0a0b915 	stw	r2,-32028(gp)
        result = true;
8113c918:	00800044 	movi	r2,1
8113c91c:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113c920:	e0bffb17 	ldw	r2,-20(fp)
}
8113c924:	e037883a 	mov	sp,fp
8113c928:	dfc00117 	ldw	ra,4(sp)
8113c92c:	df000017 	ldw	fp,0(sp)
8113c930:	dec00204 	addi	sp,sp,8
8113c934:	f800283a 	ret

8113c938 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113c938:	defff904 	addi	sp,sp,-28
8113c93c:	de00012e 	bgeu	sp,et,8113c944 <Check_for_DOS_FAT+0xc>
8113c940:	003b68fa 	trap	3
8113c944:	dfc00615 	stw	ra,24(sp)
8113c948:	df000515 	stw	fp,20(sp)
8113c94c:	df000504 	addi	fp,sp,20
8113c950:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113c954:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113c958:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113c95c:	e17fff17 	ldw	r5,-4(fp)
8113c960:	0009883a 	mov	r4,zero
8113c964:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113c968:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113c96c:	d0a0b817 	ldw	r2,-32032(gp)
8113c970:	10800a17 	ldw	r2,40(r2)
8113c974:	10807f84 	addi	r2,r2,510
8113c978:	1080002b 	ldhuio	r2,0(r2)
8113c97c:	10bfffcc 	andi	r2,r2,65535
8113c980:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113c984:	e0bffe0f 	ldh	r2,-8(fp)
8113c988:	10ffffcc 	andi	r3,r2,65535
8113c98c:	00aa9554 	movui	r2,43605
8113c990:	1881841e 	bne	r3,r2,8113cfa4 <Check_for_DOS_FAT+0x66c>
8113c994:	e0bffb17 	ldw	r2,-20(fp)
8113c998:	10018226 	beq	r2,zero,8113cfa4 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113c99c:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113c9a0:	d0a0b817 	ldw	r2,-32032(gp)
8113c9a4:	10800a17 	ldw	r2,40(r2)
8113c9a8:	10800023 	ldbuio	r2,0(r2)
8113c9ac:	10803fcc 	andi	r2,r2,255
8113c9b0:	1007883a 	mov	r3,r2
8113c9b4:	00a045b4 	movhi	r2,33046
8113c9b8:	1094fb04 	addi	r2,r2,21484
8113c9bc:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113c9c0:	d0a0b817 	ldw	r2,-32032(gp)
8113c9c4:	10800a17 	ldw	r2,40(r2)
8113c9c8:	10800044 	addi	r2,r2,1
8113c9cc:	10800023 	ldbuio	r2,0(r2)
8113c9d0:	10803fcc 	andi	r2,r2,255
8113c9d4:	1007883a 	mov	r3,r2
8113c9d8:	00a045b4 	movhi	r2,33046
8113c9dc:	1094fb04 	addi	r2,r2,21484
8113c9e0:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113c9e4:	d0a0b817 	ldw	r2,-32032(gp)
8113c9e8:	10800a17 	ldw	r2,40(r2)
8113c9ec:	10800084 	addi	r2,r2,2
8113c9f0:	10800023 	ldbuio	r2,0(r2)
8113c9f4:	10803fcc 	andi	r2,r2,255
8113c9f8:	1007883a 	mov	r3,r2
8113c9fc:	00a045b4 	movhi	r2,33046
8113ca00:	1094fb04 	addi	r2,r2,21484
8113ca04:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113ca08:	e03ffc15 	stw	zero,-16(fp)
8113ca0c:	00001106 	br	8113ca54 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113ca10:	d0a0b817 	ldw	r2,-32032(gp)
8113ca14:	10c00a17 	ldw	r3,40(r2)
8113ca18:	e0bffc17 	ldw	r2,-16(fp)
8113ca1c:	1885883a 	add	r2,r3,r2
8113ca20:	108000c4 	addi	r2,r2,3
8113ca24:	10800023 	ldbuio	r2,0(r2)
8113ca28:	10803fcc 	andi	r2,r2,255
8113ca2c:	1009883a 	mov	r4,r2
8113ca30:	00a045b4 	movhi	r2,33046
8113ca34:	1094fb04 	addi	r2,r2,21484
8113ca38:	e0fffc17 	ldw	r3,-16(fp)
8113ca3c:	10c5883a 	add	r2,r2,r3
8113ca40:	108000c4 	addi	r2,r2,3
8113ca44:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113ca48:	e0bffc17 	ldw	r2,-16(fp)
8113ca4c:	10800044 	addi	r2,r2,1
8113ca50:	e0bffc15 	stw	r2,-16(fp)
8113ca54:	e0bffc17 	ldw	r2,-16(fp)
8113ca58:	10800210 	cmplti	r2,r2,8
8113ca5c:	103fec1e 	bne	r2,zero,8113ca10 <__reset+0xfb11ca10>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113ca60:	d0a0b817 	ldw	r2,-32032(gp)
8113ca64:	10800a17 	ldw	r2,40(r2)
8113ca68:	10800304 	addi	r2,r2,12
8113ca6c:	10800023 	ldbuio	r2,0(r2)
8113ca70:	10803fcc 	andi	r2,r2,255
8113ca74:	1004923a 	slli	r2,r2,8
8113ca78:	1007883a 	mov	r3,r2
8113ca7c:	d0a0b817 	ldw	r2,-32032(gp)
8113ca80:	10800a17 	ldw	r2,40(r2)
8113ca84:	108002c4 	addi	r2,r2,11
8113ca88:	10800023 	ldbuio	r2,0(r2)
8113ca8c:	10803fcc 	andi	r2,r2,255
8113ca90:	10803fcc 	andi	r2,r2,255
8113ca94:	1080201c 	xori	r2,r2,128
8113ca98:	10bfe004 	addi	r2,r2,-128
8113ca9c:	1884b03a 	or	r2,r3,r2
8113caa0:	1007883a 	mov	r3,r2
8113caa4:	00a045b4 	movhi	r2,33046
8113caa8:	1094fb04 	addi	r2,r2,21484
8113caac:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113cab0:	d0a0b817 	ldw	r2,-32032(gp)
8113cab4:	10800a17 	ldw	r2,40(r2)
8113cab8:	10800344 	addi	r2,r2,13
8113cabc:	10800023 	ldbuio	r2,0(r2)
8113cac0:	10803fcc 	andi	r2,r2,255
8113cac4:	1007883a 	mov	r3,r2
8113cac8:	00a045b4 	movhi	r2,33046
8113cacc:	1094fb04 	addi	r2,r2,21484
8113cad0:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113cad4:	d0a0b817 	ldw	r2,-32032(gp)
8113cad8:	10800a17 	ldw	r2,40(r2)
8113cadc:	10800384 	addi	r2,r2,14
8113cae0:	1080002b 	ldhuio	r2,0(r2)
8113cae4:	10bfffcc 	andi	r2,r2,65535
8113cae8:	1007883a 	mov	r3,r2
8113caec:	00a045b4 	movhi	r2,33046
8113caf0:	1094fb04 	addi	r2,r2,21484
8113caf4:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113caf8:	d0a0b817 	ldw	r2,-32032(gp)
8113cafc:	10800a17 	ldw	r2,40(r2)
8113cb00:	10800404 	addi	r2,r2,16
8113cb04:	10800023 	ldbuio	r2,0(r2)
8113cb08:	10803fcc 	andi	r2,r2,255
8113cb0c:	1007883a 	mov	r3,r2
8113cb10:	00a045b4 	movhi	r2,33046
8113cb14:	1094fb04 	addi	r2,r2,21484
8113cb18:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113cb1c:	d0a0b817 	ldw	r2,-32032(gp)
8113cb20:	10800a17 	ldw	r2,40(r2)
8113cb24:	10800484 	addi	r2,r2,18
8113cb28:	10800023 	ldbuio	r2,0(r2)
8113cb2c:	10803fcc 	andi	r2,r2,255
8113cb30:	1004923a 	slli	r2,r2,8
8113cb34:	1007883a 	mov	r3,r2
8113cb38:	d0a0b817 	ldw	r2,-32032(gp)
8113cb3c:	10800a17 	ldw	r2,40(r2)
8113cb40:	10800444 	addi	r2,r2,17
8113cb44:	10800023 	ldbuio	r2,0(r2)
8113cb48:	10803fcc 	andi	r2,r2,255
8113cb4c:	10803fcc 	andi	r2,r2,255
8113cb50:	1884b03a 	or	r2,r3,r2
8113cb54:	1007883a 	mov	r3,r2
8113cb58:	00a045b4 	movhi	r2,33046
8113cb5c:	1094fb04 	addi	r2,r2,21484
8113cb60:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113cb64:	d0a0b817 	ldw	r2,-32032(gp)
8113cb68:	10800a17 	ldw	r2,40(r2)
8113cb6c:	10800504 	addi	r2,r2,20
8113cb70:	10800023 	ldbuio	r2,0(r2)
8113cb74:	10803fcc 	andi	r2,r2,255
8113cb78:	1004923a 	slli	r2,r2,8
8113cb7c:	1007883a 	mov	r3,r2
8113cb80:	d0a0b817 	ldw	r2,-32032(gp)
8113cb84:	10800a17 	ldw	r2,40(r2)
8113cb88:	108004c4 	addi	r2,r2,19
8113cb8c:	10800023 	ldbuio	r2,0(r2)
8113cb90:	10803fcc 	andi	r2,r2,255
8113cb94:	10803fcc 	andi	r2,r2,255
8113cb98:	1884b03a 	or	r2,r3,r2
8113cb9c:	1007883a 	mov	r3,r2
8113cba0:	00a045b4 	movhi	r2,33046
8113cba4:	1094fb04 	addi	r2,r2,21484
8113cba8:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113cbac:	d0a0b817 	ldw	r2,-32032(gp)
8113cbb0:	10800a17 	ldw	r2,40(r2)
8113cbb4:	10800544 	addi	r2,r2,21
8113cbb8:	10800023 	ldbuio	r2,0(r2)
8113cbbc:	10803fcc 	andi	r2,r2,255
8113cbc0:	1007883a 	mov	r3,r2
8113cbc4:	00a045b4 	movhi	r2,33046
8113cbc8:	1094fb04 	addi	r2,r2,21484
8113cbcc:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113cbd0:	d0a0b817 	ldw	r2,-32032(gp)
8113cbd4:	10800a17 	ldw	r2,40(r2)
8113cbd8:	10800584 	addi	r2,r2,22
8113cbdc:	1080002b 	ldhuio	r2,0(r2)
8113cbe0:	10bfffcc 	andi	r2,r2,65535
8113cbe4:	1007883a 	mov	r3,r2
8113cbe8:	00a045b4 	movhi	r2,33046
8113cbec:	1094fb04 	addi	r2,r2,21484
8113cbf0:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113cbf4:	d0a0b817 	ldw	r2,-32032(gp)
8113cbf8:	10800a17 	ldw	r2,40(r2)
8113cbfc:	10800604 	addi	r2,r2,24
8113cc00:	1080002b 	ldhuio	r2,0(r2)
8113cc04:	10bfffcc 	andi	r2,r2,65535
8113cc08:	1007883a 	mov	r3,r2
8113cc0c:	00a045b4 	movhi	r2,33046
8113cc10:	1094fb04 	addi	r2,r2,21484
8113cc14:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113cc18:	d0a0b817 	ldw	r2,-32032(gp)
8113cc1c:	10800a17 	ldw	r2,40(r2)
8113cc20:	10800684 	addi	r2,r2,26
8113cc24:	1080002b 	ldhuio	r2,0(r2)
8113cc28:	10bfffcc 	andi	r2,r2,65535
8113cc2c:	1007883a 	mov	r3,r2
8113cc30:	00a045b4 	movhi	r2,33046
8113cc34:	1094fb04 	addi	r2,r2,21484
8113cc38:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113cc3c:	d0a0b817 	ldw	r2,-32032(gp)
8113cc40:	10800a17 	ldw	r2,40(r2)
8113cc44:	10800704 	addi	r2,r2,28
8113cc48:	10800037 	ldwio	r2,0(r2)
8113cc4c:	1007883a 	mov	r3,r2
8113cc50:	00a045b4 	movhi	r2,33046
8113cc54:	1094fb04 	addi	r2,r2,21484
8113cc58:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113cc5c:	d0a0b817 	ldw	r2,-32032(gp)
8113cc60:	10800a17 	ldw	r2,40(r2)
8113cc64:	10800804 	addi	r2,r2,32
8113cc68:	10800037 	ldwio	r2,0(r2)
8113cc6c:	1007883a 	mov	r3,r2
8113cc70:	00a045b4 	movhi	r2,33046
8113cc74:	1094fb04 	addi	r2,r2,21484
8113cc78:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113cc7c:	d0a0b817 	ldw	r2,-32032(gp)
8113cc80:	10800a17 	ldw	r2,40(r2)
8113cc84:	10800904 	addi	r2,r2,36
8113cc88:	10800023 	ldbuio	r2,0(r2)
8113cc8c:	10803fcc 	andi	r2,r2,255
8113cc90:	1007883a 	mov	r3,r2
8113cc94:	00a045b4 	movhi	r2,33046
8113cc98:	1094fb04 	addi	r2,r2,21484
8113cc9c:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113cca0:	d0a0b817 	ldw	r2,-32032(gp)
8113cca4:	10800a17 	ldw	r2,40(r2)
8113cca8:	10800944 	addi	r2,r2,37
8113ccac:	10800023 	ldbuio	r2,0(r2)
8113ccb0:	10803fcc 	andi	r2,r2,255
8113ccb4:	1007883a 	mov	r3,r2
8113ccb8:	00a045b4 	movhi	r2,33046
8113ccbc:	1094fb04 	addi	r2,r2,21484
8113ccc0:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113ccc4:	d0a0b817 	ldw	r2,-32032(gp)
8113ccc8:	10800a17 	ldw	r2,40(r2)
8113cccc:	10800984 	addi	r2,r2,38
8113ccd0:	10800023 	ldbuio	r2,0(r2)
8113ccd4:	10803fcc 	andi	r2,r2,255
8113ccd8:	1007883a 	mov	r3,r2
8113ccdc:	00a045b4 	movhi	r2,33046
8113cce0:	1094fb04 	addi	r2,r2,21484
8113cce4:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113cce8:	00a045b4 	movhi	r2,33046
8113ccec:	1094fb04 	addi	r2,r2,21484
8113ccf0:	1080040b 	ldhu	r2,16(r2)
8113ccf4:	10ffffcc 	andi	r3,r2,65535
8113ccf8:	00a045b4 	movhi	r2,33046
8113ccfc:	1094fb04 	addi	r2,r2,21484
8113cd00:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113cd04:	00a045b4 	movhi	r2,33046
8113cd08:	1094fb04 	addi	r2,r2,21484
8113cd0c:	10c01117 	ldw	r3,68(r2)
8113cd10:	00a045b4 	movhi	r2,33046
8113cd14:	1094fb04 	addi	r2,r2,21484
8113cd18:	1080068b 	ldhu	r2,26(r2)
8113cd1c:	10bfffcc 	andi	r2,r2,65535
8113cd20:	1887883a 	add	r3,r3,r2
8113cd24:	00a045b4 	movhi	r2,33046
8113cd28:	1094fb04 	addi	r2,r2,21484
8113cd2c:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113cd30:	00a045b4 	movhi	r2,33046
8113cd34:	1094fb04 	addi	r2,r2,21484
8113cd38:	10c01217 	ldw	r3,72(r2)
8113cd3c:	00a045b4 	movhi	r2,33046
8113cd40:	1094fb04 	addi	r2,r2,21484
8113cd44:	1080068b 	ldhu	r2,26(r2)
8113cd48:	10bfffcc 	andi	r2,r2,65535
8113cd4c:	1887883a 	add	r3,r3,r2
8113cd50:	00a045b4 	movhi	r2,33046
8113cd54:	1094fb04 	addi	r2,r2,21484
8113cd58:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113cd5c:	00a045b4 	movhi	r2,33046
8113cd60:	1094fb04 	addi	r2,r2,21484
8113cd64:	10c01317 	ldw	r3,76(r2)
8113cd68:	00a045b4 	movhi	r2,33046
8113cd6c:	1094fb04 	addi	r2,r2,21484
8113cd70:	1080050b 	ldhu	r2,20(r2)
8113cd74:	10bfffcc 	andi	r2,r2,65535
8113cd78:	1008917a 	slli	r4,r2,5
8113cd7c:	00a045b4 	movhi	r2,33046
8113cd80:	1094fb04 	addi	r2,r2,21484
8113cd84:	1080030b 	ldhu	r2,12(r2)
8113cd88:	10bfffcc 	andi	r2,r2,65535
8113cd8c:	2085283a 	div	r2,r4,r2
8113cd90:	1887883a 	add	r3,r3,r2
8113cd94:	00a045b4 	movhi	r2,33046
8113cd98:	1094fb04 	addi	r2,r2,21484
8113cd9c:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113cda0:	00a045b4 	movhi	r2,33046
8113cda4:	1094fb04 	addi	r2,r2,21484
8113cda8:	1080058b 	ldhu	r2,22(r2)
8113cdac:	10bfffcc 	andi	r2,r2,65535
8113cdb0:	10000b26 	beq	r2,zero,8113cde0 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113cdb4:	00a045b4 	movhi	r2,33046
8113cdb8:	1094fb04 	addi	r2,r2,21484
8113cdbc:	1080058b 	ldhu	r2,22(r2)
8113cdc0:	10ffffcc 	andi	r3,r2,65535
8113cdc4:	00a045b4 	movhi	r2,33046
8113cdc8:	1094fb04 	addi	r2,r2,21484
8113cdcc:	10800383 	ldbu	r2,14(r2)
8113cdd0:	10803fcc 	andi	r2,r2,255
8113cdd4:	1885283a 	div	r2,r3,r2
8113cdd8:	e0bffd15 	stw	r2,-12(fp)
8113cddc:	00000906 	br	8113ce04 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113cde0:	00a045b4 	movhi	r2,33046
8113cde4:	1094fb04 	addi	r2,r2,21484
8113cde8:	10c00917 	ldw	r3,36(r2)
8113cdec:	00a045b4 	movhi	r2,33046
8113cdf0:	1094fb04 	addi	r2,r2,21484
8113cdf4:	10800383 	ldbu	r2,14(r2)
8113cdf8:	10803fcc 	andi	r2,r2,255
8113cdfc:	1885203a 	divu	r2,r3,r2
8113ce00:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113ce04:	e0bffd17 	ldw	r2,-12(fp)
8113ce08:	1083fdc8 	cmpgei	r2,r2,4087
8113ce0c:	1000051e 	bne	r2,zero,8113ce24 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113ce10:	00a045b4 	movhi	r2,33046
8113ce14:	1094fb04 	addi	r2,r2,21484
8113ce18:	00c00304 	movi	r3,12
8113ce1c:	10c01085 	stb	r3,66(r2)
8113ce20:	00000c06 	br	8113ce54 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113ce24:	e0bffd17 	ldw	r2,-12(fp)
8113ce28:	00fffb54 	movui	r3,65517
8113ce2c:	18800516 	blt	r3,r2,8113ce44 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113ce30:	00a045b4 	movhi	r2,33046
8113ce34:	1094fb04 	addi	r2,r2,21484
8113ce38:	00c00404 	movi	r3,16
8113ce3c:	10c01085 	stb	r3,66(r2)
8113ce40:	00000406 	br	8113ce54 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113ce44:	00a045b4 	movhi	r2,33046
8113ce48:	1094fb04 	addi	r2,r2,21484
8113ce4c:	00c00804 	movi	r3,32
8113ce50:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113ce54:	e03ffc15 	stw	zero,-16(fp)
8113ce58:	00001106 	br	8113cea0 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113ce5c:	d0a0b817 	ldw	r2,-32032(gp)
8113ce60:	10c00a17 	ldw	r3,40(r2)
8113ce64:	e0bffc17 	ldw	r2,-16(fp)
8113ce68:	1885883a 	add	r2,r3,r2
8113ce6c:	108009c4 	addi	r2,r2,39
8113ce70:	10800023 	ldbuio	r2,0(r2)
8113ce74:	10803fcc 	andi	r2,r2,255
8113ce78:	1009883a 	mov	r4,r2
8113ce7c:	00a045b4 	movhi	r2,33046
8113ce80:	1094fb04 	addi	r2,r2,21484
8113ce84:	e0fffc17 	ldw	r3,-16(fp)
8113ce88:	10c5883a 	add	r2,r2,r3
8113ce8c:	10800ac4 	addi	r2,r2,43
8113ce90:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113ce94:	e0bffc17 	ldw	r2,-16(fp)
8113ce98:	10800044 	addi	r2,r2,1
8113ce9c:	e0bffc15 	stw	r2,-16(fp)
8113cea0:	e0bffc17 	ldw	r2,-16(fp)
8113cea4:	10800110 	cmplti	r2,r2,4
8113cea8:	103fec1e 	bne	r2,zero,8113ce5c <__reset+0xfb11ce5c>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113ceac:	e03ffc15 	stw	zero,-16(fp)
8113ceb0:	00001106 	br	8113cef8 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113ceb4:	d0a0b817 	ldw	r2,-32032(gp)
8113ceb8:	10c00a17 	ldw	r3,40(r2)
8113cebc:	e0bffc17 	ldw	r2,-16(fp)
8113cec0:	1885883a 	add	r2,r3,r2
8113cec4:	10800ac4 	addi	r2,r2,43
8113cec8:	10800023 	ldbuio	r2,0(r2)
8113cecc:	10803fcc 	andi	r2,r2,255
8113ced0:	1009883a 	mov	r4,r2
8113ced4:	00a045b4 	movhi	r2,33046
8113ced8:	1094fb04 	addi	r2,r2,21484
8113cedc:	e0fffc17 	ldw	r3,-16(fp)
8113cee0:	10c5883a 	add	r2,r2,r3
8113cee4:	10800bc4 	addi	r2,r2,47
8113cee8:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113ceec:	e0bffc17 	ldw	r2,-16(fp)
8113cef0:	10800044 	addi	r2,r2,1
8113cef4:	e0bffc15 	stw	r2,-16(fp)
8113cef8:	e0bffc17 	ldw	r2,-16(fp)
8113cefc:	108002d0 	cmplti	r2,r2,11
8113cf00:	103fec1e 	bne	r2,zero,8113ceb4 <__reset+0xfb11ceb4>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113cf04:	e03ffc15 	stw	zero,-16(fp)
8113cf08:	00001106 	br	8113cf50 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113cf0c:	d0a0b817 	ldw	r2,-32032(gp)
8113cf10:	10c00a17 	ldw	r3,40(r2)
8113cf14:	e0bffc17 	ldw	r2,-16(fp)
8113cf18:	1885883a 	add	r2,r3,r2
8113cf1c:	10800d84 	addi	r2,r2,54
8113cf20:	10800023 	ldbuio	r2,0(r2)
8113cf24:	10803fcc 	andi	r2,r2,255
8113cf28:	1009883a 	mov	r4,r2
8113cf2c:	00a045b4 	movhi	r2,33046
8113cf30:	1094fb04 	addi	r2,r2,21484
8113cf34:	e0fffc17 	ldw	r3,-16(fp)
8113cf38:	10c5883a 	add	r2,r2,r3
8113cf3c:	10800e84 	addi	r2,r2,58
8113cf40:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113cf44:	e0bffc17 	ldw	r2,-16(fp)
8113cf48:	10800044 	addi	r2,r2,1
8113cf4c:	e0bffc15 	stw	r2,-16(fp)
8113cf50:	e0bffc17 	ldw	r2,-16(fp)
8113cf54:	10800210 	cmplti	r2,r2,8
8113cf58:	103fec1e 	bne	r2,zero,8113cf0c <__reset+0xfb11cf0c>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113cf5c:	e03ffc15 	stw	zero,-16(fp)
8113cf60:	00000a06 	br	8113cf8c <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113cf64:	00a045b4 	movhi	r2,33046
8113cf68:	10951004 	addi	r2,r2,21568
8113cf6c:	e0fffc17 	ldw	r3,-16(fp)
8113cf70:	180691ba 	slli	r3,r3,6
8113cf74:	10c5883a 	add	r2,r2,r3
8113cf78:	10800f04 	addi	r2,r2,60
8113cf7c:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113cf80:	e0bffc17 	ldw	r2,-16(fp)
8113cf84:	10800044 	addi	r2,r2,1
8113cf88:	e0bffc15 	stw	r2,-16(fp)
8113cf8c:	e0bffc17 	ldw	r2,-16(fp)
8113cf90:	10800510 	cmplti	r2,r2,20
8113cf94:	103ff31e 	bne	r2,zero,8113cf64 <__reset+0xfb11cf64>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113cf98:	00800044 	movi	r2,1
8113cf9c:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113cfa0:	00000106 	br	8113cfa8 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113cfa4:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113cfa8:	e0bffb17 	ldw	r2,-20(fp)
}
8113cfac:	e037883a 	mov	sp,fp
8113cfb0:	dfc00117 	ldw	ra,4(sp)
8113cfb4:	df000017 	ldw	fp,0(sp)
8113cfb8:	dec00204 	addi	sp,sp,8
8113cfbc:	f800283a 	ret

8113cfc0 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113cfc0:	defffc04 	addi	sp,sp,-16
8113cfc4:	de00012e 	bgeu	sp,et,8113cfcc <Look_for_FAT16+0xc>
8113cfc8:	003b68fa 	trap	3
8113cfcc:	dfc00315 	stw	ra,12(sp)
8113cfd0:	df000215 	stw	fp,8(sp)
8113cfd4:	df000204 	addi	fp,sp,8
	bool result = false;
8113cfd8:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113cfdc:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113cfe0:	10002e26 	beq	r2,zero,8113d09c <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113cfe4:	d0a0b217 	ldw	r2,-32056(gp)
8113cfe8:	1080000b 	ldhu	r2,0(r2)
8113cfec:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113cff0:	d020b615 	stw	zero,-32040(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113cff4:	d020b715 	stw	zero,-32036(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113cff8:	e0bfff0f 	ldh	r2,-4(fp)
8113cffc:	10002716 	blt	r2,zero,8113d09c <Look_for_FAT16+0xdc>
8113d000:	e0bfff0b 	ldhu	r2,-4(fp)
8113d004:	10bfffcc 	andi	r2,r2,65535
8113d008:	1083000c 	andi	r2,r2,3072
8113d00c:	10830020 	cmpeqi	r2,r2,3072
8113d010:	1000221e 	bne	r2,zero,8113d09c <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113d014:	e0bfff0b 	ldhu	r2,-4(fp)
8113d018:	10bfffcc 	andi	r2,r2,65535
8113d01c:	1083000c 	andi	r2,r2,3072
8113d020:	10810018 	cmpnei	r2,r2,1024
8113d024:	1000031e 	bne	r2,zero,8113d034 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113d028:	0009883a 	mov	r4,zero
8113d02c:	113c9380 	call	8113c938 <Check_for_DOS_FAT>
8113d030:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113d034:	e0bfff0b 	ldhu	r2,-4(fp)
8113d038:	10bfffcc 	andi	r2,r2,65535
8113d03c:	1083000c 	andi	r2,r2,3072
8113d040:	1000061e 	bne	r2,zero,8113d05c <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113d044:	113c2740 	call	8113c274 <Check_for_Master_Boot_Record>
8113d048:	10000426 	beq	r2,zero,8113d05c <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113d04c:	d0a0b617 	ldw	r2,-32040(gp)
8113d050:	1009883a 	mov	r4,r2
8113d054:	113c9380 	call	8113c938 <Check_for_DOS_FAT>
8113d058:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113d05c:	e0bffe17 	ldw	r2,-8(fp)
8113d060:	10800058 	cmpnei	r2,r2,1
8113d064:	10000d1e 	bne	r2,zero,8113d09c <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113d068:	00a045b4 	movhi	r2,33046
8113d06c:	1094fb04 	addi	r2,r2,21484
8113d070:	10801083 	ldbu	r2,66(r2)
8113d074:	10803fcc 	andi	r2,r2,255
8113d078:	10800420 	cmpeqi	r2,r2,16
8113d07c:	1000021e 	bne	r2,zero,8113d088 <Look_for_FAT16+0xc8>
				{
					result = false;
8113d080:	e03ffe15 	stw	zero,-8(fp)
8113d084:	00000506 	br	8113d09c <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113d088:	00a045b4 	movhi	r2,33046
8113d08c:	1094fb04 	addi	r2,r2,21484
8113d090:	1080058b 	ldhu	r2,22(r2)
8113d094:	10bfffcc 	andi	r2,r2,65535
8113d098:	d0a0b715 	stw	r2,-32036(gp)
				}
			}
		}
	}
	return result;
8113d09c:	e0bffe17 	ldw	r2,-8(fp)
}
8113d0a0:	e037883a 	mov	sp,fp
8113d0a4:	dfc00117 	ldw	ra,4(sp)
8113d0a8:	df000017 	ldw	fp,0(sp)
8113d0ac:	dec00204 	addi	sp,sp,8
8113d0b0:	f800283a 	ret

8113d0b4 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113d0b4:	defffb04 	addi	sp,sp,-20
8113d0b8:	de00012e 	bgeu	sp,et,8113d0c0 <filename_to_upper_case+0xc>
8113d0bc:	003b68fa 	trap	3
8113d0c0:	dfc00415 	stw	ra,16(sp)
8113d0c4:	df000315 	stw	fp,12(sp)
8113d0c8:	df000304 	addi	fp,sp,12
8113d0cc:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113d0d0:	e13fff17 	ldw	r4,-4(fp)
8113d0d4:	111c5040 	call	8111c504 <strlen>
8113d0d8:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113d0dc:	e03ffd15 	stw	zero,-12(fp)
8113d0e0:	00001e06 	br	8113d15c <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113d0e4:	e0bffd17 	ldw	r2,-12(fp)
8113d0e8:	e0ffff17 	ldw	r3,-4(fp)
8113d0ec:	1885883a 	add	r2,r3,r2
8113d0f0:	10800003 	ldbu	r2,0(r2)
8113d0f4:	10803fcc 	andi	r2,r2,255
8113d0f8:	1080201c 	xori	r2,r2,128
8113d0fc:	10bfe004 	addi	r2,r2,-128
8113d100:	10801850 	cmplti	r2,r2,97
8113d104:	1000121e 	bne	r2,zero,8113d150 <filename_to_upper_case+0x9c>
8113d108:	e0bffd17 	ldw	r2,-12(fp)
8113d10c:	e0ffff17 	ldw	r3,-4(fp)
8113d110:	1885883a 	add	r2,r3,r2
8113d114:	10800003 	ldbu	r2,0(r2)
8113d118:	10803fcc 	andi	r2,r2,255
8113d11c:	1080201c 	xori	r2,r2,128
8113d120:	10bfe004 	addi	r2,r2,-128
8113d124:	10801ec8 	cmpgei	r2,r2,123
8113d128:	1000091e 	bne	r2,zero,8113d150 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113d12c:	e0bffd17 	ldw	r2,-12(fp)
8113d130:	e0ffff17 	ldw	r3,-4(fp)
8113d134:	1885883a 	add	r2,r3,r2
8113d138:	e0fffd17 	ldw	r3,-12(fp)
8113d13c:	e13fff17 	ldw	r4,-4(fp)
8113d140:	20c7883a 	add	r3,r4,r3
8113d144:	18c00003 	ldbu	r3,0(r3)
8113d148:	18fff804 	addi	r3,r3,-32
8113d14c:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113d150:	e0bffd17 	ldw	r2,-12(fp)
8113d154:	10800044 	addi	r2,r2,1
8113d158:	e0bffd15 	stw	r2,-12(fp)
8113d15c:	e0fffd17 	ldw	r3,-12(fp)
8113d160:	e0bffe17 	ldw	r2,-8(fp)
8113d164:	18bfdf16 	blt	r3,r2,8113d0e4 <__reset+0xfb11d0e4>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113d168:	0001883a 	nop
8113d16c:	e037883a 	mov	sp,fp
8113d170:	dfc00117 	ldw	ra,4(sp)
8113d174:	df000017 	ldw	fp,0(sp)
8113d178:	dec00204 	addi	sp,sp,8
8113d17c:	f800283a 	ret

8113d180 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113d180:	defff804 	addi	sp,sp,-32
8113d184:	de00012e 	bgeu	sp,et,8113d18c <check_file_name_for_FAT16_compliance+0xc>
8113d188:	003b68fa 	trap	3
8113d18c:	dfc00715 	stw	ra,28(sp)
8113d190:	df000615 	stw	fp,24(sp)
8113d194:	df000604 	addi	fp,sp,24
8113d198:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113d19c:	e13fff17 	ldw	r4,-4(fp)
8113d1a0:	111c5040 	call	8111c504 <strlen>
8113d1a4:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8113d1a8:	00bfffc4 	movi	r2,-1
8113d1ac:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113d1b0:	00bfffc4 	movi	r2,-1
8113d1b4:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8113d1b8:	00800044 	movi	r2,1
8113d1bc:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113d1c0:	e03ffa15 	stw	zero,-24(fp)
8113d1c4:	00006d06 	br	8113d37c <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8113d1c8:	e0bffa17 	ldw	r2,-24(fp)
8113d1cc:	e0ffff17 	ldw	r3,-4(fp)
8113d1d0:	1885883a 	add	r2,r3,r2
8113d1d4:	10800003 	ldbu	r2,0(r2)
8113d1d8:	10803fcc 	andi	r2,r2,255
8113d1dc:	1080201c 	xori	r2,r2,128
8113d1e0:	10bfe004 	addi	r2,r2,-128
8113d1e4:	10800820 	cmpeqi	r2,r2,32
8113d1e8:	10003e1e 	bne	r2,zero,8113d2e4 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113d1ec:	e0bffa17 	ldw	r2,-24(fp)
8113d1f0:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8113d1f4:	e0bffb17 	ldw	r2,-20(fp)
8113d1f8:	1880121e 	bne	r3,r2,8113d244 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113d1fc:	e0bffa17 	ldw	r2,-24(fp)
8113d200:	e0ffff17 	ldw	r3,-4(fp)
8113d204:	1885883a 	add	r2,r3,r2
8113d208:	10800003 	ldbu	r2,0(r2)
8113d20c:	10803fcc 	andi	r2,r2,255
8113d210:	1080201c 	xori	r2,r2,128
8113d214:	10bfe004 	addi	r2,r2,-128
8113d218:	10801720 	cmpeqi	r2,r2,92
8113d21c:	1000311e 	bne	r2,zero,8113d2e4 <check_file_name_for_FAT16_compliance+0x164>
8113d220:	e0bffa17 	ldw	r2,-24(fp)
8113d224:	e0ffff17 	ldw	r3,-4(fp)
8113d228:	1885883a 	add	r2,r3,r2
8113d22c:	10800003 	ldbu	r2,0(r2)
8113d230:	10803fcc 	andi	r2,r2,255
8113d234:	1080201c 	xori	r2,r2,128
8113d238:	10bfe004 	addi	r2,r2,-128
8113d23c:	10800be0 	cmpeqi	r2,r2,47
8113d240:	1000281e 	bne	r2,zero,8113d2e4 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113d244:	e0fffa17 	ldw	r3,-24(fp)
8113d248:	e0bffc17 	ldw	r2,-16(fp)
8113d24c:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113d250:	10800258 	cmpnei	r2,r2,9
8113d254:	1000091e 	bne	r2,zero,8113d27c <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113d258:	e0bffa17 	ldw	r2,-24(fp)
8113d25c:	e0ffff17 	ldw	r3,-4(fp)
8113d260:	1885883a 	add	r2,r3,r2
8113d264:	10800003 	ldbu	r2,0(r2)
8113d268:	10803fcc 	andi	r2,r2,255
8113d26c:	1080201c 	xori	r2,r2,128
8113d270:	10bfe004 	addi	r2,r2,-128
8113d274:	10800b98 	cmpnei	r2,r2,46
8113d278:	10001a1e 	bne	r2,zero,8113d2e4 <check_file_name_for_FAT16_compliance+0x164>
8113d27c:	e0fffb17 	ldw	r3,-20(fp)
8113d280:	e0bffc17 	ldw	r2,-16(fp)
8113d284:	18801926 	beq	r3,r2,8113d2ec <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113d288:	e0fffa17 	ldw	r3,-24(fp)
8113d28c:	e0bffc17 	ldw	r2,-16(fp)
8113d290:	1885c83a 	sub	r2,r3,r2
8113d294:	10800110 	cmplti	r2,r2,4
8113d298:	1000141e 	bne	r2,zero,8113d2ec <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113d29c:	e0bffa17 	ldw	r2,-24(fp)
8113d2a0:	e0ffff17 	ldw	r3,-4(fp)
8113d2a4:	1885883a 	add	r2,r3,r2
8113d2a8:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113d2ac:	10803fcc 	andi	r2,r2,255
8113d2b0:	1080201c 	xori	r2,r2,128
8113d2b4:	10bfe004 	addi	r2,r2,-128
8113d2b8:	10801720 	cmpeqi	r2,r2,92
8113d2bc:	10000b1e 	bne	r2,zero,8113d2ec <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113d2c0:	e0bffa17 	ldw	r2,-24(fp)
8113d2c4:	e0ffff17 	ldw	r3,-4(fp)
8113d2c8:	1885883a 	add	r2,r3,r2
8113d2cc:	10800003 	ldbu	r2,0(r2)
8113d2d0:	10803fcc 	andi	r2,r2,255
8113d2d4:	1080201c 	xori	r2,r2,128
8113d2d8:	10bfe004 	addi	r2,r2,-128
8113d2dc:	10800be0 	cmpeqi	r2,r2,47
8113d2e0:	1000021e 	bne	r2,zero,8113d2ec <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8113d2e4:	e03ffd15 	stw	zero,-12(fp)
            break;
8113d2e8:	00002706 	br	8113d388 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8113d2ec:	e0bffa17 	ldw	r2,-24(fp)
8113d2f0:	e0ffff17 	ldw	r3,-4(fp)
8113d2f4:	1885883a 	add	r2,r3,r2
8113d2f8:	10800003 	ldbu	r2,0(r2)
8113d2fc:	10803fcc 	andi	r2,r2,255
8113d300:	1080201c 	xori	r2,r2,128
8113d304:	10bfe004 	addi	r2,r2,-128
8113d308:	10801720 	cmpeqi	r2,r2,92
8113d30c:	1000091e 	bne	r2,zero,8113d334 <check_file_name_for_FAT16_compliance+0x1b4>
8113d310:	e0bffa17 	ldw	r2,-24(fp)
8113d314:	e0ffff17 	ldw	r3,-4(fp)
8113d318:	1885883a 	add	r2,r3,r2
8113d31c:	10800003 	ldbu	r2,0(r2)
8113d320:	10803fcc 	andi	r2,r2,255
8113d324:	1080201c 	xori	r2,r2,128
8113d328:	10bfe004 	addi	r2,r2,-128
8113d32c:	10800bd8 	cmpnei	r2,r2,47
8113d330:	1000041e 	bne	r2,zero,8113d344 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8113d334:	e0bffa17 	ldw	r2,-24(fp)
8113d338:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113d33c:	e0bffa17 	ldw	r2,-24(fp)
8113d340:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8113d344:	e0bffa17 	ldw	r2,-24(fp)
8113d348:	e0ffff17 	ldw	r3,-4(fp)
8113d34c:	1885883a 	add	r2,r3,r2
8113d350:	10800003 	ldbu	r2,0(r2)
8113d354:	10803fcc 	andi	r2,r2,255
8113d358:	1080201c 	xori	r2,r2,128
8113d35c:	10bfe004 	addi	r2,r2,-128
8113d360:	10800b98 	cmpnei	r2,r2,46
8113d364:	1000021e 	bne	r2,zero,8113d370 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113d368:	e0bffa17 	ldw	r2,-24(fp)
8113d36c:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113d370:	e0bffa17 	ldw	r2,-24(fp)
8113d374:	10800044 	addi	r2,r2,1
8113d378:	e0bffa15 	stw	r2,-24(fp)
8113d37c:	e0fffa17 	ldw	r3,-24(fp)
8113d380:	e0bffe17 	ldw	r2,-8(fp)
8113d384:	18bf9016 	blt	r3,r2,8113d1c8 <__reset+0xfb11d1c8>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8113d388:	e0bffe17 	ldw	r2,-8(fp)
8113d38c:	10bfffc4 	addi	r2,r2,-1
8113d390:	e0ffff17 	ldw	r3,-4(fp)
8113d394:	1885883a 	add	r2,r3,r2
8113d398:	10800003 	ldbu	r2,0(r2)
8113d39c:	10803fcc 	andi	r2,r2,255
8113d3a0:	1080201c 	xori	r2,r2,128
8113d3a4:	10bfe004 	addi	r2,r2,-128
8113d3a8:	10801720 	cmpeqi	r2,r2,92
8113d3ac:	10000a1e 	bne	r2,zero,8113d3d8 <check_file_name_for_FAT16_compliance+0x258>
8113d3b0:	e0bffe17 	ldw	r2,-8(fp)
8113d3b4:	10bfffc4 	addi	r2,r2,-1
8113d3b8:	e0ffff17 	ldw	r3,-4(fp)
8113d3bc:	1885883a 	add	r2,r3,r2
8113d3c0:	10800003 	ldbu	r2,0(r2)
8113d3c4:	10803fcc 	andi	r2,r2,255
8113d3c8:	1080201c 	xori	r2,r2,128
8113d3cc:	10bfe004 	addi	r2,r2,-128
8113d3d0:	10800bd8 	cmpnei	r2,r2,47
8113d3d4:	1000011e 	bne	r2,zero,8113d3dc <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8113d3d8:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8113d3dc:	e0bffd17 	ldw	r2,-12(fp)
}
8113d3e0:	e037883a 	mov	sp,fp
8113d3e4:	dfc00117 	ldw	ra,4(sp)
8113d3e8:	df000017 	ldw	fp,0(sp)
8113d3ec:	dec00204 	addi	sp,sp,8
8113d3f0:	f800283a 	ret

8113d3f4 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8113d3f4:	defffb04 	addi	sp,sp,-20
8113d3f8:	de00012e 	bgeu	sp,et,8113d400 <get_dir_divider_location+0xc>
8113d3fc:	003b68fa 	trap	3
8113d400:	dfc00415 	stw	ra,16(sp)
8113d404:	df000315 	stw	fp,12(sp)
8113d408:	df000304 	addi	fp,sp,12
8113d40c:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8113d410:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8113d414:	e13fff17 	ldw	r4,-4(fp)
8113d418:	111c5040 	call	8111c504 <strlen>
8113d41c:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8113d420:	e03ffd15 	stw	zero,-12(fp)
8113d424:	00001506 	br	8113d47c <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113d428:	e0bffd17 	ldw	r2,-12(fp)
8113d42c:	e0ffff17 	ldw	r3,-4(fp)
8113d430:	1885883a 	add	r2,r3,r2
8113d434:	10800003 	ldbu	r2,0(r2)
8113d438:	10803fcc 	andi	r2,r2,255
8113d43c:	1080201c 	xori	r2,r2,128
8113d440:	10bfe004 	addi	r2,r2,-128
8113d444:	10801720 	cmpeqi	r2,r2,92
8113d448:	10000f1e 	bne	r2,zero,8113d488 <get_dir_divider_location+0x94>
8113d44c:	e0bffd17 	ldw	r2,-12(fp)
8113d450:	e0ffff17 	ldw	r3,-4(fp)
8113d454:	1885883a 	add	r2,r3,r2
8113d458:	10800003 	ldbu	r2,0(r2)
8113d45c:	10803fcc 	andi	r2,r2,255
8113d460:	1080201c 	xori	r2,r2,128
8113d464:	10bfe004 	addi	r2,r2,-128
8113d468:	10800be0 	cmpeqi	r2,r2,47
8113d46c:	1000061e 	bne	r2,zero,8113d488 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113d470:	e0bffd17 	ldw	r2,-12(fp)
8113d474:	10800044 	addi	r2,r2,1
8113d478:	e0bffd15 	stw	r2,-12(fp)
8113d47c:	e0fffd17 	ldw	r3,-12(fp)
8113d480:	e0bffe17 	ldw	r2,-8(fp)
8113d484:	18bfe816 	blt	r3,r2,8113d428 <__reset+0xfb11d428>
        {
            break;
        }
    }
    
    if (index == length)
8113d488:	e0fffd17 	ldw	r3,-12(fp)
8113d48c:	e0bffe17 	ldw	r2,-8(fp)
8113d490:	1880021e 	bne	r3,r2,8113d49c <get_dir_divider_location+0xa8>
    {
        index = -1;
8113d494:	00bfffc4 	movi	r2,-1
8113d498:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113d49c:	e0bffd17 	ldw	r2,-12(fp)
}
8113d4a0:	e037883a 	mov	sp,fp
8113d4a4:	dfc00117 	ldw	ra,4(sp)
8113d4a8:	df000017 	ldw	fp,0(sp)
8113d4ac:	dec00204 	addi	sp,sp,8
8113d4b0:	f800283a 	ret

8113d4b4 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8113d4b4:	defffa04 	addi	sp,sp,-24
8113d4b8:	de00012e 	bgeu	sp,et,8113d4c0 <match_file_record_to_name_ext+0xc>
8113d4bc:	003b68fa 	trap	3
8113d4c0:	df000515 	stw	fp,20(sp)
8113d4c4:	df000504 	addi	fp,sp,20
8113d4c8:	e13ffd15 	stw	r4,-12(fp)
8113d4cc:	e17ffe15 	stw	r5,-8(fp)
8113d4d0:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8113d4d4:	00800044 	movi	r2,1
8113d4d8:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8113d4dc:	e03ffc15 	stw	zero,-16(fp)
8113d4e0:	00004606 	br	8113d5fc <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8113d4e4:	e0fffd17 	ldw	r3,-12(fp)
8113d4e8:	e0bffc17 	ldw	r2,-16(fp)
8113d4ec:	1885883a 	add	r2,r3,r2
8113d4f0:	10800003 	ldbu	r2,0(r2)
8113d4f4:	10803fcc 	andi	r2,r2,255
8113d4f8:	10801870 	cmpltui	r2,r2,97
8113d4fc:	1000101e 	bne	r2,zero,8113d540 <match_file_record_to_name_ext+0x8c>
8113d500:	e0fffd17 	ldw	r3,-12(fp)
8113d504:	e0bffc17 	ldw	r2,-16(fp)
8113d508:	1885883a 	add	r2,r3,r2
8113d50c:	10800003 	ldbu	r2,0(r2)
8113d510:	10803fcc 	andi	r2,r2,255
8113d514:	10801ee8 	cmpgeui	r2,r2,123
8113d518:	1000091e 	bne	r2,zero,8113d540 <match_file_record_to_name_ext+0x8c>
8113d51c:	e0fffd17 	ldw	r3,-12(fp)
8113d520:	e0bffc17 	ldw	r2,-16(fp)
8113d524:	1885883a 	add	r2,r3,r2
8113d528:	10800003 	ldbu	r2,0(r2)
8113d52c:	10bff804 	addi	r2,r2,-32
8113d530:	10c03fcc 	andi	r3,r2,255
8113d534:	18c0201c 	xori	r3,r3,128
8113d538:	18ffe004 	addi	r3,r3,-128
8113d53c:	00000706 	br	8113d55c <match_file_record_to_name_ext+0xa8>
8113d540:	e0fffd17 	ldw	r3,-12(fp)
8113d544:	e0bffc17 	ldw	r2,-16(fp)
8113d548:	1885883a 	add	r2,r3,r2
8113d54c:	10800003 	ldbu	r2,0(r2)
8113d550:	10c03fcc 	andi	r3,r2,255
8113d554:	18c0201c 	xori	r3,r3,128
8113d558:	18ffe004 	addi	r3,r3,-128
8113d55c:	e0bffc17 	ldw	r2,-16(fp)
8113d560:	e13ffe17 	ldw	r4,-8(fp)
8113d564:	2085883a 	add	r2,r4,r2
8113d568:	10800003 	ldbu	r2,0(r2)
8113d56c:	10803fcc 	andi	r2,r2,255
8113d570:	1080201c 	xori	r2,r2,128
8113d574:	10bfe004 	addi	r2,r2,-128
8113d578:	10801850 	cmplti	r2,r2,97
8113d57c:	1000121e 	bne	r2,zero,8113d5c8 <match_file_record_to_name_ext+0x114>
8113d580:	e0bffc17 	ldw	r2,-16(fp)
8113d584:	e13ffe17 	ldw	r4,-8(fp)
8113d588:	2085883a 	add	r2,r4,r2
8113d58c:	10800003 	ldbu	r2,0(r2)
8113d590:	10803fcc 	andi	r2,r2,255
8113d594:	1080201c 	xori	r2,r2,128
8113d598:	10bfe004 	addi	r2,r2,-128
8113d59c:	10801ec8 	cmpgei	r2,r2,123
8113d5a0:	1000091e 	bne	r2,zero,8113d5c8 <match_file_record_to_name_ext+0x114>
8113d5a4:	e0bffc17 	ldw	r2,-16(fp)
8113d5a8:	e13ffe17 	ldw	r4,-8(fp)
8113d5ac:	2085883a 	add	r2,r4,r2
8113d5b0:	10800003 	ldbu	r2,0(r2)
8113d5b4:	10bff804 	addi	r2,r2,-32
8113d5b8:	10803fcc 	andi	r2,r2,255
8113d5bc:	1080201c 	xori	r2,r2,128
8113d5c0:	10bfe004 	addi	r2,r2,-128
8113d5c4:	00000706 	br	8113d5e4 <match_file_record_to_name_ext+0x130>
8113d5c8:	e0bffc17 	ldw	r2,-16(fp)
8113d5cc:	e13ffe17 	ldw	r4,-8(fp)
8113d5d0:	2085883a 	add	r2,r4,r2
8113d5d4:	10800003 	ldbu	r2,0(r2)
8113d5d8:	10803fcc 	andi	r2,r2,255
8113d5dc:	1080201c 	xori	r2,r2,128
8113d5e0:	10bfe004 	addi	r2,r2,-128
8113d5e4:	18800226 	beq	r3,r2,8113d5f0 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113d5e8:	e03ffb15 	stw	zero,-20(fp)
			break;
8113d5ec:	00000606 	br	8113d608 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8113d5f0:	e0bffc17 	ldw	r2,-16(fp)
8113d5f4:	10800044 	addi	r2,r2,1
8113d5f8:	e0bffc15 	stw	r2,-16(fp)
8113d5fc:	e0bffc17 	ldw	r2,-16(fp)
8113d600:	10800210 	cmplti	r2,r2,8
8113d604:	103fb71e 	bne	r2,zero,8113d4e4 <__reset+0xfb11d4e4>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113d608:	e03ffc15 	stw	zero,-16(fp)
8113d60c:	00004a06 	br	8113d738 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8113d610:	e0fffd17 	ldw	r3,-12(fp)
8113d614:	e0bffc17 	ldw	r2,-16(fp)
8113d618:	1885883a 	add	r2,r3,r2
8113d61c:	10800204 	addi	r2,r2,8
8113d620:	10800003 	ldbu	r2,0(r2)
8113d624:	10803fcc 	andi	r2,r2,255
8113d628:	10801870 	cmpltui	r2,r2,97
8113d62c:	1000121e 	bne	r2,zero,8113d678 <match_file_record_to_name_ext+0x1c4>
8113d630:	e0fffd17 	ldw	r3,-12(fp)
8113d634:	e0bffc17 	ldw	r2,-16(fp)
8113d638:	1885883a 	add	r2,r3,r2
8113d63c:	10800204 	addi	r2,r2,8
8113d640:	10800003 	ldbu	r2,0(r2)
8113d644:	10803fcc 	andi	r2,r2,255
8113d648:	10801ee8 	cmpgeui	r2,r2,123
8113d64c:	10000a1e 	bne	r2,zero,8113d678 <match_file_record_to_name_ext+0x1c4>
8113d650:	e0fffd17 	ldw	r3,-12(fp)
8113d654:	e0bffc17 	ldw	r2,-16(fp)
8113d658:	1885883a 	add	r2,r3,r2
8113d65c:	10800204 	addi	r2,r2,8
8113d660:	10800003 	ldbu	r2,0(r2)
8113d664:	10bff804 	addi	r2,r2,-32
8113d668:	10c03fcc 	andi	r3,r2,255
8113d66c:	18c0201c 	xori	r3,r3,128
8113d670:	18ffe004 	addi	r3,r3,-128
8113d674:	00000806 	br	8113d698 <match_file_record_to_name_ext+0x1e4>
8113d678:	e0fffd17 	ldw	r3,-12(fp)
8113d67c:	e0bffc17 	ldw	r2,-16(fp)
8113d680:	1885883a 	add	r2,r3,r2
8113d684:	10800204 	addi	r2,r2,8
8113d688:	10800003 	ldbu	r2,0(r2)
8113d68c:	10c03fcc 	andi	r3,r2,255
8113d690:	18c0201c 	xori	r3,r3,128
8113d694:	18ffe004 	addi	r3,r3,-128
8113d698:	e0bffc17 	ldw	r2,-16(fp)
8113d69c:	e13fff17 	ldw	r4,-4(fp)
8113d6a0:	2085883a 	add	r2,r4,r2
8113d6a4:	10800003 	ldbu	r2,0(r2)
8113d6a8:	10803fcc 	andi	r2,r2,255
8113d6ac:	1080201c 	xori	r2,r2,128
8113d6b0:	10bfe004 	addi	r2,r2,-128
8113d6b4:	10801850 	cmplti	r2,r2,97
8113d6b8:	1000121e 	bne	r2,zero,8113d704 <match_file_record_to_name_ext+0x250>
8113d6bc:	e0bffc17 	ldw	r2,-16(fp)
8113d6c0:	e13fff17 	ldw	r4,-4(fp)
8113d6c4:	2085883a 	add	r2,r4,r2
8113d6c8:	10800003 	ldbu	r2,0(r2)
8113d6cc:	10803fcc 	andi	r2,r2,255
8113d6d0:	1080201c 	xori	r2,r2,128
8113d6d4:	10bfe004 	addi	r2,r2,-128
8113d6d8:	10801ec8 	cmpgei	r2,r2,123
8113d6dc:	1000091e 	bne	r2,zero,8113d704 <match_file_record_to_name_ext+0x250>
8113d6e0:	e0bffc17 	ldw	r2,-16(fp)
8113d6e4:	e13fff17 	ldw	r4,-4(fp)
8113d6e8:	2085883a 	add	r2,r4,r2
8113d6ec:	10800003 	ldbu	r2,0(r2)
8113d6f0:	10bff804 	addi	r2,r2,-32
8113d6f4:	10803fcc 	andi	r2,r2,255
8113d6f8:	1080201c 	xori	r2,r2,128
8113d6fc:	10bfe004 	addi	r2,r2,-128
8113d700:	00000706 	br	8113d720 <match_file_record_to_name_ext+0x26c>
8113d704:	e0bffc17 	ldw	r2,-16(fp)
8113d708:	e13fff17 	ldw	r4,-4(fp)
8113d70c:	2085883a 	add	r2,r4,r2
8113d710:	10800003 	ldbu	r2,0(r2)
8113d714:	10803fcc 	andi	r2,r2,255
8113d718:	1080201c 	xori	r2,r2,128
8113d71c:	10bfe004 	addi	r2,r2,-128
8113d720:	18800226 	beq	r3,r2,8113d72c <match_file_record_to_name_ext+0x278>
        {
            match = false;
8113d724:	e03ffb15 	stw	zero,-20(fp)
			break;
8113d728:	00000606 	br	8113d744 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113d72c:	e0bffc17 	ldw	r2,-16(fp)
8113d730:	10800044 	addi	r2,r2,1
8113d734:	e0bffc15 	stw	r2,-16(fp)
8113d738:	e0bffc17 	ldw	r2,-16(fp)
8113d73c:	108000d0 	cmplti	r2,r2,3
8113d740:	103fb31e 	bne	r2,zero,8113d610 <__reset+0xfb11d610>
        {
            match = false;
			break;
        }
    }
	return match;
8113d744:	e0bffb17 	ldw	r2,-20(fp)
}
8113d748:	e037883a 	mov	sp,fp
8113d74c:	df000017 	ldw	fp,0(sp)
8113d750:	dec00104 	addi	sp,sp,4
8113d754:	f800283a 	ret

8113d758 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113d758:	deffe704 	addi	sp,sp,-100
8113d75c:	de00012e 	bgeu	sp,et,8113d764 <get_home_directory_cluster_for_file+0xc>
8113d760:	003b68fa 	trap	3
8113d764:	dfc01815 	stw	ra,96(sp)
8113d768:	df001715 	stw	fp,92(sp)
8113d76c:	df001704 	addi	fp,sp,92
8113d770:	e13ffd15 	stw	r4,-12(fp)
8113d774:	e17ffe15 	stw	r5,-8(fp)
8113d778:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113d77c:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8113d780:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8113d784:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8113d788:	e13ffd17 	ldw	r4,-12(fp)
8113d78c:	113d3f40 	call	8113d3f4 <get_dir_divider_location>
8113d790:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8113d794:	00012f06 	br	8113dc54 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113d798:	00800804 	movi	r2,32
8113d79c:	e0bff905 	stb	r2,-28(fp)
8113d7a0:	00800804 	movi	r2,32
8113d7a4:	e0bff945 	stb	r2,-27(fp)
8113d7a8:	00800804 	movi	r2,32
8113d7ac:	e0bff985 	stb	r2,-26(fp)
8113d7b0:	00800804 	movi	r2,32
8113d7b4:	e0bff9c5 	stb	r2,-25(fp)
8113d7b8:	00800804 	movi	r2,32
8113d7bc:	e0bffa05 	stb	r2,-24(fp)
8113d7c0:	00800804 	movi	r2,32
8113d7c4:	e0bffa45 	stb	r2,-23(fp)
8113d7c8:	00800804 	movi	r2,32
8113d7cc:	e0bffa85 	stb	r2,-22(fp)
8113d7d0:	00800804 	movi	r2,32
8113d7d4:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8113d7d8:	00800804 	movi	r2,32
8113d7dc:	e0bffb05 	stb	r2,-20(fp)
8113d7e0:	00800804 	movi	r2,32
8113d7e4:	e0bffb45 	stb	r2,-19(fp)
8113d7e8:	00800804 	movi	r2,32
8113d7ec:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8113d7f0:	00bfffc4 	movi	r2,-1
8113d7f4:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113d7f8:	e0bfea17 	ldw	r2,-88(fp)
8113d7fc:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113d800:	e03fec15 	stw	zero,-80(fp)
8113d804:	00002d06 	br	8113d8bc <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113d808:	e0ffec17 	ldw	r3,-80(fp)
8113d80c:	e0bfed17 	ldw	r2,-76(fp)
8113d810:	1885883a 	add	r2,r3,r2
8113d814:	1007883a 	mov	r3,r2
8113d818:	e0bffd17 	ldw	r2,-12(fp)
8113d81c:	10c5883a 	add	r2,r2,r3
8113d820:	10800003 	ldbu	r2,0(r2)
8113d824:	10803fcc 	andi	r2,r2,255
8113d828:	1080201c 	xori	r2,r2,128
8113d82c:	10bfe004 	addi	r2,r2,-128
8113d830:	10800b98 	cmpnei	r2,r2,46
8113d834:	1000031e 	bne	r2,zero,8113d844 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113d838:	e0bfec17 	ldw	r2,-80(fp)
8113d83c:	e0bfee15 	stw	r2,-72(fp)
8113d840:	00001b06 	br	8113d8b0 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8113d844:	e0bfee17 	ldw	r2,-72(fp)
8113d848:	10000c0e 	bge	r2,zero,8113d87c <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8113d84c:	e0ffec17 	ldw	r3,-80(fp)
8113d850:	e0bfed17 	ldw	r2,-76(fp)
8113d854:	1885883a 	add	r2,r3,r2
8113d858:	1007883a 	mov	r3,r2
8113d85c:	e0bffd17 	ldw	r2,-12(fp)
8113d860:	10c5883a 	add	r2,r2,r3
8113d864:	10c00003 	ldbu	r3,0(r2)
8113d868:	e13ff904 	addi	r4,fp,-28
8113d86c:	e0bfec17 	ldw	r2,-80(fp)
8113d870:	2085883a 	add	r2,r4,r2
8113d874:	10c00005 	stb	r3,0(r2)
8113d878:	00000d06 	br	8113d8b0 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8113d87c:	e0ffec17 	ldw	r3,-80(fp)
8113d880:	e0bfee17 	ldw	r2,-72(fp)
8113d884:	1885c83a 	sub	r2,r3,r2
8113d888:	e13fec17 	ldw	r4,-80(fp)
8113d88c:	e0ffed17 	ldw	r3,-76(fp)
8113d890:	20c7883a 	add	r3,r4,r3
8113d894:	1809883a 	mov	r4,r3
8113d898:	e0fffd17 	ldw	r3,-12(fp)
8113d89c:	1907883a 	add	r3,r3,r4
8113d8a0:	18c00003 	ldbu	r3,0(r3)
8113d8a4:	e13ffb04 	addi	r4,fp,-20
8113d8a8:	2085883a 	add	r2,r4,r2
8113d8ac:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113d8b0:	e0bfec17 	ldw	r2,-80(fp)
8113d8b4:	10800044 	addi	r2,r2,1
8113d8b8:	e0bfec15 	stw	r2,-80(fp)
8113d8bc:	e0ffec17 	ldw	r3,-80(fp)
8113d8c0:	e0bfeb17 	ldw	r2,-84(fp)
8113d8c4:	18bfd016 	blt	r3,r2,8113d808 <__reset+0xfb11d808>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8113d8c8:	e0bfea17 	ldw	r2,-88(fp)
8113d8cc:	10005c1e 	bne	r2,zero,8113da40 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113d8d0:	00a045b4 	movhi	r2,33046
8113d8d4:	1094fb04 	addi	r2,r2,21484
8113d8d8:	1080050b 	ldhu	r2,20(r2)
8113d8dc:	10bfffcc 	andi	r2,r2,65535
8113d8e0:	1006917a 	slli	r3,r2,5
8113d8e4:	00a045b4 	movhi	r2,33046
8113d8e8:	1094fb04 	addi	r2,r2,21484
8113d8ec:	1080030b 	ldhu	r2,12(r2)
8113d8f0:	10bfffcc 	andi	r2,r2,65535
8113d8f4:	1885283a 	div	r2,r3,r2
8113d8f8:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113d8fc:	e03ff015 	stw	zero,-64(fp)
8113d900:	00003b06 	br	8113d9f0 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8113d904:	00a045b4 	movhi	r2,33046
8113d908:	1094fb04 	addi	r2,r2,21484
8113d90c:	10c01317 	ldw	r3,76(r2)
8113d910:	e0bff017 	ldw	r2,-64(fp)
8113d914:	1885883a 	add	r2,r3,r2
8113d918:	1007883a 	mov	r3,r2
8113d91c:	d0a0b617 	ldw	r2,-32040(gp)
8113d920:	100b883a 	mov	r5,r2
8113d924:	1809883a 	mov	r4,r3
8113d928:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113d92c:	10003426 	beq	r2,zero,8113da00 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113d930:	e03ff115 	stw	zero,-60(fp)
8113d934:	00002506 	br	8113d9cc <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113d938:	e0bff117 	ldw	r2,-60(fp)
8113d93c:	1004917a 	slli	r2,r2,5
8113d940:	e0fff017 	ldw	r3,-64(fp)
8113d944:	180f883a 	mov	r7,r3
8113d948:	000d883a 	mov	r6,zero
8113d94c:	e17fff17 	ldw	r5,-4(fp)
8113d950:	1009883a 	mov	r4,r2
8113d954:	113c4200 	call	8113c420 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113d958:	e0bfff17 	ldw	r2,-4(fp)
8113d95c:	10800003 	ldbu	r2,0(r2)
8113d960:	10803fcc 	andi	r2,r2,255
8113d964:	10803960 	cmpeqi	r2,r2,229
8113d968:	1000151e 	bne	r2,zero,8113d9c0 <get_home_directory_cluster_for_file+0x268>
8113d96c:	e0bfff17 	ldw	r2,-4(fp)
8113d970:	10800003 	ldbu	r2,0(r2)
8113d974:	10803fcc 	andi	r2,r2,255
8113d978:	10001126 	beq	r2,zero,8113d9c0 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113d97c:	e0fffb04 	addi	r3,fp,-20
8113d980:	e0bff904 	addi	r2,fp,-28
8113d984:	180d883a 	mov	r6,r3
8113d988:	100b883a 	mov	r5,r2
8113d98c:	e13fff17 	ldw	r4,-4(fp)
8113d990:	113d4b40 	call	8113d4b4 <match_file_record_to_name_ext>
8113d994:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8113d998:	e0bff817 	ldw	r2,-32(fp)
8113d99c:	10000826 	beq	r2,zero,8113d9c0 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8113d9a0:	e0bfff17 	ldw	r2,-4(fp)
8113d9a4:	1080058b 	ldhu	r2,22(r2)
8113d9a8:	10bfffcc 	andi	r2,r2,65535
8113d9ac:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8113d9b0:	e0bfff17 	ldw	r2,-4(fp)
8113d9b4:	00c00044 	movi	r3,1
8113d9b8:	10c00a15 	stw	r3,40(r2)
                                break;
8113d9bc:	00000606 	br	8113d9d8 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113d9c0:	e0bff117 	ldw	r2,-60(fp)
8113d9c4:	10800044 	addi	r2,r2,1
8113d9c8:	e0bff115 	stw	r2,-60(fp)
8113d9cc:	e0bff117 	ldw	r2,-60(fp)
8113d9d0:	10800410 	cmplti	r2,r2,16
8113d9d4:	103fd81e 	bne	r2,zero,8113d938 <__reset+0xfb11d938>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8113d9d8:	e0ffef17 	ldw	r3,-68(fp)
8113d9dc:	e0bfea17 	ldw	r2,-88(fp)
8113d9e0:	1880091e 	bne	r3,r2,8113da08 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113d9e4:	e0bff017 	ldw	r2,-64(fp)
8113d9e8:	10800044 	addi	r2,r2,1
8113d9ec:	e0bff015 	stw	r2,-64(fp)
8113d9f0:	e0fff017 	ldw	r3,-64(fp)
8113d9f4:	e0bff717 	ldw	r2,-36(fp)
8113d9f8:	18bfc216 	blt	r3,r2,8113d904 <__reset+0xfb11d904>
8113d9fc:	00000306 	br	8113da0c <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8113da00:	0001883a 	nop
8113da04:	00000106 	br	8113da0c <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113da08:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8113da0c:	e0ffef17 	ldw	r3,-68(fp)
8113da10:	e0bfea17 	ldw	r2,-88(fp)
8113da14:	18800826 	beq	r3,r2,8113da38 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113da18:	e0bfef17 	ldw	r2,-68(fp)
8113da1c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113da20:	e0ffed17 	ldw	r3,-76(fp)
8113da24:	e0bfeb17 	ldw	r2,-84(fp)
8113da28:	1885883a 	add	r2,r3,r2
8113da2c:	10800044 	addi	r2,r2,1
8113da30:	e0bfed15 	stw	r2,-76(fp)
8113da34:	00007d06 	br	8113dc2c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113da38:	0005883a 	mov	r2,zero
8113da3c:	00009106 	br	8113dc84 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8113da40:	e0bfea17 	ldw	r2,-88(fp)
8113da44:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113da48:	e0bff417 	ldw	r2,-48(fp)
8113da4c:	10ffff84 	addi	r3,r2,-2
8113da50:	00a045b4 	movhi	r2,33046
8113da54:	1094fb04 	addi	r2,r2,21484
8113da58:	10800383 	ldbu	r2,14(r2)
8113da5c:	10803fcc 	andi	r2,r2,255
8113da60:	1885383a 	mul	r2,r3,r2
8113da64:	1007883a 	mov	r3,r2
8113da68:	00a045b4 	movhi	r2,33046
8113da6c:	1094fb04 	addi	r2,r2,21484
8113da70:	10801417 	ldw	r2,80(r2)
8113da74:	1885883a 	add	r2,r3,r2
8113da78:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113da7c:	e03ff215 	stw	zero,-56(fp)
8113da80:	00003606 	br	8113db5c <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113da84:	e0fff217 	ldw	r3,-56(fp)
8113da88:	e0bff517 	ldw	r2,-44(fp)
8113da8c:	1885883a 	add	r2,r3,r2
8113da90:	d0e0b617 	ldw	r3,-32040(gp)
8113da94:	180b883a 	mov	r5,r3
8113da98:	1009883a 	mov	r4,r2
8113da9c:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113daa0:	10003526 	beq	r2,zero,8113db78 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113daa4:	e03ff315 	stw	zero,-52(fp)
8113daa8:	00002306 	br	8113db38 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113daac:	e0bff317 	ldw	r2,-52(fp)
8113dab0:	1004917a 	slli	r2,r2,5
8113dab4:	e0fff417 	ldw	r3,-48(fp)
8113dab8:	e13ff217 	ldw	r4,-56(fp)
8113dabc:	200f883a 	mov	r7,r4
8113dac0:	180d883a 	mov	r6,r3
8113dac4:	e17fff17 	ldw	r5,-4(fp)
8113dac8:	1009883a 	mov	r4,r2
8113dacc:	113c4200 	call	8113c420 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113dad0:	e0bfff17 	ldw	r2,-4(fp)
8113dad4:	10800003 	ldbu	r2,0(r2)
8113dad8:	10803fcc 	andi	r2,r2,255
8113dadc:	10803960 	cmpeqi	r2,r2,229
8113dae0:	1000121e 	bne	r2,zero,8113db2c <get_home_directory_cluster_for_file+0x3d4>
8113dae4:	e0bfff17 	ldw	r2,-4(fp)
8113dae8:	10800003 	ldbu	r2,0(r2)
8113daec:	10803fcc 	andi	r2,r2,255
8113daf0:	10000e26 	beq	r2,zero,8113db2c <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8113daf4:	e0fffb04 	addi	r3,fp,-20
8113daf8:	e0bff904 	addi	r2,fp,-28
8113dafc:	180d883a 	mov	r6,r3
8113db00:	100b883a 	mov	r5,r2
8113db04:	e13fff17 	ldw	r4,-4(fp)
8113db08:	113d4b40 	call	8113d4b4 <match_file_record_to_name_ext>
8113db0c:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8113db10:	e0bff617 	ldw	r2,-40(fp)
8113db14:	10000526 	beq	r2,zero,8113db2c <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113db18:	e0bfff17 	ldw	r2,-4(fp)
8113db1c:	1080058b 	ldhu	r2,22(r2)
8113db20:	10bfffcc 	andi	r2,r2,65535
8113db24:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113db28:	00000606 	br	8113db44 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113db2c:	e0bff317 	ldw	r2,-52(fp)
8113db30:	10800044 	addi	r2,r2,1
8113db34:	e0bff315 	stw	r2,-52(fp)
8113db38:	e0bff317 	ldw	r2,-52(fp)
8113db3c:	10800410 	cmplti	r2,r2,16
8113db40:	103fda1e 	bne	r2,zero,8113daac <__reset+0xfb11daac>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8113db44:	e0ffef17 	ldw	r3,-68(fp)
8113db48:	e0bfea17 	ldw	r2,-88(fp)
8113db4c:	18800c1e 	bne	r3,r2,8113db80 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113db50:	e0bff217 	ldw	r2,-56(fp)
8113db54:	10800044 	addi	r2,r2,1
8113db58:	e0bff215 	stw	r2,-56(fp)
8113db5c:	00a045b4 	movhi	r2,33046
8113db60:	1094fb04 	addi	r2,r2,21484
8113db64:	10800383 	ldbu	r2,14(r2)
8113db68:	10803fcc 	andi	r2,r2,255
8113db6c:	e0fff217 	ldw	r3,-56(fp)
8113db70:	18bfc416 	blt	r3,r2,8113da84 <__reset+0xfb11da84>
8113db74:	00000306 	br	8113db84 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113db78:	0001883a 	nop
8113db7c:	00000106 	br	8113db84 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8113db80:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8113db84:	e0ffef17 	ldw	r3,-68(fp)
8113db88:	e0bfea17 	ldw	r2,-88(fp)
8113db8c:	1880141e 	bne	r3,r2,8113dbe0 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8113db90:	e0bfef17 	ldw	r2,-68(fp)
8113db94:	e0fffc04 	addi	r3,fp,-16
8113db98:	180b883a 	mov	r5,r3
8113db9c:	1009883a 	mov	r4,r2
8113dba0:	113c0d00 	call	8113c0d0 <get_cluster_flag>
8113dba4:	10000c26 	beq	r2,zero,8113dbd8 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113dba8:	e0bffc0b 	ldhu	r2,-16(fp)
8113dbac:	10bfffcc 	andi	r2,r2,65535
8113dbb0:	10fffe0c 	andi	r3,r2,65528
8113dbb4:	00bffe14 	movui	r2,65528
8113dbb8:	1880021e 	bne	r3,r2,8113dbc4 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8113dbbc:	0005883a 	mov	r2,zero
8113dbc0:	00003006 	br	8113dc84 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8113dbc4:	e0bffc0b 	ldhu	r2,-16(fp)
8113dbc8:	10bfffcc 	andi	r2,r2,65535
8113dbcc:	10bffe0c 	andi	r2,r2,65528
8113dbd0:	e0bfef15 	stw	r2,-68(fp)
8113dbd4:	00000206 	br	8113dbe0 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8113dbd8:	0005883a 	mov	r2,zero
8113dbdc:	00002906 	br	8113dc84 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8113dbe0:	e0bff417 	ldw	r2,-48(fp)
8113dbe4:	00fffdd4 	movui	r3,65527
8113dbe8:	18800316 	blt	r3,r2,8113dbf8 <get_home_directory_cluster_for_file+0x4a0>
8113dbec:	e0ffef17 	ldw	r3,-68(fp)
8113dbf0:	e0bfea17 	ldw	r2,-88(fp)
8113dbf4:	18bf9426 	beq	r3,r2,8113da48 <__reset+0xfb11da48>
            if (new_cluster != home_dir_cluster)
8113dbf8:	e0ffef17 	ldw	r3,-68(fp)
8113dbfc:	e0bfea17 	ldw	r2,-88(fp)
8113dc00:	18800826 	beq	r3,r2,8113dc24 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113dc04:	e0bfef17 	ldw	r2,-68(fp)
8113dc08:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113dc0c:	e0ffed17 	ldw	r3,-76(fp)
8113dc10:	e0bfeb17 	ldw	r2,-84(fp)
8113dc14:	1885883a 	add	r2,r3,r2
8113dc18:	10800044 	addi	r2,r2,1
8113dc1c:	e0bfed15 	stw	r2,-76(fp)
8113dc20:	00000206 	br	8113dc2c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113dc24:	0005883a 	mov	r2,zero
8113dc28:	00001606 	br	8113dc84 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8113dc2c:	e0bfed17 	ldw	r2,-76(fp)
8113dc30:	e0fffd17 	ldw	r3,-12(fp)
8113dc34:	1885883a 	add	r2,r3,r2
8113dc38:	1009883a 	mov	r4,r2
8113dc3c:	113d3f40 	call	8113d3f4 <get_dir_divider_location>
8113dc40:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8113dc44:	e0bfeb17 	ldw	r2,-84(fp)
8113dc48:	1000020e 	bge	r2,zero,8113dc54 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8113dc4c:	00800044 	movi	r2,1
8113dc50:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8113dc54:	e0bfeb17 	ldw	r2,-84(fp)
8113dc58:	00becf16 	blt	zero,r2,8113d798 <__reset+0xfb11d798>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8113dc5c:	e0bffe17 	ldw	r2,-8(fp)
8113dc60:	e0ffea17 	ldw	r3,-88(fp)
8113dc64:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113dc68:	e0bfea17 	ldw	r2,-88(fp)
8113dc6c:	1000041e 	bne	r2,zero,8113dc80 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8113dc70:	e0bfff17 	ldw	r2,-4(fp)
8113dc74:	10000a15 	stw	zero,40(r2)
		result = true;
8113dc78:	00800044 	movi	r2,1
8113dc7c:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8113dc80:	e0bfe917 	ldw	r2,-92(fp)
}
8113dc84:	e037883a 	mov	sp,fp
8113dc88:	dfc00117 	ldw	ra,4(sp)
8113dc8c:	df000017 	ldw	fp,0(sp)
8113dc90:	dec00204 	addi	sp,sp,8
8113dc94:	f800283a 	ret

8113dc98 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8113dc98:	deffe804 	addi	sp,sp,-96
8113dc9c:	de00012e 	bgeu	sp,et,8113dca4 <find_file_in_directory+0xc>
8113dca0:	003b68fa 	trap	3
8113dca4:	dfc01715 	stw	ra,92(sp)
8113dca8:	df001615 	stw	fp,88(sp)
8113dcac:	df001604 	addi	fp,sp,88
8113dcb0:	e13ffd15 	stw	r4,-12(fp)
8113dcb4:	e17ffe15 	stw	r5,-8(fp)
8113dcb8:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8113dcbc:	e13ffe17 	ldw	r4,-8(fp)
8113dcc0:	113d3f40 	call	8113d3f4 <get_dir_divider_location>
8113dcc4:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8113dcc8:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113dccc:	00800804 	movi	r2,32
8113dcd0:	e0bff905 	stb	r2,-28(fp)
8113dcd4:	00800804 	movi	r2,32
8113dcd8:	e0bff945 	stb	r2,-27(fp)
8113dcdc:	00800804 	movi	r2,32
8113dce0:	e0bff985 	stb	r2,-26(fp)
8113dce4:	00800804 	movi	r2,32
8113dce8:	e0bff9c5 	stb	r2,-25(fp)
8113dcec:	00800804 	movi	r2,32
8113dcf0:	e0bffa05 	stb	r2,-24(fp)
8113dcf4:	00800804 	movi	r2,32
8113dcf8:	e0bffa45 	stb	r2,-23(fp)
8113dcfc:	00800804 	movi	r2,32
8113dd00:	e0bffa85 	stb	r2,-22(fp)
8113dd04:	00800804 	movi	r2,32
8113dd08:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8113dd0c:	00800804 	movi	r2,32
8113dd10:	e0bffb05 	stb	r2,-20(fp)
8113dd14:	00800804 	movi	r2,32
8113dd18:	e0bffb45 	stb	r2,-19(fp)
8113dd1c:	00800804 	movi	r2,32
8113dd20:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8113dd24:	00bfffc4 	movi	r2,-1
8113dd28:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8113dd2c:	e0bffd17 	ldw	r2,-12(fp)
8113dd30:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8113dd34:	e13ffe17 	ldw	r4,-8(fp)
8113dd38:	111c5040 	call	8111c504 <strlen>
8113dd3c:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8113dd40:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113dd44:	00000b06 	br	8113dd74 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113dd48:	e0ffeb17 	ldw	r3,-84(fp)
8113dd4c:	e0bfea17 	ldw	r2,-88(fp)
8113dd50:	1885883a 	add	r2,r3,r2
8113dd54:	10800044 	addi	r2,r2,1
8113dd58:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113dd5c:	e0bfeb17 	ldw	r2,-84(fp)
8113dd60:	e0fffe17 	ldw	r3,-8(fp)
8113dd64:	1885883a 	add	r2,r3,r2
8113dd68:	1009883a 	mov	r4,r2
8113dd6c:	113d3f40 	call	8113d3f4 <get_dir_divider_location>
8113dd70:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113dd74:	e0bfea17 	ldw	r2,-88(fp)
8113dd78:	00bff316 	blt	zero,r2,8113dd48 <__reset+0xfb11dd48>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113dd7c:	e0bfeb17 	ldw	r2,-84(fp)
8113dd80:	e0bfee15 	stw	r2,-72(fp)
8113dd84:	00002706 	br	8113de24 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113dd88:	e0bfee17 	ldw	r2,-72(fp)
8113dd8c:	e0fffe17 	ldw	r3,-8(fp)
8113dd90:	1885883a 	add	r2,r3,r2
8113dd94:	10800003 	ldbu	r2,0(r2)
8113dd98:	10803fcc 	andi	r2,r2,255
8113dd9c:	1080201c 	xori	r2,r2,128
8113dda0:	10bfe004 	addi	r2,r2,-128
8113dda4:	10800b98 	cmpnei	r2,r2,46
8113dda8:	1000031e 	bne	r2,zero,8113ddb8 <find_file_in_directory+0x120>
        {
            ext_index = index;
8113ddac:	e0bfee17 	ldw	r2,-72(fp)
8113ddb0:	e0bfec15 	stw	r2,-80(fp)
8113ddb4:	00001806 	br	8113de18 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8113ddb8:	e0bfec17 	ldw	r2,-80(fp)
8113ddbc:	10000b0e 	bge	r2,zero,8113ddec <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8113ddc0:	e0ffee17 	ldw	r3,-72(fp)
8113ddc4:	e0bfeb17 	ldw	r2,-84(fp)
8113ddc8:	1885c83a 	sub	r2,r3,r2
8113ddcc:	e0ffee17 	ldw	r3,-72(fp)
8113ddd0:	e13ffe17 	ldw	r4,-8(fp)
8113ddd4:	20c7883a 	add	r3,r4,r3
8113ddd8:	18c00003 	ldbu	r3,0(r3)
8113dddc:	e13ff904 	addi	r4,fp,-28
8113dde0:	2085883a 	add	r2,r4,r2
8113dde4:	10c00005 	stb	r3,0(r2)
8113dde8:	00000b06 	br	8113de18 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8113ddec:	e0ffee17 	ldw	r3,-72(fp)
8113ddf0:	e0bfec17 	ldw	r2,-80(fp)
8113ddf4:	1885c83a 	sub	r2,r3,r2
8113ddf8:	10bfffc4 	addi	r2,r2,-1
8113ddfc:	e0ffee17 	ldw	r3,-72(fp)
8113de00:	e13ffe17 	ldw	r4,-8(fp)
8113de04:	20c7883a 	add	r3,r4,r3
8113de08:	18c00003 	ldbu	r3,0(r3)
8113de0c:	e13ffb04 	addi	r4,fp,-20
8113de10:	2085883a 	add	r2,r4,r2
8113de14:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113de18:	e0bfee17 	ldw	r2,-72(fp)
8113de1c:	10800044 	addi	r2,r2,1
8113de20:	e0bfee15 	stw	r2,-72(fp)
8113de24:	e0ffee17 	ldw	r3,-72(fp)
8113de28:	e0bff417 	ldw	r2,-48(fp)
8113de2c:	18bfd616 	blt	r3,r2,8113dd88 <__reset+0xfb11dd88>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8113de30:	e0bffd17 	ldw	r2,-12(fp)
8113de34:	1000461e 	bne	r2,zero,8113df50 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113de38:	00a045b4 	movhi	r2,33046
8113de3c:	1094fb04 	addi	r2,r2,21484
8113de40:	1080050b 	ldhu	r2,20(r2)
8113de44:	10bfffcc 	andi	r2,r2,65535
8113de48:	1006917a 	slli	r3,r2,5
8113de4c:	00a045b4 	movhi	r2,33046
8113de50:	1094fb04 	addi	r2,r2,21484
8113de54:	1080030b 	ldhu	r2,12(r2)
8113de58:	10bfffcc 	andi	r2,r2,65535
8113de5c:	1885283a 	div	r2,r3,r2
8113de60:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113de64:	e03ff015 	stw	zero,-64(fp)
8113de68:	00003506 	br	8113df40 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113de6c:	00a045b4 	movhi	r2,33046
8113de70:	1094fb04 	addi	r2,r2,21484
8113de74:	10c01317 	ldw	r3,76(r2)
8113de78:	e0bff017 	ldw	r2,-64(fp)
8113de7c:	1885883a 	add	r2,r3,r2
8113de80:	1007883a 	mov	r3,r2
8113de84:	d0a0b617 	ldw	r2,-32040(gp)
8113de88:	100b883a 	mov	r5,r2
8113de8c:	1809883a 	mov	r4,r3
8113de90:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113de94:	10009626 	beq	r2,zero,8113e0f0 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113de98:	e03ff115 	stw	zero,-60(fp)
8113de9c:	00002006 	br	8113df20 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113dea0:	e0bff117 	ldw	r2,-60(fp)
8113dea4:	1004917a 	slli	r2,r2,5
8113dea8:	e0fff017 	ldw	r3,-64(fp)
8113deac:	180f883a 	mov	r7,r3
8113deb0:	000d883a 	mov	r6,zero
8113deb4:	e17fff17 	ldw	r5,-4(fp)
8113deb8:	1009883a 	mov	r4,r2
8113debc:	113c4200 	call	8113c420 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113dec0:	e0bfff17 	ldw	r2,-4(fp)
8113dec4:	10800003 	ldbu	r2,0(r2)
8113dec8:	10803fcc 	andi	r2,r2,255
8113decc:	10803960 	cmpeqi	r2,r2,229
8113ded0:	1000101e 	bne	r2,zero,8113df14 <find_file_in_directory+0x27c>
8113ded4:	e0bfff17 	ldw	r2,-4(fp)
8113ded8:	10800003 	ldbu	r2,0(r2)
8113dedc:	10803fcc 	andi	r2,r2,255
8113dee0:	10000c26 	beq	r2,zero,8113df14 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8113dee4:	e0fffb04 	addi	r3,fp,-20
8113dee8:	e0bff904 	addi	r2,fp,-28
8113deec:	180d883a 	mov	r6,r3
8113def0:	100b883a 	mov	r5,r2
8113def4:	e13fff17 	ldw	r4,-4(fp)
8113def8:	113d4b40 	call	8113d4b4 <match_file_record_to_name_ext>
8113defc:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8113df00:	e0bff817 	ldw	r2,-32(fp)
8113df04:	10000326 	beq	r2,zero,8113df14 <find_file_in_directory+0x27c>
                        {
                            result = true;
8113df08:	00800044 	movi	r2,1
8113df0c:	e0bfef15 	stw	r2,-68(fp)
                            break;
8113df10:	00000606 	br	8113df2c <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113df14:	e0bff117 	ldw	r2,-60(fp)
8113df18:	10800044 	addi	r2,r2,1
8113df1c:	e0bff115 	stw	r2,-60(fp)
8113df20:	e0bff117 	ldw	r2,-60(fp)
8113df24:	10800410 	cmplti	r2,r2,16
8113df28:	103fdd1e 	bne	r2,zero,8113dea0 <__reset+0xfb11dea0>
            }
            else
            {
                break;
            }
            if (result)
8113df2c:	e0bfef17 	ldw	r2,-68(fp)
8113df30:	1000711e 	bne	r2,zero,8113e0f8 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113df34:	e0bff017 	ldw	r2,-64(fp)
8113df38:	10800044 	addi	r2,r2,1
8113df3c:	e0bff015 	stw	r2,-64(fp)
8113df40:	e0fff017 	ldw	r3,-64(fp)
8113df44:	e0bff717 	ldw	r2,-36(fp)
8113df48:	18bfc816 	blt	r3,r2,8113de6c <__reset+0xfb11de6c>
8113df4c:	00006b06 	br	8113e0fc <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113df50:	e0bfed17 	ldw	r2,-76(fp)
8113df54:	10ffff84 	addi	r3,r2,-2
8113df58:	00a045b4 	movhi	r2,33046
8113df5c:	1094fb04 	addi	r2,r2,21484
8113df60:	10800383 	ldbu	r2,14(r2)
8113df64:	10803fcc 	andi	r2,r2,255
8113df68:	1885383a 	mul	r2,r3,r2
8113df6c:	1007883a 	mov	r3,r2
8113df70:	00a045b4 	movhi	r2,33046
8113df74:	1094fb04 	addi	r2,r2,21484
8113df78:	10801417 	ldw	r2,80(r2)
8113df7c:	1885883a 	add	r2,r3,r2
8113df80:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113df84:	e03ff215 	stw	zero,-56(fp)
8113df88:	00003306 	br	8113e058 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113df8c:	e0fff217 	ldw	r3,-56(fp)
8113df90:	e0bff517 	ldw	r2,-44(fp)
8113df94:	1885883a 	add	r2,r3,r2
8113df98:	d0e0b617 	ldw	r3,-32040(gp)
8113df9c:	180b883a 	mov	r5,r3
8113dfa0:	1009883a 	mov	r4,r2
8113dfa4:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113dfa8:	10003226 	beq	r2,zero,8113e074 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113dfac:	e03ff315 	stw	zero,-52(fp)
8113dfb0:	00002106 	br	8113e038 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113dfb4:	e0bff317 	ldw	r2,-52(fp)
8113dfb8:	1004917a 	slli	r2,r2,5
8113dfbc:	e0ffed17 	ldw	r3,-76(fp)
8113dfc0:	e13ff217 	ldw	r4,-56(fp)
8113dfc4:	200f883a 	mov	r7,r4
8113dfc8:	180d883a 	mov	r6,r3
8113dfcc:	e17fff17 	ldw	r5,-4(fp)
8113dfd0:	1009883a 	mov	r4,r2
8113dfd4:	113c4200 	call	8113c420 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113dfd8:	e0bfff17 	ldw	r2,-4(fp)
8113dfdc:	10800003 	ldbu	r2,0(r2)
8113dfe0:	10803fcc 	andi	r2,r2,255
8113dfe4:	10803960 	cmpeqi	r2,r2,229
8113dfe8:	1000101e 	bne	r2,zero,8113e02c <find_file_in_directory+0x394>
8113dfec:	e0bfff17 	ldw	r2,-4(fp)
8113dff0:	10800003 	ldbu	r2,0(r2)
8113dff4:	10803fcc 	andi	r2,r2,255
8113dff8:	10000c26 	beq	r2,zero,8113e02c <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113dffc:	e0fffb04 	addi	r3,fp,-20
8113e000:	e0bff904 	addi	r2,fp,-28
8113e004:	180d883a 	mov	r6,r3
8113e008:	100b883a 	mov	r5,r2
8113e00c:	e13fff17 	ldw	r4,-4(fp)
8113e010:	113d4b40 	call	8113d4b4 <match_file_record_to_name_ext>
8113e014:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8113e018:	e0bff617 	ldw	r2,-40(fp)
8113e01c:	10000326 	beq	r2,zero,8113e02c <find_file_in_directory+0x394>
                            {                               
                                result = true;
8113e020:	00800044 	movi	r2,1
8113e024:	e0bfef15 	stw	r2,-68(fp)
                                break;
8113e028:	00000606 	br	8113e044 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113e02c:	e0bff317 	ldw	r2,-52(fp)
8113e030:	10800044 	addi	r2,r2,1
8113e034:	e0bff315 	stw	r2,-52(fp)
8113e038:	e0bff317 	ldw	r2,-52(fp)
8113e03c:	10800410 	cmplti	r2,r2,16
8113e040:	103fdc1e 	bne	r2,zero,8113dfb4 <__reset+0xfb11dfb4>
                }
                else
                {
                    break;
                }
                if (result)
8113e044:	e0bfef17 	ldw	r2,-68(fp)
8113e048:	10000c1e 	bne	r2,zero,8113e07c <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113e04c:	e0bff217 	ldw	r2,-56(fp)
8113e050:	10800044 	addi	r2,r2,1
8113e054:	e0bff215 	stw	r2,-56(fp)
8113e058:	00a045b4 	movhi	r2,33046
8113e05c:	1094fb04 	addi	r2,r2,21484
8113e060:	10800383 	ldbu	r2,14(r2)
8113e064:	10803fcc 	andi	r2,r2,255
8113e068:	e0fff217 	ldw	r3,-56(fp)
8113e06c:	18bfc716 	blt	r3,r2,8113df8c <__reset+0xfb11df8c>
8113e070:	00000306 	br	8113e080 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8113e074:	0001883a 	nop
8113e078:	00000106 	br	8113e080 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113e07c:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8113e080:	e0bfef17 	ldw	r2,-68(fp)
8113e084:	1000141e 	bne	r2,zero,8113e0d8 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8113e088:	e0bfed17 	ldw	r2,-76(fp)
8113e08c:	e0fffc04 	addi	r3,fp,-16
8113e090:	180b883a 	mov	r5,r3
8113e094:	1009883a 	mov	r4,r2
8113e098:	113c0d00 	call	8113c0d0 <get_cluster_flag>
8113e09c:	10000c26 	beq	r2,zero,8113e0d0 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113e0a0:	e0bffc0b 	ldhu	r2,-16(fp)
8113e0a4:	10bfffcc 	andi	r2,r2,65535
8113e0a8:	10fffe0c 	andi	r3,r2,65528
8113e0ac:	00bffe14 	movui	r2,65528
8113e0b0:	1880021e 	bne	r3,r2,8113e0bc <find_file_in_directory+0x424>
					{
						return false;
8113e0b4:	0005883a 	mov	r2,zero
8113e0b8:	00001106 	br	8113e100 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113e0bc:	e0bffc0b 	ldhu	r2,-16(fp)
8113e0c0:	10bfffcc 	andi	r2,r2,65535
8113e0c4:	10bffe0c 	andi	r2,r2,65528
8113e0c8:	e0bfed15 	stw	r2,-76(fp)
8113e0cc:	00000206 	br	8113e0d8 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8113e0d0:	0005883a 	mov	r2,zero
8113e0d4:	00000a06 	br	8113e100 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8113e0d8:	e0bfed17 	ldw	r2,-76(fp)
8113e0dc:	00fffdd4 	movui	r3,65527
8113e0e0:	18800616 	blt	r3,r2,8113e0fc <find_file_in_directory+0x464>
8113e0e4:	e0bfef17 	ldw	r2,-68(fp)
8113e0e8:	103f9926 	beq	r2,zero,8113df50 <__reset+0xfb11df50>
8113e0ec:	00000306 	br	8113e0fc <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8113e0f0:	0001883a 	nop
8113e0f4:	00000106 	br	8113e0fc <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8113e0f8:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8113e0fc:	e0bfef17 	ldw	r2,-68(fp)
}
8113e100:	e037883a 	mov	sp,fp
8113e104:	dfc00117 	ldw	ra,4(sp)
8113e108:	df000017 	ldw	fp,0(sp)
8113e10c:	dec00204 	addi	sp,sp,8
8113e110:	f800283a 	ret

8113e114 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8113e114:	defff504 	addi	sp,sp,-44
8113e118:	de00012e 	bgeu	sp,et,8113e120 <find_first_empty_cluster+0xc>
8113e11c:	003b68fa 	trap	3
8113e120:	dfc00a15 	stw	ra,40(sp)
8113e124:	df000915 	stw	fp,36(sp)
8113e128:	df000904 	addi	fp,sp,36
8113e12c:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8113e130:	00a045b4 	movhi	r2,33046
8113e134:	1094fb04 	addi	r2,r2,21484
8113e138:	10801117 	ldw	r2,68(r2)
8113e13c:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8113e140:	00800084 	movi	r2,2
8113e144:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8113e148:	00bfffc4 	movi	r2,-1
8113e14c:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8113e150:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8113e154:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8113e158:	00a045b4 	movhi	r2,33046
8113e15c:	1094fb04 	addi	r2,r2,21484
8113e160:	10801417 	ldw	r2,80(r2)
8113e164:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8113e168:	00a045b4 	movhi	r2,33046
8113e16c:	1094fb04 	addi	r2,r2,21484
8113e170:	1080058b 	ldhu	r2,22(r2)
8113e174:	10bfffcc 	andi	r2,r2,65535
8113e178:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113e17c:	00a045b4 	movhi	r2,33046
8113e180:	1094fb04 	addi	r2,r2,21484
8113e184:	10800917 	ldw	r2,36(r2)
8113e188:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113e18c:	e0bffd17 	ldw	r2,-12(fp)
8113e190:	e0fffe17 	ldw	r3,-8(fp)
8113e194:	18800b2e 	bgeu	r3,r2,8113e1c4 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113e198:	e0fffd17 	ldw	r3,-12(fp)
8113e19c:	e0bffc17 	ldw	r2,-16(fp)
8113e1a0:	1887c83a 	sub	r3,r3,r2
8113e1a4:	00a045b4 	movhi	r2,33046
8113e1a8:	1094fb04 	addi	r2,r2,21484
8113e1ac:	10800383 	ldbu	r2,14(r2)
8113e1b0:	10803fcc 	andi	r2,r2,255
8113e1b4:	1885203a 	divu	r2,r3,r2
8113e1b8:	10800044 	addi	r2,r2,1
8113e1bc:	e0bffb15 	stw	r2,-20(fp)
8113e1c0:	00002a06 	br	8113e26c <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113e1c4:	e0fffe17 	ldw	r3,-8(fp)
8113e1c8:	e0bffc17 	ldw	r2,-16(fp)
8113e1cc:	1887c83a 	sub	r3,r3,r2
8113e1d0:	00a045b4 	movhi	r2,33046
8113e1d4:	1094fb04 	addi	r2,r2,21484
8113e1d8:	10800383 	ldbu	r2,14(r2)
8113e1dc:	10803fcc 	andi	r2,r2,255
8113e1e0:	1885203a 	divu	r2,r3,r2
8113e1e4:	10800044 	addi	r2,r2,1
8113e1e8:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113e1ec:	00001f06 	br	8113e26c <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8113e1f0:	e0bff717 	ldw	r2,-36(fp)
8113e1f4:	d0e0b617 	ldw	r3,-32040(gp)
8113e1f8:	180b883a 	mov	r5,r3
8113e1fc:	1009883a 	mov	r4,r2
8113e200:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113e204:	10001426 	beq	r2,zero,8113e258 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8113e208:	e0bff817 	ldw	r2,-32(fp)
8113e20c:	10803fcc 	andi	r2,r2,255
8113e210:	1085883a 	add	r2,r2,r2
8113e214:	1007883a 	mov	r3,r2
8113e218:	d0a0b817 	ldw	r2,-32032(gp)
8113e21c:	10800a17 	ldw	r2,40(r2)
8113e220:	1885883a 	add	r2,r3,r2
8113e224:	1080002b 	ldhuio	r2,0(r2)
8113e228:	10bfffcc 	andi	r2,r2,65535
8113e22c:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8113e230:	e0bff90f 	ldh	r2,-28(fp)
8113e234:	10000726 	beq	r2,zero,8113e254 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8113e238:	e0bff817 	ldw	r2,-32(fp)
8113e23c:	10800044 	addi	r2,r2,1
8113e240:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8113e244:	e0bff817 	ldw	r2,-32(fp)
8113e248:	10803fcc 	andi	r2,r2,255
8113e24c:	103fee1e 	bne	r2,zero,8113e208 <__reset+0xfb11e208>
8113e250:	00000106 	br	8113e258 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8113e254:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8113e258:	e0bff90f 	ldh	r2,-28(fp)
8113e25c:	10000926 	beq	r2,zero,8113e284 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8113e260:	e0bff717 	ldw	r2,-36(fp)
8113e264:	10800044 	addi	r2,r2,1
8113e268:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113e26c:	00a045b4 	movhi	r2,33046
8113e270:	1094fb04 	addi	r2,r2,21484
8113e274:	10c01217 	ldw	r3,72(r2)
8113e278:	e0bff717 	ldw	r2,-36(fp)
8113e27c:	18bfdc1e 	bne	r3,r2,8113e1f0 <__reset+0xfb11e1f0>
8113e280:	00000106 	br	8113e288 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8113e284:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8113e288:	e0bff90f 	ldh	r2,-28(fp)
8113e28c:	1000081e 	bne	r2,zero,8113e2b0 <find_first_empty_cluster+0x19c>
8113e290:	e0bff90f 	ldh	r2,-28(fp)
8113e294:	e0fffb17 	ldw	r3,-20(fp)
8113e298:	18800536 	bltu	r3,r2,8113e2b0 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113e29c:	e0bfff17 	ldw	r2,-4(fp)
8113e2a0:	e0fff817 	ldw	r3,-32(fp)
8113e2a4:	10c00015 	stw	r3,0(r2)
		result = true;
8113e2a8:	00800044 	movi	r2,1
8113e2ac:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8113e2b0:	e0bffa17 	ldw	r2,-24(fp)
}
8113e2b4:	e037883a 	mov	sp,fp
8113e2b8:	dfc00117 	ldw	ra,4(sp)
8113e2bc:	df000017 	ldw	fp,0(sp)
8113e2c0:	dec00204 	addi	sp,sp,8
8113e2c4:	f800283a 	ret

8113e2c8 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8113e2c8:	defff604 	addi	sp,sp,-40
8113e2cc:	de00012e 	bgeu	sp,et,8113e2d4 <find_first_empty_record_in_a_subdirectory+0xc>
8113e2d0:	003b68fa 	trap	3
8113e2d4:	dfc00915 	stw	ra,36(sp)
8113e2d8:	df000815 	stw	fp,32(sp)
8113e2dc:	df000804 	addi	fp,sp,32
8113e2e0:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8113e2e4:	00bfffc4 	movi	r2,-1
8113e2e8:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8113e2ec:	e0bfff17 	ldw	r2,-4(fp)
8113e2f0:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113e2f4:	e0bff917 	ldw	r2,-28(fp)
8113e2f8:	10ffff84 	addi	r3,r2,-2
8113e2fc:	00a045b4 	movhi	r2,33046
8113e300:	1094fb04 	addi	r2,r2,21484
8113e304:	10800383 	ldbu	r2,14(r2)
8113e308:	10803fcc 	andi	r2,r2,255
8113e30c:	1885383a 	mul	r2,r3,r2
8113e310:	1007883a 	mov	r3,r2
8113e314:	00a045b4 	movhi	r2,33046
8113e318:	1094fb04 	addi	r2,r2,21484
8113e31c:	10801417 	ldw	r2,80(r2)
8113e320:	1885883a 	add	r2,r3,r2
8113e324:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113e328:	e03ffa15 	stw	zero,-24(fp)
8113e32c:	00002c06 	br	8113e3e0 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113e330:	e0fffa17 	ldw	r3,-24(fp)
8113e334:	e0bffc17 	ldw	r2,-16(fp)
8113e338:	1885883a 	add	r2,r3,r2
8113e33c:	d0e0b617 	ldw	r3,-32040(gp)
8113e340:	180b883a 	mov	r5,r3
8113e344:	1009883a 	mov	r4,r2
8113e348:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113e34c:	10002b26 	beq	r2,zero,8113e3fc <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113e350:	e03ffb15 	stw	zero,-20(fp)
8113e354:	00001c06 	br	8113e3c8 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113e358:	e0bffb17 	ldw	r2,-20(fp)
8113e35c:	1004917a 	slli	r2,r2,5
8113e360:	1007883a 	mov	r3,r2
8113e364:	d0a0b817 	ldw	r2,-32032(gp)
8113e368:	10800a17 	ldw	r2,40(r2)
8113e36c:	1885883a 	add	r2,r3,r2
8113e370:	10800023 	ldbuio	r2,0(r2)
8113e374:	10803fcc 	andi	r2,r2,255
8113e378:	10803fcc 	andi	r2,r2,255
8113e37c:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8113e380:	e0bffd0b 	ldhu	r2,-12(fp)
8113e384:	10803960 	cmpeqi	r2,r2,229
8113e388:	1000021e 	bne	r2,zero,8113e394 <find_first_empty_record_in_a_subdirectory+0xcc>
8113e38c:	e0bffd0b 	ldhu	r2,-12(fp)
8113e390:	10000a1e 	bne	r2,zero,8113e3bc <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8113e394:	e0bffa17 	ldw	r2,-24(fp)
8113e398:	1006913a 	slli	r3,r2,4
8113e39c:	e0bffb17 	ldw	r2,-20(fp)
8113e3a0:	1885883a 	add	r2,r3,r2
8113e3a4:	1006943a 	slli	r3,r2,16
8113e3a8:	e0bff917 	ldw	r2,-28(fp)
8113e3ac:	1884b03a 	or	r2,r3,r2
8113e3b0:	e0bff815 	stw	r2,-32(fp)
                        return result;
8113e3b4:	e0bff817 	ldw	r2,-32(fp)
8113e3b8:	00005306 	br	8113e508 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113e3bc:	e0bffb17 	ldw	r2,-20(fp)
8113e3c0:	10800044 	addi	r2,r2,1
8113e3c4:	e0bffb15 	stw	r2,-20(fp)
8113e3c8:	e0bffb17 	ldw	r2,-20(fp)
8113e3cc:	10800410 	cmplti	r2,r2,16
8113e3d0:	103fe11e 	bne	r2,zero,8113e358 <__reset+0xfb11e358>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113e3d4:	e0bffa17 	ldw	r2,-24(fp)
8113e3d8:	10800044 	addi	r2,r2,1
8113e3dc:	e0bffa15 	stw	r2,-24(fp)
8113e3e0:	00a045b4 	movhi	r2,33046
8113e3e4:	1094fb04 	addi	r2,r2,21484
8113e3e8:	10800383 	ldbu	r2,14(r2)
8113e3ec:	10803fcc 	andi	r2,r2,255
8113e3f0:	e0fffa17 	ldw	r3,-24(fp)
8113e3f4:	18bfce16 	blt	r3,r2,8113e330 <__reset+0xfb11e330>
8113e3f8:	00000106 	br	8113e400 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8113e3fc:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8113e400:	e0bff817 	ldw	r2,-32(fp)
8113e404:	1000390e 	bge	r2,zero,8113e4ec <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113e408:	e0bff917 	ldw	r2,-28(fp)
8113e40c:	e0fffd84 	addi	r3,fp,-10
8113e410:	180b883a 	mov	r5,r3
8113e414:	1009883a 	mov	r4,r2
8113e418:	113c0d00 	call	8113c0d0 <get_cluster_flag>
8113e41c:	10003126 	beq	r2,zero,8113e4e4 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113e420:	e0bffd8b 	ldhu	r2,-10(fp)
8113e424:	10bfffcc 	andi	r2,r2,65535
8113e428:	10fffe0c 	andi	r3,r2,65528
8113e42c:	00bffe14 	movui	r2,65528
8113e430:	18802e1e 	bne	r3,r2,8113e4ec <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8113e434:	e0bffe04 	addi	r2,fp,-8
8113e438:	1009883a 	mov	r4,r2
8113e43c:	113e1140 	call	8113e114 <find_first_empty_cluster>
8113e440:	10002326 	beq	r2,zero,8113e4d0 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113e444:	e0bff917 	ldw	r2,-28(fp)
8113e448:	e0fffe17 	ldw	r3,-8(fp)
8113e44c:	18ffffcc 	andi	r3,r3,65535
8113e450:	18e0001c 	xori	r3,r3,32768
8113e454:	18e00004 	addi	r3,r3,-32768
8113e458:	01800044 	movi	r6,1
8113e45c:	180b883a 	mov	r5,r3
8113e460:	1009883a 	mov	r4,r2
8113e464:	113c18c0 	call	8113c18c <mark_cluster>
8113e468:	10001926 	beq	r2,zero,8113e4d0 <find_first_empty_record_in_a_subdirectory+0x208>
8113e46c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113e470:	01800044 	movi	r6,1
8113e474:	017fffc4 	movi	r5,-1
8113e478:	1009883a 	mov	r4,r2
8113e47c:	113c18c0 	call	8113c18c <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113e480:	10001326 	beq	r2,zero,8113e4d0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113e484:	e0bff917 	ldw	r2,-28(fp)
8113e488:	e0fffe17 	ldw	r3,-8(fp)
8113e48c:	18ffffcc 	andi	r3,r3,65535
8113e490:	18e0001c 	xori	r3,r3,32768
8113e494:	18e00004 	addi	r3,r3,-32768
8113e498:	000d883a 	mov	r6,zero
8113e49c:	180b883a 	mov	r5,r3
8113e4a0:	1009883a 	mov	r4,r2
8113e4a4:	113c18c0 	call	8113c18c <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113e4a8:	10000926 	beq	r2,zero,8113e4d0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113e4ac:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8113e4b0:	000d883a 	mov	r6,zero
8113e4b4:	017fffc4 	movi	r5,-1
8113e4b8:	1009883a 	mov	r4,r2
8113e4bc:	113c18c0 	call	8113c18c <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113e4c0:	10000326 	beq	r2,zero,8113e4d0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8113e4c4:	113bf9c0 	call	8113bf9c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8113e4c8:	e0bffe17 	ldw	r2,-8(fp)
8113e4cc:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8113e4d0:	e0bffd8b 	ldhu	r2,-10(fp)
8113e4d4:	10bfffcc 	andi	r2,r2,65535
8113e4d8:	10bffe0c 	andi	r2,r2,65528
8113e4dc:	e0bff915 	stw	r2,-28(fp)
8113e4e0:	00000206 	br	8113e4ec <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8113e4e4:	00bfffc4 	movi	r2,-1
8113e4e8:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8113e4ec:	e0bff917 	ldw	r2,-28(fp)
8113e4f0:	00fffdd4 	movui	r3,65527
8113e4f4:	18800316 	blt	r3,r2,8113e504 <find_first_empty_record_in_a_subdirectory+0x23c>
8113e4f8:	e0bff817 	ldw	r2,-32(fp)
8113e4fc:	10bfffe0 	cmpeqi	r2,r2,-1
8113e500:	103f7c1e 	bne	r2,zero,8113e2f4 <__reset+0xfb11e2f4>
    return result; 
8113e504:	e0bff817 	ldw	r2,-32(fp)
}
8113e508:	e037883a 	mov	sp,fp
8113e50c:	dfc00117 	ldw	ra,4(sp)
8113e510:	df000017 	ldw	fp,0(sp)
8113e514:	dec00204 	addi	sp,sp,8
8113e518:	f800283a 	ret

8113e51c <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8113e51c:	defff904 	addi	sp,sp,-28
8113e520:	de00012e 	bgeu	sp,et,8113e528 <find_first_empty_record_in_root_directory+0xc>
8113e524:	003b68fa 	trap	3
8113e528:	dfc00615 	stw	ra,24(sp)
8113e52c:	df000515 	stw	fp,20(sp)
8113e530:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113e534:	00a045b4 	movhi	r2,33046
8113e538:	1094fb04 	addi	r2,r2,21484
8113e53c:	1080050b 	ldhu	r2,20(r2)
8113e540:	10bfffcc 	andi	r2,r2,65535
8113e544:	1006917a 	slli	r3,r2,5
8113e548:	00a045b4 	movhi	r2,33046
8113e54c:	1094fb04 	addi	r2,r2,21484
8113e550:	1080030b 	ldhu	r2,12(r2)
8113e554:	10bfffcc 	andi	r2,r2,65535
8113e558:	1885283a 	div	r2,r3,r2
8113e55c:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8113e560:	00bfffc4 	movi	r2,-1
8113e564:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113e568:	e03ffb15 	stw	zero,-20(fp)
8113e56c:	00002d06 	br	8113e624 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113e570:	00a045b4 	movhi	r2,33046
8113e574:	1094fb04 	addi	r2,r2,21484
8113e578:	10c01317 	ldw	r3,76(r2)
8113e57c:	e0bffb17 	ldw	r2,-20(fp)
8113e580:	1885883a 	add	r2,r3,r2
8113e584:	1007883a 	mov	r3,r2
8113e588:	d0a0b617 	ldw	r2,-32040(gp)
8113e58c:	100b883a 	mov	r5,r2
8113e590:	1809883a 	mov	r4,r3
8113e594:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113e598:	10002626 	beq	r2,zero,8113e634 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113e59c:	e03ffc15 	stw	zero,-16(fp)
8113e5a0:	00001a06 	br	8113e60c <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113e5a4:	e0bffc17 	ldw	r2,-16(fp)
8113e5a8:	1004917a 	slli	r2,r2,5
8113e5ac:	1007883a 	mov	r3,r2
8113e5b0:	d0a0b817 	ldw	r2,-32032(gp)
8113e5b4:	10800a17 	ldw	r2,40(r2)
8113e5b8:	1885883a 	add	r2,r3,r2
8113e5bc:	10800023 	ldbuio	r2,0(r2)
8113e5c0:	10803fcc 	andi	r2,r2,255
8113e5c4:	10803fcc 	andi	r2,r2,255
8113e5c8:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8113e5cc:	e0bfff0b 	ldhu	r2,-4(fp)
8113e5d0:	10803960 	cmpeqi	r2,r2,229
8113e5d4:	1000021e 	bne	r2,zero,8113e5e0 <find_first_empty_record_in_root_directory+0xc4>
8113e5d8:	e0bfff0b 	ldhu	r2,-4(fp)
8113e5dc:	1000081e 	bne	r2,zero,8113e600 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8113e5e0:	e0bffb17 	ldw	r2,-20(fp)
8113e5e4:	1006913a 	slli	r3,r2,4
8113e5e8:	e0bffc17 	ldw	r2,-16(fp)
8113e5ec:	1885883a 	add	r2,r3,r2
8113e5f0:	1004943a 	slli	r2,r2,16
8113e5f4:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113e5f8:	e0bffe17 	ldw	r2,-8(fp)
8113e5fc:	00000f06 	br	8113e63c <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113e600:	e0bffc17 	ldw	r2,-16(fp)
8113e604:	10800044 	addi	r2,r2,1
8113e608:	e0bffc15 	stw	r2,-16(fp)
8113e60c:	e0bffc17 	ldw	r2,-16(fp)
8113e610:	10800410 	cmplti	r2,r2,16
8113e614:	103fe31e 	bne	r2,zero,8113e5a4 <__reset+0xfb11e5a4>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113e618:	e0bffb17 	ldw	r2,-20(fp)
8113e61c:	10800044 	addi	r2,r2,1
8113e620:	e0bffb15 	stw	r2,-20(fp)
8113e624:	e0fffb17 	ldw	r3,-20(fp)
8113e628:	e0bffd17 	ldw	r2,-12(fp)
8113e62c:	18bfd016 	blt	r3,r2,8113e570 <__reset+0xfb11e570>
8113e630:	00000106 	br	8113e638 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8113e634:	0001883a 	nop
        }
    }
    return result;
8113e638:	e0bffe17 	ldw	r2,-8(fp)
}
8113e63c:	e037883a 	mov	sp,fp
8113e640:	dfc00117 	ldw	ra,4(sp)
8113e644:	df000017 	ldw	fp,0(sp)
8113e648:	dec00204 	addi	sp,sp,8
8113e64c:	f800283a 	ret

8113e650 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8113e650:	defffa04 	addi	sp,sp,-24
8113e654:	de00012e 	bgeu	sp,et,8113e65c <convert_filename_to_name_extension+0xc>
8113e658:	003b68fa 	trap	3
8113e65c:	df000515 	stw	fp,20(sp)
8113e660:	df000504 	addi	fp,sp,20
8113e664:	e13ffd15 	stw	r4,-12(fp)
8113e668:	e17ffe15 	stw	r5,-8(fp)
8113e66c:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8113e670:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8113e674:	e03ffb15 	stw	zero,-20(fp)
8113e678:	00002506 	br	8113e710 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113e67c:	e0bffc17 	ldw	r2,-16(fp)
8113e680:	e0fffd17 	ldw	r3,-12(fp)
8113e684:	1885883a 	add	r2,r3,r2
8113e688:	10800003 	ldbu	r2,0(r2)
8113e68c:	10803fcc 	andi	r2,r2,255
8113e690:	1080201c 	xori	r2,r2,128
8113e694:	10bfe004 	addi	r2,r2,-128
8113e698:	10800ba0 	cmpeqi	r2,r2,46
8113e69c:	1000141e 	bne	r2,zero,8113e6f0 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8113e6a0:	e0bffb17 	ldw	r2,-20(fp)
8113e6a4:	e0fffe17 	ldw	r3,-8(fp)
8113e6a8:	1885883a 	add	r2,r3,r2
8113e6ac:	e0fffc17 	ldw	r3,-16(fp)
8113e6b0:	e13ffd17 	ldw	r4,-12(fp)
8113e6b4:	20c7883a 	add	r3,r4,r3
8113e6b8:	18c00003 	ldbu	r3,0(r3)
8113e6bc:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8113e6c0:	e0bffc17 	ldw	r2,-16(fp)
8113e6c4:	e0fffd17 	ldw	r3,-12(fp)
8113e6c8:	1885883a 	add	r2,r3,r2
8113e6cc:	10800003 	ldbu	r2,0(r2)
8113e6d0:	10803fcc 	andi	r2,r2,255
8113e6d4:	1080201c 	xori	r2,r2,128
8113e6d8:	10bfe004 	addi	r2,r2,-128
8113e6dc:	10000926 	beq	r2,zero,8113e704 <convert_filename_to_name_extension+0xb4>
8113e6e0:	e0bffc17 	ldw	r2,-16(fp)
8113e6e4:	10800044 	addi	r2,r2,1
8113e6e8:	e0bffc15 	stw	r2,-16(fp)
8113e6ec:	00000506 	br	8113e704 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8113e6f0:	e0bffb17 	ldw	r2,-20(fp)
8113e6f4:	e0fffe17 	ldw	r3,-8(fp)
8113e6f8:	1885883a 	add	r2,r3,r2
8113e6fc:	00c00804 	movi	r3,32
8113e700:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8113e704:	e0bffb17 	ldw	r2,-20(fp)
8113e708:	10800044 	addi	r2,r2,1
8113e70c:	e0bffb15 	stw	r2,-20(fp)
8113e710:	e0bffb17 	ldw	r2,-20(fp)
8113e714:	10800210 	cmplti	r2,r2,8
8113e718:	103fd81e 	bne	r2,zero,8113e67c <__reset+0xfb11e67c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8113e71c:	e0bffc17 	ldw	r2,-16(fp)
8113e720:	e0fffd17 	ldw	r3,-12(fp)
8113e724:	1885883a 	add	r2,r3,r2
8113e728:	10800003 	ldbu	r2,0(r2)
8113e72c:	10803fcc 	andi	r2,r2,255
8113e730:	1080201c 	xori	r2,r2,128
8113e734:	10bfe004 	addi	r2,r2,-128
8113e738:	10800b98 	cmpnei	r2,r2,46
8113e73c:	1000031e 	bne	r2,zero,8113e74c <convert_filename_to_name_extension+0xfc>
8113e740:	e0bffc17 	ldw	r2,-16(fp)
8113e744:	10800044 	addi	r2,r2,1
8113e748:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8113e74c:	e03ffb15 	stw	zero,-20(fp)
8113e750:	00001c06 	br	8113e7c4 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8113e754:	e0bffc17 	ldw	r2,-16(fp)
8113e758:	e0fffd17 	ldw	r3,-12(fp)
8113e75c:	1885883a 	add	r2,r3,r2
8113e760:	10800003 	ldbu	r2,0(r2)
8113e764:	10803fcc 	andi	r2,r2,255
8113e768:	1080201c 	xori	r2,r2,128
8113e76c:	10bfe004 	addi	r2,r2,-128
8113e770:	10000c26 	beq	r2,zero,8113e7a4 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
8113e774:	e0bffb17 	ldw	r2,-20(fp)
8113e778:	e0ffff17 	ldw	r3,-4(fp)
8113e77c:	1885883a 	add	r2,r3,r2
8113e780:	e0fffc17 	ldw	r3,-16(fp)
8113e784:	e13ffd17 	ldw	r4,-12(fp)
8113e788:	20c7883a 	add	r3,r4,r3
8113e78c:	18c00003 	ldbu	r3,0(r3)
8113e790:	10c00005 	stb	r3,0(r2)
            local++;
8113e794:	e0bffc17 	ldw	r2,-16(fp)
8113e798:	10800044 	addi	r2,r2,1
8113e79c:	e0bffc15 	stw	r2,-16(fp)
8113e7a0:	00000506 	br	8113e7b8 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8113e7a4:	e0bffb17 	ldw	r2,-20(fp)
8113e7a8:	e0ffff17 	ldw	r3,-4(fp)
8113e7ac:	1885883a 	add	r2,r3,r2
8113e7b0:	00c00804 	movi	r3,32
8113e7b4:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8113e7b8:	e0bffb17 	ldw	r2,-20(fp)
8113e7bc:	10800044 	addi	r2,r2,1
8113e7c0:	e0bffb15 	stw	r2,-20(fp)
8113e7c4:	e0bffb17 	ldw	r2,-20(fp)
8113e7c8:	108000d0 	cmplti	r2,r2,3
8113e7cc:	103fe11e 	bne	r2,zero,8113e754 <__reset+0xfb11e754>
        {
            extension[counter] = ' ';
        }
    }

}
8113e7d0:	0001883a 	nop
8113e7d4:	e037883a 	mov	sp,fp
8113e7d8:	df000017 	ldw	fp,0(sp)
8113e7dc:	dec00104 	addi	sp,sp,4
8113e7e0:	f800283a 	ret

8113e7e4 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8113e7e4:	defff504 	addi	sp,sp,-44
8113e7e8:	de00012e 	bgeu	sp,et,8113e7f0 <create_file+0xc>
8113e7ec:	003b68fa 	trap	3
8113e7f0:	dfc00a15 	stw	ra,40(sp)
8113e7f4:	df000915 	stw	fp,36(sp)
8113e7f8:	df000904 	addi	fp,sp,36
8113e7fc:	e13ffd15 	stw	r4,-12(fp)
8113e800:	e17ffe15 	stw	r5,-8(fp)
8113e804:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8113e808:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8113e80c:	e0bffc04 	addi	r2,fp,-16
8113e810:	1009883a 	mov	r4,r2
8113e814:	113e1140 	call	8113e114 <find_first_empty_cluster>
8113e818:	1000a026 	beq	r2,zero,8113ea9c <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8113e81c:	e0bfff17 	ldw	r2,-4(fp)
8113e820:	10800a17 	ldw	r2,40(r2)
8113e824:	1000031e 	bne	r2,zero,8113e834 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8113e828:	113e51c0 	call	8113e51c <find_first_empty_record_in_root_directory>
8113e82c:	e0bff815 	stw	r2,-32(fp)
8113e830:	00000606 	br	8113e84c <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8113e834:	e0bfff17 	ldw	r2,-4(fp)
8113e838:	1080058b 	ldhu	r2,22(r2)
8113e83c:	10bfffcc 	andi	r2,r2,65535
8113e840:	1009883a 	mov	r4,r2
8113e844:	113e2c80 	call	8113e2c8 <find_first_empty_record_in_a_subdirectory>
8113e848:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
8113e84c:	e0bff817 	ldw	r2,-32(fp)
8113e850:	10009216 	blt	r2,zero,8113ea9c <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8113e854:	e13ffd17 	ldw	r4,-12(fp)
8113e858:	113d3f40 	call	8113d3f4 <get_dir_divider_location>
8113e85c:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
8113e860:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8113e864:	00000b06 	br	8113e894 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8113e868:	e0fffa17 	ldw	r3,-24(fp)
8113e86c:	e0bff917 	ldw	r2,-28(fp)
8113e870:	1885883a 	add	r2,r3,r2
8113e874:	10800044 	addi	r2,r2,1
8113e878:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
8113e87c:	e0bffa17 	ldw	r2,-24(fp)
8113e880:	e0fffd17 	ldw	r3,-12(fp)
8113e884:	1885883a 	add	r2,r3,r2
8113e888:	1009883a 	mov	r4,r2
8113e88c:	113d3f40 	call	8113d3f4 <get_dir_divider_location>
8113e890:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
8113e894:	e0bff917 	ldw	r2,-28(fp)
8113e898:	00bff316 	blt	zero,r2,8113e868 <__reset+0xfb11e868>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8113e89c:	e0bffa17 	ldw	r2,-24(fp)
8113e8a0:	e0fffd17 	ldw	r3,-12(fp)
8113e8a4:	1887883a 	add	r3,r3,r2
8113e8a8:	e13ffe17 	ldw	r4,-8(fp)
8113e8ac:	e0bffe17 	ldw	r2,-8(fp)
8113e8b0:	10800204 	addi	r2,r2,8
8113e8b4:	100d883a 	mov	r6,r2
8113e8b8:	200b883a 	mov	r5,r4
8113e8bc:	1809883a 	mov	r4,r3
8113e8c0:	113e6500 	call	8113e650 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8113e8c4:	e0bffe17 	ldw	r2,-8(fp)
8113e8c8:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8113e8cc:	e0bffe17 	ldw	r2,-8(fp)
8113e8d0:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8113e8d4:	e0bffe17 	ldw	r2,-8(fp)
8113e8d8:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8113e8dc:	e0bffe17 	ldw	r2,-8(fp)
8113e8e0:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8113e8e4:	e0bffe17 	ldw	r2,-8(fp)
8113e8e8:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8113e8ec:	e0bffe17 	ldw	r2,-8(fp)
8113e8f0:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8113e8f4:	e0bffc17 	ldw	r2,-16(fp)
8113e8f8:	1007883a 	mov	r3,r2
8113e8fc:	e0bffe17 	ldw	r2,-8(fp)
8113e900:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8113e904:	e0bffe17 	ldw	r2,-8(fp)
8113e908:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8113e90c:	e0fffc17 	ldw	r3,-16(fp)
8113e910:	e0bffe17 	ldw	r2,-8(fp)
8113e914:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8113e918:	e0bffe17 	ldw	r2,-8(fp)
8113e91c:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
8113e920:	e0bffe17 	ldw	r2,-8(fp)
8113e924:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8113e928:	e0bff817 	ldw	r2,-32(fp)
8113e92c:	10ffffcc 	andi	r3,r2,65535
8113e930:	e0bffe17 	ldw	r2,-8(fp)
8113e934:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8113e938:	e0bff817 	ldw	r2,-32(fp)
8113e93c:	1004d43a 	srli	r2,r2,16
8113e940:	1000010e 	bge	r2,zero,8113e948 <create_file+0x164>
8113e944:	108003c4 	addi	r2,r2,15
8113e948:	1005d13a 	srai	r2,r2,4
8113e94c:	1007883a 	mov	r3,r2
8113e950:	e0bffe17 	ldw	r2,-8(fp)
8113e954:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8113e958:	e0bff817 	ldw	r2,-32(fp)
8113e95c:	1004d43a 	srli	r2,r2,16
8113e960:	1007883a 	mov	r3,r2
8113e964:	00a00034 	movhi	r2,32768
8113e968:	108003c4 	addi	r2,r2,15
8113e96c:	1884703a 	and	r2,r3,r2
8113e970:	1000040e 	bge	r2,zero,8113e984 <create_file+0x1a0>
8113e974:	10bfffc4 	addi	r2,r2,-1
8113e978:	00fffc04 	movi	r3,-16
8113e97c:	10c4b03a 	or	r2,r2,r3
8113e980:	10800044 	addi	r2,r2,1
8113e984:	1004917a 	slli	r2,r2,5
8113e988:	1007883a 	mov	r3,r2
8113e98c:	e0bffe17 	ldw	r2,-8(fp)
8113e990:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
8113e994:	e0bfff17 	ldw	r2,-4(fp)
8113e998:	1080058b 	ldhu	r2,22(r2)
8113e99c:	10ffffcc 	andi	r3,r2,65535
8113e9a0:	e0bffe17 	ldw	r2,-8(fp)
8113e9a4:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8113e9a8:	e0bffe17 	ldw	r2,-8(fp)
8113e9ac:	00c00044 	movi	r3,1
8113e9b0:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
8113e9b4:	e0bffe17 	ldw	r2,-8(fp)
8113e9b8:	00c00044 	movi	r3,1
8113e9bc:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113e9c0:	e0bffe17 	ldw	r2,-8(fp)
8113e9c4:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113e9c8:	1000071e 	bne	r2,zero,8113e9e8 <create_file+0x204>
8113e9cc:	00a045b4 	movhi	r2,33046
8113e9d0:	1094fb04 	addi	r2,r2,21484
8113e9d4:	10c01317 	ldw	r3,76(r2)
8113e9d8:	e0bffe17 	ldw	r2,-8(fp)
8113e9dc:	10800b17 	ldw	r2,44(r2)
8113e9e0:	1885883a 	add	r2,r3,r2
8113e9e4:	00000f06 	br	8113ea24 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8113e9e8:	00a045b4 	movhi	r2,33046
8113e9ec:	1094fb04 	addi	r2,r2,21484
8113e9f0:	10c01417 	ldw	r3,80(r2)
8113e9f4:	e0bffe17 	ldw	r2,-8(fp)
8113e9f8:	10800a17 	ldw	r2,40(r2)
8113e9fc:	113fff84 	addi	r4,r2,-2
8113ea00:	00a045b4 	movhi	r2,33046
8113ea04:	1094fb04 	addi	r2,r2,21484
8113ea08:	10800383 	ldbu	r2,14(r2)
8113ea0c:	10803fcc 	andi	r2,r2,255
8113ea10:	2085383a 	mul	r2,r4,r2
8113ea14:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8113ea18:	e0bffe17 	ldw	r2,-8(fp)
8113ea1c:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113ea20:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113ea24:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8113ea28:	e0bffb17 	ldw	r2,-20(fp)
8113ea2c:	d0e0b617 	ldw	r3,-32040(gp)
8113ea30:	180b883a 	mov	r5,r3
8113ea34:	1009883a 	mov	r4,r2
8113ea38:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113ea3c:	10001726 	beq	r2,zero,8113ea9c <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
8113ea40:	e0bffe17 	ldw	r2,-8(fp)
8113ea44:	10800c0b 	ldhu	r2,48(r2)
8113ea48:	10bfffcc 	andi	r2,r2,65535
8113ea4c:	10a0001c 	xori	r2,r2,32768
8113ea50:	10a00004 	addi	r2,r2,-32768
8113ea54:	e17ffe17 	ldw	r5,-8(fp)
8113ea58:	1009883a 	mov	r4,r2
8113ea5c:	113c6a40 	call	8113c6a4 <Write_File_Record_At_Offset>
8113ea60:	10000e26 	beq	r2,zero,8113ea9c <create_file+0x2b8>
                {
                    Save_Modified_Sector();
8113ea64:	113bf9c0 	call	8113bf9c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8113ea68:	e0bffc17 	ldw	r2,-16(fp)
8113ea6c:	01800044 	movi	r6,1
8113ea70:	017fffc4 	movi	r5,-1
8113ea74:	1009883a 	mov	r4,r2
8113ea78:	113c18c0 	call	8113c18c <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
8113ea7c:	e0bffc17 	ldw	r2,-16(fp)
8113ea80:	000d883a 	mov	r6,zero
8113ea84:	017fffc4 	movi	r5,-1
8113ea88:	1009883a 	mov	r4,r2
8113ea8c:	113c18c0 	call	8113c18c <mark_cluster>
8113ea90:	10000226 	beq	r2,zero,8113ea9c <create_file+0x2b8>
                    {
                        result = true;
8113ea94:	00800044 	movi	r2,1
8113ea98:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
8113ea9c:	e0bff717 	ldw	r2,-36(fp)
}
8113eaa0:	e037883a 	mov	sp,fp
8113eaa4:	dfc00117 	ldw	ra,4(sp)
8113eaa8:	df000017 	ldw	fp,0(sp)
8113eaac:	dec00204 	addi	sp,sp,8
8113eab0:	f800283a 	ret

8113eab4 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
8113eab4:	defffb04 	addi	sp,sp,-20
8113eab8:	de00012e 	bgeu	sp,et,8113eac0 <copy_file_record_name_to_string+0xc>
8113eabc:	003b68fa 	trap	3
8113eac0:	df000415 	stw	fp,16(sp)
8113eac4:	df000404 	addi	fp,sp,16
8113eac8:	e13ffe15 	stw	r4,-8(fp)
8113eacc:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
8113ead0:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113ead4:	e03ffc15 	stw	zero,-16(fp)
8113ead8:	00001506 	br	8113eb30 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
8113eadc:	e0fffe17 	ldw	r3,-8(fp)
8113eae0:	e0bffc17 	ldw	r2,-16(fp)
8113eae4:	1885883a 	add	r2,r3,r2
8113eae8:	10800003 	ldbu	r2,0(r2)
8113eaec:	10803fcc 	andi	r2,r2,255
8113eaf0:	10800820 	cmpeqi	r2,r2,32
8113eaf4:	10000b1e 	bne	r2,zero,8113eb24 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8113eaf8:	e0bffd17 	ldw	r2,-12(fp)
8113eafc:	e0ffff17 	ldw	r3,-4(fp)
8113eb00:	1885883a 	add	r2,r3,r2
8113eb04:	e13ffe17 	ldw	r4,-8(fp)
8113eb08:	e0fffc17 	ldw	r3,-16(fp)
8113eb0c:	20c7883a 	add	r3,r4,r3
8113eb10:	18c00003 	ldbu	r3,0(r3)
8113eb14:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8113eb18:	e0bffd17 	ldw	r2,-12(fp)
8113eb1c:	10800044 	addi	r2,r2,1
8113eb20:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113eb24:	e0bffc17 	ldw	r2,-16(fp)
8113eb28:	10800044 	addi	r2,r2,1
8113eb2c:	e0bffc15 	stw	r2,-16(fp)
8113eb30:	e0bffc17 	ldw	r2,-16(fp)
8113eb34:	10800210 	cmplti	r2,r2,8
8113eb38:	103fe81e 	bne	r2,zero,8113eadc <__reset+0xfb11eadc>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
8113eb3c:	e0bffe17 	ldw	r2,-8(fp)
8113eb40:	10800203 	ldbu	r2,8(r2)
8113eb44:	10803fcc 	andi	r2,r2,255
8113eb48:	10800820 	cmpeqi	r2,r2,32
8113eb4c:	1000241e 	bne	r2,zero,8113ebe0 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
8113eb50:	e0bffd17 	ldw	r2,-12(fp)
8113eb54:	e0ffff17 	ldw	r3,-4(fp)
8113eb58:	1885883a 	add	r2,r3,r2
8113eb5c:	00c00b84 	movi	r3,46
8113eb60:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
8113eb64:	e0bffd17 	ldw	r2,-12(fp)
8113eb68:	10800044 	addi	r2,r2,1
8113eb6c:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
8113eb70:	e03ffc15 	stw	zero,-16(fp)
8113eb74:	00001706 	br	8113ebd4 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
8113eb78:	e0fffe17 	ldw	r3,-8(fp)
8113eb7c:	e0bffc17 	ldw	r2,-16(fp)
8113eb80:	1885883a 	add	r2,r3,r2
8113eb84:	10800204 	addi	r2,r2,8
8113eb88:	10800003 	ldbu	r2,0(r2)
8113eb8c:	10803fcc 	andi	r2,r2,255
8113eb90:	10800820 	cmpeqi	r2,r2,32
8113eb94:	10000c1e 	bne	r2,zero,8113ebc8 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
8113eb98:	e0bffd17 	ldw	r2,-12(fp)
8113eb9c:	e0ffff17 	ldw	r3,-4(fp)
8113eba0:	1885883a 	add	r2,r3,r2
8113eba4:	e13ffe17 	ldw	r4,-8(fp)
8113eba8:	e0fffc17 	ldw	r3,-16(fp)
8113ebac:	20c7883a 	add	r3,r4,r3
8113ebb0:	18c00204 	addi	r3,r3,8
8113ebb4:	18c00003 	ldbu	r3,0(r3)
8113ebb8:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
8113ebbc:	e0bffd17 	ldw	r2,-12(fp)
8113ebc0:	10800044 	addi	r2,r2,1
8113ebc4:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8113ebc8:	e0bffc17 	ldw	r2,-16(fp)
8113ebcc:	10800044 	addi	r2,r2,1
8113ebd0:	e0bffc15 	stw	r2,-16(fp)
8113ebd4:	e0bffc17 	ldw	r2,-16(fp)
8113ebd8:	108000d0 	cmplti	r2,r2,3
8113ebdc:	103fe61e 	bne	r2,zero,8113eb78 <__reset+0xfb11eb78>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8113ebe0:	e0bffd17 	ldw	r2,-12(fp)
8113ebe4:	e0ffff17 	ldw	r3,-4(fp)
8113ebe8:	1885883a 	add	r2,r3,r2
8113ebec:	10000005 	stb	zero,0(r2)
}
8113ebf0:	0001883a 	nop
8113ebf4:	e037883a 	mov	sp,fp
8113ebf8:	df000017 	ldw	fp,0(sp)
8113ebfc:	dec00104 	addi	sp,sp,4
8113ec00:	f800283a 	ret

8113ec04 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
8113ec04:	defffc04 	addi	sp,sp,-16
8113ec08:	de00012e 	bgeu	sp,et,8113ec10 <alt_up_sd_card_open_dev+0xc>
8113ec0c:	003b68fa 	trap	3
8113ec10:	dfc00315 	stw	ra,12(sp)
8113ec14:	df000215 	stw	fp,8(sp)
8113ec18:	df000204 	addi	fp,sp,8
8113ec1c:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
8113ec20:	d1600d04 	addi	r5,gp,-32716
8113ec24:	e13fff17 	ldw	r4,-4(fp)
8113ec28:	11440c00 	call	811440c0 <alt_find_dev>
8113ec2c:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
8113ec30:	e0bffe17 	ldw	r2,-8(fp)
8113ec34:	10001e26 	beq	r2,zero,8113ecb0 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8113ec38:	e0bffe17 	ldw	r2,-8(fp)
8113ec3c:	10800a17 	ldw	r2,40(r2)
8113ec40:	10808d04 	addi	r2,r2,564
8113ec44:	d0a0b015 	stw	r2,-32064(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8113ec48:	e0bffe17 	ldw	r2,-8(fp)
8113ec4c:	10800a17 	ldw	r2,40(r2)
8113ec50:	10808904 	addi	r2,r2,548
8113ec54:	d0a0b115 	stw	r2,-32060(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8113ec58:	e0bffe17 	ldw	r2,-8(fp)
8113ec5c:	10800a17 	ldw	r2,40(r2)
8113ec60:	10808404 	addi	r2,r2,528
8113ec64:	d0a0b215 	stw	r2,-32056(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
8113ec68:	e0bffe17 	ldw	r2,-8(fp)
8113ec6c:	10800a17 	ldw	r2,40(r2)
8113ec70:	10808c04 	addi	r2,r2,560
8113ec74:	d0a0b315 	stw	r2,-32052(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
8113ec78:	e0bffe17 	ldw	r2,-8(fp)
8113ec7c:	10800a17 	ldw	r2,40(r2)
8113ec80:	10808b04 	addi	r2,r2,556
8113ec84:	d0a0b415 	stw	r2,-32048(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
8113ec88:	e0bffe17 	ldw	r2,-8(fp)
8113ec8c:	10800a17 	ldw	r2,40(r2)
8113ec90:	d0a0b515 	stw	r2,-32044(gp)
		device_pointer = dev;
8113ec94:	e0bffe17 	ldw	r2,-8(fp)
8113ec98:	d0a0b815 	stw	r2,-32032(gp)
		initialized = false;
8113ec9c:	d020ae15 	stw	zero,-32072(gp)
		is_sd_card_formated_as_FAT16 = false;
8113eca0:	d020af15 	stw	zero,-32068(gp)
		search_data.valid = false;
8113eca4:	00a045b4 	movhi	r2,33046
8113eca8:	1094f604 	addi	r2,r2,21464
8113ecac:	10000415 	stw	zero,16(r2)
	}
	return dev;
8113ecb0:	e0bffe17 	ldw	r2,-8(fp)
}
8113ecb4:	e037883a 	mov	sp,fp
8113ecb8:	dfc00117 	ldw	ra,4(sp)
8113ecbc:	df000017 	ldw	fp,0(sp)
8113ecc0:	dec00204 	addi	sp,sp,8
8113ecc4:	f800283a 	ret

8113ecc8 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8113ecc8:	defffd04 	addi	sp,sp,-12
8113eccc:	de00012e 	bgeu	sp,et,8113ecd4 <alt_up_sd_card_is_Present+0xc>
8113ecd0:	003b68fa 	trap	3
8113ecd4:	df000215 	stw	fp,8(sp)
8113ecd8:	df000204 	addi	fp,sp,8
    bool result = false;
8113ecdc:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8113ece0:	d0a0b817 	ldw	r2,-32032(gp)
8113ece4:	10000826 	beq	r2,zero,8113ed08 <alt_up_sd_card_is_Present+0x40>
8113ece8:	d0a0b017 	ldw	r2,-32064(gp)
8113ecec:	1080002b 	ldhuio	r2,0(r2)
8113ecf0:	10bfffcc 	andi	r2,r2,65535
8113ecf4:	1080008c 	andi	r2,r2,2
8113ecf8:	10000326 	beq	r2,zero,8113ed08 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
8113ecfc:	00800044 	movi	r2,1
8113ed00:	e0bffe15 	stw	r2,-8(fp)
8113ed04:	00001e06 	br	8113ed80 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8113ed08:	d0a0ae17 	ldw	r2,-32072(gp)
8113ed0c:	10800058 	cmpnei	r2,r2,1
8113ed10:	10001b1e 	bne	r2,zero,8113ed80 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
8113ed14:	d020ae15 	stw	zero,-32072(gp)
		search_data.valid = false;
8113ed18:	00a045b4 	movhi	r2,33046
8113ed1c:	1094f604 	addi	r2,r2,21464
8113ed20:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
8113ed24:	d020af15 	stw	zero,-32068(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113ed28:	e03fff15 	stw	zero,-4(fp)
8113ed2c:	00001106 	br	8113ed74 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
8113ed30:	00a045b4 	movhi	r2,33046
8113ed34:	10951004 	addi	r2,r2,21568
8113ed38:	e0ffff17 	ldw	r3,-4(fp)
8113ed3c:	180691ba 	slli	r3,r3,6
8113ed40:	10c5883a 	add	r2,r2,r3
8113ed44:	10800f04 	addi	r2,r2,60
8113ed48:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
8113ed4c:	00a045b4 	movhi	r2,33046
8113ed50:	10951004 	addi	r2,r2,21568
8113ed54:	e0ffff17 	ldw	r3,-4(fp)
8113ed58:	180691ba 	slli	r3,r3,6
8113ed5c:	10c5883a 	add	r2,r2,r3
8113ed60:	10800e04 	addi	r2,r2,56
8113ed64:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113ed68:	e0bfff17 	ldw	r2,-4(fp)
8113ed6c:	10800044 	addi	r2,r2,1
8113ed70:	e0bfff15 	stw	r2,-4(fp)
8113ed74:	e0bfff17 	ldw	r2,-4(fp)
8113ed78:	10800510 	cmplti	r2,r2,20
8113ed7c:	103fec1e 	bne	r2,zero,8113ed30 <__reset+0xfb11ed30>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
8113ed80:	e0bffe17 	ldw	r2,-8(fp)
}
8113ed84:	e037883a 	mov	sp,fp
8113ed88:	df000017 	ldw	fp,0(sp)
8113ed8c:	dec00104 	addi	sp,sp,4
8113ed90:	f800283a 	ret

8113ed94 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
8113ed94:	defffd04 	addi	sp,sp,-12
8113ed98:	de00012e 	bgeu	sp,et,8113eda0 <alt_up_sd_card_is_FAT16+0xc>
8113ed9c:	003b68fa 	trap	3
8113eda0:	dfc00215 	stw	ra,8(sp)
8113eda4:	df000115 	stw	fp,4(sp)
8113eda8:	df000104 	addi	fp,sp,4
	bool result = false;
8113edac:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8113edb0:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113edb4:	10000c26 	beq	r2,zero,8113ede8 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8113edb8:	d0a0ae17 	ldw	r2,-32072(gp)
8113edbc:	1000071e 	bne	r2,zero,8113eddc <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8113edc0:	113cfc00 	call	8113cfc0 <Look_for_FAT16>
8113edc4:	d0a0af15 	stw	r2,-32068(gp)
			initialized = is_sd_card_formated_as_FAT16;
8113edc8:	d0a0af17 	ldw	r2,-32068(gp)
8113edcc:	d0a0ae15 	stw	r2,-32072(gp)
			search_data.valid = false;
8113edd0:	00a045b4 	movhi	r2,33046
8113edd4:	1094f604 	addi	r2,r2,21464
8113edd8:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8113eddc:	d0a0af17 	ldw	r2,-32068(gp)
8113ede0:	e0bfff15 	stw	r2,-4(fp)
8113ede4:	00000206 	br	8113edf0 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8113ede8:	d020ae15 	stw	zero,-32072(gp)
		is_sd_card_formated_as_FAT16 = false;
8113edec:	d020af15 	stw	zero,-32068(gp)
	}

	return result;
8113edf0:	e0bfff17 	ldw	r2,-4(fp)
}
8113edf4:	e037883a 	mov	sp,fp
8113edf8:	dfc00117 	ldw	ra,4(sp)
8113edfc:	df000017 	ldw	fp,0(sp)
8113ee00:	dec00204 	addi	sp,sp,8
8113ee04:	f800283a 	ret

8113ee08 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8113ee08:	deffea04 	addi	sp,sp,-88
8113ee0c:	de00012e 	bgeu	sp,et,8113ee14 <alt_up_sd_card_find_first+0xc>
8113ee10:	003b68fa 	trap	3
8113ee14:	dfc01515 	stw	ra,84(sp)
8113ee18:	df001415 	stw	fp,80(sp)
8113ee1c:	df001404 	addi	fp,sp,80
8113ee20:	e13ffe15 	stw	r4,-8(fp)
8113ee24:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8113ee28:	00800084 	movi	r2,2
8113ee2c:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ee30:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113ee34:	10002426 	beq	r2,zero,8113eec8 <alt_up_sd_card_find_first+0xc0>
8113ee38:	d0a0af17 	ldw	r2,-32068(gp)
8113ee3c:	10002226 	beq	r2,zero,8113eec8 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
8113ee40:	e0ffee04 	addi	r3,fp,-72
8113ee44:	e0bfed04 	addi	r2,fp,-76
8113ee48:	180d883a 	mov	r6,r3
8113ee4c:	100b883a 	mov	r5,r2
8113ee50:	e13ffe17 	ldw	r4,-8(fp)
8113ee54:	113d7580 	call	8113d758 <get_home_directory_cluster_for_file>
8113ee58:	10001926 	beq	r2,zero,8113eec0 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
8113ee5c:	e0bfed17 	ldw	r2,-76(fp)
8113ee60:	1007883a 	mov	r3,r2
8113ee64:	00a045b4 	movhi	r2,33046
8113ee68:	1094f604 	addi	r2,r2,21464
8113ee6c:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
8113ee70:	e0bfed17 	ldw	r2,-76(fp)
8113ee74:	1007883a 	mov	r3,r2
8113ee78:	00a045b4 	movhi	r2,33046
8113ee7c:	1094f604 	addi	r2,r2,21464
8113ee80:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
8113ee84:	00a045b4 	movhi	r2,33046
8113ee88:	1094f604 	addi	r2,r2,21464
8113ee8c:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
8113ee90:	00a045b4 	movhi	r2,33046
8113ee94:	1094f604 	addi	r2,r2,21464
8113ee98:	00ffffc4 	movi	r3,-1
8113ee9c:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8113eea0:	00a045b4 	movhi	r2,33046
8113eea4:	1094f604 	addi	r2,r2,21464
8113eea8:	00c00044 	movi	r3,1
8113eeac:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8113eeb0:	e13fff17 	ldw	r4,-4(fp)
8113eeb4:	113eee00 	call	8113eee0 <alt_up_sd_card_find_next>
8113eeb8:	e0bfec0d 	sth	r2,-80(fp)
8113eebc:	00000206 	br	8113eec8 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8113eec0:	00800044 	movi	r2,1
8113eec4:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8113eec8:	e0bfec0b 	ldhu	r2,-80(fp)
}
8113eecc:	e037883a 	mov	sp,fp
8113eed0:	dfc00117 	ldw	ra,4(sp)
8113eed4:	df000017 	ldw	fp,0(sp)
8113eed8:	dec00204 	addi	sp,sp,8
8113eedc:	f800283a 	ret

8113eee0 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8113eee0:	deffe404 	addi	sp,sp,-112
8113eee4:	de00012e 	bgeu	sp,et,8113eeec <alt_up_sd_card_find_next+0xc>
8113eee8:	003b68fa 	trap	3
8113eeec:	dfc01b15 	stw	ra,108(sp)
8113eef0:	df001a15 	stw	fp,104(sp)
8113eef4:	df001a04 	addi	fp,sp,104
8113eef8:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8113eefc:	00800084 	movi	r2,2
8113ef00:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ef04:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113ef08:	1000df26 	beq	r2,zero,8113f288 <alt_up_sd_card_find_next+0x3a8>
8113ef0c:	d0a0af17 	ldw	r2,-32068(gp)
8113ef10:	1000dd26 	beq	r2,zero,8113f288 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
8113ef14:	00a045b4 	movhi	r2,33046
8113ef18:	1094f604 	addi	r2,r2,21464
8113ef1c:	10800417 	ldw	r2,16(r2)
8113ef20:	1000d726 	beq	r2,zero,8113f280 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
8113ef24:	00a045b4 	movhi	r2,33046
8113ef28:	1094f604 	addi	r2,r2,21464
8113ef2c:	10800117 	ldw	r2,4(r2)
8113ef30:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
8113ef34:	e0bfe717 	ldw	r2,-100(fp)
8113ef38:	1000561e 	bne	r2,zero,8113f094 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113ef3c:	00a045b4 	movhi	r2,33046
8113ef40:	1094fb04 	addi	r2,r2,21484
8113ef44:	1080050b 	ldhu	r2,20(r2)
8113ef48:	10bfffcc 	andi	r2,r2,65535
8113ef4c:	1006917a 	slli	r3,r2,5
8113ef50:	00a045b4 	movhi	r2,33046
8113ef54:	1094fb04 	addi	r2,r2,21484
8113ef58:	1080030b 	ldhu	r2,12(r2)
8113ef5c:	10bfffcc 	andi	r2,r2,65535
8113ef60:	1885283a 	div	r2,r3,r2
8113ef64:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
8113ef68:	00a045b4 	movhi	r2,33046
8113ef6c:	1094f604 	addi	r2,r2,21464
8113ef70:	10800217 	ldw	r2,8(r2)
8113ef74:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
8113ef78:	00a045b4 	movhi	r2,33046
8113ef7c:	1094f604 	addi	r2,r2,21464
8113ef80:	1080030b 	ldhu	r2,12(r2)
8113ef84:	10bfffcc 	andi	r2,r2,65535
8113ef88:	10a0001c 	xori	r2,r2,32768
8113ef8c:	10a00004 	addi	r2,r2,-32768
8113ef90:	10800044 	addi	r2,r2,1
8113ef94:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113ef98:	00003606 	br	8113f074 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113ef9c:	00a045b4 	movhi	r2,33046
8113efa0:	1094fb04 	addi	r2,r2,21484
8113efa4:	10c01317 	ldw	r3,76(r2)
8113efa8:	e0bfe817 	ldw	r2,-96(fp)
8113efac:	1885883a 	add	r2,r3,r2
8113efb0:	1007883a 	mov	r3,r2
8113efb4:	d0a0b617 	ldw	r2,-32040(gp)
8113efb8:	100b883a 	mov	r5,r2
8113efbc:	1809883a 	mov	r4,r3
8113efc0:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113efc4:	10002f26 	beq	r2,zero,8113f084 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113efc8:	00002306 	br	8113f058 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8113efcc:	e0bfe917 	ldw	r2,-92(fp)
8113efd0:	1004917a 	slli	r2,r2,5
8113efd4:	e13fe817 	ldw	r4,-96(fp)
8113efd8:	e0ffef04 	addi	r3,fp,-68
8113efdc:	200f883a 	mov	r7,r4
8113efe0:	000d883a 	mov	r6,zero
8113efe4:	180b883a 	mov	r5,r3
8113efe8:	1009883a 	mov	r4,r2
8113efec:	113c4200 	call	8113c420 <Read_File_Record_At_Offset>
8113eff0:	10001626 	beq	r2,zero,8113f04c <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113eff4:	e0bfef03 	ldbu	r2,-68(fp)
8113eff8:	10803fcc 	andi	r2,r2,255
8113effc:	10001326 	beq	r2,zero,8113f04c <alt_up_sd_card_find_next+0x16c>
8113f000:	e0bfef03 	ldbu	r2,-68(fp)
8113f004:	10803fcc 	andi	r2,r2,255
8113f008:	10803960 	cmpeqi	r2,r2,229
8113f00c:	10000f1e 	bne	r2,zero,8113f04c <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8113f010:	e0bfe917 	ldw	r2,-92(fp)
8113f014:	1007883a 	mov	r3,r2
8113f018:	00a045b4 	movhi	r2,33046
8113f01c:	1094f604 	addi	r2,r2,21464
8113f020:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
8113f024:	e0ffe817 	ldw	r3,-96(fp)
8113f028:	00a045b4 	movhi	r2,33046
8113f02c:	1094f604 	addi	r2,r2,21464
8113f030:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
8113f034:	e0bfef04 	addi	r2,fp,-68
8113f038:	e17fff17 	ldw	r5,-4(fp)
8113f03c:	1009883a 	mov	r4,r2
8113f040:	113eab40 	call	8113eab4 <copy_file_record_name_to_string>
									return 0;
8113f044:	0005883a 	mov	r2,zero
8113f048:	00009006 	br	8113f28c <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113f04c:	e0bfe917 	ldw	r2,-92(fp)
8113f050:	10800044 	addi	r2,r2,1
8113f054:	e0bfe915 	stw	r2,-92(fp)
8113f058:	e0bfe917 	ldw	r2,-92(fp)
8113f05c:	10800410 	cmplti	r2,r2,16
8113f060:	103fda1e 	bne	r2,zero,8113efcc <__reset+0xfb11efcc>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
8113f064:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113f068:	e0bfe817 	ldw	r2,-96(fp)
8113f06c:	10800044 	addi	r2,r2,1
8113f070:	e0bfe815 	stw	r2,-96(fp)
8113f074:	e0ffe817 	ldw	r3,-96(fp)
8113f078:	e0bfec17 	ldw	r2,-80(fp)
8113f07c:	18bfc716 	blt	r3,r2,8113ef9c <__reset+0xfb11ef9c>
8113f080:	00000106 	br	8113f088 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
8113f084:	0001883a 	nop
					}
				}
				result = -1;
8113f088:	00bfffc4 	movi	r2,-1
8113f08c:	e0bfe60d 	sth	r2,-104(fp)
8113f090:	00007d06 	br	8113f288 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
8113f094:	00a045b4 	movhi	r2,33046
8113f098:	1094f604 	addi	r2,r2,21464
8113f09c:	1080030b 	ldhu	r2,12(r2)
8113f0a0:	10bfffcc 	andi	r2,r2,65535
8113f0a4:	10a0001c 	xori	r2,r2,32768
8113f0a8:	10a00004 	addi	r2,r2,-32768
8113f0ac:	10800044 	addi	r2,r2,1
8113f0b0:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113f0b4:	e0bfe717 	ldw	r2,-100(fp)
8113f0b8:	10ffff84 	addi	r3,r2,-2
8113f0bc:	00a045b4 	movhi	r2,33046
8113f0c0:	1094fb04 	addi	r2,r2,21484
8113f0c4:	10800383 	ldbu	r2,14(r2)
8113f0c8:	10803fcc 	andi	r2,r2,255
8113f0cc:	1885383a 	mul	r2,r3,r2
8113f0d0:	1007883a 	mov	r3,r2
8113f0d4:	00a045b4 	movhi	r2,33046
8113f0d8:	1094fb04 	addi	r2,r2,21484
8113f0dc:	10801417 	ldw	r2,80(r2)
8113f0e0:	1885883a 	add	r2,r3,r2
8113f0e4:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8113f0e8:	00a045b4 	movhi	r2,33046
8113f0ec:	1094f604 	addi	r2,r2,21464
8113f0f0:	10800217 	ldw	r2,8(r2)
8113f0f4:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f0f8:	00003806 	br	8113f1dc <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113f0fc:	e0ffeb17 	ldw	r3,-84(fp)
8113f100:	e0bfed17 	ldw	r2,-76(fp)
8113f104:	1885883a 	add	r2,r3,r2
8113f108:	d0e0b617 	ldw	r3,-32040(gp)
8113f10c:	180b883a 	mov	r5,r3
8113f110:	1009883a 	mov	r4,r2
8113f114:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113f118:	10003726 	beq	r2,zero,8113f1f8 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
8113f11c:	00002806 	br	8113f1c0 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8113f120:	e0bfea17 	ldw	r2,-88(fp)
8113f124:	1004917a 	slli	r2,r2,5
8113f128:	e13fe717 	ldw	r4,-100(fp)
8113f12c:	e17feb17 	ldw	r5,-84(fp)
8113f130:	e0ffef04 	addi	r3,fp,-68
8113f134:	280f883a 	mov	r7,r5
8113f138:	200d883a 	mov	r6,r4
8113f13c:	180b883a 	mov	r5,r3
8113f140:	1009883a 	mov	r4,r2
8113f144:	113c4200 	call	8113c420 <Read_File_Record_At_Offset>
8113f148:	10001a26 	beq	r2,zero,8113f1b4 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113f14c:	e0bfef03 	ldbu	r2,-68(fp)
8113f150:	10803fcc 	andi	r2,r2,255
8113f154:	10001726 	beq	r2,zero,8113f1b4 <alt_up_sd_card_find_next+0x2d4>
8113f158:	e0bfef03 	ldbu	r2,-68(fp)
8113f15c:	10803fcc 	andi	r2,r2,255
8113f160:	10803960 	cmpeqi	r2,r2,229
8113f164:	1000131e 	bne	r2,zero,8113f1b4 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
8113f168:	e0ffe717 	ldw	r3,-100(fp)
8113f16c:	00a045b4 	movhi	r2,33046
8113f170:	1094f604 	addi	r2,r2,21464
8113f174:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
8113f178:	e0bfea17 	ldw	r2,-88(fp)
8113f17c:	1007883a 	mov	r3,r2
8113f180:	00a045b4 	movhi	r2,33046
8113f184:	1094f604 	addi	r2,r2,21464
8113f188:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8113f18c:	e0ffeb17 	ldw	r3,-84(fp)
8113f190:	00a045b4 	movhi	r2,33046
8113f194:	1094f604 	addi	r2,r2,21464
8113f198:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8113f19c:	e0bfef04 	addi	r2,fp,-68
8113f1a0:	e17fff17 	ldw	r5,-4(fp)
8113f1a4:	1009883a 	mov	r4,r2
8113f1a8:	113eab40 	call	8113eab4 <copy_file_record_name_to_string>
										return 0;
8113f1ac:	0005883a 	mov	r2,zero
8113f1b0:	00003606 	br	8113f28c <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
8113f1b4:	e0bfea17 	ldw	r2,-88(fp)
8113f1b8:	10800044 	addi	r2,r2,1
8113f1bc:	e0bfea15 	stw	r2,-88(fp)
8113f1c0:	e0bfea17 	ldw	r2,-88(fp)
8113f1c4:	10800410 	cmplti	r2,r2,16
8113f1c8:	103fd51e 	bne	r2,zero,8113f120 <__reset+0xfb11f120>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
8113f1cc:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113f1d0:	e0bfeb17 	ldw	r2,-84(fp)
8113f1d4:	10800044 	addi	r2,r2,1
8113f1d8:	e0bfeb15 	stw	r2,-84(fp)
8113f1dc:	00a045b4 	movhi	r2,33046
8113f1e0:	1094fb04 	addi	r2,r2,21484
8113f1e4:	10800383 	ldbu	r2,14(r2)
8113f1e8:	10803fcc 	andi	r2,r2,255
8113f1ec:	e0ffeb17 	ldw	r3,-84(fp)
8113f1f0:	18bfc216 	blt	r3,r2,8113f0fc <__reset+0xfb11f0fc>
8113f1f4:	00000106 	br	8113f1fc <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8113f1f8:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
8113f1fc:	00a045b4 	movhi	r2,33046
8113f200:	1094fb04 	addi	r2,r2,21484
8113f204:	10800383 	ldbu	r2,14(r2)
8113f208:	10803fcc 	andi	r2,r2,255
8113f20c:	e0ffeb17 	ldw	r3,-84(fp)
8113f210:	18801716 	blt	r3,r2,8113f270 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
8113f214:	e0bfe717 	ldw	r2,-100(fp)
8113f218:	e0ffee04 	addi	r3,fp,-72
8113f21c:	180b883a 	mov	r5,r3
8113f220:	1009883a 	mov	r4,r2
8113f224:	113c0d00 	call	8113c0d0 <get_cluster_flag>
8113f228:	10000f26 	beq	r2,zero,8113f268 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113f22c:	e0bfee0b 	ldhu	r2,-72(fp)
8113f230:	10bfffcc 	andi	r2,r2,65535
8113f234:	10fffe0c 	andi	r3,r2,65528
8113f238:	00bffe14 	movui	r2,65528
8113f23c:	1880051e 	bne	r3,r2,8113f254 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
8113f240:	00bfffc4 	movi	r2,-1
8113f244:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8113f248:	00a045b4 	movhi	r2,33046
8113f24c:	1094f604 	addi	r2,r2,21464
8113f250:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
8113f254:	e0bfee0b 	ldhu	r2,-72(fp)
8113f258:	10bfffcc 	andi	r2,r2,65535
8113f25c:	10bffe0c 	andi	r2,r2,65528
8113f260:	e0bfe715 	stw	r2,-100(fp)
8113f264:	00000206 	br	8113f270 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
8113f268:	00bfffc4 	movi	r2,-1
8113f26c:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
8113f270:	e0bfe717 	ldw	r2,-100(fp)
8113f274:	00fffdd4 	movui	r3,65527
8113f278:	18bf8e0e 	bge	r3,r2,8113f0b4 <__reset+0xfb11f0b4>
8113f27c:	00000206 	br	8113f288 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
8113f280:	008000c4 	movi	r2,3
8113f284:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8113f288:	e0bfe60b 	ldhu	r2,-104(fp)
}
8113f28c:	e037883a 	mov	sp,fp
8113f290:	dfc00117 	ldw	ra,4(sp)
8113f294:	df000017 	ldw	fp,0(sp)
8113f298:	dec00204 	addi	sp,sp,8
8113f29c:	f800283a 	ret

8113f2a0 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
8113f2a0:	deffe904 	addi	sp,sp,-92
8113f2a4:	de00012e 	bgeu	sp,et,8113f2ac <alt_up_sd_card_fopen+0xc>
8113f2a8:	003b68fa 	trap	3
8113f2ac:	dfc01615 	stw	ra,88(sp)
8113f2b0:	df001515 	stw	fp,84(sp)
8113f2b4:	df001504 	addi	fp,sp,84
8113f2b8:	e13ffe15 	stw	r4,-8(fp)
8113f2bc:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8113f2c0:	00bfffc4 	movi	r2,-1
8113f2c4:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113f2c8:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
8113f2cc:	1000cf26 	beq	r2,zero,8113f60c <alt_up_sd_card_fopen+0x36c>
8113f2d0:	d0a0af17 	ldw	r2,-32068(gp)
8113f2d4:	1000cd26 	beq	r2,zero,8113f60c <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8113f2d8:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8113f2dc:	e13ffe17 	ldw	r4,-8(fp)
8113f2e0:	113d0b40 	call	8113d0b4 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
8113f2e4:	e13ffe17 	ldw	r4,-8(fp)
8113f2e8:	113d1800 	call	8113d180 <check_file_name_for_FAT16_compliance>
8113f2ec:	1000c726 	beq	r2,zero,8113f60c <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8113f2f0:	e0ffee04 	addi	r3,fp,-72
8113f2f4:	e0bfed04 	addi	r2,fp,-76
8113f2f8:	180d883a 	mov	r6,r3
8113f2fc:	100b883a 	mov	r5,r2
8113f300:	e13ffe17 	ldw	r4,-8(fp)
8113f304:	113d7580 	call	8113d758 <get_home_directory_cluster_for_file>
8113f308:	1000021e 	bne	r2,zero,8113f314 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8113f30c:	e0bfeb0b 	ldhu	r2,-84(fp)
8113f310:	0000bf06 	br	8113f610 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113f314:	e03fec15 	stw	zero,-80(fp)
8113f318:	00000e06 	br	8113f354 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
8113f31c:	00a045b4 	movhi	r2,33046
8113f320:	10951004 	addi	r2,r2,21568
8113f324:	e0ffec17 	ldw	r3,-80(fp)
8113f328:	180691ba 	slli	r3,r3,6
8113f32c:	10c5883a 	add	r2,r2,r3
8113f330:	10800f04 	addi	r2,r2,60
8113f334:	10800017 	ldw	r2,0(r2)
8113f338:	1000031e 	bne	r2,zero,8113f348 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
8113f33c:	e0bfec17 	ldw	r2,-80(fp)
8113f340:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
8113f344:	00000606 	br	8113f360 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113f348:	e0bfec17 	ldw	r2,-80(fp)
8113f34c:	10800044 	addi	r2,r2,1
8113f350:	e0bfec15 	stw	r2,-80(fp)
8113f354:	e0bfec17 	ldw	r2,-80(fp)
8113f358:	10800510 	cmplti	r2,r2,20
8113f35c:	103fef1e 	bne	r2,zero,8113f31c <__reset+0xfb11f31c>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8113f360:	e0bfeb0f 	ldh	r2,-84(fp)
8113f364:	1000a916 	blt	r2,zero,8113f60c <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8113f368:	e0bfed17 	ldw	r2,-76(fp)
8113f36c:	1009883a 	mov	r4,r2
8113f370:	e0bfeb0f 	ldh	r2,-84(fp)
8113f374:	100691ba 	slli	r3,r2,6
8113f378:	00a045b4 	movhi	r2,33046
8113f37c:	10951004 	addi	r2,r2,21568
8113f380:	1885883a 	add	r2,r3,r2
8113f384:	100d883a 	mov	r6,r2
8113f388:	e17ffe17 	ldw	r5,-8(fp)
8113f38c:	113dc980 	call	8113dc98 <find_file_in_directory>
8113f390:	10007b26 	beq	r2,zero,8113f580 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
8113f394:	e0bfff17 	ldw	r2,-4(fp)
8113f398:	10000226 	beq	r2,zero,8113f3a4 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8113f39c:	00bfffc4 	movi	r2,-1
8113f3a0:	00009b06 	br	8113f610 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
8113f3a4:	e13feb0f 	ldh	r4,-84(fp)
8113f3a8:	e0ffeb0f 	ldh	r3,-84(fp)
8113f3ac:	00a045b4 	movhi	r2,33046
8113f3b0:	10951004 	addi	r2,r2,21568
8113f3b4:	180691ba 	slli	r3,r3,6
8113f3b8:	10c5883a 	add	r2,r2,r3
8113f3bc:	10800584 	addi	r2,r2,22
8113f3c0:	1080000b 	ldhu	r2,0(r2)
8113f3c4:	10ffffcc 	andi	r3,r2,65535
8113f3c8:	00a045b4 	movhi	r2,33046
8113f3cc:	10951004 	addi	r2,r2,21568
8113f3d0:	200891ba 	slli	r4,r4,6
8113f3d4:	1105883a 	add	r2,r2,r4
8113f3d8:	10800704 	addi	r2,r2,28
8113f3dc:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8113f3e0:	e0ffeb0f 	ldh	r3,-84(fp)
8113f3e4:	00a045b4 	movhi	r2,33046
8113f3e8:	10951004 	addi	r2,r2,21568
8113f3ec:	180691ba 	slli	r3,r3,6
8113f3f0:	10c5883a 	add	r2,r2,r3
8113f3f4:	10800804 	addi	r2,r2,32
8113f3f8:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8113f3fc:	e0ffeb0f 	ldh	r3,-84(fp)
8113f400:	00a045b4 	movhi	r2,33046
8113f404:	10951004 	addi	r2,r2,21568
8113f408:	180691ba 	slli	r3,r3,6
8113f40c:	10c5883a 	add	r2,r2,r3
8113f410:	10800904 	addi	r2,r2,36
8113f414:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8113f418:	e0ffeb0f 	ldh	r3,-84(fp)
8113f41c:	00a045b4 	movhi	r2,33046
8113f420:	10951004 	addi	r2,r2,21568
8113f424:	180691ba 	slli	r3,r3,6
8113f428:	10c5883a 	add	r2,r2,r3
8113f42c:	10800f04 	addi	r2,r2,60
8113f430:	00c00044 	movi	r3,1
8113f434:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8113f438:	e0ffeb0f 	ldh	r3,-84(fp)
8113f43c:	00a045b4 	movhi	r2,33046
8113f440:	10951004 	addi	r2,r2,21568
8113f444:	180691ba 	slli	r3,r3,6
8113f448:	10c5883a 	add	r2,r2,r3
8113f44c:	10800e04 	addi	r2,r2,56
8113f450:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113f454:	e03fec15 	stw	zero,-80(fp)
8113f458:	00004506 	br	8113f570 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
8113f45c:	e0ffeb0f 	ldh	r3,-84(fp)
8113f460:	e0bfec17 	ldw	r2,-80(fp)
8113f464:	18803f26 	beq	r3,r2,8113f564 <alt_up_sd_card_fopen+0x2c4>
8113f468:	00a045b4 	movhi	r2,33046
8113f46c:	10951004 	addi	r2,r2,21568
8113f470:	e0ffec17 	ldw	r3,-80(fp)
8113f474:	180691ba 	slli	r3,r3,6
8113f478:	10c5883a 	add	r2,r2,r3
8113f47c:	10800f04 	addi	r2,r2,60
8113f480:	10800017 	ldw	r2,0(r2)
8113f484:	10800058 	cmpnei	r2,r2,1
8113f488:	1000361e 	bne	r2,zero,8113f564 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113f48c:	e0ffeb0f 	ldh	r3,-84(fp)
8113f490:	00a045b4 	movhi	r2,33046
8113f494:	10951004 	addi	r2,r2,21568
8113f498:	180691ba 	slli	r3,r3,6
8113f49c:	10c5883a 	add	r2,r2,r3
8113f4a0:	10800a04 	addi	r2,r2,40
8113f4a4:	10c00017 	ldw	r3,0(r2)
8113f4a8:	00a045b4 	movhi	r2,33046
8113f4ac:	10951004 	addi	r2,r2,21568
8113f4b0:	e13fec17 	ldw	r4,-80(fp)
8113f4b4:	200891ba 	slli	r4,r4,6
8113f4b8:	1105883a 	add	r2,r2,r4
8113f4bc:	10800a04 	addi	r2,r2,40
8113f4c0:	10800017 	ldw	r2,0(r2)
8113f4c4:	1880271e 	bne	r3,r2,8113f564 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113f4c8:	e0ffeb0f 	ldh	r3,-84(fp)
8113f4cc:	00a045b4 	movhi	r2,33046
8113f4d0:	10951004 	addi	r2,r2,21568
8113f4d4:	180691ba 	slli	r3,r3,6
8113f4d8:	10c5883a 	add	r2,r2,r3
8113f4dc:	10800b04 	addi	r2,r2,44
8113f4e0:	10c00017 	ldw	r3,0(r2)
8113f4e4:	00a045b4 	movhi	r2,33046
8113f4e8:	10951004 	addi	r2,r2,21568
8113f4ec:	e13fec17 	ldw	r4,-80(fp)
8113f4f0:	200891ba 	slli	r4,r4,6
8113f4f4:	1105883a 	add	r2,r2,r4
8113f4f8:	10800b04 	addi	r2,r2,44
8113f4fc:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113f500:	1880181e 	bne	r3,r2,8113f564 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8113f504:	e0ffeb0f 	ldh	r3,-84(fp)
8113f508:	00a045b4 	movhi	r2,33046
8113f50c:	10951004 	addi	r2,r2,21568
8113f510:	180691ba 	slli	r3,r3,6
8113f514:	10c5883a 	add	r2,r2,r3
8113f518:	10800c04 	addi	r2,r2,48
8113f51c:	1100000b 	ldhu	r4,0(r2)
8113f520:	00a045b4 	movhi	r2,33046
8113f524:	10951004 	addi	r2,r2,21568
8113f528:	e0ffec17 	ldw	r3,-80(fp)
8113f52c:	180691ba 	slli	r3,r3,6
8113f530:	10c5883a 	add	r2,r2,r3
8113f534:	10800c04 	addi	r2,r2,48
8113f538:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113f53c:	20ffffcc 	andi	r3,r4,65535
8113f540:	18e0001c 	xori	r3,r3,32768
8113f544:	18e00004 	addi	r3,r3,-32768
8113f548:	10bfffcc 	andi	r2,r2,65535
8113f54c:	10a0001c 	xori	r2,r2,32768
8113f550:	10a00004 	addi	r2,r2,-32768
8113f554:	1880031e 	bne	r3,r2,8113f564 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8113f558:	00bfff84 	movi	r2,-2
8113f55c:	e0bfeb0d 	sth	r2,-84(fp)
								break;
8113f560:	00002a06 	br	8113f60c <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113f564:	e0bfec17 	ldw	r2,-80(fp)
8113f568:	10800044 	addi	r2,r2,1
8113f56c:	e0bfec15 	stw	r2,-80(fp)
8113f570:	e0bfec17 	ldw	r2,-80(fp)
8113f574:	10800510 	cmplti	r2,r2,20
8113f578:	103fb81e 	bne	r2,zero,8113f45c <__reset+0xfb11f45c>
8113f57c:	00002306 	br	8113f60c <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
8113f580:	e0bfff17 	ldw	r2,-4(fp)
8113f584:	10001f26 	beq	r2,zero,8113f604 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8113f588:	e0bfeb0f 	ldh	r2,-84(fp)
8113f58c:	100691ba 	slli	r3,r2,6
8113f590:	00a045b4 	movhi	r2,33046
8113f594:	10951004 	addi	r2,r2,21568
8113f598:	1885883a 	add	r2,r3,r2
8113f59c:	e0ffee04 	addi	r3,fp,-72
8113f5a0:	180d883a 	mov	r6,r3
8113f5a4:	100b883a 	mov	r5,r2
8113f5a8:	e13ffe17 	ldw	r4,-8(fp)
8113f5ac:	113e7e40 	call	8113e7e4 <create_file>
8113f5b0:	10001126 	beq	r2,zero,8113f5f8 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
8113f5b4:	e0ffeb0f 	ldh	r3,-84(fp)
8113f5b8:	00a045b4 	movhi	r2,33046
8113f5bc:	10951004 	addi	r2,r2,21568
8113f5c0:	180691ba 	slli	r3,r3,6
8113f5c4:	10c5883a 	add	r2,r2,r3
8113f5c8:	10800f04 	addi	r2,r2,60
8113f5cc:	00c00044 	movi	r3,1
8113f5d0:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
8113f5d4:	e0ffeb0f 	ldh	r3,-84(fp)
8113f5d8:	00a045b4 	movhi	r2,33046
8113f5dc:	10951004 	addi	r2,r2,21568
8113f5e0:	180691ba 	slli	r3,r3,6
8113f5e4:	10c5883a 	add	r2,r2,r3
8113f5e8:	10800e04 	addi	r2,r2,56
8113f5ec:	00c00044 	movi	r3,1
8113f5f0:	10c00015 	stw	r3,0(r2)
8113f5f4:	00000506 	br	8113f60c <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
8113f5f8:	00bfffc4 	movi	r2,-1
8113f5fc:	e0bfeb0d 	sth	r2,-84(fp)
8113f600:	00000206 	br	8113f60c <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
8113f604:	00bfffc4 	movi	r2,-1
8113f608:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8113f60c:	e0bfeb0b 	ldhu	r2,-84(fp)
}
8113f610:	e037883a 	mov	sp,fp
8113f614:	dfc00117 	ldw	ra,4(sp)
8113f618:	df000017 	ldw	fp,0(sp)
8113f61c:	dec00204 	addi	sp,sp,8
8113f620:	f800283a 	ret

8113f624 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113f624:	defffd04 	addi	sp,sp,-12
8113f628:	de00012e 	bgeu	sp,et,8113f630 <alt_up_sd_card_set_attributes+0xc>
8113f62c:	003b68fa 	trap	3
8113f630:	df000215 	stw	fp,8(sp)
8113f634:	df000204 	addi	fp,sp,8
8113f638:	2007883a 	mov	r3,r4
8113f63c:	2805883a 	mov	r2,r5
8113f640:	e0fffe0d 	sth	r3,-8(fp)
8113f644:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113f648:	e0bffe0f 	ldh	r2,-8(fp)
8113f64c:	10001416 	blt	r2,zero,8113f6a0 <alt_up_sd_card_set_attributes+0x7c>
8113f650:	e0bffe0f 	ldh	r2,-8(fp)
8113f654:	10800508 	cmpgei	r2,r2,20
8113f658:	1000111e 	bne	r2,zero,8113f6a0 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113f65c:	e0fffe0f 	ldh	r3,-8(fp)
8113f660:	00a045b4 	movhi	r2,33046
8113f664:	10951004 	addi	r2,r2,21568
8113f668:	180691ba 	slli	r3,r3,6
8113f66c:	10c5883a 	add	r2,r2,r3
8113f670:	10800f04 	addi	r2,r2,60
8113f674:	10800017 	ldw	r2,0(r2)
8113f678:	10000926 	beq	r2,zero,8113f6a0 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8113f67c:	e0fffe0f 	ldh	r3,-8(fp)
8113f680:	e0bfff0b 	ldhu	r2,-4(fp)
8113f684:	1009883a 	mov	r4,r2
8113f688:	00a045b4 	movhi	r2,33046
8113f68c:	10951004 	addi	r2,r2,21568
8113f690:	180691ba 	slli	r3,r3,6
8113f694:	10c5883a 	add	r2,r2,r3
8113f698:	108002c4 	addi	r2,r2,11
8113f69c:	11000005 	stb	r4,0(r2)
        }
    }
}
8113f6a0:	0001883a 	nop
8113f6a4:	e037883a 	mov	sp,fp
8113f6a8:	df000017 	ldw	fp,0(sp)
8113f6ac:	dec00104 	addi	sp,sp,4
8113f6b0:	f800283a 	ret

8113f6b4 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113f6b4:	defffd04 	addi	sp,sp,-12
8113f6b8:	de00012e 	bgeu	sp,et,8113f6c0 <alt_up_sd_card_get_attributes+0xc>
8113f6bc:	003b68fa 	trap	3
8113f6c0:	df000215 	stw	fp,8(sp)
8113f6c4:	df000204 	addi	fp,sp,8
8113f6c8:	2005883a 	mov	r2,r4
8113f6cc:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
8113f6d0:	00bfffc4 	movi	r2,-1
8113f6d4:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113f6d8:	e0bfff0f 	ldh	r2,-4(fp)
8113f6dc:	10001416 	blt	r2,zero,8113f730 <alt_up_sd_card_get_attributes+0x7c>
8113f6e0:	e0bfff0f 	ldh	r2,-4(fp)
8113f6e4:	10800508 	cmpgei	r2,r2,20
8113f6e8:	1000111e 	bne	r2,zero,8113f730 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113f6ec:	e0ffff0f 	ldh	r3,-4(fp)
8113f6f0:	00a045b4 	movhi	r2,33046
8113f6f4:	10951004 	addi	r2,r2,21568
8113f6f8:	180691ba 	slli	r3,r3,6
8113f6fc:	10c5883a 	add	r2,r2,r3
8113f700:	10800f04 	addi	r2,r2,60
8113f704:	10800017 	ldw	r2,0(r2)
8113f708:	10000926 	beq	r2,zero,8113f730 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8113f70c:	e0ffff0f 	ldh	r3,-4(fp)
8113f710:	00a045b4 	movhi	r2,33046
8113f714:	10951004 	addi	r2,r2,21568
8113f718:	180691ba 	slli	r3,r3,6
8113f71c:	10c5883a 	add	r2,r2,r3
8113f720:	108002c4 	addi	r2,r2,11
8113f724:	10800003 	ldbu	r2,0(r2)
8113f728:	10803fcc 	andi	r2,r2,255
8113f72c:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
8113f730:	e0bffe0b 	ldhu	r2,-8(fp)
}
8113f734:	e037883a 	mov	sp,fp
8113f738:	df000017 	ldw	fp,0(sp)
8113f73c:	dec00104 	addi	sp,sp,4
8113f740:	f800283a 	ret

8113f744 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
8113f744:	defffa04 	addi	sp,sp,-24
8113f748:	de00012e 	bgeu	sp,et,8113f750 <alt_up_sd_card_read+0xc>
8113f74c:	003b68fa 	trap	3
8113f750:	dfc00515 	stw	ra,20(sp)
8113f754:	df000415 	stw	fp,16(sp)
8113f758:	df000404 	addi	fp,sp,16
8113f75c:	2005883a 	mov	r2,r4
8113f760:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
8113f764:	00bfffc4 	movi	r2,-1
8113f768:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113f76c:	e0bfff0f 	ldh	r2,-4(fp)
8113f770:	1000ce16 	blt	r2,zero,8113faac <alt_up_sd_card_read+0x368>
8113f774:	e0bfff0f 	ldh	r2,-4(fp)
8113f778:	10800508 	cmpgei	r2,r2,20
8113f77c:	1000cb1e 	bne	r2,zero,8113faac <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
8113f780:	e0ffff0f 	ldh	r3,-4(fp)
8113f784:	00a045b4 	movhi	r2,33046
8113f788:	10951004 	addi	r2,r2,21568
8113f78c:	180691ba 	slli	r3,r3,6
8113f790:	10c5883a 	add	r2,r2,r3
8113f794:	10800f04 	addi	r2,r2,60
8113f798:	10800017 	ldw	r2,0(r2)
8113f79c:	1000c326 	beq	r2,zero,8113faac <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113f7a0:	e0ffff0f 	ldh	r3,-4(fp)
8113f7a4:	00a045b4 	movhi	r2,33046
8113f7a8:	10951004 	addi	r2,r2,21568
8113f7ac:	180691ba 	slli	r3,r3,6
8113f7b0:	10c5883a 	add	r2,r2,r3
8113f7b4:	10800904 	addi	r2,r2,36
8113f7b8:	10c00017 	ldw	r3,0(r2)
8113f7bc:	e13fff0f 	ldh	r4,-4(fp)
8113f7c0:	00a045b4 	movhi	r2,33046
8113f7c4:	10951004 	addi	r2,r2,21568
8113f7c8:	200891ba 	slli	r4,r4,6
8113f7cc:	1105883a 	add	r2,r2,r4
8113f7d0:	10800604 	addi	r2,r2,24
8113f7d4:	10800017 	ldw	r2,0(r2)
8113f7d8:	1880b42e 	bgeu	r3,r2,8113faac <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113f7dc:	00a045b4 	movhi	r2,33046
8113f7e0:	1094fb04 	addi	r2,r2,21484
8113f7e4:	10c01417 	ldw	r3,80(r2)
8113f7e8:	e13fff0f 	ldh	r4,-4(fp)
8113f7ec:	00a045b4 	movhi	r2,33046
8113f7f0:	10951004 	addi	r2,r2,21568
8113f7f4:	200891ba 	slli	r4,r4,6
8113f7f8:	1105883a 	add	r2,r2,r4
8113f7fc:	10800704 	addi	r2,r2,28
8113f800:	10800017 	ldw	r2,0(r2)
8113f804:	113fff84 	addi	r4,r2,-2
8113f808:	00a045b4 	movhi	r2,33046
8113f80c:	1094fb04 	addi	r2,r2,21484
8113f810:	10800383 	ldbu	r2,14(r2)
8113f814:	10803fcc 	andi	r2,r2,255
8113f818:	2085383a 	mul	r2,r4,r2
8113f81c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
8113f820:	e13fff0f 	ldh	r4,-4(fp)
8113f824:	00a045b4 	movhi	r2,33046
8113f828:	10951004 	addi	r2,r2,21568
8113f82c:	200891ba 	slli	r4,r4,6
8113f830:	1105883a 	add	r2,r2,r4
8113f834:	10800804 	addi	r2,r2,32
8113f838:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113f83c:	1885883a 	add	r2,r3,r2
8113f840:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
8113f844:	e0ffff0f 	ldh	r3,-4(fp)
8113f848:	00a045b4 	movhi	r2,33046
8113f84c:	10951004 	addi	r2,r2,21568
8113f850:	180691ba 	slli	r3,r3,6
8113f854:	10c5883a 	add	r2,r2,r3
8113f858:	10800904 	addi	r2,r2,36
8113f85c:	10800017 	ldw	r2,0(r2)
8113f860:	10006826 	beq	r2,zero,8113fa04 <alt_up_sd_card_read+0x2c0>
8113f864:	e0ffff0f 	ldh	r3,-4(fp)
8113f868:	00a045b4 	movhi	r2,33046
8113f86c:	10951004 	addi	r2,r2,21568
8113f870:	180691ba 	slli	r3,r3,6
8113f874:	10c5883a 	add	r2,r2,r3
8113f878:	10800904 	addi	r2,r2,36
8113f87c:	10800017 	ldw	r2,0(r2)
8113f880:	10807fcc 	andi	r2,r2,511
8113f884:	10005f1e 	bne	r2,zero,8113fa04 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113f888:	e0ffff0f 	ldh	r3,-4(fp)
8113f88c:	00a045b4 	movhi	r2,33046
8113f890:	10951004 	addi	r2,r2,21568
8113f894:	180691ba 	slli	r3,r3,6
8113f898:	10c5883a 	add	r2,r2,r3
8113f89c:	10800804 	addi	r2,r2,32
8113f8a0:	10c00017 	ldw	r3,0(r2)
8113f8a4:	00a045b4 	movhi	r2,33046
8113f8a8:	1094fb04 	addi	r2,r2,21484
8113f8ac:	10800383 	ldbu	r2,14(r2)
8113f8b0:	10803fcc 	andi	r2,r2,255
8113f8b4:	10bfffc4 	addi	r2,r2,-1
8113f8b8:	1880401e 	bne	r3,r2,8113f9bc <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113f8bc:	e0ffff0f 	ldh	r3,-4(fp)
8113f8c0:	00a045b4 	movhi	r2,33046
8113f8c4:	10951004 	addi	r2,r2,21568
8113f8c8:	180691ba 	slli	r3,r3,6
8113f8cc:	10c5883a 	add	r2,r2,r3
8113f8d0:	10800704 	addi	r2,r2,28
8113f8d4:	10800017 	ldw	r2,0(r2)
8113f8d8:	e0fffe04 	addi	r3,fp,-8
8113f8dc:	180b883a 	mov	r5,r3
8113f8e0:	1009883a 	mov	r4,r2
8113f8e4:	113c0d00 	call	8113c0d0 <get_cluster_flag>
8113f8e8:	10003226 	beq	r2,zero,8113f9b4 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113f8ec:	e0bffe0b 	ldhu	r2,-8(fp)
8113f8f0:	10bfffcc 	andi	r2,r2,65535
8113f8f4:	10fffe0c 	andi	r3,r2,65528
8113f8f8:	00bffe14 	movui	r2,65528
8113f8fc:	1880021e 	bne	r3,r2,8113f908 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
8113f900:	00bfffc4 	movi	r2,-1
8113f904:	00006a06 	br	8113fab0 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113f908:	e13fff0f 	ldh	r4,-4(fp)
8113f90c:	e0bffe0b 	ldhu	r2,-8(fp)
8113f910:	10ffffcc 	andi	r3,r2,65535
8113f914:	00a045b4 	movhi	r2,33046
8113f918:	10951004 	addi	r2,r2,21568
8113f91c:	200891ba 	slli	r4,r4,6
8113f920:	1105883a 	add	r2,r2,r4
8113f924:	10800704 	addi	r2,r2,28
8113f928:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113f92c:	e0ffff0f 	ldh	r3,-4(fp)
8113f930:	00a045b4 	movhi	r2,33046
8113f934:	10951004 	addi	r2,r2,21568
8113f938:	180691ba 	slli	r3,r3,6
8113f93c:	10c5883a 	add	r2,r2,r3
8113f940:	10800804 	addi	r2,r2,32
8113f944:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113f948:	00a045b4 	movhi	r2,33046
8113f94c:	1094fb04 	addi	r2,r2,21484
8113f950:	10c01417 	ldw	r3,80(r2)
8113f954:	e13fff0f 	ldh	r4,-4(fp)
8113f958:	00a045b4 	movhi	r2,33046
8113f95c:	10951004 	addi	r2,r2,21568
8113f960:	200891ba 	slli	r4,r4,6
8113f964:	1105883a 	add	r2,r2,r4
8113f968:	10800704 	addi	r2,r2,28
8113f96c:	10800017 	ldw	r2,0(r2)
8113f970:	113fff84 	addi	r4,r2,-2
8113f974:	00a045b4 	movhi	r2,33046
8113f978:	1094fb04 	addi	r2,r2,21484
8113f97c:	10800383 	ldbu	r2,14(r2)
8113f980:	10803fcc 	andi	r2,r2,255
8113f984:	2085383a 	mul	r2,r4,r2
8113f988:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113f98c:	e13fff0f 	ldh	r4,-4(fp)
8113f990:	00a045b4 	movhi	r2,33046
8113f994:	10951004 	addi	r2,r2,21568
8113f998:	200891ba 	slli	r4,r4,6
8113f99c:	1105883a 	add	r2,r2,r4
8113f9a0:	10800804 	addi	r2,r2,32
8113f9a4:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113f9a8:	1885883a 	add	r2,r3,r2
8113f9ac:	e0bffd15 	stw	r2,-12(fp)
8113f9b0:	00001406 	br	8113fa04 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
8113f9b4:	00bfff84 	movi	r2,-2
8113f9b8:	00003d06 	br	8113fab0 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113f9bc:	e13fff0f 	ldh	r4,-4(fp)
8113f9c0:	e0ffff0f 	ldh	r3,-4(fp)
8113f9c4:	00a045b4 	movhi	r2,33046
8113f9c8:	10951004 	addi	r2,r2,21568
8113f9cc:	180691ba 	slli	r3,r3,6
8113f9d0:	10c5883a 	add	r2,r2,r3
8113f9d4:	10800804 	addi	r2,r2,32
8113f9d8:	10800017 	ldw	r2,0(r2)
8113f9dc:	10c00044 	addi	r3,r2,1
8113f9e0:	00a045b4 	movhi	r2,33046
8113f9e4:	10951004 	addi	r2,r2,21568
8113f9e8:	200891ba 	slli	r4,r4,6
8113f9ec:	1105883a 	add	r2,r2,r4
8113f9f0:	10800804 	addi	r2,r2,32
8113f9f4:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113f9f8:	e0bffd17 	ldw	r2,-12(fp)
8113f9fc:	10800044 	addi	r2,r2,1
8113fa00:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
8113fa04:	d0e0b617 	ldw	r3,-32040(gp)
8113fa08:	e0bffd17 	ldw	r2,-12(fp)
8113fa0c:	1885883a 	add	r2,r3,r2
8113fa10:	1007883a 	mov	r3,r2
8113fa14:	d0a0ba17 	ldw	r2,-32024(gp)
8113fa18:	18800726 	beq	r3,r2,8113fa38 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113fa1c:	d0a0b617 	ldw	r2,-32040(gp)
8113fa20:	100b883a 	mov	r5,r2
8113fa24:	e13ffd17 	ldw	r4,-12(fp)
8113fa28:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113fa2c:	1000021e 	bne	r2,zero,8113fa38 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
8113fa30:	00bfff84 	movi	r2,-2
8113fa34:	00001e06 	br	8113fab0 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
8113fa38:	d0e0b517 	ldw	r3,-32044(gp)
8113fa3c:	e13fff0f 	ldh	r4,-4(fp)
8113fa40:	00a045b4 	movhi	r2,33046
8113fa44:	10951004 	addi	r2,r2,21568
8113fa48:	200891ba 	slli	r4,r4,6
8113fa4c:	1105883a 	add	r2,r2,r4
8113fa50:	10800904 	addi	r2,r2,36
8113fa54:	10800017 	ldw	r2,0(r2)
8113fa58:	10807fcc 	andi	r2,r2,511
8113fa5c:	1885883a 	add	r2,r3,r2
8113fa60:	10800023 	ldbuio	r2,0(r2)
8113fa64:	10803fcc 	andi	r2,r2,255
8113fa68:	10803fcc 	andi	r2,r2,255
8113fa6c:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113fa70:	e13fff0f 	ldh	r4,-4(fp)
8113fa74:	e0ffff0f 	ldh	r3,-4(fp)
8113fa78:	00a045b4 	movhi	r2,33046
8113fa7c:	10951004 	addi	r2,r2,21568
8113fa80:	180691ba 	slli	r3,r3,6
8113fa84:	10c5883a 	add	r2,r2,r3
8113fa88:	10800904 	addi	r2,r2,36
8113fa8c:	10800017 	ldw	r2,0(r2)
8113fa90:	10c00044 	addi	r3,r2,1
8113fa94:	00a045b4 	movhi	r2,33046
8113fa98:	10951004 	addi	r2,r2,21568
8113fa9c:	200891ba 	slli	r4,r4,6
8113faa0:	1105883a 	add	r2,r2,r4
8113faa4:	10800904 	addi	r2,r2,36
8113faa8:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
8113faac:	e0bffc0b 	ldhu	r2,-16(fp)
}
8113fab0:	e037883a 	mov	sp,fp
8113fab4:	dfc00117 	ldw	ra,4(sp)
8113fab8:	df000017 	ldw	fp,0(sp)
8113fabc:	dec00204 	addi	sp,sp,8
8113fac0:	f800283a 	ret

8113fac4 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
8113fac4:	defff804 	addi	sp,sp,-32
8113fac8:	de00012e 	bgeu	sp,et,8113fad0 <alt_up_sd_card_write+0xc>
8113facc:	003b68fa 	trap	3
8113fad0:	dfc00715 	stw	ra,28(sp)
8113fad4:	df000615 	stw	fp,24(sp)
8113fad8:	df000604 	addi	fp,sp,24
8113fadc:	2007883a 	mov	r3,r4
8113fae0:	2805883a 	mov	r2,r5
8113fae4:	e0fffe0d 	sth	r3,-8(fp)
8113fae8:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
8113faec:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113faf0:	e0bffe0f 	ldh	r2,-8(fp)
8113faf4:	10017716 	blt	r2,zero,811400d4 <alt_up_sd_card_write+0x610>
8113faf8:	e0bffe0f 	ldh	r2,-8(fp)
8113fafc:	10800508 	cmpgei	r2,r2,20
8113fb00:	1001741e 	bne	r2,zero,811400d4 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
8113fb04:	e0fffe0f 	ldh	r3,-8(fp)
8113fb08:	00a045b4 	movhi	r2,33046
8113fb0c:	10951004 	addi	r2,r2,21568
8113fb10:	180691ba 	slli	r3,r3,6
8113fb14:	10c5883a 	add	r2,r2,r3
8113fb18:	10800f04 	addi	r2,r2,60
8113fb1c:	10800017 	ldw	r2,0(r2)
8113fb20:	10016c26 	beq	r2,zero,811400d4 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113fb24:	00a045b4 	movhi	r2,33046
8113fb28:	1094fb04 	addi	r2,r2,21484
8113fb2c:	10c01417 	ldw	r3,80(r2)
8113fb30:	e13ffe0f 	ldh	r4,-8(fp)
8113fb34:	00a045b4 	movhi	r2,33046
8113fb38:	10951004 	addi	r2,r2,21568
8113fb3c:	200891ba 	slli	r4,r4,6
8113fb40:	1105883a 	add	r2,r2,r4
8113fb44:	10800704 	addi	r2,r2,28
8113fb48:	10800017 	ldw	r2,0(r2)
8113fb4c:	113fff84 	addi	r4,r2,-2
8113fb50:	00a045b4 	movhi	r2,33046
8113fb54:	1094fb04 	addi	r2,r2,21484
8113fb58:	10800383 	ldbu	r2,14(r2)
8113fb5c:	10803fcc 	andi	r2,r2,255
8113fb60:	2085383a 	mul	r2,r4,r2
8113fb64:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
8113fb68:	e13ffe0f 	ldh	r4,-8(fp)
8113fb6c:	00a045b4 	movhi	r2,33046
8113fb70:	10951004 	addi	r2,r2,21568
8113fb74:	200891ba 	slli	r4,r4,6
8113fb78:	1105883a 	add	r2,r2,r4
8113fb7c:	10800804 	addi	r2,r2,32
8113fb80:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113fb84:	1885883a 	add	r2,r3,r2
8113fb88:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
8113fb8c:	e0fffe0f 	ldh	r3,-8(fp)
8113fb90:	00a045b4 	movhi	r2,33046
8113fb94:	10951004 	addi	r2,r2,21568
8113fb98:	180691ba 	slli	r3,r3,6
8113fb9c:	10c5883a 	add	r2,r2,r3
8113fba0:	10800904 	addi	r2,r2,36
8113fba4:	10c00017 	ldw	r3,0(r2)
8113fba8:	00a045b4 	movhi	r2,33046
8113fbac:	1094fb04 	addi	r2,r2,21484
8113fbb0:	1080030b 	ldhu	r2,12(r2)
8113fbb4:	10bfffcc 	andi	r2,r2,65535
8113fbb8:	1889203a 	divu	r4,r3,r2
8113fbbc:	2085383a 	mul	r2,r4,r2
8113fbc0:	1885c83a 	sub	r2,r3,r2
8113fbc4:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113fbc8:	e0fffe0f 	ldh	r3,-8(fp)
8113fbcc:	00a045b4 	movhi	r2,33046
8113fbd0:	10951004 	addi	r2,r2,21568
8113fbd4:	180691ba 	slli	r3,r3,6
8113fbd8:	10c5883a 	add	r2,r2,r3
8113fbdc:	10800904 	addi	r2,r2,36
8113fbe0:	10c00017 	ldw	r3,0(r2)
8113fbe4:	e13ffe0f 	ldh	r4,-8(fp)
8113fbe8:	00a045b4 	movhi	r2,33046
8113fbec:	10951004 	addi	r2,r2,21568
8113fbf0:	200891ba 	slli	r4,r4,6
8113fbf4:	1105883a 	add	r2,r2,r4
8113fbf8:	10800604 	addi	r2,r2,24
8113fbfc:	10800017 	ldw	r2,0(r2)
8113fc00:	1880672e 	bgeu	r3,r2,8113fda0 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113fc04:	e0fffe0f 	ldh	r3,-8(fp)
8113fc08:	00a045b4 	movhi	r2,33046
8113fc0c:	10951004 	addi	r2,r2,21568
8113fc10:	180691ba 	slli	r3,r3,6
8113fc14:	10c5883a 	add	r2,r2,r3
8113fc18:	10800904 	addi	r2,r2,36
8113fc1c:	10800017 	ldw	r2,0(r2)
8113fc20:	1000e126 	beq	r2,zero,8113ffa8 <alt_up_sd_card_write+0x4e4>
8113fc24:	e0bffc0f 	ldh	r2,-16(fp)
8113fc28:	1000df1e 	bne	r2,zero,8113ffa8 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113fc2c:	e0fffe0f 	ldh	r3,-8(fp)
8113fc30:	00a045b4 	movhi	r2,33046
8113fc34:	10951004 	addi	r2,r2,21568
8113fc38:	180691ba 	slli	r3,r3,6
8113fc3c:	10c5883a 	add	r2,r2,r3
8113fc40:	10800804 	addi	r2,r2,32
8113fc44:	10c00017 	ldw	r3,0(r2)
8113fc48:	00a045b4 	movhi	r2,33046
8113fc4c:	1094fb04 	addi	r2,r2,21484
8113fc50:	10800383 	ldbu	r2,14(r2)
8113fc54:	10803fcc 	andi	r2,r2,255
8113fc58:	10bfffc4 	addi	r2,r2,-1
8113fc5c:	18803d1e 	bne	r3,r2,8113fd54 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113fc60:	e0fffe0f 	ldh	r3,-8(fp)
8113fc64:	00a045b4 	movhi	r2,33046
8113fc68:	10951004 	addi	r2,r2,21568
8113fc6c:	180691ba 	slli	r3,r3,6
8113fc70:	10c5883a 	add	r2,r2,r3
8113fc74:	10800704 	addi	r2,r2,28
8113fc78:	10800017 	ldw	r2,0(r2)
8113fc7c:	e0fffc84 	addi	r3,fp,-14
8113fc80:	180b883a 	mov	r5,r3
8113fc84:	1009883a 	mov	r4,r2
8113fc88:	113c0d00 	call	8113c0d0 <get_cluster_flag>
8113fc8c:	10002f26 	beq	r2,zero,8113fd4c <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
8113fc90:	e0bffc8b 	ldhu	r2,-14(fp)
8113fc94:	10bfffcc 	andi	r2,r2,65535
8113fc98:	10bffe28 	cmpgeui	r2,r2,65528
8113fc9c:	1000c21e 	bne	r2,zero,8113ffa8 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113fca0:	e13ffe0f 	ldh	r4,-8(fp)
8113fca4:	e0bffc8b 	ldhu	r2,-14(fp)
8113fca8:	10ffffcc 	andi	r3,r2,65535
8113fcac:	00a045b4 	movhi	r2,33046
8113fcb0:	10951004 	addi	r2,r2,21568
8113fcb4:	200891ba 	slli	r4,r4,6
8113fcb8:	1105883a 	add	r2,r2,r4
8113fcbc:	10800704 	addi	r2,r2,28
8113fcc0:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113fcc4:	e0fffe0f 	ldh	r3,-8(fp)
8113fcc8:	00a045b4 	movhi	r2,33046
8113fccc:	10951004 	addi	r2,r2,21568
8113fcd0:	180691ba 	slli	r3,r3,6
8113fcd4:	10c5883a 	add	r2,r2,r3
8113fcd8:	10800804 	addi	r2,r2,32
8113fcdc:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113fce0:	00a045b4 	movhi	r2,33046
8113fce4:	1094fb04 	addi	r2,r2,21484
8113fce8:	10c01417 	ldw	r3,80(r2)
8113fcec:	e13ffe0f 	ldh	r4,-8(fp)
8113fcf0:	00a045b4 	movhi	r2,33046
8113fcf4:	10951004 	addi	r2,r2,21568
8113fcf8:	200891ba 	slli	r4,r4,6
8113fcfc:	1105883a 	add	r2,r2,r4
8113fd00:	10800704 	addi	r2,r2,28
8113fd04:	10800017 	ldw	r2,0(r2)
8113fd08:	113fff84 	addi	r4,r2,-2
8113fd0c:	00a045b4 	movhi	r2,33046
8113fd10:	1094fb04 	addi	r2,r2,21484
8113fd14:	10800383 	ldbu	r2,14(r2)
8113fd18:	10803fcc 	andi	r2,r2,255
8113fd1c:	2085383a 	mul	r2,r4,r2
8113fd20:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113fd24:	e13ffe0f 	ldh	r4,-8(fp)
8113fd28:	00a045b4 	movhi	r2,33046
8113fd2c:	10951004 	addi	r2,r2,21568
8113fd30:	200891ba 	slli	r4,r4,6
8113fd34:	1105883a 	add	r2,r2,r4
8113fd38:	10800804 	addi	r2,r2,32
8113fd3c:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113fd40:	1885883a 	add	r2,r3,r2
8113fd44:	e0bffb15 	stw	r2,-20(fp)
8113fd48:	00009706 	br	8113ffa8 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
8113fd4c:	0005883a 	mov	r2,zero
8113fd50:	0000e106 	br	811400d8 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113fd54:	e13ffe0f 	ldh	r4,-8(fp)
8113fd58:	e0fffe0f 	ldh	r3,-8(fp)
8113fd5c:	00a045b4 	movhi	r2,33046
8113fd60:	10951004 	addi	r2,r2,21568
8113fd64:	180691ba 	slli	r3,r3,6
8113fd68:	10c5883a 	add	r2,r2,r3
8113fd6c:	10800804 	addi	r2,r2,32
8113fd70:	10800017 	ldw	r2,0(r2)
8113fd74:	10c00044 	addi	r3,r2,1
8113fd78:	00a045b4 	movhi	r2,33046
8113fd7c:	10951004 	addi	r2,r2,21568
8113fd80:	200891ba 	slli	r4,r4,6
8113fd84:	1105883a 	add	r2,r2,r4
8113fd88:	10800804 	addi	r2,r2,32
8113fd8c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113fd90:	e0bffb17 	ldw	r2,-20(fp)
8113fd94:	10800044 	addi	r2,r2,1
8113fd98:	e0bffb15 	stw	r2,-20(fp)
8113fd9c:	00008206 	br	8113ffa8 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113fda0:	e0fffe0f 	ldh	r3,-8(fp)
8113fda4:	00a045b4 	movhi	r2,33046
8113fda8:	10951004 	addi	r2,r2,21568
8113fdac:	180691ba 	slli	r3,r3,6
8113fdb0:	10c5883a 	add	r2,r2,r3
8113fdb4:	10800904 	addi	r2,r2,36
8113fdb8:	10800017 	ldw	r2,0(r2)
8113fdbc:	10007a26 	beq	r2,zero,8113ffa8 <alt_up_sd_card_write+0x4e4>
8113fdc0:	e0bffc0f 	ldh	r2,-16(fp)
8113fdc4:	1000781e 	bne	r2,zero,8113ffa8 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113fdc8:	e0fffe0f 	ldh	r3,-8(fp)
8113fdcc:	00a045b4 	movhi	r2,33046
8113fdd0:	10951004 	addi	r2,r2,21568
8113fdd4:	180691ba 	slli	r3,r3,6
8113fdd8:	10c5883a 	add	r2,r2,r3
8113fddc:	10800804 	addi	r2,r2,32
8113fde0:	10c00017 	ldw	r3,0(r2)
8113fde4:	00a045b4 	movhi	r2,33046
8113fde8:	1094fb04 	addi	r2,r2,21484
8113fdec:	10800383 	ldbu	r2,14(r2)
8113fdf0:	10803fcc 	andi	r2,r2,255
8113fdf4:	10bfffc4 	addi	r2,r2,-1
8113fdf8:	18803e1e 	bne	r3,r2,8113fef4 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8113fdfc:	e0bffd04 	addi	r2,fp,-12
8113fe00:	1009883a 	mov	r4,r2
8113fe04:	113e1140 	call	8113e114 <find_first_empty_cluster>
8113fe08:	10003826 	beq	r2,zero,8113feec <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8113fe0c:	e0fffe0f 	ldh	r3,-8(fp)
8113fe10:	00a045b4 	movhi	r2,33046
8113fe14:	10951004 	addi	r2,r2,21568
8113fe18:	180691ba 	slli	r3,r3,6
8113fe1c:	10c5883a 	add	r2,r2,r3
8113fe20:	10800704 	addi	r2,r2,28
8113fe24:	10800017 	ldw	r2,0(r2)
8113fe28:	e0fffd17 	ldw	r3,-12(fp)
8113fe2c:	18ffffcc 	andi	r3,r3,65535
8113fe30:	18e0001c 	xori	r3,r3,32768
8113fe34:	18e00004 	addi	r3,r3,-32768
8113fe38:	01800044 	movi	r6,1
8113fe3c:	180b883a 	mov	r5,r3
8113fe40:	1009883a 	mov	r4,r2
8113fe44:	113c18c0 	call	8113c18c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
8113fe48:	e0bffd17 	ldw	r2,-12(fp)
8113fe4c:	01800044 	movi	r6,1
8113fe50:	017fffc4 	movi	r5,-1
8113fe54:	1009883a 	mov	r4,r2
8113fe58:	113c18c0 	call	8113c18c <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
8113fe5c:	e0fffe0f 	ldh	r3,-8(fp)
8113fe60:	00a045b4 	movhi	r2,33046
8113fe64:	10951004 	addi	r2,r2,21568
8113fe68:	180691ba 	slli	r3,r3,6
8113fe6c:	10c5883a 	add	r2,r2,r3
8113fe70:	10800704 	addi	r2,r2,28
8113fe74:	10800017 	ldw	r2,0(r2)
8113fe78:	e0fffd17 	ldw	r3,-12(fp)
8113fe7c:	18ffffcc 	andi	r3,r3,65535
8113fe80:	18e0001c 	xori	r3,r3,32768
8113fe84:	18e00004 	addi	r3,r3,-32768
8113fe88:	000d883a 	mov	r6,zero
8113fe8c:	180b883a 	mov	r5,r3
8113fe90:	1009883a 	mov	r4,r2
8113fe94:	113c18c0 	call	8113c18c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
8113fe98:	e0bffd17 	ldw	r2,-12(fp)
8113fe9c:	000d883a 	mov	r6,zero
8113fea0:	017fffc4 	movi	r5,-1
8113fea4:	1009883a 	mov	r4,r2
8113fea8:	113c18c0 	call	8113c18c <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8113feac:	e13ffe0f 	ldh	r4,-8(fp)
8113feb0:	e0fffd17 	ldw	r3,-12(fp)
8113feb4:	00a045b4 	movhi	r2,33046
8113feb8:	10951004 	addi	r2,r2,21568
8113febc:	200891ba 	slli	r4,r4,6
8113fec0:	1105883a 	add	r2,r2,r4
8113fec4:	10800704 	addi	r2,r2,28
8113fec8:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8113fecc:	e0fffe0f 	ldh	r3,-8(fp)
8113fed0:	00a045b4 	movhi	r2,33046
8113fed4:	10951004 	addi	r2,r2,21568
8113fed8:	180691ba 	slli	r3,r3,6
8113fedc:	10c5883a 	add	r2,r2,r3
8113fee0:	10800804 	addi	r2,r2,32
8113fee4:	10000015 	stw	zero,0(r2)
8113fee8:	00001506 	br	8113ff40 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8113feec:	0005883a 	mov	r2,zero
8113fef0:	00007906 	br	811400d8 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
8113fef4:	e13ffe0f 	ldh	r4,-8(fp)
8113fef8:	e0fffe0f 	ldh	r3,-8(fp)
8113fefc:	00a045b4 	movhi	r2,33046
8113ff00:	10951004 	addi	r2,r2,21568
8113ff04:	180691ba 	slli	r3,r3,6
8113ff08:	10c5883a 	add	r2,r2,r3
8113ff0c:	10800904 	addi	r2,r2,36
8113ff10:	10c00017 	ldw	r3,0(r2)
8113ff14:	00a045b4 	movhi	r2,33046
8113ff18:	1094fb04 	addi	r2,r2,21484
8113ff1c:	1080030b 	ldhu	r2,12(r2)
8113ff20:	10bfffcc 	andi	r2,r2,65535
8113ff24:	1887203a 	divu	r3,r3,r2
8113ff28:	00a045b4 	movhi	r2,33046
8113ff2c:	10951004 	addi	r2,r2,21568
8113ff30:	200891ba 	slli	r4,r4,6
8113ff34:	1105883a 	add	r2,r2,r4
8113ff38:	10800804 	addi	r2,r2,32
8113ff3c:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ff40:	00a045b4 	movhi	r2,33046
8113ff44:	1094fb04 	addi	r2,r2,21484
8113ff48:	10c01417 	ldw	r3,80(r2)
8113ff4c:	e13ffe0f 	ldh	r4,-8(fp)
8113ff50:	00a045b4 	movhi	r2,33046
8113ff54:	10951004 	addi	r2,r2,21568
8113ff58:	200891ba 	slli	r4,r4,6
8113ff5c:	1105883a 	add	r2,r2,r4
8113ff60:	10800704 	addi	r2,r2,28
8113ff64:	10800017 	ldw	r2,0(r2)
8113ff68:	113fff84 	addi	r4,r2,-2
8113ff6c:	00a045b4 	movhi	r2,33046
8113ff70:	1094fb04 	addi	r2,r2,21484
8113ff74:	10800383 	ldbu	r2,14(r2)
8113ff78:	10803fcc 	andi	r2,r2,255
8113ff7c:	2085383a 	mul	r2,r4,r2
8113ff80:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
8113ff84:	e13ffe0f 	ldh	r4,-8(fp)
8113ff88:	00a045b4 	movhi	r2,33046
8113ff8c:	10951004 	addi	r2,r2,21568
8113ff90:	200891ba 	slli	r4,r4,6
8113ff94:	1105883a 	add	r2,r2,r4
8113ff98:	10800804 	addi	r2,r2,32
8113ff9c:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ffa0:	1885883a 	add	r2,r3,r2
8113ffa4:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
8113ffa8:	d0e0b617 	ldw	r3,-32040(gp)
8113ffac:	e0bffb17 	ldw	r2,-20(fp)
8113ffb0:	1885883a 	add	r2,r3,r2
8113ffb4:	1007883a 	mov	r3,r2
8113ffb8:	d0a0ba17 	ldw	r2,-32024(gp)
8113ffbc:	18800726 	beq	r3,r2,8113ffdc <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113ffc0:	d0a0b617 	ldw	r2,-32040(gp)
8113ffc4:	100b883a 	mov	r5,r2
8113ffc8:	e13ffb17 	ldw	r4,-20(fp)
8113ffcc:	113bff00 	call	8113bff0 <Read_Sector_Data>
8113ffd0:	1000021e 	bne	r2,zero,8113ffdc <alt_up_sd_card_write+0x518>
                {
					return false;
8113ffd4:	0005883a 	mov	r2,zero
8113ffd8:	00003f06 	br	811400d8 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8113ffdc:	d0e0b517 	ldw	r3,-32044(gp)
8113ffe0:	e0bffc0f 	ldh	r2,-16(fp)
8113ffe4:	1885883a 	add	r2,r3,r2
8113ffe8:	e0ffff07 	ldb	r3,-4(fp)
8113ffec:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113fff0:	e13ffe0f 	ldh	r4,-8(fp)
8113fff4:	e0fffe0f 	ldh	r3,-8(fp)
8113fff8:	00a045b4 	movhi	r2,33046
8113fffc:	10951004 	addi	r2,r2,21568
81140000:	180691ba 	slli	r3,r3,6
81140004:	10c5883a 	add	r2,r2,r3
81140008:	10800904 	addi	r2,r2,36
8114000c:	10800017 	ldw	r2,0(r2)
81140010:	10c00044 	addi	r3,r2,1
81140014:	00a045b4 	movhi	r2,33046
81140018:	10951004 	addi	r2,r2,21568
8114001c:	200891ba 	slli	r4,r4,6
81140020:	1105883a 	add	r2,r2,r4
81140024:	10800904 	addi	r2,r2,36
81140028:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
8114002c:	e0fffe0f 	ldh	r3,-8(fp)
81140030:	00a045b4 	movhi	r2,33046
81140034:	10951004 	addi	r2,r2,21568
81140038:	180691ba 	slli	r3,r3,6
8114003c:	10c5883a 	add	r2,r2,r3
81140040:	10800904 	addi	r2,r2,36
81140044:	10c00017 	ldw	r3,0(r2)
81140048:	e13ffe0f 	ldh	r4,-8(fp)
8114004c:	00a045b4 	movhi	r2,33046
81140050:	10951004 	addi	r2,r2,21568
81140054:	200891ba 	slli	r4,r4,6
81140058:	1105883a 	add	r2,r2,r4
8114005c:	10800604 	addi	r2,r2,24
81140060:	10800017 	ldw	r2,0(r2)
81140064:	18801736 	bltu	r3,r2,811400c4 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
81140068:	e13ffe0f 	ldh	r4,-8(fp)
8114006c:	e0fffe0f 	ldh	r3,-8(fp)
81140070:	00a045b4 	movhi	r2,33046
81140074:	10951004 	addi	r2,r2,21568
81140078:	180691ba 	slli	r3,r3,6
8114007c:	10c5883a 	add	r2,r2,r3
81140080:	10800604 	addi	r2,r2,24
81140084:	10800017 	ldw	r2,0(r2)
81140088:	10c00044 	addi	r3,r2,1
8114008c:	00a045b4 	movhi	r2,33046
81140090:	10951004 	addi	r2,r2,21568
81140094:	200891ba 	slli	r4,r4,6
81140098:	1105883a 	add	r2,r2,r4
8114009c:	10800604 	addi	r2,r2,24
811400a0:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
811400a4:	e0fffe0f 	ldh	r3,-8(fp)
811400a8:	00a045b4 	movhi	r2,33046
811400ac:	10951004 	addi	r2,r2,21568
811400b0:	180691ba 	slli	r3,r3,6
811400b4:	10c5883a 	add	r2,r2,r3
811400b8:	10800e04 	addi	r2,r2,56
811400bc:	00c00044 	movi	r3,1
811400c0:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
811400c4:	00800044 	movi	r2,1
811400c8:	d0a0b915 	stw	r2,-32028(gp)
			result = true;
811400cc:	00800044 	movi	r2,1
811400d0:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
811400d4:	e0bffa17 	ldw	r2,-24(fp)
}
811400d8:	e037883a 	mov	sp,fp
811400dc:	dfc00117 	ldw	ra,4(sp)
811400e0:	df000017 	ldw	fp,0(sp)
811400e4:	dec00204 	addi	sp,sp,8
811400e8:	f800283a 	ret

811400ec <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
811400ec:	defffb04 	addi	sp,sp,-20
811400f0:	de00012e 	bgeu	sp,et,811400f8 <alt_up_sd_card_fclose+0xc>
811400f4:	003b68fa 	trap	3
811400f8:	dfc00415 	stw	ra,16(sp)
811400fc:	df000315 	stw	fp,12(sp)
81140100:	df000304 	addi	fp,sp,12
81140104:	2005883a 	mov	r2,r4
81140108:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
8114010c:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140110:	113ecc80 	call	8113ecc8 <alt_up_sd_card_is_Present>
81140114:	10006026 	beq	r2,zero,81140298 <alt_up_sd_card_fclose+0x1ac>
81140118:	d0a0af17 	ldw	r2,-32068(gp)
8114011c:	10005e26 	beq	r2,zero,81140298 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
81140120:	e0ffff0f 	ldh	r3,-4(fp)
81140124:	00a045b4 	movhi	r2,33046
81140128:	10951004 	addi	r2,r2,21568
8114012c:	180691ba 	slli	r3,r3,6
81140130:	10c5883a 	add	r2,r2,r3
81140134:	10800f04 	addi	r2,r2,60
81140138:	10800017 	ldw	r2,0(r2)
8114013c:	10005626 	beq	r2,zero,81140298 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
81140140:	e0ffff0f 	ldh	r3,-4(fp)
81140144:	00a045b4 	movhi	r2,33046
81140148:	10951004 	addi	r2,r2,21568
8114014c:	180691ba 	slli	r3,r3,6
81140150:	10c5883a 	add	r2,r2,r3
81140154:	10800e04 	addi	r2,r2,56
81140158:	10800017 	ldw	r2,0(r2)
8114015c:	10004526 	beq	r2,zero,81140274 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
81140160:	e0ffff0f 	ldh	r3,-4(fp)
81140164:	00a045b4 	movhi	r2,33046
81140168:	10951004 	addi	r2,r2,21568
8114016c:	180691ba 	slli	r3,r3,6
81140170:	10c5883a 	add	r2,r2,r3
81140174:	10800b04 	addi	r2,r2,44
81140178:	10800017 	ldw	r2,0(r2)
8114017c:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81140180:	e0ffff0f 	ldh	r3,-4(fp)
81140184:	00a045b4 	movhi	r2,33046
81140188:	10951004 	addi	r2,r2,21568
8114018c:	180691ba 	slli	r3,r3,6
81140190:	10c5883a 	add	r2,r2,r3
81140194:	10800a04 	addi	r2,r2,40
81140198:	10800017 	ldw	r2,0(r2)
8114019c:	1000071e 	bne	r2,zero,811401bc <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
811401a0:	00a045b4 	movhi	r2,33046
811401a4:	1094fb04 	addi	r2,r2,21484
811401a8:	10801317 	ldw	r2,76(r2)
811401ac:	e0fffe17 	ldw	r3,-8(fp)
811401b0:	1885883a 	add	r2,r3,r2
811401b4:	e0bffe15 	stw	r2,-8(fp)
811401b8:	00001406 	br	8114020c <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
811401bc:	00a045b4 	movhi	r2,33046
811401c0:	1094fb04 	addi	r2,r2,21484
811401c4:	10c01417 	ldw	r3,80(r2)
811401c8:	e0bffe17 	ldw	r2,-8(fp)
811401cc:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
811401d0:	e13fff0f 	ldh	r4,-4(fp)
811401d4:	00a045b4 	movhi	r2,33046
811401d8:	10951004 	addi	r2,r2,21568
811401dc:	200891ba 	slli	r4,r4,6
811401e0:	1105883a 	add	r2,r2,r4
811401e4:	10800a04 	addi	r2,r2,40
811401e8:	10800017 	ldw	r2,0(r2)
811401ec:	113fff84 	addi	r4,r2,-2
811401f0:	00a045b4 	movhi	r2,33046
811401f4:	1094fb04 	addi	r2,r2,21484
811401f8:	10800383 	ldbu	r2,14(r2)
811401fc:	10803fcc 	andi	r2,r2,255
81140200:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81140204:	1885883a 	add	r2,r3,r2
81140208:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
8114020c:	e0bffe17 	ldw	r2,-8(fp)
81140210:	d0e0b617 	ldw	r3,-32040(gp)
81140214:	180b883a 	mov	r5,r3
81140218:	1009883a 	mov	r4,r2
8114021c:	113bff00 	call	8113bff0 <Read_Sector_Data>
81140220:	10001426 	beq	r2,zero,81140274 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81140224:	e0ffff0f 	ldh	r3,-4(fp)
81140228:	00a045b4 	movhi	r2,33046
8114022c:	10951004 	addi	r2,r2,21568
81140230:	180691ba 	slli	r3,r3,6
81140234:	10c5883a 	add	r2,r2,r3
81140238:	10800c04 	addi	r2,r2,48
8114023c:	1080000b 	ldhu	r2,0(r2)
81140240:	113fffcc 	andi	r4,r2,65535
81140244:	2120001c 	xori	r4,r4,32768
81140248:	21200004 	addi	r4,r4,-32768
8114024c:	e0bfff0f 	ldh	r2,-4(fp)
81140250:	100691ba 	slli	r3,r2,6
81140254:	00a045b4 	movhi	r2,33046
81140258:	10951004 	addi	r2,r2,21568
8114025c:	1885883a 	add	r2,r3,r2
81140260:	100b883a 	mov	r5,r2
81140264:	113c6a40 	call	8113c6a4 <Write_File_Record_At_Offset>
81140268:	10000226 	beq	r2,zero,81140274 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
8114026c:	113bf9c0 	call	8113bf9c <Save_Modified_Sector>
81140270:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81140274:	e0ffff0f 	ldh	r3,-4(fp)
81140278:	00a045b4 	movhi	r2,33046
8114027c:	10951004 	addi	r2,r2,21568
81140280:	180691ba 	slli	r3,r3,6
81140284:	10c5883a 	add	r2,r2,r3
81140288:	10800f04 	addi	r2,r2,60
8114028c:	10000015 	stw	zero,0(r2)
			result = true;
81140290:	00800044 	movi	r2,1
81140294:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81140298:	e0bffd17 	ldw	r2,-12(fp)
}
8114029c:	e037883a 	mov	sp,fp
811402a0:	dfc00117 	ldw	ra,4(sp)
811402a4:	df000017 	ldw	fp,0(sp)
811402a8:	dec00204 	addi	sp,sp,8
811402ac:	f800283a 	ret

811402b0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811402b0:	defffa04 	addi	sp,sp,-24
811402b4:	de00012e 	bgeu	sp,et,811402bc <altera_avalon_jtag_uart_read_fd+0xc>
811402b8:	003b68fa 	trap	3
811402bc:	dfc00515 	stw	ra,20(sp)
811402c0:	df000415 	stw	fp,16(sp)
811402c4:	df000404 	addi	fp,sp,16
811402c8:	e13ffd15 	stw	r4,-12(fp)
811402cc:	e17ffe15 	stw	r5,-8(fp)
811402d0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811402d4:	e0bffd17 	ldw	r2,-12(fp)
811402d8:	10800017 	ldw	r2,0(r2)
811402dc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
811402e0:	e0bffc17 	ldw	r2,-16(fp)
811402e4:	10c00a04 	addi	r3,r2,40
811402e8:	e0bffd17 	ldw	r2,-12(fp)
811402ec:	10800217 	ldw	r2,8(r2)
811402f0:	100f883a 	mov	r7,r2
811402f4:	e1bfff17 	ldw	r6,-4(fp)
811402f8:	e17ffe17 	ldw	r5,-8(fp)
811402fc:	1809883a 	mov	r4,r3
81140300:	1140b340 	call	81140b34 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81140304:	e037883a 	mov	sp,fp
81140308:	dfc00117 	ldw	ra,4(sp)
8114030c:	df000017 	ldw	fp,0(sp)
81140310:	dec00204 	addi	sp,sp,8
81140314:	f800283a 	ret

81140318 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81140318:	defffa04 	addi	sp,sp,-24
8114031c:	de00012e 	bgeu	sp,et,81140324 <altera_avalon_jtag_uart_write_fd+0xc>
81140320:	003b68fa 	trap	3
81140324:	dfc00515 	stw	ra,20(sp)
81140328:	df000415 	stw	fp,16(sp)
8114032c:	df000404 	addi	fp,sp,16
81140330:	e13ffd15 	stw	r4,-12(fp)
81140334:	e17ffe15 	stw	r5,-8(fp)
81140338:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8114033c:	e0bffd17 	ldw	r2,-12(fp)
81140340:	10800017 	ldw	r2,0(r2)
81140344:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81140348:	e0bffc17 	ldw	r2,-16(fp)
8114034c:	10c00a04 	addi	r3,r2,40
81140350:	e0bffd17 	ldw	r2,-12(fp)
81140354:	10800217 	ldw	r2,8(r2)
81140358:	100f883a 	mov	r7,r2
8114035c:	e1bfff17 	ldw	r6,-4(fp)
81140360:	e17ffe17 	ldw	r5,-8(fp)
81140364:	1809883a 	mov	r4,r3
81140368:	1140df80 	call	81140df8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
8114036c:	e037883a 	mov	sp,fp
81140370:	dfc00117 	ldw	ra,4(sp)
81140374:	df000017 	ldw	fp,0(sp)
81140378:	dec00204 	addi	sp,sp,8
8114037c:	f800283a 	ret

81140380 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81140380:	defffc04 	addi	sp,sp,-16
81140384:	de00012e 	bgeu	sp,et,8114038c <altera_avalon_jtag_uart_close_fd+0xc>
81140388:	003b68fa 	trap	3
8114038c:	dfc00315 	stw	ra,12(sp)
81140390:	df000215 	stw	fp,8(sp)
81140394:	df000204 	addi	fp,sp,8
81140398:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8114039c:	e0bfff17 	ldw	r2,-4(fp)
811403a0:	10800017 	ldw	r2,0(r2)
811403a4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
811403a8:	e0bffe17 	ldw	r2,-8(fp)
811403ac:	10c00a04 	addi	r3,r2,40
811403b0:	e0bfff17 	ldw	r2,-4(fp)
811403b4:	10800217 	ldw	r2,8(r2)
811403b8:	100b883a 	mov	r5,r2
811403bc:	1809883a 	mov	r4,r3
811403c0:	11409cc0 	call	811409cc <altera_avalon_jtag_uart_close>
}
811403c4:	e037883a 	mov	sp,fp
811403c8:	dfc00117 	ldw	ra,4(sp)
811403cc:	df000017 	ldw	fp,0(sp)
811403d0:	dec00204 	addi	sp,sp,8
811403d4:	f800283a 	ret

811403d8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
811403d8:	defffa04 	addi	sp,sp,-24
811403dc:	de00012e 	bgeu	sp,et,811403e4 <altera_avalon_jtag_uart_ioctl_fd+0xc>
811403e0:	003b68fa 	trap	3
811403e4:	dfc00515 	stw	ra,20(sp)
811403e8:	df000415 	stw	fp,16(sp)
811403ec:	df000404 	addi	fp,sp,16
811403f0:	e13ffd15 	stw	r4,-12(fp)
811403f4:	e17ffe15 	stw	r5,-8(fp)
811403f8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
811403fc:	e0bffd17 	ldw	r2,-12(fp)
81140400:	10800017 	ldw	r2,0(r2)
81140404:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81140408:	e0bffc17 	ldw	r2,-16(fp)
8114040c:	10800a04 	addi	r2,r2,40
81140410:	e1bfff17 	ldw	r6,-4(fp)
81140414:	e17ffe17 	ldw	r5,-8(fp)
81140418:	1009883a 	mov	r4,r2
8114041c:	1140a3c0 	call	81140a3c <altera_avalon_jtag_uart_ioctl>
}
81140420:	e037883a 	mov	sp,fp
81140424:	dfc00117 	ldw	ra,4(sp)
81140428:	df000017 	ldw	fp,0(sp)
8114042c:	dec00204 	addi	sp,sp,8
81140430:	f800283a 	ret

81140434 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81140434:	deffef04 	addi	sp,sp,-68
81140438:	de00012e 	bgeu	sp,et,81140440 <altera_avalon_jtag_uart_init+0xc>
8114043c:	003b68fa 	trap	3
81140440:	dfc01015 	stw	ra,64(sp)
81140444:	df000f15 	stw	fp,60(sp)
81140448:	dc400e15 	stw	r17,56(sp)
8114044c:	dc000d15 	stw	r16,52(sp)
81140450:	df000f04 	addi	fp,sp,60
81140454:	e13ff715 	stw	r4,-36(fp)
81140458:	e17ff815 	stw	r5,-32(fp)
8114045c:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
81140460:	e0bff717 	ldw	r2,-36(fp)
81140464:	10800c04 	addi	r2,r2,48
81140468:	e0bff215 	stw	r2,-56(fp)
8114046c:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81140470:	e0bff60b 	ldhu	r2,-40(fp)
81140474:	e0fff684 	addi	r3,fp,-38
81140478:	180b883a 	mov	r5,r3
8114047c:	1009883a 	mov	r4,r2
81140480:	11347b80 	call	811347b8 <OSFlagCreate>
81140484:	1007883a 	mov	r3,r2
81140488:	e0bff217 	ldw	r2,-56(fp)
8114048c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81140490:	e0bff717 	ldw	r2,-36(fp)
81140494:	10800a04 	addi	r2,r2,40
81140498:	e0bff315 	stw	r2,-52(fp)
8114049c:	00800044 	movi	r2,1
811404a0:	e0bff58d 	sth	r2,-42(fp)
811404a4:	e0bff58b 	ldhu	r2,-42(fp)
811404a8:	1009883a 	mov	r4,r2
811404ac:	11387140 	call	81138714 <OSSemCreate>
811404b0:	1007883a 	mov	r3,r2
811404b4:	e0bff317 	ldw	r2,-52(fp)
811404b8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
811404bc:	e0bff717 	ldw	r2,-36(fp)
811404c0:	10800b04 	addi	r2,r2,44
811404c4:	e0bff415 	stw	r2,-48(fp)
811404c8:	00800044 	movi	r2,1
811404cc:	e0bff50d 	sth	r2,-44(fp)
811404d0:	e0bff50b 	ldhu	r2,-44(fp)
811404d4:	1009883a 	mov	r4,r2
811404d8:	11387140 	call	81138714 <OSSemCreate>
811404dc:	1007883a 	mov	r3,r2
811404e0:	e0bff417 	ldw	r2,-48(fp)
811404e4:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811404e8:	e0bff717 	ldw	r2,-36(fp)
811404ec:	00c00044 	movi	r3,1
811404f0:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
811404f4:	e0bff717 	ldw	r2,-36(fp)
811404f8:	10800017 	ldw	r2,0(r2)
811404fc:	10800104 	addi	r2,r2,4
81140500:	1007883a 	mov	r3,r2
81140504:	e0bff717 	ldw	r2,-36(fp)
81140508:	10800817 	ldw	r2,32(r2)
8114050c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
81140510:	e0bff817 	ldw	r2,-32(fp)
81140514:	e0fff917 	ldw	r3,-28(fp)
81140518:	d8000015 	stw	zero,0(sp)
8114051c:	e1fff717 	ldw	r7,-36(fp)
81140520:	01a04534 	movhi	r6,33044
81140524:	31818104 	addi	r6,r6,1540
81140528:	180b883a 	mov	r5,r3
8114052c:	1009883a 	mov	r4,r2
81140530:	114434c0 	call	8114434c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81140534:	e0bff717 	ldw	r2,-36(fp)
81140538:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
8114053c:	e0bff717 	ldw	r2,-36(fp)
81140540:	10800204 	addi	r2,r2,8
81140544:	d0e08d17 	ldw	r3,-32204(gp)
81140548:	e1fff717 	ldw	r7,-36(fp)
8114054c:	01a04534 	movhi	r6,33044
81140550:	31823004 	addi	r6,r6,2240
81140554:	180b883a 	mov	r5,r3
81140558:	1009883a 	mov	r4,r2
8114055c:	1143e9c0 	call	81143e9c <alt_alarm_start>
81140560:	1000040e 	bge	r2,zero,81140574 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
81140564:	e0fff717 	ldw	r3,-36(fp)
81140568:	00a00034 	movhi	r2,32768
8114056c:	10bfffc4 	addi	r2,r2,-1
81140570:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81140574:	d0a08683 	ldbu	r2,-32230(gp)
81140578:	10803fcc 	andi	r2,r2,255
8114057c:	10800058 	cmpnei	r2,r2,1
81140580:	10000f1e 	bne	r2,zero,811405c0 <altera_avalon_jtag_uart_init+0x18c>
81140584:	d0e08d17 	ldw	r3,-32204(gp)
81140588:	00b33374 	movhi	r2,52429
8114058c:	10b33344 	addi	r2,r2,-13107
81140590:	1888383a 	mulxuu	r4,r3,r2
81140594:	1885383a 	mul	r2,r3,r2
81140598:	1021883a 	mov	r16,r2
8114059c:	2023883a 	mov	r17,r4
811405a0:	8804d0fa 	srli	r2,r17,3
811405a4:	e1fff717 	ldw	r7,-36(fp)
811405a8:	01a044f4 	movhi	r6,33043
811405ac:	3183ba04 	addi	r6,r6,3816
811405b0:	100b883a 	mov	r5,r2
811405b4:	012045b4 	movhi	r4,33046
811405b8:	213eb904 	addi	r4,r4,-1308
811405bc:	1143e9c0 	call	81143e9c <alt_alarm_start>
811405c0:	d0a08703 	ldbu	r2,-32228(gp)
811405c4:	10803fcc 	andi	r2,r2,255
811405c8:	10800058 	cmpnei	r2,r2,1
811405cc:	1000051e 	bne	r2,zero,811405e4 <altera_avalon_jtag_uart_init+0x1b0>
811405d0:	e0bff717 	ldw	r2,-36(fp)
811405d4:	10800017 	ldw	r2,0(r2)
811405d8:	100b883a 	mov	r5,r2
811405dc:	e13ff717 	ldw	r4,-36(fp)
811405e0:	11310800 	call	81131080 <alt_log_jtag_uart_startup_info>
}
811405e4:	0001883a 	nop
811405e8:	e6fffe04 	addi	sp,fp,-8
811405ec:	dfc00317 	ldw	ra,12(sp)
811405f0:	df000217 	ldw	fp,8(sp)
811405f4:	dc400117 	ldw	r17,4(sp)
811405f8:	dc000017 	ldw	r16,0(sp)
811405fc:	dec00404 	addi	sp,sp,16
81140600:	f800283a 	ret

81140604 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81140604:	defff204 	addi	sp,sp,-56
81140608:	de00012e 	bgeu	sp,et,81140610 <altera_avalon_jtag_uart_irq+0xc>
8114060c:	003b68fa 	trap	3
81140610:	dfc00d15 	stw	ra,52(sp)
81140614:	df000c15 	stw	fp,48(sp)
81140618:	df000c04 	addi	fp,sp,48
8114061c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81140620:	e0bfff17 	ldw	r2,-4(fp)
81140624:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81140628:	e0bff617 	ldw	r2,-40(fp)
8114062c:	10800017 	ldw	r2,0(r2)
81140630:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81140634:	e0bff717 	ldw	r2,-36(fp)
81140638:	e17ff617 	ldw	r5,-40(fp)
8114063c:	1009883a 	mov	r4,r2
81140640:	11310d40 	call	811310d4 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81140644:	e0bff717 	ldw	r2,-36(fp)
81140648:	10800104 	addi	r2,r2,4
8114064c:	10800037 	ldwio	r2,0(r2)
81140650:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81140654:	e0bff817 	ldw	r2,-32(fp)
81140658:	1080c00c 	andi	r2,r2,768
8114065c:	10009126 	beq	r2,zero,811408a4 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81140660:	e0bff817 	ldw	r2,-32(fp)
81140664:	1080400c 	andi	r2,r2,256
81140668:	10004726 	beq	r2,zero,81140788 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
8114066c:	00800074 	movhi	r2,1
81140670:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81140674:	e0bff617 	ldw	r2,-40(fp)
81140678:	10800d17 	ldw	r2,52(r2)
8114067c:	10800044 	addi	r2,r2,1
81140680:	1081ffcc 	andi	r2,r2,2047
81140684:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81140688:	e0bff617 	ldw	r2,-40(fp)
8114068c:	10c00e17 	ldw	r3,56(r2)
81140690:	e0bff917 	ldw	r2,-28(fp)
81140694:	18802726 	beq	r3,r2,81140734 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81140698:	e0bff717 	ldw	r2,-36(fp)
8114069c:	10800037 	ldwio	r2,0(r2)
811406a0:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
811406a4:	e0bff417 	ldw	r2,-48(fp)
811406a8:	10a0000c 	andi	r2,r2,32768
811406ac:	10002326 	beq	r2,zero,8114073c <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
811406b0:	e0bff617 	ldw	r2,-40(fp)
811406b4:	10800d17 	ldw	r2,52(r2)
811406b8:	e0fff417 	ldw	r3,-48(fp)
811406bc:	1809883a 	mov	r4,r3
811406c0:	e0fff617 	ldw	r3,-40(fp)
811406c4:	1885883a 	add	r2,r3,r2
811406c8:	10801104 	addi	r2,r2,68
811406cc:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811406d0:	e0bff617 	ldw	r2,-40(fp)
811406d4:	10800d17 	ldw	r2,52(r2)
811406d8:	10800044 	addi	r2,r2,1
811406dc:	10c1ffcc 	andi	r3,r2,2047
811406e0:	e0bff617 	ldw	r2,-40(fp)
811406e4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
811406e8:	e0bff617 	ldw	r2,-40(fp)
811406ec:	10800c17 	ldw	r2,48(r2)
811406f0:	e0bffb15 	stw	r2,-20(fp)
811406f4:	00800044 	movi	r2,1
811406f8:	e0bffc0d 	sth	r2,-16(fp)
811406fc:	00800044 	movi	r2,1
81140700:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81140704:	d0a09603 	ldbu	r2,-32168(gp)
81140708:	10803fcc 	andi	r2,r2,255
8114070c:	103fd926 	beq	r2,zero,81140674 <__reset+0xfb120674>
  {
    OSFlagPost (group, flags, opt, &err);
81140710:	e0bffc0b 	ldhu	r2,-16(fp)
81140714:	e0fffc83 	ldbu	r3,-14(fp)
81140718:	e13ffdc4 	addi	r4,fp,-9
8114071c:	200f883a 	mov	r7,r4
81140720:	180d883a 	mov	r6,r3
81140724:	100b883a 	mov	r5,r2
81140728:	e13ffb17 	ldw	r4,-20(fp)
8114072c:	11353c40 	call	811353c4 <OSFlagPost>
      }
81140730:	003fd006 	br	81140674 <__reset+0xfb120674>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81140734:	0001883a 	nop
81140738:	00000106 	br	81140740 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
8114073c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81140740:	e0bff417 	ldw	r2,-48(fp)
81140744:	10bfffec 	andhi	r2,r2,65535
81140748:	10000f26 	beq	r2,zero,81140788 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8114074c:	e0bff617 	ldw	r2,-40(fp)
81140750:	10c00817 	ldw	r3,32(r2)
81140754:	00bfff84 	movi	r2,-2
81140758:	1886703a 	and	r3,r3,r2
8114075c:	e0bff617 	ldw	r2,-40(fp)
81140760:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81140764:	e0bff717 	ldw	r2,-36(fp)
81140768:	10800104 	addi	r2,r2,4
8114076c:	1007883a 	mov	r3,r2
81140770:	e0bff617 	ldw	r2,-40(fp)
81140774:	10800817 	ldw	r2,32(r2)
81140778:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8114077c:	e0bff717 	ldw	r2,-36(fp)
81140780:	10800104 	addi	r2,r2,4
81140784:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81140788:	e0bff817 	ldw	r2,-32(fp)
8114078c:	1080800c 	andi	r2,r2,512
81140790:	103fac26 	beq	r2,zero,81140644 <__reset+0xfb120644>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81140794:	e0bff817 	ldw	r2,-32(fp)
81140798:	1004d43a 	srli	r2,r2,16
8114079c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
811407a0:	00002606 	br	8114083c <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
811407a4:	e0bff717 	ldw	r2,-36(fp)
811407a8:	e0fff617 	ldw	r3,-40(fp)
811407ac:	18c01017 	ldw	r3,64(r3)
811407b0:	e13ff617 	ldw	r4,-40(fp)
811407b4:	20c7883a 	add	r3,r4,r3
811407b8:	18c21104 	addi	r3,r3,2116
811407bc:	18c00003 	ldbu	r3,0(r3)
811407c0:	18c03fcc 	andi	r3,r3,255
811407c4:	18c0201c 	xori	r3,r3,128
811407c8:	18ffe004 	addi	r3,r3,-128
811407cc:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811407d0:	e0bff617 	ldw	r2,-40(fp)
811407d4:	10801017 	ldw	r2,64(r2)
811407d8:	10800044 	addi	r2,r2,1
811407dc:	10c1ffcc 	andi	r3,r2,2047
811407e0:	e0bff617 	ldw	r2,-40(fp)
811407e4:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
811407e8:	e0bff617 	ldw	r2,-40(fp)
811407ec:	10800c17 	ldw	r2,48(r2)
811407f0:	e0bffa15 	stw	r2,-24(fp)
811407f4:	00800084 	movi	r2,2
811407f8:	e0bffd0d 	sth	r2,-12(fp)
811407fc:	00800044 	movi	r2,1
81140800:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81140804:	d0a09603 	ldbu	r2,-32168(gp)
81140808:	10803fcc 	andi	r2,r2,255
8114080c:	10000826 	beq	r2,zero,81140830 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81140810:	e0bffd0b 	ldhu	r2,-12(fp)
81140814:	e0fffd83 	ldbu	r3,-10(fp)
81140818:	e13ffe04 	addi	r4,fp,-8
8114081c:	200f883a 	mov	r7,r4
81140820:	180d883a 	mov	r6,r3
81140824:	100b883a 	mov	r5,r2
81140828:	e13ffa17 	ldw	r4,-24(fp)
8114082c:	11353c40 	call	811353c4 <OSFlagPost>

        space--;
81140830:	e0bff517 	ldw	r2,-44(fp)
81140834:	10bfffc4 	addi	r2,r2,-1
81140838:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
8114083c:	e0bff517 	ldw	r2,-44(fp)
81140840:	10000526 	beq	r2,zero,81140858 <altera_avalon_jtag_uart_irq+0x254>
81140844:	e0bff617 	ldw	r2,-40(fp)
81140848:	10c01017 	ldw	r3,64(r2)
8114084c:	e0bff617 	ldw	r2,-40(fp)
81140850:	10800f17 	ldw	r2,60(r2)
81140854:	18bfd31e 	bne	r3,r2,811407a4 <__reset+0xfb1207a4>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81140858:	e0bff517 	ldw	r2,-44(fp)
8114085c:	103f7926 	beq	r2,zero,81140644 <__reset+0xfb120644>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81140860:	e0bff617 	ldw	r2,-40(fp)
81140864:	10c00817 	ldw	r3,32(r2)
81140868:	00bfff44 	movi	r2,-3
8114086c:	1886703a 	and	r3,r3,r2
81140870:	e0bff617 	ldw	r2,-40(fp)
81140874:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81140878:	e0bff617 	ldw	r2,-40(fp)
8114087c:	10800017 	ldw	r2,0(r2)
81140880:	10800104 	addi	r2,r2,4
81140884:	1007883a 	mov	r3,r2
81140888:	e0bff617 	ldw	r2,-40(fp)
8114088c:	10800817 	ldw	r2,32(r2)
81140890:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81140894:	e0bff717 	ldw	r2,-36(fp)
81140898:	10800104 	addi	r2,r2,4
8114089c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
811408a0:	003f6806 	br	81140644 <__reset+0xfb120644>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
811408a4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
811408a8:	0001883a 	nop
811408ac:	e037883a 	mov	sp,fp
811408b0:	dfc00117 	ldw	ra,4(sp)
811408b4:	df000017 	ldw	fp,0(sp)
811408b8:	dec00204 	addi	sp,sp,8
811408bc:	f800283a 	ret

811408c0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
811408c0:	defff904 	addi	sp,sp,-28
811408c4:	de00012e 	bgeu	sp,et,811408cc <altera_avalon_jtag_uart_timeout+0xc>
811408c8:	003b68fa 	trap	3
811408cc:	dfc00615 	stw	ra,24(sp)
811408d0:	df000515 	stw	fp,20(sp)
811408d4:	df000504 	addi	fp,sp,20
811408d8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
811408dc:	e0bfff17 	ldw	r2,-4(fp)
811408e0:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
811408e4:	e0bffb17 	ldw	r2,-20(fp)
811408e8:	10800017 	ldw	r2,0(r2)
811408ec:	10800104 	addi	r2,r2,4
811408f0:	10800037 	ldwio	r2,0(r2)
811408f4:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
811408f8:	e0bffc17 	ldw	r2,-16(fp)
811408fc:	1081000c 	andi	r2,r2,1024
81140900:	10000b26 	beq	r2,zero,81140930 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81140904:	e0bffb17 	ldw	r2,-20(fp)
81140908:	10800017 	ldw	r2,0(r2)
8114090c:	10800104 	addi	r2,r2,4
81140910:	1007883a 	mov	r3,r2
81140914:	e0bffb17 	ldw	r2,-20(fp)
81140918:	10800817 	ldw	r2,32(r2)
8114091c:	10810014 	ori	r2,r2,1024
81140920:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81140924:	e0bffb17 	ldw	r2,-20(fp)
81140928:	10000915 	stw	zero,36(r2)
8114092c:	00002106 	br	811409b4 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81140930:	e0bffb17 	ldw	r2,-20(fp)
81140934:	10c00917 	ldw	r3,36(r2)
81140938:	00a00034 	movhi	r2,32768
8114093c:	10bfff04 	addi	r2,r2,-4
81140940:	10c01c36 	bltu	r2,r3,811409b4 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81140944:	e0bffb17 	ldw	r2,-20(fp)
81140948:	10800917 	ldw	r2,36(r2)
8114094c:	10c00044 	addi	r3,r2,1
81140950:	e0bffb17 	ldw	r2,-20(fp)
81140954:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81140958:	e0bffb17 	ldw	r2,-20(fp)
8114095c:	10c00917 	ldw	r3,36(r2)
81140960:	e0bffb17 	ldw	r2,-20(fp)
81140964:	10800117 	ldw	r2,4(r2)
81140968:	18801236 	bltu	r3,r2,811409b4 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
8114096c:	e0bffb17 	ldw	r2,-20(fp)
81140970:	10800c17 	ldw	r2,48(r2)
81140974:	e0bffd15 	stw	r2,-12(fp)
81140978:	00800104 	movi	r2,4
8114097c:	e0bffe0d 	sth	r2,-8(fp)
81140980:	00800044 	movi	r2,1
81140984:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81140988:	d0a09603 	ldbu	r2,-32168(gp)
8114098c:	10803fcc 	andi	r2,r2,255
81140990:	10000826 	beq	r2,zero,811409b4 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81140994:	e0bffe0b 	ldhu	r2,-8(fp)
81140998:	e0fffe83 	ldbu	r3,-6(fp)
8114099c:	e13ffec4 	addi	r4,fp,-5
811409a0:	200f883a 	mov	r7,r4
811409a4:	180d883a 	mov	r6,r3
811409a8:	100b883a 	mov	r5,r2
811409ac:	e13ffd17 	ldw	r4,-12(fp)
811409b0:	11353c40 	call	811353c4 <OSFlagPost>
811409b4:	d0a08d17 	ldw	r2,-32204(gp)
    }
  }

  return alt_ticks_per_second();
}
811409b8:	e037883a 	mov	sp,fp
811409bc:	dfc00117 	ldw	ra,4(sp)
811409c0:	df000017 	ldw	fp,0(sp)
811409c4:	dec00204 	addi	sp,sp,8
811409c8:	f800283a 	ret

811409cc <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
811409cc:	defffd04 	addi	sp,sp,-12
811409d0:	de00012e 	bgeu	sp,et,811409d8 <altera_avalon_jtag_uart_close+0xc>
811409d4:	003b68fa 	trap	3
811409d8:	df000215 	stw	fp,8(sp)
811409dc:	df000204 	addi	fp,sp,8
811409e0:	e13ffe15 	stw	r4,-8(fp)
811409e4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
811409e8:	00000506 	br	81140a00 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
811409ec:	e0bfff17 	ldw	r2,-4(fp)
811409f0:	1090000c 	andi	r2,r2,16384
811409f4:	10000226 	beq	r2,zero,81140a00 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
811409f8:	00bffd44 	movi	r2,-11
811409fc:	00000b06 	br	81140a2c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81140a00:	e0bffe17 	ldw	r2,-8(fp)
81140a04:	10c01017 	ldw	r3,64(r2)
81140a08:	e0bffe17 	ldw	r2,-8(fp)
81140a0c:	10800f17 	ldw	r2,60(r2)
81140a10:	18800526 	beq	r3,r2,81140a28 <altera_avalon_jtag_uart_close+0x5c>
81140a14:	e0bffe17 	ldw	r2,-8(fp)
81140a18:	10c00917 	ldw	r3,36(r2)
81140a1c:	e0bffe17 	ldw	r2,-8(fp)
81140a20:	10800117 	ldw	r2,4(r2)
81140a24:	18bff136 	bltu	r3,r2,811409ec <__reset+0xfb1209ec>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81140a28:	0005883a 	mov	r2,zero
}
81140a2c:	e037883a 	mov	sp,fp
81140a30:	df000017 	ldw	fp,0(sp)
81140a34:	dec00104 	addi	sp,sp,4
81140a38:	f800283a 	ret

81140a3c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81140a3c:	defffa04 	addi	sp,sp,-24
81140a40:	de00012e 	bgeu	sp,et,81140a48 <altera_avalon_jtag_uart_ioctl+0xc>
81140a44:	003b68fa 	trap	3
81140a48:	df000515 	stw	fp,20(sp)
81140a4c:	df000504 	addi	fp,sp,20
81140a50:	e13ffd15 	stw	r4,-12(fp)
81140a54:	e17ffe15 	stw	r5,-8(fp)
81140a58:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81140a5c:	00bff9c4 	movi	r2,-25
81140a60:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81140a64:	e0bffe17 	ldw	r2,-8(fp)
81140a68:	10da8060 	cmpeqi	r3,r2,27137
81140a6c:	1800031e 	bne	r3,zero,81140a7c <altera_avalon_jtag_uart_ioctl+0x40>
81140a70:	109a80a0 	cmpeqi	r2,r2,27138
81140a74:	1000181e 	bne	r2,zero,81140ad8 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81140a78:	00002906 	br	81140b20 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81140a7c:	e0bffd17 	ldw	r2,-12(fp)
81140a80:	10c00117 	ldw	r3,4(r2)
81140a84:	00a00034 	movhi	r2,32768
81140a88:	10bfffc4 	addi	r2,r2,-1
81140a8c:	18802126 	beq	r3,r2,81140b14 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81140a90:	e0bfff17 	ldw	r2,-4(fp)
81140a94:	10800017 	ldw	r2,0(r2)
81140a98:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81140a9c:	e0bffc17 	ldw	r2,-16(fp)
81140aa0:	10800090 	cmplti	r2,r2,2
81140aa4:	1000061e 	bne	r2,zero,81140ac0 <altera_avalon_jtag_uart_ioctl+0x84>
81140aa8:	e0fffc17 	ldw	r3,-16(fp)
81140aac:	00a00034 	movhi	r2,32768
81140ab0:	10bfffc4 	addi	r2,r2,-1
81140ab4:	18800226 	beq	r3,r2,81140ac0 <altera_avalon_jtag_uart_ioctl+0x84>
81140ab8:	e0bffc17 	ldw	r2,-16(fp)
81140abc:	00000206 	br	81140ac8 <altera_avalon_jtag_uart_ioctl+0x8c>
81140ac0:	00a00034 	movhi	r2,32768
81140ac4:	10bfff84 	addi	r2,r2,-2
81140ac8:	e0fffd17 	ldw	r3,-12(fp)
81140acc:	18800115 	stw	r2,4(r3)
      rc = 0;
81140ad0:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81140ad4:	00000f06 	br	81140b14 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81140ad8:	e0bffd17 	ldw	r2,-12(fp)
81140adc:	10c00117 	ldw	r3,4(r2)
81140ae0:	00a00034 	movhi	r2,32768
81140ae4:	10bfffc4 	addi	r2,r2,-1
81140ae8:	18800c26 	beq	r3,r2,81140b1c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81140aec:	e0bffd17 	ldw	r2,-12(fp)
81140af0:	10c00917 	ldw	r3,36(r2)
81140af4:	e0bffd17 	ldw	r2,-12(fp)
81140af8:	10800117 	ldw	r2,4(r2)
81140afc:	1885803a 	cmpltu	r2,r3,r2
81140b00:	10c03fcc 	andi	r3,r2,255
81140b04:	e0bfff17 	ldw	r2,-4(fp)
81140b08:	10c00015 	stw	r3,0(r2)
      rc = 0;
81140b0c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81140b10:	00000206 	br	81140b1c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81140b14:	0001883a 	nop
81140b18:	00000106 	br	81140b20 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81140b1c:	0001883a 	nop

  default:
    break;
  }

  return rc;
81140b20:	e0bffb17 	ldw	r2,-20(fp)
}
81140b24:	e037883a 	mov	sp,fp
81140b28:	df000017 	ldw	fp,0(sp)
81140b2c:	dec00104 	addi	sp,sp,4
81140b30:	f800283a 	ret

81140b34 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81140b34:	deffed04 	addi	sp,sp,-76
81140b38:	de00012e 	bgeu	sp,et,81140b40 <altera_avalon_jtag_uart_read+0xc>
81140b3c:	003b68fa 	trap	3
81140b40:	dfc01215 	stw	ra,72(sp)
81140b44:	df001115 	stw	fp,68(sp)
81140b48:	df001104 	addi	fp,sp,68
81140b4c:	e13ffc15 	stw	r4,-16(fp)
81140b50:	e17ffd15 	stw	r5,-12(fp)
81140b54:	e1bffe15 	stw	r6,-8(fp)
81140b58:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81140b5c:	e0bffd17 	ldw	r2,-12(fp)
81140b60:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81140b64:	e0bffc17 	ldw	r2,-16(fp)
81140b68:	10800a17 	ldw	r2,40(r2)
81140b6c:	e0bff815 	stw	r2,-32(fp)
81140b70:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81140b74:	e0bff90b 	ldhu	r2,-28(fp)
81140b78:	e0fffb04 	addi	r3,fp,-20
81140b7c:	180d883a 	mov	r6,r3
81140b80:	100b883a 	mov	r5,r2
81140b84:	e13ff817 	ldw	r4,-32(fp)
81140b88:	1138a3c0 	call	81138a3c <OSSemPend>

  while (space > 0)
81140b8c:	00006106 	br	81140d14 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81140b90:	e0bffc17 	ldw	r2,-16(fp)
81140b94:	10800d17 	ldw	r2,52(r2)
81140b98:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81140b9c:	e0bffc17 	ldw	r2,-16(fp)
81140ba0:	10800e17 	ldw	r2,56(r2)
81140ba4:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81140ba8:	e0fff317 	ldw	r3,-52(fp)
81140bac:	e0bff417 	ldw	r2,-48(fp)
81140bb0:	18800536 	bltu	r3,r2,81140bc8 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81140bb4:	e0fff317 	ldw	r3,-52(fp)
81140bb8:	e0bff417 	ldw	r2,-48(fp)
81140bbc:	1885c83a 	sub	r2,r3,r2
81140bc0:	e0bff115 	stw	r2,-60(fp)
81140bc4:	00000406 	br	81140bd8 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81140bc8:	00c20004 	movi	r3,2048
81140bcc:	e0bff417 	ldw	r2,-48(fp)
81140bd0:	1885c83a 	sub	r2,r3,r2
81140bd4:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81140bd8:	e0bff117 	ldw	r2,-60(fp)
81140bdc:	10001e26 	beq	r2,zero,81140c58 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81140be0:	e0fffe17 	ldw	r3,-8(fp)
81140be4:	e0bff117 	ldw	r2,-60(fp)
81140be8:	1880022e 	bgeu	r3,r2,81140bf4 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81140bec:	e0bffe17 	ldw	r2,-8(fp)
81140bf0:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81140bf4:	e0bffc17 	ldw	r2,-16(fp)
81140bf8:	10c01104 	addi	r3,r2,68
81140bfc:	e0bff417 	ldw	r2,-48(fp)
81140c00:	1885883a 	add	r2,r3,r2
81140c04:	e1bff117 	ldw	r6,-60(fp)
81140c08:	100b883a 	mov	r5,r2
81140c0c:	e13ff017 	ldw	r4,-64(fp)
81140c10:	111ba100 	call	8111ba10 <memcpy>
      ptr   += n;
81140c14:	e0fff017 	ldw	r3,-64(fp)
81140c18:	e0bff117 	ldw	r2,-60(fp)
81140c1c:	1885883a 	add	r2,r3,r2
81140c20:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81140c24:	e0fffe17 	ldw	r3,-8(fp)
81140c28:	e0bff117 	ldw	r2,-60(fp)
81140c2c:	1885c83a 	sub	r2,r3,r2
81140c30:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81140c34:	e0fff417 	ldw	r3,-48(fp)
81140c38:	e0bff117 	ldw	r2,-60(fp)
81140c3c:	1885883a 	add	r2,r3,r2
81140c40:	10c1ffcc 	andi	r3,r2,2047
81140c44:	e0bffc17 	ldw	r2,-16(fp)
81140c48:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81140c4c:	e0bffe17 	ldw	r2,-8(fp)
81140c50:	00bfcf16 	blt	zero,r2,81140b90 <__reset+0xfb120b90>
81140c54:	00000106 	br	81140c5c <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81140c58:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81140c5c:	e0fff017 	ldw	r3,-64(fp)
81140c60:	e0bffd17 	ldw	r2,-12(fp)
81140c64:	18802e1e 	bne	r3,r2,81140d20 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81140c68:	e0bfff17 	ldw	r2,-4(fp)
81140c6c:	1090000c 	andi	r2,r2,16384
81140c70:	10002d1e 	bne	r2,zero,81140d28 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81140c74:	d0a09603 	ldbu	r2,-32168(gp)
81140c78:	10803fcc 	andi	r2,r2,255
81140c7c:	10800058 	cmpnei	r2,r2,1
81140c80:	1000161e 	bne	r2,zero,81140cdc <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81140c84:	e0bffc17 	ldw	r2,-16(fp)
81140c88:	10800c17 	ldw	r2,48(r2)
81140c8c:	e0bff215 	stw	r2,-56(fp)
81140c90:	00800144 	movi	r2,5
81140c94:	e0bff98d 	sth	r2,-26(fp)
81140c98:	00bfe0c4 	movi	r2,-125
81140c9c:	e0bffa05 	stb	r2,-24(fp)
81140ca0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81140ca4:	d0a09603 	ldbu	r2,-32168(gp)
81140ca8:	10803fcc 	andi	r2,r2,255
81140cac:	10001526 	beq	r2,zero,81140d04 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81140cb0:	e0fff98b 	ldhu	r3,-26(fp)
81140cb4:	e13ffa03 	ldbu	r4,-24(fp)
81140cb8:	e17ffa8b 	ldhu	r5,-22(fp)
81140cbc:	e0bffb44 	addi	r2,fp,-19
81140cc0:	d8800015 	stw	r2,0(sp)
81140cc4:	280f883a 	mov	r7,r5
81140cc8:	200d883a 	mov	r6,r4
81140ccc:	180b883a 	mov	r5,r3
81140cd0:	e13ff217 	ldw	r4,-56(fp)
81140cd4:	1134d9c0 	call	81134d9c <OSFlagPend>
81140cd8:	00000a06 	br	81140d04 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81140cdc:	0001883a 	nop
81140ce0:	e0bffc17 	ldw	r2,-16(fp)
81140ce4:	10c00d17 	ldw	r3,52(r2)
81140ce8:	e0bff317 	ldw	r2,-52(fp)
81140cec:	1880051e 	bne	r3,r2,81140d04 <altera_avalon_jtag_uart_read+0x1d0>
81140cf0:	e0bffc17 	ldw	r2,-16(fp)
81140cf4:	10c00917 	ldw	r3,36(r2)
81140cf8:	e0bffc17 	ldw	r2,-16(fp)
81140cfc:	10800117 	ldw	r2,4(r2)
81140d00:	18bff736 	bltu	r3,r2,81140ce0 <__reset+0xfb120ce0>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81140d04:	e0bffc17 	ldw	r2,-16(fp)
81140d08:	10c00d17 	ldw	r3,52(r2)
81140d0c:	e0bff317 	ldw	r2,-52(fp)
81140d10:	18800726 	beq	r3,r2,81140d30 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81140d14:	e0bffe17 	ldw	r2,-8(fp)
81140d18:	00bf9d16 	blt	zero,r2,81140b90 <__reset+0xfb120b90>
81140d1c:	00000506 	br	81140d34 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81140d20:	0001883a 	nop
81140d24:	00000306 	br	81140d34 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81140d28:	0001883a 	nop
81140d2c:	00000106 	br	81140d34 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81140d30:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81140d34:	e0bffc17 	ldw	r2,-16(fp)
81140d38:	10800a17 	ldw	r2,40(r2)
81140d3c:	1009883a 	mov	r4,r2
81140d40:	1138dc40 	call	81138dc4 <OSSemPost>

  if (ptr != buffer)
81140d44:	e0fff017 	ldw	r3,-64(fp)
81140d48:	e0bffd17 	ldw	r2,-12(fp)
81140d4c:	18801826 	beq	r3,r2,81140db0 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140d50:	0005303a 	rdctl	r2,status
81140d54:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140d58:	e0fff717 	ldw	r3,-36(fp)
81140d5c:	00bfff84 	movi	r2,-2
81140d60:	1884703a 	and	r2,r3,r2
81140d64:	1001703a 	wrctl	status,r2
  
  return context;
81140d68:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81140d6c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81140d70:	e0bffc17 	ldw	r2,-16(fp)
81140d74:	10800817 	ldw	r2,32(r2)
81140d78:	10c00054 	ori	r3,r2,1
81140d7c:	e0bffc17 	ldw	r2,-16(fp)
81140d80:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81140d84:	e0bffc17 	ldw	r2,-16(fp)
81140d88:	10800017 	ldw	r2,0(r2)
81140d8c:	10800104 	addi	r2,r2,4
81140d90:	1007883a 	mov	r3,r2
81140d94:	e0bffc17 	ldw	r2,-16(fp)
81140d98:	10800817 	ldw	r2,32(r2)
81140d9c:	18800035 	stwio	r2,0(r3)
81140da0:	e0bff617 	ldw	r2,-40(fp)
81140da4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140da8:	e0bff517 	ldw	r2,-44(fp)
81140dac:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81140db0:	e0fff017 	ldw	r3,-64(fp)
81140db4:	e0bffd17 	ldw	r2,-12(fp)
81140db8:	18800426 	beq	r3,r2,81140dcc <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81140dbc:	e0fff017 	ldw	r3,-64(fp)
81140dc0:	e0bffd17 	ldw	r2,-12(fp)
81140dc4:	1885c83a 	sub	r2,r3,r2
81140dc8:	00000606 	br	81140de4 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81140dcc:	e0bfff17 	ldw	r2,-4(fp)
81140dd0:	1090000c 	andi	r2,r2,16384
81140dd4:	10000226 	beq	r2,zero,81140de0 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81140dd8:	00bffd44 	movi	r2,-11
81140ddc:	00000106 	br	81140de4 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81140de0:	00bffec4 	movi	r2,-5
}
81140de4:	e037883a 	mov	sp,fp
81140de8:	dfc00117 	ldw	ra,4(sp)
81140dec:	df000017 	ldw	fp,0(sp)
81140df0:	dec00204 	addi	sp,sp,8
81140df4:	f800283a 	ret

81140df8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81140df8:	deffed04 	addi	sp,sp,-76
81140dfc:	de00012e 	bgeu	sp,et,81140e04 <altera_avalon_jtag_uart_write+0xc>
81140e00:	003b68fa 	trap	3
81140e04:	dfc01215 	stw	ra,72(sp)
81140e08:	df001115 	stw	fp,68(sp)
81140e0c:	df001104 	addi	fp,sp,68
81140e10:	e13ffc15 	stw	r4,-16(fp)
81140e14:	e17ffd15 	stw	r5,-12(fp)
81140e18:	e1bffe15 	stw	r6,-8(fp)
81140e1c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
81140e20:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81140e24:	e0bffd17 	ldw	r2,-12(fp)
81140e28:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81140e2c:	e0bffc17 	ldw	r2,-16(fp)
81140e30:	10800b17 	ldw	r2,44(r2)
81140e34:	e0bff815 	stw	r2,-32(fp)
81140e38:	e03ff90d 	sth	zero,-28(fp)
81140e3c:	e0bff90b 	ldhu	r2,-28(fp)
81140e40:	e0fffb44 	addi	r3,fp,-19
81140e44:	180d883a 	mov	r6,r3
81140e48:	100b883a 	mov	r5,r2
81140e4c:	e13ff817 	ldw	r4,-32(fp)
81140e50:	1138a3c0 	call	81138a3c <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81140e54:	00003706 	br	81140f34 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
81140e58:	e0bffc17 	ldw	r2,-16(fp)
81140e5c:	10800f17 	ldw	r2,60(r2)
81140e60:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
81140e64:	e0bffc17 	ldw	r2,-16(fp)
81140e68:	10801017 	ldw	r2,64(r2)
81140e6c:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81140e70:	e0fff417 	ldw	r3,-48(fp)
81140e74:	e0bff017 	ldw	r2,-64(fp)
81140e78:	1880062e 	bgeu	r3,r2,81140e94 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
81140e7c:	e0fff017 	ldw	r3,-64(fp)
81140e80:	e0bff417 	ldw	r2,-48(fp)
81140e84:	1885c83a 	sub	r2,r3,r2
81140e88:	10bfffc4 	addi	r2,r2,-1
81140e8c:	e0bff115 	stw	r2,-60(fp)
81140e90:	00000b06 	br	81140ec0 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81140e94:	e0bff017 	ldw	r2,-64(fp)
81140e98:	10000526 	beq	r2,zero,81140eb0 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81140e9c:	00c20004 	movi	r3,2048
81140ea0:	e0bff417 	ldw	r2,-48(fp)
81140ea4:	1885c83a 	sub	r2,r3,r2
81140ea8:	e0bff115 	stw	r2,-60(fp)
81140eac:	00000406 	br	81140ec0 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81140eb0:	00c1ffc4 	movi	r3,2047
81140eb4:	e0bff417 	ldw	r2,-48(fp)
81140eb8:	1885c83a 	sub	r2,r3,r2
81140ebc:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81140ec0:	e0bff117 	ldw	r2,-60(fp)
81140ec4:	10001e26 	beq	r2,zero,81140f40 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81140ec8:	e0fffe17 	ldw	r3,-8(fp)
81140ecc:	e0bff117 	ldw	r2,-60(fp)
81140ed0:	1880022e 	bgeu	r3,r2,81140edc <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81140ed4:	e0bffe17 	ldw	r2,-8(fp)
81140ed8:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81140edc:	e0bffc17 	ldw	r2,-16(fp)
81140ee0:	10c21104 	addi	r3,r2,2116
81140ee4:	e0bff417 	ldw	r2,-48(fp)
81140ee8:	1885883a 	add	r2,r3,r2
81140eec:	e1bff117 	ldw	r6,-60(fp)
81140ef0:	e17ffd17 	ldw	r5,-12(fp)
81140ef4:	1009883a 	mov	r4,r2
81140ef8:	111ba100 	call	8111ba10 <memcpy>
      ptr   += n;
81140efc:	e0fffd17 	ldw	r3,-12(fp)
81140f00:	e0bff117 	ldw	r2,-60(fp)
81140f04:	1885883a 	add	r2,r3,r2
81140f08:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81140f0c:	e0fffe17 	ldw	r3,-8(fp)
81140f10:	e0bff117 	ldw	r2,-60(fp)
81140f14:	1885c83a 	sub	r2,r3,r2
81140f18:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81140f1c:	e0fff417 	ldw	r3,-48(fp)
81140f20:	e0bff117 	ldw	r2,-60(fp)
81140f24:	1885883a 	add	r2,r3,r2
81140f28:	10c1ffcc 	andi	r3,r2,2047
81140f2c:	e0bffc17 	ldw	r2,-16(fp)
81140f30:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81140f34:	e0bffe17 	ldw	r2,-8(fp)
81140f38:	00bfc716 	blt	zero,r2,81140e58 <__reset+0xfb120e58>
81140f3c:	00000106 	br	81140f44 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
81140f40:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140f44:	0005303a 	rdctl	r2,status
81140f48:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140f4c:	e0fff717 	ldw	r3,-36(fp)
81140f50:	00bfff84 	movi	r2,-2
81140f54:	1884703a 	and	r2,r3,r2
81140f58:	1001703a 	wrctl	status,r2
  
  return context;
81140f5c:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
81140f60:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81140f64:	e0bffc17 	ldw	r2,-16(fp)
81140f68:	10800817 	ldw	r2,32(r2)
81140f6c:	10c00094 	ori	r3,r2,2
81140f70:	e0bffc17 	ldw	r2,-16(fp)
81140f74:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81140f78:	e0bffc17 	ldw	r2,-16(fp)
81140f7c:	10800017 	ldw	r2,0(r2)
81140f80:	10800104 	addi	r2,r2,4
81140f84:	1007883a 	mov	r3,r2
81140f88:	e0bffc17 	ldw	r2,-16(fp)
81140f8c:	10800817 	ldw	r2,32(r2)
81140f90:	18800035 	stwio	r2,0(r3)
81140f94:	e0bff617 	ldw	r2,-40(fp)
81140f98:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140f9c:	e0bff317 	ldw	r2,-52(fp)
81140fa0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81140fa4:	e0bffe17 	ldw	r2,-8(fp)
81140fa8:	00802a0e 	bge	zero,r2,81141054 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81140fac:	e0bfff17 	ldw	r2,-4(fp)
81140fb0:	1090000c 	andi	r2,r2,16384
81140fb4:	10002a1e 	bne	r2,zero,81141060 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81140fb8:	d0a09603 	ldbu	r2,-32168(gp)
81140fbc:	10803fcc 	andi	r2,r2,255
81140fc0:	10800058 	cmpnei	r2,r2,1
81140fc4:	1000161e 	bne	r2,zero,81141020 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81140fc8:	e0bffc17 	ldw	r2,-16(fp)
81140fcc:	10800c17 	ldw	r2,48(r2)
81140fd0:	e0bff515 	stw	r2,-44(fp)
81140fd4:	00800184 	movi	r2,6
81140fd8:	e0bff98d 	sth	r2,-26(fp)
81140fdc:	00bfe0c4 	movi	r2,-125
81140fe0:	e0bffa05 	stb	r2,-24(fp)
81140fe4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81140fe8:	d0a09603 	ldbu	r2,-32168(gp)
81140fec:	10803fcc 	andi	r2,r2,255
81140ff0:	10001526 	beq	r2,zero,81141048 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81140ff4:	e0fff98b 	ldhu	r3,-26(fp)
81140ff8:	e13ffa03 	ldbu	r4,-24(fp)
81140ffc:	e17ffa8b 	ldhu	r5,-22(fp)
81141000:	e0bffb04 	addi	r2,fp,-20
81141004:	d8800015 	stw	r2,0(sp)
81141008:	280f883a 	mov	r7,r5
8114100c:	200d883a 	mov	r6,r4
81141010:	180b883a 	mov	r5,r3
81141014:	e13ff517 	ldw	r4,-44(fp)
81141018:	1134d9c0 	call	81134d9c <OSFlagPend>
8114101c:	00000a06 	br	81141048 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
81141020:	0001883a 	nop
81141024:	e0bffc17 	ldw	r2,-16(fp)
81141028:	10c01017 	ldw	r3,64(r2)
8114102c:	e0bff017 	ldw	r2,-64(fp)
81141030:	1880051e 	bne	r3,r2,81141048 <altera_avalon_jtag_uart_write+0x250>
81141034:	e0bffc17 	ldw	r2,-16(fp)
81141038:	10c00917 	ldw	r3,36(r2)
8114103c:	e0bffc17 	ldw	r2,-16(fp)
81141040:	10800117 	ldw	r2,4(r2)
81141044:	18bff736 	bltu	r3,r2,81141024 <__reset+0xfb121024>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81141048:	e0bffc17 	ldw	r2,-16(fp)
8114104c:	10800917 	ldw	r2,36(r2)
81141050:	1000051e 	bne	r2,zero,81141068 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
81141054:	e0bffe17 	ldw	r2,-8(fp)
81141058:	00bfb616 	blt	zero,r2,81140f34 <__reset+0xfb120f34>
8114105c:	00000306 	br	8114106c <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
81141060:	0001883a 	nop
81141064:	00000106 	br	8114106c <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
81141068:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
8114106c:	e0bffc17 	ldw	r2,-16(fp)
81141070:	10800b17 	ldw	r2,44(r2)
81141074:	1009883a 	mov	r4,r2
81141078:	1138dc40 	call	81138dc4 <OSSemPost>

  if (ptr != start)
8114107c:	e0fffd17 	ldw	r3,-12(fp)
81141080:	e0bff217 	ldw	r2,-56(fp)
81141084:	18800426 	beq	r3,r2,81141098 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81141088:	e0fffd17 	ldw	r3,-12(fp)
8114108c:	e0bff217 	ldw	r2,-56(fp)
81141090:	1885c83a 	sub	r2,r3,r2
81141094:	00000606 	br	811410b0 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81141098:	e0bfff17 	ldw	r2,-4(fp)
8114109c:	1090000c 	andi	r2,r2,16384
811410a0:	10000226 	beq	r2,zero,811410ac <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
811410a4:	00bffd44 	movi	r2,-11
811410a8:	00000106 	br	811410b0 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
811410ac:	00bffec4 	movi	r2,-5
}
811410b0:	e037883a 	mov	sp,fp
811410b4:	dfc00117 	ldw	ra,4(sp)
811410b8:	df000017 	ldw	fp,0(sp)
811410bc:	dec00204 	addi	sp,sp,8
811410c0:	f800283a 	ret

811410c4 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
811410c4:	defffa04 	addi	sp,sp,-24
811410c8:	de00012e 	bgeu	sp,et,811410d0 <alt_avalon_timer_sc_irq+0xc>
811410cc:	003b68fa 	trap	3
811410d0:	dfc00515 	stw	ra,20(sp)
811410d4:	df000415 	stw	fp,16(sp)
811410d8:	df000404 	addi	fp,sp,16
811410dc:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
811410e0:	0007883a 	mov	r3,zero
811410e4:	e0bfff17 	ldw	r2,-4(fp)
811410e8:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
811410ec:	e0bfff17 	ldw	r2,-4(fp)
811410f0:	10800104 	addi	r2,r2,4
811410f4:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
811410f8:	11312780 	call	81131278 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811410fc:	0005303a 	rdctl	r2,status
81141100:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141104:	e0fffd17 	ldw	r3,-12(fp)
81141108:	00bfff84 	movi	r2,-2
8114110c:	1884703a 	and	r2,r3,r2
81141110:	1001703a 	wrctl	status,r2
  
  return context;
81141114:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81141118:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
8114111c:	1131b280 	call	81131b28 <alt_tick>
81141120:	e0bffc17 	ldw	r2,-16(fp)
81141124:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141128:	e0bffe17 	ldw	r2,-8(fp)
8114112c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
81141130:	0001883a 	nop
81141134:	e037883a 	mov	sp,fp
81141138:	dfc00117 	ldw	ra,4(sp)
8114113c:	df000017 	ldw	fp,0(sp)
81141140:	dec00204 	addi	sp,sp,8
81141144:	f800283a 	ret

81141148 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81141148:	defff804 	addi	sp,sp,-32
8114114c:	de00012e 	bgeu	sp,et,81141154 <alt_avalon_timer_sc_init+0xc>
81141150:	003b68fa 	trap	3
81141154:	dfc00715 	stw	ra,28(sp)
81141158:	df000615 	stw	fp,24(sp)
8114115c:	df000604 	addi	fp,sp,24
81141160:	e13ffc15 	stw	r4,-16(fp)
81141164:	e17ffd15 	stw	r5,-12(fp)
81141168:	e1bffe15 	stw	r6,-8(fp)
8114116c:	e1ffff15 	stw	r7,-4(fp)
81141170:	e0bfff17 	ldw	r2,-4(fp)
81141174:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81141178:	d0a08d17 	ldw	r2,-32204(gp)
8114117c:	1000021e 	bne	r2,zero,81141188 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81141180:	e0bffb17 	ldw	r2,-20(fp)
81141184:	d0a08d15 	stw	r2,-32204(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81141188:	e0bffc17 	ldw	r2,-16(fp)
8114118c:	10800104 	addi	r2,r2,4
81141190:	00c001c4 	movi	r3,7
81141194:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81141198:	d8000015 	stw	zero,0(sp)
8114119c:	e1fffc17 	ldw	r7,-16(fp)
811411a0:	01a04534 	movhi	r6,33044
811411a4:	31843104 	addi	r6,r6,4292
811411a8:	e17ffe17 	ldw	r5,-8(fp)
811411ac:	e13ffd17 	ldw	r4,-12(fp)
811411b0:	114434c0 	call	8114434c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
811411b4:	0001883a 	nop
811411b8:	e037883a 	mov	sp,fp
811411bc:	dfc00117 	ldw	ra,4(sp)
811411c0:	df000017 	ldw	fp,0(sp)
811411c4:	dec00204 	addi	sp,sp,8
811411c8:	f800283a 	ret

811411cc <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811411cc:	defffa04 	addi	sp,sp,-24
811411d0:	de00012e 	bgeu	sp,et,811411d8 <altera_avalon_uart_read_fd+0xc>
811411d4:	003b68fa 	trap	3
811411d8:	dfc00515 	stw	ra,20(sp)
811411dc:	df000415 	stw	fp,16(sp)
811411e0:	df000404 	addi	fp,sp,16
811411e4:	e13ffd15 	stw	r4,-12(fp)
811411e8:	e17ffe15 	stw	r5,-8(fp)
811411ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811411f0:	e0bffd17 	ldw	r2,-12(fp)
811411f4:	10800017 	ldw	r2,0(r2)
811411f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
811411fc:	e0bffc17 	ldw	r2,-16(fp)
81141200:	10c00a04 	addi	r3,r2,40
81141204:	e0bffd17 	ldw	r2,-12(fp)
81141208:	10800217 	ldw	r2,8(r2)
8114120c:	100f883a 	mov	r7,r2
81141210:	e1bfff17 	ldw	r6,-4(fp)
81141214:	e17ffe17 	ldw	r5,-8(fp)
81141218:	1809883a 	mov	r4,r3
8114121c:	114188c0 	call	8114188c <altera_avalon_uart_read>
      fd->fd_flags);
}
81141220:	e037883a 	mov	sp,fp
81141224:	dfc00117 	ldw	ra,4(sp)
81141228:	df000017 	ldw	fp,0(sp)
8114122c:	dec00204 	addi	sp,sp,8
81141230:	f800283a 	ret

81141234 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81141234:	defffa04 	addi	sp,sp,-24
81141238:	de00012e 	bgeu	sp,et,81141240 <altera_avalon_uart_write_fd+0xc>
8114123c:	003b68fa 	trap	3
81141240:	dfc00515 	stw	ra,20(sp)
81141244:	df000415 	stw	fp,16(sp)
81141248:	df000404 	addi	fp,sp,16
8114124c:	e13ffd15 	stw	r4,-12(fp)
81141250:	e17ffe15 	stw	r5,-8(fp)
81141254:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81141258:	e0bffd17 	ldw	r2,-12(fp)
8114125c:	10800017 	ldw	r2,0(r2)
81141260:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
81141264:	e0bffc17 	ldw	r2,-16(fp)
81141268:	10c00a04 	addi	r3,r2,40
8114126c:	e0bffd17 	ldw	r2,-12(fp)
81141270:	10800217 	ldw	r2,8(r2)
81141274:	100f883a 	mov	r7,r2
81141278:	e1bfff17 	ldw	r6,-4(fp)
8114127c:	e17ffe17 	ldw	r5,-8(fp)
81141280:	1809883a 	mov	r4,r3
81141284:	1141b400 	call	81141b40 <altera_avalon_uart_write>
      fd->fd_flags);
}
81141288:	e037883a 	mov	sp,fp
8114128c:	dfc00117 	ldw	ra,4(sp)
81141290:	df000017 	ldw	fp,0(sp)
81141294:	dec00204 	addi	sp,sp,8
81141298:	f800283a 	ret

8114129c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
8114129c:	defffc04 	addi	sp,sp,-16
811412a0:	de00012e 	bgeu	sp,et,811412a8 <altera_avalon_uart_close_fd+0xc>
811412a4:	003b68fa 	trap	3
811412a8:	dfc00315 	stw	ra,12(sp)
811412ac:	df000215 	stw	fp,8(sp)
811412b0:	df000204 	addi	fp,sp,8
811412b4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811412b8:	e0bfff17 	ldw	r2,-4(fp)
811412bc:	10800017 	ldw	r2,0(r2)
811412c0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
811412c4:	e0bffe17 	ldw	r2,-8(fp)
811412c8:	10c00a04 	addi	r3,r2,40
811412cc:	e0bfff17 	ldw	r2,-4(fp)
811412d0:	10800217 	ldw	r2,8(r2)
811412d4:	100b883a 	mov	r5,r2
811412d8:	1809883a 	mov	r4,r3
811412dc:	11417ec0 	call	811417ec <altera_avalon_uart_close>
}
811412e0:	e037883a 	mov	sp,fp
811412e4:	dfc00117 	ldw	ra,4(sp)
811412e8:	df000017 	ldw	fp,0(sp)
811412ec:	dec00204 	addi	sp,sp,8
811412f0:	f800283a 	ret

811412f4 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
811412f4:	defff304 	addi	sp,sp,-52
811412f8:	de00012e 	bgeu	sp,et,81141300 <altera_avalon_uart_init+0xc>
811412fc:	003b68fa 	trap	3
81141300:	dfc00c15 	stw	ra,48(sp)
81141304:	df000b15 	stw	fp,44(sp)
81141308:	df000b04 	addi	fp,sp,44
8114130c:	e13ffd15 	stw	r4,-12(fp)
81141310:	e17ffe15 	stw	r5,-8(fp)
81141314:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81141318:	e0bffd17 	ldw	r2,-12(fp)
8114131c:	10800017 	ldw	r2,0(r2)
81141320:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81141324:	e0bffd17 	ldw	r2,-12(fp)
81141328:	10800704 	addi	r2,r2,28
8114132c:	e0bffa15 	stw	r2,-24(fp)
81141330:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81141334:	e0bffb0b 	ldhu	r2,-20(fp)
81141338:	e0fffc84 	addi	r3,fp,-14
8114133c:	180b883a 	mov	r5,r3
81141340:	1009883a 	mov	r4,r2
81141344:	11347b80 	call	811347b8 <OSFlagCreate>
81141348:	1007883a 	mov	r3,r2
8114134c:	e0bffa17 	ldw	r2,-24(fp)
81141350:	10c00015 	stw	r3,0(r2)
  return err;
81141354:	e0bffc83 	ldbu	r2,-14(fp)
81141358:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8114135c:	1000241e 	bne	r2,zero,811413f0 <altera_avalon_uart_init+0xfc>
81141360:	e0bffd17 	ldw	r2,-12(fp)
81141364:	10800804 	addi	r2,r2,32
81141368:	e0bff715 	stw	r2,-36(fp)
8114136c:	00800044 	movi	r2,1
81141370:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81141374:	e0bffb8b 	ldhu	r2,-18(fp)
81141378:	1009883a 	mov	r4,r2
8114137c:	11387140 	call	81138714 <OSSemCreate>
81141380:	1007883a 	mov	r3,r2
81141384:	e0bff717 	ldw	r2,-36(fp)
81141388:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114138c:	e0bff717 	ldw	r2,-36(fp)
81141390:	10800017 	ldw	r2,0(r2)
81141394:	10000226 	beq	r2,zero,811413a0 <altera_avalon_uart_init+0xac>
81141398:	0005883a 	mov	r2,zero
8114139c:	00000106 	br	811413a4 <altera_avalon_uart_init+0xb0>
811413a0:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811413a4:	1000121e 	bne	r2,zero,811413f0 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
811413a8:	e0bffd17 	ldw	r2,-12(fp)
811413ac:	10800904 	addi	r2,r2,36
811413b0:	e0bff815 	stw	r2,-32(fp)
811413b4:	00800044 	movi	r2,1
811413b8:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811413bc:	e0bffc0b 	ldhu	r2,-16(fp)
811413c0:	1009883a 	mov	r4,r2
811413c4:	11387140 	call	81138714 <OSSemCreate>
811413c8:	1007883a 	mov	r3,r2
811413cc:	e0bff817 	ldw	r2,-32(fp)
811413d0:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811413d4:	e0bff817 	ldw	r2,-32(fp)
811413d8:	10800017 	ldw	r2,0(r2)
811413dc:	10000226 	beq	r2,zero,811413e8 <altera_avalon_uart_init+0xf4>
811413e0:	0005883a 	mov	r2,zero
811413e4:	00000106 	br	811413ec <altera_avalon_uart_init+0xf8>
811413e8:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811413ec:	10000226 	beq	r2,zero,811413f8 <altera_avalon_uart_init+0x104>
811413f0:	00800044 	movi	r2,1
811413f4:	00000106 	br	811413fc <altera_avalon_uart_init+0x108>
811413f8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811413fc:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81141400:	e0bff917 	ldw	r2,-28(fp)
81141404:	10000f1e 	bne	r2,zero,81141444 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81141408:	e0bffd17 	ldw	r2,-12(fp)
8114140c:	00c32004 	movi	r3,3200
81141410:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81141414:	e0bff617 	ldw	r2,-40(fp)
81141418:	10800304 	addi	r2,r2,12
8114141c:	e0fffd17 	ldw	r3,-12(fp)
81141420:	18c00117 	ldw	r3,4(r3)
81141424:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81141428:	d8000015 	stw	zero,0(sp)
8114142c:	e1fffd17 	ldw	r7,-12(fp)
81141430:	01a04534 	movhi	r6,33044
81141434:	31851704 	addi	r6,r6,5212
81141438:	e17fff17 	ldw	r5,-4(fp)
8114143c:	e13ffe17 	ldw	r4,-8(fp)
81141440:	114434c0 	call	8114434c <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81141444:	0001883a 	nop
81141448:	e037883a 	mov	sp,fp
8114144c:	dfc00117 	ldw	ra,4(sp)
81141450:	df000017 	ldw	fp,0(sp)
81141454:	dec00204 	addi	sp,sp,8
81141458:	f800283a 	ret

8114145c <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
8114145c:	defffa04 	addi	sp,sp,-24
81141460:	de00012e 	bgeu	sp,et,81141468 <altera_avalon_uart_irq+0xc>
81141464:	003b68fa 	trap	3
81141468:	dfc00515 	stw	ra,20(sp)
8114146c:	df000415 	stw	fp,16(sp)
81141470:	df000404 	addi	fp,sp,16
81141474:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81141478:	e0bfff17 	ldw	r2,-4(fp)
8114147c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81141480:	e0bffc17 	ldw	r2,-16(fp)
81141484:	10800017 	ldw	r2,0(r2)
81141488:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
8114148c:	e0bffd17 	ldw	r2,-12(fp)
81141490:	10800204 	addi	r2,r2,8
81141494:	10800037 	ldwio	r2,0(r2)
81141498:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
8114149c:	e0bffd17 	ldw	r2,-12(fp)
811414a0:	10800204 	addi	r2,r2,8
811414a4:	0007883a 	mov	r3,zero
811414a8:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811414ac:	e0bffd17 	ldw	r2,-12(fp)
811414b0:	10800204 	addi	r2,r2,8
811414b4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
811414b8:	e0bffe17 	ldw	r2,-8(fp)
811414bc:	1080200c 	andi	r2,r2,128
811414c0:	10000326 	beq	r2,zero,811414d0 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
811414c4:	e17ffe17 	ldw	r5,-8(fp)
811414c8:	e13ffc17 	ldw	r4,-16(fp)
811414cc:	11415000 	call	81141500 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
811414d0:	e0bffe17 	ldw	r2,-8(fp)
811414d4:	1081100c 	andi	r2,r2,1088
811414d8:	10000326 	beq	r2,zero,811414e8 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
811414dc:	e17ffe17 	ldw	r5,-8(fp)
811414e0:	e13ffc17 	ldw	r4,-16(fp)
811414e4:	11416400 	call	81141640 <altera_avalon_uart_txirq>
  }
  

}
811414e8:	0001883a 	nop
811414ec:	e037883a 	mov	sp,fp
811414f0:	dfc00117 	ldw	ra,4(sp)
811414f4:	df000017 	ldw	fp,0(sp)
811414f8:	dec00204 	addi	sp,sp,8
811414fc:	f800283a 	ret

81141500 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81141500:	defff904 	addi	sp,sp,-28
81141504:	de00012e 	bgeu	sp,et,8114150c <altera_avalon_uart_rxirq+0xc>
81141508:	003b68fa 	trap	3
8114150c:	dfc00615 	stw	ra,24(sp)
81141510:	df000515 	stw	fp,20(sp)
81141514:	df000504 	addi	fp,sp,20
81141518:	e13ffe15 	stw	r4,-8(fp)
8114151c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81141520:	e0bfff17 	ldw	r2,-4(fp)
81141524:	108000cc 	andi	r2,r2,3
81141528:	10003f1e 	bne	r2,zero,81141628 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
8114152c:	e0bffe17 	ldw	r2,-8(fp)
81141530:	10c00317 	ldw	r3,12(r2)
81141534:	e0bffe17 	ldw	r2,-8(fp)
81141538:	10800217 	ldw	r2,8(r2)
8114153c:	1880121e 	bne	r3,r2,81141588 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81141540:	e0bffe17 	ldw	r2,-8(fp)
81141544:	10800717 	ldw	r2,28(r2)
81141548:	e0bffc15 	stw	r2,-16(fp)
8114154c:	00800044 	movi	r2,1
81141550:	e0bffd0d 	sth	r2,-12(fp)
81141554:	00800044 	movi	r2,1
81141558:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114155c:	d0a09603 	ldbu	r2,-32168(gp)
81141560:	10803fcc 	andi	r2,r2,255
81141564:	10000826 	beq	r2,zero,81141588 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
81141568:	e0bffd0b 	ldhu	r2,-12(fp)
8114156c:	e0fffd83 	ldbu	r3,-10(fp)
81141570:	e13ffdc4 	addi	r4,fp,-9
81141574:	200f883a 	mov	r7,r4
81141578:	180d883a 	mov	r6,r3
8114157c:	100b883a 	mov	r5,r2
81141580:	e13ffc17 	ldw	r4,-16(fp)
81141584:	11353c40 	call	811353c4 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81141588:	e0bffe17 	ldw	r2,-8(fp)
8114158c:	10800317 	ldw	r2,12(r2)
81141590:	10800044 	addi	r2,r2,1
81141594:	10800fcc 	andi	r2,r2,63
81141598:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
8114159c:	e0bffe17 	ldw	r2,-8(fp)
811415a0:	10800317 	ldw	r2,12(r2)
811415a4:	e0fffe17 	ldw	r3,-8(fp)
811415a8:	18c00017 	ldw	r3,0(r3)
811415ac:	18c00037 	ldwio	r3,0(r3)
811415b0:	1809883a 	mov	r4,r3
811415b4:	e0fffe17 	ldw	r3,-8(fp)
811415b8:	1885883a 	add	r2,r3,r2
811415bc:	10800a04 	addi	r2,r2,40
811415c0:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
811415c4:	e0bffe17 	ldw	r2,-8(fp)
811415c8:	e0fffb17 	ldw	r3,-20(fp)
811415cc:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811415d0:	e0bffe17 	ldw	r2,-8(fp)
811415d4:	10800317 	ldw	r2,12(r2)
811415d8:	10800044 	addi	r2,r2,1
811415dc:	10800fcc 	andi	r2,r2,63
811415e0:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
811415e4:	e0bffe17 	ldw	r2,-8(fp)
811415e8:	10c00217 	ldw	r3,8(r2)
811415ec:	e0bffb17 	ldw	r2,-20(fp)
811415f0:	18800e1e 	bne	r3,r2,8114162c <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811415f4:	e0bffe17 	ldw	r2,-8(fp)
811415f8:	10c00117 	ldw	r3,4(r2)
811415fc:	00bfdfc4 	movi	r2,-129
81141600:	1886703a 	and	r3,r3,r2
81141604:	e0bffe17 	ldw	r2,-8(fp)
81141608:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
8114160c:	e0bffe17 	ldw	r2,-8(fp)
81141610:	10800017 	ldw	r2,0(r2)
81141614:	10800304 	addi	r2,r2,12
81141618:	e0fffe17 	ldw	r3,-8(fp)
8114161c:	18c00117 	ldw	r3,4(r3)
81141620:	10c00035 	stwio	r3,0(r2)
81141624:	00000106 	br	8114162c <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81141628:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
8114162c:	e037883a 	mov	sp,fp
81141630:	dfc00117 	ldw	ra,4(sp)
81141634:	df000017 	ldw	fp,0(sp)
81141638:	dec00204 	addi	sp,sp,8
8114163c:	f800283a 	ret

81141640 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81141640:	defffa04 	addi	sp,sp,-24
81141644:	de00012e 	bgeu	sp,et,8114164c <altera_avalon_uart_txirq+0xc>
81141648:	003b68fa 	trap	3
8114164c:	dfc00515 	stw	ra,20(sp)
81141650:	df000415 	stw	fp,16(sp)
81141654:	df000404 	addi	fp,sp,16
81141658:	e13ffe15 	stw	r4,-8(fp)
8114165c:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81141660:	e0bffe17 	ldw	r2,-8(fp)
81141664:	10c00417 	ldw	r3,16(r2)
81141668:	e0bffe17 	ldw	r2,-8(fp)
8114166c:	10800517 	ldw	r2,20(r2)
81141670:	18804726 	beq	r3,r2,81141790 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81141674:	e0bffe17 	ldw	r2,-8(fp)
81141678:	10800617 	ldw	r2,24(r2)
8114167c:	1080008c 	andi	r2,r2,2
81141680:	10000326 	beq	r2,zero,81141690 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81141684:	e0bfff17 	ldw	r2,-4(fp)
81141688:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8114168c:	10003226 	beq	r2,zero,81141758 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81141690:	e0bffe17 	ldw	r2,-8(fp)
81141694:	10c00417 	ldw	r3,16(r2)
81141698:	e0bffe17 	ldw	r2,-8(fp)
8114169c:	10800517 	ldw	r2,20(r2)
811416a0:	10800044 	addi	r2,r2,1
811416a4:	10800fcc 	andi	r2,r2,63
811416a8:	1880121e 	bne	r3,r2,811416f4 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
811416ac:	e0bffe17 	ldw	r2,-8(fp)
811416b0:	10800717 	ldw	r2,28(r2)
811416b4:	e0bffc15 	stw	r2,-16(fp)
811416b8:	00800084 	movi	r2,2
811416bc:	e0bffd0d 	sth	r2,-12(fp)
811416c0:	00800044 	movi	r2,1
811416c4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811416c8:	d0a09603 	ldbu	r2,-32168(gp)
811416cc:	10803fcc 	andi	r2,r2,255
811416d0:	10000826 	beq	r2,zero,811416f4 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
811416d4:	e0bffd0b 	ldhu	r2,-12(fp)
811416d8:	e0fffd83 	ldbu	r3,-10(fp)
811416dc:	e13ffdc4 	addi	r4,fp,-9
811416e0:	200f883a 	mov	r7,r4
811416e4:	180d883a 	mov	r6,r3
811416e8:	100b883a 	mov	r5,r2
811416ec:	e13ffc17 	ldw	r4,-16(fp)
811416f0:	11353c40 	call	811353c4 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
811416f4:	e0bffe17 	ldw	r2,-8(fp)
811416f8:	10800017 	ldw	r2,0(r2)
811416fc:	10800104 	addi	r2,r2,4
81141700:	e0fffe17 	ldw	r3,-8(fp)
81141704:	18c00417 	ldw	r3,16(r3)
81141708:	e13ffe17 	ldw	r4,-8(fp)
8114170c:	20c7883a 	add	r3,r4,r3
81141710:	18c01a04 	addi	r3,r3,104
81141714:	18c00003 	ldbu	r3,0(r3)
81141718:	18c03fcc 	andi	r3,r3,255
8114171c:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81141720:	e0bffe17 	ldw	r2,-8(fp)
81141724:	10800417 	ldw	r2,16(r2)
81141728:	10800044 	addi	r2,r2,1
8114172c:	e0fffe17 	ldw	r3,-8(fp)
81141730:	18800415 	stw	r2,16(r3)
81141734:	10c00fcc 	andi	r3,r2,63
81141738:	e0bffe17 	ldw	r2,-8(fp)
8114173c:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81141740:	e0bffe17 	ldw	r2,-8(fp)
81141744:	10800117 	ldw	r2,4(r2)
81141748:	10c01014 	ori	r3,r2,64
8114174c:	e0bffe17 	ldw	r2,-8(fp)
81141750:	10c00115 	stw	r3,4(r2)
81141754:	00000e06 	br	81141790 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81141758:	e0bffe17 	ldw	r2,-8(fp)
8114175c:	10800017 	ldw	r2,0(r2)
81141760:	10800204 	addi	r2,r2,8
81141764:	10800037 	ldwio	r2,0(r2)
81141768:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8114176c:	e0bfff17 	ldw	r2,-4(fp)
81141770:	1082000c 	andi	r2,r2,2048
81141774:	1000061e 	bne	r2,zero,81141790 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81141778:	e0bffe17 	ldw	r2,-8(fp)
8114177c:	10c00117 	ldw	r3,4(r2)
81141780:	00bfefc4 	movi	r2,-65
81141784:	1886703a 	and	r3,r3,r2
81141788:	e0bffe17 	ldw	r2,-8(fp)
8114178c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81141790:	e0bffe17 	ldw	r2,-8(fp)
81141794:	10c00417 	ldw	r3,16(r2)
81141798:	e0bffe17 	ldw	r2,-8(fp)
8114179c:	10800517 	ldw	r2,20(r2)
811417a0:	1880061e 	bne	r3,r2,811417bc <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811417a4:	e0bffe17 	ldw	r2,-8(fp)
811417a8:	10c00117 	ldw	r3,4(r2)
811417ac:	00beefc4 	movi	r2,-1089
811417b0:	1886703a 	and	r3,r3,r2
811417b4:	e0bffe17 	ldw	r2,-8(fp)
811417b8:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811417bc:	e0bffe17 	ldw	r2,-8(fp)
811417c0:	10800017 	ldw	r2,0(r2)
811417c4:	10800304 	addi	r2,r2,12
811417c8:	e0fffe17 	ldw	r3,-8(fp)
811417cc:	18c00117 	ldw	r3,4(r3)
811417d0:	10c00035 	stwio	r3,0(r2)
}
811417d4:	0001883a 	nop
811417d8:	e037883a 	mov	sp,fp
811417dc:	dfc00117 	ldw	ra,4(sp)
811417e0:	df000017 	ldw	fp,0(sp)
811417e4:	dec00204 	addi	sp,sp,8
811417e8:	f800283a 	ret

811417ec <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
811417ec:	defffd04 	addi	sp,sp,-12
811417f0:	de00012e 	bgeu	sp,et,811417f8 <altera_avalon_uart_close+0xc>
811417f4:	003b68fa 	trap	3
811417f8:	df000215 	stw	fp,8(sp)
811417fc:	df000204 	addi	fp,sp,8
81141800:	e13ffe15 	stw	r4,-8(fp)
81141804:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81141808:	00000506 	br	81141820 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8114180c:	e0bfff17 	ldw	r2,-4(fp)
81141810:	1090000c 	andi	r2,r2,16384
81141814:	10000226 	beq	r2,zero,81141820 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81141818:	00bffd44 	movi	r2,-11
8114181c:	00000606 	br	81141838 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81141820:	e0bffe17 	ldw	r2,-8(fp)
81141824:	10c00417 	ldw	r3,16(r2)
81141828:	e0bffe17 	ldw	r2,-8(fp)
8114182c:	10800517 	ldw	r2,20(r2)
81141830:	18bff61e 	bne	r3,r2,8114180c <__reset+0xfb12180c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81141834:	0005883a 	mov	r2,zero
}
81141838:	e037883a 	mov	sp,fp
8114183c:	df000017 	ldw	fp,0(sp)
81141840:	dec00104 	addi	sp,sp,4
81141844:	f800283a 	ret

81141848 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81141848:	defffe04 	addi	sp,sp,-8
8114184c:	de00012e 	bgeu	sp,et,81141854 <alt_get_errno+0xc>
81141850:	003b68fa 	trap	3
81141854:	dfc00115 	stw	ra,4(sp)
81141858:	df000015 	stw	fp,0(sp)
8114185c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81141860:	d0a01017 	ldw	r2,-32704(gp)
81141864:	10000326 	beq	r2,zero,81141874 <alt_get_errno+0x2c>
81141868:	d0a01017 	ldw	r2,-32704(gp)
8114186c:	103ee83a 	callr	r2
81141870:	00000106 	br	81141878 <alt_get_errno+0x30>
81141874:	d0a07d04 	addi	r2,gp,-32268
}
81141878:	e037883a 	mov	sp,fp
8114187c:	dfc00117 	ldw	ra,4(sp)
81141880:	df000017 	ldw	fp,0(sp)
81141884:	dec00204 	addi	sp,sp,8
81141888:	f800283a 	ret

8114188c <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
8114188c:	deffec04 	addi	sp,sp,-80
81141890:	de00012e 	bgeu	sp,et,81141898 <altera_avalon_uart_read+0xc>
81141894:	003b68fa 	trap	3
81141898:	dfc01315 	stw	ra,76(sp)
8114189c:	df001215 	stw	fp,72(sp)
811418a0:	df001204 	addi	fp,sp,72
811418a4:	e13ffc15 	stw	r4,-16(fp)
811418a8:	e17ffd15 	stw	r5,-12(fp)
811418ac:	e1bffe15 	stw	r6,-8(fp)
811418b0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
811418b4:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
811418b8:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
811418bc:	e0bfff17 	ldw	r2,-4(fp)
811418c0:	1090000c 	andi	r2,r2,16384
811418c4:	1005003a 	cmpeq	r2,r2,zero
811418c8:	10803fcc 	andi	r2,r2,255
811418cc:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
811418d0:	e0bffc17 	ldw	r2,-16(fp)
811418d4:	10800817 	ldw	r2,32(r2)
811418d8:	e0bff815 	stw	r2,-32(fp)
811418dc:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811418e0:	e0bff90b 	ldhu	r2,-28(fp)
811418e4:	e0fffb44 	addi	r3,fp,-19
811418e8:	180d883a 	mov	r6,r3
811418ec:	100b883a 	mov	r5,r2
811418f0:	e13ff817 	ldw	r4,-32(fp)
811418f4:	1138a3c0 	call	81138a3c <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
811418f8:	00001306 	br	81141948 <altera_avalon_uart_read+0xbc>
    {
      count++;
811418fc:	e0bff017 	ldw	r2,-64(fp)
81141900:	10800044 	addi	r2,r2,1
81141904:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81141908:	e0bffd17 	ldw	r2,-12(fp)
8114190c:	10c00044 	addi	r3,r2,1
81141910:	e0fffd15 	stw	r3,-12(fp)
81141914:	e0fffc17 	ldw	r3,-16(fp)
81141918:	18c00217 	ldw	r3,8(r3)
8114191c:	e13ffc17 	ldw	r4,-16(fp)
81141920:	20c7883a 	add	r3,r4,r3
81141924:	18c00a04 	addi	r3,r3,40
81141928:	18c00003 	ldbu	r3,0(r3)
8114192c:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81141930:	e0bffc17 	ldw	r2,-16(fp)
81141934:	10800217 	ldw	r2,8(r2)
81141938:	10800044 	addi	r2,r2,1
8114193c:	10c00fcc 	andi	r3,r2,63
81141940:	e0bffc17 	ldw	r2,-16(fp)
81141944:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81141948:	e0fff017 	ldw	r3,-64(fp)
8114194c:	e0bffe17 	ldw	r2,-8(fp)
81141950:	1880050e 	bge	r3,r2,81141968 <altera_avalon_uart_read+0xdc>
81141954:	e0bffc17 	ldw	r2,-16(fp)
81141958:	10c00217 	ldw	r3,8(r2)
8114195c:	e0bffc17 	ldw	r2,-16(fp)
81141960:	10800317 	ldw	r2,12(r2)
81141964:	18bfe51e 	bne	r3,r2,811418fc <__reset+0xfb1218fc>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81141968:	e0bff017 	ldw	r2,-64(fp)
8114196c:	10003a1e 	bne	r2,zero,81141a58 <altera_avalon_uart_read+0x1cc>
81141970:	e0bffc17 	ldw	r2,-16(fp)
81141974:	10c00217 	ldw	r3,8(r2)
81141978:	e0bffc17 	ldw	r2,-16(fp)
8114197c:	10800317 	ldw	r2,12(r2)
81141980:	1880351e 	bne	r3,r2,81141a58 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81141984:	e0bff117 	ldw	r2,-60(fp)
81141988:	1000071e 	bne	r2,zero,811419a8 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
8114198c:	11418480 	call	81141848 <alt_get_errno>
81141990:	1007883a 	mov	r3,r2
81141994:	008002c4 	movi	r2,11
81141998:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
8114199c:	00800044 	movi	r2,1
811419a0:	e0bfef05 	stb	r2,-68(fp)
        break;
811419a4:	00003006 	br	81141a68 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811419a8:	0005303a 	rdctl	r2,status
811419ac:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811419b0:	e0fff517 	ldw	r3,-44(fp)
811419b4:	00bfff84 	movi	r2,-2
811419b8:	1884703a 	and	r2,r3,r2
811419bc:	1001703a 	wrctl	status,r2
  
  return context;
811419c0:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
811419c4:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811419c8:	e0bffc17 	ldw	r2,-16(fp)
811419cc:	10800117 	ldw	r2,4(r2)
811419d0:	10c02014 	ori	r3,r2,128
811419d4:	e0bffc17 	ldw	r2,-16(fp)
811419d8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811419dc:	e0bffc17 	ldw	r2,-16(fp)
811419e0:	10800017 	ldw	r2,0(r2)
811419e4:	10800304 	addi	r2,r2,12
811419e8:	e0fffc17 	ldw	r3,-16(fp)
811419ec:	18c00117 	ldw	r3,4(r3)
811419f0:	10c00035 	stwio	r3,0(r2)
811419f4:	e0bff417 	ldw	r2,-48(fp)
811419f8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811419fc:	e0bff617 	ldw	r2,-40(fp)
81141a00:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81141a04:	e0bffc17 	ldw	r2,-16(fp)
81141a08:	10800717 	ldw	r2,28(r2)
81141a0c:	e0bff215 	stw	r2,-56(fp)
81141a10:	00800044 	movi	r2,1
81141a14:	e0bff98d 	sth	r2,-26(fp)
81141a18:	00bfe0c4 	movi	r2,-125
81141a1c:	e0bffa05 	stb	r2,-24(fp)
81141a20:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81141a24:	d0a09603 	ldbu	r2,-32168(gp)
81141a28:	10803fcc 	andi	r2,r2,255
81141a2c:	10000a26 	beq	r2,zero,81141a58 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81141a30:	e0fff98b 	ldhu	r3,-26(fp)
81141a34:	e13ffa03 	ldbu	r4,-24(fp)
81141a38:	e17ffa8b 	ldhu	r5,-22(fp)
81141a3c:	e0bffb04 	addi	r2,fp,-20
81141a40:	d8800015 	stw	r2,0(sp)
81141a44:	280f883a 	mov	r7,r5
81141a48:	200d883a 	mov	r6,r4
81141a4c:	180b883a 	mov	r5,r3
81141a50:	e13ff217 	ldw	r4,-56(fp)
81141a54:	1134d9c0 	call	81134d9c <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81141a58:	e0bff017 	ldw	r2,-64(fp)
81141a5c:	1000021e 	bne	r2,zero,81141a68 <altera_avalon_uart_read+0x1dc>
81141a60:	e0bffe17 	ldw	r2,-8(fp)
81141a64:	103fb81e 	bne	r2,zero,81141948 <__reset+0xfb121948>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81141a68:	e0bffc17 	ldw	r2,-16(fp)
81141a6c:	10800817 	ldw	r2,32(r2)
81141a70:	1009883a 	mov	r4,r2
81141a74:	1138dc40 	call	81138dc4 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141a78:	0005303a 	rdctl	r2,status
81141a7c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141a80:	e0fff717 	ldw	r3,-36(fp)
81141a84:	00bfff84 	movi	r2,-2
81141a88:	1884703a 	and	r2,r3,r2
81141a8c:	1001703a 	wrctl	status,r2
  
  return context;
81141a90:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81141a94:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81141a98:	e0bffc17 	ldw	r2,-16(fp)
81141a9c:	10800117 	ldw	r2,4(r2)
81141aa0:	10c02014 	ori	r3,r2,128
81141aa4:	e0bffc17 	ldw	r2,-16(fp)
81141aa8:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81141aac:	e0bffc17 	ldw	r2,-16(fp)
81141ab0:	10800017 	ldw	r2,0(r2)
81141ab4:	10800304 	addi	r2,r2,12
81141ab8:	e0fffc17 	ldw	r3,-16(fp)
81141abc:	18c00117 	ldw	r3,4(r3)
81141ac0:	10c00035 	stwio	r3,0(r2)
81141ac4:	e0bff417 	ldw	r2,-48(fp)
81141ac8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141acc:	e0bff317 	ldw	r2,-52(fp)
81141ad0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81141ad4:	e0bfef03 	ldbu	r2,-68(fp)
81141ad8:	10000226 	beq	r2,zero,81141ae4 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81141adc:	00bffd44 	movi	r2,-11
81141ae0:	00000106 	br	81141ae8 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81141ae4:	e0bff017 	ldw	r2,-64(fp)
  }
}
81141ae8:	e037883a 	mov	sp,fp
81141aec:	dfc00117 	ldw	ra,4(sp)
81141af0:	df000017 	ldw	fp,0(sp)
81141af4:	dec00204 	addi	sp,sp,8
81141af8:	f800283a 	ret

81141afc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81141afc:	defffe04 	addi	sp,sp,-8
81141b00:	de00012e 	bgeu	sp,et,81141b08 <alt_get_errno+0xc>
81141b04:	003b68fa 	trap	3
81141b08:	dfc00115 	stw	ra,4(sp)
81141b0c:	df000015 	stw	fp,0(sp)
81141b10:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81141b14:	d0a01017 	ldw	r2,-32704(gp)
81141b18:	10000326 	beq	r2,zero,81141b28 <alt_get_errno+0x2c>
81141b1c:	d0a01017 	ldw	r2,-32704(gp)
81141b20:	103ee83a 	callr	r2
81141b24:	00000106 	br	81141b2c <alt_get_errno+0x30>
81141b28:	d0a07d04 	addi	r2,gp,-32268
}
81141b2c:	e037883a 	mov	sp,fp
81141b30:	dfc00117 	ldw	ra,4(sp)
81141b34:	df000017 	ldw	fp,0(sp)
81141b38:	dec00204 	addi	sp,sp,8
81141b3c:	f800283a 	ret

81141b40 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81141b40:	deffec04 	addi	sp,sp,-80
81141b44:	de00012e 	bgeu	sp,et,81141b4c <altera_avalon_uart_write+0xc>
81141b48:	003b68fa 	trap	3
81141b4c:	dfc01315 	stw	ra,76(sp)
81141b50:	df001215 	stw	fp,72(sp)
81141b54:	df001204 	addi	fp,sp,72
81141b58:	e13ffc15 	stw	r4,-16(fp)
81141b5c:	e17ffd15 	stw	r5,-12(fp)
81141b60:	e1bffe15 	stw	r6,-8(fp)
81141b64:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81141b68:	e0bffe17 	ldw	r2,-8(fp)
81141b6c:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81141b70:	e0bfff17 	ldw	r2,-4(fp)
81141b74:	1090000c 	andi	r2,r2,16384
81141b78:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81141b7c:	e0bffc17 	ldw	r2,-16(fp)
81141b80:	10800917 	ldw	r2,36(r2)
81141b84:	e0bff815 	stw	r2,-32(fp)
81141b88:	e03ff90d 	sth	zero,-28(fp)
81141b8c:	e0bff90b 	ldhu	r2,-28(fp)
81141b90:	e0fffb44 	addi	r3,fp,-19
81141b94:	180d883a 	mov	r6,r3
81141b98:	100b883a 	mov	r5,r2
81141b9c:	e13ff817 	ldw	r4,-32(fp)
81141ba0:	1138a3c0 	call	81138a3c <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81141ba4:	00005106 	br	81141cec <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81141ba8:	e0bffc17 	ldw	r2,-16(fp)
81141bac:	10800517 	ldw	r2,20(r2)
81141bb0:	10800044 	addi	r2,r2,1
81141bb4:	10800fcc 	andi	r2,r2,63
81141bb8:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81141bbc:	e0bffc17 	ldw	r2,-16(fp)
81141bc0:	10c00417 	ldw	r3,16(r2)
81141bc4:	e0bff217 	ldw	r2,-56(fp)
81141bc8:	1880371e 	bne	r3,r2,81141ca8 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81141bcc:	e0bff017 	ldw	r2,-64(fp)
81141bd0:	10000526 	beq	r2,zero,81141be8 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81141bd4:	1141afc0 	call	81141afc <alt_get_errno>
81141bd8:	1007883a 	mov	r3,r2
81141bdc:	008002c4 	movi	r2,11
81141be0:	18800015 	stw	r2,0(r3)
        break;
81141be4:	00004306 	br	81141cf4 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141be8:	0005303a 	rdctl	r2,status
81141bec:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141bf0:	e0fff517 	ldw	r3,-44(fp)
81141bf4:	00bfff84 	movi	r2,-2
81141bf8:	1884703a 	and	r2,r3,r2
81141bfc:	1001703a 	wrctl	status,r2
  
  return context;
81141c00:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81141c04:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81141c08:	e0bffc17 	ldw	r2,-16(fp)
81141c0c:	10800117 	ldw	r2,4(r2)
81141c10:	10c11014 	ori	r3,r2,1088
81141c14:	e0bffc17 	ldw	r2,-16(fp)
81141c18:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81141c1c:	e0bffc17 	ldw	r2,-16(fp)
81141c20:	10800017 	ldw	r2,0(r2)
81141c24:	10800304 	addi	r2,r2,12
81141c28:	e0fffc17 	ldw	r3,-16(fp)
81141c2c:	18c00117 	ldw	r3,4(r3)
81141c30:	10c00035 	stwio	r3,0(r2)
81141c34:	e0bff417 	ldw	r2,-48(fp)
81141c38:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141c3c:	e0bff117 	ldw	r2,-60(fp)
81141c40:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81141c44:	e0bffc17 	ldw	r2,-16(fp)
81141c48:	10800717 	ldw	r2,28(r2)
81141c4c:	e0bff315 	stw	r2,-52(fp)
81141c50:	00800084 	movi	r2,2
81141c54:	e0bff98d 	sth	r2,-26(fp)
81141c58:	00bfe0c4 	movi	r2,-125
81141c5c:	e0bffa05 	stb	r2,-24(fp)
81141c60:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81141c64:	d0a09603 	ldbu	r2,-32168(gp)
81141c68:	10803fcc 	andi	r2,r2,255
81141c6c:	10000a26 	beq	r2,zero,81141c98 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81141c70:	e0fff98b 	ldhu	r3,-26(fp)
81141c74:	e13ffa03 	ldbu	r4,-24(fp)
81141c78:	e17ffa8b 	ldhu	r5,-22(fp)
81141c7c:	e0bffb04 	addi	r2,fp,-20
81141c80:	d8800015 	stw	r2,0(sp)
81141c84:	280f883a 	mov	r7,r5
81141c88:	200d883a 	mov	r6,r4
81141c8c:	180b883a 	mov	r5,r3
81141c90:	e13ff317 	ldw	r4,-52(fp)
81141c94:	1134d9c0 	call	81134d9c <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81141c98:	e0bffc17 	ldw	r2,-16(fp)
81141c9c:	10c00417 	ldw	r3,16(r2)
81141ca0:	e0bff217 	ldw	r2,-56(fp)
81141ca4:	18bfe726 	beq	r3,r2,81141c44 <__reset+0xfb121c44>
      }
    }

    count--;
81141ca8:	e0bfef17 	ldw	r2,-68(fp)
81141cac:	10bfffc4 	addi	r2,r2,-1
81141cb0:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81141cb4:	e0bffc17 	ldw	r2,-16(fp)
81141cb8:	10c00517 	ldw	r3,20(r2)
81141cbc:	e0bffd17 	ldw	r2,-12(fp)
81141cc0:	11000044 	addi	r4,r2,1
81141cc4:	e13ffd15 	stw	r4,-12(fp)
81141cc8:	10800003 	ldbu	r2,0(r2)
81141ccc:	1009883a 	mov	r4,r2
81141cd0:	e0bffc17 	ldw	r2,-16(fp)
81141cd4:	10c5883a 	add	r2,r2,r3
81141cd8:	10801a04 	addi	r2,r2,104
81141cdc:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81141ce0:	e0bffc17 	ldw	r2,-16(fp)
81141ce4:	e0fff217 	ldw	r3,-56(fp)
81141ce8:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81141cec:	e0bfef17 	ldw	r2,-68(fp)
81141cf0:	103fad1e 	bne	r2,zero,81141ba8 <__reset+0xfb121ba8>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81141cf4:	e0bffc17 	ldw	r2,-16(fp)
81141cf8:	10800917 	ldw	r2,36(r2)
81141cfc:	1009883a 	mov	r4,r2
81141d00:	1138dc40 	call	81138dc4 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141d04:	0005303a 	rdctl	r2,status
81141d08:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141d0c:	e0fff717 	ldw	r3,-36(fp)
81141d10:	00bfff84 	movi	r2,-2
81141d14:	1884703a 	and	r2,r3,r2
81141d18:	1001703a 	wrctl	status,r2
  
  return context;
81141d1c:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81141d20:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81141d24:	e0bffc17 	ldw	r2,-16(fp)
81141d28:	10800117 	ldw	r2,4(r2)
81141d2c:	10c11014 	ori	r3,r2,1088
81141d30:	e0bffc17 	ldw	r2,-16(fp)
81141d34:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81141d38:	e0bffc17 	ldw	r2,-16(fp)
81141d3c:	10800017 	ldw	r2,0(r2)
81141d40:	10800304 	addi	r2,r2,12
81141d44:	e0fffc17 	ldw	r3,-16(fp)
81141d48:	18c00117 	ldw	r3,4(r3)
81141d4c:	10c00035 	stwio	r3,0(r2)
81141d50:	e0bff417 	ldw	r2,-48(fp)
81141d54:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141d58:	e0bff617 	ldw	r2,-40(fp)
81141d5c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81141d60:	e0fffe17 	ldw	r3,-8(fp)
81141d64:	e0bfef17 	ldw	r2,-68(fp)
81141d68:	1885c83a 	sub	r2,r3,r2
}
81141d6c:	e037883a 	mov	sp,fp
81141d70:	dfc00117 	ldw	ra,4(sp)
81141d74:	df000017 	ldw	fp,0(sp)
81141d78:	dec00204 	addi	sp,sp,8
81141d7c:	f800283a 	ret

81141d80 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81141d80:	defffe04 	addi	sp,sp,-8
81141d84:	de00012e 	bgeu	sp,et,81141d8c <alt_get_errno+0xc>
81141d88:	003b68fa 	trap	3
81141d8c:	dfc00115 	stw	ra,4(sp)
81141d90:	df000015 	stw	fp,0(sp)
81141d94:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81141d98:	d0a01017 	ldw	r2,-32704(gp)
81141d9c:	10000326 	beq	r2,zero,81141dac <alt_get_errno+0x2c>
81141da0:	d0a01017 	ldw	r2,-32704(gp)
81141da4:	103ee83a 	callr	r2
81141da8:	00000106 	br	81141db0 <alt_get_errno+0x30>
81141dac:	d0a07d04 	addi	r2,gp,-32268
}
81141db0:	e037883a 	mov	sp,fp
81141db4:	dfc00117 	ldw	ra,4(sp)
81141db8:	df000017 	ldw	fp,0(sp)
81141dbc:	dec00204 	addi	sp,sp,8
81141dc0:	f800283a 	ret

81141dc4 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81141dc4:	defffc04 	addi	sp,sp,-16
81141dc8:	de00012e 	bgeu	sp,et,81141dd0 <alt_msgdma_write_standard_descriptor+0xc>
81141dcc:	003b68fa 	trap	3
81141dd0:	df000315 	stw	fp,12(sp)
81141dd4:	df000304 	addi	fp,sp,12
81141dd8:	e13ffd15 	stw	r4,-12(fp)
81141ddc:	e17ffe15 	stw	r5,-8(fp)
81141de0:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81141de4:	e0bffd17 	ldw	r2,-12(fp)
81141de8:	10800037 	ldwio	r2,0(r2)
81141dec:	1080010c 	andi	r2,r2,4
81141df0:	10000226 	beq	r2,zero,81141dfc <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81141df4:	00bff904 	movi	r2,-28
81141df8:	00001506 	br	81141e50 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81141dfc:	e0bfff17 	ldw	r2,-4(fp)
81141e00:	10800017 	ldw	r2,0(r2)
81141e04:	1007883a 	mov	r3,r2
81141e08:	e0bffe17 	ldw	r2,-8(fp)
81141e0c:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81141e10:	e0bffe17 	ldw	r2,-8(fp)
81141e14:	10800104 	addi	r2,r2,4
81141e18:	e0ffff17 	ldw	r3,-4(fp)
81141e1c:	18c00117 	ldw	r3,4(r3)
81141e20:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81141e24:	e0bffe17 	ldw	r2,-8(fp)
81141e28:	10800204 	addi	r2,r2,8
81141e2c:	e0ffff17 	ldw	r3,-4(fp)
81141e30:	18c00217 	ldw	r3,8(r3)
81141e34:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81141e38:	e0bffe17 	ldw	r2,-8(fp)
81141e3c:	10800304 	addi	r2,r2,12
81141e40:	e0ffff17 	ldw	r3,-4(fp)
81141e44:	18c00317 	ldw	r3,12(r3)
81141e48:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81141e4c:	0005883a 	mov	r2,zero
}
81141e50:	e037883a 	mov	sp,fp
81141e54:	df000017 	ldw	fp,0(sp)
81141e58:	dec00104 	addi	sp,sp,4
81141e5c:	f800283a 	ret

81141e60 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81141e60:	defffc04 	addi	sp,sp,-16
81141e64:	de00012e 	bgeu	sp,et,81141e6c <alt_msgdma_write_extended_descriptor+0xc>
81141e68:	003b68fa 	trap	3
81141e6c:	df000315 	stw	fp,12(sp)
81141e70:	df000304 	addi	fp,sp,12
81141e74:	e13ffd15 	stw	r4,-12(fp)
81141e78:	e17ffe15 	stw	r5,-8(fp)
81141e7c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81141e80:	e0bffd17 	ldw	r2,-12(fp)
81141e84:	10800037 	ldwio	r2,0(r2)
81141e88:	1080010c 	andi	r2,r2,4
81141e8c:	10000226 	beq	r2,zero,81141e98 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81141e90:	00bff904 	movi	r2,-28
81141e94:	00003b06 	br	81141f84 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81141e98:	e0bfff17 	ldw	r2,-4(fp)
81141e9c:	10800017 	ldw	r2,0(r2)
81141ea0:	1007883a 	mov	r3,r2
81141ea4:	e0bffe17 	ldw	r2,-8(fp)
81141ea8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81141eac:	e0bffe17 	ldw	r2,-8(fp)
81141eb0:	10800104 	addi	r2,r2,4
81141eb4:	e0ffff17 	ldw	r3,-4(fp)
81141eb8:	18c00117 	ldw	r3,4(r3)
81141ebc:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81141ec0:	e0bffe17 	ldw	r2,-8(fp)
81141ec4:	10800204 	addi	r2,r2,8
81141ec8:	e0ffff17 	ldw	r3,-4(fp)
81141ecc:	18c00217 	ldw	r3,8(r3)
81141ed0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81141ed4:	e0bffe17 	ldw	r2,-8(fp)
81141ed8:	10800304 	addi	r2,r2,12
81141edc:	e0ffff17 	ldw	r3,-4(fp)
81141ee0:	18c0030b 	ldhu	r3,12(r3)
81141ee4:	18ffffcc 	andi	r3,r3,65535
81141ee8:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81141eec:	e0bffe17 	ldw	r2,-8(fp)
81141ef0:	10800384 	addi	r2,r2,14
81141ef4:	e0ffff17 	ldw	r3,-4(fp)
81141ef8:	18c00383 	ldbu	r3,14(r3)
81141efc:	18c03fcc 	andi	r3,r3,255
81141f00:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81141f04:	e0bffe17 	ldw	r2,-8(fp)
81141f08:	108003c4 	addi	r2,r2,15
81141f0c:	e0ffff17 	ldw	r3,-4(fp)
81141f10:	18c003c3 	ldbu	r3,15(r3)
81141f14:	18c03fcc 	andi	r3,r3,255
81141f18:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81141f1c:	e0bffe17 	ldw	r2,-8(fp)
81141f20:	10800404 	addi	r2,r2,16
81141f24:	e0ffff17 	ldw	r3,-4(fp)
81141f28:	18c0040b 	ldhu	r3,16(r3)
81141f2c:	18ffffcc 	andi	r3,r3,65535
81141f30:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81141f34:	e0bffe17 	ldw	r2,-8(fp)
81141f38:	10800484 	addi	r2,r2,18
81141f3c:	e0ffff17 	ldw	r3,-4(fp)
81141f40:	18c0048b 	ldhu	r3,18(r3)
81141f44:	18ffffcc 	andi	r3,r3,65535
81141f48:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81141f4c:	e0bffe17 	ldw	r2,-8(fp)
81141f50:	10800504 	addi	r2,r2,20
81141f54:	0007883a 	mov	r3,zero
81141f58:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81141f5c:	e0bffe17 	ldw	r2,-8(fp)
81141f60:	10800604 	addi	r2,r2,24
81141f64:	0007883a 	mov	r3,zero
81141f68:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81141f6c:	e0bffe17 	ldw	r2,-8(fp)
81141f70:	10800704 	addi	r2,r2,28
81141f74:	e0ffff17 	ldw	r3,-4(fp)
81141f78:	18c00717 	ldw	r3,28(r3)
81141f7c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81141f80:	0005883a 	mov	r2,zero
}
81141f84:	e037883a 	mov	sp,fp
81141f88:	df000017 	ldw	fp,0(sp)
81141f8c:	dec00104 	addi	sp,sp,4
81141f90:	f800283a 	ret

81141f94 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81141f94:	defff804 	addi	sp,sp,-32
81141f98:	de00012e 	bgeu	sp,et,81141fa0 <alt_msgdma_irq+0xc>
81141f9c:	003b68fa 	trap	3
81141fa0:	dfc00715 	stw	ra,28(sp)
81141fa4:	df000615 	stw	fp,24(sp)
81141fa8:	df000604 	addi	fp,sp,24
81141fac:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81141fb0:	e0bfff17 	ldw	r2,-4(fp)
81141fb4:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81141fb8:	e0bffa17 	ldw	r2,-24(fp)
81141fbc:	10801783 	ldbu	r2,94(r2)
81141fc0:	10803fcc 	andi	r2,r2,255
81141fc4:	10001126 	beq	r2,zero,8114200c <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81141fc8:	e0bffa17 	ldw	r2,-24(fp)
81141fcc:	10800617 	ldw	r2,24(r2)
81141fd0:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81141fd4:	1007883a 	mov	r3,r2
81141fd8:	00bffdc4 	movi	r2,-9
81141fdc:	1884703a 	and	r2,r3,r2
81141fe0:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81141fe4:	e0bffa17 	ldw	r2,-24(fp)
81141fe8:	10800617 	ldw	r2,24(r2)
81141fec:	e0fffb17 	ldw	r3,-20(fp)
81141ff0:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81141ff4:	e0bffa17 	ldw	r2,-24(fp)
81141ff8:	10800617 	ldw	r2,24(r2)
81141ffc:	10800404 	addi	r2,r2,16
81142000:	00c00044 	movi	r3,1
81142004:	10c00035 	stwio	r3,0(r2)
81142008:	00001106 	br	81142050 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114200c:	e0bffa17 	ldw	r2,-24(fp)
81142010:	10800317 	ldw	r2,12(r2)
81142014:	10800104 	addi	r2,r2,4
81142018:	10800037 	ldwio	r2,0(r2)
8114201c:	1007883a 	mov	r3,r2
81142020:	00bffbc4 	movi	r2,-17
81142024:	1884703a 	and	r2,r3,r2
81142028:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
8114202c:	e0bffa17 	ldw	r2,-24(fp)
81142030:	10800317 	ldw	r2,12(r2)
81142034:	10800104 	addi	r2,r2,4
81142038:	e0fffb17 	ldw	r3,-20(fp)
8114203c:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81142040:	e0bffa17 	ldw	r2,-24(fp)
81142044:	10800317 	ldw	r2,12(r2)
81142048:	00c08004 	movi	r3,512
8114204c:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81142050:	e0bffa17 	ldw	r2,-24(fp)
81142054:	10800b17 	ldw	r2,44(r2)
81142058:	10001226 	beq	r2,zero,811420a4 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114205c:	0005303a 	rdctl	r2,status
81142060:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142064:	e0fffd17 	ldw	r3,-12(fp)
81142068:	00bfff84 	movi	r2,-2
8114206c:	1884703a 	and	r2,r3,r2
81142070:	1001703a 	wrctl	status,r2
  
  return context;
81142074:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81142078:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
8114207c:	e0bffa17 	ldw	r2,-24(fp)
81142080:	10800b17 	ldw	r2,44(r2)
81142084:	e0fffa17 	ldw	r3,-24(fp)
81142088:	18c00c17 	ldw	r3,48(r3)
8114208c:	1809883a 	mov	r4,r3
81142090:	103ee83a 	callr	r2
81142094:	e0bffc17 	ldw	r2,-16(fp)
81142098:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114209c:	e0bffe17 	ldw	r2,-8(fp)
811420a0:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
811420a4:	e0bffa17 	ldw	r2,-24(fp)
811420a8:	10801783 	ldbu	r2,94(r2)
811420ac:	10803fcc 	andi	r2,r2,255
811420b0:	10000a26 	beq	r2,zero,811420dc <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
811420b4:	e0bffa17 	ldw	r2,-24(fp)
811420b8:	10800617 	ldw	r2,24(r2)
811420bc:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
811420c0:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
811420c4:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
811420c8:	e0bffa17 	ldw	r2,-24(fp)
811420cc:	10800617 	ldw	r2,24(r2)
811420d0:	e0fffb17 	ldw	r3,-20(fp)
811420d4:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
811420d8:	00000c06 	br	8114210c <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
811420dc:	e0bffa17 	ldw	r2,-24(fp)
811420e0:	10800317 	ldw	r2,12(r2)
811420e4:	10800104 	addi	r2,r2,4
811420e8:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
811420ec:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
811420f0:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811420f4:	e0bffa17 	ldw	r2,-24(fp)
811420f8:	10800317 	ldw	r2,12(r2)
811420fc:	10800104 	addi	r2,r2,4
81142100:	e0fffb17 	ldw	r3,-20(fp)
81142104:	10c00035 	stwio	r3,0(r2)
    }

    return;
81142108:	0001883a 	nop
}
8114210c:	e037883a 	mov	sp,fp
81142110:	dfc00117 	ldw	ra,4(sp)
81142114:	df000017 	ldw	fp,0(sp)
81142118:	dec00204 	addi	sp,sp,8
8114211c:	f800283a 	ret

81142120 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81142120:	defffb04 	addi	sp,sp,-20
81142124:	de00012e 	bgeu	sp,et,8114212c <alt_msgdma_construct_standard_descriptor+0xc>
81142128:	003b68fa 	trap	3
8114212c:	df000415 	stw	fp,16(sp)
81142130:	df000404 	addi	fp,sp,16
81142134:	e13ffc15 	stw	r4,-16(fp)
81142138:	e17ffd15 	stw	r5,-12(fp)
8114213c:	e1bffe15 	stw	r6,-8(fp)
81142140:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81142144:	e0bffc17 	ldw	r2,-16(fp)
81142148:	10c01217 	ldw	r3,72(r2)
8114214c:	e0800117 	ldw	r2,4(fp)
81142150:	18800436 	bltu	r3,r2,81142164 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81142154:	e0bffc17 	ldw	r2,-16(fp)
81142158:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
8114215c:	10803fcc 	andi	r2,r2,255
81142160:	10000226 	beq	r2,zero,8114216c <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81142164:	00bffa84 	movi	r2,-22
81142168:	00000e06 	br	811421a4 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
8114216c:	e0bffd17 	ldw	r2,-12(fp)
81142170:	e0fffe17 	ldw	r3,-8(fp)
81142174:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81142178:	e0bffd17 	ldw	r2,-12(fp)
8114217c:	e0ffff17 	ldw	r3,-4(fp)
81142180:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81142184:	e0bffd17 	ldw	r2,-12(fp)
81142188:	e0c00117 	ldw	r3,4(fp)
8114218c:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81142190:	e0800217 	ldw	r2,8(fp)
81142194:	10e00034 	orhi	r3,r2,32768
81142198:	e0bffd17 	ldw	r2,-12(fp)
8114219c:	10c00315 	stw	r3,12(r2)
    
    return 0;
811421a0:	0005883a 	mov	r2,zero
}
811421a4:	e037883a 	mov	sp,fp
811421a8:	df000017 	ldw	fp,0(sp)
811421ac:	dec00104 	addi	sp,sp,4
811421b0:	f800283a 	ret

811421b4 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
811421b4:	defff604 	addi	sp,sp,-40
811421b8:	de00012e 	bgeu	sp,et,811421c0 <alt_msgdma_construct_extended_descriptor+0xc>
811421bc:	003b68fa 	trap	3
811421c0:	df000915 	stw	fp,36(sp)
811421c4:	df000904 	addi	fp,sp,36
811421c8:	e13ff715 	stw	r4,-36(fp)
811421cc:	e17ff815 	stw	r5,-32(fp)
811421d0:	e1bff915 	stw	r6,-28(fp)
811421d4:	e1fffa15 	stw	r7,-24(fp)
811421d8:	e1800317 	ldw	r6,12(fp)
811421dc:	e1400417 	ldw	r5,16(fp)
811421e0:	e1000517 	ldw	r4,20(fp)
811421e4:	e0c00617 	ldw	r3,24(fp)
811421e8:	e0800717 	ldw	r2,28(fp)
811421ec:	e1bffb0d 	sth	r6,-20(fp)
811421f0:	e17ffc05 	stb	r5,-16(fp)
811421f4:	e13ffd05 	stb	r4,-12(fp)
811421f8:	e0fffe0d 	sth	r3,-8(fp)
811421fc:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81142200:	e0bff717 	ldw	r2,-36(fp)
81142204:	10c01217 	ldw	r3,72(r2)
81142208:	e0800117 	ldw	r2,4(fp)
8114220c:	18801936 	bltu	r3,r2,81142274 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81142210:	e13ff717 	ldw	r4,-36(fp)
81142214:	20801317 	ldw	r2,76(r4)
81142218:	20c01417 	ldw	r3,80(r4)
8114221c:	e13ffe0b 	ldhu	r4,-8(fp)
81142220:	213fffcc 	andi	r4,r4,65535
81142224:	2015883a 	mov	r10,r4
81142228:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
8114222c:	1ac01136 	bltu	r3,r11,81142274 <alt_msgdma_construct_extended_descriptor+0xc0>
81142230:	58c0011e 	bne	r11,r3,81142238 <alt_msgdma_construct_extended_descriptor+0x84>
81142234:	12800f36 	bltu	r2,r10,81142274 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81142238:	e13ff717 	ldw	r4,-36(fp)
8114223c:	20801317 	ldw	r2,76(r4)
81142240:	20c01417 	ldw	r3,80(r4)
81142244:	e13fff0b 	ldhu	r4,-4(fp)
81142248:	213fffcc 	andi	r4,r4,65535
8114224c:	2011883a 	mov	r8,r4
81142250:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81142254:	1a400736 	bltu	r3,r9,81142274 <alt_msgdma_construct_extended_descriptor+0xc0>
81142258:	48c0011e 	bne	r9,r3,81142260 <alt_msgdma_construct_extended_descriptor+0xac>
8114225c:	12000536 	bltu	r2,r8,81142274 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81142260:	e0bff717 	ldw	r2,-36(fp)
81142264:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81142268:	10803fcc 	andi	r2,r2,255
8114226c:	10800060 	cmpeqi	r2,r2,1
81142270:	1000021e 	bne	r2,zero,8114227c <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81142274:	00bffa84 	movi	r2,-22
81142278:	00002106 	br	81142300 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8114227c:	e0bff817 	ldw	r2,-32(fp)
81142280:	e0fff917 	ldw	r3,-28(fp)
81142284:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81142288:	e0bff817 	ldw	r2,-32(fp)
8114228c:	e0fffa17 	ldw	r3,-24(fp)
81142290:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81142294:	e0bff817 	ldw	r2,-32(fp)
81142298:	e0c00117 	ldw	r3,4(fp)
8114229c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
811422a0:	e0bff817 	ldw	r2,-32(fp)
811422a4:	e0fffb0b 	ldhu	r3,-20(fp)
811422a8:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
811422ac:	e0bff817 	ldw	r2,-32(fp)
811422b0:	e0fffc03 	ldbu	r3,-16(fp)
811422b4:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
811422b8:	e0bff817 	ldw	r2,-32(fp)
811422bc:	e0fffd03 	ldbu	r3,-12(fp)
811422c0:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
811422c4:	e0bff817 	ldw	r2,-32(fp)
811422c8:	e0fffe0b 	ldhu	r3,-8(fp)
811422cc:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
811422d0:	e0bff817 	ldw	r2,-32(fp)
811422d4:	e0ffff0b 	ldhu	r3,-4(fp)
811422d8:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
811422dc:	e0bff817 	ldw	r2,-32(fp)
811422e0:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
811422e4:	e0bff817 	ldw	r2,-32(fp)
811422e8:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811422ec:	e0800217 	ldw	r2,8(fp)
811422f0:	10e00034 	orhi	r3,r2,32768
811422f4:	e0bff817 	ldw	r2,-32(fp)
811422f8:	10c00715 	stw	r3,28(r2)

  return 0 ;
811422fc:	0005883a 	mov	r2,zero

}
81142300:	e037883a 	mov	sp,fp
81142304:	df000017 	ldw	fp,0(sp)
81142308:	dec00104 	addi	sp,sp,4
8114230c:	f800283a 	ret

81142310 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81142310:	deffee04 	addi	sp,sp,-72
81142314:	de00012e 	bgeu	sp,et,8114231c <alt_msgdma_descriptor_async_transfer+0xc>
81142318:	003b68fa 	trap	3
8114231c:	dfc01115 	stw	ra,68(sp)
81142320:	df001015 	stw	fp,64(sp)
81142324:	df001004 	addi	fp,sp,64
81142328:	e13ffd15 	stw	r4,-12(fp)
8114232c:	e17ffe15 	stw	r5,-8(fp)
81142330:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81142334:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81142338:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
8114233c:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81142340:	e0bffd17 	ldw	r2,-12(fp)
81142344:	10800317 	ldw	r2,12(r2)
81142348:	10800204 	addi	r2,r2,8
8114234c:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81142350:	10bfffcc 	andi	r2,r2,65535
81142354:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81142358:	e0bffd17 	ldw	r2,-12(fp)
8114235c:	10800317 	ldw	r2,12(r2)
81142360:	10800204 	addi	r2,r2,8
81142364:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81142368:	1004d43a 	srli	r2,r2,16
8114236c:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81142370:	e0bffd17 	ldw	r2,-12(fp)
81142374:	10800917 	ldw	r2,36(r2)
81142378:	e0fff417 	ldw	r3,-48(fp)
8114237c:	1880042e 	bgeu	r3,r2,81142390 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81142380:	e0bffd17 	ldw	r2,-12(fp)
81142384:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81142388:	e0fff317 	ldw	r3,-52(fp)
8114238c:	18800236 	bltu	r3,r2,81142398 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81142390:	00bff904 	movi	r2,-28
81142394:	0000a906 	br	8114263c <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81142398:	e0bffd17 	ldw	r2,-12(fp)
8114239c:	10801817 	ldw	r2,96(r2)
811423a0:	e0bff615 	stw	r2,-40(fp)
811423a4:	e03ffc0d 	sth	zero,-16(fp)
811423a8:	e0bffc0b 	ldhu	r2,-16(fp)
811423ac:	e0fffc84 	addi	r3,fp,-14
811423b0:	180d883a 	mov	r6,r3
811423b4:	100b883a 	mov	r5,r2
811423b8:	e13ff617 	ldw	r4,-40(fp)
811423bc:	1138a3c0 	call	81138a3c <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811423c0:	00800804 	movi	r2,32
811423c4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811423c8:	0005303a 	rdctl	r2,status
811423cc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811423d0:	e0fff717 	ldw	r3,-36(fp)
811423d4:	00bfff84 	movi	r2,-2
811423d8:	1884703a 	and	r2,r3,r2
811423dc:	1001703a 	wrctl	status,r2
  
  return context;
811423e0:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811423e4:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811423e8:	e0bffd17 	ldw	r2,-12(fp)
811423ec:	10800317 	ldw	r2,12(r2)
811423f0:	10800104 	addi	r2,r2,4
811423f4:	e0fff117 	ldw	r3,-60(fp)
811423f8:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
811423fc:	e0bffd17 	ldw	r2,-12(fp)
81142400:	10800317 	ldw	r2,12(r2)
81142404:	e0fffd17 	ldw	r3,-12(fp)
81142408:	18c00317 	ldw	r3,12(r3)
8114240c:	18c00037 	ldwio	r3,0(r3)
81142410:	10c00035 	stwio	r3,0(r2)
81142414:	e0bff217 	ldw	r2,-56(fp)
81142418:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114241c:	e0bffb17 	ldw	r2,-20(fp)
81142420:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81142424:	e0bffe17 	ldw	r2,-8(fp)
81142428:	10001e26 	beq	r2,zero,811424a4 <alt_msgdma_descriptor_async_transfer+0x194>
8114242c:	e0bfff17 	ldw	r2,-4(fp)
81142430:	10001c1e 	bne	r2,zero,811424a4 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81142434:	00001106 	br	8114247c <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81142438:	01000044 	movi	r4,1
8114243c:	11301c40 	call	811301c4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81142440:	e0bff00b 	ldhu	r2,-64(fp)
81142444:	1084e230 	cmpltui	r2,r2,5000
81142448:	1000091e 	bne	r2,zero,81142470 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
8114244c:	01204574 	movhi	r4,33045
81142450:	21288704 	addi	r4,r4,-24036
81142454:	11447640 	call	81144764 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81142458:	e0bffd17 	ldw	r2,-12(fp)
8114245c:	10801817 	ldw	r2,96(r2)
81142460:	1009883a 	mov	r4,r2
81142464:	1138dc40 	call	81138dc4 <OSSemPost>
				
                return -ETIME;
81142468:	00bff084 	movi	r2,-62
8114246c:	00007306 	br	8114263c <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81142470:	e0bff00b 	ldhu	r2,-64(fp)
81142474:	10800044 	addi	r2,r2,1
81142478:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114247c:	e0bffd17 	ldw	r2,-12(fp)
81142480:	10c00317 	ldw	r3,12(r2)
81142484:	e0bffd17 	ldw	r2,-12(fp)
81142488:	10800417 	ldw	r2,16(r2)
8114248c:	e1bffe17 	ldw	r6,-8(fp)
81142490:	100b883a 	mov	r5,r2
81142494:	1809883a 	mov	r4,r3
81142498:	1141dc40 	call	81141dc4 <alt_msgdma_write_standard_descriptor>
8114249c:	103fe61e 	bne	r2,zero,81142438 <__reset+0xfb122438>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811424a0:	00002706 	br	81142540 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811424a4:	e0bffe17 	ldw	r2,-8(fp)
811424a8:	10001f1e 	bne	r2,zero,81142528 <alt_msgdma_descriptor_async_transfer+0x218>
811424ac:	e0bfff17 	ldw	r2,-4(fp)
811424b0:	10001d26 	beq	r2,zero,81142528 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
811424b4:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811424b8:	00001106 	br	81142500 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811424bc:	01000044 	movi	r4,1
811424c0:	11301c40 	call	811301c4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811424c4:	e0bff00b 	ldhu	r2,-64(fp)
811424c8:	1084e230 	cmpltui	r2,r2,5000
811424cc:	1000091e 	bne	r2,zero,811424f4 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
811424d0:	01204574 	movhi	r4,33045
811424d4:	21289d04 	addi	r4,r4,-23948
811424d8:	11447640 	call	81144764 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811424dc:	e0bffd17 	ldw	r2,-12(fp)
811424e0:	10801817 	ldw	r2,96(r2)
811424e4:	1009883a 	mov	r4,r2
811424e8:	1138dc40 	call	81138dc4 <OSSemPost>
				
                return -ETIME;
811424ec:	00bff084 	movi	r2,-62
811424f0:	00005206 	br	8114263c <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811424f4:	e0bff00b 	ldhu	r2,-64(fp)
811424f8:	10800044 	addi	r2,r2,1
811424fc:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81142500:	e0bffd17 	ldw	r2,-12(fp)
81142504:	10c00317 	ldw	r3,12(r2)
81142508:	e0bffd17 	ldw	r2,-12(fp)
8114250c:	10800417 	ldw	r2,16(r2)
81142510:	e1bfff17 	ldw	r6,-4(fp)
81142514:	100b883a 	mov	r5,r2
81142518:	1809883a 	mov	r4,r3
8114251c:	1141e600 	call	81141e60 <alt_msgdma_write_extended_descriptor>
81142520:	103fe61e 	bne	r2,zero,811424bc <__reset+0xfb1224bc>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81142524:	00000606 	br	81142540 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81142528:	e0bffd17 	ldw	r2,-12(fp)
8114252c:	10801817 	ldw	r2,96(r2)
81142530:	1009883a 	mov	r4,r2
81142534:	1138dc40 	call	81138dc4 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81142538:	00bfffc4 	movi	r2,-1
8114253c:	00003f06 	br	8114263c <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81142540:	e0bffd17 	ldw	r2,-12(fp)
81142544:	10800b17 	ldw	r2,44(r2)
81142548:	10001c26 	beq	r2,zero,811425bc <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
8114254c:	e0bffd17 	ldw	r2,-12(fp)
81142550:	10c00d17 	ldw	r3,52(r2)
81142554:	e0bff117 	ldw	r2,-60(fp)
81142558:	1884b03a 	or	r2,r3,r2
8114255c:	10800514 	ori	r2,r2,20
81142560:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81142564:	e0fff117 	ldw	r3,-60(fp)
81142568:	00bff7c4 	movi	r2,-33
8114256c:	1884703a 	and	r2,r3,r2
81142570:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142574:	0005303a 	rdctl	r2,status
81142578:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114257c:	e0fff917 	ldw	r3,-28(fp)
81142580:	00bfff84 	movi	r2,-2
81142584:	1884703a 	and	r2,r3,r2
81142588:	1001703a 	wrctl	status,r2
  
  return context;
8114258c:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81142590:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81142594:	e0bffd17 	ldw	r2,-12(fp)
81142598:	10800317 	ldw	r2,12(r2)
8114259c:	10800104 	addi	r2,r2,4
811425a0:	e0fff117 	ldw	r3,-60(fp)
811425a4:	10c00035 	stwio	r3,0(r2)
811425a8:	e0bff217 	ldw	r2,-56(fp)
811425ac:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811425b0:	e0bff517 	ldw	r2,-44(fp)
811425b4:	1001703a 	wrctl	status,r2
811425b8:	00001b06 	br	81142628 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
811425bc:	e0bffd17 	ldw	r2,-12(fp)
811425c0:	10c00d17 	ldw	r3,52(r2)
811425c4:	e0bff117 	ldw	r2,-60(fp)
811425c8:	1884b03a 	or	r2,r3,r2
811425cc:	10800114 	ori	r2,r2,4
811425d0:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
811425d4:	e0fff117 	ldw	r3,-60(fp)
811425d8:	00bff3c4 	movi	r2,-49
811425dc:	1884703a 	and	r2,r3,r2
811425e0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811425e4:	0005303a 	rdctl	r2,status
811425e8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811425ec:	e0fffa17 	ldw	r3,-24(fp)
811425f0:	00bfff84 	movi	r2,-2
811425f4:	1884703a 	and	r2,r3,r2
811425f8:	1001703a 	wrctl	status,r2
  
  return context;
811425fc:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81142600:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81142604:	e0bffd17 	ldw	r2,-12(fp)
81142608:	10800317 	ldw	r2,12(r2)
8114260c:	10800104 	addi	r2,r2,4
81142610:	e0fff117 	ldw	r3,-60(fp)
81142614:	10c00035 	stwio	r3,0(r2)
81142618:	e0bff217 	ldw	r2,-56(fp)
8114261c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142620:	e0bff817 	ldw	r2,-32(fp)
81142624:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81142628:	e0bffd17 	ldw	r2,-12(fp)
8114262c:	10801817 	ldw	r2,96(r2)
81142630:	1009883a 	mov	r4,r2
81142634:	1138dc40 	call	81138dc4 <OSSemPost>
    
    return 0;
81142638:	0005883a 	mov	r2,zero
}
8114263c:	e037883a 	mov	sp,fp
81142640:	dfc00117 	ldw	ra,4(sp)
81142644:	df000017 	ldw	fp,0(sp)
81142648:	dec00204 	addi	sp,sp,8
8114264c:	f800283a 	ret

81142650 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81142650:	deffee04 	addi	sp,sp,-72
81142654:	de00012e 	bgeu	sp,et,8114265c <alt_msgdma_descriptor_sync_transfer+0xc>
81142658:	003b68fa 	trap	3
8114265c:	dfc01115 	stw	ra,68(sp)
81142660:	df001015 	stw	fp,64(sp)
81142664:	df001004 	addi	fp,sp,64
81142668:	e13ffd15 	stw	r4,-12(fp)
8114266c:	e17ffe15 	stw	r5,-8(fp)
81142670:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81142674:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81142678:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8114267c:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81142680:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81142684:	e0bffd17 	ldw	r2,-12(fp)
81142688:	10800317 	ldw	r2,12(r2)
8114268c:	10800204 	addi	r2,r2,8
81142690:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81142694:	10bfffcc 	andi	r2,r2,65535
81142698:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114269c:	e0bffd17 	ldw	r2,-12(fp)
811426a0:	10800317 	ldw	r2,12(r2)
811426a4:	10800204 	addi	r2,r2,8
811426a8:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811426ac:	1004d43a 	srli	r2,r2,16
811426b0:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
811426b4:	00807804 	movi	r2,480
811426b8:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811426bc:	00001906 	br	81142724 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
811426c0:	01000044 	movi	r4,1
811426c4:	11301c40 	call	811301c4 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811426c8:	e0bff10b 	ldhu	r2,-60(fp)
811426cc:	1084e230 	cmpltui	r2,r2,5000
811426d0:	1000051e 	bne	r2,zero,811426e8 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
811426d4:	01204574 	movhi	r4,33045
811426d8:	2128b304 	addi	r4,r4,-23860
811426dc:	11447640 	call	81144764 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
811426e0:	00bff084 	movi	r2,-62
811426e4:	0000d706 	br	81142a44 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
811426e8:	e0bff10b 	ldhu	r2,-60(fp)
811426ec:	10800044 	addi	r2,r2,1
811426f0:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811426f4:	e0bffd17 	ldw	r2,-12(fp)
811426f8:	10800317 	ldw	r2,12(r2)
811426fc:	10800204 	addi	r2,r2,8
81142700:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81142704:	10bfffcc 	andi	r2,r2,65535
81142708:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114270c:	e0bffd17 	ldw	r2,-12(fp)
81142710:	10800317 	ldw	r2,12(r2)
81142714:	10800204 	addi	r2,r2,8
81142718:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8114271c:	1004d43a 	srli	r2,r2,16
81142720:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81142724:	e0bffd17 	ldw	r2,-12(fp)
81142728:	10800917 	ldw	r2,36(r2)
8114272c:	e0fff317 	ldw	r3,-52(fp)
81142730:	18bfe32e 	bgeu	r3,r2,811426c0 <__reset+0xfb1226c0>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81142734:	e0bffd17 	ldw	r2,-12(fp)
81142738:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114273c:	e0fff217 	ldw	r3,-56(fp)
81142740:	18bfdf2e 	bgeu	r3,r2,811426c0 <__reset+0xfb1226c0>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81142744:	e0bffd17 	ldw	r2,-12(fp)
81142748:	10801817 	ldw	r2,96(r2)
8114274c:	e0bff815 	stw	r2,-32(fp)
81142750:	e03ffc0d 	sth	zero,-16(fp)
81142754:	e0bffc0b 	ldhu	r2,-16(fp)
81142758:	e0fffc84 	addi	r3,fp,-14
8114275c:	180d883a 	mov	r6,r3
81142760:	100b883a 	mov	r5,r2
81142764:	e13ff817 	ldw	r4,-32(fp)
81142768:	1138a3c0 	call	81138a3c <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114276c:	0005303a 	rdctl	r2,status
81142770:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142774:	e0fffb17 	ldw	r3,-20(fp)
81142778:	00bfff84 	movi	r2,-2
8114277c:	1884703a 	and	r2,r3,r2
81142780:	1001703a 	wrctl	status,r2
  
  return context;
81142784:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81142788:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8114278c:	e0bffd17 	ldw	r2,-12(fp)
81142790:	10800317 	ldw	r2,12(r2)
81142794:	10800104 	addi	r2,r2,4
81142798:	00c00804 	movi	r3,32
8114279c:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811427a0:	e0bffd17 	ldw	r2,-12(fp)
811427a4:	10800317 	ldw	r2,12(r2)
811427a8:	e0fffd17 	ldw	r3,-12(fp)
811427ac:	18c00317 	ldw	r3,12(r3)
811427b0:	18c00037 	ldwio	r3,0(r3)
811427b4:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811427b8:	e0bffe17 	ldw	r2,-8(fp)
811427bc:	10001f26 	beq	r2,zero,8114283c <alt_msgdma_descriptor_sync_transfer+0x1ec>
811427c0:	e0bfff17 	ldw	r2,-4(fp)
811427c4:	10001d1e 	bne	r2,zero,8114283c <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
811427c8:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811427cc:	00001106 	br	81142814 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
811427d0:	01000044 	movi	r4,1
811427d4:	11301c40 	call	811301c4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811427d8:	e0bff10b 	ldhu	r2,-60(fp)
811427dc:	1084e230 	cmpltui	r2,r2,5000
811427e0:	1000091e 	bne	r2,zero,81142808 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
811427e4:	01204574 	movhi	r4,33045
811427e8:	2128c704 	addi	r4,r4,-23780
811427ec:	11447640 	call	81144764 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811427f0:	e0bffd17 	ldw	r2,-12(fp)
811427f4:	10801817 	ldw	r2,96(r2)
811427f8:	1009883a 	mov	r4,r2
811427fc:	1138dc40 	call	81138dc4 <OSSemPost>
				
                return -ETIME;
81142800:	00bff084 	movi	r2,-62
81142804:	00008f06 	br	81142a44 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81142808:	e0bff10b 	ldhu	r2,-60(fp)
8114280c:	10800044 	addi	r2,r2,1
81142810:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81142814:	e0bffd17 	ldw	r2,-12(fp)
81142818:	10c00317 	ldw	r3,12(r2)
8114281c:	e0bffd17 	ldw	r2,-12(fp)
81142820:	10800417 	ldw	r2,16(r2)
81142824:	e1bffe17 	ldw	r6,-8(fp)
81142828:	100b883a 	mov	r5,r2
8114282c:	1809883a 	mov	r4,r3
81142830:	1141dc40 	call	81141dc4 <alt_msgdma_write_standard_descriptor>
81142834:	103fe61e 	bne	r2,zero,811427d0 <__reset+0xfb1227d0>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81142838:	00002706 	br	811428d8 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114283c:	e0bffe17 	ldw	r2,-8(fp)
81142840:	10001f1e 	bne	r2,zero,811428c0 <alt_msgdma_descriptor_sync_transfer+0x270>
81142844:	e0bfff17 	ldw	r2,-4(fp)
81142848:	10001d26 	beq	r2,zero,811428c0 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8114284c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81142850:	00001106 	br	81142898 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81142854:	01000044 	movi	r4,1
81142858:	11301c40 	call	811301c4 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114285c:	e0bff10b 	ldhu	r2,-60(fp)
81142860:	1084e230 	cmpltui	r2,r2,5000
81142864:	1000091e 	bne	r2,zero,8114288c <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81142868:	01204574 	movhi	r4,33045
8114286c:	2128d804 	addi	r4,r4,-23712
81142870:	11447640 	call	81144764 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81142874:	e0bffd17 	ldw	r2,-12(fp)
81142878:	10801817 	ldw	r2,96(r2)
8114287c:	1009883a 	mov	r4,r2
81142880:	1138dc40 	call	81138dc4 <OSSemPost>
				
                return -ETIME;
81142884:	00bff084 	movi	r2,-62
81142888:	00006e06 	br	81142a44 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
8114288c:	e0bff10b 	ldhu	r2,-60(fp)
81142890:	10800044 	addi	r2,r2,1
81142894:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81142898:	e0bffd17 	ldw	r2,-12(fp)
8114289c:	10c00317 	ldw	r3,12(r2)
811428a0:	e0bffd17 	ldw	r2,-12(fp)
811428a4:	10800417 	ldw	r2,16(r2)
811428a8:	e1bfff17 	ldw	r6,-4(fp)
811428ac:	100b883a 	mov	r5,r2
811428b0:	1809883a 	mov	r4,r3
811428b4:	1141e600 	call	81141e60 <alt_msgdma_write_extended_descriptor>
811428b8:	103fe61e 	bne	r2,zero,81142854 <__reset+0xfb122854>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811428bc:	00000606 	br	811428d8 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811428c0:	e0bffd17 	ldw	r2,-12(fp)
811428c4:	10801817 	ldw	r2,96(r2)
811428c8:	1009883a 	mov	r4,r2
811428cc:	1138dc40 	call	81138dc4 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811428d0:	00bfffc4 	movi	r2,-1
811428d4:	00005b06 	br	81142a44 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811428d8:	e0bffd17 	ldw	r2,-12(fp)
811428dc:	10800317 	ldw	r2,12(r2)
811428e0:	10800104 	addi	r2,r2,4
811428e4:	e0fffd17 	ldw	r3,-12(fp)
811428e8:	19000d17 	ldw	r4,52(r3)
811428ec:	00fff2c4 	movi	r3,-53
811428f0:	20c6703a 	and	r3,r4,r3
811428f4:	18c00114 	ori	r3,r3,4
811428f8:	10c00035 	stwio	r3,0(r2)
811428fc:	e0bff517 	ldw	r2,-44(fp)
81142900:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142904:	e0bff717 	ldw	r2,-36(fp)
81142908:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
8114290c:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81142910:	e0bffd17 	ldw	r2,-12(fp)
81142914:	10800317 	ldw	r2,12(r2)
81142918:	10800037 	ldwio	r2,0(r2)
8114291c:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81142920:	00001506 	br	81142978 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81142924:	01000044 	movi	r4,1
81142928:	11301c40 	call	811301c4 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114292c:	e0bff10b 	ldhu	r2,-60(fp)
81142930:	1084e230 	cmpltui	r2,r2,5000
81142934:	1000091e 	bne	r2,zero,8114295c <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81142938:	01204574 	movhi	r4,33045
8114293c:	2128e904 	addi	r4,r4,-23644
81142940:	11447640 	call	81144764 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81142944:	e0bffd17 	ldw	r2,-12(fp)
81142948:	10801817 	ldw	r2,96(r2)
8114294c:	1009883a 	mov	r4,r2
81142950:	1138dc40 	call	81138dc4 <OSSemPost>
			
            return -ETIME;
81142954:	00bff084 	movi	r2,-62
81142958:	00003a06 	br	81142a44 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8114295c:	e0bff10b 	ldhu	r2,-60(fp)
81142960:	10800044 	addi	r2,r2,1
81142964:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81142968:	e0bffd17 	ldw	r2,-12(fp)
8114296c:	10800317 	ldw	r2,12(r2)
81142970:	10800037 	ldwio	r2,0(r2)
81142974:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81142978:	e0fff017 	ldw	r3,-64(fp)
8114297c:	e0bff617 	ldw	r2,-40(fp)
81142980:	1884703a 	and	r2,r3,r2
81142984:	1000031e 	bne	r2,zero,81142994 <alt_msgdma_descriptor_sync_transfer+0x344>
81142988:	e0bff017 	ldw	r2,-64(fp)
8114298c:	1080004c 	andi	r2,r2,1
81142990:	103fe41e 	bne	r2,zero,81142924 <__reset+0xfb122924>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81142994:	e0fff017 	ldw	r3,-64(fp)
81142998:	e0bff617 	ldw	r2,-40(fp)
8114299c:	1884703a 	and	r2,r3,r2
811429a0:	10000626 	beq	r2,zero,811429bc <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811429a4:	e0bffd17 	ldw	r2,-12(fp)
811429a8:	10801817 	ldw	r2,96(r2)
811429ac:	1009883a 	mov	r4,r2
811429b0:	1138dc40 	call	81138dc4 <OSSemPost>
		
        return error;
811429b4:	e0bff617 	ldw	r2,-40(fp)
811429b8:	00002206 	br	81142a44 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
811429bc:	e0bffd17 	ldw	r2,-12(fp)
811429c0:	10800317 	ldw	r2,12(r2)
811429c4:	10800104 	addi	r2,r2,4
811429c8:	10800037 	ldwio	r2,0(r2)
811429cc:	10800814 	ori	r2,r2,32
811429d0:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811429d4:	0005303a 	rdctl	r2,status
811429d8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811429dc:	e0fffa17 	ldw	r3,-24(fp)
811429e0:	00bfff84 	movi	r2,-2
811429e4:	1884703a 	and	r2,r3,r2
811429e8:	1001703a 	wrctl	status,r2
  
  return context;
811429ec:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
811429f0:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811429f4:	e0bffd17 	ldw	r2,-12(fp)
811429f8:	10800317 	ldw	r2,12(r2)
811429fc:	10800104 	addi	r2,r2,4
81142a00:	e0fff417 	ldw	r3,-48(fp)
81142a04:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81142a08:	e0bffd17 	ldw	r2,-12(fp)
81142a0c:	10800317 	ldw	r2,12(r2)
81142a10:	e0fffd17 	ldw	r3,-12(fp)
81142a14:	18c00317 	ldw	r3,12(r3)
81142a18:	18c00037 	ldwio	r3,0(r3)
81142a1c:	10c00035 	stwio	r3,0(r2)
81142a20:	e0bff517 	ldw	r2,-44(fp)
81142a24:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142a28:	e0bff917 	ldw	r2,-28(fp)
81142a2c:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81142a30:	e0bffd17 	ldw	r2,-12(fp)
81142a34:	10801817 	ldw	r2,96(r2)
81142a38:	1009883a 	mov	r4,r2
81142a3c:	1138dc40 	call	81138dc4 <OSSemPost>
    
    return 0;
81142a40:	0005883a 	mov	r2,zero

}
81142a44:	e037883a 	mov	sp,fp
81142a48:	dfc00117 	ldw	ra,4(sp)
81142a4c:	df000017 	ldw	fp,0(sp)
81142a50:	dec00204 	addi	sp,sp,8
81142a54:	f800283a 	ret

81142a58 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81142a58:	defff804 	addi	sp,sp,-32
81142a5c:	de00012e 	bgeu	sp,et,81142a64 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81142a60:	003b68fa 	trap	3
81142a64:	dfc00715 	stw	ra,28(sp)
81142a68:	df000615 	stw	fp,24(sp)
81142a6c:	df000604 	addi	fp,sp,24
81142a70:	e13ffc15 	stw	r4,-16(fp)
81142a74:	e17ffd15 	stw	r5,-12(fp)
81142a78:	e1bffe15 	stw	r6,-8(fp)
81142a7c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81142a80:	e0800217 	ldw	r2,8(fp)
81142a84:	d8800115 	stw	r2,4(sp)
81142a88:	e0bfff17 	ldw	r2,-4(fp)
81142a8c:	d8800015 	stw	r2,0(sp)
81142a90:	e1fffe17 	ldw	r7,-8(fp)
81142a94:	000d883a 	mov	r6,zero
81142a98:	e17ffd17 	ldw	r5,-12(fp)
81142a9c:	e13ffc17 	ldw	r4,-16(fp)
81142aa0:	11421200 	call	81142120 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81142aa4:	e037883a 	mov	sp,fp
81142aa8:	dfc00117 	ldw	ra,4(sp)
81142aac:	df000017 	ldw	fp,0(sp)
81142ab0:	dec00204 	addi	sp,sp,8
81142ab4:	f800283a 	ret

81142ab8 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81142ab8:	defff804 	addi	sp,sp,-32
81142abc:	de00012e 	bgeu	sp,et,81142ac4 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81142ac0:	003b68fa 	trap	3
81142ac4:	dfc00715 	stw	ra,28(sp)
81142ac8:	df000615 	stw	fp,24(sp)
81142acc:	df000604 	addi	fp,sp,24
81142ad0:	e13ffc15 	stw	r4,-16(fp)
81142ad4:	e17ffd15 	stw	r5,-12(fp)
81142ad8:	e1bffe15 	stw	r6,-8(fp)
81142adc:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81142ae0:	e0800217 	ldw	r2,8(fp)
81142ae4:	d8800115 	stw	r2,4(sp)
81142ae8:	e0bfff17 	ldw	r2,-4(fp)
81142aec:	d8800015 	stw	r2,0(sp)
81142af0:	000f883a 	mov	r7,zero
81142af4:	e1bffe17 	ldw	r6,-8(fp)
81142af8:	e17ffd17 	ldw	r5,-12(fp)
81142afc:	e13ffc17 	ldw	r4,-16(fp)
81142b00:	11421200 	call	81142120 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81142b04:	e037883a 	mov	sp,fp
81142b08:	dfc00117 	ldw	ra,4(sp)
81142b0c:	df000017 	ldw	fp,0(sp)
81142b10:	dec00204 	addi	sp,sp,8
81142b14:	f800283a 	ret

81142b18 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81142b18:	defff804 	addi	sp,sp,-32
81142b1c:	de00012e 	bgeu	sp,et,81142b24 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81142b20:	003b68fa 	trap	3
81142b24:	dfc00715 	stw	ra,28(sp)
81142b28:	df000615 	stw	fp,24(sp)
81142b2c:	df000604 	addi	fp,sp,24
81142b30:	e13ffc15 	stw	r4,-16(fp)
81142b34:	e17ffd15 	stw	r5,-12(fp)
81142b38:	e1bffe15 	stw	r6,-8(fp)
81142b3c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81142b40:	e0800317 	ldw	r2,12(fp)
81142b44:	d8800115 	stw	r2,4(sp)
81142b48:	e0800217 	ldw	r2,8(fp)
81142b4c:	d8800015 	stw	r2,0(sp)
81142b50:	e1ffff17 	ldw	r7,-4(fp)
81142b54:	e1bffe17 	ldw	r6,-8(fp)
81142b58:	e17ffd17 	ldw	r5,-12(fp)
81142b5c:	e13ffc17 	ldw	r4,-16(fp)
81142b60:	11421200 	call	81142120 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81142b64:	e037883a 	mov	sp,fp
81142b68:	dfc00117 	ldw	ra,4(sp)
81142b6c:	df000017 	ldw	fp,0(sp)
81142b70:	dec00204 	addi	sp,sp,8
81142b74:	f800283a 	ret

81142b78 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81142b78:	defff004 	addi	sp,sp,-64
81142b7c:	de00012e 	bgeu	sp,et,81142b84 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81142b80:	003b68fa 	trap	3
81142b84:	dfc00f15 	stw	ra,60(sp)
81142b88:	df000e15 	stw	fp,56(sp)
81142b8c:	df000e04 	addi	fp,sp,56
81142b90:	e13ff915 	stw	r4,-28(fp)
81142b94:	e17ffa15 	stw	r5,-24(fp)
81142b98:	e1bffb15 	stw	r6,-20(fp)
81142b9c:	e1fffc15 	stw	r7,-16(fp)
81142ba0:	e1000317 	ldw	r4,12(fp)
81142ba4:	e0c00417 	ldw	r3,16(fp)
81142ba8:	e0800517 	ldw	r2,20(fp)
81142bac:	e13ffd0d 	sth	r4,-12(fp)
81142bb0:	e0fffe05 	stb	r3,-8(fp)
81142bb4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81142bb8:	e0bffd0b 	ldhu	r2,-12(fp)
81142bbc:	e0fffe03 	ldbu	r3,-8(fp)
81142bc0:	e13fff0b 	ldhu	r4,-4(fp)
81142bc4:	d9000615 	stw	r4,24(sp)
81142bc8:	d8000515 	stw	zero,20(sp)
81142bcc:	d8c00415 	stw	r3,16(sp)
81142bd0:	d8000315 	stw	zero,12(sp)
81142bd4:	d8800215 	stw	r2,8(sp)
81142bd8:	e0800217 	ldw	r2,8(fp)
81142bdc:	d8800115 	stw	r2,4(sp)
81142be0:	e0bffc17 	ldw	r2,-16(fp)
81142be4:	d8800015 	stw	r2,0(sp)
81142be8:	e1fffb17 	ldw	r7,-20(fp)
81142bec:	000d883a 	mov	r6,zero
81142bf0:	e17ffa17 	ldw	r5,-24(fp)
81142bf4:	e13ff917 	ldw	r4,-28(fp)
81142bf8:	11421b40 	call	811421b4 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81142bfc:	e037883a 	mov	sp,fp
81142c00:	dfc00117 	ldw	ra,4(sp)
81142c04:	df000017 	ldw	fp,0(sp)
81142c08:	dec00204 	addi	sp,sp,8
81142c0c:	f800283a 	ret

81142c10 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81142c10:	defff004 	addi	sp,sp,-64
81142c14:	de00012e 	bgeu	sp,et,81142c1c <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81142c18:	003b68fa 	trap	3
81142c1c:	dfc00f15 	stw	ra,60(sp)
81142c20:	df000e15 	stw	fp,56(sp)
81142c24:	df000e04 	addi	fp,sp,56
81142c28:	e13ff915 	stw	r4,-28(fp)
81142c2c:	e17ffa15 	stw	r5,-24(fp)
81142c30:	e1bffb15 	stw	r6,-20(fp)
81142c34:	e1fffc15 	stw	r7,-16(fp)
81142c38:	e1000317 	ldw	r4,12(fp)
81142c3c:	e0c00417 	ldw	r3,16(fp)
81142c40:	e0800517 	ldw	r2,20(fp)
81142c44:	e13ffd0d 	sth	r4,-12(fp)
81142c48:	e0fffe05 	stb	r3,-8(fp)
81142c4c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81142c50:	e0bffd0b 	ldhu	r2,-12(fp)
81142c54:	e0fffe03 	ldbu	r3,-8(fp)
81142c58:	e13fff0b 	ldhu	r4,-4(fp)
81142c5c:	d8000615 	stw	zero,24(sp)
81142c60:	d9000515 	stw	r4,20(sp)
81142c64:	d8000415 	stw	zero,16(sp)
81142c68:	d8c00315 	stw	r3,12(sp)
81142c6c:	d8800215 	stw	r2,8(sp)
81142c70:	e0800217 	ldw	r2,8(fp)
81142c74:	d8800115 	stw	r2,4(sp)
81142c78:	e0bffc17 	ldw	r2,-16(fp)
81142c7c:	d8800015 	stw	r2,0(sp)
81142c80:	000f883a 	mov	r7,zero
81142c84:	e1bffb17 	ldw	r6,-20(fp)
81142c88:	e17ffa17 	ldw	r5,-24(fp)
81142c8c:	e13ff917 	ldw	r4,-28(fp)
81142c90:	11421b40 	call	811421b4 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81142c94:	e037883a 	mov	sp,fp
81142c98:	dfc00117 	ldw	ra,4(sp)
81142c9c:	df000017 	ldw	fp,0(sp)
81142ca0:	dec00204 	addi	sp,sp,8
81142ca4:	f800283a 	ret

81142ca8 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81142ca8:	deffee04 	addi	sp,sp,-72
81142cac:	de00012e 	bgeu	sp,et,81142cb4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81142cb0:	003b68fa 	trap	3
81142cb4:	dfc01115 	stw	ra,68(sp)
81142cb8:	df001015 	stw	fp,64(sp)
81142cbc:	df001004 	addi	fp,sp,64
81142cc0:	e13ff715 	stw	r4,-36(fp)
81142cc4:	e17ff815 	stw	r5,-32(fp)
81142cc8:	e1bff915 	stw	r6,-28(fp)
81142ccc:	e1fffa15 	stw	r7,-24(fp)
81142cd0:	e1800417 	ldw	r6,16(fp)
81142cd4:	e1400517 	ldw	r5,20(fp)
81142cd8:	e1000617 	ldw	r4,24(fp)
81142cdc:	e0c00717 	ldw	r3,28(fp)
81142ce0:	e0800817 	ldw	r2,32(fp)
81142ce4:	e1bffb0d 	sth	r6,-20(fp)
81142ce8:	e17ffc05 	stb	r5,-16(fp)
81142cec:	e13ffd05 	stb	r4,-12(fp)
81142cf0:	e0fffe0d 	sth	r3,-8(fp)
81142cf4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81142cf8:	e0bffb0b 	ldhu	r2,-20(fp)
81142cfc:	e0fffc03 	ldbu	r3,-16(fp)
81142d00:	e13ffd03 	ldbu	r4,-12(fp)
81142d04:	e17ffe0b 	ldhu	r5,-8(fp)
81142d08:	e1bfff0b 	ldhu	r6,-4(fp)
81142d0c:	d9800615 	stw	r6,24(sp)
81142d10:	d9400515 	stw	r5,20(sp)
81142d14:	d9000415 	stw	r4,16(sp)
81142d18:	d8c00315 	stw	r3,12(sp)
81142d1c:	d8800215 	stw	r2,8(sp)
81142d20:	e0800317 	ldw	r2,12(fp)
81142d24:	d8800115 	stw	r2,4(sp)
81142d28:	e0800217 	ldw	r2,8(fp)
81142d2c:	d8800015 	stw	r2,0(sp)
81142d30:	e1fffa17 	ldw	r7,-24(fp)
81142d34:	e1bff917 	ldw	r6,-28(fp)
81142d38:	e17ff817 	ldw	r5,-32(fp)
81142d3c:	e13ff717 	ldw	r4,-36(fp)
81142d40:	11421b40 	call	811421b4 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81142d44:	e037883a 	mov	sp,fp
81142d48:	dfc00117 	ldw	ra,4(sp)
81142d4c:	df000017 	ldw	fp,0(sp)
81142d50:	dec00204 	addi	sp,sp,8
81142d54:	f800283a 	ret

81142d58 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81142d58:	defffb04 	addi	sp,sp,-20
81142d5c:	de00012e 	bgeu	sp,et,81142d64 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81142d60:	003b68fa 	trap	3
81142d64:	df000415 	stw	fp,16(sp)
81142d68:	df000404 	addi	fp,sp,16
81142d6c:	e13ffc15 	stw	r4,-16(fp)
81142d70:	e17ffd15 	stw	r5,-12(fp)
81142d74:	e1bffe15 	stw	r6,-8(fp)
81142d78:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81142d7c:	e0bffc17 	ldw	r2,-16(fp)
81142d80:	10c01217 	ldw	r3,72(r2)
81142d84:	e0800117 	ldw	r2,4(fp)
81142d88:	18800436 	bltu	r3,r2,81142d9c <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81142d8c:	e0bffc17 	ldw	r2,-16(fp)
81142d90:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81142d94:	10803fcc 	andi	r2,r2,255
81142d98:	10000226 	beq	r2,zero,81142da4 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81142d9c:	00bffa84 	movi	r2,-22
81142da0:	00001406 	br	81142df4 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81142da4:	e0bffd17 	ldw	r2,-12(fp)
81142da8:	e0fffe17 	ldw	r3,-8(fp)
81142dac:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81142db0:	e0bffd17 	ldw	r2,-12(fp)
81142db4:	e0ffff17 	ldw	r3,-4(fp)
81142db8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81142dbc:	e0bffd17 	ldw	r2,-12(fp)
81142dc0:	e0c00117 	ldw	r3,4(fp)
81142dc4:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81142dc8:	e0fffd17 	ldw	r3,-12(fp)
81142dcc:	e0bffd17 	ldw	r2,-12(fp)
81142dd0:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81142dd4:	e0c00217 	ldw	r3,8(fp)
81142dd8:	00900034 	movhi	r2,16384
81142ddc:	10bfffc4 	addi	r2,r2,-1
81142de0:	1884703a 	and	r2,r3,r2
81142de4:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81142de8:	e0bffd17 	ldw	r2,-12(fp)
81142dec:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81142df0:	0005883a 	mov	r2,zero
}
81142df4:	e037883a 	mov	sp,fp
81142df8:	df000017 	ldw	fp,0(sp)
81142dfc:	dec00104 	addi	sp,sp,4
81142e00:	f800283a 	ret

81142e04 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81142e04:	defff404 	addi	sp,sp,-48
81142e08:	de00012e 	bgeu	sp,et,81142e10 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81142e0c:	003b68fa 	trap	3
81142e10:	df000b15 	stw	fp,44(sp)
81142e14:	df000b04 	addi	fp,sp,44
81142e18:	e13ff715 	stw	r4,-36(fp)
81142e1c:	e17ff815 	stw	r5,-32(fp)
81142e20:	e1bff915 	stw	r6,-28(fp)
81142e24:	e1fffa15 	stw	r7,-24(fp)
81142e28:	e1800517 	ldw	r6,20(fp)
81142e2c:	e1400617 	ldw	r5,24(fp)
81142e30:	e1000717 	ldw	r4,28(fp)
81142e34:	e0c00817 	ldw	r3,32(fp)
81142e38:	e0800917 	ldw	r2,36(fp)
81142e3c:	e1bffb0d 	sth	r6,-20(fp)
81142e40:	e17ffc05 	stb	r5,-16(fp)
81142e44:	e13ffd05 	stb	r4,-12(fp)
81142e48:	e0fffe0d 	sth	r3,-8(fp)
81142e4c:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81142e50:	e0bff717 	ldw	r2,-36(fp)
81142e54:	10c01217 	ldw	r3,72(r2)
81142e58:	e0800317 	ldw	r2,12(fp)
81142e5c:	18801936 	bltu	r3,r2,81142ec4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81142e60:	e13ff717 	ldw	r4,-36(fp)
81142e64:	20801317 	ldw	r2,76(r4)
81142e68:	20c01417 	ldw	r3,80(r4)
81142e6c:	e13ffe0b 	ldhu	r4,-8(fp)
81142e70:	213fffcc 	andi	r4,r4,65535
81142e74:	2015883a 	mov	r10,r4
81142e78:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81142e7c:	1ac01136 	bltu	r3,r11,81142ec4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81142e80:	58c0011e 	bne	r11,r3,81142e88 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81142e84:	12800f36 	bltu	r2,r10,81142ec4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81142e88:	e13ff717 	ldw	r4,-36(fp)
81142e8c:	20801317 	ldw	r2,76(r4)
81142e90:	20c01417 	ldw	r3,80(r4)
81142e94:	e13fff0b 	ldhu	r4,-4(fp)
81142e98:	213fffcc 	andi	r4,r4,65535
81142e9c:	2011883a 	mov	r8,r4
81142ea0:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81142ea4:	1a400736 	bltu	r3,r9,81142ec4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81142ea8:	48c0011e 	bne	r9,r3,81142eb0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81142eac:	12000536 	bltu	r2,r8,81142ec4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81142eb0:	e0bff717 	ldw	r2,-36(fp)
81142eb4:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81142eb8:	10803fcc 	andi	r2,r2,255
81142ebc:	10800060 	cmpeqi	r2,r2,1
81142ec0:	1000021e 	bne	r2,zero,81142ecc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81142ec4:	00bffa84 	movi	r2,-22
81142ec8:	00003106 	br	81142f90 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81142ecc:	e0bff817 	ldw	r2,-32(fp)
81142ed0:	e0fff917 	ldw	r3,-28(fp)
81142ed4:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81142ed8:	e0bff817 	ldw	r2,-32(fp)
81142edc:	e0fffa17 	ldw	r3,-24(fp)
81142ee0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81142ee4:	e0bff817 	ldw	r2,-32(fp)
81142ee8:	e0c00117 	ldw	r3,4(fp)
81142eec:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81142ef0:	e0bff817 	ldw	r2,-32(fp)
81142ef4:	e0c00217 	ldw	r3,8(fp)
81142ef8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81142efc:	e0bff817 	ldw	r2,-32(fp)
81142f00:	e0c00317 	ldw	r3,12(fp)
81142f04:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81142f08:	e0bff817 	ldw	r2,-32(fp)
81142f0c:	e0fffb0b 	ldhu	r3,-20(fp)
81142f10:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81142f14:	e0bff817 	ldw	r2,-32(fp)
81142f18:	e0fffc03 	ldbu	r3,-16(fp)
81142f1c:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81142f20:	e0bff817 	ldw	r2,-32(fp)
81142f24:	e0fffd03 	ldbu	r3,-12(fp)
81142f28:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81142f2c:	e0bff817 	ldw	r2,-32(fp)
81142f30:	e0fffe0b 	ldhu	r3,-8(fp)
81142f34:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81142f38:	e0bff817 	ldw	r2,-32(fp)
81142f3c:	e0ffff0b 	ldhu	r3,-4(fp)
81142f40:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81142f44:	e0bff817 	ldw	r2,-32(fp)
81142f48:	1019883a 	mov	r12,r2
81142f4c:	001b883a 	mov	r13,zero
81142f50:	e33ff515 	stw	r12,-44(fp)
81142f54:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81142f58:	e0fff517 	ldw	r3,-44(fp)
81142f5c:	e0bff817 	ldw	r2,-32(fp)
81142f60:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
81142f64:	e0fff617 	ldw	r3,-40(fp)
81142f68:	e0bff817 	ldw	r2,-32(fp)
81142f6c:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81142f70:	e0c00417 	ldw	r3,16(fp)
81142f74:	00900034 	movhi	r2,16384
81142f78:	10bfffc4 	addi	r2,r2,-1
81142f7c:	1884703a 	and	r2,r3,r2
81142f80:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81142f84:	e0bff817 	ldw	r2,-32(fp)
81142f88:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
81142f8c:	0005883a 	mov	r2,zero
}
81142f90:	e037883a 	mov	sp,fp
81142f94:	df000017 	ldw	fp,0(sp)
81142f98:	dec00104 	addi	sp,sp,4
81142f9c:	f800283a 	ret

81142fa0 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81142fa0:	defff804 	addi	sp,sp,-32
81142fa4:	de00012e 	bgeu	sp,et,81142fac <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81142fa8:	003b68fa 	trap	3
81142fac:	dfc00715 	stw	ra,28(sp)
81142fb0:	df000615 	stw	fp,24(sp)
81142fb4:	df000604 	addi	fp,sp,24
81142fb8:	e13ffc15 	stw	r4,-16(fp)
81142fbc:	e17ffd15 	stw	r5,-12(fp)
81142fc0:	e1bffe15 	stw	r6,-8(fp)
81142fc4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81142fc8:	e0800317 	ldw	r2,12(fp)
81142fcc:	d8800115 	stw	r2,4(sp)
81142fd0:	e0800217 	ldw	r2,8(fp)
81142fd4:	d8800015 	stw	r2,0(sp)
81142fd8:	e1ffff17 	ldw	r7,-4(fp)
81142fdc:	e1bffe17 	ldw	r6,-8(fp)
81142fe0:	e17ffd17 	ldw	r5,-12(fp)
81142fe4:	e13ffc17 	ldw	r4,-16(fp)
81142fe8:	1142d580 	call	81142d58 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81142fec:	e037883a 	mov	sp,fp
81142ff0:	dfc00117 	ldw	ra,4(sp)
81142ff4:	df000017 	ldw	fp,0(sp)
81142ff8:	dec00204 	addi	sp,sp,8
81142ffc:	f800283a 	ret

81143000 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143000:	defff804 	addi	sp,sp,-32
81143004:	de00012e 	bgeu	sp,et,8114300c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81143008:	003b68fa 	trap	3
8114300c:	dfc00715 	stw	ra,28(sp)
81143010:	df000615 	stw	fp,24(sp)
81143014:	df000604 	addi	fp,sp,24
81143018:	e13ffc15 	stw	r4,-16(fp)
8114301c:	e17ffd15 	stw	r5,-12(fp)
81143020:	e1bffe15 	stw	r6,-8(fp)
81143024:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81143028:	e0800217 	ldw	r2,8(fp)
8114302c:	d8800115 	stw	r2,4(sp)
81143030:	e0bfff17 	ldw	r2,-4(fp)
81143034:	d8800015 	stw	r2,0(sp)
81143038:	e1fffe17 	ldw	r7,-8(fp)
8114303c:	000d883a 	mov	r6,zero
81143040:	e17ffd17 	ldw	r5,-12(fp)
81143044:	e13ffc17 	ldw	r4,-16(fp)
81143048:	1142d580 	call	81142d58 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
8114304c:	e037883a 	mov	sp,fp
81143050:	dfc00117 	ldw	ra,4(sp)
81143054:	df000017 	ldw	fp,0(sp)
81143058:	dec00204 	addi	sp,sp,8
8114305c:	f800283a 	ret

81143060 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
81143060:	defff804 	addi	sp,sp,-32
81143064:	de00012e 	bgeu	sp,et,8114306c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
81143068:	003b68fa 	trap	3
8114306c:	dfc00715 	stw	ra,28(sp)
81143070:	df000615 	stw	fp,24(sp)
81143074:	df000604 	addi	fp,sp,24
81143078:	e13ffc15 	stw	r4,-16(fp)
8114307c:	e17ffd15 	stw	r5,-12(fp)
81143080:	e1bffe15 	stw	r6,-8(fp)
81143084:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81143088:	e0800217 	ldw	r2,8(fp)
8114308c:	d8800115 	stw	r2,4(sp)
81143090:	e0bfff17 	ldw	r2,-4(fp)
81143094:	d8800015 	stw	r2,0(sp)
81143098:	000f883a 	mov	r7,zero
8114309c:	e1bffe17 	ldw	r6,-8(fp)
811430a0:	e17ffd17 	ldw	r5,-12(fp)
811430a4:	e13ffc17 	ldw	r4,-16(fp)
811430a8:	1142d580 	call	81142d58 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
811430ac:	e037883a 	mov	sp,fp
811430b0:	dfc00117 	ldw	ra,4(sp)
811430b4:	df000017 	ldw	fp,0(sp)
811430b8:	dec00204 	addi	sp,sp,8
811430bc:	f800283a 	ret

811430c0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
811430c0:	deffee04 	addi	sp,sp,-72
811430c4:	de00012e 	bgeu	sp,et,811430cc <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
811430c8:	003b68fa 	trap	3
811430cc:	dfc01115 	stw	ra,68(sp)
811430d0:	df001015 	stw	fp,64(sp)
811430d4:	df001004 	addi	fp,sp,64
811430d8:	e13ff915 	stw	r4,-28(fp)
811430dc:	e17ffa15 	stw	r5,-24(fp)
811430e0:	e1bffb15 	stw	r6,-20(fp)
811430e4:	e1fffc15 	stw	r7,-16(fp)
811430e8:	e1000417 	ldw	r4,16(fp)
811430ec:	e0c00517 	ldw	r3,20(fp)
811430f0:	e0800617 	ldw	r2,24(fp)
811430f4:	e13ffd0d 	sth	r4,-12(fp)
811430f8:	e0fffe05 	stb	r3,-8(fp)
811430fc:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81143100:	e0bffd0b 	ldhu	r2,-12(fp)
81143104:	e0fffe03 	ldbu	r3,-8(fp)
81143108:	e13fff0b 	ldhu	r4,-4(fp)
8114310c:	d9000815 	stw	r4,32(sp)
81143110:	d8000715 	stw	zero,28(sp)
81143114:	d8c00615 	stw	r3,24(sp)
81143118:	d8000515 	stw	zero,20(sp)
8114311c:	d8800415 	stw	r2,16(sp)
81143120:	e0800317 	ldw	r2,12(fp)
81143124:	d8800315 	stw	r2,12(sp)
81143128:	e0800217 	ldw	r2,8(fp)
8114312c:	d8800215 	stw	r2,8(sp)
81143130:	e0bffc17 	ldw	r2,-16(fp)
81143134:	d8800115 	stw	r2,4(sp)
81143138:	e0bffb17 	ldw	r2,-20(fp)
8114313c:	d8800015 	stw	r2,0(sp)
81143140:	000f883a 	mov	r7,zero
81143144:	000d883a 	mov	r6,zero
81143148:	e17ffa17 	ldw	r5,-24(fp)
8114314c:	e13ff917 	ldw	r4,-28(fp)
81143150:	1142e040 	call	81142e04 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81143154:	e037883a 	mov	sp,fp
81143158:	dfc00117 	ldw	ra,4(sp)
8114315c:	df000017 	ldw	fp,0(sp)
81143160:	dec00204 	addi	sp,sp,8
81143164:	f800283a 	ret

81143168 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81143168:	deffee04 	addi	sp,sp,-72
8114316c:	de00012e 	bgeu	sp,et,81143174 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81143170:	003b68fa 	trap	3
81143174:	dfc01115 	stw	ra,68(sp)
81143178:	df001015 	stw	fp,64(sp)
8114317c:	df001004 	addi	fp,sp,64
81143180:	e13ff915 	stw	r4,-28(fp)
81143184:	e17ffa15 	stw	r5,-24(fp)
81143188:	e1bffb15 	stw	r6,-20(fp)
8114318c:	e1fffc15 	stw	r7,-16(fp)
81143190:	e1000417 	ldw	r4,16(fp)
81143194:	e0c00517 	ldw	r3,20(fp)
81143198:	e0800617 	ldw	r2,24(fp)
8114319c:	e13ffd0d 	sth	r4,-12(fp)
811431a0:	e0fffe05 	stb	r3,-8(fp)
811431a4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811431a8:	e0bffd0b 	ldhu	r2,-12(fp)
811431ac:	e0fffe03 	ldbu	r3,-8(fp)
811431b0:	e13fff0b 	ldhu	r4,-4(fp)
811431b4:	d8000815 	stw	zero,32(sp)
811431b8:	d9000715 	stw	r4,28(sp)
811431bc:	d8000615 	stw	zero,24(sp)
811431c0:	d8c00515 	stw	r3,20(sp)
811431c4:	d8800415 	stw	r2,16(sp)
811431c8:	e0800317 	ldw	r2,12(fp)
811431cc:	d8800315 	stw	r2,12(sp)
811431d0:	e0800217 	ldw	r2,8(fp)
811431d4:	d8800215 	stw	r2,8(sp)
811431d8:	d8000115 	stw	zero,4(sp)
811431dc:	d8000015 	stw	zero,0(sp)
811431e0:	e1fffc17 	ldw	r7,-16(fp)
811431e4:	e1bffb17 	ldw	r6,-20(fp)
811431e8:	e17ffa17 	ldw	r5,-24(fp)
811431ec:	e13ff917 	ldw	r4,-28(fp)
811431f0:	1142e040 	call	81142e04 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
811431f4:	e037883a 	mov	sp,fp
811431f8:	dfc00117 	ldw	ra,4(sp)
811431fc:	df000017 	ldw	fp,0(sp)
81143200:	dec00204 	addi	sp,sp,8
81143204:	f800283a 	ret

81143208 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81143208:	deffec04 	addi	sp,sp,-80
8114320c:	de00012e 	bgeu	sp,et,81143214 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81143210:	003b68fa 	trap	3
81143214:	dfc01315 	stw	ra,76(sp)
81143218:	df001215 	stw	fp,72(sp)
8114321c:	df001204 	addi	fp,sp,72
81143220:	e13ff715 	stw	r4,-36(fp)
81143224:	e17ff815 	stw	r5,-32(fp)
81143228:	e1bff915 	stw	r6,-28(fp)
8114322c:	e1fffa15 	stw	r7,-24(fp)
81143230:	e1800617 	ldw	r6,24(fp)
81143234:	e1400717 	ldw	r5,28(fp)
81143238:	e1000817 	ldw	r4,32(fp)
8114323c:	e0c00917 	ldw	r3,36(fp)
81143240:	e0800a17 	ldw	r2,40(fp)
81143244:	e1bffb0d 	sth	r6,-20(fp)
81143248:	e17ffc05 	stb	r5,-16(fp)
8114324c:	e13ffd05 	stb	r4,-12(fp)
81143250:	e0fffe0d 	sth	r3,-8(fp)
81143254:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81143258:	e0bffb0b 	ldhu	r2,-20(fp)
8114325c:	e0fffc03 	ldbu	r3,-16(fp)
81143260:	e13ffd03 	ldbu	r4,-12(fp)
81143264:	e17ffe0b 	ldhu	r5,-8(fp)
81143268:	e1bfff0b 	ldhu	r6,-4(fp)
8114326c:	d9800815 	stw	r6,32(sp)
81143270:	d9400715 	stw	r5,28(sp)
81143274:	d9000615 	stw	r4,24(sp)
81143278:	d8c00515 	stw	r3,20(sp)
8114327c:	d8800415 	stw	r2,16(sp)
81143280:	e0800517 	ldw	r2,20(fp)
81143284:	d8800315 	stw	r2,12(sp)
81143288:	e0800417 	ldw	r2,16(fp)
8114328c:	d8800215 	stw	r2,8(sp)
81143290:	e0800317 	ldw	r2,12(fp)
81143294:	d8800115 	stw	r2,4(sp)
81143298:	e0800217 	ldw	r2,8(fp)
8114329c:	d8800015 	stw	r2,0(sp)
811432a0:	e1fffa17 	ldw	r7,-24(fp)
811432a4:	e1bff917 	ldw	r6,-28(fp)
811432a8:	e17ff817 	ldw	r5,-32(fp)
811432ac:	e13ff717 	ldw	r4,-36(fp)
811432b0:	1142e040 	call	81142e04 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
811432b4:	e037883a 	mov	sp,fp
811432b8:	dfc00117 	ldw	ra,4(sp)
811432bc:	df000017 	ldw	fp,0(sp)
811432c0:	dec00204 	addi	sp,sp,8
811432c4:	f800283a 	ret

811432c8 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
811432c8:	defffc04 	addi	sp,sp,-16
811432cc:	de00012e 	bgeu	sp,et,811432d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
811432d0:	003b68fa 	trap	3
811432d4:	df000315 	stw	fp,12(sp)
811432d8:	df000304 	addi	fp,sp,12
811432dc:	e13ffe15 	stw	r4,-8(fp)
811432e0:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
811432e4:	e0bfff17 	ldw	r2,-4(fp)
811432e8:	1000021e 	bne	r2,zero,811432f4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
811432ec:	00bffa84 	movi	r2,-22
811432f0:	00002f06 	br	811433b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
811432f4:	e0bfff17 	ldw	r2,-4(fp)
811432f8:	10c00317 	ldw	r3,12(r2)
811432fc:	e0bfff17 	ldw	r2,-4(fp)
81143300:	18800226 	beq	r3,r2,8114330c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81143304:	00bffa84 	movi	r2,-22
81143308:	00002906 	br	811433b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114330c:	e0bffe17 	ldw	r2,-8(fp)
81143310:	10800017 	ldw	r2,0(r2)
81143314:	1000051e 	bne	r2,zero,8114332c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81143318:	e0bffe17 	ldw	r2,-8(fp)
8114331c:	e0ffff17 	ldw	r3,-4(fp)
81143320:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81143324:	0005883a 	mov	r2,zero
81143328:	00002106 	br	811433b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8114332c:	e0bffe17 	ldw	r2,-8(fp)
81143330:	10c00017 	ldw	r3,0(r2)
81143334:	e0bfff17 	ldw	r2,-4(fp)
81143338:	1880021e 	bne	r3,r2,81143344 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114333c:	00bffa84 	movi	r2,-22
81143340:	00001b06 	br	811433b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81143344:	e0bffe17 	ldw	r2,-8(fp)
81143348:	10800017 	ldw	r2,0(r2)
8114334c:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81143350:	00000906 	br	81143378 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81143354:	e0bffd17 	ldw	r2,-12(fp)
81143358:	10c00317 	ldw	r3,12(r2)
8114335c:	e0bfff17 	ldw	r2,-4(fp)
81143360:	1880021e 	bne	r3,r2,8114336c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81143364:	00bffa84 	movi	r2,-22
81143368:	00001106 	br	811433b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114336c:	e0bffd17 	ldw	r2,-12(fp)
81143370:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81143374:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81143378:	e0bffd17 	ldw	r2,-12(fp)
8114337c:	10800317 	ldw	r2,12(r2)
81143380:	e0fffe17 	ldw	r3,-8(fp)
81143384:	18c00017 	ldw	r3,0(r3)
81143388:	10fff21e 	bne	r2,r3,81143354 <__reset+0xfb123354>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114338c:	e0ffff17 	ldw	r3,-4(fp)
81143390:	e0bffd17 	ldw	r2,-12(fp)
81143394:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81143398:	e0bffe17 	ldw	r2,-8(fp)
8114339c:	10800017 	ldw	r2,0(r2)
811433a0:	1007883a 	mov	r3,r2
811433a4:	e0bfff17 	ldw	r2,-4(fp)
811433a8:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
811433ac:	0005883a 	mov	r2,zero
}
811433b0:	e037883a 	mov	sp,fp
811433b4:	df000017 	ldw	fp,0(sp)
811433b8:	dec00104 	addi	sp,sp,4
811433bc:	f800283a 	ret

811433c0 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
811433c0:	defff804 	addi	sp,sp,-32
811433c4:	de00012e 	bgeu	sp,et,811433cc <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
811433c8:	003b68fa 	trap	3
811433cc:	df000715 	stw	fp,28(sp)
811433d0:	df000704 	addi	fp,sp,28
811433d4:	e13ffe15 	stw	r4,-8(fp)
811433d8:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
811433dc:	e13fff17 	ldw	r4,-4(fp)
811433e0:	2000021e 	bne	r4,zero,811433ec <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
811433e4:	00bffa84 	movi	r2,-22
811433e8:	00005906 	br	81143550 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
811433ec:	e13fff17 	ldw	r4,-4(fp)
811433f0:	2015883a 	mov	r10,r4
811433f4:	0017883a 	mov	r11,zero
811433f8:	e2bffc15 	stw	r10,-16(fp)
811433fc:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81143400:	e13fff17 	ldw	r4,-4(fp)
81143404:	21400317 	ldw	r5,12(r4)
81143408:	e13ffc17 	ldw	r4,-16(fp)
8114340c:	29000626 	beq	r5,r4,81143428 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81143410:	e13fff17 	ldw	r4,-4(fp)
81143414:	21400b17 	ldw	r5,44(r4)
81143418:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114341c:	29000226 	beq	r5,r4,81143428 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81143420:	00bffa84 	movi	r2,-22
81143424:	00004a06 	br	81143550 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81143428:	e13ffe17 	ldw	r4,-8(fp)
8114342c:	21000017 	ldw	r4,0(r4)
81143430:	2000051e 	bne	r4,zero,81143448 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81143434:	e0bffe17 	ldw	r2,-8(fp)
81143438:	e0ffff17 	ldw	r3,-4(fp)
8114343c:	10c00015 	stw	r3,0(r2)
		return 0;
81143440:	0005883a 	mov	r2,zero
81143444:	00004206 	br	81143550 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81143448:	e13ffe17 	ldw	r4,-8(fp)
8114344c:	21400017 	ldw	r5,0(r4)
81143450:	e13fff17 	ldw	r4,-4(fp)
81143454:	2900021e 	bne	r5,r4,81143460 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81143458:	00bffa84 	movi	r2,-22
8114345c:	00003c06 	br	81143550 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81143460:	e13ffe17 	ldw	r4,-8(fp)
81143464:	21000017 	ldw	r4,0(r4)
81143468:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8114346c:	e13ffe17 	ldw	r4,-8(fp)
81143470:	21000017 	ldw	r4,0(r4)
81143474:	2011883a 	mov	r8,r4
81143478:	0013883a 	mov	r9,zero
8114347c:	e23ffa15 	stw	r8,-24(fp)
81143480:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81143484:	00001806 	br	811434e8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
81143488:	e13fff17 	ldw	r4,-4(fp)
8114348c:	200d883a 	mov	r6,r4
81143490:	000f883a 	mov	r7,zero
81143494:	e1bffc15 	stw	r6,-16(fp)
81143498:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114349c:	e13ff917 	ldw	r4,-28(fp)
811434a0:	21400317 	ldw	r5,12(r4)
811434a4:	e13ffc17 	ldw	r4,-16(fp)
811434a8:	2900061e 	bne	r5,r4,811434c4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
811434ac:	e13ff917 	ldw	r4,-28(fp)
811434b0:	21400b17 	ldw	r5,44(r4)
811434b4:	e13ffd17 	ldw	r4,-12(fp)
811434b8:	2900021e 	bne	r5,r4,811434c4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811434bc:	00bffa84 	movi	r2,-22
811434c0:	00002306 	br	81143550 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811434c4:	e13ff917 	ldw	r4,-28(fp)
811434c8:	21000317 	ldw	r4,12(r4)
811434cc:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811434d0:	e13ff917 	ldw	r4,-28(fp)
811434d4:	21000b17 	ldw	r4,44(r4)
811434d8:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811434dc:	e13ffc17 	ldw	r4,-16(fp)
811434e0:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811434e4:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811434e8:	e13ff917 	ldw	r4,-28(fp)
811434ec:	21400317 	ldw	r5,12(r4)
811434f0:	e13ffa17 	ldw	r4,-24(fp)
811434f4:	29000426 	beq	r5,r4,81143508 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
811434f8:	e13ff917 	ldw	r4,-28(fp)
811434fc:	21400b17 	ldw	r5,44(r4)
81143500:	e13ffb17 	ldw	r4,-20(fp)
81143504:	293fe01e 	bne	r5,r4,81143488 <__reset+0xfb123488>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81143508:	e13fff17 	ldw	r4,-4(fp)
8114350c:	2005883a 	mov	r2,r4
81143510:	0007883a 	mov	r3,zero
81143514:	e0bffc15 	stw	r2,-16(fp)
81143518:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8114351c:	e0fffc17 	ldw	r3,-16(fp)
81143520:	e0bff917 	ldw	r2,-28(fp)
81143524:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81143528:	e0fffd17 	ldw	r3,-12(fp)
8114352c:	e0bff917 	ldw	r2,-28(fp)
81143530:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81143534:	e0fffa17 	ldw	r3,-24(fp)
81143538:	e0bfff17 	ldw	r2,-4(fp)
8114353c:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
81143540:	e0fffb17 	ldw	r3,-20(fp)
81143544:	e0bfff17 	ldw	r2,-4(fp)
81143548:	10c00b15 	stw	r3,44(r2)
	return 0;
8114354c:	0005883a 	mov	r2,zero
}
81143550:	e037883a 	mov	sp,fp
81143554:	df000017 	ldw	fp,0(sp)
81143558:	dec00104 	addi	sp,sp,4
8114355c:	f800283a 	ret

81143560 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
81143560:	defffc04 	addi	sp,sp,-16
81143564:	de00012e 	bgeu	sp,et,8114356c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
81143568:	003b68fa 	trap	3
8114356c:	df000315 	stw	fp,12(sp)
81143570:	df000304 	addi	fp,sp,12
81143574:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81143578:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114357c:	e0bfff17 	ldw	r2,-4(fp)
81143580:	1000021e 	bne	r2,zero,8114358c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81143584:	00bffa84 	movi	r2,-22
81143588:	00001906 	br	811435f0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114358c:	e0bfff17 	ldw	r2,-4(fp)
81143590:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81143594:	00000a06 	br	811435c0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81143598:	e0bffd17 	ldw	r2,-12(fp)
8114359c:	10800717 	ldw	r2,28(r2)
811435a0:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811435a4:	e0bffe17 	ldw	r2,-8(fp)
811435a8:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811435ac:	e0bffd17 	ldw	r2,-12(fp)
811435b0:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811435b4:	e0bffd17 	ldw	r2,-12(fp)
811435b8:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
811435bc:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811435c0:	e0bffd17 	ldw	r2,-12(fp)
811435c4:	10c00317 	ldw	r3,12(r2)
811435c8:	e0bfff17 	ldw	r2,-4(fp)
811435cc:	18bff21e 	bne	r3,r2,81143598 <__reset+0xfb123598>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
811435d0:	e0bffd17 	ldw	r2,-12(fp)
811435d4:	10800717 	ldw	r2,28(r2)
811435d8:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811435dc:	e0bffe17 	ldw	r2,-8(fp)
811435e0:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811435e4:	e0bffd17 	ldw	r2,-12(fp)
811435e8:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
811435ec:	0005883a 	mov	r2,zero
}
811435f0:	e037883a 	mov	sp,fp
811435f4:	df000017 	ldw	fp,0(sp)
811435f8:	dec00104 	addi	sp,sp,4
811435fc:	f800283a 	ret

81143600 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81143600:	defff804 	addi	sp,sp,-32
81143604:	de00012e 	bgeu	sp,et,8114360c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81143608:	003b68fa 	trap	3
8114360c:	df000715 	stw	fp,28(sp)
81143610:	df000704 	addi	fp,sp,28
81143614:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81143618:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114361c:	e13fff17 	ldw	r4,-4(fp)
81143620:	2000021e 	bne	r4,zero,8114362c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81143624:	00bffa84 	movi	r2,-22
81143628:	00002806 	br	811436cc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114362c:	e13fff17 	ldw	r4,-4(fp)
81143630:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81143634:	e13fff17 	ldw	r4,-4(fp)
81143638:	2005883a 	mov	r2,r4
8114363c:	0007883a 	mov	r3,zero
81143640:	e0bffb15 	stw	r2,-20(fp)
81143644:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81143648:	00001006 	br	8114368c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114364c:	e0bff917 	ldw	r2,-28(fp)
81143650:	10800f17 	ldw	r2,60(r2)
81143654:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81143658:	e0bffa17 	ldw	r2,-24(fp)
8114365c:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81143660:	e0bff917 	ldw	r2,-28(fp)
81143664:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81143668:	e0bff917 	ldw	r2,-28(fp)
8114366c:	10800317 	ldw	r2,12(r2)
81143670:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81143674:	e0bff917 	ldw	r2,-28(fp)
81143678:	10800b17 	ldw	r2,44(r2)
8114367c:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81143680:	e0bffd17 	ldw	r2,-12(fp)
81143684:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81143688:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114368c:	e0bff917 	ldw	r2,-28(fp)
81143690:	10c00317 	ldw	r3,12(r2)
81143694:	e0bffb17 	ldw	r2,-20(fp)
81143698:	18800426 	beq	r3,r2,811436ac <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114369c:	e0bff917 	ldw	r2,-28(fp)
811436a0:	10c00b17 	ldw	r3,44(r2)
811436a4:	e0bffc17 	ldw	r2,-16(fp)
811436a8:	18bfe81e 	bne	r3,r2,8114364c <__reset+0xfb12364c>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
811436ac:	e0bff917 	ldw	r2,-28(fp)
811436b0:	10800f17 	ldw	r2,60(r2)
811436b4:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811436b8:	e0bffa17 	ldw	r2,-24(fp)
811436bc:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811436c0:	e0bff917 	ldw	r2,-28(fp)
811436c4:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
811436c8:	0005883a 	mov	r2,zero
}
811436cc:	e037883a 	mov	sp,fp
811436d0:	df000017 	ldw	fp,0(sp)
811436d4:	dec00104 	addi	sp,sp,4
811436d8:	f800283a 	ret

811436dc <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811436dc:	deffeb04 	addi	sp,sp,-84
811436e0:	de00012e 	bgeu	sp,et,811436e8 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
811436e4:	003b68fa 	trap	3
811436e8:	dfc01415 	stw	ra,80(sp)
811436ec:	df001315 	stw	fp,76(sp)
811436f0:	df001304 	addi	fp,sp,76
811436f4:	e13ffb15 	stw	r4,-20(fp)
811436f8:	e17ffc15 	stw	r5,-16(fp)
811436fc:	e1bffd15 	stw	r6,-12(fp)
81143700:	3807883a 	mov	r3,r7
81143704:	e0800217 	ldw	r2,8(fp)
81143708:	e0fffe05 	stb	r3,-8(fp)
8114370c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81143710:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81143714:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81143718:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114371c:	e0bffc17 	ldw	r2,-16(fp)
81143720:	e0bff815 	stw	r2,-32(fp)
81143724:	e0bffd17 	ldw	r2,-12(fp)
81143728:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114372c:	e0bffb17 	ldw	r2,-20(fp)
81143730:	10801817 	ldw	r2,96(r2)
81143734:	e0bff615 	stw	r2,-40(fp)
81143738:	e03ff70d 	sth	zero,-36(fp)
8114373c:	e0bff70b 	ldhu	r2,-36(fp)
81143740:	e0fffa04 	addi	r3,fp,-24
81143744:	180d883a 	mov	r6,r3
81143748:	100b883a 	mov	r5,r2
8114374c:	e13ff617 	ldw	r4,-40(fp)
81143750:	1138a3c0 	call	81138a3c <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
81143754:	e0bffb17 	ldw	r2,-20(fp)
81143758:	10800617 	ldw	r2,24(r2)
8114375c:	10800037 	ldwio	r2,0(r2)
81143760:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
81143764:	e0bfed17 	ldw	r2,-76(fp)
81143768:	1080004c 	andi	r2,r2,1
8114376c:	10000626 	beq	r2,zero,81143788 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
81143770:	e0bffb17 	ldw	r2,-20(fp)
81143774:	10801817 	ldw	r2,96(r2)
81143778:	1009883a 	mov	r4,r2
8114377c:	1138dc40 	call	81138dc4 <OSSemPost>
		return -EBUSY;
81143780:	00bffc04 	movi	r2,-16
81143784:	00009606 	br	811439e0 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81143788:	00800804 	movi	r2,32
8114378c:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143790:	0005303a 	rdctl	r2,status
81143794:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143798:	e0fff217 	ldw	r3,-56(fp)
8114379c:	00bfff84 	movi	r2,-2
811437a0:	1884703a 	and	r2,r3,r2
811437a4:	1001703a 	wrctl	status,r2
  
  return context;
811437a8:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811437ac:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811437b0:	e0bffb17 	ldw	r2,-20(fp)
811437b4:	10800317 	ldw	r2,12(r2)
811437b8:	10800104 	addi	r2,r2,4
811437bc:	e0ffee17 	ldw	r3,-72(fp)
811437c0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
811437c4:	e0bffb17 	ldw	r2,-20(fp)
811437c8:	10800317 	ldw	r2,12(r2)
811437cc:	e0fffb17 	ldw	r3,-20(fp)
811437d0:	18c00317 	ldw	r3,12(r3)
811437d4:	18c00037 	ldwio	r3,0(r3)
811437d8:	10c00035 	stwio	r3,0(r2)
811437dc:	e0bfef17 	ldw	r2,-68(fp)
811437e0:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811437e4:	e0bff017 	ldw	r2,-64(fp)
811437e8:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
811437ec:	e0bffb17 	ldw	r2,-20(fp)
811437f0:	10800b17 	ldw	r2,44(r2)
811437f4:	10002326 	beq	r2,zero,81143884 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
811437f8:	e0bffb17 	ldw	r2,-20(fp)
811437fc:	10c00d17 	ldw	r3,52(r2)
81143800:	e0bfee17 	ldw	r2,-72(fp)
81143804:	1884b03a 	or	r2,r3,r2
81143808:	10800514 	ori	r2,r2,20
8114380c:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81143810:	e0ffee17 	ldw	r3,-72(fp)
81143814:	00bff7c4 	movi	r2,-33
81143818:	1884703a 	and	r2,r3,r2
8114381c:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81143820:	e0bfed17 	ldw	r2,-76(fp)
81143824:	10800214 	ori	r2,r2,8
81143828:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114382c:	0005303a 	rdctl	r2,status
81143830:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143834:	e0fff417 	ldw	r3,-48(fp)
81143838:	00bfff84 	movi	r2,-2
8114383c:	1884703a 	and	r2,r3,r2
81143840:	1001703a 	wrctl	status,r2
  
  return context;
81143844:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81143848:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114384c:	e0bffb17 	ldw	r2,-20(fp)
81143850:	10800317 	ldw	r2,12(r2)
81143854:	10800104 	addi	r2,r2,4
81143858:	e0ffee17 	ldw	r3,-72(fp)
8114385c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81143860:	e0bffb17 	ldw	r2,-20(fp)
81143864:	10800617 	ldw	r2,24(r2)
81143868:	e0ffed17 	ldw	r3,-76(fp)
8114386c:	10c00035 	stwio	r3,0(r2)
81143870:	e0bfef17 	ldw	r2,-68(fp)
81143874:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143878:	e0bff117 	ldw	r2,-60(fp)
8114387c:	1001703a 	wrctl	status,r2
81143880:	00002306 	br	81143910 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81143884:	e0bffb17 	ldw	r2,-20(fp)
81143888:	10c00d17 	ldw	r3,52(r2)
8114388c:	e0bfee17 	ldw	r2,-72(fp)
81143890:	1884b03a 	or	r2,r3,r2
81143894:	10800114 	ori	r2,r2,4
81143898:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114389c:	e0ffee17 	ldw	r3,-72(fp)
811438a0:	00bff3c4 	movi	r2,-49
811438a4:	1884703a 	and	r2,r3,r2
811438a8:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
811438ac:	e0ffed17 	ldw	r3,-76(fp)
811438b0:	00bffdc4 	movi	r2,-9
811438b4:	1884703a 	and	r2,r3,r2
811438b8:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811438bc:	0005303a 	rdctl	r2,status
811438c0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811438c4:	e0fff517 	ldw	r3,-44(fp)
811438c8:	00bfff84 	movi	r2,-2
811438cc:	1884703a 	and	r2,r3,r2
811438d0:	1001703a 	wrctl	status,r2
  
  return context;
811438d4:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
811438d8:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811438dc:	e0bffb17 	ldw	r2,-20(fp)
811438e0:	10800317 	ldw	r2,12(r2)
811438e4:	10800104 	addi	r2,r2,4
811438e8:	e0ffee17 	ldw	r3,-72(fp)
811438ec:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811438f0:	e0bffb17 	ldw	r2,-20(fp)
811438f4:	10800617 	ldw	r2,24(r2)
811438f8:	e0ffed17 	ldw	r3,-76(fp)
811438fc:	10c00035 	stwio	r3,0(r2)
81143900:	e0bfef17 	ldw	r2,-68(fp)
81143904:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143908:	e0bff317 	ldw	r2,-52(fp)
8114390c:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81143910:	e0bffb17 	ldw	r2,-20(fp)
81143914:	10800617 	ldw	r2,24(r2)
81143918:	10800104 	addi	r2,r2,4
8114391c:	e0fff817 	ldw	r3,-32(fp)
81143920:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81143924:	e0bffb17 	ldw	r2,-20(fp)
81143928:	10800617 	ldw	r2,24(r2)
8114392c:	10800204 	addi	r2,r2,8
81143930:	e0fff917 	ldw	r3,-28(fp)
81143934:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81143938:	e0bffe03 	ldbu	r2,-8(fp)
8114393c:	10000426 	beq	r2,zero,81143950 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81143940:	e0bfed17 	ldw	r2,-76(fp)
81143944:	10800414 	ori	r2,r2,16
81143948:	e0bfed15 	stw	r2,-76(fp)
8114394c:	00000406 	br	81143960 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81143950:	e0ffed17 	ldw	r3,-76(fp)
81143954:	00bffbc4 	movi	r2,-17
81143958:	1884703a 	and	r2,r3,r2
8114395c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81143960:	e0bfff03 	ldbu	r2,-4(fp)
81143964:	10000e26 	beq	r2,zero,811439a0 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81143968:	e0bfed17 	ldw	r2,-76(fp)
8114396c:	10800094 	ori	r2,r2,2
81143970:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81143974:	e0bffb17 	ldw	r2,-20(fp)
81143978:	10800617 	ldw	r2,24(r2)
8114397c:	10800304 	addi	r2,r2,12
81143980:	10800037 	ldwio	r2,0(r2)
81143984:	10000a1e 	bne	r2,zero,811439b0 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81143988:	e0bffb17 	ldw	r2,-20(fp)
8114398c:	10800617 	ldw	r2,24(r2)
81143990:	10800304 	addi	r2,r2,12
81143994:	00c03fc4 	movi	r3,255
81143998:	10c00035 	stwio	r3,0(r2)
8114399c:	00000406 	br	811439b0 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
811439a0:	e0ffed17 	ldw	r3,-76(fp)
811439a4:	00bfff44 	movi	r2,-3
811439a8:	1884703a 	and	r2,r3,r2
811439ac:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
811439b0:	e0bfed17 	ldw	r2,-76(fp)
811439b4:	10800054 	ori	r2,r2,1
811439b8:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811439bc:	e0bffb17 	ldw	r2,-20(fp)
811439c0:	10800617 	ldw	r2,24(r2)
811439c4:	e0ffed17 	ldw	r3,-76(fp)
811439c8:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
811439cc:	e0bffb17 	ldw	r2,-20(fp)
811439d0:	10801817 	ldw	r2,96(r2)
811439d4:	1009883a 	mov	r4,r2
811439d8:	1138dc40 	call	81138dc4 <OSSemPost>
	 
	 return 0;
811439dc:	0005883a 	mov	r2,zero
}
811439e0:	e037883a 	mov	sp,fp
811439e4:	dfc00117 	ldw	ra,4(sp)
811439e8:	df000017 	ldw	fp,0(sp)
811439ec:	dec00204 	addi	sp,sp,8
811439f0:	f800283a 	ret

811439f4 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
811439f4:	defff704 	addi	sp,sp,-36
811439f8:	de00012e 	bgeu	sp,et,81143a00 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
811439fc:	003b68fa 	trap	3
81143a00:	dfc00815 	stw	ra,32(sp)
81143a04:	df000715 	stw	fp,28(sp)
81143a08:	dc400615 	stw	r17,24(sp)
81143a0c:	dc000515 	stw	r16,20(sp)
81143a10:	df000704 	addi	fp,sp,28
81143a14:	e13ffa15 	stw	r4,-24(fp)
81143a18:	e17ffb15 	stw	r5,-20(fp)
81143a1c:	3007883a 	mov	r3,r6
81143a20:	3805883a 	mov	r2,r7
81143a24:	e0fffc05 	stb	r3,-16(fp)
81143a28:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81143a2c:	e13ffb17 	ldw	r4,-20(fp)
81143a30:	11435600 	call	81143560 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81143a34:	10000226 	beq	r2,zero,81143a40 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81143a38:	00bffa84 	movi	r2,-22
81143a3c:	00000b06 	br	81143a6c <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81143a40:	e0bffb17 	ldw	r2,-20(fp)
81143a44:	1021883a 	mov	r16,r2
81143a48:	0023883a 	mov	r17,zero
81143a4c:	e0fffc03 	ldbu	r3,-16(fp)
81143a50:	e0bffd03 	ldbu	r2,-12(fp)
81143a54:	d8800015 	stw	r2,0(sp)
81143a58:	180f883a 	mov	r7,r3
81143a5c:	800b883a 	mov	r5,r16
81143a60:	880d883a 	mov	r6,r17
81143a64:	e13ffa17 	ldw	r4,-24(fp)
81143a68:	11436dc0 	call	811436dc <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81143a6c:	e6fffe04 	addi	sp,fp,-8
81143a70:	dfc00317 	ldw	ra,12(sp)
81143a74:	df000217 	ldw	fp,8(sp)
81143a78:	dc400117 	ldw	r17,4(sp)
81143a7c:	dc000017 	ldw	r16,0(sp)
81143a80:	dec00404 	addi	sp,sp,16
81143a84:	f800283a 	ret

81143a88 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81143a88:	defff704 	addi	sp,sp,-36
81143a8c:	de00012e 	bgeu	sp,et,81143a94 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81143a90:	003b68fa 	trap	3
81143a94:	dfc00815 	stw	ra,32(sp)
81143a98:	df000715 	stw	fp,28(sp)
81143a9c:	dc400615 	stw	r17,24(sp)
81143aa0:	dc000515 	stw	r16,20(sp)
81143aa4:	df000704 	addi	fp,sp,28
81143aa8:	e13ffa15 	stw	r4,-24(fp)
81143aac:	e17ffb15 	stw	r5,-20(fp)
81143ab0:	3007883a 	mov	r3,r6
81143ab4:	3805883a 	mov	r2,r7
81143ab8:	e0fffc05 	stb	r3,-16(fp)
81143abc:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81143ac0:	e13ffb17 	ldw	r4,-20(fp)
81143ac4:	11436000 	call	81143600 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81143ac8:	10000226 	beq	r2,zero,81143ad4 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81143acc:	00bffa84 	movi	r2,-22
81143ad0:	00000b06 	br	81143b00 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81143ad4:	e0bffb17 	ldw	r2,-20(fp)
81143ad8:	1021883a 	mov	r16,r2
81143adc:	0023883a 	mov	r17,zero
81143ae0:	e0fffc03 	ldbu	r3,-16(fp)
81143ae4:	e0bffd03 	ldbu	r2,-12(fp)
81143ae8:	d8800015 	stw	r2,0(sp)
81143aec:	180f883a 	mov	r7,r3
81143af0:	800b883a 	mov	r5,r16
81143af4:	880d883a 	mov	r6,r17
81143af8:	e13ffa17 	ldw	r4,-24(fp)
81143afc:	11436dc0 	call	811436dc <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81143b00:	e6fffe04 	addi	sp,fp,-8
81143b04:	dfc00317 	ldw	ra,12(sp)
81143b08:	df000217 	ldw	fp,8(sp)
81143b0c:	dc400117 	ldw	r17,4(sp)
81143b10:	dc000017 	ldw	r16,0(sp)
81143b14:	dec00404 	addi	sp,sp,16
81143b18:	f800283a 	ret

81143b1c <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81143b1c:	defffc04 	addi	sp,sp,-16
81143b20:	de00012e 	bgeu	sp,et,81143b28 <alt_msgdma_open+0xc>
81143b24:	003b68fa 	trap	3
81143b28:	dfc00315 	stw	ra,12(sp)
81143b2c:	df000215 	stw	fp,8(sp)
81143b30:	df000204 	addi	fp,sp,8
81143b34:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81143b38:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81143b3c:	d1603504 	addi	r5,gp,-32556
81143b40:	e13fff17 	ldw	r4,-4(fp)
81143b44:	11440c00 	call	811440c0 <alt_find_dev>
81143b48:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81143b4c:	e0bffe17 	ldw	r2,-8(fp)
81143b50:	1000041e 	bne	r2,zero,81143b64 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81143b54:	1141d800 	call	81141d80 <alt_get_errno>
81143b58:	1007883a 	mov	r3,r2
81143b5c:	008004c4 	movi	r2,19
81143b60:	18800015 	stw	r2,0(r3)
    }

    return dev;
81143b64:	e0bffe17 	ldw	r2,-8(fp)
}
81143b68:	e037883a 	mov	sp,fp
81143b6c:	dfc00117 	ldw	ra,4(sp)
81143b70:	df000017 	ldw	fp,0(sp)
81143b74:	dec00204 	addi	sp,sp,8
81143b78:	f800283a 	ret

81143b7c <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81143b7c:	defff604 	addi	sp,sp,-40
81143b80:	de00012e 	bgeu	sp,et,81143b88 <alt_msgdma_init+0xc>
81143b84:	003b68fa 	trap	3
81143b88:	dfc00915 	stw	ra,36(sp)
81143b8c:	df000815 	stw	fp,32(sp)
81143b90:	df000804 	addi	fp,sp,32
81143b94:	e13ffd15 	stw	r4,-12(fp)
81143b98:	e17ffe15 	stw	r5,-8(fp)
81143b9c:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81143ba0:	e0bffd17 	ldw	r2,-12(fp)
81143ba4:	10801783 	ldbu	r2,94(r2)
81143ba8:	10803fcc 	andi	r2,r2,255
81143bac:	10000b26 	beq	r2,zero,81143bdc <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81143bb0:	e0bffd17 	ldw	r2,-12(fp)
81143bb4:	10800617 	ldw	r2,24(r2)
81143bb8:	00c00104 	movi	r3,4
81143bbc:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81143bc0:	0001883a 	nop
81143bc4:	e0bffd17 	ldw	r2,-12(fp)
81143bc8:	10800617 	ldw	r2,24(r2)
81143bcc:	10800037 	ldwio	r2,0(r2)
81143bd0:	1080010c 	andi	r2,r2,4
81143bd4:	1005d0ba 	srai	r2,r2,2
81143bd8:	103ffa1e 	bne	r2,zero,81143bc4 <__reset+0xfb123bc4>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81143bdc:	e0bffd17 	ldw	r2,-12(fp)
81143be0:	10800317 	ldw	r2,12(r2)
81143be4:	10800104 	addi	r2,r2,4
81143be8:	00c00084 	movi	r3,2
81143bec:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81143bf0:	0001883a 	nop
81143bf4:	e0bffd17 	ldw	r2,-12(fp)
81143bf8:	10800317 	ldw	r2,12(r2)
81143bfc:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81143c00:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81143c04:	103ffb1e 	bne	r2,zero,81143bf4 <__reset+0xfb123bf4>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81143c08:	e0bffd17 	ldw	r2,-12(fp)
81143c0c:	10800317 	ldw	r2,12(r2)
81143c10:	10800104 	addi	r2,r2,4
81143c14:	10800037 	ldwio	r2,0(r2)
81143c18:	1007883a 	mov	r3,r2
81143c1c:	00bffbc4 	movi	r2,-17
81143c20:	1884703a 	and	r2,r3,r2
81143c24:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81143c28:	e0bff917 	ldw	r2,-28(fp)
81143c2c:	10800814 	ori	r2,r2,32
81143c30:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81143c34:	e0bffd17 	ldw	r2,-12(fp)
81143c38:	10800317 	ldw	r2,12(r2)
81143c3c:	10800104 	addi	r2,r2,4
81143c40:	e0fff917 	ldw	r3,-28(fp)
81143c44:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81143c48:	e0bffd17 	ldw	r2,-12(fp)
81143c4c:	10800317 	ldw	r2,12(r2)
81143c50:	e0fffd17 	ldw	r3,-12(fp)
81143c54:	18c00317 	ldw	r3,12(r3)
81143c58:	18c00037 	ldwio	r3,0(r3)
81143c5c:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81143c60:	e0bffd17 	ldw	r2,-12(fp)
81143c64:	10801783 	ldbu	r2,94(r2)
81143c68:	10803fcc 	andi	r2,r2,255
81143c6c:	10000826 	beq	r2,zero,81143c90 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81143c70:	e0bffd17 	ldw	r2,-12(fp)
81143c74:	10800617 	ldw	r2,24(r2)
81143c78:	10800404 	addi	r2,r2,16
81143c7c:	e0fffd17 	ldw	r3,-12(fp)
81143c80:	18c00617 	ldw	r3,24(r3)
81143c84:	18c00404 	addi	r3,r3,16
81143c88:	18c00037 	ldwio	r3,0(r3)
81143c8c:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81143c90:	d1603504 	addi	r5,gp,-32556
81143c94:	e13ffd17 	ldw	r4,-12(fp)
81143c98:	11440140 	call	81144014 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81143c9c:	e0bffd17 	ldw	r2,-12(fp)
81143ca0:	10801804 	addi	r2,r2,96
81143ca4:	e0bffb15 	stw	r2,-20(fp)
81143ca8:	00800044 	movi	r2,1
81143cac:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81143cb0:	e0bffc0b 	ldhu	r2,-16(fp)
81143cb4:	1009883a 	mov	r4,r2
81143cb8:	11387140 	call	81138714 <OSSemCreate>
81143cbc:	1007883a 	mov	r3,r2
81143cc0:	e0bffb17 	ldw	r2,-20(fp)
81143cc4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81143cc8:	e0bffb17 	ldw	r2,-20(fp)
81143ccc:	10800017 	ldw	r2,0(r2)
81143cd0:	10000226 	beq	r2,zero,81143cdc <alt_msgdma_init+0x160>
81143cd4:	0005883a 	mov	r2,zero
81143cd8:	00000106 	br	81143ce0 <alt_msgdma_init+0x164>
81143cdc:	00bfffc4 	movi	r2,-1
81143ce0:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81143ce4:	e0bffa17 	ldw	r2,-24(fp)
81143ce8:	1000081e 	bne	r2,zero,81143d0c <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81143cec:	d8000015 	stw	zero,0(sp)
81143cf0:	e1fffd17 	ldw	r7,-12(fp)
81143cf4:	01a04534 	movhi	r6,33044
81143cf8:	3187e504 	addi	r6,r6,8084
81143cfc:	e17fff17 	ldw	r5,-4(fp)
81143d00:	e13ffe17 	ldw	r4,-8(fp)
81143d04:	114434c0 	call	8114434c <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81143d08:	00000406 	br	81143d1c <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81143d0c:	01204574 	movhi	r4,33045
81143d10:	2128fb04 	addi	r4,r4,-23572
81143d14:	11447640 	call	81144764 <alt_printf>
    }
    
    return;
81143d18:	0001883a 	nop

}
81143d1c:	e037883a 	mov	sp,fp
81143d20:	dfc00117 	ldw	ra,4(sp)
81143d24:	df000017 	ldw	fp,0(sp)
81143d28:	dec00204 	addi	sp,sp,8
81143d2c:	f800283a 	ret

81143d30 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81143d30:	defffb04 	addi	sp,sp,-20
81143d34:	de00012e 	bgeu	sp,et,81143d3c <alt_msgdma_register_callback+0xc>
81143d38:	003b68fa 	trap	3
81143d3c:	df000415 	stw	fp,16(sp)
81143d40:	df000404 	addi	fp,sp,16
81143d44:	e13ffc15 	stw	r4,-16(fp)
81143d48:	e17ffd15 	stw	r5,-12(fp)
81143d4c:	e1bffe15 	stw	r6,-8(fp)
81143d50:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81143d54:	e0bffc17 	ldw	r2,-16(fp)
81143d58:	e0fffd17 	ldw	r3,-12(fp)
81143d5c:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81143d60:	e0bffc17 	ldw	r2,-16(fp)
81143d64:	e0ffff17 	ldw	r3,-4(fp)
81143d68:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81143d6c:	e0bffc17 	ldw	r2,-16(fp)
81143d70:	e0fffe17 	ldw	r3,-8(fp)
81143d74:	10c00d15 	stw	r3,52(r2)

    return ;
81143d78:	0001883a 	nop
}
81143d7c:	e037883a 	mov	sp,fp
81143d80:	df000017 	ldw	fp,0(sp)
81143d84:	dec00104 	addi	sp,sp,4
81143d88:	f800283a 	ret

81143d8c <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81143d8c:	defffc04 	addi	sp,sp,-16
81143d90:	de00012e 	bgeu	sp,et,81143d98 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81143d94:	003b68fa 	trap	3
81143d98:	dfc00315 	stw	ra,12(sp)
81143d9c:	df000215 	stw	fp,8(sp)
81143da0:	df000204 	addi	fp,sp,8
81143da4:	e13ffe15 	stw	r4,-8(fp)
81143da8:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81143dac:	000d883a 	mov	r6,zero
81143db0:	e17fff17 	ldw	r5,-4(fp)
81143db4:	e13ffe17 	ldw	r4,-8(fp)
81143db8:	11423100 	call	81142310 <alt_msgdma_descriptor_async_transfer>

}
81143dbc:	e037883a 	mov	sp,fp
81143dc0:	dfc00117 	ldw	ra,4(sp)
81143dc4:	df000017 	ldw	fp,0(sp)
81143dc8:	dec00204 	addi	sp,sp,8
81143dcc:	f800283a 	ret

81143dd0 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81143dd0:	defffc04 	addi	sp,sp,-16
81143dd4:	de00012e 	bgeu	sp,et,81143ddc <alt_msgdma_extended_descriptor_async_transfer+0xc>
81143dd8:	003b68fa 	trap	3
81143ddc:	dfc00315 	stw	ra,12(sp)
81143de0:	df000215 	stw	fp,8(sp)
81143de4:	df000204 	addi	fp,sp,8
81143de8:	e13ffe15 	stw	r4,-8(fp)
81143dec:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81143df0:	e1bfff17 	ldw	r6,-4(fp)
81143df4:	000b883a 	mov	r5,zero
81143df8:	e13ffe17 	ldw	r4,-8(fp)
81143dfc:	11423100 	call	81142310 <alt_msgdma_descriptor_async_transfer>
}
81143e00:	e037883a 	mov	sp,fp
81143e04:	dfc00117 	ldw	ra,4(sp)
81143e08:	df000017 	ldw	fp,0(sp)
81143e0c:	dec00204 	addi	sp,sp,8
81143e10:	f800283a 	ret

81143e14 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81143e14:	defffc04 	addi	sp,sp,-16
81143e18:	de00012e 	bgeu	sp,et,81143e20 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81143e1c:	003b68fa 	trap	3
81143e20:	dfc00315 	stw	ra,12(sp)
81143e24:	df000215 	stw	fp,8(sp)
81143e28:	df000204 	addi	fp,sp,8
81143e2c:	e13ffe15 	stw	r4,-8(fp)
81143e30:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81143e34:	000d883a 	mov	r6,zero
81143e38:	e17fff17 	ldw	r5,-4(fp)
81143e3c:	e13ffe17 	ldw	r4,-8(fp)
81143e40:	11426500 	call	81142650 <alt_msgdma_descriptor_sync_transfer>
}
81143e44:	e037883a 	mov	sp,fp
81143e48:	dfc00117 	ldw	ra,4(sp)
81143e4c:	df000017 	ldw	fp,0(sp)
81143e50:	dec00204 	addi	sp,sp,8
81143e54:	f800283a 	ret

81143e58 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81143e58:	defffc04 	addi	sp,sp,-16
81143e5c:	de00012e 	bgeu	sp,et,81143e64 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81143e60:	003b68fa 	trap	3
81143e64:	dfc00315 	stw	ra,12(sp)
81143e68:	df000215 	stw	fp,8(sp)
81143e6c:	df000204 	addi	fp,sp,8
81143e70:	e13ffe15 	stw	r4,-8(fp)
81143e74:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81143e78:	e1bfff17 	ldw	r6,-4(fp)
81143e7c:	000b883a 	mov	r5,zero
81143e80:	e13ffe17 	ldw	r4,-8(fp)
81143e84:	11426500 	call	81142650 <alt_msgdma_descriptor_sync_transfer>
}
81143e88:	e037883a 	mov	sp,fp
81143e8c:	dfc00117 	ldw	ra,4(sp)
81143e90:	df000017 	ldw	fp,0(sp)
81143e94:	dec00204 	addi	sp,sp,8
81143e98:	f800283a 	ret

81143e9c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81143e9c:	defff504 	addi	sp,sp,-44
81143ea0:	de00012e 	bgeu	sp,et,81143ea8 <alt_alarm_start+0xc>
81143ea4:	003b68fa 	trap	3
81143ea8:	df000a15 	stw	fp,40(sp)
81143eac:	df000a04 	addi	fp,sp,40
81143eb0:	e13ffc15 	stw	r4,-16(fp)
81143eb4:	e17ffd15 	stw	r5,-12(fp)
81143eb8:	e1bffe15 	stw	r6,-8(fp)
81143ebc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81143ec0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81143ec4:	d0a08d17 	ldw	r2,-32204(gp)
  
  if (alt_ticks_per_second ())
81143ec8:	10003c26 	beq	r2,zero,81143fbc <alt_alarm_start+0x120>
  {
    if (alarm)
81143ecc:	e0bffc17 	ldw	r2,-16(fp)
81143ed0:	10003826 	beq	r2,zero,81143fb4 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81143ed4:	e0bffc17 	ldw	r2,-16(fp)
81143ed8:	e0fffe17 	ldw	r3,-8(fp)
81143edc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81143ee0:	e0bffc17 	ldw	r2,-16(fp)
81143ee4:	e0ffff17 	ldw	r3,-4(fp)
81143ee8:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143eec:	0005303a 	rdctl	r2,status
81143ef0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143ef4:	e0fff917 	ldw	r3,-28(fp)
81143ef8:	00bfff84 	movi	r2,-2
81143efc:	1884703a 	and	r2,r3,r2
81143f00:	1001703a 	wrctl	status,r2
  
  return context;
81143f04:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81143f08:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81143f0c:	d0a08e17 	ldw	r2,-32200(gp)
      
      current_nticks = alt_nticks();
81143f10:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81143f14:	e0fffd17 	ldw	r3,-12(fp)
81143f18:	e0bff617 	ldw	r2,-40(fp)
81143f1c:	1885883a 	add	r2,r3,r2
81143f20:	10c00044 	addi	r3,r2,1
81143f24:	e0bffc17 	ldw	r2,-16(fp)
81143f28:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81143f2c:	e0bffc17 	ldw	r2,-16(fp)
81143f30:	10c00217 	ldw	r3,8(r2)
81143f34:	e0bff617 	ldw	r2,-40(fp)
81143f38:	1880042e 	bgeu	r3,r2,81143f4c <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81143f3c:	e0bffc17 	ldw	r2,-16(fp)
81143f40:	00c00044 	movi	r3,1
81143f44:	10c00405 	stb	r3,16(r2)
81143f48:	00000206 	br	81143f54 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81143f4c:	e0bffc17 	ldw	r2,-16(fp)
81143f50:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81143f54:	e0bffc17 	ldw	r2,-16(fp)
81143f58:	d0e01404 	addi	r3,gp,-32688
81143f5c:	e0fffa15 	stw	r3,-24(fp)
81143f60:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81143f64:	e0bffb17 	ldw	r2,-20(fp)
81143f68:	e0fffa17 	ldw	r3,-24(fp)
81143f6c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81143f70:	e0bffa17 	ldw	r2,-24(fp)
81143f74:	10c00017 	ldw	r3,0(r2)
81143f78:	e0bffb17 	ldw	r2,-20(fp)
81143f7c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81143f80:	e0bffa17 	ldw	r2,-24(fp)
81143f84:	10800017 	ldw	r2,0(r2)
81143f88:	e0fffb17 	ldw	r3,-20(fp)
81143f8c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81143f90:	e0bffa17 	ldw	r2,-24(fp)
81143f94:	e0fffb17 	ldw	r3,-20(fp)
81143f98:	10c00015 	stw	r3,0(r2)
81143f9c:	e0bff817 	ldw	r2,-32(fp)
81143fa0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143fa4:	e0bff717 	ldw	r2,-36(fp)
81143fa8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81143fac:	0005883a 	mov	r2,zero
81143fb0:	00000306 	br	81143fc0 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81143fb4:	00bffa84 	movi	r2,-22
81143fb8:	00000106 	br	81143fc0 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81143fbc:	00bfde84 	movi	r2,-134
  }
}
81143fc0:	e037883a 	mov	sp,fp
81143fc4:	df000017 	ldw	fp,0(sp)
81143fc8:	dec00104 	addi	sp,sp,4
81143fcc:	f800283a 	ret

81143fd0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81143fd0:	defffe04 	addi	sp,sp,-8
81143fd4:	de00012e 	bgeu	sp,et,81143fdc <alt_get_errno+0xc>
81143fd8:	003b68fa 	trap	3
81143fdc:	dfc00115 	stw	ra,4(sp)
81143fe0:	df000015 	stw	fp,0(sp)
81143fe4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81143fe8:	d0a01017 	ldw	r2,-32704(gp)
81143fec:	10000326 	beq	r2,zero,81143ffc <alt_get_errno+0x2c>
81143ff0:	d0a01017 	ldw	r2,-32704(gp)
81143ff4:	103ee83a 	callr	r2
81143ff8:	00000106 	br	81144000 <alt_get_errno+0x30>
81143ffc:	d0a07d04 	addi	r2,gp,-32268
}
81144000:	e037883a 	mov	sp,fp
81144004:	dfc00117 	ldw	ra,4(sp)
81144008:	df000017 	ldw	fp,0(sp)
8114400c:	dec00204 	addi	sp,sp,8
81144010:	f800283a 	ret

81144014 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81144014:	defffa04 	addi	sp,sp,-24
81144018:	de00012e 	bgeu	sp,et,81144020 <alt_dev_llist_insert+0xc>
8114401c:	003b68fa 	trap	3
81144020:	dfc00515 	stw	ra,20(sp)
81144024:	df000415 	stw	fp,16(sp)
81144028:	df000404 	addi	fp,sp,16
8114402c:	e13ffe15 	stw	r4,-8(fp)
81144030:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81144034:	e0bffe17 	ldw	r2,-8(fp)
81144038:	10000326 	beq	r2,zero,81144048 <alt_dev_llist_insert+0x34>
8114403c:	e0bffe17 	ldw	r2,-8(fp)
81144040:	10800217 	ldw	r2,8(r2)
81144044:	1000061e 	bne	r2,zero,81144060 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81144048:	1143fd00 	call	81143fd0 <alt_get_errno>
8114404c:	1007883a 	mov	r3,r2
81144050:	00800584 	movi	r2,22
81144054:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81144058:	00bffa84 	movi	r2,-22
8114405c:	00001306 	br	811440ac <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
81144060:	e0bffe17 	ldw	r2,-8(fp)
81144064:	e0ffff17 	ldw	r3,-4(fp)
81144068:	e0fffc15 	stw	r3,-16(fp)
8114406c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81144070:	e0bffd17 	ldw	r2,-12(fp)
81144074:	e0fffc17 	ldw	r3,-16(fp)
81144078:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114407c:	e0bffc17 	ldw	r2,-16(fp)
81144080:	10c00017 	ldw	r3,0(r2)
81144084:	e0bffd17 	ldw	r2,-12(fp)
81144088:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114408c:	e0bffc17 	ldw	r2,-16(fp)
81144090:	10800017 	ldw	r2,0(r2)
81144094:	e0fffd17 	ldw	r3,-12(fp)
81144098:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114409c:	e0bffc17 	ldw	r2,-16(fp)
811440a0:	e0fffd17 	ldw	r3,-12(fp)
811440a4:	10c00015 	stw	r3,0(r2)

  return 0;  
811440a8:	0005883a 	mov	r2,zero
}
811440ac:	e037883a 	mov	sp,fp
811440b0:	dfc00117 	ldw	ra,4(sp)
811440b4:	df000017 	ldw	fp,0(sp)
811440b8:	dec00204 	addi	sp,sp,8
811440bc:	f800283a 	ret

811440c0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
811440c0:	defffa04 	addi	sp,sp,-24
811440c4:	de00012e 	bgeu	sp,et,811440cc <alt_find_dev+0xc>
811440c8:	003b68fa 	trap	3
811440cc:	dfc00515 	stw	ra,20(sp)
811440d0:	df000415 	stw	fp,16(sp)
811440d4:	df000404 	addi	fp,sp,16
811440d8:	e13ffe15 	stw	r4,-8(fp)
811440dc:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
811440e0:	e0bfff17 	ldw	r2,-4(fp)
811440e4:	10800017 	ldw	r2,0(r2)
811440e8:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
811440ec:	e13ffe17 	ldw	r4,-8(fp)
811440f0:	111c5040 	call	8111c504 <strlen>
811440f4:	10800044 	addi	r2,r2,1
811440f8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
811440fc:	00000d06 	br	81144134 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81144100:	e0bffc17 	ldw	r2,-16(fp)
81144104:	10800217 	ldw	r2,8(r2)
81144108:	e0fffd17 	ldw	r3,-12(fp)
8114410c:	180d883a 	mov	r6,r3
81144110:	e17ffe17 	ldw	r5,-8(fp)
81144114:	1009883a 	mov	r4,r2
81144118:	1144ed40 	call	81144ed4 <memcmp>
8114411c:	1000021e 	bne	r2,zero,81144128 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
81144120:	e0bffc17 	ldw	r2,-16(fp)
81144124:	00000706 	br	81144144 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81144128:	e0bffc17 	ldw	r2,-16(fp)
8114412c:	10800017 	ldw	r2,0(r2)
81144130:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81144134:	e0fffc17 	ldw	r3,-16(fp)
81144138:	e0bfff17 	ldw	r2,-4(fp)
8114413c:	18bff01e 	bne	r3,r2,81144100 <__reset+0xfb124100>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
81144140:	0005883a 	mov	r2,zero
}
81144144:	e037883a 	mov	sp,fp
81144148:	dfc00117 	ldw	ra,4(sp)
8114414c:	df000017 	ldw	fp,0(sp)
81144150:	dec00204 	addi	sp,sp,8
81144154:	f800283a 	ret

81144158 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81144158:	defffb04 	addi	sp,sp,-20
8114415c:	de00012e 	bgeu	sp,et,81144164 <alt_find_file+0xc>
81144160:	003b68fa 	trap	3
81144164:	dfc00415 	stw	ra,16(sp)
81144168:	df000315 	stw	fp,12(sp)
8114416c:	df000304 	addi	fp,sp,12
81144170:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81144174:	d0a00b17 	ldw	r2,-32724(gp)
81144178:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114417c:	00003106 	br	81144244 <alt_find_file+0xec>
  {
    len = strlen(next->name);
81144180:	e0bffd17 	ldw	r2,-12(fp)
81144184:	10800217 	ldw	r2,8(r2)
81144188:	1009883a 	mov	r4,r2
8114418c:	111c5040 	call	8111c504 <strlen>
81144190:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81144194:	e0bffd17 	ldw	r2,-12(fp)
81144198:	10c00217 	ldw	r3,8(r2)
8114419c:	e0bffe17 	ldw	r2,-8(fp)
811441a0:	10bfffc4 	addi	r2,r2,-1
811441a4:	1885883a 	add	r2,r3,r2
811441a8:	10800003 	ldbu	r2,0(r2)
811441ac:	10803fcc 	andi	r2,r2,255
811441b0:	1080201c 	xori	r2,r2,128
811441b4:	10bfe004 	addi	r2,r2,-128
811441b8:	10800bd8 	cmpnei	r2,r2,47
811441bc:	1000031e 	bne	r2,zero,811441cc <alt_find_file+0x74>
    {
      len -= 1;
811441c0:	e0bffe17 	ldw	r2,-8(fp)
811441c4:	10bfffc4 	addi	r2,r2,-1
811441c8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
811441cc:	e0bffe17 	ldw	r2,-8(fp)
811441d0:	e0ffff17 	ldw	r3,-4(fp)
811441d4:	1885883a 	add	r2,r3,r2
811441d8:	10800003 	ldbu	r2,0(r2)
811441dc:	10803fcc 	andi	r2,r2,255
811441e0:	1080201c 	xori	r2,r2,128
811441e4:	10bfe004 	addi	r2,r2,-128
811441e8:	10800be0 	cmpeqi	r2,r2,47
811441ec:	1000081e 	bne	r2,zero,81144210 <alt_find_file+0xb8>
811441f0:	e0bffe17 	ldw	r2,-8(fp)
811441f4:	e0ffff17 	ldw	r3,-4(fp)
811441f8:	1885883a 	add	r2,r3,r2
811441fc:	10800003 	ldbu	r2,0(r2)
81144200:	10803fcc 	andi	r2,r2,255
81144204:	1080201c 	xori	r2,r2,128
81144208:	10bfe004 	addi	r2,r2,-128
8114420c:	10000a1e 	bne	r2,zero,81144238 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
81144210:	e0bffd17 	ldw	r2,-12(fp)
81144214:	10800217 	ldw	r2,8(r2)
81144218:	e0fffe17 	ldw	r3,-8(fp)
8114421c:	180d883a 	mov	r6,r3
81144220:	e17fff17 	ldw	r5,-4(fp)
81144224:	1009883a 	mov	r4,r2
81144228:	1144ed40 	call	81144ed4 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114422c:	1000021e 	bne	r2,zero,81144238 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
81144230:	e0bffd17 	ldw	r2,-12(fp)
81144234:	00000706 	br	81144254 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81144238:	e0bffd17 	ldw	r2,-12(fp)
8114423c:	10800017 	ldw	r2,0(r2)
81144240:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81144244:	e0fffd17 	ldw	r3,-12(fp)
81144248:	d0a00b04 	addi	r2,gp,-32724
8114424c:	18bfcc1e 	bne	r3,r2,81144180 <__reset+0xfb124180>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
81144250:	0005883a 	mov	r2,zero
}
81144254:	e037883a 	mov	sp,fp
81144258:	dfc00117 	ldw	ra,4(sp)
8114425c:	df000017 	ldw	fp,0(sp)
81144260:	dec00204 	addi	sp,sp,8
81144264:	f800283a 	ret

81144268 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
81144268:	defff904 	addi	sp,sp,-28
8114426c:	de00012e 	bgeu	sp,et,81144274 <alt_get_fd+0xc>
81144270:	003b68fa 	trap	3
81144274:	dfc00615 	stw	ra,24(sp)
81144278:	df000515 	stw	fp,20(sp)
8114427c:	df000504 	addi	fp,sp,20
81144280:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81144284:	00bffa04 	movi	r2,-24
81144288:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114428c:	d0a08417 	ldw	r2,-32240(gp)
81144290:	e0bffd15 	stw	r2,-12(fp)
81144294:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81144298:	e0bffe0b 	ldhu	r2,-8(fp)
8114429c:	e0fffe84 	addi	r3,fp,-6
811442a0:	180d883a 	mov	r6,r3
811442a4:	100b883a 	mov	r5,r2
811442a8:	e13ffd17 	ldw	r4,-12(fp)
811442ac:	1138a3c0 	call	81138a3c <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
811442b0:	e03ffb15 	stw	zero,-20(fp)
811442b4:	00001906 	br	8114431c <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
811442b8:	00a04574 	movhi	r2,33045
811442bc:	10ab6a04 	addi	r2,r2,-21080
811442c0:	e0fffb17 	ldw	r3,-20(fp)
811442c4:	18c00324 	muli	r3,r3,12
811442c8:	10c5883a 	add	r2,r2,r3
811442cc:	10800017 	ldw	r2,0(r2)
811442d0:	10000f1e 	bne	r2,zero,81144310 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
811442d4:	00a04574 	movhi	r2,33045
811442d8:	10ab6a04 	addi	r2,r2,-21080
811442dc:	e0fffb17 	ldw	r3,-20(fp)
811442e0:	18c00324 	muli	r3,r3,12
811442e4:	10c5883a 	add	r2,r2,r3
811442e8:	e0ffff17 	ldw	r3,-4(fp)
811442ec:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
811442f0:	d0e00f17 	ldw	r3,-32708(gp)
811442f4:	e0bffb17 	ldw	r2,-20(fp)
811442f8:	1880020e 	bge	r3,r2,81144304 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
811442fc:	e0bffb17 	ldw	r2,-20(fp)
81144300:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81144304:	e0bffb17 	ldw	r2,-20(fp)
81144308:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114430c:	00000606 	br	81144328 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81144310:	e0bffb17 	ldw	r2,-20(fp)
81144314:	10800044 	addi	r2,r2,1
81144318:	e0bffb15 	stw	r2,-20(fp)
8114431c:	e0bffb17 	ldw	r2,-20(fp)
81144320:	10800810 	cmplti	r2,r2,32
81144324:	103fe41e 	bne	r2,zero,811442b8 <__reset+0xfb1242b8>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81144328:	d0a08417 	ldw	r2,-32240(gp)
8114432c:	1009883a 	mov	r4,r2
81144330:	1138dc40 	call	81138dc4 <OSSemPost>

  return rc;
81144334:	e0bffc17 	ldw	r2,-16(fp)
}
81144338:	e037883a 	mov	sp,fp
8114433c:	dfc00117 	ldw	ra,4(sp)
81144340:	df000017 	ldw	fp,0(sp)
81144344:	dec00204 	addi	sp,sp,8
81144348:	f800283a 	ret

8114434c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114434c:	defff904 	addi	sp,sp,-28
81144350:	de00012e 	bgeu	sp,et,81144358 <alt_ic_isr_register+0xc>
81144354:	003b68fa 	trap	3
81144358:	dfc00615 	stw	ra,24(sp)
8114435c:	df000515 	stw	fp,20(sp)
81144360:	df000504 	addi	fp,sp,20
81144364:	e13ffc15 	stw	r4,-16(fp)
81144368:	e17ffd15 	stw	r5,-12(fp)
8114436c:	e1bffe15 	stw	r6,-8(fp)
81144370:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81144374:	e0800217 	ldw	r2,8(fp)
81144378:	d8800015 	stw	r2,0(sp)
8114437c:	e1ffff17 	ldw	r7,-4(fp)
81144380:	e1bffe17 	ldw	r6,-8(fp)
81144384:	e17ffd17 	ldw	r5,-12(fp)
81144388:	e13ffc17 	ldw	r4,-16(fp)
8114438c:	114451c0 	call	8114451c <alt_iic_isr_register>
}  
81144390:	e037883a 	mov	sp,fp
81144394:	dfc00117 	ldw	ra,4(sp)
81144398:	df000017 	ldw	fp,0(sp)
8114439c:	dec00204 	addi	sp,sp,8
811443a0:	f800283a 	ret

811443a4 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
811443a4:	defff904 	addi	sp,sp,-28
811443a8:	de00012e 	bgeu	sp,et,811443b0 <alt_ic_irq_enable+0xc>
811443ac:	003b68fa 	trap	3
811443b0:	df000615 	stw	fp,24(sp)
811443b4:	df000604 	addi	fp,sp,24
811443b8:	e13ffe15 	stw	r4,-8(fp)
811443bc:	e17fff15 	stw	r5,-4(fp)
811443c0:	e0bfff17 	ldw	r2,-4(fp)
811443c4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811443c8:	0005303a 	rdctl	r2,status
811443cc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811443d0:	e0fffb17 	ldw	r3,-20(fp)
811443d4:	00bfff84 	movi	r2,-2
811443d8:	1884703a 	and	r2,r3,r2
811443dc:	1001703a 	wrctl	status,r2
  
  return context;
811443e0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811443e4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
811443e8:	00c00044 	movi	r3,1
811443ec:	e0bffa17 	ldw	r2,-24(fp)
811443f0:	1884983a 	sll	r2,r3,r2
811443f4:	1007883a 	mov	r3,r2
811443f8:	d0a08517 	ldw	r2,-32236(gp)
811443fc:	1884b03a 	or	r2,r3,r2
81144400:	d0a08515 	stw	r2,-32236(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81144404:	d0a08517 	ldw	r2,-32236(gp)
81144408:	100170fa 	wrctl	ienable,r2
8114440c:	e0bffc17 	ldw	r2,-16(fp)
81144410:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144414:	e0bffd17 	ldw	r2,-12(fp)
81144418:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114441c:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
81144420:	0001883a 	nop
}
81144424:	e037883a 	mov	sp,fp
81144428:	df000017 	ldw	fp,0(sp)
8114442c:	dec00104 	addi	sp,sp,4
81144430:	f800283a 	ret

81144434 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
81144434:	defff904 	addi	sp,sp,-28
81144438:	de00012e 	bgeu	sp,et,81144440 <alt_ic_irq_disable+0xc>
8114443c:	003b68fa 	trap	3
81144440:	df000615 	stw	fp,24(sp)
81144444:	df000604 	addi	fp,sp,24
81144448:	e13ffe15 	stw	r4,-8(fp)
8114444c:	e17fff15 	stw	r5,-4(fp)
81144450:	e0bfff17 	ldw	r2,-4(fp)
81144454:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144458:	0005303a 	rdctl	r2,status
8114445c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144460:	e0fffb17 	ldw	r3,-20(fp)
81144464:	00bfff84 	movi	r2,-2
81144468:	1884703a 	and	r2,r3,r2
8114446c:	1001703a 	wrctl	status,r2
  
  return context;
81144470:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81144474:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
81144478:	00c00044 	movi	r3,1
8114447c:	e0bffa17 	ldw	r2,-24(fp)
81144480:	1884983a 	sll	r2,r3,r2
81144484:	0084303a 	nor	r2,zero,r2
81144488:	1007883a 	mov	r3,r2
8114448c:	d0a08517 	ldw	r2,-32236(gp)
81144490:	1884703a 	and	r2,r3,r2
81144494:	d0a08515 	stw	r2,-32236(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81144498:	d0a08517 	ldw	r2,-32236(gp)
8114449c:	100170fa 	wrctl	ienable,r2
811444a0:	e0bffc17 	ldw	r2,-16(fp)
811444a4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811444a8:	e0bffd17 	ldw	r2,-12(fp)
811444ac:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811444b0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
811444b4:	0001883a 	nop
}
811444b8:	e037883a 	mov	sp,fp
811444bc:	df000017 	ldw	fp,0(sp)
811444c0:	dec00104 	addi	sp,sp,4
811444c4:	f800283a 	ret

811444c8 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
811444c8:	defffc04 	addi	sp,sp,-16
811444cc:	de00012e 	bgeu	sp,et,811444d4 <alt_ic_irq_enabled+0xc>
811444d0:	003b68fa 	trap	3
811444d4:	df000315 	stw	fp,12(sp)
811444d8:	df000304 	addi	fp,sp,12
811444dc:	e13ffe15 	stw	r4,-8(fp)
811444e0:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
811444e4:	000530fa 	rdctl	r2,ienable
811444e8:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
811444ec:	00c00044 	movi	r3,1
811444f0:	e0bfff17 	ldw	r2,-4(fp)
811444f4:	1884983a 	sll	r2,r3,r2
811444f8:	1007883a 	mov	r3,r2
811444fc:	e0bffd17 	ldw	r2,-12(fp)
81144500:	1884703a 	and	r2,r3,r2
81144504:	1004c03a 	cmpne	r2,r2,zero
81144508:	10803fcc 	andi	r2,r2,255
}
8114450c:	e037883a 	mov	sp,fp
81144510:	df000017 	ldw	fp,0(sp)
81144514:	dec00104 	addi	sp,sp,4
81144518:	f800283a 	ret

8114451c <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
8114451c:	defff504 	addi	sp,sp,-44
81144520:	de00012e 	bgeu	sp,et,81144528 <alt_iic_isr_register+0xc>
81144524:	003b68fa 	trap	3
81144528:	dfc00a15 	stw	ra,40(sp)
8114452c:	df000915 	stw	fp,36(sp)
81144530:	df000904 	addi	fp,sp,36
81144534:	e13ffc15 	stw	r4,-16(fp)
81144538:	e17ffd15 	stw	r5,-12(fp)
8114453c:	e1bffe15 	stw	r6,-8(fp)
81144540:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81144544:	00bffa84 	movi	r2,-22
81144548:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
8114454c:	e0bffd17 	ldw	r2,-12(fp)
81144550:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81144554:	e0bff817 	ldw	r2,-32(fp)
81144558:	10800808 	cmpgei	r2,r2,32
8114455c:	1000271e 	bne	r2,zero,811445fc <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144560:	0005303a 	rdctl	r2,status
81144564:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144568:	e0fffb17 	ldw	r3,-20(fp)
8114456c:	00bfff84 	movi	r2,-2
81144570:	1884703a 	and	r2,r3,r2
81144574:	1001703a 	wrctl	status,r2
  
  return context;
81144578:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114457c:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
81144580:	00a045b4 	movhi	r2,33046
81144584:	10965004 	addi	r2,r2,22848
81144588:	e0fff817 	ldw	r3,-32(fp)
8114458c:	180690fa 	slli	r3,r3,3
81144590:	10c5883a 	add	r2,r2,r3
81144594:	e0fffe17 	ldw	r3,-8(fp)
81144598:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114459c:	00a045b4 	movhi	r2,33046
811445a0:	10965004 	addi	r2,r2,22848
811445a4:	e0fff817 	ldw	r3,-32(fp)
811445a8:	180690fa 	slli	r3,r3,3
811445ac:	10c5883a 	add	r2,r2,r3
811445b0:	10800104 	addi	r2,r2,4
811445b4:	e0ffff17 	ldw	r3,-4(fp)
811445b8:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
811445bc:	e0bffe17 	ldw	r2,-8(fp)
811445c0:	10000526 	beq	r2,zero,811445d8 <alt_iic_isr_register+0xbc>
811445c4:	e0bff817 	ldw	r2,-32(fp)
811445c8:	100b883a 	mov	r5,r2
811445cc:	e13ffc17 	ldw	r4,-16(fp)
811445d0:	11443a40 	call	811443a4 <alt_ic_irq_enable>
811445d4:	00000406 	br	811445e8 <alt_iic_isr_register+0xcc>
811445d8:	e0bff817 	ldw	r2,-32(fp)
811445dc:	100b883a 	mov	r5,r2
811445e0:	e13ffc17 	ldw	r4,-16(fp)
811445e4:	11444340 	call	81144434 <alt_ic_irq_disable>
811445e8:	e0bff715 	stw	r2,-36(fp)
811445ec:	e0bffa17 	ldw	r2,-24(fp)
811445f0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811445f4:	e0bff917 	ldw	r2,-28(fp)
811445f8:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
811445fc:	e0bff717 	ldw	r2,-36(fp)
}
81144600:	e037883a 	mov	sp,fp
81144604:	dfc00117 	ldw	ra,4(sp)
81144608:	df000017 	ldw	fp,0(sp)
8114460c:	dec00204 	addi	sp,sp,8
81144610:	f800283a 	ret

81144614 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81144614:	defff904 	addi	sp,sp,-28
81144618:	de00012e 	bgeu	sp,et,81144620 <alt_open_fd+0xc>
8114461c:	003b68fa 	trap	3
81144620:	dfc00615 	stw	ra,24(sp)
81144624:	df000515 	stw	fp,20(sp)
81144628:	df000504 	addi	fp,sp,20
8114462c:	e13ffc15 	stw	r4,-16(fp)
81144630:	e17ffd15 	stw	r5,-12(fp)
81144634:	e1bffe15 	stw	r6,-8(fp)
81144638:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
8114463c:	e1bfff17 	ldw	r6,-4(fp)
81144640:	e17ffe17 	ldw	r5,-8(fp)
81144644:	e13ffd17 	ldw	r4,-12(fp)
81144648:	11316780 	call	81131678 <open>
8114464c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
81144650:	e0bffb17 	ldw	r2,-20(fp)
81144654:	10001c16 	blt	r2,zero,811446c8 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81144658:	00a04574 	movhi	r2,33045
8114465c:	10ab6a04 	addi	r2,r2,-21080
81144660:	e0fffb17 	ldw	r3,-20(fp)
81144664:	18c00324 	muli	r3,r3,12
81144668:	10c5883a 	add	r2,r2,r3
8114466c:	10c00017 	ldw	r3,0(r2)
81144670:	e0bffc17 	ldw	r2,-16(fp)
81144674:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
81144678:	00a04574 	movhi	r2,33045
8114467c:	10ab6a04 	addi	r2,r2,-21080
81144680:	e0fffb17 	ldw	r3,-20(fp)
81144684:	18c00324 	muli	r3,r3,12
81144688:	10c5883a 	add	r2,r2,r3
8114468c:	10800104 	addi	r2,r2,4
81144690:	10c00017 	ldw	r3,0(r2)
81144694:	e0bffc17 	ldw	r2,-16(fp)
81144698:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114469c:	00a04574 	movhi	r2,33045
811446a0:	10ab6a04 	addi	r2,r2,-21080
811446a4:	e0fffb17 	ldw	r3,-20(fp)
811446a8:	18c00324 	muli	r3,r3,12
811446ac:	10c5883a 	add	r2,r2,r3
811446b0:	10800204 	addi	r2,r2,8
811446b4:	10c00017 	ldw	r3,0(r2)
811446b8:	e0bffc17 	ldw	r2,-16(fp)
811446bc:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
811446c0:	e13ffb17 	ldw	r4,-20(fp)
811446c4:	113191c0 	call	8113191c <alt_release_fd>
  }
} 
811446c8:	0001883a 	nop
811446cc:	e037883a 	mov	sp,fp
811446d0:	dfc00117 	ldw	ra,4(sp)
811446d4:	df000017 	ldw	fp,0(sp)
811446d8:	dec00204 	addi	sp,sp,8
811446dc:	f800283a 	ret

811446e0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
811446e0:	defffb04 	addi	sp,sp,-20
811446e4:	de00012e 	bgeu	sp,et,811446ec <alt_io_redirect+0xc>
811446e8:	003b68fa 	trap	3
811446ec:	dfc00415 	stw	ra,16(sp)
811446f0:	df000315 	stw	fp,12(sp)
811446f4:	df000304 	addi	fp,sp,12
811446f8:	e13ffd15 	stw	r4,-12(fp)
811446fc:	e17ffe15 	stw	r5,-8(fp)
81144700:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81144704:	01c07fc4 	movi	r7,511
81144708:	01800044 	movi	r6,1
8114470c:	e17ffd17 	ldw	r5,-12(fp)
81144710:	01204574 	movhi	r4,33045
81144714:	212b6d04 	addi	r4,r4,-21068
81144718:	11446140 	call	81144614 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
8114471c:	01c07fc4 	movi	r7,511
81144720:	000d883a 	mov	r6,zero
81144724:	e17ffe17 	ldw	r5,-8(fp)
81144728:	01204574 	movhi	r4,33045
8114472c:	212b6a04 	addi	r4,r4,-21080
81144730:	11446140 	call	81144614 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
81144734:	01c07fc4 	movi	r7,511
81144738:	01800044 	movi	r6,1
8114473c:	e17fff17 	ldw	r5,-4(fp)
81144740:	01204574 	movhi	r4,33045
81144744:	212b7004 	addi	r4,r4,-21056
81144748:	11446140 	call	81144614 <alt_open_fd>
}  
8114474c:	0001883a 	nop
81144750:	e037883a 	mov	sp,fp
81144754:	dfc00117 	ldw	ra,4(sp)
81144758:	df000017 	ldw	fp,0(sp)
8114475c:	dec00204 	addi	sp,sp,8
81144760:	f800283a 	ret

81144764 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
81144764:	defff204 	addi	sp,sp,-56
81144768:	de00012e 	bgeu	sp,et,81144770 <alt_printf+0xc>
8114476c:	003b68fa 	trap	3
81144770:	dfc00a15 	stw	ra,40(sp)
81144774:	df000915 	stw	fp,36(sp)
81144778:	df000904 	addi	fp,sp,36
8114477c:	e13fff15 	stw	r4,-4(fp)
81144780:	e1400215 	stw	r5,8(fp)
81144784:	e1800315 	stw	r6,12(fp)
81144788:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
8114478c:	e0800204 	addi	r2,fp,8
81144790:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
81144794:	e0bfff17 	ldw	r2,-4(fp)
81144798:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
8114479c:	00006f06 	br	8114495c <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
811447a0:	e0bff807 	ldb	r2,-32(fp)
811447a4:	10800960 	cmpeqi	r2,r2,37
811447a8:	1000041e 	bne	r2,zero,811447bc <alt_printf+0x58>
        {
            alt_putchar(c);
811447ac:	e0bff807 	ldb	r2,-32(fp)
811447b0:	1009883a 	mov	r4,r2
811447b4:	11449980 	call	81144998 <alt_putchar>
811447b8:	00006806 	br	8114495c <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
811447bc:	e0bff717 	ldw	r2,-36(fp)
811447c0:	10c00044 	addi	r3,r2,1
811447c4:	e0fff715 	stw	r3,-36(fp)
811447c8:	10800003 	ldbu	r2,0(r2)
811447cc:	e0bff805 	stb	r2,-32(fp)
811447d0:	e0bff807 	ldb	r2,-32(fp)
811447d4:	10006926 	beq	r2,zero,8114497c <alt_printf+0x218>
            {
                if (c == '%')
811447d8:	e0bff807 	ldb	r2,-32(fp)
811447dc:	10800958 	cmpnei	r2,r2,37
811447e0:	1000041e 	bne	r2,zero,811447f4 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
811447e4:	e0bff807 	ldb	r2,-32(fp)
811447e8:	1009883a 	mov	r4,r2
811447ec:	11449980 	call	81144998 <alt_putchar>
811447f0:	00005a06 	br	8114495c <alt_printf+0x1f8>
                } 
                else if (c == 'c')
811447f4:	e0bff807 	ldb	r2,-32(fp)
811447f8:	108018d8 	cmpnei	r2,r2,99
811447fc:	1000081e 	bne	r2,zero,81144820 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81144800:	e0bffe17 	ldw	r2,-8(fp)
81144804:	10c00104 	addi	r3,r2,4
81144808:	e0fffe15 	stw	r3,-8(fp)
8114480c:	10800017 	ldw	r2,0(r2)
81144810:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81144814:	e13ffd17 	ldw	r4,-12(fp)
81144818:	11449980 	call	81144998 <alt_putchar>
8114481c:	00004f06 	br	8114495c <alt_printf+0x1f8>
                }
                else if (c == 'x')
81144820:	e0bff807 	ldb	r2,-32(fp)
81144824:	10801e18 	cmpnei	r2,r2,120
81144828:	1000341e 	bne	r2,zero,811448fc <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
8114482c:	e0bffe17 	ldw	r2,-8(fp)
81144830:	10c00104 	addi	r3,r2,4
81144834:	e0fffe15 	stw	r3,-8(fp)
81144838:	10800017 	ldw	r2,0(r2)
8114483c:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
81144840:	e0bffb17 	ldw	r2,-20(fp)
81144844:	1000031e 	bne	r2,zero,81144854 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81144848:	01000c04 	movi	r4,48
8114484c:	11449980 	call	81144998 <alt_putchar>
                        continue;
81144850:	00004206 	br	8114495c <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81144854:	00800704 	movi	r2,28
81144858:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
8114485c:	00000306 	br	8114486c <alt_printf+0x108>
                        digit_shift -= 4;
81144860:	e0bff917 	ldw	r2,-28(fp)
81144864:	10bfff04 	addi	r2,r2,-4
81144868:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
8114486c:	00c003c4 	movi	r3,15
81144870:	e0bff917 	ldw	r2,-28(fp)
81144874:	1884983a 	sll	r2,r3,r2
81144878:	1007883a 	mov	r3,r2
8114487c:	e0bffb17 	ldw	r2,-20(fp)
81144880:	1884703a 	and	r2,r3,r2
81144884:	103ff626 	beq	r2,zero,81144860 <__reset+0xfb124860>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81144888:	00001906 	br	811448f0 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
8114488c:	00c003c4 	movi	r3,15
81144890:	e0bff917 	ldw	r2,-28(fp)
81144894:	1884983a 	sll	r2,r3,r2
81144898:	1007883a 	mov	r3,r2
8114489c:	e0bffb17 	ldw	r2,-20(fp)
811448a0:	1886703a 	and	r3,r3,r2
811448a4:	e0bff917 	ldw	r2,-28(fp)
811448a8:	1884d83a 	srl	r2,r3,r2
811448ac:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
811448b0:	e0bffc17 	ldw	r2,-16(fp)
811448b4:	108002a8 	cmpgeui	r2,r2,10
811448b8:	1000041e 	bne	r2,zero,811448cc <alt_printf+0x168>
                            c = '0' + digit;
811448bc:	e0bffc17 	ldw	r2,-16(fp)
811448c0:	10800c04 	addi	r2,r2,48
811448c4:	e0bff805 	stb	r2,-32(fp)
811448c8:	00000306 	br	811448d8 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
811448cc:	e0bffc17 	ldw	r2,-16(fp)
811448d0:	108015c4 	addi	r2,r2,87
811448d4:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
811448d8:	e0bff807 	ldb	r2,-32(fp)
811448dc:	1009883a 	mov	r4,r2
811448e0:	11449980 	call	81144998 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
811448e4:	e0bff917 	ldw	r2,-28(fp)
811448e8:	10bfff04 	addi	r2,r2,-4
811448ec:	e0bff915 	stw	r2,-28(fp)
811448f0:	e0bff917 	ldw	r2,-28(fp)
811448f4:	103fe50e 	bge	r2,zero,8114488c <__reset+0xfb12488c>
811448f8:	00001806 	br	8114495c <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
811448fc:	e0bff807 	ldb	r2,-32(fp)
81144900:	10801cd8 	cmpnei	r2,r2,115
81144904:	1000151e 	bne	r2,zero,8114495c <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81144908:	e0bffe17 	ldw	r2,-8(fp)
8114490c:	10c00104 	addi	r3,r2,4
81144910:	e0fffe15 	stw	r3,-8(fp)
81144914:	10800017 	ldw	r2,0(r2)
81144918:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
8114491c:	00000906 	br	81144944 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81144920:	e0bffa17 	ldw	r2,-24(fp)
81144924:	10c00044 	addi	r3,r2,1
81144928:	e0fffa15 	stw	r3,-24(fp)
8114492c:	10800003 	ldbu	r2,0(r2)
81144930:	10803fcc 	andi	r2,r2,255
81144934:	1080201c 	xori	r2,r2,128
81144938:	10bfe004 	addi	r2,r2,-128
8114493c:	1009883a 	mov	r4,r2
81144940:	11449980 	call	81144998 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81144944:	e0bffa17 	ldw	r2,-24(fp)
81144948:	10800003 	ldbu	r2,0(r2)
8114494c:	10803fcc 	andi	r2,r2,255
81144950:	1080201c 	xori	r2,r2,128
81144954:	10bfe004 	addi	r2,r2,-128
81144958:	103ff11e 	bne	r2,zero,81144920 <__reset+0xfb124920>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
8114495c:	e0bff717 	ldw	r2,-36(fp)
81144960:	10c00044 	addi	r3,r2,1
81144964:	e0fff715 	stw	r3,-36(fp)
81144968:	10800003 	ldbu	r2,0(r2)
8114496c:	e0bff805 	stb	r2,-32(fp)
81144970:	e0bff807 	ldb	r2,-32(fp)
81144974:	103f8a1e 	bne	r2,zero,811447a0 <__reset+0xfb1247a0>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81144978:	00000106 	br	81144980 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
8114497c:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81144980:	0001883a 	nop
81144984:	e037883a 	mov	sp,fp
81144988:	dfc00117 	ldw	ra,4(sp)
8114498c:	df000017 	ldw	fp,0(sp)
81144990:	dec00504 	addi	sp,sp,20
81144994:	f800283a 	ret

81144998 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81144998:	defffd04 	addi	sp,sp,-12
8114499c:	de00012e 	bgeu	sp,et,811449a4 <alt_putchar+0xc>
811449a0:	003b68fa 	trap	3
811449a4:	dfc00215 	stw	ra,8(sp)
811449a8:	df000115 	stw	fp,4(sp)
811449ac:	df000104 	addi	fp,sp,4
811449b0:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
811449b4:	d0a00517 	ldw	r2,-32748(gp)
811449b8:	10800217 	ldw	r2,8(r2)
811449bc:	100b883a 	mov	r5,r2
811449c0:	e13fff17 	ldw	r4,-4(fp)
811449c4:	111be140 	call	8111be14 <putc>
#endif
#endif
}
811449c8:	e037883a 	mov	sp,fp
811449cc:	dfc00117 	ldw	ra,4(sp)
811449d0:	df000017 	ldw	fp,0(sp)
811449d4:	dec00204 	addi	sp,sp,8
811449d8:	f800283a 	ret

811449dc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
811449dc:	deffff04 	addi	sp,sp,-4
811449e0:	de00012e 	bgeu	sp,et,811449e8 <altera_nios2_gen2_irq_init+0xc>
811449e4:	003b68fa 	trap	3
811449e8:	df000015 	stw	fp,0(sp)
811449ec:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
811449f0:	000170fa 	wrctl	ienable,zero
}
811449f4:	0001883a 	nop
811449f8:	e037883a 	mov	sp,fp
811449fc:	df000017 	ldw	fp,0(sp)
81144a00:	dec00104 	addi	sp,sp,4
81144a04:	f800283a 	ret

81144a08 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81144a08:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81144a0c:	de002436 	bltu	sp,et,81144aa0 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81144a10:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81144a14:	d120a717 	ldw	r4,-32100(gp)

      stw ra,  0(sp)
81144a18:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81144a1c:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81144a20:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81144a24:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81144a28:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81144a2c:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81144a30:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81144a34:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81144a38:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
81144a3c:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81144a40:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81144a44:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81144a48:	1144ca40 	call	81144ca4 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
81144a4c:	d120a117 	ldw	r4,-32124(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81144a50:	d1609887 	ldb	r5,-32158(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81144a54:	d120a715 	stw	r4,-32100(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81144a58:	d16098c5 	stb	r5,-32157(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
81144a5c:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81144a60:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81144a64:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81144a68:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
81144a6c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
81144a70:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
81144a74:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
81144a78:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
81144a7c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
81144a80:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
81144a84:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
81144a88:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
81144a8c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81144a90:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81144a94:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81144a98:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81144a9c:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81144aa0:	003da0fa 	break	3

81144aa4 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81144aa4:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81144aa8:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81144aac:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81144ab0:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81144ab4:	1144ca40 	call	81144ca4 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81144ab8:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81144abc:	d4a09605 	stb	r18,-32168(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81144ac0:	003fe206 	br	81144a4c <__reset+0xfb124a4c>

81144ac4 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81144ac4:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81144ac8:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81144acc:	10800054 	ori	r2,r2,1
      wrctl status, r2
81144ad0:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81144ad4:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81144ad8:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81144adc:	dec00204 	addi	sp,sp,8

      callr r2
81144ae0:	103ee83a 	callr	r2

      nop
81144ae4:	0001883a 	nop

81144ae8 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81144ae8:	defff704 	addi	sp,sp,-36
81144aec:	de00012e 	bgeu	sp,et,81144af4 <OSTaskStkInit+0xc>
81144af0:	003b68fa 	trap	3
81144af4:	dfc00815 	stw	ra,32(sp)
81144af8:	df000715 	stw	fp,28(sp)
81144afc:	df000704 	addi	fp,sp,28
81144b00:	e13ffc15 	stw	r4,-16(fp)
81144b04:	e17ffd15 	stw	r5,-12(fp)
81144b08:	e1bffe15 	stw	r6,-8(fp)
81144b0c:	3805883a 	mov	r2,r7
81144b10:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81144b14:	e0fffe17 	ldw	r3,-8(fp)
81144b18:	00bfff04 	movi	r2,-4
81144b1c:	1884703a 	and	r2,r3,r2
81144b20:	10bef704 	addi	r2,r2,-1060
81144b24:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81144b28:	01810904 	movi	r6,1060
81144b2c:	000b883a 	mov	r5,zero
81144b30:	e13ff917 	ldw	r4,-28(fp)
81144b34:	111bb600 	call	8111bb60 <memset>
81144b38:	e0bff917 	ldw	r2,-28(fp)
81144b3c:	10c0bb04 	addi	r3,r2,748
81144b40:	e0bff917 	ldw	r2,-28(fp)
81144b44:	10c00115 	stw	r3,4(r2)
81144b48:	e0bff917 	ldw	r2,-28(fp)
81144b4c:	10c0d504 	addi	r3,r2,852
81144b50:	e0bff917 	ldw	r2,-28(fp)
81144b54:	10c00215 	stw	r3,8(r2)
81144b58:	e0bff917 	ldw	r2,-28(fp)
81144b5c:	10c0ef04 	addi	r3,r2,956
81144b60:	e0bff917 	ldw	r2,-28(fp)
81144b64:	10c00315 	stw	r3,12(r2)
81144b68:	e0fff917 	ldw	r3,-28(fp)
81144b6c:	00a04574 	movhi	r2,33045
81144b70:	10a90304 	addi	r2,r2,-23540
81144b74:	18800d15 	stw	r2,52(r3)
81144b78:	e0bff917 	ldw	r2,-28(fp)
81144b7c:	00c00044 	movi	r3,1
81144b80:	10c02915 	stw	r3,164(r2)
81144b84:	10002a15 	stw	zero,168(r2)
81144b88:	e0bff917 	ldw	r2,-28(fp)
81144b8c:	00ccc384 	movi	r3,13070
81144b90:	10c02b0d 	sth	r3,172(r2)
81144b94:	e0bff917 	ldw	r2,-28(fp)
81144b98:	00eaf344 	movi	r3,-21555
81144b9c:	10c02b8d 	sth	r3,174(r2)
81144ba0:	e0bff917 	ldw	r2,-28(fp)
81144ba4:	00c48d04 	movi	r3,4660
81144ba8:	10c02c0d 	sth	r3,176(r2)
81144bac:	e0bff917 	ldw	r2,-28(fp)
81144bb0:	00f99b44 	movi	r3,-6547
81144bb4:	10c02c8d 	sth	r3,178(r2)
81144bb8:	e0bff917 	ldw	r2,-28(fp)
81144bbc:	00f7bb04 	movi	r3,-8468
81144bc0:	10c02d0d 	sth	r3,180(r2)
81144bc4:	e0bff917 	ldw	r2,-28(fp)
81144bc8:	00c00144 	movi	r3,5
81144bcc:	10c02d8d 	sth	r3,182(r2)
81144bd0:	e0bff917 	ldw	r2,-28(fp)
81144bd4:	00c002c4 	movi	r3,11
81144bd8:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81144bdc:	e0bff917 	ldw	r2,-28(fp)
81144be0:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81144be4:	e0bffa17 	ldw	r2,-24(fp)
81144be8:	10bff304 	addi	r2,r2,-52
81144bec:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81144bf0:	e0bffb17 	ldw	r2,-20(fp)
81144bf4:	10800c04 	addi	r2,r2,48
81144bf8:	e0fffc17 	ldw	r3,-16(fp)
81144bfc:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81144c00:	e0bffb17 	ldw	r2,-20(fp)
81144c04:	10800b04 	addi	r2,r2,44
81144c08:	e0fffd17 	ldw	r3,-12(fp)
81144c0c:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81144c10:	e0bffb17 	ldw	r2,-20(fp)
81144c14:	10800a04 	addi	r2,r2,40
81144c18:	e0fff917 	ldw	r3,-28(fp)
81144c1c:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81144c20:	00a04534 	movhi	r2,33044
81144c24:	1092b104 	addi	r2,r2,19140
81144c28:	10c00104 	addi	r3,r2,4
81144c2c:	e0bffb17 	ldw	r2,-20(fp)
81144c30:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81144c34:	e0bffb17 	ldw	r2,-20(fp)
}
81144c38:	e037883a 	mov	sp,fp
81144c3c:	dfc00117 	ldw	ra,4(sp)
81144c40:	df000017 	ldw	fp,0(sp)
81144c44:	dec00204 	addi	sp,sp,8
81144c48:	f800283a 	ret

81144c4c <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
81144c4c:	defffe04 	addi	sp,sp,-8
81144c50:	de00012e 	bgeu	sp,et,81144c58 <OSTaskCreateHook+0xc>
81144c54:	003b68fa 	trap	3
81144c58:	df000115 	stw	fp,4(sp)
81144c5c:	df000104 	addi	fp,sp,4
81144c60:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81144c64:	0001883a 	nop
81144c68:	e037883a 	mov	sp,fp
81144c6c:	df000017 	ldw	fp,0(sp)
81144c70:	dec00104 	addi	sp,sp,4
81144c74:	f800283a 	ret

81144c78 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
81144c78:	defffe04 	addi	sp,sp,-8
81144c7c:	de00012e 	bgeu	sp,et,81144c84 <OSTaskDelHook+0xc>
81144c80:	003b68fa 	trap	3
81144c84:	df000115 	stw	fp,4(sp)
81144c88:	df000104 	addi	fp,sp,4
81144c8c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81144c90:	0001883a 	nop
81144c94:	e037883a 	mov	sp,fp
81144c98:	df000017 	ldw	fp,0(sp)
81144c9c:	dec00104 	addi	sp,sp,4
81144ca0:	f800283a 	ret

81144ca4 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81144ca4:	deffff04 	addi	sp,sp,-4
81144ca8:	de00012e 	bgeu	sp,et,81144cb0 <OSTaskSwHook+0xc>
81144cac:	003b68fa 	trap	3
81144cb0:	df000015 	stw	fp,0(sp)
81144cb4:	d839883a 	mov	fp,sp
}
81144cb8:	0001883a 	nop
81144cbc:	e037883a 	mov	sp,fp
81144cc0:	df000017 	ldw	fp,0(sp)
81144cc4:	dec00104 	addi	sp,sp,4
81144cc8:	f800283a 	ret

81144ccc <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81144ccc:	deffff04 	addi	sp,sp,-4
81144cd0:	de00012e 	bgeu	sp,et,81144cd8 <OSTaskStatHook+0xc>
81144cd4:	003b68fa 	trap	3
81144cd8:	df000015 	stw	fp,0(sp)
81144cdc:	d839883a 	mov	fp,sp
}
81144ce0:	0001883a 	nop
81144ce4:	e037883a 	mov	sp,fp
81144ce8:	df000017 	ldw	fp,0(sp)
81144cec:	dec00104 	addi	sp,sp,4
81144cf0:	f800283a 	ret

81144cf4 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81144cf4:	defffe04 	addi	sp,sp,-8
81144cf8:	de00012e 	bgeu	sp,et,81144d00 <OSTimeTickHook+0xc>
81144cfc:	003b68fa 	trap	3
81144d00:	dfc00115 	stw	ra,4(sp)
81144d04:	df000015 	stw	fp,0(sp)
81144d08:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81144d0c:	d0a0bb0b 	ldhu	r2,-32020(gp)
81144d10:	10800044 	addi	r2,r2,1
81144d14:	d0a0bb0d 	sth	r2,-32020(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81144d18:	d0a0bb0b 	ldhu	r2,-32020(gp)
81144d1c:	10bfffcc 	andi	r2,r2,65535
81144d20:	10807d30 	cmpltui	r2,r2,500
81144d24:	1000021e 	bne	r2,zero,81144d30 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81144d28:	d020bb0d 	sth	zero,-32020(gp)
        OSTmrSignal();
81144d2c:	113b6440 	call	8113b644 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81144d30:	0001883a 	nop
81144d34:	e037883a 	mov	sp,fp
81144d38:	dfc00117 	ldw	ra,4(sp)
81144d3c:	df000017 	ldw	fp,0(sp)
81144d40:	dec00204 	addi	sp,sp,8
81144d44:	f800283a 	ret

81144d48 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81144d48:	deffff04 	addi	sp,sp,-4
81144d4c:	de00012e 	bgeu	sp,et,81144d54 <OSInitHookBegin+0xc>
81144d50:	003b68fa 	trap	3
81144d54:	df000015 	stw	fp,0(sp)
81144d58:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81144d5c:	d020bb0d 	sth	zero,-32020(gp)
#endif
}
81144d60:	0001883a 	nop
81144d64:	e037883a 	mov	sp,fp
81144d68:	df000017 	ldw	fp,0(sp)
81144d6c:	dec00104 	addi	sp,sp,4
81144d70:	f800283a 	ret

81144d74 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81144d74:	deffff04 	addi	sp,sp,-4
81144d78:	de00012e 	bgeu	sp,et,81144d80 <OSInitHookEnd+0xc>
81144d7c:	003b68fa 	trap	3
81144d80:	df000015 	stw	fp,0(sp)
81144d84:	d839883a 	mov	fp,sp
}
81144d88:	0001883a 	nop
81144d8c:	e037883a 	mov	sp,fp
81144d90:	df000017 	ldw	fp,0(sp)
81144d94:	dec00104 	addi	sp,sp,4
81144d98:	f800283a 	ret

81144d9c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
81144d9c:	deffff04 	addi	sp,sp,-4
81144da0:	de00012e 	bgeu	sp,et,81144da8 <OSTaskIdleHook+0xc>
81144da4:	003b68fa 	trap	3
81144da8:	df000015 	stw	fp,0(sp)
81144dac:	d839883a 	mov	fp,sp
}
81144db0:	0001883a 	nop
81144db4:	e037883a 	mov	sp,fp
81144db8:	df000017 	ldw	fp,0(sp)
81144dbc:	dec00104 	addi	sp,sp,4
81144dc0:	f800283a 	ret

81144dc4 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81144dc4:	defffe04 	addi	sp,sp,-8
81144dc8:	de00012e 	bgeu	sp,et,81144dd0 <OSTCBInitHook+0xc>
81144dcc:	003b68fa 	trap	3
81144dd0:	df000115 	stw	fp,4(sp)
81144dd4:	df000104 	addi	fp,sp,4
81144dd8:	e13fff15 	stw	r4,-4(fp)
}
81144ddc:	0001883a 	nop
81144de0:	e037883a 	mov	sp,fp
81144de4:	df000017 	ldw	fp,0(sp)
81144de8:	dec00104 	addi	sp,sp,4
81144dec:	f800283a 	ret

81144df0 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81144df0:	defffe04 	addi	sp,sp,-8
81144df4:	de00012e 	bgeu	sp,et,81144dfc <alt_exception_cause_generated_bad_addr+0xc>
81144df8:	003b68fa 	trap	3
81144dfc:	df000115 	stw	fp,4(sp)
81144e00:	df000104 	addi	fp,sp,4
81144e04:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81144e08:	e0bfff17 	ldw	r2,-4(fp)
81144e0c:	10bffe84 	addi	r2,r2,-6
81144e10:	10c00428 	cmpgeui	r3,r2,16
81144e14:	18001a1e 	bne	r3,zero,81144e80 <alt_exception_cause_generated_bad_addr+0x90>
81144e18:	100690ba 	slli	r3,r2,2
81144e1c:	00a04534 	movhi	r2,33044
81144e20:	10938c04 	addi	r2,r2,20016
81144e24:	1885883a 	add	r2,r3,r2
81144e28:	10800017 	ldw	r2,0(r2)
81144e2c:	1000683a 	jmp	r2
81144e30:	81144e70 	cmpltui	r4,r16,20793
81144e34:	81144e70 	cmpltui	r4,r16,20793
81144e38:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e3c:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e40:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e44:	81144e70 	cmpltui	r4,r16,20793
81144e48:	81144e78 	rdprs	r4,r16,20793
81144e4c:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e50:	81144e70 	cmpltui	r4,r16,20793
81144e54:	81144e70 	cmpltui	r4,r16,20793
81144e58:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e5c:	81144e70 	cmpltui	r4,r16,20793
81144e60:	81144e78 	rdprs	r4,r16,20793
81144e64:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e68:	81144e80 	call	881144e8 <__reset+0x20f44e8>
81144e6c:	81144e70 	cmpltui	r4,r16,20793
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
81144e70:	00800044 	movi	r2,1
81144e74:	00000306 	br	81144e84 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
81144e78:	0005883a 	mov	r2,zero
81144e7c:	00000106 	br	81144e84 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
81144e80:	0005883a 	mov	r2,zero
  }
}
81144e84:	e037883a 	mov	sp,fp
81144e88:	df000017 	ldw	fp,0(sp)
81144e8c:	dec00104 	addi	sp,sp,4
81144e90:	f800283a 	ret

81144e94 <exit>:
81144e94:	defffe04 	addi	sp,sp,-8
81144e98:	000b883a 	mov	r5,zero
81144e9c:	de00012e 	bgeu	sp,et,81144ea4 <exit+0x10>
81144ea0:	003b68fa 	trap	3
81144ea4:	dc000015 	stw	r16,0(sp)
81144ea8:	dfc00115 	stw	ra,4(sp)
81144eac:	2021883a 	mov	r16,r4
81144eb0:	114503c0 	call	8114503c <__call_exitprocs>
81144eb4:	00a04574 	movhi	r2,33045
81144eb8:	10b08104 	addi	r2,r2,-15868
81144ebc:	11000017 	ldw	r4,0(r2)
81144ec0:	20800f17 	ldw	r2,60(r4)
81144ec4:	10000126 	beq	r2,zero,81144ecc <exit+0x38>
81144ec8:	103ee83a 	callr	r2
81144ecc:	8009883a 	mov	r4,r16
81144ed0:	11451c40 	call	811451c4 <_exit>

81144ed4 <memcmp>:
81144ed4:	01c000c4 	movi	r7,3
81144ed8:	3980192e 	bgeu	r7,r6,81144f40 <memcmp+0x6c>
81144edc:	2144b03a 	or	r2,r4,r5
81144ee0:	11c4703a 	and	r2,r2,r7
81144ee4:	10000f26 	beq	r2,zero,81144f24 <memcmp+0x50>
81144ee8:	20800003 	ldbu	r2,0(r4)
81144eec:	28c00003 	ldbu	r3,0(r5)
81144ef0:	10c0151e 	bne	r2,r3,81144f48 <memcmp+0x74>
81144ef4:	31bfff84 	addi	r6,r6,-2
81144ef8:	01ffffc4 	movi	r7,-1
81144efc:	00000406 	br	81144f10 <memcmp+0x3c>
81144f00:	20800003 	ldbu	r2,0(r4)
81144f04:	28c00003 	ldbu	r3,0(r5)
81144f08:	31bfffc4 	addi	r6,r6,-1
81144f0c:	10c00e1e 	bne	r2,r3,81144f48 <memcmp+0x74>
81144f10:	21000044 	addi	r4,r4,1
81144f14:	29400044 	addi	r5,r5,1
81144f18:	31fff91e 	bne	r6,r7,81144f00 <__reset+0xfb124f00>
81144f1c:	0005883a 	mov	r2,zero
81144f20:	f800283a 	ret
81144f24:	20c00017 	ldw	r3,0(r4)
81144f28:	28800017 	ldw	r2,0(r5)
81144f2c:	18bfee1e 	bne	r3,r2,81144ee8 <__reset+0xfb124ee8>
81144f30:	31bfff04 	addi	r6,r6,-4
81144f34:	21000104 	addi	r4,r4,4
81144f38:	29400104 	addi	r5,r5,4
81144f3c:	39bff936 	bltu	r7,r6,81144f24 <__reset+0xfb124f24>
81144f40:	303fe91e 	bne	r6,zero,81144ee8 <__reset+0xfb124ee8>
81144f44:	003ff506 	br	81144f1c <__reset+0xfb124f1c>
81144f48:	10c5c83a 	sub	r2,r2,r3
81144f4c:	f800283a 	ret

81144f50 <strncpy>:
81144f50:	2906b03a 	or	r3,r5,r4
81144f54:	18c000cc 	andi	r3,r3,3
81144f58:	2005883a 	mov	r2,r4
81144f5c:	18002c1e 	bne	r3,zero,81145010 <strncpy+0xc0>
81144f60:	010000c4 	movi	r4,3
81144f64:	21802a2e 	bgeu	r4,r6,81145010 <strncpy+0xc0>
81144f68:	033fbff4 	movhi	r12,65279
81144f6c:	02e02074 	movhi	r11,32897
81144f70:	633fbfc4 	addi	r12,r12,-257
81144f74:	5ae02004 	addi	r11,r11,-32640
81144f78:	100f883a 	mov	r7,r2
81144f7c:	2a000017 	ldw	r8,0(r5)
81144f80:	3815883a 	mov	r10,r7
81144f84:	4313883a 	add	r9,r8,r12
81144f88:	0206303a 	nor	r3,zero,r8
81144f8c:	48c6703a 	and	r3,r9,r3
81144f90:	1ac6703a 	and	r3,r3,r11
81144f94:	1800261e 	bne	r3,zero,81145030 <strncpy+0xe0>
81144f98:	39c00104 	addi	r7,r7,4
81144f9c:	52000015 	stw	r8,0(r10)
81144fa0:	31bfff04 	addi	r6,r6,-4
81144fa4:	3811883a 	mov	r8,r7
81144fa8:	29400104 	addi	r5,r5,4
81144fac:	21bff336 	bltu	r4,r6,81144f7c <__reset+0xfb124f7c>
81144fb0:	30001e26 	beq	r6,zero,8114502c <strncpy+0xdc>
81144fb4:	29c00003 	ldbu	r7,0(r5)
81144fb8:	31bfffc4 	addi	r6,r6,-1
81144fbc:	40c00044 	addi	r3,r8,1
81144fc0:	41c00005 	stb	r7,0(r8)
81144fc4:	39c03fcc 	andi	r7,r7,255
81144fc8:	39c0201c 	xori	r7,r7,128
81144fcc:	39ffe004 	addi	r7,r7,-128
81144fd0:	29400044 	addi	r5,r5,1
81144fd4:	38001026 	beq	r7,zero,81145018 <strncpy+0xc8>
81144fd8:	1811883a 	mov	r8,r3
81144fdc:	00000906 	br	81145004 <strncpy+0xb4>
81144fe0:	29c00003 	ldbu	r7,0(r5)
81144fe4:	31bfffc4 	addi	r6,r6,-1
81144fe8:	29400044 	addi	r5,r5,1
81144fec:	41c00005 	stb	r7,0(r8)
81144ff0:	39c03fcc 	andi	r7,r7,255
81144ff4:	39c0201c 	xori	r7,r7,128
81144ff8:	39ffe004 	addi	r7,r7,-128
81144ffc:	1811883a 	mov	r8,r3
81145000:	38000526 	beq	r7,zero,81145018 <strncpy+0xc8>
81145004:	18c00044 	addi	r3,r3,1
81145008:	303ff51e 	bne	r6,zero,81144fe0 <__reset+0xfb124fe0>
8114500c:	f800283a 	ret
81145010:	1011883a 	mov	r8,r2
81145014:	003fe606 	br	81144fb0 <__reset+0xfb124fb0>
81145018:	30000726 	beq	r6,zero,81145038 <strncpy+0xe8>
8114501c:	198d883a 	add	r6,r3,r6
81145020:	18000005 	stb	zero,0(r3)
81145024:	18c00044 	addi	r3,r3,1
81145028:	19bffd1e 	bne	r3,r6,81145020 <__reset+0xfb125020>
8114502c:	f800283a 	ret
81145030:	3811883a 	mov	r8,r7
81145034:	003fdf06 	br	81144fb4 <__reset+0xfb124fb4>
81145038:	f800283a 	ret

8114503c <__call_exitprocs>:
8114503c:	defff504 	addi	sp,sp,-44
81145040:	de00012e 	bgeu	sp,et,81145048 <__call_exitprocs+0xc>
81145044:	003b68fa 	trap	3
81145048:	df000915 	stw	fp,36(sp)
8114504c:	dd400615 	stw	r21,24(sp)
81145050:	dc800315 	stw	r18,12(sp)
81145054:	dfc00a15 	stw	ra,40(sp)
81145058:	ddc00815 	stw	r23,32(sp)
8114505c:	dd800715 	stw	r22,28(sp)
81145060:	dd000515 	stw	r20,20(sp)
81145064:	dcc00415 	stw	r19,16(sp)
81145068:	dc400215 	stw	r17,8(sp)
8114506c:	dc000115 	stw	r16,4(sp)
81145070:	d9000015 	stw	r4,0(sp)
81145074:	2839883a 	mov	fp,r5
81145078:	04800044 	movi	r18,1
8114507c:	057fffc4 	movi	r21,-1
81145080:	00a04574 	movhi	r2,33045
81145084:	10b08104 	addi	r2,r2,-15868
81145088:	12000017 	ldw	r8,0(r2)
8114508c:	45005217 	ldw	r20,328(r8)
81145090:	44c05204 	addi	r19,r8,328
81145094:	a0001c26 	beq	r20,zero,81145108 <__call_exitprocs+0xcc>
81145098:	a0800117 	ldw	r2,4(r20)
8114509c:	15ffffc4 	addi	r23,r2,-1
811450a0:	b8000d16 	blt	r23,zero,811450d8 <__call_exitprocs+0x9c>
811450a4:	14000044 	addi	r16,r2,1
811450a8:	8421883a 	add	r16,r16,r16
811450ac:	8421883a 	add	r16,r16,r16
811450b0:	84402004 	addi	r17,r16,128
811450b4:	a463883a 	add	r17,r20,r17
811450b8:	a421883a 	add	r16,r20,r16
811450bc:	e0001e26 	beq	fp,zero,81145138 <__call_exitprocs+0xfc>
811450c0:	80804017 	ldw	r2,256(r16)
811450c4:	e0801c26 	beq	fp,r2,81145138 <__call_exitprocs+0xfc>
811450c8:	bdffffc4 	addi	r23,r23,-1
811450cc:	843fff04 	addi	r16,r16,-4
811450d0:	8c7fff04 	addi	r17,r17,-4
811450d4:	bd7ff91e 	bne	r23,r21,811450bc <__reset+0xfb1250bc>
811450d8:	00800034 	movhi	r2,0
811450dc:	10800004 	addi	r2,r2,0
811450e0:	10000926 	beq	r2,zero,81145108 <__call_exitprocs+0xcc>
811450e4:	a0800117 	ldw	r2,4(r20)
811450e8:	1000301e 	bne	r2,zero,811451ac <__call_exitprocs+0x170>
811450ec:	a0800017 	ldw	r2,0(r20)
811450f0:	10003226 	beq	r2,zero,811451bc <__call_exitprocs+0x180>
811450f4:	a009883a 	mov	r4,r20
811450f8:	98800015 	stw	r2,0(r19)
811450fc:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
81145100:	9d000017 	ldw	r20,0(r19)
81145104:	a03fe41e 	bne	r20,zero,81145098 <__reset+0xfb125098>
81145108:	dfc00a17 	ldw	ra,40(sp)
8114510c:	df000917 	ldw	fp,36(sp)
81145110:	ddc00817 	ldw	r23,32(sp)
81145114:	dd800717 	ldw	r22,28(sp)
81145118:	dd400617 	ldw	r21,24(sp)
8114511c:	dd000517 	ldw	r20,20(sp)
81145120:	dcc00417 	ldw	r19,16(sp)
81145124:	dc800317 	ldw	r18,12(sp)
81145128:	dc400217 	ldw	r17,8(sp)
8114512c:	dc000117 	ldw	r16,4(sp)
81145130:	dec00b04 	addi	sp,sp,44
81145134:	f800283a 	ret
81145138:	a0800117 	ldw	r2,4(r20)
8114513c:	80c00017 	ldw	r3,0(r16)
81145140:	10bfffc4 	addi	r2,r2,-1
81145144:	15c01426 	beq	r2,r23,81145198 <__call_exitprocs+0x15c>
81145148:	80000015 	stw	zero,0(r16)
8114514c:	183fde26 	beq	r3,zero,811450c8 <__reset+0xfb1250c8>
81145150:	95c8983a 	sll	r4,r18,r23
81145154:	a0806217 	ldw	r2,392(r20)
81145158:	a5800117 	ldw	r22,4(r20)
8114515c:	2084703a 	and	r2,r4,r2
81145160:	10000b26 	beq	r2,zero,81145190 <__call_exitprocs+0x154>
81145164:	a0806317 	ldw	r2,396(r20)
81145168:	2088703a 	and	r4,r4,r2
8114516c:	20000c1e 	bne	r4,zero,811451a0 <__call_exitprocs+0x164>
81145170:	89400017 	ldw	r5,0(r17)
81145174:	d9000017 	ldw	r4,0(sp)
81145178:	183ee83a 	callr	r3
8114517c:	a0800117 	ldw	r2,4(r20)
81145180:	15bfbf1e 	bne	r2,r22,81145080 <__reset+0xfb125080>
81145184:	98800017 	ldw	r2,0(r19)
81145188:	153fcf26 	beq	r2,r20,811450c8 <__reset+0xfb1250c8>
8114518c:	003fbc06 	br	81145080 <__reset+0xfb125080>
81145190:	183ee83a 	callr	r3
81145194:	003ff906 	br	8114517c <__reset+0xfb12517c>
81145198:	a5c00115 	stw	r23,4(r20)
8114519c:	003feb06 	br	8114514c <__reset+0xfb12514c>
811451a0:	89000017 	ldw	r4,0(r17)
811451a4:	183ee83a 	callr	r3
811451a8:	003ff406 	br	8114517c <__reset+0xfb12517c>
811451ac:	a0800017 	ldw	r2,0(r20)
811451b0:	a027883a 	mov	r19,r20
811451b4:	1029883a 	mov	r20,r2
811451b8:	003fb606 	br	81145094 <__reset+0xfb125094>
811451bc:	0005883a 	mov	r2,zero
811451c0:	003ffb06 	br	811451b0 <__reset+0xfb1251b0>

811451c4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
811451c4:	defffc04 	addi	sp,sp,-16
811451c8:	de00012e 	bgeu	sp,et,811451d0 <_exit+0xc>
811451cc:	003b68fa 	trap	3
811451d0:	dfc00315 	stw	ra,12(sp)
811451d4:	df000215 	stw	fp,8(sp)
811451d8:	df000204 	addi	fp,sp,8
811451dc:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
811451e0:	d0a01217 	ldw	r2,-32696(gp)
811451e4:	10800058 	cmpnei	r2,r2,1
811451e8:	1000031e 	bne	r2,zero,811451f8 <_exit+0x34>
811451ec:	01204574 	movhi	r4,33045
811451f0:	21290404 	addi	r4,r4,-23536
811451f4:	1130e880 	call	81130e88 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
811451f8:	d0a01217 	ldw	r2,-32696(gp)
811451fc:	10800058 	cmpnei	r2,r2,1
81145200:	1000041e 	bne	r2,zero,81145214 <_exit+0x50>
81145204:	e17fff17 	ldw	r5,-4(fp)
81145208:	01204574 	movhi	r4,33045
8114520c:	21290f04 	addi	r4,r4,-23492
81145210:	1130e880 	call	81130e88 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
81145214:	d0a01217 	ldw	r2,-32696(gp)
81145218:	10800058 	cmpnei	r2,r2,1
8114521c:	1000031e 	bne	r2,zero,8114522c <_exit+0x68>
81145220:	01204574 	movhi	r4,33045
81145224:	21291a04 	addi	r4,r4,-23448
81145228:	1130e880 	call	81130e88 <alt_log_printf_proc>
  ALT_OS_STOP();
8114522c:	d0209605 	stb	zero,-32168(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
81145230:	d0a01217 	ldw	r2,-32696(gp)
81145234:	10800058 	cmpnei	r2,r2,1
81145238:	1000031e 	bne	r2,zero,81145248 <_exit+0x84>
8114523c:	01204574 	movhi	r4,33045
81145240:	21292404 	addi	r4,r4,-23408
81145244:	1130e880 	call	81130e88 <alt_log_printf_proc>
81145248:	e0bfff17 	ldw	r2,-4(fp)
8114524c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
81145250:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
81145254:	10000226 	beq	r2,zero,81145260 <_exit+0x9c>
    ALT_SIM_FAIL();
81145258:	002af070 	cmpltui	zero,zero,43969
8114525c:	00000106 	br	81145264 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
81145260:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
81145264:	d0a01217 	ldw	r2,-32696(gp)
81145268:	10800058 	cmpnei	r2,r2,1
8114526c:	1000031e 	bne	r2,zero,8114527c <_exit+0xb8>
81145270:	01204574 	movhi	r4,33045
81145274:	21292e04 	addi	r4,r4,-23368
81145278:	1130e880 	call	81130e88 <alt_log_printf_proc>
  while (1);
8114527c:	003fff06 	br	8114527c <__reset+0xfb12527c>
